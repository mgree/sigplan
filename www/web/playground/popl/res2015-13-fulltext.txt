well complete popl consist easy to safe efficient gradual typing for typescript university of college park fournet microsoft research oracle university of california san diego abstract current proposals for adding gradual typing to javascript such as closure typescript and dart soundness to deal with issues of scale code reuse and popular programming patterns we show how to address these issues in practice while soundness we design and implement a new gradual type system for as a safe compilation mode for typescript our compiler achieves soundness by enforcing static checks and embedding residual runtime checks in compiled code it plain javascript that runs on virtual machines our main theorem is a simulation that ensures that the checks introduced by safe typescript catch any dynamic type error and do not alter the semantics of typesafe typescript code safe typescript is carefully designed to minimize the performance overhead of runtime checks at its core we rely on two new ideas differential subtyping a new form of coercive subtyping that computes the minimum amount of runtime type information that must be added to each object and an erasure modality which we use to safely and erase type information this allows us to scale our design to typescript including arrays maps classes inheritance overloading and generic types we validate the and performance of safe typescript by typechecking and compiling around lines of existing typescript source code although runtime checks can be expensive the overhead is small for code bases that already have type annotations for instance we the safe typescript compiler lines including the base typescript compiler we measure a runtime overhead for type safety and also programming errors as type safety violations we conclude that at least during development and testing programs to safe gradual typing adds significant value to source type annotations at a cost introduction originally intended for javascript is now widely used to develop large applications using javascript in complex is however not without difficulties the lack of robust this work was done at microsoft research permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page for components of this work owned by others than the authors must be abstracting with credit is permitted to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission andor a fee request permissions from popl january ­ copyright is held by the publication to acm acm language abstractions such as static types classes and interfaces can programmer and tool support unfortunately abstraction into javascript is difficult as one must support language features and programming patterns in existing code and libraries without either most programs or requiring extensive annotations perhaps using a type system gradual type systems set out to fix this problem in a manner and have led to popular proposals for javascript notably closure typescript and dart although the latter is strictly speaking not javascript but a variant with some features of javascript removed these proposals bring substantial benefits to the working programmer usually taken for granted in typed languages such as a convenient notation for code api exploration code completion and of basic type errors interestingly to be usable at scale all these proposals are unsound programs may be easier to write and maintain but their type annotations do not prevent runtime type errors instead of giving up on soundness at the we that a sound gradual type system for javascript is practically feasible there are some significant challenges to overcome for the language includes inherently features such as eval and stack some of bad parts however recent work is et al proposed ts a sound type system for javascript to untyped code it from a typed core language although the typed fragment of ts is too limited for javascript developments its of with the bad parts using typebased memory isolation is promising in this work we the problem of developing a sound yet practical gradual type system for a large fragment of javascript its most features to untrusted code by relying implicitly on memory isolation concretely we take typescript as our starting point in brief typescript is javascript with optional type annotations every valid javascript program is a valid typescript program typescript adds an objectoriented gradual type system while its compiler all traces of types and javascript that can run on virtual machines the code is syntactically close to the source except for type erasure hence typescript and javascript with the same performance type system is unsound et al some of its unsound features including subtyping for functions and arrays as well as in class and interface extension the lack of soundness limits the benefits of writing type annotations in typescript making abstractions hard to enforce and leading to programming patterns even for programmers who clear of the bad parts consider for instance the following from et al a mobile programming platform written in typescript private if typeof c string return figure architecture of safe typescript despite annotating the formal parameter c as a string the typescript programmer must still check that the argument received is indeed a string using javascript reflection and deal with errors safe typescript we present a new typechecker and code generator for a subset of typescript that guarantees type safety through a combination of static and dynamic checks its implementation is fully integrated as a branch of the typescript compiler programmers can opt in to safe typescript simply by providing a flag to the compiler similar in spirit to strict mode which lets the programmer some unsafe features as with typescript the code generated by safe typescript is standard javascript and runs on virtual machines figure illustrates safe typescript at work a programmer authors a typescript program and it to the typescript compiler setting the safe flag to enable our system the compiler initially processes using standard typescript passes the file is parsed and a type inference algorithm computes potentially unsound types for all subterms for the toplevel function f in the figure typescript infers the type using by default the dynamic type any for its formal parameter it may infer more precise types in other cases the subterm xf is inferred to have type any as well in typescript values can be passed to a context a more precise type so typescript accepts that xf be returned at type number since typescript all types xf need not be a number at runtime which may cause callers of f to fail later despite fs annotation in contrast when using safe typescript a second phase of typechecking is applied to the program to soundly the types inferred by earlier phases this second phase may produce various static errors and warnings once all static errors have been fixed safe typescript rewrites the program to objects with runtime type information rtti and insert runtime checks based on this rtti in the example the rewriting involves xf as f a call into a runtime library rt used by all safe typescript programs although the static type of x is any the rtti introduced by our compiler allows the runtime library to determine whether it is safe to project xf and further using to ensure that its content is indeed a number finally the dynamically typesafe javascript code is by a code generator that out type annotations and constructs like classes but otherwise leaves the program unchanged underlying safe typescript are two novel technical ideas partial erasure many prior gradual type systems require that a single dynamic type called dynamic dyn any etc be a universal supertype and further that any be related to all other types by subtyping and coercion we relax this requirement in safe typescript any characterizes only those values that are tagged with rtti separately we have a modality for erased types whose val need not be tagged with rtti erased types are not subtypes of any nor can they be to it yielding four important capabilities first information hiding we show how to use erased types to encode private fields in an object and prove a confidentiality theorem theorem second performance through careful erasure the user can minimize the overhead of rtti operations third modularity allow us to ensure that objects owned by external modules do not have rtti and fourth evolution allowing us to scale safe typescript up to a language with a wide range of typing features differential subtyping in addition we rely on a form of coercive subtyping that allows us to partial rtti on objects and is for good runtime performance main contributions we present the first sound gradual type system with a formal treatment of objects with mutable fields and immutable methods addition and deletion of computed properties from objects nominal object types interfaces structural object types with and partial type erasure formal core § we develop a core calculus for safe typescript our formalization includes the type system compiler and runtime for a subset of safe typescript and also provides a dynamic semantics suitable for a core of both typescript and safe typescript its metatheory establishes that welltyped programs with embedded runtime checks simulate programs running under semantics without runtime checks except for the possibility of a failed runtime check that stops execution early theorem this enables programmers to switch between safe and unsafe mode while testing and debugging implementation for typescript § relying on differential subtyping and erasure we extend to the full safe typescript language adding support for several forms of inheritance for classes and interfaces structural interfaces with recursion support for primitive objects generic classes interfaces and functions arrays and dictionaries with types objects with optional fields functions and a simple module system in all cases we make use of a combination of static checks and runtime checks to ensure dynamic type safety and performance evaluation § we report on our experience using safe typescript to typecheck and safely compile about lines of source code including the safe typescript compiler itself in doing so we found and several errors that were as type safety violations in the compiler and in a widely used benchmark we evaluate safe tagging strategy against two alternatives and find that differential subtyping and of course erasure offers significant performance benefits we conclude that large typescript projects can easily be to safe typescript thereby increasing the benefits of existing type annotations that safe typescript can reveal programming bugs both statically and dynamically that statically typed code overhead and that selective rtti can ensure type safety with overhead we provide the full formal development and proofs of and more experimental details in an technical report et al source code of our compiler and all our benchmarks are available at we also provide an of safe typescript in action at an overview of safe typescript being sound safe typescript types with many of the properties that java or c programmers might expect but not find in typescript on the other hand safe typescript is also intended to be compatible with javascript programming as a language user understanding what type safety means is critical as a language designer the right balance is we first summarize some important consequences of type safety in safe typescript an object implements the methods in its type objects in javascript are used in two complementary first as mutable dictionaries they use to represent keys second in a more objectoriented style they expose methods to operate on their state safe typescript supports both in less structured code objects may be used the type system ensures that fields have the expected type when defined in more structured code objects may expose their functionality using methods the type system guarantees that an object always implement calls to the methods declared in its type ie methods are always defined and immutable the two can be freely mixed ie a dictionary may have both methods and fields with functional types values can be undefined whereas languages like c and java have one included in all reference types javascript has two null and undefined safe typescript this aspect of design in effect removing null from welltyped programs while only undefined only null is possible too but less for existing programs that may use null our implementation provides an option to permit null to also be a member of every reference type note that undefined is also included in all native types such as boolean and number this supports eg the use in javascript of undefined for false type safety as a foundation for security javascript provides a native notion of dynamic type safety although relatively weak it is the basis of many dynamic security enforcement techniques for instance the to object references is the basis of security techniques et al by compiling to javascript safe typescript like typescript itself still these properties moreover safe typescript provides higher level abstractions for encapsulation enforced with a combination of static and dynamic checks for example typescript provides syntax for classes with access qualifiers to mark certain fields as private but does not enforce them even in welltyped code in § we show how like private fields can be easily built and upon in safe typescript looking forward safe type safety should provide a useful basis for more advanced program analyses static safety and canonical forms for welltyped program fragments that do not make use of the any type safe typescript ensures that no runtime checks are inserted in the code although some rtti may still be added for code that uses only erased types neither checks nor rtti are added ensuring that code runs at full speed when adding rtti we are careful not to break underlying semantics eg we preserve object identity additionally programmers can rely on a property for example if a value v is defined and has static type then the programmer can conclude that contains a number if defined and that can be safely updated with a number in contrast approaches to gradual typing based on higherorder casts do not have this property for example in the system of et al a value r with static type ref number may in fact be another value wrapped with a runtime to update r with a number may cause a dynamic type error in the remainder of this section we illustrate the main features of safe typescript using several small examples nominal classes and structural interfaces javascript widely relies on encodings of objectoriented idioms into objects to this end typescript provides syntactic support for classes with single inheritance and multiple interfaces constructs in java or c and its code generator class declarations to using wellknown techniques safe typescript classes and interfaces with a few important differences illustrated on the code below interface point class implements point public public dx dy function return x x the code defines a point to be a pair of numbers representing its and a class with two public fields x and y initialized to the arguments of the constructor and a public move method in typescript all types are interpreted structurally point and are aliases for tp and to void respectively this structural treatment is uniform but it has some first a purely structural view of object types is incompatible with semantics one might expect that every welltyped function call returns true however in typescript this need not be the case structurally taking v to be the object literal x y is welltyped but v is not an instance of which is decided by vs prototype and the function returns false to fix this safe typescript treats but let them be viewed structurally that is is a subtype of both tp and to but neither tp nor to are subtypes of interfaces in safe typescript remain by default structural ie point is equivalent to tp in § we show how the programmer can this default through the careful use of nominal types both with classes and interfaces programmers can build robust abstractions and as we will see in later sections minimize the overhead of rtti and runtime checks a new style of efficient gradual typing following typescript safe typescript includes a dynamic type any which is a supertype of every type t when a value of type t is passed to a context an any or vice versa safe typescript runtime checks on rtti to ensure that all the are enforced the particular style of gradual typing developed for safe typescript is of prior proposals by et al and siek and but makes important improvements over both whereas prior approaches require all values to be instrumented with rtti leading to a significant performance overhead as discussed in § in safe typescript rtti is added to objects only as needed next we illustrate the way this works in a few common cases the source program shown to the left of figure defines two types point and and three functions copy f and g the function g passes its argument to f at the type any clearly there is a latent type error in this code in line the function is expected to return a number but is no longer a point since the assignment at line the and changes its type safe typescript cannot detect this error statically the formal parameter q has type any and any property access on objects is however safe typescript does detect this error at runtime the result of compilation is the instrumented code shown to the right of figure interface point interface function function var c x y function number return function q function fq var c center function return figure sample source typescript program left and javascript by the safe typescript compiler right as we aim for statically typed code to no performance it must remain as such the copy function and the statically typed field accesses are compiled unchanged the allocated object literal xy is inferred to have type point and is also unchanged in contrast to et al and siek and who all objects with rtti we insert checks only at the boundaries between static and dynamically typed code and within dynamically typed code as detailed in the steps below userdefined types with the runtime the interface definitions in the source program lines ­ are translated to calls to rt the safe typescript runtime library linked with every compiled program each call to registers the runtime representation of a userdefined type tagging objects with rtti to lock invariants safe typescript uses rtti to express invariants that must be enforced at runtime in our example g passes to f which uses it at an type any to express that must be treated as a even in dynamically typed code before calling f in the generated code line is instrumented using the function whose implementation is shown partially below function t if t return c the rtti of an object is maintained in an additional field here called rtti of that object an objects rtti may at runtime safe typescript guarantees that the rtti decreases with respect to the subtyping relation never less precise as the program executes at each call to safe typescript ensures that c has type t while after the call if c is defined the old rtti of c is updated using the function combine to also recall that c has type t in our example importantly for performance does not into the structure of c tagging objects single tag at the outermost object suffices nested objects need not be tagged with rtti a difference from prior work propagating invariants in dynamically typed code going back to our source program line the dynamically typed read is rewritten to whose definition is shown partially below function if name return f reading a field f out of an object requires tagging the value stored in of with the invariants expected of that field by the enclosing object in our example we tag the object stored in with rtti indicating that it must remain a point the benefit we gain by not into the structure of an object in is offset in part by the cost of propagating rtti as the components of an object are accessed in dynamically typed we find that it is a good tradeoff see § and § establishing invariants by and updating rtti when passing c to copy line we need to check that c is a point as expected by copy we do this by calling another runtime function that unlike into the structure of c checks that c is structurally a point and if it succeeds tags c with rtti recording that it is a point we outline below the partial implementation of with a simplified signature in our example where f is called only from g the check succeeds function t if v undefined return v if if t typeof v return v else a t else if for var f in return t finally we come to the assignment to it is instrumented using the function at line in the generated code whose partial definition is shown below function f v if name return the call f v ensures that the value v being written into the f field of object o is consistent with the typing invariants expected of that invariants are recorded in os rtti specifically in f in our example this call fails since cannot be typed as a point differential subtyping tagging objects can be costly especially with no native support from javascript virtual machines prior work on gradual typing suggests tagging every object as soon as it is allocated cf siek and and et al following their approach our initial implementation of safe typescript that every object carries a tag we defer a detailed quantitative comparison until § but in summary this variant can be times slower than the technique we describe below underlying our efficient tagging scheme is a new form of coercive subtyping called differential subtyping the main are as follows tagging is unnecessary for an object as long as it is used in with the static type discipline and even if an object is used dynamically its rtti need not record a full description of the objects typing invariants only those parts used outside of the static type discipline require tagging with these consider the program in figure which illustrates width subtyping the triple of numbers p in a is a subtype of the pair a point expected by so the program is accepted and compiled to the code at the right of the figure the only instrumentation occurs at the use of subtyping on the argument to using we tag p with rtti that records just the rtti need function function pz y z function qx function pz y z figure in a source typescript program left and after compilation to javascript right not mention x or y since the static type of parameter guarantees that it will respect the type invariants of those fields of course to tag the object with would open the to dynamic type safety violations as in the previous section differential to decide what needs to be tagged on each use of subtyping we define a subtyping relation t t which states that the type t is more precise than t and that is to a first approximation the difference in precision between t and t we let range over types or when there is no loss in precision we of t as a subtype of t for on records the relation includes the splitting rule x t y t x t y t since the loss between the two record types is precisely the omitted fields y t on the other hand for a record type t we have t any t since in this case the loss is total at each use of subtyping the safe typescript compiler computes and tags objects with rtti that record just rather than the full type t taking advantage of primitive rtti our definition of differential subtyping is specifically to the rtti available in safe typescript and more generally in other platforms the relation would likely be different for primitive types such as numbers for instance the javascript runtime already provides primitive rtti typeof n evaluates to number for any number n so there is no need for additional tagging thus although number is more precise than any we let number any similarly for objects javascript provides an operator to test whether an object is an instance of a class cf § also a form of primitive rtti hence for a object type c we have c any meaning that safe typescript does not tag when subtyping is used on a object type as such our subtyping relation computes the loss between two types that may not already be captured by rtti hence subtyping is on types with primitive rtti controlling differences to preserve object identity besides performance differential subtyping helps us ensure that our instrumentation does not alter the semantics of typescript consider subtyping for function types one might expect a value to be usable at type via a standard lifting of the relation to function types given that differential subtyping is coercive tags must be added the only way to lift the tagging coercions to functions is by inserting a wrapper for example we might coerce f to the function g below which tags the z field of the argument and then tags that field again on the result function gy var t return tt unfortunately for a language like typescript in which object identity is observable functions are a special case of objects coercive wrappers like the one above are function g is not identical to f the function it our solution is to require that higher order subtyping only use subtypes for relating function arguments ie only subtyping is fully structural thus we from the subtyping relation conversely given t xt t and t xt t we have t t t when t t and t t since the difference ensures that no wrappers need to be inserted subtyping on functions is still coercive however in the relation above notice that the difference is computed to be t the type of the lefthand side thus we coerce f t to t using which sets t in the rtti field of the function object f thereby capturing the precise type of f in its rtti a modality for type erasure selective tagging and differential subtyping enable objects with partial rtti going further it is useful to ensure that some objects never carry rtti both for performance and for modularity to this end safe typescript introduces a new modality on types to account for objects erasure consider a program that calls on a large array of the use of in the body of causes every object in the array to get tagged with rtti recording a z number field this is as the usage of each is typesafe without any instrumentation to avoid unnecessary tagging the programmer may write instead function the type is the type of erased points ie objects that have fields x and y but potentially no rtti subtyping towards erased types is ie so along one dimension erased types provide greater flexibility since they enable more subtyping at higherorder however without rtti the runtime system cannot enforce the typing invariants of values so along another dimension erased types are more restrictive since they dynamic programming idioms like field extension reflection or deletion on values with erased types in particular is not a subtype of any these tradeoffs requires some careful from the programmer but it can performance and does not safety information hiding with erased types since values of erased types respect a static type discipline programmers can use erasure to enforce deeper invariants through information hiding javascript provides just a single mechanism for information hiding closures through the use of erased types safe typescript provides another more form of hiding illustrated below consider a monotonic counter object with a private v field hidden from its clients and a public inc method for the counter var ctr v inc return by introducing the newly allocated object ctr at an erased type its client code is checked statically and dynamically to ensure with its published api only inc is accessible not v without the erasure modality clients could the v field using statements like we show an encoding of abstract types using erased types in § theorem erasure modularity and trust typescript programs run in isolation their environment includes provided by primitive javascript arrays and strings the web document object model dom the file system for javascript etc the default library used for typing typescript programs includes about lines of specifications providing types to these § discusses how we fit erased types into typescript without any modifications to its concrete syntax until then we use the · to mark erased types external libraries and even more typescript library specifications are available online all these libraries with safe typescript is not feasible besides sometimes these libraries are not even in javascript nevertheless being able to use these libraries according to their trusted specifications from within safe typescript is crucial in practice the erasure modality can help we mark such external libraries as providing objects with erased type for two purposes since these external objects carry no rtti this ensures that their use within safe typescript is statically checked for with their specification the erased types ensure that their objects are never new fields to objects owned by external libraries is to cause those libraries to break as such the type safety for typical safe typescript programs is guaranteed only modulo the of external libraries to their specifications in scenarios where trust in external code an or when parts of the program need to carefully features of javascript like eval that are outside our typesafe language one might instead to the typebased isolation mechanism of ts et al specifically ts proposes the use of an abstract type un to untyped code and a family of typedirected coercions to safely manipulate this mechanism is complementary to what safe typescript offers in fact as discussed in § safe erased types generalize their un type in particular from theorem we have that the type · is the safe typescript of un safe typescript using erased types over the course of last year as we were developing safe typescript typescript added several advanced features to its type system notably generic types keeping with typescript is a challenge made easier through the use of erased types recall that values of erased types must be with statically since erased types are to the runtime system adding generic class types to safe typescript requires significant changes to the between the safe typescript compiler and its runtime one way to minimize this is to add generic types to safe typescript in two steps first to the static type system only where are well understood and only to the runtime system if needed § explains how we completed the first step by treating all generic types as erased this allows safe typescript programmers to use generic types statically code reuse and reducing the need for potentially expensive subtyping by restricting the interaction between generic types and any the system remains simple and sound so far preventing the use of polymorphic values in dynamically typed code has not been a significant limitation the formal core of safe typescript models a fragment of safe typescript including erased types primitive types structural objects and nominal classes and interfaces in this section we define the syntax type system and dynamic semantics we model compilation as a translation from to itself that inserts dynamic type checks due to space constraints we cover only the subset of without classes and interfaces full details can be found in the technical report et al the following section § the parts of omitted here and informally explains how our implementation extends to all of safe typescript our main results are expressed as a weak meaning that runtime checks do not alter the behavior of welltyped programs except when a dynamic type safety violation is detected and an theorem letting programmers build robust abstractions despite dynamic features type t · t dynamic type t c any m f primitive c void number string boolean method types m · mi m m field types f · f f f expression e v m f ef ee ee ei t e value v x ct method m · s return e m m field f · f e f f statement s e skip s s var x e x e ef e ee e syntax the syntax for is given above we types into those that may be used dynamically and those that may be erased dynamic types t include primitive types c any and structural object types m f where f is a sequence of field names f and their types and m is a sequence of method names m and their method types written i as expected in typescript methods also take an implicit this argument with the type of the enclosing object like javascript expressions from statements expressions include values v literals static and dynamic field projections static and dynamic method calls and type casts the form ranges over the runtime functions with several expression or type arguments used to compiled programs modeled as primitives in as such the rt form is from source programs values include memory locations variables x including the distinguished variable this and literals ranged over by the metavariable ct to reflect their primitive rtti provided by javascript and returned by typeof we may subscript literals with their type writing eg object literals are sequences of explicitly typed method and field definitions in our implementation those types are first inferred by the typescript compiler as shown in figure method definitions are written s return e for simplicity method bodies consist of a statement s and a return expression e methods return undefined field definitions are written f e where is the type inferred by typescript and is not concrete syntax statements include expressions skip sequences typed variable definitions variable assignments and static dynamic field assignments conditional statements and loops are trivial so we them to the full technical report like typescript models functions as objects with a single method named call thus functions in concrete syntax function xi s return e become s return e and function calls become static semantics figure presents a core of the static semantics of the main judgments involve the typing and compilation for expressions e e and for statements s s where the source and target terms are both included in the embedding of compiled to a formal semantics of javascript is beyond the scope of this work the type system of has two fragments a fairly standard static type discipline that applies to most terms and a more permissive discipline that applies to the more dynamic terms such as dynamic field projection figure gives the most interesting rules although typescript provides different notation for methods and fields it makes no semantic distinction between the two in concrete syntax the formal parameters in a method type must be named although arguments are still resolved by position e e m m f f s s void c any m f any m f m f f f mi m mi m ii i m f m f m f m m f f t t x f this m m f f e e x x m f m f f e f s s e e e e f fields s return e s return ef e f e e mi r methods i ei i ei r e i ii i i e e x x e x e e f fields e e ef e ef j ej tj ej ee e t e e t j ej tj ej ee any t e j i ej tj ej any t e ei ti et e tc t e t t t figure typing and compiling a core of where t and · x and from both fragments we discuss them in turn due to space constraints we omit routine rules such as those for typing literals differential subtyping is a relation as a shorthand we write when subtyping is reflexive and is provably transitive via the undefined value all a setting one may choose to omit this rule the rules and enforce any as a supertype for all primitive and object types as well as subtyping on object types as discussed in § rule stands for two rules both t and are subtypes of so long as t is a subtype of t although there is a loss of precision when using this rule uses of terms have to be typed statically so there is no need to add the difference in the conclusion as we will see the use of subtyping when typing expressions and statements is carefully use of subtyping may introduce a loss in precision which gets reflected into the rtti of the compiled term by although not shown in the rules when the call to is optimized away variables are typed and compiled to themselves using objects are typed using by typing their method and field definitions in turn the auxiliary function f computes the type of the object itself for the this reference discussed further in the next fields are typed using the must be a subtype of the field type the loss in precision due to the use of subtyping is reflected into the rtti of e using methods are typed using in the first premise we extend to contain not only the parameter bindings but also bindings for local variables of the method body denoted by this models of local variables in method bodies the rule then types s and the return expression e the use of subtyping for the result is in the compiled code by a call to restricting the use of this the dynamic semantics in a normal method call vm the body of m executes with the implicit parameter this bound to v for a function call g however semantics for the is much more speaking the body of g executes with this bound to a global object as such relying on any properties of this in g is unsafe we the use of this in a function g e by typing it using this · the type of an abstract reference to an object see theorem specifically we define · whereas for all other objects f m f the pointwise erasure of method and to their types field projections method calls local variable assignments and field assignments are statically typed by and respectively these rules are routine apart from their use of at each use of subtyping the dynamic fragment of includes the rules and tc in each case we restrict the types of each subterm involved to dynamic types types must respect the static discipline when compiling the term we generate a runtime check that the dynamic operation in question passing to the check the subterms and some of their static types as rtti in the next subsection we discuss how each check makes use of rtti to ensure dynamic type safety dynamic semantics figure presents selected rules from our smallstep operational semantics of the form c c where each runtime configuration c is a pair of a state c and a program statement s our semantics models the execution of programs both before and after former is intended as a model of the dynamic semantics of a core of typescript while the latter is a model of safe typescript a state c is a h t x l consisting of a heap h mapping locations to mutable objects o and values v a tag heap t mapping some of these locations to rtti t when executing source programs the tag heap is always empty a call stack x where each element consists of a local store l and an evaluation context e and a local store l mapping variables x to locations for the current statement we use the notation ch for the heap component of c c h for c with updated heap h and use similar notations for the other components and also for c our runtime representation of objects includes a prototype field a sequence of method definitions sharing a captured closure environment l and a sequence of field definitions for simplicity we treat return e as a statement although it can only occur at the end of a method body finally we define evaluation contexts e as follows for both statements and expressions a strict lefttoright evaluation order e ef ee ve e et e s var x t e return e context rules figure begins with where is a distinguished literal that arises only from the failure of a runtime check the failure up and terminates the execution we omit the other standard rules for evaluation contexts field projection and update static field projection f involves a prototype traversal using the lookup function whose definition we omit dynamic field reads split into two cases we show only the former when an object reference is used as a key into the fields of as in javascript is to a string by calling when the key is a literal and h maps to an object we return either its corresponding field if any or undefined dynamic field writes also have two cases we show only the latter we expect ch to contain an object and we update its field fc with v we write fc for primitive coercion of a literal c to a field name the calling convention and closures shows a dynamic call of the method c in object in the first premise we use the auxiliary function lookup m this to traverse the prototype chain to find the method m and to implement semantics for the implicit this argument to usually except when m call ie a function call when to a global is safe since the type system ensures that functions do not use this in their bodies next we all the local variables yj from the method body s and allocate slots for them and the function parameters in the heap and parameters are mutable as shown in the next rule and are shared across all closures that capture them so we use one indirection and their contents to the heap in the conclusion of we push one stack frame set the current local store to the captured closure environment extended with the and parameters and proceed to the method body the stack and returns the value v to the suspended callers context rule allocates objects a fresh location in the heap is initialized with an object o whose prototype is set to a distinguished location representing concretely in javascript the methods involves capturing the current local store cl as a closure environment the fields is straightforward two sources of rtti for enforcing dynamic type safety the main of our dynamic semantics is in the remaining six rules which enforce notion of dynamic type safety using rtti rtti in comes in two is persistent rtti associated with objects in the tag heap or available on literals and rtti provided by the compiler among the arguments to the rt functions the most precise view of an objects invariants available to a runtime check is obtained by combining both forms of rtti using the auxiliary partial function combine figure an invariant of our system ensures that it is always possible to combine the persistent and rtti consistently eg it is impossible for the tag heap to claim that an object has a field f number while the rtti claims f any additionally our invariants ensure that the method types in the persistent rtti are never less precise than the method that any loss in precision due to subtyping on methods is recorded in the rtti using reads and writes reading fc from an object reference t similarly writing vt to fc of t in both cases we combine any persistent rtti stored at t defined as t when and · · otherwise with t the rtti of provided by the compiler and then use the partial function to compute the type of fc if the field is present in the rtti we simply use its type tf unless the field name with a known method name the field type to any otherwise is not defined and both and are this case the configuration steps to we omit these routine rules given tf in we project the field and then propagate tf into the persistent rtti of the value that is read before returning it in before updating fc we check that vt is compatible with the expected type tf method and function invocations and these invocations in the goal is to safely invoke method fc on t with parameters if we find the method in s combined rtti we invoke it after checking that the parameters have the expected types and then propagate the result type into the rtti of the result in the goal is to call a field of t the handling is similar except that instead of looking up a method we traverse the prototype chain project the field and that fields rtti for a call signature if we find the signature we call the function just as in in both rules if the method or function is not found the configuration steps to propagating and checking tags finally we have two for the semantics and the semantics of the former is given by t an interpretation function on tag heaps when or v c there is no tag propagation and the function is the identity on structural types we use the combine function to update the tag heap an invariant ensures that persistent rtti ie it never gets less precise whereas never fails the interpretation t t th is a partial function that either evaluates to a new tag heap or returns the interpretation is given by the function the most interesting case involves checking whether can be given the type m f to do this we m f the combined view of s rtti and if m f m fc where fc are the fields shared between f and f we tag with the loss in precision if any we then recursively s fields for each of the fields in f not in f and if that succeeds we finally propagate to s rtti we prove that always terminates even in the presence of cycles in the object graph metatheory our main result is that compilation is a weak which also implies subject reduction for welltyped programs our second theorem is an abstraction property for values of erased types careful programmers with robust encapsulation our results apply to full including classes and nominal interfaces in full runtime states c are s h t x l where the additional s is a signature that contains all class and interface declarations the runtime functions like are parameterized by s as well and use it to implement dynamic type safety for these constructs some runtime checks on classes can be more efficient since they can be implemented eg using c s c c e s c f v c f c v c c h ch ch fc v c c v c h v lookup m fc l i s yj j i fresh h h i vi j undefined h t x l e h t x le l this xi i yj j s h v cx x le c x v c h skip c return v c x l e v fresh h ch proto m cl m vi c m fi vi c h tf t tf any c read t c c c tf t c write t c v t c c t tf t t t any t ct c invoke t c vi ti c ti ti c c t v fc t t any t t t c invoke t c vi ti c ti ti c t t c t v figure selected rules from dynamic semantics c s c s t if f t then t else if f then any else t t if t c or t any f m f m m m m m f f t t m f t t t t m f t t t h t t c t h t t any t h t t t h t t t h t m f t h let m f l t let fc f t f f f fc check m f m fc let t t and fi any ti ti h · tn t t th t t t h t t t h if none of the above figure auxiliary functions used in dynamic semantics compiling configurations we extend the typing and compiling relation of figure to runtime configurations writing c c where is a and is the type of the result of the stack of evaluation contexts the main is in the compilation of statements that include free in particular when compiling c s to c s we relate the statements using a generalization of statement typing of the form s c t s s where is derived from cl and intuitively the heap typing records the static type of a location at the instant it was allocated while c t records the dynamic rtti of a location which according to definition below to translate heap locations we introduce the following rule t s t t this rule captures the essence of differential subtyping in traditional systems with subtyping we would type a location using any supertype of with differential subtyping however any loss in precision due to subtyping must be reflected in the rtti of ie in t in we are trying to relate a source configuration c to a given target configuration c where t c t so we must pick a type t such that the loss in precision in t rel to is already captured in the persistent rtti at t in fact t may be more precise or even to so long as taken together with t there is no loss or gain in precision the premise of makes this intuition precise since combine is a partial function the rule is applicable only when the persistent rtti of is consistent with its static type the following relation how tag heaps in particular the information about a location never grows less precise the auxiliary relation t in the full paper states that is consistent with t for each location in the domain of t ie its static and dynamic types are never in contradiction definition tag heap evolution t to t written t t when t t and for all we have either or t t or t m f and t m f with m m and f f intuitively our main theorem states that if a source configuration c is typed at and compiled to c then every step taken by c is matched by one or more steps by c unless c detects a violation of dynamic type safety theorem forward simulation if we have c c then either both c and c are terminal or for some c and c we have c c c c and either cs or for some we have c c and ct ct an immediate corollary of the theorem is the canonical forms property mentioned in § we can also read off the theorem a type safety property for target configurations stated below where c cc c corollary type safety if c then either c is terminal or for some we have c c and c information hiding our second theorem states that values with type · are immutable and secret in welltyped contexts the theorem considers two welltyped configurations c and c that differ only in the contents of location · and shows that their reductions proceed in it provides a property on which to build more sophisticated partial abstractions for example the monotonic counter from § chooses to allow the context to it in a controlled manner and to reveal the result theorem abstraction of · if l · and for i we have c h oi then for n c h o n c h o if and only if c h o n c h o theorem also the similarity between type · and type un from ts et al both types are abstract to the context however erased types are more general type contains more information it has a field f with type number whereas un is an abstract type with no more information scaling to safe typescript typescript has a of features for practical programming and we adapt them all soundly for use in safe typescript of particular interest are the many forms of polymorphism inheritance for classes and interfaces ad hoc subtyping with recursive interfaces javascript primitive objects implicit conversions ad hoc overloading and even parametric polymorphism space constraints prevent a detailed treatment of all these features we select a few and sketch how can be extended to handle them by restricting more advanced typing features eg parametric polymorphism to erased types we improve the expressiveness of the static fragment of the language while ensuring that these features do not the runtime invariants of safe typescript and its interface with the typechecker encoding type qualifiers since typescript does not syntactically support type qualifiers we used a simple though limited encoding for the erasure modality for instance we give below the concrete syntax for the function with erased types presented in § module sts interface erased safe typescript library client code interface extends point function function pz to mark a type t as erased we define a new interface i that extends both t and a distinguished empty interface defined in the standard library we discuss inheritance of classes and interfaces in more detail in typescript the type i has all the fields of t and no others so i is to t in safe typescript however we interpret i and any type that extends as an erased type we use similar encodings to mark types as being immutable or nominal while these encodings fit within typescript they have obvious limitations eg only named types can be qualified inheritance class and interface extension provides a simple model of classes and particular it has no support for inheritance adding inheritance is straightforward as one would expect since fields are mutable classes and interfaces are not permitted to inherited field types method are as long as they respect the subtyping relation specifically when class c extends c we require that every overriding method m in c be a subtype of the method that it in c which enforces method arguments and return types to be related by subtyping we refer to this as the it is analogous to rule in § implements clauses class inheritance in typescript is directly to inheritance in javascript as an object may have only one prototype multiple inheritance for classes is as in languages like java or c a substitute for multiple inheritance is ad hoc subtyping using classes that implement multiple interfaces unlike java or c however an instance of a class c can implicitly be viewed as an instance of a interface i even when c does not declare that it implements i nevertheless in typescript class declarations may be augmented with implements clauses one or more interfaces for each such declaration safe typescript checks that the class provides every field and method declared in these interfaces using the above extending subtyping with nominal interfaces subtyping on the arguments and results of methods in the can sometimes be too restrictive as explained in § using erased types may help their subtyping is since they need not carry rtti subtyping towards class or is also since their values always carry rtti safe typescript makes use of to also provide subtyping towards certain interfaces by default interface types are structural but some of them can be qualified as nominal nominal interfaces are only by instances of classes specifically declared to implement those interfaces as would be expected in java or c more importantly nominal interfaces are only by class instances with primitive rtti thereby enabling subtyping and making and the more permissive primitive object hierarchy aside from inheritance via classes and interfaces we also capture the inheritance provided in javascript every object type a subtype of extends the nominal interface object the base of the javascript prototype chain that provides various methods likewise every function an object with a call method in safe typescript extends the nominal interface function for instance our subtyping relation includes t string arbitrary prototype chains finally we discuss a feature from safe typescript programmers cannot build arbitrary prototype chains using proto property or using arbitrary functions as object constructors the former forbidden in the javascript standard but implemented by several is by treating proto as a property and its access both statically where and at runtime the latter is pre typescript more permits inheritance that both fields and methods using an unsound relation et al by requiring that new be called only on objects with a constructor signature only present on class types generic interfaces functions and classes the code below illustrates several valid uses of generic types in safe typescript interface pair ab fst a snd b function pair ab pair ab return fst a snd b declare var array new a a interface array t number t class map ab private map array pair a b constructor new array public we have a declaration of a generic interface for pairs line and a generic function for constructing pairs line showing how types can be abstracted line declares an external symbol array provided by the javascript runtime at an implicitly erased type that includes a generic can be abstracted at method signatures too the constructor in array builds a value of type array a an interface partially defined at lines ­ that provides a push function which receives a variable number of arguments adds them all to the end of the array and returns the new length of the array the type array t also contains an index signature line which states that each array t is a map from keys to values indicating that an array t can be using ai for finally line defines a generic class map ab typing except for erasure explained next our static treatment of generic types is fairly straightforward we extend the context with type variables and allow type abstraction at interfaces classes and boundaries to enable instantiations of type variables at arbitrary types including erased types their subtyping only includes since erased types may not even be subtypes of any we also support bounded quantification to extend subtyping for type variables type instantiations are inferred by inference algorithm eg at line typescript infers pair ab for the arguments of new array and at line pair ab and a b for the arguments of push and pair respectively generic types to keep the interface between our compiler and runtime system simple we erase all generic types and we subtyping from generic types to any take the pair function or the array value for example were we to allow it to be used at type any several issues arise for instance how to compute type instantiations when these values are used at type any conversely should any be to the type of pair ahmed et al propose a solution based on dynamic but it is not suitable here since dynamic would break object identity types and their use in dynamically typed contexts these issues on the other hand instances of generic interfaces need not always be erased for example pair number string is a subtype of and vice versa the latter type can be viewed structurally and safely handled at type any with the difference computed as usual thus the erasure modality safely allows us to extend with arrays typescript types arrays using the generic array t interface outlined in § given their use safe typescript extends with array types written t arrays in javascript are instances of a primitive object called array however all instances of arrays regardless of their generic instantiation share the same prototype thus in contrast with object and function we do not treat array as a nominal interface type instead we have t any t meaning that array instances are tagged with rtti as required by subtyping further complications arise from subtyping in typescript array subtyping is both covariant as in java and c and contravariant allowing for instance number any string more conservatively safe typescript supports sound covariant subtyping for immutable arrays based on a type in the standard library and a type qualifier for tracking specifically we have t s t as long as t s the type includes only a subset of the methods of array for instance keeping map but push additionally the compiler inserts checks to prevent assignments on instances of finally the runtime provides a function st s t which allows an immutable array a to be back to an array with a different element type after checking the rtti of a for safety experimental evaluation we summarize below the experiments we to measure the performance implications of our design choices and to gain insight into how safe typescript when used in practice we compared differential subtyping to a variant of safe typescript that tags objects with rtti as they are created we find that a slow down by a factor of we compared two implementation strategies for the tag heap one using weak maps to maintain a global rtti table off to the side the other uses an additional field in tagged objects we find the latter to be faster by a factor of to gain experience from javascript we six benchmarks from the suite to safe typescript we observe that at least for these examples migration is straightforward by initially typing the whole program using any even so safe variable scoping rules statically discovered a semantic bug in one of the benchmarks which has subsequently been fixed independently for more static checking we added types to the benchmarks and doing so also performance of the safe typescript version to parity with the original javascript finally we significant experience with moving a large typescript to safe typescript in particular we the safe typescript compiler including about from typescript originally written in typescript while doing so safe typescript reported static type errors and dynamic type errors once fixed we were able to safely safe cost of dynamic type safety is a performance of exploring the design space of tagging differential subtyping vs prior proposals for gradual typing suggest tagging every object eg et al we adapted this strategy to safe typescript and implemented a version of the compiler called sts that tags every object array and function that has a type with rtti upon creation thus sts also benefits from the use of erased types one of the main of safe typescript in code that makes heavy use of objects safe typescript and sts have essentially the same both strategies all objects have rtti via their prototype chain as soon as they are allocated finally sts has a few limitations particularly when used with generic interfaces consider the function pair from § in safe typescript the function call pair correctly allocates a pair v with no tags later if we were to use subtyping and view v at type any safe typescript again correctly tags v with the type in contrast sts fails to allocate the correct rtti for v since doing so would require passing explicit type parameters to pair so as to tag it with the correct type at the allocation site thus sts is not suitable for but it provides a conservative basis against which to measure the performance benefit of differential subtyping object instrumentation vs weak maps our default implementation strategy is to add a field to every object that carries rtti this strategy has some advantages as well as some on the plus side accessing rtti is fast since it is with the object however we must ensure that welltyped code never accesses this additional field to this end we use a field name and we the read write and invoke functions as well as property to this name however this strategy is when objects with rtti are passed to external untrusted code an alternative strategy to these problems makes use of a new primitive in the es standard for javascript already available in some experimental javascript environments provides a mapping from objects to values in which the keys are weakly held ie they do not garbage collection this allows us to associate rtti with an object in state that is private to the safe typescript runtime library for class instances we retain a field in the objects prototype we refer to our implementation that use as sts the performance evaluation in the remainder of this section compares safe typescript with its variants sts and sts on windows and an hp z benchmarks is an open javascript benchmark suite it contains java script programs ranging from simple data structures and algo like trees and implemented in a few lines to large pieces of javascript code automatically by compilers and even compilers implemented in javascript for compiling other languages to javascript the table lists programs we from the benchmark each a program a few lines long which we could port to typescript with reasonable effort all these programs use a javascript encoding of classes using in them to safe typescript we these encodings and used classes name loc classes types instead since direct of prototype chains cannot be proven typesafe in safe typescript the classes column indicates the number of classes we the number in indicates the number of abstract classes added while type checking the program we then added type annotations primarily to establish type safety and recover good performance the types column indicates their number without any type annotations we pay a high cost for enforcing dynamic type safety for the six benchmarks the a broad range from a factor of x to x with an average of x however with the addition of types we recover the lost for the typed versions is on average only on benchmarks that make almost exclusive use of classes eg and the per of safe typescript and sts is as expected the same in untyped code the cost of additional tagging in sts is by the large overhead of checks however in typed code sts an average of and sometimes as much as x finally in dynamically typed code involving many rtti operations sts is significantly slower than safe typescript x on average parity in the best case and x in the worst case we have spent some effort on simple optimizations mainly inlining runtime checks this had a measurable impact on dynamically typed code improving performance by on average however there is still substantial room for applying many optimizations towards detecting and redundant checks we draw a few conclusions from our performance evaluation first differential subtyping is clearly to when trying to ensure good performance for statically typed code second better type inference would significantly improve the experience of from javascript to safe typescript currently we rely solely on support for local type inference within method bodies most of the annotations we added manually were for toplevel functions and for uninitialized variables where typescript to inferring any inferring better types for these based on usage sites is left as future work weak maps are an implementation choice in principle their performance overhead in sts is still too substantial for practical use although as es is more widely implemented this option may become safe typescript our most substantial experience with safe typescript to date has been with the safe typescript compiler itself which contains about of code by the developers of typescript and about written by us typescript supports an option that causes the compiler to report a if the type of any variable was inferred to be any without an explicit user annotation and their compiler was developed with this option enabled thus much of the code is carefully annotated with types static error detection the safe typescript code base in static type errors it took one author about to and fix all these static errors summarized below we detected uses of subtyping of arrays we fixed the covariant cases through the use of the immutable type § and the contravariant cases by local code rewriting covariant subtyping of method arguments was observed times mostly in a single file that implemented a pattern over an ast and due to binary methods in class inheritance we fixed them all through the use of a runtime check variable scoping issues up times which we fixed by manually variable declarations and in cases almost certain bugs on code paths programmers methods and functions times eg a method when passing a parameter to a higherorder function which we fixed by local code rewriting we lack the space to discuss the long tail of remaining error classes dynamic type safety violations were detected times each a failed operation while running the compiler test suite five of these were due to dynamic uses of covariant subtyping of mutable fields primarily in code that was written by when write code with type safety in mind it is easy to make many failed erased by typescript were found in the existing code of typescript which we fixed by rewriting the code slightly interestingly two classes of dynamic type errors we discovered were in the new code we added in order to implement safe typescript we had to reverse some of the invariants of the typescript compiler in some cases we this slightly wrong some values to be instances of a particular class when they were failed checks pointed directly to our another class of errors was related to a bug in the subtyping hierarchy we introduced while the system with generic types and which had not itself earlier because of the lack of checked casts the performance overhead of safely the compiler relative to the same code base with all runtime checks was a of only the added cost of runtime checks was easily for by the of bugs found in tested production code we also the compiler using sts and sts observing a further of and compiler makes heavy use of classes for which we do not use weak maps or so the difference is but not we conclude that at least during development and testing in to safe sound gradual type system can significantly improve code quality for a code base that is already annotated with types as most typescript developments are the cost of even a large to safe typescript can be reasonable a or worth of static error followed by dynamic error detection with only slightly slower on the other hand to be fair understanding the root cause of errors requires some with our type system ie a interested in using safe typescript effectively would probably have to understand at least the informal parts of this paper experience with the typescript v compiler while we were working on safe typescript the typescript team released a new version typescript of the compiler typescript is much smaller k loc and faster x turner it is a complete rewrite of the old compiler including a design shift from being to structural record and we have typescript using safe typescript in the process providing inputs to the typescript team about the type errors found by safe typescript in preliminary experiments of using the instrumented version of typescript we found that the overhead of the dynamic checks is much higher as compared to safe typescript which is based on typescript the reason is that runtime checks are more expensive for structural types than for nominal class types we are currently in the process of our type checker to typescript related work there has been considerable work on combining static and dynamic typechecking in a variety of language too much to provide a survey discuss a few classic work on static and dynamic types abadi et al were among the first to study the semantics of a simply typed calculus with the explicit addition of a dynamic type around the same time and cartwright and considered adding static checks to a dynamically typed language their soft typing approach involved using a static type system to detect fragments of an program at compile time and guard them with runtime checks for dynamic type safety wright and cartwright developed an implementation of soft typing for scheme also related is the work of and who develop a system to translate a subset of scheme to ml while also handling polymorphism static type systems for javascript given its over the last two the earlier focus on lisp and scheme has to include javascript early proposals for the addition of types to javascript were made by who used singleton types and firstclass record labels and et al who focused on type inference et al proposed a flowsensitive static type system that refines types based on the control flow typeof checks comparison with undefined etc the most recent of this line of work is et al an extensible framework for exploring a range of static type systems for javascript features a sophisticated base type system including bounded quantification intersection and union types mutable references typelevel functions recursive types object types and a kind system despite this or perhaps because of it the base type system and its userdefined extensions come without a soundness argument et al used both refinement and heap types to statically check some highly dynamic programming idioms of javascript however again no soundness argument is given et al used an encoding of javascript following a translation semantics by et al into a generalpurpose sound system of monadic refinement types to verify javascript safety gradual typing siek and the term gradual typing for systems that mix static and dynamic idioms while allowing the programmer to control their interaction using a language of type annotations and runtime checks and felleisen introduced similar ideas almost simultaneously the addition of runtime checks can cause failures particularly with higherorder types to address this problem wadler and findler present a notion of blame for gradual type systems which allows failed runtime checks to identify the module in a program responsible for the failure blame may be less important in safe typescript as it does not involve higher order wrappers an important source of difficulty for error typed scheme and felleisen from the of soft scheme it allows programmers to their code with optional types and provides a controlflow sensitive type system to enforce them using a combination of static and dynamic checks et al describe and formalize typed the version of typed scheme their type system is similar in scope to safe typescript in that it deals with methods mutable fields and structural subtyping it also supports mixins and their subtle interaction with inheritance it tracks flows of information between the typed and untyped spaces relying on row polymorphism and contracts to deal with mixins it offers blame tracking should errors occur mixins in typed are of dynamic field extension in safe typescript they may be coded in our system using a of static types runtime checks and reflection et al propose a gradual type system called ts for javascript and rtti as a mechanism for ensuring type safety as discussed in § and § the two systems are somewhat complementary safe typescript focuses on scale and flexibility it new typing mechanisms leading to a more permissive type systems with lower runtime overhead ts focuses on isolation of untrusted code and safe with code outside the fragment covered by safe typescript as an alternative to isolation or in one may also reduce trust in external code by to the techniques of and who develop tools to specifically check the correctness of a large typescript type definition et al present python a framework for with gradual type systems in python they consider three cast semantics a the wellknown wrapper semantics which breaks object identity b a semantics that involves inserting runtime checks at call sites function definitions etc and c a monotonic semantics that locks objects with field types the semantics is not formalized and its soundness is the monotonic semantics is of et al and safe typescript except that types with respect to an subtyping hierarchy et al study three cast insertion strategies placing casts at the callsite the callee or a mix of the two for a smalltalk and observe performance when interacting with typed libraries to this behavior they recently present confined gradual typing et al an extension of a gradual typing with type qualifiers to track values between typed and untyped spaces one of these qualifiers is similar to the erasure modality of safe typescript in that both subtyping to any however their use of higherorder casts does not preserve object identity et al another mechanism for static and dynamically typed code they extend by allowing every nominal class type c to be qualified as functions taking like c parameters are statically checked against cs interface whereas their callers are unconstrained hence type safety involves dynamic checks on expressions et al recently proposed for javascript building on typescript their model does not cover higherorder fields method arguments and references their objects are purely functional our type system is more expressive and our semantics more faithful to typescript on the other hand they use type information as a source of optimizations in the vm an interesting aspect complementary to our work as discussed in § gradual type systems are starting to see adoption typescript has a gradual type system similar to the system of siek and but adds a number of unsound typing rules to support particular programming patterns and all types during compilation thereby dynamic checks et al dart similarly soundness and also normally to javascript by all types but it has a checked mode that adhoc runtime checks for early detection of some common errors has released a gradual type system for php again types are erased and there is no soundness guarantee in the presence of any types conclusions safe typescript is the first sound gradual type system for javascript we have already argued for the benefits it provides to application developers at a performance we also expect our work to be useful for researchers developing javascript program analyses who may consider using safe typescript as a on which to build more sophisticated analyses a large community effort continues to be on designing and implementing static analyses for javascript and each must with the inherent of the language starting from safe typescript may static analysis problems more tractable to our compiler the task of and allowing the tool to focus on higher level properties some challenges remain notably javascript and typescript are moving targets both languages with the new standard of javascript es due in a few and versions of typescript also expected whether or not the of a sound type system will be by the growing javascript and typescript community of developers and along with those languages remains to be seen acknowledgments our thanks to abadi and the typescript team for several useful discussions to the anonymous reviewers of the paper and for their valuable feedback and to matthias felleisen and for improvements to our discussion of related work references m abadi l cardelli b pierce and g plotkin dynamic typing in a language in proceedings of popl a ahmed r b findler j g siek and p wadler blame for all in proceedings of popl e j and cast insertion strategies for objects in proceedings of e j r and confined gradual typing in proceedings of oopsla c p and s towards type inference for javascript in proceedings of ecoop g m abadi and m understanding typescript in proceedings of ecoop r cartwright and m soft typing in proceedings of pldi r d and r jhala dependent types for javascript in proceedings of m soft typing an approach to type checking for dynamically typed languages phd thesis a and a checking correctness of typescript interfaces for javascript libraries in proceedings of oopsla a c and s the essence of javascript in proceedings of ecoop a c and s typing local control and state using flow analysis in proceedings of esop f and j safe polymorphic type inference for scheme translating scheme to ml in proceedings of d a and c flanagan gradual typing higher order symbol comput b s j g a and s type systems for javascript in proceedings of z coercive subtyping j log comput ­ m s m b i and m safe active content in javascript unpublished paper a n c fournet g and p safe efficient gradual typing for typescript g f z c and j types you can count on unpublished paper j g siek and w gradual typing for functional languages in proceedings of scheme and functional programming workshop j g siek and w gradual typing for objects in proceedings of ecoop j g siek and m m monotonic references for gradual typing unpublished paper n j c j chen and b verifying higherorder programs with the dijkstra monad in proceedings of pldi n c fournet a k j chen py and g gradual typing embedded in javascript in proceedings of popl a t s c s and m felleisen gradual typing for firstclass classes in proceedings of oopsla p towards a type systems for analyzing javascript programs in proceedings of esop n m j de m and s app development on mobile devices in proceedings of s and m felleisen migration from scripts to programs in proceedings of s and m felleisen the design and implementation of typed scheme in proceedings of popl j turner typescript http m m a m j g siek and j design and evaluation of gradual typing for python in proceedings of p wadler and r b findler welltyped programs cant be in proceedings of esop a k wright and r cartwright a practical soft type system for scheme acm trans program lang syst ­ jan t f z s j and j integrating typed and untyped code in a language in proceedings of popl 