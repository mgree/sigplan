a language for automatically enforcing privacy policies yang mit abstract it is important for applications to protect sensitive data with current techniques the programmer the burden of ensuring that the applications behavior to policies about where sensitive values may flow unfortunately privacy policies are difficult to because their global nature requires reasoning and enforcement to address this problem we describe a programming model that makes the system responsible for ensuring to privacy policies the programming model has two components core programs describing functionality independent of privacy concerns and declarative policies controlling how sensitive values are each sensitive value multiple views policies describe which views are allowed based on the output context the system is responsible for automatically ensuring that outputs are consistent with the policies we have implemented this programming model in a new functional constraint language named jeeves in jeeves sensitive values are introduced as symbolic variables and policies correspond to constraints that are resolved at output channels we have implemented jeeves as a scala library using an smt solver as a model in this paper we describe the dynamic and static semantics of jeeves and the properties about policy enforcement that the semantics guarantees we also describe our experience implementing a conference management system and a network categories and subject descriptors d programming languages language constructs and features general terms languages security keywords language design runtime system privacy security introduction as users share more personal data online it becomes important for applications to protect confidentiality this places the burden on programmers to ensure even when both the application and the policies may be this work was in part by the us under the and nsf research programs the views and conclusions contained are those of the authors and should not be interpreted as representing the policies either expressed or implied of the us permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission andor a fee popl january ­ pa usa copyright c acm ensuring with privacy policies requires reasoning globally about both the flow of information and the interaction of different policies this information a number of tools have been developed to check code against privacy policies statically and dynamically while these checking tools can help avoid data leaks the programmer is still responsible for implementing applications that display enough information to satisfy the users needs without privacy policies the programming model that we propose goes beyond checking to simplify the process of writing the code that preserves confidentiality the main contribution of this paper is a new programming model that makes the system responsible for automatically producing outputs consistent with policies this automation makes it easier for programmers to enforce policies specifying how each sensitive value should be displayed in a given context the programming model has two components a core program representing functionality and privacy policies controlling the of sensitive values this separation of policies from core functionality allows the programmer to express policies explicitly in association with sensitive data rather than implicitly across the code base the declarative nature of policies allows the system to ensure even when these policies interact in nontrivial ways we have implemented this programming model in a new functional constraint language named jeeves jeeves introduces three main concepts sensitive values policies and contexts sensitive values are introduced as pairs vv where v is the value v is the value and is a level variable that can take on the values and determines which view of the value should be shown policies correspond to constraints on the values of level variables the language of policies is a decidable logic of quantifierfree arithmetic constraints boolean constraints and equality constraints over records and record fields a policy may refer to a context value characterizing the output channel and containing relevant information about how the data is viewed for example in a small application we implemented as a case study we included a policy that allows users to restrict the of their location to users in their because the location is a sensitive value a function such as print that tries to output a value derived from a location will need to be passed a context containing the location of the user to this value is about to be displayed using this context the runtime system can then derive an output that is consistent with the policy we formally specify jeeves to show that the component of a sensitive value can only affect program output if the policies allow it we define jeeves in terms of j a constraint functional language that describes the propagation and enforcement of policies in jeeves j is different from existing constraint functional languages in the restrictions it places on the logical model and its use of default logic to provide determinism in program behavior these restrictions make it possible for j to have an efficient execution model without too much expressiveness there is a straightforward translation from jeeves level levels exp exp op exp expressions if exp then else exp f exp exp exp exp level in exp policy then level in exp stmt let x exp print exp figure jeeves syntax to j jeeves level variables for sensitive values are logic variables policies are assertions and all values depending on logic variables are evaluated symbolically the symbolic evaluation and constraint propagation in j allow jeeves to automatically enforce policies about information flow we implemented jeeves as a domainspecific language embedded in scala using the z smt solver to resolve constraints as a way to demonstrate the feasibility of the jeeves programming model to evaluate the expressiveness of jeeves we have used our scala embedding to implement a small conference management system and a small network the case studies show that jeeves allows the separate implementation of functionality and policies for example in the conference management example the code makes no attempt to between users or even the general public yet the policies ensure that the system the right level of information to each user through every phase of the review process in summary we make the following contributions in this paper · we present a programming model and language jeeves that allows programmers to separate privacy concerns from core program functionality · we formalize the dynamic and static semantics of jeeves in terms of a j a new constraint functional language we prove that jeeves executions satisfy a noninterference property between low and high components of sensitive values · we describe the implementation of jeeves as an embedded domainspecific language in scala using the z smt solver · we describe small case studies that show that jeeves supports the desired policies and allows the programmer to separately develop core functionality and policies privacy to jeeves jeeves allows the programmer to specify policies explicitly and upon data creation rather than implicitly across the code base the jeeves system the programmer to correctly specify policies describing high and views of sensitive values and to correctly provide context values characterizing output channels the runtime system is responsible for producing outputs consistent with the policies given the contexts jeeves guarantees that the system will not leak information about a value unless the policies allow this value to be shown in this section we introduce a simple conference management example to explain the main ideas in jeeves introducing sensitive values writing policies providing contexts and implementing the core program logic conference management systems have simple information flow policies that are difficult to implement given the interaction of features being able to separately specify the policies allows the core functionality to be quite concise in fact we can write a single program that allows all to access the list of papers directly for searching and the program relies on the jeeves runtime system to display the appropriately information for reviewers vs the general public for the sake of brevity we present jeeves using an mllike concrete syntax shown in figure introduction to jeeves we first describe how to introduce sensitive values use them to compute result values and display the results in different output contexts suppose we have the policy that a sensitive value name should be seen as alice by users with a high confidentiality level and as anonymous by else a jeeves program can use the name value as follows let msg author is name print alice msg output author is alice print bob msg output author is anonymous to achieve the different outputs for alice and bob we associate a policy with name by it through the following jeeves code let name level a in policy a context alice then in anonymous this code introduces a level variable a and associates with it a policy that if the context value is not alice then the value is the context value represents a in the output channel the code then this policy to the sensitive value anonymous which defines the view as the string anonymous and the view as alice when this code is executed the jeeves runtime ensures that only the user alice can see her name appearing as the author in the string msg user bob the string author is anonymous each sensitive value defines a and view for a value the jeeves programmer defines sensitive values by introducing a tuple vv where v is the value v is the high confidentiality value and is a level variable associated with a set of policies determining which of the two values to show an expression containing n sensitive values can evaluate to one of n possible views level variables provide the means of abstraction to specify policies incrementally and independently of the sensitive value declaration level variables can be constrained directly by explicitly passing around a level variable or indirectly by another level variable when there is a dependency it is possible to encode more than two privacy levels but for the sake of simplicity the paper assumes only two policies introduced through policy expressions provide declarative rules describing when to set a level variable to or notice that the policy above forces a to be when the user is not alice other policies could further restrict the level variable to be even for alice but no amount of policy interactions can allow a different user to see the v value in contradiction with the policy policies may mention variables in scope and also the context variable which corresponds to an implicit parameter characterizing the output channel the context construct the programmer of the burden of structuring code to propagate values from the output context to the policies statements such as print that release information to the require a context parameter the jeeves runtime system propagates policies associated with sensitive values so that when a value is about to be displayed though an output channel the right context can be inserted into the policy and the appropriate result can be produced in addition to print shown above other output channels include sending email and writing to file declarative and policies we now describe how to write policies in jeeves using fragments of our conference management example the paper record is defined below it assumes single author papers to simplify the presentation type paper title string author user review list accepted bool option the way of policies to values is to create sensitive values for each field and then policies let title string author string review list accepted bool option paper level tp rp in let p title title tp author accepted none some accepted in p tp p p rp p p this function introduces level variables for each of the fields creates sensitive values for each of the fields policies to the level variables and returns the resulting paper record the jeeves programmer associates policies with sensitive values by introducing level variables policies to them and using them to create sensitive values consider the policy that the title of a paper should be visible to the authors of the paper reviewers and pc members and only visible to the general public after it is public that the paper has been accepted we can define as follows let p paper a level unit policy a context context role context role pc public p then this function to level variable a a policy that sets the level to unless the has a right to see the paper title policies may refer to values corresponding to the output channel through the context variable the condition for the policy in function uses the and stage fields of the context variable which have types and types respectively type user stage type review decision public a context value of type must be produced in order for an output channel to access a sensitive value produced by the function with type inference it is not necessary for the programmer to provide the context type annotation in the scala implementation the programmer does not need to provide context annotations policy interactions the jeeves model helps prevent the programmer from information about one value through the enforcement of a policy for another value we show how jeeves can prevent the programmer from writing code where the policy for paper leaks information about a paper records accepted field consider the following situation in which the policy for one sensitive field paper depends on another sensitive field whether the paper has been accepted in the function the predicate p depends on the accepted field of the paper p which is some accepted if a decision has been made and the decision is known or none otherwise the accepted field needs its own policy to prevent its status from being early the following function adds the appropriate policy let p paper a level unit policy a context role context role pc public then this policy allows reviewers and program members to always see whether a paper has been accepted and for others to see this field only if the stage is public with this policy in place the title field cannot leak information about the accepted tag even if the policy for paper were to drop the public requirement the policy for accepted would prevent the of accepted papers from being before the public stage circular dependencies and the jeeves system can also enforce policies when there are circular dependencies between sensitive values as could happen when a context value depends on a sensitive value consider the following function that associates a policy with the authors of a paper let p level unit policy n p context user public p then this policy says that to see the author of a paper the user must be an author or the paper must be a accepted paper now consider functionality that sends messages to authors of papers let author user let msg in user author stage review msg the policy for level variable n depends on here is a sensitive value as the value of the author variable depends on the this leads to a circular dependency that makes the solution the value of the message on the context value which contains the message either sending mail to the empty user or sending mail to the author is correct under the policy the latter behavior is as it ensures that user a can communicate with user b without knowing private information about user b the jeeves runtime ensures this functional behavior by setting level variables to by default if the policies allow a level variable to be or the value will be the j language and semantics to more formally describe the guarantees we define the semantics of jeeves in two steps first we introduce j a simple constraint functional language based on the calculus and then we show how to translate jeeves to j j differs from existing constraint functional languages in two key ways j restricts its constraint language to quantifierfree constraints involving boolean and arithmetic expressions over primitive values and records and j supports default values for logic variables to facilitate reasoning about nondeterminism js restrictions on the constraint language allow execution to rely on an smt solver in this section we introduce the j language the dynamic semantics the static semantics and the translation from jeeves the j language extends the calculus with defer and assert for introducing and logic variables as well as a construct to produce concrete values from them the dynamic semantics describe the lazy evaluation of expressions with logic variables and the interaction with the constraint environment the static semantics describe how the system guarantees evaluation progress and enforces restrictions on symbolic values and recursion the translation from jeeves to j illustrates how jeeves uses js lazy evaluation and constraint propagation combined with jeeves restrictions on how logic variables are used to provide privacy guarantees c n b x e record x error concrete primitives x context symbolic values c op op c op if then t else f c values e e op e expressions if e then et else e f e e let x e in e let rec f e in e defer x e default d assert e e with c figure the j abstract syntax the j language j is the calculus extended with logic variables figure shows the abstract syntax of j expressions e include the standard expressions extended with the defer construct for introducing logic variables the assert construct for introducing constraints and the construct for producing concrete values consistent with the constraints j evaluation produces irreducible values which are either concrete c or symbolic concrete values are what one would expect from calculus while symbolic values are values that cannot be reduced further due to the presence of logic variables symbolic values also include the context construct which allows constraints to refer to a value supplied at concretization time the context variable is an implicit parameter provided in the expression in the semantics we model the behavior of the context variable as a symbolic value that is constrained during evaluation of j contains a let rec construct that handles recursive functions in the standard way using fix a novel feature of j is that logic variables are also associated with a default value that serves as a default assumption this is the assigned value for the logic variable unless it is inconsistent with the constraints the purpose of default values is to provide some determinism when logic variables are dynamic semantics the j evaluation rules extend calculus evaluation with constraint propagation and symbolic evaluation of logic variables evaluation involves keeping track of constraints which are required to be true hard constraints and the set of constraints we use for if consistent with our hard constraints default assumptions to correctly evaluate conditionals with symbolic conditions we also need to keep track of the possibly symbolic path condition ation happens in the context of a path condition g an environment storing the current set of constraints and an environment storing the set of constraints on default values for logic variables evaluation rules take the form g e e evaluation produces a tuple e of a resulting expression e along with modified constraint and default environments in figure we show the smallstep dynamic j semantics evaluation with logic variables j has the expected semantics for function application and arithmetic and boolean operations the and rules describe a callbyvalue semantics the and rules for operations show that the arguments are evaluated to irreducible expressions and then if both arguments become concrete the rule can be applied to produce a concrete result conditionals whose conditions evaluate to concrete values evaluate according to the and rules as one would expect when the condition evaluates to a symbolic value the whole conditional evaluates to a symbolic if value by evaluating both branches as described by the and rules note that j expressions are pure effects are only in jeeves statements so side effects cannot occur in conditional branches evaluating under symbolic conditions is potentially because evaluation of such conditionals with a recursive function application in a branch could lead to infinite recursion when the condition is symbolic our system prevents this behavior by using the type system to enforce that recursive calls are not made under symbolic conditions section introduction and elimination of logic variables in j logic variables are introduced through the defer keyword to illustrate the semantics of defer consider the example below let x int defer x int x default as we show in the evaluation rule the righthand side of the assignment evaluates to an renamed version of the logic variable x evaluation adds the constraint g x to the constraint environment and the constraint g x to the default constraint environment the constraint g x is a hard constraint that must hold for all derived outputs while g x is a constraint that is only used if it is consistent with the resulting logical environment hard constraints are introduced within the of defer expressions and through assert expressions soft constraints are introduced through the default clause of defer expressions in addition to the constraints in defer the program can introduce constraints on logic variables through assert expressions the rule describes how the constraint is added to the con environment taking into account the path condition g for instance consider the following code if x then assert x else assert x evaluation adds to the constraint environment the constraints x x and ¬x x symbolic expressions can be made concrete through the construct evaluation of expressions either produces a concrete value or an error a expression includes the expression to and a context let result int x with as we describe in the rule concretization adds the constraint context to the constraint environment and finds an assignment to x consistent with the constraint and default environments an important observation is that the context itself may be symbolic in which case the system will also be finding a concrete context consistent with the hard constraints the model function takes the constraint and default environments computes a satisfying assignment to free variables and produces a substitution m c that is used to produce a concrete value as shown in the rule the rule describes what happens if there is no satisfiable expression consistent with the constraint environment in this case evaluation of the expression produces the error value interaction with the constraint environment valid constraint expressions consist of j expressions that do not contain expressions this constraint language corresponds to constraints that can be solved by smt solvers the g e e g e e g e e e e g e e g e e c c op c g xe ex g c op c c g g e e e op e e op e g g e e op e op e g g ec ec if ec then et else e f if ec then et else e f g et et g e f e f g if true then et else e f et g if false then et else e f e f g g et et if then et else e f if then et else e f ¬ g e f e f g if then t else e f if then t else e f g e e g defer x e default d defer x e default d fresh x g defer x c default d g cx x g x d x g e e g assert e assert e g assert g g e e g e with c e with c model g context c m c m v g v with c c model g context c g v with c error figure dynamic semantics for j model procedure in the rule is the model finding procedure for default logic the default environment and constraint environment specify a default theory where each default judgement has the form true the model procedure produces either a model m for the theory if it is consistent or we use a fixedpoint algorithm for model that uses classical smt decision procedures and iteratively the logical context with default judgements in a nondeterministic order j static semantics the j static semantics ensures that evaluation produces either a concrete expression or a wellformed symbolic expression recall that symbolic expressions must be valid constraints which include arithmetic boolean and conditional expressions but not functions in the j semantics we do not explicitly address data structures such as lists data structures are also required to be concrete but may have symbolic elements thus the static semantics guarantee that concrete values are supplied when concrete values are expected symbolic values are wellformed evaluation under symbolic conditions does not cause infinite recursion and concrete sym determinism tag unit base type int bool nr type figure j types context values have the appropriate types the type system therefore ensures that the logical state will always be well formed although it cannot guarantee that it will be logically consistent to guarantee properties the j type system tracks the flow of symbolic values out symbolic functions and applications under symbolic conditions applications are function applications that may recursively call the current function we prevent such applications under symbolic conditions to prevent nontermination that may arise from evaluating both sides of a conditional branch with a symbolic condition property on the other hand is enforced by ensuring that the type of the context used at concretization is an upper bound for the types of contexts required by all the relevant policies we show the j types in figure and the subtyping type wellformedness and typing rules in figure base types are the standard calculus types extended with the and types to indicate values that are necessarily concrete expressions of function type are not permitted to be symbolic there are two function types nr for functions whose application cannot be and for functions whose application can be we will use the term function to refer to a function whose application can be typing judgments have the form e a judgment says that in the type environment under a path of type sym or concrete the expression e has type is defined · x the typing rules keep track of whether a value may be symbolic int or bool type or must be concrete and functions this information is used to determine the value of the tag in the and rules information about whether the condition is symbolic is used in out symbolic functions and out under symbolic branches symbolic functions are by the and rules which restrict the production of symbolic functions the rule restricts the explicit introduction of symbolic values to have base type while the rule restricts the implicit introduction of symbolic values to base type the rule shows that recursive functions must be considered have type within their own definitions since applying the function will cause a recursive call to the current function outside their declaration on the other hand they can have nr type a second restriction on functions is imposed by the type wellformedness predicate rep which requires that functions taking arguments that may be be themselves labeled as this prevents functions from being used to the restrictions on calls according to the rules a call cannot occur under a symbolic condition the rule sets sym when the condition is symbolic the rule allows applications of recursive functions only under concrete paths this implies that canonical recursive functions such as factorial can only typecheck if they require a concrete argument this restriction does not prevent recursive sort or other recursive functions because data structures are necessarily concrete so conditions involving their structure are also concrete the subtyping relationship allows values that are necessarily concrete to be used as potentially symbolic values this way functions that require concrete values can only be applied when concrete arguments are supplied but a concrete value can be used as a symbolic value for instance as int the subtyping rules allow functions nr to be used as functions contexts we also have typing rules not shown in figure ensuring that contexts of the appropriate type are provided in expressions in the rule the context typing judgment c enforces that the context type supplied is the context type expected the context typing judgement is c x c where c is the context type of an expression the rules propagate the context type enforce that matching contexts are provided for subexpressions and enforce that the correct context type is supplied at concretization we define a lattice describing when different context types may be combined the bottom of the lattice is and for all types we have the relationship c contexts support width subtyping on record types record m c record n ni a record with fields m can be used as a context whenever a record with fields n expected as long as the labelled fields of mi are a superset of the labelled fields of n translation from jeeves there is a straightforward translation from jeeves to j sensitive values and level variables in jeeves correspond to j logic variables level policies correspond to j assertions and contextual enforcement corresponds to producing concrete values consistent with the logical environment default values provide determinism in handling policy dependencies we show the translation of levels and sensitive values from jeeves to j in figure we have the exp e rule to describe how a jeeves expression translates to a j expression e the translation has the following properties level variables are the only logic variables expressions containing sensitive values yield symbolic results only jeeves policies introduce assertions and the construct can only appear at the outermost level and is associated with an effectful computation sensitive values a jeeves sensitive value v va is translated to a symbolic value equal to either v or v depending on the value of level variable a because sensitive values are symbolic all expressions computed from this sensitive value are subject to policies depending on the value of level variable a level variables jeeves level variables are translated to j expressions binding a new logic variable of level type equal to either or the default value of level variables is the constraint solving oracle first the constraint environment with the assumption that each level is and only this if the variable must be equal to this provides the programmer with some guarantees about program behavior when level variables are can arise for instance if values in the context depend on sensitive values besides being useful in handling circular dependencies having the default value of level variables as prevents the programmer from a value as a result of an value if a level variable is policies on a subsequent variable can affect the value it can take let x level a in a let y level b in policy b true then in policy b x then in b if the value of x were fixed this would yield a contradiction but instead these policies indirectly fix the value of x and a true b line x line x line a line making level variables by default forces programmers to explicitly introduce policies setting level variables to for this reason will only cause level variables to be set to instead of declarative constraint policies as we show in table level policies are translated to j assert expressions level policies can be introduced on any logic variables in scope and are added to the environment based on possible path assumptions made up to that point the policy that a jeeves expression exp enforces consists of the constraint environment produced when evaluating exp as a j expression more specifically we are about where exp e and e this policy contains constraints determining whether level variables can be or int bool nr rep rep nr rep rep nr nr rep rep rep rep rep rep rep rep rep rep e x x x n b unit rep context e e rep e et e f rep e op e top if e then et else e f e bool sym et sym e f c rep c if e then et else e f c x d e rep rep x d e d e nr e e e rep rep f e f nr e rep rep let rec f nr e in e concrete e e rep rep e e x ec bool ec bool defer x ec default assert ec unit e c e e with c figure static semantics for j describing simple typechecking and enforcing restrictions on scope of nondeterminism and recursion recall that refers to base types false true el eh if then eh else el exp e level in exp let defer bool default true in e policy ep exp e b then in exp assert ep b in e ec exp e print exp print e with ec figure translation from jeeves to j contextual enforcement at output channels effectful computations such as print in jeeves require contexts corresponding to the to the result is displayed as we show by the rule is inserted in the translation because sensitive values can only produce concrete values consistent with the policies this ensures enforcement of policies at output channels properties we describe more formally the guarantees that jeeves provides we prove progress and preservation properties for j we show that the only way the value for the high component of a sensitive value to affect the output of the computation is if the policies permit it progress and preservation we first show the correctness of evaluation we can prove progress and preservation properties for j evaluation of an expression e always results in a value and preserves the type of e including the internal nondeterminism tag there are two interesting parts to the proof showing that all function applications can be reduced and showing that all defer and assert expressions can be evaluated to produce appropriate constraint expressions we can first show that the j type system guarantees that all functions are concrete lemma concrete functions if is a value of type then x e where e has type theorem progress suppose e is a closed welltyped expression then e is either a value or there is some e such that e e proof the proof mostly involves induction on the typing derivations one interesting case is ensuring that model will either re turn a valid model m or for the and rules since the j type system rules out symbolic functions only wellformed constraints can be added the other interesting case is function applications e e e where e and e are welltyped with types and we can rule out the cases when e and e are not values by applying the induction hypothesis for the case when e and e are both values we can apply the concrete functions lemma to deduce that e must have the form x e where e in this case we can apply the rule we can also prove a preservation theorem that evaluation does not change the type of a j expression theorem preservation if e and e e then e proof we can show the preservation of both and by induction on the typing derivation the value for all evaluation rules except for the rules is the same for both sides confidentiality theorem we show that level variables enforce the confidentiality of values once the policy sets a level variable where we have some the output will be derived as if was not involved in evaluation at all because we have if and only if we have policies that require jeeves programmers can rely on policies to enforce confidentiality we first prove that the views of the sensitive values are protected by level variables we can show that for a sensitive value v the only way the value for the high component may affect the output of the computation is when is consistent with the policies it is impossible for an to distinguish between v and v if the policy requires theorem view noninterference consider a sensitive value v in a jeeves expression e assume eh eh e e eh eh e e for any context value v if context v context v then c with v c c with v c proof from the rules of jeeves translation v maps to an irreducible symbolic expression if then eh else el in e where el el and eh eh thus we can say that e is e with the expression eh replaced by eh where eh eh in addition we also know that both e and e are j expressions with no subexpressions this makes evaluation of e and e deterministic and allows us to put their derivation trees in correspondence there are two places where evaluation differs reduction of eh and eh rule and substitution of the reduced sensitive value rule let us understand how they affect the logical environment and the resulting symbolic value the values and may differ only in the subexpressions eh and eh reduce to these subexpressions are guarded by the level variable since the logical environments that under context v any model chosen at concretization sets to therefore under such models and evaluate to the same value then to show that the set of concrete values is the same it suffices to show the models of are models of and vice versa the dynamic semantics and with the same con modulo substitution of the sensitive variable except during reduction of eh and eh the constraints added at rule are all guarded by the level variable since and both ¬ and these guarded constraints are implied by ¬ we can safely eliminate them from both and that leaves us with the same set of hard constraints introduced through defer and assert expressions the default judgements in jeeves all have the form true therefore for the shared level variables and use the same default value true the remaining level variables do not affect evaluation of and our noninterference theorem allows programmers rely on policies to enforce confidentiality in jeeves policies have the form or by the theorem once the policy setting to is guaranteed to be added to the constraint environment the output is going to be the same as if the high view component of the sensitive value was not involved in evaluation at all if policies permit both and levels then the default logic model will guide evaluation to a model levels set to note that if policies are and the set of constraints is unsatisfiable the evaluation halts with an error and no value is exposed the theorem still holds and this behavior is safe scala embedding we have implemented jeeves as an embedded domainspecific language in scala programming language overloading capabilities offer us the necessary flexibility in designing a domain specific language for j with the benefit of with existing java technology in this section we discuss our scala embedding of j and our implementation of the jeeves library on top of that we describe how we used features of scala to implement js lazy evaluation of symbolic expressions how we collect constraints and how we interact with the z smt solver on top of the functional model we have presented we also handle objects and mutation scala embedding of j every kind of symbolic expression in j has a corresponding scala case class for instance corresponding to symbolic integer expressions arithmetic and boolean operators are defined as methods constructing new expressions we use implicit type conversions to lift concrete scala values to symbolic constants type inference x to which in turn evaluates to constant where x is a symbolic integer variable implicit type conversion allows us to use concrete expressions in place of symbolic ones but requires type annotations where a symbolic expression is expected to be used the three core language extensions defer assert and are implemented as library calls we implement the library as a scala that maintains the logical and default constraint environments as lists of symbolic boolean expressions calls to invoke an smt solver for the satisfiability query model we translate j constraints to the logic of and use incremental to implement the default logic decision procedure concretization in differs from j in two ways first accepts an arbitrary boolean expression rather than a context equality predicate second is not allowed to be a part of a symbolic expression in since concretization generally happens as part of print routine this restriction does not affect our case studies in addition to boolean and linear integer constraints the scala embedding supports symbolic expressions for objects corresponding to j records with equality theory objects are modeled as a finite algebraic data type in z the set of available objects is maintained by using of instances of a special atom object fields are modeled as total functions interpreted at the time of concretization fields are with values that are arbitrary expressions and constants does not check types of symbolic object expressions we rely on support for dynamic to resolve field dereferences we use special zero values null or false to represent undefined fields in smt does not support symbolic collections instead we use implicit type conversions to extend the standard scala collection library with filter and has methods that take symbolic arguments the argument to filter is a function f from an element to a symbolic boolean it maps every element o to conditional expression if f o o else null method has takes a symbolic object o and produces a disjunction of equalities between elements of the collection and o jeeves as a library in scala we have implemented jeeves as a library on top of our library has function calls corresponding to sensitive values level construct policy construct and contextual output functions see figure levels are introduced using method that returns a logical level variable which can be either or sensitive values are created with methods that take a level variable together with high and low values context is a logical object variable context to introduce a level policy the programmer the code is available at extends extends atom register this val context symbolic context variable def def policy lvar f formula l level def lvar high low def lvar high symbolic low symbolic symbolic def symbolic e t figure jeeves library in scala calls policy method and a level variable the desired level and a boolean condition the boolean condition is passed by name to delay its evaluation until concretization this way policies that refer to mutable parts of the heap will produce correct constraints for the of the system at concretization the jeeves library supports mutation in variables and object fields by treating the mutable state as part of the context in call to mutable fields are interpreted at the time of policies that depend on mutable state are evaluated to boolean conditions during concretization the set of allocated is supplied at concretization these conditions together with the equality predicate context ctx are used to expressions in experience we have implemented a conference management system and a network our experience suggests that jeeves allows the programmer to separate the core functionality from the privacy policies allowing the programmer to separately test policies and functionality conference management system we have implemented a simple conference management system to demonstrate how a wellknown system with privacy concerns looks in jeeves this system is similar to the example we described in section our implementation demonstrates that jeeves allows us to implement all functionality including search and display over final paper versions with a core functionality that is separate from the policies supports the following subset of the functionality mentioned on the for the conference management system smart paper search by id by etc paper tagging for instance accepted and by and search by tags assigning collecting responses and and final paper versions does not implement functionality for which confidentiality is less key for instance the process of for papers all core functionality to the privacy policies implements the following information flow policies · paper are visible to the authors of the paper reviewers and pc members during all stages paper are visible to during the public stage · author names are visible to the authors on the paper during all stages to reviewers and pc members during and after the stage and to during the public stage if the paper has been accepted file total total loc policy loc table of lines of code across the source class int var body string var score int extends val val level val val policy level policy level level null figure · identities are only to pc members · and are to authors of the paper reviewers and pc members after the review phase during the review phase reviewers must have submitted a review for a paper p before they can see ps our implementation allows us to separate the declaration of policies and code we show the of code and policies in table the policies are in the data classes and which describe the attributes and policies associated with maintaining data associate with papers and paper the other files including do not contain policies this allows the core functionality to be concise the implementation of our functionality as specified is only lines the implementation of the core functionality of is to the policies the back end stores a list of objects and supports adding papers updating components of papers and searching over papers by id name and tags we show the function to search papers by tag below def papers filter this function produces a list of symbolic objects which are equal to objects containing paper data if the paper tag tag is present and null otherwise the core program can be concise because it does not have to be concerned with policies we implement policies specified in terms of program variables such as a papers list of tags and values from the output context to provide an example of a data class definition we show the definition of the class in figure a object has the fields body and score the class defines a policy that the identity of the as stored in the field is visible only to other reviewers and pc members the code introduces a new level variable level adds a policy that the context must be a or pc member to see the object the policies on allowed contexts for the entire object are defined in the class representing data associated with papers the policies with respect to data policy updates to change at what stage of the conference when reviewers are allowed to see names of authors we can simply change the few lines of code corresponding to the author list policy the programmer does not have to make changes across the code base to update policies network for networks it is important to develop code that implements information flow policies privacy issues have put the network under the of the making it crucial that they do not leak sensitive data on the other side one of key values is to move fast develop features separation of policies and core program functionality can help developers develop features to investigate this hypothesis we have implemented jeeves net a network that uses jeeves policies to control confidentiality of data jeeves net core functionality involves storing and allowing queries over user attributes such as names and networks a relation between users and dynamically changing properties such as user location jeeves net allows a user u to define policies about who can see which versions of these attributes based on the relationship of the to the u the system allows the user to define different versions of their information to be shown to given which level they satisfy these policies are stateful for instance a policy on the visibility of user us location refers to the location of u and the location of output v jeeves allows the programmer to develop policies and core functionality separately in our source all policies in class representing a user while the query code in is left the programmer can extend the arbitrarily and rely on the jeeves system to enforce information policies the programmer can also easily change the policies enforced across the program by changing the policy code in in the rest of this section we through how we implement interesting policies in jeeves net support for userdefined policies that may depend on the relation stateful policies and policies that have mutual dependencies as a result of a symbolic context defining levels each sensitive field in a object is defined in terms of the level of the output we use jeeves level variables to define three levels is most permissive and allows public access allows access only to and self is most restrictive and access to except the user the following function creates level variables associated with userdefined levels def level ul val a val me context this ul match case case self me case policy l me a the context variable refers to the user at the other end of the output channel the mutable set of is in a private field of we use this function to create sensitive values for user fields based on levels the constructor for the class takes parameters and to specify who can see the name and fields to create a sensitive property for the name of a user passed to the constructor as string we declare an field val name null we can create a list that is visible based on the level as follows def val l level when these fields are accessed the results will only be displayed to who have an appropriate level of access policies become implicitly combined when different sensitive values interact to get names of of a user we simply call user although the code looks the same as if without jeeves the context user here must simultaneously be able to access the list of and the name property to see the name of a location policy the location demonstrates that if of location information is not carefully people can easily use this information for for instance in determining candidates for jeeves allows programmers to easily express policies location data based on not just relationships but also on policies involving user locations a user may choose to share her location with with users or only to who are to write the policy that only a user can see the location we create sensitive values for in the method guarded by distance policy var x var y def x y val l policy l this this x x this y y def symbolic b symbolic bx by the policy uses sensitive values for x and y to guard the values themselves we can do this because whenever there are such circular dependencies the jeeves runtime will choose a safe but assignment to levels for example if all users in the network are it is safe to return low values for however jeeves would output the actual values since that the number of levels without safety since policies and query code are separated to change the location policy we only need to modify the a stronger policy that permits only to see the location requires one change to line to replace with level symbolic context jeeves also allows the context to contain sensitive values as an example consider the following function which sends a users name to her def for f yield email f the email function sends to f a version of with context f since the list is symbolic f is symbolic as well this means that f will take high value only if the corresponding of u is allowed to see the list of of u the name of u is only if its policies permit f to see because jeeves handles circular dependencies by finding a safe but assignment the jeeves runtime system will send the name to each if the is permitted to see the name such reasoning about symbolic contexts is hard to simulate in runtime systems such as that do not use symbolic constraints jeeves limitations jeeves currently provides only a limited amount of static checking the implementation of jeeves as a domainspecific embedded library in scala relies on scala typechecking to enforce static properties at present jeeves does not provide static feedback about more complex program properties for instance neither the jeeves design nor the implementation provide support for statically determining whether policies are consistent or total we being able to detect properties such as and inconsistency using static analysis that we can implement as a scala compiler extension there are many open questions regarding the of jeeves symbolic evaluation and smt are that have been improving in performance but it is not clear they can handle the demands of realworld applications one direction for future exploration includes scalability of jeeves programs how to efficiently handle data and development of execution models another direction for exploration involves the ease of programming and of jeeves programs related work jeeves privacy policies yield comparable expressiveness to languages for verifying system security such as fine and urweb these are static approaches that have no dynamic overhead rather than providing support for verifying properties the jeeves execution model handles policy enforcement that programs to the desired properties by construction but with dynamic overhead the jeeves runtime is similar to the data flow framework which allows the programmer to insert checking code to be executed at output channels declarative policies allow the programmer to specify policies at a higher level and allow automatic handling of dependencies between policies there are also with dynamic approaches to security and secure approach executes multiple copies of the program providing to copies that should not get access to secret inputs symbolic evaluation the need to execute multiple program copies and jeeves allows more complex policies for instance ones that may depend on sensitive values in this space is also et als dynamic approach which partitions a program into for each security level for ensuring timing and termination noninterference the focus of this is different from our work which does not address timing or termination jeeves can also be compared to aspectoriented programming existing frameworks for provide for explicit annotations at join points jeeves differs from because execution model supports more a more powerful interaction with the core program the most similar work in is logical invariants and method for generating aspect code for behavior such as error automatically method is static and involves values such as the runtime call stack in order to insert the correct code at fixed control flow points jeeves allows policies to affect control flow decisions the way jeeves handles privacy is inspired by angelic nondeterminism jeeves most directly from a constraint functional programming calculus presented by et al similar functional logic models have also been implemented in languages such as and curry our system differs in the restrictions we place on nondeterminism and the execution model j leaves functions and the theory of lists out of the logical model j execution also supports default logic to facilitate reasoning when programming with constraints our work is also related to work in executing specifications and dynamic synthesis jeeves differs from existing work in executing specifications in our goal of propagating nondeterminism the core program rather than executing isolated nondeterministic program repair approaches such as data structure repair the plan b system for dynamic contract checking and et als synthesis approach also target local program expressions conclusions our main contribution is a programming model that allows programmers to separate privacy concerns from core program functionality we present the jeeves programming language formally define the underlying constraint functional language j and prove that jeeves executions satisfy a noninterference property between low and high components of sensitive values we describe our implementation as an embedded domainspecific language in scala we also describe our case studies which illustrate how the programmer can separately develop core functionality and privacy policies while relying on the system to produce outputs consistent with the policies acknowledgments we would like to thank michael andrew myers martin rinard and for their input and feedback references g a on default logics acm computing ­ c a and c the standard version in smt workshop b b v and f http july j chen r and n typepreserving compilation of verification of security enforcement sigplan not ­ doi a static checking of security policies in applications in proceedings of the th usenix conference on operating systems design and implementation pages ­ berkeley ca usa usenix association url b and m rinard data structure repair using reasoning in proceedings of the th international conference on software engineering pages ­ new york ny usa acm isbn doi d and f noninterference through secure security and privacy ieee symposium on ­ doi r w nondeterministic algorithms j acm ­ october doi url m improving control of logic programs by using functional logic languages in proc of the th international symposium on programming language implementation and logic programming pages ­ springer lncs m h j j r and i ii curry a functional logic language g j a c c v jm and j aspectoriented programming in ecoop pages ­ e v m r and p complete functional synthesis in pldi pages ­ j r lewis j launchbury e and m b implicit parameters dynamic scoping with static types in proceedings of the th acm sigplansigact symposium on principles of programming languages popl pages ­ new york ny usa acm isbn doi url j w programming in an integrated functional and logic language journal of functional and logic programming c morgan the specification statement acm trans program lang syst ­ doi http l d and n z an efficient smt solver in in conference on tools and algorithms for the construction and analysis of systems tacas a and t a constraint functional logic language and its continuation semantics in esop proceedings of the th european symposium on programming pages ­ london uk springerverlag isbn a c myers jflow practical information flow control in in proc th acm symp on principles of programming languages popl pages ­ m odersky p v b s s n m e and m an overview of the scala programming language technical report d a k g and d specifications in oopsla companion pages ­ h e d and t d back on executable specifications in ecoop pages ­ d r smith a generative approach to aspectoriented programming in g and e editors volume of lecture notes in computer science pages ­ springer isbn d r smith aspects as invariants in o danvy h f and a editors automatic program development a to robert pages ­ z f j and t c an efficient purely declarative logic programming language in in proceedings of the computer science conference pages ­ j e with privacy issues in the journal may a x wang n and m f improving application security with data flow assertions in proceedings of the th acm symposium on operating systems principles big october h for php move fast february 