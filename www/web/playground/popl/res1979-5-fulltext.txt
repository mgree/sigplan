the evolution of algorithms and the need for structured program verification lee computer science division university of california berkeley ca p computer science division university of california berkeley ca l sciences inst way ca introduction how can one the understanding of complex algorithms people have been about this issue at least since first tried to explain his greatest common algorithm to his but for current research into verifying programs some precise answers to the question are needed over the past the various verification methods which have been introduced inductive assertions structural induction semantics etc have many basic principles of program cation which we define as establishing that a text satisfies output specifications that most published a given pair however it examples of no the application of these methods have dealt with programs of carefully considered simplicity experience indicates that these first generation principles with which one can easily verify a greatest common al do not directly enable one to verify a line operating system or even a line algorithm in complete detail to verify complex programs additional of organization analysis and manipulation are required that a similar situation exists in the writing of large correct programs has long been recognized structured programming being one solution this paper the of cor program transformations see in structuring fairly complex correctness proofs using our approach one starts with a simple highlevel or abstract algorithm which can be easily verified then refines it by implementing the abstractions of the initial algorithm to obtain various final detailed algorithms in section we introduce the technique by deriving the partially supported by nsf grant present dept univ of ta the of computer science research c also projects partially in part under contract supported by nsf grant algorithm our main ex is the more complex problem of verifying algorithms sec tion defines the issues section presents the key intermediate algorithm in detail and section considers three of the most complex published implementations of one of which is discussed in detail in section we make some general remarks on program verification and the of our results to the larger field of program correctness section some related work first list marking problem specification and the initial algorithm we wish to define list marking in general terms applicable to any particular list marking is a special implementation case of computing closure of a relation as the we let mem denote a nonempty set r denote a binary relation elements of and between z denote some element of then and define our input assertion as and the goal is to con struct the st rz defined as the smallest set m satisfying z c m a rm m interpreting mem as the finite set of all memory cells r as w b is directly reachable a a points to b and from z as the root cell of some list structure we conclude that m rz a z r mem unchanged are appropriate ab specifications of the task of construct ing the set m of all cells reachable from cell z as we use identifiers exclusively for beginning constants with let the second half of will be left implicit our initial marking algorithm is see top of next page in and throughout this paper we use rp to denote q ie those directly reachable from p note that the while assert m z loop z e m a m g rz while m c rz do select p in m satisfying rp not rp m assert m rz statement delimited by loop its invariant assertion the semantics select statement are defined as follows s includes of the p select z in s satisfying qz for predicates p and q not containing z as a free variable thus the select statement is in that any element of set s satisfying q may be assigned to z when a transformation replaces a select statement with a deterministic program segment any implementation may be chosen which meets the above semantic definition this along with implementations of abstract data structures will enable us to generate final algorithms from a common ancestor a formal proof of partial with respect to assertions is obtained by proving that for the while loop and correctness for is rz m rz both proofs of various here finite are straightforward properties of the sets trivially requiring the domain in question follows from use requires several ab properties of sets eg a e rb ra rb termination of function each iteration is proven with ml whose value the variant decreases at transformations yielding the we apply our first program transformation the reference to rz by using the transformation and the domain property to in order to remove from the loop exit test schema ts figure ab ab ra b ra we can while property change while m c rz do in to not rm m do above set ensures premise of ts is our next transformation introduces a new variable to increase the efficiency of the exit test if u for denotes a subset of m satisfying possibly rm ­ u m then only cells point to new cells not already in u can in m allowing us to ignore cells in m ­ u when eval not rm m transformation ts ts and ts see figure yields a new algorithm ma ma assert m z uz loop wh not ru m do select p in u satisfying not rp sm m m u rp u new u assert where new u satisfies maintains the invariance the premise of of ts ie we refer to ma as an algorithm for list marking that is different marking al can be obtained from ma via depending on how set u is implemented in the remainder of section we shall derive the algorithm from ma by derivations omitted here one can also obtain algorithms a b and c of from ma intermediate marking algorithms in deriving we interpret u as the set of just those cells in m with any hence u new u in ma becomes u u p u rp which satisfies the be implemented with random access eg our next algorithm the select statement premise of ts as u will a data structure not allowing a stack rather than an array ma removes the condition on ma assert mz uz loop while select p in u if not rp m then m m u rp u u p u rp else u u p fi assert where denotes the empty set and select select satisfying true p in u no that while the loop invariant is unchanged from algo rithm ma the variant function necessary to prove termination is now m u i the transformation schema used is ts as the system of basic transformation that we use has been formally presented elsewhere we discuss in what follows only the intermediate al since in this paper they and not the transformations themselves are our interest name of mation original program segment premises transformation for new program segment ts exit test replacement ts addition of loop variable ts select stint set restriction ts select stint condition elimination assert p loop b do s assert q assert p loop while b d s assert q select x in a px p pi ap ab s api v not free in pq or v doesnt appear in s y ab py assert p loop s assert q b g do assert p v eo loop ib s assert q do v a p el select x in b px assert p while bx do select x in a bx s assert q aa a ye a a by assert p loop do select x in if bx tn s else a ax fi assert q figure a few program transformation next we partition the set u into cell p currently under and all the rest denoted bv u substituting ui j p for u in ma we the new ma assert m z p z ul loop p arm ui wh not ul if not rp a rp m m then select q in rp m m u q not q e m u u u p else select p in u ui u p fi assert the set u can now be directly implemented as a stack denote by t we then separate the single while loop of ma into two inner loops each to one branch of the conditional statement to get our next algorithm top of next page in the invariant ma see t denotes the set of nodes contained in stack t our next algorithm modifies ma in two ways to avoid rp for each node pop off the stack in loop we make each stack element a pair node set of nodes and in loop push p together with its possibly des rp q onto stack t to avoid unnecessary sequences we move the exit test for the main loop so that it follows loop and unfold loop once in the following algorithm the syntax could loop equivalently a s while be expressed b do s ll s if not b then n li l goto l applying the appropriate ma figure transformations a yields implementing ma is an fo algorithms including which differ marking ma assert m z p z pz t atm p m while not a rp s m do loop while not rp m do select q in rp not q e m m m u q push pq tp loop while rp m and not p do assert in their implementation of stack type has a down phase loop pointers to nodes and loop which stack t in search of pointers obtaining from ma requires t the ­ which follows a phase nodes off to nodes making four ad specify the node structure by defining each node to contain four fields mark atom a and b for any node p is the mark bit of the node false indicates p is and pa pb contain left and pointers respectively if true then pa pb are as p is an atom since memory cells corresponding to atoms are not marked in we implement r by interpreting rp as if p then else pa if then pb the atom functions and mark fields correspond atom mark mem true to abstract false implement set m by interpreting equivalent to true p e m as implement select where rp gm q in rp satisfying by assigning not q e m if not the left link of before its the n pa a node is right link else pb followed in if possible to q thus the implement stack t as a linked list within the original list structure see applying transformations above four features produces ma figure b to ma to add the the marking al the following general observations about ma also apply to the list copying implementations of section two new types of assertions appear in the loop invariant and m y are equivalence assertions which define the correspondence between the abstract and implemented data structures note that m and t are in ma auxiliary or ghost variables as the equivalence assertions have enabled the loop tests to be expressed independently of the abstract variables we can now remove the statements in from ma and jm t the correctness with of the resulting and invariant follows from the correctness of ma by the ghost variable theorem see is a a result of the assertion defines assertion which is necessary as in stack implementation this the changes made in the original list structure which pointers are ­ and makes it possible to guarantee at termination that all pointers and atom flags have been re stored to their original values in other words see ap al for of assertions mod list copying specification and initial algorithm in a fashion similar to sec we now con struct a pair of inputoutput specifications for list copying by considering the general case of extending a relation to produce an isomorphic mapping between let elements with r as in sec s denote a subset of c denote a set disjoint from and equal in size to s and d denote a pairing of elements from s and c then we wish to extend r to u such that a o r ec x c and dx for every y in s then interpreting rc o x s as rz c as a set of i cells disjoint from the original set used for the copy of rz d as a mapping from cells in the original list structure to cells in the copy and as the set of all pointers in the new list structure we obtain a c n mem p a d rz a d is a bijection a rz a unchanged c as our general copying specifications in denotes dx x e and d is a bijection dy a ranged c we use original dx list x y structure and old cell in referring to rz and list structure and new cell to refer to assert z mem a r c mem x mm m pz loop fi m rz m a t loop while not rp c m do select q in rp not q e m m q pq loop while n ot while not select q in t do not q e m replace t with tl q pq assert m rz assert a a r ra uw atom a m x false m z true p z tp nil a m y a a p while if not then q pa or or else q pb and d o m m u q true q pa then pq z g p m while tp nil not or if then tp atom else while tp nil do q false fi m mu q true tl tq tp atom false pq assert a q rz a notation tn for nl t if empty s v else tl u a t c rtl c a figure a algorithm ma y in memory a a for c ab for f atom mark see app al for mod figure b algorithm ma although rz appears in the assertion the final copying algorithm start with only z and r given and must traverse the original graph ie construct rz in order to copy it if we assume for the moment that values of the function d are known a priori we can obtain our initial algorithm assert la lb a d a bijection m z r while m c rz do select p in m not rp m o u assert a b a rz by applying a transformation to wo in order to add the lines above in line denotes y rz ie the set of copies of edges from z speaking of the list structure as a in lines and is u y e w for w equal to m or rp respectively hence in the edges from each node y are copied is added to m encountered in the traversal as y given a verification respect to that the premises of to verify with we need only check of the applied transformation are satisfied by establishing of line and noting that the invariance a the proof of uses the same variant function as for the algorithm motivation of the three new issues but not list marking the copying relevant to list copying influence our derivation from of generating the bijection d in the final target copying algorithms a d or pairing is not supplied thus constructs a mapping which satisfies assertion this results in a structure for the and final algorithms one traversal of the graph to define a d and identify rz followed by a second traversal to do the copying specifying order the target algorithms of under a bounded only a small fixed amount of interest constraint additional to us ie storage is available to the algorithm apart from the and copy list structures as a result im the abstract data structures of and the copying will involve consider able of the original list contents which must nonetheless be to their ini tial values once the copying is complete that this is accomplished requires cation of the exact traversal order in the and to this end the algorithm de a spanning tree for the original greatly simplifying the assertions necessary for defining the traversal and copying order copying and traversal in all edges from any node p are copied simultaneously eg at line for p z in the final algorithms of section however edges pointers from a given cell are in general copied at different times this suggests an copying process for since once copying is for some edges the set m of visited nodes can no longer fully characterize how much copying has been done as it does in the assertions in pass of where the copy ing is done define the set of edges copied dependently of m and all loop tests and traversal assertions are expressed in terms of edges rather than nodes the copying in detail as section presented an extended example of the use of program trans we omit here the intermediate algorithms several of them similar to ma through ma type between figure and a is a proper pass of the extension of ma pass figure b which is derived from in dependently of pass has a very similar struc ture the additions and changes to ma re the comments of sec are discussed below bijection generation pass the assertion guarantees that the set those cells initially able for constructing the copy ­ contains a sub set which can satisfy of algorithm for each node in the original graph encountered during the pass traversal a new cell is trans from to c via a statement an abbreviation for select n in n c c un is added to the constructed bijection and the pairing h now re to as the u to distinguish it from the constant d of a new clause in the invariant bijection asserts u to be a bijection from m to c thus upon termination of pass p maps rz onto c satisfying the a bijection assertion of ­ defining the spanning tree pass the only other extension of pass beyond ma is a standard partitioning of the of the list structure into sets s and b of tree and back edges respectively as by while not all final copying implement sets s and b their presence if only as ghost variables greatly simplifies our proofs of correctness since the spanning tree defined by s is a struc assert in a t a m z p z cl n from n s to c b a rz ml a while not rp cm select q in rp do m q s s u pq n from p u pq qn to c b b u ql g while b b t ql t m do pp t while not do select p in t satisfying m m u p not p m replace t s s u n from p u pn p to c assert a a z see appendix a for bijection a pass of ture with respect to which traversal order can be statically defined eg pass traverses the spanning tree in preorder to a typical assertion from section such invariants become more complex when they must be expressed solely in terms of traversal order over a possibly cyclic and traversal pass in parallel with the notation far we now define used so r as als a et of each e a e e in r representing a directed edge from node el to node e assert et ze a ze z e ze gr ze e et a et a tt et a a a a r ze while ie ns select e ie do satisfying es et u e el e et c u et while not et et u tt do o uu pop tt while select replace e in tt satisfying top of tt with es et et u e is u assert r e notation is is u g see app a for figure b pass of i as a relation between edges defined by e is upon e or e el in terms of nodes hence i r x r and ze as an auxiliary initial edge upon node z the root thus edges out of the root of the list structure like pass i the second pass is a transitive sure algorithm it copies the set of all edges of the graph not since ze is nodes loop just of the just as as pass traverses graph pass has ma and pass do rz all the a down and a the tests in pass z ao not refer to membership in et the set of edges compare while rp m in pass but use only the tree in pass to guide traversal not spanning tree edges are copied and followed back edges are ly copied showing that this results in only un copied edges being added to et in loop hence termination requires a more complex stack tion than in pass see appendix a since edges are pushed onto the stack in pass rather than nodes we now refer to the stack as tt the below we present the as one implementation type copying algorithm of our copying overview of implementation of abstract data node structure and relation r fields other each node p considered by contains pl pr which contain either pointers nodes or the nil pointer two to rp if pl pr set m nil nil then then else else pl pr uses four pointer values ­ called flags for i which are from any pointer in the original list structure the of each original node is with one of these flags when the node is first encountered so we interpret p ie m y for i stack t implements t just as does with a linked list thus if the current node p lies in the left right subtree of some node y on the stack then the field of left right descendant in the spanning tree points back to y set obtains cells for the copy list structure from a ie heap statement n from to such as allocation so c is implemented by a to use pascal function u puts a forwarding address or which points to the corresponding new cell into the of each old cell ­ thus u u pn is implemented by pl n sets s and b uses four values to indicate which of a nodes tree or pointers pointer flags so in the of flags two fields contain nil is considered a flags valued or indicate implementation in s in s p contains p contains where pl pr denote the original a mark a mark or ­ flag or flag pointer values overview of program execution we now describe in general terms the two passes of details are covered when the in variant assertions for the algorithm are considered in sections the discussion below refers to intermediate algorithms and figures ar respectively which roughly correspond in their degree of refinement to rithm ma except that stack t remains the stack implementation appears in algorithm figure br as dis in section pass figure a as each old node p is first encountered in loop a new cell n up is obtained as in above and ps original pointer values are stored in the and fields of n fields pl and pr are then with a and flag respectively figure b illustrates this stage in the pro of p traversal then continues just as in ma with the addition that whenever a pointer in p is followed to an node the flag in pr is by one two in that ps is a tree edge no other processing eg copying is performed during pass so at its conclusion we have a defined p via the original list for every node in b classified every edge as in s or b via flags c not copied any edges and all original pointers are accessible stored in new cells exactly as in pass in addition a depth first numbering of the nodes of the original list structure is defined by means of an abstract tion called df this is an auxiliary function introduced solely to facilitate the correctness proofs ­ see section pass figure the main traversal tests of pass whether a given edge is a using the flags edge are imple in general pointers are copied in loop during phase by placing the appropriate of the cell pointed to into the copy cell see fig f the old pointer is to its original cell field at the same time thus a flag respectively is lost each time a followed pointer before is copied in loop when possible are in opposite order to pass ­ this is crucial to the success as explained in section structuring the assertions one important benefit of using the tional method of program proving is the it provides in organization of the invariant assertions that these assertions will be of length for any but the simplest of grams cannot be but this need not be to verification efforts provided assertions assert a n ma a r r u r in z p z oc c c nil nil sl s bl b xx df n from p p u pn to c p a p a p while not and d if not q s s u pq q cn p u bl bl u m df df p u bj bj u n for j m while n ot t if t then b b u while not do p t m m u p replace t with tl s s u assert a rz y for ji to v notation i u if else then true c increments in the flag into a flag fp x for any function f f denotes u px see figure a for invariants figure a algorithm a assert fz without loop loop while not and if not then s else s fs f m while gf nil qa if else then while gf nil f assert variables p q tl n see appendix in b f s gf son vp a for invariants figure b figure figure original node y contents y copy node contents a loop c d e i ir t it i y i i f xl y ie y above below pass f is pass ­ figure f of y in spanning tree i e y f first y y a second en counter y third counter a figure g indicates pass traversal figure are not thought of and produced as in firstorder predicate ic tions become much more when their struc ture clearly reflects ones understanding of the of the program which they describe we feel this is a property shared by our invariants by of their incremental construction in the context of algorithms the concept we use to the assertions needed for the final copying algorithms is node status a natural way to describe in the course of pass or pass how much processing a node has is to refer to how many times the node has been encountered thus far in the traversal since uses traversal the possibilities are o or see figure g we employ four pre to partition the nodes of the original graph referring to the abstract traversal stack t we define as y m as y t a as y t a as where m denotes m p in loop of loop for pass interpret m as z u e e and replace pass m in t with tt see appendix t pushed onto a is the t along given that node y is on stack t set of nodes in pass edges with y thus intuitively is true just when y has been encountered in the sense n times all of the new invariant clauses for the algorithm not present in are of the form this format for the tions the description of exactly how first builds up in pass then in pass its in related abstractions implementations u s and b of the im of ma in contrast only the invariant mod is needed to define the of the single im of stack t which must be removed before termination of the algorithm on verifying pass the invariant clauses for passes and of appear in tabular form in figures a b re this figure is read as the predicate beginning each row implies the tion of all the entries in that row each a single assertion of one of the column types equivalence introduced in section thus reading across a row defines the state of er illustrates all nodes reading down column the stages that say flags go through in a given pass note in particular that since at the end of pass every node in rz is node obvious since by the exit test holds and also m rz an old by now across the bottom row of figure a yields the copying part of the pass a output assertion as every node of the graph at the start of pass by definition the top line of figure ki is identical the bottom line of figure a ie as desired is of to for the most part the copying assertions col through v for pass of simply figures says pointer values are stored in the corresponding copy cell we use the constant zy zy for the original values of node y rather than rb as in the assertions as a that the pointer relations are subsets of mem x u nil and extensions of r c mem x this is why is used to de the pointer value of a copy node y rather than o r as in gi is used to refer to current pointer values in the original list struc ture similarly to of note that if for example both of ps pointers are nil loop of the implemented algorithm is this is one case of the abstract condition rp m since rp as defined in is empty when pl pr nil of the four remaining equivalence assertions and iii are the assertion how the information content of the flag increases as first a nodes then are examined during pass traversal and the assertion defines the possible values of the flags for each group this assertion is needed in pass since the flags value is each time a tree edge is dis covered it is unnecessary in pass and does not appear in figure b the need for availability assertions we use the term availability assertions in referring to pass s equivalence assertions to indicate the role by these invariant clauses in establishing the correctness of the second pass the need for these invariants is a straightforward consequence of the constraint on the algorithm since and flags are removed during pass our assertions must be strong enough to prove that at every ap of a the necessary or e e s in algorithm or flag is still present availability assertions are unnecessary for the copying since in the abstract data structures p s and b are present throughout the course of the algorithm note also that in the implementation of algorithm ma availability assertions are not used because stack t can only be accessed through the variable tp cf comments made about ma there is however no simple tion on when any given nodes or flag will be needed in pass thus s and b are represented as sets in and must be implemented as approximately data structures the next section explains using availability as the precise extent of that approximation on verifying pass note that edge e in the we write p and nodes respectively instead of referring traversal as in q in for the of e to a current pass of head and tail assert nil z p l l while ep ns do if ep s et et see app a else u p q p et ep p v u p a while not if tt fi u pop tt while g u q replace tt assert y g rz jy a y uj y notation each assignment if then stint s containing aj denotes s s figure algorithm the first is written component of each stack as a node element in this essentially notational change in stack tt is made in order to simplify the implementation as since in it is more convenient to think of implementation values etc as stored in the current node rather than in the head of the current edge recall that in pass of nodes are not mentioned to emphasize that rj m rl i s r w rl r ir i m i w o w r n g the transitive tion is being closure copied of the rela in algorithm loop tests and assignment statement right hand sides are still expressed ab the next transformation to be applied will replace ep i s with r p p with p below the intermediate etc in the dis algorithm referred to may be either or its successor due to lack of space the availability omitted tions for the two are the same flag availability every implementation of an e s test in pass marked by in figure is applied to edge from either a node node p at l a node node in statement since the test is only made if tt thus by the availability assertion which could be as an or v is a valid the implemented version of the test is correct the invariance of is an immediate consequence of the fact that the only edge possibly copied in loop going down is the of a node y if it has one after which y is a or node depending on whether or not ys is found to be a tree edge availability here the assertions edge e is copied by that the needed or must imply that when any a statement marked in for e ­ ie is available for tree edges this is accomplished by using in loop an extra variable son along with a corresponding invariant clause stating that stores the of the node up from which we are returning since all tree edges are copied in phase and each node a unique tree ancestor the single variable suffices for back edges the case is more complex as arbitrary number of back edges from any node in the list may point to a given node y as the assertion states an v v we may indirectly demonstrate by establishing the validity of lie eb e y where oc denotes the set u of edges in the copy list structure the invariance of is a consequence of pass s traversing the list struc ture in reverse order before from pass a detailed argument of s invariance is greatly by the presence of df and the depthfirst assertion see appendix a which enable a simple case argument omitted here for lack of space to be made note that we certainly do not claim the above discussions to be proofs of the invariance of or assertion above they are intuitive arguments to that end in this we emphasize the construction and nature merely article of the invariant assertions themselves and have omitted formal proofs of their invariance for that reason this article should not be to be an of formal verification rather an on some methods useful formal verification see section but in the final transformations applying a transformation to algorithm to implement stack t just as with the transformation yields figure b in which we to original variable names the correspondence with ables is noted in the table is done both to facilitate comparison with the program as originally presented in and because are more once the stack is introduced given the assertions of together with some elementary path analysis one can then apply to the final transformation obtaining pass of the algorithm exactly as originally presented that version approximately the relationship to that ma has to ma since each pass of program is written as a conditional statement within a single while loop pass of the program is obtained from via an identical sequence of transformations beyond the algorithm one advantage of the copying algorithm is its to any system of al location in some applications this is an consideration if in the presence of collection say all free cells must be or as a however more efficient algorithms can be obtained by implementing storage pool by means of a region of memory addressed by values greater than for example this minor implementation re has a significant effect on the of the resulting algorithms as it eliminates the need for traversal flags forwarding are as pointers whose values and thus by their presence mark vi cells the extra made available by this double use of the forwarding addresses is in two ways all copying need no longer be consider figure b once the mark flag becomes unnecessary only the nodes must be saved in the copy cell thus one new pointer for the copy list structure can now be inserted in pass different types of traversal may be used as follows the copying algorithm pre in can be from algorithm by a derivation which at the transformation corresponding to the one producing algorithm ma in section the set u of cells containing pointers than as a stack subsequent as a queue transformations rather then the copy region as an array order to implement the traversal queue the in principal intermediate algorithm in this derivation is apart from its use of a queue essentially the same as the from is the current algorithm in terms of execution up to time as its its derivation and including the traversal method is that of algorithm however in subsequent refinements both pointers of the current node are always examined in loop only those nodes containing two tree edges are pushed onto the stack thus up traversal of the original list structure our unpublished work on the and algorithms adds support to the the refinement approach is particularly when verifying a family of related algorithms in the of program correctness research we think it important to present some personal by program correctness we mean establishing that a given program does what we want it to do or more precisely increasing our that a given program does what we want it to do this is the desired end which can be by a variety of means there are empirical methods such as pro gram testing by which we increase our in a programs behavior since this increase results from an inductive inference based on a particular experimental result testing by itself is not the solution to of program correctness testing cannot detect the absence of bugs only their presence as the goes there are logical methods such as program verification which either formal or in formal arguments that a program does what we in tend the advantage of an informal method is that is deals directly with our intuitive notions of what the program should however a analysis cannot take full advantage of cur logical techniques of program verification such as fixedpoint induction or our transformation al approach once we express our arguments com within a formal system eg predicate calculus however we face the problem of our original as to what we want the program to do into precise formal specifications this problem of formal specification of realworld programs is a concern separate from the issues which we address in the current article despite our about the progress being made by others and ourselves in the area of proofs of large pro grams we grant that further progress in formal specification techniques is necessary before the if ever that formal verification alone can claim to solve the problem of program correctness conclusion related work conclusion we see our version method as making three of the contributions as presented in this paper it can be used as an aid to informal verification sections and argue the correctness of the final copying algorithm by using our framework of and implementations to the invariance of the loop assertions that reasoning does not formally verify the algorithm but we feel that an algo rithm in terms of its highlevel structure is a more effective way of of the algorithms correctness than is considering only the final program text also the use of algorithms reduces the complexity and hence increases the of the individual components of the correctness argument the axiomatic definition of our trans formation as presented in full in es the property of the transformations ­ thus the correctness of al ma is a function solely of the validity of the application of the transformations used in its derivation and the correctness of our initial algorithm this fact may be used to for verify ma without ever having to establish the invariance of any loop as except that of the initial algorithm in verifying large programs this may be an easier approach than the traditional method of proving in one the invariance of the final extremely complex loop assertion any formal verification should closely reflect ones understanding of why an algorithm works our methodology both reflects and supports that and provides another counterexample to and hence commonly held that there is an between and for on the one hand and on the other as dijkstra says in related work while in this summary of our initial efforts with algorithms we have in terms of program transformations than those described in this larger scale is particularly important when the intermediate al are first formulated for complex programs considers some program transformations defined in terms of an algebra of binary relations and uses them to de a small but square root al was the first to prove correctness of the algorithm was among the first to apply the refinement tech to verifying algorithms ­ see and for an alternate more formal definition of the abstractions of section various implementations of an abstract back tracking algorithm are considered by and in the very elegant program trans formation work of burstall and in is comparable in spirit to our approach however their technique appears best suited to algorithms processing recursive data structures such as trees in a simple applicative framework the imperative manipulation features required to handle pointer and a more complex memory formalism obtained in our method by starting out with an abstract memory tion cf the o function of algorithm and then implementing it in later transformations de in presents proofs of correct ness both least and greatest fixed point techniques of a group of traversal and backtracking algorithms including that of and focuses on the similarity in their proofs without using trans see for termination the algorithms it was the attempt work to some difficult which out the importance of explicitly structured techniques of paper proofs for to extend algorithms using the the current this s we wish to thank the university of for its support of the tional involved in the writing of this paper the especially e w dijkstra provided many valuable comments on an earlier version of this paper thanks also to and for their typing and to for support discussion of assertions appendix omitted for lack of space al alg ma v u t def if then then else u else if fi a a ab a y gw c where w a a s v g et a where a ie fl a for a e a sb a alg z a a vt a a a a same where i in is replaced by by ii are identical to assertions in app al a alg v get a net et a net a a et a where a invariants z y cm y stk a e y g stk a y cm stk m stk mp t z ue and where in pass tt in pass else depthfirst e a a v where w m rz and sq is the set of nodes the subtree rooted at the node q including q a sc uc in loops and respectively in references a towards mathematical structured programming in formal of concepts ej cd northholland co burstall rm formation system for jacm jan and j developing recursive pp a structures a fast algorithm cacm may for copying pp list dijkstra of a concurrent june ew finding the correctness proc van amsterdam pp proof a da copying cyclic list in linear time using bounded may pp structures cacm transformations alto sl proc second popl pp symp program palo sl verification sept pp proof theory systems of partial cor siam j comp sl two proof of program correctness techniques for trans sl ture abstractions technique proc san francisco and l of the backtracking second intl conf oct control struc programming on software vol knuth de section the art of algorithms computer addisonwesley copying cyclic pp jm a bounded storage algorithm structures cacm june for in languages springerverlag wp on backtracking and greatest oc fourth int conf o and a cd ation report university of wp an on dept trees and comp sci h and procedure for tion in various list structures pp an efficient garbage aug list marking artificial r correctness of the algorithm memo school of intelligence univ of edinburgh instantiations proc symp on lang sigplan l and ag abstractions and proofs of marking algorithms artificial intelligence and prog aug pp 