predicate abstraction and refinement for verifying multithreaded programs gupta rybalchenko germany abstract automated verification of multithreaded programs requires explicit identification of the between interacting threads socalled environment transitions to enable scalable compositional reasoning once the environment transitions are identified we can prove program properties by considering each program thread in isolation as the environment transitions keep track of the interleaving with other threads finding adequate environment transitions that are sufficiently precise to yield results and yet do not the verifier with unnecessary details about the interleaving with other threads is a major challenge in this paper we propose a method for safety verification of multithreaded programs that applies transition predicate discovery of environment transitions a minimal amount of information about the thread interleaving the of our method is an abstraction refinement procedure that uses horn clauses to state abstraction refinement queries then the queries are resolved by a corresponding constraint solving algorithm we present preliminary experimental results for mutual exclusion protocols and multithreaded device drivers categories and subject descriptors d software engineering verification f logics and meanings of programs specifying and verifying and reasoning about programs general terms algorithms languages reliability verification keywords multithreaded programs safety proof rule modular reasoning environment transitions transition predicate abstraction abstraction refinement horn clauses introduction the availability of parallel computing by the of architectures requires a shift towards multithreaded programming to take full advantage of the available computing resources writing correct multithreaded software is a difficult task as the programmer needs to keep track of a very large number of possible interactions between the program threads automated program analysis and verification tools permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission andor a fee popl january ­ austin texas usa copyright c acm can support programmer in dealing with this challenge by systematically and exploring program behaviours and checking their correctness direct treatment of all possible thread interleavings by reasoning about the program globally is a expensive task even for small programs by applying relyguarantee techniques see eg such global reasoning can be avoided by considering each program thread in isolation using environment transitions to summarize the effect of executing other threads and applying them on the thread at hand the success of such an approach depends on the ability to automatically discover environment transitions that are precise enough to a outcome and yet do not keep track of unnecessary details in order to avoid efficiency in this paper we present a method that relyguarantee reasoning for verifying safety of multithreaded programs our method relies on an automated discovery of environment transitions using transition predicate abstraction it performs a predicate reachability computation for each thread and it with the construction of environment transitions that the effect of executing thread transitions using transition predicates the success of our method depends on an abstraction refinement procedure that transition predicates the refinement procedure attempts to minimize the amount of details that are exposed by the environment transitions in order to avoid unnecessary details about thread interaction the of our refinement approach is in using a declarative formulation of the abstraction refinement algorithm that can deal with the thread reachability environment transitions and their mutual dependencies we use horn clauses to describe constraints on the desired transition predicates and solve these constraints using a general algorithm for horn clauses our formalization can accommodate additional requirements that express the preference for modular predicates that do not refer to the local variables of environment threads together with the preference for modular transition predicates that only deal with global variables and their versions we implemented the proposed method in a verification tool for multithreaded programs and applied it on a range of benchmarks which includes fragments of open source software mutual exclusion protocols and multithreaded linux device drivers the results of the experimental evaluation indicate that our declarative abstraction refinement approach can be effective in finding adequate environment transitions for the verification of multithreaded programs this paper makes the following contributions the automatic relyguarantee based method for verifying multithreaded programs using transition predicate abstraction the novel formulation of abstraction refinement schemes using horn clauses and its application for the transition abstraction discovery for multithreaded programs the algorithm for solving horn clauses over linear arithmetic constraints the prototype implementation and its evaluation the rest of the paper is organized as follows first we illustrate our method in section in section we present necessary definitions section presents a proof rule that provides a basis for our method and shows how the proof rule can be automated using the connection to fixpoints and abstraction techniques we present the main algorithm in section section focuses on the abstraction refinement using horn clauses while section presents a constraint solving algorithm for horn clauses over linear inequalities we discuss the experimental evaluation in section related work is presented in section illustration in this section we illustrate our algorithm using two multithreaded examples the first example does not have a modular proof hence our algorithm reasons about relationship between the local variables of different threads for the second example our algorithm succeeds in finding a modular proof by applying an abstraction refinement procedure that guarantees the discovery of a modular abstraction whenever it exists example see figure for the program that consists of two threads the threads attempt to access a critical section and their accesses using a global variable lock we assume that initially the lock is not taken ie lock and that the locking statement until the lock is released and then assigns the value of its second parameter to lock thus taking the lock we write v lock pc pc for the program variables where pc and pc are local program counter variables of the first and second thread respectively we start by representing the program using assertions init and err over program variables that describe the initial and error states of the program together with assertions over and program variables and that describe the transition relations for program statements init pc a pc p lock err pc b pc q lock lock pc a pc b pc pc lock lock pc p pc q pc pc the auxiliary assertions and state that the local variable of the first and second thread respectively is preserved during the transition to verify our algorithm computes a sequence of abstract reachability and environment trees each tree computation amounts to a combination of i a standard abstract reachability computation that is performed for each thread and is called thread reachability and ii a construction and application of environment transitions abstract states represent sets of concrete program states while environment transitions are binary relations of program states thread a b critical thread p q critical figure example program each thread until the lock is released and then assigns the integer to lock m m a n n m m e m b n n e n m n e e m m n n c figure reachability trees constructed using different abstraction functions edges are labeled with a transition nodes with gray background represent spurious error tuples m n from a and m n from b no pair of states from c err first computation the thread reachability computation for the first thread starts by computing an abstraction of the initial program states init here we use an abstraction function where the dot indicates that this function sets of program states and not sets of pairs of states as will take place later and the index indicates that this abstraction function is used for the first thread in this example we assume that the abstraction function only tracks the value of the program counter of the first thread ie p pc a pc b and is computed as follows s p p v s p we obtain the initial abstract state m as follows m init pc a next we compute an abstract successor of m with respect to the transition using the strongest postcondition operator post that is combined with m post m pc b similarly we compute the thread reachability for the second thread using predicates over the program counter of the second thread ie p pc p pc q we compute the following two abstract states n init pc p n post n pc q for each thread we the computed abstract states in a tree see figure a we stop the computation since we discover that the error states overlap with the intersection of the abstract state m from the thread reachability of the first thread and n from the second thread ie m n err is satisfiable first abstraction refinement we treat the pair m and n as a possible evidence that the error states of the program can be reached yet we cannot assert that the program is incorrect since abstraction was involved when computing m and n we check if the discovered evidence is spurious by a constraint that is satisfiable if and only if the abstraction can be refined to the for each abstract state involved in the reachability of and including m and n we create an unknown predicate that denotes a set of program states we obtain mv nv mv and nv which correspond to m n m and n respectively then we record the relation between the unknown predicates using constraints in the form of horn clauses for example since m was an abstraction of the initial program states we require that mv init as well and represent this requirement by a horn clause init mv as a result we obtain the following set of clauses hc init mv mv mv init nv nv nv mv nv err false the last clause in hc requires that the intersection of the refined versions of the abstract states m and n is disjoint from the error states of the program we check if the conjunction of the clauses in hc is satisfiable using a algorithm presented in section presents an algorithm for solving horn clauses over linear inequalities we obtain the following satisfying assignment sol that maps each unknown predicate to an assertion of the program variables pc p pc a pc p pc a the existence of sol indicates that the discovered evidence is spurious we use sol to refine the abstraction functions and hence eliminate the source of we collect the predicates that appear in the solution for abstract states from the first thread add them to the sets of predicates p and perform a similar step for the second thread the resulting sets of predicates are shown below p pc a pc b pc p p pc p pc q pc a they guarantee that the same will not appear during subsequent computations second computation we the computation using the previously discovered predicates figure b shows the two trees computed with the refined abstraction functions where m pc a pc p n pc a pc p m pc b pc p n pc a pc q due to the first abstraction refinement step m n err is unsatisfiable the thread reachability computation for each thread does not discover any further abstract states the computation proceeds by considering interleaving of the transitions from one thread with the transitions from the other thread we account for thread interleaving by constructing and applying environment transitions first we construct an environment transition e that records the effect of applying on m in the first thread on the thread reachability in the second thread this effect is by using an abstraction function ¨ in this function the double dot indicates that the function abstracts binary relations over states and not sets of states the index indicates that this function is applied to abstract effect of the first thread on the second thread initially we use the empty set of transition predicates over pairs of states to define ¨ the environment transition e is defined as e ¨ m true and it nondeterministically updates the program variables since true does not impose any restrictions on the successor states of the transition next we add e to the transitions of the second thread then its thread reachability computation uses e during the abstract successor computation and creates an abstract state n by applying e on n as follows n post e n pc q the conjunct ensures that the local variable of the second thread is not changed by the environment transition we use a function ¨ to abstract the effect of applying transitions in the second thread on the thread reachability of the first thread the application of on n results in the environment transition e such that e ¨ n true we apply e to contribute an abstract successor m of the abstract state m to the thread reachability of the first thread m post e m pc b we observe that the intersection of the abstract states m and n contains a nonempty set of error states ie m n err is satisfiable thus a possible evidence for second abstraction refinement similarly to the first abstraction refinement step we construct a set of horn clauses hc to check if the discovered evidence is spurious we consider predicates mv nv mv nv mv and nv that represent unknown sets of program states together with ev v and ev v that represent unknown binary relations over program states hc init mv mv mv init nv nv nv mv ev v nv ev v nv nv ev v mv ev v mv mv nv err false the conjunction of clauses in hc is satisfiable we obtain the following satisfying assignment sol true true false false lock lock v lock v lock this solution mv and nv to states where the lock is held lock while the environment transitions ev v and ev v are applicable only in states for which the lock is not held by the respective thread lock we add the transition predicates that appear in the environment transition e of the first thread to the set and we add the predicates from e to for the next thread a b critical thread p q critical figure example program computation we have the following set of predicates p pc a pc b pc p lock p pc p pc q pc a lock lock lock last computation we perform another computation and a subsequent abstraction refinement step we add the predicate lock to both and and proceed with the final computation figure c shows the resulting trees the application of thread transitions produces the following abstract states and environment transitions m init pc a pc p n init pc a pc p m post m pc b pc p lock n post n pc a pc q lock e ¨ m lock lock e ¨ n lock lock the environment transitions e and e produce the abstract states m and n whose intersection does not contain any error states m post e m pc a lock n post e n pc p lock neither thread nor environment transitions can be applied from the abstract states m and n while no further abstract states are found since each pair of abstract states from different threads yields an intersection that is disjoint from the error states we conclude that is safe the labeling of the computed trees can be directly used to construct a safety proof for as sections and will show example our second example shown in figure is a variation of uses an integer variable lock instead of a single bit to record which thread holds the lock due to this additional information recorded in the global variable the example has a modular proof which does not refer to any local variables we show how our algorithm such a proof by only modular predicates in the abstraction refinement step differs from in its transition relation lock lock pc p pc q first computation similarly to we discover that m n err is satisfiable and compute the following set of horn clauses hc init mv mv mv init nv nv nv mv nv err false one possible satisfying assignment sol is pc p pc a pc p pc a m n m n figure tree that shows all the reachable abstract states found during the last computation for this assignment uses a predicate pc p over the local variable of the second thread as a solution for the abstract state mv in the thread reachability of the first thread by collecting and using the corresponding predicates we will discover a proof to avoid the of proofs our algorithm does not use hc and attempts to find modular predicates for abstraction refinement instead we express the preference for modular predicates using a set of horn clauses in which the unknown predicates are restricted to the desired variables as described in sections for the abstract states in the first thread we require that the corresponding solutions are over the global variable lock and the local variable pc of the first thread ie we have the unknown predicates pc and pc similarly for the second thread we obtain pc and pc instead of hc we use a set of horn clauses hc shown below hc init pc pc pc init pc pc pc pc pc err false the conjunction of clauses from hc can be satisfied by an assignment sol such that pc true pc lock pc true pc lock which contains only modular predicates last computation we present the last computation for which uses on the following transition predicates collected so far p pc a pc b lock p pc p pc q lock lock lock figure shows the resulting abstract reachability and environment trees constructed as follows m init pc a n init pc p m post m pc b lock n post n pc q lock e ¨ m lock e ¨ n lock the construction is completed since post e m m post e m false post e n n post e n false by pairs of abstract states from different trees we conclude that is safe furthermore no predicate in p refers to the local variable of the second thread the symmetric condition holds for p and the predicates in as well as do not refer to any local variables thus from the trees in figure we can construct a modular safety proof in this section we briefly describe multithreaded programs their computations and correctness we also introduce auxiliary definitions that we apply for reasoning about programs programs we consider a multithreaded program p that consists of n concurrent threads let n be the set n we assume that the program variables v vg v vn are partitioned into global variables vg that are shared by all threads and local variables v vn that are only accessible by the threads n respectively the set of global states g consists of the valuations of global variables and the sets of local states l ln consist of the valuations of the local variables of respective threads by taking the product of the global and local state spaces we obtain the set of program states g × l × · · · × ln we represent sets of program states using assertions over program variables binary relations between sets of program states are represented using assertions over and variables let denote the satisfaction relation between pairs of states and assertions the set of initial program states is denoted by init and the set of error states is denoted by err for each thread i n we have a finite set of transition relations ti which are abbreviated as transitions each transition ti can change the values of the global variables and the local variables of the thread i let i be a constraint requiring that the local variables of the thread i do not change ie i vi vi then ti has the form vi vg vi j where the first conjunct represents the update of the variables in the scope of the thread i and the remaining conjuncts ensure that the local variables of other threads do not change we write i for the union of the transitions of the thread i ie i ti the transition relation of the program is t · · · n computations a computation of p is a sequence of program states s s such that s is an initial state ie s init and each pair of consecutive states si and si in the sequence is connected by some transition from a program thread ie si si a path is a sequence of transitions we write for the empty sequence let be a substitution function such that replaces w by z in let be the relational composition function for binary relations given by assertions over and variables such that for assertions and we have v v v v v then a path relation is a relational composition of transition relations along the path ie for · · · n we have n a path is feasible if its path relation is not empty ie v v a program state is reachable if it appears in some computation let reach denote the set of reachable states the program is safe if none of its error states is reachable ie reach err false for assertions r rn over v and e en over v and v cs cs cs cs cs init ri ri i ri ei i ri ri inj ri i ej r · · · rn err false for i n for i n for i n for j n program p is safe figure proof rule for compositional safety proofs of multithreaded programs ri stands for v yields a characterization through equations auxiliary definitions we define a successor function post such that for a binary relation over states and a set of states we have post v v v v v v v we also extend the logical implication to tuples of equal length ie n n · · · n n where each implication is implicitly universally quantified over the free variables occurring in it from now on we assume that tuples of assertions are partially ordered by the above extension of a horn clause bw · · · bw consists of relation symbols b bn b and vectors of variables w wn w for the algorithm in section we only consider horn clauses over linear arithmetic we say that b depends on the relation symbols bi i n bi a set of horn clauses is if the transitive closure of the corresponding dependency relation is well proof rule fixpoints and abstraction in this section we develop the foundations for our verification algorithm we present a compositional proof rule and then derive a corresponding characterization in terms of least fixpoints and their approximations we present the ability of our proof rule to facilitate modular reasoning when by the program without the ability for global reasoning otherwise proof rule figure presents a proof rule for compositional verification of program safety the proof rule is inspired by the existing proof rules for compositional safety reasoning see eg our formulation of directly leads to a characterization thus providing a basis for the proof rule automation using abstraction and refinement techniques relies on thread reachability assertions r rn that keep track of program states reached by threads n together with their respective environment transitions e en the environment transition of each thread keeps track of modifications of program states by other threads the auxiliary assertions used in our proof rule can refer to all program variables that is they are not restricted to a combination of global variables and local variables of a particular thread if the provided auxiliary assertions satisfy all premises of the proof rule ie cs cs then the program is safe the premise cs requires that each thread reachability the initial program states cs ensures that the thread reachability of each thread is invariant under the application of the thread transitions in addition cs requires invariance under the environment transitions of the thread the conjunct i in cs se the subset of the environment transition that does not modify the local variables of the thread given a thread j the premise cs collects transitions that start from states in the thread reachability of other threads and combines them into the environment transition for j finally cs checks that there is no error state that appears in each thread reachability set the proof rule can be directly used to prove program safety following a procedure first we need to identify candidate assertions for the thread reachability and environment transitions second we need to check that these candidate assertions satisfy the premises of proof rule the correctness of the conclusion is formalized by the following theorems theorem soundness the proof rule is sound proof let r rn and e en satisfy the premises cs cs we show that the program is safe to prove safety for each reachable state s reach we prove that s r · · · rn by induction over the length k of a shortest computation segment s sk such that s init and sk s for the base case k the inclusion holds due to the premise cs for the induction step we assume that the above statement holds for states reachable in k steps and prove the statement for their immediate successors that is let sk reach and hence sk r · · · rn if sk does not have any successor ie sk sk t then there are no more states to consider otherwise we choose a successor state sk of sk that is reached by taking a transition in a thread i ie sk sk i from cs follows that sk ri to show that sk rj for each j n i we rely on the premises cs and cs by induction hypothesis sk ri and due to cs we have sk sk ej now sk rj follows from cs theorem relative completeness the proof rule is complete relative to firstorder reasoning proof let p be safe we define r · · · rn reach and e · · · en reach t then the premises cs cs are immediately satisfied modular and global proofs reasoning about multithreaded program is more complex than reasoning about sequential programs since thread interaction needs to be taken into account some programs admit modular reasoning that deals with each thread in isolation ie assertions used in the proof only refer to the global variables and the local variables of one thread at a time the proof rule modular reasoning about multithreaded programs if a program has a modular safety proof then the following modular assertions satisfy the proof rule premises ri v vg vi reach ei v v vg vg reach t for i n for i n is not restricted to modular proofs since the assertions used in can refer to each of the program variables proofs can be directly used in fact the proof of theorem relies on assertions since reach may refer to local variables of different threads in section we will present our algorithm that can discover modular assertions for if the program admits modular proofs and assertions otherwise fixpoints the proof rule in figure directly leads to a characterization which defines our algorithm in section from the premises cs cs and cs we obtain a function f on of assertions over the program variables and of assertions over the and program variables such that f s sn t tn post t s post n tn n sn in si i si i we formalize the relation between f and as follows lemma each of f satisfies the premises cs cs and cs of that is if f r rn e en r rn e en then r rn e en satisfies cs cs and cs we define a distinguished tuple f f init init false false n times then each of f that is greater than f satisfies the premise cs by choosing a r rn e en above f such that r rn err false we will satisfy all premises of the proof rule and hence prove the program safety fixpoint abstraction computing of f that satisfy cs and cs is a difficult task we this computation using the framework of abstract interpretation which uses overapproximation to a balance between reasoning precision and efficiency to implement required overapproximation functions we will use a collection of abstraction functions i and j where i j n that sets and binary relations over programs states respectively we define a function f that f using given abstraction functions f s sn t tn post s post t s ··· n sn tn n sn in si i ··· i let f be an overapproximation of f such that f init false false n times the least of f above f can be used to prove program safety by applying the following theorem and is the key outcome of our algorithm in section theorem abstract fixpoint checking if the least of f above f say r rn e en satisfies the premise cs then the program is safe proof the theorem follows directly from the soundness of the proof rule lemma and introduced by the applied abstraction functions function main input p program with n threads vars pi i predicates for thread i and corresponding state abstraction function j j transition predicates for pair of threads i j and corresponding transition abstraction function ri abstract states of thread i ei abstract environment transitions of thread i parent parent function for abstract states and environment transitions parent thread function for abstract states and environment transitions begin for each i j n do pi j repeat for each i j n do i s p pi v s p j t j v v t if exists s r sn rn such that v s · · · sn err then try refines sn with unsatisfiable d some si from s sn return counterexample else return program p is safe with the proof r rn e en until true end figure function main for verifying safety of the multithreaded program p the choice of the abstract domains ie the range sets of the abstraction functions determines if the least fixpoint of f yields a modular proof our abstraction discovery algorithm in section automatically chooses the abstraction such that modular proofs are thread reachability and environment transitions in this section we present our relyguarantee based verification algorithm for proving safety properties of multithreaded programs the algorithm is based on theorem and consists of three main steps the first step computes for each thread a tree that is by abstract states and environment transitions socalled and analyses the discovered abstract states if an intersection with the error states of the program is found then the second step generates a set of corresponding horn clauses see section at the third step we solve the constraint defined by the conjunction of the generated horn clauses and use the solutions to the refine the abstraction functions used for the computation see section procedure begin parent the empty function for each i n do ri ei repeat finished true for each i n and s ri do states for each ti ei do s if ti then s else i s if ri v s s then ri s ri parents s s i finished false done environment transitions for each ti and j n i do js if ¬ tj ej v v then ej ej parent s i finished false done done until finished end figure procedure implements computation we assume that the iterator statements in lines and make an immutable of their domains ri and ei respectively for example this implies that each addition of s in line is in line until the next iteration of the repeat loop function main the main function of our algorithm main is shown in figure main takes as input the multithreaded program p the repeat loop iterates through the three main steps of the algorithm first we construct the abstraction functions i and j at lines ­ from a given set of transition predicates which is empty initially next the computation is performed in line using these abstraction functions in lines ­ the abstract states in the computed are analyzed wrt the safety property in case of a positive outcome of this check main constructs and returns a safety proof in lines ­ if the safety check fails then refine is executed on the abstract states if refine terminates normally and hence succeeds in eliminating the violation by refining the abstraction functions then main continues with the next iteration of the repeat loop in case an unsatisfiable exception is from figure constructs a counterexample path that we report to the user procedure see figure for the procedure that implements computation using the abstraction functions i and j we use parent and to maintain information about the constructed trees and initialize function input d abstract state begin match with s match parent with o o return · o return · return the empty sequence end figure function takes as input an abstract state d and returns a sequence of transitions that lead to d them with the empty function in line ri and ei keep track of abstract states and environment transitions for a thread i n ei is initialized to an empty set in line while ri contains the abstraction of the initial program states computed for the thread i the computation is performed iteratively in the repeat loop see lines ­ the first part of the loop see lines ­ implements a standard least fixpoint computation over reachable states at line the algorithm an already reachable states s ri in order to compute its abstract successors after computing at lines ­ one successor of s line implements a fixpoint check which succeeds if s contains program states that have not been reached yet the new states reachable in thread i are stored in ri at line the function parent is updated to keep track of the relation between abstract states while maps the new reachable state to its parent thread the second part of the loop see lines ­ performs a least fixpoint computation over environment transitions each time a transition from a thread i is at line the abstraction of its effect computed in line is propagated to each other thread j note however that the propagation only happens for environment transitions that are not subsumed by the existing ones which is checked in line additional environment transitions are recorded in line environment transitions are taken into consideration when computing abstract state reachability see line upon termination which is guaranteed by the of our abstract domains the function computes sets of abstract states r rn and sets of environment transitions e en abstraction refinement procedure refine in figure we present the procedure refine that takes as argument an error tuple and if possible refines the abstraction functions to include predicates that witness the fact that the error state is unreachable the procedure refine generates a set of horn clauses corresponding to the error tuple lines ­ next the refine algorithm invokes a solving procedure for horn clauses lines ­ the procedure refine updates the abstraction functions using the solution of horn clauses at lines ­ we consider the solution sol and add the atomic predicates that appear in to the set of predicates pi the index i is chosen to be that of the thread where s from similarly the procedure updates the transition abstraction functions at line here we only assume that returns a correct solution to the set of horn clauses received as argument in procedure refine input s sn abstract error tuple begin hc sv · · · err false sol sv i n s ri v v i n ei for each i n and s ri do pi pi for each j n and ej do i j v j end figure procedure refine the function · creates a relation symbol from a given abstract transition the function extracts atomic predicates from the solutions to the set of horn clauses hc function input d abstract state begin i d return match with s begin match parent with o o o v v sv v v i dv sv dv end init dv end figure function section we present a solving algorithm for horn clauses over the linear arithmetic domain function the generation of the horn clauses is started from lines ­ of figure one clause requires that the solutions corresponding to the abstract states from the error tuple do not err sv · · · err false the other clauses are generated by invoking for i n the function generates horn clauses for transitions considered during computation as follows if the abstract state d was produced by following a local transition ie vi o vg vg vi vg vg i vi vi vi end init vi figure modifications to to admit only modular solutions thread x cnt a b critical thread p q critical init pc x pc p lock cnt pc pc cnt cnt pc pc pc x pc a lock lock cnt cnt cnt pc a pc b lock lock cnt cnt pc p pc q lock lock err pc b pc q figure is an expanded version of the program s and parent then one horn clause corresponds to the application of the local transition at line sv dv additional horn clauses are generated recursively for the parent state s at line if the abstract state d was produced by following an environment transition ie s and parent o o then two horn clauses correspond to the generation of the environment transition line and to the application of the environment transition line finally if then one horn clause the solution of dv at line init dv note that solutions for unknown states are expressed in terms of all program variables v while solutions for unknown transitions are expressed in terms of v and v consequently these solutions may lead to proofs even for a set of horn clauses that has modular solutions discovery of modular predicates we present modifications to our abstraction refinement algorithm that guarantee the discovery of modular solutions whenever they exist with these modifications solutions for unknown states in thread i can only be expressed in terms of vg vi rather than the whole set of program variables v solutions for unknown transitions are restricted to the set of global variables vg vg to implement these changes we change line from the refine procedure as follows hc v · · · vn err we also replace lines ­ from with the fragment shown in figure the rest of the function is unchanged if the resulting horn clauses have no so ie an unsatisfiable exception then it may still be possible that a solution exists in this case we invoke the abstraction refinement once again this time generating horn clauses using the function from figure example we illustrate the generation of horn clauses using an expanded version of shown in figure this example contains an additional variable cnt local to the first thread the initial symbolic state of the program init both cnt and lock to the value the transition relation of the first thread is extended with which increments cnt by and assumes that the value is greater than or equal to similar to the example from section err encodes the violation of the mutual exclusion property we show in figure a the reachability trees as computed by the computation the error tuple consists of m and n ie m n err is satisfiable from this error tuple generates horn clauses following the procedure from figure these horn clauses are shown in figure b the horn clauses have unknown states mv mv mv mv nv nv and nv the unknown transitions are ev v and ev v we show in figure c the horn clauses generated with preference for modular solutions the solutions for the unknown states of thread can refer only to vg v while the unknown states of thread are restricted to vg v the unknown transitions are vg and vg theorem progress of abstraction refinement the procedure refine guarantees progress of abstraction refinement ie the same set of horn clauses is never discovered twice solving horn clauses over linear inequalities as presented in the previous section refine calls the function in this section we present a function that can be used as an implementation of takes as input a set of clauses hc over linear inequalities that is to simplify the presentation of the algorithm we make two additional assumptions on hc first we assume that for each pair of clauses bw and b w from hc we have b b and b b second we assume that hc contains a clause false the additional assumptions are satisfied by the clauses generated in section in case is applied on a set of horn clauses over linear arithmetic that violates the two assumptions above we can apply a certain renaming of relation symbols and introduction of additional clauses to meet the assumptions function the function generates a tree representation for a set of horn clauses and is shown in figure for every relation appearing in the horn clauses the algorithm generates a corresponding tree node the children of a node are maintained in a function children as follows nodes that correspond to linear arithmetic relations have no children see lines ­ a node that corresponds to an unknown relation with a relation symbol b has as children those nodes that represent relation symbols that depend on b the label attribute of the tree nodes is initialized to a linear arithmetic constraint for leaves of the tree in line and to an unknown relation for internal tree nodes in line function see figure for the of the procedure this procedure creates a tree representation for hc at line at line we build a set containing m m m e m n n e n a init v init mv mv mv mv mv mv ev v mv ev v mv init nv nv nv nv ev v nv ev v nv mv nv err false b init v v v v v v vg v vg v init v v v v vg v vg v v v err false c init v mv v v init v init v mv v v mv v v nv v v nv v v mv v v mv ev v v v nv ev v v v mv nv err v false d cnt cnt cnt cnt cnt cnt cnt cnt e init vg v vi v vg v vii vg v init vg v v vg v vg v vv v vg v vg v v vg v f figure a reachability trees constructed by computation b corresponding horn clauses generated using c horn clauses generated with preference for modular solutions d a tree representation of the clauses from b as generated by each node shows its label attribute the of the node name identifies the set of variables appearing in the attribute of the node e the pred map generated by from the clauses in b f the label map generated by from the clauses in c all the label attributes of leaf nodes and store this set in atoms the input set of horn clauses is satisfiable if and only if atoms is unsatisfiable if atoms is unsatisfiable the test at lines ­ succeeds and returns a proof of in the form of weights for each linear inequality this test can be implemented using some linear arithmetic constraint solver if the constraint solver fails to find a proof an exception unsatisfiable is at line at line calls the procedure which is presented in figure this procedure recursively traverses the input tree in if this procedure is invoked for a leaf node n it directly computes the value of pred n as a linear combination of atomic formulas with weights given by the proof function see line if this procedure is invoked for an internal node n the attribute pred of ns children is computed using a recursive call at line after the recursive call pred n is calculated by adding the values of the pred attributes of ns children since there may be multiple nodes in the tree corresponding to the same unknown relation the algorithm has to account for the pred attributes of all these nodes therefore at lines ­ we compute solutions for each bw in by taking conjunction of pred of each node of the tree that is labeled with bu for some u theorem computes a solution for a set of horn clauses hc if and only if the conjunction of the clauses in hc is satisfiable example we illustrate the solving procedure using the same example from the previous section given the horn clauses from figure b constructs a tree that is shown in figure d this tree contains nodes which we label for convenience with identifiers from to in figure d we show the label map of the tree a witness of the of atoms is given by the following atomic formulas cnt cnt cnt cnt label label label our solver treats each linear equality as a conjunction of two linear inequalities the equality cnt is split in two inequalities cnt cnt the proof of is cnt cnt cnt cnt this is encoded in the proof map with values of at locations corresponding to the three atomic formulas above and values of for all the other atomic formula next we show in figure e the values for the pred map as computed by the final solution of the horn clauses is built by a conjunction of the pred attributes for nodes with the same unknown label the resulting solution sol is shown below v cnt v cnt solving the clauses shown in figure c given the horn clauses shown in this figure returns a tree tion with a similar children map structure but with different label attributes the part of the tree that to the proof of is shown in figure f the variable cnt does not appear in the subtree of the node since label vg part of this subtree is the node let us name the variable at this function input hc horn clauses over linear inequalities unknown relations vars label map from node to attribute children map from node to a set of nodes pred map from node to an atomic predicate proof weight function for inequalities begin label children the empty function root atoms label n if exists proof atoms q such that proof bu · bu bu atoms then for each bw do pred n bu return sol else throw unsatisfiable end figure function returns a solution for a set of horn clauses over linear arithmetic node as the proof of shown above does no longer hold since the following formula is satisfiable cnt cnt cnt however the conjunction of the elements from the atoms set is still unsatisfiable indicating that a modular solution exists we find that the following atoms contribute to a proof of lock lock label label after splitting the equalities in equivalent inequalities our algorithm computes the following solution pred lock pred lock pred lock pred lock pred from this pred map our algorithm derives a solution sol in lines ­ and succeeds in computing modular predicates experimental results in this section we describe a implementation of our proposed algorithm as an extension of the model checker tool description the verifier we built takes as input a number of functions written in the c language representing threads that should execute concurrently the input file also contains the description of an initial state and a number of assertions to be proven correct our tool uses a frontend based on the infrastructure to translate a c program to its corresponding multithreaded transition system that is formalized in section the main function input g relation either bu or false begin p q new nodes match g with false bw · · · false hc z zn fresh copies of w wn · · · bu bw · · · bw hc z zn z fresh copies of w wn w · · · label p i n bi label q g p i n bi return q end figure function fresh copies are created consistent eg fresh copies of v v v v returns f f ff where f f f are fresh variables that do not appear anywhere else procedure input n node of horn tree begin if then pred n proof bu label n else for each n do pred n pred n n end figure procedure of our tool is an implementation of our algorithm done using prolog an important design decision in our implementation concerns the treatment of and data variables even if both variables and data variables can be handled uniformly by our algorithm we found that different abstraction domains and refinement for the two domains can lead to significant improvement in our implementation the refine procedure first splits the constraints into data variable constraints and constraints the splitting procedure preserves of the original constraint since there is no atomic formula in the program transitions that relates both control variables and data variables if the data constraints are satisfiable the algorithm proceeds as in figure if the data constraints are unsatisfiable our implementation relies on a specialized refinement procedure described in that takes advantage of the simpler form of control counterexamples for these counterexamples control variables range over a finite domain and no atomic formula from the program transitions involves different control variables benchmark programs we tested our prototype implementation using a collection of programs that have correctness proofs for their safety assertions the first four programs shown in table are derived from two examples as figures in together with their from the the property to verify is that two operations performed by different threads are executed in the correct order the next three examples model the procedure of a windows nt driver contains two threads one thread and another thread to model the procedure of the driver and are the fixed versions of the model with two and respectively three threads is a linux character device driver that implements access to a global memory area the property to verify is that read and write operations are performed in critical section we also include some examples which are not particularly to a modular reasoning approach these examples are algorithms that establish mutual exclusion and mainly deal with global variables no local computation is included in the critical region the mutual exclusion property of the version of the algorithm holds only when assuming assignments are performed atomically our verifier was able to the bug present in the code without such atomicity assumption is the complete version of the algorithm while lamport is an algorithm with an optimized path in the absence of memory contention is an algorithm implementing the synchronization algorithm it is an alternative to a lock having read operations performance of our tool to explain our experimental results we first a working hypothesis this hypothesis suggests that when verifying a program that does not have a modular proof the algorithm with preference for modular solutions denoted as verification with is expected to pay a by to search for modular solutions that do not exist on the other hand for cases where a modular proof does exist the verification could fail to find a modular proof and instead return a more detailed proof therefore the hypothesis suggests that in these cases the verification is expected to succeed faster compared to the verification we report statistical data for each of the programs in table we show the number of lines of code loc and whether a modular proof exists for a program see column our implementation has two modes column shows the verification results when using our algorithm with a preference for modular solutions the last column of the table shows the verification results for the implementation of our algorithm the results demonstrate that our approach to verification of multithreaded programs is feasible and that the constraint solving procedure with is able to produce modular proofs more often than the verification furthermore without the the verification procedure for and examples showing the benefits of modular proofs as another experiment we tested some of our smaller examples using two model checkers for sequential c programs and for each of the tested programs and lamport we instrumented the program counter as explicit program variables pc and pc and obtained a sequential model of the multithreaded examples both and consider all interleavings and obtained after for both and lamport our tool exploits the thread structure of these programs and obtains verification results fast name benchmark programs loc has a modular proof no yes no yes no no no yes time varying mutex lamport no no yes no no yes no no yes our algorithm with no × modular × modular modular s s s s s s s s × modular × to s s s s s s s modular modular modular s s s s s s s s s s s s s s s s s to table has a modular proof indicates whether the program has a modular proof of correctness and × indicate whether the program is proven safe or a counterexample is returned while to stands for time out after modular indicates that a modular proof is found by our tool related work the main for our work from the relyguarantee reasoning method and automatic abstraction refinement approach to verification the work on relyguarantee reasoning initially an approach to reason about multithreaded programs by making explicit the interference between threads subsequently relyguarantee reasoning was used to the problem of state explosion in verification of multithreaded programs relyguarantee reasoning was mechanized and implemented in the model checker for java programs reduces the verification of the multithreaded program to the verification of several sequential programs with the help of a programmer specified environment assumption in model checking was proposed to infer automatically environment assumptions that propagate only global variable changes to other threads the algorithm has low complexity polynomial in the number of threads but is incomplete and fails to discover environment assumptions that refer to the local states of a thread verification is formalized by in the framework of abstract interpretation as cartesian product of sets of states the method of uses a richer abstraction scheme that computes contextual thread reachability where the context in which a thread executes includes information on both global and local states of threads the context or environment is computed using bisimilarity in steps that are interleaved with abstract reachability computations the verification starts with the strongest possible environment assumption and by refinement the environment is until it the transitions of the other threads in contrast our approach refines iteratively the environment based on overapproximation starting with the weakest environment and strengthening it at every iteration for abstraction refinement a counterexample from is reduced to a concrete sequential path by replacing environment transitions with their corresponding local transitions the approach of presents another solution to overcome the incompleteness of local reasoning by counterexamples it refines the abstraction by a local variable of a thread as a global variable this refinement the completeness of reasoning but is applicable to finitestate systems and may compute an precise abstraction in contrast our refinement procedure relies on interpolation and includes predicates on local variables as needed during verification another approach to overcome the state explosion problem of monolithic reasoning over multithreaded programs is to translate the multithreaded program to a sequential program assuming a bound on the number of context switches this scheme was initially proposed and implemented in a multithreaded checker for c programs and later to handle and even difficult to find monolithic reasoning can be greatly by using techniques from partialorder reduction like dynamic partialorder reduction or partial order reduction yet another technique to state explosion is to factor out redundancy due to thread replication as proposed in counter abstraction and implemented in the model checker we view these techniques as in obtaining practical multithreaded but orthogonal to our proposal for automatic environment inference acknowledgments the first author was supported by the we thank cook and peter ohearn for comments and suggestions references y and g automatic discovery of mutual exclusion algorithms in pages ­ g m t and d symbolic counter abstraction for concurrent software in cav pages ­ g m d ch l t and h taking boolean program model checking one step further in tacas pages ­ e m clarke o s y lu and h counterexampleguided abstraction refinement in cav pages ­ a and k s local proofs for global safety properties ­ j a and g linux device drivers rd edition inc p cousot and r cousot abstract interpretation a unified lattice model for static analysis of programs by construction or approximation of fixpoints in popl pages ­ c flanagan and p dynamic partialorder reduction for model checking software in popl pages ­ c flanagan and s qadeer model checking in pages ­ c flanagan s n and s qadeer verification for programs in esop pages ­ p partialorder methods for the verification of concurrent systems an approach to the problem phd thesis university of computer science department s and h construction of abstract state graphs with in cav pages ­ a gupta c and a rybalchenko refinement of control abstraction for concurrent programs in pages ­ t a henzinger r jhala r majumdar and g lazy abstraction in popl pages ­ t a henzinger r jhala and r majumdar race checking by context inference in pldi pages ­ c b jones steps toward a development method for programs acm trans program lang syst ­ c b jones specification and design of parallel programs in ifip pages ­ l lamport a new solution of concurrent programming problem acm ­ l lamport a fast mutual exclusion algorithm acm trans comput syst ­ s lu s park e and y learning from a study on real world concurrency bug characteristics in pages ­ a a podelski and a rybalchenko verification is cartesian abstract interpretation in pages ­ z manna and a pnueli temporal verification of reactive systems safety springerverlag p using and to verify parallel algorithms edition m s qadeer t ball g p a and i finding and in concurrent programs in pages ­ g c necula s s p and w intermediate language and tools for analysis and transformation of c programs in cc pages ­ s s and d an axiomatic proof technique for parallel programs i inf ­ a pnueli j xu and l d liveness with abstraction in cav pages ­ a podelski and a rybalchenko transition predicate abstraction and fair termination in popl pages ­ a podelski and a rybalchenko the logical choice for software model checking with abstraction refinement in pages ­ s qadeer and d wu keep it simple and sequential in pldi pages ­ a rybalchenko the tool available from b k a simple solution to concurrent programming problem with linear wait in pages ­ the systems laboratory prolog users manual institute of computer science release c wang z yang v and a gupta partial order reduction in tacas pages ­ 