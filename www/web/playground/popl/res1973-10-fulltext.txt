types are not sets james h morris jr xerox corporation palo alto research center palo alto california introduction the title is not a statement of fact of course but an about how language designers should think about types there has been a natural to look to mathematics for a consistent precise notion of what types are the point of view there is extensional a type is a subset of the universe of values while this approach may have its purpose quite in mathematics defining programming language types in this way ignores some ideas some interesting developments following the extensional approach are the algol type system vw scott s theory s and reynolds system r while each of these valuable insight to programming languages i feel they miss an important aspect of types rather than about what types are i shall focus on the role of type checking type checking seems to serve two distinct purposes authentication and secrecy both are useful when a programmer to implement a class of abstract objects to be used by many other programmers he usually proceeds by choosing a representation for the objects in terms of other objects and then writes the required operations to manipulate them there are two problems about the interaction of his programs with that he has great difficulty solving without the aid of a ty fe system to constrain the interactions first users of his programs may ask them to operate a this work was the author was at the berkeley by nsf grant while university of value that is not a valid representation of any of the objects he has to process this is the authentication problem he could begin each operation with a wellformedness check but in many cases the cost would that of the useful processing second users may write programs that depend upon the particular representation he chooses for objects this his the representation this is the secrecy problem type checking is a way to things from all represent the abstract considered to be of a certain rules are prevent values objects type such used to are the only values submitted authentication of that for type can be processing only the procedures applied to objects secrecy given can be of that type the remaining question is how to decide whether a given value has a particular type the discussion should serve to the reader that the question should not turn on what the value is but rather where it or q created it in other words type should not be an extensional property i shall now outline type system considerations the design for an based on the modules the overall structure of the language must permit different parts of the same program to have different capabilities any language with textual scope rules has this property to some extent eg a subroutine has exclusive access to its local variables the syntactic construct module is introduced to provide such structure a module has the form of a complete algol program delimited by q the main program part if any may be used to perform initialization a module may appear anywhere a declaration can any identifiers declared at the outermost level of the module may be tagged with to that they are entries in which case they are known in the enclosing block if the identifier denotes storage that storage may be read but not written from outside the module if it denotes a procedure the procedure may be called from outside a module is very similar to a class d example the following program defines and tests a scheme to remember equivalence classes the array a and r are unknown outside the module while count and are known module integer array a integer count integer ri integer i integer t ti while i rt end procedure integer xy iv rx ry re xy integer xy uv q q until count end print count print the programmer of a module is to assume nothing about the that access its entries he should use private storage to maintain the integrity of his data structures and treat parameters with the previous example violates the latter unless checking is assumed a modules whenever the question each other initialization its enclosing of whether recursively part is executed block is entered modules can call is while it is conceptually simpler to regard every program as one piece of text in practice one must break them to facilitate editing compiling etc the most natural way to do this seems to map large modules blocks into into files file and first a mechanism presented operating one designed w dynamic type similar to that in m will be it seems more appropriate for systems and is similar also the for system performing the operation to the caller two capabilities in the form of procedures and along with the integer i these things are unique in the sense that returns different versions every time it is called its role is analogous to a x produces a value limited properties xc with the following i ii is true in addition by y seq in x can be applied to unless y is a value produced is false and causes an error the is the sense that no properties of discovered ie a primitive x causes an error the operation transparent sealing operation with i e value produces a along x all the properties of x except that is true in addition yi is false unless y was produced by a of operations one of which was in other words transparent are like in that any number may be without each other or any other properties of the object it is suggested implementing a operations in the that new following a programmer type use these way during module initialization he calls with false if he an type true otherwise every time an object of the new type is passed out of the module he guarantees that it is every time a value of the new is passed into the module he tests its and it if it is opaque this scheme detects code since type errors only the module by is able to put its on things further if the is opaque the representation of the new type is kept a secret a considerable gain in clarity efficiency can be achieved following assumptions are valid if and the a a fixed number of new types are created by the program independent of the data b each new type is represented by a set of values as a compiletime eg an algol mode c sealing testing and are performed only at module boundaries in the manner described above d is never used in such cases the type checking exclusive of union testing can be done compiletime and the activity becomes so as at to to a new type one makes a declaration in the static of the form system g name type description normally the name will be tagged as an entry indicating that the type name can be used outside the module if is used the type is opaque if it is transparent the type checking rules can be summarized rules bv some coercion inside the module name simply an abbreviation f type description ie coercions in either direction are allowed outside the module an opaque type cannot be at all ie something declared a name can only in contexts declared such outside the module a transparent type may be downward ie something of type name may move into contexts with type type description but not back it should be that never induces any computation simply serve to control values may move between coercion here the rules the contexts the and implements pairs assuming arrays following program defines three modules the first of real numbers as arrays are heap allocated in the algol sense the second implements intervals as real pairs the third complex numbers as real each of he new types may be used in declarations outside its module since and interval are transparent types a value of type interval may be treated like an array for purposes of reading however an assignment to an intervals component intl is not permitted the assignment because it is regarded as int int and the real coercion complex outside re and righthand side has implicit array which implies an type upward since complex is an opaque type numbers must be treated as atoms the module using the procedures im to get at their components mo end real array procedure end t t xy real xy ty module interval procedure real xy xy then q xy yx interval interval xy xy end module g complex procedure real xv g x t yx real rec complex c re cl c real procedure complex c im cl sin c g real t real array a interval y complex z y xy x ay ty there are several not be legal in them are statements the main that would among xa yx x z yz y the first four call for upward which are never permitted remaining three attempt to opaque type coercions while the coerce an this type system has been designed to facilitate program verification on a modular basis the general principle is that a module writer should not have to look outside his module to verify its correctness part of this is achieved by defining correctness and the rest by having the type checker restrict how the outside world with a module associated with a new type of the form t may be a px eg xc interval xx to prove that it holds the module the verifier everywhere must outside prove p v variable v of of initialization holds for every type t at the end if any at each entry of the module assume the invariant holds and prove p x for all changed variables and returned values of type t at the exits of the module for example to the interval invariant above one must prove that the parameters of each call of jn and are in one may assume the invariant holds for the formal parameters x and y opaque types do not facilitate proofs per se but their can be illustrated by considering proofs the external specification of a module might be given as a set of statements of the form where f is function of the procedure describing the effect entry eg xy xy since values of an opaque type cannot be directly there is no need for these statements to be true indeed they are not for the current example the actual situation can be described by assuming an implicit representation function r which maps the underlying representation into the assumed one eg rz then the internal the module writer r at appropriate specifications given are derived by places eg to now the module writer is free to choose any r he and prove that the programs the internal specifications for this particular example he would be to choose r to be the identity function and the program accordingly the important point is that he is free to change r any time he and the external specifications need not change remarks the type system presented here is like class construction but improves on it in a few respects first it allows the module writer to have private data while allows outside programs to access all a storage second it makes implementing binary operations on new types simple something that is nearly impossible in a of john has designed of the class mechanism to overcome these problems the notion of a transparent type provides a very limited form of polymorphism if several transparent types are ui s base type it is possible to write a single procedure that accepts any of those types as a parameter it is not entirely clear how to achieve true polymorphism since such a procedure is unable to return values of varying type dependent on the input type an interesting point comes up when one tries to justify the proof rule for type invariants what a module entry or exit if one has a language like algol with recursion and nonlocal transfers each procedure call in the module must be regarded as an exit followed by an entry this can be quite because it requires everything be ue ie the invariants truth before every procedure call it is therefore to put the following constraints on the control structure any procedures within involve recursive must one module entries of chain of be entirely and cannot the module a nonlocal transfer cannot cross any module boundary to the effect restriction one can provide mechanism similar to pl n error signal propagates of the an error exit back along the call things chain allowing each module to clean up so as to restore its invariant references v van algorithmic a report on the language algol s scott d of a mathematical theory of oxford university r reynolds jc settheoretic approach to the concept of national d oj and hoare car program structure structural academic press m morris programming l jan languages comm ac w wa et al the of a multiprocessor operating department of computer science carnegie mellon university june 