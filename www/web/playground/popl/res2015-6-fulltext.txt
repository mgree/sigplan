differential privacy now its getting personal university of technology david sands university of technology university of abstract differential privacy provides a way to get useful information about sensitive data without much about any one individual it many nice compositionality properties not shared by other approaches to privacy including in particular against designing differentially private mechanisms from can be a challenging task one way to make it easier to construct new differential private mechanisms is to design a system which allows more complex mechanisms programs to be built from differentially private building blocks in way so that the resulting programs are guaranteed to be differentially private by construction this paper is about a new principle for building differentially private programs it is based on a simple of classic differential privacy which we call differential privacy in each individual has its own personal privacy level we describe proper a interactive system for implementing which maintains a privacy budget for each individual when a primitive query is made on data derived from the provenance of the involved records determines how the privacy budget of an individual is affected the number of records derived from alice determines the for the privacy decrease in budget this offers some advantages over previous systems in particular its finegrained character allows better of the privacy budget than mechanisms based purely on the concept of global sensitivity and it applies naturally to the case of a live database where new are added over time we provide a formal model of the proper approach prove that it provides differential privacy and describe a prototype implementation based on system categories and subject descriptors d programming languages language application languages general terms design languages theory keywords differential privacy provenance permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page for components of this work owned by others than the authors must be abstracting with credit is permitted to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission andor a fee request permissions from popl january copyright is held by the publication to acm acm introduction differential privacy is a relatively new notion of privacy ­ the theory shows that by adding the right amount of to statistical queries one can get useful results at the same time as providing a notion of privacy its definition does not involve a syntactic condition on the data itself but rather it is a condition formed by comparing the results of a query on any database with or without any one individual a query q a function is differentially private if the difference in probability of any query outcome on a only by a factor of e approximately for small whenever an individual is added or removed research on differential privacy has developed a variety of query mechanisms that provide differential privacy for a useful range of statistical problems a few works have more on composition principles that allow new differential private mechanisms to design a system which allows more complex mechanisms programs to be built from differentially private building blocks in way so that the resulting programs are guaranteed to be differentially private by construction is the starting point for the present work global privacy budget is an of interactive differential privacy which ensures at runtime that queries to a global privacy budget client code freely how sensitive data sets should be processed and the runtime system ensures that this does not break a specified privacy budget builds on a collection of standard differentially private primitive queries together with simple composition principles ­ mathematical properties by the definition of differential privacy one central principle is that multiple queries eg with differential privacy and respectively have an additive effect on the overall differential privacy another central idea is to track sensitivity of functions to measure how much a change in the input might affect the value of the data together these components allow the system to track how much to from the global privacy budget on each invocation of a primitive query limitations of the global privacy budget in a system where all computations are described as a monolithic program a global budget is reasonable in an interactive system however there are several limitations to this style of imagine a scenario involving a large data set of ­ a of the population ­ containing various information about and let us suppose further that we aim for differential privacy for some specified value of on the selects all the people from the database who have a particular type and constructs an algorithm which extracts information about them as part of research since just of the population have this type the of the database involved in this study is relatively small but the database is known to be big enough for it to be meaningful let us suppose that the cost of this analysis according to the system is now on the gets a new task to extract information about the of towards an for this is a significantly larger portion of the database possibly overlapping research group the has left to if is large the has the budget by the small group even though that study did not touch the data of the larger part of the population offers a way around this problem by adding nonstandard database primitives here we would partition the data into ab not ab and perform the two studies in parallel with cost being the maximum of the cost of the two studies this leads to a reasoning and an programming style but it also has another limitation what if the database is live ­ we obtain new data over time or if data is being added a global budget forces us to be pessimistic about new data differential privacy this paper addresses these issues by a simple of differential privacy called differential privacy which permits each individual to have a privacy budget the definition supports generalised versions of the composition principles upon which systems like are based § and moreover a number of properties which allow for less compositional principles § for example any query about the of offers differential privacy for as it does for any records of which enter the database after the query has been made from these principles we design a system in the style of called proper provenance for differential the proper system maintains a personal budget for every record entering the system instead of using sensitivity proper tracks the provenance of every record in the system and uses the exact provenance to calculate how a query should affect the of the unlike the system is described as an abstract formal model for which we prove differential privacy this is important because the correctness of proper is not obvious for two reasons the individual become highly sensitive and how we handle them is novel more specifically if a query involves records that would break the budget of an individual they are from the data set upon which the query is calculated in the example above analysis of will automatically data derived from any as soon as the cost of the queries their secondly it is necessary to restrict the domain of computations over data sets to a class which guarantees that the provenance of any derived record is affine zero or one record otherwise the number of records which might get due to a small change in the input might be too big to give privacy guarantees the approach is suitable for integration with other systems since we assume the existence of basic primitives providing classical differential privacy we have implemented a prototype of the proper approach which extends the system § with and the ability to input live data we compare the performance of our implementation with to show that the runtime overhead is not significant we conclude with a discussion of related work § a summary of our contributions § and the current limitations of the approach as well as directions for future work differential privacy we begin by the classic definition of differential privacy and its simple composition principles that allow the construction of new algorithms from existing components in this work the data sets will abstract representations of databases modelled simply as multisets over some unspecified set of records when we say that a and b differ on at most one record also written a b we mean that they are either identical or one can be obtained from the other by adding a single record definition a function q provides differential privacy if for all data sets a b and any set of possible outputs s we have p s p s × e thus the of a given output to a query q only changes by a amount with or without any individual the smaller the the better the privacy guarantee for the individual the literature contains many examples of differentially private aggregate operations on data achieving an appropriate balance between privacy and utility by the use of statistical in this work we take the existence of such building blocks as given we will adopt the convention of writing q to denote an differentially private query queries will be algorithms rather than just abstract mathematical functions so we assume that the range of q is finite and moreover the result of a query forms a discrete probabilistic distribution given this we can simplify the conditions of the form qa s to qa v for any value in the range of q definition satisfies a number of useful properties that serve as building blocks for systems enforcing differential privacy which we outline informally here query composition if we apply two queries q and then q to a data set then the combined result is differentially private this result holds even if q is chosen in response to the result of q although useful the sequential query composition principle can be very if two queries are applied to disjoint sets of data then the privacy loss is the maximum of the privacy of the two queries this observation to include this as a nonstandard parallel query operation in preprocessing and sensitivity what if we transform data before applying a query a key concept is the sensitivity of a function it is also a key concept in the design of primitive differentially private operations although that is not our focus here roughly speaking a function f has sensitivity c also known as stability c if whenever the distance between two inputs is n the distance between the results of applying f is at most c × n for multisets the distance between a and b is just the size of their symmetric difference not all functions have a bounded sensitivity for example consider the cartesian product of two data sets adding a record to one data set can add many elements to the result ­ it depends on the size of the other argument we the following property the sensitivity composition principle if transformer f has sensitivity c then q f is · private the proof of this follows easily from the following scaling property of differential privacy if data sets a and b differ by k elements then p s p s × a very simple ­ perhaps obvious ­ property is that a differentially private query is robust under for any function f f q is differentially private this means that the result of a query cannot extract more private information than the query itself released this is also the case when f is chosen in response to other queries ­ or the result of other side knowledge about the data set differential privacy now we turn to the main concept introduced in this paper or big epsilon differential privacy and its analogous compositionality properties definition big epsilon differential privacy we say that data sets a and b differ on record r written a r b if a can be obtained from b by adding the record r or let e be a function from records to nonnegative real numbers a randomized query q provides e differential privacy if for all records r and all a r b and any set of outputs s we have p s p s × ee r differential privacy allows each individual record to have its own personal privacy level this may turn out to be a useful concept in its own right but its main purpose in this work is as a that permits a more finegrained in the construction of classical differentially private mechanisms and one which plays well with dynamic databases the following proposition the relation to differential privacy proposition i if q is differentially private then q is private ii if q is e differentially private and then q is differentially private now we consider the composition principles analogous to those above we keep the presentation informal since we will not apply these principles directly in our formal developments ­ rather they provide an intuition behind the approach most of the principles above to differential privacy query composition in the sequential composition of queries if q and q are e and private respectively then applied in sequence they yield a private query for parallel queries let us be a little more precise let be a partition of the set of all records and be a set of queries we define a parallel query p a ii ri where is just the nary cartesian product of sets now we have the following natural of the parallel query principle if qi is private then p is e differentially private where e r if r ri now we introduce the first principle which takes advantage of the finegrained nature of differential privacy the selection principle for set a define x a if q is e differentially private then q is e r r private here e r r a denotes the function which maps every element outside a to and behaves as e otherwise in simple terms a query which operates on a is private for outside of a in contrast the composition principle of differential privacy has nothing helpful to say here the sensitivity of the selection function is how does this help us it can show how the sequential composition principle for e differential privacy gives greater precision specifically parallel composition is simply no longer necessary to give a reasonably accurate estimate of privacy cost suppose we compute p a by sequentially computing qi then the sequential composition principle the cost of this iterated sequential composition as if x ri then else which is precisely the cost calculated for the parallel query sensitivity composition the sensitivity composition principle also into the world of differential privacy if transformer f has sensitivity c and q is e differentially private then q f is xe x × private the proof analogously follows easily from the following scaling property if data sets a and b differ on elements c then p s p s × e r the sensitivity principle a key feature of differential privacy is that it supports a finegrained composition property for a large and important class of functions namely functions that are union preserving a function f from multisets to multisets is union preserving if f a b f a f b a b denotes the additive union of multisets a and b in standard relational algebra for example all functions are union preserving in each of their arguments with the exception of the multiset difference operator which is not union preserving in its second argument complex functions may be built from simple ones as they are closed under compositions you will read more about supported compositions in section the characteristic property of union preserving functions is that their behaviour can be completely by their behaviour on individual records this gives us a completely precise way to compute the influence of a single record on the result of the function since f a r f a f r this leads us to the following lemma if f is a function and q is e differentially private then qf is xe private proof follows easily from the scaling property taking e r yields the following useful corollary which is the core of our approach to combining existing differentially private mechanisms with our approach corollary if f is a function and q is differentially private then q f is x × differentially private proper provenance for privacy in this section we provide an abstract model of the proper system the proper system sensitive databases and computations over them via an imperative api it guarantees as we shall prove e differential privacy for the records which enter the system vs systems the principles described in the previous section are a guide as to how we can build a system that allows to compose new differentially private algorithms from differentially private components in principle such systems can be of two kinds or in a system we can apply the principles to compute and report on the level of privacy achieved by a given run of a program a system on the other hand is given a goal ­ an amount of privacy that is to be achieved and the system must use the principles and ensure that the privacy within the bound in a dy in an approach based on static analysis such as the of one could say that these two approaches are unified system like however it is more natural to describe a system ­ one which does not violate a level of privacy in a system the desired amount of privacy can be thought of as a budget and in the literature it is often referred to as such for proper this is an amount of privacy per record as described by some function e but the principles described above know nothing of ­ they are purely it is therefore important to design a mechanism which is private even when the program fails to meet the intended goals with differential privacy this is a crucial question ­ because the budget itself is clearly a sensitive object in a the proper approach involves tracking the provenance of each record in any intermediate table on which sensitive input record does it depend and by records from the arguments to statistical queries if the presence of those records would break the privacy budget of some individual the provenance information is used to make that link we begin with an informal overview before describing the system in formal terms overview of proper the proper system is described in terms of two main components the protected system which stores all sensitive data and its derivatives and all computation over that data and the client program which queries the sensitive data requests computations to be performed over the sensitive data and the inclusion of new input records into the protected system an illustration of the architecture is given in figure configuration queries client program protected system table environment api privacy budget responses inputs figure proper system structure from the viewpoint of a client program the system just stores tables tables are referenced via table variables a client program will issue a command to the protected system in terms of table variables these commands will represent transformations such as select all from table a and assign the result to table b or input some new records and assign them to table c or primitive queries such as return the number of records in table c with differential privacy the records that are input are the subject of our privacy concerns we refer to those records as to provide e differential privacy for the the protected system needs to maintain more information than just the mapping between table variables and tables for each individual r that has been input to the system so far a privacy budget for r needs to be maintained initially the budget will be e r as queries are performed over time the budget for each individual may decrease there are two key issues that the system must address i how much should the budget for each individual be when a table is and ii how do we prevent the budget from negative which would imply that we have violated privacy the solution to this is to track together with each record its provenance the provenance of a given record is just the individual from which that record was derived if any problem i is then solved by noting that the cost for individual r is the privacy cost of the query by the number of elements in the table which have provenance r cf corollary before we can provide the formal definitions of the above sketch we need to define our basic domains and introduce some suitable notation preliminary definitions and notation given sets a and b a b denotes the set of partial functions between a and b with finite domain if f is partial function then f x y denotes the partial function which maps x to y and behaves as f for all other arguments we will also write partial functions and updates using a style notation eg x x x we assume an untyped set of records rec ranged over by r s etc we will work extensively with multisets in particular multisets of records for a set a we write to denote the set of multisets over a isomorphic to functions a n more specifically the set of tables table is defined to be it will be convenient to introduce some notation for working with multisets we use multiset brackets such as eg a denoting a multiset a containing two copies of and one we n write multiset membership a a to mean that there are exactly n n copies of a in a and a a means n a a analogous to notation we will use multiset with the ability to express for example xn x n x but note that may sum up as in this example × xn x n given multisets a and b we write a b to denote the additive n union which is the least multiset such that whenever a a and m mn a b then a a b binary relations are to sets as are to multisets in other words a is just a notation for a multiset of pairs we will use the concept of extensively to model the records of a table together with their provenance for example a table containing just three copies of a record r two of which where derived from individual alice and one from individual bob will be modelled by a r alice r alice r bob before we show how we use this in practice we need some notation to make reasoning with more formally given sets a and b we write a b to denote n × b if r a b then we write a r b to mean a n is related to b n times ie a b r definition operations on let r and s range over x x for some x let be t is a subset of x and u we define the following operations involving relations domain of a relation relation composition application right restriction def an a b n r r s def a a n r b b m s c r · u def a n r b b m u r def a bn a n r bb t example given the following two r x y x w x w s y z w z w v then doms y w w r s x z x v r £ w x w and r · w y x the following properties are easily verified proposition for all r r s and s and set t i composition is preserving in both arguments r r s r s r s r s s r s r s ii restriction is preserving in its first argument r s £ t r £ t s £ t iii restriction and composition associate as follows r s £ t r s £ t iv and finally £ t r · t note that as in iv we will freely use sets as if they were multisets without making the obvious injection operation explicit provenance tracing as mentioned we will track the provenance of each record derived the key idea to achieve differential privacy is that the provenance of a given record must be at most one record we call this affine provenance supported operations as we explained in this setting records provenance should be affine this is achieved by simply requiring that all transformations are unary and preserving ie transformations f for which f a b f a f b this guarantees that provenance can be tracked by observing the action of f on and ii provenance will always be a single element to give a simple syntactic of a class of unary preserving functions we can use a grammar of terms built from the standard operations of relational algebra used here over multisets the basic operators of relational algebra to multisets are the set operations multiset union set difference cartesian product × together with record selection p which selects all elements satisfying property p and projection a which transforms each row by only the columns given by schema a we omit the details of the definitions and refer to for definitions of multiset variants of these standard operations definition affine relational terms let v range over sets of variables and t over literal multisets we define a family of relational algebra terms av by the following grammar av x v av av av × aa × av t theorem any multiset transformation f defined by f x ax is preserving the proof follows by induction on the definition of ax using the properties of the operators the restrictions imposed by the grammar are due to the facts that all the operations preserve unions in each argument except for the second argument of set difference and that preserves unions across its arguments simultaneously whereas × does not ie a a × b b a × b a × b provenance tables the fact that we will track affine provenance leads us to define a provenance table as a table in which the affine provenance of each element is recorded definition provenance table a provenance table is a relation of type def rec rec where rec def rec for some distinguished the underlying table t represented by a provenance table d is obtained by simply taking the domain of d ie t the provenance of each element r of the table t is given by the element to which they are related viz if then there is a copy of r in t that has provenance s if some record r is related to this that r is present in the table but that it has no provenance ie it was not derived from any individual in the remainder of this section we introduce the notation and techniques necessary to permit provenance to be traced across computation how do we build and maintain provenance tables we need a way to create provenance tables from new tables and we need a way to construct the provenance table of a table produced by a transformation applied to a provenance table when new records of enter the system then their provenance table has a simple form the provenance of each record is itself when we create a new literal table ie where the elements do not depend on then each record has provenance the following notation for these cases will be useful definition for a set of records r define the identity provenance table def r r r r for a table t define the constant provenance table def r n r n t the final building block is to show how to lift a function f which computes over tables to a function f which computes over provenance tables so that in particular the following diagram d f d dom t dom t f definition given a preserving function f table table define f by fd def f d nn where f rec rec is defined by t f s t f s the fact that the diagram above is captured as follows lemma functional correctness f proof first we show that the relational representation of f and the relational application operator behave as expected f · a f a f a n f b b m a a n f b b m a ak a k f a f a def f preserves now we show d d · d a m d b b n d c a m d b b n d c mk a b d b d · finally we calculate d f · f eq eq the system model the semantics of the overall system will be given by a probabilistic transition system described by combining the client program with the protected system protected system the protected system is a collection of states which encodes four pieces of information the set of which have been input to the system so far a privacy budget a positive real for each of these indicating how much of the privacy remains a set of table variables used to identify intermediate tables computed and a table environment which maps each table variable to the provenance table it represents the first two items are modelled by a partial function from to and we assume that the set of table variables is fixed and at least countable this leads us to the formal definition of the states definition protected system states states def × rec r client program model we work with an abstract notion of a client program a program is just a labelled transition system subject to some restrictions where the labels ­ the actions ­ represent the imperative api through which the program with the protected system the program model inspired by is an imperative program that computes with tables by that the commands a are performed is specified in figure here we assume that f ranges over an unspecified set denoting preserving functions in table table and q ranges over tv expr v step assignment primitive query returning v val expr tv table variable f tv · · · tv k transform t table literal t table input reference to the input stream figure the labels of the transition system an unspecified set of queries with the convention that q denotes an differentially private query note that we will not formally distinguish the name of a function as used here to define the set of actions from its denotation as used in the specification of the semantics of the system below the idea is that programs have no direct access to tables but make requests for the system to manipulate them on their this includes making a request for the system to collect new via an input action and place them in a table variable the primitive query action is special it does not model a request but rather a request and its result all in one the reason for this is that it allows us to model value passing without to introduce any specific syntax for programs secondly the value returned by the query is known to the program and the program can act on it accordingly from the perspective of the program and the protected system together this value will be considered an observable output of the whole system we also model internal actions of the program and hence the of time via the traditional action a program then is just a transition system however we impose some restrictions on the transition system which model the fact that i the query operation really is an input operation so if the program issues a query there must be a transition for that query with every possible value and that ii the program is fully deterministic so that at most one type of action is possible in any given state and the action determines the next state definition client program a client program a program for short is a labelled transition system p p where p is the set of program states with initial state p and transition relation p × × p satisfying the following properties it is deadlock free ­ a program can always make a transition and secondly it satisfies the property for all states p if p a p and p b p then if a b then p p if a is not a query then a b if a r then b r for some r and for all s there exists a ps such that p ps remark implicit parameters to avoid of definitions in what follows we will fix some arbitrary client program p p and some arbitrary personal budget e and make definitions relative to these configuration semantics now we can provide the semantics of the combination of a program and the protected system ­ what we will call a configuration c def p × × rec r we will write a configuration as a triple p e b where metavariable e ranges over the table environment and b ranges over the budget the behaviour of a configuration will be a form of probabilistic labelled transition system whose labels are the values of queries made by the program the transition and the tables of unique which are input by the environment definition initial configuration the initial configuration is formed from the initial program state the environment that maps every variable to the empty provenance table and the empty budget table c def p tv tv definition operational semantics the operational semantics of configurations is given by a probabilistic labelled transition relation with transitions of the form c a p c where a act def val rec and probability p the definition is given by cases in figure we put probability in parentheses because the relation is not a priori probabilistic but something that must be proven this is established in lemma first we provide some explanation of each nontrivial rule in turn input the program requests an input to be made and assigned to a table variable the rule imposes a constraint on the records t which are input it must be a set of records and this set must be disjoint from the records previously input the domain of b this reflects the idea that the input records are the subject of privacy and represent unique the transition of the configuration is labelled with t to record that the environment chose to input t the probability of the transition is meaning that the choice of input is treated nondeterministically the configuration is updated in two ways the table is converted to a provenance table by recording that the provenance of each record is itself secondly the budget for each new record is from e assign the program requests a transformation of existing data here we apply the mechanisms developed in section to lift the function respectively table into the world of provenance tables query here the program is the value of a query to answer the query we must determine the records l from the table tv which can safely be involved in this query to do this we first determine a cost map c which describes the privacy cost which would be upon individual r by the query the cost of an differentially private query on tv to an individual r is by the number of records in tv which have provenance r given the cost map we can determine a the set of for which this cost is acceptable ­ ie those who have sufficient budget finally we can use a to determine l it is the of records which depend at most on records in a the probability of the transition is inherited from the probability that the query returns that particular value trace semantics the transition system on configuration c a p c is fully probabilistic in that c and the value of a uniquely determine p and when p c this makes it very straightforward to lift the semantics to a probabilistic trace semantics in what follows let range over traces sequences of zero or more actions act the empty trace is denoted by and a denotes the trace starting with a and with definition trace semantics define the trace transition relation × act × × inductively by the following rules c c c a p c c q c c a pq c we write c p to mean c p c for some c although we have a transition system involving numbers derived from probabilities it remains to show in what sense we have specified a probabilistic system we begin with a definition which describes when an input sequence is compatible with a given trace definition input compatibility an input trace i is a sequence of mutually disjoint sets of records we say that a trace t is compatible with i written t i iff the subsequence of inputs in t is a prefix of i now we can state the sense in which the transition system is probabilistic it can be viewed as a probabilistic function of the input and the length of the trace observed lemma traces are probabilistic for all input traces i and all n p c t p t i n ie in response to a given input the possible traces of a program of a given length form a probability distribution proof sketch a key here is the following property whenever c a p c and c a q c for p q then c c and p q this can be established by cases according to the transition and depends on the assumption that the program transitions are deterministic from this it is straightforward to show that c t p c and c t q c for p q imply p q and c c the first q is easily established by cases according to the rule the transition making use of determinism assumption about programs the second clause c c then follows easily from the first with these two properties the proof follows by induction on n so whenever c p p is the probability of observing among traces of the same length and for which the input sequence is the same we thus write p rc p to mean c p proper provides e differential privacy in this section we establish the main theorem for the system which states that the trace semantics is an e differentially private function of its input in order to state this in a convenient way we introduce some notation definition for any record r and any tables t r and t we write t t to mean that t r t we lift r this relation to traces writing to mean t and r t for some t t such that t t r we will further lift t t to various structures containing tables in all cases we define the overloaded relation r to be the symmetric closure of r so t r t iff either t r t or t r t so when r then and differ in exactly one element an input set and and their difference is exactly the record r theorem e differential privacy for all traces if r and p then q for some q such that p q · r input p p t rec t p e b t p br e r r t p p assign p e b p d b · · · n if e f tv · · · tv n where d if e t if e tv p p p e b p e b p p query p e b n p p e br br cr r a c s · s s where a l r br cr · a p n figure operational semantics to prove the theorem by an induction over the trace length we must establish an invariant relation over configurations r which t t the most and important of these is the relation between provenance tables r definition d d d d £ r d r this says that when d d the table represented by d has all the elements of d with the same provenance and that the elements of d which are not in d all have provenance r this relation will be used to express a key invariant in the correctness proof and can also be thought of in the main proof as establishing the correctness of the provenance information now we establish some basic properties of this relation on provenance tables r proposition d d d · r proof r d d d £ r d d £ r d £ r d · r iv rr proposition i di ii di ii di proof i £ r di di di £ r di di ii di £ r di di i ii di £ r di di i ii r di di ii ii ii r def of the following establishes that computations over provenance r tables preserves proposition d r d fd r fd proof assume premise fd f d f d £ r d f d £ r f d f d £ r f d fd £ r fd hence fd r fd as required def premise i iii f def definition r similarity for configurations we define the following similarity relations for the components of configurations rr · e e tv e tv e tv r · b b br b e r r r r · p e b p e b p p e e b b finally define c r c r iff c c or c r c the generalised version of theorem establishes the invariant relation between configurations from which the theorem is a straightforward corollary lemma if r and c p c then c q c where c r c for some such that p q r the proof is given in appendix a implementation and experimental results in this section we start by briefly describing the implementation of proper we continue with a small example to give a on how the tool is used and finally we present some experimental results in terms of time and memory execution applied to a of benchmarks comparing proper with description of the tool we have implemented our approach into the tool proper the tool has been implemented in c in order to interact with the tool the user must be working on a programming environment eg c and needs to create an instance of the proper class after this there are a number of constructs available the proper api to and manipulate data proper is based on and its interface has been designed having as so not surprisingly the way a user with both tools is similar modulo some syntactic differences despite there are important differences in the way and proper are implemented as explained below i when a new data set is given to proper each record of the data set is assigned a unique key and an individual privacy budget in records do not have a key and the privacy budget is global ii proper performs provenance tracking using the above mentioned record keys one feature of this provenance tracking is that each record depends at most on one record from the input set iii some transformations are implemented differently in proper where and select are equipped with provenance tracking mechanisms but this is not the case in iv though the dynamic updating of databases adding records is possible in the added records inherit the current global budget and thus they can be used as many times in queries as the old records in proper guarantees that added records may in as many queries as their individual budget allows not depending on others record budget or global budget in what follows we elaborate on how proper works let us assume the user has a data set and wants to perform a number of transformations in order to make some queries in order to do this a proper object is first created the data set is imported into proper the transformations are applied to this object and finally the user can then run arbitrary queries on that proper object the above description is a simplification as proper only supports transformations where each resulting record depends on at most one record if other transformations not this constraint are a subroutine will be called and treated like a primitive query in more detail in proper sensitive data is stored in a protected object with the generic type of in sensitive data is placed in a object when data is manipulated using preserving transformations provenance information is also and attached to the resulting records two important supported transformations are where and select representing the projection and selection primitive operators in relational algebra when it comes to records with sufficient privacy budget are selected and their privacy budget is reduced also when a transformation with type of provenance is the data set may switch to classical differential privacy by calling epsilon this reduces the budget of each involved record by and creates a protected object of type from this point the resulting object can be used in other arbitrary transformations defined in classical differential privacy or contribute in other differentially private example as mentioned previously introduces a special parallel composition operation for applying queries to disjoint parts of a data set we argued that implies that the does not need to construct parallel queries § ­ it is just as efficient to pose sequential queries but in situations where there is no natural partition of data our approach is not only more convenient but also gives strictly better results let us assume a data set on which we will perform three queries each one with accuracy and such that the pairwise intersection of the intended domains of these queries is nonempty but where we know that that the intersection of the queries is empty see figure in the universe where each person is allowed to have at most two roles the queries m ht figure m and and are about in different roles in this case we cannot use parallel composition as in since it would require that the queries are disjoint if we run them sequentially it would consume whereas if we use we will consume note that in the case of disjoint queries the approach would consume the same budget as in the parallel case the above case may be generalised given n queries such that each record is involved in at most g queries would give the following parallel composition a la cannot be applied sequential composition would consume n · while would consume g · as a simple example we demonstrate how this analysis can be implemented in proper we use the structure described below to store an information where each individual has at most two different roles role eg and role eg manager public struct individual public string name public string role public string role to and our database with sample data we can pass an array of type individual as an argument to the constructor method individual population new individual new individual name alice role role new individual name bob role manager role var new proper individual population budget to construct a proper protected object that only stores information about we can use the selection operation note that each record in the resulting proper has a dependency relation with exactly one record from the input data set var using the select transformation we can modify an attributes value or totally remove an attribute from a relation for instance as you can see in the following code we transformed the table storing information about all into another table containing the length of their names var person finally to extract information from the above table we call the method which will reduce the budget of each individual record from the data set under consideration by and will create a object with total budget now it is possible to run a classical differential privacy query the simplest one being to call an function with accuracy as shown in the code below x x similarly the proper object can be converted into a object as follows var note that objects can also be used in more complicated transformations like join and available in as we have previously mentioned another distinct feature of proper is its ability to deal with dynamic databases for that proper has the following available methods update insert and delete it is also possible for users to define their own methods to manipulate data if needed be a function to the contents of the database when it is called can be defined with the method the defined function is called by the client program each time is called epsilon experimental results to have a space and execution time comparison we implemented the clustering algorithm both in and proper this algorithm only uses projection and selection primitives which makes it a perfect candidate for comparison the algorithm accepts four parameters a list of records the number of the number of dimensions and the number of iterations for the purpose of this research we fixed three of the parameters number of dimensions number of number of iterations and modified the number of records to see its effect on execution time and memory usage the result of our experiments concerning time is shown in figure where it is possible to see the effect on execution time when varying the number of records as it can be seen in the figure adding provenance tracking proper has a negative effect on the execution time and down the system by around concerning the memory usage proper implementation of the clustering algorithm uses twice as much memory as the implementation this can be motivated by the fact that each record has the type double and for each record a key with type int and a structure to keep track of privacy budget is needed this high memory usage is since these extra structures key and privacy budget has almost the same size as the size of the record more generally the overhead in memory will be the ratio of the size of the record with and without the provenance record key limitations the restriction of proper to unary transformations means that in some cases we simply have to fall back to using routines for example in the network analysis example of and the first transformation of the is to group network requests by ip address if the number of possible ip addresses was small and statically known then we could iterate over this list to select the elements corresponding to each ip but since they are not the list of groups clearly has multiple and is thus not supported by our method so in this example · execution proper number of records · figure comparing and proper wrt execution time we immediately fall back to using a subprogram and appear to get no benefit from but potential benefits from are not far away for example if one decided to restrict analysis to a specific then would ensure that we dont the budget of the rest of the world another example is if traffic data over time in which case we would automatically filter the records which have an budget without requiring any visible at the level of the code related work the literature on differential privacy although only ten years old is already for an overview we refer to we consider work related along four dimensions general systems which provide mechanisms for constructing differentially private analyses approaches to dealing with dynamic data provenance and its connection to privacy and approaches to improving the of privacy budget systems enforcing differential privacy as mentioned earlier the interactive style of our system is inspired by the implementation of has a number of as pointed out in these and other implementation are certainly present in our implementation and it has not been our goal to focus on those other systems of note include which is a framework for constructing differentially private programs untrusted client construct and the system provides differentially private note that mapping is restricted in by modifying the jvm to be a operation only a single record is allowed to affect the pairs output by the so it would be interesting to explore in that setting since it could potentially improve the budget over time and perhaps remove the need to statically decide and enforce the exact number of elements produced by the another line of work developing the and dfuzz describes differential privacy in which the whole computation over private data is described by a domainspecific functional program and a static type system determines statically whether the computation will be within budget this approach would combine well with ours by using it as a necessarily sideeffect free query dynamic systems and data streams there are different in which a system might support dynamic data in one sense the users are static but their data arrive as a stream one approach to privacy on streaming data is a stronger notion than differential privacy which ensures that the entire state of the system is private streaming is a version of that supports this kind of data introduces a novel concept of privacy which over time it seems that this is a feature that could be added to proper by periodic increase in the of records and build a model and proof techniques for reasoning about interactive differential privacy with records that are input over time they introduce a specific of differential privacy called differential noninterference their formal model of noninterference has to ours based on probabilistic transition systems they develop proof methods and similar ideas could be useful in our setting to our main proof in our setting the one system we reason about is over any program which uses the internal api in the formal model of et al the queries are supplied by the environment thus the model of the malicious analysis is the sequence of all possible queries for all possible input sequences a question mark over this model is that is does not capture the strategy of the user for a probabilistic systems it is known from the noninterference literature that modelling the user using nondeterminism rather than a strategy can hide the presence of information leaks one aspect of their model is not captured in our system they model bounded memory this causes an in the privacy cost of computations since addition of one record into an input stream will cause a full memory to change by two records the record itself and the record that it provenance and the notion of provenance that we use is more specifically called what provenance in the terminology of et al more specifically it is the notion from et al transformations are called in that work our main principle is the tracking of data from input to the point at which it is used in a query complementary to this and abadi show how to improve privacy by tracking from the result of a query to the final result of the program if the query is not used to produce the final result then you dont need to count its cost in some sense this optimisation is already built into systems like our model assumes that the results of intermediate queries are observed by the attacker so using this principle would require us to refine our model but it can be straight into our implementation there are a number of other works which link the concepts of provenance and privacy although these are mainly connected with queries about the provenance of data in a privacy preserving manner eg improving the accuracy of composition many methods in differential privacy deal with improving the bound that is attributed to a given class of computations some of these are related to the of the sequential query composition principle and are typically much more and therefore more technically sophisticated than the method of provenance tracing described here ­ see for example and provide a compositional method for improving the sensitivity for relational algebra terms it would be interesting to investigate whether these ideas can be used our approach and introduced a framework for weighted in problematic records those extra to preserve privacy are treated the idea is that in order to better preserve privacy while not the accuracy of the query result the weight of those individual records in an aggregate query is down instead of scaling up the added to all records note that weights in are associated with each and every record whereas in proper are associated just with the original inputs by making weights part of every record the privacy of the weights themselves will be protected by the requirements of the definition of differential privacy weights are used to track sensitivity at the level of each record level ­ similar to the finegrained achieved by tracking provenance but the number of transformations that supports is more than in the price to pay is that every primitive query must be implemented to use the weights appropriately and must be proven to be differentially private in proper the correctness argument for the system itself has to be argued from first principles but the method is able to reuse arbitrary differentially private queries as without modification conclusion we have introduced a new concept of differential privacy that improves the regarding the cost of composed queries and makes it easy to include dynamic expansion of the data base we have this idea in the design of proper a system which enforces for all deterministic client programs that compute against a simple api we have proved that the proper model provides ­ and therefore also standard ­ differential privacy on limitations of affine provenance in our development of this work the implementation the theoretical development our first implementation traced the provenance for a much more general class of sql functions ie we traced provenance across operations like join which implies non affine provenance the provenance of a record may be more than one input record through our we subsequently discovered that this in fact violates differential privacy used as a mechanism where we record privacy rather than from a budget this approach is still sound since it never needs to any records from queries but it is less clear how to such a system the restriction to unary functions on the other hand limits the functionality of client programs but seems no worse than restrictions in section you can see a list of relational algebra operations that guarantee to have records with affine provenance in any case when a cannot be expressed via a transformation we can still in any other differential privacy mechanism this was further discussed in section on dynamic data and utility perhaps the advantage of is that it supports dynamic databases in a style system ­ something that seems difficult to achieve in the presence of a single global budget our prototype implementation shows a compared to requiring just a constant space overhead per record another potential advantage of is precisely each individual can set her own privacy budget however we are in our of this as a feature in its own right rather than just a means to an end what is missing in the theory of is a proper treatment of utility the personal budget determines how quickly a record will be used up this the understanding of the utility of the information returned by queries but even if we start out with every record being assigned the same budget if the has no prior on the data then it can be hard to say much about the utility of any given query one particular case where utility guarantees may be easy to give without a prior is the case when the rate at which new data enters the database is sufficiently high relative to the rate at which queries consume their assume a stream of inputs with flow rate f queue size l and individual privacy budget of b if we apply differentially private queries at an execution rate below then we can guarantee that proper can answer all queries without caused by blocking too many old records from being used in queries a more rigorous analysis of this idea is appropriate for future work acknowledgements this research has been partially supported by a grant from the foundation for research many thanks to our in the and formal methods groups for many helpful discussions and special thanks for in the early stage of the research and to for comments on an earlier draft thanks also to fournet and the anonymous for helpful comments references a f and m abadi differential privacy with information flow control in proceedings of the acm sigplan th workshop on programming languages and analysis for security pages ­ acm j l and wc provenance in databases why how and where found databases ­ y and j tracing for general data transformations the journal the international journal on very large data bases ­ s b s s j v and y chen on provenance and privacy in proceedings of the th international conference on database theory pages ­ acm c differential privacy in rd international colloquium on automata languages and programming part ii icalp volume pages ­ springer verlag c differential privacy a survey of results in theory and applications of models of computation volume of lecture notes in computer science pages ­ springer berlin c a foundation for private data analysis communications of the acm ­ c f k and a smith to sensitivity in private data analysis in theory of cryptography pages ­ springer h a framework for differentially private analysis thesis university of technology m a j a and b c pierce linear dependent types for differential privacy in proceedings of the th annual acm sigplansigact symposium on principles of programming languages popl pages ­ acm p w and r a de by a multiset extended relational algebra a formal approach to a practical issue in data engineering proceedings th international conference pages ­ ieee a b c pierce and a differential privacy under in usenix security symposium i in z informatica ­ g and s practical differential privacy via and in proceedings of the th international conference on very large data bases pages ­ c li m v g and a optimizing linear counting queries under differential privacy in proceedings of the acm symposium on principles of database systems pages ­ acm f and r network trace analysis comput rev ­ f d privacy integrated queries an extensible platform for data analysis in proceedings of the acm international conference on management of data pages ­ acm d s a and r n wright algorithms via statistics on in proceedings of the acm symposium on principles of database systems pages ­ acm i on of the least significant bits for differential privacy in acm conference on computer and communications security acm k r m r and s informationflow security for interactive programs in pages ­ ieee computer society c and m differential privacy for relational algebra improving the sensitivity bounds via constraint systems in workshop on quantitative aspects of programming languages volume of electronic proceedings in theoretical computer science pages ­ open association d s and f data to sensitivity in private data analysis th international conference on very large data bases ­ j and b c pierce distance makes the types grow stronger a calculus for differential privacy in proceedings of the th acm sigplan international conference on functional programming icfp pages ­ acm i s t v a v and e security and privacy for in pages ­ usenix association m c d and a formal verification of differential privacy for interactive systems extended abstract notes theor comput sci ­ sept l privacy integrated data stream queries in proceedings of the th annual conference on systems programming and applications software for acm j t and d m johnson information flow in nondeterministic systems in ieee symposium on security and privacy pages ­ y l and c differentially private data release through partitioning in proceedings of the th conference on secure data management springerverlag a proof of main lemma proof assume that r and c p c we proceed by induction on the length of the trace and by cases according to the last step of the trace case since we cannot have r if there are no inputs case a suppose that c p p e b a p p e b c and hence that p pp we split this into two cases according to whether r is input on the last step or earlier in the trace case a and a a t t r suppose that a t the other case is argued similarly then we must have p p for some tv and hence c p bs e s s t c p r bs e s s t r p r bs e s s t r e r hence c c since the probability of the input transition is we have p q and hence p q r e r as required case a and r the induction hypothesis gives us q p e b and such that c q p e b e r e b r b p q r from here we argue by cases according to the rule applied for the last transition p e b a p p e b in every case except for the query transition we will see that p and that p e b a c for some c in those cases it follows that p q · r by taking and using case input in this case a t and p input p hence we have transitions p e b t c where p e b t c c p bs e s s t c p bs e s s t since r t it follows easily from and that c r c case similar but simpler argument to above ­ the only change in the configuration is the program component so it follows directly from the ih case constant transformation p p and hence p e b c and p e b c where c p b c p b and we reason as for case case table variable similar to the previous case p p and hence p e b c and p e b c where c p tv b c p tv b and we reason as for case case f transformation here p p and so we have c p · · · n b c p · · · n b since from we have i r i i n and so from and it follows that · · · n r · · · n and hence we have that c r c case query here we have a rule instance of the form query p p p e b n p c and thus there is an analogous transition p e b n q c where c p e b c p e b b bs bs cs s a b bs bs c s s a c s · · s s c s · · s s a s bs cs l · a a s bs c s l · a p n q n since the environments are unchanged in this transition e r e follows immediately from the induction hypothesis suppose without loss of generality that r is in c then it remains to show that for some r bb p · p q · q · r r let us first compare the respective cost mappings c and c e e gives · tv · s whenever s r hence the only difference between c and c is a single mapping c c r · · r now consider a and a since c and c only differ on r then if br cr then a a r otherwise a a consider these cases in turn case a a and hence l l and hence p q by taking to be requirement follows from the induction hypothesis since the budget of r is unchanged in either transition then b r b follows from the induction hypothesis case a a r l · a r · a · r l · a · a where the last step follows since r a and e r e hence l l · r ­ ie the difference in the size of the sets on which the respective queries are made is · r since q is differentially private it follows from the definition of differential privacy that p q · exp · · r combining this inequality with we get p · p q · q · r · exp · · r the gives p · p q · q · r when · · r we complete the proof by showing that this value of gives b r b from the induction hypothesis we have that b and b agree on all values in their domains except r and from we have that the same holds for c and c thus b and b only differ on r for which br br cr · · r and hence b r b as required 