inductive data flow graphs university of podelski university of abstract the correctness of a sequential program can be shown by the annotation of its control flow graph with inductive assertions we propose inductive data flow graphs data flow graphs with incorporated inductive assertions as the basis of an approach to verifying concurrent programs an inductive data flow graph accounts for a set of dependencies between program actions in interleaved thread executions and therefore stands as a representation for the set of concurrent program traces which give rise to these dependencies the approach first constructs an inductive data flow graph and then checks whether all program traces are represented the size of the inductive data flow graph is polynomial in the number of data dependencies in a sense that can be made formal it does not grow exponentially in the number of threads unless the data dependencies do the approach shifts the burden of the exponential explosion towards the check whether all program traces are represented ie to a combinatorial problem over finite graphs categories and subject descriptors d verification correctness proofs f logics and meanings of programs specifying verifying and reasoning about programs general terms languages verification keywords concurrency verification static analysis introduction the success of the two main approaches to algorithmic verification is well established for their intended target domains · static analysis for the verification of sequential programs · model checking for the verification of finitestate concurrent protocols this paper addresses the algorithmic verification of concurrent programs considerable progress has been made with approaches that depending on terminology extend static analysis to concurrent control or extend model checking to general data domains ­ each of these approaches provides a different of attack to the same fundamental issue the space required to prove the correctness of a concurrent program grows exponentially in the number of its threads we propose inductive data flow graphs data flow graphs with incorporated inductive assertions as the basis of an permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission andor a fee popl january ­ italy copyright c acm approach to verifying concurrent programs an idfg accounts for a set of dependencies between data operations in interleaved thread executions and therefore stands as a representation for the set of concurrent program traces which give rise to these dependencies the approach first constructs an idfg and then checks whether all program traces are represented the size of an idfg is polynomial in the number of data dependencies in a sense that can be made formal it does not grow exponentially in the number of threads unless the data dependencies do intuitively this is possible because represent only the data flow of the program and abstract away control features that are irrelevant to the proof the approach shifts the burden of the exponential explosion towards the check whether all program traces are represented which is a combinatorial problem over finite graphs there are several directions in which one can explore the practical potential of the approach this is not the focus of this paper the focus in this paper is to introduce the approach and to investigate its formal foundation we will next explain in what sense our approach relies on the respective strength of both static analysis and model checking in static analysis techniques have been developed that are successful in finding solutions to fixpoint equations namely by solving them over abstract domains in the settings where the elements of the abstract domain denote state predicates static analysis amounts to establishing a annotation of the control flow graph of the program the validity of the fixpoint equation translates to the of the annotation ie the validity of the hoare triple at each node of the control flow graph to establish the validity of the solution for the fixpoint the hoare triples the annotation of the control flow graph has to be stored this becomes an for the naive approach to apply static analysis to a concurrent program the naive approach is to the concurrent program ie transform it to a nondeterministic sequential program whose executions include all interleaved executions of the concurrent program the size of the control flow graph of the program grows exponentially with the number of threads one motivation behind the work in this paper is the question whether static the techniques that are well established for sequential programs can be put into work for concurrent programs our approach does not aim at improving those techniques for constructing abstract domains widening strengthening loop invariants etc but instead relies on them the question is whether the output of the static analysis applied to interleaved executions of the threads of a concurrent program can be and used in a way the answer we propose lies in in model checking techniques have been developed that are successful for the exhaustive exploration of the finite though exponentially large state space of concurrent protocols model checking is a combinatorial problem that is easy in the sense that it can be reduced to search and therefore can be solved in pspace our approach relies on the efficiency of space exploration techniques as used in model checking for checking whether all program traces are represented by a given idfg the check solves a problem which is directly related to model checking and inherits its theoretical complexity bound ie the check can be implemented in polynomial space polynomial in the number of threads of the given concurrent program we will next explain how the concept of data dependencies in connection with hoare triples leads to assume trace is composed of three actions a x a y and x y a possibly from different threads of a concurrent program the two edges in the graph to the right express the z xy data dependencies in conceptually the graph represents the set of all traces that preserve the data expressed by its edges such traces contain the three ac tions in an order that with the two edges ie a and a must occur before a they can contain additional actions as long as these actions do not modify the value of x y or z all such traces have the same behavior which formally means that they satisfy the same set of pairs now in the set of verification where correctness is defined by one particular pair we would like to have a more sense of data dependencies and thus a means to define a more set of traces as an example we take the pair that defines the correctness of the trace in the hoare triple below x y x y z the essence of a possible correctness proof for consists of the three hoare triples below x y z y y y x x x in addition to the three essential hoare triples the correctness proof contains the two stability hoare triples below which state the invariance stability of an assertion under an action y x y x y x we obtain the two hoare triples below by taking the sequential composition of hoare triples that appear above x x y x y x y y to obtain a correctness proof for we apply the conjunction rule to these two hoare triples and then sequentially compose with the hoare triple for in the idfg to the right is constructed x y from the correctness proof for the trace the annotation of edges with assertions corresponds to the three hoare triples x y in which form the essence of the cor x y proof we consider the idfg to be a repre z xy the set of all traces such that the three hoare triples in form the essence z of a possible correctness proof all other axioms used in the cor proof are stability hoare triples by definition all traces in this set are correct the set contains the trace we next give more examples of traces in the set if we the actions a and a in the trace the resulting trace lies in the set the essence of the correctness proof for is the three hoare triples in the other hoare triples in the correctness proof for state the stability of x under the action y and the stability of y under the action x if we add actions to the trace or to the trace and the assertion at each position with an added action is stable under the added action then the new trace lies in the set the essence of its correctness proof are the hoare triples in the new hoare triples in the correctness proof are stability hoare triples the edges in an idfg explicitly formulate ordering constraints on the actions in a trace as in the example above we will next illustrate that the assertion labels of edges implicitly define additional ordering constraints the idfg shown to the y x right can be constructed from the correctness proof for the x y y x trace composed of the actions b xy b yx and x yx b correctness is defined as above through the z same pair the assertions labeling the two z edges are x and y x the assertion x is stable under the action b the hoare triple x yx x holds however the assertion y x is not stable under the action b the hoare triple y x xy y x does not hold this means that the action b may come after the action b but not vice versa that is the trace lies in the set of traces represented by the idfg but the trace does not note that the trace is correct but the trace is not we use as the basis of an algorithm to verify concurrent programs see also figure the algorithm iteratively a program trace applies a static analysis to the program trace uses the output of the static analysis to construct an idfg merges the new idfg with the one constructed so far and checks whether the set of traces that is represented by the resulting idfg includes all program traces if this is the case the iteration stops the program is proven correct in section we will see examples in the context of concurrent programs sections to then present the individual conceptual and technical contributions of our work · the concept of as a representation of a set of interleavings of thread executions and the characterization of program correctness by an idfg section · the reduction of the check of program correctness given a program and an idfg to a combinatorial problem in pspace section · the formalization of a measure of data complexity and the proof that can be polynomial in this measure section · a verification algorithm section and · the proof that the algorithm constructs a idfg under the assumption that the underlying static analysis provides the required inductive assertions section examples in this section we use a few simple examples of concurrent programs to illustrate algorithm the code below implements a version of mutual exclusion protocol for two threads the integer variables n and n the are initially set to the boolean variables e and e to false we use the notation exp for assume statements trace idfg g init a e true a tmp n a n tmp a e false a a n n n b e true b tmp n b n tmp b e false b b n n n n true tmp n tmp tmp n tmp n n tmp n tmp n n n n n n false trace b e true b tmp n a e true a tmp n a n tmp a e false b n tmp b e false a a n n n b b n n n idfg g n init n tmp n tmp n tmp tmp n tmp n tmp n n n n n false trace b e true b tmp n b n tmp b e false b b n n n a e true a tmp n a n tmp a e false a a n n n idfg g init true n tmp n tmp n tmp n tmp n tmp n tmp n n n n n n false trace a e true a tmp n b e true b tmp n b n tmp b e false b b n n n a n tmp a e false a a n n n idfg g init true e true e true false figure four traces of the algorithm and their corresponding the four constitute a proof of the correctness of the mutual exclusion property correctness here means every trace that violates mutual exclusion is infeasible ie has postcondition false the precondition is n n e e false the action init is a dummy label of the initial node in an idfg then skip else block thread b cannot enter its critical section unless either n thread a has not to enter the critical section or n n thread a has but it has done so after thread b for thread a except if there is a tie n n thread a has priority over thread b to enter its critical section first we break the acquisition statement n n into two statements tmp n and n tmp to reflect the possibility of the update we treat individual program statements as atomic the flag e initially false is used to communicate that thread a is entering that is it is in the process of its the flag e is used similarly for thread b thread a a e true a tmp n a n tmp a e false a a n n n critical section a n thread b b e true b tmp n b n tmp b e false b b n n n critical section b n we wish to verify that this protocol guarantees mutual exclusion only one thread at a time can be in its critical section each trace leading to a state where both threads are in their critical sections after executing a respectively b must be infeasible ie there exists no initial state that has an execution along the trace or equivalently must have the postcondition false trace in figure is a run of where first thread a runs until it enters its critical section and then thread b runs until it enters its critical section the idfg g in figure expresses the essence of the proof that trace is infeasible this graph should be read from bottom to top and should be thought of as backwards proof argument along the lines of the following between and why is trace infeasible ­ thread b can not execute the statement b ­ why not ­ when thread b tries to execute b n thread a has a and n n thread as is smaller than thread bs the then · why is n at b ­ thread a executes at a when tmp ­ but what about everything that happens between a and b ­ irrelevant nothing between a and b can change the fact that n ­ why is tmp at a ­ · why is n n at b ­ the idfg g in figure keeps account of the relevant details of the trace eg the edge labeled n represents that a must be executed before b and nothing executed between a and b may change the fact that n it abstracts away irrelevant details of the trace eg the ordering between a and b the idfg represents the set of traces which are infeasible for essentially the same reason as trace ie which have essentially the same hoare triples in the proof that the postcondition is false the traces in the set can be obtained from trace by reordering actions or by inserting actions that are irrelevant for the proof they leave the corresponding assertion stable informally the set contains all traces where thread b enters its critical section while thread a has a smaller nonzero every trace that violates mutual exclusion into one of four scenarios each scenario being by a trace in figure the scenarios are trace thread b attempts to enter its critical section when thread a has a smaller trace the symmetric scenario where thread a attempts to enter its critical section when thread b has a smaller trace thread b attempts to enter its critical section when thread a and b have the same that thread a has priority in this situation trace thread b enters its critical section without waiting for thread a to receive its the g g express the essence of the proof of the of each trace that into the corresponding scenario together they form a proof of the correctness of this is because each trace of into one of the four scenarios formally it lies in one of the four sets represented by g g which one can check with the algorithm of section note that there is no need for a new idfg for the trace symmetric to trace the corresponding scenario is for by the scenario of trace this is due to the of the protocol thread a has priority over thread b if they have the same increment example we use a simple program with a parametrized number of threads to illustrate the exponential of data flow graphs the program has one global variable x initially and is composed of a thread that asserts x and a parametrized number n of threads that each increment x once thread a n thread a x thread n an x the program is safe the assert never fails if x n is an invariant for the correctness of the program x x n init means that each trace containing the assume statement xn is infeasible x ie has postcondition false the idfg shown on the right is a proof of the cor x n x of the program its size linear x in n as one can check section the set of traces it represents xn x contains all program traces thus it is a proof of the correctness of the program the program is based on an example that was used in to x n x the need for auxiliary variables in compositional proof rules the pro xn gram is a challenge for many existing approaches we ran experiments for example with the tool x xn which generates type proofs and relyguarantee type proofs x n and with the tool which uses using craig inter false with slicing in both tools the space used for the proof grows exponentially in n if we consider the increment actions of each thread as pairwise distinct ie the program has n actions instead of just one then we can give a correctness proof in the form of an idfg of size quadratic in n the graph can be depicted as an n matrix of vertices each column i contains n vertices labeled with the increment action of the ith thread plus the vertex labeled xn each vertex in row j has an edge to every vertex in row j the set represented by this idfg thus contains traces with more than one occurrences of the increment action of the same thread for example the traces corresponding to a column these traces do not correspond to a path in the control flow graph but they are correct this illustrates the point that a set of correct traces can represented more if it is larger algorithm in the parametrized version of the algorithm depicted below the statement at line i for i n indicates an atomic operation that increments t after assigning its current value to mi initially s t the algorithm is a challenge for many existing approaches to concurrent program verification in that as with the increment example the space used for the proof will grow exponentially in n thread m t m s critical section s s thread n n mn t n mn s critical section n s s we can give a correctness proof in the form of an idfg of quadratic size in n it is related to the one for the increment example we present its construction for n as an example in section inductive data flow graphs we will first introduce the notation needed to define the correctness of programs we then introduce the notion of inductive data flow graphs and use it to characterize program correctness to abstract away from the of a programming language and from the of a program analysis and verification en we use a very general a program is given as an graph p loc the control flow graph where the edge labels are taken from the set actions a given set of actions ie we say that the edge between the two vertices locations and is labeled by the action a if a the program p loc can be defined as the parallel composition of a number n of programs p loc pn n we will say that p pn are the threads of the program p its set of locations is the cartesian product of the sets of thread locations ie loc loc × · · · × each edge i ai i in the ith thread pi gives rise to an edge ai in the program p the edge is labeled by the same action ai and goes from the location i n to the location i n ie only the ith component can change in algorithms that take p pn as the input the control flow graph for the program p is generally not constructed explicitly we assume a set of assertions each assertion is a first order logic formula over a given vocabulary that includes a set var of variables the program variables we assume that the set of assertions comes with a binary relation the entailment relation each action a comes with a binary relation between assertions the set of its pairs we say that the hoare triple pre a post is valid if the binary relation for the action a holds between the assertions pre and post it is useful to suppose that we have actions that correspond to assume statements that is for every assertion we have an action such that the hoare triple pre post is valid if the assertion post is by the conjunction pre a trace is a sequence of actions say a an we extend the validity of hoare triples to traces in the canonical way the hoare triple pre post is valid for the empty trace if pre entails post it is valid for the trace a an if each of the hoare triples pre a n a post is valid later when we formulate algorithms we will abstract away from the specific procedure static analysis interpolant ation used to construct the sequence of intermediate assertions n to define the correctness of the program p we need to define its set of program traces we assume that the control flow graph of the program p comes with an initial location and a set f of final locations we say that the trace is a program trace of p if labels a path between the initial and a final location not every such path corresponds to a possible execution of the program the set of program traces is generally not we say that the program p is correct wrt to the pair pre post if the hoare triple pre post is valid for every program trace of p we will later characterize program correctness in terms of the notion that we introduce next definition inductive data flow graph idfg an inductive data flow graph idfg g v e pre post v consists of a graph v e an assertion pre the precondition an assertion post the postcondition a vertex v v the initial vertex and the subset of vertices v the set of final vertices · vertices are labeled by actions we use to denote the action that labels v the initial vertex v has a dummy label the special action init which has the same hoare triples as skip ie init holds if entails · edges are labeled by assertions ie e v × × v we require that the initial vertex v has no incoming edges we will use the notation v v to denote an edge from v to v labeled by the assertion · the labeling of edges with assertions is inductive ie for every vertex v labeled with say the action a the hoare triple a holds for assertions and chosen as follows if v is the initial vertex ie v v then is the precondition pre otherwise is the conjunction of the assertions labeling the incoming edges to v if v is a final vertex ie v then is the conjunction of the postcondition post and the assertions labeling the outgoing edges of v otherwise is just the conjunction of the assertions labeling the outgoing edges of v remark if the initial vertex of the idfg g is a final vertex then the precondition of g entails its postcondition formally if v then pre post we will use an idfg g as a representation of a set of traces g the denotation of g the set g consists of those traces for which g can be a justify the correctness of in this paper whenever the context is given by an idfg g the term correctness refers to the pair of g we will next use an example to explain how one uses an idfg g to justify the correctness of a trace ie how one derives that g consider the g g in figure which all have the same precondition pre x y but different postconditions the trace and its prefix traces xy x and we will derive g via g g and g in one derivation branch and via g g and g in the other by remark the precondition of g entails its postcondition so we can use g to justify the correctness of the empty trace wrt the specification of g ie the validity of pre x thus g the idfg g has the postcondition x the trace is of the form x we have already used g to justify that has the postcondition x since by the of g the hoare triple x x x is valid we can use g to justify the correctness of wrt the postcondition x thus g the trace is of the form y we have already used g to justify that has the postcondition x the idfg g has the postcondition x which is stable under the action y ie x y x is valid taken together this means that we can use g also to justify the correctness of wrt the postcondition x thus g we use g to justify the correctness of now wrt the post condition y in three steps that are similar but not symmetric to the previous one we derive g by remark g because x and the postcondition of g is stable under the action x ie y y y and g y and by the of g y x y is valid the trace is of the form we can use g and g together to justify that has the postcondition x y which is the conjunction of the of g resp g since by the of g x y z is valid we can use g to the correctness of wrt the postcondition z thus g in the derivation above xy the g and g to the two init ing edges to the final node of g are treated in conjunction true x y one derives that the prefix of lies in g and in g we next illustrate that x x x x y y the notion of also provides a concept of z xy tion in the idfg g to the right two of the three z ing edges to the final node are labeled with the same assertion namely x the two corresponding to the two edges are g and g where g is as before and g is the idfg whose final node is the new node labeled with the action x both g and g have the postcondition x they are treated in disjunction in order to derive g one can derive that lies in g or in g as a consequence we can derive not only g via g but also g where via g where xy the examples above illustrate how one can use an idfg g to justify the correctness of a trace and derive g the definition below generalizes the examples definition denotation of an idfg g we define when a trace lies in the denotation of an idfg g formally g by induction over the construction of the trace the empty trace lies in g iff v the trace a obtained by the action a at the end of the trace lies in the denotation of an idfg g of the form g v e pre post v if either · the postcondition of g is stable under the action a and the trace lies in the denotation of g ie post a post and g or g x y init x y g x y init x y g x y init x y g x y init x y g x y init x y x y x y z xy x y x y z xy x y x y z xy x y x y z xy x y x y z xy z z z z z figure example used to illustrate definition the five differ in the postcondition post and the set of final vertices in each idfg consists of the vertex with a dangling outgoing edge the edge has no target or its target lies in the gray part of the graph and post is the assertion labeling that edge for example the final vertex of g is the vertex labeled with the action x and post is x the final node of g is the initial vertex and post is x · one of the final vertices vf is labeled by the action a and the assertions n are the labels of the incoming edges of the final vertex vf ie n v vf for each i n the trace lies in the denotation of the idfg gi which we obtain from g by taking the assertion i for the postcondition and the set of vertices vi defined below for the set of final vertices ie gi v e pre i v vi where vi is the set of vertices that have an outgoing edge labeled with the assertion i to the final vertex vf ie vi v v i vf remark an alternative equivalent definition of the denotation of an idfg is based on fixpoints given the idfg g as above we define a monotone function f v actions v actions over the complete lattice v actions as follows f lv and for all v v f lv where stable a actions a we use l to denote the least fixpoint of f the denotation of g can be equivalently defined as below g the following observation a direct consequence of definition relates the correctness of a trace with the denotation of an idfg remark let g v e pre post v be an idfg then for any g the hoare triple pre post holds since we defined that the program p is correct wrt the pair pre post if the hoare triple pre post is valid for every program trace the above observation gives immediately rise to a characterization of program correctness theorem program correctness via idfg a program p is correct wrt the precondition pre and the postcondition post if there exists an idfg g with precondition pre and postcondition post such that every program trace of the program p lies in the denotation of the idfg g program traces of p g we say that g is a proof for p if the above inclusion holds in the next sections we will investigate how one can check the inclusion for a given program and a given idfg and how one can construct an idfg checking in order to show that a given idfg g is a proof for a given program p we need to check the condition that every program trace of p lies in the denotation of g we will reduce this check to an inclusion problem between two automata the set of program traces of the program p is the set of of paths between the initial location and a final location f in the control flow graph of the program p as mentioned previously not every such path corresponds to a possible execution of the program thus the set of program traces is a regular language over the alphabet actions the set of actions it is recognized by the program p viewed as an automaton its set of states is loc the set of program locations its transition are the edges a state goes to state upon reading letter a the initial state is the initial location and the set of final states is the set f of final locations we use la to denote the language recognized by the automaton a we thus have program traces of p lp we will next transform an idfg g into an alternating finite automaton alternating finite automata or are a generalization of nfa this generalization is easily understood if one views the generalization from dfa to nfa as follows the value of the deterministic successor function is generalized from a single successor state to a disjunction of states and the initial state is generalized to be a disjunction of states the nfa associates with any word a boolean expression in fact a disjunction of states obtained by repeatedly rewriting the initial formula using the successor function and accepts if that boolean expression evaluates to true under the assignment that sends final states to true and states to false the generalization to is then very natural one allows a general boolean expression over states for the image of the successor function and for the initial condition from data flow graph g to alternating finite automaton ag given the data flow graph g v e pre post v we define the ag q q where · actions · q v v v v v post vf vf · v a skip v a step v a where skip v a v if a false otherwise step v a v v false v v v v if a otherwise · q vf post vf · v q v v the observation below is immediate by the fact that the construction of ag the definition of the denotation of g we write for the reversal of the language l remark the set of traces denoted by g is the reverse of the language recognized by ag ie g we can now theorem from the previous section the check whether a given language is included in the reversal of the language of a given can the construction of the reversal of the because we can reverse the program traces instead theorem checking program correctness via an idfg a program p is correct wrt the precondition pre and the postcondition post if there exists an idfg g with precondition pre and postcondition post such that the language inclusion lp holds for the program automaton of p and the alternating finite automaton ag derived from the idfg g the theorem above expresses that we can shift the burden of having to deal with the exponential size of the control flow graph of a concurrent program p defined by the parallel composition of n threads to a combinatorial problem over finite graphs and thus to a place where it less in comparison to a setting where one has to deal with data we can view the problem as a finitestate model checking problem since it is equivalent to the satisfaction of a linear time property a regular safety property defined by the by a finitestate model the control flow graph of p it is a classical result that this problem can be solved in polynomial space theorem pspace the problem of checking whether an idfg g is a proof for a program p given as the parallel tion of n threads ie checking whether all program traces of p are included in the denotation of g is pspace in the number n of threads of in this section we justify our claim that are proof objects we introduce proofs in order to define a measure of the difficulty of proving that given program p satisfies a specification pre post we call this measure the data complexity of p with respect to pre post we prove that if there exists a small proof of correctness for a program ie if the program has low data complexity then there exists a small idfg proof it is easy to construct an idfg proof from a control flow graph with a annotation by replacing edges with vertices and vertices with edges this construction proves the completeness of our proof rule relative to the completeness of proofs but it leaves something to be desired for a concurrent program p the idfg resulting from this construction is of the same size as the control flow graph for p which is exponential in the number of threads in p in the rest of this section we develop a characterization of when it is possible to prove that small idfg proofs exist consider the increment example from section there is an intuitive sense in which it is easy to prove that this program is correct because although the size of the control flow graph for increment is exponential in the number of threads the number of distinct assertions in the labeling of the control flow graph as required by a proof is linear the assertions appearing in the annotation are the ones of the form x i for i n following this example a first attempt at defining a measure of the inherent difficulty of proving a program correct wrt a specification may be the minimal number of assertions in a proof of the property this definition fails a natural requirement for such a measure which is that if the threads have no shared data disjoint parallelism then their parallel composition should have a small proof it is for this reason that we introduce the concept of proofs we first explain the intuition behind proofs and then give their formal definition proofs are a way of how compositional a proof is while avoiding syntactic issues common to practical compositional proof methods such as auxiliary variables in or relyguarantee a proof essentially splits each assertion in the annotation of the control flow graph of p into a global assertion and a set of local assertions local for a thread the total number of distinct assertions both global and local can then be seen as a measure of the inherent complexity of the proof the intuition behind this view comes from the idea of transforming a proof in some other framework eg to a proof for the product program in performing this transformation assertions from the proof will be replicated several times an assertion attached to the control location of some thread pi will appear as a conjunct in each assertion attached to a location of the control flow graph of p where thread pi is at ie a location of the form i n where i definition proof given a concurrent program p defined by the parallel composition of n threads p pn and a pair pre post a proof n is as a tuple of annotations ie mappings from locations of the control flow graph of p to assertions where each assertion the global assertion at may refer to global and local variables but each assertion i may refer only to the local variables of thread pi if the edge a labeled by the action a from the location to the location in the control flow graph of p is induced by the edge k a k of the thread pk ie if n and n then i i for i k then the hoare triple k a k is valid and for all i different from k the local assertion is the same for location and location ie i i for i k the assertions at the initial location are by the precondition ie pre i for i n every final location is annotated with the same tuple of assertions and their conjunction entails the postcondition ie there exist n such that n for all final locations and · · · n post a proof can be viewed as a particular presentation of the proof that labels each location with the conjunction of the global assertion and all local assertions for location in a case of a proof the local annotations · · · n are all trivial ie i true for each location of p and for i n in this case the whole assertion for location in a proof is put into the global assertion of the proof the size of a proof n is the number of distinct assertions appearing in formally size · · in where denotes the range of the annotation and is the set of actions in the ith thread pi example consider the following simple example program consisting of n threads which each increment a local variable ti before storing that value in a global variable x thread t xt thread n tn in the hoare proof that this program satisfies the specification pre x t tn post x a distinct assertion is required for each combination of values for the ti and x variables except the combination where x and each ti the total number of such assertions is n in the hoare proof i assigns ti to every location after thread i executes ti and ti to every other location the global annotation assigns x to every location where some thread has executed and x to every other location the size of this proof is in · · n definition data complexity given a pair pre post the data complexity of a program p is the size of a proof that p satisfies the specification pre post we can now state the main result of this section theorem size of idfg proofs given the pair pre post if a proof for the program p exists then there ex a proof for p in the form of an idfg whose size is polynomial in the data complexity of p proof let pre post be a specification p loc be a program obtained as the parallel composition of n threads p pn and n be a proof of minimum size that p satisfies prepost we construct an idfg g v e pre post v that proves that p satisfies the specification prepost the set of vertices of g consists of the initial vertex v regular vertices and final vertices v v the regular vertices are defined as a i i n a i where for any i n i denotes the set of edges due to thread pi the final vertices are defined as a n a f where f denotes the set of final locations of p the labeling act of a vertex v with an action is as one expects the construction of the set of edges of g uses two auxiliary functions the function in maps each vertex v to a set of assertions that will label the incoming edges to v and the function pre maps each vertex to an assertion that can be thought of as its precondition inv in a i i in a n n prev pre pre a i i pre a n · · · n the set of edges is defined as e u v u v v u inv and a for and a this completes our definition of g it is easy to check that the labeling of the edges of g with assertions is inductive we now argue that the number of vertices of g is linear in the size of the proof and therefore the size of g is polynomial a regular vertex is a triple of an action a global assertion and a local assertion hence the number of regular vertices is at most size a final vertex corresponds to a location that has an edge to a final location in p according to the definition of a proof can vary from only in two components the global assertion and one of the local assertions and every final location is annotated with the same tuple of assertions ie hence the number of final vertices is at most size in order to prove that every program trace of p belongs to g we prove the lemma below here the notation gv refers to the idfg obtained from g by making v the unique final vertex and the postcondition for a vertex v of g and an assertion gv v e pre v v lemma for any path · · an n in p of length n starting at the initial location and leading to the location n there exists a tuple of vertices u u un such that · · an i n for i n before we prove this lemma we show why it implies that every trace of p belongs to g suppose is a trace of p then there exists a path · · an n such that · · an and n is a final location by the lemma there exists some u u un such that · · an i n for all i n let an n n n n then it follows from the construction of e that ui in e for all i n and thus that · · g now we prove the lemma by induction on the length n of paths in p the base case n is trivial we may set each of u u un to be the initial vertex v for the induction step suppose that · · an n is a path in p and that there exists u · · un such that · · an belongs to i n for all i n let k n be the index of the thread that executes the last action an we distinguish two cases for i k we may take ui ui by the induction hypothesis · · an i n by condition of definition i n i n so · · an i n since i n is stable under the action an since an is executed by thread k i it follows that · · i n for i k we make take ui an n k n by the definition of e we have u n ui e and uk kn ui e since by the induction hypothesis · · an is in both n and i n we have the desired result · · k n we still need to choose a vertex of g that we take for u we take the same vertex that we took for ui the same argument as above shows that · · n the proof shows that the number of nodes of g is linear in the data complexity in the extreme case of disjoint parallelism a concurrent program composed of n threads with no shared data there exists a proof without global assertion formally each global assertion is true in this case the idfg constructed in the proof of theorem is essentially the collection of local proofs as in an style proof the local proofs are connected via edges from the initial vertex v its vertices correspond to pairs consisting of an action and a local assertion hence the number of its vertices is linear in n a special case of this theorem is a concurrent program in a parametrized number n of threads that has a proof where the number of global assertions ie the size of grows linearly in n and the number of actions and local assertions ie the size of is constant the increment example from section into this case the idfg constructed in the proof of theorem has on vertices as does the one we constructed manually in section in section we also at the idfg with on vertices for the case where we rename apart the action x in each thread this case illustrates the motivation to use the number of actions as a parameter for the data complexity which becomes quadratic in n in this case in the case of the algorithm not only the number of global assertions but also the number of local assertions grows linearly in n therefore the data complexity is quadratic in n indeed the idfg we will construct in section has on vertices verification algorithm in this section we develop an algorithm for verifying concurrent programs given a program p and a pair pre post the goal of this algorithm is to either · construct a proof for p in the form of an idfg g or · return a counterexample ie a program trace such that the hoare triple pre post does not hold we use figure to explain the basic idea behind the algorithm the algorithm starts by a program trace if the trace does not satisfy the hoare triple pre post then the program is not correct with respect to the given specification if it does then is abstracted into an idfg g the algorithm maintains an idfg g that represents a set of traces proven correct initially this set is empty the idfg g is updated by merging it with g if the resulting idfg contains every program trace then g is a proof for the program if not then the algorithm keeps generating traces and updating g until either a proof or a counterexample is found in component d we check whether an idfg g is a proof for p which means checking the inclusion lp g we discussed how to this in section the failure of the inclusion check means that there is a trace in the difference between the two sets lp g by choosing such a trace in component a a pick a program trace d no does g represent all program traces yes program is correct is correct no program is incorrect b yes construct an idfg g from c merge g into g figure verification algorithm based on inductive data flow graphs initially g is empty we ensure progress of the algorithm ie after each iteration g denotes a larger set of correct traces in what follows we discuss the remaining components b and c we will explain how an idfg g is constructed from a trace section and how idfg g is updated by merging it with g section finally we present the full algorithm in section constructing an idfg from a trace we will present an algorithm that given a trace and a pair pre post such that the hoare triple pre post holds constructs an idfg g with the same pair whose denotation contains by remark g is a proof for the correctness of ie for the validity of the hoare triple pre post this algorithm uses an auxiliary procedure given a trace which ends in the action a ie a and which is correct for a given pair of assertions pre post ie pre a post the call of the auxiliary procedure a post returns an intermediate assertion such that pre and a post the auxiliary procedure is always applied to a finite program trace which is effectively a very simple sequential program this means that it can be implemented by one form or another of static analysis applied backwards to this sequential program that consists just of the trace one can the power of existing static analysis methods such as apply a backwards transformer in some abstract domain craig interpolation weakest precondition computation among others to construct intuitively the procedure takes the trace and detects what actions in and what ordering constraints in are irrelevant for the postcondition this is accomplished by the procedure as follows · if a returns the postcondition and thus the postcondition is stable wrt the action a ie a and therefore a is irrelevant · otherwise if a returns a proper conjunction · · · k then each assertion or k can be as postcondition for the prefix trace in parallel as opposed to in sequential order one possibility to parallelism is to have return formulae in conjunctive normal form the particular strategy to break the intermediate assertions into conjuncts does not matter for the correctness of the overall algorithm note that produces acyclic without no vertex has multiple incoming edges labeled with the same assertion and cycles will be produced by the merge procedure that we will discuss in section algorithm input trace and a pair of assertions such that output proof for in the form of an idfg g ie g has the pair and g if then return g v v v else a for some trace and action a a if then return else · · · k v fresh vertex with label a ie a parallel for i k do vi ei i v i end parallel for v v ik vi e u i v u return g v e v v end if end if example we will demonstrate the algorithm by applying it to trace of in figure a the precondition is n n and the postcondition is false we use to denote trace and to denote the prefix of obtained by removing last action b for this example we use the craig interpolation feature of to implement the first call to in yields the following interpolant b false n n n intuitively the order in which the two assertions n and n n are enforced is irrelevant as long as both are enforced before b is executed this is reflected by how the execution of proceeds namely by calling n and n n in parallel the two calls correspond respectively to the left and the right branch of the idfg c in figure in order to illustrate how irrelevant actions we will continue and follow the execution of the call n we use to denote the prefix of obtained by removing last action which is the action is irrelevant in the sense that it is not needed to enforce the postcondition n this is established by when the next interpolant along this branch is computed n n since the computed interpolant is the same as the postcondition enters the then branch of the conditional and proceeds to the call n the algorithm continues to irrelevant actions in this way going backwards along until it comes to the first action under which n is not stable which is a n tmp this action becomes the next vertex along the n branch of the idfg in figure a the essential property of is that it constructs an idfg proof of the correctness of a trace with respect to a given this is expressed in the following lemma lemma let be a trace that is correct with respect to the and let g then g merging our merge operator g g can be thought of as a three step process in the first step we construct the disjoint union of g and g in the second step completion we this idfg by adding edges that do not violate the property for in the third step reduction we equivalent vertices we begin with a declarative definition for what it means for an idfg to be complete ie definition complete an idfg g v e v is complete if · for any v v with such that prev holds v · for any u v v and any such that v has an incoming edge labeled and holds u v e where prev if v v otherwise completion plays an essential role in the construction of idfg proofs for programs it is essential for producing proofs of programs that contain loops note that as we mentioned in section the procedure does not introduce any are essential for capturing program behaviour produced by loops the completion process can introduce these necessary for example consider the following sim ple program and its specification x y while x y x y the idfg to the right proves that init xy this program satisfies the specification the subgraph consisting only of the arrows x can be generated by from a x y x y sample trace of the program xy the remaining dotted edge is added to the idfg y by the completion procedure since x has an incoming edge labeled x y and the xy hoare triple y x y holds this generalizes the idfg so that it proves the correctness of any number of iterations of the loop rather than a single iteration the following is a declarative definition for what it means for an idfg to be reduced ie definition reduced an idfg g v e v is reduced if there exist no distinct u v v such that and the set of assertions labeling the incoming edges to u and v are the same ie ww v e ww u e there is an algorithm that given an arbitrary idfg g constructs a reduced complete idfg such that contains g we call the reduced completion of g this is stated formally in the following proposition proposition for every idfg g v e pre post v there is a reduced complete idfg that can be computed from g in · e time and such that the precondition of is pre the postcondition of is post and g proof for any vertex v we define inv uu v g we define v e pre post v where v v inv v v v e a a a v a pre a and v inv v inv v if pre post otherwise it is easy to check that is welldefined the machinery required to prove that g is presented in section finally we describe our merge operation the merge operator g g functions by forming the disjoint union of g and g and then taking the reduced completion of the resulting idfg formally we define merge as follows definition given two g v e v and g v e v their merge g g is defined to be the idfg g g rc v e v where v v v e e e and is defined in the obvious way for simplicity this definition assumes that the initial vertex of g is also the initial vertex of g and that otherwise their vertices are disjoint applying the rc operator in the merge plays an essential role in reducing the size of idfg proofs for example the idfg proof for the example from section would require on vertices without applying the rc operator see example the progress of our algorithm depends on the following lemma concerning the merge operator lemma let g and g be two we have g g g g an example of the merge operator appears in figure part c is the merge of parts a and b notice that c proves that the trace s is infeasible starting from the precondition s t even though this fact is not proved by a or b putting it all together we are now ready to present a formal description of our verification algorithm the last component of this algorithm that has not already been described is the initialization of g if pre implies post or equivalently the hoare triple pre post holds then g is initialized to an idfg with a single vertex that is both initial and st st init t m t t s m t m s m t m s a init t m t t s m t m m s false m t m s m t m s b m t m m s false st s s init t t m t t m t t m t m t m m m s m s false c false figure intermediate for the algorithm final and therefore g otherwise g is initialized to an idfg that has no final vertices and therefore g algorithm verification algorithm input program p precondition pre postcondition post output yes if p is correct wrt the specification no otherwise if pre entails post then g v pre post v v else g v pre post v end if while lp g do let lp g if the hoare triple pre post holds then g pre post g g g else return no with counterexample end if end while return yes as a direct consequence of lemmas and we can state the following progress property of the verification algorithm proposition progress if gi and gi are the con by the verification algorithm in respectively the round i and round i then we have gi gi the inclusion is strict we conclude this section with an example run of the verification algorithm on the algorithm mentioned in section example we consider the thread instance of the mutual exclusion algorithm which runs three copies of the thread below in parallel where i is substituted for the thread id the first two of the thread i cation algorithm are depicted in figure since the property of interest is mutual exclusion we take the traces i mi t i mi s critical section of this program to be the ones that i s s end with at least two threads inside their critical section and prove that the program meets the cation with precondition s t and postcondition false ie every trace mutual exclusion is infeasible the algorithm begins with the empty idfg g the first program trace that we select in lp g is depicted in fig a along with an idfg proof for as constructed by we call this idfg g t true init t s m t t m m t t m t m t m t t m t m t m t m m t m m m t m s m m s s m m s m m s m s m s m s s figure correctness proof of the algorithm note that the postconditions all false have been removed from the figure to keep it clean in a complete version of this figure all nodes with labels mi s have a dangling arrow with a label false on the next iteration of the loop we select the trace depicted in part figure b and merge its corresponding idfg proof called g with g to form g in figure c since g does not cover every program trace ie lp lg the algo rithm continues the loop after four more iterations the algorithm will terminate after all traces that violate mutual exclusion have been proved to be infeasible the idfg that is constructed by this algorithm is depicted in figure the intuition for the idfg in figure can be used to construct a proof for the mutual exclusion algorithm for any number of threads for any such idfg proof the number of vertices is quadratic in the number of threads properties of the verification algorithm we will now investigate the properties of the verification algorithm in particular we prove that the algorithm is sound that it is complete under the assumption that the auxiliary procedure returns the right assertions and that its time and space complexity is polynomial in the data complexity of the input program and specification again under the assumption about we will also introduce some technical machinery required to prove these results we begin with soundness if the algorithm returns a result then the result is correct which is a direct consequence of theorem theorem soundness if the verification algorithm returns safe p satisfies the given specification if it returns unsafe the program does not satisfy the given specification we now move on to our completeness result no algorithm exists that is complete in the strong sense due to the halting problem instead we show that the verification algorithm is complete in the sense that if a there exists a safety proof for a program then the algorithm will find one under the assumption that produces the right assertions we formalize this by assuming that is a nondeterministic procedure that may return any valid interpolant and showing that the following holds theorem completeness if a program has a hoare safety proof then there exists a run of the verification algorithm that terminates with a safe result in fact we can this completeness theorem and give bounds on the time and space required by the verification algorithm theorem complexity if a program p has a hoare proof that it satisfies a specification prepost then there exists a run of the verification algorithm that terminates with an idfg of size in the data complexity of p wrt prepost moreover the number of iterations of the main loop of the algorithm required to produce this proof is polynomial in the data complexity the proof of this theorem requires some technical machinery which will be presented in the following however we present some early intuition on the proof for readers that wish to skip the technical details in the remainder of this section we assume that we are given a proof presented as an idfg g the size of which we may assume is polynomial in the data complexity by theorem given any trace there is a of g that corresponds to roughly speaking this structure corresponds to the accepting run of through the corresponding to g under the assumption that produces the assertions corresponding to this structure pre post produces this structure exactly intuitively this is a way of reasoning about why the appropriate assertions exist for to produce we can show that g is covered by finitely many such so that the algorithm will terminate in finite time with a proof that is essentially the same as g proofs we now present the technical machinery required to prove theorem the main concept we introduce here is idfg which is a structural relationship between we say that an idfg g into g if g can be mapped onto a subgraph of g in a way that is in some sense tight formally we define an idfg embedding as follows definition embedding given g v e pre post v and g v e pre post v sharing the same precondition and postcondition we say that a map h v v is an embedding if the following hold · v v and uu v e uu hv e · hv v · v hv · u v e hu hv e if such an embedding exists we say that g into g the main property of interest concerning is the following lemma lemma if g and g are such that g into g then g g the key idea of our completeness theorem is that we can use a given idfg proof g as an oracle to guide the interpolation procedure so that pre post will yield an idfg representing some of the target proof g ie an idfg that into g formally lemma for any idfg g v e pre post v and any trace g there is a run of pre post that produces an idfg g such that g into g our proof of theorem is based on being able to maintain a loop invariant that g into some target proof g in order to prove this invariant we must show that if g and g embed into some target proof g then g g also into g formally we have the following lemma for any g and g sharing the same and postcondition both g and g embed into g g for any complete idfg g such that g and g both embed into g g g into g we are now ready to provide a sketch of the proof of rem in fact we will prove a stronger by theorem result for any reduced complete idfg g such that lp g there exists a run of the verification algorithm that terminates with an idfg g such that lp g and such that g into g since g and g are reduced and complete the fact that g into g implies that g is no larger than g moreover regardless of how traces are chosen from lp g the algorithm will terminate in at most v iterations where v is the number of vertices in g the proof is by induction we assume that at the start of the iteration of the loop g into g and prove that there is an execution of the loop body such that the number of vertices in g increases and such that g still into g at the end of the loop let lp g since g is a safety proof we must have lg by lemma there exists a run of pre post that produces an idfg g that into g we let g g g be the idfg at the end of the loop the invariant that g into g is by lemma the condition that g has more vertices than g is en by the fact that g into g but not g since that would g related work concurrent program verification as mentioned above existing approaches to the algorithmic verification of concurrent programs eg provide a different of attack at the same fundamental issue the exponential space complexity exponential in the number of threads none of these approaches shifts the burden of the exponential growth of space towards a combinatorial problem over finite graphs the practical potential of these approaches is demonstrated on a selection of practical examples none of the approaches the question whether there are assumptions under which the space complexity is polynomial the exponential cost of space is not an issue that occurs just in theory we observe the exponential curve eg when we run and on the algorithm and the program increment see section these are two concurrent programs parametrized in the number n of threads where our approach comes with a formal guarantee for polynomial space consumption this proposition establishes that g g is a in the category of reduced complete where the morphisms are all the approaches mentioned above are based on abstraction the construction of an idfg from a trace can be viewed as an abstraction of the trace it is interesting to compare the two concepts of abstraction in the setting of the approaches if an abstraction is too it introduces spurious errors in our setting it is desirable to abstract a trace in order to obtain a idfg that denotes a large set of traces this is because are used to represent correct behaviours rather than program behaviours more overapproximation leads to a larger set of correct traces compositional proof rules our notion of inductive data flow graph with style proof rules and other compositional proof rules for concurrent programs eg the use of local assertions of conjunction of stability compositionality is often thought of as the only way to go for proofs in the number of threads our approach to algorithmic verification can be viewed as the automation of a proof rule the proof rule is obtained by the characterization of program correctness in theorem however one can view sets of traces as modules as opposed to modules based on the syntactic construction of programs these modules capture the intuitive notion of scenarios the composition of modules is set union verification the approach to verification achieves modularity at the of giving up completeness in fact the approach is complete exactly for the class of programs whose correctness can be proven in style proofs without auxiliary variables our approach in contrast is motivated by combining the goal of full relative completeness with space efficiency data flow graphs variations of data flow graphs have a long history within the compilers community both as a means for parallelism in sequential code for compilers and as a data structure for use in sparse dataflow analysis our use of is closer to this first line of work can be seen as a procedure that the parallelism in a single example trace for a compiler to be correct parallelization must preserve the behaviour of the sequential code the correctness of depends on the much weaker condition that a proof argument is preserved more recently have been used for invariant generation in both concurrent and sequential settings the work of is particularly relevant it uses data flow graphs to generate numerical invariants for parameterized concurrent programs these invariants can be used to prove safety properties but if the invariants are too weak to prove a property of interest a false is reported our verification algorithm produces no false alarms and can provide a counterexample for properties that fail moreover the inductive presented in this paper are capable of expressing proofs that cannot be represented using the rather than used in ie every proof in corresponds to an idfg but some do not correspond to proofs trace abstraction the work in presents an approach to the analysis and verification of sequential and recursive programs the present paper continues this line of work and extends it to concurrent programs another form of trace abstraction appears in the work on trace covers and trace partitioning there the general goal is to obtain to obtain more precision by the static analysis to specific subsets of program traces in contrast in our work the subsets of program traces are defined by the which are constructed via the static analysis of a single trace conclusion and future work in this paper we have introduced a new approach for the verification of concurrent programs the approach succeeds in putting the static analysis techniques for sequential programs to work namely by the output of the static analysis applied to interleaved executions in a way we formalize under what assumptions the space efficiency can be guaranteed for fundamental reasons we cannot avoid the exponential explosion in the number of threads but we can shift its burden to a combinatorial problem over finite graphs to a place where it less the approach has an interesting practical potential the focus in this paper was to introduce the approach and to investigate its formal foundation there are several directions in which one can explore the practical potential of the approach this should be the focus of future work the most critical operation is perhaps the construction of an idfg from a given trace of the program in section we already at several directions for practical optimizations we need to develop and evaluate these optimizations for practical examples the operation depends on the static analysis that is applied to the trace as a special case of a sequential program the abstract values generated by the static analysis are used to extract single conjuncts for the labeling of an idfg with inductive assertions one possible research direction for practical of is to design a procedure that splits formulae into independent clauses that can be achieved in parallel for use in the current procedure another direction is to develop a craig interpolation procedure that can generate the branching structure of an idfg directly from a resolution proof references g r concurrent programming principles and practice isbn k r apt f s de and e r verification of sequential and concurrent programs springerverlag isbn j berdine t r g and m sagiv thread quantification for concurrent shape analysis in cav volume of lncs pages ­ springer berlin b p cousot r cousot j l a d and x a static analyzer for large software in pldi pages ­ f abstract interpretation by dynamic partitioning journal of functional programming ­ j and e on equations for regular languages finite automata and sequential networks theoretical computer science ­ a k d c kozen and l j alternation j acm ­ jan e m clarke and e a emerson design and synthesis of synchronization skeletons using temporal logic in logic of programs pages ­ p cousot and r cousot abstract interpretation a unified lattice model for static analysis of programs by construction or approximation of fixpoints in popl pages ­ r cousot des de et de de a f a d and t predicate abstraction for concurrent programs in cav pages ­ k a b and h a model checker for concurrent systems in tacas pages ­ a and z verification of parameterized concurrent programs by modular reasoning about data and control in popl pages ­ j ferrante k j and j d the program dependence graph and its use in optimization acm trans program lang syst ­ c flanagan and s qadeer model checking in pages ­ a a practical approach to satisfiability modulo linear integer arithmetic ­ january a gupta c and a rybalchenko predicate abstraction and refinement for verifying multithreaded programs in popl pages ­ m j and a podelski refinement of trace abstraction in sas pages ­ m j and a podelski nested interpolants in popl pages ­ t a henzinger r jhala r majumdar and s qadeer abstraction refinement in cav pages ­ r johnson and k program analysis in pldi pages ­ v s and a gupta semantic reduction of thread interleavings in concurrent programs in tacas pages ­ d j r h d a b and m dependence graphs and compiler optimizations in popl pages ­ l lamport a new solution of concurrent programming problem acm ­ a cartesian abstraction and verification of multithreaded programs phd thesis university of l and x trace partitioning in abstract interpretation based static in esop page a static analysis of runtime errors in embedded critical parallel c programs in esop pages ­ h oh k w lee w lee and k yi design and implementation of sparse global analyses for languages in pldi pages ­ s and d verifying properties of parallel programs an axiomatic approach acm ­ may a abstract domains application to the alias analysis of untyped programs in sas pages ­ d r f m and b value dependence graphs representation without in popl pages ­ 