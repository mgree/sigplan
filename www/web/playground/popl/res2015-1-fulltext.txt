functors are type refinement systems paris paris joint centre abstract the standard reading of type theory through the lens of category theory is based on the idea of a type system as a category of welltyped terms we propose a basic of this reading rather than interpreting type systems as categories we describe them as functors from a category of typing derivations to a category of underlying terms then this around we explain how in fact any functor gives rise to a generalized type system with an abstract notion of typing judgment typing derivations and typing rules this leads to a purely categorical of various natural classes of type systems as natural classes of functors the main purpose of this paper is to describe the general framework which can also be seen as providing a categorical analysis of refinement types and to present a few applications as a larger case study we reynolds paper on the meaning of types showing how the papers main results may be along these lines categories and subject descriptors f semantics of programming languages keywords type theory category theory refinement types introduction one basic difficulty with type theory as a mathematical theory is that in practice the word type actually covers two very different sometimes like the parts of types serve to define the basic grammar of wellformed expressions in this usage all expressions carry a type and there is no need or even sense to consider the meaning of untyped expressions other times like the predicates types serve as a way of identifying subsets of expressions with certain desirable properties in this usage every expression carries an independent meaning and typing judgments serve to assert some property of that meaning permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page for components of this work owned by others than the authors must be abstracting with credit is permitted to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission andor a fee request permissions from popl january ­ copyright is held by the publication to acm acm these two different uses of types are often associated respectively with church and haskell curry hence types à la church and types à la curry while john reynolds referred to these as the and the views of typing in his theories of programming languages traditionally of type theory through the lens of category theory have towards the à la church view this is natural given the analogy type system category which for example that a welltyped term x a xn an e b of the simplytyped lambda calculus may be interpreted as a morphism a × · · · × an e b in a category this the interpretation since any morphism of a category a f b is associated with a pair of types namely its domain dom f a and codomain f b on the other hand there are typetheoretic situations where such an interpretation is problematic for example type systems including a notion of intersection or subtyping eb ec eb bc ec involve making multiple judgments about the same expres sion but in a category it is not even to write the same morphism between a different pair of objects a a f b f c what reynolds originally observed is that an semantics for such a type system must really interpret typing derivations rather than terms this leads to questions of coherence ie whether two derivations of the same typing judgment have the same meaning and in later work reynolds gave a particularly elegant proof of coherence as a corollary to a pair of more general results a logical relations theorem and a theorem relating an semantics of typing derivations to an semantics defined directly on untyped terms here and below we adopt the practice of writing an to the left of an expression which is with respect to some conventions made clear from context conceptually reynolds semantics may be formulated as a functor d derivations meanings from a category of typing derivations to some semantic category of meanings while his semantics may be seen as a functor t terms meanings from a category of untyped terms to the same category of meanings on the other hand somewhat hidden in reynolds original analysis implicitly there is also a functor u derivations terms from typing derivations to terms since every typing derivation is about some underlying term the logical relations and theorems can then be as describing relationships among these three functors our starting point here will be the observation that this analysis may be turned around in fact any functor may be alternatively viewed as a type system in a generalized sense if we interpret the arbitrary category d as a category of typing derivations and the arbitrary category t as a category of terms this will lead us to a purely categorical way of speaking about typing derivations and also conversely to a purely typetheoretic way of speaking about functors in some ways this very abstract view goes back to ideas developed after in particular by who the idea that any functor may be seen as a generalized we will describe how themselves can be expressed quite naturally in typetheoretic terms as type systems with inverse image types our approach is also closely related inspired concept of refinement in type theory u as the functor which refinement information in the paper we will adopt some of the language typically used to about refinement type systems in order to about general effect providing a simple and natural categorical semantics of refinement types reading a functor as a refinement system for completeness and in order to fix notations we begin by the formal definitions of category and functor definition a category consists of · a collection of objects a b · a collection of morphisms f g together with opera tions dom and assigning to each morphism a unique source and target we write f a b to indicate that dom f a and f b · composition and identity for any pair of morphisms f a b and g b c a morphism f g a c as well as for every object a a morphism a a we often omit the subscript on id when it can be from context · such that associativity and unit laws hold f g h f g h f id f id f definition let d and t be categories we say that u is a functor from d to t when it determines the following · for each object s of d an object us of t and · for each morphism s t of d a morphism u us ut of t · such that composition and identity are preserved u u u now for the remainder of the section we will assume a fixed arbitrary functor u d t and consider various notions relative to u definition we say that an object s d refines an object a t if us a definition a typing judgment is a triple s f t such that s and t refine the domain and codomain of f respectively ie such that f a b us a and ut b for some arbitrary a and b in the special case where f id that us ut we also call this a subtyping judgment definition a derivation of a typing judgment s f t is a morphism s t in d such that u f we emphasize again that these definitions are all parameterized by a fixed functor u and in some situations to be completely explicit we could of judgments and so on in fig we give a graphical illustration of the definitions relative to a few examples along with these definitions we introduce some notation also appearing in fig and conventions inspired from logic and proof theory we write s a to indicate that s refines a ie us a in general we refer to objects of t as types to objects of d as refinement types and to morphisms of t as terms we write s t f to indicate that s f t is a typing judgment in the sense of ie us dom f and ut f and uv to indicate that u id v is a subtyping judgment ie uu uv since subtyping is just a special case of typing the two judgments u v and u v id have precisely the same meaning we write s t f to indicate that is a derivation of the typing judgment s f t in the sense of ie s t and u f we also write s t f to simply indicate that such a derivation exists without naming it or s t f to indicate the absence of such a derivation in which case we say that the typing judgment is valid or invalid respectively ab c s t a uc a type refinement s f ab c s t u v f b typing and subtyping judgments st u v f ab c s t u v f c derivations of typing and subtyping judgments figure an illustration of various typetheoretic concepts associated to a functor more generally we say that a typing rule s t sn tn f fn s t f is valid if given derivations of the premises we can construct a derivation of the conclusion we will sometimes give an explicit name to a typing rule as a way of referring to the corresponding construction on derivations by placing it to the right of the bar for example any derivation can be treated as a valid typing rule with no premises s t s t ff proposition the following typing rules are always valid s t t u fg s u f g s s id id proof these are immediate consequences of the of u for example suppose is a derivation of s f t and is a derivation of t g u by definition this means that s t and u f and t u and u g but then is a derivation of s f g u since s u and u u u f g proposition subtyping is reflexive and transitive and admits rules of covariant and contravariant subsumption ss st tu su s t t u f s u f s t t u g s u g proof of subtyping is by definition just another way of writing the id typing rule of prop while transitivity and subsumption are all special cases of with one or both of the terms ie morphisms of t f and g set to the identity term id as the proof of prop illustrates sometimes constructing a typing derivation involves reasoning about equality of terms ie morphisms of t in general we allow ourselves to work modulo this equality but for clarity it is sometimes useful to make the move between equal terms explicit by indicating a conversion step s t f s t g for example the covariant subsumption rule of prop can be more explicitly derived as follows s t t u f s u f id s u f finally we should mention that the categorical axioms also imply various equations on typing derivations for example the associativity axioms imply that the derivation named by s t t u fg s u u v fg h s v f gh is equal to the derivation named by t u u v s t gh t v f gh s v f gh while the unit laws imply that s t t u fg s u u u id s t t u f g id fg s u s u f f g t u u v t t id gh t v t u u v id gh t v gh t v gh these various simple observations our the following definition definition a refinement system is a functor u d t example to try to provide a bit of intuition for this way of reading functors we will consider a simple and naive example which is indeed perhaps the model of refinement types for t we take the category set of sets and functions while for d we take the category subset of subsets and image an object of subset is a pair a s of a set a and a subset of that set s a while a morphism a s b t is a function between the underlying sets f ab such that the image of the first subset is included in the second aa s f a t as the functor u subset set we take the first projection sending a subset to its underlying set putting aside formal questions of what exactly sets are eg whether by etc by most interpretations the category set is already quite rich with types for example we can probably suppose it contains types of natural numbers integers sequences of integers n z zn and many more besides but if one could attribute a to type refinement it is that rather than trying to say everything at once in the language of types it is sometimes better to start from a statement and then explore ways of making it more precise while keeping the original statement so for instance we might consider the refinement types of odd even or prime natural numbers odd def n kn k n even def n kn k n prime def n n kk k n k n n of nonzero or nonnegative integers nonzero def x x z def x x z of linear or bounded sequences linear def f a bn f n a · n b zn bounded def f xn f n x zn and so on the point of the functor u subset set is that these refinement types in subset will always be considered with respect to the original types in set they refine for example the question whether every prime number is odd may be as a subtyping problem prime odd whose answer happens to be negative ie the judgment is invalid on the other hand the question of whether every linear sequence is odd is not really sensible without to some encoding and the corresponding subtyping judgment linear odd here we allow ourselves the slight of writing s a although strictly speaking the pair a s is the object of subset is not wellformed since the two sides refine different types as another example if we take xx z z to be the function on the integers then the following three typing judgments are respectively valid invalid and nonzero xx nonzero xx bounded xx monoidal and logical refinement systems in the previous section we described how an arbitrary functor gives rise to a refinement system in the sense of an abstract notion of typing judgment typing rules etc of course if all we could say were restricted to such then we could not say very much but we have several strategies for out richer classes of refinement systems u d t by for additional structure on d and t and that it is preserved by u by for additional properties of u like for instance that it is a by considering specific refinement type signatures under assumption of some existing structure and properties in this section we will the first strategy the others will be considered later on we begin by the standard definition of a monoidal category definition a monoidal structure on a category d consists of a functor called the tensor product together with an object i d satisfying associativity and axioms up to natural isomorphism a · b · c a · b · c a · i a i · a moreover these natural isomorphisms have to satisfy certain coherence laws which we omit here see a monoidal category is a category equipped with a monoidal structure there are many examples of monoidal categories and often the tensor product satisfies additional properties such as being symmetric or cartesian however here we just want to start from the most basic situation definition a monoidal refinement system is a functor u d t between monoidal categories preserving the monoidal structure in the strict sense that we have a pair of commutative d × d d id d t u t u t it to read these conditions in typetheoretic language we first allow ourselves to introduce another natural convention we say that a refinement rule s a sn an sa is valid if us a an implies that us a then the commutative of translate straightforwardly to the following proposition we omit subscripts on the monoidal operations since they are always clear from context proposition in any monoidal refinement system the following refinement rules and typing rules are valid s a s a s · s a · a i s t s t i f f s · s t · t f · i i i i likewise the axioms of monoidal categories translate to various equations on derivations constructed using the typing rules we these here and instead move on to considering what we call logical refinement systems first we recall more standard material on category theory definition let a and c be two objects of a monoidal category a left residual of c by a is an object b equipped with a map c and a transformation from maps f c where b is any object to maps b f b called such that for any f a · b c and g b b we have equations id · f f g id · g these equations ensure that there is a correspondence between maps of the form and maps of the form similarly for any two objects b and c a right residual of c by b is an object a equipped with a map a c and a transformation from maps f c where a is any object to maps a f a called such that for any f a · b c and g a a we have f · id f g g · id proposition is determined up to isomorphism ie if b and b are two left residuals of c by a then b b and if a and a are two right residuals of c by b then a a because of this proposition we allow ourselves to of the left residual of c by a whenever it exists writing a c to denote similarly c b for the right residual definition a logical refinement system is a monoidal refinement system u d t which preserves left and right residuals it is worth that the definition of a logical refinement system in our sense does not require that all left and s au c su ac s · s u u s · t u f t s u f s · t u f s s id t s u id f · s · t s · s u s · s u u f s · t u f s · t u f s s id t s u g · s · t s · s u s · s u u s · t u t s u t s u g figure the defining rules of a logical refinement system restricted to the rules involving left residuals right residuals exist in d and t ie that the categories are closed but only that u preserves any which exist in d in fig we illustrate how limited to the part involving left residuals may be equivalently formulated in the language of type theory using the appropriate refinement rules typing rules and equations these rules are actually quite standard in the literature on refinement types see for example the system of simple sorts described by pfenning § except for our use of the notation of the calculus justified by the fact that we are working in a general monoidal rather than a cartesian setting perhaps one rule from fig that is the refinement rule s au c su ac under the conventions we have established the rule simply the condition that the functor u preserves left residuals in particular the refinement rule should not be with the familiar rule of subtyping for function types which in the domain with in the codomain proposition the following subtyping rules are valid in any logical refinement system if the corresponding residuals exist s s u u s u s u u u t t u t u t proof we can derive the rule for left residuals as follows the case of right residuals is symmetric s s s u s u id · s · s u s · s u s · s u u s · s u u s · s u u s u s u s u s u u u example the refinement system subset set considered in section extends to a logical refinement system the monoidal structure on set is the usual cartesian structure a · b def a × b i def which also to a cartesian monoidal structure on subset s a · t b def a b a s b t a × b i i def both categories are also closed with left and right residuals both defined in terms of the function space we describe only the underlying not evaluation and a c def ca c b def cb s a u c def f aa s f a u ca u c t b def f bb t f b u cb the functor subset set sends products and residuals in subset to products and residuals in set and thus defines a logical refinement system as an example writing n · n n for addition of natural numbers we can state various easy arithmetic facts and as valid and invalid judgments odd odd even odd even odd even prime odd reading in translation in this section we will the second strategy mentioned at the beginning of section and begin by the definition of when a functor u d t is a à la definition a morphism t t in d is said to be cartesian if for every object s d and every pair of morphisms s t and g us ut such that u g u there is a unique morphism s t such that and u g definition let f a b be a morphism in t and t be an object of d such that ut b a morphism in d is said to be a cartesian lifting of f to t if u f t and is cartesian definition a functor u d t is said to be a if for every morphism f a b in t and object t d such that ut b f has a cartesian lifting to t the definition of plays a fundamental role in category theory as well as in the semantics of dependent types and we may thus whether we can understand it from our point of view on refinement type systems again we assume u d t is fixed with the notational and conventions of section we do not assume any other structure on d and t definition let f a b and t b a or inverse image of t along f is a refinement type t a equipped with a pair of valid typing rules t t l f s t g f s t r g such that for all derivations s t and g f s t g we have a pair of equalities s t g f s t r t t l g f s t s t g f g f and s t t t l gf s t s t g f s t r gg now it is essentially immediate by the definitions that we have just to a typetheoretic proposition t t is a cartesian lifting of f to t if and only if the triple t l r is a of t along f where l and where r is defined using the universal property of proposition u is a iff for every f a b and t b there exists a of t along f somewhat many standard facts about can be derived quite mechanically under this translation of proofs in the sequent calculus we begin by showing in this style that are determined up to vertical isomorphism definition let s t a be two refinements of a common type we say that s and t are isomorphic written s t when there exist a pair of subtyping derivations st ts which compose to the identity st ts ss s s id ts st tt t t id proposition any two of t along f are isomorphic proof let t and t both be of t along f equipped with corresponding valid typing rules t t lt f s t g f s t rt g and s t g f t t lt s t rt fg then we can build derivations of t t and t t by t t lt f t t rt t t lt f t t rt f ab t b ft a f t t l f f s t s g f f t rf g s t g f s g f t r f f t t f s t g f lf s t g f s g f t f t t l f f s t s g f t g f s g f t r f figure the defining rules of refinements s a f ab fs b s t f g f s t l f g s f s r f f s t f g rf lf s f s f f s g t s t s t fg fg rf s f s f f s g t s t f s g t f g lf f s g t figure the defining rules of refinements and easily verify from the axioms that these two derivations compose to the identity because are determined up to vertical isomorphism we allow ourselves to of the of t along f whenever one exists writing f t for the refinement type and l f and r f for the corresponding rules see fig we can now mechanically establish the following facts about which in categorical go into showing that any determines a t op cat proposition whenever the corresponding exist the following subtyping rule is valid t t f t f t we have vertical isomorphisms g f t g f t id t t proof f t t l f t t f f t f id t f t t id f f t f t rf for the left equation we construct subtyping derivations in both directions by g f t t lg f g f g f t f t rf g g f t g f t rg g f t f t lg f t t l f gf g f t t g g f f t g f t rg f and again by an easy calculation we can show that these two derivations compose to the identity the right equation id t t is essentially immediate which also means that along the identity always exist next we give an analogous reconstruction of the dual concept of an definition let s a and f a b a or image of s along f is a refinement type s b equipped with a pair of valid typing rules s t f g s t l g s s r f such that for all derivations s t and f g s t g we have equalities s t f g s s r s t l fg s t s t fg fg and s s r s t f g s t s t f g s t l gg proposition u is a iff for every s a and f a b there exists a of s along f since are determined up to vertical isomorphism we of the of s along f writing f s for the refinement type and l f and r f for the corresponding rules see fig again we can mechanically establish some basic facts about which go into showing that any determines a t cat proposition whenever the corresponding exist the following subtyping rule is valid s s f s f s we have vertical isomorphisms f g s g f s id s s proposition whenever the respective and exist we have a correspondence of f s t iff s t iff f s ft example for the refinement system subset set and refinements may be constructed as suggested by the notation via image and inverse image operations on subsets along any function f a b f s def f a a s f t def a f a t for example the typing judgment f t t f is obviously valid reading as « f maps anything in the inverse image of t along f to something in t » while s f s f reads as « f maps anything in s to something in the image of s along f » since these operations are defined for any f a b s a and t b the functor subset set is both a and an ie a example the general approach of hoare logic provides a natural class of examples of refinement systems to a first approximation defined as follows we will consider a more view in section · take t as a category with one object w corresponding to the state space and with morphisms c w w corresponding to program commands identified with state transformers · take d as a category whose objects are predicates over states and whose morphisms are pairs of a state transformer c together with a verification that c takes any state satisfying to a state satisfying · let u d t be the evident functor mapping every to w and every verification about c to c itself indeed the induced notion of typing judgment for the functor u d t corresponds exactly to the classical notion of hoare triple c one easily checks that the usual rules of sequential composition and are valid by propositions and and moreover that a of along c is precisely a weakest precondition while a of along c is a strongest postcondition c c on the other hand it is not necessarily the case that d t is a andor whether weakest postconditions exist for all predicates and state transformers depends on the of the class of predicates and the class of state transformers example the example of subset set can be generalized in terms of category theory let v v iv v be a symmetric monoidal closed category let be the of categories and let the category of ie the category whose objects are functors s a v out of categories and where a morphism from s a v to t b v is a pair of a f a b together with a natural transformation s f t then the refinement system given by the domain functor dom is a with simply defined by and computed as f t def a t f a a f s def b b f a b v ta note that this is also an example of a logical refinement symmetric closed monoidal structure on is defined by constructing tensor product categories and functor categories a · b def a b a c def a c c b def b c while the tensor product of two is defined as their external tensor product ab v s · t def a b sa v tb and the left and right residuals defined as ends s u a c v s u def f sa a u t b c v v u f a u t def g tb v b example a trivial example of a is the unique functor d from any category d to the terminal category since there is only the identity arrow in all and exist trivially if d is monoidal this is also trivially a logical refinement system separation logic and the frame rule we have seen how a lot of general type theory can be as a theory of functors in many ways though the really interesting arise by taking the various type constructors as building blocks and using them to define specific type signatures effectively this is a way of refinement systems as a logical framework using them both to define theories and to construct models in this section we will give some basic examples describing how some aspects of reynolds and separation logic can be explained in terms of refinement systems recall example that hoare logic may be considered as a refinement system where terms c w w t are commands refinements w are predicates over the state space and where derivations c are proofs that the command c will take any state satisfying to a state satisfying although this description suggests that t is a category such a restriction is not really necessary and it turns out to be useful to work more generally in particular suppose we know that t is a monoidal category and that w is a monoid object in t ie that it is equipped with operations w ew satisfying the monoid axioms then for any pair of refinements w we can define their separating conjunction w as a along of a tensor product def · we similarly define the unit of the separating conjunction emp w as a along e of the tensor unit emp def e i finally for any w we define magic wand w as a along the of of a residual def these kinds of in order to define some logical structure of interest we rely on a similar structure in the now interpreting this signature in the refinement system subset set examples to yields the basic settheoretic semantics of the separation logic connectives w w w w emp e w w w w w on the other hand we can see that the abstract definition in terms of refinement systems is much more general for example interpreting the signature in example the wellknown construction for lifting a monoidal structure on a category to a closed monoidal structure on its category of the next proposition describes the situation more abstractly proposition whenever the operations and are defined ie when the corresponding and residuals exist they are in the sense that subtyping rules are valid and adjoint in the sense that the subtyping rule is both valid and invertible this proposition is actually independent of whether and e satisfy the monoid axioms and can even be adapted for a binary operation of arbitrary type a · b c the of expressed in prop is a trivial instance of frame rule which can be expressed as follows for a general command c c c frame there is no reason why the frame rule should be valid in an arbitrary refinement system and it is impossible to derive it from the above axioms on the other hand in the presence of or it is not difficult to see that the frame rule is equivalent to either one of two simple algebraic conditions on the command c c c c c the correspondence between the frame rule and the lefthand side property was already by ohearn and yang here we would like to emphasize that the lefthand side property says that along c seen as an c on the of w is strong with respect to the action of the monoidal category on itself this correspondence the frame rule to the traditional description of locality as a monadic strength in the semantics of effects the meaning of types as we mentioned in the introduction john reynolds on the distinction between the and views of typing as he did on many topics and considered the relationship between these two views carefully in logical a pattern and an example of the principle in the sense of and in section we will see this pattern again in the definition of the logical relation his paper on the meaning of types to conclude our paper we want to reynolds analysis and describe how much of it may be expressed quite naturally in the language of refinement systems the following sections to track sections ­ of syntax and typing rules we define a category t and a functor u d t representing the syntax and typing rules of a small language the language reynolds considers in the paper is a simple extension of the lambda calculus including primitive boolean and arithmetic operations records recursion and subtyping since the language is meant to be rather than interesting of itself we will further simplify here by getting of records recursion and a few of the primitive operations in order to focus on the treatment of subtyping we will also follow the lf approach and use higherorder abstract syntax rather than explicit identifiers to describe binding operations since this leads to an elegant analysis in terms of cartesian logical refinement systems definition a cartesian logical refinement system is a logical refinement system u d t in which the monoidal structures on d and t are cartesian we write x × y and yx to denote cartesian products and the reason we must consider cartesian rather than arbitrary logical refinement systems is that in reynolds language variables can be used any number of times and in any order otherwise though whether one works with cartesian logical refinement systems or in the general monoidal setting the structure of the analysis is essentially the same so we begin by considering the category t of terms as a cartesian category freely generated from a single type p of phrases a pair of morphisms lam pp p app p pp representing lambda and application and morphisms add sub lt p × p p not p p zero one true false p representing the operations of addition comparison negation and the numerical and boolean constants we next define a functor u d t as a cartesian logical refinement system freely generated from the following refinement rules p p int p nat p bool p fn p the following subtyping rules nat int ni nat bool nb fn fn fn a pair of typing rules for lambda and application fn lam lam app fn app and a collection of typing rules for the primitive operations nat × nat nat n int × int int i bool × bool bool b add add add int × int int i int × int bool i bool bool sub lt not nat n nat n bool bt bf bool zero one true false we emphasize that this signature should be read as specifying conditions on the category d and the functor u for example the ni subtyping rule indicates that d contains a morphism ni nat int and that u maps ni to while the app rule says that d contains a morphism app fn for every p and that u maps app to app in the spirit of the lf approach but now at the level of refinements cf there is a lot that we dont have to mention in this signature for example we dont have to explicitly include reynolds subsumption rule since it is valid in any refinement system prop on the other hand observe that the fn subtyping rule is not an instance of prop since a priori we do not identify fn with the exponential object the former refines p the latter pp example the function dec · one sub one from an integer may be typed by the following derivation at the bottom we write lam for the typing rule defined by with lam nat n nat int ni int int id one int id one int int × int · int × int int i sub int int int lam dec example it is possible to have more than one typing derivation of the same typing judgment for example the typing judgment nat × nat bool add may be derived either as nat × nat nat n nat bool nb add nat × nat bool add or as nat bool nb nat bool nb · nat × nat bool × bool bool × bool bool b add nat × nat bool add an semantics we define a cartesian closed functor d d dom from derivations to domains in order to define the semantics we assume domains n z b of integers and booleans as well as operations n n z z b b z z × z z z z × z b ¬ b b b n tt ff b for the extensions of the evident operations on integers and booleans we also write i n z for the evident inclusion and j n b for the strict extension of the following map n tt ff if n if n then we define the functor d d dom by nat n int z bool b t t s ni i nb j fn f f lam id app id n n i z b b i z i z ¬ b n n bt tt b f ff note that this data suffices for defining the cartesian closed functor d by the requirement that it preserves cartesian products and an untyped semantics we define a cartesian closed functor t t dom from terms to domains in order to define the untyped semantics we assume a domain u equipped with operations p z o u p uu o f u f such that p p id and f f id ie pairs we also suppose operations z z z × z z ¬ z z z which must at minimum satisfy x z y x z y when x y when x y when x when x then t is defined by p u lam f app f add p · p z p sub p · p z p lt p · p z p not p · p ¬ z p zero false i p one i p true p as in section this data suffices for defining t as a cartesian closed functor logical relations we formalize reynolds logical relations theorem connecting the semantics to the untyped semantics the logical relations theorem down to defining a cartesian closed functor d satisfying a pair of d d d dom d u t dom t here is the category whose objects are relations over domains hence relations and whose morphisms are pairs of functions mapping related arguments to related results while the i are the evident projection functors to define we take advantage of the fact that the pairing of the projection functors dom × dom has the structure of a logical refinement system with all and some let us take a moment to describe this structure cf example a refinement s a b corresponds to a relation s a × b between domains while a derivation of s t fg corresponds to a proof that a b a s b f a t gb products residuals and are defined as follows on relations a a b b iff a s b a t b f ts g iff a b a s b f a t gb a fg t b iff f a t gb c fg s d iff a b c f a d gb a s b note that is a partial operation because the relation f g s is not necessarily however the along a pair of functions f g with flat or more generally with where every element is compact is always defined now in order to satisfy the and the object part of the functor d must assign to each p a relation u let dom be the cartesian closed functor assigning the identity relation to any domain we define as follows by induction on int id p z nat id p id i n bool id p id i id j b fn id f by the interpretation of the logical refinement system dom × dom it is easy to check that these definitions agree with reynolds definitions and for example we have b bool p iff b b pp iff in b b n iff in b jn we can now prove that extends to a functor and that the two and commute which modulo our treatment of variables using higherorder abstract syntax rather than explicit environments is an exact of reynolds logical relations theorem theorem if p then p proof by induction on the content of the proof is basically identical with the proof in but the through refinement systems gives the proof considerably more structure we illustrate with a few cases · ni n z i ii id i n z i id p id i n id p z fun nat int ni id where we write a double line for expansion of definitions fun for of prop and i for the application of the functor to the map i n z · lam id f id f f lam lam fn · n n · n n n i n id i n n n n · n id i n n n i n × n id i n nat × nat nat np z p nat × nat nat n add where at we have several easy steps of reasoning and at we use the fact that n i i · i z we formalize reynolds theorem which combined with the logical relations theorem yields coherence we begin by defining for each domain in the image of the semantics a pair of functions o u which will turn out to be an pair the family is defined as follows by induction on int p int p nat i p nat p i bool j i p bool p i j fn f fn f here g f def f · id g while i z n is the function sending nonnegative integers to and everything else to and j b n is the strict extension of the function sending tt to and ff to note that this family of pairs may be seen as a pair of transformations between functors d u t u t d not a pair of natural transformations instead and are related by reynolds theorem theorem the two judgments id id are derivable for all proof by induction on once again the proof is highly structured and we include it in full in appendix a finally by combining the theorem with the logical relations theorem we can show that the semantics is coherent ie that any two derivations of the same judgment have the same interpretation the following statements correspond to reynolds theorem and corollary corollary coherence we have if p then p if p and p then related work and conclusions refinement type systems are the higherorder version of hoare logic and as such they are recognized as a fundamental tool in program analysis and certification an important contribution to this line of research has been the work by frank pfenning and his who have developed along the years a theory of refinement type systems including a clean account of the relationship between and typing here by going back to reynolds we establish a very natural connection between refinement type systems and semantics based on the idea that every functor defines a refinement type system semantics is an old idea going back to in algebra and logic and which plays a central role in the study of imperative languages since reynolds and semantics has also a defining role in the early development of separation logic as well as in more recent extensions of the logic to higherorder imperative languages one feature of the present work is to develop a formal language of typing judgments and derivations the basic reasoning principles of semantics this language has been designed in order to be amenable to and could eventually serve as an intermediate language in a proof assistant we demonstrated the power of the language in section by the sophisticated semantic arguments used by reynolds in a concise and highly structured way one of the original for this language was to better understand effect type systems and their aspects along the lines of the idea of using product and in the study of logical predicates and logical relations may be traced back to with later developments by effects and refinement type systems led us to replace by general functors and in particular to the expressive power of closed functors together with the existence of specific and one many of the operations of dependent types but in a more flexible and general setting the principle of refining types while careful attention to the dual act of also appears in notion of which have been analyzed in terms we would like to the connection with our work in the future finally the idea of using closed functors as a logical framework capable of speaking about both syntax and semantics in a unified way is very much in the spirit of de abstract grammars as well as and interpreters references robert and refining inductive types at work notes from a course at tu in june taken by thomas birkedal and higherorder separation logic and abstraction acm trans program lang syst birkedal and yang semantics of typing and higherorder frame rules for algollike languages and finally partially evaluated staged interpreters for simpler typed languages and a categorical treatment of lics de towards abstract grammars in assoc for computational th annual monads in action popl tim and frank pfenning refinement types for ml pldi robert harper and gordon plotkin a framework for defining logics journal of the acm logical predicates and phd thesis university of edinburgh november car hoare an axiomatic basis for computer programming communications of the acm categorical logic and type theory studies in logic and the foundations of mathematics north holland relating computational effects by lifting icalp max basic concepts in category theory the mathematics of sentence structure mathematical and philip scott introduction to higherorder categorical logic f william semantics of algebraic theories phd thesis university f william in foundations ­ william refinement types for logical frameworks phd thesis carnegie mellon university september mac categories for the working springer algebras algebraic to appear version available on authors peter w ohearn and david j the logic of implications peter w ohearn and yang a semantic basis for local reasoning frank j a approach to the semantics of programming languages phd thesis university frank pfenning refinement types for logical frameworks workshop on types for proofs and programs may frank pfenning church and curry combining and typing studies in logic ­ john c reynolds the essence of algol algorithmic languages ­ john c reynolds the coherence of languages with intersection types john c reynolds theories of programming languages john c reynolds the meaning of types from to semantics report rs university december john c reynolds separation logic a logic for shared mutable data structures lics a proof of the theorem recall that the theorem thm says that the pair of judgments id id are derivable in the logical refinement system dom × dom we prove this by induction on · case fn in one direction we build the following derivation ih id · · id ih id id f f id f f id f fn fn where at we apply composition twice the order is irrelevant by associativity after the leftmost premise by the identity on the right to bring it to the appropriate type in the other direction we build the following derivation id f f ih ih id id · · id f id f fn fn l where at again we multiply the leftmost premise by the identity on the left before composing and at l we apply an instance of the following rule which is valid in any logical refinement system s s u u vk s · s u u l k · case int z z id z z z p id p z p int int id p z z p int int · case nat n id i n i n id i n p n id p id i n p nat nat · case bool b b id b b b j id j b j b id i id j b i i b id i id j b id j b id j ip id p id i id j b p bool bool n n id n n id i n n i id p id i n i n p nat nat id j b b j id j id j b b j id i id j b i b j id p id i id j b i j b p bool bool 