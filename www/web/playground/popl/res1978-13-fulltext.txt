record of the fifth annual acm symposium on principles of programming languages unrestricted procedure calls in robert cartwright computer science department cornell university ny computer science department stanford university stanford ca abstract this paper presents a new version of logic including generalized procedure call and assignment rules which correctly handle aliased variables formal are given for the new rules introduction despite the acceptance of logic as the most suitable formalism for verifying programs written in procedural languages the logic still from several in our view the two most significant problems are the limitation on language constructs particularly procedures imposed by commonly accepted rules of the logic the absence of formal for most of these rules of the sets of hoare proof rules proposed in the literature hoare hoare and london et al london and cook none is sound for all programs in any reasonably complicated procedural language such as pascal in particular all of the rules place significant restrictions on procedures and procedure calls even the most procedure call rule proposed to date for by et al must aliasing in procedure calls passing as parameters procedures and functions require that value parameters ie constant parameters be a procedure procedure of the same name within a require that the global variables accessed this research has been partially supported by national science foundation grants and by a procedure every call be accessible at the point of another aspect of current versions of logic is that most of the proposed rules have never been formally justified perhaps as a result many of the rules have counter examples the few sets of rules that have been proved sound apply only to programming languages cook the proof rule systems proposed for practical programming languages such as pascal hoare and and london et al have never been formally justified and all contain serious errors and as a step toward solving these problems we will concentrate on and rules for procedure calls in pascal ­ including calls involving aliasing first we will develop a simple procedure call rule after hoare along the same lines as the rule et al for calls where no al is present next we will propose assignment and procedure call rules for where aliasing is permitted both rules to the corresponding simple rules if no aliasing is present we will sketch soundness and relative com proofs for all of our new rules in the process we will propose a new mathematical for the meaning of statements in logic which seems sufficiently to handle most procedural languages yet is tractable mathematical foundations rules tions before we can formulate and justify we must establish the mathematical for our version of logic three sets of definitions our proof we state vectors and access sequences from an informal a state vector is a sequence of bindings of program vl data procedure names to procedure eg a lisp association list an access is a canonical name for an entry in a state vector for example the access sequence for the variable x is x since x the value of the variable x we use x to refer to the variable itself sequence for the array element all typically means the notation the access is al more formally we let d denote the set of data values that program variables may assume and let i and i denote the set of program identifiers ab c and program identifiers a b c respectively we let b denote the set of procedure bodies a is any legal hand side of an assignment statement a simple variable is a consisting of a single identifier for example ax and x are both x is a simple variable but is not for the sake of simplicity we limit our at to a subset of pascal restricting the set of to simple variables and array references similarly we assume the data value domain for our pascal di has the form u j where the sets d are disjoint data objects eg integers and denotes the set sets of primitive characters of mappings booleans arrays from a d into dk we call these restrictions each set d and are made only for ex purposes all of our results generalize to arbitrary pascal data domains we define the access sequence corresponding to the simple variable v as the singleton sequence iv for a of the form ae where a is an array and e is an expression the access sequence is where e e d is the value of e disjoint if ment of the we define two access sequences and only if neither is an initial other to be let h be a finite set of variable tions v v is a program identifier tv is and procedure declarations procedure bp where pj is a program and identifier parameter a p is a sequence of var and value declarations and bp is the remainder of the procedure body we call set a state vector s consistent mapping from i identifiers into u b procedure bodies declared in h is bound tv and each procedure procedure bp such that to a data is bound h a declaration with h is a d data values each variable value of type to the body v typically we are only interested in only a finite restriction of s specifically the bindings of the variables and procedure names declared in h in this case we can think of s as a finite sequence of ordered pairs where x is a pro gram identifier declared in h and d is its binding we let a and s denote the set of access se and the set of state vectors respectively value and update functions we introduce two functions value to access and modify states analogous and update to the array access and update functions defined by value maps a state vector s and an access sequence u into the binding of a in s date maps a state vector s an access sequence and a value d into the state vector s where s is identical to s except that the entry within s specified by a has the new value d into in more formal terms value is a mapping from into and update is a mapping from s satisfying the following axioms value update for arbitrary state vector s access sequence a and value e provided the entry specified by a exists in s al and a are disjoint f access sequences and the entries specified by al and q in s let select be the standard array access function mapping x di into dj for all ij e provided then value for arbitrary state ve vector s v array value d and data value e is in the domain of d let store be the standard array update fun tion mapping x di x d into for all ij then value d v store for arbitrary state vector s identifier v and data values d and e provided e and d belong to the domain and range of value sv respectively r we extend value and update to apply to se of disjoint access sequences as follows value un for arbitrary state vector s and access sequences al an provided the entries specified by al un exist in s update an all dn l access sequences all dn provided the are welldefined al un specified for values updates let al an be disjoint access sequences such that a a u have the form lk k where v is an and e is a data value let aj aj be the remaining access sequences and let then update d denote values v dn u a nk store d id provided the specified k d updates the collects updates to various elements of the same array and combines them into a single can use this axiom of disjoint of simple updates ables rather than update of the entire array we to convert an arbitrary se updates to an equivalent set ie updates of simple vari array elements for example update update c we denote the set of sequences by a of access se definition of truth in meaning this section of statements we define the syntax and in our version of the base logic we assume we are theory lm for the of a logical a mode m for l with given a base first order program data domain language l with equality and the following properties the domain of the model m includes d data values i identifiers sequences over a and b procedure bodies the variables of l include two disjoint sets language identifiers and v a set of logical variables which may not appear within programs the logic includes the binary function and the unary function the operator two sequences r l vi vn ij l maps a data object d specifically a identifier access sequence d with we can construct and a a data value into the singleton or an se the functions and arbitrary members of a the logic includes all the primitive func tions of programming language including array access and update functions select and store we let ae where a is an and e is a term abbreviate the term select are the logic includes a characteristic pred pt for each data type t in d we will use the familiar notation x t to abbreviate the logic includes the predicates disjoint and with domains a and respectively disjoint l is true if and only if access sequences ai and a j are disjoint for all ij such that ij al am al true if and only if i and j are disjoint for all i given an arbitrary variable v we can construct a term v in l such that the mean ing of v is the sequence for v if v is a simple variable x then v is simply if v is an array element then v is we will frequently employ this con in our proof rules extended terms and formulas for the sake of clarity we formulas of l from using program identifiers as bound quantified variables in addition to handle updates to the state vector we ex tend the logical language l to include updated formulas and terms we define an extended for term of l as follows an extended for term has a recursive definition identical to that of an ordinary formula term except that there is an additional mechanism called an update terms from existing for building new formulas ones given an extended and for term a the form a is also an extended formula term where is a sequence of disjoint and is a sequence of ordinary not updated terms in l we will call a simultaneous update formula we will simply use the term term to refer to an extended formula extended term hoare assertions and statements let q be an arbitrary let xl xn be the program formula identifiers in l and which occur in q declarations let h be a declaration set including for xn a hoare assertion has the form let a be a program segment and formulas in l let h be a declaration declarations for all the free variables and procedure names in ap hoare statement has the form p and q be set in program and q a we define the meaning of hoare assertions and statements as follows let be an hoare assertion the definition of truth for is identical to the standard firstorder definition of truth for q except is with h true for states the meaning of the updated formula term u for state s is the meaning of the formula updates of access term a for state where denotes sequences corresponding the sequence to v let be an arbitrary hoare state ment and let eval be an interpreter a partial function mapping states x into states then is true if and only if for all states s either is false for s sa is undefined q is true for standard proof rules obvious the standard simple hoare proof rules in our version of the logic have the most fundamental and substitution rules consequences have the following form consequence q h as composition substitution h th where x denotes replaced is a q with by t logical variable and every free occurrence of renaming bound variables x the other as given are standard rules which we will take declaration h u begin xt pb a where xt and and procedure are sequences and procedure g pb are sequences of variable declarations and and of fresh program variables names corresponding to and simultaneous assignment h disjoint where where terms is a disjoint g is the sequence in l corresponding assignment of access to and sequence reasoning about updated formulas in order to prove hoare assertions involving updated formulas we need special axioms about updates formulas for disjoint the following updates axioms modifying entire from the corresponding axioms for update are sufficient iq q where is a sequence of distinct simple variables and q is a formula containing no updates vn be disjoint variable where have the form ll k where a is a particular array identifier let v be the remaining let denote the sequence of and let denote the se of then q e u iq given an arbitrary disjoint simultaneous up date we can eliminate the update from a formula of the form iq where q is up date free by using axiom to eliminate all assign ments to array elements and then applying axiom we similarly eliminate all updates from a form of the form v lq where q is update free by repeatedly applying the same simplification procedure simple procedure call rule in this section we assume that our pascal subset aliasing in procedure calls passing procedures and functions as parameters requires that the global variables accessed by a procedure be explicitly declared at the head of the procedure and that these variables be accessible at the point of every call under these assumptions it is to formulate a procedure call rule by treat ing procedure calls as simultaneous assignments to the variables passed to the procedure the assigned values are any values consistent with the inputoutput assertions for the procedure let p be declared as procedure value yt global b in the declaration set h b may any global variables other than let h be h augmented by the declarations and prior declarations of and are replaced let p and q be formulas containing no free program variables other than and respectively let be the free logical variables of p and q and let and be fresh logical variables correspond ing to and then the nonrecursive simple procedure call rule has the following form h i it is important to note that the free logical variables and in the second premise are universally quantified the rule forces r is to be true for arbitrary and consistent with in contrast the procedure call rule the corresponding quantifier false soundness if eval is properly defined it is easy to prove the soundness of the simple procedure call rule let s be an arbitrary state consistent with h such that is true for s and pf is defined we must show s is true for sp let s be s where are the output values of and z in ie the values of and in the eval sb since s satisfies and r in the premise s must also satisfy se the definition of eval the call state both second s by eval sp u oo s s s hence eval sp satisfies s qed although the soundness rule does not depend on the above the of at the point of every call of the procedure third assumption the procedure the assumption call listed is necessary to prove that eval rules the natural definition used in the soundness proof rules if the third assumption and dynamic scope rules are equivalent static scope of eval which we dynamic scope holds then static semantically relative completeness it is also reasonably straightforward to prove that the simple procedure call rule is rel complete for nonrecursive programs in the sense of cook we assume that the language l is expressive ie that given an arbitrary assertion p in l and a program ment a the strongest q of a given p is definable in l to show that the rule is complete relative to the completeness of the other proof rules and the axiomatization of the extended base logic it suffices to show that for any program segment a and ion q the weakest precondition p is provable the proof proceeds by contradiction assume p is a procedure call for which the rule is not complete let the procedure call in the evaluation of p for which the simple procedure call is not complete let h be the declaration set at the point of the call and let p be declared as procedure value global b in h let s be an arbitrary for pg condition we define q for b given by assumption as the strongest the h post provable we define q to be by the rule of be provable in addition re z s is clearly a provable precondition of the rule assume r is not the weakest then there exists a state s consistent with h such that r is false and either undefined or s is true for let s be ur either is un defined or q is true for zt in the be false for all since is false for all hence r is true generating a i in the other case is true only for states with x and z equal to the values of and in but for such and m x consequently for all states satisfying z ds is true zz r is true qed again we have a a sample proof lets consider a simple example which less sophisticated procedure call rules handle let swap be a standard variable swap as follows procedure begin xy post end xy a a integer by the simultaneous assignment q rule we must show yx a to establish the declared pre and for swap by the substitution axiom axiom in xy yx yx a a which is precisely the now let us consider a sample application of the procedure call rule assume we want to prove integer integer a i a let h denote integer of integer p denote the a q denote the substituted condition a r denote and s denote a by the simple call rule we must show i the correctness of the inputoutput tions for the procedure body pq r since is trivial and we have already proved it suffices to prove first we trans form xy s into ai e since by hypothesis s g xi o a in io r i a by applying form the equality a into hypotheses in r we x i a which an immediate consequence of when are instantiated as ai and i respectively qed handling recursion our simple rule can be extended to handle mutually recursive procedures by generalizing original approach to the problem hoare however we must impose the following additional restriction on our pascal subset to ensure the soundness of the rule no procedure named p may be declared within the scope of another procedure named p our rule is not unique in this respect every other proposed procedure call rule requires an equivalent restriction the restriction is necessary because the inputoutput specifications for a procedure p may be assumed for any procedure call within a procedure declared in the scope of p let procedure pi var value global i bi il rn be a sequence of pro declarations let pi and qi il at the head of some block n be assertions containing no free program variables other ii respectively variables in let i be qi let h be than ii and the free logical a declaration set containing the declarations of pl pk and let h denote h with these declarations an exception is a rule currently under develop ment by but his rule requires rewriting of the program text replaced by forward procedure declarations which only specify the the procedures formal parameters let hi denote h augmented by the declarations prior declarations of x and y are placed for il n we define the recursion hypothesis ii as the rule where recursive version and h are arbitrary of the rule has the then form the where in f use the special rules ii to prove means we may qj unlike original rule and the rule our recursive rule is relatively complete even for the programs mutual recursion of the rules previously proposed in the literature our rule most closely that of mutually uses a more complex recursive procedures set of instead of pi r pn two parts and the procedure a rule of modification call rule into and a rule of invariance we originally formulated our pro call rules in two part form but the approach after we failed to a complete to simple rule by restricting variables achieves relative com actual var parameters we can prove that the recursive version of the simple procedure call rule is sound by the argument we used for the nonrecursive rule we construct the sequences of pro p l pk n as follows we let be a nonterminating procedure with parameters identical to pi for we et pk be defined by the procedure pk global i pj j jl n ie by the same declaration as pi except each call pj within the body of pi is replaced by the call clearly if the tion of an arbitrary call requires less than k levels of nested calls on pn then the call is equivalent to pi note that this statement does not hold if the restriction on procedure names is violated by the of the rule and lm ple induction on k we know that the recursive rule is sound if we interpret p in the by jl n and pi n the conclusion by without loss of generality we may assume pi terminates otherwise the rule is true let k be any integer greater than the maximum recursion calling depth on in the evaluation of pi by assumption the premises are true for jl n consistent any interpretation with h hence of pj they must hold for conclusion pj interpreted of the rule as pk holds i the since is equivalent to pi of the rule must be true qed the conclusion the relative completeness of the recursive rule can be established by a similar inductive generalization of the proof for the nonrecursive rule we assume l is expressive the proof pro by induction on the structure of a program let pi pn be a sequence of procedures declared at the head of a block such that the rule is for the procedures declared within pi r pn assume we are given for all of the procedures recursion containing pro pn we want to show that the weakest precondition is provable for any procedure call in the block body given an arbitrary post assertion for each procedure and let pi we let p be qi be the tion defining the given strongest p as before we let of bi qi be let an arbitrary call in bi such that q is either pj the procedures argument we used in for some j or pl pn the nonrecursive a procedure con by the same case the weakest precondition of q given an arbitrary s is provable hence since the remaining rules of the logic are complete by assumption n is provable by the same the weakest precondition again we conclude that of any call on a pro q in the block body is provable by induction on the structure of a program we can repeatedly apply the previous argument to derive that the procedure call rule is complete for calls in the body of the program qed rules for programs with aliasing we now extend our version of to handle aliasing the modifications are surprisingly minor logic required original assignment axiom has the form ep where term this x is a simple in the logical axiom is invalid variable language if x is e is an expression l and p is a formula a reference or an array reference since there may be syntactically distinct variables in p with access sequences identical to x while style axiom can be to handle array assignment by the assignment e as an abbreviation a for the simple it completely assignment breaks down in the case of aliasing in contrast our rule does not rely on the concept of substitution although it to that form in trivial cases as a result our rule is able to handle array assign ment and aliasing without any modification reference parameters in a programming reference parameters language with unrestricted like pascal we interpret procedure calls as passing the access sequences ie abstract addresses of the actual reference parameters to the procedure in other words the interpreter eval binds a formal reference to the access sequence of the corresponding actual parameter for example if p is a pro with the single reference parameter x then the procedure call pa where a is a variable binds x to the access sequence for a and evaluates the procedure body in a language like pascal every reference to a formal refer ence parameter is automatically if x is a formal reference parameter bound to an actual parameter a an assignment to x in the procedure body changes the binding of a the variable to which x is bound it does not change the binding of x the binding of the formal parameter x is unchanged for the of the call consequently we consider notation for referring to formal reference parameters leading to the situation in our pascal we require that every reference to a for reference parameter x in the body of the pro have the form x instead of x we have taken the f operator from pascal where it serves a dereferencing operator for pointers for if x is a reference parameter then the standard pascal statement x x in our x x is written as we also require formal reference parameter declarations to have the form xi ti instead of to accommodate aliasing within our logic we must extend the set of hoare assertions to in terms of the form xf where x is declared in the declaration set h as t for some type t we the dereferencing operator from appear ing in other contexts the meaning of x given state s consistent with his value the access sequence for x is the value of x the access sequence term for x is simply x our proof rule for assignments formal reference parameters to our ordinary assignment rule to identical op where we extend the definition of the update u a as term or formula in variable possibly follows l be a including let sequence of formal reference parameters and be a corresponding updates of sequence of terms not containing the meaning of u for s is a for updates where update the is extended to overlapping is defined by exactly access sequences update the same axioms as before except axiom section no longer requires the access sequences al an to be disjoint informally a simultaneous update with over is performed in left order the soundness the assignment rule consequence of the and relative completeness of stated above are an fact that in order to reason about updated formulas containing updates to variables we need the following axioms about updates let p and q be arbitrary formulas u uk be terms and be an arbitrary update then lq pq ep pa lr v u p where not free in e u p where not free in t uk ul for every predicate equality symbol pi including uk for every function symbol fi these axioms enable us to move updates inside a formula to the point where they apply only to variable and logical variables we also need axioms for updates to logical variables variable vn be variable and tl tn be corresponding terms let vn tl be an arbitrary updated variable then and u t la b tl n u cl a since updates do not axiom holds variable affect for xl xl variables updated the logical the soundness of all the axioms for an immediate consequence of the definition for updated formulas updates is of truth we can use the axioms for updates to convert an arbitrary formula to form to this transformation we repeatedly apply the follow ing procedure first we push all updates inside the formula so that they apply only to variable and logical variables we eliminate all updates to variables by applying axiom above then for each updated variable k we perform a case between k reduction axioms split on the relationship and a and apply the or above appropriate to each case reducing the complexity of the updates involved while the update elimination practical value since increase the size of a formula that our axioms for updates are to the base theory procedure is it can exponentially it demonstrates complete relative of generalized simultaneous assignment rule given the generalized concept of update de in the previous section we can general the simultaneous assignment axiom to permit overlapping variables on the lefthand side of the statement the new simultaneous assignment axiom is identical to the old one except that the disjointness premise is omitted let t be a simultaneous assignment statement p be a formula and e be a declaration set all the program variables appearing in p or then the generalized assignment rule states the soundness and completeness immediate consequence of the and in the logic of fact truth the rule are that for statements an generalized procedure call rule assume our pascal subset satisfies the tions listed in section our generalized proce call rule is nearly identical to the simple rule value let p be declared as procedure tx global b in the declaration set h let p and q be formulas containing no free program variables other than and r respective ly let be the free logical variables in p and q let and be fresh logical variables correspond ing to and let r and s be formulas and let h denote h augmented by tx where prior y ty and declarations of and are replaced then the disjointness hypothesis in h asserts that the sequences for the formal are disjoint from the passed actual refer ence parameter access sequences from this we can deduce that the for reference parameters do not any of the formal parameters as aliases we must add an analogous hypothesis to the rule given in section soundness and relative completeness the soundness and relative completeness proofs for the generalized procedure call rule differ only in trivial details from the corresponding proofs for the simple rule the only concerns the definition of we must not let eval be by formal parameter names which match actual reference parameter names the simplest solution is to force eval to rename the actual parameters con with formal parameter names before evaluating the procedure simultaneous the procedure body eval body after evaluating performs the appropriate a sample proof involving aliasing let swap be the standard defined by integer swap procedure procedure begin xy ref integer a xy post a end first we prove the correctness of the pre and post assertions let h be a declaration set including the declaration of swap let h be h augmented by the formal parameter declarations of swap and the disjointness hypothesis by the simultaneous assignment rule proving the pre and post assertions for swap reduces to proving the verification tion h i a a moving the update assertion inside generates the equivalent h i which immediately reduces to a h i a y a since x and y are both ref h i xy v integers we know y in the former case xy reducing the verification condition to that h which is y disjoint true since xy in condition to the other case x and reducing the h i which is an obvious qed now let us examine a sample application of the generalized procedure call rule involving aliasing let h include the declarations integer of integer assume we want prove h i a by the generalized procedure a call we must show h i a a o a let s denote the of the final tion yields moving the updates within s further inside k a which reduces to a tie instantiate the logical variables major hypothesis as al and a respectively us the hypothesis a xa in the giving since the premise of this hypothesis is identical the minor hypothesis we deduce the new hypothesis to a xa if ij then s reduces on the other hand if precisely ij then to this s reduces formula to a ya which is a simple consequence of the hypotheses and qed ij handling recursion the recursive form of the generalized procedure call rule is completely analogous to the recursive generalization of the simple procedure call rule the soundness and relative completeness proofs are also nearly identical to those for the simple rule reducing aliasing the complexity of proofs involving although our rules for procedures with alias ing are relatively simple and easy to understand they are rather to use in practice because they force all variable parameters to be passed by reference many procedures exploiting aliasing are designed to work only for a small subset of the possible aliasing configurations if all variable parameters are passed by reference the pre and post assertions for such a procedure must include a long list of disjointness assumptions we believe that a procedural programming language should provide two distinct classes of formal variable parameters those which can have aliases and those which cannot the explicit syntactic between these two classes greatly reduces the number of possible aliasing con simplifying reasoning about updates to incorporate this modification into pascal we establish the following syntax for procedures our new procedure aliased global b global z zl tw value where are reference parameters as described n section are variable parameters which have no aliases within the procedure are standard value parameters are global which may have aliases in the procedure and are global variables which may not ment within the procedure code block b an assign to any parameter v other than a reference param has the standard form ve in contrast all must be explicitly ment to a reference references to a reference hence parameter w has the parameter an wk the generalized recursion for this procedure extension call rule without of pascal has the following form in a declaration let p be declared as shown above set h let p and q be formulas in l containing no program variables other and respectively than let be the free logical variables in p and q let wl be logical variables corresponding to respectively let r and s be arbitrary formulas and let h be h augmented and by w ref fw with prior declarations of r deleted then h i h i r h j q the soundness for the modified from before and relative completeness proofs rule are essentially unchanged eliminating the remaining restrictions our most general require the following procedure restrictions call rules still parameters or functions may be passed as every global variable accessed must be accessible at the point in a procedure of every call no procedure named p may be declared the scope of a procedure p within as has pointed out restriction can be eliminated by making the declaration rule rename new variables within program text a similar can be used to eliminate restriction in essence this approach makes the rules rename gram identifiers so that restrictions and hold after the renaming we the idea how ever because it modifies the text of a program and any embedded assertions in the course of a proof fortunately neither of these restrictions the programmer in any way they simply force name his variables and procedures for this reason we believe these two restrictions are a reasonable part of a practical programming language definition in the remaining of procedures and functions as param the from using an language construct in some application areas such as numerical as parameters analysis procedures and func are nearly we intend to extend logic to handle this language construct in a subsequent paper acknowledgments we are ing several errors per to london for discover in an earlier draft of his references apt and apt lz r and j w semantics and proof theory of pascal tech amsterdam cook cook s axiomatic and semantics for an algol fragment tech dept sci univ of of j e complementary programming language verlag berlin definitions springer of h a mathematical press new introduction york to g a a complete axiomatic system for proving assertions about recursive and nonrecursive programs tech dept of comp sci univ of jan j v j j and a proof rule for xerox palo alto ca r l london tech london and automatic program verification basis and its pp i acts a logical informatica hoare hoare c a r an computer programming pp axiomatic cacm approach to oct hoare hoare c a an axiomatic of algorithmic r procedures and parameters approach symp on semantics languages e cd berlin pp hoare and hoare c a r and n an axiomatic definition of the programming language pascal acts informatica london r programming palo l et al language alto ca proof rules tech for the xerox d c on logic tech dept and program verification of comp sci univ of 