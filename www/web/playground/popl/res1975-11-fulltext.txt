even are hard to analyze by d jones s muchnick department of computer science the university of introduction it has long been known that most questions of interest about the behavior of programs are recursively undecidable these questions include whether a program will halt whether two programs are equivalent whether one is an optimized form of another and so on on the other hand it is possible to make some or all of these questions decidable by restricting the computational ability of the language under consideration the loop language of meyer and for example has a decidable halting problem but undecidable equivalence restricting the computational ability still further all of these questions are decidable for finite automata and generalized sequential machines except that has shown equivalence undecidable for nondeterministic a natural question to ask is how hard it is to solve these problems for languages for which they are decidable and it is with this area that we are concerned in this paper in particular we describe a programming language modeled on current higherlevel languages which has exactly the computational power of deterministic finite state transducers with final states and analyze the space and time required to decide various questions of programming interest about the language we find that questions about halting equivalence and optimization are already for this very simple language we also study extensions to the language such as simple arithmetic capabilities arrays and recursive subroutines with both callbyvalue and callbyname parameter passing mechanisms some of which extend in one case undecidable the capabilities that of recursion of the language with callbyname andor increase the previously the complexity decidable of its questions decidable problems are seen to become ii finite memory programs let z be a fixed number of symbols in instructions such that finite alphabet and a symbol not in i u then a finite memory lll z the let s denote the or p is a finite sequence of labeled each i is of one of the following j read x j write v forms if vi v go to l accept halt where j n each v or vi denotes k either an of u or a variable name x j and single halt lk or accept there is an m such that each of x x occurs m in p and no x occurs j in p for j m denote the number of variables in p by m and of instructions in p by k we denote the length of the program by counting each word read if etc as symbol and representing the subscripts the variable names in binary notation a the work of the second author grant was partially supported by university of general research labels are not counted in while program length will in length will be of little or no a configuration of the p is a triple u mc z denote the vector aa be a major concern in this paper linear such that x e z i k and am in the sequel we use the symbol v to denote either a variable name or a symbol in x u and so define to the configuration a by v the content with respect let a aj f v j and be configurations then a yields b immediately denoted a e iff one of the following holds ii read xl for some j i bk ak for k and either there is a bl z such that i i i j il y x b l v go to y x bk ak for all k and either j and and the relation a is false if ii or accept closure of by and define p accepts and i such that as usual we denote for x e x iff there the reflexive transitive exist lm and ii is accept accepted further by p is lp x is called accepts x an accepting configuration the as noted above a finite output is defined by a partial u a ap memory program function pe u x i is not simply an but has output as well e which satisfies the condition that for x z and ap is an accepting configuration then the if px where for each i if u i then v c otherwise if x lp then px is undefined pi and p are written pl u p if and px are either both defined and equal or both undefined for all x z we also say pi and p have inputoutput behavior for p u p the above describes the strict formal syntax of finite memory programs and their semantics shall not however to the strict syntax in writing programs we use a variety of informal constructs which may all be easily ie in log space translated into the strict syntax with a not more than two additional instructions and no additional variables for each these constructs include labels and variable names statements without labels statement brackets begin we cost of end to v then s and v then s s where s s represent statements the computational power of the class of is characterized as follows lemma if p is any then there is a deterministic final states and identical input and output alphabets such behavior ie vx e z px mx and conversely generalized sequential machine that p and m have identical inputoutput m with proof that a can simulate a should be clear so we concentrate on the other direction notice that we can modify a to determine whether it has entered an infinite loop and halt if so this is proved in of lemma below the set of states of the can be z where r is the set of labels of the read statements are distinct accepting and states in the m is the number of variables and qa and the initial state is am where i is the label of the first encountered read statement and al am are the values of the variable immediately before of that statement the set of final states is f qa and is a looping state since the states record the transition function all of the current configuration of the except k x z u k x z can be defined in a totally the input it follows finite manner that n a variety of modifications in without the computational following lemma note that unlike the syntax of the language and capabilities of the language the informal syntax extensions the construction of programs can be made some of these are summarized in the some of these may have effects on the size of programs and hence on their complexity lemma for any there conditions is a p equivalent to p and satisfying p has exactly one halt and exactly one accept instruction p halts or accepts only after reading the entire input p halts or accepts for every input ie it never loops p has no instructions p has no assignment statements any or all of the following proof for simply append to p the instructions k halt k accept and change all other halt instructions f go to k suppose p halts before reading to if the l read xl go to k and all other entire input then replace all accept instructions instructions to by l and as necessary the maximum number of instructions that can be executed between read instructions without p looping is a counter replace each let c be such xi instruction that c by and let add variables y o to n to use as replace any other instruction read x if x then l j i by yo i begin then y a yo a begin y c if y c then a halt end this and translating this follows by a as in lemma the resulting back to a also follows directly from then removing the states ii while construction are not powerful to prove that enough to simulate all nondeterministic there is an easy lemma any nondeterministic finite automaton with n states and transitions w more than n variables and length of order log n is equivalent to a proof we use one variable z to receive each input character variables are partitioned into two sets x xn and y yn states q in which the nondeterministic finite automaton is currently x az each symbol b is read q l and then the y are used l to the yi are copied construct into the the x set to the finite automaton the xi are used to record the the active x if state i qi p of states that qb other set of f q and p as ij basic results among the questions in the following sets about which we believe to be of interest accept p i x z such that p accepts f i lp x are those expressed by membership halt p i x z such that p halts but does not accept on input x loop p x z such that p enters an infinite loop on input x reject halt u loop accessible p i x n i xx e x such that on input x p executes its i th instruction at least once pp i x x remove pi ith instruction x n i x px of p and where as necessary p is the program obtained by removing the other questions about optimization than those expressed by accessible and remove are difficult to formulate without some measure of what it means for one to be better or more efficient than another such measures might include program length number of variables execution time and so on but are difficult enough to down that for the present we limit our concern to consideration of the above questions many of these sets are of essentially the same complexity in the following sense define s t to be true iff there is a function f such that for any x x e s iff fx e t for some c and all x and fx is computable in space let ts then the following relations hold among these problems for example accept may be shown as follows given a p we construct fp pp where p is identical to p except that each instruction in p is replaced by write a accept and as appropriate for some fixed a x it is easily checked that f satisfies and thus we can restrict our attention to accept loop and in our consideration of the of these problems the following definition and lemma due in concept to meyer and ms are essential to our lower bound results for space complexity our model for the complexity of problems is the turing machine that is a turing machine with a single readwrite tape we say that a turing machine z operates in space s for sn n iff on input x it not more than tape and in time t iff on input x it makes not more than transitions the class is defined to be the class of all sets which can be recognized by deterministic turing machines operating in s and is defined analogously bounds let for nondeterministic rg a be an arbitrary turing machines and are defined analogously for time relation defined on an alphabet a satisfying x u g a are distinct symbols x e z letting n x we define a not in z and let s be a function comp to be the set of all xs such that sn n for y satisfying any is an initial substring of y bi qf for some i m and s n r a of a set l g a is a set hl where ha z is a homomorphism such that for any ab e a in the following m denotes a class of machine descriptions or programs we will initially in our applications of lemma below have the of as m but later will apply it to various extensions of note that m could just as well be the class of turing machines or another class of automata m we denote m and lm by accept in general in specific cases we simplify this notation so that is simply accept is and so on we shall use the clause q requires at least and similar for the other time we use the g to indicate set and c to indicate proper inclusion ie ac b iff and space hierarchies to mean that q f so for any bound s such that note that this condition while probably not particularly natural space bounds that do not polynomials we have s en spaces n in addition if o c d implies s en c which is true for exponential the conditions of lemma will imply that accept g for some c for most bounds o then lemma suppose that for each a and r g a there is a function f x m such that fr is computable in log space for some c and all x x and accepts then requires some of comp xs at least s proof as follows qf be the let z be an arbitrary a and r such that vx let a u k u b unique final state of nondeterministic e z z accepts turing machine o in space sn then x iff lm where m f r x cm this can be seen where r is the tape alphabet of z and k is its set of states and let a let r for i sn letting a difficult x e lz to see that comp xs iff s where is an accepting is the transition relation of z then it computation on input x by z clearly is not now suppose can be recognized in space where o let z be a turing machine which operates in sn space and such that lz co en then x lz can be determined by first calculating and then deciding whether clearly a nondeterministic turing machine can do this in at most the that lz co en s n space n the above lemma also holds for offline turing machines with space bounds down to log n by a similar but more complex construction which we omit for sake the problem p accept can be decided nondeterministically in the amount of space necessary to represent and manipulate a configuration without input a im comparing the size of a configuration without input and the size of the corresponding program p we conclude theorem accept proof we can decide lp with a nondeterministic turing machine by an input x simulating the operation of p on x we simulate the control flow of p in the transition function turing machine and so require space for the label of the current instruction and the contents of variable ie a configuration without input we estimate the size of a p with m variables k instructions as ml s kl kl log ml and of the and the and the size of a configuration o as kl m log thus accept from lemma we can obtain a lower bound for accept namely theorem accept requires at least ng n proof we construct of size linear in n a p which accepts to do so we use m n variables n for any r and x where xl xm each of which n x and which over is z u across the is satisfied the variables and string y see the definitions whether xb n n v l program structure may immediately preceding l tm l l be thought of as a window checking whether l qf in which moves the relation y we r must l name each of the m variables we must have m log m n which is the case for m n c from our comments before accessible as well as accept lemma it is immediate theorem also applies that theorems and apply to halt remove and to loop and reject and a small modification of causes note that theorem to a to them as well the set px t p accepts x is in and requires at least since we now do not need to guess the x accepted by p the same comment of course applies to the other problems mentioned above by another technique we can show that the same bounds apply to in particular we can show that if m m are deterministic with final states then ml m is decidable in space this result appears to be new and while to the corresponding result for without final states equivalence is of the same order of difficulty as halting of so we restrict our attention to the accept problem not difficult note the rather this also holds in considering is not simply an surprising fact for most of the extensions easy corollary that extensions theorem for with final states ml and m ml m log n since this result is of the paper for any p let forward to build a turing i th symbol of a description of only importance here we its p denote the naturally corresponding equivalent machine which given pi as input will construct of p now given any two pi and p we can proof for a version to p it is straight in linear space the apply the turing machine which construction shows for to p and p analysis of the space requirements for this theorem n corollary to theorem we have corollary requires at least n note that we section ii by specifying that we were working over a fixed alphabet z u of size s if we were to allow the size of z to vary this would affect our complexity results we might then of the complexity of problems for machines of different word sizes and would find that each of our upper bounds would have a multiplicative constant of log s as long as we within any particular word size alphabet size this is only a constant factor but allow the size of z to vary arbitrarily we introduce a factor bounded by into the upper bounds we might introduce an element of nondeterminism into by allowing the instruction whose execution would go to cause a nondeterministic zn selection of one of the statements labeled to be the next statement executed an input would then be accepted iff there were some sequence of choices which led to an accepting configuration while not the upper and lower space bounds for accept and equivalent problems accessible etc this change undecidable by result in addition the problem given m is l m z may be shown to require at least n for some c by use of lemma in this section we see that all the questions of interest about deterministic require approximately nondeterministic linear space even though the is a particularly simple and restricted model of computation we are thus led to conclude that the problems which are undecidable for general programming languages are though decidable in this limited context nevertheless extremely difficult for even such simple languages as we consider here in essence they require the amount of space and time necessary to do exhaustive search iv finite memory programs with numbers in this and the two sections we discuss natural extensions to finite memory programs which increase their ease of programming andor computational ability and which make their decidable questions harder we shall be rather less formal in describing the extensions than in our presentation of the basic model in section ii we denote the extensions by on the name and the problems about the extensions by applying the same to the names of the problems thus we have for example and for with recursion fixed word size the first extension we consider is the to perform arithmetic this is naturally done by interpreting the symbols in x u as representing the integers s with representing o we then define a memory program with numbers to be syntactically a as before with the possible addition of instructions of the forms xy op z where op is any of semantically these are interpreted in the usual way except that all values are taken modulo e and denotes integer division with in of num a s not computationally more powerful than a since its total number of configurations without input is still finite in fact we have lemma any program p in may be replaced by an equivalent length of p will be linearly bounded by the length of p as p ranges program p in over further the proof we first show how to replace only x x and usual primitive recursive constructions replaced by the sequence each the usual of instruction of the form x y op z by an equivalent instructions from successor this is done in a way similar for example x y z may to be z than go to next go il the and may de dy xo n note that the number of instructions performed in executing p may be significantly less than in p corollary li accept is in and requires proof immediate from theorems and at least ng n d variable word size in his we define a finite ps where s is the binary representation interpret o as and z as ls however use of addition modulo s p is a as defined program variable word size of an integer s and p is to be elements of z may be accessed before with two exceptions described implicitly to be a pair we again by the a the elements of x are represented in binary notation and b p may contain instructions of the form x x with the addition performed modulo s note computational to x x reason is that we could also of a however this that s is variable allow instructions since the of the form same technique x y z etc as in lemma instruction cannot itself be eliminated as was so each x x would be replaced by os without increasing the could be used to reduce done i lemma the en s instructions them theorem accept ws proof the proof input string i as for theorem by simulating an arbitrary given p on a nondeterministically the amount of space used is bounded by the size of a configuration log k s log theorem requires at least n log n proof this lower bound is obtained in a way similar to the corresponding result for ordinary theorem by constructing fixed r and x where n a of size x the key to the proportional construction to n which accepts comp z for n any is to consider m variables each containing a number between o each may be viewed as a string of m bits so a configuration specifies m bits of memory is defined variables which can be used to store just before lemma the must have a distinct name version of this paper the string of m symbols from the factor enters because of the fact that each eo m must satisfy m log m n further details will string y which of the m be given in d v finite memory programs with arrays we next consider the extension of adding arrays to in particular the class of finite memory programs with arrays or has an alphabet z the and s ix u as before in addition we have a fixed except that for each form where subscript occurrence set o c x a of an xi there we may each wj is either an p is then now have variable a program as described in either an x or an expression x or a symbol from g and section ii of the each v or vi represents an xi an expression or a symbol z u the number of subscripts to xi must be the same throughout obvious extension of the semantics of except for p the semantics two points are a straightforward and if in an expression wi one or more of the has as its value a symbol not in then the entire expression evaluates to o and in a configuration each ai is a function ai o number of subscripts possibly zero to the variable x by a similar argument to many of those above we obtain the following e u where l is the theorem the complexity t of the problem is exactly where t i provided tn the lower bound is obtained by showing how to construct given x a which accepts in space linear in n x the key is to construct an array whose elements contain a part of length tn of the string y referred to immediately of lemma note that by varying the size of the subscript set or the requirement that o g z we may alter the complexity bounds the resulting bounds will however correspond to nondeterministic space proportional to the number of cells as a function of the size of the program vi finite memory programs with recursion we next consider with parameter passing mechanism but explicitly callbyname recursive subroutines we discuss two forms which turns out to be equivalent to one with and no explicit the other which is without parameters a finite where memory program with or is a p tuple p xo xp are disjoint sets of variable names x is the set of global variables and xi is the set of variables for pi for i for i p pi is an ordinary except that a pi may refer only to variables in xo u xi b pi may contain instructions of the form pj for j and return the instructions of pop pp have distinct labels and no go to instruction may cross a procedure boundary if expressed in the style of algol the syntax would take the following form begin all variables in xo procedure pi begin symbol all variables in xl body of pi end begin p p all variables body of p p end body of main program po in x p the semantics length tuple the end are a bit different length is three more from than those twice of an ordinary a configuration is a variable the current depth of calls of the form cx where for each i if is an instruction in p then y z l j xl intuitively for j q i is a return address and yi denotes j variables of the corresponding pl the current instruction is that the initial the values i q configuration of the local is the relation is defined nearly as before the effects of read xi v xi v accept and are all essentially as for an ordinary the effect lx of pj is to add the pair ij j to the end of a where i is the number of the first j instruction of p and to change i to iq the effect c of return is to remove from the end of a and to continue execution with the instruction i q note that the semantics are quite consistent with those of the algol skeleton presented above the effect of callbyvalue parameters may clearly he achieved by setting global variables before a and then copying them into local variables immediately after procedure entry clearly is computationally more powerful than since sets such as may be accepted in particular we have theorem for any p there is a deterministic p ie px mx for all x z and conversely pushdown transducer m equivalent to proof given a p the construction of an equivalent m with final states and is a corresponds of the is current memory i extension of the proof to the set of configurations the set of instruction labels contents the effect of onto the stack and of the corresponding part of lemma the state set of the of p input and the stack the stack alphabet k of p along with is simulated by symbols from z to hold current state corresponding to the first instruction of p and the current memory contents return is simulated by branching to the state corresponding to the j instruction on top of the stack along with the current memory contents and the stack now suppose we are given a m we may without loss of generality assume m is presented in the form of a program similar to that of a with the following instruction types read x write c push c pop x f x c go ko accept and with the obvious semantics only a single variable the instructions of m be labelled k we now define p xf x is needed c denotes any symbol from z u let where po is defined below and each pi is indexed by a constant c in x u pi may also be denoted by pc the overall structure of p expressed in algol like notation is as follows a is some symbol from z begin fk one procedure for each c e z u procedure pc begin f then if f then begin f go to lc end f to l end else if fk then begin fk go to l end lc lj c l kj end of procedure f a p pc end if instruction read x push d pop x i of m is d then in the same instruction f a p go to il x c a pe lb the effect is to replace each push by a and each pop by a return the variants pc one for symbol are used to keep track of which symbols were pushed the flags f fk are used to preserve the point of control across a or return a similar technique will be used for the simulation of queue by recursion with callbyname d each a theorem there is a constant c such that accept ec proof detailed of the construction that m may be constructed a from p in time of the first part of the proof or fixed a and all p of theorem reveals iff lp and the test lm may be carried by constructing m and then testing out in time polynomial in thus lp may be determined to see whether lm the total time used is clearly bounded by cn for some c n in the following we shall denote the binary representation o and will be identified with two symbols from z of a nonnegative integer i by further definition such that if given notation then let b and let op and s be deterministic offline x where x z and ij xx turing machines with one work are presented in binary tape a op computes a binary operation on xx b s whether i is in a set x and x c op and s operate in space the gen problem determined by x op and s is the following x f to determine whether o is in the smallest subset of xx which contains sx and is closed under whether o is generated by sx under n it was shown in jl that the gen problem is complete for p ie proof a closely related result for exponential time bounds the proof of theorem and corollary of jl the proof time depends we now n on a careful state without analysis of theorem let z be a turing machine which operates in time tn where and all n then there are offline turing machines op and s as in definition z accepts op x iff x has a solution tn an for some a such that for all x z the following is similar in purpose and use to lemma theorem let m be a of machine descriptions eg and all n and suppose further that o c d implies t en in definition there is a function fe m such that programs c let tn an for some a if for every as a f is computable in time tn b for some c and all x and c for all x fx m f iff for some d has a solution proof suppose for all d and let z be any turing machine which operates in time exist that t such let for all that lz f be as in the premise x x e lz iff fx by theorem appropriate tn op and s turing machines ing the conclusion of theorem and above we see accept d now by assumption with d lc accept thus membership in lz may be determined by calculating fx of length and testing for membership fact that in accept which requires at most time lz f thus the assumption tn that g but this contradicts the for all d must be false nu corollary g n for some d proof we show how the premises op s and x consider the contextfree of theorem can be satisfied for tn ng grammar gx a n first for any where p contains sx and clearly whenever k if ai sw w may be viewed as a prefix expression with the symbol replacing further it is easily seen that ai w holds only if i is the value denoted by w thus iff o is generated we now define f so that from x for each x fx is a which accepts w iff a w and satisfies conditions we let m a b and c of theorem nl where as usual the form of f is as follows n x again in a notation begin sol im procedure op comment op and stores taking from im and from the result into k l km body of op procedure s comment o if not s takes from cells k km and sets in to if k x and body of s procedure p comment p reads an expression and returns its binary value in begin l symbol km read k if k then begin read km s if in then else halt end p l k l m km call op il m end of p end of fx k m o then accept halt all three of the conditions of theorem will be satisfied provided it is possible to construct procedures op and s to behave as specified in time polynomial in n and to have size which is linear n condition a then follows from the simplicity of fx and the fact that tn dominates any polynomial in this case condition b also follows with the addition of if necessary since m log m n condition c is immediate since it is clear that when given a prefix expression w machine fx will evaluate it using for end accept w iff w is in thus fx iff gen x has a solution in finally op and s are obtained from the turing machines of the same names constructing simulation programs in each square is represented the state transitions are encoded as instruction sequences in a straightforward variables needed is bounded by log n which is certainly much smaller than n from representation of the input tape which corresponds to x along with from by by a separate variable way the number of the only variables k km and and im in n one via log n since a solution variables separate variable can is to define a table will return the ith not be lookup symbol assigned to each procedure which of x this can symbol when easily of x without given i n as a binary be space linear case parameters called by name linearity number in n n we now show that at least one interpretation of callbyname parameter passing gives rise to an undecidable halting problem consequently emptiness equivalence and the other problems are also undecidable in order to see this we show that any of a family of programs which is known to have an undecidable halting problem may be simulated by programs which are completely finite except for an unbounded pushdown stack which contains return addresses and parameter information consider a simple programming language q with instructions of the form is add the value of x to the left end of a queue x that is remove the value which ie at the right end of the queue and store it into x iv v go to halt the semantics known e g via should l as for be clear we assume results on tag systems the queue symbols min that the are positive integers now it following problem is undecidable is given an arbitrary program p in q to determine whether or not p will eventually its halt by performing a instruction or by theorem the halting callbyname problem is undecidable for finite memory programs with recursion and proof let p lll be any program in q which uses variables following begin integer ix xm procedure value c integer abc begin it i then go to l if i then go to l if i k go to lk ee go to encoding of ll x xm consider the k kl encoding end of ik i ea po end instruction encoding ii x is encoded as i il then c else go to b ii x is encoded as if b than go to x a a a c ii if v v go to l appears unchanged notes this program substitution differs slightly from algol in that a a becomes if b than c a if b then c a in effect after parameter this is not legal in algol but its import should be clear at any point execution the runtime stack will contain among other things a list of all previous values of c from earlier calls if this list has the form it at earlier that steps the queue now consists of y and that elements have been removed note that each variable only assumes a finite range of values or in the case of parameters abc a pointer to part of the original program thus all memory is strictly finite except for the implied by recursive calls it may be verified that this program will halt iff the original q program p halts halting of q programs however is undecidable thus the halting problem for any class of finite memory programs large enough to contain programs of the form above is also undecidable representation of this program as a type of with callbyname parameter passing is straightforward although a bit complex it is necessary to store parameter access information e g addresses in the stack in addition to the return addresses in addition the semantics would have to ensure the proper evaluation of formal parameters n vii conclusions we have discussed a restricted model of computation on current the computational difficulty of various solvable questions concerning it natural extensions of the language and their contributions to increasing questions we have shown that in general the problems require essentially among the possible configurations of a program and thus are both of large improvement by the of techniques we believe the kind of work reported here is novel and of higherlevel languages and we have then considered various the complexity of these the work to do an exhaustive extremely hard and further attention we suggest in particular definitions the study of complexity of other extensions measures appropriate to the language other problems of programming interest to the study of optimization questions and so on g hu jl m ms min references cook a characterization of pushdown machines in terms of computers journal of the association for computing vol no january pp generalized july t v the machines of pp of the equivalence e for machinery nondeterministic vol no hopcroft john e and jeffrey addisonwesley d unman languages and their relation to automata jones proceedings d and of annual william t complete problems for deterministic acm symposium on theory of computing polynomial time pp meyer r and m research paper rc may complexity and structure meyer r and l j the equivalence requires exponential space annual theory october pp problem for regular expressions with on and automata l computation finite and infinite machines prenticehall pp on finite on switching theory and logical automata proceedings of the fifth design pp annual 