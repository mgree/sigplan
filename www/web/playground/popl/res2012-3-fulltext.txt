and interleaved bugs k microsoft research wa usa microsoft research abstract static assertion checking of open programs requires setting up a precise to capture the environment assumptions for instance a library may require a file handle to be properly initialized before it is passed into it a is used to set up or specify the appropriate preconditions before invoking methods from the program in the absence of a precise even the most precise automated static checkers are bound to report numerous false alarms this often limits the adoption of static assertion checking in the of a user in this work we explore the possibility of automatically away or warnings that result from in the we limit our attention to the scenario when one is interested in finding bugs due to concurrency we define a to be an interleaved bug when it on an input for which no sequential interleaving produces a as we argue in the paper limiting a static analysis to only consider interleaved bugs greatly reduces false positives during static concurrency analysis in the presence of an we formalize interleaved bugs as a differential analysis between the original program and its sequential version and provide various techniques for finding them our implementation demonstrates that the scheme of finding interleaved bugs can the need to construct precise while checking concurrent programs categories and subject descriptors d software engineering verification general terms verification reliability keywords concurrency verification differential analysis static analysis false alarms introduction static analysis is concerned with the problem of finding bugs or proving their absence in code without actually running the code in this paper we apply static analysis to open programs or libraries ie programs that do not have a main procedure but instead expose a set of api methods in such a setting the user of static analysis has to provide a that invokes appropriate methods from the library permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission andor a fee popl january ­ pa usa copyright c acm often times the exercise of writing a correct is difficult and error when done manually one reason for this difficulty is that the libraries usually have preconditions that must be satisfied before invoking particular methods for instance before invoking a read operation on a file the library may assume that file handle is properly initialized if one applies static analysis to such a library without the precondition the read operation can fail and the static analysis will report a bug however this does not reveal any bug in the implementation of the library instead it only reveals a problem with the that was used to invoke the library thus no matter how precise the static analysis is it is bound to report false alarms while using in our experience the problem of false alarms including those due to limits the adoption of static analysis tools that aim at checking userdefined assertions in programs the problem of spurious warnings due to does not get better while checking concurrent programs however there is a very natural option for false alarms in order to look for the more interesting warnings find violations to assertions assuming that the sequential executions of the concurrent program under a correct do not violate any assertion this assumption about the sequential executions being safe may be justified because a program is more likely to be tested for interesting inputs rather than for different interleavings as it is beyond the control of a this assumption immediately leads to pruning of the set of inputs to the program if an input i fails an assertion in the program in a sequential interleaving then it has to be an illegal input that should have been by a missing precondition in the hence we are left to search for over the space of inputs for which no sequential execution violates an assertion if an input in this space violates an assertion it has to manifest in a complex interleaving of threads we term bugs that manifest on such inputs as interleaved bugs the static analysis problem then becomes that of finding interleaved bugs instead of finding all bugs formally a concurrent program p has an interleaved bug if some assertion in the program fails for an input i for which no sequential interleaving of threads in p result in an assertion failure interleaved bugs might still be spurious however we make the following conjecture based on looking at a large number of spurious warnings if an illegal input due to an violates an assertion then it does so in a fairly simple execution more precisely whenever an illegal input leads to an assertion failure there would be a sequential interleaving this failure we formally define the notion of sequential interleavings in § as one in which threads do not interfere with each other it may be possible that a concurrent execution on an illegal input fails we are only that in such a case there would also be some sequential execution that fails under this conjecture most interleaved bugs would correspond to real errors our experiments § support this conjecture all interleaved bugs that we found were actual bugs in the program although this result might not hold for all programs it gives us greater that our approach actual concurrency bugs note that our technique does not provide help when one is looking for sequential bugs we are only addressing the scenario when one is interested in finding concurrency bugs but static analysis results in many false alarms let us contrast the approach of looking for interleaved bugs against two other incomparable approaches for warnings one possibility is to find a the set s of locations failing asserts that manifest in sequential executions and b the set c of locations that manifest in concurrent executions and only report the locations in the difference of c and s this approach does not provide any guarantee on the absence of bugs when the program has been sequentially verified unlike our approach this is because the presence of a single illegal input that can fail an assertion sequentially that assert even when a legal input could fail the same assert another approach is to all the sequential traces that violate an assertion and only report those traces that have interleaving between threads this may still report too many false alarms it may report trivial interleavings that still transform the shared state in manner similar to some sequential interleaving an example of such a program is given in § we believe that interleaved bugs achieves a good tradeoff for false alarms due to environment assumptions while not true concurrency bugs in this paper we algorithms for finding interleaved bugs we formalize the problem as a differential analysis of two programs for two programs p and p p is the problem of finding an input i such that p can fail when started with i but p cannot in some sense p acts as a filter for p run p on an input only when p doesnt fail on it let p be the concurrent program under test let ps be the same as p but executions of ps are restricted to be sequential ie ps can have multiple threads but it does not them we formally describe how to capture ps as a program in § then finding interleaved bugs is the same as solving p although solving all instances of is infeasible it is undecidable we provide techniques § that allow us to find interleaved bugs in many realworld programs we also show that one can choose various interesting of ps for the purpose of proving the absence of interleaved bugs the various choices have impact on the performance of the analysis one technical is that p is harder when the programs are nondeterministic ie when they have multiple possible executions for a given input as with any tool nondeterminism is it comes comes from modeling of external calls as well as the thread scheduler we give techniques to handle this difficulty we have implemented our algorithms for finding interleaved bugs in a tool called that uses an bug as the static analysis tool we evaluated on real and concurrent windows device drivers examples of false alarms and real bugs in these drivers can be found in § this paper makes the following contributions we define interleaved bugs for assertion checking of concurrent programs § and illustrate its role in reducing false alarms due to we describe the problem of finding interleaved bugs as an instance of the problem for comparing two nondeterministic programs with respect to a set of assertions and various techniques for solving it § our experiments § show that is able to remove all of the false alarms due to missing preconditions and retain true concurrency bugs the rest of the paper is organized as follows in § we present realworld examples to justify our observation on for concurrent programs in § we formalize the more abstract problem and present algorithms for solving it in § we apply for finding interleaved bugs and discuss specific filters and optimizations in § we evaluate our approach in § we mention related work motivation we our work with a few realworld examples of checking properties of concurrent programs where a missing environment assumptions result in spurious warnings b the spurious warnings often manifest in sequential traces and c our technique only reports true concurrency bugs without requiring the user to specify environment assumptions example figure illustrates a simplified version of a bug found by the tool in a microsoft windows device driver this particular bug is an instance of class of bugs where an object is accessed after it has been the method is a dispatch routine that handles read requests sent to this driver denoted by the request parameter among other things the method makes a call to with the request and a method one of the sideeffects of the call is to set a field to after this call the method may be called on request by the device driver to the request by invoking the routine similarly the method sets the to null the routine from being invoked the request is completed or by a call to method the method accesses fields in the request by a call to it is the of the driver to ensure that a request is not accessed after being completed several such as the following are provided for driver writers if a driver has called and if the drivers callback function has not executed and called the driver must call before it calls outside of the callback function the property can be modeled by a introducing a ghost field completed for each request it is set to true by a call to and b every access to a request request by the assertion these assertions are implicitly present in this program before the calls to the methods and that access fields in request the routine test is the or the test driver it invokes a set of procedure calls in body some of these procedures may thread t thread t void void request request request request void request f null status if f void test request init body async request async figure down version of a bug found by in the device driver the three columns show the two threads and the test driver be executed by new threads using the async keyword in addition to the method calls the user has to additionally constrain the inputs to the methods this can be done by either constructing objects that are passed on to the methods or specifying some constraints on the inputs the out assume statement in the test is one such constraint that has to be manually specified to model the environment assumptions for the open program let us understand the need for these assume statements by looking at the warnings reported by a precise analysis for this program we describe an interleaved trace by a sequence of events tid i li where tid i is a thread identifier and li is the line number of event we sometimes avoid specifying all the events in the trace and specify only the end points of an context in each thread the trace would cause an assertion failure for the access to request in however this is a spurious because the read routine is called with incomplete requests in any legal execution the trace is another spurious that may happen if is set to and request is completed in the input to test the trace denotes a feasible trace that may cause the device driver to access a completed request in line in the second thread this was the bug reported by and has been fixed in future versions of the device driver note that the bug in a small window the instruction has to be executed between and it is easy to observe the only the third is an interleaved bug ie it cannot manifest on any sequential interleaving of the threads on the other hand the first two manifest in a sequential interleaving our method only reports the third without the need for environment assumption in line in test that rules out the first two warnings thereby reducing false alarms automatically on the other hand if we use a strategy to any error location that can fail sequentially we will be unable to discover this bug example figure shows another example where failure to specify environment assumptions may cause large set of false alarms the example is a simplified version of the serial device driver the example consists of two threads running two dispatch routines for write and read respectively the structure denotes a pointer to an interrupt request packet or a request and we check a similar property the main differences in this example are the driver explicitly nested pointer fields in the eg in line of the completion routine may all pointers reachable from a pointer that it completes unlike the driver in § the serial driver an driver does not use much data abstraction mechanisms and often nested fields making it more challenging for analysis we have explicitly added the various assertions to model the property a tool that analyzes the test should report that there are no assertion violations in this example this is because for any concrete execution the device driver ensures the following precondition to test a the pointers reachable from each request are not completed and b the two requests and are disjoint ie the set of pointers reachable from and do not overlap it is not hard to see that in the absence of such assumptions any tool will yield false alarms for example the sequential traces and require a precondition that pointers reachable from and are not completed similarly the trace requires that two requests have disjoint set of reachable pointers one approach taken in practice is to create fresh objects by invoking constructors this ensures that the set of pointers in two requests are disjoint and not completed however this approach is not always desirable for several reasons first a created request packet may not represent the most general request packet and thereby provide coverage of the code it secondly in our case the routines that create a request in the kernel and may not be invoked from the driver therefore a user of a tool is forced to write the environment assumptions as a nontrivial set of precondition constraints in the init block not shown here among the various preconditions the two requests to be disjoint is quite to express instead our tool is able to automatically rule out all warnings because and do not have any interleaved bugs an interesting fact about this example is that the false alarms manifest in both sequential orderings of threads as well as this observation motivated our definition of interleaved bugs given in § thread t thread t void void void test do do do init body async struct csl struct csl async csl csl if if put the write into a queue else put the read into a queue else figure simplified example from serial device driver the need for aliasing preconditions the reader might argue that we are only looking for traces that require an interleaving of actions from different threads however such a scheme will report numerous warnings for this example for instance the assertion in line can fail on many interleavings between the two threads eg this example may seem trivial from the perspective of concurrency analysis but that is because we have omitted the synchronization protocol that guards a request among different threads we use this example only to show the difficulty of understanding false alarms and writing preconditions to rule them out manually nondeterministic filters as noted earlier we find interleaved bugs using sequential interleavings as filters however the program that captures these interleavings may be nondeterministic ie it may have multiple behaviors for the same input state there are two main reasons for nondeterminism in the filter programs · data nondeterminism the concurrent program may have calls to external libraries that are modeled nondeterministically for example in order to model one would write a model or stub that returns any nondeterministically chosen time possibly in an increasing sequence the sequential program inherits these sources of nondeterminism · control nondeterminism as we illustrate in § the program representing the sequential interleavings may have a limited amount of nondeterminism in scheduling for example the filter used in § has to capture scheduling either of the two threads first one of the main technical challenges in this work is to deal with these nondeterministic filters therefore we start by considering the problem of comparing two nondeterministic programs in the next section § differential error checking in this section we study the more abstract problem of comparing two possibly nondeterministic programs with respect to a set of assertions in § we apply the results of this section towards finding interleaved bugs programs we consider a simplified syntax for imperative programs with concurrency we assume that there is a single global variable g of type t we leave t undefined we only require the presence of certain predicates over t let failed be a predicate of type t bool a program is a list of procedure declarations each procedure takes a single variable of type t as input returns a single variable of type t as output and has a single statement a program statement st has the syntax st st st if e st else st while e do st x e assume e assert e x call x return x async call sequence ifthenelse loop assignment assume assert nondeterministic assignment procedure call procedure return thread spawn one can encode programs with multiple global variables into our syntax by simply considering t to be a vector of types here e is an expression over variables in scope using some operators that we leave undefined semantics of our language is standard the x statement assigns a value to a variable x an assume e statement blocks in a state when e does not hold and has no effect otherwise an assert e statement fails in a state when e does not hold in which case the control jumps to the end of the program and the global variable g is modified such that holds there is no other way for to hold an async call statement a new thread that executes procedure foo with argument e even though we have defined a compact syntax we will still use syntax for easy writing of example programs we will sometimes write x in place of x nondeterminism in this language arises from two sources the statement induces data nondeterminism whereas concurrency via threads by async statements induces control nondeterminism for the rest of this section we do not distinguish between these two sources of nondeterminism we identify a program with the name of its main procedure at any point in a programs execution we refer to the value of variables in scope as the programs state in particular the input and output state of a program is the value of global variable g at beginning and end of the main procedure of the program respectively given a program p let fp be its inputoutput relation we say that s t fp if there is some execution of the program from input s that ends in a state t a program has a execution on input s if s t fp for some t and holds problem formulation in this section we describe the problem of differential error in more detail along with different algorithms to solve it we aim to solve over two programs that expect the same input also we assume that we are always given programs with assertions that capture the property of interest the problem can be formally defined as follows definition given two programs p and p p holds if there exists an input state s such that there is some execution of p starting at s that violates an assertion and no execution of p on s can violate an assertion we say that p acts as an for p note that is harder than standard verification let x y be a formula in a decidable fragment of logic say quantifierfree firstorder logic with equality then we can reduce the satisfiability check of y to the problem as follows construct two programs p and p with a global variable x and local variable y in p p y assert x y p assert false then p holds if and only if y is true thus even though verifying p and p is decidable p is not because checking the satisfiability of quantified firstorder logic with function symbols and equality is undecidable the next few describe a few algorithms for solving the problem in § we consider the case when the filter program is deterministic and terminating in § we consider a method for nondeterministic filter programs the method may not terminate for all programs both these approaches § and § use quantifierfree reasoning of theorem provers deterministic filters when the program p is deterministic ie given a fixed input it has exactly one execution and terminating ie given any input the program either terminates or fails an assertion in finite amount of time then we have an easy way of solving by reducing it to standard verification let be a program obtained from p by replacing all assert e statements with assume e statements consider the program p shown in fig that executes and p on the same input var g t program p var g g call g g call p figure a program p constructed from two programs p and p because we have replaced asserts by assumes in p the program will block on all inputs that cause p to fail consequently an execution of p on that input will not even reach the call to p thus p can only fail on some input i provided p does not fail on i and p fails on i which exactly solves theorem for a deterministic program p the following statements are true a if the program p in fig fails on some input then p holds and b if p is also terminating and p does not fail any assertion then p does not hold this theorem states that checking can be reduced to checking assertions in a program and we can standard verification techniques note that the requirement that p is deterministic and terminating is important for this theorem as the next example shows consider the example in fig p and p are two programs that take a pointer p as input the final assert in foo can fail because the programmer made a the operation in the else branch should be not addition we assume that both programs have implicit assertions for pointer dereferences ie there is an assert p null before any statement that dereferences p the intention is to find a bug in p that reveals that the assertion in the last line can fail static analysis of p can get and report that the initial dereference px can fail when p null however solving p correctly us to the desired bug p will filter out the input p null because it can fail on that input note that thm doesnt apply for this example because p is nondeterministic if we were to construct the program p as in fig then p can still fail on input p null a similar argument holds when p is nonterminating for example consider a program p with a single statement assume false this program never fails and should not filter any input for p however for the program p of fig it will block all input from reaching p nondeterministic filters we now describe a technique for solving p that can handle nondeterministic filter programs however the technique may fail to terminate on all programs even when both p and p are programs first note that the construction of fig is useful even when the filter program p is not deterministic but terminating because then p necessarily fails less often than p more specifically p does not fail on those inputs on which p fails ie every execution of p fails hence we can always replace p by p p p struct st p struct st p void bar int t t px void foo int x px px t py px else t px py figure a nondeterministic filter program algorithm algorithm for solving require programs p and p loop r if r then return end if let i r r i if r then return r end if let i r true p assume ¬ p end loop our algorithm is shown in alg it uses a tool which we call we assume that given a program with assertions either returns meaning that the program has no bugs or returns i meaning that the program can fail on input i and t is the execution trace that failure a trace consists of a sequence of program statements in the order in which they executed along with values of variables at each point in the trace can also be supplied with an input in which case it only checks the program under that input alg returns its output in the same format as it returns if there is no input for which p holds or returns i such that p holds and t is an execution of p that fails on input i but p does not fail on input i the algorithm works by iteratively away more and more inputs if it finds a bug in p line then it checks to see if p has a bug on the same input i line if p doesnt then it returns this input line if p does have a bug then i needs to be for this it uses a modification of the trace t itself to create a deterministic filter f line that filters out i as well as other inputs that cause p to fail along the trace t in some sense f acts as a that filters out some of the input that causes p to fail the procedure takes a trace t and performs the following modification to it it replaces the x statements with x c where c is the concrete value assigned to x in the trace the predicate transformer takes a trace t a sequence of statements and a formula and returns a formula representing the path condition in terms of the inputs to the trace it is defined inductively on the structure of the trace as follows note that removes statements from the trace ¬ e ex t fig a shows an example of a trace that fails the assertion in p in fig for the statement t we indicate the value say assigned to t in the trace fig b shows the formula constructed in line which is equivalent to p null t assume t assert p null a p null b figure a a trace through p from fig and b the corresponding formula the most expensive parts in alg s loop are the calls to one can optimize these calls in cases when is incremental for instance the calls on line always contains the same program with an increasing list of assume statements the calls on line are to the same program but with different inputs thus any information that infers about p or p can be across iterations theorem the following statements are true a if alg returns then p does not hold and b if alg returns i then p holds and input i and trace t are the witnesses alg is not guaranteed to terminate even for programs which is expected because is undecidable in general however it does terminate for programs with bounded nondeterminism formally nondeterminism in a program is bounded if for any nondeterministic choice value v in the program v only appears in expressions of the form v c where and c is a constant this subsumes the case when v is boolean ie v true false we did not come across unbounded nondeterminism in our experiments consider the example in fig where the is a procedure with complex operations to compute the hash value of an input it is not hard to see that p does not hold for this example however alg will diverge by all the possible values of the nondeterministic choice of i in p the variable j in p is not necessary for the divergence there are several ways to extend our approach to deal with such cases at the cost of a natural extension is to set a bound k on the number of times a source of nondeterministic values in during the execution of alg after this threshold is we perform pre on the trace t directly instead of it we extend pre for statements x x this results in quantified filters in line of alg for the above example with k we will generate the filter j j if is able to reason about such quantifiers then we will be able to prove that p does not hold for this example however if is unable to reason precisely about these quantifiers then alg may diverge the same path in p for example if is an theorem prover the quantified verification condition generated may not be void a int b int i void a int b int j int i if j assert ai assert ai figure example where alg diverges amenable to the schemes for instantiating quantifiers in most smt solvers there is no good trigger for the bound variable j in the formula above this is the reason why j is present in p the above formula would need some simplifications eg quantifier elimination in conjunction with quantifier instantiations we also present a variant of this idea in appendix a that instead produces a quantified formula to precisely describe whether p holds for bounded programs and then it off to a theorem prover the main difference is that it pushes the divergence from within alg to within the theorem prover interleaved bugs we now return to the topic of finding interleaved bugs for concurrent programs in the presence of we start by defining the problem formally show how it can be cast as a problem and then describe a few optimizations specific to our setting let p be a concurrent program with dynamic thread creation using async statements we define a program execution to be one that has a of execution formally a execution while executing thread t follows one of two possibilities at an async statement that thread t · t for t the thread t executes immediately and t until t and any thread by t completes additionally while t is executing any async call must follow this same option in some sense the async call acts like a synchronous procedure call · t for t the thread t does not execute until t when t any of the threads by it can start executing let be a subset of fp such that s t if and only if s t fp and there is some execution of p from input s that ends in state t our intuition is that assertion violations resulting from illegal inputs will often manifest in executions thus they will be captured in definition interleaved bug a program p has an interleaved bug if there is a pair of states s t fp such that holds and for all s t does not hold we find interleaved bugs using theorem given two concurrent programs p and q the following statements are true i if fq and p does not hold then p has no interleaved bugs ii if fq and p holds then p has an interleaved bug thm suggests that it suffices to work with bugs and of inter bugs in § and § we define filters as programs in § we define the program that captures pre in each case we define the filter using a syntactic program transformation and the filter is a sequential program void new args let fe fe figure entry procedure for and filter the filter program always chooses the behavior where the async statement is treated as a synchronous procedure call that executes immediately this corresponds to the first option in the definition of executions the use of this filter is desirable as it can lead to a deterministic filter if the program does not make use of data nondeterminism or the nondeterminism does not influence the assertions this filter can be obtained from p simply by replacing all async calls with normal procedure calls the program shown in fig uses this filter to remove all bugs filter the filter program all behaviors in which threads are delayed until the parent thread this corresponds to the second option in the definition of executions we capture this filter as an program note that an async call in this case is like an event that has to be processed when the current event this behavior is typical of programs let main be the entry procedure of p let be a multiset of events where each event is a function pointer along with its arguments the filter has the entry procedure shown in fig it the set of events with the main procedure and then executes an arbitrary event from in a loop events are added to the set by executing a async statement the following transformation is applied to each async statement async e it is easy to see that a thread does not execute until the parent thread there are several existing analyses of programs the work by and discusses the complexity of analyzing such programs jhala and majumdar present a approach and et al present an analysis a realworld example where this filter is required is described in § in our experiments we use a tool based on the approach of et al remark when the concurrent program p has synchronization eg thread join operations then it is possible that may deadlock this is acceptable in our setting because we do not consider deadlocks to be bugs filter the filter program all executions such a program can have strictly more behaviors than both previous put together this is because it allows an execution to follow the first option in the definition of executions in some places and to follow the second option in other places out int x if x allocate device return else if x fail return else if x fail return else figure stub for let main be the entry procedure of p let be as defined in § the filter has the same entry procedure as the difference is in the transformation of async statements we add a boolean variable first to initialize it to false and then carry out the following transformation async else first true first false else e the variable first is true when we have decided to execute a thread immediately in this case any recursively thread must also be executed immediately when first is false we nondeterministically decide between two execute the thread immediately or delay it until the current thread nondeterminism the filters defined in previous sections have multiple sources of nondeterminism which our interest in nondeterministic filters the main source of nondeterminism is from the environment as for any static analysis tool one has to close the program by writing for the environment such as the operation system these the environment and are inherently nondeterministic for instance in order to model system call in windows we used the stub shown in fig it can nondeterministically choose to allocate the device object or fail and return one of a fixed number of error codes these were created for an earlier study on static analysis we did not modify them another source of nondeterminism is in modeling the filters themselves both and have nondeterminism in the order in which they pick events the filter does not add any extra nondeterminism the stub in fig and the filter structure both induce a bounded amount of nondeterminism which is suitable for our int x void p x async foo async void foo x x void p l x l p else l p figure example to show incompleteness of the optimization lazy algorithm § however some have for instance the stub that we use for malloc is one that can return any address which has not been previously allocated however such has never been a problem in our experiments one reason could be that programs and consequently bugs do not rely on the actual address values optimizations for the purpose of finding interleaved bugs we have a special instance of p namely one in which fp fp in this setting we can optimize alg by avoiding a few calls to more concretely let t i be as defined on line of alg then t is a concurrent execution possibly with many threads we can statements in t such that the resulting trace to the filter in use and then check the feasibility of the resulting trace for example let t have two threads t and t and consists of statements executed in the following order t a a a b b a a b b a where the refer to statements by t and the refer to statements by t further let a be the statement that thread t let t and t be the following permutations of statements in t t a a a b b b b a a a t a a a a a a b b b b then t to t to and both to suppose we are using as the filter and t happens to be feasible on input i ie i satisfies true then we can let r be i and jump to line thereby avoiding the call to on line in general there are many ways to a given concurrent trace to make it correspond to a filter in our implementation we try a few permutations if any of these work then we can avoid a call to note that this optimization does not work the other way consider the example shown in fig where every dereference is implicitly protected by a assertion it has an execution that fails on line l that requires four context switches and no sequential permutation of this execution is feasible however we cannot conclude that the execution is an interleaved bug because there is a sequential execution on the same input but takes a different path due to the nondeterminism at l that fails at label l evaluation we implemented alg mentioned in § on concurrent programs in a tool called it first uses the filter if it does not find bugs in the presence of this filter then it stops otherwise it uses the filter and reports resulting bugs as interleaved bugs the use of is an optimization because it is easier to analyze than uses as the tool for finding bugs in concurrent programs ie acts as in alg is one of the tools for concurrent programs that uses iterative to look for bugs we experiments to evaluate on two goals first can rule out bugs caused by illegal input while the true bugs second we compare against a different strategy namely one that filters based on asserts in this strategy if a sequential trace leads to an assertion violation then we remove that assertion and repeat until no more warnings are produced results we chose a collection of windows device drivers from the suite for experiments some of these drivers were manually with bugs by others in an independent study to the best of our knowledge these are the only bugs present in the code we suffix the driver name with bug when it has a single bug this allows us to a controlled study none of the drivers have a precise we checked the property mentioned in § as well as for dereferences the results are reported in fig each row of this table has the name of the driver name the number of nonempty lines of code by tool loc along with the number of assertions shown in the property being checked prop and the type of bug present in the code either none or interleaved or sequential the next column lf is the number of iterations of alg ie the number of lazy filters generated by the rest of the columns show the number of false positives fp and false fn of the two approaches and the total time taken to generate all the warnings the manual effort of a as a true or false positive whenever used for generating a lazy filter we mention it in the lf column with ag for instance the first row is for the driver with the property the driver does not have any actual bugs however when we run static analysis it reports a false positive because of the on the other hand this automatically it generates one lazy filter our experiments show does not report any false positives whereas the assert technique reported false positives did not miss any of the interleaved bugs whereas assert one in bug the use of is a useful optimization and is enough to rule out false warnings in most cases as expected also ends up true sequential bugs however it demonstrates good results for concurrency bugs we now explain some of the results in more detail to illustrate the need for and the kinds of preconditions that these drivers required property on the existing for the device driver for the property added two preconditions a particular lock must be initialized and a doublylinked list of requests is empty although the first is a valid precondition the second one is the simplest way to establish the actual preconditions a the incoming request does not belong to the list and b the list is wellformed linked list that respects the relationships between the forward and the backwards links unless the latter is enforced the pointer performed to insert or delete an element of the list does not have the desired effects both these preconditions are very hard to express for lowlevel c programs even for bounded lists void void void true void async async figure example of checking on driver every dereference of a pointer has an implicit nonnull check preceding it however by limiting the input to contain an empty list most of the interesting logic related to list traversal in the code does not get there are three versions of this driver depending on which dispatch routine is chosen read write or in the absence of preconditions we get false alarms in each of the three versions whereas does not report any false alarms for read requires the use of filter with alone it reports a false where the input list is not wellformed this example shows that in the presence of complicated preconditions one needs although at the of more runtime checking we also checked several drivers for the absence of each pointer dereference was with a nonnull assertion as shown in fig this property introduced a large number of assertions in the program fig shows an example motivated by that requires the filter to remove the false alarms the test needs the preconditions that both and are nonnull to ensure that the concurrent program does not fail any assertions it is easy to observe that the illegal inputs where is null fails by executing sequentially and is thus away by consider the nonnull check for the dereference if we restrict the executions of test to only consider the is only when either or is set in the input this implies that using the filter will generate failure traces where the body of is executed before the test on inside however using the filter we can defer to execute after has executed thereby failing the assertion on any input a similar situation requires the use of for the example in § related work in this paper we presented an approach for reducing false alarms due to environments during static assertion checking in concurrent programs by using the sequential behaviors as an oracle we position our work in the context of previous work in each of the areas in the next few static analysis alarms et al propose a method of discovering bugs by observing inconsistent behavior in source code et al provide a semantic basis for finding such inconsistent behaviors by the problem as a problem both these approaches have been applied to find null dereference errors in large sequential name bug bug bug bug bug read write bug bug read read loc asserts prop no seq int seq seq int no no no seq int no no no no no lf ag ag fp fn time assert fp fn time figure results obtained from running on windows device drivers times are in seconds these work can also be seen as false alarms if usage is consistent with some unknown protocol eg if all dereferences of a variable x is not protected by a the accesses to the variable is most likely safe due to some invariant in the program one can think of interleaved bugs as discovering with respect to a given set of assertions where the sequential behaviors describe an implicit protocol on the other hand unlike these approaches we do not require a separate analysis for different patterns and provide a formal guarantee of relative correctness if there are no interleaved bugs approaches for or ranking warnings have ranged from statistical techniques such as to more domain specific methods such as warnings although these approaches are applied to the results of static analyses that scale to large modules they do not provide any formal guarantees of the bugs that are besides most of these approaches are at the of static analysis as opposed to the environment problem sequential filters the idea of using sequential behaviors as oracle for concurrent implementations has been studied in the context of checking linearizability which provides a natural specification in many settings for checking concurrent programs various static and dynamic tools have been built to check concurrent behaviors against sequential ones is a dynamic analysis tool that flags a concurrent behavior when it outputs a value that no sequential execution produced et al provide runtime techniques to check parallel implementations against nondeterministic sequential specifications et al employ symbolic execution along with enumeration of interleavings to check against the sequential behaviors for numerical programs unlike these approaches we consider the dual problem when specifications are present in the program but the environment is because we check for assertions we can apply the technique to any concurrent program even if it is not linearizable environment synthesis generating environments for model checking of open systems is a problem et al generate environment models from assumptions and by analyzing environment implementations et al address the problem of synthesizing the most environment using a combination of predicate abstraction and automata learning one can view our approach as inferring the most environment that does not induce failures on sequential executions and using it to check the concurrent program as demonstrated in § inferring legal environment preconditions may involve inferring complex aliasing relationships on the input data that may not be amenable to finitestate approaches nonetheless it would be interesting to combine synthesis techniques with our algorithm conclusion in this paper we the problem of false alarms in static analysis due to missing environment assumptions and present a solution when checking assertions in concurrent programs we define a class of warnings as interleaved bugs when they are by a filter that attributes all warnings in the sequential interleavings to the or to missing preconditions we believe this can be an effective way to high quality warnings when looking at warnings generated by a static analyzer for concurrent programs our preliminary experience with a simple implementation to find interleaved bugs is although we expect more work to deal with unbounded nondeterminism in the filter programs more generally the paper makes one of the first contributions to the area of using semantic techniques for alarms from static analysis sequential filters are natural filters when alarms for concurrency analysis we believe that one can extend this idea to use other than sequential executions in the source code to automatically define filter programs for other domains as well acknowledgments we thank ball rajamani and the anonymous reviewers for their feedback on an earlier draft we thank for pointing us to with work on using sequential executions as for concurrent modules finally we thank and qadeer who many of the concurrent for the device drivers which as a starting point for our experiments references r p p and w synthesis of interface specifications for java classes in principles of programming languages popl pages ­ m and k r m leino of programs in program analysis for software tools and engineering pages ­ e e and y the classical decision problem springerverlag s c m and r a complete and automatic linearizability checker in programming language design and implementation pldi pages ­ j t g c necula and k runtime checking for nondeterministic sequential specifications of parallel correctness in programming language design and implementation pldi pages ­ l and b fischer verifying multithreaded software using model checking in international conference on software engineering pages ­ d g nelson and j b simplify a theorem prover for program checking j acm ­ e w dijkstra guarded commands and formal derivation of programs communications of the acm ­ i t and a aiken static error detection using semantic inconsistency inference in programming language design and implementation pldi pages ­ m s qadeer and z scheduling in principles of programming languages pages ­ d r d y chen and a bugs as inconsistent behavior a general approach to inferring errors in systems code in symposium on operating systems principles pages ­ m and j m linearizability a correctness condition for concurrent objects acm trans program lang syst ­ r jhala and r majumdar interprocedural analysis of asynchronous programs in principles of programming languages pages ­ t and d r using statistical analysis to counter the impact of static analysis approximations in static analysis symposium sas lncs pages ­ s s qadeer and z static and precise detection of concurrency errors in systems code using smt solvers in computer aided verification k r m leino t d and j b generating error traces from counterexamples sci comput program ­ the concurrency k and m model checking multithreaded programs with asynchronous atomic methods in computer aided verification pages ­ s f a g s and l a clarke using model checking with symbolic execution to verify parallel numerical programs in international symposium on software testing and analysis pages ­ o m b and c s automated environment generation for software model checking in automated software engineering pages ­ j w r jhala and s static race detection on of lines of code in symposium on foundations of software engineering pages ­ microsoft windows driver a quantified vc generation in this section we describe a method for generating a quantified verification condition for programs in the presence of nondeterministic and possibly nonterminating filter programs recall that the goal of p is to filter any input i such that there is some choice of the nondeterministic values in p that fails p this implies that the nondeterminism in p is angelic in contrast to the nondeterminism in p one option is to extend our language in § to introduce a statement choose x in addition to x to model the angelic nondeterminism and then create a program similar to one described in fig where we replace the x statements in p with choose x statements in addition to the transformation of the assert e statements however we are not aware of any efficient verification condition vc generation algorithm in the presence of such nondeterminism let us one of the main difficulties of extending vc generation algorithms with choose statements most efficient vc generation algorithms see generate a formula whose size is at most quadratic in the size of the program this is achieved by using a variant of static single assignment where auxiliary variables are introduced to hold different of a program variable after an assignment a statement or at merge points these variables are implicitly universally quantified in the vc when checking for validity the presence of choose statements introduces an existential quantifier eg x x whereas x x where refers to weakest precondition predicate transformer this with the use of auxiliary variables in the vc as determining quantification vs of a particular variable and the nesting can be challenging instead we present in alg a vc generation mechanism for that vc generation along with symbolic execution along error paths to add the quantifier alternation the idea is simple we enumerate all the program paths in p that lead to an assertion violation and create an expression purely in terms of the inputs to p that characterizes all the conditions under which p fails we generate a vc for p using any vc generation technique after blocking all these inputs the formula represents the set of inputs for which there is a choice of the nondeterministic values such that an assertion in p fails similarly the set a represents a set of paths in p that lead to an assertion violation these variables are initialized to false and respectively line and line the loop from line to line different paths in p that fail an assertion we use an oracle in line that takes as arguments i a program and a ii set of paths and finds an error trace that avoids the set of paths specified or indicating that there are no bugs can be implemented by vc generation to avoid a set of paths while checking assertions once all the error paths have been explored the algorithm computes the vc for p after blocking all the inputs in using assume ¬ line otherwise for a given error r we extract the error trace t and the input i and update a and line and line the predicate transformer is extended for statements x x observe that true is a formula whose free variables are inputs to p and can be to a formula of the form x xk where is a ground formula after renaming the bound variables introduced due to to avoid variable capture algorithm algorithm for generating a vc for require programs p and p ensure a formula representing the vc for p false a loop r a if r then return ¬ end if let i r a a t true end loop theorem a given programs p and p if be the formula returned by alg then p holds if and only if is satisfiable it is interesting to note that the theorem above holds even when the filter program p does not terminate on some inputs this is because we only enumerate paths in p that lead to an assertion violation for instance if we consider the nonterminating example from § where p was simply assume false then we will not find any bugs in p and alg will simply return the vc of p consider the example in fig where the is a procedure with complex operations to compute the hash value of an input it is not hard to see that p does not hold for this example however alg will diverge by all the possible values of the nondeterministic choice of i in p instead alg generates the following precondition to p by capturing all the inputs that fail p j j which is equivalent to i ai and sufficient to prove the assertion in p for any implementation of although the algorithm presented here generates a precise vc for the problem the undecidable nature of the problem any algorithm to solve all instances of the problem the algorithm presented here may not be complete due to the incompleteness of automatic theorem provers to deal with quantifiers in the resulting vc for example the quantified vc generated may not be amenable to the schemes for instantiating quantifiers in most smt solvers there is no good trigger for the bound variable j above the above formula would need some simplifications eg quantifier elimination in conjunction with quantifier instantiations nevertheless by translating the p to a logical formula we can hope to advances in automated theorem provers to obtain more precise and efficient solution for p 