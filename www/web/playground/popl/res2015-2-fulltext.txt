well easy to complete popl consist integrating dependent and linear types r university of benton microsoft research abstract in this paper we show how to integrate linear types with type dependency by extending the calculus of benton to support type dependency next we give an application of this calculus by giving a account of imperative programming which requires extending the calculus with computationally irrelevant quantification proof and a monad of computations we show the soundness of our theory by giving a realizability model in the style of which permits us to validate not only the laws for each type but also the laws these extensions permit us to decompose hoare triples into a collection of simpler typetheoretic connectives yielding a rich equational theory for higherorder imperative programs furthermore both the type theory and its model are relatively simple even when all of the extensions are considered keywords linear types dependent types intersection types proof separation logic hoare triples introduction two of the most research directions in language design are logic and dependent type theory logics like linear logic and separation logic offer finegrained control over the structural rules of logic ie contraction and weakening which means types control not only how a value of a given type is used but also how often it is used this permits giving a logical account of the notion of resource and has been useful in giving modular and accurate specifications to stateful and imperative programs on the other hand dependent type theory extends simple type theory by terms to occur in types the expression of concepts like equality in types this enables giving types which give a very finegrained specification of the functional behaviour of their we would like to fully integrate dependent and linear type theory linear type theory would permit us to extend the correspondence to for example permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page for components of this work owned by others than the authors must be abstracting with credit is permitted to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission andor a fee request permissions from popl january ­ copyright is held by the publication to acm acm programs and type dependency permits giving very precise types to describe the precise functional behavior of those programs the primary difficulty we face is precisely the interaction between type dependency and the structural rules since linear types ensure a variable occurs only once in a program and dependent types permit variables to occur in both types and terms how should we count occurrences of variables in types the key observation our approach is that we do not have to answer this question we build on the work of benton which formulated models of intuitionistic linear logic in terms of a monoidal f g between a monoidal closed category l and a cartesian closed category c the exponential a then as the composition of the syntactically such a model then corresponds to a pair of lambda calculi one intuitionistic and one linear which are related by a pair of modal operators f and g in the calculus we no longer have to view the intuitionistic function space p q through the lens of the girard encoding p q instead the intuitionistic arrow is a connective in its own right independent of the linear function space given such a separation we can make the intuitionistic part of the language dependent changing the type x y to the x x y without the linear function space a b we then end up with a type theory in which linear types may depend on intuitionistic terms in quite sophisticated ways but we never have to form a type dependent on an open linear term as an illustration recall classic motivating example of the resource reading of linear logic in which the proposition a represents a b represents obtaining a pack of and c obtaining a pack of the formula a bc then expresses that one may a and receive the option of a pack of and of a pack of but only of these may be in from that assumption one can type for example a machine m that takes n and produces its choice of something you can m n n tuple n a fm n m n p m m n tuple m b tuple m c where tuple n a is the definable linear tensor · · a the return type of the linear function space in the type of m is a linear dependent pair which generalizes f modality for mapping intuitionistic values into linear ones so m yields two integers m and m a proof that their sum is n and an of bs together with an m tuple of cs contributions in this paper we make the following contributions · first we describe a core type theory that both linearity and full type dependency by ex ok ok x type · ok x x ok ok · ok ok a linear a a ok x type a linear x ui x type a li a linear x y type a b linear x y ui x y type a b li a b linear figure structural judgements ui ui li ui x ui x x y ui x x y ui x ui x x y ui x x y ui ui a li g a ui x ui e x e x e x e ui i li a li b li a b li a li a b li b li x ui x x a li x x a li x ui x x a li fx x a li li a li b li a b li figure type wellformedness the calculus our type theory is an extensional type theory which means that we consider the full theory of the language and furthermore it also has a universe hierarchy meaning that we support dependent types including large ie computing types from terms our approach to linear dependent type theory gives a simple explanation of how the adhoc restrictions on the interaction of linearity in earlier approaches such as linear lf arise by showing how they can be modelled in · second we show how to turn this calculus into a language for imperative programming in the style of separation logic the general idea is to combine linearity and type dependency to turn style specifications into types and to take imperative programs to be of those types ensuring that programs have the appropriate operational behavior requires a number of extensions to the type system including pointer types implicit quantification in the style of intersection and union types and proof for linear types · once this is done we not only have a very expressive type system for higherorder imperative programs but we also can systematically give a natural equational theory for them via the theory for each of the type constructors we use · next we give a realizability model in the style of to show the consistency of our calculus our model is very simple and easy to work with but nevertheless simply and the wide variety of the extensions we consider · finally we give a small implementation of our extended type theory that it is possible to implement all of these constructions core dependent linear type theory in this section we describe the core dependent calculus the full grammar of terms and types is given later in figure but here we present the calculus rule by rule x x x x e y x y type ex e x e e e x x y e x x y e x e x x y e x x y type x x e y x e x x y e x x y e x e e e xy ee x refl e x e · e a ge ga figure intuitionistic typing the basic structural judgements are given in figure the judgement ok is the judgement that a context of intuitionistic hypotheses is wellformed as is standard a wellformed context is either empty or a context x x where is wellformed and x is an intuitionistic type wellformed in the judgement ok says that is a wellformed linear context whose linear types may depend only upon the intuitionistic variables in the judgements x type and a linear when a term is an intuitionistic or linear type respectively the equality judgements x y type and a b linear determine whether two intuitionistic or linear types are equal respectively both x type and a linear work by immediately to an ordinary typing judgement for an intuitionistic universe ui and a linear universe li the type wellformedness rules are given in figure and the introduction and elimination rules are given in figure with the judgement e x both linear and intuitionistic li and ui are elements of the larger universe ui note that li is an element of ui this is because a linear type is an intuitionistic term since we do not wish to restrict how often type variables ranging over linear types can occur that is we want polymorphic types like li to be wellformed a a a a e b a b linear e a · i e i e c let e in e c e a e b e e a b e a b a a b b e c let a b e in e c a a e b a e a b e a b e a e e b x x e a x e x x a e x x a e x e e e xa e a e a e e a a e ab e a e ab e b e x t f e t fx x a e fx x a x x a a e c let f x a e in e c e ga · g e a figure linear typing the intuitionistic types we consider are the dependent function space x x y with a and function application as its introduction and elimination rules the dependent pair x x y with pairing e e as its introduction and the or strong e and e the unit type and the equality type e x e equality is introduced with refl but has no explicit elimination form since we are giving an extensional type theory with equality reflection these rules are all standard for dependent type theory similarly it is possible to add inductive types such as natural numbers to the calculus including support for large though we omit them from the rules in the paper for space reasons rules and proofs are in the companion tech report the first place that linearity arises is with the the adjoint embedding of linear types into intuitionistic types g a its intuitionistic introduction rule is g e which checks that e has linear type a in the empty linear context intuitively this reflects the fact that closed linear terms can be freely duplicated it is worth noting that our intuitionistic types are also essentially the same types as are found in the calculus only we have changed x y to a and x × y to a the typing judgement e a for linear terms says that e has type a assuming intuitionistic variables and linear variables the wellformedness and typing rules for the connectives i are all standard the elimination form of the type g a is g e which yields an a in an empty linear context which is the same as in benton ee x t t a p e x e ee x x e e e xe x e x e x x x y e e e x e e e x e e e x x y ee g g e e g a · g g t t a x e e e xe c e x e x a b x e e e xe c e x e x x x a e e e e e a e e e b e e e a b let in e e c let t in xt c let a b t t in t ta c let a b t in a b xt c let f x a f e t in t ex c let f x a t in f x a yt c figure equality we from propositional when we reach the dependent version of the other adjoint connective instead of a unary modal connective fx we introduce the linear dependent pair type fx x ax its introduction form f e t consists of a pair consisting of an intuitionistic term e of type x and a linear term t of type ae observe the type of the linear term may depend on the intuitionistic first component however just as in the calculus this pair has a pattern matching let f x a e in e also we add a dependent linear function space x x a which is a function which takes an intuitionistic argument and returns a linear result whose type may depend on the argument we add this for essentially reasons it gives us syntax for the equivalence fx x a c x x a c the equality theory of our language is given in figure this gives the and rules for each of the connectives including conversions for all of the positive connectives ie i and f we also include the equality reflection rule of extensional type theory for space reasons we do not include any of the congruence rules or the equivalence relation axioms they are given in the technical report loc ui e loc x ui e x li a li t a li a li a li x ui x x y ui x x y ui x ui x x y li x x y li x ui x x y ui x x y ui x ui x x y li x x y li i ui figure wellformedness of extensions x x e y x fve e x x y e x x y e x e e xy x x y y e z x fve y x x y e z x x y type e x e e xy e x x y x x e a x fve e x x a e x x a e x e e xa x x a a e c x fve a x x a e c x x y linear e x e e xy e x x y n n x xn yn type f i x x e y n n f x xn yn x e n f x e fix f x e n n x xn yn figure intersection and union types internal imperative programming there have been a number of very successful applications of dependent type theory to verify imperative programs using dependent types such as xcap and the verified software these approaches all have the common feature that they are external for imperative programming that is within the of dependent type theory an imperative language such as c or assembly and its semantics is defined and a program logic for that language is specified and proved correct so the type theory remains pure and imperative programs are therefore objects of study rather than programs of the type theory we would like to investigate an internal proofs as programs methodology for imperative programming where we write functional programs which a have effects but b nonetheless are of the appropriate types pointers computations and proof in order to program with mutable state we need types to describe both state and computation that manipulate it to do this we will follow the pattern of l and introduce a type of locations and a type of reference capabilities e loc t e x x x a e x t c let x a t in t c e a val e t a e t a a a e t c let val a e in e t c ex · e t fx loc x x e loc t e x free e t t i e loc t e x e y e t e t e y a e a e a x a e ÷ c let x e in e ÷ c e i e c let e in e c e a b a a b b e c let a b e in e c figure typing of imperative programs x x e e y e e x x y e e x x y t x e e e e t x e e x x y x x y y e e z x fve e z y x x y e e z let val x val t in t t c let val x t in val x t t c let val y let val x t in t in t t c let val x t in let val y t in t e e a x x e e a e e x x y e e x x a t x e e e e t x e e x x a x x a a e e c x fve e c a x x a e e c fix f x e e fix f x ef e xe z figure imperative equality the type loc is an intuitionistic type of locations this is a type of addresses which may be freely duplicated and stored in data structures testing locations for equality is a pure computation and for simplicity we do not consider address arithmetic however merely having a location is not sufficient to dereference it since a priori we do not know if that location points to allocated memory the right to access a pointer is encoded in the capability type e x this says that the location e holds a value of type x this differs slightly from separation logic whose pointsto assertion e v says that e points to the specific value v however since we have dependent types at our we can easily recover the separation logic assertion with the encoding e v e x x x v at this point much of the power of separation logic is already available to us as soon as we have locations and pointer capabilities we can use the tensor product p q just like the separating conjunction p q next we introduce a type t a of computations that is if a is a linear type then t a is a computation type which produces a result of type a note that t a is itself a linear type intuitively executing a computation modifies the current state so that it becomes a of type a the reason we treat computations is because allocation and deallocation of memory violates linearity for example if we typed allocation as fx loc x x the pointsto assertion is created from nothing since one of our design goals is precisely to keep the semantics see section as naive as possible we introduce a linear computation type with the features we have introduced so far a stateful computation e might be given the type g p t q representing a term which takes a of type p and computes a result of type q while this is adequate from a point of view it is not quite right computationally in our approach we encode reasoning about state using linear types so that we can read the type p p as saying that the state p implies the state p however a proof f of this entailment is a linear lambda term and evaluating it does computation so if we the proof f with the computation e then we get a result which does different computation than e did originally this is quite different from the way that the rule of consequence works in hoare logic to solve this problem we introduce a form of linear proof into our language the type a is a type which all of the data about a we are left with only knowledge of its our type system has a rule saying that is an of a if we can find evidence for it using the monadic judgement e ÷ a this judgement lets us turn any derivation of a as evidence of and lets us use evidence of as long as we in the judgement we also give a pair of rules to through tensor products and units it is relatively easy to show that any formula in the logic of implications which does not the ordinary implication p q and the magic wand p q has a corresponding proof in linear logic since interleaving the additive and multiplicative implications is the only way to create contexts however the magic wand is used in practice though see the isomorphism a × b a × b is derivable but the proof relies on the fact that pairing has first and second projections with the linear tensor product this isomorphism has to be built into the syntax so we can type computations as g p t fx x q representing computations that take p to while returning values of type x we can now describe the typing rules for computations in figure given a location and a capability to access it we can now type a dereference operation dereferencing let x a t in t in figure takes a location e and a capability t and then binds the contents to x and the returned capability in the variable a before evaluating the body t the dereference operation is a pure linear term ie has a type since it reads but does not modify the state the other stateful operations are monadic allocation e is a computation which returns a pair of location and an irrelevant capability to access that location deallocation free e e takes a location and the capability to access it and then the memory returning a computation of unit type update e t e takes a location and a capability to access it and then updates the location returning a new capability to access it since capabilities are linear we are able to support strong update ­ assignment can change the type of a pointer we also include standard monadic rules for returning pure values and sequencing computations as a simple example consider the following term let val f x c in let val f y c false in let n c c in let val c y c n in val f x c f y c on the first two lines this function allocates two pointers x pointing to and y pointing to false with access capabilities c and c on line it dereferences x binding the result to n furthermore the linear capability c is taken by the dereference operation and returned as the capability c on line y is updated to point to n again taking in the capability c and returning the capability c this is a strong update changing the type of y so that it points to a natural number then we return both pointers and their access capabilities on line with an overall type of t fx loc x n fy loc y n one point worth is that our computation monad is a strong monad which is in some sense the essence of the frame rule of separation logic the of the map a t b t a b means that a computation of b that doesnt use the state a can fold it in to produce a computation of a b another point worth is that our system only treats reading pointers as a pure linear action one might expect writes could also be viewed as pure since linearity ensures that there is at most one capability to modify a location unfortunately this idea is incompatible with a term and terms which could modify the heap would be unsound intersection types and implicit quantification at this point we are close to being able to formulate specifications of imperative programs in an internal way however one feature of program logics is support of logical variables these are variables which occur only in specifications but which do not affect the evaluation of a program fortunately these have also been studied extensively in lambdacalculus under a different name intersection types we introduce the two type x x y and x x y and their linear counterparts corresponding to an intersection and union respectively a term e is an of x x y if it is an of y for all x and e x x y if there is some v x such that e the precise rules are given in figure ­ the key constraint is that even though a new hypothesis becomes available in the context it cannot occur in the term this ensures that it cannot affect evaluation even though it can appear in typing the classical intersection type a b can be encoded using large elimination as b a b and the union type a b is b a b now we can introduce logical variables into our specifications ie types by simple quantification x x g p t fy y q the variable x can now range over both the pre and the postconditions without being able to affect the computation fixed points finally we make use of intersection types to introduce a recursive function form fix f x e see figure this function is the type n n x xn yn when assuming f has the type x xn yn and x has the type then the body has the type and we can show that the body has the type y when the argument has type x in the base case we also assume that f has a top type which cannot be used to prevent recursive calls this permits us to define recursive functions if we can supply a decreasing termination metric as a argument this is useful because the inductive require a argument which we might not have examples with all of this machinery we can now define a simple linked list predicate for simplicity we leave the data out leaving only the link structure behind n × loc l l l inl l fl loc l inr l l this says that a list of length is a pointer to a null value and a list of length n is a pointer to a list of length n note that this predicate is in that a term of type l is a nested tuple including all the pointers in the linked list as a result we need to the predicate when giving specifications to programs we will also make use of the fact that quantifiers inside of a can be turned into quantifiers outside of a that is the axiom fx x a x x a is by the term x in particular this lets us turn into union types a b a b list length as a first example if we to define a length function for linked lists we would need to do it as len n n l loc l fm n pf m n l len l gc let c in let c c c in let v pf c c in inl f refl inr l let f m pf c g len l in f m refl the type of this function says that if we are given a list of length n then we can recursively traverse the linked list in order to get a number equal to n this turns out to be a very common pattern in specifications we use computations to between some logical fact about a piece of data ie the index n and computational data in this case the length m of the list obviously this function cannot be defined with an on n since the point is precisely to compute a relevant number equal to n and the data we receive is merely a pointer along with the right to traverse it worth noting is that the type completely almost all of the related to manipulating the predicate as a result it is obvious what the action is though why things work can get quite to figure out in this case on the first line we making use of the fact that given a list l we can get out an element of the union type p n l inl i k n n sk l loc l inr l l this is bound to c and then the body can be under both alternatives list append we can also write a typetheoretic version of list append one of the examples from the original paper on separation logic first lets write a function which changes the head pointer of a list n n l l loc gl inl l t l l l gc c let c c in let v c c in let val c l c v in let val free l c in val this function simply assigns the contents the list to the first argument pointer and then the head pointer of the second list as usual a small amount of is needed to split irrelevant arguments but otherwise the code is very similar to what one might write in ml or haskell append n n n l l loc l l t n l append l l gc c let c c in let v c c in inl let val c l l c c in val inr l let val c l l c c in val this to the end of a list and then the head of the second list to the tail of the first list then with some straightforward its possible to show that this gives us a linked list of the appropriate shape which is in the val terms the fact that we return only a argument corresponds to the fact that this is an algorithm which modifies the state and returns only some linear knowledge about the new state data abstraction because we can quantify over types our calculus also supports data abstraction in the style of et al as an example we can use our linked list to implement a stack as an abstract type first we define a function to grow a linked list by one element grow l loc n n n t n grow l gc let c c in let v c c in inl let val l c new inl in let val c l c inr l in val inr l let val c l c in val this iterates to the end of the list and then adds one element to the tail in order to preserve the identity of the list similarly we can a list by an element as well l loc n n n l gc let c c in let l c c in let val c l c inl in l l c c t n this an element of the list using the function to ensure that the head pointer remains unchanged now we can give a procedure to build a stack as an abstract type make stack n li push n n g stack n t pop n n g t stack n stack make val f l c new in val f n l f grow l f l c this procedure allocates a new location initialized to and then returns the grow and operations at the types for push and pop importantly the representation of the stack is completely hidden there is no way to know a pointer represents the stack one particularly interesting feature of this specification is that the choice of representation invariant is our definition of the stack predicate captures the actual location allocated as a free variable equational theory so far we have decomposed the hoare triple p x x q as the dependent linear type g p t fx x q that is we view elements of hoare type as terms which take a witness for the p and then compute a result of type x as well as a producing a witness for the q this is a of connectives however such finegrained have a number of benefits since each of the connectives we give has a very simple theory we can derive the equational theory for terms of hoare type by joining up the theory of its components as a simple example an immediate consequence of our decomposition is that all terms of type x x q that is the type of computations with a false precondition are equal simply via the for functions and another consequence which we rely upon in our examples comes from our encoding of the pointsto predicate of separation logic our basic pointer type l x says only that l contains a value of type x we encode the pointsto of separation logic l v using the type l x x x v then the fact that the is ie all its elements we say the equational theory because the equality is canonical however there are many desirable equations such as those arising from parametricity which go far beyond it are equal means that we know that any dereference of l is equal to v refl without having to put explicit proofs into the terms because of equality reflection in addition moving things like preconditions out of the computation monad t a lets us give a very simple model for it which means that we can easily show the soundness of equations such as eliminating duplicate gets let x c e in x c c in e a let x c e in xx e and eliminating gets after sets let val c e e e in x c c in e t a let val c e e e in ce x cc e hoare type theory hoare type theory gives an alternative internal approach to imperative programming by directly embedding hoare triples into type theory the central idea is to use dependent types to specify imperative programs as elements of an indexed monad where the index domain are formulas of separation logic this approach has proven successful in verifying complex imperative programs such as modern congruence closure algorithms but working out the equational theory of the hoare type has proven to be an extremely challenging problem to the point that et al give a model without any equations to illustrate the connection more clearly we note that each of the basic constants of hoare type theory is definable in our calculus with a type that is close to the image of the translation of its hoare type below we give allocation dereference assignment and the rule of consequence to illustrate we leave out the terms because they can be read off the types in each case the hoare type is on the top line and the linear type is on the line below new emp x loc x g t fx loc x set x loc v v x x v x v v x x loc v x g x v t x v get x loc v x x v v x v v x v v x x loc g x v fv x pf v v x v con p p q q p p q q p x x q p x x q g p p g q q p p q q li g p fx x q g p fx x q we can see that in some cases the typings have computational advantages for example for the set constant we are able to use the implicit quantifier to make clear that while the pointer and the new value need to be passed as arguments the old contents do not need to be passed in this is not possible in due to the absence of intersections and to work around this a postcondition is used as another example the get constant doesnt have a monadic effect in as a result any totally correct program in hoare type theory should in principle be into the much and automation available for hoare type theory there is however a significant difference between and the latter supports general recursion and deals with partial correctness requires a termination metric on fixed point definitions and only deals with total correctness most of the complexity in the model theory of comes from its treatment of recursion such as the need for closure to ensure for fixed point induction we have these issues by only on total correctness in fact much of the in the design of in the effort needed to rule out general recursion in languages with higherorder store it is usually possible to write recursion operators by function pointers and so we had to carefully exploit linearity to prevent the typability of such examples this was originally observed by ahmed et al another example is found in our fixed point operator which defines recursive functions with an irrelevant termination metric if we had given a general fixed point operator fix x e even with an irrelevant termination metric then looping computations would be definable this is connected to the ability of intersection types to detect evaluation order as a result to formally argue that our approach makes proving equations easier we would need to give a version of our t monad which is partial which would give a calculus corresponding more closely to we hope to investigate these questions more in future work as stand all we can say is that our semantics is in many ways much less technically sophisticated than models such as the one of et al even though it permits us to prove a number of novel equations on programs metatheory we now establish the metatheory of our type system our approach the ideas of harper and ahmed et al we begin by giving an untyped operational semantics for the language in fact we give three operational semantics one for pure intuitionistic terms one for pure linear terms and one for monadic linear terms next we use this operational semantics to give a semantic realizability model by defining the interpretation of each logical connective as a partial equivalence relation per because we have dependent types we need to define the set of syntactic types mutually recursively with the interpretation of each type in the style of an definition furthermore we have to interpret intuitionistic and linear terms differently we use an ordinary per on terms to interpret intuitionistic types and a per on machine configurations terms plus store to interpret linear types this gives a semantic interpretation of closed types we extend this to an interpretation of contexts as sets of environments and then prove the fundamental theorem of logical relations for our type system which establishes the soundness and adequacy of our rules including its equational theory operational semantics the syntax for our language of untyped terms is given in figure for simplicity all our types and terms live in the same syntactic category regardless of whether they are tic and linear the variable v ranges over intuitionistic values u ranges over linear values and denotes heaps there are actually three operational semantics for our language first we have an evaluation relation e v for intuitionistic terms a a linear evaluation relation e u for linear terms and a monadic evaluation relation e val u for evaluating monadic terms both the linear and monadic semantics are relations because they are imperative computations which may depend upon the state of memory the intuitionistic evaluation relation e v is a standard callbyname bigstep evaluation relation for the lambda calculus we treat all types as values and do not evaluate their subterms and also include location values l in the syntactic category of values though there are no typing rules for location values they may arise during program evaluation when fresh memory cells are allocated the linear evaluation relation e u evaluates the machine configuration e to u this is also a callbyname bigstep evaluator however there are many rules in this reduction relation simply because we have many linear types in our language the rules for functions both linear a b and dependent x x a and pairs a b follow the of the equational theory as expected the for i a b and fx x a are more but also line up with the of the theory the g e evaluates e to a term g t and then executes t again following the a in our rules is that we need operational rules for the rules ie let a b e in e proof through units and this has no computational content since the argument e is never evaluated but nevertheless we must include evaluation rules for it finally we also have the dereference operation let x c e in e this rule evaluates e to a location l and e to an irrelevant value then it looks up the value v stored at l and binds that to x and binds c to the irrelevant value before evaluating the continuation e one point worth making is that none of these rules affect the shape of the heap ­ we can dereference pointers in the pure linear fragment but we cannot write or modify them as a result every linear reduction is really of the form e u we could have easily have made this into a syntactic restriction but having two configurations is slightly more convenient when giving the realizability semantics finally we have the monadic evaluation e val u the rule for let val x e in e is sequential composition it evaluates the first argument to a monadic value and then binds the result to x before evaluating e the rule for new e evaluates its intuitionistic argument to a value v and then allocates a fresh location l to store it in returning the location and a dummy for the capability the rule for assignments e e e evaluates e to a location l e to a value v and e to a capability then it modifies the heap so that l points to v similarly the rule for deallocation free e e evaluates e to l and then the pointer note that all of these operations could get stuck if the appropriate piece of heap did not exist the soundness proof will establish that typesafe programs are indeed safe and fixed points since types depend on terms in dependent type theory we cannot define the grammar of types up front before giving an interpretation their interpretations instead what we need is an definition as a result we e t x a x x y a b x c e e e x e i let e in e x x y a b e e e e let x y e in e g e g e fx x a f e t let f x a t in t ab x x y x x y e x e refl n se e sx y e ui li x fix f x e a let x e in e e x loc e free e t l let x a e in e e e e t a val e let val x e in e v x a e e e refl g e l sv x x y a b a b i x x y a b fx x b e x e e x loc ui li u x e e e f e e x e e e val e let val x e in e e e e e · l v figure terms e t x a values v linear values u stores need to use a fixed theorem which is a little stronger than the standard kleene or fixed point theorems recall that a pointed partial order is a triple x such that x is a set is a partial order on x and is the least element of x a subset d x is a directed set when every pair of elements x y d has an upper bound in d ie there is a z d such that x z and y z a pointed partial order is complete ie forms a when every directed set d has a d in x the following fixed point theorem is in harper and is theorem in and theorem fixed points on if x is a and f x x is a monotone function on x then f has a least fixed point proof construct the sequence x where x x fx x x because f is monotone we can show by induction that every initial segment is directed which ensures the needed exist and the sequence is welldefined now we know there must be a stage such that x x if there were not then we could construct a bijection between the and the strictly increasing chain of elements of the sequence x however the elements of the sequence x are all drawn from x since x is a set it follows that the elements of x must themselves form a set since the do not form a set they are a proper class this leads to a contradiction hence f must have a fixed point partial equivalence relations and semantic type systems we now need to define what our types are and how to interpret them following the example of we will a constructive impredicative proof of this theorem is possible this is theorem ev vv e x a e v e e v e e e e v e v e e e e v e v ev se sv e e v e sx y e v e sn e sx y e v nx v e sx y e v e fix f x e fix f x ef e xe v ee v e u u u e x e u e e u e x e u e e u e e e e u e u e e e e u e u e e u let e in e u e e e ea u let a b e in e u e f e e ex u let f x a e in e u e ge e u g e u e u let e in e u a be u let a b e in e u el e l v l v vx ce u let x c e in e u e val v val e val e e u e val u u e val u val u e val e val v let val x e in e val v ev e l dom l v val f l e l e v e l v l v e e e l v val e l t l v free e t val figure operational semantics interpret types as partial equivalence relations of terms with the intuition that if e e x then e is an element of the type x and that if e e x then e is equal to e because of type dependency we will then simultaneously define the per of types and an interpretation function sending each type to the per it defines a partial equivalence relation per is a symmetric transitive relation on closed terminating expressions we further require that pers be closed under evaluation given a per r we require that for all e e v v such that e v and e v we have that e e r if and only if v v r given a per p we write p to close it up under evaluation we extend this notation to functions as well so that given a function f into pers fx f x finally given a relation r we write r to take its symmetric transitive closure we will use pers to interpret intuitionistic types a partial evaluation relation on configurations is a symmetric transitive relation on terminating machine configurations e we further require that they be closed under linear evaluation given a m we require that for all e such that e u and e such that e u we have e e m if and only if u u m we will use to interpret linear types with the idea that the store components of each element of the per corresponds to the resources owned by that term note that since evaluation both ordinary and linear is deterministic an per is determined by its on values or value configurations as a result we will often define pers and functions on pers by simply giving the relation for values a semantic type system is a i per l per i per l such that respects i and respects l we say that i are the semantic intuitionistic types l are the semantic linear types and and are the type interpretation functions the set of type systems forms a the least element is the type system per with an empty set of intuitionistic and linear types the ordering i l i l is given by set inclusion on i i and l l when there is agreement between and on the common part of their domains and likewise for and which we write and given a directed set the join is given by taking unions pointwise treating the functions and as graphs next our goal is to define a semantic type system to interpret our syntax to do this we will define a monotone type system operator tk since type systems form a we can define the semantic type system we use to interpret our syntax as the least fixed point of tk first well define some constructions on pers in figures and there is one construction for each of the type connectives in our language what each connective means logical relations style though these constructions do not yet define a logical relation since they are just constructions on pers the intuitionistic constructions are given in figure the loc relation relates each location to itself and the unit relation relates the unit value to itself the identity relation b e is equal to refl refl if a and b are in the relation e and is empty otherwise the construction takes a per e and a function from elements of e to pers which respects the relation e from that data it returns the per of function values f f which take pairs a a to f a f a in ea with the e construction working similarly for loc l l l loc b e refl refl a b e e v v a a e va v a a e a b a b a a e b b a gc g e g e · e · e c e v v e e e v v e e v v e e e v v e n sk sk k is a natural number i v v v val v val figure intuitionistic per constructions pairs the intersection type e construction just takes the intersection over a for all a in e which is a per since pers are closed under intersection the union type is a little more complicated it takes the union of pers and then has to take the symmetric transitive closure because pers are not closed under unions the natural number relation n relates to themselves and i relates any two values the linear constructions are given in figure the relation relates two unit values under any stores at all whereas the i relation relates two units only in the empty store similarly the a b relation relates two pairs as long as the first components are related at a using all of the store and the second components are related at b using all of the store the tensor relation c d relation on the other hand relates two pairs if their stores can divided into two disjoint parts one relating the first components in the c relation and the other relating the second components in the d relation the semantic linear function space constructor c d relates functions such that if we have values in c with disjoint store then the applications are related in d with the combined store much like the magic wand of separation logic the fe relation consists of pairs of stores and values f a b and f a b such that a and a are intuitionistic terms related in e and b and b are related in a using their whole stores the l relation works similarly except that it relates on dependent linear functions rather than pairs the linear intersection and union type constructors work similarly to their intuitionistic counterparts the proof relation relates two tokens at some stores if there are linear terms that could relate those stores at a the pointer construction e simply says that the heap consists of a single memory cell addressed by e and whose contents are related at e its only term is because we dont care about its value as we use it solely to track capabilities the t a construction relates monadic computations if each side reduces to a configuration which is related by a furthermore only computations can be related if a computation works in a smaller store it should also work in a larger store without modifying that larger store we can now define an operator tk on type systems l i l where i and l are defined in figure and and where and are defined in figure the definition of i and l includes each of the base types and then for each of the operations the argument types from i or l so that for example l includes every a b where a and b are in l the definition of and is by analysis of the structure of the elements of i and l using the per constructions we described earlier store a b a b a b a a a b b b i c d · · c d c d c d c d c · d c · d c c c c c d d d d d c d u u c c if c c c then · uc · u c d fe f a b f a b ea a b b a le u u e e e u e u e e le u u e e e u u e le t a e u u e e e u u e e e f g u u · f e · f val u · g e · g val u u u a l v l v e l loc v v e a a a a a figure linear per constructions to interpret each of the type constructors furthermore in the definition of when we write loc we actually mean any e such that i e loc this is justified by the fact that evaluation is deterministic and relations are closed under similarly we define only on the values extending it to all terms by and closure under evaluation once we have this definition we can then show that tk is a monotone type system operator lemma tk is monotone we have that tk is a monotone function on type systems proof sketch this lemma really makes two claims first that tk is indeed a function on semantic type systems in particular that and respect i and l and second that it is monotone both of these follow from a case analysis on the shape of the possible elements of i and l see the technical report for details then we can take the interpretation of the ith universe ti to be the least fixed point of ti furthermore we also have a property lemma universe if i k then ti tk we sometimes write t for the limit of the countable universe hierarchy and write u l and for its components semantic environments our semantic type system t gives us an interpretation of closed types before we can prove the correctness of our typing rules we have to extend our interpretation to open types and terms and to do that we have to give an interpretation of environments in figure we give the interpretation of contexts the meaning of an intuitionistic context is given as a set of binary substitutions by binary substitution we mean that for every x dom we have that x e e for some i loc loc n n i i e x e t y t ix y xe t xe t x x yx x x y x ix x v v x y v x x yx x x y x ix x v v x y v x x yx x x y x ix x v v x y v x x yx x x y x ix x v v x y v g a g a la a ui ui i k li li i k l i i a b a b la a lb b a b a b la a lb b fx x ax ix x fx x a x v v x a v x x ax ix x x x a x v v x a v x x ax ix x x x a x v v x a v x x ax ix x x x a x v v x a v a b a b la a lb b t a t a a a l e x e x e e loc x x i figure definition of type part of tk loc loc n i n i e x e e x x x yx x v x x yx x v x x yx x v x x yx x v g a ga ui when i k let u l in u li when i k let u l in l i a b a b a b fx x ax x x ax x x ax x x ax t a e x i a b a b a b fx v av lx v av lx v av lx v av t a x figure definition of tk interpretation part · x x e ex x x u e e x · · · a a ea e a a a l e e a figure interpretation of environments pair of terms we write for the ordinary unary substitution substituting the first projection of for each variable in and for the ordinary substitution substituting the second projection we write e for the pair e e the of the empty context is the empty sub the interpretation of x x is every substitution e e x where and x is a type in u and e e are related by x the interpretation of linear contexts is a little more com instead of a binary substitution its elements consist of pairs of pairs intuitively a linear en is a set of linear values for each linear variable plus the store needed to interpret the value so the tation of a context a a are all the pairs of configurations ea e a where e and e are related by a and a is a linear type in l the interpretation of the empty linear context is similar to the interpretation for i it relates two empty substitutions in empty heaps likewise the interpretation of contexts is very similar to the interpretation of the tensor product when we interpret a context we take it be a pair of and such that we can divide the stores so that · and · and is related to at and likewise is related to at fundamental property we can now state the fundamental lemma of logical relations theorem fundamental property suppose ok and and ok and then we have that if x type then x u if if if if x y type then x y u e x then e x e e x then e e x a linear then a l if a b linear then a b l if e a then e e x if e e a then e e x if then there are t and t such that for each and we have t t a proof the theorem follows by a mutual induction over all of the rules of all of the judgements in the system the full proof is in the companion technical report worth noting is that in many of the cases we make the arbitrary choice to use the first projection of the substitution ie or rather than the second of dependent types may that difficulties could be in this choice there are no problems because we established that t is a semantic type system up front and so we know that and respect i and u evaluation of all closed welltyped terms terminates the fundamental property also implies consistency since every welltyped term is in the logical relation and inconsistent types like have empty relations we also have adequacy any two provably equal terms of natural number type will evaluate to the same and similarly for the linear type fn n i and the monadic type t fn n i implementation we have written a small type checker for a version of our theory in ocaml we say version of because the type system we present in this paper is extremely undecidable and so we have needed to make a number of modifications to the type theory to make it implementable we emphasize that even though all of the modifications we made seem straightforward we have done no proofs about the implementation we still need to show that everything is consistent and conservative with respect to the extensional system equality reflection our implementation does not support equality reflection or indeed most of the rules our system implements an untyped conversion relation and implements a few of the easier for example x f x f so our implementation is really an intensional type theory rather than an extensional one intersection and union types the formulation of intersections and unions in this paper is set up to optimize the simplicity of the side conditions to check a term e against the type x x y we just add x x to the context and check that x does not occur free in e however eliminating an intersection type requires the instantiation in our implementation we have to write an explicit abstraction x e to introduce a universal quantifier x x y and eliminating an intersection requires an explicit annotation so that if f x x y and we want to instantiate it with e x then we need to write f e similarly we give a syntax for implicit x x y where the introduction is an explicit pack t with e x and t and the elimination is an let y e in e however we track which variables are computationally relevant or not in both a x e and a let y e in e the x is not computationally relevant may only appear within type annotations implicit applications and the first argument of this restriction is in the style of the operator of pfenning which was later extended to type dependency by our overall result also looks very much like the variant of the implicit calculus of constructions with decidable typechecking proof in this paper we implement linear proof with a term to turn this into something we can typecheck we note that the premise of the rule requires that we produce an irrelevant derivation e ÷ a the rules of this judgement see figure are actually a linear version of the monadic modality of pfenning and and in fact we their notation so to turn this into something we can typecheck all we have to do is to replace with a term e where we can derive e ÷ a we should also extend definitional equality to all terms of type a though we have not yet implemented this as that requires a typed conversion relation evaluation our preliminary experience is that equality is the most challenging issue for us we had to numerous equalities that are sound in our model but not applied automatically and this is quite for example we needed to function to make things work since we formulate lists in terms of and they are not wellbehaved in addition our derivations of uses fix f x e often make use of equality reflection but we have not yet found a completely satisfactory formulation of its typing rule that works well in an intensional setting an easy fix is to add lists and other inductive types as a primitive to our system and another possibility is to move to something like observational type theory discussion and related work we divide the discussion into several categories even though many individual pieces of work multiple categories dependent types as an extensional type theory our system is constructed in the our metatheory was designed following the paper of harper and many of our logical connectives were inspired by work on for example our treatment of intersection and union types is similar to the work of as well as per models of polymorphism such as the work of et al our treatment of proof is also inspired by the types of though because of the constraints of linearity we could not directly use his rules linearity and pfenning proposed the linear logical framework a core type theory for integrating linearity and dependent types this calculus of the negative fragment of together with a dependent function space x a b with the restriction that in any application f e the argument e could contain no free linear variables in our calculus this type corresponds to x g a b this explains why the argument of the application should not have any free linear variables every application f e corresponds to an application f g e in our calculus very recently has proposed an extension of linear lf in which he extends linear lf with an intuitionistic x a b whose introduction form is a pair whose first component does not have any free linear variables in our calculus this can be encoded as fx g a b this encoding yields a nice explanation of why the first component of the pair is intuitionistic and also why the dependent pair has a elimination rather than a he also extends the calculus with many other features such as equality types and just as we have but in both cases these extensions are straightforward and so there is nothing interesting to compare instead of an operational semantics he gives a categorical axiomatization and in future work we will see if his semantics applies to our syntax value dependency and proof another extension of is the concurrent logical framework or of et al which extends with positive types such as ab ab and the intuitionistic types as well as a computational monad a to between uses of positive and negative types this seems to be an instance of in which a pair of adjoint modalities n and p are used to positive and negative types with the monadic type a arising as the composite p the distinction between positive and negative corresponds to a distinction cf while the calculus is also built on an this reflects the distinction and not the distinction as a result our language is pure the full theory for all the connectives and we can freely mix positive and negative types eg a b c however remains interesting from both purely theoretical and more practical points of view gives dependent l a linear dependent type theory from a purely perspective the key observation is that calculi have a weaker notion of substitution namely variables stand for values rather than arbitrary terms and as a result a dependent types may depend only on values which large but b since contraction of closed values is safe since no computations can occur in types linear variables may be freely duplicated when they occur in types similar ideas are also found in the f language of et al this is an extension of the f language with type dependency since f is an imperative language in the ml for soundness dependency is restricted to value dependency just as in dependent l however the treatment of dependency on linear variables is somewhat different f has a universe of intuitionistic types and affine variables can appear freely in types imperative programming with capabilities in addition to languages exploring type dependency including hoare type theory which we discuss in section there are also a number of languages which have at using linear types as a programming feature with linear by and xi is not a language since it very strictly its proof and programming language however it has an extremely extensive language of proofs and this proof language includes linear types which are used to control memory accesses in a fashion very similar to l or separation logic interestingly the entire linear is computationally irrelevant ­ linear proofs are proofs and hence erased at runtime similarly the calculus of capabilities of pottier represents another approach towards integrating linear capabilities with a programming language as with capabilities are linear and irrelevant and this system also includes support for advanced features such as the rule a simpler capability system can be found in the work of et al who give a kernel linear capability calculus at this point it should be clear that the combination of proof and linearity is something which has appeared frequently in the literature in many different unfortunately it has mostly been introduced on an adhoc basis and is not something which has been studied in its own right as a result we cannot give a comparison of our proof modality with this other work since the design space seems very complex other work one piece of work we wish to draw attention to is the effect calculus of et al this calculus is like the calculus except that it restricts linear contexts to at most a single variable so that they are in terminology one is that has a mixed pair x a which looks very much like our linear dependent pair fx x a another direction for future work is to the heap model our model of imperative computations is a generalization of ahmed et al which in turn builds a logical relation model on top of the basic heap model of separation logic however over the past this model of heaps has been extended both from a semantic perspective and from the of verification references a in type theory with a heterogeneous equality judgement in foundations of software science and computational structures pages ­ springer a ahmed m and g morrisett l a linear language with locations ­ t c and w observational equality now in pages ­ acm a appel r a l j g s and x leroy program logics for certified compilers cambridge university press e s p j freyd a and p j scott polymorphism theoretical computer science ­ b and b the implicit calculus of constructions as a programming language with dependent types in foundations of software science and computational structures pages ­ springer n benton a mixed linear and nonlinear logic proofs terms and models in computer science logic csl n benton and p wadler linear logic monads and the lambda calculus in logic in computer science lics l birkedal k and j a relational realizability model for higherorder stateful the journal of logic and algebraic programming ­ i and f pfenning a linear logical framework inf comput ­ a verification of lowlevel programs in computational separation logic acm sigplan notices ­ r l constructive mathematics as a programming logic i some principles of theory in of mathematics volume pages ­ b a and h a introduction to lattices and order cambridge university press t l birkedal p m parkinson and h yang views compositional reasoning for concurrent programs acm sigplan notices ­ d dreyer g and l birkedal the impact of higherorder state and control effects on local relational reasoning journal of functional programming ­ j r e and a an effect calculus with linear types in computer science logic pages ­ springer m h joins in the frame of applied categorical structures ­ jy girard linear logic theoretical computer science ­ jy girard linear logic its syntax and semantics in advances in linear logic volume of london mathematical society lecture notes r harper constructing type systems over an operational semantics journal of symbolic computation ­ a and j the of sharing in data structures acm sigplan notices ­ j b and l birkedal separation logic in programming languages and systems pages ­ springer a type theoretical foundations for data structures classes and objects phd thesis p b a synthesis volume of semantics structures in computation springer p and g intuitionistic type theory f j and l in proceedings of the acm sigplan workshop on programming languages meets program verification pages ­ acm a the implicit calculus of constructions extending pure type systems with an intersection type binder and subtyping in pages ­ springer a g morrisett and l birkedal polymorphism and separation in hoare type theory in j h and j l editors icfp pages ­ acm a g morrisett and l birkedal hoare type theory polymorphism and separation journal of functional programming ­ a v vafeiadis and j berdine structuring the verification of programs in m v and j palsberg editors popl pages ­ acm z ni d and z shao using xcap to realistic systems code machine context management in pages ­ a types a modular approach in theorem proving in higher order logics pages ­ springer p w ohearn and d j the logic of implications of symbolic logic ­ r l l birkedal a and g morrisett a realizability model for impredicative hoare type theory in programming languages and systems pages ­ springer f pfenning and proof in modal type theory in lics proceedings pages ­ ieee f pfenning and r a reconstruction of modal logic mathematical structures in computer science ­ f pottier syntactic soundness proof of a system with hidden state journal of functional programming ­ jan j c reynolds separation logic a logic for shared mutable data structures in logic in computer science proceedings th annual ieee symposium on pages ­ ieee a a dissection of l url k l birkedal and a state and dependent types in ch l editor volume of lecture notes in computer science pages ­ springer n j chen c fournet py k and j yang secure distributed programming with types in icfp pages ­ m syntax and semantics of linear dependent types url k i f pfenning and d walker a concurrent logical framework the propositional fragment in types pages ­ n on the of duality ann pure logic ­ d and h xi safe programming with pointers through stateful views in pages ­ january 