martin hofmann germany symmetric lenses benjamin pierce university of pennsylvania pennsylvania usa daniel university of pennsylvania pennsylvania usa abstract transformations between pairs of connected been extensively studied and are beginning to find their way into practice however some aspects of their foundations remain understood in particular most previous work has focused on the special case of asymmetric lenses where one of the structures is taken as primary and the other is thought of as a projection or view a few studies have considered symmetric variants where each structure contains information not present in the other but these all lack the basic operation of composition moreover while many domainspecific languages based on lenses have been designed lenses have not been explored from an algebraic perspective we offer two contributions to the theory of lenses first we present a new symmetric formulation based on an old idea from the database literature this formulation generalizes the familiar structure of asymmetric lenses and it admits a good notion of composition second we explore the algebraic structure of the space of symmetric lenses we present of a number of known constructions on asymmetric lenses and some questions about their particular we prove the existence of symmetric monoidal tensor products and sums and the of full categorical products or sums in the category of symmetric lenses we then show how the methods of universal algebra can be applied to build iterator lenses for structured data such as lists and trees yielding lenses for operations like mapping and concatenation from first principles finally we investigate an even more general technique for constructing mapping combinators based on the theory of containers categories and subject descriptors d programming languages language application languages general terms design languages theory keywords lens algebra category theory introduction the electronic world is with partially synchronized data replicated structures that are not identical but share some common parts and where the shared parts need to be kept up to date as the permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission andor a fee popl january ­ austin texas usa copyright c acm structures change examples include databases and views and representations of heap structures connected components of user interfaces and models representing different aspects of the same software system in current practice the propagation of changes between connected structures is mostly handled by ad hoc methods given a pair of structures x and y we write one transformation that maps changes to x into changes to y and a separate transformation that maps y changes to x changes however when the structures involved are complex such pairs of transformations manually can be a this has led to a interest in bidirectional programming languages in which every expression denotes a related pair of transformations a great variety of bidirectional languages have been proposed see for recent and these ideas are beginning to see commercial application eg in system tool one particularly class of bidirectional programming languages is the framework of lenses prior work on lenses and structures has mostly been carried out in specific combinators for lenses that work over strings trees relations graphs or software models by contrast our aim in this paper is to advance the foundations of lenses in two significant respects first we show that lenses can be generalized from their usual asymmetric one of the structures is always a view of the a fully symmetric version where each of the two structures may contain information that is not present in the other section this generalization is significantly more expressive than any previously known although symmetric variants of lenses have been studied they all lack a notion of sequential composition of lenses a significant technical and practical limitation see section as we will see the extra structure that we need to support composition is nontrivial in particular constructions involving symmetric lenses need to be proved correct modulo a notion of behavioral equivalence section second we a systematic investigation of the algebraic structure of the space of lenses using the concepts of elementary category theory as and principles our presentation is self contained but some prior with basic concepts of category theory will be helpful most proofs are omitted for brevity they can be found in a long version of the paper available from the second authors web page we begin this algebraic investigation with some simple generic constructions on symmetric lenses composition terminal lenses simple etc section we then some basic questions about products and sums sections and in particular it was previously known that asymmetric lenses admit constructions intuitively corresponding to pairing and projection and another construction that is intuitively like a sum however these constructions were not very well understood in particular it was not known whether the pairing and projection operations formed a full categorical product while the injection arrows from x to x y and from y to x y were not definable at all in the asymmetric setting we prove that the category of symmetric lenses does not have full categorical products or sums but does have symmetric monoidal structures with many of the useful properties of products and sums next we consider how to build lenses over more complex data structures such as lists and trees section we first observe that the standard construction of algebraic datatypes can be lifted straightforwardly from the category of sets to the category of lenses for example from the definition of lists as the least solution of the equation lx unit x × lx we obtain a lens connecting the set lx with the set unit x × lx the two directions of this lens correspond to the unfold and fold operations on lists moreover the familiar notion of initial algebra also generalizes to lenses giving us powerful iterators that allow for a modular definition of many symmetric lenses on lists and mapping a symmetric lens over a list and translating between lists and trees finally we briefly investigate an even more general technique for constructing mapping lenses that apply the action of a given to all the elements of some data structure section this technique applies not only to algebraic data structures but to an arbitrary container in the sense of and this extends the variety of list and tree mapping combinators that we can construct from first principles to include datatypes such as labeled dags and graphs we carry out these in the richer space of symmetric lenses but many of the results and techniques should also apply to the special case of asymmetric lenses indeed we can show section that asymmetric lenses form a of symmetric ones in a natural way every asymmetric lens can be embedded in a symmetric lens and many of the algebraic operators on symmetric lenses specialize to known constructions on asymmetric lenses conversely a symmetric lens can be into a back to back assembly of two asymmetric ones sections and discuss related and future work fundamental definitions asymmetric lenses to set the stage lets review the standard definition of asymmetric lenses other definitions can be given weaker or stronger laws but this version is widely accepted we discuss variants in section suppose x is some set of source structures say the possible states of a database and y a set of target structures views of the database an asymmetric lens from x to y has two components get x y put y × x x the get component is the forward transformation a total function from x to y the put component takes an old x and a modified y and yields a modified x these components must two laws for every x x and y y put get x x x get put y x y it is also useful to be able to create an element of x given just an element of y with no original x to put it into in order to handle this in a uniform way each lens is also equipped with a function create y x and we assume one more axiom get create y y the key step toward symmetric lenses is the notion of the idea back to a paper in the database literature on the view update problem and was adapted to lenses in and for a slightly different definition and it is quite simple if we think of the get component of a lens as a sort of projection function then we can find another projection from x into some set c that keeps all the information discarded by get equivalently we can think of get as returning two element of y and an element of together contain all the information needed to the original element of x now the put function doesnt need a whole x x to with some updated y y it can just take the complement c c generated from x by the get since this will contain all the information that is missing from y moreover instead of a separate create function we can simply pick a distinguished element missing c and define as missing formally an asymmetric lens with complement mapping between x and y consists of a set c a distinguished element missing c and two functions get x y × c put y × c x the following laws for every x x y y and c c get x y c put y c x get put y c b c b y note that the type is just lens from x to y the set c is an internal component not part of the visible type in symbols y c missing c get x y × c put y × c x symmetric lenses now we can first instead of having only get return a complement we make put return a ment too and we take this complement as a second argument to get so we have get x y and put y x × cy intuitively cx is the information from x that is discarded by get and cy is the information from y that is discarded by put next we observe that we can without loss of generality use the same set c as the complement in both directions so now we have get x y and put y x intuitively we can think of the combined complement c as cx that is each complement contains some private information from x and some private information from y by convention the get function reads the cy part and writes the cx part while the put reads the cx part and writes the cy part now that everything is symmetric the get put distinction is not helpful so we rename the functions to putr and this us to our core definition definition symmetric lens a lens from x to y written x y has three parts a set of c a element missing c and two functions putr x × c y × c y × c x × c satisfying the following laws we can convert back and between the two in particular if get put create are the components of a traditional lens then we define a canonical complement by c f y x y y y we then define the components missing get and put of an asymmetric lens with complement as missing create and get x x and put y f f y germany only here only here a initial germany germany each transformation propagates using the complement updates both to the target to fill in information not and to the complement available in the source d propagating the edit germany germany add an extra structure the complement that stores the private information from both sides b initial complement germany italy e second replica is figure behavior of a symmetric lens germany germany c one replica germany italy italy f this change is propagated putr x c y c y c x c y c x c putr x c y c when several lenses are under discussion we use record notation to identify their parts writing c for the complement set of etc the force of the and laws is to establish some consistent or triples x y c for which puts of x from the left or y from the right will have no is will not change the complement the conclusion of each rule has the same variable c on both sides of the equation to reflect this we will use the equation putr x c y c to characterize the states in general a put of a new x from the left entails finding a y and a c that restore consistency additionally we often wish this process to involve the complement c from the previous state as a result it can be to choose a good value of missing this value can often be chosen each of our primitive lenses and lens combinators specify one good choice for missing one can imagine other laws in particular the long version of the paper considers symmetric forms of the asymmetric laws which specify that two put operations in a row should have the same effect as the second one alone as with asymmetric lenses these laws appear too strong to be desirable in practice examples figure illustrates the use of a symmetric lens the structures in this example are lists of textual records describing the partially synchronized records a have a name and two on the left and a name and a on the right the complement b contains all the information that is discarded by both the from the lefthand structure and all the from the righthand structure it can be viewed as a pair of lists of strings or equivalently as a list of pairs of strings the way we build list lenses later actually corresponds to the latter if we add a new record to the left hand structure c and use the putr operation to propagate it through the lens d we copy the shared information the new name directly from left to right store the private information the new in the complement and use a default string to fill in both the private information on the right and the corresponding righthand part of the complement if we now update the righthand structure to fill in the missing information and correct a in one of the other names e then a operation will propagate the to the complement propagate the name to the other structure and use the complement to restore the for all three viewed more abstractly the connection between the information about a single in the two tables is a lens from x × y to y × z with complement x × call it e its putr component is given x y as input and has x z in its complement it constructs a new complement by replacing x by x to form x z and it constructs its output by pairing the y from its input and the z from its complement to form y z the component does the opposite replacing the z part of the complement and the x part then the toplevel lens in figure lets call it e abstractly has type x × y y × z and can be thought of as the lifting of e from elements to lists there are several implementations of e with slightly different behaviors when list elements are added and removed ie when the input and complement arguments to putr or are lists of different lengths one possibility is to take e c ec and maintain the invariant that the complement list in the output is the same length as the input list when the lists in the input have different lengths we can restore the invariant by either the complement list or it with for example taking x a b c y z a b c and m m and writing a b c for the sequence with the three elements a b and c we could have putr a p p q q putr a p p p a p putr a b a p putr a b a p m m p m a p b m notice that after the first putr the information in the second element of the complement list q q is lost the second putr creates a new second element for the list so the value q is forever left is the default value m another better to keep an infinite list of whenever we do a put we use and update a prefix of the complement list of the same length as the current value being put but we keep the infinite tail so that later we have values to use when the list being put is longer putr a p p q q m m m m p a p q q m m m m putr a b a p q q m m m m p q a p b q m m we call the first form the list mapping lens and the second the list mapping lens we will see later that the difference between these two precisely down to a difference in the behavior of the operator in the specification e id unit e e of the list mapping lens figure illustrates another use of symmetric lenses the structures in this example are lists of data each name on the left is either a tagged inl or an author tagged inr and each name on the right is either a or an actor the lens under consideration will just the between the two lists leaving the authors on the left and the actors on the right the synchronized state a shows a complement with two lists each with holes for the if we the righthand structure b the change in order will be reflected on the left by the two adding another on the left c involves adding a new hole to each complement on the left the location of the hole is determined by the new list and on the right it simply shows up at the end similarly if we remove a d the final hole on the other side abstractly to achieve this behavior we need to define a lens comp between x y and x z to do this it is convenient to first define a lens that x y and x × y call this lens partition the complement of the partition is a list of booleans whether the corresponding element of the left list is an x or a y the putr function is fairly simple we separate the x y list into x and y lists by checking the tag of each element and set the complement to exactly match the tags for example putr inl a inl b inr c a b false false true putr inl a inr inl b c a b false true false these examples demonstrate that putr ignores the complement entirely a completely new one from its input the function on the other hand relies entirely on the complement for its ordering information when there are extra entries not for by the complement it adds them at the end consider taking the output of the second putr above and adding c to the x list and to the y list a b c false true false inl a inr inl b inl c inr false true false false true the in as much of the beginning of the list as it can using the complement to indicate whether to draw elements from x or from y how the remaining x and y elements are interleaved is a free choice not specified by the lens laws since this case only arises when we are not in a situation the strategy shown here where all new x entries all new y entries is just one possibility given partition we can obtain comp by composing three lenses in sequence from x y we get to x × y using partition then to x × z using a variant of the lens e discussed above and finally to x z using a backwards partition alignment one important of the present paper is dealing with the important issue of alignment we consider only the simple case of lenses that work for example the lens e in the example will always use e to propagate changes between the first element of x and the first element of y between the second element of x and the second of y and so on this amounts to assuming that the lists are either by editing individual elements in place or by adding or deleting elements at the end of the list if an actual edit inserts an element at the head of one of the lists alignment will produce surprising and probably results we see two for richer notions of alignment either we can generalize the mechanisms of matching lenses to the setting of symmetric lenses or we can refine the whole framework of symmetric lenses with a notion of propagation see section equivalence since each lens carries its own since this need not be the same as the complement of another lens with the same domain and now need to define what it means for two lenses to be in the sense that no user could ever tell the difference between them by observing just the x and y parts of their outputs we will use this relation in what follows indeed most of the laws we would like our constructions to things as basic as associativity of composition will not hold on the but only up to equivalence definition given x y cf cg and a relation r cf × cg we say that functions f x × cf y × cf and g x × cg y × cg are written f r g if they take inputs with to equal outputs with cf cg r f x cf yf cf gx cg cg yf cf cg r definition lens equivalence two lenses k and are equivalent written k if there is a relation r kc × c with missing r r putr r we write x y for the set of equivalence classes of lenses from x to y when is a lens we write for the equivalence class of that is x y iff x y where no confusion results we notation and drop these brackets using for both a lens and its equivalence class we show in the long version that this definition of lens equivalence coincides with a more observational definition where two lenses are equivalent iff they always give the same sequence of outputs when presented with the same sequence of inputs starting with a missing complement basic constructions with the basic definitions in hand we can start defining lenses we begin in this section with several relatively simple constructions definition identity lens let unit be a distinguished singleton set and its only element id x x x c unit missing putr x x x x inl inl inl inl inl inl inl inl a initial b the right inl inl inl inl inl inl inl inl inl inl c inserting on the left d deleting from the left figure lists of sums to check that this definition is well formed we must show that the components defined in the lower box satisfy the laws implied by the upper box this proof and analogous ones for later lens definitions are given in full in the long version definition lens composition kx y y z k x z c kc × c missing missing putr x ck c let y ck x ck in let z c putr y c in z ck c z ck c let y c z c in let x ck y ck in x ck c this definition specifies what it means to compose two lenses to show that this definition to equivalence classes of lenses we need to check the following congruence property we include the proof to give a of the technique proofs of similar lemmas for the other operators on lenses defined below are deferred to the long version lemma composition preserves equivalence if k k and then k k definition the following function on relations is convenient here r × r c c c c c c r c c r proof of if the simulation rk witnesses k k and r witnesses then it is straightforward to verify that r rk × r witnesses k k there are three things to show we wish to show the first line k missing r k missing missing r k missing missing rk k missing missing r missing but the final line is certainly true since rk and r are simulation relations we must show that k putr r k putr so take ck c ck c such that ck c r ck c and choose an input x define the following y ck x ck z c putr y c y ck k putr x ck z c putr y c we can then compute k putr x ck c z ck c k putr x ck c z ck c we need to show that z z and that ck c r ck c since ck rk ck we can conclude that y y and ck rk ck similarly since c r c and y y we know that z z one of our two proof and c r c combining the above facts we find that ck c r ck c by definition of r the other proof burden the proof that k r k is similar to the putr case lemma associativity of composition j k j k the equivalence is crucial here j k and j k are not the same lens because their are structured differently lemma identity arrows the identity lens is a left and right identity for composition id x id y thus symmetric lenses form a category lens with sets as objects and equivalence classes of lenses as arrows the identity arrow for a set x is id x composition is k k proposition lenses f x y f x y c unit missing putr x f x y f y if we were designing syntax for a bidirectional language we might not want to include since we would then need to offer programmers some notation for writing down in such a way that we can verify that they are and derive their however even if it doesnt appear in the surface syntax we will see several places where is useful in about the algebraic theory of symmetric lenses this transformation and several others we will see respects much of the structure available in our category formally is a functor recall that a covariant respectively contravariant functor between categories c and d is a pair of from objects of c to objects of d and the other from arrows of c to arrows of preserve typing identities and composition · the image of any arrow f x y in c has the type f f f x f y respectively f f f y f x in d · for every object x in c we have f id x id f x in d · if f g h in c then f f f g f h respectively f g f f f h in d covariant functors are simply called functors when it can be inferred from the arrow mapping the object mapping is often lemma the operator forms a functor from the category whose objects are sets and whose arrows are isomorphic functions to is id x and definition dual of a lens x y op y x c missing putr y c x c c missing y c putr x c it is easy to see that op is is that for every and that for any f that an is a functor whose source and target categories are identical we can easily show the following lemma lemma the op operation can be lifted to a contravariant on the category lens mapping each arrow to op corollary the category lens is self dual ie equivalent to its own opposite note that this does not mean that each arrow is its own inverse proof the arrow part of op is the lenses we have discussed so far maintain all the information in the domain and codomain it is sometimes useful to discard some information in one direction of the lens the terminal lens does this recording the discarded information in the complement so that the other direction of the lens can restore it definition terminal lens xx x unit c x missing x putr x c x c c c proposition uniqueness of terminal lens lenses with the same type as a terminal lens are equivalent to a terminal lens more precisely suppose k x unit and x c then k of course there may be many pairwise terminal lenses of a particular type for any two x y x with x y its clear that proposition tells us that there are exactly as many arrows x unit as there are elements of x definition lens xx yy x y xy term x term op y the lens does not its two sides at all the complement is x × y inputs are away into one side of the complement and outputs are from the other side of the complement products a few additional notions from elementary category theory will be useful for giving us ideas about what sorts of properties to look for and for structuring the discussion of which of these properties hold and which fail for lenses the categorical product of two objects x and y is an object x × y and arrows x × y x and x × y y such that for any two arrows f z x and g z y there is a unique arrow f g z x × y the pairing of f and g satisfying f g f and f g g it is well known that if a categorical product exists at all it is unique up to isomorphism if a category c has a product for each pair of objects we say that c has products theorem lens does not have products proof idea suppose we have lenses k z x and z y informally the lens k includes a way to take any z and choose a corresponding x and a way to take any x and find a corresponding z many common categories with products include the former but the latter is somewhat unique to lens categories so we focus on the return here the lenses k and together mean we have a way to take any x and choose a corresponding z and we have a separate way to take any y and choose a corresponding z assume that the object part of the product of two objects is simply the cartesian product to complete the product we must construct k z x × y that is we must find a way to take an x and a y and choose a z that corresponds to both simultaneously but there may not be any such z that k gives us from x may not be the same as the z that gives us from y to complete the proof we simply choose x and y carefully to rule out the possibility of a corresponding z regardless of whether we choose x × y to be the cartesian product or to be some other construction proof uniqueness of pairing shows that there is exactly one lens from unit to unit × unit whatever this may be combined with prop this shows that unit × unit is a set again by prop this then means that lenses between unit × unit and any other set x are constant which leads to cardinality once x a more detailed proof appears in the full paper however lens does have a similar but weaker structure a tensor an associative functor for any two objects x and y we have an object x y and for any two arrows f a x and g b y an arrow f g a b x y such that f f g g f g f g and id x id y id xy furthermore for any three objects x y z there is a natural isomorphism xyz x y z xy z satisfying certain coherence conditions which specify that all ways of a are equal a categorical product is always a tensor product by defining f g f g and conversely a tensor product is a categorical product if there are natural transformations xy x y x xy x y y x x x such that subscripts to reduce f g f f g g f f f id id id for all arrows f and g building a categorical product from a tensor product is not the most familiar presentation but it can be shown to be equivalent see proposition in for example in the category lens we can build a tensor product and can also build projection lenses with reasonable behaviors however these projections are not quite natural and above hold only with an additional indexing constraint for particular f and g more while it seems we can define some reasonable natural transformations with the type of that is arrows satisfying law none of them satisfy the final three laws definition tensor product lens kx z y w k c kc × c missing missing putr x y ck c let z ck x ck in let w c putr y c in z w ck c z w ck c let x ck z ck in let y c w c in x y ck c the verification that this forms a lens is straightforward lemma product bijection for f and g in fact the particular tensor product defined above is very well it induces a symmetric monoidal a category with a unit object and the following natural isomorphisms xyz x y z x y z x x x x x x xy x y y x these are known as the and symmetry respectively in addition to the equations implied by these being natural isomorphisms they must also satisfy some coherence conditions given in the full version proposition lens is a symmetric monoidal category in the category set the cartesian product is a with unit as unit and gives rise to a symmetric monoidal category let × × × × be and symmetry natural isomorphisms then the also gives rise to a symmetric monoidal category of lenses with unit as unit and × × × and × as and symmetry respectively knowing that lens is a symmetric monoidal category is useful for several reasons first it tells us that even though it is not quite a product the tensor construction is quite well second it a convenient intuition where lenses built from multiple are as graphical diagrams and suggests a possible syntax for lenses that product components which we briefly discuss in section definition projection lenses in lens the projection is parametrized by an extra element to return when executing a with a missing complement yy y x × y x y id x x the other projection is defined similarly returning to the example in the introduction recall that we wish to create a lens e x y with missing elements m x and m z we now have the machinery necessary to construct this lens e m the extra parameter to the projection eg m or m above needs to be chosen with some care some sets may have clear neutral elements for example a projection from a × b a will likely use the empty list as its neutral element other projections may need additional domain knowledge to choose a good neutral example a projection a × a might use the with the most as its default in some cases the algebraic laws that one wants the projection to satisfy may guide the choice as well the extra parameter prevents full from holding and therefore prevents this from being a categorical product but the following indexed version of the law does hold lemma of projections suppose k xk yk and x y and choose some initial value yi y define xi ci yi missing then k yi xi k the most serious problem though is that there is no diagonal there are of course lenses with the type we need for example or more the lens that the copies of x whenever possible the left one when it cannot this is essentially the merge lens from x x × x c unit x missing inl putr x inl x x inl putr x inr x x x x x x c x x where here the eq function tests its arguments for equality x yields inl if x x and yields x if not however neither of these proposals satisfy all the required laws sums and lists the status of sums has been even more than that of products in particular the injection arrows from a to a b and b to a b do not even make sense in the asymmetric setting as functions they are not so they cannot satisfy a categorical sum of two objects x and y is an object x y and arrows inl x x y and inr y x y such that for any two arrows f x z and g y z there is a unique arrow f g x y choice of f or inl f g f and inr f g g as with products if a sum exists it is unique up to isomorphism since products and sums are dual corollary and theorem imply that lens does not have sums but we do have a tensor whose object part is a settheoretic fact there are at least two interestingly different we can define useful associated structures including a choice operation on lenses as with products a tensor can be extended to a sum by providing injection and natural transformations satisfying a family of equations but these constructions are even away from being categorical sums than what we saw with products the two which we called and in section differ in how they handle the complement when the new value being put is from a different branch of the sum than the old value that was put the sum keeps for both in its own complement and switches between them as needed the sum keeps only one complement corresponding to branch was last put if the next put switches sides the complement is replaced with missing we give just the sum here since it seems more useful the sum can be found in the long version definition tensor sum lens kx z y w k xy c kc × c missing missing putr inl x ck c let z ck x ck in inl z ck c putr inr y ck c let w c putr y c in inr w ck c inl z ck c let x ck z ck in inl x ck c inr w ck c let y c y c in inr y ck c lemma sum bijection for f and g proposition lens is a symmetric monoidal category in set the disjoint union gives rise to a symmetric monoidal category with as unit let be and symmetry natural isomorphisms then the gives rise to a symmetric monoidal category of lenses with as unit and and as and symmetry respectively the types of these natural isomorphisms are xyz x y z x y z x x x x x x xy x y y x unlike the product unit there are no interesting lenses whose domain is the sums unit so this cannot be used to define the injection lenses we have to do it by hand definition injection lenses xx inl x x x y c x × unit y missing x inl putr x x inl inl x x inl putr x x inr y inr y x inr y inl x c x x inl inr y x c x x inr y we also define inr y inl y yx proposition the injection lenses are not natural as with products where we have a useful lens of type x x × x that is nevertheless not a diagonal lens we can a useful conditional lens of type x x x that is nevertheless not a lens in fact we define a more general lens union x y x y a value that is both an x and a y may be put to the left across one of these union lenses in this situation the lens may choose either an inr tag or an inl tag the union lens uses the most recent unambiguous put to break the tie in the long version we also define a variant that looks back to the last tagged value that was put to the right that was in both sets definition union lens x y x y c bool missing false putr inl x c x false putr inr y c y true xy c inl xy false xy y xy x inr xy true xy x xy y c this definition is not symmetric in x and y because to return an inl value if there have been no tie yet because of this preference union cannot be used to construct a true however there are two useful related constructions definition switch lens x x x definition case lens kx z y z x y z k a case lens appears in the long version lists we can also define a variety of lenses operating on lists we only consider mapping here because in the next section we show how to obtain this and a whole variety of other functions on lists as instances of a powerful generic theorem but it is useful to see one concrete instance first write x for the set of lists with elements from the set x write for the empty list and for the list with head x and tail xs write x for the set of infinite lists over x when x x and ss x write x for the infinite list with head x and tail ss write x x for the infinite list of xs definition list mapping lens x y map x y c c missing missing putr x c let x xm x in let c c in let yi ci putr xi ci in y ym c cm cm similar as we saw in section there is also a variant of the list mapping lens indeed this is the one that corresponds to the known list mapping operator on asymmetric lenses additionally the map lens gives us the machinery we need to complete the first example in the introduction simply define e iterators in functional programming mapping are usually seen as instances of more general fold patterns or defined by general recursion in this section we investigate to what extent this path can be followed in the world of symmetric lenses allowing general recursive definitions for symmetric lenses may be possible but in general change when unfolding a recursive definition this means that the structure of the complement of the recursively defined function would itself have to be given by some kind of fixpoint construction preliminary investigation suggests that this is possible but it would considerably the top of the general of having to deal with therefore we choose a different path we identify a fold combinator for lists of the view of lists as initial algebras we show that several important lenses on be defined with the help of a fold and that due to the of lenses folds can be composed to yield general recursive patterns in the style of we also discuss iteration patterns on trees and argue that the methodology carries over to other polynomial inductive datatypes lists let fold unit x be the bijection between lists and lists fold takes inl to and inr x xs to note that unit x is then a arrow in the category lens definition an algebra on a set z is an arrow unit z and a function w z n such that z c inr x z c implies wz wz we write tx for the functor that sends any lens k to id unit id x k the function w here plays the role of a termination measure we will be producing a stream of values of type z which we would like to guarantee eventually ends theorem for algebra on z there is a unique arrow it x z such that the following diagram tx x tx it tx z x it z proof sketch we choose the complement of it to be c so that the of the two of the square are isomorphic we then take commutativity of the diagram as a for a recursive definition of both putr and the length of the list in the case of putr and the weight function in the case of are used as ranking functions establishing totality of the recursive definitions one must then prove again by induction on these ranking functions that the square does indeed commute to show uniqueness we take another lens k which satisfies the above commutativity diagram the diagram induces an unfolding of ks complement into an infinite sequence of that satisfy a pairwise correspondence property with the infinite sequence in it s complement we can then show that putr and preserve this correspondence which lets us construct a relation the equivalence of k and it in the terminology of universal algebra an algebra for a functor f from some category to itself is simply an object z and an arrow f z z an arrow between f algebras z f and z f is an arrow u z z such that f u f u f the f algebras thus form a category themselves an initial f algebra is an initial object in that category an initial object has exactly one arrow to each other object and is unique up to isomorphism f algebras can be used to model a wide variety of inductive datatypes including lists and various kinds of trees using this terminology theorem says that is an initial object in the consisting of those tx algebras for which a weight function w is available let us consider some concrete instances of the theorem first if k x y is a lens then we can form an algebra on y by composing id unit k id y unit unit y with unit y y a suitable weight function is given by the induced lens it x y is the lens of the familiar list mapping function in fact substituting the lens e x × y y × z from the introduction for k in the above diagram we find that it is the variant of the lens e again we are ignoring the important question of alignment here a map lens could perform a more sophisticated alignment analysis to associate similar items in a sequence of puts and recover more appropriate data from the complement the process described above results in a simple alignment scheme second suppose that x x x and let z be x × x writing xi for xi × xi we can define isomorphisms f x x × x × x x x x × x x × x g unit x x x × x x × x by the sum and unfolding the list type for f and by factoring the polynomial and folding the list type for g then we can create unit x x × z z id unit id unit id xx a suitable weight function for is given by xs the lens it x x x × x that we obtain from iteration partitions the input list in one direction and uses a stream of booleans from the state to put them back in the right order in the other direction indeed it is exactly the partition lens described in the examples composing it with a projection yields a filter lens alternatively the filter lens could be obtained directly by a slightly consequently we now have the machinery we need to define comp from the introduction filter partition comp filter filter op corollary suppose is an algebra on w and is an algebra on z then there is a lens w z such that the following diagram tx w k w tx tx z z proof define as the composition it one can think of as a recursive definition of a lens the lens k tells whether a recursive call should be made and if so produces the argument for the recursive call and some auxiliary data the lens then describes how the result is to be built from the result of the recursive call and the auxiliary data this gives us a lens version of the pattern from functional programming unfortunately we were unable to prove or the uniqueness of we have not formally studied the question of whether it is actually an initial algebra ie whether it can be defined and is unique even in the absence of a weight function however this seems because then it would apply to the case where z is the set of finite and infinite x lists and the obvious lens the component of it would then have to an infinite list which would break the square other datatypes of theorem and corollary are available for a number of other functors in particular those that are built up from variables by and × all of these can also be as containers see section but the iterator and patterns provide more powerful operations for the construction of lenses than the mapping operation available for general containers moreover the universal property of the iterator provides a modular proof method allowing one to deduce equational laws which can be to establish directly because of the definition of equality as behavioral equivalence for instance we can immediately deduce that list mapping is a functor containers on the other hand datatypes such as labeled graphs that are not initial algebras iterators with multiple arguments the list iterator allows us to define a lens between x and some other set z but theorem cannot be directly used to define a lens between x × y and z think of y as modeling parameters in standard functional programming a map from x × y to z is to a map from x to y z so iteration with parameters is subsumed by the case unfortunately lens does not seem to have the function spaces required to play this trick therefore we introduce the functor z y x × z and notice that x × y x × y just as before an algebra for that functor is a lens z z together with a function w z n such that z c inr x z c implies wz wz as an example let y z x and define x x c missing bool true putr inl xs b xs true putr inr x xs b false b true false inl true inl true inr x xs false iteration yields a lens x × x x that can be seen as a bidirectional version of list concatenation the square for the iterator corresponds to the familiar recursive definition of concatenation ys ys and ys ys in the bidirectional case considered here the complement will automatically retain enough information to allow splitting in the direction we can use a version of corollary for this data structure to implement tail recursive constructions consider for instance the algebra k x x × x x × x where acc true inl acc true acc true inr xs true acc xs false inr acc xs false together with the algebra x x x this a bidirectional version of the familiar tail recursive list reversal that sends acc xs to acc trees for set x let be the set of binary trees given inductively by leaf and x x r r t consider the unit x × z × z let c denote the obvious lens an algebra is a lens z z and a function w z n with the property that if z c inr x zl c then wz and wz the lens c is then the initial object in the category of algebras that is every algebra on z defines a unique lens in z consider for example the concatenation lens x × x x let unit x × x × x x be the lens obtained from by with the and the terminal lens term intuitively this lens sends inl to and x xs xs to using the complement to this operation properly this lens forms an example of a tree algebra with number of nodes as weight functions and thus iteration a lens x which does a preorder traversal keeping enough information in the complement to a tree from a modified traversal the pattern can also be applied to trees yielding the ability to define symmetric lenses by ie by dispatching one call to two parallel recursive calls whose results are then appropriately merged containers the previous section suggests a construction for a variety of operations on datatypes built from polynomial functors narrowing the focus to the very common map operation we can generalize still further to any kind of container functor ie a normal functor in the terminology of or an analytic functor in the terminology of these structures are also related to the types of and definition container a container consists of a set i together with an family of sets b i set each container i b gives rise to an fib on set whose object part is defined by ii bi x for example if i n and bn n then is x up to isomorphism or if i is the set of binary trees with trivial labels and bi is the set of nodes of i then is the set of binary trees labeled with elements of x in general we can think of i as a set of shapes and for each shape i i we can think of bi as the set of positions in shape i so an element i f consists of a shape i and a function f assigning an element f p x to each position p bi the arrow part of fib maps a function u x y to a function given by i f i f u now we would like to find a way to view a container as a functor on the category of lenses in order to do this we need a little extra structure definition a container with ordered shapes is a pair i b satisfying these conditions i is a partial order with binary meets we say i is a of j whenever i j b is a functor from i viewed as a category with one object for each element and an arrow from i to j iff i j into set when b and i are understood we simply write bi for bi i b if b bi and i i if i and i are both of a common shape j and we have positions b bi and b bi with bj b j then there must be a unique such that b bi and b bi thus such b and b are really the same position in other words every diagram of the following form is a bi i i bi i bi bi i i bi j bi bi j bj if i j we can apply the instance of the diagram where i i and hence i i i and deduce that bi j bi bj is always injective for example in the case of trees we can define t t if every path from the root in t is also a path from the root in t the arrow part of b then positions of a smaller tree into positions of a tree the meet of two trees is the greatest common subtree starting from the root definition container mapping lens x y fib fib x fib y c t ii bi c i i i i bbi ti bi missing putr i f t let f b fst putr f b in let t if b bi j bj b then snd putr f bi in else i f t similar will note that c is the limit of the contravariant functor i bi c alternatively we can c as the function space d c where d is the of the functor b concretely d is given by ii bi modulo the equivalence relation generated by i b i b whenever i i and b bi i b for the case of lists this mapping lens coincides with the map that we obtained from the iterator in section in general two pieces of data synchronized by one of these mapping lenses will have exactly the same shape any shape change to one of the sides will be precisely in the other side for example the tree version of this lens will the deletion of a node by deleting the node in the same position on the other side we believe it should also be possible to define a version where the complement is just fib c asymmetric lenses as symmetric lenses the final step in our investigation is to formalize the connection between symmetric lenses and the more familiar asymmetric ones and to show how known constructions on asymmetric lenses correspond to the constructions we have considered write x a y for the set of asymmetric lenses from x to y using the first presentation of asymmetric lenses from section with get put and create components definition every asymmetric lens can be embedded in a symmetric one x a y sym x y c f y x y y y y missing create putr x f fx y f let x f y in x fx here means x x as the source of an asymmetric lens and therefore as having more information than y we can understand the definition of the complement here as being a value from x stored as a closure over that value the presentation is complicated slightly by the need to accommodate the situation where a complete x does not yet when defining which case we can use create to an x value out of a y value if necessary definition asymmetric lenses here are several useful asymmetric lenses based on string lenses from we give only their names and types here full definitions appear in the long version we use xy to stand for any asymmetric lens x a y x a x xy yz x a z x a unit whenever x x xy · x × z a y × w xy x z a y w xy x a y theorem the symmetric of these lenses correspond to definitions from earlier in this paper copy sym x id x k sym sym sym x term x k · sym sym k sym f sym union sym sym the first two show that sym is a functor the f operator is the variant of see the long version for the full definition we that there might be an asymmetric fold construction similar to our iteration lens above satisfying an equivalence like fold sym it sym but have not explored this carefully the sym functor is not is there are some lenses which are not the image of any asymmetric lens injection lenses for example have no in the category of asymmetric lenses nor do either of the example lenses presented in the introduction however we can characterize symmetric lenses in terms of asymmetric ones in a slightly more elaborate way theorem given any arrow of lens there are asymmetric lenses k k such that op to see this we need to know how to a symmetric lens we can view a symmetric lens as a pair of asymmetric lenses tail to tail whose common domain is consistent triples for any lens x y define s x y c x × y × c putr x c y c now define x y r s a x y c x x y c let y c putr x c in x y c create x let y c putr x missing in x y c the definition of l s a y is similar proof of given choose k r and k l related work there is a large literature on lenses and related approaches to propagating updates between connected structures we discuss only the most closely related work here good general of the area can be found in connections to the literature on view update in databases are in the first symmetric approach to update propagation was proposed by and followed up by and et al suggests modeling synchronization between two sets x and y by a consistency relation r x and two consistency x × y x and x × y y such that x y r y and x r x y always hold and such that x r y implies x y x and x y y the main advantage of symmetric lenses over consistency is their closure under composition indeed all of the authors note that in general consistency do not compose and view this as a suppose that we have relations r x × y and r y × z maintained by and resp if we want to construct a for the composition r r we face the problem that given x x and z z there is no canonical way of coming up with a y y that will allow us to use either of the existing functions concretely gives the following counterexample let x be the set of nonempty context free grammars over some alphabet and let y be the set of words over that same alphabet let r x × y be given by g r x x lg it is easy to define computable functions making this relation a constraint composing this relation with its opposite yields an undecidable relation namely whether the intersection of two contextfree grammars is nonempty so there cannot be computable functions we can transform any constraint into a symmetric lens as follows take the relation r itself viewed as a set of pairs as the complement and define x x y x y x x y and similarly for putr if we compose such a symmetric lens with its opposite we obtain as the complement and for example putr x x y y x x x y x x y x y x x y for counterexample we would have of the form g w w g with w lg and w lg putr ing a new grammar g through the composed lens yields the complement g w w g where w is w if w lg and some default otherwise and where g g if w lg and sw where s is the start state otherwise we observe that there is a property of lenses analogous to requirement that x r y implies x y x this property is not necessarily preserved by composition and in particular the lens described above for languages does not have it using a chain of consistency in such a situation to achieve a similar effect however the properties of such chains have not been explored for asymmetric lenses a number of alternative laws have been explored some of these are weaker than ours for example a number of papers from a community of researchers based in replace the law with a somewhat law a range of useful behaviors for lenses that duplicate information it would be interesting to see what kind of categorical structures arise from these choices the proposal by et al is particularly interesting because it also the idea of conversely stronger laws can be such as the law discussed by foster et al a different foundation for defining lenses by recursion was explored by foster et al using standard tools from domain theory to define monotonicity and continuity for lens combinators parametrized on other lenses the main of this approach is that the required manual proofs that such recursive lenses are total tend to be somewhat by contrast we expect that our approach can be equipped with automatic proofs of totality that is choices of the weight function w in many cases of interest conclusions and future work we have proposed the first notion of symmetric bidirectional transformations that supports composition up the study of symmetric bidirectional transformations from a perspective we have explored the category of symmetric lenses which is and has the category of and that of asymmetric lenses each as full we have the structure of this category and found it to admit tensor product structures that are the cartesian product and disjoint union on objects we have also investigated datatypes both inductively and as containers and found the category of symmetric lenses to support powerful mapping and folding constructs syntax although we have focused here on semantic and algebraic foundations many of our constructions have a straightforward syntactic realization in particular it is easy to give a interpretation to all the constructions in sections to including lenses over lists these could easily be used to build a symmetric version of more interesting would be to eliminate builtin lists and instead obtain lenses over lists and other structures mapping of lists transforming trees into lists solely by using the combinators derived from the structure we have to this two further fine points need to be considered first we would want an automatic way for discovering weight functions for iterators we believe that a straightforward termination analysis based on unfolding similar to the one built into coq could help but the details remain to be checked and second we must a formal syntax for programming with containers surprisingly the existing literature does not seem to contain such a proposal more it is a wellknown result that symmetric monoidal categories are in correspondence with diagrams and with firstorder linear lambda calculus we would like to exploit this correspondence to design a syntax for symmetric lenses and perhaps also a language the linear lambda calculus has judgments of the form xa t a where a an are sets or possibly syntactic type expressions and where t is a linear term made up from basic lenses lens combinators and the variables x xn this could be taken as denoting a symmetric lens a · · a for example here is such a term for the lens from section a a a match z with inl inr a al ar ar the interpretation of such a term in the category of lenses then takes care of the appropriate insertion of lenses for and tensor products as states one benefit of treating explicitly is that it the way to a stateful presentation of lenses the idea is that the complement of a lens can be thought of as its local part of the heap that belongs to it an obvious next step is that instead of the lens components taking the local storage as an argument and returning an updated version as a result they can just onto it themselves internally in mutable variables the types of the put operations then become just putr a b and b a where the is now a programming language function type with the usual implicit treatment of the heap this avoids the given c each time we propagate an update and a new c to yield as a result improving the efficiency of the implementation an additional improvement comes from the next potential extension alignment and lenses as we mentioned in section dealing correctly with alignment of structured information is crucial in practice this issue has been extensively explored in the context of asymmetric lenses and it seems it should be possible to adapt existing ideas such as dictionary lenses and matching lenses to symmetric lenses an even better approach might be to change the fundamental nature of lenses so that instead of working directly with entire structures they work with of changes to the structures these can arise from simple judgments as in this paper from heuristics from within the data itself or perhaps even from user interaction the lens itself doesnt need to know anything about this many of our basic constructions can be adapted to by taking the domain and codomain of a lens to be monoids of edit operations instead of sets and then for each lens construction defining an appropriate edit monoid from the monoids of its components for example an edit for a pair lens is a pair of edits for the left and righthand sides of the pair however more thought is required to make this scheme really work applying this idea leads to expressive edit languages for structures like lists in particular we would like to see insertion and deletion as edit operations on lists and and the like for trees etc currently we believe that containers are a promising framework for this algebraic structure we have shown that the category of symmetric lenses does not have products or sums one suggests that it may be interesting to explore placing a partial order on the the of our category the sets of arrows between pairs of objects perhaps this extra structure would allow us to define variants of products and sums in which the required equations do not hold as equalities but as inequalities acknowledgments we are to foster for discussions of many points especially about the category of lenses and to both and for helpful comments on of the paper our work is supported by the national science foundation under grant foundations for xml view update references m t and n categories of containers in foundations of software science and computation structures pages ­ springer michael and containers constructing strictly positive types theor comput sci ­ abramsky and introduction to categories and categorical logic in bob editor new structures for springer and update semantics of relational views acm transactions on database systems ­ december m j foster michael and benjamin c pierce matching lenses alignment and view update in acm sigplan international conference on functional programming icfp september jeffrey a and benjamin c pierce relational lenses a language for views in principles of database systems extended version available as university of pennsylvania technical report j foster benjamin c pierce and alan lenses for string data in acm symposium on principles of programming languages popl san francisco california january j foster hu and james f bidirectional transformations a perspective in richard f editor volume of lecture notes in computer science pages ­ springer isbn z k and m algebraic foundations and the tile notation in proceedings of the workshop on comparison and of software models pages ­ ieee computer society algebraic models for bidirectional model synchronization in and editors models volume of lecture notes in computer science pages ­ springer isbn j foster michael b t moore benjamin c pierce and alan combinators for bidirectional tree transformations a approach to the view update problem acm transactions on programming languages and systems may extended abstract in principles of programming languages popl j foster and benjamin c pierce lenses in acm sigplan international conference on functional programming icfp september john foster bidirectional programming languages phd thesis university of pennsylvania december r two applications of analytic functors theoretical computer science ­ s z hu h and k a compositional approach to bidirectional model transformation in new ideas and results track of st international conference on software engineering track s z hu k h k and k graph transformations in acm sigplan international conference on functional programming icfp september hu mu and a editor for developing structured documents based on bidirectional transformations in partial evaluation and program manipulation pages ­ extended version to appear in higher order and symbolic computation c and j robin b types and shape polymorphism in editor esop volume of lecture notes in computer science pages ­ springer isbn a et de structures pages ­ hu and bidirectional interpretation of in acm sigplan symposium on partial evaluation and program manipulation nice france pages ­ new york ny usa david a linux configuration api february available from k z hu k m and m transformation based on automatic derivation of view complement functions in acm sigplan international conference on functional programming icfp pages ­ acm press new york ny usa designing constraint for user interaction manuscript e m and r functional programming with lenses and barbed in functional programming languages and computer architecture pages ­ springer mu hu and an algebraic approach to bidirectional updating in symposium on programming languages and systems pages ­ november bidirectional model transformations in semantic issues and open questions in international conference on model driven engineering languages and systems models tn volume of lecture notes in computer science pages ­ springerverlag isbn a of bidirectional model transformations of towards an algebraic theory of bidirectional transformations in graph transformations th international conference september proceedings page springer categorical programming with inductive and coinductive types phd thesis y h z hu and m supporting parallel updates with bidirectional model transformations theory and practice of model transformations pages ­ hu and towards automatic model synchronization from model transformations in international conference on automated software engineering ga pages ­ 