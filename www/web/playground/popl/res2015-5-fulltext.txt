higherorder approximate relational refinement types for mechanism design and differential privacy software institute university of university of pennsylvania complete popl consist well easy to abstract mechanism design is the study of algorithm design where the inputs to the algorithm are controlled by agents who must be to report them unlike typical properties it is not sufficient for algorithms to merely satisfy the properties are only useful if the agents also believe this fact verification is an way to agents that the properties actually hold but mechanism design several unique challenges interesting properties can be sophisticated relational properties of probabilistic computations involving expected values and mechanisms may rely on other probabilistic properties like differential privacy to achieve their goals we introduce a relational refinement type system called hoare for verifying mechanism design and differential privacy we show that hoare is sound wrt a denotational semantics and correctly models p privacy moreover we show that it subsumes dfuzz an existing linear dependent type system for differential privacy finally we develop an implementation of hoare and use it to verify challenging examples of mechanism design including and games and new proposed examples from differential privacy categories and subject descriptors d programming languages formal definitions and d software engineering verification keywords program logics probabilistic programming introduction when designing algorithms we usually assume that the inputs are correctly reported however in the real world inputs may be provided by people who may want to influence the outcome of the algorithm mechanism design is the field of algorithm design where the inputs to the algorithm often called a mechanism are controlled by agents who may manipulate what their inputs in this setting it is not enough to design an algorithm which behaves correctly on correct input the design of the mechanism permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page for components of this work owned by others than the authors must be abstracting with credit is permitted to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission andor a fee request permissions from popl january ­ copyright is held by the publication to acm acm must agents to provide their correct inputs to the algorithm the canonical application of mechanism design is design in an the algorithmic problem can be very simple for instance allocate some set of a set of n agents so as to their sum value for the the inputs to the algorithmic problem are simply the agents values for the but these are unknown to the algorithm designer instead the mechanism must to agents to actions compute a price that each agent must pay are generally designed so that the allocation and rules agents to their true value for the no matter what their do an that satisfies this property is said to be strategy compatible or simply this is among the most important solution about behavior of mechanism design beyond mechanisms design can be used to handle more abstract games where agents have a variety of actions and a utility function based on the actions selected by all agents in most settings agents do not have any strategies and so we must be satisfied with weaker solution concepts like informally a set of actions one for each player forms a if no player can increase her utility to a different action so long as no other player the hope is that agents will decide to play at an no single agent can gain by however can be an prediction of behavior first of all they are generally not unique agents must coordinate to play at a single but different agents might prefer different outcomes second of all in games with a large number of players agents generally do not have complete knowledge about utility functions and so may not even know what the of the game are to help players coordinate on an one approach is to design an selection mechanism agents are to report their utility functions to some and the suggests some action for them to play agents are so they are free to their utility function or the a will agents to report and follow the a promising and recent tool for design is differential privacy the original goal of differential privacy was to protect privacy in data by ensuring that the same query on two databases in a single data leads to results that are close in some sense seen another way differential privacy limits any influence on the result this can be contrast this with strategies in a no agent can gain by no matter what the other players play quite useful as a tool for mechanism design if the satisfies differential privacy agents will have little to from behavior since they can only change the selected to a small degree while this is a clean idea there can be practical issues currently proposed mechanisms are complex enough that agents may not be able to verify the properties of the in general if agents do not believe the properties of a mechanism then they may behave in ways or to indeed designers of an public have as a key features should be apparent to any agent while this is a desirable goal for simple mechanisms it is hard to achieve for complex mechanisms for these cases we propose an alternative approach rather than simplify the mechanism use formal verification to automatically check properties however mechanism design serious challenges for verification first both differential privacy and properties are relational properties of programs which reason about more than one run of the same program for instance states that the of an agent in a run when she reports is at least its in a run where she reports arbitrarily second properties are significantly more involved than typical program verification properties for randomized mechanisms properties are stated in terms of expected value rather than more standard equivalences or relations between distributions finally properties of mechanisms rest on nontrivial interactions between properties and differential privacy so their formal verification must be in a framework that is expressive enough to reason about differential privacy properties and interactions of the two contributions to handle these challenges we present hoare a typebased framework for relational properties of higherorder probabilistic programs like differential privacy and approximate hoare is based on refinement types an expressive type discipline that captures finegrained properties of computations by types with assertions and several features relational refinements refinements at higher types where assertions constrain the behavior of functions and a representation of approximate refinements for probabilistic computations we demonstrate the theoretical and practical of hoare through the following contributions · we demonstrate that hoare achieves desirable properties like soundness with respect to a denotational semantics § and semantic subtyping as a contribution of independent interest we show that the logical interpretation of nontermination adopted by existing refinement type systems is inconsistent with semantic subtyping when refinements at higher order types are allowed · we define a typepreserving embedding of dfuzz a linear dependent type system for differential hoare and recover soundness of dfuzz from soundness of hoare § the embedding illustrates how semantic subtyping and refinements at higher types combine to logical relations in hoare · we implement a typechecker for hoare and verify examples drawn from differential privacy and mechanism design for instance we verify properties of randomized and an selection algorithm for games based on differential privacy the implementation is fully automated assertions using smt solvers we discuss related work in § and conclude with possible future directions in § relational refinements informally we will establish properties of programs by using refinement types an expressive typing discipline introduced by and pfenning as is typical in refinement type systems we type expressions in two steps first we define a simply typed system in which the type of probabilistic computations are modeled using a probability monad for example the expected value of a positive real valued function wrt a distribution is modeled by a function e of type s Ñ pt Ñ rq Ñ r where r denotes the type of positive reals and r denotes r extended with next we define a relational refinement type system for simply typed expressions relational refinements specify properties of pairs of values via types of the form tx t u where is a relational assertion a logical formula that can express facts involving the left instance xy and the right instance x of x for instance the type tx n xy ´ x models pairs of natural numbers which differ by at most k both traditional and relational refinement type systems eg often refinements at higher types like tx t u where t is a function type however such relational refinements are convenient to model properties of probabilistic operators for instance given a distribution µ s the following types for e µ capture monotonicity and linearity of expectation tf t Ñ r Ñ tr r ry ru tf t Ñ r Ñ tx r xy relational refinements can also be used to model relations between pairs of distributions like differential privacy a probabilistic computation f t Ñ u is p private wrt an relation if for every t t p t and for every subset of outputs e t t pr rx p es q pr rx p es t t the parameters and are nonnegative real numbers controlling the strength of the privacy guarantee using relational refinement types the type of p private computations from t to u is tx t xy xu Ñ s u where max pr rx p es ´ q pr rx p es eu is the distance between two distributions µ and µ over u however this modeling is not appropriate for practical program verification indeed the definition of distance uses probabilities and it is possible to formalize basic properties for these concepts but more advanced reasoning which is required for some examples is beyond the of smt solvers instead we introduce a probabilistic with a type constructor of the form m and two operators unit and bind with respective types unit t Ñ m rt s bind m rt s Ñ pt Ñ m ru sq Ñ m ru s the main advantage of the versus the explicit formalization of distance is that all reasoning about probabilities is confined to the definition of valid judgment and to the proof of soundness of the monadic rules on the other hand the refinement types t and u remain standard relational refinements and do not need to refer to probabilities or the interpretation of m is based on a lifting operator l that turns a relation on tt into a relation l pq on we will provide the formal definition in § a useful property of lifting is that two distributions are related by l pq iff their distance is upper bounded by in particular p private computations can be modeled by the relational refinement tx t xy xu Ñ m u yy which leads to simpler verification conditions over individual outputs rather than sets of outputs another advantage of this approach is that the type of the bind operator captures the sequential composition theorem of differential privacy and that it leads to an elegant type system in which quantitative reasoning related to differential privacy is confined to the rules of the this is in contrast to some prior work where quantitative reasoning is in all rules of the system the last component of hoare is a monad to model computations while this is quite standard this approach is key to semantic subtyping and refinements at higher types we elaborate on this point next an aside on nontermination and refinement types exploiting the power of refinement types requires the ability to draw useful from assertions these are typically represented in typing derivations via a subtyping relation and applied with a special typing rule called subsumption that changes the type of an expression to an arbitrary supertype the subtyping relation should be complete wrt the denotational semantics of the type property known as semantic subtyping however extending most existing refinement type systems with semantic subtyping can lead to an inconsistency because semantic subtyping conflicts with typical logical of nontermination inconsistency can arise both in and relational settings let us consider the case here inconsistency itself as an expression of type tx n in the empty context with the expression reducing to a value existing refinement type systems such as f f and assign the type tx n x u Ñ ty n to any recursive function f that does not terminate on values x such as for instance letrec g x case x with r ñ s y ñ g xs on the other hand semantic subtyping the equivalence tx t u Ñ ty u u » tf t Ñ u x t rf where we write t » u iff t u and u t it follows that f has the problematic type f tx n x u Ñ ty n f tg n Ñ n x nx f tg n Ñ n x f n Ñ tx n f tx n n where the first three are by subsumption the first two by and the second by the standard rule of consequence replacing an assertion by a logically weaker one this example shows that a naive combination of semantic subtyping with refinements at higher types is inconsistent with the use of k to model computation we will follow a more semantically correct approach by modeling nontermination as a monadic effect using a monad that distinguishes nonterminating and terminating computations in this way the inconsistency is avoided we conclude this discussion by noting that this counterexample is independent of the evaluation strategy accordingly it the recent observation by et al that a logical interpretation of nontermination is unsound for callbyname even in languages without higherorder refinements et al solve the issue by size types into refinement types to enforce termination the hoare system expressions hoare is a relational type discipline for a calculus with inductive types unbounded recursion and monads for probabilities and for readability we only present our calculus with some fixed inductive types let x tx y u be a infinite set of variables the set q of expressions with variables in x is defined as follows e x n p n p r pq ¨ ¨ false true e e x e let x e in e f x e if e then e else e case e with r ñ e x x ñ es x e in e e x e in e where m p and r stands for r augmented with the we write pcf for q when x is clear from the context most of the syntax is standard the expressions e and x e in e corresponds to the unit and the multiplication of the probabilistic monad similarly and x e in e corresponds to the unit and the multiplication of the monad finally we have two expressions for building recursive definitions one for terminating programs the other for non terminating ones we distinguish between them by means of the m p hoare distinguishes between expressions and relational ex the former are used in the subject of typing judgments and correspond to the actual programs to which we can assign se the latter are used in assertions definition expressions and relational expressions let xr and xp be two disjoint infinite sets of relational and plain variables associated with every relational variable x p xr we have a left instance xy and a right instance x we write xr for x u and x for xr y xp the set of hoare expressions e is the set of expressions in q the set of hoare relational expressions e is the set of expressions in q where only variables can be bound hoare types we introduce the types of hoare in two steps first we introduce simple types for simplicity we restrict instances of inductive types to base types then we introduce relational refinement types which express properties about two interpretations of an expression definition types the sets ty and of simple types and core simple types are defined as follows p ty r mr s cr s Ñ r r p b n r r r list the type mr s corresponds to the probability monad over the type while the type cr s corresponds to the monad over the type besides the standard function types Ñ the type language includes the unit type booleans integers reals and lists relational types extend the grammar of simple types with relational refinements and use a dependent function type rather than standard function types definition the sets of relational types t tt u u and assertions a t u are defined as follows t u p t r m rt s s px t q t tx t u p a q px q px p xp q q px t q px p cp nq e e e e c tj k where e p e and q p t du the definitions of relational types and assertions are mutually recursive for the latter the constructors and m rs capture the monad and the probability for relational refinements the type px t q u corresponds to the dependent type product of t over u indexed by x as usual we write t Ñ u for px t q u when x does not occur free in u a type of the shape tx t u refines the type t using the assertion in both dependent and refinement types we require the bound variable to be relational x p xr assertions are built from primitive assertions using the standard connectives and quantification we allow quantification over both relational and plain variables primitive assertions are equalities and inequalities over relational expressions the notions of substitutions are defined largely as usual substitutions bind pairs of expressions to relational variables and involve a special treatment of refinement type constructors which must handle the relational expressions for instance for a substitution ty ÞÑ pe we define tx t u x t yy y ÞÑ ÞÑ ey e where ey resp e is obtained from e by replacing all the free variables x of e by xy resp x standard typing we define the simply typed layer of hoare and prove its soundness wrt a denotational semantics both the type system and the semantics are mostly standard static semantics the typing rules are for the two different letrec of our language f Ñ x e Ñ letrec letrec f x e Ñ f Ñ x e Ñ sn guard f x e Ñ the rule letrec handles unrestricted recursion and requires that the output type be in the monad on the contrary the rule does not impose any restriction on the type but the expression must pass a termination guard we leave the termination guard unspecified possible forms of enforcing the guard include types and syntactic criteria denotational semantics the denotational semantics is largely standard core types are interpreted in the standard way the interpretation of types a and cpo semantics in order to accommodate the monad definition interpretation of types the interpretation of a type p ty is inductively defined as follows mr s Ñ r discrete xp µ x u cr s k Ñ where the support of a distribution µ is the set of elements for which µ takes a nonzero value and represents a cpo cr s e x e in e k if d k e otherwise where d e cr s e mr s x ÞÑ if x e otherwise x e in e d ÞÑ gp p e e f x e Ñ f Ñ q where f f Ñ x e Ñ fd figure interpretation of pcf expressions continuous function space when the codomain is equipped with a cpo structure and the function space otherwise types cr s and Ñ where is interpreted as a cpo are interpreted as cpos however types of the form mr s are not interpreted as cpos because their interpretation is based on discrete distributions we can now define the denotational interpretation of expressions definition a valuation is any finite map from x to a valuation an environment written if x p x p x we denote by e the interpretation of e with respect to the definition of the interpretation is mostly standard figure gives the interpretation of the monadic constructions and of the two letrec operators as expected the static semantics is sound wrt the denotational one lemma if e and then e p refinement typing the key point of relational typing is its ability to relate a pair of we call the left and right relational assertions that appear as refinements in types for instance the type px nq ty n yy xy y xu represents a pair of integer to integer functions where the left function adds to argument and the right one returns its argument in this section we define the refinement type system of hoare in three steps first we give an interpretation for assertions and refinement types second we define a subtyping relation that is complete wrt this interpretation finally we define the refinement type system and prove its soundness wrt a denotational semantics we start by defining relational contexts definition a relational environment g is any finite sequence of relational bindings px t q st a variable is never bound twice and only variables of xr are bound we use h to denote the empty environment a relational environment defines a finite mapping from it would have been possible to interpret them as and to define another letrec operator for probabilistic computations at the cost of replacing by q q in the typing rule for bind however our examples do not require this additional generality cp nq cp n q e e e e e e e e px q dp px t q d px q pd d qp t z dp ÑÞ ÑÞ d d d px t q z t ÞÑ ÞÑ d d where c stands for the operator figure relational interpretation of assertions pd p r pd p r pd p t ÞÑ ÞÑ d d pd p tx t u pf fq p t Ñ u pd p t p u ÑÞ ÞÑ d d pf fq p px t q u pd p t y pd p s µ µ p s l p t q µ µ p m rt s figure relational interpretation of types variables to relational types we write for the application of the finite map g to x we define a type erasure function ¨ from relational to simple types which maps dependent products to function spaces and refinements and the of the probabilistic monad the definition of ¨ extends recursively to relational environments for any x p we also define the relational type erasure of g written g by iff x p where s p ty u note that given a relational binding px t q the relational type erasure px t q gives the environment t x t q next we interpret assertions and refinement types definition relational interpretation of refinement types we say that a valuation a relational environment g written g if g and x p xq p figures and define the relational interpretation p tj resp t p t of an assertion resp of a relational type t wrt a valuation resp g assertions are interpreted in the expected way where some care is needed for quantifiers since the interpretation distinguishes between binders for relational and plain variables relational types are interpreted as sets of pairs of elements of the interpretation of the erased type formally a pair pd is in the relational interpretation of a refinement tx t u if the assertion holds in a relational context where d and d are assigned to xy and x respectively the relational interpretation of the dependent product is defined in a logical relation style it relates function elements f f that map related elements d d in t to related elements in u ÞÑ ÑÞ d d a monadic type s is interpreted as the set of pairs in the interpretation of t plus the pair pk the type m rt s is interpreted using a lifting construction l that turns a relation on tt into a relation l pq on definition lifting of a relation given t t we have l pq µ µ iff there is a distribution µ p ts such that µ pa implies pa p µ µ µ µ and where µ x y µ px and µ y x µ px we next define subtyping between refinement types definition subtyping the subtyping relation g t u is defined by the rules of figure gt g t t gt u v g t v gt u g t list u list gt u g s s g tx t u g tx t u t g t u g x u g x t ñ g t tx u u gt u g i r g i r g x t ñ g m rt s m ru s g t t g x t u u g px tq u px tq u figure relational subtyping a subtyping judgment g t u relates only relational types that erase to the same simple type ie t u the rules and allow and refinements the rule allows weakening the indices of the probabilistic and the underlying refinements other rules are mostly standard the definition of subtyping the relational counterpart of the equivalence discussed in § more generally it is possible to define a normalization function that converts any refinement type t into an equivalent type tx u u where u is a simple type ie does not contain any refinement the existence of the normalization function immediately entails semantic subtyping finally we present the hoare typing rules definition relational typing the refinement typing relation g e e t is defined in figure we use e t as a shorthand for e e t we briefly comment on some of the typing rules as in relational hoare logic we distinguish between synchronous and asynchronous rules the latter operate on both expressions of the x p var g x g x t e u abs g x e px t q u g e px t q u g e t app g e e u tx ÑÞ eu g f px t q u x e px t q u g px t q u sn guard g f x e px t q u g px t q s g f px t q s x e px t q s letrec g letrec f x e px t q s gt g e t case g e r list g ñ q pe q g x r y r list xy yy e x e t g case e with r ñ e x y ñ es t g e t g s g e g g x t e g x e in e g r g r g e t g e m rt s g e m g m g x g x e in e t e m m g e t g t u sub g e u e Ñ e g g e e e e t t g t g e r list g e t g u e e t g x r y r list xy e e t g case e with r ñ e x y ñ es e t figure relational typing selected rules judgments whereas the former operate on a single expression and can relate expressions that have different shapes synchronous rules exist for the two monads the two letrec and the dependent product note that the rule for application the argument of the application into the result type and does not impose any value restriction the case construction is an example of a rule with both a synchronous and an asynchronous version the synchronous rule requires a condition the same branch must be taken in the left and right expressions for the case of lists this is by requiring that the matched lists are either both empty or both nonempty in contrast the asynchronous rule does not require this condition the reduction rules close typing under reduction and is useful to relate expressions that do not have the same shape refinement typing is sound wrt its denotational semantics theorem soundness if g e e t then for every valuation ù g we have p e e q p t it follows that hoare accurately models differential privacy corollary differential privacy if e tx u Ñ m yy then e is p private wrt relation we have completed a formalization of theorem in the coq proof assistant assuming an axiomatization of probabilities and lifting typechecking we have implemented a typechecker for hoare the typechecker generates proof obligations during typechecking proof obligations are sent to smt solvers via why the typechecker uses a mllike syntax and includes a few practical extensions like example histogram binary summarization lines time s s s s s s s s s s s s table benchmarks inductive datatypes let expressions as well as the ability to define logical predicates and core theories for the datatypes all the programs presented in § and § as well as some additional examples from the dp literature private sums two level counters and were automatically type checked by the implementation with the only help of toplevel type annotations see table for a summary both the typechecker and the coq formalization are available at embedding dfuzz dfuzz is a linear dependently typed language that has been used to verify many examples of differential private algorithms in this section we define a typepreserving embedding from dfuzz r n kinds s i s sizes r i s r r r r ¨ r r types i e x n r x e expressions letrec f x e e e i e case e with r ñ e x ñ es h x r environments h i environments h s s i constraints figure dfuzz types and expressions into hoare and recover soundness of dfuzz from theorem the embedding is interesting for several reasons first it shows that hoare is sufficiently expressive to capture all differentially examples covered by dfuzz second it relates two previously approaches for verifying differential privacy third it shows how relational refinements can logical relations for we only consider a terminating fragment of dfuzz with probabilities only over real numbers types and expressions are defined in figure both are parameterized by drawn from two distinct languages the first one deals with interpreted as elements of r and the second one deals with sizes interpreted as natural numbers typing judgments are of the form d e where is an environment that records the sensitivity and size variables is a set of constraints used in pattern matching and is an environment containing assignments of the form x r figure gives selected typing rules where environments are combined by algebraic operations the environment r ¨ is obtained by taking x for every x ri p while environment addition is defined as px r q px r q x rr p q px r q x r p q if x r px r q x r p q if x r we refer to et al for definitions and further explanation of the typing rules in dfuzz types are interpreted as metric spaces with associated metrics d d then the dfuzz type system enforces metric preservation if e is well typed in context for arbitrary closing substitutions for the distance between the interpretations of and is upper bounded by the distance between and as a particular instance dfuzz expressions of type r correspond to functions ie functions f such that for every pairs of inputs v and v d pf v f r ¨ we will present an embedding which captures metric preservation as a relational refinement type to this end we first define the multiplication operation on in more detail we distinguish two sorts rs r y ts u and rd r y td we interpret r in dfuzz as while metrics figure are interpreted as we write s and d to range over the respective sorts to interpret multiplication we define a associative and commutative operator that maps rs rs Ñ rs and rd rs Ñ rd the nonstandard cases are those involving s d and k s d d k if d d otherwise r r r ¨ r if r r p r x d x x r d e d x e r d e r d e r ¨ d e e d e r ¨ d return e f pr q x r d e ¨ d letrec f x e r i f pi q d e i fresh in ¨ d letrec f i e i d e x d e mr s d let x e in e mr s i d e i fresh in d i e i d e i ù s d d e s d el i n s i x r xs r d er r ¨ d case e with r ñ el x ñ figure dfuzz typing rules d ´ d di q d in k if s otherwise k if d d r otherwise dr pd max d d p d d d d max ln di pd max d d dp figure metric induced by dfuzz types note that with type rd rd Ñ rd is never used then the expression d Ñ rd will capture the distance function for the dfuzz type on our embedding where ¨ is the erasure function from dfuzz types to simple types for the sake of readability we define d in usual mathematical style see figure where sz denotes the length of a list the translation is first defined on and sizes then on types and expressions and finally on environments and sizes are translated directly as expressions of type rs and n respectively more interestingly the translation for types given in figure uses refinements and dependent products to capture tx r xy x p tx list pr ° Ñ ° pi pi tx ° xy ° figure translation of dfuzz types size and sensitivity information the translation of expressions is straightforward the only interesting case are i e with r Ñ e x Ñ case with r Ñ x xs Ñ the translation of environments is defined inductively we have h for terms index environments and constraints moreover we define p x ° x ° p i ° i tx ° xy xu p s sq ° t b note that the translation of size and sensitivity environments requires the equivalence of the left and right instances of the relational variables we can show soundness of the embedding theorem dfuzz embedding if d e then ° ° ° ty ° d where xr p r d xq proof by induction on the derivation of d e the cases for abstraction and application rely on the properties of semantics subtyping in particular using subtyping we can pass from px ° d xy x to tf px ° dr fq and vice versa higher order relational refinements are crucial here for the metric of dfuzz at the function type that is essentially a logical relation equivalence shows that two functions are related if they map related inputs to related outputs similarly for the probability distribution case that we consider only distributions over base types we use subtyping to pass from r to tz l zy and vice versa the other cases are similar interestingly the case of pattern matching does not require asynchronous reasoning indeed the refinement type of the translation of the term under match ensures that the two runs will take the same branch hence typable dfuzz expressions are differentially private corollary if h h x d e then tx ° xq u m r yy proof by theorem x ° ty with x let u tx ° d xq u by definition of d and elementary reasoning about probabilities x u ty u finally by semantic subtyping x u m r yy moreover theorem and theorem give a direct proof of metric preservation for dfuzz theorem dfuzz metric preservation if d e and ù and ù then d p q d p q notice that the above theorem uses three valuations the valuation is used for index variables which are equal in the two executions the other two valuations are used to substitute related values in the two executions differential privacy theorem establishes that every differentially private algorithm that can be modeled in dfuzz is also captured by hoare in addition we present a few previously unverified algorithms the features of our system in what follows we will use some notational we write for the operations of the probabilistic and monad we write r for the type tx r xy xu when a relational variable x is assumed to be equal in both runs xy x we omit the projection and write x for both xy and x private primitives we review two differentially private mechanisms that are used in the next algorithms the first mechanism is the mechanism which a private version of a numeric value which can differ in the two runs by adding drawn from the distribution formally the private mechanism takes a real number x as input and returns x where is random drawn from the distribution which has density function f pq exp q if x can differ by at most s in adjacent runs then the mechanism is p s q differentially private we model this as an operator with the following type px rq m r when the output range is a typical tool from differential privacy is the exponential mechanism let b be the output range and suppose there is a quality score q b Ñ a Ñ r on an input a the exponential mechanism produces b p b approximately q b a if for every b p b and adjacent a a p a wrt an relation the quality score q satisfies the condition q b a ´ q b a s then the exponential mechanism satisfies p s privacy we model this as an operator of type ta a ay au Ñ s Ñ m b by with the type s of score functions defined as tb b by bu Ñ ta a ay au Ñ tr r ry ´ r su dual query release we first focus on the problem of a large set of queries the mechanism is a simple solution but its known that this will add to each query proportional to k for k queries under p when k is large the large will make the released answers completely useless fortunately there is a line of algorithms where is added in a carefully manner privacy while adding proportional only to log k we have verified the privacy of one such algorithm called the algorithm is parameterized by a natural number s and a set qs of queries to answer accurately the input is the number of t and database db and the output is a private database that is accurate for the given queries the code of the algorithm is given below let rec t db match t with Ñ t Ñ t db in let quality t in e db quality s e let opt in in in we encode the database as a list of natural numbers adjacent databases are lists of the same length whose distance wrt dn list is smaller than here we consider dn list to be defined similarly to the distance d for list of size n defined in figure but where the n is provided implicitly by the length of the lists we represent the output of the mechanism as a list of selected records each encoded as a natural number the algorithm performs t steps producing one record of the database in every round for each round we first build a quality score function from queries to real numbers based on the previously produced records using the auxiliary function if we think of the current records as forming an approximate database the quality score measures how the approximation performs on each query we then sample s queries using the exponential mechanism with this quality score queries with higher error are more likely to be selected these queries are into an optimization function opt which chooses the next record to add to the approximate database the only private operation is the exponential mechanism the quality score we generate at each round i has sensitivity i and so a draw form the exponential mechanism is i private since i is upper bounded by t and there are s samples per round the privacy cost per round is bounded by s ¨ t ¨ with t in total the whole algorithm is s ¨ t ¨ private this guarantee is reflected in the type of tt n ty tu Ñ n list dn u Ñ rtl n list ly the type states that for two runs with adjacent databases will return databases that are s ¨ t ¨ apart where t is the number of iterations and s is the number of samples used private counters and the monad our second example is a private counter the program takes in a list of real numbers and a list of running counts this algorithm is also known as the binary mechanism due to chan et al and has not been verified before previous verification work focused on the twolevel counter from the same paper suppose the input stream has length t n the binary mechanism will return a list of sums to reduce the improve the accuracy of the sums the algorithm proceeds via branching recursion in the base case we add to the single element of the input stream and return in the recursive case we split the input stream into a first and a second half and perform the recursive call on each half we then return the sum of the whole stream together with the result of the recursive calls each output list contains the sums for one level of the tree the first list contains a single sum of length n the next contains the two sums of length and so on the algorithm terminates but the simple guard condition implemented in our tool does not capture termination hence its formalization is based on the monad and its associated and operations let rec binary n ls match l with Ñ x xs Ñ match xs with Ñ sum x in sum y ys Ñ let left right split l in binary n left in binary n right in in in sum sum l in sum the algorithm binary takes as input a natural number n and a list ls of reals with length n and returns a list of lists of reals formally binary has type tn n ny nu Ñ tl r list n dr lq Ñ pr list ly where we write n for readability since it is assumed equal in both runs and where we use dr list to the distance of lists at the type r list defined analogously to dn list and algorithmic game theory we now study the verification of mechanisms with properties we start by describing the property for deterministic mechanisms then we proceed to the randomized case the closing examples illustrates the problem of computing an approximate using differential privacy in the digital setting there is an infinite supply of identical to be in for instance when can be for free we assume every agent or i has a secret value vi which is the price she values the item and a single bi to the mechanism once all have been submitted the mechanism selects a set of winning and pi for each aim to their utility which is if they do not and vi ´ pi if they and at price pi it is of course possible to prove termination using known techniques but we want to demonstrate the monad we want our mechanism to be given fixed of the other agents the utility of agent i is when she her true valuation bi vi this feature makes easy for and provides the algorithm designer with some that she will see the correct inputs the true values of the players from a verification point of view is a relational property of programs if the mechanism maps to outcomes and all but one of the the same in both runs then the remaining should have higher utility when than when we start with the a very simple mechanism for this setting first we pick a price p the price then their and we select all who above p to be each winning is price p informally this process is a price does not depend on her own so her will never lower the can only cause her to lose the item at a price that she would have to pay similarly increasing her above her value is never if her is winning raising her does not change the outcome she still and the same price if her is raising her can only cause her to the item at a price that is higher than her value to model this with code we will model a single utility when she note that each is treated independently her utility depends solely on her value her and the price and not on what any of the other do so we can model this with the following function which a single utility let b p if b p then v p else for clarity we treat v as a parameter declared in context with refinement type tv r vu of this follows from the type of tb r by vu Ñ tp r py pu Ñ tu r uu the relational variable b is required to be equal to v in the first run and arbitrary on the second run then the final utility u cannot be higher on the second run this example also demonstrates a boolean version of the asynchronous typing rule from figure since the b is arbitrary in the second run the two runs may take different branches indeed these are the most interesting cases of the reasoning if the same branch is taken in both runs then the utility is the same in both runs since the price is the same in both runs when different branches are taken we verify that holds even when from changes the outcome of the universal and randomized mechanisms while the is very simple it has properties since the price is set independently of the setting it too high will lead to very few and hence low and setting it too low may many but at a price that is substantially less than would have been to pay again low however the price as a function of the can the property what to do it turns out that is a useful way around this problem in the random sampling due to et al the are randomly split into two groups g and g the is computed for each group and then a is run in each using the price computed from the other group holds since the price to any remains independent of her own while it is possible to code the full that all the and all the we verify the core guarantee of which deals with a single utility function since the mechanism is randomized we want to verify in expectation an expected utility will never increase if she from her true value in fact the random sampling satisfies a stronger property known as universal a will never be able to gain by from even knowing the random of the mechanism to model the random sampling we will treat as parameters the value v r of the single ° and the of the other bs r list these are again assumed to the same on both runs we define a deterministic utility function that takes the b for the ° a indicating the group of ° and a list of indicating the groups of the other then utility for ° is computed using the with price from the in the other group the optimal price function is denoted by let utility b let g g split b bs in if then b g else b g universal can be seen from the type of utility tb r by Ñ tc b b list cy cu Ñ tu r uu the type shows that for any realization of the the utility is by the main takes in the b of ° the booleans indicating the groups and uses the expectation operation to compute the expected utility of ° on this distribution let b me flip in others repeat n flip in let me others in e utility b above flip returns a uniformly random boolean and has type b cy the repeat function is used to generate a list of n random booleans where n is the total number of that are then used to split the other into two groups for the random sampling is reflected by the type for which computes the expected utility of ° tb r by Ñ tu r uu to verify the of this we rely on monotonicity of expectation as captured by the refinement type from § via differential privacy in this section we move beyond and consider the more general setting of games a game is by a collection of n agents indexed by i each with a set of possible actions ai the action space given a vector of actions one for each player a pa an q each agent receives a possibly randomized an q agents to their expected for an example can be considered as games where each agents action space is the space of possible and the of each agent is their utility for the chosen outcome so far we have considered mechanisms where one action is a strategy a maximum strategy no matter how the play in general games like strategies usually do not exist in this section we consider a weaker solution concept approximate let rec i br br s sign br i br i match i with Ñ s i Ñ ss i br br s ss in in let rec search i br br sums if i nth i sums t then i else match i with Ñ i Ñ search i br br sums let br br e sums k br br in let s search k br br sums in let a br s in let a br s in let p pay a sign a a in p x x figure game mechanism definition let an assignment of agents to actions a strategy profile pa an q is an approximate if no single agent i can gain more than from a from ai assuming that all other players are according to a that is for all agents i and actions ai ai an qs ai an qs ´ we consider an algorithm for computing an approximate when the are not known there are at least two difficulties first a general game may have several agents may prefer different among the many that exist this may lead agents to their functions to influence which is selected something we want to prevent second functions may consist of sensitive information and agents may be to reveal their to the mechanism if the output could their private information somewhat using differential privacy to solve the second problem also solves the first if we can compute a under differential privacy then the profile of actions when agents report their function is an approximate a full discussion is beyond the scope of this paper we present and verify the approximate property for a version of a mechanism due to et al which computes approximate of games in an game are a function only of an agents own action and a signal a nonnegative real number bounded by k that depends on the actions of all players that is the function for i is of the form an qq where s is a signal function of type a ¨ ¨ ¨ an Ñ r ks in code we will write sign for the signal function and k for the bound they are the same in both runs and we consider them implicit parameters the mechanism we have verified computes an of an game where the are reported by the agents we want to show that the true and the action suggested by the mechanism is an approximate to keep the notation light we think of all players as having the same action space and we consider only two players with actions a and a respectively we consider the player ° as the possibly player while the other agent is a representing all of the other players in the game who do not the relevant code for the mechanism is in figure the func tion computes the expected for ° it takes as inputs best response functions br and br that map signals to an agents action this is how agents report their pay off and functions and that map actions to actual actions agents also have a true pay and pay also considered as parameters since they are the same in both runs the mechanism will not use these functions in the code they are only referred to by the refinements the function performs the following steps use to compute a list sums of signals using the mechanism compute a signal s such that if both agents choose their best action br s and br s for signal s then the true signal based on strategy profiles a and a defined next is close to s apply the functions and to the action br s and br s of each player to produce the strategy profile a and a calculate the true p for the agent on the strategy profile compute the expectation of the p for the agent players have two opportunities to they could their best response function or they could choose a function to play differently than their we want to show that the true best response function and following the ie using the identity function for is an approximate as before we perform the verification by assigning a relational refinement type where ° behaves in the left execution while in the right execution ° behaves arbitrarily assuming that is the true best response function corresponding to pay and that is the identity function and that br and coincide on both runs we thus omit subscripts we want to prove according to definition br br br ´ for some value we do this by checking that has type tbr r Ñ a s a pay sq s pay a su Ñ a Ñ a x x xu Ñ tbr r Ñ a Ñ a Ñ a a a a au Ñ tu r u ´ u we briefly comment on the two most interesting steps in the verification first when calculating s the algorithm computes sums by adding to each induced best response we want to ensure that agents have a limited influence on the chosen signal and hence have limited to their best response strategy for the accuracy guarantee we need to show that this is not too large which is the case if the signal and functions satisfy certain conditions captured with refinement types this is modeled by assigning to the mechanism a refinement type capturing accuracy px rq m r u xy ´ t us where t is defined as xy ´ x log informally this states that the added is less than t with probability ´ the second interesting point is taking the expected value the expression p is randomized and has type m r u ´ us for some concrete values of and the above is a probability distribution on real numbers related by the lifted inequality relation we wish to take the expected value of these distributions in order to relate the expected on the two runs however a priori it is not clear how the expected values of these distributions are related fortunately the expected values are related in a rather simple way as seen in the following refinement for e m r xy x ´ us Ñ tf r Ñ r fy f Ñ tu r u ´ u where is an expression computed from and that is taking expectation of two distributions related by the lifted inequality relation yields two real numbers that are approximately related by the standard inequality relation on real numbers though not obvious the soundness of this refinement can be derived from the definition of expectation and lifting from this refinement on the expected for ° computed by we conclude that and following the action is an approximate related work our work lies at the intersection of differential privacy mechanism design probabilistic programming languages and verification we briefly comment on the first three areas which are too to be covered here and elaborate on the most relevant work in program verification differential privacy differential privacy first proposed by et al and formally defined by et al has been an area of research in the last we have on a of private algorithms including an algorithm for computing running sums part of a literature on streaming privacy large classes of queries part of a literature on approaches to data privacy we refer readers interested in a more treatment to the by mechanism design mechanism design was introduced to the theoretical computer science community with a new focus on efficient implementations by the work of and see et al for a introduction it is understood that guarantees can be difficult to prove and verify so there is a literature giving generic reductions from mechanism design to algorithm design in limited settings but it is known that this is not possible in full generality differential privacy was first proposed as a tool in mechanism design by and and has since found many applications see and for a survey of this area probabilistic programs there is a long line of work that models of probabilistic programs the monadic representation of distributions from and was further developed in a programming language setting by later work the connections with machine learning have recently a of interest in probabilistic programming languages we refer the reader to recent for further information verification of higherorder programs the refinement type discipline was introduced by and pfenning and further developed by others advances in smt solvers have allowed practical systems that support refinement types through smt for instance f f and our work is mostly related to a recent variant of f called rf like hoare rf supports relational reasoning of probabilistic computations however rf lacks support for approximate relational refinement types and higherorder refinements which are both critical for verifying differential privacy and properties dependent types is another expressive typing discipline that can be used to verify properties of functional also form the basis of proof like coq examples of dependently typed languages include and like our system distinguishes between terminating and nonterminating expressions to ensure logical consistency other approaches for verifying functional programs include dynamic checking and its combination with static typechecking modelchecking and translating functional programs into logic verification of differential privacy and mechanism design there has been significant work on languagebased techniques for verifying differentially privacy pierce defines three categories runtime enforcement static enforcement dfuzz and enforcement our work clearly into the last category all these works are focused on privacy rather than accuracy see et al pierce for a more detailed account of related work there has been little work on languagebased techniques for verifying mechanism design et al give an interesting approach by presenting a programming language for automatically verifying simple mechanisms a key component of the language is a type analysis to determine if an algorithm is monotone if have a single real number as their value domains then is equivalent to a monotonicity property eg see and their language can be extended by means of userdefined primitives that preserve monotonicity the paper shows the use of the language for verifying two simple examples but it is how this approach to larger finally et al propose the use of program synthesis for verifying of their approach reduces the verification of to linear constraints that can be handled by an smt solver in this respect their approach is similar in spirit to ours however the constraints they consider are linear and moreover their technique applies to imperative programs the extension to higher order functions is not obvious future directions hoare is an expressive system of relational refinement types that captures differential privacy properties and other relational properties of probabilistic computations an direction for further work is to formally verify more complex mechanisms whose guarantees are less standard for example it would be interesting to verify mechanisms that are merely in expectation for which universally do not exist eg and such mechanisms use in a crucial way for their properties and in addition to being interesting challenges for verification are mechanism for which is we also intend to develop a version of hoare for reasoning about the accuracy of probabilistic computations acknowledgements we thank wu for good discussions and in particular for the games example we also thank the anonymous reviewers for their close reading and helpful comments this research was supported by the european framework grant grant project and nsf grant references l ­ a language with dependent types in acm sigplan international conference on functional programming icfp pages ­ url http mf a j d and y reducing mechanism design to algorithm design via machine learning journal of computer and system sciences ­ url g b f and s probabilistic relational reasoning for differential privacy in acm symposium on principles of programming languages popl pennsylvania pages ­ url http g c fournet b py n and s probabilistic relational verification for cryptographic implementations in acm symposium on principles of programming languages popl san diego california pages ­ url j k c fournet a d gordon and s refinement types for secure implementations in ieee computer security foundations symposium pittsburgh pennsylvania url n benton simple relational correctness proofs for static analyses and program transformations in acm symposium on principles of programming languages popl italy pages ­ url a c f and k practical privacy the framework in acm symposium on principles of database systems pages ­ url j t and k s a firstorder type for data in symposium on programming languages and systems url e a generalpurpose dependently typed programming language design and implementation journal of functional programming ­ url c v and s weirich combining proofs and programs in a dependently typed in acm symposium on principles of programming languages popl san diego california url th h chan e and d private and release of statistics acm transactions on information and system security url s n and b on the limits of reductions in mechanism design in acm symposium on theory of computing new york new york url r m a and z s wu privacy and selection for games technical report url r and f pfenning intersection types and computational effects in acm sigplan international conference on functional programming icfp pages ­ url s and s on the power of in algorithmic mechanism design in ieee symposium on foundations of computer science pages ­ url s and t randomized reductions in algorithmic mechanism design siam journal on computing ­ url j and f pfenning typecheck ing in acm symposium on principles of programming languages popl italy pages ­ url c differential privacy in international colloquium on automata languages and programming icalp italy pages ­ url c differential privacy a survey of results in theory and applications of models of computation volume of lncs pages ­ springer berlin url c f k and a smith to sensitivity in private data analysis in theory of cryptography conference new york new york pages ­ url y s and m mechanism design at popl r b findler and m felleisen contracts for higherorder functions in acm sigplan international conference on functional programming icfp pittsburgh pennsylvania pages ­ url t and f pfenning refinement types for ml in acm sigplan conference on programming language design and implementation pldi pages ­ url m a j a and b c pierce linear dependent types for differential privacy in acm symposium on principles of programming languages popl italy pages ­ url m e j j a and z s wu dual query practical private query release for high dimensional data in international conference on machine learning url m a categorical approach to probability theory categorical aspects of topology and analysis pages ­ a v j d a r m and a wright games and behavior url n d the principles and practice of probabilistic programming in acm symposium on principles of programming languages popl italy pages ­ url a d gordon t a henzinger a v and s k rajamani probabilistic programming in international conference on software engineering pages ­ url m b c pierce and s weirich contracts made manifest in acm symposium on principles of programming languages popl pages ­ url j k a s n and c flanagan hybrid checking for flexible specifications in scheme and functional programming workshop pages ­ url j d and b bayesian algorithmic mechanism design in acm symposium on theory of computing cambridge massachusetts pages ­ url m g n d and n programming in workshop on the mathematical foundations of programming semantics new york url o and embedded probabilistic programming in pages ­ a a and d a typed language for mechanism design technical report url c practical programming with dependent types in advanced functional programming pages ­ springer url f privacy integrated queries in acm international conference on management of data island url f and k mechanism design via differential privacy in ieee symposium on foundations of computer science island pages ­ url http p and i and in acm conference on and computation ec palo alto california pages ­ url a and n approximation mechanisms for restricted combinatorial games and behavior ­ url n and a algorithmic mechanism design in acm symposium on theory of computing pages ­ url n t e and v v algorithmic game theory cambridge university press ch l and s j verifying higherorder functional programs with patternmatching algebraic data types in acm symposium on principles of programming languages popl austin texas volume pages ­ url m m and a privacy and mechanism design acm ­ url s park f pfenning and s a probabilistic language based upon sampling functions in acm symposium on principles of programming languages popl long california pages ­ url b c pierce differential privacy in the programming languages community at workshop on recent work on differential privacy across computer science n ramsey and a stochastic lambda calculus and monads of probability distributions in acm symposium on principles of programming languages popl portland pages ­ url j and b c pierce distance makes the types grow stronger a calculus for differential privacy in acm sigplan international conference on functional programming icfp url p m m and r jhala types in acm sigplan conference on programming language design and implementation pldi pages ­ url http i s a v and e security and privacy for in usenix symposium on systems design and implementation san california url n j chen c fournet py k and j yang secure distributed programming with types in acm sigplan international conference on functional programming icfp url n e l r jhala d and s peyton jones refinement types for haskell in acm sigplan international conference on functional programming icfp url d s peyton jones k and d haskell to logic through denotational semantics in acm symposium on principles of programming languages popl italy url p wadler and r b findler welltyped programs cant be in european symposium on programming esop york pages ­ url h xi and f pfenning dependent types in practical programming in acm symposium on principles of programming languages popl san texas pages ­ url 