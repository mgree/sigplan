verification of parameterized concurrent programs by modular reasoning about data and control university of abstract in this paper we consider the problem of verifying properties of multithreaded programs in which the number of active threads cannot be statically bounded our approach is based on the task into two modules where one reasons about data and the other reasons about control the data module computes invariants eg linear constraints over global variables and local variables of one thread using the thread interference information computed by the control module the control module computes a representation of thread interference as an incrementally constructed data flow graph using the data invariants provided by the data module these invariants are used to rule out patterns of thread interference that can not occur in a real program execution the two modules are incorporated into a feedback loop so that the abstractions of data and interference are iteratively as the algorithm that is they become weaker until a fixed point is reached our approach is sound and terminating and applicable to programs with infinite state eg unbounded integers and many threads the verification method presented in this paper has been implemented into a tool called we demonstrate the effectiveness of our technique by verifying properties of a selection of linux device drivers using and also compare with previous work on verification of parameterized boolean program using the boolean abstractions of these drivers categories and subject descriptors d software engineering checkers correctness proofs f logics and meanings of programs specifying and verifying and reasoning about assertions d programming languages formal definitions and d operating systems security and general terms verification algorithms reliability keywords concurrency abstract interpretation compositional reasoning data flow graphs parameterized programs thread invariants both authors were partially supported by an national science and engineering research discovery grant for this work permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission andor a fee popl january ­ pa usa copyright c acm introduction concurrent programs are hard to verify verification of concurrent systems has been a very active area of research in the past few years there has been significant progress with testing and bug finding techniques but due to a number of possible schedules even with a fixed input it is hard to provide useful coverage guarantees standard model checking techniques provide coverage but from the state explosion problem static analysis techniques have been successful in checking simple generic properties such as race and deadlock freedom there is a large class of concurrent programs that are designed to be executed by an arbitrary number of clients for example device drivers concurrent data structure libraries and file systems this class of programs commonly called parameterized concurrent programs are more difficult to verify than concurrent programs with a fixed number of threads the verification problem for parameterized systems has been studied extensively however the focus has mostly been on verifying protocols these protocols for example protocol and mutual exclusion algorithm are often small programs but the reasoning behind their correctness is usually complicated see section for a more detailed discussion when functional correctness is the goal eg mutual exclusion in contrast we are interested in large programs such as device drivers and file systems where the reasoning behind their correctness is more straightforward in these programs interference is usually by simple synchronization mechanisms and the of the verification effort is spent in reasoning about the sequential behaviour of each thread moreover we are interested in proving program assertions which is easier to handle than proving functional correctness of protocols program assertions are boolean combinations of program expressions that relate shared variables to local variables of a specific thread at a location in that thread they are expressive enough to include interesting properties of concurrent programs such as the absence of null pointer dereferences or out of bounds array accesses we believe that this combination of programs and properties is a good candidate for automated verification in the parameterized setting and is the target of the work presented in this paper we propose a static analysis technique that the verification task into a data module and a control module this separation achieves both precision and scalability for proving assertions correct in concurrent programs with many threads the data module using an abstract interpreter computes data invariants for each program location these invariants are guaranteed to be consistent with the most recent information about interference provided by the control module the control module using a deduction system determines the pattern of interference by using the most recent information from the data module about data invariants the two modules are combined into a feedback loop to compute a solution to the verification problem this strategy can be used to generate invariants for program locations ie invariants that do not refer to the local variables of more than one thread these invariants can be used for proving the absence of program assertion failures one of the enabling ideas of our modular approach is to use a data flow graph as a program representation for performing abstract interpretation in data flow graphs only the flow of data is modelled control constructs which are irrelevant to a data analysis are abstracted away data flow graphs offer a convenient way to represent the interference between threads for example if one thread writes to a global variable at some location u which is subsequently read by another thread at location v then u and v are connected by a data flow edge also since each program location regardless of the number of threads in the system is represented by one vertex in the data flow graph ie there is no explicit representation for threads it is possible to use them to analyze data in parameterized systems computing data invariants over a data flow graph is mostly as straightforward as abstract interpretation for sequential programs the idea is that the structure of a data flow graph captures the interference among threads and therefore one only needs to focus on how data flows through this structure the figure on the right illustrates the idea data invariants behind our approach we start by assuming no interference among threads as if threads data invariant generation interference deduction are running and through ab interpretation compute the first set of data flow edges data invariants per program location at this stage the data flow graph only contains data flow edges that correspond to the tial executions of program threads then the data invariants are passed to a deduction system which uses them to compute a new set of data flow edges the deduction system uses the data to reason about what patterns of interference are feasible and adds the corresponding data flow edges which capture these new interference patterns to the data flow graph these new data flow edges may result in computing weaker data invariants in the next round these weaker invariants may trigger the addition of more data flow edges the data flow graph this loop continues until a fixed point is reached the analysis we use for computing data flow edges is compositional data flow is a property that intuitively involves two threads one that writes to a global variable and one that reads from it one would like to reason about the of data flow edges by considering only two threads at a time however it is not generally sound to reason using only two threads since a program path eg from a write to a read may involve many threads with each other we overcome this problem by using data invariants from the data invariant generation mod to soundly approximate the effects of other threads that may contribute to a data flow path being realizable an invariant with a program location corresponds to an overapproximation of the values of the program variables when at least one thread is at that location therefore we may reason about data flow paths that may require the of arbitrarily many threads while considering only two threads at a time we call our approach compositional in contrast to fully compositional because our method over two threads is all pairs of locations are considered while every other thread in the system is for in a compositional manner we implemented our approach in a tool called and evaluated it on a set of linux device drivers can prove a total of out of of array bounds and integer assertions safe in we also compared against two recent tools that deal with parameterized concurrent boolean programs namely and the dynamic detection algorithm of which are both based on model checking we compared against and on the set of benchmarks provided by the authors which are boolean abstractions generated by the tool of the linux device drivers has the clear advantage of being directly applicable to the drivers as opposed to their boolean abstractions but we performed these experiments to show that it does these tools even at the level of boolean programs our experiments shows that substantially by proving compared to for boolean programs correct also by proving programs safe in contrast to only programs that can prove safe motivating example in concurrent programs threads communicate using many different methods they may communicate through synchronization primitives such as locks or which can be viewed as control type primitives that only affect the feasible control paths in a thread and not the data threads may also communicate via reading from and writing to shared memory which are data type primitives in the presence of both patterns of communication among threads precise reasoning about the program often involves reasoning about both data and control simultaneously but doing so can be very expensive for a programs with an unbounded number of threads in this paper we present a scalable approach to reason about data and control in separate but modules in this section we use an example that includes both modes of communication among threads through both data variables and locks to provide a high level understanding of our approach figure illustrates a simplified concurrent example let us assume that each statement is executed atomically and that initially no thread holds any locks and counter is the producer can produce items or in mode and keeps track of the number of produced items waiting to be consumed using the global variable counter two cannot produce items simultaneously but a consumer can run in parallel with a producer in mode the consumer if there are items to process them by counter the assertion at v states a correctness property for the consumer the number of items waiting to be consumed must be nonnegative at position u in the producer the value of counter is always zero so the assignment at u does not add any behaviour but it helps us demonstrate an interesting point this program demonstrates the use of both synchronization primitives locks in this case and conditional statements to rule out interference from other threads for example if the goal is to prove that the assertion at v holds then one must prove that the zero value assigned to counter at u cannot reach the at v and consequently the assertion in other words we need to rule out a pattern of thread interference in order to prove the desired invariant at v and v the interesting aspect of this example is that the reverse is also true since the locations u and v are not protected by a common lock in order to rule out the interference one needs to rely on the fact that at v the value of counter is always strictly positive in this scenario if one starts from a weak invariant at v one cannot rule out interference from u and if one starts by assuming the interference from u may occur one cannot prove the data invariant needed to rule out this interference here we explain how our algorithm operates on the program in figure at a high level in section in example we will this example and explain it in more detail first we assume that producer and consumer are executed sequentially with no interaction and compute a sequential data flow graph p next a set of data invariants is generated from p this analysis determines that the consumer threads cannot reach location v and that in producer threads location u is unreachable using the previously computed data invariants the interference deduction unit computes new data flows and adds the appropriate edges to p to get a data flow graph p for example this analysis determines that the value of counter from u may reach the beginning of the producer and consumer threads and so adds the edges u v and u u the interference deduction unit uses the fact that counter is an invariant at u to infer that the value of counter from u cannot flow to v without passing through v and therefore does not add an edge from u to v data invariants are then generated for the data flow graph p which determines that u and v are now reachable and that counter at u the subsequent interference analysis computes new data flow edges for example u u which is possible as the result of us new weaker invariant the invariants are still strong enough to prove that there is no data flow from u to v these edges are added to p to get a new data flow graph p the data analysis runs on p but does not produce weaker invariants and consequently the subsequent interference analysis does not produce any new data flow edges the algorithm then terminates having computed a set of invariants that soundly approximate the dynamic behaviours of the program these invariants are strong enough to prove that the assertion at v never fails the rest of this paper is organized as follows in section we define our program model we define the data flow graphs in section and discuss how data invariants can be computed by abstract interpretation of data flow graphs this the data portion of our analysis we then discuss construction of the data flow graphs in section where we explain how data invariants are used to infer new data flow edges the complete algorithm as an iterative framework is presented in section section presents our experiments section discusses related work and section concludes notation and the program model we define a program to be a tuple p h gv lv l · where h loc cf is a finite control flow graph cfg whose vertices we call locations gv is a finite set of global variables lv is a finite set of local variables and l · assigns to each control location a transition relation for the rest of this section we will formalize this program model and introduce notation to be used in the rest of the paper we will identify threads with natural numbers where the behaviour of an individual thread is given by the control flow graph h loc cf together with the semantic function l · the initial vertex of h which is assumed to have no control flow predecessors is denoted by the behaviour of the program p is defined to be that of the infinite parallel composition of all threads n n since we are interested in thread invariants we can restrict ourselves to finite executions in which only finitely many threads can thus for proving thread invariants our program model is equivalent to the parameterized model in which p is taken to be the finite parallel composition of all threads up to some k n where k is a parameter we also note that we lose no generality in assuming that every thread n n executes the same code since several code segments can be simply combined into one int u u if u u counter u u u return else u u u counter while u u counter u u u u return void consumer v while v v v v v figure example we will assume that gv lv and n × lv are pairwise disjoint a pair n x n × lv is conceptually thread ns copy of the local variable x and define the set of variables var gv lv for simplicity we will assume that all variables are of type integer a global state is a pair s consisting of a global environment gv n × lv z and an assignment of a control location to each thread n loc a thread state is a mapping e var z from variables to values for a given thread n n and global state s the thread state of n in s which we denote by sn and which is defined by if x gv n x otherwise the function l · loc × associates a transition relation on thread states to every location we call a pair a n v v consisting of a thread n n and a control flow edge v v cf an action if the target v of the control flow edge v v is understood from the context or irrelevant we simply write n v we use a a to denote the global state transition relation associated with the action a which is obtained by lifting l v from thread states to global states as follows s s a n v v e e l v such that · sn e and s n e · v and v · n n n · n n n x lv n x n x given a sequence of actions and a subset n n the projection of onto n denoted n is the subsequence of consisting of all actions whose thread identifiers belong to n a trace is a finite sequence of actions such that when onto a single thread corresponds to a path in the cfg h beginning at the initial location for a trace the post states of denoted · is the set of final states of that execution a trace is feasible if · is nonempty for a trace and a thread n n we use n to denote the end location of the cfg path n note that has the property that s · n n n a property is an assertion with free variables in var we will denote the set of such formulae by and more generally fv will denote firstorder formulae with free variables in v for a thread state e we write e to denote that e satisfies to provide some intuition on our program model we will describe how to represent locking a lock is represented by a global variable lock gv let be a location where lock is to be acquired and let rel be a location where it is to be released then we can define l e l rel e note that given a feasible trace the fact that · is nonempty implies that there is no point along in which two threads hold the same lock our program model does not support conditional branching but this can be simulated with nondeterministic branching and assume actions where l e e e c programs that depend on the initial state satisfying some property can be simulated by defining l as l assume although our algorithm and our implementation handles dynamic thread creation we omit it from this presentation for the sake of simplicity data flow graphs data flow graphs are a program representation that explicitly represents the flow of data in a program rather than the flow of control as in a control flow graph our analysis uses to compute program invariants by interpreting each edge of the as a constraint and then computing an overapproximation of the least solution to this constraint system via abstract interpretation a for a program p is a directed graph p loc df where df loc × var × loc is a set of directed edges labeled by program variables and where we assume that loc contains an additional location with no incoming or outgoing edges in the control flow graph of p we will use u x v to denote the triple u x v loc × var × loc we define the collecting semantics of a p loc df to be the least solution to the following set of equations x ex e inv e u x v x e e inv e e l v if v otherwise consider the example in figure this figure a program with two code segments each of which may be executed by ar many threads variable c is global and variable incr is local each vertex except the special vertex has at least one incoming edge for each variable each of these incoming edges provides a value for a particular variable for example the edge u c v represents the constraint that any value for c after executing u is a possible value for c before v that is ec e inv ec e the two edges from to indicate that any value is possible for incr and c at the location at which both threads begin execution the vertex sets the initial condition of the program as incr thus edges at for a similar use of dataflow graphs see for example global c local incr u incr u c c incr v incr v incr c incr cc incr u incr c c v incr incr cc incr c u c v figure a program and a data flow graph representing it indicate that a particular variable may get its value from the initial state the fact that v incr u does not belong to this graph indicates that the value of incr at v is not observable at u intuitively a for a program p represents a trace if it has enough edges to ensure that any thread state reached by belongs to inv for some v the remainder of this section formalizes this notion we will assume the existence of a function mod loc that maps every control location to the set of variables modified at that location we require that mod satisfies the following for any x var if there exists some e e l v with ex e x then x a feature of the mod we use in practice is that a location of the form assume is considered to be a modification of every variable in this allows us to take advantage of information at conditional branches that otherwise would not be possible in a data flow graph for a trace variable x and thread n we define x n to be the location of the last action to write to the variable x along or thread ns copy of x if x is local more formally if x is a global variable x n is the unique location v such that m v for some m n and where no action of any thread along modifies x if such a v exists and otherwise similarly if x is a local variable x n is the unique location v such that n v and no action of thread n along modifies x if such a v exists and otherwise definition witness let u v be locations x be a variable and be a trace we say that is a witness for the data flow edge u x v if there exists some thread n n such that x n u and n v conceptually is a witness for u x v if on u sets a value for x which is not changed until the end of the trace where some thread is at v we are now ready to define a representation condition for traces and program definition representation a p loc df represents a trace iff for every u v loc and x var if some not necessarily proper of is a witness for u x v then u x v df p represents a program p if it represents for every feasible trace of p the relationship between the collecting semantics of a and the traces it represents is given by the following theorem soundness let be a trace and let p be a such that p represents then the collecting semantics of p the set of thread states reached by formally for all s · for all n n we have that sn proof sketch let p loc df be a and let be a trace represented by p we proceed by induction on base case follows from the fact that for all x x df since p represents and the fact that for all x x z inductive step suppose is a trace such that p represents let n n and let v n we need to show that sn to prove this it is sufficient to show that x var u loc such that u x v df and x let x be a variable and take u to be x n then u x v df because witnesses this data flow and p represents if u we are done since x z if u it follows that m u for some thread m n trace and sequence of actions such that x is not modified along by the definition of x n moreover we must have that there is some s · such that s with s s a m u and s nx by the induction hypothesis s m so s m and s nx s mx x we also note that unlike typical definitions of data flow graphs we require that each location has inputs for every variable rather than just the variables read by that location this is a technical convenience that simplifies the presentation of our algorithm abstract interpretation of data flow graphs in this section we discuss how invariants are computed over a data flow graph for clarity of this presentation we will assume a concrete representation of an abstract domain as a subset of the semantics of program locations is given by an abstract transition relation l · loc that the strongest postcondition ie e e l v implies e l v e an annotation for a p is a map loc f var that assigns each location v loc a formula v we define an condition for annotations that follows the structure of the collecting semantics and which holds when the annotation the collecting semantics of the definition an annotation is inductive for a data flow graph loc df if · true · for all v loc lu x u v where l u x u denotes the formula obtained from the formula l u u by existentially every variable except x standard techniques can be used to compute inductive annotations from a inductive annotations correspond to solutions in the terminology of abstract interpretation for example in our implementation we use a variation of the wellknown worklist algorithm the following is a consequence of theorem and the fact that inductive annotations the collecting semantics corollary let be a trace let p be a dataflow graph that represents definition and let be an inductive annotation for p definition then for all states s · and all threads n n sn ie the thread state of thread n in the global state s is by the annotation at the location of thread n note that in the collecting semantics and therefore in inductive annotations the values of different variables cannot be for example if v is a location x and y are variables and e e inv are reachable thread states such that ex ey and e x e y then there exists an e inv in which e x e y this suggests that are most appropriate for analyses based on abstract domains such as intervals or the domain which are also of representing relationships between variables in section we will discuss a variation of which are more appropriate for relational abstract domains interference analysis we now address the problem of how to compute a that represents a program we start by defining a subset of traces called feasible traces where is a given annotation and then develop an interference analysis that computes the set of data flow edges that are by feasible traces the definition of feasibility is such that if is a weak enough annotation then every feasible trace is feasible with such an annotation every edge which is by a feasible trace will also be by an feasible trace and thus will be found by our interference analysis our interference analysis relies on a finite domain of data invariants which is defined using finite set of observable conditions an observable condition is a predicate c with free variables in gv in the remainder of this section we assume a fixed finite set of observable conditions which we denote by c we define the set of observable formulae f gv to be the set of formulae that can be expressed as a conjunction i i where for each i i c or c an annotation loc f var along with the set of observable conditions c determines an abstract annotation loc f gv that assigns to each location u loc an observable formula that is implied by u and which is at least as strong as any other observable formula with this property thus going from concrete to abstract and using to denote is more precise than we have inv v v for any location v the set of observable conditions c determines an enabling condition enabled loc f gv where e e e a v e v and is at least as strong as any other observable formula with this property we are now ready to state our definition of feasibility definition let be a trace and be an annotation then is feasible if · or · n v where is an feasible trace and for all m n m is satisfiable note that the condition for extending an feasible path by an action n v depends only on the annotations at the end locations of each thread rather than on the states in · example consider the trace u u u of the program in figure this trace is not feasible because every state in u u · has counter so u is not enabled however assuming that u counter lock u counter and c counter lock lock which implies u true u and counter this trace is feasible to illustrate how feasibility depends on consider the infeasible trace u u v this trace is this condition is not strictly necessary but makes for a more efficient analysis v u v v v v x v x u v u u cf u u cf x u v x v x u v u u cf x u v x u x u v v v cf figure interference analysis x u v u x v feasible if u counter lock and infeasible if u u counter lock lock by combining the definition of feasibility with the definition of a witness of a data flow edge we arrive at the following definition let be a trace be an annotation u and v be locations and x be a variable then is an feasible witness of the data flow u x v if is feasible and witnesses the data flow u x v that is simultaneously satisfies definitions and a key property of our notion of feasibility is that it is preserved under projections that is for any if is an feasible trace then for any sets of threads n n n is also feasible the following lemma states a projection result that forms the basis of our algorithm for interference analysis it implies that in order to compute the set of data flow edges that are by feasible traces it is sufficient to consider only traces that involve two threads lemma projection let be an annotation u v be locations and x be a variable let be an feasible witness for the data flow u x v then there exists m n n such that mn is an feasible witness for u x v proof sketch we will first prove that for any n n and any feasible trace n is an feasible trace by induction on the base case is obvious for the inductive step let n v be an feasible trace and assume that n is feasible if n n then n v n n and the result is immediate from the induction hypothesis if n n then n v n n n v in this case we need to show that for all m n m is satisfiable let m n and distinguish two cases · m n then m m and the fact that m is satisfiable follows from the fact that n v is feasible · m n then n since is finite only finitely many threads execute actions in so there exists a thread i n that does not execute actions in since n v is feasible i is satisfiable since i m we are done now we must prove that the property of being a witness is preserved by projections let u v be locations and x be a variable and let by a witness of the data flow u x v we assume that x is a global variable ­ the case of local variables is similar it follows from definition that there exists some m n n a trace and a sequence of actions such that n u such that x x is not modified by any action along and v m it is easy to check that mn witnesses u x v inferring data flow edges our algorithm for inferring data flow edges is stated in figure as a set of deduction rules for feasible witnesses for u v loc and x var we write u x v iff an feasible witness for the data flow u x v exists these proof rules are sound and complete for determining whether a witness for an data flow edge exists ­ data flows can be computed independently using a standard sequential reaching definitions analysis the rules use an input relation which holds iff is satisfiable additionally two auxiliary relations are used · v holds iff there is some feasible trace such that u and v · x v w holds iff there is some feasible trace such that u x v and u since the set of locations and the set of variables are finite and all must be finite as a result we may compute all members of in finite time by iteratively applying these rules until no new members of any relation are ie until a fixed point is reached moreover the fact that these relations are all finite allows us to efficient propositional techniques for example representing relations by binary decision diagrams lemma interference analysis soundness completeness let u v loc and x var there exists an feasible trace that witnesses data flow the u x v iff there exists a singlethreaded witness or if u x v belongs to the least fixpoint solution of the system of interference rules in figure note that this lemma implies that although we lose information in our interference analysis by going from feasible traces to feasible traces we do not lose information by going from feasible traces to thread feasible traces the rules in figure are a simplified version of the ones we implement in handles some additional language features thread creation and atomic blocks and has several optimizations u v x u v counter u counter u counter u counter u u u u u v v v true counter counter counter counter counter counter false false true counter counter counter counter counter counter counter counter true counter counter counter counter counter counter counter counter v figure computation on the program in figure to make it more efficient however all the essential ideas of the analysis are present in the rules of figure iterative in section we gave a method for computing an annotation for a data flow graph in section we gave a method for computing data flow edges given an annotation by both components into a feedback loop we obtain our main algorithm algorithm given a parameterized multithreaded program computes a that represents that program as well as an annotation that is inductive for that given a program p begins by computing a data flow graph p with only sequential data flow edges it then computes an inductive annotation for p as discussed in section this annotation is used as input to the interference analysis of section which computes the set of feasible data flow edges and adds them to p to obtain a p after adding these edges a new possibly weaker annotation is computed that is inductive for p this process continues until a fixed point is reached that is until we reach some k such that pk pk at this point pk represents the program p and k is inductive for pk and therefore k the reachable thread states of p by theorem this algorithm makes use of several auxiliary functions which are defined below · computes a sequential data flow graph for p this computation is a standard sequential reaching definitions analysis this graph contains all data flow edges including all those for local variables and all those from · computes a set of observable conditions for p by the program for locks and predicates q such that q only uses global variables and occurs in p · invariants loc df computes an annotation that is inductive for the loc df using a modification of the standard worklist algorithm as discussed in section · c computes an observable formula v for every location v that is implied by v and is at least as strong as any other observable formula with that property · computes the relation through a bottomup evaluation of the logic program given in figure example consider the program in figure figure how the and annotation computed by on this program for simplicity we show only information that is relevant to the counter variable in particular the contains only vertices that modify or block on counter and all the edges between them and the annotation is restricted to refer only to the variable counter a special vertex x appears in the to improve readability by factoring edges it does not represent a real vertex an edge u x from some arbitrary vertex u to x represents four edges u u u u u and u v the vertex is the initial location of the program where every thread begins its execution and which has u and v as its control flow successors its action is to assume the condition of the initial state as in lock lock the edges in figure are added in the first round the dashed edges are added in the second round and the dotted edges are added in the third round the columns labeled and represent the annotation of the corresponding location in the first second and third note that there is no edge from u to v this is very important for proving the assertion at v since the invariant at u always remains counter the interference analysis can infer that there is no feasible path of the program this edge any feasible path of the program that u has to go through a counter increment u or an assume statement v before it can reach v and since each of those paths contains a location modifying counter in the segment from u to v they cannot be witnesses for a data flow edge from u to v finally the correctness condition of algorithm is stated in the following theorem theorem soundness for any program p computes an annotation and a p such that p represents p and for every reachable state s of p and thread n sn proof sketch let and p be the be the annotation and data flow graph computed by the termination condition algorithm input a program p loc cf gv lv l · output a sound annotation for p loc df c df repeat df df df invariants loc df c df until df df return of implies that is inductive for p and every feasible trace of p is represented in p we first prove that every feasible trace of p is feasible by induction on the base case is trivial since is feasible for any for the induction step assume that n v is a feasible trace and is feasible we must prove that n v is feasible since n v is feasible there must exist some s · and s state such that s s a n v by the definition of we have that s we note that for a formula with free variables in gv the meaning of s is since assigns a single value to each global variable x gv moreover we note that if s free variables are in gv then sn iff s since sn and s agree on the values of all global variables let m n be an arbitrary thread since is feasible is represented by the loc df since is inductive for loc df and s · we have that sm by corollary it follows from the definition of that s and thus s since this holds for all m n v is feasible noting that m since every feasible trace is an feasible trace and every feasible trace is represented by p every feasible trace is represented by p and so p is represented by p finally let s be a reachable thread state and let n n be a thread then there exists some feasible trace such that s · since is feasible by the above argument it follows that is represented by p finally since is represented by p and is inductive for p we have that sn by corollary relational abstract domains we have discussed only the use of also known as independent attribute abstract domains up to this point although such domains are typically very efficient the fact that they cannot encode relationships between variables limits their expressive power in our framework it is possible to use relational domains such as and polyhedra by modifying the data flow graph instead having data flow graph edges labeled with a single variable we allow sets of variables as labels indicating that the value of every variable in this set flows from the source to the target since a value for each x x flows along such an edge u x v relationships between variables in x can be maintained a particularly simple instance of this idea is to create a partition p of the set of variables var into semantically related sets intuitively we can think of each cell x p as a variable with one field for each x x for a given partition p of var the collecting semantics for a relational loc df with edges is given by the following x e e e x inv e u x v x x p e e inv e e l v if v otherwise using the collecting semantics as a it is straightforward to define inductive invariants for relational the interference analysis of section must then be adapted to infer relational data flow edges towards this end we mod to act on cells rather than variables as follows x p x by the interference analysis in figure with in place of mod we obtain our algorithm for calculating data flows in a relational since analyses and relational analyses operate on different data flow graphs it is not generally true as in the case of sequential analyses that a relational analysis is necessarily more accurate than a analysis there is a positive side and a negative side to variables when it comes to concurrent program analysis on the positive side variables together makes it possible to infer relationships between variables which results in a more precise analysis on the negative side variables together may create additional interference edges resulting in a less precise analysis as is generally larger than for v loc for example if and counter are together in the relational construction for figure then the interference analysis will infer the edges v u and u v with these edges present the invariant that counter at v can no longer be proved because the condition for annotations implies that there is no lower bound for counter at v in our experiments in section there are cases when interval analysis succeeds in proving a property correct when analysis fails and vice versa in section we briefly discuss the simple algorithm that we use to partition variables into semantically related sets while simple this algorithm performs fairly well on our benchmarks however we believe that there is considerable room for improvement with a better variable algorithm experiments the approach presented in this paper is implemented into a tool called we used a benchmark suite of linux device drivers to evaluate additionally we ran on the set of boolean programs generated by from these linux drivers to compare with two recent techniques on verification of parameterized boolean programs implementation is written in ocaml and makes use of the frontend for the c language and the goto program frontend distributed with our abstract interpreter uses the library for its numerical abstract domains we use the datalog implementation to perform the interference analysis described in section currently accepts three types of inputs c programs using library for thread operations boolean programs in the input language of as an input or goto programs as produced by the cc frontend part of the project for more information on this tool see device drivers assertions sc wf wf total interval analysis safe time ms s s s ms ms s s s s s s s s s ms analysis safe time ms s ms ms ms ms ms s s ms s s s ms ms table performance on parameterized integer programs run on an core tm machine with gb of ram our implementation currently all function calls and then performs an intraprocedural analysis alias analysis we use a typebased alias analysis to handle pointers for each variable whose address is not taken we assign a memory location which receives strong updates for every type in the program we assign a memory location which receives weak updates and each access path of that type other than variables whose address is not taken is considered to be a reference to that memory location the interference analysis implemented in operates on these memory locations rather than variables this scheme is sound under the assumption that expressions are never cast for the benchmark suite used in section aliasing is not particularly important for proving array bounds and integer overflow properties therefore we expect the consequences of our unsound and alias analysis to be we use algorithm to partition variables into semantically related sets for our implementation of analysis while simple it seems to be effective in practice when performing an analysis on boolean abstractions of linux device drivers algorithm variable partitioning algorithm input a set of program locations loc a set of local variables lv and global variables gv output a partition of var p is a disjoint set data structure p x x var for v loc do if v is an assignment statement then vs if vs vs lv vs gv then merge the partitions of each x vs end if else if v then if lv gv then merge the partitions of each x end if end if end for return p evaluation below we provide the results of with on a collection of linux device drivers and on boolean abstractions of those drivers since a driver may have arbitrary many clients it is important to verify these drivers in a parameterized setting parameterized integer programs table presents the result of running on a collection of linux device drivers these drivers are all written in c and include infinite data such as integer types we know of no other tool that can verify numerical properties of such large programs with arbitrarily many threads and therefore we present the result of running on these integer benchmarks without comparison with other tools and are used to automatically process each driver into a goto program annotated with assertions checking array bounds and integer with an analysis to prove most of the assertions correct out of a total and does so in performance using an analysis is slightly worse proving assertions correct in most false positives for appear to be caused by one of two reasons in the abstract domain and in how handles the treatment of in goto programs in particular many drivers use traverse arrays as in the below for i i since our abstraction of arrays has no special representation for arrays flags this as an array bound error since no upper bound for i can be inferred our handling of is because goto programs model them as pointers to integers which take value either or depending on whether the lock is acquired access to which is protected by atomic blocks due to our alias analysis lock can only weakly update this integer field which means that two threads can it is possible to run on the integer benchmarks by first extracting boolean programs with however is designed for sequential programs rather than concurrent ones and the boolean programs extracted by the version of that was available at the time we ran our experiments produced results the combined procedure took and did not prove any assertions correct device drivers programs sc wf wf total safe unsafe li unknown timeout analysis safe unsafe timeout interval analysis safe unsafe timeout table comparison with linear interfaces for parameterized boolean programs average time per benchmark was s for li and s for benchmarks were run on an core tm machine with gb of ram acquire the same lock neither of these sources of is due to a fundamental limitation of the analysis technique proposed in this paper or related to concurrency and we expect that our false positive rate to drop considerably with the core algorithm unchanged parameterized boolean programs although boolean programs are not the target of this work we with them for two reasons two recent approaches for verification of parameterized concurrent programs only accept boolean programs as their input and there is no aliasing present in boolean programs which limits the scope of for a better evaluation of the core method does not require a predicate abstraction phase to handle linux device drivers but to present a more fair comparison with the existing tools we also ran on the boolean abstractions we compare against two recent algorithms that handle parameterized boolean programs dynamic detection from as implemented in and linear interfaces li from as implemented in we compared these tools against our own on the benchmarks used in the papers as provided by the authors the programs were generated by from a set of linux device drivers the input formats of and are slightly different so we report the results separately the and benchmarks were generated from the same device drivers but refer to a different set of boolean programs in tables and each li benchmark consists of a server and a client thread template where the client template is replicated arbitrarily many times the client thread template is the device driver code and the server thread template simulates the os interacting with the drivers in the benchmarks there is a single thread template that is replicated all benchmarks were run with a timeout of table presents the results of comparison with the li algorithm on the set of boolean programs used in in the li algorithm the system is tested under of scheduling to look for a counter example and if one is not found then an adequacy checker is executed that may succeed in proving the program safe for arbitrarily many threads and of scheduling the safe columns refer to the number of instances that were proved safe for each analysis the unsafe column for li refers to the instances for which li found a counterexample a bug while in it refers to the instances where assertions could not be proved safe the timeout column for li refers to instances where li cannot finish checking the program under or cannot find a counterexample under and the adequacy checker times out while trying to prove the program safe the timeout column for refers to all the instances that cannot prove safe within the timeout limit the unknown column for li refers to the instances that no counterexample is found and the adequacy checker but fails to prove the program safe for arbitrary number of threads in almost all benchmarks other than can prove many more instances safe and for it is close vs can prove many of the unknown and timeout instances of li safe the small table below presents a different view of the same results not distinguishing among individual drivers oct safe unsafe timeout safe unsafe li timeout unknown the above table compares the results of the analysis in with li can prove an additional programs correct compared to li there are instances that reports a false positive a program that is known to be safe but fails to prove safe there are a total of programs that are proved safe by and programs that are correctly declared unsafe and therefore generates a total of correct answers this puts the percentage of incorrect answers out of the total number of correct and incorrect answers for at table presents the results of comparison with the algorithm on the set of boolean programs used in in the algorithm there is only one thread template which is replicated until a counterexample or a point is found a point is a number of threads n such every thread state that is reachable with m n threads is also reachable with n threads for the subset of these benchmarks where does not time out the is at most threads interval and analysis substantially in proving programs correct in note that since our approach is not complete failure to prove an assertion does not imply that the assertion is necessarily false device drivers programs safe unsafe timeout analysis safe unsafe timeout interval analysis safe unsafe timeout table comparison with dynamic detection for parameterized boolean programs average time per benchmark was s for and s for benchmarks were run on an machine with gb of ram particular can prove a total programs correct with interval and analysis combined in contrast to for and there are no programs which proves safe and which cannot related work verification and analysis of concurrent programs has been studied here we focus on verification of parameterized concurrent programs and systems which is more relevant to our work extensive research has been done in the area verification of parameterized protocols these include but are not limited to split invariants regular model checking parameterized model checking network invariants and exploiting symmetry in the tool counter abstraction has been a useful technique in verifying replicated components although bounded as discussed in section we believe that proving functional correctness of a protocol is much more involved compared to proving program assertions correct in program such as a device driver the focus of our work for example the correctness of protocol requires complex global invariant with quantifiers in contrast we expect driver code to use significantly simpler invariants to enforce synchronization such as a flag being set or a lock being held moreover global program properties such as mutual exclusion are part of the correctness of a protocol such as whereas we focus on program assertions which are not expressive enough to relate the states of different threads to each other to the best of our knowledge the body of work on verification of parameterized protocols some of it mentioned above does not contain a single tool that can for example effectively verify numerical properties of linux device drivers with many threads recently two new approaches have been proposed for verification of parameterized boolean programs that target boolean abstractions of linux device drivers and are more closely related to our work in a detection algorithm is proposed to determine a bound on the number of threads needed to explore all thread states in an under approximation method based on limiting the number of scheduler as opposed to and the use of linear interfaces to summarize interference in a round is proposed we compare against both these algorithms in our experiments in section the most important advantage of our framework is that we handle unbounded data domains such as integers whereas these other techniques are limited to boolean programs based on our experiments it is a significant advantage to be able to apply directly to integer programs since predicate abstraction does not make any considerations for threads a very recent work takes a first step towards closing this gap by making predicate abstraction in an abstract domain construction was presented which can represent invariants of the form tt where t is a variable representing a thread t is an abstract value in some base domain since such an invariant is an assertion about all threads rather than some fixed set this technique is applicable to parameterized programs the authors apply their construction to a shape domain and successfully verify linearizability for a number of concurrent data structures a property that is more complex than the type we consider in this paper however computation of abstract transformers for quantified domains is potentially very expensive moreover our computation of thread interference using traces is potentially more accurate than their method which is statebased there are a few recent approaches in concurrent program verification which assume a fixed number of threads and therefore not applicable to parameterized programs and not directly comparable to our work but are worth here the work in uses predicate abstraction to automatically generate environment abstractions for threads in a relyguarantee based proof method they attempt to find a modular proof where the environment of every thread refers only to global variables if one exists and generate a one local variables can occur everywhere otherwise they can prove more sophisticated properties such as correctness of algorithm than but only for a small fixed number of threads therefore it is hard to draw any fair comparison between the two tools the work in is based on abstract interpretation where they refine the transaction graphs which model interference among threads using abstract interpretation at a high level our work is similar to the approach in however there are significant differences besides the fact that our approach deals with parameterized programs our notion of interference is quite different and our need to iterate our analysis until convergence is for a different reason in particular in the notion of interference is static in the sense that the structure of the dataflow equations do not change from one round to the next only the abstract values involved change conclusion and future work we propose a solution to the problem of thread invariants for parameterized multithreaded programs our approach is based on an iterative framework consisting of a feedback loop between two components one that computes data invariants using a data flow graph representation of the program and another that uses the data invariants to infer new data flow edges and update the data flow graph our algorithm is sound and terminating and is applicable to programs with infinite state eg unbounded integers and many threads we have implemented our approach into a tool called and applied it to a selection of linux device drivers and a large suite of boolean programs our experiments demonstrate the effectiveness of the approach in proving properties of parameterized concurrent programs in terms of both speed and precision aliasing is a big for any program verification method and more specifically for concurrency verification in our framework distinguishing two global variables as can potentially have a impact on the patterns of interference among threads and make or break a proof of correctness also naturally information about data invariants and thread can result in a more precise alias analysis for concurrent programs we believe that combining alias analysis inside the feedback loop in our framework is an interesting research question for future work as discussed in section a more algorithm for com variable groups for relational analyses will also definitely improve the precision and scalability of our analysis acknowledgments we wish to thank podelski for his significant role in improving the presentation of this paper we would also like to thank and cousot for their comments on an earlier version of this paper finally we thank and for providing the boolean programs and for their help with running and references j d n he a n and m project url t a pnueli s j xu and l d parameterized verification with automatically computed inductive assertions in cav pages ­ g m t and d symbolic counter abstraction for concurrent software in cav pages ­ j berdine t r g and m sagiv thread quantification for concurrent shape analysis in cav volume of lncs pages ­ j and a a library of numerical abstract domains for static analysis in cav pages ­ a b m and t regular model checking in cav pages ­ j k lee a r v sarkar and m efficient and precise detection for multithreaded objectoriented programs sigplan not ­ e clarke d and f a tool for checking programs in k and a podelski editors tools and algorithms for the construction and analysis of systems tacas volume of lecture notes in computer science pages ­ springer isbn x e m clarke d n and k predicate abstraction for in tacas pages ­ a and k s local proofs for properties of concurrent programs in cav pages ­ a f a d and t predicate abstraction for concurrent programs in cav pages ­ e a emerson and v model checking and parameterized resource allocation systems in tacas pages ­ e a emerson and a p symmetry and model checking form methods syst des ­ d and k effective static detection of race conditions and deadlocks syst rev ­ a gupta c and a rybalchenko predicate abstraction and refinement for verifying multithreaded programs in popl pages ­ c n ip and d l verifying systems with replicated components in r johnson and k program analysis in pldi pages ­ v s and a gupta semantic reduction of thread interleavings in concurrent programs in tacas pages ­ a d and t dynamic detection in parameterized concurrent programs in cav pages ­ y o m a pnueli and e symbolic model checking with rich languages in cav pages ­ y a pnueli e and l d network invariants in action in concur pages ­ s la p and g modelchecking parameterized concurrent programs using linear interfaces in cav pages ­ s k and r e predicate abstraction with indexed predicates acm trans comput logic l lamport a new solution of concurrent programming problem acm ­ a static analysis of runtime errors in embedded critical parallel c programs in esop pages ­ berlin springerverlag isbn m and a aiken conditional must not aliasing for static race detection sigplan not ­ m a aiken and j effective static race detection for java sigplan not ­ g c necula s s p and w intermediate language and tools for analysis and transformation of c programs in cc pages ­ a pnueli s and l d automatic deductive verification with invariants in tacas pages ­ a pnueli j xu and l d liveness with counter abstraction in cav pages ­ isbn p j s foster and m contextsensitive analysis for race detection sigplan not ­ n a static data race analysis tool in usenix pages ­ j and m s lam contextsensitive pointer alias analysis using binary decision diagrams sigplan not ­ june 