formal verification of object layout for c multiple inheritance inria texas am university leroy inria abstract object layout the concrete representation of objects raises many issues in the case of the c language in particular to multiple inheritance c compatibility and separate compilation this paper formalizes a family of c object layout schemes and mechanically proves their correctness against the operational semantics for multiple inheritance of et al this formalization is flexible enough to account for techniques such as empty base class optimization and optimization as an application we obtain the first formal correctness proofs for realistic optimized object layout algorithms including one based on the popular common c application binary interface this work provides semantic foundations to discover and justify new layout optimizations it is also a first step towards the verification of a c compiler frontend categories and subject descriptors d software engineering proofs d programming languages language constructs and and objects d programming languages e data storage representations object representation f logics and meanings of programs studies of program constructs general terms languages verification introduction one of the of compilers and interpreters is to represent the data types and structures of the source language in terms of the lowlevel facilities provided by the machine bits pointers etc in particular for data structures that must be stored in memory an appropriate memory layout must be determined and implemented this layout determines the position of each component of a compound data structure relative to the start address of the memory area representing this structure partially supported by nsf grants and partially supported by grant permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission andor a fee popl january ­ austin tx usa copyright c acm many programming languages are implemented using straightforward memory layouts in fortran and c for example compound data structures are out in memory their members in a conventional order such as ordering for fortran arrays or declaration order for c structures is inserted between the members as necessary to satisfy the alignment constraints of the machine higherlevel languages leave more flexibility for determining data representations but practical considerations generally result in simple memory layouts quite similar in principle to those of c structures with the addition of tags and dynamic type information to guide the garbage collector and implement dynamic dispatch and type tests this paper focuses on data representation for objects in the c language c combines the many scalar types and pointer types inherited from c with a rich object model multiple inheritance with both repeated and shared inheritance of base classes object identity distinction dynamic dispatch and runtime type tests for some but not all classes this combination raises interesting data representation challenges on the one hand the layout of objects must by the semantics of c as defined by the standards on the other hand this semantics leaves significant flexibility in the way objects are out in memory flexibility that can be and has repeatedly been exploited to reduce the memory footprint of objects a representative example is the empty base optimization described in section as a result of this a number of optimized object layout algorithms have been proposed implemented in production compilers and as part of application binary interfaces section some of these algorithms and their evolution these layout algorithms are quite complex sometimes incorrect see myers for examples and often difficult to relate with the highlevel requirements of the c specification for example the c common several pages to the specification of an object layout algorithm which includes a special cases the work reported in this paper provides a formal framework to specify c object layout algorithms and prove their correctness as the highlevel specification of operations over objects we use the operational semantics for c multiple inheritance formalized by et al which we have extended with structure fields and structure array fields section we then formalize a family of layout algorithms independently of the target architecture and a number of conditions they must respect while leaving room for many optimizations section we prove that these conditions are sufficient to guarantee semantic preservation when the highlevel operations over objects are as memory accesses and pointer section finally we formalize two realistic layout algorithms one based on the popular common c and its ex with one further optimization we prove their correctness by showing that they satisfy the sufficient conditions section all the specifications and proofs in this paper have been mechanically verified using the coq proof assistant the coq development is available online the contribution of this paper is on one hand it is to the best of our knowledge the first formal proof of semantic correctness for realistic optimizing c object layout algorithms one of which being part of a widely used moreover we hope that large parts of our formalization and proofs can be reused for other present or future layout algorithms on the other hand just like the subobject calculus of and friedman and the operational semantics for multiple inheritance of et al were important first steps towards a formal specification of the semantics of realistic subsets of the c language the work presented in this paper is a first step towards the formal verification of a compiler frontend for realistic subsets of c similar in principle and structure to earlier compiler verification efforts for other languages such as java c and c overview the object layout problem generally speaking an object layout algorithm is a systematic way to map an abstract view of objects down to memory accesses and pointer operations at the source level a c object is an abstract entity over which various primitive operations can be performed such as accessing and updating a field converting an object or an object descriptor to another type or dispatching a virtual function call at the machine level an object descriptor is a pointer p to a block of memory containing the current state of the object the object layout scheme determines at compiletime how to the object operations as machine instructions · accessing a field f defined in the class c of the object becomes a memory read or write at address p where the constant offset is determined by the layout algorithm as a function of c and f · dispatching a virtual function call is achieved by the dynamic type information attached to the object typically a virtual function table a pointer to which is stored at a fixed offset relative to p · converting to a base class superclass d of c is also achieved by adding an offset to the pointer p making it point to the subobject of class d contained within the offset can be statically determined in many cases but to multiple virtual inheritance it may have to be determined at runtime by the dynamic type information of the object · accessing a field f defined in a base class d of c is achieved by converting p to d then accessing f at a fixed offset from the resulting pointer for the generated machine operations to correctly implement the c semantics of object operations the object layout scheme must satisfy a number of correctness conditions first when a scalar field is updated the values of all other fields must be preserved this immediately translates to the following requirement field separation two distinct scalar fields reachable through inheritance andor fields from the same object map to disjoint memory areas moreover the hardware architecture can impose alignment constraints on memory accesses for example loading a bit integer is possible only from an address that is a multiple of this leads to a second requirement field alignment for any field f of scalar type t the natural alignment of type t its memory address besides containing fields c objects also have an identity which can be observed by taking the address of an object and comparing it using the or operators with addresses of other objects of the same type the c semantics specifies precisely the outcome of these comparisons and this semantics must be preserved when the comparisons are as pointer comparisons object identity two pointers to two distinct subobjects of the same static type a obtained through conversions or accesses to structure fields map to different memory addresses this requirement is further by the fact that c operates under a separate compilation model inherited from c and the fact that every class can be used independently to create complete objects and every subobject in isolation is a potential target of most operations supported by any complete object of the same type furthermore some classes are considered to be dynamic those classes that need dynamic type data to perform virtual function dispatch dynamic cast access to a virtual base or other dynamic operations the concrete representation for objects of these dynamic classes must include dynamic type data usually as a pointer to a data structure describing the class and such data must be preserved by field updates dynamic type preservation any scalar field maps to a memory area that is disjoint from any memory area to hold dynamic type data the separation conditions between two areas holding dynamic type data are weaker than the separation conditions for fields indeed most layout algorithms that the dynamic type data for a class c is shared with that of one of its dynamic nonvirtual direct bases called the nonvirtual primary base of c and chosen during layout in a way that preserves the semantics of virtual function dispatch and other dynamic operations dynamic type data separation for any two dynamic classes the memory areas of their respective dynamic type data must be disjoint unless one of the classes is the nonvirtual primary base of the other the layout scheme early c compilers such as translator used a simple object layout algorithm that obviously satisfies the requirements listed above in effect all components of a class fields base classes and dynamic data if needed are out following a conventional order inserting unused bytes between components and after the last component as necessary to satisfy alignment constraints in this approach each component base or field of a class c has its own memory area disjoint from those of all other components of c moreover each class is represented by at least one byte of data even if it contains no fields nor dynamic type data this trivially enforces the object identity requirement tail optimization the simple layout scheme just described is inefficient in space because it never attempts to reuse to store useful data consider struct a int a struct b a char b struct c b char c assume the size and natural alignment a b c of type int are bytes to ensure proper alignment of field a bytes of are inserted after field b in b and more bytes b of are inserted after field c in c to understand why consider arrays whose elements have type b or c consequently b has size while c has size however it is to reuse one a b c of the bytes of present at the end of b to hold the value of field c of c in this case c only bytes for a nice space of this layout trick is known as the tail optimization and is used by many c compilers empty base class optimization empty classes offer another for space that is unused in a base class consider struct a struct b a struct b a struct c b b char c char c c c a a a b c a a a b c here the classes a b and b are empty they contain c c no field and need no dynamic type information it is to give them size so that their instances t a a no memory space at all however this would violate the object identity requirement as depicted to the right the pointers a and a to the two instances of a logically contained within c would compare equal while cs semantics that they are different the layout algorithm must therefore insert at least one byte of in a resulting in a b and b having size following the naive approach outlined in section c therefore bytes c c b b a a however it is unnecessary to keep the fields c and c disjoint from the subobjects of types b and b the inserted in the latter to satisfy the object identity requirement can be reused to hold the values of fields c and c as shown to the right c c bc t a a this technique is known as the empty base class optimization it is implemented by many c compilers but often in restricted cases only here is an example where gcc misses an for the tail of an empty base class struct a struct b a struct b a struct c b b char c struct d c char d as in the previous example b and b must be out at different offsets within c to allow distinguishing the two a contained in c thus c must have size at least this lower bound can be achieved by placing c at offset as explained above what about d gcc places d at offset resulting in a size of for d however the second byte of c is just introduced to preserve the identity of empty base classes and it can be reused to hold data such as field d this optimized layout d in just two bytes why empty classes matter over the years successful c software such as the standard template libraries stl has become dependent on cs ability to efficient code based on simple techniques such as empty classes and inlining part of the success of the stl is based on its use of function objects these are objects of classes with the function call operator overloaded these objects typically do not carry any runtime data rather their semantics is their static types as an example consider sorting an array of integers the stl provides the following template template ran comp void first ran last comp the comparator could be a pointer to function like the function in c but in c it is any object whose type the function call operator struct int int bool bool i int j const return i j the sort template can then be invoked as t n the comparator object constructed by is of interest not for its runtime data it carries none but for its type the comparison function is not passed to the sorting routine through data but through the type of the object consequently it is directly called and in most cases since the body is a simple integer comparison which typically reduces to a single machine instruction this simple technique a of the stl success is effective one can think of it as a simulation of dependent types where data is encoded at the level of types therefore making data flow obvious the function object technique just described is at the basis of a composable component of the stl composition implies a protocol that parts being composed should to for example if we want to combine two unary function objects we need a mechanism to ensure that the result type of one function object with the argument type of the other to that end the stl requires the existence of certain nested types such as and in the class above to reduce the stl provides classes that define those types in this case one would write struct bool i int j const return i j the purpose of is to provide those nested types it is an empty base class that introduces no data and no virtual functions its semantics is purely static this usage while not objectoriented programming by most popular definitions is very common in modern c programs the pattern is not restricted to only one empty base class a class can inherit from several empty base classes this is the case of which inherits both from and a compiler that effectively supports c should not have to allocate space for such empty classes since their runtime semantics are completely irrelevant while an optimization in c the empty base optimization is considered so important that it is required in the next version cx semantic model to capture the expected behavior of c object operations we build on the model of multiple inheritance introduced by and friedman and further developed and mechanized by et al using the proof assistant in this section we briefly recall the main aspects of this model referring the reader to for full details then describe how we extended it to handle fields that are themselves structures or arrays of structures and finally use the model to given an operational semantics to a simple calculus of c objects modeling multiple inheritance a c class can inherit from several base classes consequently a class d can inherit from another class a through several different ways consider for example struct a int a struct b a struct b a struct c a struct d b b c b b c ds d t d an instance of d contains as many copies of a as ways to inherit each copy of a is called a subobject of d of static type a in this example d has three different subobjects of static type a obtained through the base classes b b and c this is called nonvirtual inheritance by replicated inheritance by and friedman or repeated inheritance by et al however the programmer can to declare some base classes as virtual as in the following example struct a int a struct b virtual a struct b virtual a struct c a struct d b b c aa b b c d in this case b and b contribute only one subobject of static type a to class d the paths ba and ba the same subobject this is called virtual inheritance or shared inheritance note however that c another distinct subobject a to d since c inherits from a in a nonvirtual manner following et al we capture this notion of subobject and these two of inheritance as follows a base class subobject of a given object is represented by a pair h l where h is either repeated or shared and l is a path in the nonvirtual inheritance graph the directed graph having classes as nodes and edges u v if and only if v is a direct nonvirtual base of u more formally we write c i a to mean that a base class subobject of class c this subobject having static type a this predicate is defined inductively c repeated c i c b direct nonvirtual base of c b repeated l i a c repeated c l i a b virtual base of c b h l i a c shared l i a the fields of a full instance of a class c then are the pairs f where c i a and f is a field defined in class a in the first example above the fields of d are repeated d b a a repeated d b a a repeated d c a a while in the second example involving virtual inheritance they are shared a a repeated d c a a structure fields and structure array fields in the original formalization of et al fields are restricted to scalar types arithmetic types or pointer types we extended this formalization to support fields that are themselves structures or arrays of structures to simplify presentation we only consider arrays of structures treating a structure field or variable c x as a array c x in our formalization a full object is always an element of a possibly array of structures which is either bound to a program variable or dynamically created using new or appears as a structure array field of a larger object to a subobject of an array of structures we therefore proceed in three steps select an array of structures contained in this array select an element of this select a base class subobject of this element in the sense of section to select an array of structures contained in a larger array we introduce the notion of an array path from an array of n structures of type c to an array of n structures of type c written cn a c n array paths are defined inductively by the following rules i n c i a cn i ci a n n cn a cn f f d m is a structure field defined in a cn i ci a dm a c n cn i f a c n then a generalized subobject of type a of a full object of type cn is a triple i where is an array path from cn to some c n and i n is an index in the array of type c n and is a base class subobject of c of type a we write cn i a and formally define this relation by c n a c n i ci a c n i a consider for example struct z struct a z struct b a a struct c virtual b struct c virtual b struct d c c struct e d d e e the expression z denotes the generalized subobject i within e where repeated e d shared b a i repeated a z the static type of a generalized subobject i is the static type of the base class subobject this generalized subobject denotes a full instance of class c if and only if is the trivial subobject of c of static type c that is repeated c an operational semantics building on these notions of subobjects we now give an operational semantics for a small address intermediate language a object model the syntax of this language is as follows x ranges over variable names stmt x xn arithmetic x null pointer x x c field field access xc field x field assignment x array indexing x x x pointer equality test x static cast c c x static cast x dynamic cast c c x dynamic cast object operations are annotated with static types c as determined during typechecking for instance in field operations c is the class that defines the field being accessed in conversions c is the static type of the argument of the conversion and c is the destination type our coq formalization also includes some control structures sequence conditional loops which we omit for simplicity also omitted are virtual function calls object creation and object destruction which we have not fully formalized yet the operational semantics uses the following semantic objects v atom base value ptr null pointer ptr n pointer to a subobject v x v variable environment n f t v values of scalar fields h c n object heap the state of the execution is a pair v h of an environment v mapping variable names to scalar values either base values or pointers and a heap h mapping toplevel object identifiers to their type cn and their contents the contents is in turn a mapping from scalar field pairs of a generalized subobject n and a field f t to scalar values the operational semantics is given as a transition relation stmt v h v h relating the state v h before and the state v h after executing stmt we show some representative rules v x i ho c n cn i a f is a scalar field of a x x af v h v x i f h v x i ho c n cn i a f is a scalar field of a i f v x x v h v ho c n v x i ho c n cn i a f f a n is an array field of a p o i f repeated a x x af v h v x ptr p h v x i repeated a ho a n a n a a n i n v x atom j i j n p o i j repeated a x x x v h v x ptr p h for reads and writes over scalar fields first two rules above the content map of the toplevel object o being accessed is or updated at the path i to the subobject and the accessed field in contrast accessing a structure array field third rule and addressing an array element fourth rule just synthesize the appropriate subobject from that given in the object pointer in the case of a structure array field the given subobject i is refined into the i f repeated a the structure array stands for list concatenation for array addressing only the i part of the given subobject is modified by lack of space we omit the rules for static and dynamic casts which are complicated but similar to those given by et al formalization of a family of layout algorithms in this section we formalize the interface to a family of layout algorithms and sufficient conditions ensuring that they are semantically correct parameters our formalization is independent of the characteristics of the hardware platform it is parameterized by a set of scalar types arithmetic types eg int short char float double etc and pointer types for each scalar type t we take as parameters its size and its natural alignment the only assumptions we make about size and alignment is that they are positive and that all pointer types have the same size and alignment the unit of size is not even specified a natural choice is bytes but bits could be used as well likewise natural are not required to be of as additional parameters we also assume given a positive size and a positive natural alignment for dynamic type data for simplicity we assume that dynamic type data has the same size for all classes this was not always the case in early compilers but the is to store only a pointer to a class descriptor thus a constant access overhead one or two more but significant improvements on the size of objects interface of a layout algorithm let c be a class we introduce the following notations · is the set of direct nonvirtual bases of c · is the set of direct or indirect virtual bases of c · is the set of scalar fields declared in c each such field is of the form f t where f is an identifier and t is a scalar type · is the set of structure array fields declared in c each such field is of the form f b n where f is an identifier b is the structure type of the field and n is the number of elements in the array · is the set of all fields declared in c for every class c in the program a layout algorithm is expected to compute each of the following as depicted in figure · is the primary base of c if any more precisely either or b for some direct nonvirtual base b of c · n assigns offsets to the nonvirtual direct bases of c · n is an offset within c representing the boundary between nonvirtual base data and field data · n assigns offsets to the fields declared in c · n is the nonvirtual data size of c the data size of its nonvirtual part · n is the nonvirtual size of c the total size of its nonvirtual part b f v b b f v dynamic type data for c and b b nonvirtual data of b nonvirtual base data nonvirtual data data of c b b empty b b b field data virtual base data f v fv offsets to empty bases of b nonvirtual part of b nonvirtual part of c offsets to empty classes accessible from f field f offsets to empty bases of v virtual base v figure a proposed layout for a full instance of a dynamic class c having a primary nonvirtual base b a nonempty nonvirtual base b an empty nonvirtual base b a field f and a virtual base v areas represent represent offsets to inheritance or field subobjects of c of empty types the top part the layout parameters related to data the bottom part those related to object identity · n gives the offsets of the virtual bases of c · n is the total data size of c · n is the total size of c this is the that evaluates to for the purpose of our formalization c can be considered as a virtual base of itself thus we introduce the notion of a class b being a generalized virtual base of c either b c or b is a direct or indirect virtual base of c thanks to this notion we can state that the layout of a full instance of c is composed of the layout of the nonvirtual parts of the generalized virtual bases of c for this instance with the nonvirtual part of c starting at offset thus we may safely extend the domain of by taking c empty classes and dynamic classes our formalization leaves partially specified the notions of empty classes and dynamic classes leaving their exact definitions to the layout algorithm subject to the following conditions · an empty class must not contain any scalar field · an empty class must not contain any structure field of a nonempty class type · an empty class must not have any nonempty base · a dynamic class is not empty · if a class c has a virtual base then c is dynamic · if a class c has a nonvirtual primary base b then both c and b are dynamic in our formalization the data size and the nonvirtual data size of a class are of interest only if the class is not empty our way of empty classes and dynamic classes can be understood as follows the data of a class is composed of all its reachable scalar fields and dynamic type data an empty class is a class that requires no data and a dynamic class is a class that requires dynamic type data computing offsets and compiling object operations once the listed in section have been computed by a layout algorithm all the offsets mentioned in section and required during compilation can be computed as follows the offset l of a nonvirtual base class subobject repeated c l within the lowlevel representation of a subobject of static type c is b l b l the offset h l of the base class subobject h l of c within the lowlevel representation of a full instance of c is computed as follows repeated c l l shared b l b l if l is an array path from cn to c n then the offset l of the first element of the array of n elements of type c designated by l within the lowlevel representation of an array of n elements of type c is determined by and i s f a m i · s a m where b is the static type of s finally the offset i s of a generalized subobject i s within an array of structures of type c is computed as follows i s i · where bm is the destination type of using these offsets we now outline a compilation scheme for the intermediate language of section the target language is a conventional lowlevel intermediate language a flat memory pointer arithmetic and explicit p and p x operations to read and write at address p for field and array accesses we have x x c f x x f if f f t is a scalar field of c xc f x x f x if f f t is a scalar field of c x x c f x x f if f is a structure array field of c x x x × x x x x x x x for static casts we have two cases depending on whether inheritance is virtual or not if c repeated l i a for a uniquely defined path repeated l conversion to or from a nonvirtual base the static cast is achieved by the pointer by a constant offset x static cast a c x x x x static cast c ax x x if c shared b l i a and shared b l is unique conversion through a virtual base the offset of the virtual base b of c must be up in the dynamic type data x static cast a c x t x x x b finally the code x dynamic cast a c x for a dynamic cast is t x if a then x x a else x null as shown in the last two cases the target language features three operations over the runtime representation t of dynamic type data b returns the offset appropriate for virtual base b a returns if a dynamic cast to a is possible otherwise and a returns the offset appropriate for a dynamic cast to a in the semantics of our target language we formalize these operations at an abstract level through queries to an oracle the actual concrete implementation virtual table dictionary etc is left unspecified however we have formally proved that such an oracle can always be constructed from a wellfounded class hierarchy soundness conditions we now state a number of soundness conditions over the results of the layout algorithm section shows that these conditions are sufficient to guarantee semantic preservation sizes the first set of conditions ensures that the total nonvirtual size and total size of a class c are large enough to all corresponding components of c c b if b direct nonvirtual base of c c f if f field of c c b if b generalized virtual base of c c c the first two conditions ensure that the total nonvirtual size of c is large enough to hold the nonvirtual part of any nonvirtual base of c c as well as any field of c c we write for the size of the field f computed as follows n · if f has scalar type t if f has array type bn likewise the total size of c must be large enough to hold a full instance of c including any virtual base of c c the nonvirtual part of c itself c again and all data of c its c by contrast it is not required that more precisely the nonvirtual size of a class is an upper bound of the interval in which offsets to fields or subobjects within the nonvirtual part of the class must appear the nonvirtual size plays no role in the correctness of data access however c is used to show that the data of two disjoint cells of a structure array or of two cells of distinct structure arrays are disjoint which guarantees that data access within an object does not affect other objects conversely the nonvirtual data size and data sizes in general play no role in the correctness of subobject identification the c standard that the total size of a class be positive this is necessary to ensure that distinct elements of an array of structures have different offsets we require a stronger condition that the total nonvirtual size of a class be positive c this is necessary to preserve object identity as the following example demonstrates struct a struct b a struct b a struct c b b c c a a a b c a a a b c abc abc uc uc uc uc tt abc abc if the nonvirtual size of a were then c would allow the nonvirtual sizes of b and b to be so that the nonvirtual size of c could be thus c would allow the size of c to be but in that case assuming b at offset and b at offset in c the pointers a and a would compare equal even though they refer to logically different subobjects field separation we now present a set of conditions sufficient to guarantee separation between scalar fields and therefore the good variable property updating a field preserves the values of all other fields these conditions are local they only involve the fields defined in the class c under consideration as well as the layout for its direct bases but do not need to consider inherited fields nor indirect bases they focus on relevant components of the class c under consideration a base class is not relevant if and only if it is of an empty class type a field is not relevant if and only if it is an array of structures of an empty type we write s t to say that two sets are disjoint s t c b b b b if b b distinct nonempty nonvirtual direct bases of c c b if b nonempty nonvirtual direct base of c c f if f relevant field of c c f f f f if f and f are distinct relevant fields of c c f if f relevant field of c c c b b b b if b b distinct nonempty generalized virtual bases of c c b condition c states the absence of overlap between the data of two distinct nonempty nonvirtual direct bases of a class to separate the data of direct nonvirtual bases of c from the data of the fields of c our formalization introduces a boundary such that every nonempty direct nonvirtual base of c has its data out below this boundary c and every relevant field f of c is out above this boundary c it is however possible for the tail of a direct nonvirtual base of c to the data or even the tail of a field of c define the data size of a relevant field f as if f has scalar type t n · if f has array type bn in other words the tail of a structure array field is that of the last element of the array while the tail of the first n elements is part of the data area for this field so that this data area is in memory then condition c states that the data areas of two distinct relevant fields f and f of c are disjoint note however that the tail of a field of c can be reused to hold some of the next fields of c the nonvirtual data size of c like the nonvirtual size and the size of c is not computed directly instead it is constrained as follows the data of any relevant field f of c is included in the nonvirtual data of c c and the nonvirtual data of any direct nonvirtual bases of c is embedded in the nonvirtual data of c c this condition is redundant if c has at least one relevant field finally as virtual inheritance two distinct nonempty generalized virtual bases b and b of c are out in such a way that they do not overlap c recall that a generalized virtual base of c is c itself or a direct or indirect virtual base of c then if b is a nonempty virtual base of c then c is not empty as it has a nonempty base so the above condition holds for generalized virtual bases b and c which guarantees that the data of the nonvirtual part of the virtual base b does not overlap the data of the nonvirtual part of c finally the data of c its contains the nonvirtual data of any generalized virtual base b of c c by contrast since neither any scalar value nor any virtual function can be accessed from an irrelevant component the data of an irrelevant component need not be disjoint from other fields or bases of the same type likewise it is not required that an irrelevant field starts at the field boundary it may also nonvirtual base data field alignment the next set of conditions ensures that every field is out at an offset that is naturally aligned with respect to its type even if the field appears in a base class or an array define the natural alignment of a field f as if f has scalar type t and if f has type bn besides its alignment a class c has a nonvirtual alignment used whenever c is out as a base of another class this distinction allows the nonvirtual part of c to be out under weaker alignment constraints than for a full instance of c especially if the alignment of a full instance of c is constrained by that of a virtual base the conditions related to alignment are as follows we write p q to mean that p q c f and if f field of c c b and if b nonvirtual base of c c if c is dynamic c b and if b is a generalized virtual base of c c in particular c implies that as expected c ensures accesses to the dynamic type data of a class finally c is used to show that an access to an element of an array of type c is correctly aligned it is however not necessary for nonvirtual sizes as there are never any arrays composed only of nonvirtual parts of a class dynamic type data similarly to compilers such as gcc we chose to store the dynamic type data of a subobject at the beginning of the subobject this leads to the following conditions for a dynamic class c c c b if b is a nonempty nonvirtual direct base of c c b b any relevant field must be out after the dynamic type data c if c is dynamic but has no primary base c ensures that all nonempty nonvirtual direct bases of c start after the dynamic type data of c finally the primary base of a class is out at offset so that the class and its primary base can share the same storage for their dynamic type data c as a consequence of c c and c it follows that nonempty direct nonvirtual bases of c other than its primary base are out at offsets at least identity of subobjects the final set of conditions guarantees that two different subobjects of a class c of the same type b map to different offsets in memory this identity requirement is achieved in two completely different ways depending on whether b is empty or not if b is nonempty the requirement follows immediately from c c nonempty in practice actual layout algorithms define empty bases in such a way that this condition automatically holds a nonempty base contains at least one byte of field data or some dynamic type data but we still need to include it in the specification if b is an empty base of c neither condition c nor the field separation conditions suffice to show that two different b subobjects map to distinct memory offsets we therefore need specific conditions for empty bases unfortunately we found no local condition to ensure that two different subobjects of the same empty type are mapped to distinct offsets we need to involve not only the layout parameters of the direct bases of the class c under consideration but also those of all classes reachable from c by inheritance or structure fields indeed if we took a local condition similar to the one used for field separation ­ for instance if we required the whole nonvirtual not only the data of nonvirtual bases to be disjoint ­ then we would lose tail optimization and fall back to a naive implementation similar to that of section therefore we have to compute for any class c the set of empty base offsets ie the offsets of all empty classes reachable from c through inheritance or structure fields similarly we compute for any class c the set of nonvirtual empty base offsets ie the offsets of all empty classes that are subobjects of direct nonvirtual bases or that are reachable through a field of c or a field of a nonvirtual base define s def a o a o s then the sets of the nonvirtual empty base offsets of c and of empty base offsets of c are defined as follows def b c def if c is empty then c else b f b n i · in for the purposes of the coq proofs those sets are described as mutually inductive predicates and intended to be computed separately by algorithms from an implementation point of view we can assume that those sets are computed incrementally when it comes to computing those offsets for c they are assumed to be computed for all of the bases and structure field types of c now we impose that the unions defining and be disjoint c b b if b b distinct nonvirtual bases of c c b f b n j · jn if b nonvirtual base of c and f b n structure field of c c f b n j · j n f b n j · j n if f b n and f b n distinct structure fields of c c if b b distinct generalized virtual bases of c in practice whenever the algorithm tries to out a base or a field it can check its empty base offsets against the empty base offsets out so far for the main class whenever this check fails the offset is by the alignment of the component as the algorithms in section show these checks can be simplified by layout constraints at the cost of some tail optimizations correctness proof we now show that the conditions stated in section are sufficient to guarantee the various separation alignment and disjointness properties discussed in section these properties being in turn sufficient to ensure semantic preservation during compilation all the results below have been mechanically verified using the coq proof assistant we therefore only sketch the proofs giving an idea of how the various conditions are used field separation consider a generalized subobject p of static type a from an array of structures of type c and a field f defined in class a define p f to be the offset of the field f of the subobject designated by p within the representation of the array of type c p f p theorem if p p are two generalized subobjects of static type a a within an array of structures of type c and if f f are scalar fields of a a of types t t respectively such that p f p f then the memory areas associated with these fields are disjoint p f p f p f p f proof first we show that two distinct scalar fields reachable through base class subobjects s and s of a class c are disjoint there are two cases if s s then f f and c concludes otherwise we show that if ai is the static type of si then each fi is included c c c c in the field data of ai the memory between offsets and within ai such that the two field data of s and s are disjoint then we show that if s and s are two distinct base class subobjects of c through nonvirtual inheritance only then their field data are disjoint there are two cases if one subobject say s is a subobject of the other s then a denoting the static type of s field f is on the righthand side of the field boundary of a c whereas f is included in a direct nonvirtual base of a which is on the lefthand side of the field boundary of a c which concludes otherwise s and s are subobjects of some classes a and a that are distinct direct nonvirtual bases of some class a so a similar inclusion scheme combined with c concludes then if s and s are distinct base class subobjects of c we consider the generalized virtual bases of which s and s are nonvirtual subobjects if they are equal then the nonvirtual case above can be reused otherwise c concludes finally we can show our main theorem by induction on the length of the array path of say p then for each i pi fi can be decomposed into ji si fi pi where ji is an integer less than the size n of the array of type cn from which p and p start and si is a base class subobject of c of some static type bi and fi is a field of ai such that either fi pi fi no structure fields are traversed or fi is a structure field of type and pi pi for some generalized subobject pi from the array in that case the array path of p is one element than the one of p which allows induction there are five cases if j j then the scalar fields are included in distinct cells of the initial array as two distinct fields of an array are necessarily disjoint we conclude additionally using c c if s s then fields f and f are included in disjoint field data as fields f and f are included in the data of f and f this concludes if f f then their data are disjoint as the data of each fi is included in the data of fi which may be the same if fi fi otherwise f f is a structure field and we may use the induction hypothesis it is legal to use all those conditions as all considered classes are nonempty as f and f are scalar fields the classes defining them are nonempty so are their derived classes the structure fields containing them and so on alignment theorem if p is a generalized subobject of static type a within an array of structures of type c and if f is a scalar field of a of type t then the access to f via p is correctly aligned p f and proof easy induction on the path using transitivity of the relation alignment conditions c c c and additionally c for array cell accesses access to the ith cell of an array of structures of type b corresponds to by i · which requires an alignment condition for theorem if p is a generalized subobject of static type a within an array of structures of type c and if a is dynamic then the access to the dynamic data of p is correctly aligned p and proof same reasoning as above additionally using c identity of subobjects theorem if p p are two different generalized subobjects of the same static type a within an array of structures of type c then their corresponding offsets are distinct p p p p proof there are two different depending on whether a is empty if it is not empty then the proof is similar to that of theorem thanks to condition c if a is empty all those conditions no longer apply by induction on the length of the array path of p there are two cases if p and p from the same cell of the array of structures of type c then c c c c and the induction hypothesis conclude otherwise we know that the two cells are entirely disjoint not only their data so we simply have to show that each pi is included in its own cell using c c c and also c preservation of dynamic type data the following theorem ensures that writing a scalar field does not change the dynamic type data of subobjects theorem if p p are two generalized subobjects of static type a a within an array of structures of type c and if a is a dynamic class and if f is a scalar field of a of type t then the memory area by the dynamic type data of a is disjoint from the memory area by field f p p p f p f proof the proof that of theorem except that data not only field data must be checked c ensures that dynamic type data is included in the data of a subobject but it also ensures that it is disjoint from the field data if p is a generalized subobject that is reachable from p by inheritance andor scalar fields conversely if p is reachable from p then c c must be additionally used a dynamic class c may share its dynamic type data with one of its dynamic nonvirtual bases b the primary base of c but the semantics of c guarantees that dynamic operations eg dynamic cast dynamic function dispatch on a base class subobject s of c give the same result as on a base class subobject s of c if s is reachable from s ie if s dominates s as the primary base b is a base of c this sharing is semantically sound however initialization of dynamic data has still to be checked even without a detailed semantics of object construction and destruction which is out of the scope of this paper we still have to know whether the dynamic data of a subobject does not change the dynamic data of other subobjects we proved formally that this is the case except for two subobjects s and s such that s can be reached by s through primary bases only a primary path is a path in the primary path graph where classes are the vertices and u v is an edge if and only if v is the primary base of u any nonvirtual path b l can be decomposed into a reduced path l such that · if b l is primary then l def b · otherwise b l can be rewritten as lb b l where b is a nonvirtual base of b that is not the primary base of b and b l is a primary path then l def lb b in other words the reduced path of a nonvirtual path l is obtained by the longest primary path on the right of l theorem let p i h l p i h l be two generalized subobjects of static types a and a respectively from an array of structures of type c assume a and a are dynamic classes if i i or then the dynamic type data of the two subobjects are disjoint p p p p proof the proof proceeds like that of theorem but replacing each li with its reduced path semantic preservation to conclude this section and exercise the theorems above we now sketch a proof of semantic preservation for the compilation scheme given in section the semantics of the target language is given in terms of states v m where v maps variables to target values and m is a memory state in the style of target values v are the union of base values atom bv data pointers ptr i where i an integer is the address of a byte in memory and pointers to dynamic type data memory states are presented abstractly through the two partial operations n m and n v m where i an integer is the address of a byte and n is a byte count by lack of space we omit the operational semantics of the target language referring the reader to the online instead we now define a predicate v h v m relating the states of the program before and after compilation we start with the relation h v v between source values and target val h atom bv atom bv h ptr ptr ho c n cn i a h i i in the last rule is a partial mapping from object identifiers o to memory addresses it represents the initial placement of toplevel objects in memory agreement v h v m between a source state and a target state is then the conjunction of the following conditions variable agreement h v x v x for all x alignment of toplevel objects if ho c n separation between toplevel objects n × n × if ho c n and ho c n and o o correct values for scalar fields h i f t i t m if ho c n and cn i a and f t is a scalar field of a correct values for dynamic data i red m red if ho c n and cn a bm i ci a and a is a dynamic class theorem every execution step of the source program is simulated by one or several execution steps of the compiled code if v h v m and stmt v h v h then there exists a target state v m such that stmt v m v m and v h v m proof if stmt is an assignment to a scalar field the existence of m follows from theorem which guarantees that the store is properly aligned and therefore succeeds theorem combined with the good variable properties of the target memory model shows part of the agreement between the final states part likewise follows from theorem and the good variable properties if stmt is a pointer comparison theorem ensures that the address comparison generated by the compilation scheme produces the same boolean outcome the remaining cases follow more or less directly from the hypothesis v h v m verification of representative layout algorithms we now put our formalization into practice by using it to prove the correctness of two realistic optimizing c object layout algorithms the common c the first layout algorithm we study is the one specified in the common c first introduced for and now used by the gcc compiler on many other platforms our algorithm is faithful to the specification with one exception we do not allow the use of nearly empty virtual bases as primary bases an optimization of value discussed in section following the we define a class c to be dynamic if and only if it has a virtual function or a nonvirtual dynamic base or a virtual base in the latter case c is considered dynamic as its dynamic type data is actually used to find the offsets of the virtual bases of c likewise we define a class to be empty if and only if all the following conditions hold it has no virtual function it has no fields it has no virtual bases all its direct nonvirtual bases are empty in particular an empty class cannot be dynamic the layout algorithm is summarized below see for the full it takes as input a class c and the layout of all classes b mentioned in c ie b is a direct or indirect base of c or b is the type of a field of c or depends on a base of c or of the type of a field of c besides the layout parameters listed in section it also computes the set of the offsets of all subobjects of an empty virtual base of c or an empty nonvirtual direct base of c start from and arbitrarily choose a dynamic nonvirtual direct base b if any this will be the primary base give it offset within c and update and to their b counterparts if there is no primary base but the class is dynamic then some space for the dynamic type data update and to and to start at offset equal to the size of dynamic type data then for each nonvirtual direct base b of c · try to give it an offset b within c starting from the least multiple of no less than if there is a type conflict with empty base offsets then try at a further offset by increasing b by knowing that for b there will be no conflict however if b is empty first try before trying any offset from · update to and to · if b is not empty also update to b in this case note that the whole nonvirtual part of b not only its data is included in the data of c set to then for each field try to it out starting from find a correctly aligned offset by and set to f so that the next field starts after the end of the whole previous field not only its data this explains why any class having a field even an irrelevant one is not empty then for each virtual base try to out its nonvirtual part the same way as for nonvirtual bases but updating etc instead of etc type conflicts with empty base offsets are detected as follows when trying to out an empty base b check between bs nonvirtual empty base offsets and the whole set of empty base offsets so far when trying to out a nonempty base b or a field of type bn check between the bases or the fields nonvirtual empty base offsets and the offsets of c so far reachable by inheritance only through an empty direct nonvirtual base or an empty virtual base in other words ignore those offsets of bases reachable through fields or through nonempty bases of c indeed those offsets are guaranteed to be out in the data of c as this algorithm ensures that a field or a nonempty base is included not only its data in the data of c as the data of already out relevant components is disjoint from the data of the current relevant component there is no need to check whether those offsets are present in the empty base offsets of the current component these details about type conflict resolution were not present in the specification it gave no about which offsets to empty subobjects need to be checked we proved that this algorithm satisfies all the conditions stated in section thus it is semantically correct with respect to field access dynamic operations and subobject identification a more efficient layout empty member optimization the previous algorithm misses several opportunities for space consider struct a struct a a struct b char f a a struct c b b char f struct d a a a struct e d char f running this example through gcc which follows the common we obtain and this indicates that field f of c is out completely from b even though ba contains no data a is empty the space for ba could be reused giving likewise field f of e is out completely from the subobject d which is considered as not empty even though da contains no data the space for d could be reused resulting in this optimisation is justified as an object of empty class has no source of observable behavior other than its address it carries no runtime data consequently a c implementation can systematically compile assignments to such objects as we propose an algorithm that performs these space optimizations by refining the notion of empty classes say that a class is empty if and only if all the following conditions hold · it has no virtual functions · it has no scalar fields · it has no virtual bases · all its direct nonvirtual bases are empty · all its structure fields are of an empty type in particular an empty class cannot be dynamic this definition of empty classes is the smallest that satisfies the conditions from section then the previous algorithm is modified as follows · when out an irrelevant component all correctly aligned offsets starting from are tried until the offsets to empty subobjects do not or is reached · a field can start in the tail of the previous field when a relevant field is being out the data size is updated to f instead of f similarly for a nonempty base this requires a modification when checking for type conflicts with empty base offsets the whole sets of offsets must be considered every time indeed as there are no more conditions about the sizes of the fields or the nonvirtual sizes of the bases there are no more guarantees that an empty subobject reachable from an already out component will not with the current component being out similar modifications occur for fields and virtual bases in the latter case checking against as all offsets are checked the auxiliary set is no longer useful we proved this algorithm to be correct in fact the proof is easier than for the previous algorithm as this algorithm is closer to the conditions stated in section limitations and extensions bit fields in our formalization we did not specify the size unit so that sizes and offsets can be expressed in bits instead of bytes however this may not be enough to fully implement bit fields as they require specific alignment constraints consider struct a int i int j int k on a bit platform fields i and j can be into a single bit integer and by and from this integer however the field k should not be adjacent to j otherwise two memory accesses would be required to recover the value of k our alignment constraints over field offsets would have to be accordingly our work does not consider the of plain old data and treats them in an ordinary way not distinguishing them from general c structures roughly speaking a structure is a structure with no inheritance and no fields as such it is roughly equivalent to a c structure the standard the layout of structures to be compatible with c allowing in particular assignment between structures using by contrast our work considers that structures are always assigned to by assignments of fields however we that whenever c is a could help us prove the correctness of copy even if a is inherited by another class unions just like structures unions offer opportunities for tail that is common to all of its members the practical benefits are low unions are used enough that treating them like is a reasonable choice the main difficulty in extending our formalism to unions comes from the operational semantics which must be instrumented to enforce the policy that at any time the only member of an union that can be accessed is the one most recently initialized virtual in our work a class can share its dynamic type data only with a nonvirtual primary base however the common allows a class to share its dynamic type data with one of its virtual bases as long as the latter has no fields in practice the layout of such a virtual base called a nearly empty virtual base is reduced to its dynamic type data so that it can be shared with the dynamic type data of its derived class however such a layout would break the schema of out the nonvirtual part of a class separately from the nonvirtual parts from its virtual bases as some nonempty virtual bases may be actually out in the nonvirtual part of the class moreover indirect primary virtual bases may appear several times in a class layout because they have been chosen as primary bases by different nonvirtual bases we do not know how to solve this layout ambiguity in practice the latter case also actually efficiency problems in most compilers so much so that the virtual primary optimization is described as an error in the design of the common alternate layout of dynamic type data our work assumes that dynamic type data is out at the beginning of a class some c compilers such as or compiler to place it at a different offset that layout scheme has the property that a pointer to the complete object is also a pointer to the data of the primary base class subobject which may not need dynamic type data how frequently that situation occurs in practice is moreover it can lead to alignment that is more difficult to reuse in derived classes bidirectional layout in our work as in production c compilers object representation can only be extended on one side in derived classes there are however some layouts that may extend an object representation to both sides so that for instance a class may share its dynamic type data with two of its bases however an efficient implementation of such layout would need to know the derived classes of a class in advance which would separate compilation holes our work assumes that the nonvirtual data of a class is a memory consequently holes arising from cannot be detected and reused as in the following example struct a struct a a char x int y struct b a char z there is some alignment between ax and ay but in the layout of b our formalization does not allow z to be stored in this unused space as the data of a is considered to be virtual table layout our work focused so far on the representation of objects leaving the concrete representation of dynamic type data future work includes formalizing the layout of virtual tables as studied by and as well as this pointer during virtual function dispatch this would lead to mechanized verification of the implementation of dynamic operations such as virtual function dispatch and dynamic cast object construction and destruction a related piece of future work is the formalization of object construction and destruction especially the updates to the dynamic type data of objects that take place during this process related work obviously any c compiler includes an object layout algorithm however to the best of our knowledge none has been reported as formally verified extensively discusses object layouts found in earlier c compilers although he explicitly stated objects of an empty class have a nonzero size p he did not consider empty base class optimization nor was that optimization implemented in the nonzero size requirement was later by the c standard the empty base optimization as a basis for efficient programming technique was by myers he for the possibility of optimizing empty member subobjects as we consider in this paper however there was no proposed algorithm and as we observed such an optimization requires careful assumptions about plain old data the empty base class optimization is explicitly by the common which is a practical basis of our formalization and improvements our present work is based on the algebraic model of inheritance by and friedman and the operational semantics of et al these foundational papers do not consider concrete object layout algorithms rather they focus on abstract object semantics independent of concrete machine representations there are other of aspects of the compilation of c but none of them considers concrete data representation chen proposed a typed intermediate language for compiling multiple inheritance this work formally describes which pointer are necessary for virtual function calls and conversions including offset computations and thunks and proves type soundness results about them however formalization focusing only on an intermediate language leaves largely unspecified the concrete object layout the issue of subobject identity is not addressed either and proposed a separation formalism for reasoning about multiple inheritance this paper does not address the issues of concrete object layout rather it relies on a syntactic form of field resolution close to the algorithm of and itself a of the calculus of and friedman furthermore and restricted themselves to nonvirtual multiple inheritance only considered a rather abstract storage model and defined the semantics of field access through substitution in a completely different direction and proposed an space and bidirectional object layout scheme for multiple inheritance the core of their algorithms is based on the assumption that the compiler knows the complete class hierarchy that assumption holds only in special cases eg in a closed world with whole program analysis and is for most realistic c compilers at large which must with a separate compilation model inherited from c this theoretical work was followed up by an quantitative study by and they developed a formalism to characterize when compiler to support runtime semantics of inheritance are required their work design choices in the memory layout of the ibm age c v compiler the core of the bidirectional layout was later refined by and to a object layout algorithm for multiple inheritance however they explicitly nonvirtual multiple inheritance on the ground that it is a or an it is not and we cannot such assumption for formally verified layout algorithms in real world compilers for standard c leaving c objects for the simpler world of c structures a field separation property of structure layout and used it in a separation logic able to verify lowlevel system c code the clight formal semantics of and leroy defines a simple structure layout algorithm the field separation field alignment and prefix compatibility properties were mechanically verified conclusions c object layout is one of those implementation issues that turn out to require a line coq development to start making formal sense between the few compilers in the past that the layout object identity in the process and the great many compilers that err on the side of and miss opportunities for space our formalization and mechanized verification a design space of yet efficient layout algorithms more in and further safe optimizations this work is also a first step towards formally verifying a compiler frontend for a realistic subset of c even though much work remains to be done on other aspects of the c object model virtual dispatch construction and destruction etc acknowledgments we are to the anonymous reviewers for their very helpful suggestions to improve our results and their presentation we thank and for their feedback which us to keep our formalization connected to the realistic of c compilers references s and x leroy mechanized semantics for the clight subset of the c language journal of automated reasoning ­ j chen a typed intermediate language for compiling multiple inheritance in th symp principles of programming languages pages ­ acm hp ibm intel red and c url b core issue technical report march url m a and b the annotated c reference manual addisonwesley j and p f space and memory layout for multiple inheritance in th conf on objectoriented programming systems languages and applications oopsla pages ­ acm j y w g e and y bidirectional object layout acm trans program lang syst ­ international standard programming languages c international organization for standards g and t a model for a language virtual machine and compiler acm trans prog lang syst ­ d w paul and e towards the formal verification of a c compiler code generation and implementation correctness in int conf on software engineering and formal methods pages ­ ieee x leroy formal verification of a realistic compiler acm ­ c and s separation logic for multiple inheritance notes theor comput sci ­ n myers the empty member c optimization dr journal aug url g and h a member lookup algorithm for c in programming language design and implementation pldi pages ­ acm t formal verification of object layout for c multiple inheritance ­ coq development and material url j g and d p friedman an algebraic semantics of subobjects in th conf on objectoriented programming systems languages and applications oopsla pages ­ acm p f and m g and evaluating the space overhead for alternative c memory layouts software practice and experience ­ h formal verification of c systems code structured types separation logic and theorem proving journal of automated reasoning ­ d t g and f tip an operational semantics and type safety proof for multiple inheritance in c in st conf on objectoriented programming systems languages and applications oopsla pages ­ acm 