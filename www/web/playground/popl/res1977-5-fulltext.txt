generalized subexpressions in very high level languages department of university c computer science of ns ia abstract we propose a new optimization technique applicable shall call to languages general common subexpression which we t ion it involves the computation of the function for all nodes n in a flow graph where is the set of expres sions such that along every path leading to n there will be found a computation of the ex followed by only assignments ie a a u x or a a x to its operands and that the number of such assignments is bounded independent of the path taken we shall try to justify our definitions and demonstrate the of this technique by several examples we shall that this optimization problem does not fit into the semilattice theoretic model for global program optimization ki gw and that the standard iterative algorithm for such does not work in this case we then give several theorems which allow the problem to be solved for reducible flow graphs the formulae given in the theorems are in such a form that an efficient algorithm can be found by an algorithm given in u steps the resulting of an extended algorithm takes type where bit oe log e vector operations the number are regarded as one step and e ia of edges of the flow graph it takes on log n extended for a program flow graph of n nodes introduction one of the most important techniques in global code optimization is the detection of common subexpressions al a au cs c u an expression such as a b is available at a point p in a program if every sequence of branches which the program may take to p causes a b to have been computed after the last tation of a or b if we determine available expressions at the set of to the nodes of a flow graph then we know which expressions have already been computed prior to each node thus we may be able to eliminate the redundant computation of some expressions with each node this theoretic optimization languages can be applied such aa setl to set work partially supported by nsf grant while the author is at princeton let us take as an example the following program n nl y m the program language as in are temporaries may appear the following in an intermediate where t and t n x m t z d t the expression a u b is considered able on entering node m so that it the computation of a eliminated we see that since both to need ub t be be can be and t compute the same expression having the same value we can eliminate t and replace it by t this is usually called common tion in the literature gram is obtained subexpression thus the following pro n m z dt now consider the following program n nl m the expression a u b is considered whenever any of its operands is a u b is no longer available on entering hence has to be computed from the values operands a and b however if we notice so m and of its that since a is only changed slightly at nl a ub at m ing its follows can be value computed at n much more easily by modify we modify the program as n t t u x nf m zd tl in this available case in the correct value of a u b is t on entering m hence we have replaced computing the union by the addition of an element magnitude improvement in the a u b at m is achieved of two arbitrary thus an order computation time acts of of we shall demonstrate the optimization by yet another example of this consider algorithm for finding shortest paths for a single source the follow ing is one version of the algorithm taken from we assume that the existential quantifier also has the side effect of storing the existing value into the control variable as in e the w s v o for v c vs do dv while vs do x c vs then ql for v c vs do dv end end end the look like temporaries program in an the following intermediate where program t ti might are begin s o for v e t do dv while t do w x c t then w dv end end end figure after for possible common elimination we find that statement in fig can be eliminated statements and which appear in a loop and take time proportional to the size of v plus the size of s can both be eliminated replaced ment in fig which by the addition takes only unit of state time also one temporary t is necessary the temporaries tz t and t each using as much space as t can all follows be eliminated the modified program is as s vi o for v e tl do dv while t do begin x e fl begin w t t w for v in t do dv end end end figure in the remaining part of this paper we shall concentrate on finding the set of expressions at each node for which this optimization is in section we shall give the basic definitions and attempt to justify them in section we explain why the semilattice model fails to our problem we then give several theorems which allow us to solve the problem efficiently for reducible flow graphs section the algorithm adapted from u on the details which are different from that given in u the paper is by a brief discussion on some implications of this optimization and a summary the flow graph model we assume a language such as setl s the operations we assume can be done in unit time are arithmetic on integers insertion of an element into a set deletion of an element from a set selection of some member from a set testing whether an atom fs in a set these assumptions are valid at least in an expected time sense if one uses a hash table representation for sets such as in s with elements which are sets represented by pointers to their values we take it as a corollary to that a set may be tested for emptiness in unit time it is assumed further that we are presented a program as a flow graph consisting address statements eg a b u c n d which would appear of not as we shall being use the usual model for to code improvement a program definition a flow graph g n e no where is a triple n is a finite set of nodes e is a subset of n x n called edges the edge nn enters node n and leaves node nl we say nl is a predecessor of n and n is a successor of nl the presence of edge means that after execution of the instructions represented by nl it is possible that control will pass to that represented by no in n is the initial where all computations begin the place we say there is a in g to if there is a sequence of nodes nn nk such that ni il is in e for the path length of n is k we require that there be a path the flow graph from no to every node in definition call an assignment is of or note that an assignment takes unit time as assumed in our model if it only let us examine a slight variation example given in section of the n i i nl m if we perform the optimization formally in the previous section program like described in the modified i x i j t t u x a aux m z dt it is easy to see that in order to have the correct value of a lj b in tl node m t may have to be updated an arbitrary number of times as the loop indicated in the above figure may be executed an arbitrary number of times hence it is not clear that this tion is in this case in fact it might even the running time of the program if we that an order of magnitude improve ment in the computation of an expression w at node n be achieved in this manner we should require that there are at most a bounded number of any path independent motivation assignments to any operand of w in from the last computation of w to n of the path taken this ia the for the requirement in the to follow we that associated with certain are computations e g k ig ik flow where z is the of expressions flow graph computed by the g ia a mapping from n to x if an ex w a b is in gn then we imagine that w is generated ie computed within the block represented by n and that neither a nor b is defined or read into within the block k is a mapping from n to x kn as the set of expressions which in block n informally expression if either a or b are defined into within the block n we interpret are a b is or read ig generated subsequently assignments is a mapping from n to z as the set of expressions we in block n such that if a or b it is only by b is ik is a mapping from n to zz we in as the set of expressions which only in block n in formally expression a b is if either a or b are defined in block n and they are defined only by note that by definition is a subset of kn and gn is a subset of let computation f n e no be a flow z g k ig ik graph with definition for n in be the of expressions path in f from nk to n define w for n say to which in every nk where is in n n there k ia some ik for and w is not in which for w definition for n in be the set of expressions exists a positive integer path in f from no to n define to w for which there c such that for every n say non nk where n there is some i ik for which k w is in and w is not in for and the number of nodes nx such that w is in is not greater than c note that by definition subset of for all nodes n is a computation of we shall begin this section by briefly ex why for this global data flow analysis problem the relevant information desired namely for all nodes n in the flow graph cannot be modeled by the model ki gw at least in the only natural choice of semilattice the problem arises from the requirement that if w is in then for any path leading to n the number of assignments computation to any operand of w after the last of w be bounded independent of the path from r taken consider let go be the the following graph as shown example in fig a let w be an expression in and in by definition of w is not in now consider gc for co aa shown in where each nl for is a the node nl in go tie w is in for all c now consider the c semilattice l of finite sets which is the natural one here of expressions the function fl from l to l associated be the same as the function with lj nl in go must associated with in gc for all j lj let s be the set of expressions generated in no if this problem the semilattice framework then contains w for all c because contains w for all c ut for path contains p from n to w n in go the assumption that w is not in n go no nl n n lc n figure a figure b hence the semilattice model does not reflect the interaction of relevant information desired in our problem also the standard iterative algo rithm as appears in ki does not work here however efficiently we have been able to solve the problem for reducible flow graphs we shall now give the theorems which allow us to do so our algorithm flow graph which are subgraphs which node dominates all n dominates is based on the fact that re can be built from regions with a single header node nodes in the region node m if every path a from initial node of the flow graph to node goes through n moreover the reducible graph can be built from regions of a single by the following two constructions m flow node tl given a region r such that there are some edges that go from nodes in rj to the header of r form ri by including edges t given regions rz and r such that all predecessors of the header of r are in r form ri from of r and r plus the edges from r to the header of r the header of rz becomes the header of ri see u for details the algorithm ing five r n e nl works by computing for each region the follow is the set of w for which which every path within l contains lk rem o n r includes a node ti for w and does not contain w if i j is the set of expressions w for which no path zi fk from n to n such within that w is in r includes ki and a node i w is not in for j i note that is a subset of trans n r for all nodes n is the set of expressions w for which there exists a positive integer c such that every path l lk rem to n within r include a node i for which w is in and w is not in of nodes ik j e x is not greater for than and the number for which w is in c note that is a subset of for all regions r and for all nodes in r is the set of expressions w for which no path l tk from nl to n within r includes w is in a node and w such that i is not in for j i and there exists a positive z integer c such that for a lk from nl to n if q is the largest integer such the number of nodes that w is in lx for which w is in is not greater than c if there exists no such of nodes q x not greater than c is a subset integer q then the number for which w is in is note that by definition of is a subset of and is a subset of for all regions r and for all nodes n in r is the set of expressions w for which such that from the there exists a positive integer for every path p l l k header nl of r to n c entirely in r one of the following is true there is no node i x in the path for which w is in or p includes a node for which i is in and w is not in w number of w is in for j nodes ji and the l x for is not greater which than c note that by definition u is a subset of and is a subset of for all regions r and for all nodes n in r the following two theorems allow us to compute the five recursively for larger and larger regions the formulae given in the two theorems are in such a form that an efficient algorithm can be found by an algorithm from u theorem let rl n el n be a region formed by transformation r n ez n that t from region is el consists of e and those edges represented then for all n in by the edges n n n n u t n n n u a n u a f n where t is the intersection of taken over all m such el e and a is the that m nl intersection of is in over the same ms proof and can be found and follow from the definition in u of and and are straightforward is less intuitive and we shall for it we shall show that a subset of the right hand first we want to prove that sketch the argument the left hand side side and vice versa is u a il is a subset of n we shall n it is a n if w is not in not in n r and not there are two cases to in consider w is not in n because it condition that is there ri say ti exists ik in the definition a path from where for some of n to n in q w is in we can find for some and w is a sequence not in j of indices so that p is nl for if and only if p is one of jl jr then the paths j jr lk are q j each or and r and for each i the edge l j is in e e now iq must last be in one of path w is these paths if is in the q not in hence not in therefore w is not in u a n if iq is not in the last one then w is not in hence not in a and not in u a we have shown that if w is not in it is not in r u a hence the latter is a subset of n suppose w is not in n because condition violated violated exists in the definition of is we assume now condition is not that is given an integer c there a path l k from n to n such that such a if q is the largest that w is in integer then the number of nodes for which w is in is greater than c b if no such q exists the number of nodes l x for which then w is in is greater than c we can find a sequence of indices jl jr for some so that if p is one of t is nl if and only p then the paths lj l for and i lk are each within ji r and for each i the edge of is in el e we shall consider cases a and b separately a lq must be in one of these is the last path w is not in paths if q hence not in therefore w is not in u a if iq is not in the last one then w is not in a and not hence not in in u a fl therefore u a is a subset of n b if no such let q exists w is not in y be the smallest integer for which w is in if ey is in the last path w is not in if y hence is not in the w is not in path w is not in a u a r to prove the converse suppose w is not in n and not in a fl n we shall prove that w is not in n if w is not in n it is r in n r if w is in n r not in a and thus not in for not it is some m such that m n not in m r is in el e since w is there are two cases to consider we can construct a path in ri by going from nl to m in such a way that w is in for some node y in that path then from m to nl and w is not generated to n in such a way that if w is in ity clearly w is not in n hence we may assume w is in let the path from ni to m constructed above be denoted by p then pq nl n for ql are all paths in ri from nl to n since w is in for some y in p and w is not generated there given any integer c the path pq where qc is a path from nl to n in ri such that the number of nodes x for which w is in is greater than c hence w is not in if we cannot then by definition construct a path as in case of there exists l a path in iz from n to such that for any integer integer such that m say c if w is y is the in largest the number of nodes t x ya for which w is in ia greater than c we can construct the following path from nl to n in ri it con of the path p followed by nl then onto n in such a way that w is not generated this is possible because w is not in r n the number of nodes x in this path for which w is in after the last generation of w is greater than c since this can be constructed for any integer c w is not in n we have shown that if w is not in and not in a n it is not in hence is a subset of u a n theorem let r be region formed by transformation t regions r and r then all n in n n for n n for all n in n n u r l u t n n u ir n u a n r n u n where r is the intersection of gen m over all rz m such that the intersection m n is in ir is of m a is the inter section of m the intersection r of trans m and r is the intersection of over the same ms proof the proof and we omit it ia similar to that of theorem c the following from the definitions theorem is essential and follows of and theorem let f n e no be a reducible flow graph and hence a region then and for n no is the intersection over all predecessors m of n of proof by definitions el from theorem we can obtain the function if we can compute for the entire graph which turned out to be difficult to compute directly however we can compute and together starting with regions of one node and to larger and larger regions theorems and give us inefficient but method for doing this we shall discuss how it can be made efficient in the next section if the function is also desired gen and trans for the entire flow graph can also be computed by the same algorithm the function can be easily computed from for all nodes n in f u efficient implementation trans of gen in the last section we have given two theorems which allow us to compute gen trans it turns out that the formulae are in such a form that they can be computed efficiently by an algorithm u in this section we shall outline the algorithm only on the which are different from those given in u from we shall region the each node in properties construct tree the region a tree representing have a leaf representing and with the following each no interior than three direct node of the tree descendants will have more if an interior node has h the longest path from the node to a leaf is h then it has at least h descendant leaves all from a node to its leaves have the same length descendant the edges tuples of sets that then of the tree will be of expressions it if the tree represents labeled by will be region r can be computed by following the path from the leaf for n to the root as follows let r al t rk ak tk ik be the labels of the edges n let toward the root from the leaf for node gi ti and ii be defined by the following computation g ig to set of all expressions x the for compute gi ig i ill i ig ig i u u gi i g u ti l i ig i i and then g k iu k tk i k and a basic in the next refer to it manipulation lemma and as of edge labels in fig of an edge to is given we to lemma let to t be nodes of a tree with edges and labels as in if the labels of those edges are changed to those in then the same gen trans functions as before are computed for all the leaves of the tree by algorithm proof algebraic the lemma follows manipulation by straightforward to d to where ai iii u ir ii i ci g i i u a ai ti u i ii for fig b note that an edge with label has no effect on the calculation of algorithm that is if is and g is a subset of and is a subset of both ii and iu then g g i il i i li i and li i we shall now implement the relations given theorems and sets of expressions will be represented by bit vectors the are described in the next algorithm in the algorithm for initialization trees for regions block the second by application of consists ie consisting and third t and of three parts one the construction of of a single basic for region constructed t respectively initialization for the initial regions consisting of a single node n take two nodes r and t make r the root and label the single edge rt by gn z u application of tl suppose region rx is created tion of t from region r let the computed in theorem tree for region ri by the following by an and a be create the steps a create a new node r whose son is the root r of the tree for r label edge rr by b strip the edge rr c delete r and the edge for ri rr r is the root application of t suppose r is created by t from regions r and r where the node representing r is the predecessor of the node representing r let r ir a t and i be the mentioned in theorem create the tree for region r by the following steps a create a new node r whose is the root r of the tree for r label the edge rr by b strip the edge rr c delete r and the edge rr d merge the resulting the tree for r the tree for region tree with the resulting r root r tree and is the but is identical omit the details algorithm in spirit is rather to that complicated in u we we shall now outline the complete algorithm for computation of and for the entire flow graph once we have this the computation of is easily done in oe steps where e ia the number of edges by theorem if the function is also desired gen and trans for the entire flow graph can also be computed by the same algorithm algorithm let f graph with computation be a reducible flow use the algorithm of hu or t to construct a r of f create consisting of algorithm of a for single the initial regions node using step each step if the step b the steps a region creates of i in order if the by using tl do a a region by using t do a using using create the tree for step of algorithm the new region the t and a mentioned can be computed algorithm b create step of compute the the tree algorithm for the i ir new region algorithm a t using to after step for the entire is completed we have the tree flow graph f compute for each node n in n compute for all nodes n in according to theorem n the above algorithm requires oe log e extended steps where bit vector are regarded as one step as in u when applied to a flow graph with e edges and n the proof can be found in u on a program flow graph of n nodes where the number of edges e ia sn algorithm requires on log n extended steps discussion and summary we shall briefly discuss some implications of this optimization in the examples given in section the common subexpressions found are ex created in the process of computing other expressions ie they are assigned to system variables sc that by identify ing them two temporary variables say t and t y be pointing to the same value now if t is dead at the time t is to be created we can use the same name ie ti and hence the same value possibly with slight modification as ia the case in the examples in section now consider the example below n m by identifying the two expressions a u b at nodes n and m we will also be identifying the program variables x and y if x is dead on reaching m there would be no problem if not then the fact that x and y are now point ing to the same value must be recorded it is possible that a different copy of this value may have to be made at a later time in which case the due to common elimination amounts merely to copying a u b instead of com the union obtaining maybe a constant speedup now consider the case illustrated by the following piece of code n m if x is dead on reaching m x can be modified into y if not and if x and y are only different by x an idea similar to one from fu where a new variable a is introduced to record the difference between slightly different acts may be used we shall not go into details here we merely want to point out that performing common elimination in settheoretic may cause different variables to be sharing the same representation of certain value this should be dealt with aa the general problem of dealing with assignment statement such as x y and deciding whether a new copy should be made or whether they can share the same in summary we have proposed a new tion technique for we have illustrated its use by examples and shown that the problem does not fit the semilattice theoretic algorithm model and that the standard iterative does not work here we have stated several theorems which allow the problem to be solved for reducible flow graphs moreover the usual available expressions computed namely the function can be obtained at the same time when the function is calculated by slightly modifying algorithm entire algorithm takes oe log e extended steps for a flow graph of e edges and takes on log n extended steps for a program flow graph of n nodes acknowledgements the author to thank jeffrey d unman for his helpful comments and dr k rosen for pointing out an error in an earlier draft of this paper the author would also like to thank j for her careful typing of this paper al fe allen program annual review in automatic pp optimization p in vol a fe allen and j a optimizing transformations in design and optimization of compilers r ed prentice hall pp of av the design aho and analysis hopcroft and of computer jd unman algorithms au av aho and jd unman the theory of parsing translation vol ii compiling prentice hall c j elimination pp july global sigplan common subexpression notices vol no cs j and languages and their schwartz compilers e j high automatic programming sym on very high march level operations proc sigplan level languages in ac application optimization principles and jd unman of lattice algebra to loop proc nd acm on of programming fu ac and jd unman induction variables in very high level languages rd acm on principles languages jan of programming proc gw sl graham and m wegman a usually linear algorithm for global proc nd acm sym on principles programming languages jc fast flow of and analysis hu hopcroft and algorithm for reduction a princeton conference and systems jd unman an of flow graphs g information n log n th kl ga global tion during compilation principles of programming october expression proc of acm cx on pp tion jan and jd unman global problems and iterative algorithms r bk rosen private communication t re computing tarjan proc play flow graph th acm symp on of u jd elimination informatica unman fast algorithms of common subexpressions pp for the acts 