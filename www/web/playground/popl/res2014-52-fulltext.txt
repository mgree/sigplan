applying quantitative semantics to higherorder quantum computing paris paris france peter university dept university of pennsylvania usa abstract finding a denotational semantics for higher order quantum computation is a problem in the semantics of quantum programming languages most past approaches to this problem short in one way or another either limiting the language to an small finitary fragment or giving up important features of quantum such as in this paper we propose a denotational semantics for a quantum lambda calculus with recursion and an infinite data type using constructions from quantitative semantics of linear logic categories and subject descriptors f semantics of programming languages denotational semantics keywords higherorder quantum computation functional programming completely positive maps categorical model introduction type theory and denotational semantics have been successfully used to model design and reason about programming languages for almost half a the application of such methods to quantum computing is much more recent going back only about years an important problem in the semantics of quantum computing is how to combine quantum computing with higherorder functions or in other words how to design a functional quantum programming language a syntactic answer to this question was given with the design of the quantum lambda calculus the quantum lambda calculus has a welldefined syntax and operational semantics with a strong type system and a practical type inference algorithm however the question of how to give a denotational semantics to the quantum lambda calculus turned out to be difficult and has open for many years one reason that designing such a semantics is difficult is that quantum computation is inherently defined on finite dimensional spaces whereas partially by project number js and et permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page for components of this work owned by others than the authors must be abstracting with credit is permitted to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission andor a fee request permissions from popl january ­ san diego ca usa copyright is held by the publication to acm acm the semantics of higherorder functional programming languages including such features as infinite data types and recursion is inherently in recent years a number of solutions have been proposed to the problem of finding a denotational semantics of higherorder quantum computation with varying of success the first approach was to restrict the language to strict linearity meaning that each function had to use each argument exactly once in the spirit of linear logic in this way all concepts such as infinite types and recursion were eliminated from the language not surprisingly the resulting finitary language permitted a fully abstract semantics in terms of finite dimensional spaces this was an acceptable solution to the general problem the second approach was to construct a semantics of higherorder quantum computation by methods from category theory specifically by applying a construction to a model of firstorder quantum computation this indeed succeeds in yielding a model of the full quantum lambda calculus without recursion the main of the model are the absence of recursion and the fact that such models are relatively difficult to reason about the third approach was based on the geometry of interaction starting from a traced monoidal category of basic quantum operations and applied a sequence of categorical constructions which eventually a model of higherorder quantum computation the problem with this approach is that the tensor product constructed from the construction does not coincide with the tensor product of the underlying physical data types therefore the model the possibility of states and thereby fails to model one of the defining features of quantum computation our contribution in this paper we give a novel denotational semantics of higherorder quantum computation based on methods from quantitative semantics quantitative semantics refers to a family of semantics of linear logic that interpret proofs as linear mappings between vector spaces or more generally modules and standard lambda terms as power series the original idea comes from normal functor semantics more recently quantitative semantics has been used to give a denotational semantics for various algebraic extensions of lambda calculus such as probabilistic and differential lambda calculi eg one feature of our model is that it can represent infinite dimensional structures and is expressive enough to describe recursive types such as lists of qubits and to model recursion this is achieved by providing an exponential structure a la linear logic unlike the model our model permits general we interpret a minor variant of the quantum lambda calculus in this model our main result is the adequacy of the model with respect to the operational semantics qubit qubit · h i ii m xy qubit location a location b iii figure the quantum protocol the model is the of a simple model of quantum computation together with a canonical completion yielding the structures of linear logic our model demonstrates that the quantum and the classical work well together but also ­ surprisingly ­ that they do not mix too much even at higher order types outline in section we briefly review some background section presents the version of the quantum lambda calculus that we use in this paper including its operational semantics section presents the denotational semantics of the quantum lambda calculus and section proves the adequacy theorem section concludes with some properties of the representable elements background quantum computation in a quantum computation is a computational paradigm based on the laws of quantum we briefly recall some basic notions see for a more complete treatment the basic unit of information in quantum computation is a quantum bit or qubit whose state is given by a normalized vector in the space c it is to write the canonical basis of c as and to identify these basis vectors with the booleans false and true respectively the state of a qubit can therefore be thought of as a complex linear combination of booleans called a quantum more generally the state of n qubits is an element of the tensor product c c there are three kinds of basic operations on quantum data unitary maps and measurements initialization a new qubit in state or a unitary map or gate is an invertible linear map u such that u u here u denotes the complex of u finally the operation of measurement a qubit and returns a classical bit if n qubits are in state where and are normalized states of n qubits then the leftmost qubit yields false with probability leaving the remaining qubits in state and true with probability leaving the remaining qubits in state example a small algorithm is the simulation of an initialize one quantum bit to apply the gate sending to and to then measure the result is true with probability and false with probability example a slightly more involved algorithm is the quantum algorithm see for details the procedure is summarized in figure represent the path of quantum bits in the computation and time flows from left to right the gate h stands for an application of the gate whereas the gate · is a it the bottom qubit if the upper one is in state the box m is a measurement the are u u u u the goal is to send a quantum bit in an unknown state from location a to location b using two classical bits the procedure can be to send two classical bits using a quantum bit in this case it is called the coding algorithm the algorithm consists of three parts in i two quantum bits qubits and are in state in ii the input qubit in state is with qubit then both are measured the result is sent over location b where in iii an correction is applied on qubit setting it to state density matrices and completely positive maps if we identify and with the standard basis vectors and the state of a qubit can be expressed as a vector v similarly the state of an system can be expressed as an column vector of ten it is necessary to consider probability distributions on states these are also known as mixed states consider a system that is in one of several states v vk with p pk respectively the density matrix of this mixed state is defined to be a i where denotes the adjoint operator by a theorem of von the density matrix is a good representation of mixed states in the following sense two mixed states are by any physical experiment if and only if they have the same density matrix note that tr a p pk for our purposes it is often convenient to permit distributions so that p pk let us write for the space of n × recall that a matrix a is called positive if for all v cn given a b we write a b iff b a is positive this is the socalled partial order a linear map f is called positive if a implies f a and completely positive if f is positive for all k where is the identity function on if f moreover satisfies a tr a for all positive a then it is called a the density matrices are precisely the positive matrices a of trace moreover the correspond precisely to those functions from mixed states to mixed states that are possible the category the category is defined as follows the objects are natural numbers and a morphism f n m is a completely positive map f let be the free completion of under finite specifically the objects of are sequences n n nk of natural numbers and a morphism f n m is a matrix of morphisms nj mi of the categories and are symmetric monoidal and in fact compact closed limitations of as a model the category can serve as a fully abstract model for a simple strictly linear finitary quantum lambda calculus for example the type bit is interpreted as and the type qubit is inter as measurement as a map from qubit to bit sends a c to to a d the p function spaces are is a map sending p interpreted via the compact closed structure as mentioned in the introduction the semantics of is ex limited because it is completely finitary thus recursion infinite data types and nonlinear functions ie those that can use their argument more than once had to be completely removed from terms m n p x m n skip m n m n let xa yb m in n in m inr m match p with xa m yb n letrec f m new u values v w x c v w in v inr w types a b c qubit ab a b a b a b a table grammars of terms values and types the language in order to fit the model for example even the simple function f xf f x is not representable in the purpose of the present paper is to remove all of these restrictions as an example consider the following in val qubit qubit list let rec q if then q else let xy q in y here is a fair and the function sends to so if the function is applied to a qubit the output is with probability with probability with probability and so on its semantics should be of type mapping a c b d a c b d ab c d the category is almost capable of handling this case but not quite because it cannot express infinite tuples of matrices the model we propose in this paper is essentially an extension of to infinite using methods developed in a quantum lambda calculus we define a variant of the typed quantum lambda calculus of the main difference is that the language in this present paper is a true extension of linear logic see the type assignment system of table in particular in contrast with a b ab is not provable and there is no need for a subtyping relation the operational semantics implements a callbyvalue strategy an untyped callbyname variant has been studied in the classes of terms values and types are defined in table the symbol c ranges over the set of term constants skip new u the constant u ranges over a set of elementary unitary transformations on quantum bits in the examples below we will be using the gate h and the gate nc defined as follows h nc notice that bound variables are given in church style ie with a type annotation this enables proposition and simplifies the se interpretation of the typed terms we omit such annotations in the sequel if or obvious we have two kinds of arrows the linear arrow ab and the intuitionistic arrow a b which is obtained by the value translation of the intuitionistic implication into linear logic intuitively only the terms of type a b represent functions that can be used repeatedly whereas terms of type ab must be used exactly once a type of the form a is called a type or nonlinear type and all other types are called linear the distinction between linear and nonlinear types is crucial for allowing the type system to enforce the property of quantum by convention is associative to the right while application and tensor are associative to the left we use the notation an for a n times the type a denotes finite lists of type a when doing structural induction on types we assume that a is greater than an for any n n the set of terms and types is somewhat however it can be easily extended by introducing syntactic sugar note that for technical convenience we have only allowed types of the form a when a is an arrow type however for an arbitrary type a the type a can be simulated by using a instead notation we write bit tt inr skip ff in skip nil in skip and m n inr m n we write for the term where z is a fresh variable and if p then m else n for match p with x n y m a context is a function from a finite set of variables to types we denote the domain of by and we write x a xn an whenever x xn and xi ai we call exponential resp linear whenever all ai are types resp no ai is a type we write for a context that is exponential the notation refers to the union of the two contexts and and assumes that and are disjoint a judgement is a triple m a of a context a term m and a type a a judgement is called valid if it can be inferred from the typing rules in figure using the convention that the contexts and are linear proposition there is at most one derivation inferring a given typing judgement m a example in section we the informal program our language is expressive enough to represent it the term can be defined as tt and it has type bit the term is new ff which has type qubit qubit qubit then is letrec f q if then q nil else let q in x f y which has type qubit qubit in examples and we discuss its operational and denotational semantics respectively example in example and figure we sketched the quantum algorithm we said that the algorithm can be decomposed into parts each of these parts can be described and typed in the quantum lambda calculus yielding a higherorder term this is an adaptation of an example provided in i generates an pair of quantum bits its type is therefore qubit qubit the corresponding term is ff new ff ii performs a bell measurement on two quantum bits and outputs two classical bits x y its type is thus qubit qubit bit bit and the term is defined as qq let x y nc q q in h x y a linear x a x a ax x a b x a b v a b v value p v a b skip i x a m b a b i m a b n a m n b e m n a m n a e m a n b m n a b i m a b x a y b n c let xa yb m in n c e m a in m a b i m b inr m a b ri x a m c p a b y b n c match p with xa m yb n c e m aa f a b x a m b f a b n c m a i split a aa letrec f ab x m in n c rec u of arity n qubit bit new bit qubit new u u table typing rules the contexts and are assumed to be linear iii performs a correction it takes one quantum bit two classical bits and outputs a quantum bit it has a type of the form qubit bit bit qubit the term is u qx x then if y then u q else u q else if y then u q else u q we can now write the term x y skip in let f x in let g u y in f g it can then be shown that qubit bit bit bit bit qubit is a valid typing judgement in other words the algorithm produces a pair of functions f qubit bit bit and g qubit these functions have the property that gf for all qubits and f gx y x y for all booleans x and y these two functions are each others inverse but because they contain an embedded qubit each they can only be used once they can be said to form a between the otherwise types qubit and bit bit however the whole procedure is one can generate as many isomorphism pairs as desired operational semantics the operational semantics is defined in terms of an abstract machine simulating the behavior of model it is similar to the semantics given in definition a quantum closure is a triple q m where · q is a normalized vector of cn for some integer n the vector q is called the quantum state · m is a term not necessarily closed · is a map from the set of free variables of m to the set n it is called the linking function we write for the domain of by of language we may call a closure q v a value when the term v is a value we denote the set of quantum closures by cl and the set of quantum closures that are values by val we write m for the linking function whose domain is restricted to the set of free variables of m we say that the quantum closure q m is total when has cardinality n the size of the quantum state in that case if x xn and xi i we write as x xn a quantum closure q x xn m has a type a whenever x qubit xn qubit m a in case x xn we can also write m a the purpose of a quantum closure is to provide a mechanism to talk about terms with embedded quantum data the idea is that a variable y is bound in the closure q m to qubit number y of the quantum state q so for example the quantum closure x x denotes a term with two embedded qubits x x in the state xx the notion of equivalence extends naturally to quantum for instance the states q x and q z are equivalent from now on we identify quantum closures up to renaming of bound variables the evaluation of a term is defined as a probabilistic rewriting procedure on quantum closures using a callbyvalue reduction strategy we use the notation q m p q m to mean that the lefthand side closure reduces in one step to the righthand side with probability p definition the reduction rules are shown in table the rules split into three categories a rules handling the classical part of the calculus b rules dealing with quantum data and c congruence rules for the callbyvalue strategy note that in the statement of the rules v and w refer to values in the rules in table b the quantum state q has size n the quantum state q in the first rule is obtained by applying the unitary gate u to the qubits x xk precisely q u id q where is the action on cn of any permutation over n such that i xi whenever i k in the rules about measurements we assume that if q and q are normalized quantum states of the form jj j j then q and q are respectively j jj j j jj j j jj j q v q m v x q let xa yb v w in n q n v x wy q q n q match in v with xa m yb n q m v x q q v q match inr v with xa m yb n q n v y q letrec f ab x m in n q n f ab x m in m f a classical control q u x · · · xk q x · · · xk q new ff q y n y q q x i x q tt q new tt q y n y q q x i x q ff b quantum data the variable y is fresh the decomposition of the quantum array in the case of x is explained in definition q m n p q m n q m n p q m n q in m p q in m q v m p q v m q m n p q m n q v m p q v m q inr m p q inr m q let xa yb m in n p q let xa yb m in n q match m with xa p yb n p q match m with xa p yb n c congruence rules under the hypothesis that for some we have m m and q m m p q m m table reduction rules on closures where the vectors j have dimension x so that the measured qubit is x in summary the quantum state acts as a shared global store that is updated by the various quantum operations note that the only probabilistic reduction step is the one corresponding to measurement also we that the hypothesis associated with a congruence rule q cm p q cm takes into account the whole quantum states q and q in fact because of the the evaluation of q m m may have a sideeffect on the state of the qubits pointed to by the variables occurring in the context c the rules assume that the involved closures are welldefined in particular whenever q m p q m the two terms m and m have the same free variables for example the closure yz xyz cannot reduce and it represents an error it would reduce to the erroneous quantum closure yz z where the domain of the linking function is not the set of free variables as specified by definition the type system will prevent such an error as proven in proposition example recall example we have x x x the latter reducing to either tt or ff with equal probability as for we have that x x x new ff xy y xy x y similarly one can check that q q behaves as described in section reducing to q q nil with probability to qq q q nil with probability etc in particular notice that in any single tion sequence the variable q has not been duplicated as correctly by the type of lemma substitution suppose x a m b and v a where and are linear contexts with disjoint domain then m v x b proposition subject reduction when q y yn m p q x xn m and y qubit yn qubit m a then x qubit xn qubit m a proposition type safety if q m is typable then either m is a value or there is a closure q m such that q m p q m moreover if m is not a value the total probability of all possible reductions from q m is lemma totality if q m p q m and q m is total then q m is total too proof by induction on a derivation of q m p q m one proves that where is the size of the quantum state q and is the cardinality of the domain set of the linking function then one gets the statement since q m is total iff notation the reduction relation defines the probability that a closure reduces to another one in a single step we extend this relation to an arbitrary large but finite number of reduction steps with the notation it is the total probability of q m reducing to a value q v it is defined as the sum q v of is all m i pi where q m a finite reduction sequence of p m q m · · · pm n steps we write for the sup over n of fi we define the total probability of q m to any value as qv val denotational semantics we interpret the quantum lambda calculus in a suitable extension of the category described in section what essentially misses is the linear logic exponential a and our plan is to introduce it via the equation a ak k where k is the infinite of the family ak k each ak being the symmetric tensor power of a ie the equal of the k of the tensor ak a · · · a the category cannot express this equation because it lacks both infinite and a convenient definition of symmetric tensor the category is in some sense the minimal extension of having these two missing the plan of the section is as follows section presents some preliminary material section defines and section the categorical structure allowing us to interpret the lambda calculus section the proof of the sound ness of the model with respect to the operational semantics finally section discusses the denotations of the programs and port from to permutation groups let sn be the symmetric group of degree n ie the group of permutations of n n any permutation g sn gives rise to a matrix pg defined by where ei is the ith standard basis vector we define an action of g on by g · m pg moreover for a g sn we define g g · m gg where g is the number of elements of g lemma given a g sn its action on is idempotent ie g · g · m g · m for all m and completely positive proof for the idempotence notice that for every g g gg g therefore g · g · m g gg gg · m g · m the complete of g is derived from the complete of each map m g · m pg in the sequel we use the notation g both for a of sn and for the completely positive map defined by it the above lemma allows us to define the set of completely positive maps from to invariant under the actions of two g sn h sm by h f m g f h f where f g is the composition f gx gf x and m is the set of completely positive maps from to completion of the positive cone the set h is a module over the semiring r of the nonnegative real numbers the order on completely positive maps this module with the structure of a bounded directed complete partial order ie there is a minimum element the zero function and any directed set d that is bounded ie such that there exists f h such that for all g d g f has a least upper bound d h however there exist unbounded directed subsets in h we therefore need to complete h to a the relevant construction is the of which we briefly recall given any poset p say that a subset x is if it is and for every directed i s if the least upper bound i exists in p then i s we say that a monotone function between posets f p q is if it preserves all existing least upper bounds of directed subsets let p be the set of subsets of p this forms a under the subset ordering the cp is defined to be the smallest of p containing all sets of the form x then cp is a and there is a canonical injective map p cp defined by x x which allows us to regard p as a subset of cp the preserves all existing least upper bounds of directed sets is idempotent and satisfies the following universal property given any other e and map f p e there exists a unique g cp e such that f g it follows that the is moreover if p is a bounded directed complete partial order then p is an initial subset of cp ie the only new elements added by the completion are at we call these the infinite elements of cp the h is then extended by namely h h the categorical operations are extended in the unique way using the universal property of this allows us to de fine indexed sums over h as follows if h is a possibly infinite indexed family ii fi is defined as f if fi indeed the set if fi f fin i is always directed so has a least upper bound in the order com h of h the category given a set a and a a a define the symbol aa n which takes value if a a and if a a objects are given by indexed families a where the index set a is called the web of a and for every a a is a natural nonnegative integer and a of permutations of degree called respectively the dimension and the permutation group of aa morphisms from a to b are matrices indexed by a × b and such that ab composition of b and c is the matrix defined by for a a and c c ac bb ab bc identity is the diagonal matrix built with the of a ie for a a a aa the description of the objects and the morphisms as indexed families is crucial for inferring the structure of a compact closed category section however it is to notice that can also be presented as a concrete category of mod and linear maps between modules let us sketch such an alter native presentation let a be an object of we define a module over r r as follows for every a in a let us write for the cone of the positive matrices in this latter being the of the matrices in invariant under this positive cone is an we then define aa in fact we have that and aa hence is a continuous module over r addition and scalar multiplication are defined pointwise and are continuous operations with respect to the order mb if m and b ff if m and b tt otherwise new mb if m and b ff if m and b tt otherwise u m m u m u if m otherwise table interpretation of the quantum constants the writing m stands for a sequence of multisets in the equality m meaning that each of these multisets is empty u and m have the same dimension u being unitary let f be a continuous module homomorphism we say that f is completely positive if all the module homomorphisms a f b are completely positive maps for all a a and b b indeed since the positive matrices span the complex vector space of square matrices of corresponding size one can extend the definition of complete to module homomorphisms proposition there is an isomorphism between the b and the continuous module homomorphisms from to that are completely positive as a model of the quantum lambda calculus a compact closed category is a special case of symmetric monoidal closed category a symmetric monoidal closed category with finite products such that each object has a corresponding free commutative is called a category which is known to be a model of intuitionistic linear logic the category can be with such a structure as we will show in sections ­ below we can therefore interpret the quantum lambda calculus in the denotation a of a type a is an object of in case a is the ground type ie qubit its denotation is qubit d id g id the denotation of the other types is given by structural induction following the compact closed structure of we note in particular that the permutation groups play a role only when interpreting formulas let xa the denotation of a typing judgement m a is a morphism m a a · · · an a the definition is by structural induction on the unique type derivation of m a see proposition the denotations of the constants new and the unitary transformations are given in table table briefly the denotation of the usual linear logic rules here the morphisms a b refer to the denotation of the premises of the last rule of which are uniquely defined given m a in the interpretation of the letrec constructor the fixed point operator y is defined as follows let be a morphism in the set a a by induction on n we define the morphism n a c w a n c c c c c a a since can be regarded as a continuous module homomorphism in particular it is monotone the set n is directed complete we define y as its least upper bound a b let i be a possibly infinite set of the ii ai of a family of objects in is defined by ai i × ai d ii ja ai j g ii ja ai j ii ii the corresponding projections and are denoted respectively by j and j and defined as aj ia i the i ii resp iii of a family of morphisms i elements of bi resp i elements of b is defined by i ii resp iii j ab example recall that in notation the type bit is inter as the which is the family the positive associated with and bit are pos r and pos bit r the typing judgement tt bit is interpreted as the right injection which can be seen both as a family of two completely positive maps from c to c ie tt bit tt p p and tt bit ff p and as a quantum compatible and completely positive map sending p r to p r ff bit is the map p p as an example of a term with free variables consider if x then ff else tt the denotation of x bit bit can be seen both as a family of four constant maps bb from c to c of value if b b and otherwise and as a single map from r to r sending p p to p p symmetric monoidal structure a b and a the × is defined on objects a b by a b a × b × g h g h where × is the multiplication of the two numbers and which can be seen as the ordered set of pairs i j for i j hence the action of a permutation g h on × can be described as i j gi the on morphisms is defined using the standard tensor of the category extended to the infinite el by the universal property of the section the tensor unit is the object interpreting the unit type the associativity unit and symmetry isomorphisms are de from the corresponding isomorphisms in composed with the actions of the groups of the objects eg the symmetry is aa bb where is the symmetry in between and notice that it is sufficient to with or with in order to have a map invariant under both the permutation groups and this is because a a a a x a x a a a a b x a x a m a c v a ab d a b a a b eval b e m n b w id a f skip g m n a a b id a b c a a b h m n a b i let xa yb m in n c j in m a b b r a b id a b a b abc k inr m a b l match m with xa n yb l c a a n an a m m a c a b c n letrec f x m in n c table sketch of the interpretation of the typing judgements using the structure of defined in section the morphisms a b refer to the denotation of the premises of the unique derivation a typing judgement in c and n the morphism m stands for m or the suitable sequence of m depending on the context similar simplifications will be done without explicitly it example the denotation of qubit qubit is the singleton web family id this object is associated with the cone of positive matrices of dimension × plus the in finite elements needed to complete the order the de notation of bit bit instead has a web of cardinality ie ff ff ff tt tt ff ff ff and for each index b bit bit we have and id this object is associated with the r r r r notice that in the above example the tensor product over the bit bit this is true in general the isomorphism between a ii bi and ii a bi is ii aa bb i this isomorphism allows us to define the list constructor as the infinite of tensor a n an in fact we have a a a example the denotation of the unit type list is n and for every n n dn gn id this object can be associated with the module rn and is suitable for de noting the in unary notation indeed writing n for the list skip skip nil of length n we have n p p n times compact closure a a b dual objects coincide we have a a the unit a a a and a a are defined composing the unit and of with the permutation group writing for the matrix that has everywhere except at i j we have gg i gj g j compact closed categories are monoidal closed let us recall the monoidal closure structure which is needed to model the ab and the application of the quantum lambda calculus the internal object is defined as a b a b a b the evaluation morphism b a b and the isomorphism from a b to a b are id where and are the associative left unit and symmetric isomorphisms associated with example let us consider the abstraction of the term discussed in example the denotation is obtained from just by the matrix in bb bb looking at this matrix as a module homomorphism the map is p p p which is a map from r to where we make explicit the correspondence between the web elements of bit bit and the components of the associated with application corresponds basically to matrix multiplication for example y b is the function defined as b b b y b which is sending to if b ff if b tt and otherwise free commutative ak a let us now focus on the crucial structure modeling the linear logic modality we first define the notion of kth symmetric power of an object and then we show how the of all such symmetric yields an exponential structure notation given a set x a multiset µ over x is a function x n the support of µ is the set µ a x the disjoint union is µ a a and the empty multiset is the zero constant function the cardinality of µ is ax n a multiset is finite if it has finite cardinality resp mf x is the set of the multisets over x with cardinality k resp finite finite multisets can be denoted by listing the occurrences of their elements between square brackets ie µ a a b is and zero on the other elements and is the empty multiset in a symmetric monoidal category given a natural number k the kth symmetric power of an object a is a pair ak of an object ak and a morphism from ak to ak which is an of the k of the tensor ak such do not exist in general but they do exist in and can be concretely represented using the multisets notation as follows ak ha ga ha where ha ga is a family of sequences of permutations and is a group composition being defined whose action on k k can be described by as the set of families of sequences of the form ia with for every j then the action of ha ga on such families is ia the morphism is given by k if µ a ak otherwise remark the object a k describes k unordered uses of an element of type a the fact that our model uses the symmetric tensor power ak instead of the tensor ak means operationally that the behavior of a program calling its input k times does not depend on the order of the calls example in example we have seen that qubit id the symmetric power qubit is instead the singleton web family id where is represented as the ordered set and the permutation acts on it by b b b b the group of permutations id the set of possible morphisms to or from qubit for example the matrix nc associated with the gate equation defines a complete positive of which is an of qubit but not of qubit because nc is not invariant under the action of id id nc nc nc concerning the module associated with symmetric tensor pos qubit is the of positive i i c which is a of the positive cone of of dimension concerning the denotation of qubit qubit is given by while its symmetric tensor power qubit qubit is given by the family id id notice the difference between the pair id associated with tt ff and the pair id associated with the two multisets of singleton support the a k ak of all symmetric of a can be defined as a mf a µ this object yields a concrete representation of the free commutative generated by a the also called weakening w and the or contraction c a a are µ ga µ µ the of the gives the structure of exponential the maps an object a to a and a morphism b to b defined by for µ mf a and b bk mf b k µ gb st a ak µ i the of the or d a and the or a are µ m where m a is a multiset of multisets over a and m a is the multiset union of such s ie for every a a m a m am finally the last two morphisms that are essential to interpret our calculus are m b a b and m given by and where µ × is the multiset in a b defined by µ × a b example using the isomorphism between mf and the set n and between mf tt ff and n × n the free commutative associated with and bit are and bit in general notice that all constructions of the category preserve the underlying pair id and act only at the level of for more involved examples one should look for objects with larger dimension like qubit for example qubit n notice that bit and qubit are not allowed by our type grammar in fact qubit is because of the constraint on quantum bits however such spaces should exist in the model since they are isomorphic to the tions of legal types like bit and qubit the soundness theorem the soundness of with respect to the operational semantics given in figure is an easy consequence of the fact that the category gives a model of linear logic in fact the operational semantics is a trivial extension of a strategy of linear logic proposition the category is a compact closed category hence is a model of linear logic proof sketch this basically amounts to showing that is the result of a categorical construction applied to which is known to give under certain a category and to preserve the compact closed structure of this construction was sketched in and detailed in it consists in moving i from to a category with symmetric which is actually a full of the envelope of ii to a category using the defined in and finally iii constructing the free completion of and applying equation given a linking y ym we write m a for the judgement y qubit ym qubit m a proposition invariance of the interpretation let be the linking y ym and assume m a if m is not a value then for all quantum states q cm m p · n qm p qn proof by hypothesis q m is a typable total closure and so by proposition and lemma all of its q n are typable total closures so that n is welldefined equation is proven by cases depending on the rule applied to q m the cases of table a follows from the fact that is a model of linear logic the quantum rules table b are trivial consequences of table and the congruence rules of table c are done by induction on m using the fact that the category is linear corollary we have m halt m proof by induction on n and using proposition we can show that m qq is greater or equal to qv qv then n m qq and invoking follows by taking the monotonicity of the limit as the denotations of and example recall the terms of example the web of qubit tion of the term is a morphism in qubit that is a map sending a × positive matrix onto n p the program is defined using recursion its semantics is the limit of the morphisms fn sending a c b d to the infinite sequence e n en where ei is the positive matrix a · · · b ··· · · · c ··· d this limit is the map sending a c b d to the sequence of infinitely increasing matrices e n en note that the first el of the sequence is as the program never return the empty list also note that all the positive matrices in the sequence represent states of arbitrary sizes our semantics is the first one to be able to account for such a case in only fixed sizes were allowed for states example we claim in the introduction that the model is ex enough to describe at higherorder types as we discuss in example the encoding of the quantum tion algorithm produces two mutually inverse functions f qubit bit bit and g bit bit qubit the term skip of type qubit bit bit bit bit qubit is one instance of such a pair of functions its denotation is a finite sequence of square matrices of size × using a convention we can them out as in fig because of the convention each row corresponds to an element of type bit bit qubit whereas each column corresponds to an element of type qubit bit bit a row ie a choice of two booleans amounts to choosing the two booleans that will be passed to the function g a column ie a choice of two booleans amounts to deciding on the probabilistic result we get from the function f the intersection of a column and a row is therefore the representation of a map qubit qubit this map is a description of a possible path in the control flow of the algorithm the matrices on the diagonal correspond to a run of the algo rithm as it was intended applying g to the result of f since they are to be the identity on qubit we can therefore de that the matrices a a a and a are all equal to since this matrix cannot be written as the ten of two × matrices we conclude that the denotation a of skip is indeed we can compute the other matrices using the same argument in general is a composition of f and g except that instead of applying g to x y we apply it to z t we therefore get a function qubit qubit constructed out of the u that might if xy zt or might not be the identity in general the matrix is the denotation of the unitary the denotation a is given in full detail in table remark example is a good illustration of what we in the introduction the model reflects the of quantum and classical structures even at higherorder types here the controlflow is handled by the structure and the quantum part of the algorithm is split across the list of × matrices adequacy in the following we prove the adequacy of theorem this amounts to achieving the converse inequality of corollary the proof uses a syntactic approach following we introduce a bounded which can be at most n times on the one hand the language allowing only bounded letrec is strongly normalizing lemma hence the adequacy for it can be easily achieved by induction on the longest reduction sequence of a term corollary on the other hand the unbounded letrec can be expressed as the of its bounded both semantically lemma and syntactically lemma we then conclude the adequacy for the whole quantum lambda calculus by continuity definition let us extend the grammar of terms table by adding i a new term a ii a family of new term constructs f ab x m in n indexed by natural numbers n the typing rules for these new constructs are f a b x a m b f a b n c a a f ab x m in n c their denotations are given respectively by the map and the family of maps c a b c where a b a b and a b c are the denotations of the premises and m n a b is defined in a similar fashion as in table the reduction rules are updated as follows q letrec f ab x m in n q n f q f ab x m in n q n f ab x m in m f a a a a a a a a a a a a a a a a a table the denotation of the quantum algorithm the additions to the language do not modify the properties of the language subject reduction proposition and totality lemma hold as they are stated while type safety proposition and soundness proposition are satisfied with the of considering the set of normal forms to consist of the set of values and the set of terms containing in evaluating position definition a term is called finitary when it does not contain any occurrence of the letrec construct it can however contain and any of the indexed we call a closure finitary when its term is finitary lemma strong normalization if q m is finitary and typable then every reduction sequence of the form q m p q m p q m p · · · is finite proof sketch we reduce the finitary quantum lambda calculus to a simply typed nondeterministic language without quantum states for which a standard proof technique can be used the terms of this language are the terms of the extended quantum lambda calculus the letrec construct the operational semantics is obtained from table and the rules for by replacing closures with the respective terms and the rules of table b by dummy reduction rules like u ·· · ·· ·· · ·· or new ff · the symbol · denotes a distinct term variable which by convention it is never bound by an abstraction clearly the strong normalization of this language implies that of the finitary quantum lambda calculus corollary finitary adequacy let m be a closed finitary term of unit type then m halt m proof sketch we prove that for any total finitary quantum closure of unit type q m we have m qq in fact by lemma there exists m n such that qv we conclude by induction on m definition let be a relation between finitary terms and general terms defined as the smallest congruence relation on terms satisfying for every m m and n n n f letrec f x m in n f x m in n letrec f x m in n lemma if m a then m a lemma if m m then mm m a m finitary proof sketch by induction on n one proves the inequality qv qv qv qv from which the statement follows trivially theorem let m be a program ie a closed term of unit type then m halt m proof by corollary we have m halt m con by lemma m m m m which is equal to mm halt m by corollary which is less or equal to halt m by lemma structure of the sets of representable elements we conclude this paper with an analysis of some of the properties of the denotation of terms recall that a morphism in is an indexed family of either completely positive maps or infinite elements added during we show that all types have a nonzero provided that the term constant u ranges over arbitrary unitary matrices the representable elements of a given form a convex set including and infinite elements are not part of any representable map we first need two auxiliary definitions definition we define two families of terms a and a by mutual induction in table the term c represents the fair h new ff recall example and the notation µf xm stands for letrec f x m in f lemma for all types a we have a a and a a moreover the morphisms a a and a a seen as indexed families do not contain the zero map corollary all types are by at least one closed value of nonnull denotation proof immediate with lemma for a given type a choose the term a skip proposition given a type a and a context the denotations m a of valid typing judgements m a form a convex set including proof suppose that is x a xn an a term m mapping to is a x an xn where the term is a for letrec f x f x in f skip of denotation now suppose that f m a and g m a and choose two nonnegative real numbers such that there exists an such that and that sin as the term constants u range over arbitrary the unitary matrix v sin sin is representable in the quantum lambda calculus the term c v new ff has denotation we then conclude that the term if c then m else m has denotation f g proposition if m a is valid then no infinite element is part of the denotation m a of m proof suppose that one of the infinite elements of the were to be found in the interpretation of x a xn qubit ff ab xb skip ab skip x ab skip b skip ab c then a skip else b skip a µf c then skip else a skip f skip qubit x then skip else skip ab f ab b f a skip ab c then skip else ab f g f ab z z x in a z ab x with za a z b z a µf xa match split x with z z let y y z in a yf y table two mutually recursive families of terms an m a then the closed term x m a skip an skip of type has infinite denotation theorem this last proposition indicates that infinite elements introduced during the are really an only needed for the categorical construction the representable elements in the model are only built out of families of completely positive maps conclusion we presented a higherorder lambda calculus for quantum computation classical and quantum data duplication recursion and an infinite parametric type for lists we then a open question the description of a model for the full quantum lambda calculus the model we propose is a free construction based on the known model of completely positive maps but nevertheless has a concrete presentation one thing that this model explains and illustrates is the distinction between the quantum and classical parts of the language the quantum part is described by completely positive maps finite dimension whereas the classical control is given by the category ie linear logic the model demonstrates that the two work well together but also ­ surprisingly ­ that they do not mix too much even at higher order types we always have an infinite list of finite dimensional the control flow is completely handled by the completion and not by the structure the adequacy result moreover that the model is a good representation of the language one should also note that the product and the coincide in our model for example the model has morphisms that correspond to a program returning true with probability and false with probability we would like to point out that our interpretation is not for example there are also morphisms in the model corresponding to probability adding terms with such behavior makes it possible to build a term whose denotation is ­ so the fact that this provably does not happen captures the of the model interpretations in denotational models are often not in fact it is an open problem to give a characterization of the image of our interpretation similarly the problem of is still open references v and t probabilistic coherence spaces as a model of higherorder probabilistic computation comput t spaces ­ jy girard linear logic th comp sc ­ jy girard normal functors power series and lambdacalculus ann pure logic ­ jy girard coherent spaces a continuous denotational semantics theoretical computer science i and n semantics of higherorder quantum computation via geometry of interaction in proceedings of lics pages ­ k and j d and the of pure and applied logic ­ e h conventions for quantum technical report national laboratory y et machines phd thesis paris u d a and m confluence results for a quantum lambda calculus with measurements notes theor comput sci ­ j g and g constructing differential categories and categories of games information and computation ­ j g g and m weighted relational models of typed in lics s mac categories for the working springer nd edition sept o categorical models of computation partially traced categories and models of quantum computation phd thesis university of pa categorical semantics of linear logic et pa n and c an explicit formula for the free exponential modality of linear logic in icalp pages ­ m a and i l quantum computation and quantum information cambridge university press p towards a quantum programming language mathematical structures in computer science ­ p towards a semantics for higherorder quantum computation in gen no pages ­ p and b a lambda calculus for quantum computation with classical control mathematical structures in computer science ­ p and b on a fully abstract model for a quantum linear functional language in p and b quantum lambda calculus in s and i editors semantic techniques in quantum computation chapter pages ­ cambridge university press b semantics for a higherorder functional programming language for quantum computation phd thesis univ of d and t fan of posets th comp sc 