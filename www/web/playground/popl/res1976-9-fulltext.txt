an algorithm for structuring programs extended ct s bell hill new introduction structured programming programming language constructs such as while loops until loops and if then else statements properly used these constructs make occurrences of loops and branching of control obvious they are to goto statements which tend to the flow of control this paper describes an algorithm which transforms a flowgraph into a program written using repeat do forever and if then else statements the goal of the algorithm is to produce readable programs rather than to avoid the use of goto statements entirely goto statements are generated w h e n there is no better way to describe the flow of control a number of techniques for eliminating goto statements from programs have been previously published am bj bs however these techniques do not necessarily produce clear flow of control kn of control constructs may the reader into patterns of control flow which do not exist in the algorithm for example these techniques may use repeat statement when the contained code cannot be executed more than once or add numerous control variables to avoid goto statements they also may avoid goto statements by copying segments of code or creating subroutines the former method results in longer programs and bugs may be introduced when all the identical segments must be modified the latter method may result in subroutines which appear therefore this paper formalizes some common programming as a set of principles for the use of basic control constructs if then else repeat break a branch to the statement following an enclosing repeat statement next a branch to the next iteration of an enclosing repeat statement stop and goto the principles fall into two classes those which concern the nesting of statements and those which concern the use of branching statements goto next break and stop a program which the structuring principles is called properly structured an algorithm is presented which transforms a flowgraph into a properly structured program in which the predicates and straight line code statements are the same as those of the flowgraph in both number and execution order in general the properly structured program may contain goto statements however the goto statements occur only where no other available control construct describes the flow of control if a flowgraph can be written as a properly structured program with no goto statements the algorithm does it section defines and introduces a simple structured language sl the principles concerning nesting and ordering of statements are described in section section presents the first part of the algorithm the principles for the use of branching statements and the second part of the algorithm appear in section section studies how the structuring principles limit the possible forms of programs representing the same flowgraph if a flowgraph can be represented by a properly structured program with no goto statements this program is unique more generally if a flowgraph contains no jumps into the middle of loops all properly structured programs representing it have the same nesting but not necessarily order of statements other than goto next break and stop section discusses briefly the application of the algorithm to structuring real programs the algorithm has been implemented in a program called struct which translates fortran programs into a fortran language the structured programs generated by struct are much more readable than their fortran counterparts it is not usually obvious that they are mechanically generated since the structuring principles cause them to common programming practice an example of a program structured by struct is included at the end of the paper the structuring algorithm presented in this paper is proposed as a tool for the of fortran programs one of the problems in dealing with fortran pro grams is that the lack of convenient control structures makes programs hard to under stand fortran languages such as have been developed so that new programs may be written using convenient control structures but many existing pro grams were written in fortran without the benefit of mechanically structuring these programs improves readability modification and debugging goals of structuring this section defines a simple structured language sl and what it means for an sl program to be a structuring of a flowgraph straight line code node with one a stop node with no or a predicate pred node with a true and a false a flowgraph has exactly one stop node and there is a path to it from every node in the flowgraph one node of the flowgraph is designated as the start node the structuring algorithm presented in this paper translates a flowgraph into a simple structured language sl sl contains labelled statements of the following forms straight line code statements ie assignment read write etc stop goto l where l is a label if p then s else where s and are possibly null sequences of labelled sl statements and p is a predicate repeat s where s is a possibly null sequence of labelled sl statements where i is a positive integer where i is a positive integer statements of types are interpreted in the standard way repeat s causes the sequence s to be iterated until a stop is executed or until a goto or i greater than causes a jump out of the repeat statement causes a jump to the statement following the ith enclosing repeat statement causes a jump to the next iteration of the ith enclosing repeat statement for simplicity no if then statement is provided but its equivalent is obtained by a null else clause also more complex constructs such as while and until are not provided since they can be expressed in terms of repeat if then else and break for simplicity return is not included it may be treated like stop during structuring a flowgraph is a directed graph with labelled nodes representing computational steps and arcs representing flow of control between nodes each node is either a goto stop and statements are referred to as branching statements other statements are statements an sl program is wellformed if the following conditions are satisfied every statement is accessible from the start of the program the program contains at least one stop statement and a stop statement is accessible from every statement and from both the true and false evaluations of every if predicate as a result of condition every loop in a wellformed program has an exit a flowgraph may be obtained from a wellformed sl program p to describe the flow of control between statements if predicates and stop statements each statement in p is represented by a distinct node each if predicate in p is represented by a distinct pred node and all stop statements are represented by a single stop node in there is an arc from an node p to a node q in if after executing the corresponding statement in p control can pass directly to the statement represented by q ie without first executing any other statement or if predicate there is a true false arc from a pred node p to a node q if control passes directly to the statement represented by q when the if predicate represented by p is evaluated to true false the start node of is the node representing the first statement if predicate or stop statement executed in p two wellformed sl programs p and p are equivalent if note that this is a stronger statement than merely requiring that the set of execution paths be the same if one program has two copies of an statement while the other has only one the programs may have identical sets of execution paths but are not equivalent by this definition this definition of equivalence was chosen because the algorithm of this paper does not copy code a wellformed sl program p is a structuring of a flowgraph g if g the structuring algorithm presented in this paper identifies the basic structure in in a flowgraph and writes it as an sl program it has two parts the first part determines the organization of the final program that is it how many repeat statements to use how statements should be nested and the ordering of statements the result is a program form ie an incomplete program consisting only of if then else and repeat statements together with a specification of the correspondence between these statements and nodes in the flowgraph the second part of the algorithm determines where branching statements should be added to produce the proper flow of control for example if the final structured program generated by the algorithm is repeat if p then x xl else y yi if q then goto else y fy x gx if r then else z stop then the first part of the algorithm generates the following repeat if p then x xl else y yl if q then else y fy x gx if r then else z the second part of the algorithm adds the goto the label the and the stop the program form obtained by deleting all branching statements from an sl program p is denoted by thus if the algorithm generates an sl program p the first part of the algorithm generates only deciding on principles for programs the goal of the algorithm presented in this paper is not to eliminate goto statements since the methods of eliminating all goto statements have not been found to produce readable programs kn instead the algorithm follows a set of principles for the use of control constructs to ensure that the mechanically structured programs appear natural to the reader these principles describe some reasonable for programming in sl they also appear to be followed by many programmers since a number of principles are needed to ensure production of natural sl programs some examples are presented to how this set of principles for use in the structuring algorithm the principles describe how repeat statements if then else statements and branching statements should be used in sl programs first some examples of uses of repeat statements are presented in the following program the repeat is because it contains code which does not iterate repeat sl stop the following are some equivalent programs with room for improvement in how repeat statements are used a yl goto repeat if p then else y fy x gy stop b goto repeat y if p then else y x gy stop in a the repeat statement can be entered only by into it in b this problem is because the statement y l is written inside the repeat even though it is executed only once in particular this statement cannot be reached after executing the statement y fy which is the first statement in the repeat a much way of writing the same computation is the following yl repeat y fy if p then else x gy stop the program segments presented above can be avoided by the following principle every repeat statement can be entered through its head ie not just via a goto to a statement nested within it every repeat statement contains at least one or if then else statement every statement within a repeat is accessible from the first statement within the repeat without from the repeat every statement within the repeat can lead to an iteration of the repeat without first from the repeat equivalent sl programs need not have the same number of repeat statements consider the following examples a repeat repeat if p then else if q then else x xl b repeat if p then if q then else x xl else the first example uses two repeat statements where one suffices the algorithm generates only one repeat since a single repeat appears simpler a repeat statement may not be the first statement reached upon entering repeat statement next two examples of uses of if then else statements are presented programmers often violate this principle in order to avoid goto statements when a loop has several pieces of exit code as implemented in this principle has an associated size limit so that small segments of code but not large segments may appear in a repeat without a if p then jl goto i else j i y fj stop b if p then else j goto jl y fj stop in a the statement y is placed inside the else clause forcing a jump into the else clause from the then clause in b the statement j is placed after the if statement forcing the else clause to contain a goto around the statement follow ing the if clause example a could be by jumps into then or else clauses example b could be prevent ed by requiring that a then or else clause contain as much as possible without causing a jump into it or the conditions on repeat statements but problems are caused by programs in which a loop may be entered in more than one place a flowgraph g is reducible hu if each cycle has exactly one entry point that is if every cycle in g contains a node q such that every path from the start node to a node in the cycle must pass through q otherwise a flowgraph is irreducible a wellformed sl program p is reducible irreducible if is reducible irreducible since is a property of an irreducible program does not have an equivalent reducible program however an irreducible flowgraph may be transformed into a reducible flowgraph by part of the graph consider the following equivalent irreducible programs a if p then goto else repeat if q then j i else lo j if r then stop else b if p then goto i else repeat if q then jl goto else i j if r then stop else the first example allows a goto into the else clause from outside the smallest repeat enclosing the else clause the second example avoids the goto into the else clause but forces an additional goto to be generated in the then clause locally ie within the repeat statement the first example is structured better in particular it does not look as if the statement j can be executed after both the then and else clauses therefore the following principles are used by the algorithm a a goto may jump into a then or else clause only from outside the innermost repeat enclosing the clause b a statement in the innermost repeat enclosing an if then else statement p must be placed within the then clause of p if this does not force a violation of principle a the same principle applies to else clauses the following principle guarantees that loops are created by repeat statements and that each goto statement jumps to a statement which occurs after it in the program control may flow to a preceding point in the program only to an iteration of a repeat ie by executing a or by reaching the bottom of a repeat statement a wellformed sl program which satisfies principles has proper nesting the first part of the structuring algorithm the first step in structuring a flowgraph g is to the loops in g a loop is a path of g which begins and ends at the same node a cycle is a loop in which only the first node which is the same as the last node occurs twice loops can be located by constructing a spanning tree by means of a depth first search hu as follows begin by the start node of g and setting num to the number of nodes in the flowgraph when a node m do the following if node m has an arc to a node p not already visited make p a child of m in the spanning tree and visit p next otherwise number m with num num by l and return to visit the parent of m if it exists again a back arc is an arc from a descendant to an ancestor in the spanning tree other arcs are forward arcs each node entered by one or more back arcs will become the first statement within a repeat in the final program if a cycle has more than one entry point exactly one entry point is entered by a back arc let l be a list of the nodes of the graph ordered by the numbering assigned during the depth first search this list will be used to ensure that all in the final program flow downward on the page note that an arc pq is a back arc if and only if q appears before p in l also if pq is a back arc there is a path from q to p which includes only nodes between q and p in l at this point the nodes which will be come the first statements within have been determined for each node n entered by a back arc add a single repeat node p replace each arc qn by an arc qp and add an arc pn insert the repeat node p immediately before n in l call the new graph the extension of g note that the addition of the new nodes does not change the ordering of the nodes already in l therefore an arc pq is a back arc if and only if q precedes p in l a repeat node p is the head of all loops and cycles which include p but no nodes preceding p in l in the final program the corresponding repeat statement will contain the statements corresponding to nodes in loops by p for each node q the algorithm determines which is the repeat node which will correspond to the smallest repeat enclosing q in the final program in particular of the repeat nodes which are heads of loops containing q is the one preceding q in l if no such node exists is undefined note that for a repeat node p is either a different repeat node or is undefined the repeat corresponding to p will be nested within the repeat corresponding to in the final program to produce the following segment of code then xl else x y fx the algorithm needs to know that the statements x and x can be reached only through the true and false branches of the if statement but that y fix can be reached through both branches such branching and merging of control can be described by dominators in the flowgraph au node p dominates node q if every path from the start node to node q must pass through node p node p is the immediate dominator of node q if no other dominator of q lies closer to q that is if every dominator of q other than p also dominates p every node in the flowgraph except the start node is dominated by at least one node the start node moreover every node except the start node has an immediate dominator because principle implies that the inside of a repeat must be structured as if the repeat can be entered only at its head the structuring algorithm uses a modified graph for calculating dominators intuitively it that each arc entering a cycle at a point other than its head enters the head instead let be a flowgraph obtained as follows from if pq is an arc and p is not in a cycle by the arc pq is replaced in by an arc pr where r is the first repeat node in l which is the head of a loop containing q but not the head of any loop containing p t h e resulting graph is reducible for each node p is defined to be the immediate dominator of p in the graph for each node p head and dom are used to obtain a set specifying nodes which belong after p at the same level of nesting as p for each pred node p define qq is entered by or more forward arcs in reduce p and head p head q for each repeat node p define w p ql head q head p and is in a loop by p for each node p define q head q head p and p note that the sets are pairwise disjoint for all nodes p every node is in a follow set except for the nodes which will correspond to the first statements at each level of nesting intuitively is the set of statements reachable from p which must follow p at the same level of nesting as p for example suppose p is a repeat node and q is in since q must be placed within the smallest repeat containing p but not within p since is in a loop by p every path to q within this repeat must pass through p by principle q must be at the same level of nesting as p within this repeat furthermore q must be below p to avoid an upward goto the nesting and ordering of statements in the program is determined by generating a program form from the flowgraph g ie a sequence of nested statements which will be for the final program p generated by the algorithm is generated by calling the following recursive routine on the start node of the extended flowgraph to be precise the correspondence between statements of and nodes of should be specified for simplicity it is merely assumed to exist if n is an node then print the straight line code else if n is a repeat node with arc to node q then call print else if n is a pred node with predicate r and a true arc to node p and a false arc to node q then r then call print else call print for each member q of in order of in l call if q is not in any follow set then call since the follow sets are pairwise disjoint is called exactly once on each node in the resulting program form is branching statements and the second part of the algorithm next the use of branching statements is considered the first principle for the use of branching statements is the following a goto statement may not jump to another branching statement a goto may not jump to the first statement inside a repeat it must jump to the repeat instead a branching statement may not appear unless deleting it the flow of control in the program the above principle does not specify where branching statements should be used consider the following example if p then xl stop else x stop the form of the following program is if p then x i else x stop on the other hand when the then and else clauses jump to different places it is probably to put the branching statements inside the then and else clauses the following principle is followed by the structuring algorithm to determine where branching statements be added a branching statement appears after a statement p if and only if there is exactly one node q in the corresponding flowgraph such that both of the following conditions hold a q does not correspond to an or if statement nested within p b q is the only node satisfying a which is entered by an arc from the node corresponding to p or from a node corresponding to an or if statement nested within p the next principle assigns a preference order to branching statements to ensure that branching statements following repeat statements can be reached branching statements are used in the following order of precedence for any i for any i stop goto that is a statement in the list may not be used if a choice earlier in the list may be substituted without the flow of control between statements this principle ensures that a goto statement is not used when another branching statement suffices a program which follows principles has proper the second part of the algorithm adds proper branching to by computing the statements directly reachable from each statement but not nested within it in particular for a node p in is the set consisting of all nodes q entered by arcs from p or from nodes corresponding to statements nested within p such that q does not correspond to a statement nested within p branching statements are added to the program recursively from outer levels of nesting to inner levels a branching statement is added after a statement p if contains exactly one node q and q is not the node corresponding to the statement reached automatically in the program if no branching statement follows p if a then or else clause or the entire program contains no statements a branching statement is added if it is needed to ensure proper flow of control the choice of branching statement is determined by principle and a label is added to each statement entered by a goto when the above procedure is applied to the program form generated by the first part of the algorithm the resulting program is called a wellformed sl program with prop er nesting and proper branching is properly structured if p is a structuring of a flow graph g and p is properly structured p is a proper structuring of g theorem is a proper structuring of g a nice feature of the algorithm is that it does not generate goto statements theorem if a flowgraph has a proper structuring with no goto statements the algorithm produces one a simple analysis of the algorithm yields the following upper bounds for time and space theorem in the worst case the generation of from g requires at most space on and time where n is the number of nodes in g in practice the implementation of the algorithm in struct handles fortran programs several lines in length in a reasonable amount of time on a with k bit bytes properly structured programs in this section the implications of the structuring principles are investigated one question one might ask about the conditions for proper nesting and proper branching is how much flexibility they permit in writing programs in particular suppose one is given a computation specified by a flowgraph in writing an sl program to perform this computation how much flexibility is there in the number and type of control statements in the nesting of statements and in the ordering of statements at each level of nesting in other words where may differences occur between equivalent properly nested programs consider the following example if p then else goto repeat x fy y fx if q then else this code segment could be rewritten as if p then goto else repeat y fix if q then else x there is a choice because the loop is entered in two places that is the underlying flowgraph is irreducible however when the underlying flowgraph is reducible there is no flexibility in the number or nesting of statements theorem if e i and p are equivalent properly nested reducible sl programs then and are identical in the number of occurrences of each statement and in how the statements are nested within each other note that theorem does not state that p and p are identical in the order o f statements at each level of nesting in fact the order of statements is not uniquely determined for example consider the following code if p then if q then goto else else if r then goto else xl goto x y fx this segment could be rewritten by x with x and moving the goto statements to the else clauses however there is no flexibility in order when no goto statements occur theorem if pl and p are equivalent properly nested sl programs with no goto statements then proper branching does not restrict the form of the program lemma for every properly nested sl program p there exists an equivalent sl program p with proper branching such that f o r m p f o r m p moreover p is unique except for labels on statements from the above theorems and lemma it follows that equivalent properly structured sl programs with no goto statements are identical in terms of the algorithm this result may be stated as follows corollary if p is a properly structured sl program with no goto statements then e intuitively this corollary states that flexibility in writing a program occurs only in choosing the flowgraph or in choosing to violate the principles of proper structuring in other words when a programmer to write a properly structured goto statements lies only in modifying the computation to be performed ie the flowgraph for the program and not in the way the program itself describes the computation it must be noted that an sl program without goto statements may not have an equivalent properly structured sl program because of the restriction that a repeat may not be the first statement inside another repeat the following code segment is an example repeat repeat if s then break else if p then if q then else else if r then else xx if x x and x x l were within a single repeat they would be at the same level of nesting as the if p statement but at most one of them could be reached without a goto from within the if p statement therefore there is no equivalent properly nested program without goto statements applying the algorithm the algorithm has been implemented in a program called struct which rewrites fortran programs in the basic algorithm is extended in struct to generate optional additional constructs such as while loops and a form of case statement predicates are by struct when necessary for the generation of if then statements has only break and next statements therefore struct does not strictly to the conditions of proper branching the appendix contains an example of a fortran program and the program generated from it by struct the mechanically structured versions of programs are easier to understand than their fortran counterparts sometimes so their natural indicates that the structuring principles describe reasonable programming a more extensive discussion of struct and its success in structuring fortran appears in it is expected that struct will be a useful tool in the of existing programs new programs may be written in while existing fortran programs may be structured into for greater ease of modification and debugging acknowledgements the author to thank a v aho r a s c johnson b w and m d for their helpful comments on this paper references au a v aho and j d ullman the theory of parsing translation and compiling vol h compiling prenticehall nj and z manna translating program schemas to s i a m j on comp s struct a program which structures fortran in preparation bj c and g flow diagrams turing machines and languages with only two formation rules comm a c m i bs j and k the expression of algorithms by j a c m c cooper and reduction of flow comm a c m or e w dijkstra and c a r hoare structured programming academic press new york e w dijkstra goto statement considered comm acm s and j d ullman of reducible j acm s and j d ullman flow graph siam j comput w a for a rational fortran software practice and experience d e knuth and r w notes on avoiding go to statements proc letters kn d e knuth structured programming with goto statements acm comp r analysis of structured programs j comp sys sci w t and n on the capabilities of while repeat and exit statements comm acm appendix a fortran subroutine from r c singleton algorithm an efficient algorithm for sorting with minimal storage comm a c m p subroutine c sorts array a into increasing order c from to dimension integer ml i ii if i goto k i ij ji t if ai le t goto ai ai t lj if aq ge t goto aj t t if ai le t goto ai ai t t goto al ak ak tt if al gt t goto tt al k k l if ak it t goto if k le goto if li le jk goto i ik rem goto k jl rem goto rem return if ji ge goto if i eq ii goto ii i i l if i eq j goto t if ai le t goto ki ak k k if t it ak goto t goto end the preceding subroutine as structured by struct into subroutine sorts array a into increasing order from to dimension integer ml iii repeat if i j go to repeat m m if mo return i j while ji ki ij ji t if ai t ai ai t t ai lj if aj t aj aj t t if ai ai t t repeat if tt al repeat k kl if ak t break if k break al ak ak tt if li jk k j ji m ml else i ik m ml if iii break i i repeat i i if ij break t ail if ki repeat ak kk if t ak break t return end 