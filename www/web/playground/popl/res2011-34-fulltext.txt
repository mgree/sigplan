on interference abstractions wang abstract interference is the of both concurrent programming and analysis to avoid considering all possible between concurrent threads most automated static analysis employ techniques to approximate interference eg by restricting the thread scheduler choices or by the transition relations or reachable states of the program however none of these methods are able to reason about interference directly in this paper we introduce the notion of interference abstractions ias based on the models of shared memory consistency to reason about interference efficiently ias differ from the known abstractions for concurrent programs and cannot be directly modeled by these abstractions concurrency bugs typically involve a small number of and therefore can be captured by small ias we show how ias in the form of both over and of interference can be obtained syntactically from the axioms of sequential consistency further we present an automatic method to synthesize ias suitable for checking safety properties our experimental results show that small ias are often sufficient to check properties in realistic applications and improve the scalability of concurrent program analysis in these applications categories subject descriptors d verification model checking formal methods general terms algorithms verification introduction analyzing shared memory concurrent programs is difficult due to the fact that constituent program threads may interfere with each other via shared variables multiple have been developed to model and reason about interference eg the traces model the program behaviors as a partial order over events while the model a scheduler to generate all possible thread interleavings because analyzing all possible is in practice these models employ reduction techniques to focus on a subset of eg partialorder reduction ­ or ­ in this paper we develop a new formalism based on memory consistency models for analyzing shared memory concurrent programs efficiently a memory consistency mc model rules on when a read to a shared location may observe some write to the same location and hence determines the set of feasible executions of a concurrent program concurrent program analysis permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission andor a fee popl january ­ austin texas usa copyright c acm based on mc models has received considerable attention recently both for the relaxed mc models which allow instruction reorderings by the compiler or hardware as well as for highlevel static analysis using a mc model is particularly because it allows us to reason about between reads and writes of program threads directly inside a reasoning framework for events similar to traces in this work we focus on the wellknown mc model of sequential consistency sc which is both intuitive as well as simpler to analyze the sc model the following rules more formally axioms in firstorder logic of interference for correct program executions i each read must observe some write to the same shared location write and ii a read may only observe the last such write in the order note however that enforcing these rules for all reads and corresponding writes in a program again leads to an analysis to obtain a scalable analysis we introduce interference abstraction ia a new concurrency abstraction to reason about thread interference using the memory consistency models one way to obtain an ia is by weakening the sc rules eg by a read to not observe any write in other words we allow program executions where the read may obtain any value independent of the values of the writes this form of weakening leads to an overapproximation of interference denoted as an alternatively we may the sc rules eg by forcing a read to observe only a subset of all possible writes consequently executions where the read may observe writes outside the subset are out such strengthening leads to an underapproximation of interference denoted as an either of these approximations obtained by weakening or strengthening the sc rules makes analysis more tractable intuitively an ia enforces fewer dependency relationships among reads and writes than by the sc rules many concurrent safety errors eg data races deadlocks and atomicity violations typically occur due to a small amount of interference between threads this fact is captured formally by ias ie there often exist small ias sufficient to detect these errors we present a formal framework to characterize ias in an uniform manner by exploiting the axiomatic formulation of sc rules more precisely we show how to obtain a wide variety of ias in a syntactic manner by instantiating the sc axioms the framework models not only and but also mixed ias containing both over and of interference in a manner further we show how several informal notions of concurrency abstractions for checking properties can be formally captured in the uniform framework of ias given our unified framework of ias the key problem is to synthesize ias suitable for checking a property to this goal we present an iterative refinement scheme which starts from a ia and refines it in a manner most traditional schemes eg ­ work with either over or to obtain proofs or witnesses respectively in contrast our algorithm works directly on a mixed approximation ie mixed ias and iteratively the mixed ia to an if a proof exists or an if a witness exists we implemented our approach in the fusion platform which is a collection of tools for concurrent program verification eg ­ we evaluated the effectiveness of ias for checking embedded assertions and data races on programs our results show that small ias are sufficient to decide many of the properties and our iterative refinement procedure enables improved analysis of these benchmarks further we have been able to check larger benchmarks that were without using ias to sum up this paper makes the following contributions · we introduce the notion of interference abstraction to reason about based on memory consistency models these ias may over or the thread interference or represent their combination sec we show that these ias formally capture common concurrency bug patterns and as well as correctness proofs sec · we present a unified framework for obtaining these ias from the axioms of sequential consistency sec the framework of ias provides a flexible mechanism for interference among reads and writes by the memory consistency axioms · we formalize the set of ias as a complete lattice and present an iterative approach to synthesize ias for checking properties based on a combination of over and ias sec a set of focusing heuristics are also presented to make the iterative algorithm practical we start with formalizing concurrent programs concurrent programs a concurrent program consists of a finite set of threads t tk communicating via a set sv of shared variables each thread ti has a set of local variables lv i and is represented by a control flow graph defined below threads are allowed to fork other threads in a bounded manner ie the total number of threads is finite let t denote the main thread and vi sv lv i denote the set of variables accessible to thread ti we represent a concurrent program using a concurrent control flow graph which may be viewed as an extension of control flow graphs cfgs for sequential programs a cn e consists of a set of nodes n and a set of edges e we use two special types of nodes f and join to model thread creation and thread join respectively a program thread ti corresponds to a subgraph ni ei of the where ni consists of nodes representing program locations in thread ti and ei consists of edges representing the program statements assume that ni contains unique entry and exit nodes of ti for each ti i the entry node has a single incoming edge from a f node and the exit node has a single outgoing edge to a join node each edge in ei is labeled by one of the following actions · guarded assignment where c is a condition over vi and w exp is a set of parallel assignments where w vi and exp is an expression over vi intuitively the assignments proceed iff condition c is true · fork j where j k and j i starts the execution of child thread tj · where j k and j i for child thread tj to terminate · where c is a condition over vi asserts c thread t thread t thread t int x int y t t t main t t t joint t joint t assert x y foo int a t ay t if a t x t ax t xa t else t x t bar int b t bx t if b t y t by t yb t else t y t figure a multithreaded c program with an assertion by defining expressions and using code transformations the above formulation can model all statements in standard programming languages like java and multithreaded c the details on modeling generic language constructs such as pointers and structures are omitted since they are not directly related to concurrency for more information on language modeling refer to recent efforts including ­ the guarded assignment action may have the following variants when c true it represents normal assignments when the set is empty itself can represent the of an statement while can represent the and with both guard and assignments it represents an atomic which can be used as the foundation of all kinds of synchronization primitives for example the lock lk in thread ti is modeled as lk i and the lock is modeled as here the value of lk indicates the lock owners thread index means the lock is free similarly the counting semaphore se is modeled as se se bounded concurrent programs static analysis of concurrent programs with loops andor recursion is known to be undecidable even with finite data our goal however is to analyze programs where data structures are precisely modeled we therefore focus on analyzing bounded concurrent programs whose analysis is decidable intuitively a structurally bounded program is obtained by finitely the loops and recursion in an arbitrary concurrent program bounded programs are also obtained in the context of symbolic predictive analysis eg by generalizing from the sequence of program statements executed in a particular trace this form of bounding the number of program threads and the heap further if the underlying program theory is decidable then the analysis becomes decidable a bounded program the sets of paths of the original program and hence the violations found by the analysis are real however the proofs absence of violations found may not generalize to the original program we represent bounded programs using for ease of presentation we assume that all function calls in the program have been however the presented technique can be directly extended to handle function calls example fig shows an example of a multithreaded c program with two shared variables x and y the main thread t creates threads t and t which in turn execute functions foo and bar respectively thread t for t t to terminate and join back before x y here create and join are routines in library directly corresponding to in our model since this particular example does not have loops and recursion the bounded and the original programs are same the assertion at t defines the correctness property which holds in some but not in all execution traces of the program in particular the execution trace t does not violate the assertion x y at t whereas the execution trace violates the assertion x y at t single static assignment recall that a sequential program can be encoded in a standard manner using the single static assignment form which combines the classic single static assignment ssa form each variable is defined exactly once with conditions under which a particular definition of a variable may reach a join node for example consider the following c code l if c z l else z l y z z z y the ssa form the writes to z at l and l in terms of new definitions of z and z respectively the use of z in l is then rewritten using the function as z z which by definition may evaluate to either z or z consequently l is rewritten as y z z where y is a fresh definition of y note that the operator does not contain information about the conditions under which definition z or z may be chosen and therefore cannot be used for precise encoding of the bounded program the representation solves the problem by replacing z z with z z where stands for the ifthenelse operator that is y z when condition c is true otherwise y z symbolic analysis of bounded programs we say that two memory accesses interfere if both access the same memory location and at least one of them is a write to avoid about whether the accesses are concurrent or not we use the term interference in a generic manner both for access pairs occurring in the same thread or occurring concurrently in order to check properties of a bounded c we encode it as a firstorder logic formula in a manner first the program statements in c are encoded in an manner by ignoring the interference between all reads and writes denoted c the readwrite interference in c is then encoded using sequential consistency axioms denoted which corresponds to composing the program threads the property eg existence of an assertion violation data race or atomicity violation is encoded as a formula p rp the combined formula c p rp is then checked for satisfiability using an constraint solver eg an smt solver the formula is satisfiable iff there exists an execution of the program that violates the property encoding we show how to encode all the edges of the c without modeling the interference between the global reads and writes the encoding in this section is similar to our previous works we review the main details here although the form can encode sequential programs cf sec it cannot directly encode a program thread in a concurrent context this is due to possibility of interference on shared variables by concurrent threads ie a read of a shared variable a global read in short must take into account all possible from concurrent writes to ignore modeling such each global read of variable z is assigned a fresh symbolic value rz also called a using these fresh values we can now encode the threads in the using the standard encoding we say that a program edge is global if it accesses a shared variable otherwise it is local both local and global edges in the data flow inside a thread however only global edges in data flow across the threads hence we encode the local and global edges separately this enables us to only consider global edges for encoding the thread interleavings or more precisely the interference between threads our encoding denoted by c consists of a local component l and a global component g c l g we now discuss how l and g are obtained encoding local edges l given the program in the form together with for global reads we can encode each program assignment of form w exp on a local edge as a formula w exp the local encoding l is obtained by the formula obtained from local edges fig left shows the encoding of the running example in fig the local variable a is defined in t and t at t the value of a is either a defined in t or a defined in t depending on the condition a encoding global we first compute the enabling condition for each edge path conditions the path condition for an edge ti in the c is denoted by ti executes iff is satisfiable let and be the unique first and last edge in c respectively starting with true the path conditions are computed iteratively for each ti via traversal as follows we distinguish between nodes having multiple predecessors if the predecessors are in the same thread the node is said to be an join otherwise it is an join · if the source of ti is an join node with incoming edges tj and tk then · if the source of ti is an join node with incoming edges tj and tk then · if ti is a branching statement with condition c and tj precedes ti then c · in all other cases the source of ti has a single incoming edge tj and fig center shows the path conditions in the example global accesses each global edge is encoded using the notion of a global access the global access a for an edge e is a tuple addr v al en where is the memory location accessed v is the value read or written and is the condition under which e is enabled for example edge t cf fig is encoded as an access r y ry gt similarly edge t is encoded as a global access w x a gt the global access a captures all the information about the execution of the corresponding global edge e interference skeleton observe that to model all in the c precisely we not only need the values of global accesses but also their relative order in c let denote the partial order among global accesses induced by the called program order for accesses a and a if a a holds then a must happen before a in all program executions the set of global accesses in c say rw together with their program order denoted we will later see that introducing such is in fact an instance of interference abstraction sec form t x y w w t t t a ry r t t x w t a rx r t x a w t t x w t a a a t t t ry r r path conditions of all edges gt true t b rx r gt gt gt gt t gt gt a t y w t b ry r gt gt gt gt t y b w gt gt t gt gt a t y w gt gt t b b b gt gt gt gt gt gt gt gt gt gt gt gt gt gt gt b gt gt gt gt gt gt gt gt b gt gt gt gt gt interference skeleton w w r r w w r w w r w w r r figure the symbolic encoding of the bounded program in fig the global edges are labeled by the corresponding global accesses eg t by r edges t is labeled by write accesses on x wand y w respectively edge t is labeled similarly rw is called the interference skeleton is of c fig right shows the is as a graph for the running example each node corresponds to an access a addr v al en modeling the location value and the enabling condition respectively and the edges model the program order note that the is models all the global accesses and their mutual ordering precisely to encode the is rw in firstorder logic we introduce a new type called acc and the following operators over the type a predicate hb over pairs of acc elements and operators addr val and en which map an acc element to its location value and enabling condition respectively now is is encoded as g g acc p o where encodes the set of accesses rw acc v and p o encodes p o aj we also refer to p o as program order constraints encoding properties generic programming errors may be modeled as embedded assertions in the the formula p rp then captures the condition under which a given assertion is violated for an assertion in transition t p rp is defined as p rp gt denoting that the condition c must hold if t is executed in our running example in fig fresh variables rx rx rx ry ry ry are added to denote the values of the six global reads and the property is defined as p rp gt ry besides assertion violations we can encode standard concurrency errors such as data races and atomicity violations directly as a set of happensbefore constraints suppose we want to check the atomicity violation involving global accesses c c and r where c and c are in the same thread and are intended to execute atomically r is executed in another thread and with both c and c an example of such violation is given later in fig the property formula is defined as follows p rp enc enc r c axiomatic composition given the skeleton is rw obtained from the encoding of the c we can now encode the ence both and using the axioms for sequential consistency sc over the set of global accesses rw in c intuitively the sc axioms link the read accesses in rw to appropriate write accesses in rw to obtain feasible program executions the basis of axiomatic composition is the link relation definition link relation the predicate w denotes that the read r write w ie the value by the read access r is the same as the value set by the write access w the link relation is exclusive ie w w w w the sc axioms denoted as can be modeled in typed first order logic using operators hb addr val and en and quantified variables r w and w over type acc cf sec the formula where r w w r w w r r w w w w w formula models that if a read r is enabled then r must be linked to some enabled write w and vice versa formula models the data flow and relative order between r and w when r links with w ie both the value and address of r and w must be same and w executes before r formula says that if r links with w then no other write w to the same address as r should be executed between w and r ie w executes either before w or after r fig shows the hierarchical encoding of when checking properties the axioms interact with the property violation condition p rp the condition p rp identifies wellformed paths in the that lead to a property violation and enables the reads and writes along those paths the axioms then make sure that reads and writes along those paths can be appropriately linked to obtain a feasible thread interleaving c p rp l g figure hierarchical encoding of the full instantiation of sc axioms let r and w denote the set of all reads and writes in rw respectively given r and w can be encoded directly by instantiating the quantifiers for all reads in r and writes in w recall from sec that the values of and for each access a are already encoded in g additional constraints are required to encode the of link and that hb is a strict partial order here we exploit the theory of uninterpreted functions rewrite w as where id is an indexing function which maps each access to an unique integer all writes w are initialized with unique values similarly rewrite b as where the function assigns an integer timestamp to each access and the operator encodes the partial order over integer timestamps example the sc constraints for the running example with substituted values for en val addr and hb in and are w w j wj j wj w rx w rx w rx a w let b denote the quantifierfree formula obtained by instantiating for all accesses in r and w note that the number of constraints in the worst case is in the sizes of r and w the following theorem captures the idea that the solutions of b correspond to the feasible executions of the program that violate the checked property theorem suppose we have an encoding c of a bounded c and a property encoding p rp the formula c b p rp is satisfiable iff there exists a feasible execution of c which violates the property for convenience if is satisfiable then we say that a witness exists otherwise we say that a proof exists instead of always referring to for a given and a property we say b is satisfiable has a witness or is unsatisfiable has a proof we now characterize the satisfying models of using the notion of a readwrite match and an interference relation definition readwrite match given set of reads r and writes w a readwrite match match in short is a partial function m r w definition interference relation ir an interference relation is a tuple ri wi m where ri r wi w m is a match and is a partial order over the set r w definition ir satisfying b if b is satisfiable with a model then there exists an unique ir i ri wi m satisfying b defined as follows · ri and wi are respectively the enabled reads and writes in ie r ri and w wi · m ri wi is welldefined for all r ri with codomain wi moreover m r w iff w holds in · a b a b ri wi b holds in intuitively if b is satisfiable then we can extract a match m by recording which of the w predicates hold in the current solution and the partial order induced by the hb predicate note that the of the link constraints ensures that m is a welldefined function for the running example in fig b has a satisfying ir i ri wi m where ri r r r r r r wi m r wr w r w r w r wr w and consists of program order constraints p o in sec together with w r and r w note that w and w are and hence not in wi an execution trace tt t corresponds to i and violates the assertion redundant instantiation of sc axioms as mentioned earlier may give rise to a large number in the of constraints in practice many of these are redundant for example if a read r precedes write w in the program order instantiating for w is and can be avoided redundant constraints also occur in a more manner eg suppose the given property can be violated by executing the program threads sequentially without interleaving them in this case most constraints linking reads in one thread to concurrent writes in another thread are unnecessary for checking the property pruning redundant constraints is the key to making our problem tractable interestingly the syntactic formulation of offers insights on how to redundant constraints let us consider a few pruning methods suppose for example we pick a subset of reads and writes say r r and w w respectively and instantiate only for r and w to obtain say note that is an overapproximation of b because b f where f corresponds to the constraints hence a witness to may not correspond to any feasible program execution however a proof for implies that the property is never violated in p on pruning constraints as above we are able to the interference and hence the program behaviors clearly such an overapproximation is to check if we can discover small r and w sets which are sufficient for proving the absence of violation consider another form of pruning again based on the syntactic structure of the axioms observe that instantiating leads to a disjunction of w formula for each read r r and write w w if w is large we must explore a large number of choices to find an appropriate readwrite match this naturally leads to another approximation pick a subset of writes w w for each read r and instantiate similarly and only for pairs r w where w w by pruning the we obtain an underapproximation of the interference denoted by which is to analyze this underapproximation preserves witnesses ie a witness found using corresponds to a concrete witness in the program p again the of depends on obtaining a small w sufficient for computing a witness each of the approximations above relies on either weakening or strengthening the sc axioms by reads and writes hence we refer to them as interference abstractions ias the above two examples show how the syntactic structure of the sc axioms may be exploited to obtain approximations under or over of thread interference in fact the of quantifiers in allows us to build a complex array of abstractions systematically where the under and of interference are combined we now define interference abstractions obtained in this manner formally interference abstractions to formally represent the interference abstractions we first define the link set for a read definition link set given a set of reads r r let w r w map each read r r to a set of writes which r may link with we say that wr is the link set of r let wc denote the default link set such that contains all possible writes that r may link with statically for example in fig w w w w because r reads variable x let and denote the r w pairs and r w w for which and are instantiated respectively now we can the sc axioms as follows r r w wr r w r w r w r w w r w w where r w r w r w w w w r w w w to model and we introduce functions and as follows r w r w r r w wr r w w r w w r r w wr w w r given r w and w the functions and model the set of r w pairs and r w w triples that and are instantiated for respectively the complete instantiation b of corresponds to r r w wc r wc and r wc wc syntactic ias an interference abstraction ia is characterized by an incomplete instantiation of axioms we say that the ias thus obtained are syntactic because they are obtained by restricting the instantiations of sc axioms syntactically definition syntactic interference abstraction ia given as above and the set of all global reads r an interference abstraction is defined to be a tuple r w such that i r r ii w wc iii r wc and iv r wc wc we say that is a proper ia if at least one of r w or is a proper subset we refer to r w and as components or dimensions of the size of is defined to be the sum of the sizes of components of each ia r w corresponds to an instantiation of denoted by consisting of and intuitively an ia corresponds to first a set of reads r and the set of writes wr that each read r r may link to and then instantiating for each r w in r w and and for subsets of r wc and r wc wc respectively note that replacing read values by during encoding cf sec is the ia where a read does not link with any write ie may assume an arbitrary value an ia is said to be iff b similarly is said to be iff b otherwise we say that is a mixed ia as expected an is useful for obtaining witnesses while an helps obtain proofs we now show how the and as defined above in a semantic manner can be obtained syntactically definition syntactic an ia r w is an iff w wc in other words an is obtained if is instantiated for all writes in the default link set of each read r r however need not be instantiated for all reads and may not be instantiated for all reads and writes the following lemma shows that a syntactic is also a semantic and hence preserves proofs lemma given a syntactic b syntactic are more to define definition syntactic an ia r w is an iff i r r ii r w and iii r w wc intuitively an is obtained if is instantiated for all reads r r but only for a subset w of the default link set of each read moreover must be instantiated for all pairs r w r w and consists of all triples r w w where w is drawn from wr but w ranges over the default set all the above constraints are critical for constructing an which preserves witnesses lemma given a syntactic r w b a subtle difference between an r w and an r w must be noted suppose for some r r r r in in the r r and hence r r however let w r be empty although these two cases appear similar they correspond to different instantiations of for the will not be instantiated for r at all however for the will be instantiated as in other words not including a read r in an allows r to be enabled in any witness of without linking to any write in contrast setting w r in an amounts to r in all witnesses of a full instantiation b of corresponds to both an and an also an ia r w is an mixed ia if is neither an nor an in particular if r r and w wc then is an intuitively in an some reads may not be linked to any writes while other reads may link to a restricted set of writes we next discuss how to the set of syntactic ias syntactic ias as mentioned above an ia corresponds to instantiating only for a subset of all possible reads andor writes note that even though is instantiated for r w and may be instantiated independent of for different subsets of reads and writes from r and w the possible choice of read and write subsets gives rise to a complex space of ias to better this space consider fig which shows the components as four independent dimensions r w and intuitively the w dimension corresponds to an underapproximation while the other dimensions correspond to moving away from the center along any dimension corresponds to reducing the approximation corresponding to that dimension note also that the dimensions are somewhat ie it makes sense to select values for and only after we finish selecting the values for r and w the ia space shown in fig is in fact even more complex eg we may instantiate only the order constraints r in without instantiating the data flow constraints consequently we may obtain even more finegrained corresponding to of the axis in the figure we show later that the space of syntactic ias directly corresponds to a complete lattice we now show that these syntactic ias indeed have a practical ie they correspond to some common semantic notions useful for reasoning about concurrent programs useful semantic interference abstractions many popular techniques for reasoning about concurrent programs incorporate some form of semantic interference abstraction many of these abstractions can be readily modeled by our syntactic ias let us first examine the meaning of instantiating not instantiating for some read r and write w linking r with w in any execution formula corresponds to local consistency not instantiating for some r w implies that r r r r w w r w w r w w figure the space of syntactic interference abstractions thread t t t x t t y t t z t thread t t t a y t t b x t t z t no interleaving can reach t and t simultaneously t t figure a reachability analysis can prove the absence of data race between t and t in any execution r may link with w of their values addresses and execution order the formula corresponds to global consistency not instantiating for some r w w implies that in any execution where r links with w any other w is allowed to in between r and w reachability sometimes we can prove a property using a reachability analysis where the control flow structure and the synchronization operations such as and are modeled precisely whereas the other data flow is ignored this reasoning corresponds to a semantic ia defined as follows partition the set of all reads r on shared variables sv in the program into two disjoint subsets and the subset consists of all the variables modeling the synchronization primitives the subset r consists of the remaining global variables which will be ignored in the ia given a default write map wc for the reads in the program this semantic ia can be obtained syntactically as wc wc wc wc the ia is an by definition w wc and r and hence a proof obtained with still holds when the sc axioms are fully enforced consider fig as an example the two concurrent threads t t communicate through locks a b and shared variables x y z the property of interest is that whether the writes to z at t and t cause a data race we can show that no data race exists by using a reachability analysis based on locks a and b only the rest of the variables x y and z may be ignored because of the following reason transitions t and t cannot be enabled at the same time because thread t must acquire a in order to reach t but if a is held by t then thread t cannot reach t because it cannot acquire a at t we can capture this reasoning precisely by including reads on only a and b variables in in the ia above and therefore can prove the absence of data race with serial or largely serial execution sometimes program bugs are to thread scheduling ie they appear even in executions where the threads execute thread ti t t if x t t y t thread ti t t t t t t t t t t t t i assume a a i assume x assume x i a y i a figure the assertion failure at t caused by double unlock can be detected in a serial execution thread t thread t t p a t if p t p t p t a a feasible interleaving t t t t t figure any serial execution of block t t is or threadlocal bugs fall in this category eg as in fig left where x initially here lock a may be released twice recall cf sec that we encode locks using guarded assignments to shared variables as in fig right additional assertions are added to t for checking errors and to t t for checking errors the assertion at t is violated due to double we can detect this violation by only considering a serial execution of threads ti this form of reasoning can be captured by an r w where r contains reads on x which are only linked with writes inside the same thread or an initial write more precisely the read of x at t links with the initial write x the read of a at t links with the write at either t or t and so on note that restricting the set of writes to link makes wr for r r and hence results in an checking this for satisfiability corresponds to checking only serial executions sometimes all the serial executions are good but an interleaved execution involving only a small amount of interference may lead to a bug fig shows one such bug due to atomicity violation the transitions t t in thread t are intended to be executed atomically however the programmer fails to enforce it if t is interleaved in between t and t a null dereference occurs again an is sufficient to detect such bugs note that if we force each global read to copy from the preceding write we will not be able to detect the bug therefore the should allow the read of p at t to link with t besides t inferring such reduced set of writes w automatically is however the prime challenge exploring the ia space we now focus on finding an efficient exploration strategy over the ia space to discover ias of small size which are precise enough for checking the given property let a denote the set containing all possible ias we define an order relation on a as follows definition order of ias given two ias r w and r w we say that if r r w w and at least one of r w is a proper subset of the corresponding r w for modeling refer to our previous work figure semantic interpretation of ias the denotes the full instantiation of if then we say that refines the poset a is a complete lattice with set union and intersection as the join and meet operators the top element of the lattice r wc r wc r wc wc corresponds to a full instantiation b while the bottom element corresponds to not instantiating at all true exploring the lattice given a property p we say that an is minimal for p if is an which proves p and there exists no such that p since computing a minimal ia is at least as hard as checking the property itself we are only interested in practically efficient algorithms to compute small ias the formulation of syntactic ias suggests two naive strategies to obtain small ias starting with a one may iteratively augment the sets w and until an actual witness is obtained similarly one may start with an and iteratively instantiate constraints until a proof is obtained both these refinement strategies introduce new constraints in a lazy manner semantically this form of refinement corresponds to increasing or interference between threads and checking if a witness or a proof as the increases the two refinement strategies presented above have a number of issues first these strategies are suitable either for finding proofs using or witnesses using but not both second since the two ias are disjoint the strategy does not gain from the strategy and vice versa we of a refinement method where both and could work in and each other a natural way to combine and is via an fig and compares the semantics of and in a manner recall that the full instantiation b models sequential consistency precisely and hence corresponds to all feasible thread interleavings an removes interference constraints from b and therefore leads to more interleavings infeasible ones than allowed by b in contrast an adds interference constraints to b leading to fewer interleavings than allowed by b an contains both an and an and therefore some interleavings from b while allowing some infeasible ones although combine the advantages of both and neither models nor proofs of may provide results because of combined over and underapproximation in an we now examine the sufficient conditions under which a model proof of an may be an actual model proof for b models and proofs of mixed ias given an we define the interference relation ir i satisfying model of the in a manner similar to in the solution of ri and wi are enabled reads and writes respectively m r w iff w holds and consists of r satisfying hb relation each ir i in turn corresponds to an induced ia defined as follows intuitively if an ir i satisfies then the induced ia models the subset of sc constraints relevant to i the hope is that is an in that case i is a true witness thread t thread t r w w l l r w w l l figure example with concurrent definition ia given an interference relation i ri wi m the ia r w induced by i denoted by is defined as follows · i r ri · ii wr m r if m r is defined else wr · iii m · iv r w w r w m w wi w w r however in general i may not correspond to a true witness of b because of approximation in all the constraints relevant to the i may not be enforced by contained in the current on enforcing the missing constraints from the set if i is no longer a witness then we say that i is inconsistent definition inconsistent ir suppose an ir i induces ia we say that i is inconsistent if is unsatisfiable an ir i ri wi m may be inconsistent invalid witness due to multiple reasons for example m may not be defined for some enabled r ri instantiating for such r is unsatisfiable because antecedent is true but the is false we say that i is inconsistent here similarly instantiating for a subset of rw pairs in m may be unsatisfiable in this case we say i is inconsistent we define inconsistent similarly note that in general we may need to instantiate a combination of and constraints for i to detect if i is inconsistent the following lemma is crucial to finding actual witnesses using ias it shows that to find an actual witness ie an ir satisfying b it is sufficient to compute a consistent ir lemma if an ir i is consistent then i satisfies b example consider the example in fig with two threads t and t each containing a pair of statements on the lock l the statements are transformed into guarded statements cf sec and note that each pair is associated with a triple of lock accesses eg r w w for t here the link set of r is wr w w similarly wr w w consider an ir i ri wi m where ri and wi contain all reads and writes respectively m r w r w and contains program order relation ie r w w and r w w clearly match m violates lock semantics more precisely m is inconsistent ie on instantiating for pairs in m the ir i becomes unsatisfiable be cause the transitivity of hb relation is violated consider another ir i with ordering r w w r w w suppose the match m links r with w the ir i is inconsistent if r links with w then the write w should not occur in between and hence i violates dual to the notion of a consistent ir a valid witness is the idea of a valid proof ie a subset of constraints of which does not mention any reads whose link sets are definition valid proof suppose the instantiation for an ia r w is unsatisfiable and p is a proof of we say that p is valid if p contains no r such that wr we say that a read r a proof p if p contains r and wr the following lemma shows that to prove absence of errors it is sufficient to find an ia having a valid proof p lemma let the instantiation of an ia r w have a valid proof p then p is also a proof for b refinement of mixed ias we now present our refinement procedure ref which tries to automatically compute an ia precise enough for either proving the property or finding a witness ref works directly on an mixed ia and iteratively refines the to obtain either a valid proof or a consistent ir cf sec fig provides an overview of our refinement procedure the procedure starts with an initial ia r w by choosing sets r w and then ref checks if with the and property encodings c and p rp respectively cf sec is satisfiable if is satisfiable and the ir i obtained from the solution is consistent the algorithm terminates with a valid witness if i is not consistent then must contain an overapproximation due to either r or cf sec therefore is refined to reduce the overapproximation using procedure otherwise is unsatisfiable if has a valid proof p the algorithm terminates if p is not valid ie it contains an underapproximation due to wr for some r then is refined to reduce the underapproximation using procedure note the advantage of working with an upon termination the final ia may not be an or an obtaining a consistent ir or a valid proof is sufficient to obtain a result we now describe the details of the and steps the code is listed as follows let r w let the inconsistent ir be i ri wi m refine by performing one of the following operations to reduce the overapproximation in · pick r ri r and w set r r r and wr w · set m · set r w w r w m w w r since is unsatisfiable obtain the set of reads r r in the proof of of refine by setting wr for each r r to reduce the underapproximation in in words analyzes the ir i and then chooses to refine by updating one or more of r or or depending on the reason of inconsistency cf sec similarly checks if is unsatisfiable due to underapproximation in wr for some r in that case removes the approximation by setting wr checking if the ir i is inconsistent is done by adding constraints related to i incrementally and checking if the result is satisfiable note that both and checking consistency involve adding constraints to reduce the overapproximation therefore we combine them in practice using a layered instantiation strategy sec besides the choices in as presented above the strategy also avoids adding irrelevant constraints note how ref exploits the uniform representation of ias in form of to check properties using a combination of and also the refinement is both by proofs and witnesses obtained at intermediate iterations initialize ia is c p rp satisfiable reduce overapproximation in sat no ir i reduce underapproximation in proof p no i is consistent is p valid yes witness yes proof figure flow diagram for the refinement procedure ref and hence is the algorithm ref terminates in finite number of steps because the height of the ia lattice is finite and each iteration of ref the lattice by one or more steps the refinement procedure can be implemented efficiently using an incremental smt solver by iteratively adding new constraints moreover using an during refinement enables sharing the learned information between the constituent and inside the thus allowing the and to each other for computing both proofs and witnesses for the example in fig we initialize r w as follows r includes all reads r r r r r r w is initialized so that the link set of each read contains no concurrent writes wr w wr w w wr w w and so on suppose we instantiate r w ie for all writes in the link set of each read let the ia is an because eg wr underapproximation and overapproximation on checking with c and p rp the result is unsatisfiable because r links with w and r links w hence the then branch in t executes while the else branch in t executes therefore r gets value and r gets value so that the assertion is never violated the proof of r and r suppose the procedure then expands w for r to w w w w and is updated with the corresponding pairs in the next iteration suppose we obtain an ir i which links r with w but i has w w r in i here i is not consistent because it violates therefore ref updates r w w using which finally results in a consistent ir with w r w note how a combination of over and underapproximation was exploited by ref to arrive at a consistent ir further even though we check bounded programs where paths in each thread or number of threads have been interference is orthogonal and does not work against the previous underapproximation in fact it may in finding the bug quickly in many cases cf above example or obtaining a proof early by avoiding redundant constraints focused refinement the procedure ref proceeds iteratively by the lattice of ias based on the current satisfying solution or an proof since the size of the lattice is exponential in the number of reads and writes the basic refinement strategy may not converge quickly to a desirable small ia on its own in particular it may add redundant constraints by the model from the solver thus making the intermediate ia larger and the subsequent iterations more expensive we propose a set of heuristics to focus the refinement on relevant constraints static focusing we first describe heuristics to guide ref by removing redundant constraints or adding useful lemmas statically s interference pruning for each read r compute a small not containing any writes that r may never link with for example a r cannot link with w if w holds statically or if r and there exist writes w along each path from w to r such writes may be detected by performing a static analysis on the interference skeleton is cf sec s initialization to obtain ias with concurrent interference we initialize wr for each r with only writes in the same thread or initial writes this ensures that if a serial or largely serial execution cf sec violates the property then few refinement iterations will be sufficient we also the initial ia to reads and writes on synchronization variables only this forces ref to start with only those ias where the above interference conditions must hold s lock lemmas a number of optimizations are possible for locks sa consider the program shown in fig again the read in the initial assume statement r may link with either w or w however note that if w holds then making the guard l as f which in turn blocks the execution of t therefore we reduce the link set by removing w from it sb let l denote the set of matching statements in the whole program and the accesses to the lock variable for each li l be ri wi wi for each l l l either the statement block denoted by l executes before the block denoted by l or this fact can be captured by the constraints ij rj ri which are quadratic in the size of l better than the original size s although instantiating for all pairs of r wc is expensive instantiating only a portion of for cost both in terms of constraints size and solving times we can therefore instantiate only a portion of eg w r for all r w this is especially useful if the ordering constraints are sufficient for checking the property formally this form of instantiation corresponds to further partitioning the components of an and instantiating some of those partitions layered instantiation note that in updating adds far more quadratic in number of reads and writes constraints than updating linear in size of reads r we therefore perform a layered refinement towards the goal of adding fewer redundant constraints given an ir i r w m satisfying we first check if i is consistent cf sec if i is not consistent we update and continue to the next iteration only when we find a consistent ir we check if i is consistent in this way we the refinement towards similarly we update the set r only when the current match m is both and consistent experiments we implemented the algorithm ref and evaluated it on concurrent benchmarks in the fusion framework although our method can be applied to arbitrary bounded concurrent programs in these experiments we focus on analyzing concurrent pro gram slices obtained by runtime analysis of the fusion tool our benchmarks consist of java program slices obtained from the various available programs ­ we check for errors such as assertion violations and data races many of these program slices are difficult to analyze because they contain multiple threads with and joins each having a large number of global accesses together with assume statements containing guards for branches taken during runtime our goal was to investigate if the subset of available benchmarks could be checked using small ias we initialize the refinement scheme with an ia containing all reads in the and the link set of each read with only writes which are with the read lock lemmas were also added to improve refinement we observed that lemma sa had a much larger impact than lemma sb although sb also reduce in a few cases further we used refinement strategy for reducing overapproximation we focus on showing the effectiveness of ias and that can perform better than or all experiments were on intel machine with gb memory fig compares the full instantiation with the refinement ref procedure on a set of properties of the hard benchmarks in this table columns show the name of each test case the number of threads and whether there is a bug t or a proof f columns show the number of reads the number of writes and the average size of the link sets the remaining columns compare the and the ia sizes obtained with and without interference abstraction the ias computed by ref are smaller than full instantiation both for satisfiable and unsatisfiable benchmarks this the that only a small amount of interference need be considered for checking many properties moreover small ias lead to much than with the full instantiation we observed that for obtaining proofs ref needed to instantiate only a few times for each rw pair in the initial ia finding witnesses is more challenging than finding proofs ref goes through a number of iterations for reducing both the overapproximation present in the initial ia fig shows the advantage of using combined in ref vs using only or only these are where the is the runtime with only or only and the is the runtime with the data points correspond to checking several data race properties in benchmark we observe that clearly that ias are essential for efficiency in contrast may not be always better than only however the overapproximation in improves the performance in most cases the procedure ref for finding small ias may be viewed as an automated quantifier instantiation technique specific to the domain of sc axioms where the variables are quantified over finite domains although a number of smt solvers support quantified formula and include generic heuristics we found that such approach did not perform well even on small benchmarks we used with default settings we believe it is due to the following reasons first the solver must be provided with large number at least quadratic in the number of reads and writes of noninterference constraints derived from static pruning cf sec without which these benchmarks become secondly generic heuristics often lead to eager redundant instantiation which performance most importantly it is difficult for generic heuristics to infer a initialization of the the initialization exploits knowledge about the typical behaviors of concurrent programs which is to the solver we are aware that a number of improved heuristics have been implemented in z we believe that these recent improvements are complementary and if exploited correctly could ref in faster note that an smt solver also uses a combination of under and internally during bm n sat r w w f t f t f t f t f t f t f t full instantiation ts ia size k k k k k k k k k k m hr hr hr k k m k k m k k m k k m k k m k k k k k k k k m hr k k m with ias ref t s ia size k k k figure terminates experimental results in form abc where r wp a r number of wr b reads writes ia and c size denotes the size of the ia r w nk and nm are shorthand for n and n when the check respectively figure using vs only or only on benchmark constraint solving which is unfortunately in handling the full instantiation directly in other words the solver is unable to focus on the concurrent facts relevant to the property by itself the presented refinement scheme in contrast has the knowledge eg to compute an initial ia and is able to the solver towards the relevant facts related work automated reasoning about concurrent programs with shared memory has been traditionally done by systematically restricting the thread scheduler based on traces with dependency relation m traces in particular the work in uses iterative of scheduler to find bugs based on proofs from a sat solver automated compositional methods have also employed abstractions of both transition relations and state spaces of individual threads ias in contrast build upon the axioms of memory consistency instead of cf note that the notion of ias is orthogonal to abstractions of transition relations ias abstract only the between reads and writes without modifying the transition relations of individual threads the notion of field abstraction introduced in for removing reads and writes to selected structure fields may be viewed as a form of however field refinement links each field read with all possible writes thus its scalability as our experiments show the combination of with is important iterative methods for sequential software using predicate abstraction have been investigated widely mixed abstractions of transition systems containing both may and must transitions to preserve universal and existential properties respectively have also been studied and applied to sequential software cf for a nice overview recent work has also combined may and of procedures to obtain a more scalable analysis of sequential software decision procedures for also employ mixed abstractions of formula automatic quantifier instantiation inside smt solvers is an active research topic the most strategy introduced in simplify to enable qi subterms of quantified assertions are matched unified with the ground terms in the partial model of the solver however such heuristics are in general incomplete and often cause a large number of redundant instantiations leino et al proposed to handle quantified assertions via a separate module similar to a theory module in an smt solver however lack of tight integration between the quantifier module and the main solver leads to duplicate theory reasoning as well as learning conclusions we presented a new form of concurrency abstraction for shared memory programs called interference abstractions ias based on the axioms of sequential consistency the framework of ias provides an automated and flexible mechanism for interference an iterative algorithm to synthesize ias for checking concurrent properties was presented and shown to yield small ias for practical benchmarks ias may be extended in multiple ways eg we can cluster multiple reads andor writes into a single access and reason about these access sets simultaneously these extensions in contrast to pure ias may also violate the program order extending the notion of ias to relaxed memory models is also an interesting direction we also plan to compare with automated quantifier instantiation inside constraint solvers handle unbounded programs and investigate relyguarantee reasoning using interference abstractions acknowledgments we thank the anonymous reviewers for their careful reading and valuable suggestions we are also to ge and for useful discussions references aw trace theory in advances in petri nets ­ p partialorder methods for the verification of concurrent systems an approach to the problem springerverlag new york inc nj usa d partial order reduction modelchecking using in ­ o f o m for systems in popl ­ m qadeer s ball t g pa i finding and in concurrent programs in ­ v wang c gupta a monotonic partial order reduction an optimal symbolic partial order reduction technique in cav ­ qadeer s j model checking of concurrent software in tacas ­ m qadeer s iterative context bounding for systematic testing of multithreaded programs in pldi ­ a t n reps tw interprocedural analysis of concurrent programs under a context bound in tacas ­ sv k shared memory consistency models a ieee computer ­ s r martin checking consistency of concurrent data types on relaxed memory models in pldi ­ e m j checking axiomatic specifications of memory models in pldi ­ n wang c staged concurrent program analysis lamport l how to make a multiprocessor computer that correctly executes programs ieee trans computers ­ lu s park s e y learning from a study on real world concurrency bug characteristics comput ­ rp verification of processes the approach princeton university press clarke em o s lu y h counterexampleguided abstraction refinement for symbolic model checking journal of the acm jacm ­ ball t majumdar r td rajamani sk automatic predicate abstraction of c programs in pldi volume acm press june ­ henzinger ta jhala r majumdar r kl abstractions from proofs in popl ­ wang c s gupta a yang y symbolic pruning of concurrent program executions in ­ wang c s mk gupta a symbolic predictive analysis for concurrent programs in fm ­ wang c r m gupta a symbolic analysis for atomicity violations in tacas springer ­ v wang c universal causality graphs a precise happensbefore model for detecting bugs in concurrent programs in cav springer ­ clarke e d f a tool for checking programs in k podelski a eds tacas volume of lncs springer ­ f yang z mk gupta a i p software verification platform in cav ­ sk qadeer s z static and precise detection of concurrency errors in systems code using smt solvers in cav ­ ra ab kj the program dependence web a representation supporting control data and demanddriven interpretation of imperative languages in pldi ­ b de l a fast solver for in cav ­ de l n z an efficient smt solver in tacas ­ lu s j f y detecting atomicity violations via access interleaving invariants in ­ a p f for atomicity violations under nested locking in cav ­ yang y g g k a framework for axiomatic and executable specifications of memory consistency models in the java benchmark suite k t model checking java programs using java international journal on software tools for technology transfer von c tr static detection of atomicity violations in objectoriented programs object technology de lm n efficient for smt solvers in ­ flanagan c p dynamic partialorder reduction for model checking software in popl ­ clarke e o d model checking mit press flanagan c qadeer s model checking in ­ henzinger ta jhala r majumdar r qadeer s abstraction refinement in cav volume springerverlag ­ a ks local proofs for global safety properties formal methods in system design ­ tf chen f g maximal models for sequentially consistent multithreaded systems technical report university of illinois o a m mixed transition systems in ­ p av rajamani sk s compositional program analysis the power of alternation in popl ­ re d j sa o ba an decision procedure for arithmetic ­ d nelson g simplify a theorem prover for program checking j acm ­ leino m x a technique for supporting quantifiers in a theorem prover in tacas ­ 