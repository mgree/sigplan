towards nominal computation university of abstract nominal sets are a different kind of set theory with a more relaxed notion of they offer an elegant formalism for describing terms modulo conversion or automata on data words this paper is an attempt at defining computation in nominal sets we present a programming language called n the key idea is that it includes a native type for finite sets in the nominal sense to illustrate the power of our language we write short programs that process automata on data words categories and subject descriptors d programming languages language constructs and features f logic and meanings of programs semantics of programming languages general terms theory keywords calculus nominal sets automata on data words introduction the theory of nominal sets from the work of in further developed by in the s at that time nominal sets were used to prove independence of the axiom of choice and other axioms in computer science they have been by and pitts in as an elegant formalism for modeling name binding since then nominal sets have become a topic in semantics they were also independently by the concurrency community as a basis for models of process calculi see and used in automata theory as a framework for describing automata on data words see from the point of view of this paper the most feature of nominal sets is that their natural notion of called is more relaxed than in classical set theory for instance in one variant of nominal sets the notion of variant is formalized partially supported by starting grant partially supported by the games for design and verification exchange grant nr and by the grant number partially supported by the of science grant nr n n permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission andor a fee popl january ­ pa usa copyright c acm later in the paper as a data symmetry the set of rational numbers is orbitfinite using one can define more powerful variants of automata or other computing devices as an example take the standard definition of a nondeterministic finite automaton it consists of finite sets q and a for the states and alphabet as well as three relations q × a × q and i f q suppose that we read this definition using orbitfinite sets instead as proved in the resulting objects have the same expressive power as wellknown automata for data words namely finite memory automata of and the same idea can be applied to other computation models such as monoids deterministic automata automata pebble automata or pushdown automata each time the nominal model corresponds to a natural device for data words the examples above concerned restricted machine models with the most expressive being pushdown automata in this paper we are interested in general nominal computation and we attempt to understand it by defining a basic programming language called n designed so that it can directly process orbitfinite nominal sets the key idea is that it includes a native type fn which represents orbitfinite sets of elements of type structure of the paper the paper has three parts in part i we discuss our design objectives and related work and show some example problems that our language can help solve in part ii we define the syntax and operational semantics of n the language is parametrized by a data symmetry subject to some conditions we also show how to represent programs of n so that they can be interpreted on a normal machine finally in part iii we present a substantial case study the emptiness problem for alternating automata on data words we are to andrew pitts and the anonymous whose constructive comments lead to a great improvement of the presentation of this paper part i motivation design objective for n avoid coding suppose informally that we want to design an algorithm that processes possibly infinite but orbitfinite data structures as a typical example let i be the set of nondeterministic finite automata in the nominal sense in such an automaton all components states alphabet transitions initial and final states are orbitfinite but perhaps infinite in the classical sense then consider the function f i that checks if an automaton accepts some word one way to compute such a function is to encode orbitfinite sets as finite data structures and implicitly bit strings in one can essentially find such representations applying such a coding to the problem domain one can reduce a nominal computational problem to a classical one the resulting notion of depends on the coding scheme but the schemes implicit in the literature are essentially the same and the small differences can be by turing machines this approach has been implicitly used in the literature when giving decidability results for decision problems in nominal sets one example is an algorithm for deciding bisimulation equivalence of orbitfinite transitions systems some algorithms for problems from automata theory can be found in including the above example of nondeterministic automata another example is the algorithm from for deciding if the language recognized by a given data monoid is firstorder definable an advantage of this approach is that it does not introduce any new concepts it just treats nominal sets as syntactic sugar for normal sets in particular there is no new nominal thesis the very same thing can be seen as a it is a way of doing computation and it the purpose of using nominal sets as an syntax n is a functional programming language that abstracts away from the details the design goal for n can be up in two words avoid coding the abstract semantics of the language is defined in terms of nominal sets and does not refer to any coding scheme in particular this means that correctness proofs for programs in n are simpler and more the language comes with a more concrete semantics which implements a coding therefore any function expressed in n is effectively computable however the coding has to be done only once as it is done in this paper once it has been implemented and proved correct the programmer can simply use the language without about how nominal objects are represented related work a closely related language is fresh ocaml a functional programming language based on nominal sets at defining and manipulating data structures with binding such as terms up to conversion it is similar to n in that both can be seen as typed calculi with some additional type and term constructors however these extensions are substantially different a crucial of fresh ocaml is a binary type constructor whose values intuitively are values of type with values of type typically basic data values called names in this context abstracted or bound these abstraction types together with a few other primitives allow a particularly elegant treatment of conversion and substitution in data structures n does not have abstraction types instead it has a type constructor fn to represent finitary collections in section we show that n also offers a way to treat binding in data structures in a slightly less direct and way than fresh ocaml however binding in data structures is just one of the many things that we can do using our language also our language works not just in standard nominal sets but also in the more general setting of nominal sets another difference with fresh ocaml is that the latter is a fully programming language with a working compiler and extensive documentation on the other hand n is a core language and a work in progress we have tried to keep the primitives as simple as possible while still covering a wide range of examples we make no claim on of the language and it is likely to however it seems that our current version of n is a rather expressive formalism in section we survey some functions that can be expressed in it first however we formally define nominal sets and related notions nominal sets we now recall the of nominal sets as studied by and pitts then in section we generalize the definitions along the lines of data values fix a infinite set d of data values in the examples below we assume d n and write for elements of d however no structure of the data values is used except for equality a permutation of d is any bijection d d the group of all permutations will be denoted by g nominal sets a right action of g on a set x is a function · x × g x subject to the following associativity axioms we use infix notation writing x · instead of x · x · · x · x where refers to multiplication in g and is the unit of g which is the identity function on d every subset of data values c d defines a of g gc g c a nominal set is a set x equipped with a right action of g such that for every x x there is a finite set c d such that x x · for every gc the set c is then called a support of x in words every element of a nominal set has a finite support for example consider the set d of infinite words over the alphabet of data values under the action d d · d d every word w is supported by the set c of all letters that appear in w the set d is not nominal but the subset of words that contain only finitely many different data values is also the smaller set d of finite words is nominal orbitfinite sets the of an element x is the set x · g def x · g a nominal set is called orbitfinite if it is a finite union of ie it has a decomposition x n i xi · g for some x xn x for example the set d is orbitfinite with one the set d has two namely the diagonal d d d d and the rest nominal subsets a subset y of a nominal set x is called a nominal subset of x if it has a finite support as an element of the powerset of x formally a finite set c d is a support of y if y y · def y · y y for every gc for example nominal subsets of d are its finite or subsets example for a fixed d d the set d e e d is a nominal subset of d finitary subsets a nominal subset y of x is called finitary if it finitely many of x in particular if x is orbitfinite for instance d or d then all its nominal subsets are finitary as another example the set of words of length at most where the data value appears at least twice is a finitary subset of d finitary subsets are the foundation of our programming language we write for the family of finitary subsets of a nominal set x in a n is simply typed calculus with a type constructor for finitary subsets we will add structure to data values in section generalized nominal sets the example of our paper is an algorithm for deciding emptiness of alternating automata in the nominal world in its full generality this example may exploit some nontrivial structure eg an order relation on the set d this us to work in the framework of generalized nominal sets introduced in the idea there was to add more structure to the data values d such as a total or partial order for automata this corresponds to more expressive tests on input letters to define generalized nominal sets one begins with a data symmetry called nominal signature in ie a set d of data values together with a group g of permutations of d it is important that g need not contain all permutations some examples of data include · the classical symmetry where d is empty and g contains only the empty bijection this symmetry yields classical sets · the equality symmetry where d is a infinite set and g contains all this symmetry yields nominal sets as studied by and pitts · the total order symmetry where d is the set of rational numbers and g contains all of rational numbers later on we will define further data importantly all examples in this paper are socalled this notion follows and will be explained in section given a data symmetry d g one defines d sets exactly as in section except with the group g and the data values d substituted in place of the equality symmetry similarly one defines the related notions like nominal and finitary subsets from now on the notion of a nominal set will always be parametrized by a data symmetry example subsets of d we now show examples of finitary subsets in the total order symmetry all examples given here will be subsets of d which is shown in the following picture with the first coordinate on the axis and the second coordinate on the vertical axis the picture also shows the three of d under the action of g above the diagonal the diagonal and below the diagonal because d is orbitfinite any nominal subset will be finitary consider a support c under the action of gc the set d breaks up into a subset x d has support c if and only if it is a union of some of these the partition of d into under gc and a subset x are illustrated below x the reader might recognize some similarity to the region construction from automata consider now a support than c say d the partition of d into under gd is more refined there are one as gd is a of gc in particular there are more subsets with support d the partition and an example subset y are illustrated below y the reader can easily see that as the support grows so does the number of subsets with the support also observe that it does not make sense to count the number of elements in a finitary set because the number of elements depends on the choice of support even if we choose the least support when counting the number of elements there is still some room for confusion observe that the example set y has least support d but it can be decomposed into one under gc and one under gd n as an algorithmic equipped with the basic notions of nominal sets we discuss some functions that can be in n in all examples except section we work with the equality symmetry only transitive closure of a binary relation consider the following binary relation on d r d d d the set r has support the set d has two namely the diagonal and the rest it follows that r like any nominal subset of d is a finitary subset of d and therefore can be input and processed by programs of n a typical thing one might want to do with a binary relation is compute its transitive closure in this particular example the transitive closure is r c d c d note that r is a finitary subset of d one can prove that this holds whenever r is finitary also we may write a recursive program in n that inputs a finitary binary relation r over some type and outputs its transitive closure in our example the type is d but the program works also for types that are not orbitfinite such as lists of d the only condition is that is an equality type an equality predicate eq data monoids a data monoid as defined in is a monoid where the carrier is a nominal set and the monoid operation is the main result of was a theorem that related firstorder logic with data monoids however in the paper was it said how one can represent a data monoid in a computer or test if it is n can help with this for example consider the data monoid m where the carrier is d the identity is and the monoid operation is defined by d e · d e d e for all m m and for all d e d e d this is the syntactic monoid of the language d · · · dn d d dn the carrier of this monoid can be seen as the finitary subset of d list that contains lists of sizes zero or two this set can be represented in n by a short piece of code the identity of the monoid m is the empty list while the monoid operation can be easily implemented using pattern matching as a function f d list × d list d list as far as the example monoid is concerned it is not important what f does for lists of lengths other than zero or two using n we can test some properties of monoids represented in this fashion for instance we can write a polymorphic function that inputs a finitary set m of values of type and a binary operation f on and checks whether f is idempotent when restricted to m in our example d list in the same spirit we can write functions that test if a data monoid is commutative etc alternating automata with one register in the literature on data words there are many automata models often of incomparable expressive power one of the expressive automaton models that still has decidable emptiness is an alternating automaton with one register roughly speaking this is an alternating automaton which can store a single data value in a register emptiness is decidable for this automaton model with a proof based on well in part iii of this paper we encode the emptiness test for alternating automata with one register into n to do this we provide an abstract definition of alternating automata with one register a definition that only uses the concepts of nominal sets then we write a program in n which tests a given automaton for emptiness an important advantage of our abstract definition of automata is that it is meaningful for any data symmetry if the definition is interpreted in the equality symmetry the usual symmetry for nominal sets the resulting model is equivalent to the automata from however the definition can also be interpreted in the classical symmetry in which case we get standard alternating automata without data values finally the definition can also be interpreted in the total order symmetry in which case we get alternating automata on ordered data values a model that has been studied in and closely related to automata in all these cases equality classical total order the same program in n emptiness for alternating automata with one register the program only needs to be into different interpreters each symmetry defines a different interpreter the proof that the program terminates depends on the chosen data symmetry we give an example where the termination proof fails and indeed the emptiness problem is undecidable terms of calculus modulo conversion nominal sets were originally motivated as an elegant algebraic approach to name binding in syntax and in particular as a way to represent terms up to conversion in a way that admits natural inductive reasoning using the socalled abstraction types that have equivalence classes of terms as values this idea has been implemented in the nominal programming language fresh ocaml although n does not have abstraction types one may represent in it equivalence classes of terms directly as finitary sets of terms such a representation is less than the one used in fresh ocaml as it contains many values that do not correspond to equivalence classes however it still lets us write functions that manipulate terms such as substitution we can also write a n program that tests whether a set of terms is an equivalence class we elaborate a little on this example in section part ii n in this part of the paper we introduce n a language for programming in nominal sets over an arbitrary data symmetry of a certain form the essential idea is to extend simply typed calculus with a collection type that represents finitary sets of values we present n in three stages first in section we present a version for the classical symmetry where no data values or group actions are involved this is to the reader to our syntax in a familiar setting notably to store intermediate values during a computation according to our operational semantics we introduce a syntactic construct that collects a finite set of terms in a practical implementation these sets would be represented as lists of terms then after some semantic considerations in sections we generalize the language to arbitrary data in sections the main conceptual difference apart from a few new primitives is that now finitary but potentially infinite families of terms are considered in intermediate values this may be seen as problematic and indeed one may if our semantics is really operational given that it directly infinite structures therefore in section we replace infinite collections of terms with a finitary syntactic construct in a step analogous to replacing finite sets of terms with lists the result is an entirely finitely language with a clearly computable reduction semantics amenable to direct implementation the semantics of sections and are equivalent formally bisimilar the latter may be seen as a reference definition for implementation purposes the former is more abstract better suited for reasoning and more closely related to the simple language of section a simply typed calculus with finite subsets in this section we show how n works in the classical symmetry where nominal sets are simply sets and where orbitfinite sets are simply finite sets the core language is presented in fig the types are as in a simply typed calculus where b comes from some set of base types extended with a type constructor f to represent finite collections the idea is that represents a singleton set and f represents finite sets of elements from in terms c comes from some set of term constants with fixed types in particular we assume polymorphic families of special constants note that f takes the role of a boolean type the typing rules of basic terms are standard and omitted from fig to simplify the operational semantics we extend the language with an additional construct setx of a more semantic with an intuitive typing rule with these as intermediate values the reduction relation on closed terms is defined as expected we do not commit to any particular evaluation strategy reduction of arbitrary subterms we from showing a formal denotational semantics for the language but our intention should be clear types are interpreted as sets with as a singleton type as function space and f as the finite powerset monad with the obvious interpretation of constants from fig we may now define other typical constants operations such as the haskell bind written infix as usual f f f a f f a singleton and set union just f just a add a union f f f union a b a add b types b f basic terms m c x xm m m intermediate terms x ranges over finite sets of terms m · · · setx m for all m x setx f special constants f add f f map f f sum ff f if f redexes xm n m nx set add setx m setx m map m setx n n x sum i i set ii xi if setx m n m if x if set m n n set reduction m x m n setx setx m n figure n without data writing bool instead of f we define boolean constants and operations true bool false bool or bool bool bool not bool bool true just false or union not a if a false true quantifiers and predicate exists forall f bool bool filter f bool f exists forall x f x x filter x f x f x if a type comes equipped with an equality predicate eq bool we may lift it to an equality predicate for f by defining membership and subset predicates member f bool subset f f bool member x x exists x eq x subset x y forall x member y finally equality is defined as subset in both directions this core language can be extended with further standard features eg product types · · · × m · · · m m m m m n m m n n then one can write programs such as binary relation composition comp using an auxiliary function comp comp × × f × comp f × f × f × comp p q if comp r s r ps comp p where is assumed to be an equality type similarly we could add recursive types such as lists that we used in section etc note that in a typical programming language finite collections are modeled by lists in presence of recursive types one could view the constants and add as constructors and define other operations by pattern matching and recursion with this in mind our set construct might look like an unnecessary however in the world of nominal sets the simple list representation fails and finding a good representation of finitary subsets of nominal sets is one of the technical challenges we shall face our semantic term construct set is introduced in of a world where it is easier to say what a finitary collection is than how to write it down nominal types semantic considerations we now wish to extend the calculus of section to deal with nominal sets for a data symmetry d g the general idea is clear given d g we interpret types as nominal sets function type categories of nominal sets are cartesian closed and it is natural to interpret function types as nominal function spaces there for nominal sets x and y the action of g on a function f x y is defined by f · x f x · · the nominal function space x fs y is the set of functions from x to y equipped with the action above restricted to those functions that have finite support we call such functions nominal note that not all nominal functions are in fact a function is if and only if it has empty support write f x fs y to say that f x y is nominal example consider the equality symmetry a function f d d is nominal if and only if there is a set z d such that f z is either the identity or a constant function collection type it remains to interpret the collection type constructor in the nominal world this will be of use already in the definition of syntax we intend to view finitary nominal collections of terms as terms so we need to define what they are the powerset of a nominal set x is easy to define px x fs where is a set with a trivial equivalently px is the set of subsets y x with an action defined by y · y · y y restricted to those subsets that have finite support these are the nominal subsets as defined in section example the powerset of an orbitfinite set need not be orbitfinite for instance for every data symmetry d g the powerset of d contains all finite subsets of d because every finite subset has a finite support itself two finite subsets of d cannot be in the same if they have different therefore there are infinitely many in pd if d is infinite observe that a nominal subset y of a nominal set x is not a d set in general as y need not be preserved by all permutations from g however if c d supports y then y is a d gc nominal set we now introduce our intended nominal interpretation of the collection type the finitary powerset recall from section that a nominal subset y px is called finitary if y finitely many of x if c supports y then y is finitary if and only if y is orbitfinite as a d gc nominal set by we denote the set of all finitary subsets of x if x is orbitfinite then all nominal subsets are finitary ie px it follows that need not be orbitfinite even if x is actually the only case when is orbitfinite is when x is finite note that our is not the free semilattice over x the latter contains only finite subsets of x although we do not yet have a clear categorical understanding of we choose it for pragmatic reasons it is a rich collection of subsets of x that we are able to represent in a finite way see section from now on we restrict attention to a special case of data called defined in and called signature there a symmetry is induced by a class k of finite relational structures which needs to be closed under isomorphism and given such a class the construction from uses the limit to produce a data symmetry d g which is well all three examples listed in section are · the classical symmetry arises from the empty class k · the equality symmetry arises from the class k of finite sets ie finite structures over the empty vocabulary · the total order symmetry arises from the class k of all finite total orders over a vocabulary with a binary relation other examples include the class k of finite partial orders or finite graphs we will see other in section from now on we consider a fixed data symmetry d g and assume that it satisfies the following conditions · symmetry the symmetry is induced by a class k · least supports any element x of a nominal set has the least support with respect to inclusion which we will denote under these assumptions the following basic results hold that will be extensively used in the following lemma d is orbitfinite under the action of g lemma orbitfinite sets are closed under cartesian products lemma refinement let x x for some nominal set x for any finite sets c d of data values there exists a finite subset z zn x such that x · gc n i zi · gd a calculus with finitary nominal subsets an extension of the language of section to nominal sets over a symmetry d g is summarized in fig we write for the least support of x types b d f fn basic terms as in fig intermediate terms as in fig but x ranges over finitary sets in setx fn special constants to fig add d d for each d d d d bool redexes to fig add hull fd fn fn d d set d e set hull setx set xx x · gc if d e c fin d set reduction m x m n c setx setx m · gc n · gc figure n with data abstract terms first a new type d of data values is introduced together with a constant for each data value and an equality predicate on d second instead of one type constructor f we now have two written f and fn the type f represents all finite subsets of as in section while fn represents all finitary nominal subsets of both type constructors are equipped with constants listed in fig and further operations for fn such as forall etc are defined as in section for f the name between constants should not lead to confusion and will always be resolved by context in particular the are two constructs setx f and setx fn where in the latter case x ranges over finitary and not finite sets of terms we explain below how to regard the set of all terms as a nominal set to avoid confusion the latter set construct we call nominal finally the new constant hull can be used to construct finitary nominal sets just as add could be used to construct finite sets in section it inputs a finite set c of data values and a finitary set x and x under the action of gc for instance in the equality symmetry the following piece of code hull represents the whole set d and the following two calls hull hull create the two of d the relation r from section can be generated by r hull we use some syntactic sugar here for example would have to be written as add add in our core language terms of n remain as in fig but in the nominal setx construct x ranges over finitary rather than finite sets of terms here we must proceed with care to avoid a circular definition where the existence of a term setx depends on all terms understood as a nominal set formally this can be done by introducing an explicit rank to terms where the rank of a term is the maximal degree of nesting of set in it then the group action of g on terms of rank n is defined by induction and every term of rank n has a finite support in other words the set of terms of each rank n is a nominal set and we may of its finitary subsets used in the set construct example in the total order symmetry we have a term that represents the set of all data values than d this term has rank and type we also have a term that represents a set of constant functions d we could also write a term for the union of the two sets above but this would not have a cannot however write a term for all data values that are integers as z is not a nominal subset of d i z is not a valid term the reduction relation is defined as in section with new redexes for and hull note that for the reduction of hull to happen c must be fully evaluated to a finite set of data value constants finally the set reduction rule given in fig is for the nominal setx construct as x may have infinitely many elements causing potentially infinite reductions we fix this problem by that all elements of x that are in the same of gc where c is the least support of x reduce in parallel and in a uniform way in other words the last rule in fig is replaced with the last rule of fig our semantics satisfies the basic properties expected from a typed calculus proposition the reduction is welldefined ie if m n then n is a valid term in addition types are preserved and so are supports if c supports m then it also supports n proof for the first part we must check that the n only contains finitary sets of terms under the set construct the proof goes by induction on the structure of terms in some cases we make use of the fact that in cartesian products of orbitfinite sets are orbitfinite proofs of other desirable properties are routine using standard methods proposition the reduction relation has the churchrosser property and is weakly recursion and examples the treatment of recursion is standard we extend the language with a new constant fix for any type with the type fix and the reduction rule fix m m fix m using this we may define recursive functions via the following syntactic sugar f x m def fix where f may appear in m as usual with recursion one can write nonterminating pro grams so weak fails however the churchrosser property holds and types and supports are still preserved by we now show some simple examples of recursive programs example recall section and the problem of computing the transitive closure of a finitary relation w may write a function trans fn × fn × that inputs a finitary binary relation over some equality type and outputs its transitive closure step fn × fn × step r union r comp r r trans r if r r r r where union and comp calculate the union and composition of given relations as defined in section example recall section and the problem of checking properties of monoids of data monoids can be represented in n as finitary subsets of some equality type with the monoid structure given by an element of the unit and a function of the type × the multiplication assuming the presence of list types the carrier of the monoid of section can be represented by taking d list and again with some syntactic sugar m hull and the monoid operation f d list × d list d list is easily defined by pattern matching suppose that we want to know if a monoid is idempotent this can be accomplished by a polymorphic function idempotent fn × bool which inputs a set of arguments and a binary operation on any equality type the code of the function is idempotent m f forall m f x x x if we execute the idempotent function on our example monoid the expression idempotent m f will evaluate to true in finite time the above two examples do not involve data values directly and the polymorphic programs trans and idempotent could be just as well interpreted in the simple language of section the next example uses data explicitly example one could why there is no primitive in the language that returns a support of a given argument somewhat surprisingly with primitives listed so far we can define a function that computes the least support for equality types the function will simply enumerate all candidates infinitely many of them we however that this search can be implemented by a finite computation as we explain in section we start by writing a function supports fd bool that checks if an element x of an equality type is supported by a finite set of data values c it returns true if the of x with respect to gc is a singleton supports x c singleton hull c just x singleton x exists x x eq x having the function supports we define search the result type of is and not just fd but the function will always return just a single support it is implemented by an exhaustive search x search x x search x just if exists x supports x filter x supports x search x x the search starts with the family x containing just one set of data values the empty one if this set is not a support in the first recursive call the family x contains all in general at recursive depth n x contains all nonempty subsets of data of cardinality at most n an auxiliary function increases this cardinality bound by one x x x d observe that the search terminates as every element of type has a finite support and always computes the least support with respect to inclusion finally note that we allow ourselves to use the set of data values d as an object of type since d can be easily represented as discussed in section term representation the language defined so far is a bit abstract in that is uses a semantic construct set in its terms for practical use we need to represent the terms in a finite way so that they can be input by users and manipulated by algorithms for example by an interpreter that chooses a specific evaluation strategy such a representation is possible under the assumption that we work in a symmetry the of our approach is lemma from section which provides a finite representation of finitary subsets lemma for every finitary subset y of x there are elements y yk and a finite set d d such that y k i yi · gd proof take as d any support of y and as x xk any of those of x that are by y apply lemma to each xi with c take the union of the results and choose as yi those zs that are elements of y note that the representation is not unique consider for instance the total order symmetry where d is the rational numbers let y be the finitary subset of d that contains data values in the open interval here are some representations of y as the last one suggests one can make the set d of data values grow which entails a growing set of y yk thanks to lemma for a finitely presented language we may replace the nominal set construct from fig with a construct m mk of finite arity cf fig intuitively its purpose is to hull d dn m mk we prefer however a separate construct for technical convenience we shall call terms built with the new construct concrete as opposed to abstract terms built using the nominal set construct to define a reduction relation on concrete terms a few notions and results are needed first there is an obvious function m m from concrete to abstract terms defined by induction with the only nontrivial case m mk c set k i mi · gc types as in fig basic terms as in fig intermediate terms c ranges over finite subsets of d m · · · m mk c mi for i k m mk c fn special constants as in fig redexes xm n m nx fix m m fix m d k kn ref cd m mk c add m mk c m m k kn cd d k kn ref cd m mk c map m m mk c m k m kn cd mi mi ci for i k e c · · · ck ki ref e mi ci for i k sum m mk c k kl kk e if m mk c m n m if c m n n k kn ref cd m mk c hull m mk c k kn cd set reduction n nn d is a short form of m mk c ni k m mk c n ni k ni nn d figure n with data concrete terms lemma implies that the mapping m m is although as we explained above not injective it also obviously preserves types lemma the following operations can be computed given concrete terms m n decide if m n given a concrete term m find given concrete terms m n and a finite set c of data values decide if m · gc n · gc proof by simultaneous induction on the size of terms the following is a computational version of the refinement lemma lemma lemma given concrete terms m mk and c e one can compute concrete terms k kn such that m mk c k kn e we then denote ref e m mk c k kn we may now formulate reduction rules for basic redexes of the language as in fig for instance to reduce a concrete term add m mk c m one first computes the least support of m using lemma then uses lemma to refine m mk c and finally adds m to the resulting list of terms other redexes are similar for the set reduction rule it is to write simply m mn c mi n m mi n mi mn c however this leads into problems note that if m · gc m · gc then m m c m c but the above rule may let m m c and m c reduce differently to avoid this we convert concrete terms to a canonical form before they can reduce specifically we say that a concrete term m m mk c is in short form if · c and · mi · gc mj · gc for i j an arbitrary concrete term is in short form if all its subterms m mk c are in short form lemma for each concrete term m a concrete term n in short form such that m n exists and can be computed n is then called a short form of m proof by induction on m using lemma using short forms the set reduction rule is defined as in fig all these complications are by a close correspondence of reduction semantics of concrete and abstract terms proposition the reduction is bisimilar to ie · if m n then m n and · if m k then there exists a concrete term n such that m n and k n proof by structural induction on concrete terms part iii case studies in this part we demonstrate the potential of n as a basis of an expressive programming language so far we have ignored many useful features typically found in functional languages such as recursive datatypes eg lists and pattern matching the let construct etc we believe that adding this kind of features to n is an issue orthogonal to our concerns and may be done along standard lines in the examples to follow we feel free to use recursive types and let as if they were in the language alternating automata as a nontrivial example of nominal programming in the remaining sections we consider the emptiness problem for alternating automata we choose a problem it is decidable only under some restrictions on the state space of the automaton and only for certain data moreover even in known decidable cases the problem is extremely complex recursive except for the classical symmetry where it is definition of alternating automaton given a data symmetry d g an alternating automaton is given by an input alphabet a an orbitfinite nominal set a set of states q an orbitfinite nominal set a partition of states q q q into two nominal subsets a transition function that is a nominal function q × a fs fq an initial state qi q the final states f a nominal subset of q an alternating automaton is used to accept or reject a word w a the semantics is defined as follows a configuration of the automaton is a finite set of states we write x y z for configurations the initial configuration is qi a configuration is called final if it is a subset of f we now define a one step transition relation which says how to go from one configuration to another by reading an input letter suppose that x y are configurations and a a is an input letter then we write x a y if the following hold for every q x · if q q then y contains some state from q a · if q q then y contains all states from q a we say the automaton accepts an input word a · · · an a if there are configurations x xn such that x is the initial configuration xn is final and x a x a x a · · · an xn we say x can reach y in one step if x a y holds for some a a and we write this x y we denote the reflexive transitive closure of by when x y holds we say that x can reach y the automaton accepts some word if and only if the initial configuration can reach some final configuration from now on we are interested in the emptiness problem given an alternating automaton decide if it accepts some word example consider the equality symmetry we construct an automaton that the language d · · · dn n n and di dj for all i j the state space is q d where the states and are in their own the initial state is and all states except are final all states belong to q and q is empty the automaton the word in state and every time it a data value d it a new thread with state d this corresponds to the transition d d for d d when a thread with state d a letter e then it ignores it and keeps on scanning the word if e d otherwise it enters the error state because d has appeared twice d e d if d e otherwise for d e d finally it is impossible to recover from the error d for d d alternating automata let k n a nominal set is called if every element is supported by a set c d of cardinality k clearly an orbitfinite set is iff each of its is so example up to isomorphism there is only one set examples of sets are d and the set d × d for any d d with the action of g not changing the first coordinate examples of sets are d or the set of all subsets of d every set is also for l k in most data with the exception of the classical symmetry the set d is not an alternating automaton is if its state space is the alphabet is not taken into account for instance the automaton in example is from now on we consider only automata fact a set is if and only if it is an image under some function of an of the set dk our definition of alternating automaton can be instantiated to various data · in the classical symmetry the notion of dimension is irrelevant since every nominal set is already when instantiated to the classical symmetry our definition is equivalent to ordinary alternating automata · when instantiated to the equality symmetry our alternating automata are equivalent to alternating automata of and emptiness is known to be undecidable for k and decidable for k in the latter case the complexity of the problem is very high it is not bounded by any primitive recursive function · when instantiated to the total order symmetry alternating automata are equivalent to the model of automata studied by and in these automata are very closely related some details have to be to alternating automata emptiness of those is known to be undecidable for k and decidable for k with a similar lower complexity bound as above the decidability result was obtained independently by and as well as and in the remaining sections we will prove the following result theorem there exists a single program in n which emptiness of alternating automata for · the classical symmetry · the equality symmetry and · the total order symmetry order orders are the key technical tool in the algorithm and its proof of correctness according to a classical definition a order x is a if for every infinite sequence x x x there exist i j such that xi xj it is well known that is a iff it is wellfounded and every is finite we extend this definition to the nominal setting a nominal order is a nominal set x together with a order which is a nominal subset of x × x let c be the least support of a nominal order is called a nominal if for every infinite sequence x x x there exist i j and a permutation gc such that xi · xj as c supports the order relation one could equivalently require xi xj · for some gc the following lemma gives an equivalent and maybe definition lemma a nominal order x is a nominal iff it is well and every is a finitary subset of x for example any orbitfinite set x with the discrete partial order all different elements are incomparable is a nominal theorem for all data mentioned in theorem if q is an orbitfinite nominal set then fq ordered by inclusion is a nominal proof the proof depends on the data symmetry involved and used deep results such as lemma for the equality symmetry or lemma for the total order symmetry example the assumption on q being is important as an example consider the equality symmetry and the set q d the family of finite sets for all n n of the following form xn d d d d dn d where d dn are distinct data values forms an in fq indeed if n m then there is no bijection such that xn · xm thus q is not a nominal decision procedure for emptiness we now use the results of the previous section to give an emptiness algorithm for alternating automata the algorithm works in the total order symmetry and in the equality symmetry thus the results of the algorithm also works in the classical symmetry but in this case it has complexity one of our contributions is that we make the between explicit we produce one piece of code in n which solves the emptiness problem for alternating automata for all these data also because the code is generic it only on the essence of the problem and needs not to talk about technical details in addition the same code solves the emptiness problem for any data symmetry which satisfies the condition of theorem if q is an orbitfinite nominal set then fq ordered by inclusion is a nominal as an example in section we describe a new data symmetry called the forest symmetry that has property we also show that the partial order symmetry does not have property so the code does not work ie may not terminate for that symmetry in fact the emptiness of alternating automata is undecidable there in short although our program works in many the decidability and also complexity depends on the choice of symmetry highlevel overview of the algorithm the algorithm for checking emptiness of alternating automata runs two procedures in parallel the first procedure terminates if and only if the automaton is nonempty the second procedure terminates if and only if the automaton is empty our code makes syntactic sense for two and higher dimensional automata as well when executed for such inputs the program may not terminate formally speaking our language does not allow running two procedures in parallel however it is not difficult to combine the two procedures into a single one the procedure this procedure simply does a search through all reachable configurations define xn to be the set of configurations that can be reached from the initial configuration in n steps x def qi xn def x x x for some x xn the algorithm the sets x x x and searches each one for a final configuration the procedure terminates if and only if the automaton is nonempty the only question is how can we represent xn the following fact implies that each xn can be stored by a program of n fact if xn is finitary then so is xn the procedure is very straightforward and it requires almost no assumptions to work in particular it works for all not just those satisfying and it works also for automata of arbitrary dimension not just one the emptiness procedure the whole weight of the algorithm is in the emptiness procedure which searches for a finitary witness of emptiness unlike the procedure its proof of termination requires the automaton to be and the data symmetry to satisfy for a set x of configurations define x x x is a configuration that includes some x x proposition the automaton is empty if and only if there is a finitary subset x of configurations such that · x contains the initial configuration · x contains no final configurations · whenever x x and x x then x x the emptiness procedure searches through all finitary subsets of configurations and terminates if it finds one that satisfies the conditions in proposition implementing the algorithm in n we begin by typing the program the input to the program is an alternating automaton its alphabet is thus a parameter of type fn for some type similarly the set of states of the automaton is of type fn for some type we assume that and are equality types an automaton is thus given by a tuple of type fn × fn × fn × × f × × fn where the six correspond to a q q qi and f respectively call the type above therefore our emptiness algorithm will have the following type bool we now code the algorithm described in section the program consists of two procedures nonempty and empty both of type the simpler procedure is described below the more complex emptiness procedure is omitted due to lack of space we start with a wrong solution to nonempty to the correct one at first the problem could be solved by computing the transitive closure of the relation for instance using the program trans defined in example however we cannot apply trans to as is not finitary instead we systematically compute configurations reachable from qi in k steps for k we focus only on the nominal aspects of the program and skip those fragments that do not process infinite nominal sets for instance we assume for simplicity that we have a function f that computes for a given configuration x and an input letter a the finite set of all successor configurations of x via a this function uses functions add and then we may easily define f that computes for a given configuration x the finitary set x x x x a x similarly may be lifted to finitary sets of configurations x the above term inputs a finitary set x of configurations and outputs the set of its successors therefore this term the mapping xn xn discussed in section the last two auxiliary functions needed to define nonempty are final f bool bool final x forall x member f x if exists x final true x for a set x of configurations the function checks if a configuration containing only final states is reachable from any configuration in x by recursively computing successors finally nonempty a q q qi f just qi note that all auxiliary functions above must be defined in an environment that contains all of an automaton that is a q q qi and f decidability in this section we discuss what happens to our program for data other than those mentioned in theorem we provide a negative example and a positive one this demonstrates that decidability of the emptiness problem in dimension is a issue and it strongly depends on a data symmetry positive example forest orders consider a forest symmetry which corresponds to the class of a partial order is called a forest if for every element x the elements smaller than x are linearly ordered the class of finite has so there is a universal structure and we can study n in the resulting data symmetry one can show that the forest symmetry satisfies condition from section the proof is the same as in theorem except that we use tree theorem instead of or lemma because condition is satisfied our emptiness algorithm works and therefore emptiness is decidable for alternating automata for the forest symmetry this is a new decidability result unknown in the automata literature negative example partial orders consider the partial order symmetry arising from the class of finite partial orders fact condition fails in the partial order symmetry in fact emptiness is undecidable for alternating automata in the partial order symmetry name binding as another case study we use n to capture name binding on the example of untyped lambda calculus up to conversion our objective is to define a datatype to implement lambda terms such that two equivalent terms are represented by the same object of that datatype in this section we work with the equality symmetry our basic idea is that a term in particular a lambda abstraction modulo conversion is represented as a finitary set of terms for instance the following two terms m dd d m will be represented intuitively by the following two sets dd the lambda terms that we want to implement are built out of variables using application and lambda abstraction to store them we use a recursive datatype term term × term × term in particular we use data values to stand for variables we will explain the idea using m and m the term m is represented by t just d thus binding of a variable say d above in a term t is obtained by considering the of d t the term m ed will be represented by t just d just e that is by the of e with respect to gd intuitively a difference between free and bound variables is that a free variable of a term is an element of its least support while the bound variable is not finally m is represented by t just d t the set of free variables of a term can be computed as the least support of that term cf section we have decided to model lambda abstraction as a suitable set of type note that this type contains elements that do not correspond to wellformed terms however one can define a function d × term term that constructs a wellformed lambda abstraction up to conversion d t abs t let c just d in hull c just d t where term is defined as in section for instance the terms t and t could be defined as t d t d e for arbitrary d e for simplicity we assume from now on that all terms are wellformed ie defined using only var app and as above in fact a wellformedness check may be easily now we will write a substitution function subst term d term term with the meaning that subst t d u the term t for every free occurrence of d in term u it can be defined recursively subst t d if e d t subst t d t t d t subst t d t subst t d let c t in let x filter e c e x in e ue subst t d u x before term t is substituted inside a lambda abstraction we filter out from x all pairs e u such that e occurs free in t thus the free variables of t are not captured and remain free we should note that the code of the basic programs above is rather especially when compared to the treatment of conversion in fresh ocaml also the fact that the property of being a wellformed lambda term is not captured by the type system of n is a we see this case study as evidence of the limitations of n just as the examples of the preceding sections are evidence of its strength a detailed study of relations between n and fresh ocaml as well as an attempt to combine their strong points is left for future work references p j j and j decidability and complexity results for automata via channel machines in icalp pages ­ m data monoids in m b and s languages with group actions in lics j a and e l on equations for regular languages finite automata and sequential networks theor comput sci ­ a k d kozen and l j alternation j acm ­ s and r ltl with the quantifier and register automata acm trans comput log g l u and m transition systems for name passing calculi a formulation in volume of lncs pages ­ d p and s relating and register automata in proc express volume of pages ­ r theory of relations northholland n and m automata theor comput sci ­ m and a m pitts a new approach to abstract syntax with variable binding formal comput ­ s and i alternating automata in pages ­ s and i alternating automata acm trans comput log u and m automata an introduction in pages ­ j and j on the decidability of metric temporal logic in lics pages ­ m history dependent automata phd thesis university of m r the fresh approach functional programming with names and binders technical report university of cambridge computer laboratory february m r and a m pitts fresh objective caml user manual technical report university of cambridge computer laboratory february 