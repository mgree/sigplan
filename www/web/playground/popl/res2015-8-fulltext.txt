faster algorithms for algebraic path properties in recursive state machines with constant treewidth institute of science and technology institute of technology abstract interprocedural analysis is at the of numerous applications in programming languages such as alias analysis constant propagation etc recursive state machines rsms are standard models for interprocedural analysis we consider a general framework with rsms where the transitions are labeled from a semiring and path properties are algebraic with semiring operations rsms with algebraic path properties can model interprocedural dataflow analysis problems the shortest path problem the most path problem etc the traditional algorithms for interprocedural analysis focus on path properties where the starting point is fixed as the entry point of a specific method in this work we consider possible multiple queries as required in many applications such as in alias analysis the study of multiple queries allows us to bring in a very important algorithmic distinction between the resource usage of the preprocessing vs for each individual query the second aspect that we consider is that the control flow graphs for most programs have constant treewidth our main contributions are simple and implementable algorithms that support multiple queries for algebraic path properties for rsms that have constant treewidth our theoretical results show that our algorithms have small additional preprocessing but can answer subsequent queries significantly faster as compared to the current solutions for several important problems such as interprocedural reachability and shortest path we provide a prototype implementation for interprocedural reachability and intraprocedural shortest path that gives a significant speedup on several benchmarks categories and subject descriptors f logics and meanings of programs semantics of programming analysis this work has been supported by the science foundation under the rise s grant pn start grant graph games and microsoft permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page for components of this work owned by others than the authors must be abstracting with credit is permitted to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission andor a fee request permissions from popl january ­ copyright is held by the publication to acm acm keywords interprocedural analysis constant treewidth graphs dataflow analysis reachability and shortest path introduction interprocedural analysis and rsms interprocedural analysis is one of the classic algorithmic problem in programming languages which is at the of numerous applications ranging from alias analysis to data dependencies modification and reference side effect to constant propagation to live and use analysis in works it was shown that a large class of interprocedural dataflow analysis problems can be solved in polynomial time a standard model for interprocedural analysis is recursive state machines rsms in a rsm is a formal model for control flow graphs of programs with recursion we consider rsms that consist of component state machines one for each method that has a unique entry and unique exit and each contains boxes which are labeled as that allows calls to other methods algebraic path properties to specify properties of traces of a rsm we consider a very general framework where edges of the rsm are labeled from a partially complete semiring which subsumes bounded and finite distributive and we refer to the labels of the edges as weights for a given path the weight of the path is the semiring product of the weights on the edges of the path and to choose among different paths we use the semiring plus operator for example i with boolean semiring with semiring product as and and semiring plus as or we can express the reachability property ii with semiring with weights semiring product as standard sum and semiring plus as minimum we can express the shortest path property and iii with semiring with probability value on edges semiring product as standard multiplication and semiring plus as maximum we can express the most path property the algebraic path properties expressed in our framework subsumes the frameworks which consider finite and meet over all paths as the semiring plus operator since are subsumed in our framework the large and important class of dataflow analysis problems that can be expressed in frameworks can also be expressed in our framework two important aspects in the traditional algorithms for interprocedural analysis the starting point is typically fixed as the entry point of a specific method in graph theoretic graph algorithms can consider two types of queries i a pair query that given nodes u and v called u query for the algebraic path property from u to v and ii a query that given a node u for the answer of u queries for all nodes v thus the traditional algorithms for interprocedural analysis has focused on the answer for one query moreover the existing algorithms also consider that the input control flow graph is arbitrary and do not exploit the fact that most control flow graphs satisfy several elegant structural properties in this work we consider two new aspects namely i multiple pair and queries and ii exploit the fact that typically the control flow graphs of programs satisfy an important structural property called the constant treewidth property we describe in details the two aspects · multiple queries we first describe the of pair and multiple pair queries and then the of even multiple queries in alias analysis the question is whether two pointers may point to the same object which is by definition modeled as a question between a pair of nodes similarly eg in constant propagation given a function call a relevant question is whether some variable remains constant within the entry and exit of the function in general it can be between a pair of nodes of the program this shows that the pair query problem and the multiple pair queries are relevant in many applications finally consider a runtime optimization scenario where the goal is to decide whether a variable remains constant from now on and this corresponds to a query where the starting point is the current execution point of the program thus multiple pair queries and multiple queries are relevant for several important static analysis problems · constant treewidth a very wellknown concept in graph theory is the notion of treewidth of a graph which is a measure of how similar a graph is to a tree a graph has treewidth precisely if it is a tree the treewidth of a graph is defined based on a tree decomposition of the graph see section for a formal definition beyond the mathematical of the treewidth property for graphs there are many classes of graphs which arise in practice and have constant treewidth the most important example is that the control flow graph for programs for many programming languages are of constant treewidth and it was also shown in that typically all java programs have constant treewidth an important property of graphs is that the number of edges is at most a constant factor larger than the number of nodes this has been considered in the comparison tables and our contributions in this work we consider rsms where every has constant treewidth and the algorithmic question of multiple and multiple pair queries where each query is a query a query starts and ends with an empty stack see for the of queries in the analysis of multiple queries there is a very important algorithmic distinction between preprocessing denoted as the preprocessing time and the work done for each individual query denoted as the query time there are two in the of tradeoff between the preprocessing and query resources that can be obtained by using the classical algorithms for one query namely i the complete preprocessing and ii the no preprocessing in complete preprocessing the answer is with every node as the starting point for example in graph reachability this corresponds to computing the reachability problem with the classical algorithm or with fast matrix multiplication in no preprocessing there is no preprocessing done and the algorithm for one query is used on demand for each individual query we consider various other possible tradeoffs in preprocessing vs query time our main contributions are as follows general result since we consider arbitrary ie not restricted to finite we consider the stack height bounded problem where the height of the stack is bounded by a parameter h while in general for arbitrary there does not exist a bound on the stack height if the semiring contains subsets of a finite universe d and the semiring plus operator is intersection or union then solving the problem with sufficiently large bound on the stack height is equivalent to solving the problem without any restriction on stack height our main result is an algorithm where the preprocessing phase requires on · log n h · b · log n semiring operations and then each subsequent bounded stack height pair query can be in constant number of semiring operations where n is the number of nodes of the rsm and b the number of boxes see table and theorem if we specialize our result to the setting with finite from a finite universe of distributive functions d d and meet over all paths as the semiring plus operator then we obtain the results shown in table corollary for example our approach with a factor of n overhead for preprocessing as compared no preprocessing can answer subsequent pair queries by a factor of on · d faster an important feature of our algorithms is that they are simple and implementable reachability and shortest path we now discuss the of our result for the very important special cases of reachability and shortest path · reachability the result for reachability with full preprocessing no preprocessing and the various tradeoff that can be obtained by our approach is obtained from table by d for example for pair queries full preprocessing requires quadratic time and space for reachability computation and answers individual queries in constant time no preprocessing requires linear time and space for individual queries whereas with our approach i with on · log n preprocessing time and space we can answer individual queries in constant time which is a significant from quadratic to improvement over full preprocessing or ii with linear space and preprocessing time we can answer queries in time which is a from linear to improvement over no preprocessing for example if we consider on pair queries then both full preprocessing and no preprocessing in total require quadratic time whereas our approach in total requires on · log n n · log n on · log n time · shortest path we now consider the problem of shortest path where the current algorithm is for pushdown graphs and we are not aware of any better bounds for rsms that have unique entries and exits the algorithm of is a polynomialtime algorithm of degree four and the full preprocessing requires on time and quadratic space and can answer resp pair queries in linear resp constant time whereas the no preprocessing requires on time and linear space for both and pair queries in contrast we show that i with on · log n preprocessing time and space we can answer resp pair queries in linear resp constant time or i with preprocessing and linear space we can answer resp pair queries in linear resp time thus our approach provides a significant theoretical improvement over the existing approaches there are two facts that are responsible for our improvement the first is that we consider that each of the rsm has constant treewidth and the second is the tradeoff of preprocessing and individual queries also note that our results apply only to queries experimental results besides the theoretical improvements we demonstrate the effectiveness of our approach on several wellknown benchmarks from programming languages we use the tool for computing tree from and all benchmarks of our experimental results have small treewidth we have implemented our algorithms for our results preprocessing time n · n h · b n · n h · b space on · log n on single source query on n pair query o on reference theorem theorem table interprocedural algebraic path problem on rsms with b boxes and constant treewidth for stack height h complete preprocessing no preprocessing our results preprocessing time on · d od · log n · n b · d on · d log n · b · d n space on · d on · d on · log n · d on · d single source query od on · d on · d on · d pair query on · d on · d od n · d reference corollary corollary table interprocedural algebraic path problem on rsms with b boxes and constant treewidth where the semiring is over the subset of d elements and the plus operator is the meet operator of the ifds framework the special case of reachability is obtained when d complete preprocessing no preprocessing our results preprocessing time on on · log n on · log n space on on on · log n on query on on on on pair query o on o n reference corollary corollary table interprocedural shortest path for rsms with constant treewidth ity both intraprocedural and interprocedural and shortest paths only intraprocedural and compare their performance against complete and no preprocessing approaches for queries our experimental results show that our approach obtains a significant improvement over the existing approaches of complete and no preprocessing technical contribution our main technical contribution is a dynamic algorithm also referred to as incremental algorithm in graph algorithm literature that given a graph with constant treewidth after a preprocessing phase of on · log n semiring operations supports changing the label of an edge with n semiring operations and pair queries with n semiring operations and queries with on semiring operations these results are presented in theorem nice several previous works such as have stated the importance and for the development of data structures and analysis techniques to support dynamic updates though our main results are for the problem where the rsm is given and fixed our main technical contribution is a dynamic algorithm that can also be used in other applications to support dynamic updates and is thus also of independent interest related work in this section we compare our work with several related work from interprocedural analysis as well as for constant treewidth property interprocedural analysis interprocedural analysis is a classic algorithmic problem in static analysis and several applications have been studied in the literature our work is most closely related to the frameworks introduced in works in both framework the semiring is finite and they study the algorithmic question of solving one query while in our framework the semiring is not necessarily finite we consider the stack height bounded problem we also consider the multiple pair and queries and the additional restriction that rsms have constant treewidth our general result specialized to finite where the stack height bounded problem coincides with the general problem improves the existing best known algorithms for the framework where the rsms have constant treewidth for example the shortest path problem cannot be expressed in the framework but can be expressed in the framework the framework considers the more general problem of weighted pushdown graphs whereas we show that with the restriction to constant treewidth rsms the bounds for the algorithm can be significantly improved finally several works such as ask for interprocedural analysis and algorithms to support dynamic updates and our main technical contributions are algorithms to support dynamic updates in interprocedural analysis recursive state machines rsms recursive state machines which in general are equivalent to pushdown graphs have been studied as a formal model for interprocedural analysis however in comparison to pushdown graphs rsms are a more convenient formalism for interprocedural analysis games on recursive state machines with modular strategies have been considered in and algorithm for general rsms with reachability has been shown in we focus on rsms with unique entries and exits and with the restriction that the components have constant tree width rsms with unique entries and exits are less expressive than pushdown graphs but remain a very natural model for efficient interprocedural analysis treewidth of graphs the notion of treewidth for graphs as an elegant mathematical tool to analyze graphs was introduced in the of constant treewidth in graph theory is mainly because several problems on graphs become easier given a tree decomposition of a graph with low treewidth t many npcomplete problems for arbitrary graphs can be solved in time polynomial in the size of the graph but exponential in t ­ even for problems that can be solved in polynomial time faster algorithms can be obtained for low treewidth graphs for example for the distance problem the property of graphs has also been used in the context of logic monadic second order mso logic is a very expressive logic and a result of showed that for graphs the decision questions for mso can be solved in polynomial time and the result of shows that this can even be achieved in deterministic dynamic algorithms for the special case of treewidth graphs has been considered in and extended to various tradeoffs by and shows how to maintain the strongly connected component decomposition under edge for constant treewidth graphs however none of these works consider rsms or interprocedural analysis various other models such as probabilistic models of markov decision processes and games on graphs for synthesis with the restriction have also been considered the problem of computing a balanced tree decomposition for a constant treewidth graph was considered in and we use this algorithm in our preprocessing phase more importantly in the context of programming languages it was shown by that the control flow graph for programs for many programming languages have constant treewidth this theoretical result was subsequently followed up in several practical approaches and it was shown in that though in theory java programs might not have constant treewidth in practice java programs do have constant treewidth we also use the existing tool developed by in our experimental results definitions we will in this section give definitions related to graphs and recursive state machines definition we consider partially complete where is a countable set and are binary operators on and and the following properties hold is associative commutative and is the neutral element is associative and is the neutral element over is infinitely associative infinitely over in multiplication ie a a additionally we consider that are equipped with a closure operator such that s s s s s s graphs and tree decomposition definition graphs and weighted paths let g v e be a finite directed graph where v is a set of n nodes and e v × v is an edge relation of m edges along with a weight function wt e that assigns to each edge of g an element from a path p u v is a sequence of edges e ek and each ei xi yi is such that x u yk v and for all i k we have yi xi the length of p is k a path p is simple if no node in the path ie it does not contain a cycle a single node is by itself a length path given a path p e ek the weight of p is p if p else p given nodes u v v the distance du v is defined as du v p u v p and du v if no such p exists definition tree decomposition and treewidth given a graph g v e a vt et is a tree such that the following conditions hold vt b bn for all i n bi v and bi v for all u v e there exists bi vt such that u v bi for all i j k such that there exist paths bi bk and bk bj in we have bi bj bk the sets bi which are nodes in vt are called the width of a is the size of the largest bag and the treewidth of g is the width of a tree decomposition of g it follows from the definition that if g has constant treewidth then m on example graph and tree decomposition the treewidth of a graph g is an intuitive measure which represents the of g to a tree though g itself not a tree the treewidth of g is precisely if g is itself a tree consider an example graph and its tree decomposition shown in figure it is straightforward to verify that all the three conditions of tree decomposition are met each node in the tree is a bag and labeled by the set of nodes it contains since each bag contains at most three nodes the tree decomposition by definition has treewidth intuitive meaning of tree decomposition in words the is a tree where every node bag is subset of nodes of g such that every vertex in g belongs to some bag every edge in g also belongs to some bag and for every node v of g for every in if v appears in the of the path then it must appear all along the path property given a graph g and its tree decomposition note that for each bag b in if we remove the set of nodes in the bag then the graph splits into possibly multiple components ie each bag is a for the graph in other words every bag acts as a of the graph notations for tree decomposition let g be a graph t and b be the root of t denote with lv bi the depth of bi in t with lv b for u v we say that a bag b introduces u if b is the bag with the smallest level among all that contain u ie bu arg ub lv b by definition there is exactly one bag introducing each node u we often write bu for the bag that introduces the node u and denote with lv bu finally we denote with the bag of the level that introduces one of u v a is if is a binary tree and every bag introduces at most one node example in the example of figure the bag is the root of the level of node is lv lv and the bag of the edge is b theorem for every graph there exists a tree decomposition that achieves the treewidth of g and uses n on for constant treewidth graphs a balanced tree decomposition can be obtained in on · log n time ie every simple path b bi in has length n the algebraic path problem on graphs of constant treewidth given g v e a balanced of g with constant treewidth t o a partially complete semiring a weight function wt e the algebraic path problem on input u v v for the distance du v from node u to node v in addition we allow the weight function to change between successive queries we measure the time complexity of our algorithms in number of operations with each operation being either a basic machine operation or an application of one of the operators of the semiring figure a graph g with treewidth left and a corresponding right recursive state machines definition rsms and a recursive state machine rsm from now on over an alphabet as defined in consists of a set a a ak such that for each i k the component state machine ai bi yi vi ei where vi ni ci ri consists of · a set bi of boxes · a map yi mapping each box in bi to an index in k we say that a box b bi corresponds to the with index · a set vi of nodes consisting of the union of the sets ni ci and ri the number ni is the size of vi each of these sets besides vi are assumed to be pairwise disjoint the set ni is the set of internal nodes the node is the entry node the node is the exit node the set ci is the set of call nodes each call node is a pair x b where b is a box in bi and x is the entry node of the corresponding with index the set ri is the set of return nodes each return node is a pair y b where b is a box in bi and y is the exit node of the corresponding with index · a set ei of internal edges each edge is a pair in ni ri × ni ci · a map mapping each edge in ei to a label in definition control flow graph of and treewidth of rsms given a rsm a a a ak the control flow graph gi vi ei for ai consists of vi as the set of vertices and ei as the set of edges where ei consists of the edges ei of ai and for each box b each call node v b of that box ie for v has an edge to each return node v b of that box ie for v we say that the rsm has treewidth t if t is the smallest integer such that for each index i k the graph gi vi ei has treewidth at most t programs are naturally represented as rsms where the control flow graph of each method of a program is represented as a example rsm and tree decomposition figure shows an example of a program for matrix multiplication consisting of two methods one for vector multiplication invoked by the one for matrix multiplication the corresponding control flow graphs and their tree that achieve treewidth are also shown in the figure box sequences for a sequence l of boxes and a box b we denote with l b the concatenation of l and b also is the empty sequence of boxes configurations and global edges a configuration of a rsm is a pair v l where v is a node in ni ri and l is a sequence of boxes the stack height of a configuration v l is the number of boxes in the sequence l the set of global edges e are edges between configurations the map wt maps each edge in e to a label in we have that there is an edge between configuration c v l where v vi and configuration c v l with label c if and only if one of the following holds · internal edge we have that v is an internal node in ni and each of the following i l l and ii v v ei and iii v · entry edge we have that v is the entry node for some box b and each of the following i l b l and ii v v b ei and iii v b · return edge we have that v v b is a return node for some exit node v and some box b and each of the following i l l b and ii v v ei and iii v note that in a configuration v l the node v cannot be or in ci in essence the corresponding configuration is at the corresponding return node instead of at the exit node or corresponding entry node instead of at the call node respectively execution paths an execution path is a sequence of configurations and labels p c c c such that for each integer i where i we have that ci ci e and i ci we call the length of p also we say that the stack height of a execution path is the maximum stack height of a configuration in the execution path for a pair of configurations c c the set c c is the set of execution paths c c c for any where c c and c c for a set s of execution paths the set bs h s is the subset of execution paths with stack height at most h given a partially complete semiring the distance of a execution path p c c c is p the empty product is given configurations c c the configuration distance dc c is defined as dc c p c c p the empty sum is also given configurations c c and a stack height h where c is from c the bounded height configuration distance dc c h is defined as dc c h p bc c h p note that the above definition of execution paths only allows for so called valid paths ie paths that fully respect the calling contexts of an execution the algebraic path problem on rsms of constant treewidth given i a rsm a a a ak and ii for each i k a balanced ei with constant treewidth at most t o and iii a partially complete semiring the algebraic path problem on input nodes u v for the distance du v ie the distance between the configurations with the empty stack similarly also given a height h the bounded height algebraic path problem on input configurations c c for the distance du v h when it is clear from the context we will write du v to refer to the algebraic path problem of nodes u and v on rsms remark note that the empty stack restriction implies that u and v are nodes of the same however the paths from u to v are in general interprocedural and thus involve invocations and returns from other this formulation has been used before in terms of and samelevel realizable paths and has several applications in program analysis eg by capturing balanced properties used in alias analysis problems we note that a wide range of interprocedural problems can be formulated as bounded height algebraic path problems reachability ie given nodes u v in the same is there a path from u to v the problem can be formulated on the boolean semiring true false false true shortest path ie given a weight function wt e r and nodes u v in the same what is the weight of the path from u to v the problem can be formulated on the semiring r min most path ie given a probability function p e and nodes u v in the same what is the probability of the path from u to v the problem can be formulated on the semiring max · the class of interprocedural finite distributive subset ifds problems defined in given a finite domain d a universe of flow functions f containing distributive functions f d d a weight function wt e f associates each edge with a flow function the weight of an interprocedural path is then defined as the composition of the flow functions along its edges and the ifds problem given nodes u v for the meet union or intersection of the weights of all u v paths the problem can be formulated on the semiring f i where i is the identity function the class of interprocedural distributive environment problems defined in this class of dataflow problems is an extension to ifds with the difference that the flow functions called environment transformers map elements from the finite domain d to values in an infinite set eg of the form f d n an environment transformer is denoted as f d meaning that the element d d is mapped to value while the mapping of all other elements remains unchanged the problem can be formulated on the semiring f i where i is the identity environment transformer leaving every map unchanged note that if we assume that the set of weights of all interprocedural paths in the system is finite then the size of this set bounds the stack height h additionally several problems can be formulated as algebraic path problems in which bounding the stack height can be viewed as an approximation to them eg shortest path with negative interprocedural cycles or probability of reaching a node v from a node u dynamic algorithms for update and query in the current section we present algorithms that take as input a constant treewidth graph g and a balanced recall theorem and achieve the following tasks preprocessing the of a graph g to answer algebraic path queries fast updating the upon change of the weight v of an edge u v the to the distance du v of any pair of nodes u v in the following section we use the results of this section in order to rsms fast with the purpose of interprocedural algebraic path queries fast refer to example of section for an illustration on how these algorithms are executed on an rsm first we establish the following lemma which captures the main intuition behind tree namely that b of the are between nodes of g that belong to components of once b is removed lemma property consider a graph g v e and a let u v v and p b b bj be the unique path in t such that u b and v bj for each i j and for each path p u v there exists a node xi bi bi p proof fix a number i j we argue that for each path p u v there exists a node xi bi bi p we construct a tree tree g which is similar to except that instead of having an edge between bag bi and bag bi there is a new bag b that contains the nodes in bi bi and there is an edge between bi and b and one between b and bi it is easy to see that tree g forms a tree decomposition of g let c c be the two components of separated be b and u c and v c it follows by the definition of tree decomposition that b is a of b c b and b c b hence each path u v must go through some node xi in b and by construction xi bi bi intuition and paths a central concept in our algorithms is that of paths given a bag b and nodes u v b we say that a path p u v is in b if one of the following conditions hold either p and for all intermediate nodes w p we have or p and b is bu or bv informally given a bag b a path in b is a path that traverses intermediate nodes that are introduced in b and its descendants in in the following we present three algorithms for i preprocessing a tree decomposition ii updating the data structures of the preprocessing upon a weight change v of an edge u v and iii for the distance du v for any pair of nodes u v the intuition behind the overall approach is that for every path p u v and z the path p can be decomposed to paths p u z and p z v by lemma if we consider the path p bu bz and any bag bi p we can find nodes x y bi p not necessarily distinct then p is decomposed to a sequence of paths pi one for each such bi and the weight of p can be written as the product of the weights of pi ie p pi similar observation holds for p hence the task of preprocessing and updating is to summarize in each bi the weights of all such paths between all pairs of nodes appearing in bi to answer the query the algorithm traverses the tree from bu and bv and combines the summarized paths to obtain the weights of all such paths p and p and eventually p such that p du v informal description of preprocessing algorithm associates with each bag b a local distance map b × b upon a weight change algorithm update updates the local distance map of some it will hold that after the preprocessing and each subsequent update v p u vp where all p are paths in b given this guarantee we later present an algorithm for u v queries with du v the distance from u to v algorithm is a dynamic programming algorithm it traverses bottomup and for a currently examined bag b introducing a node x it calls the method internal entry exit call return method dot vector input x y rn output the dot product x y result for i to n do z xi · yi result result z end return result b b b b b b method dot matrix input a b output the dot product a × b c zero matrix of size n × m for i to n do for j to m do call dot b j ci j the value returned by the call of line end end return c b b b b b b b b figure example of a program consisting of two methods their control flow graphs gi vi ei where nodes correspond to line numbers and the corresponding tree each one achieving treewidth merge to compute the local distance map in turn merge computes depending only on the local distance maps of the children bi of b and uses the closure operator to capture possibly traversals of cycles whose node is x see method and algorithm for a formal description method merge input a bag bx with children bi output a local distance map assign wt x x x x x x foreach u bx with u x do assign wt x u u x u x u assign wt u x x u x u x end foreach u v bx do assign wt u x wt x x wt x v assign u v u v u v end lemma at the end of for every bag b and nodes u v b we have v p u vp where all p are paths in b proof the proof is by induction on the parents initially b is a leaf introducing some node x thus each such path p can only go through x and hence will be captured by now assume that the algorithm a bag b and by the induction hypothesis the statement is true for all bi children of bx the correctness follows easily if b does not introduce any node since every such p is a path in some child bi of b now consider that b introduces some node x and any path p u v that additionally x and decompose it to paths algorithm input a vt et output a local distance map for each bag b vt traverse bottom up and examine each bag b with children bi if b introduces some node x then assign merge on b else foreach u v b do assign u v u v u v end end p u x p x x and p x v such that x is not an intermediate node in either p or p and we have by distributivity p p ppp p p p p p p p p p note that p and p are also in one of the children bi of bx hence by the induction hypothesis in lines and of merge we have wt u x p p and wt x v p p also by p into a possibly unbounded sequence of paths pi x x such that x is not intermediate node in any pi we get that each such pi is a path in some child of b and we have by distributivity and the induction hypothesis p p pp bl bl bl bl p p p p p p x x x x and the last expression equals wt x x from line of merge the above conclude that in line of merge we have p p finally each path p u v in b either x or is in one of the children bi hence after line of method merge has run on b for all u v b we have that v p u v p where all paths p are in b the desired results follows lemma requires on semiring operations proof merge requires ot o operations and calls merge at most once for each bag hence requiring on operations wt x x v wt x v u wt u x x p p p figure illustration of the inductive argument of informal description of updating algorithm update is called whenever the weight y of an edge of g has changed given the guarantee of lemma after update has run on an edge update y it the property that for each bag b we have v p u vp where all p are paths in b see algorithm for a formal description algorithm update input an edge x y with new weight y output a local distance map for each bag b vt assign b the bag containing the edge x y repeat call merge on b assign b b where b is the parent of b until lemma at the end of each run of update for every bag b and nodes u v b we have v p u vp where all p are paths in b proof first by the definition of a path p in b it follows that the statement holds for all not processed by update since for any such bag b and path p in b the path p cannot traverse u v for the remaining the proof follows an induction on the parents updated by update similar to that of lemma lemma update requires n operations per update proof merge requires ot o operations and update calls merge once for each bag in the path from to the root recall that the height of is n theorem and the result follows informal description of algorithm query answers a u v query with the distance du v from u to v because of lemma every path p u v is guaranteed to go through the least common ancestor bl of bu and bv and possibly some of the ancestors b of bl given this fact algorithm query uses the procedure to up the tree from bu and bv until it reaches bl and then the root of for each encountered bag b along the way it computes maps uw p p and vw p p where all p u w and p w v are such that each intermediate node y in them has been introduced in b this guarantees that for path p such that du v p when query the bag bz introducing z it will be du v uz vz hence for query it suffices to maintain a current best solution and update it with ux vx every time it ex a bag b introducing some node x figure presents a illustration of query and its correctness method presents the procedure which given a current distance map of a node a current bag b and a flag up updates with the distance to if up true or from if up false each node in b see method and algorithm for a formal description method input a bag b a map a flag up output a new map remove from all w b assign w for all w b and not in if b introduces node x then if up then up update with w w x w else down update with w w x x end return lemma query returns du v proof let p u v be any path from u to v and z the lowest level node in p decompose p to p u z p z v and it follows that p p p we argue that when query bz it will be uz p p and p vz p we only focus on the uz case here as the vz is similar we argue inductively that when algorithm query a bag bx for all w bx we have uw p p where all p are such that for each intermediate node y we have initially line it is x u bx bu and every such p is in bu hence x w p p and uw p p now consider that query a bag bx lines and and the claim holds for bx a de of bx previously examined by query if x does not occur in p it is a consequence of lemma that w bx hence by the induction hypothesis p has been considered by query otherwise x occurs in p and decompose p to p p such that p ends with the first occurrence of x in p and it is p p p note that p is a path in bx hence x w p p finally as a consequence of lemma we have that x bx and by the induction hypothesis ux p p it follows that af algorithm query input a pair u v output the distance du v from u to v initialize map u with uw u w initialize map v with vw w v assign bl the of bu bv in assign b bu repeat assign b b where b is the parent of b call on b and u with flag up set to true until b bl assign b bv repeat assign b b where b is the parent of b call on b and v with flag up set to false until b bl assign b bl assign ux vx repeat assign b b where b is the parent of b call on b and u with flag up set to true call on b and v with flag up set to false if b introduces node x then assign ux vx until return ter query processes bx it will be uw p p by the choice of z when query the bag bz it will be uz p p a similar argument shows that at that point it will also be vz p p hence at that point p p du v lemma query requires n semiring operations proof requires ot o operations and query calls once for every bag in the paths from bu and bv to the root recall that the height of is n theorem and the result follows we conclude the results of this section with the following theorem theorem consider a graph g v e and a balanced of constant treewidth the following assertions hold requires on semiring operations update requires n semiring operations per edge weight update and query correctly answers distance queries in n semiring operations witness paths our algorithms so far have only been concerned with returning the distance du v of the pair query u v when the semiring lacks the closure operator ie for all s it is s as in most problems eg reachability and shortest paths with positive weights the distance from every u to v is realized by an acyclic path then it is straightforward to also obtain a witness path ie a path p u v such that p du v with some minor additional preprocessing here we outline how whenever merge updates the local distance v between two nodes in a bag b it does so by considering the to and from an intermediate node x it suffices to remember that intermediate node for every such local distance then the witness path to a local distance in b can be obtained straightforwardly by a bz z bx bl x z bu u x bx z x bv x v figure illustration of query in computing the distance du v p as a sequence of paths whose weight has been captured in the local distance map of each bag when bz is examined with z it will be uz du z and vz dz v and hence by distributivity du v uz vz topdown computation on starting from b recall that in essence query answers a distance query u v by combining several local along the paths bu bz and bz bv where z is the node with the minimum level in a path p u v such that p du v since from every such local distance a witness pi can be obtained p is by of all such pi finally this process costs op time algorithms for constant treewidth rsms in this section we consider the bounded height algebraic path problem on rsms of constant treewidth that is we consider i an rsm a a a ak where ai consists of ni nodes and bi boxes ii a partially complete semiring and iii a maximum stack height h our task is to create a datastructure that after some preprocessing can answer queries of the form given a pair u v of configurations compute du v h also recall remark for this purpose we present the algorithm which performs such preprocessing using a datastructure d consisting of the algorithms update and query of section at the end of it will hold that algebraic path pair queries in a ai can be in ni semiring operations we later present some additional preprocessing which a factor of ni in the preprocessing space but reduces the pair query time to constant algorithm our algorithm can be viewed as a computation on the call graph of the rsm ie a graph where every node corresponds to a and an edge two if one appears as a box in the other informally consists of the following steps first it the control flow graphs gi vi ei of the ai using of section where the weight function for each gi is extended such that b ex b for all pairs of call and return nodes to the same box b this allows the computation of du v for all pairs of nodes u v since no call can be made while still having zero stack height then iteratively for each where h given that we have a dynamic datastructure d concretely an instance of the dynamic algorithms update and query from section for computing du v the algorithm does as follows first for each gi whose entry to exit distance has changed from the last iteration and for each gj that contains a box pointing to gi it updates the call to return distance of the corresponding nodes using query then it obtains the entry to exit distance to see if it was modified and continues with the next iteration of see algorithm for a formal description algorithm input a set of control flow graphs g stack height h foreach gi g do construct the call on end call query on of modified k for to h do modified foreach i modified do foreach gj that contains boxes bj st yj i do call update on gj for the weight change ex call query on if then modified modified j end end modified modified end correctness and pair query time the algorithm is described so that a proof by induction is straight forward for correctness initially running the algorithm from section on each of the graphs gi allows queries for the du v for all pairs of nodes u v since no method call can be made also the induction follows directly since for every ai updating the distance from call nodes en b to the corresponding return nodes ex b of every box b that to a aj whose distance was changed in the last iteration ensures that the distance du v of every pair of nodes u v in ai is computed correctly this is also true for the special pair of nodes which the next iteration of finally requires o k i ni · log ni time to construct a balanced tree position theorem on time to all gi initially and o · log ni to update all gi for one iteration of the loop of line from theorem hence uses o k i ni · log ni h · bi · log ni preprocessing semiring op finally it is easy to verify that all preprocessing is done in on space after the last iteration of algorithm we have a datastructure d that on space and answers distance queries du v h in ni time with u v vi by calling query from theorem for the distance du v in gi example we now present a small example of how is executed on the rsm of figure for the case of reachability in this case for any pair of nodes u v we have du v true iff u reaches v table a illustrates how the local distance maps look for each bag bx of each of the of the two methods dot vector and dot matrix each column represents the local distance map of the corresponding bag bx and an entry u v means that u v true ie u reaches v for brevity in the table we hide self loops ie entries of the form u u although they are stored by the algorithms initially the stack height and is called for each graph line the new reachability relations discovered by merge are shown in note that at this point we have wt false in method dot matrix as we do not know whether the call to method dot vector actually returns query is called to discover the distance d in method dot vector line table b shows the sequence in which query the of the tree decomposition and the and it maintains when b is examined true and hence at the end query returns true finally since query returns true the weight wt between the pair of nodes in method dot matrix is set to true an execution of update line with this update on the corresponding tree decomposition table a for updates the entries and in of method dot matrix shown in from this point any distance query can be in time in the size of its by further calls to query linear query time in order to handle queries some additional preprocessing is required the basic idea is to use to process the graphs gi and then use additional preprocessing on each gi by applying existing algorithms for graphs with constant treewidth for graphs with constant treewidth an extension of lemma from allows us to the distance du v for every pair of nodes u v vi that appear in the same bag of the computation required is similar to with the difference that this time is traversed topdown instead of bottomup additionally for each examined bag b a algorithm is run in the graph gi induced by b and all pairs of are updated it follows from lemma of that for constant treewidth this step requires time and space after all du v have been computed for each b it is straightforward to answer queries from some node u in linear time the algorithm simply maintains a map a vi and initially av du v for all v bu and av otherwise then it traverses in a manner starting at bu and for every encountered bag b and v b if av it sets av az dz v for constant treewidth this results in a constant number of semiring operations per bag and hence time in total constant pair query time after has returned it is possible to further the graphs gi to reduce the pair query time to constant while increasing the space by a factor of log ni for constant treewidth this can be obtained by theorem from to our setting which in turn is based on a rather complicated algorithmic technique of we present a more intuitive simpler and implementable approach that has a dynamic programming nature in section we present some experimental results obtained by this approach recall that the extra preprocessing for queries in linear time consists in computing du v for every pair of nodes u v that appear in the same bag at no overhead to handle pair queries in constant time we further traverse each one last time bottomup and for each node u we store maps fu tu where is the subset of vi of nodes that appear in bu and its descendants in the maps are such that du v and tu dv u hence fu stores update dot vector dot matrix b b b b b b b b b b b b b b a query d b dot vector b b true b b true table illustration of on the tree of methods dot vector and dot matrix from figure table a shows the local distance maps for each bag and stack height table b shows how the distance query d in method dot vector is handled the from u to nodes in and tu stores the from nodes in to u the maps are computed in a dynamic programming fashion as follows initially the maps fu and tu are constructed for all u that appear in a bag b which is a leaf of the information required has already been computed as part of the preprocessing for queries then is traversed up level by level when examining a bag b such that the computation has been performed for all its children for every node u b and v we set du z and similarly for tu dz u an application of lemma inductively on the levels processed by the algorithm can be used to show that when a bag b is processed for every node u b and v we have p v u p and p u v p finally there are semiring operations done at each level of and since there are ni levels · log ni operations are required in total hence the space used is also · log ni we furthermore in linear time and space to answer queries in constant time note that since is balanced this is standard to answer a pair query u v it suffices to first obtain the b of bu and bv and it follows from lemma that du v which requires a constant number of semiring operations we conclude the results of this section with the following theorem we obtain the results for the special cases of the framework reachability and shortest path theorem fix the following input i a constant treewidth rsm a a a ak where ai consists of ni nodes and bi boxes ii a partially complete semiring and iii a maximum stack height h uses o ni h · bi · log ni preprocessing semiring operations and using on space it correctly answers algebraic pair queries in ni and algebraic single source queries in semiring operations using o k i ni · log ni space it correctly answers same context algebraic pair queries in o semiring operations framework in the special case where the algebraic path problem belongs to the framework we have a semiring f i where f is a set of distributive flow functions d d d is a set of data facts is the meet operator either union or intersection is the flow function composition operator and i is the identity flow function for a fair comparison the semiring operation does not induce a unit time cost but instead a cost of od per data fact as functions are represented as graphs because the set d is finite and the meet operator is either union or intersection it follows that the image of every data fact will be updated at most d times then line of needs to change so that instead of h iterations the body of the loop is carried up to a fixpoint the cost per gi is then bi · log ni · d as there are d data facts and we have the following corollary also see table corollary fix the following input a i constant treewidth rsm a a a ak where ai consists of ni nodes and bi boxes and ii a semiring f i where f is a set of distributive flow functions d d is the flow function composition operator and is the meet operator algorithm uses o k i ni · d bi · log ni · d ni · log ni preprocessing time on · d space and correctly answers algebraic pair queries in time and algebraic queries in · d time algorithm uses o k i ni · log ni · d bi · log ni · d preprocessing time od · k i ni · log ni space and correctly answers algebraic pair queries in od time and algebraic queries in · d time reachability the special case of reachability is obtained by setting d in corollary shortest paths the shortest path problem can be formulated on the semiring r min we consider that both semiring operators cost unit time ie the weights occurring in the computation fit in a constant number of machine words because we consider nonnegative weights it follows that the distance between any pair of nodes is realized by a path that traverses every entry node at most once hence we set h k in theorem and obtain the following corollary for shortest paths also see table corollary shortest paths fix the following input a i constant treewidth rsm a a a ak where ai consists of ni nodes and bi boxes ii a semiring r min uses o · log ni k · bi · log ni preprocessing time and using on space it correctly answers shortest path pair queries in ni and shortest path queries in time using o k i ni · log ni space it correctly answers same context shortest path pair queries in o time interprocedural witness paths as in the case of simple graphs from section we can a witness path for any distance du v h that is realized by acyclic interprocedural paths p u v without the stated the process is straightforward let ai contain the pair of nodes u v on which the query is initially we obtain the witness intraprocedural path p u v as described in section then we proceed recursively to obtain a witness path pj between the entry and exit nodes of every aj such that p contains an edge between a call node en b and a return node ex b with j that is we a witness path for every call to a whose weight has been summarized locally in ai this process constructs an interprocedural witness path p u v such that p du v in op time experimental results set up we have implemented our algorithms for and pair queries presented in section and have tested them on graphs obtained from the benchmark that contains several realworld java applications every benchmark is represented as a rsm that consists of several and each corresponds to the control flow graph of a method of the benchmark we have used the framework for obtaining the control flow graphs where every node of the graph corresponds to one statement of and the tool of to obtain their tree our experiments were run on a standard computer with a cpu on a single thread interprocedural reachability and intraprocedural shortest path in our experiments we focus on the important special case of reachability and shortest path we consider of to large size all with at least five nodes as for small the running times are the first step is to execute an interprocedural reachability algorithm from the program entry to discover all actual call to return edges en b ex b of every ai ie all invocations that actually return and then consider the control flow graphs gi independently · reachability for every gi the complete preprocessing in the case of reachability is done by executing ni one from each source node the query from u is by executing one dfs from u and the pair query u v is done similarly but we stop as soon as v is reached we note that this methodology correctly answers interprocedural reachability queries · shortest path for shortest path we perform intraprocedural analysis on each gi we assign both positive and negative weights to each edge of gi uniformly at random from the range for general semiring path properties the algorithm is a very natural one which in the case of shortest path can handle positive and negative weights as long as there is no negative cycle to have a meaningful comparison with as a representative of a general semiring framework we consider both positive and negative weights but do not allow negative cycles for complete preprocessing we run the classical algorithm which computes shortest paths and is a generalization of under no preprocessing for every and pair query we run the algorithm results our experimental results are shown in table the average treewidth of control flow graphs is to be very small and does not scale with the size of the graph in fact even the largest treewidth is four the preprocessing time of our algorithm is significantly less than the complete preprocessing by factor of to times in case of reachability and by orders of magnitude in case of shortest path in both reachability and shortest path all queries are handled significantly faster after our preprocessing than no preprocessing we also note that for shortest path queries answers and pair queries in the same time which is significantly slower than both our and pair queries finally we note that for reachability queries though we do not provide theoretical improvement over dfs table the preprocessing information allows for practical improvements since our work focuses on queries and the framework does not have this restriction a direct comparison with the framework would be in our in the experimental results for interprocedural reachability with queries we show that we are faster than even dfs which is faster than description of table in the table the second resp third column shows the average number of nodes resp treewidth of of each benchmark the running times of preprocessing are by over all in each benchmark the running times of are by over all possible and pair queries in each and then over all in each benchmark conclusions in this work we considered constant treewidth rsms since control flow graphs of most programs have constant treewidth we presented algorithms to handle multiple algebraic path queries where the weights belong to a partially complete semiring our algorithms have small additional preprocessing but answer subsequent queries significantly faster than no preprocessing both in terms of theoretical bounds as well as in practice even for basic problems such as reachability and shortest path while in this work we focused on rsms with unique entries and exits an interesting theoretical question is to extend our results to rsms with multiple entries and exists acknowledgements we thank anonymous reviewers for helpful comments to improve the presentation of the paper references n and b optimal preprocessing for online product queries technical report university r m k p t w reps and m analysis of recursive state machines acm trans program lang syst r s la and p modular strategies for recursive game graphs theor comput sci benchmarks n t interprocedural reachability preprocessing query single our complete our no our pair no intraprocedural shortest path preprocessing query single our complete our no our · · · · · · · · · · · · · · · pair no table average statistics from our experiments on the benchmark times are in s and a linear time algorithms for nphard problems restricted to partial discrete math m e and a computation of optimal subgraphs of graphs j algorithm s m e a the benchmarks java development and analysis in oopsla h dynamic algorithms for graphs with treewidth in concepts in computer science lncs springer h discovering treewidth in theory and practice of computer science volume of lncs springer h l dynamic programming on graphs with bounded treewidth in icalp lncs springer h l a guide through treewidth d k d cooper k kennedy and l interprocedural constant propagation in cc acm k and j faster algorithms for markov decision processes with low treewidth in cav k and y meanpayoff pushdown games in lics k a and y quantitative interprocedural analysis in popl s algorithms for recursive state machines in popl new york ny usa acm s and c d shortest paths in of small treewidth part i sequential algorithms t c r and c introduction to algorithms mit press b graph rewriting an algebraic and logic approach in of theoretical computer science vol b mit press cambridge ma usa p cousot and r cousot static determination of dynamic properties of recursive procedures in e editor ifip conf on formal description of programming concepts m a and t versions of the theorems of and in m j fischer and a r meyer boolean matrix multiplication and transitive closure in ieee computer society r u and r invariance of approximate semantics with respect to program transformations in rd conference of the european in d and l interprocedural constant propagation a study of jump function implementation in pldi acm j o and j the treewidth of java programs in algorithm engineering and experiments lncs springer t dynamic algorithms for graphs of bounded treewidth r for graphs journal of geometry s horwitz t reps and m sagiv demand interprocedural dataflow analysis notes t treewidth computations and approximations lncs springer j and b the interprocedural theorem in cc j b and j parallelism for free efficient and optimal analyses for parallel programs acm trans program lang syst j improved deterministic algorithms for reachability and strongly connected components acm transactions on algorithms w and b g ryder aliasing a problem classification in popl acm n a and o analysis of multiple interacting objects in oopsla j fast model checking when treewidth is bounded in cav b a finding approximate and computing tree width quickly in t reps s horwitz and m sagiv precise interprocedural dataflow analysis via graph reachability in popl new york ny usa acm t reps s s and d weighted pushdown systems and their application to interprocedural dataflow analysis sci comput program t reps a and n program analysis using weighted pushdown systems in foundations of software technology and theoretical computer science lncs n and p graph iii treewidth journal of combinatorial theory series b m sagiv t reps and s horwitz precise interprocedural dataflow analysis with applications to constant propagation theor comput sci m d l and r demanddriven pointsto analysis for java in oopsla m all structured programs have small tree width and good register allocation information and computation r p co e l p lam and v a java bytecode optimization framework in ibm press t van jp van and w computing treewidth with technical report university of x r m and h yang hybrid topdown and bottomup interprocedural analysis in pldi 