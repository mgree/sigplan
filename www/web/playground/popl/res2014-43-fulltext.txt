abstract acceleration of general linear loops inria peter university of oxford university of abstract we present abstract acceleration techniques for computing loop invariants for numerical programs with linear assignments and conditionals whereas abstract interpretation techniques typically the set of reachable states iteratively abstract acceleration captures the effect of the loop with a single transfer function applied to the initial states at the loop head in contrast to previous acceleration techniques our approach applies to any linear loop without restrictions its lies in the use of the normal form decomposition of the loop body to derive symbolic expressions for the entries of the matrix modeling the effect of n iterations of the loop the entries of such a matrix depend on n through complex polynomial exponential and functions therefore we introduces an abstract domain for matrices that captures the linear inequality relations between these complex expressions this results in an abstract matrix for describing the fixpoint semantics of the loop our approach into standard abstract interpreters and can handle programs with nested loops and loops containing conditional branches we evaluate it over small but complex loops that are commonly found in control software comparing it with other tools for computing linear loop invariants the loops in our benchmarks typically exhibit polynomial exponential and behaviors that present challenges to existing approaches our approach finds nontrivial invariants to prove useful bounds on the values of variables for such loops clearly the existing approaches in terms of precision while good performance introduction we present a simple yet effective way of inferring accurate loop invariants of linear loops ie loops containing linear assignments and guards as by the programs shown in and such loops are particularly common in control and digital signal processing software due to the presence of components such as filters iterative loops for equation solving that compute square roots roots and loops that complex supported by the project and project supported by the us national science foundation nsf under grant no all involved are those of the authors and not necessarily of the us national science foundation permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page for components of this work owned by others than acm must be abstracting with credit is permitted to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission andor a fee request permissions from popl january ­ san diego ca usa copyright c acm real and y and z loop t head · while xy loop guard x xy y yz z z loop t t exit · figure linear loop having a behavior functions using static analysis of such programs using standard abstract interpretation theory over polyhedral abstract domains often a significant loss of precision due to the use of techniques widening to force termination of the analysis however widening is wellknown to be too for such loops in fact specialized domains such as and were proposed to deal with two frequently occurring patterns that are encountered in control loops these domains enable static for control systems eg e to find the strong loop invariants that can establish bounds on the variables or the absence of runtime errors in this paper we present a promising alternative approach to such loops by capturing the effect of a linear loop by means of a socalled that maps an initial set of states to an invariant at the loop head this process is commonly acceleration the idea of was first studied for communicating finitestate machines and counter automata such can be either exact see for a survey or abstract abstract acceleration to a transformer that maps initial sets of states to the best correct overapproximation of the invariant at the loop head for a given abstract domain typically the convex polyhedra domain abstract acceleration enables static to avoid widening for the innermost loops of the program by replacing them by as discussed in and observed in abstract acceleration presents the following benefits wrt widening i it is locally more precise because it takes into account the loop body in the it performs whereas widening considers only sequences of invariants ii it performs more approximations because it is monotonic unlike widening iii it makes the analysis more efficient by up convergence to a fixed point for programs without nested loops our acceleration the program apart from abstract interpretation techniques such as symbolic execution and bounded modelchecking that are especially efficient over systems can benefit from loop acceleration in this paper we present a novel approach to computing abstract our approach is avoiding widening we focus on the linear transformation induced by a linear loop body modeled by a square matrix a we to approximate the set of matrices i a a which represent the possible linear transformations that can be applied to the initial state of the program to obtain the current state this set could be defined as fixed point equations on matrices and solved iteratively on a suitable abstract domain for matrices however such an approach does not avoid widening and from efficiency issues because a matrix for a program with n variables has n entries thus requiring a matrix abstract domain with n different dimensions contributions the overall contribution of this paper is an abstract acceleration technique for computing the precise effect of any linear loop on an input predicate it relies on the computation of the normal form of the square matrix a for the loop body being based on abstract acceleration it into an abstract analyzer and can be exploited for the analysis of general programs with nested loops and conditionals by transforming them into multiple loops around a program location the first technical contribution is an abstract acceleration method for computing an approximation of the set i a a in an abstract domain for matrices it enables the analysis of any infinite linear loop the main idea is to consider the normal form j of the transformation matrix a indeed the particular structure of the normal form j has two advantages i it results in expressions for the coefficients of jn on which asymptotic analysis techniques can be applied that remove the need for widening ii it reduces the number of different coefficients of jn to at most the dimension of the vector space efficiency issue this first contribution involves a conceptually simple but technically involved derivation that we omit in this paper and which can be found in the extended version the second technical contribution addresses loops with guards that are conjunctions of linear inequalities we present an original technique for bounding the number of loop iterations once again we the normal form these two techniques together make our approach more powerful than methods eg that are restricted to stable loops because the guard is only weakly taken into account we evaluate our approach by comparing efficiency and the precision of the invariants produced with other invariant synthesis approaches including abstract interpreters and approaches the evaluation is carried out over a series of simple loops alone or inside outer loops such as in fig behaviors such as polynomial stable and and we show the ability of our approach to discover polyhedral invariants that are sound of the reachable state space for such systems any inductive reasoning in a linear domain as performed by eg standard abstract interpretation with kleene iteration and widening is often unable to find a linear invariant other than true in contrast our approach is shown to find useful bounds for many of the program variables that appear in such loops to our knowledge our method is the first one able to bound the variables in the example of et al outline we introduce some basic notions in § § gives an overview of the ideas of this paper to explain the contributions in detail § summarizes our experimental results and § discusses related work before § concludes in this section we recall the notions of linear assertions and convex polyhedra and we define the model of linear loops for which we will propose acceleration methods real and t and t while true time in each mode while t mode t time time while t mode t time figure a system composed of two simple loops inside a outer loop linear assertions and convex polyhedra let x xp be variables forming a p × column vector x a linear expression is written as an inner product c · x c rp a linear inequality is of the form c · x d with d r a linear assertion is a conjunction of linear inequalities x written as cx d q i ci di where c is an q the assertion is matrix whose ith row is ci likewise d is an q × column vector whose jth is dj the linear assertion consisting of the single inequality represents the assertion true while the assertion represents the assertion false given a linear assertion the set x rp x is a convex polyhedron the set of all convex polyhedra contained in rp is denoted by we recall that a convex polyhedron p can be represented in two ways a the constraint representation cx d with matrix c and vector d b the generator representation with a set of vertices v v vk and r r rl x p iff kl x with i j and i j i i linear loops we consider linear loops consisting of a while loop the body of which is a set of assignments without tests and the condition is a linear assertion definition linear loop a linear loop g h a b is a program fragment of the form h x ax b where gx h is a linear assertion over the state variables x representing the loop condition and a b is the linear transformation associated with the loop body figure shows an example of a linear loop with a guard that computes y xx by the successive difference method we give another example below example figure models the operation of a that switches between the and modes over time the variables t te model the room and outside respectively we wish to show that the value of t remains within some bounds that are close to the switch points units any linear loop g h a b can be by introducing a new variable that is a place for the constant to a loop of the form while g h x x a b x we will use the notation g a to denote the linear loop while gx x ax definition semantic function the semantic function of a linear loop g a over sets of states is the functional g ax ax gx x rp where ay denotes the image of a set y by the transformation a convex and template polyhedra abstract domains the set of convex polyhedra ordered by inclusion is a lattice with the greatest lower bound being the set intersection and the least upper bound being the convex hull the definition of the domain includes an abstraction function that maps sets of states to a polyhedral abstraction and a corresponding concretization function we refer the reader to the original work of cousot and for a complete description it is wellknown that the abstract domain operations such as join and transfer function across assignments are computationally expensive as a result many domains such as and templates have been proposed given a matrix t of q linear expressions rp denotes the set of template polyhedra on t rn p u q p x t x u where denotes r a template polyhedron will be denoted by t u if t is is fixed it is uniquely defined by the vector u rp ordered by inclusion is a complete lattice the abstraction t and concretization t are defined elsewhere overview this section provides a general overview of the ideas in this paper starting with abstract acceleration techniques abstract acceleration given a set of initial states x and a loop with the semantic function the smallest loop invariant x containing x can be formally written as x x nx n abstract acceleration an optimal approximation of in a given abstract domain with abstraction function whereas the standard abstract interpretation approach to solve the fix point equation y x y by iteratively computing y x the abstract acceleration approach uses to compute z x is known as the minimal fixed point solution of the reachability problem whereas is called the solution the latter is known to yield more precise results the technical challenge of abstract acceleration is thus to obtain a approximation of that avoids both inductive reasoning in the abstract domain and the use of widening abstract acceleration without guards using matrix abstract domains we now present an overview for linear loop without guards with semantic function true a for any set x we have x nx n n our approach computes a finitely representable approximation m of the infinite set of matrices abstract acceleration simply applies m to x n an the following example illustrates the first step example exponential we consider the program xx yy of which fig some after the loops semantic function is g a here it is easy to obtain a symbolic expression of an n an n the idea for of the form n an is to consider a set of m m m mm m with m a linear assertion in a template domain such that n an m using an template for instance the following assertion satisfies the condition above m m inf n sup n n n inf n sup n m n n m m m m inf n n inf n n n n n n n n these constraints actually define the smallest on entries m m that makes m an overapproximation of a an n it is depicted in fig the technique to evaluate the nonlinear inf and sup expressions above is described in § this is the first important idea of the paper § formalizes the notion of abstract matrices whereas § will exploit the normal form of a to effectively compute a for any matrix a ie to the loop body applying the abstraction to acceleration the next step is to apply the matrix abstraction m a to an abstract element x for illustration assume that both m and x are defined by linear assertions m and x from the polyhedral domain or some domains applying the set of matrices m to x amounts to computing an approximation of m x m y mm m x x y this is not trivial as the matrix multiplication generates expressions § proposes a general approach for performing the abstract multiplication the result of the procedure is illustrated by the example that follows example exponential assume that in ex and x x y we compute the abstract matrix multiplication m · x mx m · y x y m m m m m y y y m x x figure defined by m in example light gray and by m in ex gray figure dashed starting from and in ex initial set of states x gray and invariant y ax light gray in ex figure initial set of states x gray invariant y g ax in ex light gray and the better invariant z gray discovered in ex by exploiting the number of iterations x y x y x y x y y where y is the result obtained by the method described in § and is depicted in fig handling guards we consider loops of the form g a and how the loop condition guard g is handled a simple approach takes the guard into account after the fixpoint of the loop without guard is computed g ax x g a g ax which is then abstracted with x g a g ax however such an approach is often example exponential we add the guard y to our running ex using the approximation above with x as in ex we obtain the invariant y depicted in fig in this result y is bounded but x remains unbounded our idea is based on the observation that the bound on y induced by the guard implies a bound n on the maximum number of iterations for any initial state in x once this bound is known we can exploit the knowledge x the better approximation n n nx and consider n g ax x g a g an x n n the set of matrices an is then approximated in the same way as a in § we perform an iterative computation for small n however a polyhedral analysis without widening operator is expensive for or iterations while our method is both precise and efficient example exponential in our running example it is easy to see that the initial condition y together with the guard y implies that the maximum number of iteration is n n thus we can consider the set of matrices m an de by the following assertion satisfies the above m m inf n sup n n n inf n sup n n n m m m m inf n n inf n n n sup n n sup n n n n n which is depicted in fig using the formula above we obtain the invariant z depicted in fig which is much more precise than the invariant y discovered with the simple technique § presents the technique for the number of iterations of a loop where the guard g is a general linear assertion a is any matrix and x any polyhedron this is the third main contribution of the paper an comparison the capability of our method to compute of the reachable state space goes beyond invariant inference techniques the following table lists the bounds obtained on the variables of the of ex fig for some techniques e this paper t t t t time time time time t t t t time time time time there are many other invariant generation techniques and tools for linear systems see § many approaches precision for speed and therefore are on the type of linear loops considered here other more specialized approaches require conditions such as of the matrix polynomial behavior or monoidal property or handle only integer loops outline of the rest of the paper the rest of the paper the ideas illustrated in this section § formalizes the notion of matrix abstract domains and presents a technique for the abstract matrix multiplication operation § shows how to approximate the set to of matrices a loops an for guards any § square matrix a in order presents a technique for taking the guard of loops into account by n the maximum number of iterations possible from a given set of initial states § presents the experimental evaluation on various kinds of linear loops possibly embedded into outer loops § discusses related work and § concludes matrix abstract domains in this section we present abstract domains for matrices we will use abstract matrices to represent the abstract transformer of a linear loop hence the main operation on abstract matrices we use in this paper is abstract matrix multiplication § extending abstract domains from vectors to matrices we abstract sets of square matrices in by them as vectors in rp and by known abstract domains over vectors however since the concrete matrices we will be dealing with belong to of we first introduce matrix shapes that allow us to reduce the number of entries in abstract matrices definition matrix shape a matrix shape rm is a linear map from vectors to p × p square matrices intuitively matrix shapes represent matrices whose entries are linear or affine combinations of m entries example in ex we implicitly considered the matrix shape r m m m m the set m m rm represents all possible matrices that can be formed by any vector m it represents a of the vector space of all matrices a matrix shape induces an isomorphism between rm and am am am am abstract domain for matrices are constructed by a choosing an abstract domain for vectors m and b specifying a matrix shape given an abstract domain a for vectors m eg the polyhedral domain and a shape the corresponding matrix abstract domain defines a domain over subsets of example recall the matrix shape r from ex consider the p m m m m mm oct r together they represent an abstract matrix p which represents the set of matrices m m m m m m m m definition abstract domain for matrices induced by let a rm be an abstract domain for vectors ordered by set inclusion and with the abstraction function a rm a then a ordered by set inclusion is an abstract domain for with the abstraction function am a m note that since is an isomorphism the lattices a and a can be shown to be isomorphic for generality the base domain a can be an arbitrary abstract domain for the data type of the matrix entries in our examples we specifically discuss common numerical domains such as convex polyhedra intervals and templates abstract matrix multiplication we investigate now the problem of convex polyhedra matrix multiplication motivated by the need for applying an acceleration a to an abstract property x as shown in § the problem we consider two convex polyhedra matrices ms we aim at computing an approximation of m mm mm m m m m under the form of a convex polyhedron on the coefficients of the resulting matrix observe that m may be as shown by the following example example consider the two abstract matrices m m m m m n n n we have mm m n mn m n this corresponds to the wellknown non convex set of points x y x y x y depicted to the right we may follow at least two approaches for mm · either we consider the constraint representations of m and m and we to optimization techniques to obtain a template polyhedra approximation of the product · or we consider their generator representations to obtain a convex polyhedron the product we in this paper for the second ie the generator approach which leads to more accurate results ­ it general convex polyhedra more expressive than tem polyhedra obtained by optimization ­ it computes the best correct approximation in the convex poly domain for bounded matrices thm below whereas in the constraint approach the exact optimization problem involves expressions see or ex and must be relaxed in practice abstract matrices using generators given two finite sets of matrices x x xm and y y yk we write x y to denote the set x y xi x yj y if ms is expressed as a system of matrix vertices matrix rs s then vs and ms is is and can be rewritten js js is js is is m mm ii i i vi vi ij i j vi rj ij j i rj vi jj j j rj rj we obtain the following result i j i j i i i i theorem let m and m be two abstract matrices expressed as a system of vertices and v r for m and v r for m the matrix polyhedron m defined by the set of vertices and the set of v v v r v r r v r r is an overapproximation of m mm moreover if m and m are bounded ie if r r then m is the smallest polyhedron matrix containing m proof for the first part of the theorem we observe that in positive and and the other similar sums are m m ii ii vi vi ij ij vi rj ij ji rj vi ii ij ji jj jj jj rj rj ii ii which proves the first statement now assume that r r which means that both m and m are bounded and that r we will show that all the generator vertices of m belong to m hence any of their convex combination ie any element of m belongs to the convex closure of m consider the generator vertex vi vi is is v of m by sis for s taking m and example in ex we the unbounded set of matrices m depicted in fig and defined by vertices and by the bounded set of vectors x depicted in fig and generated by vertices which in the convex polyhedra y depicted in fig which is generated by vertices and we omit redundant generators regarding complexity this operation is quadratic wrt the number of generators which is itself exponential in the worstcase wrt the number of constraints in practice we did not face complexity problems in our experiments apart from the example described in § observe that by using generators and applying thm we lose information about matrix shapes in our case we will perform only abstract multiplication hence the number of entries of the product matrix actually a vector will be the dimension of the space rp the multiplication of an abstract matrix m and a concrete matrix r mr or rm can be computed exactly by considering the generators of m abstract acceleration of loops without guards in this section we consider loops of the form ax given an initial set of states x at the loop head the least inductive invariant at loop head is ax n n z our goal is to compute a template polyhedra matrix m such that t a m given a template t on the coefficients of the matrices m a the key observation underlying our approach uses a wellknown result from matrix algebra any square matrix a can be written in a special form known as the normal form using a change of basis transformation r a and j such that for any n an rj nr and j n as a result instead of computing an abstraction of the set a i a a a we will abstract the set j i j j j the block diagonal structure of j allows us to symbolically compute the coefficients of jn as a function of n § presents details on the form and the symbolic representation of jn the form of j immediately the matrix shape m and the matrix containing j we then consider a fixed set t of linear template expressions over m we use asymptotic analysis to compute bounds on each expression in the template § explains how this is computed once we have computed an abstraction m j we will return into the original basis by computing to obtain an abstraction for a which is the desired loop acceleration in this section we assume arbitrary precision numerical computations the use of finite precision computations is addressed in § the real normal form of a matrix a classical linear algebra result is that any matrix a can be transformed in a real normal form by considering an appropriate basis j jr ps s i j a r r js jr s i s with s s and i if s is a real of m or s s s s sin s s sin s s s and i if and are complex of m with s and s the form is useful because we can write a expression for its nth power jn each block is given by ns n ns ns n sn n ps n ns ps ns sn and ns sn or ns ns sin ns sin ns ns with the convention that n k for k n hence coefficients of have the general form r kn n k nk k r with r and k in which r enables converting the into a the precise expressions for r k as functions of the position i j in the matrix j are omitted here to preserve the clarity of presentation next we observe that the closed form specifies the required shape for abstracting for all n for instance if s is a real we have s m m m m m m m likewise m for the entire matrix jn is obtained by the union of the parameters for each individual proposition given the structure of the real normal form j we may fix a matrix shape m such that j i j j and m rm with m p where p is the dimension of the square matrix j hence we will work in a matrix the dimension of which is less than or equal to the number of variables in the loop this reduction of dimensions using matrix shapes is essential for our technique to be useful in practice abstracting j within template polyhedron matrices the principle let us fix a template expression matrix t composed of linear expressions t tq on parameters m knowing the symbolic form of each jn we obtain a symbolic form mn jn for parameters m hence a symbolic form for linear expressions tj · mn by deriving an upper bound m y m x figure on the lefthand side the on the two coefficients of the matrices an n of ex that defines the approximation m an n on the righthand side the image mx in light gray of the box x in gray by the set m using the method of § uj for each n we obtain a sound approximation of the set mn n and hence of j theorem abstracting j in template polyhedron matrices the template polyhedron matrix t j t m u with u t mn is the best correct overapproximation of j in the template polyhedra matrix domain defined by t moreover any u u defines a correct approximation of j proof j n jn n mn mn n considering the matrix t and referring to § t mn n m t m sup t m n m t m sup t mn m t m u n the approximation of the set of matrices j reduces thus to the computation of an upper bound for the expressions computing upper bounds to simplify the analysis we restrict template expressions tj to involve at most parameters from m as each mk in matrix jn is of the form of we have to compute an upper bound for expressions of the form n k n k k r n k n k k r with r computing bounds on this expression is at the of our technique however the actual derivations are tedious and do not contribute to the main insights of our approach hence we omit the detailed derivations and refer to the extended version for details the main properties of the technique we implemented are that it computes ­ exact bounds if the two involved are real ­ exact bounds in reals if k k and reasonable bounds if k k is replaced by k k ­ no interesting bounds otherwise because they are just the linear combination of the bounds found for each term concerning the choice of template expressions in our tion we fix a parameter and we consider all the expressions of the form cf ± mj with k k the choice of corresponds to expressions examples in ex and fig we showed the approximation of a set a using template expression with the matrix a being a normal form with real and for instance consider the expression mm nn in example which in the first case above we look at the derivative of the function f x x x we infer that x f x by appropriately f t hence we can compute the least upper bound as n n next we give another example with complex example take a and b sin with and consider the loop xx the see fig right of this loop follow an the loop body transformation is sin a sin with a already in real normal form the matrix m m containing a is of the form m m m we have mn n n and mn n sin n applying our bounding technique on template constraints on m we obtain an approximation m of a defined by the constraints m m m m m m consider for example the expression m m n sin n in example below which into the second case we first rewrite it as being decreasing the x hence we can consider the upper bound n n the possible values m m are in fig right assuming an initial set x x y we compute mx to be the polyhedron depicted in fig right in this section we have described the computation of a correct approximation m of j in the template polyhedron domain from which we can deduce a correct approximation of a applying thm we are thus able to approximate the set ax of reachable states at the head of a linear loop ax with the expression where x is a convex polyhedron describing the initial states abstract acceleration of loops with guards in this section we consider loops of the form x ax modeled by the semantic function g a as explained in § given an initial set of states x we compute an overapproximation of y g ax using a convex polyhedral domain which after unfolding is expressed as y x an x n kn the unfolding effectively computes the precondition of the guard g on the initial state x as the simple technique the expression g a in is too complex to be precisely a simple technique to approximate it safely is to exploit the following inclusion proposition for any set x and linear transformation g a g a id g a g a finally take into account the guard acceleration without guard ga x a original loop x a g id ga id b approximation figure original loop and approximation in term of invariant in accepting location prop fig illustrates prop the invariant attached to the accepting location of fig a is included in the invariant attached to the accepting location of fig b it is interesting to point out the fact that the abstract acceleration techniques described in make assumptions on the matrix a and exploit arguments so that the inclusion becomes an equality the idea behind prop is applied to matrix abstract domains to yield prop proposition let a with j a real normal form t a template expression matrix m rt jr and x a convex polyhedron then g ax can be approximated by the convex polyhedron x g a m x g this approach essentially consists of partially unfolding the loop as illustrated by fig b and abstract acceleration without guard however since the guard is only taken into account after the actual acceleration precision is lost regarding the variables that are not constrained by the guard ex and figures and in § illustrate this y is constrained by the guard whereas x remains unbounded computing and exploiting bounds on the number of iterations to overcome the above issue we propose a solution based on finding the maximal number of iterations n of the loop for any initial state in x and then to abstract the set of matrices a an instead of the set a the basic idea is that if there exists n such that an x g then n is an upper bound on the number of iterations of the loop for any initial state in x bounding the number of iterations is a classical problem in termination analysis to which our general approach provides a new original solution the following theorem formalizes this idea we assume now a guarded linear transformation g j where j is already a normal form theorem given a set of states x a template expression matrix t and the set of matrix m t j we define g m m x x g gm x n jn g with the convention min g is the set of matrices m m of which the image of at least one input state x x satisfies g if n is bounded then n g g n proof as jn m g we have x x g x or in other words jn x g this implies that g jn x g and g the definition of g and n in thm can be in the space of vectors using the matrix shape theorem under the assumption of thm and considering mn jn we have g m m x x x g n mn g our approach to take into the guard is thus to compute a finite bound n with and and to replace in m r · t j · r with m r · t jn n n · r and r the basis transformation matrix see prop example in our examples we had mn jn n n m m m mm mm see fig light gray x x y see fig gray and g y the second term of the intersection in evaluates to m thus g m m m m m m this gives us through the bound n on the number of loop iterations the abstraction m t jn n depicted on fig gray removes those matrices from m that do not contribute to the acceleration result due to the guard finally we using m and obtain the result shown in fig gray more details about these computations are given in the next section technical issues applying and requires many steps first we approximate g see and then as a second step we can approximate the maximum number of iterations n according to finally we have to compute t jn n n g let us denote q g and p m q is defined in by the conjunction of quadratic constraints on x and m followed by an elimination of x exact solutions exist for this problem but they are costly the alternative adopted in this paper is to approximate q by x on the bounding box of x g instead of it on x g let us denote the bounding box of a polyhedron z with the vector of intervals z z we have q p m x x x g x g p m g x g q q is defined by p with constraints on m and it is much easier to compute than q one can use · algorithms for interval linear constraints in particular inter val linear programming or · the linearization techniques of that are effective if the vectors m are by p in this paper we exploit the last method which is implemented in the library example coming back to our running examples and we have m g x g m m m m hence q p m p m the maximum number of iterations n computing n as defined in is not easy either because the components of vector mn are functions of defined by our approach is to exploit a matrix of template expressions proposition under the assumption of thm for any polyhedron q q and template expression matrix t n min n j tj · mn sup tj · m mq proof we have q q t q from q t q it follows mn t q mn q and mn t q mn q n mn t q is equivalent to j tj · mn sup tj · m mt q and sup tj · m sup tj · m hence we get the result mq mt q in our implementation we compute such a q as described in the previous and we choose for t the template matrix t considered in § to which we may add the constraints of q the computation of such ultimately relies on the method for solving equations our tion deals with the same cases as those mentioned in § and in other cases safely returns nj we refer to the extended version for details example coming back to examples and and con tj we have tj · n n n ej sup tj sup m mq mq and nj tj · mn ej which proves that is an upper bound on the maximum number of iterations of the loop as in ex computing t jn n n if no finite upper bound n is obtained with prop given an input polyhedron x then we apply the method of § otherwise we replace in the set m t a with m t jn n n this set m can be computed using the same technique as those mentioned in § and detailed in or even by enumeration if n is small ex and illustrate the invariant we obtain this way on our running example example running example with more complex guard coming back to examples we consider the same loop but with the guard x y represented by the matrix compared to ex we have now g x g m m hence if p is defined by m as in ex q p m m p m m linearization based on p m m m using q to bound the number of iterations according to leads to n obtained with the template expression tj from the guard at last we obtain the invariant z depicted in fig if instead of template expressions with in we choose we do not improve the bound n but we still obtain the better invariant z on fig summary we summarize now our method in the general case given a guarded linear transformation g a with j the real normal form of a its associated matrix shape a template expression matrix t and a convex polyhedron y xy z z x figure initial set of states x gray loop invariants z light gray and z gray obtained in ex x representing a set of states we compute an overapproximation g ax with x g a rm y where y rx g p t j q p y n approximated by some n using prop m t j t jn n n if n otherwise implementation and experiments we implemented the presented approach in a prototype tool evaluated over a series of benchmark examples with various kinds of linear loops possibly embedded into outer loops and compared it to invariant generators implementation we integrated our method in an abstract based on the library we detail below some of the issues involved computation of the normal form to ensure soundness we have taken a symbolic approach using the computer algebra software for computing the normal forms and transformation matrices over the field of algebraic numbers the matrices are then approximated by safe enclosing interval matrices loops with conditionals loops of which the body contains conditionals like if c x ax else x ax can be transformed into two around a head location that are executed in nondeterministic order we iteratively g a head g c a of to use widening yet practical experience shows that in many cases a fixed point is reached after a few iterations nested loops we could use a similar trick to transform nested loops ax x ax into multiple linear by adding a variable y initialized to to encode the control flow gx y x x y gx y x ax y gx y x ax y however the encoding of the control flow in an integer variable is because of the convex approximation of the polyhedral characteristics name type var examples with single loops i i i i exp div i i inv i i i i i examples with nested loops inferred bounds j j vs to to j vs analysis time sec j to to to to loop has complex or not loops guard size of largest blocks var nb of variables nb of bounds to be inferred at all control points nb of finite bounds inferred by and our method j j vs vs xyz nb of infinite bounds finite nb of improved finite bounds nb of less precise finite bounds omitted if obtained with our method over analysis time running times seconds with corresponding to computation of the normal form using and the analysis itself and j being the sum of these two times to means time out after one table experimental results abstract domain this transformation causes an loss of precision for this reason we only inner loops in nested loops situations our experimental comparison shows that computing precise of inner loops greatly improves the analysis of nested loops even if widening is applied to outer loops evaluation benchmarks our benchmarks listed in table include various examples of linear loops as commonly found in control software they contain filters and that correspond to various cases of linear transformations real or complex size of blocks and are loops with polynomial behavior similar to fig exp div is ex and is ex inv is the classical model of a balanced in position by of the it is on is a and models a that is only in a range around its lowest position as if it was the ground for example this is modeled using several modes in a leading car is followed by one or more trying to maintain their position at m from each other car car car x x x the equations for n following are for all i n cx i x i xi we analyzed a version of this example to show that there is no and to compute bounds on the relative positions and of the this example is interesting because the real form of the loop body has blocks associated to complex of size n all benchmarks have nondeterministic initial states typically bounding boxes some benchmarks where analyzed for different sets of initial states indicated by suffix ix comparison existing tools can only handle subsets of these examples with reasonable precision we compared our method with · that implements standard polyhedral analysis with widening · that implements the method of a comparison with the e tool on the example has been given in section a detailed comparison between various methods described in § is shown in table results table lists our experimental results we compared the tools based on the number of finite bounds inferred for the program variables in each control point where applicable we report the number of bounds precise finite bounds inferred by our tool in comparison to the other tools we note that our analysis improves the accuracy over the two techniques on all the benchmarks considered it generally provides strictly stronger invariants and is practically able to infer finite variable bounds whenever they exist for instance for the example fig we infer that at least and at most seconds are spent in mode and to seconds in mode just reports that time is nonnegative and is able to find the much weaker bounds and on the examples our method is the only one that is able to obtain nontrivial bounds on and yet this comes at the price of increased computation times in general is significantly faster on all examples is faster on half of the benchmarks and significantly slower on the other half for two examples does not terminate within the given timeout of one whereas our tool gives precise bounds after a few seconds it must be noted that part of the higher computation time of our tool is a for computing loop that can pay off for multiple applications in the course of a of our approach in a tool such as e in all but two of the examples the exceptions being i the cost dominates the overall a detailed account of the benchmarks and the obtained invariants can be found on type of linear transformation i sk i polynomials i i r sk i c sk sk i i loop guard handling abstract domain examples exp div inv exp div exp div linear relational abstraction this paper yes yes no yes yes yes yes no no no yes no yes no no if i no if i yes no if i no no no yes no no no no if i yes no no no no no yes yes partially no yes yes polyhedra polyhedra yes yes template polyhedra no yes no yes polynomial equalities polyhedra sk is the size of a block and i its associated table classification of linear loops and the capabilities of various analysis methods to infer precise invariants cost of our analysis all in all computation times remain reasonable in the view of the gain in precision related work invariants of linear loops the original abstract acceleration technique of et al precisely abstracts linear loops performing translations and some other special cases the affine derivative closure method approximates any loop by a translation hence it can handle any linear transformation but it is only precise for translations the tool uses constraint solving techniques for invariant generation but it is restricted to integer programs methods from linear filter analysis target stable linear systems in the sense of stability these techniques consider domains unlike our method they are able to handle inputs but they do not deal with guards designs specialized domains for first and second order filters these methods are implemented in the e tool computes interval bounds for composed filters et al present a method based on programming that infers both shape and ratio of an that is an invariant of the system in contrast our method does not impose any stability requirement et al describe a method implemented in the tool for computing single inductive polyhedral invariants for loops based on nonlinear constraint solvers it is a computationally expensive method and in contrast our approach is able to infer sound polyhedral for loops where the only inductive polyhedral invariant is true relational abstraction methods aim at finding a relation between the initial state x and any future state x in continuous linear systems which is a problem similar to the acceleration of discrete linear loops the invariants are computed based on quantifier elimination methods over real arithmetic in contrast to our method they handle only matrices a proposes a similar approach for discrete loops all these works compute a template polyhedral relation between input and output states and do not take into account the ac input states hence in contrast to our method they are unable to capture accurately and behavior strategy iteration methods ­ compute best inductive invariants in the abstract domain with the help of mathematical programming they are not restricted to simple loops and they are able to compute the invariant of a whole program at once however they are restricted to template domains eg template polyhedra and quadratic templates and hence unlike our method they are unable to infer the shape of invariants the tool infers loop invariants that are polynomial equalities by solving the recurrence equations representing the loop body in closed form the class of programs that can be handled by is incomparable to that considered in this paper whereas handles a subset of nonlinear polynomial assignments our work is currently restricted to linear assignments in contrast we take into account linear inequality loop conditions and can compute inequality invariants bounding loop iterations many papers have investigated the problem of bounding the number of iterations of a loop either for computing widening by linear termination analysis using ranking functions or for analysis based on solving recurrence equations and propose a method for computing time intervals where a linear continuous system a given safety property their method can handle complex by performing the analysis in the coordinate space however they can only deal with systems all these methods assume certain restrictions on the form of the linear loop whereas our approach applies to any linear loop conclusion we presented a novel abstract acceleration method for discovering polyhedral invariants of loops with general linear transformations it is based on abstracting the transformation matrices induced by any number of iterations polyhedral matrix multiplication and a method for the number of loop iterations that also works in case of exponential and behavior our experiments show that we are able to infer invariants that are out of the reach of existing methods the precise analysis of linear loops is an essential feature of static for control programs precise loop invariants are equally important for alternative verification methods based on model checking for example further possible applications include termination proofs and deriving complexity bounds of algorithms work in this paper we considered only closed systems ie without inputs however important classes of programs that we want to analyze eg digital filters have inputs hence we are extending our methods to loops of the form gx h x ax b with inputs similar to moreover our method easily generalizes to linear continuous systems eg representing the modes of a hybrid automaton by considering their solution xt references c alias a p and l program termination and complexity bounds of flowchart programs in sas volume of lncs pages ­ c f and f a modular static analysis approach to affine loop invariants detection in volume of pages ­ s a j and l fast acceleration from theory to practice ­ b p cousot r cousot j l a d and x a static analyzer for large software in pldi pages ­ acm b and p symbolic verification of communication protocols with infinite state spaces using in cav volume of lncs july l chen a j wang and p cousot an abstract domain to discover interval linear equalities in volume of lncs m s and h linear invariant generation using nonlinear constraint solving in computer aided verification cav volume p cousot and n automatic discovery of linear among variables of a program in symposium on principles of programming languages popl pages ­ p cousot and n automatic discovery of linear among the variables of a program in popl pages ­ p cousot r cousot j l a and x why does scale up p and l invariant generation for c programs with and ­ j static analysis of digital filters in esop volume of lncs pages ­ j numerical abstract domains for digital filters in numerical and symbolic abstract domains a and j how to compose applications to broadcast protocols in volume of lncs pages ­ s e a and s static analysis by policy iteration on relational domains in esop volume of lncs t m and h precise relational invariants through strategy iteration in computer science logic volume of lncs pages ­ springer t m h a s and abstract interpretation meets convex optimization journal of symbolic computation ­ l and n combining widening and acceleration in linear relation analysis in sas volume of lncs a gupta and a rybalchenko an efficient invariant generator in cav volume of lncs pages ­ j m and a a new weakly relational domain in automated technology for verification and analysis volume of lncs pages ­ springer b and a a library of numerical abstract domains for static analysis in cav volume of lncs pages ­ b m and g the interprocedural analyzer b p and s abstract acceleration of general linear loops abs j b and j d ullman monotone data flow analysis frameworks informatica ­ j l and j symbolic loop bound computation for analysis in of systems volume of lncs pages ­ springer l invariant generation for loops with assignments in volume of lncs pages ­ g g j and s symbolic reachability computation for families of linear vector fields ­ p and m the theory of matrices nd edition academic press a the abstract domain in ast in ieee pages ­ ieee cs press october a symbolic methods to the precision of numerical abstract domains in volume of lncs pages ­ d compositional analysis of floatingpoint linear numerical filters in cav volume of lncs pages ­ d automatic modular abstractions for linear constraints in popl acm j of systems of interval linear equations and inequalities in linear optimization problems with data pages ­ p r pl and e a generic abstract domain for linear time invariant systems in pages ­ acm s and a relational abstractions for continuous and hybrid systems in cav volume of lncs pages ­ springer s h b and z manna analysis in sas volume of lncs pages ­ s h b and z manna scalable analysis of linear systems using mathematical programming in volume of lncs p and b abstract acceleration and application to the verification of dataflow programs in sas volume of lncs pages ­ p and b applying abstract acceleration to analysis of reactive programs journal of symbolic computation ­ a simon and a widening polyhedra with in prog languages and systems volume of lncs a approximate reachability for linear systems in volume of lncs pages ­ springer h and g j geometric programming for linear system reachability in control conference pages ­ 