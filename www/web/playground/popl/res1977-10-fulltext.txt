evaluation and the value graph by john h and r center for research in computing technology university this paper i s with difficult global which require the symbolic evaluation of w use as is in global analysis a model in which the expressions are specified bu t the of is ed o by a directed graph whose nodes are block s of assignment statements we s how that if a is interpreted in the of integer arithmetic then many natural global are we then develop a direct values for method for finding expressions general symbolic our method r to an i method due to and a direct method due to and unman e means of a structure called the global va lu e which represents both symbolic values and the of these values the w are able to obtain results that are as strong a s e of these algorithm at a lower time cost to all graphs introduction th is paper is concerned with the problem of symbolic ation model of in the context of a thus the only statements in the language in the model are e lefthand sides are variables and whose righthand sides are expressions built up from fixed sets of variables function and constant the language does not for sw ra ti and all i control is reduced to a directed graph which block s of assignment may be reached which others but giving no tion t the ti under research research by grant by nsf grant which such branches t occur in this context we ms an by symbolic evaluation the task of ring for each expression t in the program text an expression for the value of t which is valid for all possible executions of the program such an on o will be said to cover t note that al ns located at different in the program text may have different covers thus t must be considered th its location in the program to be such an expression t considered as located at a particular position in the program on is called a text presents expression for the efficiency of code derived text bu t not all of expression optimizations reduce to the problem of constructing rs for text expressions a text expression t is constant if t has a cover which is a constant sign the point of a text expression t is the st node in the graph relative to the partial ordering of nodes by on discussed at which the computation of t is defined any node n ot the fl graph relative to this ordering the birthpoint of t and the original location of t has a cover for t in terms of covers for the variables the node n with the further pr q that the computation of t induces no nw errors at node n is called the of t the ion of t my safely be moved to the int n node n the text expression appropriate at not be identical to t the safety of code movement is also discussed in ca g text respect to expression tl text expression is t if redundant tl occurs wi th in the block as t and tl is covered by the formula as t a cover for a global variable on exit from a node in a loop is a invariant this problem in detail in and and the available expressions at node n are the c which on every path the start node to n t u have a c ke ke s been developed for ng we versions of global fl m problems where the transformations through blocks can be by bit vector operations expression y give the easier considerably more code improvements powerful result w than s demonstrate that it is not possible in general to c exact of expression tion problems in the tic in and have recently that t here exist global problems in certain global a sis which are solvable it follows that we must lock for heuristic methods for good but not optimal tions to these problems in order to ar methods with others we must fix the relevant parameters of the program and fl a graph w let n and a be the cardinality of the node and edge sets of the graph we let u be the number of variables in the and let l be the length of the program text our careful ion of the l avoiding for example r repre of the expression i s one of the n lt of our authors have analyzed their algorithms primarily the point of view of the graph parameters n and a if w into the programming language a construct for the declaration of es local to a b lock then the o here be the number of qq for the of simplicity not make this refinement but the interested we do reader will have no difficulty in cur time be in this way presents an based on an i method for a te tions to on optimization a version of the used for the di o f c text may r steps and operations on bit vectors of h q fx is a function bounded below by for some k see and fu show that the on c of t text expressions wk will be called constants figure give example of a text expression which is constant is not a constant figure my also be used a certain class of covers which we w call fixed give point covers another based c direct tive w which gives results than algorithm and is to reducible graphs require qn elementary steps and may log steps a main of both these is in the representation of rs directed acyclic graphs dags are used represent but separate dags are at each node of the graph since a a cover may be of size ql the tc space cost may be operations these dags which are considered to be extend steps by and cost elementary steps and cannot be by fixed number of bit vector operations in any which attempts for symbolic to p information separately each node of the flow graph will have time cost q a s the on every pair of nodes must be since l z n sh at cost is table for al applications the global used in t paper is related to a ture used to represent the of va through the program the use of the leads t relatively efficient direct method for evaluation works for all graphs method derives its efficiency by representing rs with a single dag rather than a dag at each node in general the is of s although as described in section in m o f ts these are the c found by is linear in the size of the and the cost of our a for finding mi fixed covers is linear in the size of the our a wo for all thus our for symbolic evaluation takes the linear in many cases as to which may require fl fn steps graph theoretic notions a g v e consists of a set v of elements of nodes called called nodes eds and a set the edge e of ordered u v pairs m u and enters v predecessor of v and v is a of u the of a node v is the number of sw of v and the e is the in of predecessors of v a path from sequence of nodes p u vi v s where vi c e for all ii the path k the p is a length if u of the w path p is k a node u is reachable a node v if either u v or there is a path u to v w shall require sorts of special a rooted v e r is a triple sh that v e is a and r is a distinguished node in v the that r has no predecessors and every node in v is reachable rw a ii labeled if it is augmented with a whose is the vertex set a is a with an ordering or the edges from each node a g is acyclic if g contains no lie otherwise let g be acyclic a of a node v is called a qq of v the nodes of g have a partial ordering called a of g under which each n precedes all its sons a rooted acyclic t is a if every node v other than the root has a unique reachable predecessor the of from v i n t u is a descendant v if u is of v and v is a ancestor of u ordering of a tree is the reverse of a topological called a a spanning of g v e is a tree with node set v and an edge set contained in e let g v e r be a rooted a node u d a node v if u k v and every path the root to v includes u it is easily s that there is a unique tree tg called the of g that u v in g iff u f v and u is an ancestor of v in tg we write u v if there partial is a path order u to v in tg thus is a all of the above properties of may be very e an ith has linear m c if the input of length runs n and has in time linear on on time cost if the runs in time on an where a is the extremely growing of t a is related to a inverse of ion using lists a graph with v nodes and e edges my be represented in space gives a linear time for a ordering of an acyclic tarjan tl gives a linear time for a spanning tree and in t gives an linear tree time for of a rooted computing the the global flow let p be a program to which we wish to apply va global code improvements in this section we formulate a global model for p similar to a model described by aho and the execution f program graph f n a s is a rooted a t the is a path will denote start in node s f beginning the partial s n at order an s by with t to the fixed rooted as described in section associated with e node of the program graph is a block of assignment statements these blocks do not contain ti or b statements c information is specified by the program graph program variables are taken from the set xx a t is an expression bu from program variables and fixed sets c of and ei of function the text expression t is considered to be located at a particular line of code in block e n thus two ly al located in different blocks or even in different lines of the block will be considered distinct text expressions an assignment nt is of the fo m xt where x is a program and t is a text on let x be the set of program we introduce r set of xx to denote the values of p va xn xn or variables on u to nodes let exp be the set of expressions over c e and the variables in the set zn thus u c exp is a finite expression consisting of either a constant symbol c s c a symbol xn representing the value of global input to node n or a function symbol eq to a e of expressions in hp the covering expressions are expressions in exp now w define which is the point at which all the referred to in q are defined let na u n i the symbol xn occurs in a if is empty then s and otherwise is the minimum node in na relative to the need not exist for ns in but will be welldefined in all the relevant cases ie birthpoint exists for all covers of text expressions an interp i for the program p is an o pair u the universe u contains a distinct value c for each constant sign c c c for each function sign d e there is a unique operator e which maps in uk into u also c f c for each distinct cl every constant has at most one a is in the tic if it has the interpretation z where z is the set of i and o i e the arithmetic operations of addition multiplication and integer division an expression in exp is put in reduced by r for each subexpression of the form c ec c a constant sign c that no further substitutions of this kind can be made it will be useful to a a relation z that for any expressions al a s ex f al iff al and a have the same reduced form we take as described supply definitions given functions and trust that if he chooses v and n as the reader can for each text expression t let t be an expression in exp represents the value of text expression t in t of the values of the global on input to ie in terms of the for example if the block of code at node n of p is xx y y z xy and t is the expression x y located in this b lock then t ms assume the b lock s are reduced in the sense of aho and so that yt t t if t and t are t text expressions also for each n e n and x e z let nx be an expression in exp for the value of x on from n in terms of the values of global on input to n in the example just given ny yn a global a triple f z i where f is a program graph z is the set of program va on and i the next u de is an deal with a global system h f z i let a be an expression in u s nl nk be an execution path containing then na s expression s nl n nk and p is for the value of a in the context an of this execution path p is de as po a where po u s i s k let pi s nl ni then la pi where a is obtained z a by il x for for all x c if t is a text expression located at node n t p represents the value of the text expression t after execution of path p from s to node n an expression a c exp covers a text expression t if ta loc t for every execution path p from p p s to the second represents c the value that a of t on every execution path reaching note that the birthpoint of any cover a of a text expression t is always well defined since the of na will form a chain relative to a cover is a ma for symbolic evaluation f r an the text expressions of p to expressions in exp in reduced form that for each text expression t covers t is minimal if for each a which covers text expression t in the introduction we gave a number of global fl m problems which reduce to the problem of determining c of text expressions our first result is a negative one which rules out the possibility of finding minimal c even in simple in the tic the problem of discovering all text covered ty is undecidable proof let x xl x xk be a set of variables has shown t the of determining if a k qx ix xk has a root in the natural is the method of proof will be to reduce this problem to that of the discovery of constant text expressions js x o x figure consider the graph in figure let t be the text xk located at node f and let a be the cover of t in t of the value of the variables on input to f for any path p from s and o k let be the value of xl just on observe that for any of natural entering numbers f z t here is an execution path s to f that z xl px p xk p q has a root in the numbers say zl z then it is possible to find execution paths p and q to f sh that zi xi p for all i i f k that xo p o and xo q since p z o and q t is not a constant text expression q has no root in the natural numbers then for each path p to f px p xk p i o so p o t is constant thus following global in the arithmetic problems the are discovery of and safe of code motion redundant available proof discovery each of text expressions expressions it is easy to show of constant text these problems n loop ts and that the problem reduces of to the above results indicate that we must look for methods for approximations to minimal c rs the method of may be applied to compute a class of covers which we call fixed covers so called because they are fixed of an i mapping n exp extended process let t be a to a mapping ex p exp so that a is the reduced expression derived a substituting for each xn c zn in a a is a mapping too for some such t with the that for each xn c zn either xn or n a s and tm x for every predecessor m of n in f that is either xn and t gives no information the value of x entering node n or case holds and represents the output value of x on exit from a nodes from which n can be reached by one edge that t is in fact a cover in this case is proved by s first show p u p for all expressions a e exp with a defined int and execution paths p containing proof by c let a be an expression in ex p with a minimal birthpoint n that a p p for some execution path p nk containing n thus a must have a sub expression of the f rm w such that xn p p the case xn xn is clearly impossible so n i s otherwise let ni be the last occurrence of node nil i then xn p mx p by definition of t p by our tion of the of the birthpoint of a and since n p by definition of eval which wi th our tion that xn p p theorem t is a cover proof by p p for all execution paths p to nw call a a minimal if t for all text expressions t and all then while the problem of finding minimal covers is that of finding fixed point covers is not only solvable but can be done efficiently as stated in the introduction and described the main purpose of this paper is to establish that a minimal fixed theorem for finding we in section point cover exists and is and to give an efficient it section to this end the global value graph and show in sections derive these result it can be used to and the global value graph in this section global section n we continue to assume a f e i a s as fixed in a labeled d v e l is a labeled acyclic with a node set v an edge list e giving t he order of edges nodes and a labeling the l of the nodes listing in v let of the labels be of the sub graph of d rooted at r xn where d r a xn the dag d is minimal if rd is any expression or set of expressions may be represented labelled dag dn dag vn no redundancy by a minimal d in particular w use the minimal en ln to represent efficiently t i expression terms of for the n recall the value of text values of variables that t expression on input is an t in to the node in which t we have assumed that each is reduced so we may identify the text expression located at node n of the graph wit h the nodes of the dag dn associated with n we take a cover to be a whose is not the set of text expressions but the set of nodes of the dag dn representing those text aho and introduced the use of dags for representing within b and and have applied dags to various global problems we define two partial mappings z to vn if x occurs in the righthand side of an assignment in block n then we call x an input variable of n and let ix ie the node of dag dn labelled xn also if x is assigned to in block n then x is called an out variable of n and let m n if x is node except n which avoids all constant between and not an output variable of any m or n on any path from m to of m let wn be a function input variables of n to n such that for each input variable node m relative x of node n x is the to such that either m n or x is constant between m and n let be the set of global variables which are not constant between the of n and n w can always modify the program p at cost so that wn and are easily le for example for each x c z and for each node n of which x is not an add at n a dummy assignment x x this method of p to and increases the the calculation she of wn and alternatively an in r cp wn and directly for p in al extended bit vector operations it will be convenient to assume that if x c then x is also an output variable of n we therefore add dummy assignments i f to this note that this tion changes neither the of the program p nor the functions and wn n or does it much increase the size of p let n m be a pair of nodes in the program graph f a pair of nodes v u where v is a node in the dag of n and u is a node in the dag of m is a value pair if there is an input variable x of n that u x v and either a x s and s a or b x k and m x nw to the central definition to model the of values through a program p w introduce the global e graph v e l which is a cyclic labeled such t the node set v is the union of the node sets of the dags of f e is an edge list containing a the edge list of each dn and b all value pairs and l is a labeling of v with the labeling of each dn note that the only edges from nodes labeled with function in o are of type a and the only edges from nodes labeled with es in zn are of type b and no edge from any node labeled with a constant in c also note that the value edges of type b a node labeled xn and enter a node representing a value of x on entry to node n ie the direction is opposite to the implied fl m of control a path in consisting entirely of value pairs is called a value path this is due to se is a for building a global va lu e graph algorithm ii with each block for all n c n u v e l n represented by its dag dn m w and modify h sj that if x e then x is output at n l an array of length v e all nodes n c n m let dn vn ln append vn to v all vc lv v all input variables x of node c n all predecessors m of n in f add to e add i to e g let d be the average of for nodes n in the graph many block structured programs have d of order d be u in the worst case a is correct and has time and space proof the correctness of algorithm a directly the de ion of the global graph the size of the program is increased by o d n by the modification in the second line the to process each node n c n is l but iv a u nc and da i thus the total time cost is n we partially characterize i n terms of the theorem if is a minimal then for all a if lv c then lv b if lv e then u lv s that first subexpression is the expression whose is the symbol lv whose second s ub expres sion is e exp etc where ul uk are the in order of v in c if lv c then either i lv or ii v has at least one and for such successors u proof cover let and let v v be a fixed point case a if lv u c where c c c then v c case b if lv is a function sign in e and ul uk are the successors of v in g then t z e case c if lv xn where xn c zn we have vv xn so v by d ion of the e tv lv xn or nk for all predecessors s and tv u m of n in f in case consider some edge v u s e since v u is a value pair u for some m c n and either z i x s and m and m n c a or ii x in case i recall that mx so k have case ii x tm x t u x is constant between otherwise in n and also u is the unique of v in if tv a t u then v we can construct t u which a such that violates the assumption that t is minimal thus tv tu simple constants a text expression t is called a c iff t c c for some we call v s v a simple constant if is where d is the dag of which v is a node and the expression is taken as located at the appropriate point in the text of the program p it from that simple constants can be detected by propagating possible constants through the starting from nodes labeled with constants and then testing for conflicts this to an for s imple constant detect ion with time cost linear in the size of the the a new labeling l such that if v c v is a simple constant covered by c s c then lv c and otherwise r ing lv lv the result of this of simple constants with corresponding c is the reduced global va lu e v el let be a of some spanning tree of f we construct an acyclic of by just those edges which are oriented between nodes whose c values are compatible with formally let u then observe shall propagate e v u iv use and either or and v f that v e is acyclic we c in the reverse of a topological order of v e our for simple given below algorithm input v e l f v e l constant discovery is flag a bit vector of length l an array of length let be a of a spanning e v u s e or and add v u to e propagate constants a each v s v in reverse topological order of v e q tree of f m flag v true l v cd lv c else if lv e e c l uk are of v in c c for i k and there is c s c that c ec j c me else if lv c lv c v has a in and there s c that lu c for all u f else g lv add c q test for conflicts s v st lv c lv cc there is u s v such that and lu lv w v u s ee h q c q do m delete some v q f m i false lv lv add all predecessors m of v in to q lemma constant red by some constant symbol c then lv is set to c in step d e or f proof by topological order of on v the reverse of the basis observe that by theorem q is a leaf of v e and v is a simple constant covered by c c c then lv u c for some v c v lemma is for all w occurring after v in the topological order of v e v is a simple constant covered by c consider the cases case if lv c c then lv is set to lv in step d by our ion in the basis step lv c thus lv is correctly set to c in step d case if lv e where c let ul uk be the successors of v in here lv is set to c only if c oc c where ci c k but by theorem has value the ui are simple and so by the induction has been set to ci thus lv is set to c in step e case if lv e let s be the set of of v in ve lv is set in step f only if v successor in and lu c for all u e s to that is i w must rm all hm the is constructed we have v for some n c n s and x c z if x s s u then s o nm and otherwise here n mo by theorem all of v in must be simple constants by c by the hy thesis each u c s has been previously set to c thus lv is set in step f u let l be the value of l at step b and that just before this step q has the value qo u v k c at step b q is set to q qo u vi lv c c but lv e zn and there is u g v such that v u c ee and lu i lv then v c v is eventually added to q and lv set to lv iff some of q is reachable in from v if v c v is labeled by l with a constant sign then we show simple constant iff some element of q is reachable in v proof v is not a simple constant but no element of q is reachable from v then let be the mapping v exp such that for each w e v if w is reachable v then lw and otherwise w a is derived from w by substituting lv for the expression then we can show that is a but lv s c which implies that v is a simple constant m e suppose some element of q is reachable v in clearly if v c q then v is not a simple constant for some k if there is a path of length less than k in from some u c v to an of ql then u is not a simple nt suppose there is a path p xl xk of length k from v to some of ql if k then xl e ql and otherwise then xl s xk is a path of length kl by the induction hypothesis xl is not a simple constant but v xl c e and by theorem v is not a simple constant el theorem b is t and has cost linear in the size of the proof directly the correctness of algorithm lemmas and b follows in addition we must show b has time cost linear in the initialization costs linear in the may be in linear in by the depth first search o f the time to process each v c v at step a and b is step i can be reached at most iv i times and the time cost to process each node v at step i is thus the total time cost is linear in e in general w may improve the power of b for particular interpretations by applying algebraic to reduce expressions in more often to constant symbols for example i n the arithmetic we c an use the fact that o is the identity element under integer multiplication to modify algorithm b so that if node v is labeled by l with the multiplication sign and a of v in is covered ty o t at step e w may set lv to the constant sin corresponding to o the and the minimal u in this characterize section we use the to the following further theorem easily theorems and theorem if is a minimal then for each v s v a if lv c c then lv b if lv q then lv where of v in are the c if lv s n then either lv or v has some for all such in and successors u proof case a if lv c e c then by theorem v is a constant covered by c and so u c case b if lv where o is a function sign in q then by theorem v can not be a simple constant so b e where ul uk are the of v in but the are in reduced form so case c otherwise if lv s then again by v can not be a simple constant and part c directly let be the set of all nodes of labeled with constant function or variables of the form xs s is the characterizes start node of f then exactly the value of any on nodes in fi in terms of the values of on the nodes in v ie in terms of the values on nodes whose labels are of the form xn for n s for v s vi it follows from theorem that must be for some u that lies on a value path starting v the next theorem is critical in u call two paths almost if they have exactly one node in for any v s vo let hv be the set of nodes in that lie at the ends of value paths in s f ran v theorem if is a minimal and v c t either a is this for all u u c hv value or and b l for some u u c hv and l u where u is the unique node such from that v to members on all of hv value paths there are value paths from u to n ui u c hv such that f w shall require a fw technical to aid us in the proof of recall that tf is the there is a tree path of the graph f m n if m ie n and m n if m n n then let be the ie relative to in tf of all nodes in set n sn let n c ns and let be the dominator of n in f then c a u proof let n s to each m such that c a all m n s a contain paths n so all paths s to n mu st contain n that n n it is that m for all m n a with m i for otherwise there is a path s to n avoiding so in finally n m for all mn c a then is impossible there can be no path so n s extend to s of v so that iv s s lemma vt w e e for all v c proof c z k have v consider the for some n c ns cases and x case x s by ion of the v w e e iff w for some m n c a so w s e case x i y definition of the wo is the unique of v in where m n so w ce m n u s v and let s s v v that e maximal value path in v contains an element of s then proof fork o let sk w i there is a value path p wand either of length k or not contain any of s and is of length k w proceed by induction on k basis step u w s e s sup se for some k then w by by the now w prove theorem as noted above for some u reachable from v by a value path case there is some a c exp such that a for all w c hv let us assume a if then u s hv which is impossible u c vt then for each w e hv so since hu c hv by which contradicts with the assumption that is minimal case se there i are ut u e hv that let z w w is the last element of a maximal value path in v sh that of vs v let u be some to demonstrate that lu let us f lu then by theorem i for all w such that v w c e vi i vk is a value path in v containing u and vi is the last of u in p then this implies that u vs v which is le so u lu now there is a u e vs v distinct from u but then v l u which is impossible since lu l u thus all value paths in from v to an of hv must contain u suppose part of does not hold then there is no pair of disjoint value paths w to u u s hv that i hence there is a w c v distinct from u that w is contained on all maximal value paths ir an u de that for each y e v if c all paths in from y w t y l w and otherwise y so by definition of by lam which implies that is not contradiction so part holds d u this is a theorem suggests a procedure for calculating bu t there is an implicit circularity since for v s the determination of for u s hv may require the determination of w for some other w c vf the way out is by rank decomposition of as discussed in the next s finding there will remain the problem disjoint paths which we consider of in section j decomposition of the and introduced the use of a rank ion for dags here we generalize the rank ion to the possibly cyclic this gives us a method of partitioning the nodes of the into sets of nodes which my have the cover this us to apply without circularity and thus that the minimal is unique in section w apply the rank decomposition to implement ar direct method for symbolic evaluation the of a node v c v is defined if v has no in max i v u is in e for lv c mi u v u in e otherwise s u v proof w proceed by induction basis step if either c for c c c or wa lv xs for some x c z then neither w nor v has a successor in and by definition of rank w v suppose for some r for all e v that r and consider some w v c v such that r it is easy to establish the definition of rank that mi z i z e and mi z i z c hv case av e al i let w c hv and w c then by lw lw e and for il k where are the by the induction zl respectively yl yk of w respectively w in for il k so max rank zi i max i rank w thus by the above w r s where n by theorem there is a u e v that hu hv thus u u to the rank of all nodes in w use a modified version of the depth first search developed cause the search proceeds we reverse lists to store edges in e note that the is used in two different ways first to store the number of of node v have not been visited and later is set to let v r vr be the nodes in v v of rank r we initially and on the execution of the main loop he and rl input e l o rank m rank an array of integers of length v of v r o q v either lv is a constant or is a symbol of the form xs q iv sign w q q q q vr el delete v q each u of e oh w v q u c rl to q else else if u s r to q r rl theorem jj c is correct cost linear in e proof w will sketch the proof of w l initially and has time by is set to of v for each v c v so if lv c c then is set to o als o q and q are initially set to to for some r w have on entering the inner loop the time q fr for each v c v is set to if r and is set to number of of v with rank r if r ey a second inductive proof on the inner loop we may show that on exit to the inner loop for each v s if r then v is added to q and set to rl otherwise if rl the is set to the number of of v with rank r each v c v with r is added exactly once to q and is set to r he show that algorithm c may be in linear time for each node v e v w keep a list the reverse list giving all predecessors of v to process any v c q requires time since each node is added to q exactly once the total cost is linear in el u this suffices for theorem jj the minimal is unique proof for v e to il may b e determined by applying and l vi theorems using this method be inefficient since theorem be expensive to apply and the of the values grow in size the first problem is solved by reducing it to the problems of p graph and decomposition as described in the next section the s problem is solved by constructing a special labeled dag the tion of this dag and the final are given in section this section present s an efficient applying to nodes in me for let v e l as above now to the minimal it suffices to find a subset v s v and a mapping m v onto v that if mv and c vo and lv ie is of the form then v c v thus ml v partitions v into blocks that two nodes are in the block iff they have the which can then be found by referring to node mv each block contains exactly one fixed point of m which is called the value of all nodes in the block thus v is the set of value sources note t in general v and m are not uniquely determined so the de fin of source depends on the i we have chosen we shall find value sources and reducing these to the problems of c and decomposition s below m by let g u vg eg be any directed graph and let s s vg be a set of vertices of g such that for each vertex v e vg there is some vertex u s s which v is reachable completion problem find s s u v s there are almost disjoint paths distinct of s to v not containing any other of s this form of the problem is due to that it is equivalent to the original formulation e to shapiro and actually t his form i s more general than satisfies our restriction on s by that there is a single r e s from which ll v e is reachable proves t for each v s vg there is one and only one of s which v is reachable and his proof extends directly to cur slightly more general problem given g and s find for each v c vg the unique u c s which v is reachable w first show these problems can be solved e shapiro and give an gives a more here we reduce these problems to the ion of a certain tree for which there is an linear the a s noted in section this construction was discover ed by let a nw node not and let g be the rooted dir graph vg u h eg u h vl vl h thus g is derived g by adding a new root h linking h to every node ins and removing the edges of g which lead to nodes in s let t be the tree of g the members of s are the sons of h in t proof ij predecessor t if v c e s of v in g so h is ss then by definition s then h is a the in of s there are almost disjoint paths pi p in g from distinct elements of s to v not containing any other of s clearly pi and p are also paths in g since they contain no edge entering a member of s then h pl and h p are paths from h to v in g which have only their in so v is a son of h in f only if v son of h int if h is a predecessor of v in g then v c s g s otherwise there are in g paths and hp from h to v which have only their in moreover these paths contain no element of s except for the first nodes of p p since no edge of g enters an element of s except a re almost disjoint paths h hence pi p in g from distinct members of s to v not containing any other element of s and hence v s d for each v c vg the unique node in s which v is reachable in g is the unique node which is a son of h and an ancestor of v in t proof let w be that ancestor of v which is a son of t by wc s and clearly v is ble w in g since it is ble w in t conversely if w e s is reachable v in by i and w must be an ancestor of v since otherwise v be reachable some other of s now w establish the relation problems to the problem of finding of these v and m as sta above fix some v and m by choosing one node of for each value of on v for each rank r let gr vr er where vr is the set of all nodes of of rank r as de in section and u v u iu v e e u mv ul u v e e u c v e ir thus gr is the graph derived by deleting all nodes except those in vr and deleting all edges except those both entering and nodes in vr and then all edges note that edge of a member of r enters a node of rank rl let u mv u vc i v z e for some finally let be defined sr as in the of the lemma the members of are the value sources relative proof case a to m of rank r g suppose v c by definition all of mv i v c vr a re value sources m h consider some v s that v zs e for some z d vr call a value path in containing only nodes of rank r a il since v is of rank r path pl v to some node z e r is a also there is a path p where r t r z to some n c by i so mz f mz since pl and vp are disjoint by theorem lv but no other node of has label lv c zn so v is a value case c there are in gr almost disjoint paths xl and yl in gr distinct elements of sr to v by construction of gr there ml xl exist ml distinct c hv that u yl and x and y y are value eds and so v xj x l and sy are disjoint value paths as in case b he show v is a value by constructing two disjoint value paths ql two nodes in with distinct and then applying case cl if xl yl e fr then mz xl yl m so by definition of m f u v xj j x el q yk y paths are the desired disjoint value case c otherwise without loss of generality a xl e by de ion of sr x xl just as in case b there is a path pl where r ar xl in a node w c vr case c if y c then by t and let ql xl pi q s case cs otherwise y c then we may similarity find a path p where r i r from successor of yl in to some w c r for each x s vr we may again apply to that is distinct from both and since yl is of rank r there is a path yl to some d c case c if zl s zd n xl xj then u xl pi qz s iq case c otherwise let ze xi be the element of zl zd contained in xl xj cs if zd n yl yk t let ql xj xi zd d last q u yk yk c otherwise let zf e of then ql contained xj xl pi yi zd a re the value paths yi be the last in yl yk q u only if v is a value source of rank r then v is a fixed point of m if v c r then v mv c sr and so v c s by theorem there are in two disjoint value paths xj yk xl x t xj and y yk are members of hv with distinct j where let then j k a nd c sr but xl sr hence x and s yl are disjoint paths in gr from elements of sr to v containing no other members of sr thus v e s u by proof of the uniqueness of the ion of gr on sr we have len rb for v mv is the unique value source contained on all paths in gr from e of sr thus the problem of m reduces to the problem of the reduced global graph by and then constructing trees the former can be done in linear time by algorithm c of section the latter in linear time by z ai evaluation in this section we together the pieces in sections to give a unified presentation n of our tm for symbolic evaluation instead of using the directly to represent as in the beginning of section w more represent by a dag d v e l such that v c v e u mv mu iv and lv e l is the restriction of l to v recall from section that rd maps from the rooted dag d to expressions in ex p l rd mv for all v s v proof note that by definition of m for each so we need only show for v c v w proceed by on the length of the longest path in d from v e v basis step if v is a leaf of d then by definition of d lv s c u zn so lv z by definition of a dag lv for some j rd u for all u s v such that the longest path from u in d is of length less than j consider some v e v such that the longest path from v in d is of length j let ul uk be the of v in and that are the sons of v in d by the u for i k thus rd v l by definition of r u o u by theorem b our for symbolic evaluation is given b as in w and m in the order of the of nodes in v the array color is used to discover nodes with the input el output m and d v e l il initialize m color l v e mp l la of length iv lj v by a b of section compute of nodes in v by c of section r o to max v wl let vr r be the nodes r o in v of lv r lv where ul f are of v sort nodes in r by their color each maximal set y s r containing nodes with the color do m choose some u c y to v u is made a value u has add u as u in to e w by mv u let some node not in vr er all v v uc em u c add u v to er else add mu v to er add sr v c or v to sr let tr be the vr u h er u h all sons ha tree of g u h w by u is a value add u to v ancestors v of u m by lam mv u v v lv lv q m d is and can be implemented in linear time proof the correctness dir from theorems of algorithm d and and in addition w must show algorithm d can be in almost linear time the age cost of d is linear in initialization costs the linear in in algorithm b and c cost linear time by theorems and the time cost of the of the main loop exclusive of the of tr is linear in c here we assume that elements in the range of l are representable in a fixed number of machine wo and that the number of of function is by a fixed constant k so a sort can be used to part it ion or by color the computation of the tree tr requires by t time cost linear in thus the total time cost is linear in iv i u this completes the present ation of our recall that from section that with the aid of a stage r a bit vector operations we my construct a of size where d is often of order for but may grow to u thus this preprocessing stage offers no theoretical wt in practice often leads to a of size linear in the program and graph in contrast to method which for a large class of programs has storage cost ln and time cost our direct has storage cost linear in the size of the and time cost linear in the size of the although r method may be improved somewhat t the use of identities as shown in section there is in general no for an symbolic evaluation in r these methods which operate on structured as pascal or lisp are extended to programs data in a language references au aho av and jd theory parsing translation a ng vol ii prenticehall nj a allen f e notices vol num analysis july sigplan pp c j g e sigplan notices jy pp sub expression vol no ca j and allen f e a of optimization tions design and optimization of computers r cd pp e a application optimization languages j b and jd of lattice algebra to loop conf re of the second es of jan pp i fu ea and unman jd induction variables in ve ry hh level language s conf re of the second acm es languages jan pp g c m global non university dept of computer science phd thesis oct gw s and wegman m usually analysis vol pp a fast for global no and hu ms and unman jd analysis of a simple for g f problem co nf record of the acm symposium on es of ag es pp and unman jd global data sis and iterative vol no jan pp and unman jd data analysis technical science department princeton university jan k m as jan computer kennedy k international dec safety of computer pp l code motion ma th vol ke kennedy k a global of l tr of ma sciences rice texas for dept univ ke kennedy k node fl w analysis es jan to data of the second es pp ki g a a unified to global optimization proc acm qq es of languages oct pp knuth d e art computer vol tal algorithms reading mass kn knuth d e big na ws and big and lp d and r optimization theory and e s of a conference on languages compilers f vector machines march parallel and m y sets are u pp r reif j h phd dissertation in progress s m ma al global prenticehall nj se schwartz j t optimization o f very hh languages e a nd i ts la v pp ss shapiro r and h th e r tion of l rc i technical report vol june tl tarjan r e search and linear graph siam j no june pp vol t tarjan r efficiency of a good but not set union vol april pp t tarjan re of path on trees stanford computer science dept technical au t tarjan r path ans on directed graphs stanford computer science dept technical report t tarjan r personal to m u jd fast algorithms for e on of expressions in vol n dec pp w b pr the can m n synthesis vol of no 