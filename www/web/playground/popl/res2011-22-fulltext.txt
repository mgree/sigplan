expressive modular finegrained concurrency specification frank research group department of computer science abstract compared to external synchronization of operations on data structures shared between concurrent threads finegrained internal synchronization can offer stronger progress guarantees and better performance however fully specifying operations that perform internal synchronization is a hard open problem the state of the art approaches based on linearizability or on concurrent abstract predicates have important limitations on the expressiveness of specifications linearizability does not support ownership transfer and the concurrent abstract specification approach requires a particular usage protocol in this paper we propose a novel approach that these limitations and enables fully general specification of finegrained concurrent data structures the basic idea is that clients pass the ghost code required to instantiate an operations specification for a specific client scenario into the operation in a simple form of higherorder programming we the theory of the paper using the coq proof assistant furthermore we implemented the approach in our program verifier and used it to verify two challenging finegrained concurrent data structures from the literature a algorithm and a list categories and subject descriptors f logics and meanings of programs specifying and verifying and reasoning about techniques general terms verification keywords finegrained concurrency separation logic introduction years after and proposed their ri method and their if method for the verification of parallel programs doing so fully is still an area of active research for parallel programs two kinds of modularity can be distinguished and means that each thread can be verified separately under a welldefined concise set of assumptions on its environment the ri method satisfies this criterion since the resource invariants are the only shared assumptions among the threads the this work was performed while was a of the research foundation permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission andor a fee popl january ­ austin texas usa copyright c acm if method does not since it requires each command of each thread to be checked for interference with each command of each other thread the latter problem was solved by the relyguarantee rg method which summarizes each threads interference assumptions and guarantees in a single rely resp guarantee condition means that each procedure or each group of procedures that to implement an abstract data type can be verified separately again under a welldefined concise set of assumptions on its environment that performs proper abstraction over implementation aspects neither the ri method nor rg satisfy this criterion ri because it requires auxiliary variable annotations that break modularity as we will show and rg because it does not allow operations on data structures to be treated just like atomic machine instructions although this has been addressed recently with work on verification in this paper we propose an extension of the ri method that achieves the basic idea is simple at each procedure call the auxiliary variable updates required to enable verification of the client program are passed into the procedure as an extra argument the procedures specification is parameterized by a precondition and a postcondition for the updates and imposes a correctness condition on the updates in the form of a hoare triple we first describe the approach informally in the context of an informal extension of the ri method with procedures however since the ri method imposes syntactic restrictions on which threads may mention specific variables an extension with procedures requires more involved of variable occurrences these details are not very interesting and we do not develop this setting formally rather our formal system like our implementation uses separation logic where these issues do not occur we implemented the approach in our program verifier and verified two challenging finegrained concurrent data structures from the literature a algorithm and a list the remainder of the paper is structured as follows in § we recall the ri method in § we show that this method is not in § we informally present our approach for extending ri to achieve in § we describe how our approach may be lifted to a dynamic setting using separation logic and permission in § we introduce ghost objects data structures constructed from auxiliary heap cells that enable partial information sharing in § we describe how programs that use atomic machine instructions can be encoded straightforwardly into the system of this paper in § we describe our proof of a concurrent set algorithm in § we describe the verification tool finally we discuss related work in § the method consider the simple parallel program used by to introduce their method in fig resource rx cobegin with r when true do x x with r when true do x x figure a simple parallel program can be verified with resource invariants and auxiliary variables it uses the parallel execution command cobegin s sn to run two threads that each increment variable x variable x is protected by resource r the critical section command with r when b do s blocks until b is true and no other thread is using r in this simple language data races can be avoided by the following simple syntactic restrictions · an assignment to a variable x that belongs to a resource r is allowed only inside a critical section for r · an occurrence of a variable x outside of a critical section for a resource to which it belongs if any is allowed only if no other thread modifies the variable propose the following axioms for parallel executions and critical sections similar to the ones proposed by hoare but with relaxed conditions on variable occurrences the axioms assume that an assertion ir has been defined for each resource r called the resources resource invariant parallel execution axiom if p s q and p s q and and pn sn qn and no variable free in pi or qi is changed in sj i j and all variables in ir belong to resource r then p · · · pn ir resource r cobegin s sn q · · · qn ir critical section axiom if ir p b s ir q and ir is the invariant from the cobegin command and no variable free in p or q is changed in another process then p with r when b do s q we would like to prove that if x before the program executes then x after the program terminates as point out this property cannot be verified using the above axioms directly they propose to augment the program with auxiliary variables y and z that track each threads contribution to the value of x figure shows the proof outline given by for the augmented program notice that the auxiliary variables are mentioned in assertions outside of the with do commands even though they are protected by resource r this is allowed provided that the thread that a given variable is the only one that modifies that variable per the parallel execution axiom to reasoning using auxiliary variables propose auxiliary variable sets and the auxiliary variable axiom definition a set av of program variables is an auxiliary variable set for a given program if variables in av appear in the program only in assignments to variables in av auxiliary variable axiom if av is an auxiliary variable set for s let s be obtained from s by deleting all assignments to variables in av then if p s q is true and p and q do not refer to any variables from av p s q is also true the problem now consider again the program of figure suppose we wish to x and the operation on it ie the in x begin y z y z ir resource rx y z cobegin y with r when true do y ir begin x x y end y ir y z with r when true do z ir begin x x z end z ir z y z ir end x ir x y z figure and proof of the program of figure y and z are auxiliary variables procedure incr do x x resource rx cobegin with r when true do incr with r when true do incr a external synchronization procedure incr r do with r when true do x x resource rx cobegin incr r incr r b internal synchronization figure two versions of the program of figure operation into a separate module note neither the programming language of nor their proof system support procedures since both impose syntactic conditions on the threads where variables occur and this is not welldefined in the presence of procedures in this section and the next we informally introduce our approach while over this issue in section we present our approach formally using heap cells instead of global variables thus eliminating this issue there are two ways to do this using external synchronization figure a and using internal synchronization figure b in the version that uses external synchronization the module is easy to specify procedure incr satisfies the following specification x x incr x x where x is a logical variable the specification holds for all values of x using this specification both module and client program are easy to verify the proof outline of figure is mostly unchanged the reason is that the auxiliary variables can be added in the client program no of the module is required procedure incr r do with r when true do begin x x end begin y z resource rx y z cobegin incr r y incr r z end figure the program of figure b augmented per our approach for the version that uses internal synchronization this is not the case the updates of y and z need to be added inside the with do command but this command is in the module and furthermore different updates need to be added for different call sites one might then whether on internal synchronization is it is because synchronization to the module allows the module to perform finegrained synchronization for example by locks multiple times for smaller amounts of time or by using atomic machine instructions such as one can easily see that verifying this program with the method is impossible indeed consider any of the program with auxiliary variable assignments and any proof outline for the augmented program since the assignments inside the critical section occur in both threads no variable modified inside the critical section may be mentioned by any threads proof outline outside the critical section therefore removing the critical section from the program does not the proof outline consequently the proof outline cannot verify the triple x · x achieving in order to enable a modular specification of the module of figure b we propose to augment the program not just with auxiliary variables but with a simple form of higherorder programming to allow the client program to pass auxiliary variable updates into the module specifically we augment procedure incr with a parameter that ranges over commands and its body so that it executes after the update of x inside the critical section in the client program at each call of incr the appropriate auxiliary variable update is specified as the value for parameter the augmented program is shown in figure the specification of incr is now more involved x fv p u q p ir u x u x q ir p incr r q the specification is universally quantified over the predicates p q and u it can be instantiated with appropriate predicates at each call site notice also that the specification is generic in the resource invariant the resource invariant for the resource that a finegrained concurrent data structure is chosen by the client of the data structure this enables the client to specify the relationship between the state of the data structure and the auxiliary variables introduced by the client it is important to point out that although the specification of incr looks like a proof rule it is not part of the proof system and it does not affect the soundness of the proof system rather it is a derived proof rule that must be verified starting from the proof rules of the proof system p with r when true do begin p ir u x x x u x q ir end q figure proof outline for procedure incr x begin y z y z ir resource rx y z cobegin y incr r y with p y q y u x x z y z incr r z with p z q z u x x y z y z ir end x ir x y z figure proof outline for the client program it is easy to see that the implementation of incr satisfies the specification a proof outline is shown in figure the proof of the client program is equally easy see the proof outline in figure formal system we presented our approach informally in the preceding sections in order to achieve a welldefined approach we need to resolve the problem of syntactic restrictions on which threads may mention which variables these are not compatible with procedures to do so we move to a programming language without global variables where threads share data only through the heap and we use separation logic to reason about such programs specifically we adopt the programming language and program logic of et al for locks and threads with a few modifications · we add support for auxiliary heap cells and passing closed commands into procedures as argument values · we do not treat local variables as resources a translation of the example with internal synchronization of figure b to the more dynamic programming language is shown in figure the program consists of a procedure incr and a main program the main program allocates two consecutive memory cells and it the first one at address for use as a lock and it after a thread a lock it initially holds it the second cell at address corresponds to the global variable x in the original program the program then starts two threads both of which increment the sec procedure incr acquire r r release cons init release t fork incr t fork incr joint joint acquire figure the example translated into the dynamic programming language cell under protection of the lock finally it joins both threads acquires the lock and it a thread may only locks that it holds we wish to prove that when the program terminates we have true the original proof by used auxiliary global variables in this section we use auxiliary heap cells instead specifically with each allocated real heap cell say at address we associate an infinite number of auxiliary heap cells whose address is given by a pair of integers where is the real address and is the ghost offset in the example we use the auxiliary heap cells at addresses and to track the contributions of thread and to the value of the cell at corresponding to auxiliary variables y and z in the original proof the proof system of et al requires that a tag a be associated with each lock and a lock invariant ia with each tag we will associate the tag with the lock of the example and the following lock invariant with the tag c c · c c c c the lock invariant corresponds closely to the resource invariant of the original example it states that the value of is the sum of the value of and in the original proof syntactic restrictions that auxiliary variable y could be modified only inside a critical section and only by the first thread in the current proof fractional permissions achieve the same goal specifically one half of the permission for each auxiliary heap cell becomes owned by the lock the other half is by the corresponding thread as in the previous section to verify procedure incr we start by it with an auxiliary parameter that ranges over auxiliary commands and by its body with an occurrence of after the update of but before the lock is released as before this parameter will serve to perform the auxiliary state updates required to preserve the lock invariant the specification of procedure incr enforces that it does so ia p x · x u x x · x u x ia q a p incr a q the specification is universally quantified over the address of the lock the tag a of the lock the fraction of the lock permission available to the procedure any fraction will do an additional precondition p and postcondition q and a predicate u x parameterized over an integer x that describes the resources specifically the auxiliary heap cells owned by the lock besides the heap cell at address and states that those resources are in a state corresponding to value x of the heap cell at address the specification has two premises the first one states that the lock invariant ia combined with the additional precondition p implies full permission to access the heap cell at address plus we use the terms auxiliary and ghost some extra state u x where x is the value of the heap cell the second premise states the correctness of the parameter it states that executing command must the lock invariant after the update of and the remaining state must satisfy q we again point out that this specification has the shape of a proof rule but is not part of the proof system as always when verifying programs with procedures the specifications of the procedures must be derived using the proof rules of the system as part of the verification of the program a proof outline of the program is shown in figure notice the following · the release of the lock the lock invariant · a thread specification and thread specification arguments are associated with each fork operation for verification purposes a fork with thread specification and arguments n the precondition of and produces a thread permission tid t n where t is the thread identifier · joining a thread the thread permission and produces the thread specifications postcondition · the acquisition of the lock produces the lock invariant merging the of the auxiliary heap cells yields full information about per the following law a v c · a c p c a v p v programming language the syntax of arithmetic expressions e boolean expressions b and commands c is given below all commands return a value local variables are using let commands the syntax x c y c c is syntactic sugar for let x c in let y c in c we assume a global table of procedure definitions the recursion operator µf x · ce applies the recursive function f with parameters x and body c to arguments e the scope of f is c any command expressions in c the syntax letrec f x c in c is syntactic sugar for c µf all substitutions are a command is closed if it has no free variables x vars and no free functions f we assume a encoding · of closed commands into integers a command expression c denotes the encoding of c as an integer a closure execution command executes the closed command obtained by the value of e in the examples we simply write instead of exec that is a variable name used as a command denotes a closure execution n z x vars p f e n x e e e e c b e e e e c e ee e e ee e if b then c else c return e pe let x c in c µf x · ce f e fork c procedure px c the evaluation e of a closed expression e is defined as follows n n ee e e ee e e c c we define a smallstep interleaving semantics a configuration consists of a real heap h a ghost heap g and a thread map t a real heap is a finite partial function from positive integers to integers a ghost heap is a partial function from pairs of integers to integers a thread map is a finite partial function from thread identifiers to closed continuations the continuations and contexts are procedure incr a p acquire a ia p a x u x r r a x u x a ia q release a q thread req thread req emp cons n n true release true t fork incr with u x x t true t fork incr with u x x t t true joint t true joint true acquire c c · c c c c true true figure proof outline for the example program defined as follows c n let x in c done the step relation is defined in figure in the step rules symbols n match not just integer literals but other closed expressions as well and denote their value notice that locks are implemented as a single heap cell that holds either the value if the lock is not held or the value if the lock is held we omit rules for init and we define them as equivalent to return ie a for purposes of the step relation throughout f x y denotes function update ie f x yx y and f x yz f z for z x simple closures we say a program has simple closures if there exists a partitioning of procedure parameters into closure parameters and parameters such that all exec commands are of the form where x is a closure parameter and all procedure call argument expressions for closure parameters are either command expressions or closure parameters applying the specification approach of this paper requires only simple closures as we will see simple closures admit a very simple proof system proof system the correctness of a command c is expressed in the form of a correctness judgment p c q where is a function environment and p and q are assertions an assertion describes a set of permissions the set of permissions is defined as follows p v v a tid t v a permission is a total function from permissions to real numbers between and we identify assertions with sets of permission that is we treat assertions semantically we denote the empty permission that maps all permissions to as we define some syntax for assertions emp v v v v a a tid t v tid t v p q b b b · b b b b p b q x · p x b x · b p x in p i b b · b i · bi p i where b p · n · i n · bp we say a permission is consistent if there are no two pointsto permissions with the same address and different values that both map to nonzero coefficients we say one assertion a implies another one a written a a if for every consistent b a we have b a the correctness judgment is defined inductively by the rules shown in figure notice that the proof rules for procedure calls and for closure executions simply require the correctness of the procedure or closures body it follows that a procedure that calls another procedure or that executes a closure does not in isolation have a closed proof tree rather its proof tree is parameterized by the proof trees for the procedures called and closures executed this simple approach is sufficient if the program has simple closures and an acyclic procedure call graph indeed in that case given a main command one can inline all procedure calls to obtain an equivalent command that contains no procedure call or closure execution commands the shape of the proof tree for the original main command will reflect the shape of the main command after inlining soundness we sketch how one can prove soundness of the program logic used more details are in the technical report also a proof is at continuation step rules for relation h g h g abort h g nm h n m nm g m if and m domh h g h g n if h g n if n domh then h g hn else abort h g nn if n n then h g gn n else abort h g n v if n domh then hn v g else abort h g nn v if n n then h gn n v else abort h g if n domh then h dom n g dom n true else abort h g if b then c else c if b true then h g c else h g c h g pv h g if procedure px c h g exec c h g c h g return n h g n h g let x c in c h g c let x in c h g µf x · cv h g x · cf vx h g hn g if n h h g abort if n domh h g if n domh then hn g else abort h g v let x in c h g thread map step rules for relation h g t h g t abort h g t h g t t if t t and h g h g h g t abort if t t and h g abort h g t h g t t t t c done if t fork c t and t h g t h g t h g t t v dom t abort if t joint t and t v done t if t t and n figure step rules for continuations and thread maps t note init and are emp r vn i r i vi n r i emp r r v v r v r v v r v r v v v v v p b c q p ¬b c q p if b then c else c q n emp p r return v p r v procedure px c p q p pv q p c q p q p r c qr x · qx c xx q p let x c in c q x req p q p vx c p vx r fork c tid r v p f x q p c q p vx µf x · cv x req p q tid t v joint x · p x c qx x · p x c x · qx p f x q p vx f v s as as acquires as ias ias emp p c q p c q as s p p p c q p c q qq p c q p r c q r figure proof rules the soundness theorem states that if for a command c we have emp c true then t c done abort for any thread identifier t we do not define the semantics of the correctness judgment directly rather we define an assertion transformer q similar to a weakest precondition operator but we dont about whether it is the weakest precondition or not we prove p c q p q we can then define validity of a configuration a configuration h g t is valid iff there exists a set of permissions p such that · for every with if then domh · h equals the set of pointsto permissions in p plus one element or for each a permission in p · g equals the set of ghost pointsto permissions in p · there is exactly one tid t v permission for each thread t and · there is exactly one permission for each a permission whose corresponding heap element equals and · there exists a permission bt for each thread t and a permission b for each a permission for which there is no permission and a permission bc for the programs environment which in particular contains the tid permission for the main thread such that the sum of all bt and all b and bc equals p p p and for each thread t t bt valid where x req · · · q and tid t v p for each lock a p for which there is no p b ia by correctness of the main program the initial configuration is valid we then prove that each execution step preserves configuration validity the theorem then follows from the fact that abort is not a valid configuration ghost erasure after a program is verified ghost code can be removed without the proof specifically if all code that is removed is and terminates then if the program after erasure aborts the original program aborts if the program has simple closures and the procedure call graph is acyclic then nontermination can result only from nonterminating recursive functions removed code is if it affects only the ghost heap provided that all ghost heap accesses are removed ghost objects in the previous section we used fractional pointsto assertions to enable a thread to maintain information about a shared object the location is readonly while no thread has full permission and the thread has full information it knows the exact value often proofs require a more finegrained type of tracking a thread needs to maintain partial information about a value while allowing other threads to modify the value in ways that preserve all threads assumptions a general approach to this problem is relyguarantee reasoning however in this paper we propose a different strategy we propose the use of ghost objects a ghost object is a data structure built from auxiliary heap cells that represents some mathematical value and that allows clients to obtain handles on the object that represent a condition on the value of the object handles represent partial information about the object they represent the permission to violate the condition in the sense that the object does not allow the condition without in the handle a basic ghost object is a ghost bag the abstract predicate b represents a ghost bag with identifier b currently holding the bag of integers b the object provides the following operations emp r create b add b v b v v b v v v b b v the predicate v represents the knowledge that the ghost bag b currently contains element v it furthermore represents the permission to remove this element this ghost object can be implemented in terms of simple auxiliary heap cells it does not need to be built into the proof system a verified ghost bag implementation comes with our verification tool see section furthermore based on ghost a wide variety of ghost objects can be implemented easily atomic instructions the programming language of the previous section does not include atomic machine instructions such as atomic cas instructions which are available on most platforms however one can easily translate a program that uses atomics to a equivalent but less efficient program of the formal language that uses locks by introducing an extra lock for each data structure of the program that is accessed using atomics and then translating the atomic operations into code sequences that acquire the corresponding lock perform the operation and then release the lock we will call such a lock an atomic space and its address an atomic space identifier ranged over by s note our verification tool supports atomics and atomic spaces directly and does not require a translation a procedure corresponding to a cas operation could look as follows augmented with two ghost parameters and for verification purposes procedure o n acquires v if v o then n else return v we can prove the following specification for it ias p x · x sx so n ias qo x · x o sx x ias qx as p r o n as qr we will use this procedure in the examples below as well as procedures load and store corresponding to atomic loads and stores respectively specified as follows ias p x · x sx x · sx x ias qx as p r load s as qr ias p x · x sx x · sx v ias q as p stores v as q abstraction a concurrent set in the example of the preceding sections the data structure being manipulated was a simple cell and its memory representation x was in the specification of the operation incr in this section we show that our approach supports specifications that abstract over the representation of the concurrent data structure furthermore we show that the approach allows abstract specification and verification of concurrent data structures built on top of other concurrent data structures we do so by first showing a specification and implementation of a binary semaphore module implemented in terms of atomic machine instructions we then show a specification implementation and proof of a concurrent set module implemented by locking of a sorted linked list that uses the semaphore module semaphore specification the semaphore module defines an abstract predicate v which represents a semaphore at address whose value is v either or the specification of the functions exported by the module can be given in terms of this predicate as follows init ias p v · v sv s ias q as p acquires as q ias p v · v sv v · sv ias q as p as q actually to enable sharing of information about the state of a semaphore the semaphore module defines a slightly different predicate v just v is shorthand for v the module further exports the following lemmas v v v v v v v v where and range over positive real numbers semaphore implementation the implementation of the semaphore module is straightforward predicate v v procedure init skip procedure acquires letrec iter r skip if r then iter in iter procedure stores procedure skip we omit the proof it too is straightforward set specification the set module exports three procedures emp r create set ias s v · v u v v · v v u v p u v v q v · v v u v p u v q as s p r add s o v as s qr ias s v · v u v v · v v u v p u v v q v · v v u v p u v q as s p r removes o v as s qr procedure add returns if the element was not yet present and otherwise analogously procedure remove returns if the element was present and otherwise notice that in the specification of add and remove the first premise which enables the procedure to separate the set out of the lock invariant uses s instead of p in earlier specifications there was no separate s predicate and p was used for simplicity however using p means the procedure cannot perform further atomic operations on the set after the closure or has been executed since it p and produces q using a separate predicate s means the procedure can access the set both before and after executing the closure to simplify the presentation the example module does not offer a procedure for a set object an implementation that supports verified using our verification tool is available online specifications in the above specifications of procedures add and remove the functional behavior is somewhat by the finegrained concurrency fortunately however we can easily define an abbreviated notation for typical finegrained specifications which makes them look just like sequential specifications we introduce the notation v r r as an for ias s v · v u v v · u v p u as s p r o as s qr often it is convenient to split the postcondition into multiple cases with corresponding ghost command parameters and corresponding premises we introduce v r gv r gv r where gi are pure assertions as an abbreviation for ias s v · v u v v · gv u v p u v · gv u v p u as s p r o as s qr this notation allows the above specification for procedure add to be written as v r add v v v v v r v v v r set implementation the implementation of the set module is shown in figure for node values we implicitly perform an encoding of z into z we use the following syntactic sugar n and n the set is implemented as a sorted linked list for tion one field of each node is converted into a semaphore that is used to perform locking of consecutive nodes this some degree of parallelism for concurrent operations on the set set proof the core of the proof of the set module is the definition of the set predicate it serves as the invariant of the data structure which holds before and after each atomic operation this invariant must procedure create set cons cons init return letrec n v n value if v v then acquires n n return else return n in procedure add s o v acquires o n n v n value if v v then n return else n cons n v init seman n n return procedure removes o v acquires o n n v n value if v v then acquires n n n next n n return else n return figure implementation of the set module note into add and remove enable each thread to retain between the atomic operations that constitute a set operation the information it needs about the state of the data structure for example after a node a thread must know this node will remain in the data structure for this purpose we track the set of nodes in the linked list using a ghost bag see section we keep the identifier of the ghost bag in a ghost field of the first node to refer to this ghost field we use the syntactic sugar o another consideration when defining the invariant is that we wish to retain the shape of the linked list even when a thread has taken ownership of a nodes next field in preparation for inserting or removing the next node therefore we use the ghost field at ghost offset of each node as the field n as usual we use a recursive predicate to describe the linked list f vf v f vf v vs n vn · f · vf · f vs vf n vn n vn v where n vs v n v vs seman vs n n v n value v n v v vs seman vs n v n value v v v the predicate f vf v denotes the section of the sorted linked list from node f to node node the other parameters are the ghost bag identifier b the first value vf the last value v the list of nodes and the list of values the body of the predicate is a disjunction the first disjunct describes the case where the first node equals the last node and therefore the section is empty the second disjunct describes the nonempty case specifically it describes the first node using the predicate node and recursively calls the predicate to describe the subsection from the second node to the last node this disjunct existentially over the tail of the tail of the value of the semaphore vs of the first node the next node n and the value of the next node vn predicate nodes body too is a disjunction the first disjunct describes the case where the node is not locked the second disjunct describes the case where the node is locked in the latter case full ownership of the field and fractional ownership of the semaphore and the and n value fields has been to the thread that acquired the lock notice that each node half of the value field of the next node this means that when a thread locks a node it knows not only that nodes value but also the next nodes value this allows it to safely insert a new node in between while maintaining the of the list the definition of the set predicate itself is now straightforward v b · o · b true v the definition uses the mathematical function which denotes the bag of the elements of the list it states that there is a sorted linked list starting at o that starts with value and ends with value which means that an insertion point can be found within the list for any finite value it further states that the nodes of the list are exactly the elements in the ghost bag at and that abstract value v of the set is exactly the bag of the values of the list the syntax v is shorthand for · v that is it denotes an unspecified fraction of the pointsto permission as applied in the set predicate this allows threads to remember the connection between o and b the true conjunct allows us to leak memory locations or that we do not use specifically of the last node we use only of field value we would need to be more precise if we to support of the set object the specification of local recursive function is as follows as s b n seman n n vn n value vn vn v r as s b r n vr vn · n n vr vn vr v v vn note that even though is shown outside of add and remove after it is within the scope of the parameters of these procedures and furthermore its proof can use the premises of these procedures specifications and in particular the first premise we show in figure the set implementation annotated with ghost commands a full proof outline is in the technical report procedure create set cons cons init b create add b f b return letrec n v n value if v v then acquires n skip n skip return else return n in procedure add s o v acquires o skip b n n v n value if v v then n return else n cons n v n n init seman n n add b n n return procedure removes o v acquires o skip b n n v n value if v v then acquires n skip n n next n n n n return else n return figure the set module with ghost commands client program in this subsection to illustrate how the specification of the set module can be used to verify rich properties of client programs we verify the example client program shown in figure the program starts by creating a set object o and a lock s for use by the set module to its atomic operations remember that this lock can be erased after verification if real atomic operations are used see section then the lock is initialized from this time the lock the set data structure finally a producer thread is and the main thread turns into a consumer thread the producer thread simply adds to the set the consumer thread repeatedly performs the following experiment it an arbitrary number by allocating a heap cell and it just letrec s o x add s o x s o x consumer s o x r removes o x if r then r removes o x s o pick random number x x cons consumer s o x s o in o create set s cons fork s o s o figure example client program for the concurrent set module for the address and tries to remove it if the remove operation succeeds it tries to remove it again and asserts that the latter remove operation fails it always does since the producer thread never adds the same number twice here is how our approach succeeds in verifying the assert command of this program a proof outline for this program including ghost commands is shown in figure as always the crucial step is coming up with an invariant specifically a lock invariant for the lock s it is shown at the bottom of figure the proof uses three ghost fields of s sugar for s the lock to the set o sugar for s records the last number added by the producer and sugar for s records the last number removed by the consumer the invariant states that the last value added by the producer is an upper bound for the sets elements that the last value removed by the consumer is not greater than the last value added by the producer and that the last value removed by the consumer is not in the set once the invariant is established the proof outline follows easily as usual each thread half of its associated ghost field the producer thread half of and the consumer thread half of the producer passes the required update of into add as a ghost argument analogously the consumer passes the required update of into remove as a ghost argument the specifications of add and remove are instantiated as follows for all calls predicate s is instantiated with o and predicate u v is instantiated with the invariant the set data structure itself u v p c · o p c v v · v p c p c v where variables s and o are bound at the call site the instantiations of p and q are shown at the call sites in figure given these instantiations the premises of add and removes specifications can be verified easily verification tool we implemented our approach in our program verification tool and we used the tool to verify two challenging finegrained concurrent data structures from the literature a algorithm and a list is a generalpurpose verifier prototype for c programs based on separation logic it takes source code annotated with function specifications loop invariants predicate definitions and other annotations and reports either that the program is and with function specifications or it shows a symbolic execution trace that leads to a potential error it symbolically executes each function in turn using a separation s o x logic formula as the symbolic representation of memory req spaces o p · p p x false s o req spaces o c · c false supports ghost commands for creating and updating ghost cells it also supports lemma functions which are like ordinary c functions except they may contain only ghost commands and checks that they terminate it follows that calls of lemma functions are ghost commands it supports lemma function pointers and lemma function pointer calls these features letrec are all that was needed to make it possible to apply our approach in s o x more generally any verification tool that supports ghost spaces o p · p p x add s o x x skip p p · p p x qr x spaces o x s o x consumer s o x spaces o c · c r removes o x x skip p c · c qr c · c r c x variables ghost functions and dynamic binding of ghost functions supports our verification approach this means it should be easy to extend other verification tools such as and to support our approach we have used to verify the concurrent set module used as the example for this paper we also verified a algorithm proposed by et al is built on top of a algorithm by the same authors our proof consists of a proof of with respect to an abstract specification of and a proof of based on the abstract specification of we also verified a simple example client program for each algorithm the annotation overhead consisting of specifications as well as proof steps is shown in the following table spaces o c · c r c x if r then program loc overhead time s r removes o x skip skip s p x qr x r spaces o x r s o spaces o c · c pick random number x x cons consumer s o x s o in emp o create set s cons s ns o s s s in each case the annotation overhead is in the order of to lines of annotation per line of code three things should be kept in mind when considering the overhead these are probably some of the most complex algorithms in existence secondly we did not optimize the annotation requirements for lemma function pointers it currently involves significant we show these results only as evidence that the specification approach is applicable to challenging algorithms this paper is not about notice that the runtime of the verification tool is very acceptable on the order of one second this enables an interactive annotation insertion process the tool and the annotated example programs are available online at related work s o true spaces o true to the best of our knowledge our approach is the first that enables fully general modular specification and verification of finegrained concurrent modules and their clients we are aware of two existing approaches for specification of fork s o finegrained concurrent data structures both based on a spaces o true s o of relyguarantee and separation logic a approach initially proposed in vafeiadis phd thesis and concurrent abstract predicates o p c v · o p c v v v · v p c p c v in the approach the specification for a data structure operation is in the form of a piece of sequential code that operates on a ghost variable that holds the abstract state of the data structure an implementation with the specification if for each execution trace there is a total ordering of the operation invocations in the trace such that their return values equal the figure proof outline for the client program return values that would result if the operations specifications were executed sequentially in this total order in other words there exists a linearization point between the start and end of each operation invocation such that the result values are as if each operations specification was executed atomically at the linearization point verification verifies that the data structure is linearizable by verifying that there exists a linearization point for each operation the approach can then verify client code as if the operations executed atomically a limitation of the approach is that it does not support the transfer of ownership of memory locations or other resources between the data structure and its client for example a queue implemented as a linked list where nodes are allocated by the client passed into the module on and passed back to the client on cannot be specified by the approach this is because the definition of linearizability assumes no memory is shared across the module boundary and all interaction is in the form of invocation arguments and results in contrast in our approach ownership transfer is supported for example here is a specification for the and operations of the queue module suggested above ias s · u · u p u · n q as s p q n as s q ias s · u n · u n · p u qn u p u q as s p r q as s qr an important advantage of linearizability however is that powerful automation techniques have been built for it eg concurrent abstract predicates cap extend separation logic with shared regions each shared region is associated with an interference specification which is a set of action names with associated pre and postconditions a piece of local state can be converted into a shared region this gives the thread full permission to perform the actions associated with the region it may then pass of these action permissions to other threads each assertion about a shared region must be stable with respect to the actions that other threads may perform the cap authors propose the following approach for modular specification of a finegrained data structure the module the data structure to clients in the form of a number of concurrent abstract predicates each of which give permission to perform a particular type of operation for example their example lock module predicates and which give permission to acquire resp release lock x their example set module predicates v and v which give permission to remove resp add element v this specification approach does not ours whereas our approach enables fully general specification of data structure operations this approach enforces restrictions on how the data structure may be used specifically while the set module specification allows threads to concurrently add or remove distinct elements it does not allow them to race to concurrently add or remove the same element more generally the choice of which predicates to expose is a tradeoff between the restrictions on usage and the type of information a client can track indeed the information content of a predicate imposes a restriction on what other threads can do for example if one thread holds an v permission other threads cannot remove this element to achieve a fully general specification the choice of stable permissions must be done by the client not by the module designer in order to enable this the client must be able to do atomic or observations not just nonatomic or stable ones this is what linearizability enables by allowing operations to be treated like atomic instructions and what our approach enables by allowing the in of ghost code into the critical section and by allowing the client to choose the auxiliary variables and the lock invariant note that our comparison is with the way the cap logic is used in not with other specification approaches based on the cap logic that may be proposed in the future however the cap logic is a convenient alternative to the use of ghost objects to track partial information and as such is complementary to our specification approach specifically one could have a single auxiliary variable that holds the precise abstract state of the data structure and then insert this variable into a shared region for example the ghost of section could be implemented more straightforwardly using shared regions than using a data structure built from auxiliary heap cells acknowledgments the authors would like to thank calcagno peter ohearn matthew parkinson vafeiadis and yang for helpful comments on of this paper this research is partially by the state science policy and by the research references richard calcagno peter ohearn and matthew parkinson permission in separation logic in popl thomas and modular verification of concurrent c in thomas matthew parkinson and vafeiadis concurrent abstract predicates in ecoop berdine cook and sagiv local reasoning for locks and threads in tim fraser and a pratt a practical operation in th international symposium on distributed computing and linearizability a correctness condition for concurrent objects acm toplas and frank expressive modular finegrained concurrency specification extended version technical report cw dept cs jan and frank a quick of the program verifier in c b jones specification and design of parallel programs in ifip k m leino peter and jan foundations of security analysis and design v volume of lncs chapter verification of concurrent programs with springer peter w ohearn john reynolds and yang local reasoning about programs that alter data structures in csl and david verifying properties of parallel programs an axiomatic approach cacm ­ may and david an axiomatic proof technique for parallel programs i inf j c reynolds separation logic a logic for shared mutable data structures in lics vafeiadis modular finegrained concurrency verification phd thesis computer laboratory university of cambridge july vafeiadis automatically proving linearizability in cav vafeiadis and matthew parkinson a of relyguarantee and separation logic in concur 