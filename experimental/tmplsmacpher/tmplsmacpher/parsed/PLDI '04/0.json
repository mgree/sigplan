{"article_publication_date": "06-09-2004", "fulltext": "\n Race Checking by Context Inference* Thomas A. Henzinger Ranjit Jhala Rupak Majumdar EECS Department, \nUC Berkeley, U.S.A. CS Department, UC Los Angeles, U.S.A. {tah,jhala}@eecs.berkeley.edu rupak@cs.ucla.edu \n ABSTRACT Software model checking has been successful for sequential programs, where predicate abstraction \no.ers suitable mod\u00adels, and counterexample-guided abstraction re.nement per\u00admits the automatic inference \nof models. When checking concurrent programs, we need to abstract threads as well as the contexts in \nwhich they execute. Stateless context models, such as predicates on global variables, prove insuf\u00ad.cient \nfor showing the absence of race conditions in many examples. We therefore use richer context models, \nwhich combine (1) predicates for abstracting data state, (2) control .ow quotients for abstracting control \nstate, and (3) counters for abstracting an unbounded number of threads. We in\u00adfer suitable context models \nautomatically by a combination of counterexample-guided abstraction re.nement, bisimu\u00adlation minimization, \ncircular assume-guarantee reasoning, and parametric reasoning about an unbounded number of threads. This \nalgorithm, called CIRC, has been imple\u00admented in Blast and succeeds in checking many examples of nesC \ncode for data races. In particular, Blast proves the absence of races in several cases where previous \nrace checkers give false positives. Categories and Subject Descriptors: D.2.4 [Software Engineering]: \nSoftware/Program Veri.cation; F.3.1 [Logics and Meanings of Programs]: Specifying and Verifying and Reasoning \nabout Programs. General Terms: Languages, Veri.cation, Reliability. Keywords: Software model checking, \nrace conditions. 1. INTRODUCTION Data races are a major source of errors in concurrent pro\u00adgrams. Race \ndetection tools enable the construction of ro\u00adbust concurrent systems by .nding, or con.rming the ab\u00adsence \nof, races. They also allow more aggressive program\u00adming by detecting redundant synchronizations (by verifying \n* This research was supported in part by the NSF grants CCR-0085949, CCR-0234690, and ITR-0326577. Permission \nto make digital or hard copies of all or part of this work for personal or classroom use is granted without \nfee provided that copies are not made or distributed for pro.t or commercial advantage and that copies \nbear this notice and the full citation on the .rst page. To copy otherwise, to republish, to post on \nservers or to redistribute to lists, requires prior speci.c permission and/or a fee. PLDI 04, June 9 \n11, 2004, Washington, DC, USA. Copyright 2004 ACM 1-58113-807-5/04/0006 ..$5.00 the safety of the program \nwithout the synchronizations). Existing race checkers fall into two major categories: dy\u00adnamic, lockset-based \ntools [25, 6] and static, type-based tools [4, 11]. Programmers, however, often use synchroniza\u00adtion \nidioms that cause false positives for these tools (i.e., the tool reports a possible race when there \nis none). Consider, for example, the test-and-set nesC program taken from [13] in Figure 1. Lockset-and \ntype-based approaches falsely .ag this program as potentially buggy, as it uses the value of the variable \nstate instead of explicitly declared locks to guarantee race-freedom. The .rst thread to enter the atomic \nblock sets its local variable old to 0 and the global state to 1, and gets to access x. The other threads \ncopy the value 1 into their local copy of old, and the check old =0 before accessing x precludes the \npossibility of a race on x.In many programs, the problem is harder as the accesses to the pro\u00adtected \nvariable happen in procedures other than the ones where the variable state is toggled, and often happen \nonly if the function that changes the state variable returns a par\u00adticular value ( conditional locking \n). Other synchronization mechanisms, such as the enabling and disabling of certain interrupts, are also \nbeyond the scope of methods based on locks. A more precise path and interleaving sensitive anal\u00adysis \nthat tracks the values of variables is required to verify the absence of races. Race detection is a safety \nveri.cation problem for concur\u00adrent programs: a race occurs when two threads can access (read or write) \na data variable simultaneously, and at least one of the two accesses is a write. The program is race-free \nif no such state is reachable. Thus, in principle, races can be detected (and their absence proved) using \nmodel check\u00ading. Concurrency, however, is a major practical obstacle to model checking: the interleaving \nof concurrent threads causes an exponential explosion of the control state, and if threads can be dynamically \ncreated, the number of control states is unbounded. One approach [23] is to consider the system as compris\u00ading \na main thread and a context which is an abstraction of all the other threads in the system, and then \nverifying (a) that this composed system is safe ( assume ) and (b) that the context is indeed a sound \nabstraction ( guaran\u00adtee ). Once the appropriate context has been divined, the above checks can be discharged \nby existing methods [14, 8, 22, 16, 12]. Additionally, the remaining data abstraction can be performed \nautomatically using counterexamples [3, 20, 5]. Note that either check may fail due to imprecision in \nthe context, leaving us with no information about whether the system is safe or not. Consequently, the \nmain issues are: (a) what is a model for the context that is simultaneously (i) abstract enough to permit \ne.cient checking and (ii) precise enough to pre\u00adclude false positives as well as yield real error traces \nwhen the checks fail, and (b) how can we infer such a context automatically. In [19], we addressed these \nissues as follows: (a) We chose as context model, a relation R on the global variables, which represents \nthe possible e.ects that the other threads may have on the global state between any two transitions of \nthe main thread, i.e., at any point, the context could change the global variables from s to s . so long \nas (s, s ') . R.(b) We in\u00adferred such a context using counterexample-guided abstrac\u00adtion re.nement. Experiments \nshowed that this stateless context model lacks the precision required to prove the safety of programs \nsuch as the ones described earlier, and to produce error traces for buggy programs. As context threads \nchange the global variables depending on their local states, stateless\u00adness leads to false positives. \nAlso, to generate error traces (and to re.ne abstractions) we must be able to check if an abstract trace \ncorresponds to some concrete interleaving of the program s threads. This is di.cult if the context has \nno information about the other threads local states. For these reasons, the context must track the local \nstate of its threads. Unfortunately, statefulness brings the burden of tracking the state of each of \nthe arbitrarily many context threads. We present in this paper a richer model for contexts that solves \nboth the above problems, and a generalization of the algo\u00adrithm from [19] that constructs these richer \ncontext models automatically. Stateful Contexts. First, we represent each context thread by an abstract \ncontrol .ow automaton (ACFA). Each ACFA location corresponds to a set of control locations of the thread, \nand we keep ACFAs minimal by computing weak bisimilarity quotients [7]. Each ACFA location is labeled \nby a formula over the globals, which constrains the possible values of the global variables. Second, \nwe track the state of each of arbitrarily many context ACFAs by labeling each ACFA location with an integer \ncounter (possibly .), which represents the number of threads at that location ( counter ACFA ). Thus, \nour context models combine three forms of abstraction: predicates for data abstraction, weak bisim\u00adilarity \nquotients for control abstraction, and counters for abstracting multiple threads. Context Inference. \nSuppose, for simplicity, that all threads run the same code as main. In general, our al\u00adgorithm requires \nthat each of the threads be running one of .nitely many pieces of code, and that the threads do not ref\u00aderence \neach other. The inference of context models proceeds in two nested loops. The outer loop sets the context \nmodel to be the strongest model (which does not interfere with main) and then executes the inner loop. \nGiven a predicate abstraction of main, and a counter ACFA that represents the multithreaded context, \nthe inner loop iteratively weak\u00adens the context model until either (i) an abstract error is found, or \n(ii) the resulting counter ACFA overapproximates (simulates) the program. If (i) happens, we break out \nof the inner loop and analyze the abstract counterexample. If it is real we report the bug and exit, \nif it is spurious we add new predicates or re.ne the counter, and repeat the outer loop. If (ii) happens, \nwe conclude (by assume-guarantee rea\u00adsoning) that the program is free of races and exit. Other\u00adwise (i.e., \nneither (i) or (ii)), we weaken the context model by transforming the current reach set of main into \na new ACFA and repeat the inner loop with the new, weaker con\u00adtext model. The whole process stops when \neither a concrete race is found, or the absence of races is proved using a con\u00adtext which overapproximates \nthe program. While our method applies to verifying any safety property of concurrent programs, we have \nfocused on race detection for two reasons. First, race checking requires no code anno\u00adtations or speci.cations \nfrom the user. Second, the absence of race conditions is a prerequisite for establishing a variety of \nmore complicated correctness requirements. Experimental Results. To demonstrate the practicality of the \nmethod, we have implemented this algorithm, called CIRC, in our C model checker Blast [20]. The use of \nstateful contexts (ACFAs), their minimization, and the treatment of an unbounded number of threads using \ncounters are new to Blast . We ran the method on several networked embedded systems applications [13] \nwhich use the synchronization id\u00adioms mentioned above. We were able to .nd potential races in some cases \nand prove the absence of races in others. Related Work. Type based race detectors [11, 4] provide strong \ntype systems that guarantee the absence of races, but require code annotated with locking information. \nAddition\u00adally, control .ow information may be used for more precision [26]. However, none of these methods \ncan prove absence of races in programs with complex state-based synchronization idioms. Dynamic race \ndetectors [25, 6] are e.ective in .nd\u00ading bugs but cannot guarantee their absence. Software model checkers \nlike SLAM [3] and Blast [20] check sequential programs. Verisoft [14], Bandera [8], Feaver [22], Magic \n[5], and Java Path.nder [16] check concurrent programs with a .xed .nite number of threads. Verisoft \nruns on the concrete semantics of the program, the oth\u00aders require a user supplied abstraction. 3VMC \n[27] treats an unbounded number of threads, but again requires a user supplied abstraction. Calvin [12] \nrequires that a suitable ab\u00adstract context is provided. Magic [5] checks a .nite number of concurrent \nthreads communicating by message-passing. Since communication is explicit, abstraction and minimiza\u00adtion \nare done independently of the other threads, i.e., reach\u00adability information is not required. Parametric \nveri.cation methods [24, 9, 2, 10] handle arbitrarily many threads using counters, but assume .nite-state \nprocesses.  2. AN EXAMPLE We begin with describing how our algorithm works on an example. The formal \ndevelopment of the technique is postponed to the next section. Consider the fragment of code showninFigure \n1, taken from a nesC program [13]. This fragment describes the behavior of a single thread; x and state \nare global variables and each thread has a local variable called old. The multithreaded program P has \nan arbitrary number of threads running this code concurrently. We wish to verify that there are no races \non x in P, i.e., that P never reaches a state where two (or more) threads are about to access (read or \nwrite) x, and one of the accesses is a write. 2.1 Threads Threads. We represent each thread as a Control \nFlow Automaton (CFA). The CFA is essentially the control .ow int x, state; Thread() {int old; 1: while \n(1) {atomic{ 2: old := state; 3: if (state = 0){ 4: state := 1; } [old != 0] } 5: if(old=0){ 6: x:= \nx+1;  state = 0 {state} 7: state := 0; } } state = 1 {x , state} }  Figure 1: (a) Thread (b) CFA (c) \nACFA graph of the thread, with instructions labeling the edges instead of the vertices. A CFA consists \nof: (1) integer vari\u00adables, local and global, that are accessed by the thread, (2) control locations, \nsome of which are atomic and one of which is the distinguished start location, and (3) directed edges \nthat connect the vertices. Each edge is labeled by either an assignment that is executed when the thread \nmoves along theedgeorby an assume predicate which must be true for control to move along the edge. Example \n1: [Thread] Instead of a formal de.nition, con\u00adsider the CFA shown in the middle in Figure 1 for the \nthread shown on the left in the same .gure. The assignments are in the boxes and the assume predicates \nare labeled with [\u00b7]. The vertices marked with * are atomic locations. The atomic construct of nesC allows \na sequence of operations to occur without preemption; atomic locations model this. If in a multithreaded \nprogram, a thread is at an atomic loca\u00adtion, only that thread is allowed to execute. . Informal Semantics. \nA multithreaded program is a set of threads where each thread is represented by a CFA. A state of a multithreaded \nprogram is a valuation for all the vari\u00adables, including the global variables shared by all threads and \neach thread s local variables (e.g., program counter). We shall assume for clarity that all threads have \nthe same CFA. In the initial state, each thread is at the start loca\u00adtion, and all the variables have \nvalue 0. The system evolves as follows. (1) A thread is scheduled: if some thread is at an atomic location, \nit gets to run, otherwise some thread is chosen non-deterministically. (2) The scheduled thread picks \none of the out-edges of the location it is at and exe\u00adcutes it and proceeds to the target of the edge. \nIf the edge is an assume, this happens only if the state satis.es the predicate and the variables remain \nunchanged; if the edge is an assignment x:=e then the expression e is evaluated and written into x, and \nthen the program moves to the target location of the edge. It can be checked that if the start loca\u00adtion \nis not atomic, then in any reachable state at most one thread is at an atomic location. Data Races. There \nis a data race on the variable x if the program can reach a state in which two or more threads have enabled \nactions that read or write x, and at least one of these accesses is a write. We say a thread can write \n(read) x if there is an out-edge from its location where x is assigned (read). Thus a state has a race \non x if (1) no thread is at an atomic location, and (2) one thread is at a location where x may be written \nand another is at a location that may access x. In the program comprising threads of Figure 1, there \nare no races on x if in every reachable state, at most one thread is at location 6.  2.2 Thread-Context \nPrograms We analyze a multithreaded program as a thread-context program (TCP), which comprises a main \nthread executing in a context which represents all the other threads. We model each of the context threads \nusing an abstract thread. Abstract Threads. An abstract thread is represented by an abstract control \n.ow automaton (ACFA). An ACFA is a directed graph, whose vertices are abstract control locations labeled \nby predicates on the global variables of the program, and optionally by atomic, and whose edges are labeled \nby sets of havoced global variables. When the automaton moves from one location to the next, the havoced \nvariables on the traversed edge are written to with arbitrary values, but the successor state is constrained \nto satisfy the predicate label\u00ading the successor location. Example 2: [Abstract Thread] Figure 1(c) shows \nan ACFA for the thread of the example. Locations labeled * are atomic, and if there is an (abstract) \nthread at an atomic lo\u00adcation, then only that (abstract) thread is scheduled. Each location is also labeled \nby a predicate inside a box, locations not labeled explicitly have the label true. Note this abstrac\u00adtion \ncaptures the essence of the behavior of the thread: .rst, it enters the atomic block, then if state is \n0, it havocs state subject to the constraint that state is 1 in the next state. It then proceeds to access \nx, as it will have set its old to 0, andthenhavocs state to any arbitrary value. Alternately, if state \nis not 0 when the thread entered the block, then it would set its old to a non-zero value and thus loop \nback without writing to x or state. . Informal Semantics. A TCP is a set {C }.A. comprising a main thread, \nrepresented by a CFA C ,and a context which is an arbitrary number of abstract threads A.The semantics \nof a TCP are similar to that of a multithreaded program. At the initial location, the main thread is \nat the start location of C and each context thread is at the start location of A. At each time step, \neither the main or a context thread is scheduled, and the scheduled thread makes a transition according \nto one of the out-edges of its current location. 2.3 Veri.cation by Abstraction Our method works by \nanalyzing a TCP which is an ab\u00adstraction of the program we wish to verify. Abstraction Components A precise \nanalysis of the reachable states of a multithreaded program must abstract the state space to counter \nthe in.\u00adnite data valuations as well as the exponential number of possible program location tuples. Accordingly, \nwe present three orthogonal abstractions. 1. Data Abstraction. The number of valuations for the program \nvariables is in.nite. To deal with this, we use pred\u00adicate abstraction [15], where instead of tracking \nthe exact values of variables, we track relationships between program variables captured by boolean formulae \nover a .nite set of predicates over the variables. Any local variable in a predi\u00adcate refers to the main \nthread s copy of the local. 2. Control Abstraction. The number of con.gurations of other context threads \nis exponential in the number of program locations of each thread. To ameliorate this ex\u00adponential blowup, \nwe represent each context thread as an abstract thread which is a state machine that (1) has fewer locations \nthan, and (2) overapproximates the behavior of (e.g., simulates), the thread it represents. All the predicates \nlabeling the ACFA vertices are over the globals; information pertaining to the local state of context \nthreads is encoded in the ACFA location. 3. Counters. There may be an arbitrary number of con\u00adtext threads. \nTo make our analysis sound in this setting, we must model the ACFA location of each of the arbitrar\u00adily \nmany context threads. To do this, we track the number of abstract threads that are at each of the .nitely \nmany ACFA control location [24]. Since this representation is in\u00ad.nite, we use a counter abstraction: \nwetrack thenumber precisely so long as it is less than or equal to a parameter k, and any number greater \nthan k is abstracted to ., meaning an arbitrary number of threads is at that abstract control location.1 \n Abstract Multithreaded Programs Given a set of predicates P, and a natural number k,we say that P =((C \n,P),(A,k)) is an abstract multithreaded program, which represents an abstraction of {C }.A..An abstract \nstate of P is the tuple ((pc,.),G), where pc is the main thread s control location, . is a boolean formula \nover the predicates P (local variables refer to the main thread s copy of the local variable), and G \nis a map from A s vertices to {0,...,k,.}. The operations enabled at an abstract state are the operations \nenabled at pc and at each location n of A s.t. G.n > 0, so long as none of the above mentioned locations \nis atomic, otherwise, the enabled operations are the operations enabled at the (single) atomic location. \nIn the initial abstract state, the main thread is in the ini\u00adtial location of C ,G is . for the initial \nabstract location, and 0 elsewhere, and . is the predicate abstraction (w.r.t. P)of the state where all \nvariables are 0. For an abstract state s =((pc,.),G) andanoperation op, the successor abstract state \npost. =((pc '),G'as If s.op ,.') is computed follows. 1Note: k+1= ., .+1= .,and .-1= . the operation \nis the main thread s operation, then pc . is the target of the CFA edge taken, .. is the predicate abstrac\u00adtion \n(w.r.t. P) of the strongest postcondition of . w.r.t. the operation [15, 20], and G. =G. Ifit is a contextACFA \nmov\u00ading across an abstract edge n.n ',then pc . = pc, .. is the predicate abstraction (w.r.t. P)of (.y1 \n\u00b7\u00b7\u00b7yk..).r.n . where y1 \u00b7\u00b7\u00b7yn are havoced on edge n .n . and n . is labeled with the predicate r.n ',and \nG. maps n to G.n-1, n . to G.n . +1, and all other n to G.n . Abstract Reachability. We build the set \nof reachable abstract states by iterating post from the initial abstract state until a .xpoint. We check \nif there are races by checking if any reachable state contains a race. If so, the reachability procedure \nreturns an abstract error trace. We say that G is an abstract reachability graph (ARG) for P =((C ,P),(A,k)), \nif it is an ACFA that overapproxi\u00ad mates the behavior of C in P. 2 The reachability procedure also computes \nan ARG G for P which we use to guarantee the soundness of A.If A is an overapproximation of (e.g., can \nsimulate) G then we know that A is sound. If not, a minimized version of G gives us a better abstraction \nof the individual threads, which we use in the subsequent analysis.  2.4 The Algorithm CIRC Given a \nCFA C , and a global variable x,we wishto ver\u00adify that in the multithreaded program comprising arbitrarily \nmany copies of C running concurrently, there are no races on x. In addition, the user may supply an initial \nset of pred\u00adicates P (the default is \u00d8), and an initial counter parameter k (the default is 1). Initialization \n( Initial context ) Set the initial ACFA A to be the empty ACFA, i.e., the context does nothing. Step \n1 ( Reachability: Assume ) Assuming that the con\u00adtext is made of threads behaving as A, compute the set \nof abstract reachable states of C using the present set of predicates P. Simultaneously build an abstract \nreachability graph (ARG) which is an ACFA Goverap\u00adproximating the behavior of C in the current context \n(Algorithm ReachAndBuild in Section 3). Step 2 ( Counterexample analysis ) Check if the reachable states \ncomputed above contain states with races on x. If there are no such states, go to step 3. Other\u00adwise, \ncheck whether this trace is real by .rst gener\u00adating a concrete sequence of interleaved thread opera\u00adtions \n(from the sequence of thread/ACFA operations) and then checking if the interleaved trace is feasible. \nThe concretization of the ACFA trace is done using the ARG of which the ACFA is the minimized ver\u00adsion. \nHence, every sequence of ACFA operations, cor\u00adresponds to a (possibly infeasible) path through the underlying \nCFA. If (a) it was not possible to generate the concrete trace as the counter was too low, incre\u00adment \nk, (b) the concrete trace is infeasible, infer new predicates [18] and add them to the set of predicates \nP, (c) the concrete trace is feasible then return Un\u00adsafe with the genuine error trace. Reset A to the \nempty context and go to step 1. Step 3 ( Guarantee ) Check that the A assumedinstep1 was sound by checking \nthat it overapproximates G 2We make this notion precise in Section 3   Figure 2: (a) ARG G1 (b) Min. \nARG A1 Figure 3: (a) ARG G3 (b) Min. ARG A3 Figure 4: ARG G5 computed in step 1 (Algorithm CheckSim). \nIf so, re\u00adturn Safe,else, set A to be the bisimulation mini\u00admization of G (Algorithm Collapse), and go \nto step 1. Running CIRC. We shall now run the algorithm on the example of Figure 1. Recall that there \nis no race on x.The .rst thread that goes inside the atomic block sets state to 1 and subsequent threads \nalways set their old to1and so do not write state or x. Once the original thread has set state back to \n0 the other threads can make another attempt, in which they set their old to 0, set state to 1 and then \naccess x. Initialization The initial ACFA A0 is set to be the empty ACFA. The initial set of predicates \nP0 is empty, but control .ow is explicitly tracked. Iteration 1 Step 11, 21 The ARG G1 of ReachAndBuild \nis shown in Fig\u00adure 2(a). All the control locations are reachable and the state is just true, i.e., we \nknow nothing about the values of the variables of C . The reachability is trivially free of races as \nthe context threads do nothing. Step 31 Since A0 was empty, Algorithm CheckSim detects that A0 does not \noverapproximate G1 and hence A0 is unsound. Thus, we minimize G1 to get the new ACFA A1 shown in Figure \n2(b). The dotted circles denote the sets of G1 states that are merged into a single A1 state. The minimized \nACFA starts at a non-atomic location, then moves into an atomic location, in which it havocs state and \nmoves to a non-atomic location from which it again havocs {x, state} and returns to the start location. \nThe locations I,II are not collapsed together as we wish to preserve atom\u00adicity, the same holds for II,III.Locations \nI,III are not collapsed as x can be written only in III. We repeat the loop setting A to be A1. Iteration \n2 Step 12 On redoing reachability assuming the context threads behave as A1 we .nd a race where one of \nthe context threads moves two steps to reach the abstract location III (Figure 2(b)), following which \nthe main thread moves to the concrete location 6. Step 22 We concretize the abstract trace described \nabove and .nd that the thread followed an infeasible path: 1 . 2 . 3 . 5 . 6, i.e., the trace is infeasible \nwithout even considering the other thread. From this trace, we learn the predicates old = state and old \n= 0 are required to rule out this infeasible path. We add these to get the new set of predicates P2, \nset the context ACFA A2 to be the empty ACFA, and go back to step 1. Iteration 3 Steps 13, 23, 33 We \nrepeat the reachability using A2 and P2,toget the ARG G3, shown in Figure 3(a). Notice that this time, \nthe only path to the location where the write is enabled is a feasible path for each thread. Again, the \nreach set is trivially error free. As G3 is not overapproximated by A2, the latter being the empty ACFA, \nwe set A to be A3 which is the result of minimizing G3. Thisisshown in Figure 3(b). Note that the path \nthat leads to III where to the write to x is enabled is feasible for the individual threads. Iteration \n4 Step 14 We recompute the reachability assuming the con\u00adtext has threads behaving as A3, and the predicates \nP2.The same abstract race as in step 12 is possible again. Step 24 We concretize the trace from the previous \nstep. This time, we get the feasible path 1 . 2 . 3 . 4 . 5 . 6 for the individual threads, but .nd that \nthe composed trace, where the context thread follows the above path and waits at 6 then the main thread \nfollows the same path to 6 is infeasible. This is because the .rst thread will set state to 1, and so \nthe second thread cannot take the assume edge 3 . 4. The analysis reveals the predicates state =0and \nstate = 1 rule out this behavior and we add these to our set to get P4,set A4 to be the empty ACFA and \nreturn to step 1. Iteration 5 Steps 15, 25, 35 We repeat the reachability using A4 and P4,toget the ARG \nG5, shown in Figure 4. Notice that this time, the vertices in G5 contain the values of state.The reach \nset is error free, but G5 is not overapproximated by A4, the latter being the empty ACFA, so we set A \nto be A5 which is the result of minimizing G5. Thisisthe same as the ACFA shown in Figure 1(c). Notice \nthat II,III are not collapsed as they di.er on the values of predicate state =0. Notice also, that in \nA5, the various locations are labeled by predicates describing the value of state when the abstract thread \nis at that location. In particular, when a thread is at IV,the value of state is non-zero, thus preventing \nother threads from writing x. Iteration 6 Step 16, 26 We compute the ARG with the new ACFA A5 with counter \nparameter still 1. We .nd a few more states, e.g., after a thread sees in its atomic block that state \nis 1, it may see that it has been havoced, but this is not essential as the thread still just returns \nto the head of the loop (since its old is still 0). There is no error possible as if a context ACFA goes \n.rst, it keeps state at 1 till after it has written x: so when the main thread takes the assume edge \n3 .4 ( [state = 0]) the abstract state is empty (state =0.state = 1 is unsatis.able) meaning that edge \nis not behavior is not possible. Similarly, if the main thread gets in .rst, when a context thread attempts \nto take the abstract edge 2, ' .3' the abstract state is empty. The resulting ARG is G6,and we proceed \nto step 3. Step 36 We .nd that in fact G6 is overapproximated by A5 and so the context approximation \nis sound. We conclude the system is free of races.  3. MULTITHREADED PROGRAMS AND ABSTRACTIONS In this \nsection we shall de.ne our model for multithreaded programs. First we de.ne the semantics of such programs \nabstractly using transition systems. Then we de.ne the syntactic representations of threads (CFAs) and \nabstract threads (ACFAs) and de.ne their transition systems, and .nally describe the semantics of multithreaded \nprograms. 3.1 Shared Variable Transition Systems Given a set X of variables, an X-state is a valuation \nof the variables in X.Let VX be the set of all X-states. An X\u00adtransition relation is a subset of VX \u00d7VX \n. A multithreaded program P is a set {(.1, At1), (.2, At2),...}where .i is an Xi transition relation \nand Ati .VXi is an atomic predi\u00adcate. The set of variables of Pis X = .Xi. The set of global variables \nof P is P.XG = {x |.i= j :(x .Xi nXj)}.The set of states of P is VX , and the semantics of P are given \nby an X-transition relation .P and an atomic predicate At .VX de.ned as follows: De.ne the predicate \nEn.s.i where s is an X-state and i athreadas: En.s.i = ((.j : (Atj.s)) .Ati.s). The atomic predicate \nAt.s =.i :(Ati.s). The transition relation is de.ned as: s .P s' i.there is an ' i such that (1) En.s.i \n(2) t .i t(3) .x . Xi :(s.x = '' ' t.x .s.x = t.x)(4) .x .Xi :(s.x = s.x). That is, if the thread i is \nenabled, then it updates its variables according to its transition relation, and all the other variables \nremain unchanged. The initial state s0 of Pmaps every variable to . * 0. Let P be the re.exive transitive \nclosure of .P .We de.ne [ P]] = {s |s0 . P* s}to be the set of reachable states of P. 3.2 Threads: Control \nFlow Automata Given a set of variables X,the set Exp.X is the set of arithmetic expressions over the \nvariables X,the set Pred.X is the set of boolean expressions (arithmetic comparisons) over X,and the \nset Op.X is the set of instructions contain\u00ading: (1) assignments x:= e,where x .X and e .Exp.X, and (2) \nassume predicates asm [p], where p .Pred.X,rep\u00adresenting a condition that must be true for the edge to \nbe taken. A control .ow automaton (CFA) is a tuple (Q, q0,X, .,Q *),where (1) Q is a .nite set of con\u00adtrol \nlocations, (2) q0 . Q is the initial control location, (3) X is a set of variables, partitioned into \nXG and XL, disjoint sets of global and local variables, respectively, (4) .. (Q \u00d7Op.X \u00d7Q) is a .nite \nset of directed edges  labeled with operations, and (5) Q * .Q is a set of atomic '' op locations. An \nedge (q, op,q) ..is also written as q-.q. For clarity we describe our method only for CFAs without function \ncalls; we implement function calls in our tool. ACFA C = (Q, q0,X, .,Q *)induces a state space VX.C where \nX.C = X .{pc}. 3 The atomic predicate At.C of the CFA is {s |s.pc .Q * }, that is, a state is atomic \nif the op ' thread is at an atomic location. We say that s . sif: (1) if op is asm p then s |= p and \ns'.y = s.y for all y .X,and (2) if op is x := e then s'.x = s.e and for all y .X \\{x}, ' s.y = s.y. The \ntransition relation .C is de.ned as follows: op ' ' s .C sif there exists some op such that s.pc-.s.pc \nin the op ' CFA C,and s . s. A set of states p over the set of variables X is called a data region.A \npredicate over X represents a data re\u00adgion consisting of all valuations that satisfy the predicate. We \nlift the transition relation to sets of states by de.n\u00ading the strongest postcondition operation sp.p.(q, \nop,q')= ''' .x : p[x/x] .x = e[x/x]if op is x := e and p .p if ' op is asm p.Note that sp.p.(q, op,q) \nrepresents the set op {s' .VX |.s .p :(s . s')}. We can now describe multithreaded programs and their \nsemantics. For clarity we shall restrict ourselves to symmet\u00adric multithreaded programs where each thread \nruns the same code, i.e., has the same CFA C.Let C. denote the sym\u00admetric multithreaded program running \nan arbitrary num\u00adber of copies of the CFA C. Formally, C. is the program {(.1, At1), (.2, At2),...}where \neach pair (.i, Ati)is de\u00ad.ned as follows. Let Ci be the CFA C with each local vari\u00adable x . XL .{pc} \nrenamed to xi.Then .i=.Ci and Ati = At.Ci. 3.3 Thread-Context Programs We shall consider multithreaded \nprograms in which a main thread runs in a context of an arbitrary number of abstract threads. For this, \nwe de.ne abstract threads, and Thread-Context programs (TCPs). Abstract Threads: Abstract Control Flow \nAu\u00adtomata. An Abstract CFA (ACFA) is a tuple (Q, q0,X, .,Q * ,r),where (1) Q is a .nite set of abstract \nlocations, (2) q0 . Q is a start location,(3) X isaset of variables partitioned into XG and XL, disjoint \nsets of global and local variables, respectively, (4) .. (Q \u00d72X \u00d7Q)is a .nite set of directed havoc edges \nlabeled with subsets of X,(5) Q * . Q is a set of atomic abstract locations, and (6) r : Q . Pred.X is \na location labeling function label\u00ading each location with a an abstract data region. An edge ' ' (q, \nY,q) is also written as q.q -Y, An ACFA A = (Q, q0,X, .,Q * ,r)induces a state space S.A .VX.A where \nX.A = X .{pc} and s . S.A i. s |= r.(s.pc). The atomic predicate At.A of the ACFA is {s |s.pc .Q * }, \nthat is, a state is atomic if the abstract thread is at an atomic location. The transition relation ' \n.A. S.A \u00d7S.A of an ACFA A is de.ned as s .A sif: (1) s.pc-ops .'.pc and (2) if op is Y then for each \nx.{pc}.Y, we have s'.x = s.x,and s' |= r.(s'.pc)The sp opera\u00adtor for sets of states and ACFA operations \nis de.ned as: ' sp.p.(q, Y,q)=(.y .Y.p) .A.r.q'. Thread-Context Programs. A thread-context program {C}.A. \nconsists of a CFA C and a context A. of an arbi\u00adtrary number of copies of an ACFA A. Formally, {C}.A. \nis the program {(.C, At.C)}.{(.1, At1), (.2, At2),...} 3We abuse notation to identify Q and .and q0 with \n0. where each pair (.i, Ati) is de.ned as follows. Let Ai be the ACFA A with each local variable x .XL \n.{pc}renamed to xi.Then .i=.Ai and Ati = At.Ai.  3.4 Abstractions As mentioned in Section 2, to make \nthe analysis tractable, we make the state space small and .nite by abstracting the system along several \northogonal dimensions. 1. Data Abstraction. First, we combat the in.nite data space by abstracting the \nstate space of each thread using predicates [15, 3, 20, 5]. For a set of predicates P .Pred.X and a formula \n. over X,let Abs.P.. denote the smallest (in the inclusion order) set of data regions expressible as \na boolean formula over atomic predicates from P. A thread abstraction is a pair (C, P)where C = (Q, \nq0,X, .,Q * )aCFA and P .Pred.X is a set of predi\u00adcates. An abstract thread state is a pair (q, .)where \nq .Q and . is a boolean formula over atomic predicates from P. The set of abstract thread states is S.(C, \nP). 2. Control Abstraction. Second, we must track the local states of each thread separately. Just the \ncontrol states of each thread su.ce to overwhelm the analysis (since their size of the state space grows \nas the product of the number of control locations of each thread). Thus, we approximate the behavior \nof each thread using a abstract thread.  Our algorithm incrementally builds abstract threads until it \nhas one that overapproximates the behavior of the thread in the context. To know when the above happens, \nwe re\u00adquire a notion of when abstract thread overapproximates another. We formalize this notion as a \nsimulation -re\u00adlation [17, 7]. Given two ACFAs A = (Q, q0,X, .,Q * ,r)and A1 = (Q1,q10,X1, .,Q * 1,r1), \n-is the largest subset of Q1 \u00d7Q such that: if q1 -q then (1) r1.q1 . r.q, tY ' An abstract program de.nes \nthe following transition sys\u00adtem. The set of abstract program states is S.(C ,P) \u00d7 S.(A,k). A particular \nabstract program state is ((q, p), G) where q is the control location of the thread, p is a boolean formula \nover P, and G is an abstract context state, i.e., a map from A.Q to {0 ...k, .}. An abstract program \nstate represents a set of states of the multithreaded program {C}. A. . The initial abstract state is \ns 0 =((C .q0, true), G0) where G0 maps the initial state A.q0 of the ACFA to . and maps q for q = A.q0 \nto 0. The operations of a location q . C .Q (q ' . A.Q)are the operations labeling the out-edges of the \nlocation. For an abstract state s =((q, p), G), the set of locations is L.s = {q}.{q ' .A.Q |G.q ' > \n0}, i.e., the set of (abstract) locations containing threads, and the the set of atomic loca\u00adtionsisthe \nset AL.s = {q ' .A.Q * |G.q ' > 0}.({q}nC .Q * ), i.e., it is the set of (abstract) atomic locations \ncontaining threads. The set of operations enabled in the abstract state s is de.ned as follows: (1) If \n|AL.s | = 0, then the enabled operations are the operations of the locations in L.s .(2) If |AL.s |= \n1, then the enabled operations are the operations of the unique location in AL.s . (3) Otherwise, no \noperations 4 are enabled in s. For an abstract context state G, let ..G= .{A.r.n |G.n > 0}. The abstract \ntransition relation is de.ned by the operator post that takes a abstract state and an operation o, and \nproduces the successor abstract state. For the operation o =(q, op,q ' )of C at the state ((q, p), G), \nwe compute the successor state post.((q, p), G).(q, op,q ' )as ((q ' ,p ' ), G ' ), where G ' =G and \np ' = Abs.P.(sp.p.(q, op,q ' )) . ..G ' . For the op\u00aderation o =(q1' , {y1,...,yn},q2' )of A, the successor \nstate post.((q, p), G).(q1' , {y1,...,yn},q ) 2' )= ((q, p ' ), G ' and, G '' ' G '' ' where .q1 = a.k.(G.q1 \n- 1), .q2 = a.k.(G.q +1), 2 (2) For every q1-1 there exists a q .q Y -.q ' 00 and q1 -q ' .We say A1 \n-A if q1 -q . p ' ' such that Y .Y ' ' ''' ' and for all q . A.Q \\{q1,q2},G ' .q =G.q . and 1, Y,q2' \n)) ...G ' . ' = Abs.P.(sp.p.(q 3. Counter Abstraction. Third, for soundness, in many situations we must \nassume that there are arbitrarily many context threads running concurrently. Thus, we have to track the \nlocal state of an in.nite number of context threads, in addition to the values of the global variables. \nWe model each context thread with an ACFA whose whose local infor\u00admation is encoded in the ACFA location. \nIn other words, the variables appearing in predicates labeling the ACFA lo\u00adcations and on the ACFA edge \nlabels are all global vari\u00adables. Now, instead of tracking the control location of each thread separately, \nwe shall count the number of threads at each control location. This still leads to an in.nite number \nof possibilities so we shall use a counter abstraction,where given a parameter k we shall abstract any \nnumber greater than k to be .. Formally, for every k .I.{.}, we de.ne the counter abstraction function \na.k : I.{0, ...,k, .}as a.k.j = j if j =k and . otherwise. A context abstraction is apair (A,k)where \nA = (Q, q0,X, .,Q * ,r) an ACFA and k .Iis a natural number. An abstract context state is a function \nG : A.Q .{0 ...k, .} mapping states to counter values in {0, ... ,k,.}. The set of abstract context states \nis Wesay s s ' . if there exists an operation o which is enabled in s such that post. s '' )is an operation \ns.o = .If o =(q, op,q ' ''' of C ,thenwe say s s, Y,q ) . via a program edge. If o =(q is an operation \nof A,then wesay s s ' . via an environment edge. The reachable states [ P ]] = { s0 s}. s | . * Given \nthe operation post, we can construct a reachabil\u00adity tree for an abstract multithreaded program by starting \nfrom a root node labeled with s0 and constructing successors for each node by computing post for each \nenabled operator. Precisely, the reachability tree for an abstract multithreaded program is a labeled \ntree where each node is labeled with an abstract state, and each edge is labeled with an operation. The \nroot of the tree is labeled with s0. For each node n marked with s, and each operation op enabled at \ns,there is a child n ' of n marked with post.s.op. Abstract Reachability Graph. An abstract reachability \ngraph for an abstract multithreaded program ((C,P), (A, k)) is an ACFA G = (Q, q0,X, .,Q * ,r) such that \nthere is a function f : S.(C, P) \u00d7S.(A, k) . Q such that (1) for all s =((pc,p), G), we have p implies \nG.r.(f.s ), (2) f.s 0 = q0 for the initial state s0 of the abstract multithreaded program, ' ' Y Abstract \nMultithreaded Programs. A thread abstrac-where Y contains all the variables written in op,and (4) if \ntion and a context abstraction de.nes an abstract (multi-s s ' via an environment edge, then f.s = f.s \n' .An ARG .  threaded) program P =((C ,P), (A,k)) representing an ab\u00ad 4 straction of the thread-context \nprogram {C }.A..The So long as the initial locations are not atomic, this will variables of the ACFA \nA are the global variables of C . never arise denoted S.(A,k). ' (3) if s s . via a program edge (q, \nop,q ), then f. - s.f. s for ((C, P ), (A, k)) is an ACFA that is an abstraction (over\u00adapproximation) \nof the behavior of C in the TCP {C}.A. . In other words, the ARG represents (an overapproximation of) \nthe set of transitions of C reachable in {C}.A. .  4. SAFETY VERIFICATION 4.1 The Race Detection Problem \nGiven a multithreaded program P = {T1,T2,...} with the variables X, and a set of error states E.VX , \nthe multi\u00adthreaded safety veri.cation problem is to check if [ P]] nE = \u00d8. A multithreaded program Pis \nsafe w.r.t. Eif [ P]]nE = \u00d8, and unsafe otherwise. A speci.c instance of the above is the race detection \nprob\u00adlem. For each global variable x .P.XG,let Write.i.x .VX (resp. Read.i.x .VX )denotethe setof states \nfrom which thread i has an enabled operation that writes (resp. reads) x. An operation writes x if either \nit is a CFA edge, and the operation is an assignment to x,or it is an ACFA edge, and the variable x is \nin the set of havocs of the edge. An operation reads x if it is a CFA edge, and the opera\u00adtion is an \nassignment y := e and x is a variable of e,or an assume asm [p]and x is a variable of p.Notice that Read \n.i.x = \u00d8 if Ti is an ACFA. The race-states Ex for a variable x .P.XG are X-states where two distinct \nthreads have accesses to x enabled, and one of the accesses is a write, i.e., Ex = .i=.j(Write.i.x .Read \n.i.x) nWrite.j.x.The race\u00addetection problem for a program P and a global variable x is to check [ P]] \nnEx = \u00d8. We say a program P has no races on variable x i.the program P is safe w.r.t. Ex. 4.2 Checking \nSuppose that we are given the CFA C, and a global vari\u00adable x of the CFA, we would like to check if there \nare races on x in C. . In addition, suppose we have a set of predicates P , and abstract thread A that \npurportedly describes suc\u00adcinctly the behavior of C, as well as a number k with which to abstract the \ncontext. We now describe how these various objects can be used to check that [ C. ]] nE = \u00d8(Algorithm \nCheck). There are two main steps: 1. Assume that A is a sound approximation of the behavior of C when \nC is composed with in.nitely many copies of itself. Compute the set of abstract states reachable in the \nabstract multithreaded pro\u00adgram ((C, P ), (A, k)) and check that this set does not contain any races. \nIf an error is reached, return possi\u00adbly Unsafe. This step is implemented by procedure ReachAndBuild, \nwhich does a reachability analysis and also builds an abstract reachability graph G describ\u00ading the behavior \nof C when its context is an arbitrary number of abstract threads A running concurrently. 2. Guarantee \nthat the abstract thread A is indeed a sound approximation of the behavior of C in this con\u00adtext, by \nchecking that abstract reachability graph G computed in the previous step is overapproximated by A,or \nmore precisely,that G -A.If the check succeeds, return Safe, else return possibly Unsafe. This is implemented \nby procedure CheckSim.  The soundness of the above follows via inductive assume-guarantee reasoning \n[23, 1]. We now describe ReachAndBuild and CheckSim in greater detail. Algorithm 1 Algorithm ReachAndBuild \nRequire: A thread abstraction (C ,P ), error states E Require: A context abstraction (A,k) 1: Output: \nAn ACFA A ' or raises exception Exception(t ) 2: L := {(C .q0, true), G0)}, Seen := \u00d8, G := \u00d8 3: while \nL = \u00d8do 4: pick and remove state ((q, p), G) from L 5: if not (((q, p), G) .Seen) then 6: Seen := Seen \n.{((q, p), G)} 7: if ((q, p), G) nE = \u00d8then 8: t := FindPath.Seen.((C .q0, true), G0).((q, p), G) 9: \nraise Exception(t ) 10: else 11: for each enabled operation o do 12: ((q ' ,p ' ), G ' ):= post.((q, \np), G).o 13: Connect.G.((q, p), o, (q ' ,p ' )) 14: L := L .{((q ' ,p ' ), G ' )} 15: return G Algorithm \n2 Algorithm Connect Require: Augmented ACFA G =(Q, .,r, S), where S : Q .2S.(C,P ) Require: (r, op,r \n' )where r, r ' .S.(C ,P )and o 1: n := Find.G.r; n ' := Find.G.r ' x:=e 2: if op =---.then Y 3: if n-n \n' is in G for some Y then . YY.{x} 4: Replace (n-n ' )with (n-.n ' .---)in G 5: else {x} 6: Add n--.n \n' to G asm [p] 7: else if op =----.then Y 8: if n-n ' is not in G for some Y then . \u00d8 -n 9: Add n.' to \nG 10: else 11: Union.G.(n, n ' ) Procedure ReachAndBuild is shown in Algorithm 1. It is a standard worklist \nbased reachability algorithm [7], but addi\u00adtionally builds an abstract reachability graph G summariz\u00ading \nthe reachability information. The main loop of lines 3 14 runs the reachability construction, using the \nworklist L.At each step, a state is chosen from the worklist. If it has not been seen before (line 5), \nit is added to the set of explored states (line 6), and checked for possible errors. If an error state \nhas been hit (line 7), the procedure .nds an (abstract) interleaved error trace to the error state, and \nraises an ex\u00adception containing the error trace. Otherwise, the current state is expanded. For this, \nwe construct the successor of the current state for each operation enabled from it (line 12), and connect \nthe current state and its successor as an edge in the abstract reachability graph G, using the procedure \nConnect described shortly. Finally, the successor states are added to the worklist. Note that the locations \nof the ab\u00adstract reachability graph G correspond to abstract thread states, that is, we drop the context \nstate information. Procedure Connect adds edges between the abstract states computed by the reachability \nanalysis (Algorithm 2). It takesasargument the augmented ACFA G that is being constructed, abstract thread \nstates r and r ' (the successor of r), andanoperation o. Each location of G corresponds to a set of abstract \nthread states. The ACFA G is augmented with a map S that maps a location n to the set G.S.n of thread \nstates mapped to n. Connect .rst .nds locations n, n ' corresponding to r and r ' respectively by invoking \nthe procedure Find.When Find is called with abstract thread Algorithm 3 Algorithm Find Require: Aug. \nACFA G =(Q, .,R,S)and r .S.(C ,P ) 1: Output: Alocation q .Q 2: if .q .Q : r .S.q then 3: return q 4: \nelse 5: q =fresh location 6: G.Q := G.Q .{q} 7: G.R.q := r 8: G.S.q := {r} 9: return q Algorithm 4 Algorithm \nUnion Require: Aug. ACFA G =(Q, .,R,S)and q, q ' .Q 1: if (q = q ' ) then 2: G.R.q = G.R.q .G.R.q ' 3: \nG.S.q := G.S.q .G.S.q ' 4: for each q*'' .q ' -* do .q to G 5: Add q '' -* 6: for each q ' .q '' -do \n7: Add q.q '' -* to G 8: return q state r it checks if a there exists a location n with r .G.S.n; If \nso, it returns that location and if not, it returns a new location n where G.S.n = {r}. The location \nis atomic, if r =(q, p)where q . C .Q * . An invariant maintained is that G.R.n = .G.S.n. The edges of \nthe graph G are added depending on the type of the operation o.There are two cases: o is either a thread \noperation, or a context operation. If the threadmove is anassignment x := e, then we add the {x} Y- edge \nn--.n ' (the {x} re.ecting the fact that x is updated along the edge); however if an edge n.' n is already \npresent Algorithm 5 The inference algorithm CIRC Require: CFA C, error states E 1: P := \u00d8,k := 0 2: while \ntrue do 3: try 4: G = \u00d8 5: repeat 6: (A,\u00b5):= Collapse.G 7: G := ReachAndBuild.(C ,P ).(A,k).E 8: until \n(G -A) 9: return Safe 10: with (Exception(t )) . 11: if Re.ne.C.A.G.\u00b5.t = Real(\u00afs) then 12: return Unsafe(\u00afs) \n13: else 14: (P ' ,k ' ):= Re.ne.C.A.G.\u00b5.t 15: P := P .P ' 16: k := k ' 17: done We start o.by assuming \nthe that each thread in the con\u00adtext does nothing, i.e., G is set to the empty abstract thread (line \n4). We then minimize the abstract reachability graph G with the procedure Collapse (line 6). Collapse \ntakes abstract reachability graph G and returns its weak bisimulation quo\u00adtient ACFA A [7], together \nwith a map \u00b5 that maps each state of G to its equivalence class (state) in A. In the .rst round, this \nis still empty. At each round, A will be the cur\u00adrent approximation of the context threads, and will \nbe used to make the context of C .We then call ReachAndBuild to see how C behaves in this context, the \nresult being the new abstract reachability graph G (line 7). If the present approx\u00adimation A simulates \nthe new abstract reachability graph G then it means that A was a sound approximation (i.e., meets the \nguarantee ), and we break out of the loop and return Safe (lines 8, 9). This check is performed using \nthe proce\u00ad Y.{x} in G, we replace it with n----.n ' If the thread move is an . dure CheckSim. If on the \nother hand, we .nd that A was not a good approximation (fails to meet the guarantee) then we -\u00d8n ' . \n, (in this case, no [p] then we add the edge n assume asm variable is added to the havoc edge), unless \nthere is already repeat the loopwiththe new G, which now gives us a better ' an edge n-n . Finally, if \nthe operation is a context edge, . Y approximation of each context thread (the repeat...until loop of \nlines 5 8). At any point, the procedure ReachAndBuild may raise an exception claiming it has an abstract \nerror trace to a race state. We trap this exception and analyze the counterexam\u00adthen the two locations \nn and n ' are uni.ed by procedure Union which creates a single location n '' which is obtained by merging \nthe two locations: G.S.n '' = G.S.n .G.S.n ' , G.R.n '' = G.R.n .G.R.n ' and the edges of n '' are the \nunion of the edges of n, n ' . ple to see if it is genuine, and if not, obtain a more precise set Procedure \nCheckSim checks that the abstract reachability graph G returned by the procedure ReachAndBuild is simu\u00adlated \nby the ACFA A (the guarantee part). The procedure CheckSim implements a variation of the standard simulation \nchecking algorithm [17]. This check ensures soundness. Proposition 1. [Soundness] If Algorithm Check \nwith input thread abstraction (C, P ), context abstraction (A, k), and error states E terminates and \nreturns Safe then [[C. ]]n E = \u00d8. 4.3 Inference In general, the abstract thread A that succinctly summa\u00adrizes \nthe behavior of a thread, and is simultaneously precise enough to show the absence of concurrency errors, \nis not available. Therefore, we must construct this abstraction au\u00adtomatically via an inference algorithm. \nAlgorithm 4.3 shows our inference algorithm CIRC. The initial abstraction has no predicates (P = \u00d8), \nand the counter abstraction uses k =0. of predicates or increment the counter parameter (lines 10 16). \nThe exception Exception(t ) is caught in line 10, and checkedinprocedure Re.ne. Procedure Re.ne takesasin\u00adput \na CFA C,anACFA A, the abstract reachability graph G such that A is the bisimilarity quotient of G,the \nmap \u00b5 map\u00adping states of G to those of A, and an abstract error trace t of {C}.A..If t can be realized \nin the concrete program, Re.ne returns a real error Real together with a concrete interleaved trace s\u00afin \nC. that reaches the error state. In this case, the algorithm returns Unsafe together with the real error \ns\u00af. On the other hand, if the current error path t does not have a concrete realization in C. , Re.ne \nreturns a re.nement of the abstraction by returning new predicates P ' and a new value for the counter \nk ' . The algorithm up\u00addates the thread and context abstractions by adding these new predicates to P \n, and by updating the maximum value k of a counter in the context abstraction to k ' respectively (lines \n14 16). If the abstraction is updated, we reset the current approximation of the context G back to the \nempty context, and repeat starting with the new abstraction pa\u00adrameters (P, k). In the next section, \nwe describe in detail the remaining subroutines of the algorithm, Collapse,and Re.ne, and mention some \noptimizations. Theorem 1. If Algorithm CIRC on input CFA C and er\u00adror states E terminates and returns \nSafe then C. is safe w.r.t. the error states E;if itreturns Unsafe(t )then C. is unsafe w.r.t. the error \nstates E. The algorithm is not complete in general, since reachabil\u00adity is undecidable already for single-threaded \nprograms. For .nite-state systems and just predicate and control state ab\u00adstractions, completeness follows \nfrom .niteness of the state space. It is not obvious that even for .nite-state threads, Algorithm CIRC \nis complete, since we consider unboundedly many threads. We show in Appendix A that our method us\u00ading \ncounters is complete if the threads are .nite-state. This implies that the only way the procedure can \nloop forever is if either the threads are recursive, or we keep discovering new predicates.  5. DETAILS \nProcedure Collapse. The procedure Collapse takes an ab\u00adstract reachability graph G and constructs a weak \nbisimula\u00adtion quotient A of G with respect to the global predicates. It returns the weak bisimulation \nquotient A,along with a mapping \u00b5 from G.Q to A.Q mapping each state of G to its equivalence class in \nA. We do this in two steps. First, for each location q . G.Q, we replace the state G.r.q with the state \nobtained by quantifying out all local variables as follows: in the formula G.r.q, which is a boolean \ncombina\u00adtion of predicates in P , we replace with unknown each atomic predicate containing a local variable. \nWe remove all local variables from the havoc sets labeling the edges. We then run a standard weak bisimilarity \nalgorithm [7] with the resulting predicates (now over global variables) labeling states of G as observables. \nThe bisimilarity procedure also constructs the required mapping. Whenever in G we have n-Y, and the bisimilarity \ncollapses n, n Yt .n '' to the same loca\u00ad'' '''' tion n in A, we ensure that A has a self loop edge n \n-.n with Y . Y ' . The result is an ACFA with only global vari\u00adables in its location predicates and on \nthe edges. This is important as we want that any local variable appearing in the analysis refers to the \nlocal of the main thread. Procedure Re.ne. The procedure Re.ne analyzes abstract counterexamples, to \neither extract genuine error traces or to re.ne the abstraction to eliminate the false positive. An abstract \ntrace is a sequence of operations of the main thread and the context ACFA. The input to Re.ne is a CFA \nC,an ACFA A, a reachability graph G such that A is the weak bisimilarity quotient of G,a map \u00b5 from states \nof G to states of A, and an abstract trace t . It returns either a real error trace s\u00afor, if t is infeasible, \na re.nement of the abstraction (P ' ,k ' )where P ' is a set of predicates, and k ' is a new counter \nvalue. Procedure Re.ne works in two steps: 1. Computing an Interleaving. Ascanover the entire trace su.ces \nto check if the parameter k is large enough. If not, the only re.nement is that k is incremented. If \nk is large enough, we compute the number of context threads that participate in the counterexample. Each \noperation in T1: I . II skip true T1: II . III old := state old1 = state1 asm [state = 0] state1 =0 state \n:= 1 state2 =1 asm [old = 0] old1 =0 T0: skip skip true T0: old := state old := state old2 = state2 T0: \nasm [state = 0] asm [state = 0] state2 =0 T0: state := 1 state := 1 state3 =1 T0: asm [old = 0] asm [old \n= 0] old2 =0 Figure 5: Abstract trace, concrete interleaving, TF the abstract trace is a either a main \nthread operation, or an abstract operation by a speci.c abstract context thread. To generate the concrete \ninterleaving, we get a concrete se\u00adquence of thread operations from the abstract context oper\u00adation, \nby using the underlying reachability tree of the ACFA. 2. Analyzing an Interleaving. Givenaninterleaved \ntrace, we must check if it is feasible. We .rst compute a trace formula (TF) which is a version of the \nstrongest post\u00adcondition of the trace. Each operation of the trace yields a clause and the TF is the \nconjunction of all the clauses. The trace is feasible, and hence, the counterexample genuine, i. the \nTF is satis.able, which can be checked by querying a decision procedure. If it is not satis.able, the \nproofofun\u00adsatis.ability of the TF can be mined for predicates using an extension of the technique described \nin [18]. Example 3: [Re.nement] In Figure 5 the left, middle and right columns show respectively, the \nabstract trace, concrete trace, and the unsatis.able TF for the error trace from iter\u00adation 4 of the \nexample from Section 2. The proof of unsat\u00adis.ability yields the predicates state =0 and state =1. . \n.-check. The procedure ReachAndBuild.(C, P ).(A, k)is ex\u00adpensive, so we implement the following optimization \nof the algorithm CIRC.Let ReachAndBuildk be an instance of the reachability algorithm that uses the initial \nstate ((C .q0, true), Gk 0 )where Gk 0 .q = k if q = q0 and 0 if q = q0. In our modi.ed algorithm, we \nrun ReachAndBuildk with thecurrent valueof variable k in line 7. This has the ef\u00adfect of running a multithreaded \nprogram where there are exactly k threads in the context. If the loop terminates with k = k0,we have \nan ACFA A that succinctly repre\u00adsents a context with k0 threads. At this point, we check if the CFA A \nis also a succinct description for a con\u00adtext with arbitrarily many threads. One way is to check if ReachAndBuild. \n.(C, P ).(A, k0) -A. While sound, this reachability is also very expensive. Instead we perform the following \ncheck. Suppose at termination, the values of A, G, \u00b5 and k in the algorithm are A, G, \u00b5,and k0 respectively, \nso that ( A, \u00b5 ) = Collapse.G. We .rst compute the set of reach\u00adable states R . S.( A, k0) by running \nthe reachability algo\u00adA . rithm on . This gives us all possible con.gurations that the environment can \nreach. From this, we compute the set of possible environment actions as follows. For each state q . \nA.Q, we construct the set of enabled transitions at q given that the main thread is at location q. A \ntransition q ' -\u00b7 '' is enabled at q if there is a G . R with G.q > 0, and .q ' '' either G.q > 0and \nq = q or G.q > 1and q = q ' .Intu\u00ad itively, when the main thread is in location q,if the tran\u00ad sition \nq ' -\u00b7 '' is enabled, then it is possible for some thread . q in the environment to execute this transition. \nA location {x1,...,xn} n . G.Q is good for a transition e = q ' -------. q '' of A if (1) e is enabled \nat \u00b5.n, and (2) the result of executing the context action e from G.r.n is contained in G.r.n,that is, \n(. x1 ... xn.( A.r.q '' G.r.n). We check that all G.r.n)) . ( ) . ( locations n . G.Q are good for all \ncontext transitions in A that are enabled in \u00b5.n. This check is sound: if the check succeeds then A \nsimulates a context with arbitrarily many threads. If the check fails, we increment k0 and rerun the \nmain loop. We call this algorithm .-CIRC. We have found that in practice, .-CIRC is considerably faster \nthan CIRC. Theorem 2. If Algorithm .-CIRC on input CFA C and error states E terminates and returns Safe \nthen C. is safe w.r.t. the error states E ;if itreturns Unsafe(t )then C. is unsafe w.r.t. the error \nstates E . Memory Model. So far we have described our algorithms assuming all variables are of type integer. \nIn our implemen\u00adtation, we extend the basic algorithm to deal with pointer variables and aliasing. The \nproblem is that we cannot in\u00adfer the global memory address being accessed syntactically by looking at \nthe name of the lvalue. Thus, for the error check, we ask for every pair of lvalues l1,l2 at a state, \nif the addresses of l1 and l2 can be the same, and in addition if there is a race between l1 and l2. \nAs an optimization, we use a .ow insensitive alias and escape analysis to curtail the possible aliasing \nrelationships to be explored. We omit the details for lack of space.  6. EXPERIENCES nesC [13] is a \nprogramming language for networked em\u00adbedded systems. It is used to implement event driven appli\u00adcations \nin the TinyOS operating system [21]. TinyOS has two sources of concurrency: tasks and events. When an \nin\u00adterrupt occurs an event is .red, which may in turn .re other events. As other interrupts can occur \nwhile this is happen\u00ading, events can preempt each other. Events may also post tasks, which are run when \nnothing else is happening. A task may be preempted by events, but is never preempted by another task. \nThe presence of concurrent execution leads to potential data races on the shared state. Since tasks are \nnonpreemptible, there is no data race on variables accessed only in tasks, but there may be be races \nbetween events and tasks, or between two events. As it is essential to avoid data races, nesC provides \natomic sections in the language with an atomic keyword. Code in an atomic section is executed atomically. \nThe nesC com\u00adpiler implements a .ow based static analysis to catch race conditions on shared data variables. \nIt runs an alias analysis to detect which global variables are accessed (transitively) by interrupt handlers, \nand then checks that each such access occurs within an atomic section. However, this analysis pre\u00adcludes \nthe use of some common programming idioms (e.g., the example from Section 2) which cause the analysis \nto return false positives. For this, nesC provides a norace an\u00adnotation that the programmer must provide \nif she believes that there is no race condition on a data variable. In prac\u00adtice, almost all shared accesses \nare put in atomic sections to prevent compiler warnings, even though there may be no actual race condition. \nSince atomic sections are imple\u00admented by interrupt disabling, this may make the system less responsive. \nThus, nesC programs gave us a suitable application for a precise race checker like CIRC: .rst, they critically \nrequire the absence of data races, and second, they use several non-trivial synchronization idioms. Running \nCIRC on nesC Programs. We focused on the variables that had raised false alarms with the .ow\u00adbased analysis, \nand which subsequently were .agged with the norace quali.er. nesC programs are compiled into C and event \n.res translate to function calls. We modeled the nesC applications as an arbitrary number of threads \neach executing a big while-loop that triggered hardware inter\u00adrupts non-deterministically (as long as \ninterrupts were en\u00adabled, modeled by adding a special global) or called tasks non-deterministically (as \nlong as nothing else was running). Our results on some of the largest nesC applications are summarized \nin (Table 1). The examples requiring no predi\u00adcates are ones that were trivially safe as they were accessed \nin atomic sections or only by tasks and our tool .nds this quickly. Line is the number of lines in the \ncompiled C source code. Preds is the number of predicates discovered to prove safety, ACFA is the number \nof states in the .nal ACFA. The counter parameter was always 1. State Variable based Synchronization. \nMany of the variables gTxByteCnt, gTxRunningCRC were protected by a state variable much like the example \nin Section 2, and CIRC is able to show there are no races, by .nding the appropri\u00adate abstraction. gTxState \nis protected in a similar manner but is accessed in a more complicated pattern: CIRC .rst re\u00adported a \nviolation on it in secureTosBase.On inspection we found that the variable was accessed at several places \ninside a function, in most places before a call that changed the state variable, but at the point of \ncon.ict, it was accessed after changing the state variable. On moving the access to be\u00adfore the call, \nCIRC reported the system was safe. There was another unprotected access, that occurred when a certain \nfunction call returned the value 0, but CIRC veri.ed that in that context, the function never returned \n0. gRxHeadIndex uses a complicated synchronization on multiple values of a state variable along with \nconditional accesses. Split-phase based Synchronization. The variable rec ptr in surge was accessed by \nan interrupt handler (event) (I) and by a task (T) in the following manner: the handler .red only when \nI was enabled. It then disabled the interrupt I, posted the task T and then wrote to rec ptr. The task, \nwhen it got to run, wrote to the variable, and then re-enabled the interrupt. This is an instance of \na split-phase operation, used to break up long tasks. When we modeled this interrupt precisely by tracking \nits status in a global .ag, CIRC was able to report the absence of races after in\u00adferring the appropriate \nACFA. (Since the C code does not match up interrupt bits with handlers, we had to refer to the underlying \nhardware model.) A more complicated form of synchronization was in sense where the variable tosPort was \nprotected by a combination of this and a state variable. We discovered this as CIRC found a race where \nan interrupt .red which reset the state after one thread had already set it and was about to write to \ntosPort thus letting another thread come in and access tosPort. The programmer pointed out that the malicious \nmiddle interrupt was only enabled after  Name Variable . Preds ACFA size Time secureTosBase gTxState \n11 23 7m38s (9539 lines) gTxByteCnt gTxRunningCRC gTxProto gRxHeadIndex gRxTailIndex 4 4 0 8 0 13 13 \n9 64 5 1m41 1m50s 12s 20m50s 2s surge rec ptr 4 23 1m18s (9697 lines) gTxByteCnt 4 15 1m34 gTxRunningCRC \n4 15 1m45s gTxState 11 35 9m54s sense (3019 lines) tosPort 6 26 16m25s Table 1: Experimental results \nwith CIRC on a 2GHz IBM T30 with 512M RAM the .rst thread had .nished writing to tosPort.On model\u00ading \nthis interrupt, the tool was able to prove safety. Acknowledgments. We are indebted to David Gay for \npatiently educating us about nesC.  7. REFERENCES [1] R. Alur and T.A. Henzinger. Reactive modules. \nFormal Methods in System Design, 15(1):7 48, 1999. [2] T. Ball, S. Chaki, and S. K. Rajamani. Parameterized \nveri.cation of multithreaded software libraries. In TACAS 01: Tools and Algorithms for Construction and \nAnalysis of Systems, LNCS 2031, pp. 158 173. Springer, 2001. [3] T. Ball and S.K. Rajamani. The SLAM \nproject: debugging system software via static analysis. In POPL 02: Principles of Programming Languages, \npp. 1 3. ACM, 2002. [4] C. Boyapati, R. Lee, and M. Rinard. Ownership types for safe programming: preventing \ndata races and deadlocks. In OOPSLA 02: Object-Oriented Programming, Systems, Languages and Applications, \npp. 211 230. ACM, 2002. [5] S. Chaki, J. Ouaknine, K. Yorav, and E.M. Clarke. Automated compositional \nabstraction re.nement for concurrent C programs: A two-level approach. In SoftMC 03: Software Model Checking, \n2003. [6] J.-D. Choi, K. Lee, A. Loginov, R. O Callahan, V. Sarkar, and M. Sridharan. E.cient and precise \ndatarace detection for multithreaded object-oriented programs. In PLDI 2002: Programming Languages Design \nand Implementation, pp. 258 269. ACM, 2002. [7] E.M. Clarke, O. Grumberg, and D. Peled. Model Checking. \nMIT Press, 1999. [8] J.Corbett, M. Dwyer, J. Hatcli.,C. Pasareanu,Robby, S. Laubach, and H. Zheng. Bandera \n: Extracting .nite-state models from Java source code. In ICSE 00: Software Engineering, pp. 439 448. \nIEEE, 2000. [9] G. Delzanno, J.-F. Raskin, and L. Van Begin. Towards the automated veri.cation of multithreaded \nJava programs. In TACAS 02: Tools and Algorithms for the Construction and Analysis of Systems, LNCS 2280, \npp. 173 187. Springer, 2002. [10] J. Esparza, A. Finkel, and R. Mayr. On the veri.cation of broadcast \nprotocols. In LICS 99: Logic in Computer Science, pp. 352 359. IEEE, 1999. [11] C. Flanagan and S.N. \nFreund. Detecting race conditions in large programs. In PASTE 01: Program Analysis for Software Tools \nand Engineering, pp. 90 96. ACM, 2001. [12] C. Flanagan, S. Qadeer, and S.A. Seshia. A modular checker \nfor multithreaded programs. In CAV 02: Computer-Aided Veri.cation, LNCS 2404, pp. 180 194. Springer, \n2002. [13] D. Gay, P. Levis, R. von Behren, M. Welsh, E. Brewer, and D. Culler. The nesC language: A \nholistic approach to networked embedded systems. In PLDI 2003: Programming Languages Design and Implementation, \npp. 1 11. ACM, 2003. [14] P. Godefroid. Model checking for programming languages using Verisoft. In POPL \n97: Principles of Programming Languages, pp. 174 186. ACM, 1997. [15] S. Graf and H. Sa\u00a8idi. Construction \nof abstract state graphs with PVS. In CAV 97: Computer-aided Veri.cation,LNCS 1254, pp. 72 83. Springer, \n1997. [16] K. Havelund and T. Pressburger. Model checking Java programs using Java Path.nder. Software \nTools for Technology Transfer (STTT), 2(4):72 84, 2000. [17] M.R. Henzinger, T.A. Henzinger, and P.W. \nKopke. Computing simulations on .nite and in.nite graphs. In FOCS 95: Foundations of Computer Science, \npp. 453 462. IEEE, 1995. [18] T.A. Henzinger, R. Jhala, R. Majumdar, and K.L. McMillan. Abstractions \nfrom proofs. In POPL 04: Principles of Programming Languages, pp. 232 244. ACM, 2004. [19] T.A. Henzinger, \nR. Jhala, R. Majumdar, and S. Qadeer. Thread-modular abstraction re.nement. In CAV 03: Computer-Aided \nVeri.cation, LNCS 2725, pp. 262 274. Springer, 2003. [20] T.A. Henzinger, R. Jhala, R. Majumdar, and \nG. Sutre. Lazy abstraction. In POPL 02: Principles of Programming Languages, pp. 58 70. ACM, 2002. [21] \nJ. Hill, R. Szewczyk, A. Woo, S. Hollar, D. Culler, and K. Pister. System architecture directions for \nnetworked sensors. In ASPLOS 00: Architectural Support for Programming Languages and Operating Systems, \npp. 93 104. ACM, 2000. [22] G.J. Holzmann. Logic veri.cation of ANSI-C code with SPIN. In SPIN 00: Spin \nModel Checking and Software Veri.cation, LNCS 1885, pp. 131 147. Springer, 2000. [23] C.B. Jones. Tentative \nsteps toward a development method for interfering programs. ACM Transactions on Programming Languages \nand Systems, 5(4):596 619, 1983. [24] B.D. Lubachevsky. An approach to automating the veri.cation of \ncompact parallel coordination programs I. Acta Informatica, 21:125 169, 1984. [25] S. Savage, M. Burrows, \nC.G. Nelson, P. Sobalvarro, and T.A. Anderson. Eraser: A dynamic data race detector for multithreaded \nprograms. ACM Transactions on Computer Systems, 15(4):391 411, 1997. [26] C. von Praun and T. Gross. \nStatic con.ict analysis for multi-threaded object-oriented programs. In PLDI 03: Programming Languages \nDesign and Implementation, pp. 115 128. ACM, 2003. [27] E. Yahav. Verifying safety properties of concurrent \nJava programs using 3-valued logic. In POPL 01: Principles of Programming Languages, pp. 27 40. ACM, \n2001. APPENDIX A. COMPLETENESS OF COUNTER AB-STRACTIONS For .nite-state threads, counterexample-guided \nre.ne\u00adment using counter abstractions terminates. Let X be a set of global variables, and let pc be a \nvariable not in X.Let T =(., At), where . is an X .{pc}\u00adtransition relation, be a thread. As before, \nlet T . be the multithreaded program {(.i, Ati) |i .I} running an un\u00adbounded number of copies of the \nthread T ,where (.i, Ati) is obtained from (., At)by renaming pc to pci.Notice that we assume pci is \nthe only local variable of thread i.A thread T is .nite-state if each variable in X .{pc}takesvaluesover \na .nite domain. The parameterized multithreaded program T . is .nite-state if T is .nite-state. A state \n(s, G) of the multithreaded program T . can be described by an X-state s, together with a map G : Q . \nI.{.},where Q is the .nite range of the variable pc.In\u00adtuitively, the X-state s gives the valuations \nto the global variables, and G.q for q . Q counts the number (possibly in.nite) of threads Ti with pci \n= q. We now de.ne counter abstractions (T,k)of the mul\u00adtithreaded program .Let . be a variable not in \nX, T .such that . ranges over functions in Q . I.{.}.Given T =(., At)overthe variables X .{pc}, de.ne \n(T,k)to be the program {(.k , Atk)},overthe variables X .{.} as follows. 1. The initial state is s0,where \ns0...q = . if q =0 and 0 otherwise, and .x .X,we have s0.x =0. 2. The set Atk is the set of X .{.}-states \ns s.t. there exist q .Q and t .At with (a) s...q > 0, (b) t.pc = q,and  (c) for all x .X, s.x = t.x. \n.k k '' ' 3. isan X .{.}-transition relation de.ned as follows: s . s i. .q, q .Q and t . t s.t. (a) \nfor all x .X we have s.x = t.x and s ' .x = t ' .x,(b) t.pc = q and '' ' t.pc = q ,(c) s...q > 0, (d) \ns ...q ' = a.k.(s...q ' +1), ' '' '' s ...q = s...q -1, and, for all q .{q, q }, s ...q '' = s...q '' \n, and, (e) s .Atk implies t .At. For sets X, Y of variables, and an X-state s and a Y -state t,we say \ns t i. .x . X nY we have s.x = t.x.For S aset of X-states and T aset of Y -states, we say S .T i. for \neach s .S,there exists t .T such that s t.We say S T if S .T and T .S.Notice that is an equivalence relation \nand .is re.exive and transitive. Lemma 1. [Soundness] For every T =(., At) and for every k . Iwe have \n[[T .]] [[(T,.)]] .[[(T,k +1)] . [[(T,k)]]. Let T . be a .nite-state multithreaded program over X . \n{pc}.Let E be a set of X-states, specifying possible error states. The parameterized safety veri.cation \nproblem is to check if [ T .]] .VX \\E.If so, we say that T . is safe w.r.t. E, otherwise, T . is unsafe. \nA sequence of states t = t0 ...tm is a P-trace for a program P over the globals X if there exists s = \ns0 ...sm such that: (1) s0 is the initial state of P,(2) for all 0 = j<m, sj .P sj+1, and (3) for all \n0 = k = m, sj tj . Additionally, t is called a E-counterexample if {tm}.E.Notice that if t = t0 ...tm \nis a (T,k)-trace and m =k,then t is also a T . trace. Algorithm 6 Counter-Guided Parameterized Veri.cation \nRequire: Finite-state thread T =(., At)overvariables X .{pc},set of X-states E. 1: k := 0 2: while true \ndo 3: try 4: ModelCheck.(T,k).E 5: return Safe 6: with (Exception(t0 ...tm)) . 7: if m =k then 8: return \nUnsafe(t0 ...tm) 9: else 10: k := k +1 11: done Lemma 2. [Completeness] Let T =(., At),where . is an \n(X .{pc})-transition relation, be a .nite-state thread. Let E be a set of X-states. 1. If T . is safe \nw.r.t. E, then there exists a k s.t. (T,k) is safe w.r.t. E. 2. If T . is unsafe w.r.t. E, then there \nexists a k and a sequence t of (X .{.})-states s.t. t is a (T,k)-trace, a T . trace, and an E-counterexample. \n For the .rst case, we use a result from [10], that says the set of states that can reach the error \nstates (pre * (E)) is computable by backward iteration. We then show that there is a large enough k such \nthat if s is a state of (T,k) and no concretization of s is in pre * (E), then inductively, every successor \nof s also has the same property, and thus (T,k)is safe. For the second case, let s be the shortest sequence \nof X-states that is both a T .-trace and a E-counterexample. Let k be the length of the sequence s. Notice \nthat for each sj .s, there are never more than k threads at location q for any q other than 0. Hence, \nthis sequence has a corresponding sequence of X.pc-states which is a (T,k)-trace that is also an E-counterexample. \nWe now give a counterexample-guided algorithm for the parameterized safety veri.cation problem for .nite-state \nmultithreaded programs (Algorithm 6). The algorithm pro\u00adceeds by iteratively re.ning the counter abstraction \nof the parameterized multithreaded program, until either the pro\u00adgram is proved safe, or a genuine counterexample \nis found. The procedure ModelCheck takes two arguments, a .nite\u00adstate program P and a set of states E \nand checks whether [[P] is safe w.r.t. E. If so, it simply returns, and if not, it raises an exception \nwhich is the shortest P-trace that is an E-counterexample. This procedure can be implemented us\u00ading standard \n.nite-state model checking techniques [7]. The procedure to check if a counterexample is genuine simply \ncompares the length of the trace with the counter parame\u00adter, more sophisticated re.nement schemes can \nalso be used. The termination and correctness of the Algorithm 6 follow from Lemmas 1 and 2. Theorem \n3. [Termination and Correctness] When Algorithm 6 is given a .nite-state thread T and a set of error \nstates E, it terminates. If it returns Safe then T . is safe w.r.t. E.If it returns Unsafe(t )then T \n. is not safe w.r.t. E and t is a T .-trace that is an E-counterexample.  \n\t\t\t", "proc_id": "996841", "abstract": "Software model checking has been successful for <i>sequential</i> programs, where predicate abstraction offers suitable models, and counterexample-guided abstraction refinement permits the automatic inference of models. When checking <i>concurrent</i> programs, we need to abstract threads as well as the contexts in which they execute. Stateless context models, such as predicates on global variables, prove insufficient for showing the absence of race conditions in many examples. We therefore use richer context models, which combine (1) predicates for abstracting data state, (2) control flow quotients for abstracting control state, and (3) counters for abstracting an unbounded number of threads. We infer suitable context models automatically by a combination of counterexample-guided abstraction refinement, bisimulation minimization, circular assume-guarantee reasoning, and parametric reasoning about an unbounded number of threads. This algorithm, called CIRC, has been implemented in BLAST and succeeds in checking many examples of NESC code for data races. In particular, BLAST proves the absence of races in several cases where previous race checkers give false positives.", "authors": [{"name": "Thomas A. Henzinger", "author_profile_id": "81100034124", "affiliation": "UC Berkeley", "person_id": "PP14024447", "email_address": "", "orcid_id": ""}, {"name": "Ranjit Jhala", "author_profile_id": "81100198278", "affiliation": "UC Berkeley", "person_id": "P343132", "email_address": "", "orcid_id": ""}, {"name": "Rupak Majumdar", "author_profile_id": "81100319213", "affiliation": "UC Los Angeles", "person_id": "P335105", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/996841.996844", "year": "2004", "article_id": "996844", "conference": "PLDI", "title": "Race checking by context inference", "url": "http://dl.acm.org/citation.cfm?id=996844"}