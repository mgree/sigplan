{"article_publication_date": "06-09-2004", "fulltext": "\n The Set Constraint/CFL Reachability Connection in Practice John Kodumal Alex Aiken EECS Department \nComputer Science Department University of California, Berkeley Stanford University jkodumal@cs.berkeley.edu \naiken@cs.stanford.edu ABSTRACT Many program analyses can be reduced to graph reachabil\u00adity problems involving \na limited form of context-free lan\u00adguage reachability called Dyck-CFL reachability. We show a new reduction \nfrom Dyck-CFL reachability to set con\u00adstraints that can be used in practice to solve these problems. \nOur reduction is much simpler than the general reduction from context-free language reachability to set \nconstraints. We have implemented our reduction on top of a set con\u00adstraints toolkit and tested its performance \non a substantial polymorphic .ow analysis application.  Categories and Subject Descriptors D.2.4 [Software \nEngineering]: Software/Program Veri.\u00adcation; F.3.2 [Logics and Meanings of Programs]: Se\u00admantics of Programming \nLanguages General Terms Algorithms, Design, Experimentation, Languages, Theory  Keywords Set constraints, \ncontext-free language reachability, .ow analysis, type quali.ers 1. INTRODUCTION Many program analyses \nhave been formulated and imple\u00admented using set constraints. Set constraint-based analyses have been \nshown to scale to large programs on applications such as points-to analysis, shape analysis, and receiver \nclass prediction, though scalability requires highly optimized im\u00adplementations [4, 8, 19, 21]. Recently, \na number of program analyses have been formu\u00adlated as context-free language (CFL) reachability problems. \nThese include applications such as type-based polymorphic .ow analysis, .eld-sensitive points-to analysis, \nand interpro\u00adcedural data.ow analysis [15, 17, 18]. Getting CFL-based Permission to make digital or hard \ncopies of all or part of this work for personal or classroom use is granted without fee provided that \ncopies are not made or distributed for pro.t or commercial advantage and that copies bear this notice \nand the full citation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. PLDI 04, June 9 11, 2004, Washington, DC, USA. \nCopyright 2004 ACM 1-58113-807-5/04/0006 ...$5.00. implementationsto scale has proved astricky asimplement\u00ading \nset constraints, leading to new algorithms and optimiza\u00adtion techniques. Set constraints and CFL reachability \nwere shown to be closely related in work by Melski and Reps [13]. While their result is useful for understanding \nthe conceptual similarity between the two problems, it does not serve as an imple\u00admentation strategy; \nas with many reductions, the cost of encoding one problem in the other formalism proves to be prohibitive \nin practice. Furthermore, the Melski-Reps reduction does not show how to relate the state-of-the-art \nalgorithms for set con\u00adstraints to the state-of-the-art algorithms for CFL reachabil\u00adity. Optimizations \nin one formalism are not preserved across the reduction to the other formalism. Demand-driven algo\u00adrithms \nfor CFL reachability do not automatically lead to demand algorithms for set constraints (except by applying \nthe reduction .rst). Our insight is based on the observation that almost all of the applications of CFL \nreachability in program analy\u00adsis are based on Dyck languages, which contain strings of matched parentheses. \nFor Dyck languages, we show an al\u00adternative reduction from CFL reachability to set constraints that addresses \nthe issues mentioned above. The principal contributions of this work are as follows: We give a novel \nconstruction for converting a Dyck-CFL reachability problem into a set constraint prob\u00adlem. The construction \nis simpler than the more gen\u00aderal reduction described in [13]. In fact, the constraint graphs produced \nby our construction are nearly iso\u00admorphic to the original CFL graph.  We show that on real polymorphic \n.ow analysis prob\u00adlems, our implementation of Dyck-CFL reachability based on set constraints remains \ncompetitive with a highly tuned CFL reachability engine. This is some\u00adwhat surprising since that implementation \ncontains optimizations that exploit the speci.c structure of the CFL graphs that arise in .ow analysis. \n These results have several consequences: Our results show that it is possible to use an o.-the\u00adshelf \nset constraint solver to solve Dyck-CFL reacha\u00adbility problems without su.ering the penalties we nor\u00admally \nexpect when using a reduction. Furthermore, reasonable performance can be expected without hav\u00ading to \ntune the solver for each speci.c application. G .{B (u, u'),C (u',v)} . add A (u, v) for each production \nof the form A .BC G .{B (u, v)} . add A (u, v) for each production of the form A .B G . add A (u, u) \nfor each production of the form A .E Figure 1: Closure rules for CFL reachability We believe that our \nreduction bridges the gap be- S  )1   tween the various algorithms for Dyck-CFL reachabil\u00ad (1   \n x1 z1 y  yyyyyyy   y y  Figure 2: Example Dyck-CFL reachability problem form: S .SS | (1 S )1 | \n\u00b7\u00b7\u00b7 | (n S )n | E | s (where s is a distinguished terminal not in O or C). The all-pairs Dyck-CFL reachability \nproblem is the restriction of the all-pairs CFL reachability problem to Dyck languages. Figure 1 shows \nthe closure rules for the CFL and Dyck-CFL reachability algorithms. The rules assume that the CFL grammar \nhas been normalized such that no right-hand yyyy()22yy side of any production contains more than two \nsymbols1.A naive CFL reachability algorithm might apply the rules as follows: whenever the CFL graph \nmatches the form on the left-hand side of the rule, add the edges indicated by the right-hand side of \nthe rule; iterate this process until no rule induces a new edge addition. The application of these rules \nproduces a graph closure(G) that contains all possible edges labeled by nonterminals in the grammar. \nTo check whether there is an S-path from nodes u to v in G, we simply check for the existence of an edge \nS (u, v) in closure(G). In general, the all-pairs CFL-reachability problem can be solved in time O(|T \n.N|3 n 3)for a graph with n nodes. Figure 2 shows an example of a Dyck-CFL reachability problem. The \ndashed lines show the edges added by the computation of closure(G). The edges show that there are S-paths \nbetween nodes x1 and z1,and x2 and z2.Self-loop S-paths derived from the production S .E are not shown. \n2.2 Set Constraints In this subsection, we review the set constraints frame\u00adwork introduced in [21]. \nWe de.ne a language of set con\u00adstraints (essentially a subset of the full language de.ned in [1, 6]) \nand discuss inductive form, a graph-based represen\u00adtation of set constraints. 2.2.1 A Language of Set \nConstraints A constraint system is a .nite collection of set constraints. A set constraint is a relation \nof the form L . R,where L and R are set expressions. Set expressions consist of set 1For instance, by \nconverting the grammar to Chomsky nor\u00admal form. ity [10] and the algorithms for solving set constraints. \nIn light of our reduction, it seems that the distinc\u00ad tion between these problems is illusory: the manner \nin which a problem is speci.ed (as Dyck-CFL reachability vs. set constraints) is orthogonal to other \nalgorithmic issues (e.g. whether the solver is online vs. o.ine, demand-driven vs. exhaustive). This \nhas some impor\u00ad tant consequences for instance, we plan in the future to investigate an algorithm for \nincremental set con\u00adstraints. Using our reduction, such an algorithm could be used immediately to solve \nDyck-CFL reachability problems incrementally. Furthermore, our reduction shows how techniques used to \nsolve set constraints (inductive form and cycle elim\u00adination [4]) can be applied to Dyck-CFL reachability \nproblems. The remainder of this paper is structured as follows. In Section 2 we brie.y introduce CFL \nreachability and set con\u00adstraints. In Section 3 we review the reduction from CFL reachability to set \nconstraints. Section 4 presents our spe\u00adcialized reduction from Dyck-CFL reachability to set con\u00adstraints. \nIn Section 5 we use polymorphic .ow analysis as a case study for our reduction. Section 6 covers related \nwork, and Section 7 concludes.   2. PRELIMINARIES We review basic material on CFL reachability and \nset con\u00adstraints. Readers familiar with CFL reachability may wish to skip Section 2.1, which is standard. \nSection 2.2 is based on the framework of [21], which uses some nonstandard no\u00adtation. 2.1 CFL and Dyck-CFL \nReachability In this subsection we de.ne CFL reachability and Dyck-CFL reachability and describe an approach \nto solving these problems. Let CFG =(T, N, P, S)bea contextfreegrammar with terminals T , nonterminals \nN, productions P and start sym\u00adbol S.Let G be a directed graph with edges labeled by elements of T . \nThe notation A (u, v) denotes an edge in G from node u to node v labeled with symbol A. Each path in \nG de.nes a word over T by concatenating, in order, the labels of the edges in the path. A path in G is \nan S-path if its word is in the language of CFG.The all-pairs CFL reachability problem determines the \npairs of vertices (u, v) where there exists an S-path from u to v in G. Now let O = {(1,..., (n} and \nC = {)1,..., )n} be two disjoint sets of terminals (interpreted as opening and closing symbols, respectively). \nThe subscripts are the terminals indices. The Dyck language over O .C .{s} is generated by a context \nfree grammar with productions of the following y1 s y2  x2 z2 S C .{X.X} . C S '' ' C .{c(se1,... ,sea(c)) \n.c(se1,.. .,se )}. C .{sei .sei} a(c)i C .{c(se1,...,sea(c)) .proj(c, i, se)}. C .{sei .se}C .{d(se1, \n...,sea(d)) .proj(c, i, se)}. C if c . = d C .{c(...) .d(...)}. no solution if c . = d Figure 3: Resolution \nrules for set constraints variables X, Y,..., terms constructed from n-ary construc\u00adtors c, d,...2, and \nprojection patterns: L, R .se ::= X|c(se1,. ..,sea(c)) |proj(c, i, se) Each constructor c has an arity \na(c). Given a constraint of the form c(se1, ...,sea(c)) . proj(c, i, se), the projection pattern proj(c, \ni, se)has the ef\u00adfect of selecting sei,the ith component of the term on the left-hand side, and adding \nthe constraint sei . se.Pro\u00adjection patterns are closely related to the more standard projection notation \nc -i(se). We can express c -i(se)using the following equivalence: c -i(se) =V where Vis fresh and se \n.proj(c, i, V) The equivalence preserves least solutions under a compati\u00adbility restriction: the variable \nV used to represent c -i(se) can only occur on the left-hand side of any other inclusion constraint. \nWe use the proj notation because it simpli.es the presentation of the constraint re-write rules and eluci\u00addates \nthe connection between Dyck-CFL reachability and set constraints. However, we also use c -i(se) wherever \nthat notation is more natural. Our uses of c -i(se)always ad\u00adhere to the compatibility restriction; therefore \nin this work it is always safe to replace that notation with the equivalent using proj. 2.2.2 Constraint \nGraphs Algorithms for solving set constraints operate by apply\u00ading a set of resolution rules to the constraint \nsystem until no rules apply; this is the solved form.The solved form makes the process of reading o. \na particular solution (or all solu\u00adtions) simple. For our language of set constraints, we apply the resolution \nrules in Figure 3 as left-to-right re-write rules to reduce the constraint system to solved form. Algorithmically, \na system of set constraints C can be rep\u00adresented as a directed graph G(C) where the nodes of the graph \nare set expressions and the edges denote atomic con\u00adstraints. A constraint is atomic if either the left-hand \nside or the right-hand side is a set variable. Computing the solved form involves closing G(C) under \nthe resolution rules, which are descriptions of how to add new edges to the graph. In general, a system \nof set constraints C with v variables can be reduced to solved form in time O(v 2|C|). Inductive form \nis a particular graph representation that exploits the fact that variable-variable constraints X.Y can \nbe represented as either a successor edge (Y.succ(X)) or a predecessor edge (X.pred(Y)). Thechoiceis \nmade based on a .xed total order o (generated randomly) on the variables. For a constraint X.Y, the edge \nis stored as a successor edge on Xif o(X) >o(Y), otherwise, it is stored as a predecessor edge on Y. \nConstraints of the form c(...) .X are always stored as predecessor edges on X, and constraints of the \nform X.proj(c, i, se) are always stored as successor edges on X. Given these representations, the transitive \nclosure rule for inductive form is as follows: L .pred(X) .R .succ(X) .L .R This rule, in conjunction \nwith the resolution rules in Fig\u00adure 3, produce a solved graph in inductive form. The ad\u00advantage of inductive \nform is that many fewer transitive edges are added in comparison to other graph representations [4]. \nInductive form does not explicitly compute the least so\u00adlution, but the least solution is easily calculated \nby doing backwards-reachability on the constraint graph: LS(Y)= {c(...)|c(...) .pred(Y)}. S LS(X) X.pred(Y \n) 2.2.3 Solutions of Constraint Systems We interpret set constraints under the term-set model [6]. In \nthis model, the solution to a system of set constraints maps each set variable to a (possibly in.nite) \nset of ground terms such that all inclusion relations are satis.ed. It turns out that each set variable \ndescribes a regular tree language and the solved form of the constraint graph can be viewed as a collection \nof regular tree grammars. Each atomic con\u00adstraint c(...) .X in the solved form of the constraint sys\u00adtem \ncan be interpreted as a production in a tree grammar by treating it as a production X . c(...). For example, \nconsider the solved constraint system cons(zero, X) .X nil .X where zero and nil are nullary constructors, \nand cons is a binary constructor. We see that X describes the set of all lists where every element is \nzero. The least solution for X canbe viewedasa tree language L(X) whose grammar is X . cons(zero, X) \nX . nil   3. THE MELSKI-REPS REDUCTION In this section we review the reduction from CFL reacha\u00adbility \nto set constraints [12, 13]. Readers familiar with this reduction may wish to skip this section. Again, \nwe assume that the CFL grammar is normalized so that the right-hand 2We assume throughout that constructors \nare non-strict. side of every production contains at most two symbols. The construction encodes each \nnode u in the initial CFL graph G with one set variable U, one nullary constructor nu and the constraint \nnu .U In encoding the graph, the goal is to represent an edge A (u, v)in the closed graph by the presence \nof a term cA(V), where cA is a unary constructor corresponding to symbol A, in the least solution of \nU. Accordingly, an initial edge of the form a (u, v)in G is captured by a constraint ca(V) .U This completes \nthe representation of the initial graph. The next step of the reduction is to encode the productions \nof the CFL grammar. Since edges are encoded as constructed terms, the notion of following an edge is \ncaptured by pro\u00adjection. The left-hand side of each production tells us which edge we should add if we \nfollow edges labeled by the right\u00adhand side. For instance, a binary production of the form A . BC says \nthat we should add an A edge from node u to any nodes reached by following a B edge from u and then following \na C edge. The set constraint that encodes this rule is -1 -1 (c (U))) .U cA(cCB For example, the CFL \ngraph BC ' uv u and the production A . BC result in a system of set constraints containing the following \ninclusion relations: nu .U cC (V) .U ' cB (U ' ) .U -1 -1 cA(cC (cB (U))) .U These constraints imply \nthe desired relationship cA(nv) . U, which represents the edge A (u, v). Note these constraints only \nencode each production locally: similar constraints must be generated for every node in the graph. Besides \nbinary productions, productions of the form A . B and A .E may occur in the grammar. Productions of the \n.rst form are encoded locally for each node u by the constraint -1 cA(cB (U)) .U representing the fact \nthat any B edge from node u is also an A edge. Finally, productions of the form A .E are encoded locally \nfor each node u by the constraint cA(U) .U Correctness of the reduction is proved by showing there is \nan S-path from node u to node v in closure(G) if and only if cS (nv) .Uis in the least solution of the \nconstructed system of constraints.  4. A SPECIALIZED DYCK REDUCTION This section presents our reduction, \nwhich is specialized to Dyck-CFL reachability problems. We .rst explain the in\u00adtuition behind our approach. \nWe then describe the speci.cs of the encoding, sketch a proof of correctness, and provide a complexity \nargument. Finally, we provide experimental O1(X1) proj(O1, 1, Z1)   Y1 Y2   O2(X2) proj(O2, 1, \nZ2) Figure 4: The constraint graph corresponding to the Dyck-CFL graph from Figure 2 using the reduction \nfrom Section 4 results suggesting that the specialized reduction is more ef\u00ad.cient in practice than the \nMelski-Reps reduction applied to Dyck-CFL grammars. The idea behind our reduction is that the set constraint \nclosure rules can encode Dyck language productions. The intuition is straightforward: the rule S .SS \ncorresponds to the transitive closure rule, and the rules S . (i S )i correspond to matching constructed \nterms with projection patterns. By encoding the original Dyck-CFL graph as a system of set constraints \nin a way that exploits this corre\u00adspondence, we can avoid encoding the productions of the grammar at \neach node. This leads to a more natural and compact encoding of the input graph, and better perfor\u00admance \nin applications where the number of parenthesis kinds (hence, the number of productions) is not a constant. \nThe .rst step of the encoding is unchanged. We represent each node u with a variable Uand a nullary constructor \nnu. We connect these with constraints of the form nu .U Edges are encoded so that subset relationships \nU.V between variables in the constraint system represent discov\u00adered S (u, v) edges in the input graph. \nSince we are only considering Dyck languages, there are only three kinds of labeled edges to consider: \n1. For each s (u, v)edge in the input graph, we add the constraint U.V (where U and V are the variables \ncorresponding to nodes u and v). 2. For each (i(u, v)edge in the input graph, we create a unary constructor \nOi and add the constraint Oi(U) . V. 3. For each )i (u, v)edge in the input graph, we add the constraint \nU.proj(Oi, 1, V).  Notice that there appears to be a slight asymmetry in the reduction: edges labeled \nwith (i symbols are encoded using constructed terms, while edges labeled with )i sym\u00adbols are encoded \nusing projections. Naively, one might at\u00adtempt to devise a symmetric reduction by encoding an edge )i \n(u, v)with a constraint U.Oi(V), making a corre\u00adspondence between the production S . (i S )i and the \nsecond rule (not the third) in Figure 3. However, this approach would yield an inconsistent system of \nset con\u00adstraints for any interesting graph. For example, the graph in Figure 2 would result in a constraint \nsystem contain\u00ading the constraints O1(X1) .Y1 .Y2 . O2(Z2), which Constraints New Constraint Production \nEdges New Edge X.Y.Y.Z X.Z S .SS S (x, y).S (y, z) S (x, z) Oi(X) .Y.Y.Z Oi(X) .Z Li .Li S Li (x, y).S \n(y, z) Li (x, z) X.Y.Y.proj(Oi, 1, Z) X.proj(Oi, 1, Z) Ri .SRi S (x, y).Ri (y, z) Ri (x, z) Oi(X) .Y.Y.proj(Oi, \n1, Z) Oi(X) .proj(Oi, 1, Z) .X.Z S .Li Ri Li (x, y).Ri (y, z) Table 1: Constraints added to C ' and \nthe corresponding edges in closure(G) are clearly inconsistent. We avoid this problem by us\u00ading projection \npatterns to represent )i edges. Thus, the graph in Figure 2 results in a constraint system containing \nO1(X1) .Y1 .Y2 .proj(O2, 1, Z2), which is consistent. This construction only introduces one constraint \nper node and one constraint per edge of the original CFL graph. In contrast, the reduction described \nin Section 3 introduces O(k)constraints per node (where k is the number of paren\u00adthesis kinds in the \nDyck grammar) to encode the grammar productions locally, in addition to the cost of encoding the graph \nedges. To solve the all-pairs Dyck-CFL reachability problem, we apply the rewrite rules in Section 2.2 \nto the resulting con\u00adstraint system. As we will show, there is an S-path from nodes u to v in the initial \ngraph if and only if nu .Vin the least solution of the constructed constraint system. Figure 4 shows \nthe constraint graph corresponding to the Dyck-CFL reachability problem shown in Figure 2 using this \nreduction. The nullary constructors are omitted for clarity. 4.1 Correctness We sketch a proof of correctness \nfor the specialized re\u00adduction. The reduction is correct if the solution to the constructed set constraint \nproblem gives a solution to the original Dyck-CFL reachability problem. Theorem 1. Let G be an instance \nof the Dyck-CFL reachability problem, and C be the collection of set con\u00adstraints constructed as above \nto represent G. Then there is an edge S (u, v)in closure(G) if and only if nu .V is present in LS(C). \nThe theorem follows immediately from the following lem\u00admas: Lemma 1. Given C and G as in Theorem 1, let \nC ' de\u00adnote the conjunction of C with the system of constraints in\u00adtroduced by applying the resolution \nrules shown in Figure 3 along with the transitive closure rule se .X.X .se ' . se .se ' . Then there \nis an edge S (u, v)in closure(G) if and only if U.Vis present in C ' . Proof. We apply the set constraint \nresolution rules in lock-step with the CFL closure rules, and show that for ev\u00adery S-edge added to closure(G), \nthere is a corresponding variable-variable constraint that can be added to C ' .This approach requires \nus to normalize the Dyck-CFL grammar in a very speci.c way: S . SS S . Li Ri Li . (i Li . Li S Ri . )i \nRi . SRi S . s S . E S (x, z) It is easy to see that the above grammar derives the same set of strings \nas the original Dyck-CFL grammar. The intuition here is that normalizing the Dyck-CFL grammar this way \ncauses the CFL closure rules to add edges in exactly the same way as the set constraint resolution rules. \nWe now formalize this intuition. Consider the following order for adding edges to closure(G) and constraints \nto C ' : 1. Add all edges implied by the productions S .s, S . E, Ri . )i,and Li . (i. Note that there \nare only .nitely many edges that can be added, and that they are all added in this step. 2. Add all \nedges implied by the productions S .SS, S .Li Ri, Li .Li S,and Ri .SRi, and add the corresponding constraints \nto C ' according to Table 1.  In the .rst step, notice that the added S edges correspond to variable-variable \nedges that already exist in the initial system of constraints C (refer to the .rst rule of the reduc\u00adtion \nin Section 4). In the second step, notice that for every S edge added to closure(G), there are corresponding \ncon\u00adstraints that must exist in C ' that lead to the appropriate variable-variable constraint. Lemma \n2. Given C and G as in Theorem 1, let C ' de\u00adnote the conjunction of C with the system of constraints \nin\u00adtroduced by applying the resolution rules shown in Figure 3 along with the transitive closure rule \nse .X.X .se ' . se .se ' . Then the constraint nu .Vimplies the existence of a constraint U.Vin C ' . \nProof. Clearly, the rules in Figure 3 cannot add a con\u00adstraint of the form nu .V, so such a constraint \nis either present initially in C or it was added to C ' by transitive closure. In the former case, U \n= V and the lemma holds trivially. In the latter case, we can show (by induction on the number of applications \nof the transitive closure rule) that there are variables X1,..., Xn with nu .U.X1 . ... .Xn .Vpresent \nin C ' . Then by the transitive closure rule, U.Vmust be present in C ' . We now prove Theorem 1 using \nthe two lemmas. To show that S (u, v). closure(G) implies nu .V is present in C ' , wenotethatLemma 1guarantees \ntheexistence of a constraint U.V in C ' . Our construction guarantees an initial constraint nu .U, so \nby the transitive closure rule, nu .V exists in C ' . To show that a constraint nu .V in C ' implies \nS (u, v).closure(G), we appeal to Lemma 2, which guarantees the existence of a constraint U.Vin C ' . \nAppealing once again to Lemma 1, we have that S (u, v).closure(G). 4.2 Complexity We .rst discuss the \nrunning time to solve the all-pairs Dyck-CFL reachability problem using the generic CFL reachability \nalgorithm outlined in Section 2.1. In general, the generic algorithm has complexity O(|T . N|3 n 3). \nAp\u00adplying this result directly to an instance of the Dyck-CFL problem with k parenthesis kinds and n \ngraph nodes yields an O(k3 n 3) running time. However, we can sharpen this result by specializing the \ncomplexity argument to the Dyck-CFL grammar. The run\u00adning time of the generic CFL reachability algorithm \nis dom\u00adinated by the .rst rule in Figure 1. In this step, each edge in the graph might pair with each \nof its neighboring edges. In other words, for a given node j,each of j s incoming edges might pair with \neach of j s outgoing edges. Each node in the graph might have O(kn) edges labeled with (i or )i (there \nare k di.erent kinds, and n potential target nodes), as well as O(n) edges labeled with S. For node j,each \nof the O(kn) incoming edges may pair with O(n) outgoing edges, by a sin\u00adgle production. Similarly, each \nof the O(n)incoming S edges can match with O(n) outgoing edges by the single S . SS production. Thus, \nthe work for each node j is bounded by O(kn2). Since there are n nodes in the graph, the total work is \nO(kn3). An analogous argument holds for our reduction. For the fragment of set constraints used in this \npaper, a constraint system C canbe solvedintime O(v 2|C|)where v is the num\u00adber of variables in C and \n|C| is the number of constraints in C. Given an instance of the Dyck-CFL problem with k parenthesis kinds \nand n nodes, our reduction yields a con\u00adstraint system with O(n) variables and O(kn2)constraints, yielding \nan O(kn4) running time. Again, a more precise running time can be achieved by noting that for a given \nvariable node i in the constraint graph, the rules in Figure 3 can apply only O(kn2) times to pairs of \ni s upper and lower bounds. In an n node graph, then, the total work is O(kn3). 4.3 Empirical Comparison \nWe have implemented both the Melski-Reps reduction and our reduction in order to compare the two approaches. \nBoth implementations used the banshee toolkit as the underlying set constraint solver [11]. Our implementation \nof the Melski-Reps reduction uses the following normalized form of the Dyck-CFL grammar: S . SS S . Li \n)i Li . (i S S . s S . E We ran both implementations on randomly generated graphs. To test correctness, \nwe checked that both imple\u00admentations gave consistent answers to random reachability queries. We found \nthat our implementation of the Melski-Reps reduction did not scale to large graphs, even when the number \nof parenthesis kinds was kept small. For example, on a 500 node graph with 7500 edges and 20 parenthesis \nkinds, the Melski-Reps implementation computed the graph closure in 45 seconds, while our reduction completed \nin less than 1 second. This prevented us from testing the Melski-Reps approach on real applications: \nwe tried the implemen\u00adtation on the benchmarks in our case study (see Section 5) but found that none \n.nished within 10 minutes.  5. CASE STUDY: POLYMORPHIC FLOW ANALYSIS Flow analysis statically estimates \ncreation, use, and .ow of values in a program [14]. Problems such as computing may-alias relationships, \ndetermining receiver class informa\u00adtion, and resolving control .ow in the presence of indirect function \ncalls can be solved using .ow analysis. As with most static analyses, .ow analysis can be made more precise \nby treating functions polymorphically. Polymorphic .ow analysis eliminates spurious .ow paths that arise \nfrom con\u00ad.ating all call sites of a function. Recent work has established a connection between type\u00adbased \npolymorphic .ow analysis and CFL reachability [15]. As an alternative to constraint copying, systems \nof instan\u00adtiation constraints are reduced to a CFL graph. The .ow relation is described by a Dyck-CFL \ngrammar, hence, the problem of .nding the .ow of values in the input program reduces to an all-pairs \nDyck-CFL reachability problem. In this section, we apply our technique to the problem of polymorphic \n.ow analysis. For concreteness, we consider the speci.c problem of polymorphic tainting analysis [20]. \nIn tainting analysis, we are interested in checking whether any values possibly under adversarial control \ncan .ow to functions that expect trusted data. As a trivial example, consider the following code: int \nmain(void) { char *buf; buf = read from network(); exec(buf); } The call exec(buf) is probably not safe, \nsince the bu.er may come from a malicious or untrusted source. The particular tainting analysis we use \nemploys type quali.ers to solve this problem [5]. Brie.y, we can detect errors like the example shown \nabove by introducing two type quali.ers tainted and untainted. Data that may come from an untrusted source \nis given the type quali.er tainted, and data that must be trusted is given the type quali.er untainted. \nA type error is produced whenever a tainted value .ows to a place that must be untainted. Figure 5 illustrates \nthe connection between polymorphic tainting analysis and CFL reachability with another small program. \nThere are two calls to the identity function id.At the .rst call site, id is passed tainted data. At \nthe second call site, id is passed untainted data. The variable z2 is required to be untainted. Monomorphic \n.ow analysis would con.ate the two call sites, leading to a spurious error (namely, that tainted data \nfrom variable x1 reaches the untainted variable z2). Polymorphic .ow analysis can distinguish these two \ncall sites, eliminating the spurious error. The .ow graph in Figure 5 shows the connection to Dyck-CFL \nreachability: each function call site is labeled with a distinct index. The .ow from an actual parameter \nto a formal at call site i is denoted by an edge labeled (i. The .ow corresponding to the return value \nof the function is denoted by an edge la\u00adbeled )i. Intraprocedural assignment is denoted by s edges. \nIn this example, the spurious .ow path between x1 and z2 corresponds to a path whose word is (1 s )2, \nwhich is not in the Dyck language. In the remainder of this section, we discuss how to extend int id(int \ny1) { int y2 = y1; return y2; } tainted s x1 z1 )1 int main(void) (1 { tainted int x1; y1 y2 int z1,x2; \ns (2 )2 } Figure 5: Example C program and the corresponding Dyck-CFL reachability problem untainted \nint z2; z1 = id(x1); // call site 1 y y y y y y y y z2 = id(x2); // call site 2 s x2 z2 untainted our \ntechnique to solve polymorphic .ow analysis problems. We also discuss some optimizations that improve \nthe per\u00adformance of our reduction on polymorphic .ow graphs. We conclude with an experimental assessment \nof our approach on a set of C benchmarks. 5.1 Extensions It turns out that simple Dyck-CFL reachability \nisn t quite su.cient for most polymorphic .ow analysis applications. In this section, we discuss two \nadditional aspects of the prob\u00adlem that required us to extend our technique. 5.1.1 PN Reachability The \n.rst problem is that Dyck-CFL reachability fails to capture many of the valid .ow paths. Besides the \nmatched reachability paths represented by Dyck languages, certain kinds of partially matched reachability \nalso represent valid .ow. For example, in the graph shown in Figure 5, there should be a valid .ow path \nfrom the tainted quali.er to the node y2, since it is possible for y2 to contain a tainted integer at \nruntime. However, there is no S path between tainted and y2. This issue also arises in other applications \nsuch as interprocedural data.ow analysis. The conceptual solution to this problem is to add pro\u00adductions \nto the Dyck grammar that admit these additional partially matched paths. For our application, it turns \nout that we should admit all paths generated by the following grammar (see [15]): Start . PN P . SP | \n)i P | E N . SN | (i N | E S . (i S )i | SS | s | E Intuitively, this grammar accepts any substring of \na string in a Dyck language: P paths correspond to pre.xes of Dyck strings, and N paths correspond to \nsu.xes of Dyck strings. Since our reduction (unlike the Melski-Reps reduction) is specialized to Dyck \nlanguages, it is not immediately obvi\u00adous that we can modify our approach to accept exactly the strings \nin the above language. Fortunately, it turns out that we can handle these additional .ow paths without \nfunda\u00admentally changing our reduction. We separate the problem into three subproblems. First, we tackle \nthe problem of ad\u00admitting N paths (open-paren su.xes) within our reduction. Second, we tackle the problem \nof admitting P paths (close\u00adparen pre.xes) within our reduction. Finally, we combine the two solutions \nand handle the above language in its full generality. We .rst consider the problem of .nding N paths \nin the system of constraints produced by our reduction. Suppose we ask whether there is an N path between \nnodes u and v. To answer this query, we .rst recall that the least solution of a set variable is a regular \ntree language. Let L(V)denote the language corresponding to the least solution of V.Now consider the \nfollowing tree language LNu: N . nu | Oi(N) We claim (without proof) that there is an N path in the closed \ngraph between nodes u and v if and only if the inter\u00adsection of LNu and L(V)is non-empty. To see why, \nrecall that edges of the form (i(u, v)are represented by constraints Oi(U) .V in our reduction while \nedges of the form S (u, v)are represented by constraints U.V.Then an N path be\u00adtween nodes u and v is \nindicated by the presence of a term of the form Oi(...Oj (nu)) in the least solution of V.The language \nLNu generates exactly the terms of this form, so if L(V) nLNu is non-empty, there is at least one such \nterm in the least solution of V,hence, there is an N path from u to v. As a simple example, consider \nthe following CFL graph: (j (i s uxyv and suppose we ask whether there is an N path from node u to node \nv. Our reduction yields a constraint system which includes the following constraints: nu .U Oi(U) .X \nX.Y Oj (Y) .V Note that L(V) contains the term Oj (Oi(nu)), which is also an element of LNu, indicating \nthat there is an N path from u to v. We now consider the problem of .nding P paths in the system of constraints \nproduced by our reduction. The tech\u00adnique is essentially the same as with .nding N paths. There is one \nwrinkle, however: the )i edges that form P paths are represented as projections in the constraint system. \nThere is no term representation of a )i edge as there is with a (i edge. The solution is straightforward: \nwe simply add a term representation for these edges. We modify the reduction so that for each edge of \nthe form )i (u, v),we alsoadd the con\u00adstraint p(U) .V (where p is a new unary constructor) to the system. \nNote that there is only one p constructor used for all indexed )i symbols. This is because the indices \nof the )i symbols are irrelevant to the P paths. Now, to check for P paths between nodes u and v, we \nsimply check the non-emptiness of the intersection of L(V) with the following language LPu: P . nu | \np(P) Finally, to check for PN paths from u to v, we combine the above two solutions, and check the non-emptiness \nof L(V) nLPNu,where LPNu is de.ned as follows: N . P | Oi(N) P . nu | p(P) Note that this language consists \nof terms of the form Oi(...Oj (p(...p(nu)))) which precisely characterize the PN paths. In practice, \nwe do not actually build a tree automata rec\u00adognizing the language LPNu to compute the intersection. \nInstead, to check for a PN path from node u to node v, we traverse the terms in the least solution of \nV, searching for nu. We prune the search when the expanded term is no longer in the language LPNu or \nwhen a cycle is found. Since our implementation applies the rules in Figure 3 online, this divides our \nalgorithm into two phases: an exhaustive phase where all S paths are discovered, and a demand-driven \nphase where PN paths are discovered as reachability queries are asked3 . The approach outlined in this \nsection can be generalized. The ideas apply to any regular language reachability prob\u00adlem composed with \na Dyck language reachability problem. In general, let G be an instance of the Dyck-language reach\u00adability \nproblem with alphabet O .C,and R be a regular language with alphabet A .E. Alphabet A need not be dis\u00adjoint \nfrom O .C, but the symbols s and S in the Dyck language must be interpreted as E in the regular language. \nThe all-pairs composed reachability problem over D and G determines the set of vertices (u, v) such that \nthere is a path in the language R from u to v in closure(G). Viewing the PN grammar in this setting, \nthe P productions correspond to the regular language ) * i ,the N productions correspond to the regular \nlanguage ( * i , and the regular language R is ) * i ( * i . The approach outlined previously solves \nthe all-pairs com\u00adposed reachability problem: the constraint solver elimi\u00adnates the Dyck language problem, \nleaving a regular lan\u00adguage reachability problem that can be solved on demand by exploring the least \nsolution of the constraints as described above. 3A completely demand-driven algorithm could be imple\u00admented \nusing the approach of [7]. x1 z1 / / (1 -)1 / /. / / / y / y1 yk \u00b7\u00b7\u00b7 \u00b7\u00b7\u00b7 yk-1 \u00b7\u00b7\u00b7 / / / / / / /(n \n)n / xnzn Figure 6: The summary edge optimization  5.1.2 Global Nodes Another problem we face is that \nglobal variables in lan\u00adguages such as C must be treated specially to discover all the valid .ow paths. \nThe problem is that assignments to global variables can .ow to any context, since global storage can \nbe accessed at any program point. Conceptually, nodes cor\u00adresponding to global variables should have \nself-loops labeled )i for every index i that may appear elsewhere in the graph. This solution essentially \ntreats globals monomorphically (see [3] for a more complete discussion). While this solution is simple \nand easy to implement, in practice it is too expen\u00adsive to represent these edges explicitly. With an \nexplicit representation, each global variable s upper bounds may be proportional to the size of the input \nprogram. Explicitly constructing this list is prohibitively expensive: with an ex\u00adplicit representation \nof self-edges, our implementation did not .nish after 10 minutes on even the smallest benchmark. We solved \nthis problem by adding a new feature to the constraint solver. The added feature has a simple inter\u00adpretation, \nand may prove useful in other contexts. We in\u00adtroduce constructor groups, which are simply user-speci.ed \nsets of constructors. The elements of a constructor group must all have the same arity. Once a constructor \ngroup g is de.ned, a special kind of projection pattern called a group projection pattern can be created. \nA group projection pat\u00adtern gproj(g,i, e) has essentially the same semantics as a projection pattern, \nexcept that instead of specifying a sin\u00adgle constructor, an entire group is speci.ed. The new rules for \nhandling group projections are as follows: C .{c(se1, ...,sea(c)) .gproj(g,i, se)}. C .{sei .se}if c \n.g C .{c(se1, ...,sea(c)) .gproj(g,i, se)}. C if c/.g Constructor groups provide us with a way to concisely \nrep\u00adresent collections of similar projection patterns. To handle global nodes, we add each Oi constructor \nto a new group gO. For each global node u,weadd theconstraint U.gproj(gO, 1, U) which simulates the addition \nof self loops )i for each index i in the graph.  5.2 Optimizations In this subsection, we discuss some \noptimizations for poly\u00admorphic .ow analysis applications. 5.2.1 Summary Edges The CFL graphs that arise \nin this application have a par\u00adticular structure that can be exploited to eliminate redun\u00ad O1(X1). . \n. proj(O1,1,Z1) ......... \u00ad \u00b7\u00b7\u00b7 Y1 \u00b7\u00b7\u00b7 Yk-1 Yk \u00b7\u00b7\u00b7 . On(Xn) . proj(On,1,Zn) (a) proj(O,1,Z1) y. .\u00ad \n O(X1,...,Xn) Y1 \u00b7\u00b7\u00b7 Yk-1 Yk \u00b7\u00b7\u00b7 proj(O,n,Zn) (b) Figure 7: Edges added by the set constraint solver \nfor the graph in Figure 6 using (a) the standard reduction and (b) the reduction with the clustering \noptimization dant work during the computation of the graph closure. An exemplar of this structure is \nshown in Figure 6. There are two important features of this graph that we exploit. First, there is a \nlong chain of nodes y2,...,yk-1,none of which contain edges other than s-edges. Second, the nodes y1 \nand yk have a large number of predecessor (i edges and succes\u00adsor )i edges, respectively. This situation \narises frequently in polymorphic .ow analysis applications: the xi nodes repre\u00adsent the in.ow of actual \narguments to the formal argument y1 at call sites, and the zi nodes represent the out.ow of return values \nback to call sites from the returned value yk. The trick is to discover all the S(xi,zi) paths with as \nlittle redundant work as possible. To .nd these edges, the generic CFL algorithm discussed in Section \n2.1 would add a total of nk new edges from each of the xi s to each of the yj s. Conceptually, this corresponds \nto analyzing the function body once per static call site. One way to avoid this redundant work is to \nconstruct a so-called summary edge after analyzing the chain of y nodes once [10]. This optimization \nworks as follows: the .rst path explored from an xi node triggers a new search forward from node y1. \nAnalyzing the chain of y nodes causes k-1edge additions from y1 to each of the remaining yi s. When the \nedge S(y1,yk) is .nally discovered, it is marked as a sum\u00admary edge, and y1 is marked as having a summary \nedge. When searching forward for new paths from the other xi nodes, the summary edge S(y1,yk) is used, \navoiding re\u00adpeated analysis of the y chain. In total, the summary edge approach adds a total of n+ k-1 \nnew edges to discover the S(xi,zi) edges. Conceptually, the summary edge approach corresponds to analyzing \na function body once, and copying the summarized .ow to each call site. The dashed edges in Figure 6 \nshow the edges added by a closure algorithm with the summary edge optimization. Our reduction as described \nmay perform the same work as the naive CFL closure algorithm on this example. Fig\u00adure 7(a) shows the \nworst-case edge additions performed on this example in inductive form. In inductive form, the num\u00adber \nof edge additions depends on the ordering of the Yi variables. In the worst case, the variable ordering \nmight cause inductive form to represent all variable-variable edges as as successor edges (i.e. if o(Yi) \n>o(Yi+1) for every i in the chain). On the other hand, if the ordering is such that some of the variable-variable \nedges are represented as predecessor edges, inductive form can reduce the number of edge additions. Under \nthe best variable ordering, inductive form adds the same number of edges as the summary edge optimization. \nIt is also possible to modify the reduction so that the num\u00adber of edge additions is minimized regardless \nof the variable ordering. The key is to cluster the variables corresponding to the xi nodes into a single \nn-ary constructed term instead of n unary constructed terms. The indices can be encoded by the position \nwithin the constructed term: for instance, the ith subterm represents the source end of an edge la\u00adbeled \n(i. Our representation of )i edges is modi.ed as well, so that, e.g., the constraint U.proj(O,i,V)represents \nan edge )i (u,v). Figure 7(b) shows the e.ect of the clustering optimization on the same example graph. \nThe net e.ect of this optimization is the same as with summary edges: the edges S(xi,zi) are discovered \nwith the addition of at most n+ k-1 edges instead of nk edges. With some work, this reduction can be \nextended to handle PN-reachability and global nodes, though we omit the details here.  5.2.2 Cycle Elimination \nOne advantage of our reduction is that it preserves the structure of the input graph in a way that the \nMelski-Reps reduction does not. The constraint graphs produced by our reduction are isomorphic (modulo \nthe representation of edges) to the original CFL graph. In fact, the connection is so close that cycle \nelimination, one of the key optimiza\u00adtions used in set constraint algorithms, is revealed to have an \ninterpretation in the Dyck-CFL reachability problem. Cycle elimination exploits the fact that variables \ninvolved in cyclic constraints (constraints of the form X1 .X2 . X3 ... .Xn .X1) are equal in all solutions, \nand thus can be collapsed into a single variable. By reversing our reduction, we see that cyclic constraints \ncorrespond to cycles of the form: ssss x1 x2 ... xn x1 in the Dyck-CFL graph. The corresponding set \nvariables are equivalent in all solutions; the CFL notion is that any node reaching one of the xi nodes \nreaches every xi node because we can always concatenate additional s terminals onto any word in the language \nand still derive a valid S-path. Hence, all the xi s in the CFL graph can be collapsed and treated as \na single node. Note that the Melski-Reps reduction does not preserve  such cycles: their reduction applied \nto CFL graph shown 0 50000 100000 150000 above produces constraints of the form s(Xi) .Xi-1 which Preprocessed \nLOC do not expose a cyclic constraint for cycle elimination to simplify. We validate these observations \nexperimentally in Sec- Figure 8: ment Results for the tainted/untainted experi\u00ad tion 5.3 by showing the \ne.ect of partial online cycle elimi\u00ad nation [4] on our implementation.  5.3 Experimental Results In \nthis section we compare an implementation of the re\u00ad duction in Section 4 to a hand-written Dyck-CFL \nreachabil\u00ad ity implementation by Robert Johnson, which is based on an algorithm described in [10]. Johnson \ns implementation is customized to the polymorphic quali.er inference problem, and contains optimizations \n(including summary edges) that exploit the particular structure of the graphs that arise in this application. \nOur implementation uses the banshee analysis toolkit as Ratio (no cycle-elim/cycle-elim) 45 40 35 \n30 25 20 15 10 5 0  the underlying set constraint solver [11]. We implemented the extensions for \nPN-reachability and global nodes as de\u00adscribed in Section 5.1. In addition, all of the optimizations \ndescribed in Section 5.2 are part of our implementation: we support clustering, and the banshee toolkit \nuses inductive form and enables cycle elimination by default. We used the C benchmark programs shown \nin Table 2 for our experiments. For each benchmark, the table lists the number of lines of code in the \noriginal source, the number of pre-processed lines of code, the number of distinct nodes in the CFL graph, \nthe number of edges in the CFL graph, and the number of distinct indices (recall that this num\u00adber corresponds \nto the number of function call sites). All experiments were performed on a dual-processor 550 MHz Pentium \nIII with 2GB of memory running RedHat 9.04 . We ran CQual to generate a Dyck-CFL graph, and com\u00adputed \nthe closure of that graph using Johnson s Dyck-CFL reachability implementation and our own. We also ran \nour implementation with the clustering optimization enabled. Table 2 shows the analysis times (in seconds) \nfor each exper\u00adiment. The analysis times also include the time for CQual to parse the code and build \nthe initial graph. Column 7 shows the time required for our implementation without cy\u00adcle elimination. \nColumn 8 shows times for the same im\u00adplementation with partial online cycle elimination enabled. Column \n9 shows times with cycle elimination and the clus\u00adtering optimization. Finally, column 10 shows the times \nfor Johnson s implementation, which acts as the gold standard. Figure 8 plots the analysis times for \nour implementation, normalized to Johnson s implementation. The results show that our implementation \nexhibits the same scaling behavior 4Though only one processor was actually used. 0 50000 100000 150000 \n Preprocessed LOC Figure 9: Speedup due to cycle elimination as Johnson s. In all the benchmarks except \none, the analysis time for our implementation remains within a factor of two of Johnson s implementation. \nBecause parse time is a con\u00adstant for all the implementations, factoring it out does have an a.ect on \nthese ratios; however, we found that parse time accounts for a small fraction of the total analysis time. \nThe clustering optimization improved a few benchmarks signi.\u00adcantly, but did not seem to improve scalability \noverall. Figure 9 compares the performance of our implementa\u00adtion (no clustering) with and without cycle \nelimination. We found that our benchmarks ran up to 40 times faster with cycle elimination enabled. These \nresults suggest that online cycle elimination could be incorporated into the standard algorithms for \nDyck-CFL reachability, an idea that has been implicitly suggested before [8].  6. RELATED WORK We view \nour work as a practical follow-up to Melski and Reps work, which shows that set constraints and CFL reachability \nare interconvertible [12, 13]. Our approach expands on the connection between Dyck-CFL reachabil\u00adity \nand set constraints, and illustrates the practical conse\u00adquences of that connection. Many researchers \nhave formulated program analyses as CFL reachability problems. The authors .rst became aware of the connection \nfrom work by Reps et al., who formulated Benchmark identd-1.0.0 mingetty-0.9.4 bftpd-1.0.11 woman-3.0a \npatch-2.5 m4-1.4 muh-2.05d di.utils-2.7 uucp-1.04 mars nwe-0.99 imapd-4.7c ipopd-4.7c sendmail-8.8.7 \nproftpd-1.20pre10 backup-c.xed apache-1.3.12 cfengine-1.5.4 LOC 385 441 964 2282 7561 13881 4963 15135 \n32673 25789 31655 29762 44004 23733 39572 51057 39909 Preproc 1224 1599 6032 8611 11862 18830 19083 23237 \n69238 72954 78049 78056 93383 99604 125350 135702 141863 Nodes 3281 5421 9088 10638 20587 30460 19483 \n33462 91575 115876 388794 378085 126842 184195 139189 152937 146274 Edges 1440 1469 37558 69171 76121 \n268313 141550 281736 2007054 1432531 2402204 2480718 4173247 4048202 3657071 6509818 7008837 Indices \n74 111 380 450 899 1187 684 1191 4725 4312 7714 7037 6076 7206 6339 5627 6339 banshee(s) .25 .25 1 1 \n5 11 9 10 43 117 1782 877 454 561 139 75 597 + cycle elim(s) .25 .25 .75 1 1.75 3 2 4 14 14 45 38 28 \n33 21 32 33 + clusters(s) .25 .25 .75 1.25 1.5 3 2 3 12 12 25 25 20 24 20 29 29 johnson(s) .25 .25 .5 \n.75 1 2 1.5 2 8 8 23 21 13 18 12 18 17 Table 2: Benchmark data for all experiments interprocedural data.ow \nanalysis as a Dyck-CFL graph, and introduced an algorithm to answer the all-pairs reachability problem \nfor these graphs [18]. Follow-up work introduced a demand-driven algorithm for solving this problem [10]. \nMany implementations of Dyck-CFL reachability are based on this algorithm. Rehof et al. show how to use \nCFL reach\u00adability as an implementation technique for polymorphic .ow analysis [15]. CFL reachability \nis used as an alternative to repeated copying and simpli.cation of systems of instan\u00adtiation constraints. \nThe .rst application of Rehof et al. s work was to polymorphic points-to analysis [3]. Other ap\u00adplications \nof Dyck-CFL reachability include .eld-sensitive points-to analysis, shape analysis [16], interprocedural \nslic\u00ading [9], and debugging systems of uni.cation constraints [2].  7. CONCLUSION We have shown a reduction \nfrom Dyck-CFL reachability to set constraints, and shown that our technique can be applied in practice \nto the CFL reachability problems that arise in program analyses. Acknowledgments We would like to thank \nRobert Johnson for providing us with his implementation of CFL reachability, and David Melski, Tom Reps, \nand the anonymous reviewers for their helpful comments and suggestions. 8. REFERENCES [1] A.Aiken and \nE.L.Wimmers.Solving SystemsofSet Constraints. In Proceedings, Seventh Annual IEEE Symposium on Logic \nin Computer Science, pages 329 340, Santa Cruz, California, June 1992. [2] V. Choppella and C. T. Haynes. \nSource-tracking Uni.cation. In F. Baader, editor, Automated Deduction -CADE-19, 19th International Conference \non Automated Deduction Miami Beach, FL, USA, July 28 -August 2, 2003, Proceedings, volume 2741 of Lecture \nNotes in Computer Science, pages 458 472. Springer, 2003. [3] M. Das, B. Liblit, M. F\u00a8ahndrich, and J. \nRehof. Estimating the Impact of Scalable Pointer Analysis on Optimization. In SAS 01: The 8th International \nStatic Analysis Symposium, Lecture Notes in Computer Science, Paris, France, July 16 18 2001. Springer-Verlag. \n[4] M. F\u00a8ahndrich, J. S. Foster, Z. Su, and A. Aiken. Partial Online Cycle Elimination in Inclusion Constraint \nGraphs. In Proceedings of the 1998 ACM SIGPLAN Conference on Programming Language Design and Implementation, \npages 85 96, Montreal, Canada, June 1998. [5] J. S. Foster, M. F\u00a8ahndrich, and A. Aiken. A Theory of \nType Quali.ers. In Proceedings of the 1999 ACM SIGPLAN Conference on Programming Language Design and \nImplementation, pages 192 203, Atlanta, Georgia, May 1999. [6] N. Heintze. Set Based Program Analysis.PhD \ndissertation, Carnegie Mellon University, Department of Computer Science, Oct. 1992. [7] N. Heintze and \nO. Tardieu. Demand-driven Pointer Analysis. In SIGPLAN Conference on Programming Language Design and \nImplementation, pages 24 34, 2001. [8] N. Heintze and O. Tardieu. Ultra-fast Aliasing Analysis Using \nCLA: A Million Lines of C Code in a Second. In SIGPLAN Conference on Programming Language Design and \nImplementation, pages 254 263, 2001. [9] S. Horwitz, T. Reps, and D. Binkley. Interprocedural Slicing \nUsing Dependence Graphs. ACM Transactions on Programming Languages and Systems, 12(1):26 60, 1990. [10] \nS. Horwitz, T. Reps, and M. Sagiv. Demand Interprocedural Data.ow Analysis. In Proceedings of the 3rd \nACM SIGSOFT Symposium on Foundations of Software Engineering, pages 104 115. ACM Press, 1995. [11] J. \nKodumal. BANSHEE: A Toolkit for Building Constraint-Based Analyses. http://bane.cs.berkeley.edu/banshee. \n [12] D. Melski and T. Reps. Interconvertbility of Set Constraints and Context-Free Language Reachability. \nIn Proceedings of the 1997 ACM SIGPLAN Symposium on Partial Evaluation and Semantics-based Program Manipulation, \npages 74 89. ACM Press, 1997. [13] D. Melski and T. Reps. Interconvertibility of a Class of Set Constraints \nand Context-Free-Language Reachability. Theoretical Computer Science, 248:29 98, 2000. [14] C. Mossin. \nFlow Analysis of Typed Higher-Order Programs. PhD thesis, DIKU, Department of Computer Science, University \nof Copenhagen, 1996. [15] J. Rehof and M. F\u00a8ahndrich. Type-Based Flow Analysis: From Polymorphic Subtyping \nto CFL-Reachability. In Proceedings of the 28th Annual ACM SIGPLAN-SIGACT Symposium on Principles of \nProgramming Languages, pages 54 66, London, United Kingdom, Jan. 2001. [16] T. Reps. Shape Analysis as \na Generalized Path Problem. In Proceedings of the 1995 ACM SIGPLAN Symposium on Partial Evaluation and \nSemantics-based Program manipulation, pages 1 11. ACM Press, 1995. [17] T. Reps. Program Analysis Via \nGraph Reachability. In Information and Software Technology, pages 701 726, 1998. [18] T. Reps, S. Horwitz, \nand M. Sagiv. Precise Interprocedural Data.ow Analysis via Graph Reachability. In Proceedings of the \n22nd Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, pages 49 61, San Francisco, \nCalifornia, Jan. 1995. [19] A. Rountev and S. Chandra. O.-line Variable Substitution for Scaling Points-to \nAnalysis. In Proceedings of the ACM SIGPLAN 2000 conference on Programming language design and implementation, \npages 47 56. ACM Press, 2000. [20] U. Shankar, K. Talwar, J. S. Foster, and D. Wagner. Detecting Format \nString Vulnerabilities with Type Quali.ers. In Proceedings of the 10th Usenix Security Symposium, Washington, \nD.C., Aug. 2001. [21] Z. Su, M. F\u00a8ahndrich, and A. Aiken. Projection Merging: Reducing Redundancies in \nInclusion Constraint Graphs. In Proceedings of the 27th ACM SIGPLAN-SIGACT Symposium on Principles of \nProgramming Languages, pages 81 95. ACM Press, 2000.  \n\t\t\t", "proc_id": "996841", "abstract": "Many program analyses can be reduced to graph reachability problems involving a limited form of context-free language reachability called Dyck-CFL reachability. We show a new reduction from Dyck-CFL reachability to set constraints that can be used in practice to solve these problems. Our reduction is much simpler than the general reduction from context-free language reachability to set constraints. We have implemented our reduction on top of a set constraints toolkit and tested its performance on a substantial polymorphic flow analysis application.", "authors": [{"name": "John Kodumal", "author_profile_id": "81100523487", "affiliation": "University of California, Berkeley, CA", "person_id": "P517413", "email_address": "", "orcid_id": ""}, {"name": "Alex Aiken", "author_profile_id": "81100399954", "affiliation": "Stanford University", "person_id": "PP39041079", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/996841.996867", "year": "2004", "article_id": "996867", "conference": "PLDI", "title": "The set constraint/CFL reachability connection in practice", "url": "http://dl.acm.org/citation.cfm?id=996867"}