{"article_publication_date": "06-09-2004", "fulltext": "\n Parametric Regular Path Queries* Yanhong A. Liu Tom Rothamel Fuxiang Yu Scott D. Stoller Nanjun Hu Computer \nScience Department, State University of New York at Stony Brook, Stony Brook, NY 11794 {liu,rothamel,fuxiang,stoller,nanjun@cs.sunysb.edu} \nABSTRACT Regular path queries are a way of declaratively expressing queries on graphs as regular-expression-like \npatterns that are matched against paths in the graph. There are two kinds of queries: existential queries, \nwhich specify properties about individual paths, and universal queries, which specify prop\u00aderties about \nall paths. They provide a simple and conve\u00adnient framework for expressing program analyses as queries \non graph representations of programs, for expressing veri\u00ad.cation (model-checking) problems as queries \non transition systems, for querying semi-structured data, etc. Paramet\u00adric regular path queries extend \nthe patterns with variables, called parameters, which signi.cantly increase the expres\u00adsiveness by allowing \nadditional information along single or multiple paths to be captured and related. This paper shows how \na variety of program analysis and model-checking problems can be expressed easily and suc\u00adcinctly using \nparametric regular path queries. The paper de\u00adscribes the speci.cation, design, analysis, and implementa\u00adtion \nof algorithms and data structures for e.ciently solving existential and universal parametric regular \npath queries. Major contributions include the .rst complete algorithms and data structures for directly \nand e.ciently solving ex\u00adistential and universal parametric regular path queries, de\u00adtailed complexity \nanalysis of the algorithms, detailed ana\u00adlytical and experimental performance comparison of varia\u00adtions \nof the algorithms and data structures, and investiga\u00adtion of e.ciency tradeo.s between di.erent formulations \nof queries. Categories and Subject Descriptors D.2.4 [Software Engineering]: Software/Program veri.ca\u00adtion \nmodel checking; D.3.2 [Programming Languages]: Language classi.cations very high-level languages; D.3.3 \n[Programming Languages]: Language constructs and fea\u00ad * This work was supported in part by ONR under \ngrants N00014-01-1-0109 and N00014-02-1-0363 and NSF under grants CCR-0306399, CCR-0204280, CCR-0311512, \nCCR\u00ad0205376, and CCR-9876058. Permission to make digital or hard copies of all or part of this work for \npersonal or classroom use is granted without fee provided that copies are not made or distributed for \npro.t or commercial advantage and that copies bear this notice and the full citation on the .rst page. \nTo copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior speci.c \npermission and/or a fee. PLDI 04, June 9 11, 2004, Washington, DC, USA. Copyright 2004 ACM 1-58113-807-5/04/0006 \n...$5.00. tures patterns; D.3.4 [Programming Languages]: Pro\u00adcessors code generation, optimization;E.1 \n[Data]: Data structures arrays, lists;E.2 [Data]: Data storage represen\u00adtations hash-table representations, \nlinked representations; F.2.2 [Analysis of Algorithms and Problem Complex\u00adity]: Nonnumerical algorithms \nand problems computations on discrete structures; F.3.2 [Logics and Meanings of Programs]: Semantics \nof programming languages Pro\u00adgram analysis; F.4.3 [Mathematical Logic and Formal Languages]: Formal languages \nClasses de.ned by gram\u00admars or automata; H.2.3 [Information Systems]: Data\u00adbase management query languages \n; H.2.4 [Information Systems]: Systems query processing General Terms Algorithms, Design, Languages, \nPerformance  Keywords Algorithms, data structures, graph query languages, pro\u00adgram analysis, memoization, \nmodel checking, optimization, precomputation, regular expressions, regular path queries 1. INTRODUCTION \nMany important analysis problems can be expressed as graph queries. This includes program analyses that \nare es\u00adsential for improving program performance, safety, security, etc., model-checking problems for \nveri.cation of sequential and concurrent systems, mining of semi-structured data, and so on. General \nframeworks for graph queries, together with tools based on them, allow users to easily specify and e.\u00adciently \nperform a wide variety of analysis tasks, saving enor\u00admous e.ort compared to implementing each analysis \nsepa\u00adrately. Parametric regular path queries. Regular path queries are a way of declaratively expressing \nqueries on graphs as regular-expression-like patterns that are matched against paths in the graph. They \nprovide a simple and convenient framework for expressing program analyses as queries on graph representations \nof programs [6] and for expressing model-checking problems as queries on transition systems. Regular \npath queries are also important in analyzing semi\u00adstructured data in database systems [1], particularly \ndata in XML [19], which is increasingly used for representing data, including programs as data. Regular \nexpression patterns can capture simple but com\u00admon and important properties easily, even though they \nare not as powerful as languages in more sophisticated frame\u00adworks. The combined power and simplicity \nof regular ex\u00adpressions contribute to their wide use in computing, from languages and compilers, to database \nand web information retrieval, to operating systems and security, etc. Parametric regular path queries \nextend the patterns with variables, called parameters, which signi.cantly increase the expressiveness \nby allowing additional information along sin\u00adgle or multiple paths to be captured and related, and the \namount of such information is not bounded by the size of the pattern. This extension enables analysis \nof signi.cantly many more important properties about dependencies, con\u00adcurrency, resource usage, etc. \nThe regular expression pat\u00adterns used to analyze these properties are simple, easy to write, and succinct. \nGeneral algorithms have been studied for solving simpler regular path queries, in particular, queries \ninvolving uncor\u00adrelated paths [21] and queries containing no variables [12, 6]. A method was also proposed \nto code parametric regular path queries using logic programs [7]. What have been lack\u00ading are complete \nalgorithms and data structures for solving parametric regular path queries directly, e.ciently, and with \nprecise complexity analysis. This paper. This paper studies existential and universal parametric regular \npath queries and their use in program analysis and model checking. Existential queries specify properties \nabout individual paths. Universal queries spec\u00adify properties about all paths and are much harder to \nsolve. We describe the precise speci.cation, design, analysis, and implementation of complete algorithms \nand data structures for e.ciently solving both kinds of queries. Major contributions of this paper include \nthe .rst com\u00adplete algorithms and data structures for directly and e.\u00adciently solving existential and \nuniversal parametric regular path queries, detailed complexity analysis of the algorithms, detailed analytical \nand experimental performance compari\u00adson of variations of the algorithms and data structures, and investigation \nof e.ciency tradeo.s between di.erent formu\u00adlations of queries. The rest of the paper is organized as \nfollows. Section 2 de\u00ad.nes parametric regular path queries and shows how a vari\u00adety of practical program \nanalysis and model checking prob\u00adlems can be expressed easily and succinctly as such queries. Sections \n3 and 4 describe algorithms, data structures, and time and space complexities for solving existential \nand uni\u00adversal queries, respectively. Section 5 discusses tradeo.s and extensions, as well as improvements \nin the complexity anal\u00adysis and performance and in the query language and usage. Section 6 describes \nour implementation and experiments. Section 7 compares with related work and concludes. 2. PARAMETRIC \nREGULAR PATH QUERIES When analyzing a program graph or checking a transition graph, two kinds of questions \nare often asked: Will some\u00adthing happen along some path of the graph? and Will something happen along \nall paths of the graph? We refer to these as existential and universal queries, respectively. In parametric \nregular path queries, something is expressed as an extended regular expression that contains parame\u00adters, \nhereafter called a pattern. To answer these queries, one needs to examine paths of the graph and check, \nfor an existential query, whether some path matches the pattern and, for a universal query, whether all \npaths match the pat\u00adtern. We de.ne the problem and then give examples in pro\u00adgram analysis and model \nchecking. These examples show that parametric regular path queries are powerful enough to express a wide \nvariety of useful analysis problems, and that the queries are succinct and easy to write. In contrast, \nimplementing these analyses separately without a frame\u00adwork would require a signi.cant e.ort. Thus, a \ntool for e.\u00adcient evaluation of such queries can greatly reduce the e.ort needed to implement new analyses. \nTools based on more expressive analysis frameworks, such as set constraints or temporal logic, could \nbe used for these analyses, but those frameworks and tools are typically also more complicated and hence \naccessible only to more sophisticated users. 2.1 De.nition of the problem Graphs. We consider edge-labeled \ndirected graphs. For ex\u00adample, in program graphs, vertices correspond to program points, and labeled \nedges correspond to operations. These graphs are similar to control-.ow graphs, but the roles of vertices \nand edges are reversed. We generally use edge labels that re.ect only information relevant to the analysis \nof interest. For example, consider an assignment statement a:=5 in a program. If we are inter\u00adested in \nanalyzing reaching de.nitions, then this statement mayberepresented by thelabel def(a), indicating a \ndef\u00adinition of (i.e., assignment to) a. If we are interested in constant folding, then this statement \nmight be represented by the label def(a,5). We refer to names, such as def, that represent abstract aspects \nof edge labels, as constructors, and we display them in boldface. We refer to names, such as variable \nname a or literal 5, that represent concrete aspects of edge labels, as symbols, and we display them \nin typewriter font. An edge la\u00adbel is a constructor applied to zero or more arguments, where an argument \nmay be a symbol or, recursively, a constructor application. Parametric regular-expression patterns. We \nconsider patterns that are regular expressions whose alphabet con\u00adtains parameterized elements. We display \nparameters in math italic font. For example, def(x) * use(x) represents a consecutive sequence of de.nitions \nof a same variable, de\u00adnoted by x, ended by a use of the same variable. We also allow wildcards and negations, \ndenoted by and \u00ac,respec\u00adtively. For example, * def(a) represents a sequence of zero or more arbitrary \nlabels followed by a de.nition of a, def() represents a de.nition of any variable, \u00acdef(a) represents \nanything that is not a de.nition of a,and def(\u00aca) repre\u00adsents a de.nition of any variable but a. Precisely, \nthe alphabet of the patterns contains elements, called transition labels, that may be a constructor applied \nto zero or more arguments, its negation, or a wildcard, where an argument may be: (1) a symbol in the \nedge labels, or its negation; (2) a parameter that can be instantiated to symbols in the edge labels, \nor its negation; or (3) recursively, a transition label. Note that we only consider matching of parameters \nwith symbols; a generalization to consider matching with constructor applications is possible. Substitutions \nand matching. To match patterns against graph paths, we need the notion of substitution. A substitu\u00adtion \nis a map from parameters in the pattern to symbols in the graph. For example, substitution {x . a,y. \nb} maps x to a and maps y to b. A substitution . applied to a pat\u00adtern p, denoted .(p), replaces the \nparameters in p according to the mappings in .. We say that an edge label el matches a transition label \ntl under a substitution . if .(tl) contains no parameters and el matches .(tl), where an edge label el \nmatches a transition label tl that contains no parameters if one of the following conditions holds: (1) \nel = tl;(2) tl = ;(3) tl = \u00actl1 and, recursively, el does not match tl1;(4) el = f(el1, ..., eln), tl \n= f (tl1, ..., tln), and recursively eli matches tli for i = 1..n,where f is a constructor. We say that \na path g in a graph G matches asentence p accepted by a pattern P under a substitution . if the sequence \nof edge labels on g matches the sequence of transition labels on p under . label by label. v0 a:=1; \n(a) if(f(a)) a:=2; (a) else def(a) def(b) b:=1; g(b); (b) Figure 1: An example program and its program \ngraph. Figure 1 gives an example program graph for analyses about variable de.nitions and uses. Given \na pattern (\u00acdef(x)) * use(x), the path def(a)use(a)def(a)use(b) in the graph matches the sentence (\u00acdef(x))3 \nuse(x) ac\u00adcepted by the pattern under the substitution {x . b}. Parametric regular path queries. We de.ne \ntwo kinds of queries: Existential queries: Given an edge-labeled directed graph G where labels may have \narguments, a vertex v0in G, and a parametric regular-expression pattern P ,com\u00adpute all pairs of vertex \nv in G and a substitution . for parameters in P such that there exists apathfrom v0 to v in G that matches \nsome sentence accepted by P under .. Universal queries: Given an edge-labeled directed graph G where \nlabels may have arguments, a vertex v0in G, and a parametric regular-expression pattern P ,com\u00adpute all \npairs of vertex v in G and substitution . for parameters in P such that there is a path from v0to v in \nG and every path from v0to v in G matches some sentence accepted by P under .. 2.2 Program analysis \nexamples We describe how a range of common and important prop\u00aderties can be expressed easily and succinctly \nusing para\u00admetric regular path queries. Some data-.ow analysis prob\u00adlems are backward and are expressed \nusing backward queries, meaning that all edges in the graph are reversed before the query is evaluated. \nWe assume the program has a unique entry point and a unique exit point, as the default start\u00ading vertex \nfor forward queries and backward queries, respec\u00adtively. Uninitialized variables. Checking for uses of \nunini\u00adtialized variables is a classic data-.ow analysis. Consider a program graph with labels of the \nforms def(a) and use(a), representing de.nitions and uses, respectively, of some vari\u00adable a. To .nd \nvertices that immediately follow a use of an uninitialized variable, we can use an existential query \nwith pattern (\u00acdef(x)) * use(x). To .nd only the .rst use of each uninitialized variable along each path, \nwe can use (\u00ac(def(x)|use(x))) * use(x). The substitution for x asso\u00adciated with a vertex in the result \nset identi.es the o.ending program variable. Live variables. Finding live variables at each program point \nis another classic data-.ow analysis. A variable is live at a program point if it is used before being \nde.ned on some path from that point. We can use a backward exis\u00adtential query with pattern * use(x)(\u00acdef(x)) \n* . It returns all pairs (v, .) such that at program point v,variable .(x)is live. Other classic analyses, \nsuch as reaching de.nitions and dead-code analysis, can also be formulated easily as para\u00admetric regular \npath queries. Available expressions. An expression aob for some variables a and b and operation o is \navailable at a program point v if, on every path from the program entry point to v, there is a computation \nof aob, represented using label exp(a,o,b), that is followed by no de.nitions of a or b on that path. \nWe can use a universal query with pattern * exp(x,op,y)(\u00ac(def(x)|def(y))) * . This query returns all \npairs (v, .) such that at program point v, expression .(x) .(op) .(y) is available. Constant folding. \nA variable a at a program point v has a constant value k if, on every path from the program entry point \nto v, there is a de.nition of a to the constant k, represented using label def(a,k) instead of def(a), \nfollowed by no de.nitions of a.Any use of a on outgoing edges of v can be replaced by k. We can use a \nuniversal query with pattern * def(x,c)(\u00ac(def(x)|def(x, ))) * . It returns all pairs (v, .) such that \nat program point v, variable .(x)has constant value .(c) following any possible path from the entry point. \nFiles. Operations in typical .le I/O libraries, represented using labels of the forms open(f), close(f),and \naccess(f) for .le f, must be used following certain sequencing con\u00adstraints. In particular, a .le must \nbe open at the time it is accessed, and open .les must be subsequently closed. To detect respective violations, \nwe can use an existential query with pattern (E| * close(f))(\u00acopen(f)) * access(f), where E matches the \nempty string, and a backward exis\u00adtential query with pattern (\u00acclose(f)) * open(f).Other properties, \nsuch as that a .le must be open at the time close is called on it and that a .le is possibly used after \nit is opened, can also be easily expressed in our framework. Freed memory. It is an error to free or \ndereference mem\u00adory that has already been freed. Consider program graphs with labels of the forms malloc(p), \nfree(p) and deref(p), for allocating, freeing, and dereferencing pointer p,respec\u00adtively. To .nd these \nerrors, we can use the existential query with pattern * free(p)(\u00acmalloc(p)) * (free(p)|deref(p)). It \nreturns all pairs (v, .) such that at program point v, pointer .(p) has just been freed or dereferenced \nand, ear\u00adlier along some path to v, it was freed without subsequently being assigned fresh memory. Interrupts. \nTo manipulate the interrupt level properly, operating system code typically follows a strict discipline. \nIn particular, a procedure should save the original interrupt level in a variable, say flag,(represented \nas save(flag)) before changing it (represented as change()) and should restore the interrupt level from \nflag (represented as re\u00adstore(flag)) before terminating. Such constraints are sim\u00adilar to those for .le \nI/O and can easily be expressed in our framework. For example, assuming there is an edge labeled exit() \nat the end of each procedure, the existential query with pattern * save(x)change()(\u00acrestore(x)) * exit() \nre\u00adports violations of the rule that a procedure that saved and changed the interrupt level must subsequently \nrestore it. Security. In UNIX, to ensure proper access control, a program executed with superuser privilege \nshould close all open .les before changing its e.ective user id to that of a non-superuser (by calling \nseteuid with a non-zero argu\u00adment, represented as seteuid(\u00ac0)). To detect violations of this rule, we \ncan use an existential query with pattern * open(f)(\u00acclose(f)) * seteuid(\u00ac0). This returns all pairs \n(v, .) such that at v,.le .(f) is still open on some path and seteuid has just been called with a non-zero \nargument. Locking discipline. Many concurrent programs follow a synchronization discipline in which shared \nvariables are pro\u00adtected by non-reentrant locks. A variable a is protected by a lock l if a is accessed \n(represented as access(a)) only when l is held, i.e., a is not accessed outside a duration where l is \nacquired (represented as acq(l)) and not subsequently released (represented as rel(l)). We can use a \nuniversal query with pattern ((\u00acaccess(x)) * acq(l)(\u00acrel(l)) * ) * .It returns all pairs (v, .) such \nthat variable .(x)isprotected by lock .(l)onall pathsto v. Each substitution associated with the program \nexit point gives a variable that is globally protected by a lock. Correct use of locks is also subject \nto sequencing constraints, for example, only a held lock can be released; these constraints can easily \nbe expressed in our framework. Deadlock avoidance. A classic strategy for deadlock avoidance is to introduce \na partial order . on locks, and ac\u00adquire locks in that order, i.e., a process or thread that holds a \nlock l1 can only acquire a lock l2 if l1 . l2. Assuming locks are non-reentrant, to .nd pairs of locks \nsuch that one is held while the other is acquired on some path, we can use an exis\u00adtential query with \npattern * acq(l1)(\u00acrel(l1)) * acq(l2) * . It returns all pairs (v, .) such that, on some path to v, .(l2) \nis acquired while .(l1) is held. Examination of all substitu\u00adtions associated with the program exit point \neasily reveals whether locks are acquired consistent with some partial or\u00adder .. Some of these properties, \nsuch as .le I/O and freed mem\u00adory, are a.ected by equalities between program variables, such as aliasing \nof .le pointers. Our current implementation takes into account equalities caused by passing parameters \nand return values. We plan to extend it to track additional equalities, as discussed in Section 5. 2.3 \nModel checking examples Many model-checking problems can be expressed as para\u00admetric regular path queries. \nWe consider a few representa\u00adtive model-checking problems for labeled transition systems (LTSs). An LTS \nis a .nite graph, together with a distin\u00adguished starting vertex v0, in which each edge is labeled with \nact(a) for some action a, and each vertex corresponds to a unique state. We transform LTSs to make the \nvertices (i.e., states) explicit in the edge labels. The transformation to produce graphs suitable for \nexistential queries augments each vertex v with an edge from v to v labeled state(v). The transformation \nto produce a graph suitable for univer\u00adsal queries replaces each vertex v with two vertices vin and vout \nconnected by an edge with label state(v), and incom\u00ading and outgoing edges of v are re-directed to vin \nand vout , respectively. In the rest of this subsection, we consider the resulting graphs. Deadlock. \nAn LTS has a deadlock if it contains a vertex (i.e., a state) that is reachable from v0and hasnooutgoing \nedges. To .nd vertices that have outgoing edges, we use an existential query with pattern * state(s)act(). \nIt returns all pairs (v, .) such that state .(s), i.e., vertex .(s), is reach\u00adable from v0 and is followed \nby some action just before v.If every reachable vertex appears in some substitution in the result, then \nevery reachable vertex has an outgoing edge, and the LTS contains no deadlock. Livelock. An LTS has a \nlivelock if it has a reachable cycle that contains only the invisible action i. To .nd paths that end \nwith such cycles, we can use an existential query with pattern * state(s)act(i)+state(s). It returns \nall pairs (v, .),where v is also .(s), such that vertex v is reachable from v0 and is on a cycle of invisible \nactions. The LTS contains a livelock i. the result of the query is non-empty. 2.4 Notation We consider \na graph to be a set G of labeled edges of the form (v1,el, v2), with source and target vertices v1 and \nv2 respectively and edge label el. A speci.c vertex v0in G is given as the starting vertex. We will convert \npatterns to .nite automata. An automaton is a set P of labeled transitions of the form (s1,tl, s2), with \nsource and target states s1 and s2 respectively and transition label tl; a start state s0; and a set \nF of .nal states. Given an edge label el and a transition label tl, let match(tl, el), which takes a \nset of symbols as an implicit argument, be the set of minimal substitutions . such that el matches tl \nunder .. The resulting set has at most one element when tl contains no negations but can be very large \notherwise. For example, match(use(a),\u00acuse(x))isthe set of substitutions of the form {x . b},where b is \nany symbol other than a. Given a set S of substitutions, merge(S)is (1) badsubst if any two substitutions \nin S disagree on the mapping of any variable in the intersection of their domains and (2) the union of \nthe substitutions in S otherwise. We sometimes write merge({.1,.2})as merge(.1,.2). Our complexity analysis \nuses the notation in Figure 2.  3. SOLVING EXISTENTIAL QUERIES For existential queries, we convert a \nparametric regular\u00adexpression pattern straightforwardly to an NFA (nondeter\u00administic .nite automaton) \nof the same size. The existential query problem is: given G, v0, P, s0, and F, compute all pairs (v, \n.) such that there is some path from v0tovertex v that matches some path from s0 to some state in F under \nsubstitution .. Explicit computation of matching informa\u00adtion for individual graph paths would be too \nexpensive, so we instead compute matching information for reachable ver\u00adtices. Let reach(G, P, v0,s0), \ncalled the reach set,be the set of triples (v, s, .) such that some path from v0to v in G matches some \npath from s0to s in P under substitution .. Name Meaning verts number of vertices in G states number \nof states in P symbs number of symbols in G that parameters in P can be instantiated to pars number of \nparameters in P substs 1 (for badsubst) plus the number of substitu\u00ad tions that match some path from \nv0in G with some path from s0in P ;this is O(symbspars ) labelsize maximum size of a single edge label \nin G or transition label in P edgelabels number of distinct edge labels in G translabels number of distinct \ntransition labels in P labelpars maximum number of parameters in a transi\u00ad tion label of P Figure 2: \nNotation for complexity analysis. Then the existential query is to compute {(v, .)|.s .F : (v, ., s). \nreach(G, P, v0,s0)} (1) Basic algorithm. It is easy to see that the following rules hold for computing \nreach(G, P, v0,s0): (i) if (v0,el, v). G and (s0,tl, s). P and . . match(tl, el), then (v, s, .). reach(G, \nP, v0,s0). (ii) if (v, s, .). reach(G, P, v0,s0) and (v, el, v1). G and (s, tl, s1). P and .1 . match(tl, \nel)and .2 = merge(., .1) .= badsubst, then (v1,s1,.2). reach(G, P, v0,s0).  We can compute reach(G, \nP, v0,s0) by repeatedly adding triples according to the two rules, and compute the query result according \nto (1). This leads to the following basic algorithm, where R is the set of triples already considered \nfor the reach set, W is the worklist of triples yet to consider, and E is the result of the existential \nquery: R := {}; //initialize reach set W := {}; //initialize worklist for (v0,el, v) in G // based on \nrule (i) for (s0,tl, s) in P for . in match(tl, el) W := W .{(v, s, .)}; E := {}; //initialize query \nresult while exists (v, s, .) in W//take from worklist R := R .{(v, s, .)}; //add to reach set W := \nW -{(v, s, .)}; //update worklist (2) for (v, el, v1) in G // based on rule (ii) for (s, tl, s1) in \nP for .1 in match(tl, el) if .2 = merge(., .1)=.badsubst if (v1,s1,.2) .. R W := W .{(v1,s1,.2)}; if \ns . F //update query result E := E .{(v, .)}; When transition labels contain no negations or wildcards, \nthere is at most one element in the result of match,and match and merge can be computed easily by scanning \nthe argument labels and substitutions, respectively; how to han\u00addle negations and wildcards are described \nbelow. We use adjacency list representations for G and P .We can use nested arrays, hash tables, or combinations \nof them for R and W , as well as for E. We use natural numbers, called keys, to represent vertices, states, \nsymbols, parameters, and substitutions. Substitutions are represented as arrays that map parameters to \nsymbols. We maintain an array of substi\u00adtutions, indexed by the key for substitutions. Substitutions \nare created dynamically, so we use the standard technique of doubling the size of the array when the \narray is full; this does not increase the worse-case asymptotic time and space complexities. When a substitution \nis constructed, we add it to this array if it is not already present; to e.ciently check whether it is \npresent, we can maintain a nested array struc\u00adture representing all previously constructed substitutions, \nor we canuse ahashtable. This algorithm has worst-case running time O(|G|\u00d7|P |\u00d7substs \u00d7 (labelsize + \npars)), since it considers each triple (v, s, .) in W and R, iterates over all outgoing edges of v and \noutgoing transitions of s, and computes a match and possibly a merge taking time O(labelsize)and O(pars), \nre\u00adspectively, in each iteration. The factor substs instead of symbspars is used because only substitutions \nthat are the third component of a triple in W and R, i.e., that match some path from v0in G with some \npath from s0in P ,are considered. The algorithm takes O(|G|+|P |+verts\u00d7states\u00d7 symbspars + pars \u00d7symbspars \n) space, when nested arrays are used for R and W ,and O(|G|+|P |+verts \u00d7states \u00d7substs + pars \u00d7symbspars \n) space if hashing is used for at least the last component of R and W ; the four summands are for P , \nG, R and W ,and substs, respectively. Memoization and precomputation. It is easy to see that for a pair \nof el and tl that come out of vertex v and state s, respectively, match(tl, el) may be computed multiple \ntimes. We may save and reuse the results of match in an auxiliary map, Ms, called substitution map, that \nmaps a pair (el, tl)to the resulting substitution. We initialize Ms to {} imme\u00addiately after R is initialized \nto {}, and replace each call to match with a lookup in Ms, returning the result if found and otherwise \ncomputing match, adding the result to Ms,and returning it. To support e.cient operations on Ms,we map \nedge labels and transition labels, respectively, into natural\u00adnumber keys. We represent the map as an \narray indexed by the keys for edge labels, where each array element is an ar\u00adray indexed by the keys \nfor the transition labels and whose elements are keys of substitutions. This memoization reduces the \ntotal cost of computing all match s to O(|G|\u00d7|P |\u00d7 labelsize), and reduces the time complexity of the \nalgorithm to O(|G|\u00d7|P |\u00d7 labelsize + |G|\u00d7|P |\u00d7substs \u00d7pars). The space usage is increased by O(edgelabels \n\u00d7translabels) for the substitution map. One may further notice that for each pair of vertex v and state \ns, the same set of substitutions that match outgoing edges of v and outgoing transitions of s is computed \nre\u00adpeatedly for di.erent substitutions . such that (v, s, .) is taken from W . Indeed, we may precompute \nan auxiliary map, Mts, called target-and-substitution map,that maps a pair (v, s) to the set of triples \n(v1,s1,.1) such that there is (v, el, v1) in G and (s, tl, s1) in P and match(tl, el)= .1. This yields \nthe following pseudo-code, in place of initializa\u00adtion of worklist in (2), that computes Mts as well, \nwhere Rts and Wts are needed for computing Mts, W := {}; //initialize W as in Rts := {}; // (2), except \nthat Wts := {}; // Rts, Wts,and Mts Mts := {}; // are initialized for (v0,el, v) in G // together with \nW for (s0,tl, s) in P for . in match(tl, el) W := W .{(v, s, .)}; Wts := Wts .{(v, s)}; Mts := Mts .{(v0,s0,v,s,.)}; \n(3) while exists (v, s) in Wts //compute Mts,with Rts := Rts .{(v, s)}; // help of Rts and Wts, Wts := \nWts -{(v, s)}; // as for computing W for (v, el, v1) in G // but w/o 3rd compo for (s, tl, s1) in P \n// -nent or call to merge for . in match(tl, el) if (v1,s1)..Rts Wts := Wts .{(v1,s1)}; Mts := Mts .{(v, \ns, v1,s1,.)}; and the following simpli.ed update, in place of update of worklist in (2), that uses the \nprecomputed map Mts: W := W -{(v, s, .)}; //update W ,as for (v, s, v1,s1,.1) in Mts // in (2), except \nif .2 = merge(., .1) .= badsubst // that only Mts (4) if (v1,s1,.2)..R // is needed W := W .{(v1,s1,.2)}; \nThis precomputation avoids enumerating all outgoing edges of v and outgoing transitions of s repeatedly, \nbut enu\u00admerates only target vertices and states led to by successful substitutions in Mts. This may improve \nthe running time over memoizing only results of match, though not asymp\u00adtotically, to O(|G|\u00d7|P |\u00d7labelsize \n+ |Mts|\u00d7substs \u00d7pars), where Mts is O(|G|\u00d7|P |) but could be much smaller. The additional space used \nis O(|G|\u00d7|P |). Negations and wildcards. Wildcards in transition labels are easy to handle: we only need \nto extend match to make any edge label match a wildcard under the empty substi\u00adtution. Negations, if \nsurrounding only parameters that are already bound earlier in the pattern and thus earlier on the paths, \ncan also be handled easily in the main loop of the ba\u00adsic algorithm (2): we simply modify match(tl, el)tocheck \nwhether el matches tl under . by de.nition, and to return {{}} if so and {} otherwise. This is actually \na degenerate case of our general method for handling negations, described below. One might think of treating \nnegations as alternations when converting a pattern to an automata, and then using the above algorithms; \nfor example, replace \u00acdef(a) with an al\u00adternation containing all other edge labels in G.However, this \nmethod is typically very ine.cient, and it is not appli\u00adcable when there is a parameter to a negated \nconstructor, as in \u00acdef(x). Another ine.cient approach is to naively compute match and consider all resulting \nsubstitutions. This increases the time to compute match from O(labelsize)to O(symbslabelpars O(symbslabelpars \n\u00d7labelsize)and resultsin ) substitutions. This signi.cantly increases the overall complexity. Our method \nis to modify match together with merge so that, overall, we consider only substitutions that actually \nmatch some path in G with some path in P , not enumerat\u00ading other substitutions. Observe that, in the \nbasic algorithm (2), the result of match(tl, el)isusedasanargumentto merge. So instead of computing and \nconsidering all substi\u00adtutions from the result of match(tl, el) and then computing merge for each, we \nconsider only substitutions that are ex\u00adtensions of the other argument . to merge that cover the parameters \nin tl, denoted extensions(., tl), and we simply check whether el matches tl under each of the extensions. \nThat is, we change the two lines in (2) consisting of the last for-clause and the .rst if -clause to \nfor .2 in extensions(., tl) if match(.2(tl),el) . = {} In general, the worst-case time complexity is \nO(|G|\u00d7|P |\u00d7 min(substs\u00d7symbslabelpars , symbspars \u00d7(pars-1)!)\u00d7labelsize), where labelsize is for checking \na match; in the left argu\u00adment of min, substs is the number of all . s considered, and symbslabelpars \nbounds the number of extensions of a .;in the right argument of min, symbspars bounds the number of all \nsubstitutions of all parameters, and each substitution is considered at most (pars -1)! times. The factorial \nfac\u00adtor is because each substitution for n parameters may be considered 2n times as an extension of a \nsubstitution for a subset of the n parameters, and 2pars +(pars -1)2pars-1 + (pars -1)(pars -2)2pars-2 \n+ ... = O((pars -1)!). The space complexity is the same as for the basic algorithm. Two drawbacks of \nthis algorithm are its higher complex\u00adity and that it prevents memoization and precomputation. We remedy \nthis for the usual case where each transition la\u00adbel contains at most one negation: we proceed as before \nfor the basic algorithm and for memoization and precom\u00adputation except for two changes. First, when matching \nan edge label with a transition label that contains negation, we record successful bindings for parameters \noutside and inside the negation separately, and call them agree and dis\u00adagree, respectively, if the bindings \nare consistent and where redundant bindings in disagree are removed. For example, match(def(x,\u00acc), def(a,5)) \nreturns a set containing a sin\u00adgle element that is a pair of {x .a} as agree and {c .5}as disagree. Second, \nwe change the if -clause that contains merge(., .1), where .1 is now a pair of agree and disagree,to \niterate over extensions of merge(., agree) that cover param\u00adeters in disagree and check if the extension \ndisagrees with some bindings in disagree. That is, we change the single line if .2 = merge(., .1)=.badsubst \nin (2) and (4) to if .1 = merge(., agree)=.badsubst for .2 in extensions(.1, disagree) if merge(.2, disagree)= \nbadsubst This reduces the time complexity to the same as that for the basic algorithm, for memoization, \nand for precomputa\u00adtion, respectively, except with the factor substs replaced by substs \u00d72labelpars . \nTo see the reasons for this factor, let sa and sd denote the sets of parameters in agree and disagree, \nrespectively. Wehave(1) thetest merge(.2, disagree)= badsubst succeeds for all .2 s enumerated except \nthe one that agrees with all in disagree, and thus all .2 s considered except for one will become the \nthird component of a triple put into W and R, which contributes to the factor substs,(2) .x a .2,there \nare O(2|sd|) possible .1 s for which .2 extends .1 and covers sd, because in .1 each parameter in sd \nhas two choices it maps to either nothing or what .2 maps to, (3) similarly, .x a .1,there are O(2|sa|) \npossible . s for which .1 extends . and covers sa,and (4) |sa|+ |sd| = O(labelpars). Thus, compared to \nthe algorithms for without negations, the overall complexity is increased by at most a factor of O(2labelpars \n). Since labelpars is a small constant in our appli\u00adcations, the asymptotic time complexity remains the \nsame. The space complexity is the same as that for the basic al\u00adgorithm, for memoization, and for precomputation, \nrespec\u00adtively. 4. SOLVING UNIVERSAL QUERIES For universal queries, our basic algorithm requires a de\u00adterminism \ncondition, described below, so we .rst convert the parametric regular-expression pattern to a DFA (deter\u00administic \n.nite automaton), also denoted by P ,which can be exponentially larger in the worst case, but the size \nof the pattern is small in practice. However, an automaton that appears deterministic might become nondeterministic \nunder some substitutions. For example, if a state has out\u00adgoing transitions labeled use(x) and use(y),then \nuse(a) matches both labels under substitution {x . a,y . a}. Our algorithms handle this. The universal \nquery problem is: given G, v0, P , s0, and F , compute all pairs (v, .) such that every path from v0to \nvertex v matches some path from s0 to some state in F under substitution .. Again, for e.ciency, we compute \nmatching information for reachable vertices, not individual paths. To maintain only matches for reachable \nvertices v and be able to conclude about matches for all paths to v, we require that for each path from \nv0to v in G,all pathsin P that match it (under any substitutions) pass through the same set of states \nand match it under the same substitution. We call this the determinism condition. Then we check that \nfor all paths from v0to v in G, the matching paths in P all end in states in F and that the substitutions \nfor these matchings all agree with each other. Our basic algorithm conserva\u00adtively checks the determinism \ncondition while it proceeds; we describe separately below how to handle the case when the determinism \ncheck fails. We extend the de.nition of reach(G, P, v0,s0) to include triples (v, badstate, badsubst) \nwhen there is a path from v0 to v in G that does not match any path from s0toany state in P under any \nsubstitution. Then the universal query is to compute all pairs (v, .) such that for all (v, s, .1) in \nthe extended reach(G, P, v0,s0), s is in F ,and . is the successful merge of all .1 s, i.e., {(v, .)| \n(.(v, s, .1).reach(G, P, v0,s0) : s.F ) . . = merge({.1 : (v, s, .1).reach(G, P, v0,s0)}) (5) = badsubst} \nBasic algorithm. It is easy to see that rules (i) and (ii) and the following two rules hold for computing \nthe extended reach(G, P, v0,s0): (iii) if (v0,el, v). G and .(s0,tl, s).P : match(tl, el)= {}, then (v, \nbadstate, badsubst). reach(G, P, v0,s0). (iv) if (v, s, .). reach(G, P, v0,s0) and (v, el, v1). G and \n.(s, tl, s1).P : ..1 .match(tl, el): merge(., .1)= badsubst, then (v1, badstate, badsubst). reach(G, \nP, v0,s0). We can compute the extended reach(G, P, v0,s0) by repeat\u00adedly adding triples of vertex, matching \nstate, and matching substitution according to all four rules. Then we do two things to compute the query \nresult according to (5): main\u00adtain a bit for each vertex indicating whether all matching states belong \nto F , and merge all matching substitutions. We obtain the following basic algorithm, where R and W are \nas for existential queries, matchpair tracks the current matching state and substitution, T maps each \nvertex to the bit indicating whether all matching states are .nal, and U is the result of the universal \nquery, represented as a map from each vertex to the corresponding substitution or badsubst: R := {}; \n//initialize reach set W := {}; //initialize worklist for (v0,el, v) in G // based on rules (i) matchpair \n:= null; // and (iii), and check for (s0,tl, s) in P // determinism for . in match(tl, el) if matchpair \n= null matchpair := (s, .); W := W .{(v, s, .)}; else // check determinism if matchpair . = (s, .); \nexit( determinism check failed ); if matchpair = null // use rule (iii) W := W .{(v, badstate, badsubst)}; \nT := {}; //init. test for match U := {}; //initialize query result while exists (v, s, .) in W //take \nfrom worklist R := R .{(v, s, .)}; //add to reach set W := W -{(v, s, .)}; //update worklist for (v, \nel, v1) in G // based on rules (ii) matchpair := mull; // and (iv), and check for (s, tl, s1) in P // \ndeterminism (6) for .1 in match(tl, el) if .2 = merge(., .1)=.badsubst if matchpair = null matchpair \n:= (s1,.2); if (v1,s1,.2) .. R W := W .{(v1,s1,.2)}; else // check determinism if matchpair . = (s1,.2) \nexit( determinism check failed ); if matchpair = null // use rule (iv) if (v1, badstate, badsubst) .. \nR W := W .{(v1, badstate, badsubst)}; if (T (v) is not de.ned) .T (v) //update test for match T (v):=(s \n. F ); if T (v) //update query result if U(v) is not de.ned U(v):= .; else U(v):= merge(U(v),.); //merge \nsubstitutions else U(v):= badsubst; Negations and wildcards can be handled in the same way as for existential \nqueries. We use the same data structures as for existential queries; the only di.erence is that T and \nU caneachberepresented as an additional .eld in the structure for each vertex. The time and space complexities \nare the same as for the basic algorithm for existential queries. Memoization and precomputation. We can \nmemoize the result of match as for existential queries and obtain the same time and space complexities \nas for the algorithm with mem\u00adoization for existential queries. There are also sets of repeated computations \nof match similar as for existential queries, except that matching infor\u00admation for each outgoing edge \n(v, el, v1)of v and each state s, rather than just each vertex v and state s, is needed, by the if -statement \nthat tests matched,thus the target\u00adand-substitution map is not su.cient. We may precompute an auxiliary \nmap, Mds, called determinism-and-substitution map, that maps an edge (v, el, v1,s) and state s to the \nset of pairs (s1,.1) such that there is (s, tl, s1) in P and match(tl, el)= .1. This yields pseudo-code \nsimilar to (3), except with operations on Mts replaced by operations on Mds, in place of initialization \nof worklist in (6); and sim\u00adpli.ed update code, similar to the simpli.cation from (2) to (4) except with \nthe additional tests and uses of matched and with the use of Mts replaced by a use of Mds,in place of \nupdate of worklist in (6). The time complexity is the same as for existential queries, except Mds is \nused in place of Mts. The space complexity is the same as for existential queries. Nondeterminism. When \nthe determinism condition does not hold, the algorithms above do not apply. We describe two solutions: \nan algorithm that enumerates all substitu\u00adtions, and a hybrid algorithm that .rst does an existential \nquery to reduce the number of substitutions considered. The enumeration algorithm considers all substitutions \nfrom some or all parameters in the pattern to symbols in the graph, and does a universal query without \nparameters for each substitution. That is, for each substitution, instantiate the pattern, convert the \ninstantiated pattern to a DFA, and use the algorithms described above. The total time complex\u00adity is \nO(|G|\u00d7maxT rans \u00d7symbspars ), where maxT rans is the maximum number of transitions in the DFA s for the \ninstantiated patterns, and symbspars is the number of substitutions. This is asymptotically better than \nthe algo\u00adrithm above, but enumerating all substitutions is expensive in practice. A clear advantage of \nthe enumeration algo\u00adrithm is that the space complexity is as small as O(|G|+ maxT rans + verts \u00d7maxStates \n+ verts \u00d7substs), where maxStates is the maximum number of states in the DFA s for the instantiated patterns, \nand the last summand is for the output size. The same is true if we use an enumeration algorithm for \nexistential queries. The hybrid algorithm re.nes the enumeration algorithm by .rst doing an existential \nquery with the same pattern and obtaining a set of substitutions from the result; these substitutions \nare those involved in matching on some paths. Then we enumerate all substitutions that are extensions \nto the substitutions obtained above, and do universal queries without parameters for each of them. This \nidea is also used in [6]. The asymptotic time complexity is the sum of those for the two steps, and the \nasymptotic space complexity is the same as for existential queries in the .rst step. 5. DISCUSSION We \ndiscuss several tradeo.s and extensions for the para\u00admetric regular path query framework. We also discuss \nim\u00adprovements in the complexity analysis and performance and in the query language and usage. 5.1 Tradeoffs \nand summary As in other analysis frameworks, there may be more than one way of formulating an analysis \nproblem using parametric regular path queries. There are many tradeo.s involving e.ciency, readability, \namount of information in the result, etc. Several distinct properties of this work allow users to eas\u00adily \ntest and compare the alternatives: queries can be written declaratively and succinctly; complete algorithms \nand data structures have been designed and implemented; precise run\u00adning time and space usage have been \nanalyzed, both in terms of asymptotic complexity and useful parameters in practice; and ways to automatically \nconvert queries to di.erent forms are being investigated. Consider the uninitialized variables examples \nin Section 2.2, where forward existential queries (\u00acdef(x)) * use(x) and (\u00ac(def(x)|use(x))) * use(x) \n.nd all uses and .rst uses, respectively, of uninitialized variables. These analyses can also be expressed \nas backward queries. To capture the uses, an additional parameter is used; speci.cally, use(x,l) de\u00adnotes \na use of variable x at, say, location l in the program. We add an edge from v0to v0 labeled entry(). \nThen the two backward queries are * use(x,l)(\u00acdef(x)) * entry() and * use(x,l)(\u00ac(def(x)|use(x, ))) * \nentry(), respectively. To .nd only names of uninitialized variables, we can use a backward query * use(x)(\u00acdef(x)) \n* entry().Compared with forward queries, the .rst two backward queries have a factor O(symbs2), rather \nthan O(symbs), in asymptotic time because of the extra parameter, but they run much faster be\u00adcause x \nis bound by use(x, l) before the negation \u00acdef(x), and a single l is paired with a use of x in use(x, \nl). The forward queries start with negation \u00acdef(x), and x ends up being enumerated for all possible \ninstantiations. We summarize several of the most important points based on our experience; they hold \nfor all examples we have en\u00adcountered: queries can be written clearly and succinctly; patterns always \ncontain wildcards or negations; individual edge labels contain at most one negation;  patterns contain \na small number of independent pa\u00adrameters; additional parameters can be used easily to capture additional \ninformation;  existential queries are used much more often than uni\u00adversal queries; when both kinds \ncan be used, the ex\u00adistential query is easier to write and understand than the universal query;  forward \nand backward queries can be converted to each other by introducing additional parameters, but re\u00adversing \nthe order of binding of parameters may signif\u00adicantly a.ect performance;  existential queries are much \neasier to process and more e.cient than universal queries; queries that bind pa\u00adrameters positively before \nnegations are much faster than queries that don t;  memoization and precomputation reduce asymptotic \ntime complexity, but can sometimes be slower in prac\u00adtice, and use much additional space.  5.2 Extensions \nTo further enhance the expressive power of parametric regular path queries, the framework can be extended \nto take into account more general relationships, as discussed below. Tracking equality and points-to \ninformation. Simple equality relationships are already captured through multiple occurrences of a parameter, \nbut additional equality relation\u00adships can be important. For example, one could (although it is unlikely) \nopen a .le and assign it to f , subsequently assign f to g, and then close the .le through g. If the \nanal\u00adysis does not consider the equality between f and g,itmay report false alarms for example, that \nf is not closed after it was opened or miss errors. To solve such equality problems, we may use the same \nquery and employ a separate module to track equalities. For example, Field et al. [8] study how to check \nprogram properties speci.ed using regular expressions with one-level pointers. We can extend parametric \nregular path queries to express and check such properties as well. An open prob\u00adlem is precise time and \nspace complexity analysis for the extended frameworks. Interprocedural analysis. For interprocedural \nprogram analysis, equalities relating arguments in calls and parame\u00adters in procedure de.nitions, and \nrelating return values in procedure de.nitions and return values of calls, need to be captured. We have \nextended the framework of parametric regular path queries for interprocedural analysis by explic\u00aditly \ntracking these two kinds of equalities. An advantage of this approach is that the query pattern can remain \nun\u00adchanged, and the equalities are tracked implicitly. We could make this interprocedural analysis more \nprecise by using context free grammars to restrict the algorithm to consider only valid interprocedural \npaths [14]. 5.3 Complexity analysis and performance For a given user query and query algorithm, our \ncom\u00adplexity analysis result corresponds to a formula that gives the worst-case asymptotic running time \nand space usage for evaluating the query. However, the value of substs in the formula depends on the \ninput and is bounded only by O(symbspars ). A natural re.nement is to use the sizes of the domains of \nparameters, such as the number of program vari\u00adables for parameter x in def(x), in place of symbs,which \ncounts all symbols in the program graph. Also, correlations between the parameters, such as that there \nis a single pro\u00adgram location l associated with a use of x in use(x, l), can be used to further re.ne \nthe estimated complexity. Future work may provide even .ner complexity characterizations, especially \nfor the e.ect of negations, by exploiting additional domain knowledge about the input graph and the query. \nConsidering that our algorithms are generic and do not perform optimizations that exploit domain knowledge \n(al\u00adthough such knowledge can be built into the input graph and the query), the performance is quite \ngood. We can further improve the performance, especially the memory us\u00adage, by exploiting the connectivity \nof graphs. In particular, graph vertices can be visited in a topological order of the strongly connected \ncomponents (SCCs), and after a SCC is .nished, data structures containing information about that SCC \ncan be de-allocated. Also, one can exploit sparsity of relevant edge labels. In particular, since typically \nrelatively few di.erent kinds of edge labels in the graph are relevant to a query, the graph can be compacted \nby eliminating and col\u00adlapsing certain edges and vertices before solving the query. Detailed study is \nneeded for these, especially for taking do\u00admain knowledge into account. 5.4 Query language and usage \nParametric regular path queries studied thus far can use only single labels on edges, which is why, for \nprogram anal\u00adysis problems, we need to use a kind of dual of control .ow graphs and, for model checking \nproblems, we need to transform labeled transition systems to capture the vertices (states) through edge \nlabels. Also, queries do not exploit the values of parameters besides checking equality. Finally, parametric \nregular path queries can not express analyses that involve non-regular language based patterns, such \nas analysis of matching acquire and release operations for reen\u00adtrant locks, which is equivalent to matching \nparentheses and therefore needs context-free language based patterns. We are currently extending the \nframework so queries can use also vertices and vertex labels directly, including mul\u00adtiple labels for \neach vertex and edge, and can do computa\u00adtions involving the values of parameters. This will lead to \na very powerful query language that generalizes XPath [20] by supporting unbounded repeating patterns \non paths (via the general Kleene star), not just unbounded skipping of path segments, and by allowing \nquerying of graphs, not just trees. Extending the framework to use context-free language based patterns \nis a problem open for study. To facilitate usage of the framework, we are also studying methods that \nsupport easier construction of e.cient queries. In particular, for certain kinds of problems, we can \nlet the user specify a universal property and automatically generate existential queries for checking \ndi.erent kinds of violations, as well as a merged automata for checking all kinds of vi\u00adolations at the \nsame time. For example, instead of having to write several separate queries for .le operations, the user \nmay simply specify that on every path from the entry point to exit point, operations on a .le f must \nfollow the pattern (open(f)(access(f)) * close(f)) * , allowing other opera\u00adtions to occur anywhere. \n  6. IMPLEMENTATION AND EXPERIMENTS Our tool is divided into front-ends, which take an input and convert \nit into an edge-labeled graph, and back-ends, which take that graph and an automaton, apply the para\u00admetric \nregular path query, and output the result. We have multiple front-ends. One reads C programs and creates \nintraprocedural control .ow graphs labeled with def and use, as in Section 2. The generated control .ow \ngraph may optionally include a sequence number with each use,al\u00adlowing the generated graph to be used \nfor forward and back\u00adward uninitialized use analysis. This front-end was imple\u00admented using CodeSurfer \nand consists of 682 lines of Scheme. Another front-end reads transition systems taken from the Very Large \nTransition Systems web site (http://www. inrialpes.fr/vasy/cadp/resources/benchmark_bcg.html). These \ntransition systems were produced automatically from formal descriptions of real-life concurrent systems, \nand are suitable for use as input to model checking algorithms. By exploiting existing tools, we were \nable to implement this front-end with less than a hundred lines of new code. input LOC graph edges result \nsize basic worklist time precomputation worklist time enumeration worklist time substs cksum sum expand \nuniq cut C-parser iburg struct ratfor 236 198 317 406 603 1,847 649 1,699 1,261 521 714 971 1,696 2,124 \n4,260 5,672 6,022 7,617 20 23 46 147 92 97 93 128 369 3,749 0.01s 3,620 0.01s 7,650 0.03s 33,657 0.13s \n37,878 0.15s 60,621 0.24s 87,606 0.36s 148,609 0.61s 191,809 0.82s 3,749 0.00s 3,620 0.01s 7,650 0.02s \n33,657 0.07s 37,878 0.07s 60,621 0.13s 87,606 0.19s 148,609 0.31s 191,809 0.42s 10,573 0.04s 40 22,551 \n0.07s 57 40,746 0.14s 75 127,393 0.47s 134 181,252 0.67s 146 447,995 1.72s 207 1,206,845 4.57s 377 1,101,780 \n4.34s 333 1,405,965 5.48s 361 Table 1: Algorithm performance for the detection of uninitialized variable \nuses. input states graph edges result size basic worklist time precomputation worklist time enumeration \nworklist time substs vasy-0-1 cwi-1-2 vasy-1-4 vasy-5-9 cwi-3-14 vasy-8-24 vasy-8-38 vasy-10-56 289 1,952 \n1,183 5,486 3,996 8,879 8,921 10,849 1,513 4,339 5,647 14,878 18,548 33,290 47,345 67,005 1,224 2,387 \n4,464 9,392 14,552 24,411 38,424 56,156 1,802 0.01s 6,291 0.04s 6,830 0.05s 20,364 0.13s 22,544 0.15s \n42,169 0.32s 56,266 0.40s 77,854 0.60s 1,802 0.01s 6,291 0.05s 6,830 0.05s 20,364 0.16s 22,544 0.18s \n42,169 0.35s 56,266 0.43s 77,854 0.60s 85,034 0.87s 3,814,643 26.83s 1,405,136 15.72s n/d n/d n/d n/d \nn/d n/d n/d n/d n/d n/d 289 1,952 1,183 5,486 3,996 8,879 8,921 10,849 Table 2: Algorithm performance \nfor the detection of transition system deadlocks. n/d means that the analysis was not completed in a \n180 second time limit. While the data discussed in this section is generated by the two front-ends described \nabove, we also have others, which support interprocedural .le operation analysis for C and def-use analysis \nfor Python. We are able to use the same automaton to perform uninitialized use analysis for C and Python. \nWe also have multiple back-ends corresponding to di.er\u00adent variants of the algorithms given above. All \nback-ends are written in a high-level language similar to the pseudo code given in Sections 3 and 4, \nwhich is translated to C++ by a Python program. The translator takes care of imple\u00admentation details \nsuch as data structure selection [15] and multiset discrimination [3]. One of the bene.ts of using a \ntranslator to generate the C++ code is that we can eas\u00adily experiment with changes in precomputation \nand data structure representation. The high-level source .les for the variants range from 50 to 118 lines, \nand each is translated into over a thousand lines of C++. To illustrate the performance of the algorithms, \nwe .rst present running times for the algorithms as applied to pro\u00adgram analysis. Table 1 gives performance \ninformation for detecting all uses of uninitialized variables in C programs. All timings are recorded \non a Pentium 4 running at 2.0 GHz. The enumeration variant was used for the forward query given in Section \n2.2, while the basic and precompu\u00adtation variants were used for the backward query given in Section 5.1. \nThe size of the result set is the number of pos\u00adsibly uninitialized uses found in each program. Table \n2 summarizes the performance for deadlock detec\u00adtion on a transition graph. The query is given in Section \n2.3. It is a forward query that contains no negation of unbound variables, and all three variants were \nused for it. The .rst .nding supported by these experiments is that enumeration is slower than the other \ntwo variants of the algorithms. The early introduction of substitutions forces the total amount of work \nto scale with both the size of the graph and the number of substitutions. This can lead to quadratic \nbehavior where other variants are linear. A second .nding is that the performance increase provided by \nprecomputation is highly dependent on the precise con\u00adstruction of the graph and automaton. In the uninitialized \nuses analysis, precomputation roughly halves the running time of the program, while in deadlock analysis, \nprecompu\u00adtation does not provide a consistent bene.t. In the dead\u00adlock analysis, the main worklist contains \nonly a small num\u00adber of triples per vertex, and the graph and the automaton have small out-degree. These \nfactors conspire to keep the improvement o.ered by precomputation small, or in some cases, negative. \nThe larger number of worklist triples en\u00adcountered in the uninitialized uses analysis allows the cost \nof precomputation to be amortized, leading to a signi.cant speedup. The core of our algorithms involves \noperations on sets and maps, so the design of these data structures strongly a.ects the memory usage \nand running time. We tried several variants before settling on the two best. Both are derived from the \nbased representations in [15], but di.er in how tuples are represented in sets. When a set is queried \nfor elements matching one or more keys, both representations use the .rst key to .nd a unique base containing \ninformation about set membership. This base may need to be indexed by a second or later key to determine \nset membership. This indexing can be performed by using a level of nested arrays for each additional \nkey, or lookup in a hash table of all the additional keys. A variant using hashing without basing was \nalso tried, but was rejected as inferior in both space and time usage. Table 3 shows how these representations \nprovide di.er\u00adent time and space tradeo.s. Using nested arrays is fastest only when enumerationisused, \nanditusesalargeamount basic precomputation enumeration hashing nested hashing nested hashing nested \ninput mem time mem time mem time mem time cksum 324k 0.02s 23k 0.04s 22k 0.03s sum 461k 0.02s 197k \n0.01s 582k 0.01s 32k 0.07s 31k 0.07s expand 1,118k 0.03s 359k 0.02s 1,172k 0.02s 43k 0.14s 44k 0.12s \nuniq 1,294k 0.13s 4,292k 0.13s 1,370k 0.07s 4,303k 0.07s 75k 0.47s 91k 0.43s cut 1,429k 0.15s 6,135k \n0.16s 1,531k 0.07s 5,639k 0.09s 90k 0.67s 83k 0.63s C-parser 2,300k 0.24s 16,521k 0.29s 2,486k 0.13s \n15,730k 0.14s 163k 1.72s 162k 1.57s struct 5,540k 0.61s 36,921k 0.66s 5,989k 0.31s 38,191k 0.35s 233k \n4.34s 247k 4.05s ratfor 7,201k 0.82s 70,949k 0.94s 7,831k 0.42s 65,196k 0.48s 215k 5.48s 272k 5.31s \n Table 3: Time and memory usage for hashing and nested array implementations of uninitialized uses. \nFigure 3: Worklist size and running time, respec\u00adtively, versus graph size, for uninitialized variables \nand uses. of space to represent sparse sets, such as the target-and\u00adsubstitution map. If a set is very \nsparse, the cost to ini\u00adtialize the memory may outweigh the savings from eliminat\u00ading hashing. The space \nusage of hashing is less than that of nested arrays, and the running time is similar, gener\u00adally making \na based hash representation (the second option above) the best, when it .ts into memory. Table 3 also \nshows that an advantage of using enumeration is that the memory usage is much smaller than the other \ntwo variants, at the cost of much larger running time. The running time of the algorithms is a.ected \nby the size and composition of the graph and automaton. Figure 3 plots the size of (i.e., total number \nof elements inserted in) the worklist and the running time of the basic algorithm against the size of \nthe program. Both plots look identical, providing another strong indication that, on practical graphs, \nrunning time is strongly tied to worklist size. In practice, the size of this worklist appears to grow \nat a rate slightly greater than linear, with the precise amount of work done highly dependent on the \nactual input data.  7. RELATED WORK AND CONCLUSION Existential regular path queries without parameters \nhave been studied and used for querying databases and semi\u00adstructured data [21, 1], but parameters are \nessential for ex\u00adpressing correlations of information in di.erent parts of the data. For example, parameters \nare needed in querying sys\u00adtem logs for intrusion detection [16], and in many other ap\u00adplications that \nuse regular expression packages for matching strings, even though not graphs. Many interesting applica\u00adtions \nof regular path queries in program analysis and model checking require parameters, as shown by the examples \nin this paper. Engler et al. [10] demonstrated that program analyses ex\u00adpressed as state machines can \nbe very e.ective at .nding de\u00adfects in software. Global state machines and variable-speci.c state machines \nin their framework roughly correspond to ex\u00adistential regular path queries with zero parameters and one \nparameter (which gets bound to the associated variable), respectively; this is illustrated by the interrupts \nand freed memory examples in Section 2. ESP [5] and CQUAL [9] deal with a similar class of properties. \nThese projects focus on defect detection and veri.cation for C programs. In contrast to these and other \ndata.ow frameworks and type systems for analyzing program properties and ensuring program safety, our \nfocus is on a general graph analysis framework that can easily be applied to C programs, Python programs, \nXML data, labeled transition systems, etc., and that supports a precisely de.ned and more expressive \nquery language with negation, multiple parameters, and universal queries. de Moor et al. [6] showed that \nuniversal parametric reg\u00adular path queries are useful for compiler analysis and op\u00adtimizations. They \ngive a high-level algorithm for solving universal queries without parameters and describe an imple\u00admentation \nof it as a logic program. Liu and Yu [12] designed a complete algorithm with detailed data structures \nfor solv\u00ading universal queries without parameters. That algorithm requires the .nite automaton to be \ncomplete, which usu\u00adally means adding explicit transitions to a trap state; this can signi.cantly increase \nactual space usage. The algorithm in this paper handles incomplete automata directly, saving space. Drape \net al. [7] describe how to program univer\u00adsal parametric queries as logic programs but do not give a \ndirect algorithm for solving such queries. Sittampalam et al. [17] developed an incremental algorithm \nfor solving uni\u00adversal parametric queries on restricted graphs expressible as walks on trees; the algorithm \ncan be much faster than a batch algorithm for recomputation after a subtree replace\u00adment, but it has \na high overhead and worse complexity for batch analysis even for the restricted graphs it can handle. \nA major contribution of this paper is the .rst complete algorithms and data structures for directly and \ne.ciently solving existential and universal parametric regular path queries. Other major contributions \nof this paper compared to all of the work cited above are very detailed complexity analysis of the algorithms \nfor solving the queries, detailed performance comparison of variations of the algorithms and data structures, \nand investigation of e.ciency tradeo.s be\u00adtween di.erent formulations of a query. We have derived the \nbasic algorithms using a methodology based on formal speci.cation and transformation, which helps ensure \ncor\u00adrectness and supports precise complexity analysis. Due to space limitations, details of the derivations \nare not given in this paper. Reps et al. [14] showed how to perform precise interproce\u00addural data.ow \nanalysis by using graph reachability to elim\u00adinate infeasible interprocedural paths. This technique can \nbe incorporated into many program analysis frameworks, including ours. While their work focuses on identifying \nfea\u00adsible interprocedural paths, our work focuses on a simple and powerful language for expressing analyses \nand on the detailed design and complexity analysis of the analysis al\u00adgorithms. Parametric regular path \nqueries are not as powerful as some other analysis frameworks, such as set constraints [11, 2] and temporal \nlogic [18], but they are more perspicuous and convenient, and they are su.ciently powerful to express \nmany interesting properties in many application domains, and they can easily be used within more powerful \nframe\u00adworks when necessary. Parameters support correlation of information along paths. This is also the \nidea underlying trace-based program analysis [4], which uses powerful but heavy-weight symbolic execution \ntechniques. 8. REFERENCES [1] S. Abiteboul. Querying semi-structured data. In Proceedings of the International \nConference on Database Theory, pages 1 18, 1997. [2] A. Aiken. Introduction to set constraint-based program \nanalysis. Science of Computer Programming, 35(2-3):79 111, 1999. [3] J. Cai and R. Paige. Look Ma, no \nhashing, and no arrays either . In Conference Record of the 18th Annual ACM Symposium on Principles of \nProgramming Languages, pages 143 154, 1991. [4] C. Colby and P. Lee. Trace-based program analysis. In \nConference Record of the 23rd Annual ACM Symposium on Principles of Programming Languages, pages 195 \n207, 1996. [5] M. Das, S. Lerner, and M. Seigle. ESP: Path-sensitive program veri.cation in polynomial \ntime. In PLDI 2002 [13], pages 57 68. [6] O. de Moor, D. Lacey, and E. V. Wyk. Universal regular path \nqueries. Higher-Order and Symbolic Computation, 16(1-2), 2003. [7] S.Drape,O.deMoor, andG.Sittampalam. \nTransforming the .NET intermediate language using path logic programming. In Proceedings of the 4th International \nConference on Principles and Practice of Declarative Programming, Oct. 2002. [8] J. Field, D. Goyal, \nG. Ramalingam, and E. Yahav. Typestate veri.cation: Abstraction techniques and complexity results. In \nProceedings of the 10th International Static Analysis Symposium, volume 2694 of LNCS, pages 439 462. \nSpringer-Verlag, Berlin, 2003. [9] J. S. Foster, T. Terauchi, and A. Aiken. Flow-sensitive type quali.ers. \nIn PLDI 2002 [13]. [10] S. Hallem, B. Chelf, Y. Xie, and D. Engler. A system and language for building \nsystem-speci.c, static analyses. In PLDI 2002 [13]. [11] N. Heintze and J. Ja.ar. Set constraints and \nset-based analysis. In Proceedings of the 2nd International Workshop on Principles and Practice of Constraint \nProgramming, volume 874 of LNCS, pages 281 298. Springer-Verlag, Berlin, 1994. [12] Y. A. Liu and F. \nYu. Solving regular path queries. In Proceedings of the 6th International Conference on Mathematics of \nProgram Construction, volume 2386 of LNCS, pages 195 208. Springer-Verlag, Berlin, 2002. [13] Proceedings \nof the ACM SIGPLAN 02 Conference on Programming Language Design and Implementation, 2002. [14] T. Reps, \nS. Horwitz, and M. Sagiv. Precise interprocedural data.ow analysis via graph reachability. In Conference \nRecord of the 22nd Annual ACM Symposium on Principles of Programming Languages, 1995. [15] E. Schonberg, \nJ. Schwartz, and M. Sharir. An automatic technique for the selection of data representations in SETL \nprograms. ACM Trans. Program. Lang. Syst., 3(2):126 143, Apr. 1981. [16] R. Sekar and P. Uppuluri. Synthesizing \nfast intrusion prevention/detection systems from high-level speci.cations. In Proceedings of the USENIX \nSecurity Symposium, pages 63 78, 1999. [17] G. Sittampalam, O. de Moor, and K. F. Larsen. Incremental \nexecution of transformation speci.cations. In Conference Record of the 31st Annual ACM Symposium on Principles \nof Programming Languages, pages 26 38, 2004. [18] B. Ste.en. Data .ow analysis as model checking. In \nA. M. T. Ito, editor, Theoretical Aspects of Computer Science (TACS 91), volume 526 of LNCS,pages 346 \n364. Springer-Verlag, Berlin, 1991. [19] The World Wide Web Consortium. Extensible Markup Language (XML). \nhttp://www.w3.org/XML/. [20] The World Wide Web Consortium. XML Path Language (XPath). http://www.w3.org/TR/xpath. \n[21] M. Yannakakis. Graph-theoretic methods in database theory. In Proceedings of the ACM Symposium on \nPrinciples of Database Systems, pages 230 242, 1990.  \n\t\t\t", "proc_id": "996841", "abstract": "Regular path queries are a way of declaratively expressing queries on graphs as regular-expression-like patterns that are matched against paths in the graph. There are two kinds of queries: existential queries, which specify properties about individual paths, and universal queries, which specify properties about all paths. They provide a simple and convenient framework for expressing program analyses as queries on graph representations of programs, for expressing verification (model-checking) problems as queries on transition systems, for querying semi-structured data, etc. Parametric regular path queries extend the patterns with variables, called parameters, which significantly increase the expressiveness by allowing additional information along single or multiple paths to be captured and relate.This paper shows how a variety of program analysis and model-checking problems can be expressed easily and succinctly using parametric regular path queries. The paper describes the specification, design, analysis, and implementation of algorithms and data structures for efficiently solving existential and universal parametric regular path queries. Major contributions include the first complete algorithms and data structures for directly and efficiently solving existential and universal parametric regular path queries, detailed complexity analysis of the algorithms, detailed analytical and experimental performance comparison of variations of the algorithms and data structures, and investigation of efficiency tradeoffs between different formulations of queries.", "authors": [{"name": "Yanhong A. Liu", "author_profile_id": "81350588448", "affiliation": "State University of New York at Stony Brook, Stony Brook, NY", "person_id": "PP14186730", "email_address": "", "orcid_id": ""}, {"name": "Tom Rothamel", "author_profile_id": "81100394328", "affiliation": "State University of New York at Stony Brook, Stony Brook, NY", "person_id": "PP14139592", "email_address": "", "orcid_id": ""}, {"name": "Fuxiang Yu", "author_profile_id": "81100471706", "affiliation": "State University of New York at Stony Brook, Stony Brook, NY", "person_id": "P457702", "email_address": "", "orcid_id": ""}, {"name": "Scott D. Stoller", "author_profile_id": "81100262890", "affiliation": "State University of New York at Stony Brook, Stony Brook, NY", "person_id": "PP15027682", "email_address": "", "orcid_id": ""}, {"name": "Nanjun Hu", "author_profile_id": "81547247156", "affiliation": "State University of New York at Stony Brook, Stony Brook, NY", "person_id": "P677802", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/996841.996868", "year": "2004", "article_id": "996868", "conference": "PLDI", "title": "Parametric regular path queries", "url": "http://dl.acm.org/citation.cfm?id=996868"}