{"article_publication_date": "06-09-2004", "fulltext": "\n Jedd: A BDD-based Relational Extension of Java* Ond.rej Lhot\u00b4ak Laurie Hendren Sable Research Group, \nSchool of Computer Science McGill University, Montreal, Canada {olhotak,hendren}@sable.mcgill.ca ABSTRACT \nIn this paper we present Jedd, a language extension to Java that supports a convenient way of programming \nwith Binary Decision Diagrams (BDDs). The Jedd language abstracts BDDs as database\u00adstyle relations and \noperations on relations, and provides static type rules to ensure that relational operations are used \ncorrectly. The paper provides a description of the Jedd language and re\u00adports on the design and implementation \nof the Jedd translator and associated runtime system. Of particular interest is the approach to assigning \nattributes from the high-level relations to physical do\u00admains in the underlying BDDs, which is done by \nexpressing the constraints as a SAT problem and using a modern SAT solver to compute the solution. Further, \na runtime system is de.ned that handles memory management issues and supports a browsable pro\u00ad.ling tool \nfor tuning the key BDD operations. The motivation for designing Jedd was to support the develop\u00adment \nof whole program analyses based on BDDs, and we have used Jedd to express .ve key interrelated whole \nprogram analyses in our Soot compiler framework. We provide some examples of this ap\u00adplication and discuss \nour experiences using Jedd. Categories and Subject Descriptors D.3.3 [Programming Languages]: Language \nConstructs and Fea\u00adtures Data types and structures; D.3.4 [Programming Languages]: Processors; E.2 [Data]: \nData Storage Representations General Terms Languages, Design, Experimentation  Keywords Binary decision \ndiagrams, relations, language design, Java, pro\u00adgram analysis, boolean formula satis.ability 1. INTRODUCTION \nBinary Decision Diagrams (BDDs) [8] are widely used for ef\u00ad.ciently solving problems in model checking, \nand recently, we demonstrated that BDDs are very useful for de.ning compact and *This work was supported, \nin part, by NSERC. Permission to make digital or hard copies of all or part of this work for personal \nor classroom use is granted without fee provided that copies are not made or distributed for pro.t or \ncommercial advantage and that copies bear this notice and the full citation on the .rst page. To copy \notherwise, to republish, to post on servers or to redistribute to lists, requires prior speci.c permission \nand/or a fee. PLDI 04, June 9 11, 2004, Washington, DC, USA. Copyright 2004 ACM 1-58113-807-5/04/0006 \n...$5.00. ef.cient solvers for whole program analyses like points-to analy\u00adsis [5]. As BDDs have been \nin use for some time, there exist several excellent libraries providing ef.cient representations, algorithms \nand memory management techniques for BDDs, including two C\u00adbased libraries we have been using, BuDDy \n[14] and CUDD [25]. Based on our very positive experience with using BDDs for pro\u00adgram analysis, we embarked \non a project to express a number of key, interrelated whole program analyses for Java using BDDs in\u00adside \nour Java compiler framework, Soot [27]. We still wanted to use existing ef.cient C-based libraries, but \nnow we required a clean and ef.cient interface between the Java code of our compiler and our BDD-based \nalgorithms. In developing our approach, it soon became apparent that a sim\u00adple strategy of providing \na Java wrapper to interface with a BDD library was not a good solution, for many reasons. First, we found \nthat the interface provided by the existing BDD libraries is very low level, and as we attempted to express \nseveral complex interrelated analyses, understanding and maintaining our code became dif.cult. Moreover, \nprogramming at such a low level was error prone, and errors in our code led to either the BDD library \naborting, or worse, to incorrect results. The implicit nature of the BDD representation made these errors \ndif.cult to track down. Furthermore, we found that it is quite dif.cult to match the memory management \nin Java with the reference-counter-based schemes employed in the BDD packages. Finally, we found that \ntuning a BDD-based algorithm requires pro.ling information about the size and shape of the un\u00adderlying \nBDDs at each program step. We had previously developed some ad-hoc methods for visualizing this information, \nbut a more automated approach was needed. Our solution, and the topic of this paper, was the development \nof: (1) Jedd, a language extension to Java, which provides a high-level way of programming BDD-based \nalgorithms based on relations and operations on relations; (2) an associated translator which automat\u00adically \ntranslates Jedd to Java code that ef.ciently interacts with back-end solvers; and (3) run-time support \nfor memory manage\u00adment, debugging and pro.ling of BDD operations. The key aspects of our approach, and \nthe main contributions of this paper, are: BDDs abstracted as relations: Rather than expose BDDs and \ntheir low-level operations directly, our Jedd language provides a more abstract data type based on database-style \nrelations, and operations on those relations. In developing program analy\u00adses using BDDs, we have found \nthat this is a more appropri\u00adate level of abstraction. Static and dynamic type checking: When using a \nBDD library directly, there is very little type information to help the pro\u00adgrammer determine if BDD \noperations are used in a consis\u00adtent and correct fashion. In the Jedd approach, all operations on relations \nhave static type rules which help to eliminate many programmer errors. Properties that cannot be checked \nstatically are enforced by runtime checks. Code generation strategy: We provide a strategy to convert \nthe high-level relational operations into low-level BDD opera\u00adtions, and a mechanism for interfacing \nto several different BDD back-ends. Algorithm for physical domain assignment: An important issue in programming \nwith BDDs is how to assign physical do\u00admains of BDD variables to the problem being solved. When programming \ndirectly with BDDs, the programmer must ex\u00adplicitly make all of the assignments and ensure that BDD op\u00aderations \nare applied to the correct physical domains, which is a tedious process. Furthermore, a small change \nin physical domain mappings may require many changes in the program. When specifying a program using \nthe Jedd language, the user speci.es only the important assignments, and the translator completes a consistent \nmapping for the remainder of the pro\u00adgram. The problem of assigning physical domains turns out to be \nNP-complete. We provide an algorithm to express it as an instance of the SAT problem, and we show that, \nus\u00ading modern SAT solvers, the time to .nd a solution is very acceptable. In cases where no solution \nexists, we provide in\u00adformation back to the programmer to help them modify the program to make the problem \nsolvable. Run-time support for memory management: BDD solvers make use of reference counter memory management \ntechniques to ef.ciently reclaim the BDD data structures. These re\u00adquire the programmer to explicitly \nmanipulate the reference counts, which is error-prone and does not .t with the Java memory management \nmodel. Jedd frees the programmer from this task by automatically managing all reference counts, and freeing \nBDDs as soon as it is safe to do so. BDD pro.ler: In our previous and current work with BDDs, we found \nthat tuning the BDD-based algorithms required pro.l\u00ading the size and shape of the BDD data structures \nat each pro\u00adgram point. Our Jedd system allows the user to automatically generate pro.ling information \nthat can be browsed using any HTML browser, and which provides both counts of the num\u00adber of operations \napplied, and graphical .gures showing the size and shape of the underlying BDD data structures at each \nprogram point. Proof of concept applications: In order to verify that our approach works, we have implemented \nseveral interrelated whole pro\u00adgram analyses using the Jedd system. We found that the al\u00adgorithms were \nquite easy to specify, compact, and that the resulting BDD solvers were ef.cient. We also found that \nthe physical domain assignment algorithm worked well, ran in acceptable times, and provided good mappings \nof attributes to physical domains. A high-level overview of the complete Jedd system is given in Figure \n1. Jedd programs are written in our extension to Java, and are provided as input to the jeddccompiler. \nThe jeddccompiler is composed of a front-end (parser and semantic analysis) and a back-end (physical \ndomain assignment and code generation). The physical domain assignment module calls an external SAT solver \ntool. The output of jeddc is in the form of standard Java .les which can be incorporated into any Java \nproject. The Java .les produced by jeddc, along with other ordinary Java source mak\u00ading up a project, \nare compiled to class .les using a standard Java compiler such as javac. Unless the code written in Jedd \nis mod\u00adi.ed, jeddc is not needed when recompiling the Java part of the project. The resulting class .les \ncontain calls to the Jedd runtime library, which interfaces using JNI to a BDD package. A JVM is used \nto execute the classes along with the Jedd runtime. The run\u00adtime also includes a pro.ler, which writes \npro.le information into a SQL database. When combined with CGI scripts accessing the jeddc   solution \n profiler views Figure 1: Overview of Jedd system database, an HTML browser can be used to navigate pro.ler \nviews of BDD operations. The remainder of this paper is structured as follows. In Section 2, we give \nan introduction to the Jedd language, along with some illus\u00adtrative examples from our application of \nJedd to program analysis. In Section 3, we explain the key aspects of the jeddc compiler, with a particular \nemphasis on how we handle code generation and physical domain assignment. In Section 4, we describe the \nimpor\u00adtant elements of the design of our runtime system and pro.ler, and in Section 5, we brie.y report \non our experiences with using Jedd to implement .ve interrelated whole program analyses in the Soot compiler \nframework. Finally, in Section 6, we discuss related work, and in Section 7, we conclude and suggest \nfuture work.  2. JEDD LANGUAGE In this section, we describe the Jedd language, and illustrate key concepts \nwith examples. These examples are taken from exten\u00adsions to the Soot framework that we have written in \nJedd. These extensions perform interrelated whole-program analyses such as points-to analysis, call graph \nconstruction, and side-effect analy\u00adsis in BDDs, and together they form a signi.cant application of Jedd. \nFigure 2 shows an overview of the .ve main modules that have been implemented in Jedd and how they communicate \nwith each other. In Figure 4, we show a simpli.ed version of the core of the Virtual Call Resolution \nmodule to give an idea of what Jedd code looks like. Virtual Call Hierarchy Resolution Points-to Side-effect \nAnalysis Analysis Figure 2: BDD-based analyses in Soot The remainder of this section is structured as \nfollows. In Sec\u00adtion 2.1, we introduce a new data type, relations, and in Section 2.2, we describe the \nnew operations provided for relations. The gram\u00admar for the extensions is given in Figure 5 and the type \nrules in Figure 6. In Section 2.3, we describe how objects can be extracted from relations back to Java. \n2.1 Relations Jedd extends the Java language with a new data type, database\u00adstyle relations. Informally, \na relation is just a set of tuples. For example, the top part of Figure 3 shows a relation that contains \ntype signature method A foo() A.foo() B bar() B.bar() // declaring a relation with three attributes <type, \nsignature, method> implementsMethod; // declaring a relation with explicit mappings // to physical domains \n<type:T1, signature:S1, method:M1> implementsMethodMapped; Figure 3: Relations two tuples, and each \ntuple contains values for the attributes type, signature and method.An attribute is just a named domain, \nwhere a domain is a set of Java objects such as the set of all types in a program being analyzed, or \nthe set of all methods. All tuples in a relation must have the same set of attributes, and we call the \nset of attributes for a relation its schema. The relations in Jedd are high-level abstractions for BDDs, \nand there must exist some way of mapping the attributes of the higher-level Jedd relation to the underlying \nBDDs. A physical domain is a set of BDD variables used to represent an attribute of a relation. The bottom \npart of Figure 3 shows two different ways of declar\u00ading a relation in Jedd. The .rst example declares \nthe implements-Method relation which has three attributes. In this case, no phys\u00adical domain mapping \nis given for the attributes and it is left to the Jedd compiler to .nd a mapping. However, sometimes \nthe pro\u00adgrammer does want to expose the mapping of attributes to physical domains, and the declaration \nof implementsMethodMapped de\u00adclares another relation with the same schema as before, but with explicit \nmappings to the physical domains T1, S1 and M1. The de\u00adtails of physical domains and the algorithm to \nperform the mapping of attributes to physical domains are described in Section 3. Note that in our example, \nwe have just used names for attributes (i.e. type, signature and method). These names must be de\u00ad.ned \nby the Jedd programmer by de.ning special Java classes that implement the interface jedd.Attribute to \nspecify the domain and the name. Similarly, each domain is de.ned by implementing the jedd.Domain interface, \nand each physical domain is de.ned by implementing the jedd.PhysicalDomaininterface. Each do\u00admain speci.es \nthe maximum number of objects in it, and provides a mapping from Java objects to integers and vice versa. \nThe integer associated with an object is used to represent the object in BDDs. Jedd s type checker ensures \nthat any use of an interface, domain or physical domain is a subclass of the correct interface. Only \nrelations with the same schema are assignable and com\u00adparable. Like other primitive Java types, relations \nare passed by value, not by reference. Jedd de.nes two constants, 0Band 1B, the empty relation and the \nfull relation (containing all possible tuples), respectively. These constants have a special type that \nmakes them comparable and assignable to any relation type, much like Java s nullconstant. Jedd also provides \nan easy way to create new tuples from Java objects. For example, in Soot, we use the following code to \nadd a tuple to the implementsMethodrelation: void addMethod( Type newType, Signature newSig, SootMethod \nnewMethod ) { implementsMethod |= new { newType=>type, newSignature=>signature, newMethod=>method }; \n} The new expression constructs a relation of a single tuple with the Java objects newType, newSignature, \nand newMethod in at\u00adtributes type, signature, and method, respectively. This relation of a single tuple \nis then added into the implementsMethodrelation.  2.2 Operations on Relations 2.2.1 Set Operations and \nComparison The set union, intersection, and difference operations on rela\u00adtions viewed as sets of tuples \nare written in Jedd using the operators |, &#38;, and -, respectively. These operations make sense only \nwhen their arguments have the same schema, and this is enforced by the static type checking. Jedd also \nde.nes the expected shorthand as\u00adsignment operators |=, &#38;=, and -=. In the example above, the |= \noperator is used to add the new tuple to the implementsMethod relation. The == and != operators are used \nto compare relations for equality, an operation that takes only constant time in BDDs. 2.2.2 Projection \nand Attribute Operations Jedd provides three operations on the attributes of a relation. A projection \nremoves an attribute from the relation, along with the objects associated with the attribute in each \ntuple. Recall that re\u00adlations are sets of tuples with no duplicates. Since removing an attribute from \ntwo tuples that differ only in that attribute makes the tuples equal, a projection may reduce the number \nof tuples in a relation. Attribute renaming substitutes one attribute for another, without changing the \nobjects stored in tuples. Attribute copying adds a new attribute to a relation. In each tuple, the new \nattribute is mapped to the same object as the attribute being copied. To illustrate how these operations \nare used, we will walk through the problem of resolving virtual method calls given the actual types of \nthe receivers. Given a receiver type and a method signature, the algorithm must search for a class implementing \na method with the signature, starting from the receiver type and moving up the class hierarchy. In Jedd, \nthis is done for an entire relation at once, rather than one signature and receiver type at a time. The \nJedd code for this algorithm is shown in Figure 4. It starts with the relation receiverTypes, with each \ntuple specifying a receiver type and a method signature at some call site. An example of such a relation \nis shown in Figure 4(a), specifying the receiver type B at two call sites with signatures foo() and bar(). \nBefore starting to walk up the hierarchy starting from the receiver type, the algorithm .rst saves a \ncopy of the original receiver type in each tuple using the attribute copying operation in line 3. In \nthe resulting toResolve relation, each tuple contains the method signature and two copies of the receiver \ntype (see Figure 4(b)). The next step will be to determine whether the current class implements a method \nwith the required signature. Before explaining how to do this, we must pause to introduce the join and \ncomposition operations.  2.2.3 Join and Composition The join and composition operations combine the \ninformation from two relations into a single relation. In addition to a pair of relations, they require \na list of zero or more attributes from the left relation to compare with a corresponding list of attributes \nfrom the right relation. The new relation is constructed from all pairs of tuples from the two relations \nwhich match in the attributes being compared. Each such pair of tuples is merged into a single tuple \nin the .nal relation. The difference between a composition and join is in the attributes which are included \nin the .nal relation. A composition (denoted <>) projects away all of the attributes being compared. \nA join (denoted ><) keeps the attributes being com\u00adpared, but only those from the left relation, since \ntheir values are equal to those from the right relation. Although a composition is equivalent to a join \nfollowed by a projection, Jedd includes both operations because both are commonly used, and a composition \nis implemented more ef.ciently than a join followed by a projection. To see how these operations are \nused, let us return to our exam\u00adple. Recall that the toResolve relation contains, in each tuple, a method \nsignature and two copies of the receiver type, as shown 1 <rectype, signature, tgttype, method> answer \n= 0B; 2 public void resolve( <rectype, signature> receiverTypes, <subtype, supertype> extend ) { 3 <rectype, \nsignature, tgttype> toResolve = (rectype=>rectype tgttype) receiverTypes; 4 5 do {  6 <rectype:T1, \nsignature:S1, tgttype:T2, method:M1> resolved = 7 toResolve{tgttype, signature} >< declaresMethod{type, \nsignature}; 8 answer |= resolved;  9 toResolve -= (method=>) resolved;  10 toResolve = (supertype=>tgttype) \n(toResolve {tgttype} <> extend {subtype}); 11 } while( toResolve != 0B );  12 }   (a) type signature \n(b) rectype signature tgttype (c) rectype signature tgttype method (d) subtype supertype B foo() B foo() \nB B bar() B B.bar() B A B bar() B bar() B (e) rectype signature tgttype (f) rectype signature supertype \n(g) rectype signature tgttype method B foo() B B foo() A B foo() A A.foo() Figure 4: Example of resolving \nvirtual method calls (a) receiverTypes(b) toResolvein line 3 (c) resolvedin .rst iteration (d) extend(e) \ntoResolvein line 10 (f) result of composition in line 10 (g) resolvedin second iteration in Figure 4(b). \nThe next step is to determine whether the class of the receiver type implements a method with the signature. \nThis is done using the join on line 7, which joins this relation with the implementsMethod relation from \nFigure 3, matching the current class (tgttype attribute) with the class implementing the method (type \nattribute of implementsMethod), and the method signature (signature attribute) with the method signature \nof the implemented method (signature attribute of implementsMethod). For each class and method signature \nbeing resolved, if the class implements a method with a matching signature, then the resulting relation \nre\u00adsolved contains a tuple with the method signature, two copies of the receiver type, and the target \nmethod. In our example, the only match is type B and signature bar(), resulting in the resolved re\u00adlation \nin Figure 4(c). In general, these are the method calls that we have just resolved by .nding a method \nwith the desired signature, so in line 8, we add them to our answer. The T1, S2, T2, and M1 on line 6 \nare physical domains indicat\u00ading how to assign the attributes to BDD variables. In this example, the \nprogrammer supplies them for the resolved relation, and the physical domain assignment algorithm discussed \nin Section 3.3.2 .nds a reasonable assignment for all other expressions. The next step is to remove the \nresolved call sites from the set of sites left to resolve. The resolved relation has the method at\u00adtribute \nwhich toResolve lacks, so it is projected away in line 9 before the resolved call sites are subtracted. \nAfter doing this to our example, we obtain the toResolverelation in Figure 4(e). The .nal step is to \nmove up the class hierarchy by replacing each class in the tgttype attribute with its immediate superclass. \nThis is done with a composition (in line 10) of the toResolve relation with the extend relation passed \nin from the hierarchy, which en\u00adcodes the immediate superclass (extends) relationship. In our ex\u00adample, \nas Figure 4(d) shows, B is a subclass of A. The tgttype at\u00adtribute is matched with the subtype attribute \nin the extendrelation, and a composition rather than a join is used because the attributes being compared \n(the subtype) are not needed; from the extendre\u00adlation, only the supertype attribute is needed. The resulting \nrelation has replaced each object in the tgttype attribute of toResolvewith its immediate superclass, \nas shown in Figure 4(f). Before it can be assigned to toResolve, the supertype attribute must be renamed \nto tgttype to match the schema of toResolve. Finally, if the set of call sites to be resolved is not \nyet empty, the algorithm starts an\u00adother iteration of the loop to resolve them. Figure 4(g) shows the \ncall resolved in the second iteration. Together, the relations in Fig\u00adures 4(c) and (g) show the .nal \nresult: the targets of calling foo() and bar() with a receiver of type B are A.foo() and B.bar().  2.2.4 \nSelection We have not yet mentioned the common relational operation se\u00adlection, which returns the subset \nof the tuples having speci.ed ob\u00adjects in certain attributes. This is most easily implemented by con\u00adstructing \na relation containing the desired objects, and joining it with the relation of interest. Therefore, Jedd \ndoes not have a sepa\u00adrate selection operation.  2.3 Extracting Information from Relations An important \npart of a language extension integrating relations into Java are facilities for extracting information \nfrom relations back to Java. Jedd provides two versions of java.util.Iterator for iterating over the \ntuples of a relation. The .rst works on rela\u00adtions with a single attribute, and in each iteration returns \nthe single object in each tuple. The second iterator works on relations of any size, and iterates over \nthe tuples, returning each tuple as an array of objects. These iterators are used to implement a toString() \nmethod on relations, which is very useful for debugging Jedd pro\u00adgrams. Without such a method, it would \nbe very dif.cult to inter\u00adpret the structure of a BDD to determine the relation it represents. Jedd also \nprovides a size() method that returns the number of tuples in a relation. Jedd provides additional statistics \nabout the BDD representations of relations as part of its pro.ling framework, which is described in Section \n4.3.  3. JEDD TRANSLATOR We have implemented a translator which converts Jedd programs to Java programs. \nIn Section 3.1, we discuss the key front-end is\u00adsues, and in Section 3.2, we describe how the high-level \nrelational operations are represented using lower-level BDD operations. A key part of the code generation \nalgorithm is the physical domain assignment problem which is introduced in Section 3.3, and an algorithm \nbased on SAT is provided in Section 3.3.2. In some cases, there exists no valid physical domain assignment, \nand in Sec\u00adtion 3.3.3, we discuss how unsatis.able core extraction is used to provide meaningful error \nmessages. 3.1 Front-end We implemented the Jedd to Java translator using Polyglot [21], a Java front-end \nintended for writing language extensions. We used the Java grammar [12, ch. 19] as a starting point for \na Jedd grammar, after applying some language preserving trans\u00adformations so that the extended grammar \nwould be LALR(1). The productions that we added and removed are given in Figure 5. Non\u00adAdded productions: \n() (Type)::= < (AttributePhys) , (AttributePhys)* > (AttributePhys)::= (Attribute)| (Attribute) : (Attribute) \n(Attribute)::= (ClassOrInterfaceType) (UnaryExpressionNotPlusMinus)::= (RelExprJoin) (RelExprJoin)::= \n(RelExpr)| (Join) (Join)::= (RelExprJoin)(AttrList)(JoinSym)(RelExpr)(AttrList) () (AttrList)::= { (Attribute) \n, (Attribute)* } (JoinSym)::= > < | < > (RelExpr)::= (Replace)| (Post.xExpression) () (Replace)::= ( \n(Replacement) , (Replacement)* ) (RelationExpr) (Replacement)::= (Attribute) => | (Attribute) => (Attribute) \n| (Attribute) => (Attribute)(Attribute) () (Literal)::= new { (LiteralPiece) , (LiteralPiece)* } | 0B \n| 1B (LiteralPiece)::= (Expression) => (AttributePhys) Removed production: (UnaryExpressionNotPlusMinus)::= \n(Post.xExpression) Figure 5: Jedd grammar productions terminals from the original Java grammar appear \nin italics. The re\u00adsult is a LALR(1) grammar which extends Java in a natural way. The syntax and symbols \nfor all operations are intuitive and easy to remember (the symbols for join and composition, ><and <>, \nwere inspired by N and ., respectively, often used in relational database literature). Attribute manipulation \noperations (which change the type of expressions) use a cast-like syntax. No keywords and few new symbols \nwere added. Polyglot includes a complete semantic checker for Java. We extended this checker to infer \nthe schemas of relational expres\u00adsions from their subexpressions, and statically enforce the prop\u00aderties \nshown in Figure 6. The most important general properties are that no relation may have more than one \ninstance of the same attribute, that operands of set and equality operations have compat\u00adible schemas, \nand that attributes mentioned in attribute manipula\u00adtion, join, and composition expressions exist in \nthe corresponding operands. 3.2 Implementing Relational Operations In this section, we describe how \nrelations are represented in BDDs, and how the relational operations are performed. 3.2.1 Representing \nRelations as BDDs A BDD is a compact representation of a set of binary strings of a .xed length (or, \nequivalently, a function from {0,1}n to {0,1}). Jedd groups bit positions of these strings into physical \ndomains. When a relation is represented in a BDD, each attribute is stored in a separate physical domain. \nThe physical domains are de.ned and named by the user by implementing an interface included in the Jedd \nruntime library. The relative bit ordering of the various physical domains is also speci.ed by the user. \nThe assignment of the attributes of each relation to speci.c physical domains is subject ai =aj .i = \njai <: jedd.Attribute [Literal] new{o1=>a1,...,on=>an}: {a1,...,an} x : Ta .Ta <: jedd.Attribute [Project] \n(a=>)x : T \\{a} x : Ta .Tb ./Ta,b <: jedd.Attribute [Rename] (a=>b)x : (T \\{a}).{b} x : Ta .Tb,c ./T \n\\{a} b =ca,b,c <: jedd.Attribute [Copy] (a=>bc)x : (T \\{a}).{b,c} x : Ty : T [SetOp] x 8y : T where \n8.{&#38;,|,-} x : Ty : T .y .{0B,1B} [Assign] x 8y : T where 8.{=,&#38;=,|=,-=} x : T .x .{0B,1B} y : \nT .y .{0B,1B} [Compare] x 8y : booleanwhere 8.{==,!=} x : Ty : UU' =U \\{b1,...bn} T nU' =0/ {a1,...,an}.T \n{b1,...,bn}.U ai =aj .i = jbi =bj .i = j ai,bi <: jedd.Attribute [Join] x{a1,...,an}><y{b1,...,bn}: \nT .U' x : Ty : UT 'nU' =0/ T '=(T \\{a1,...,an}) U' =(U \\{b1,...bn}) {a1,...,an}.T {b1,...,bn}.U ai =aj \n.i = jbi =bj .i = j ai,bi <: jedd.Attribute [Compose] x{a1,...,an}<>y{b1,...,bn}: T '.U' Figure 6: Typing \nrules to many constraints, and we leave the discussion of this important problem to Section 3.3. Once \na physical domain assignment has been determined, Jedd ensures that each physical domain consists of \nenough bits to store the maximum number of objects that can be stored in each attribute assigned to it. \nEach domain can convert objects in the domain to integers and vice versa. We use the binary representation \nof the integer to en\u00adcode the object. To encode a tuple, we construct the BDD contain\u00ading all strings \nsuch that for each attribute, the bits in the physical domain assigned to that attribute match the binary \nrepresentation of the object stored in that attribute. Note that we have no require\u00adment of the bits \nin physical domains not used by any attribute; these bits can be viewed to have a wildcard value. For \nexample, suppose we want to encode the tuple {o1=>A, o2=>B}, where the binary representation of o1 is \n01, and the binary representation of o2 is 10, Ais assigned to the physical domain consisting of the \n.rst two bits, Bis assigned to the physical domain consisting of the next two bits, and a third, unused \nphysical domain exists, consisting of the last two bits. This tuple would be encoded by the BDD for the \nset of binary strings {0110??}={011000,011001,011010,011011}. Although this means that the BDD encoding \nof a single tuple can be a set of many strings, this does not affect the size of the BDD because BDDs \nrepresent such regular sets compactly. More specif\u00adically, the number of nodes in a BDD for a single \ntuple always equals the total number of bits in the physical domains used to en\u00adcode the attributes. \nThe BDD for a relation of multiple tuples is simply the BDD for the union of the binary strings representing \nall the tuples. This means that the set operations on relations are implemented as the same operations \non the sets of binary strings in the BDD, which are standard in BDD libraries. Similarly, relation equality \nis just BDD equality. However, for all these operations, the physical domain assignment must be the same \nfor both their operands. 3.2.2 Operations at the BDD level Projection is implemented in BDDs using the \nexistential quan\u00adti.cation BDD operation on the physical domains assigned to the removed attributes. \nConceptually, this operation takes all strings in the BDD, and creates new strings by replacing each \nbit of the phys\u00adical domain with both 0 and 1. Therefore, each tuple in the original BDD will appear \nin the new BDD, but with a wildcard value for the physical domains projected away, indicating that they \nare not in use by the relation. Attribute renaming requires no change to the underlying BDD. Only the \nmapping from attribute to physical domain needs to be updated, with the new attribute replacing the old. \nTo implement a join in BDDs, we must .rst carefully set up the physical domain assignment. The attributes \nbeing compared must be assigned to the same physical domains in the left and right relations. The remaining \nattributes must be assigned to physical domains not used by the other relation, or else their values \nwill overwrite each other. Assuming we have such a physical domain assignment, the join itself is performed \nwith an intersection oper\u00adation on the sets of binary strings in the BDD. Since the attributes being \ncompared are mapped to the same physical domain, the set intersection will .nd exactly those pairs from \nthe two sets where these attributes match. The remaining attributes are stored in phys\u00adical domains that \nare unused by the other relation, so they are rep\u00adresented there with a wildcard value. The set intersection \nof each object with the wildcard value just gives back the original object. A composition is implemented \nin the same way as a join fol\u00adlowed by a projection (set intersection followed by existential quan\u00adti.cation), \nbut a special function of the BDD library is used that performs these two operations more ef.ciently \nin one step. Due to the requirements of each operation on the physical do\u00admain assignment, it is sometimes \nnecessary to change the physical domain assignment of a relation (that is, construct a different BDD \nrepresenting the same relation, but under a different physical do\u00admain assignment). This is implemented \nusing an operation called replace in BuDDy, and SwapVariables in CUDD, which con\u00adstructs a BDD containing \nthe same strings as the original BDD, but with the bits of each string permuted with a speci.ed permutation. \nJedd constructs the permutation required to move the bits of the old physical domain to the new physical \ndomain, resulting in a BDD representing the same tuples, but in different physical domains.  3.3 Assigning \nPhysical Domains to Attributes One important problem when implementing algorithms using BDDs is deciding \nhow to assign the attributes of each expression to physical domains of BDD variables. In this section, \nwe explain how Jedd automates this task. First, in Section 3.3.1, we present the objectives which motivated \nthe design of the physical domain assignment algorithm. Next, in Section 3.3.2, we describe the al\u00adgorithm \nitself, and explain how it achieves the objectives. Finally, in Section 3.3.3, we present the error recovery \nmechanism which provides meaningful error messages to the programmer. 3.3.1 Objectives Our objectives \nfor the design of the physical domain assignment algorithm fall into three main categories. First, we \naimed to mini\u00admize the amount of work required of the programmer. Second, we wanted to make it possible \nto experiment with different physical domain assignments, with the ultimate goal of .nding assignments \nthat make the analysis execute ef.ciently. Third, we wanted an al\u00adgorithm which could be practically \nimplemented in a useable tool. In the rest of this section, we explain these objectives in more de\u00adtail. \nThe .rst two objectives may seem contradictory, since a very .exible system can be produced by requiring \nthe user to specify ev\u00adery detail, while an automatic system offering no choices requires little from \nthe user. Therefore, one of the challenges was to .nd a reasonable compromise between these two extremes. \nA programmer using a BDD library directly must assign attributes to physical domains by hand, and write \nthe program in terms of physical domains, rather than attributes. For simple programs of several BDD \nexpressions with two or three attributes, this is accept\u00adable; however, for more complicated programs,1 \nassigning a valid physical domain to each attribute of every subexpression is both tedious and error-prone. \nIt is tedious because there are so many attributes to which physical domains must be assigned, and it \nis error-prone because the many replace operations which move data to the assigned physical domains must \nbe inserted by hand, with no automatic veri.cation of their correctness. Therefore, we would like Jedd \nto relieve the user from having to perform the full assign\u00adment by automatically generating a reasonable \nassignment from a minimum amount of user input. To prevent errors, we would like Jedd to automatically \ninsert the correct replace operations to imple\u00adment the assignment. Since Jedd is a tool designed mainly \nfor research into imple\u00admenting program analyses using BDDs, it should make it possible to experiment \nwith different physical domain assignments. It has been widely noted that the ordering of bits in a BDD \ndetermines its size, and therefore the speed of operations performed on it. The bit ordering is closely \nrelated to the physical domain assignment, since physical domains are groups of bit positions; the combination \nof the assignment of attributes to physical domains and the order\u00ading of the bits of those physical domains \ntogether determine the relative ordering of the bits of attributes. Therefore, the physical domain assignment \nchosen has an important effect on the perfor\u00admance of algorithms implemented with BDDs. Unfortunately, \nwith our currently limited knowledge of implementing program analy\u00adses using BDDs, we do not know of \nany easy ways to determine a near-optimal physical domain assignment even by hand, let alone automatically. \nSome input from the programmer about the desired physical domain assignment is therefore necessary. Indeed, \nit is de\u00adsirable to allow the researcher to specify the assignment, to make it possible to experiment \nwith different assignments. These exper\u00adiments are necessary to improve our knowledge of what makes a \ngood assignment, and will hopefully one day lead to a fully auto\u00admated physical domain assignment algorithm. \nHowever, we must remember to balance .exibility with ease of speci.cation. Ideally, Jedd would allow \nthe program to initially contain a minimum of physical domain information, and would automatically generate \na reasonable complete assignment. Later, based on pro.ling infor\u00admation, the programmer would tune the \ncritical parts of the pro\u00adgram and specify the assignment for those parts in more detail. In order for \nthe physical domain assignment algorithm to be use\u00adful, it must be implemented in a practical tool that \nis useable by programmers. When the programmer-speci.ed part of the physical domain assignment contains \nerrors (i.e., part of the physical do\u00admain assignment is inconsistent), the algorithm should be able \nto indicate the source of the error with meaningful error messages. In the absence of errors, the algorithm \nshould always .nd a reason\u00ad 1Our current implementation of whole-program analyses contains 613 BDD subexpressions \nwith a total of 1586 attributes. able assignment; it should not be a heuristic that fails for certain \ndif.cult inputs, since these dif.cult problems are likely to also be dif.cult for the programmer to solve \nby hand. Since Jedd will be run each time the program is compiled, and since the point of Jedd is to \nmake it easier to implement non-trivial program analyses us\u00ading BDDs, the algorithm should be able to \nprocess these non-trivial programs in a reasonable amount of time. Jedd addresses these objectives in \nthe following ways. For each attribute of each expression, the programmer may optionally spec\u00adify a physical \ndomain assignment, and Jedd automatically inserts the correct replace operations to implement the assignment. \nThis makes it easy to tweak the assignment without having to rewrite the replace operations. When the \nprogrammer speci.es physical domains for only a small subset of the attributes, Jedd automat\u00adically completes \nthe assignment using the algorithm described in the next section. Should the programmer not be satis.ed \nwith spe\u00adci.c parts of the automatically generated assignment, physical do\u00admains may be speci.ed for \nthese expressions explicitly, and Jedd will .nd a reasonable assignment for the rest of the program. \nIf the programmer-speci.ed portion of the physical domain assignment contains an error and an assignment \ncannot be found, Jedd reports the speci.c expression and attributes to which physical domains cannot \nbe assigned, as described in section 3.3.3. In section 5, we provide some experimental results showing \nthat the physical do\u00admain assignment algorithm is suf.ciently fast for the problems for which Jedd was \nintended. 3.3.2 Physical Domain Assignment Algorithm We call a physical domain assignment for a Jedd \nprogram valid if a BDD implementation using the assignment correctly computes the relational algebra \nexpressions in the program. In order for a physical domain assignment to be valid, it is necessary and \nsuf.\u00ad cient for it to satisfy the following constraints between attributes of expressions: 1. [con.ict] \nAll attributes of each expression must be assigned to distinct physical domains. 2. [equality] Each \noperation requires certain attributes of its op\u00aderands to be assigned to the same physical domain, as \nde\u00adscribed in Section 3.2.  A valid (though not necessarily reasonable) physical domain as\u00adsignment \ncan be found very easily. First, introduce a fresh phys\u00adical domain for each attribute of each expression, \nsatisfying the .rst requirement. Then, wrap each subexpression of a complex ex\u00adpression with a replace \noperation changing the physical domains to satisfy the second requirement. The resulting physical domain \nassignment is valid, but it requires many replace operations, slow\u00ading down program execution considerably. \nIn addition, there is no way for the programmer to force selected attributes to be assigned to speci.c \nphysical domains. We would like to minimize or at least reduce the number of re\u00adplace operations, as \nwell as give the programmer some control over where these operations take place. A convenient way to \ndo this is to allow the programmer to specify physical domains for some small subset of expressions, \nand constrain the physical domain as\u00adsignment not to contain any unnecessary replaces. This makes it \npossible for Jedd to construct a reasonable assignment with few replaces with very little input from \nthe programmer, while giving the programmer the option to more completely specify a domain assignment \nfor speci.c sections of the code. We need to formalize what we mean by unnecessary replaces. To do this, \nwe .rst wrap all subexpressions with dummy replace op\u00aderations as described above, so that the equality \nconstraints can be satis.ed. Then, for each attribute of each replace operation, we add an assignment \nedge from the attribute in the original subexpression resolved  rectype signature tgttype method T1 \nS1 T2M1 replace rectype signature tgttype method join  toResolve declaresMethod  rectype signature \ntgttype signature type method Figure 7: Example of physical domain assignment constraints to the attribute \nin the result of the replace. Intuitively, these as\u00adsignment edges connect attributes which should be \nassigned to the same physical domain; if they are, the replace operation is unnec\u00adessary and can be removed. \nBecause different replace operations have unpredictably different costs, we do not try to .nd an assign\u00adment \nhaving the minimum number of assignment edges with dif\u00adferent physical domains; instead, we are satis.ed \nwith removing computation paths in which an attribute is replaced multiple times without reason. More \nprecisely, we partition the graph formed by equality and assignment edges into connected components by \npo\u00adtentially breaking some assignment edges, such that each compo\u00adnent contains one attribute with a \nprogrammer-speci.ed physical domain, and no con.ict edge has both its endpoints in components with the \nsame physical domain (or in the same component). Every attribute in a component is then assigned the \nsame physical do\u00admain. This ensures that every replace operation has a reason, since replace operations \nonly occur between attributes at the boundaries of components with different programmer-speci.ed physical \ndo\u00admains. Furthermore, this is consistent with the kind of behaviour the programmer likely expects: if \nan attribute is involved in a com\u00adputation with other attributes for which physical domains have been \nspeci.ed, one expects it to be assigned to one of those domains. The constraints produced from lines \n6-7 of the example in Fig\u00adure 4 are shown in Figure 7. Equality constraints are shown as solid lines \nand assignment constraints as dashed lines. Con.ict constraints, which are not shown, are placed between \nall pairs of attributes within each expression. Replace operations have been wrapped around the subexpressions \ntoResolveand declares-Method, and around the entire join. In the absence of any other constraints, the \ngraph would be split into four connected compo\u00adnents (the .rst consisting of all rectype attributes, \nthe second of all signature attributes, the third of all tgttype and type attributes, and the fourth \nof all method attributes), which would be assigned the physical domains T1, S1, T2, and M1, respectively. \nSince the in\u00adput and output of each replace operation would then have the same physical domain assignment, \nno replacement would be necessary, so Jedd would remove them prior to generating Java code. In general, \n.nding a partitioning respecting all con.ict and equal\u00adity constraints and the programmer-speci.ed physical \ndomains is an NP-complete problem. An NP-completeness proof is given in [13]. Several heuristics that \nwe implemented failed on common exam\u00adple programs. More importantly, an incomplete heuristic (which may \nfail to .nd a solution even when one exists) is undesirable for this problem. The case when a heuristic \nwould fail to .nd a solu\u00adtion is precisely when the programmer very much wants to know whether a solution \nexists (and he should tediously look for it by hand) or does not exist (and he should modify the code \nso that a solution does exist). Therefore, the potentially very high cost of an exhaustive search is \njusti.ed, and our intuition told us that al\u00adthough the problem in general is NP-complete, typical instances \nwould be relatively easy . However, we realized that implement\u00ading a smart exhaustive solver that would \nhandle the easy cases ef.\u00adciently would be dif.cult, and we would be duplicating much of the work that \nhas been done on the boolean satis.ability (SAT) prob\u00adlem. We therefore encode the physical domain assignment \nproblem as a SAT problem, and call a SAT solver to solve it for us. Given a boolean formula over a set \nof variables, a SAT solver .nds a truth assignment to those variables that makes the formula evaluate \nto true. We therefore encode the physical domain assign\u00adment problem into a boolean formula in such a \nway that we can re\u00adcover a physical domain assignment from a truth assignment of its variables, and such \nthat the formula evaluates to true exactly when the physical domain assignment satis.es our constraints. \nWe con\u00adstruct the formula in conjunctive normal form because most SAT solvers require it, and it is easier \nto specify it directly in CNF than to construct an arbitrary formula and convert it to CNF later. A formula \nin CNF is a conjunction of disjunctions of literals, where each literal is a variable or a negated variable. \nLet E be the set of all expressions of BDD type in the program. a For each expression e, we use the notation \nefor attribute a of a expression e. Let A be the set of all pairs eof expressions and attributes in the \nprogram. Let P be the set of all physical domains in the program. The SAT formulation consists of two \ntypes of variables: attribute physical domain variables, and .ow path variables. A variable of the form \nea:p indicates that attribute a of expression e is assigned physical domain p. To represent the notion \nof connected compo\u00adnents in the SAT formula, we introduce .ow paths, sequences of attributes of expressions \nwith the following properties: the .rst attribute in the sequence is the only one with a programmer-speci.ed \nphysical domain,  each consecutive pair of attributes on the .ow path is con\u00adnected by an equality or \nassignment edge,  no attribute of an expression appears more than once on the .ow path, and  no other \n.ow path ending with the same attribute exists whose attributes form a proper subset of the attributes \nof the .ow path.  Intuitively, the .ow paths represent, for each attribute of each ex\u00adpression, the \nshortest paths to it following equality and assignment edges from an attribute with a programmer-speci.ed \nphysical do\u00admain. We will require that at least one .ow path ending at each attribute be active, indicating \nthat the attribute, as well as all the attributes on the .ow path, are in the same connected component. \na0:p0 a1 A variable of the form p(e0 ,e1 ,...,enan ) indicates that the given .ow path from attribute \na0 of e0 to an of en is active; that is, all attributes along it are assigned physical domain p0. We \nuse . to denote the set of all .ow paths. The constraints are encoded in terms of these variables as \nfollows. 1. Each attribute is assigned to some physical domain. a:p e ea.Ap.P 2. No attribute is assigned \nto multiple physical domains. a:p \u00acea:p .\u00aceea.Ap,p '.P,p=p ' 3. Any attribute with an explicitly speci.ed \nphysical domain is assigned that domain. a:p e(ea ,p).SPECIFIED 'a 4. For each con.ict edge between ea \nand e ' , a and a ' must not be assigned to the same physical domain. .. ' :p 'a \u00acea:p .\u00ace ' p.P(ea \n,e 'a ).CONFLICT 'a ' 5. For each equality edge between ea and e ' , a and a are as\u00adsigned the same physical \ndomain. 'a ' :p) .(\u00aca:p .e 'a ' :p) (ea:p .\u00acee ' p.P(ea ,e 'a ).EQUALITY 6. For each ea, at least one \n.ow path leading to it must be active. a0:p0 a1 p(e0 ,e1 ,...,ea) ea.A p(e0 a0:p0 ,e1a1 ,...,ea).. 7. \nWhen a .ow path is active, all attributes on it are assigned the physical domain of the .ow path. a0:p0 \na1 ai:p0 \u00acp(e0 ,e1 ,...,enan ).ei p(e0 a0:p0 ,e1 a1 ,...,enan ).. 0=i=n 3.3.3 Error Reporting One challenge \nwith using a black box such as a SAT solver in a compiler is in reporting errors to the user. When the \nSAT solver determines that no physical domain assignment exists, it reports that the boolean formula \nis unsatis.able. While this fact is useful for the programmer to know, it is not very helpful in determining \nthe cause of the error. To improve the error reporting, we took advantage of a new fea\u00adture recently \nimplemented in the zchaff SAT solver, unsatis.able core extraction [30]. When the SAT solver determines \nthat the boolean formula is unsatis.able, it also outputs a small subset of the clauses (disjunctions) \nsuch that their conjunction is also unsat\u00adis.able. Although the minimality of this core is not guaranteed, \nour experience has been that all the unsatis.able cores found for the physical domain assignment problem \nwere indeed minimal. The physical domain assignment may not have a solution for one of two reasons. First, \nthere may be an attribute of an expression with no path to any attribute for which a physical domain \nhas been speci.ed; that is, a component of the graph formed by equality and assignment edges may not \nhave a physical domain speci.ed for it. Jedd detects this case while constructing the input to the SAT \nsolver, since it makes it impossible to construct the clause requiring at least one .ow path leading \nto the attribute to be active (clause 6). Second, it may not be possible to partition the graph formed \nby equality and assignment edges in a way that respects all the con.ict constraints. In this case, the \nfollowing proposition gives us a way to report the source of the problem to the programmer. Proposition: \nWhen the boolean formula produced for the physi\u00adcal domain assignment problem is unsatis.able, every \nunsatis.able core contains at least one clause of type 4 (con.ict clause). A proof of this proposition \nis given in [13]. It follows from the proposition that the small unsatis.able core returned by the SAT \nsolver will include at least one clause of type 4. From this clause, Jedd extracts the expression and \nthe attributes to which physical domains could not be assigned, and even the physi\u00adcal domain(s) that \nwere considered for assignment to the attributes. This information is reported to the programmer along \nwith the posi\u00adtion of the expression in the source .le. The problem can be easily .xed by explicitly \nassigning a new physical domain to one of the attributes in the con.ict constraint that cannot be satis.ed. \nTo illustrate the error reporting with a typical error, consider the following declarations, along with \nthe compose subexpression taken from line 10 of Figure 4. <rectype:T1, signature:S1, tgttype:T2> toResolve; \n<supertype:T1, subtype:T2> extend; <rectype, signature, supertype> result = toResolve {tgttype} <> extend \n{subtype}; The result of the compose operation has attributes rectype, sig\u00adnature, and supertype, but \nonly the physical domain T1is avail\u00adable for both rectypeand supertype. In this case, the Jedd trans\u00adlator \nwould issue the following error message: Conflict between Compose_expression:rectype at Test.jedd:4,25 \nand Compose_expression:supertype at Test.jedd:4,25 over physical domain T1 The error message indicates \nthe line and column (4 and 25) of the expression in question, the attributes to which a physical domain \ncould not be assigned (rectype and supertype), and the sin\u00adgle physical domain which is available for \nthe two attributes (T1). To .x this error, the programmer would specify that one of the attributes, for \nexample supertype, should be assigned to a new physical domain T3: <rectype, signature, supertype:T3> \nresult = toResolve {tgttype} <> extend {subtype};   4. JEDD RUNTIME 4.1 Backends One of the bene.ts \nof expressing BDD algorithms in a language like Jedd is that we can execute these algorithms, without \nmod\u00adi.cation, using various BDD libraries as backends. This allows us to compare the performance of different \nbackends on the same problem. In Jedd, we have already implemented interfaces to the BuDDy [14] and CUDD \n[25] libraries using JNI to call C code from Java, and we are experimenting with our own library written \nentirely in Java. Several researchers have suggested using zero\u00adsuppressed binary decision diagrams (ZDDs) \n[18] for our points-to analysis algorithms. We are therefore working on a backend for Jedd based on ZDDs, \nwhich will allow us to run all our algorithms using ZDDs without modi.cation. 4.2 Memory Management \nIssues All BDD libraries that we are aware of use reference counts to identify unused BDD nodes to be \nreclaimed. A disadvantage of this approach is that a programmer using the library in a C program is required \nto explicitly increment and decrement the reference count whenever BDDs are assigned or a reference to \na BDD goes out of scope. In C++, it is possible to use overloaded assignment op\u00aderators and destructors \nto relieve the programmer of much of this burden. The lack of operator overloading makes this impossible \nin Java. If Jedd were a library rather than a language extension, the programmer would have to explicitly \nmanipulate reference counts. This is yet another tedious and error-prone aspect of working with BDDs. \nSince Jedd is an extension to the language, we can design it to update reference counts automatically, \nwithout any help from the programmer. For performance reasons, it is particularly important that the \nreference count be decremented as soon as possible after a reference becomes dead. When dead nodes are \nnot freed in a garbage collection, fewer nodes remain for future computation, so garbage collection is \nrequired more frequently. In addition, BDD libraries use a cache to speed up the basic operations on \nnodes. Large numbers of unfreed obsolete nodes may pollute this cache. In general, we cannot rely solely \non the Java garbage collector to determine when relations are unreachable, particularly short-lived temporary \nrelations. This is because unlike allocations of Java ob\u00adjects, an allocation of a BDD node will not \ntrigger a Java garbage collection when no more memory is available. It is very possible to allocate many \nlarge temporary BDDs in several iterations of a loop and have the BDD library run out of memory without \na Java garbage collection ever being triggered. A BDD can become dead in four ways. First, it may be \nthe result of a subexpression of an expression becoming unreachable after the outer expression is evaluated. \nSecond, it may be stored in a local variable or .eld, and it may be overwritten by another BDD. Third, \nthe BDD may be stored in a local variable which goes out of scope. Fourth, the BDD may be stored in a \n.eld, and the object containing the .eld may become unreachable. For temporary values, the .rst two cases \nare the most common and therefore the most important. To handle the .rst case, we implement the convention \nthat each BDD operation decrements the reference count of its arguments and increments the reference \ncount of its result before returning it. This convention is partly imposed by the requirement of the \nBDD libraries that any BDDs passed to library functions have non-zero reference counts. For a clean implementation \nof the remaining cases, we create a relation container object for each local variable and .eld. In the \ngenerated Java code, the variable/.eld points to its relation con\u00adtainer throughout its lifetime; this \nis enforced by making the vari\u00adable/.eld .nal. The BDD itself is stored as a private .eld in the relation \ncontainer, and can be updated only through an assignment method which also updates the reference counts. \nThis guarantees that in the second case, a BDD being overwritten has its reference count decremented \nimmediately. To handle the third and fourth cases, the relation container object also decrements the \nreference count of any BDD stored in its .nalizer, which is called when the relation container is garbage \ncollected. In the fourth case (a .eld becoming dead), this happens in the same garbage collection2 as \nthe one in which the object containing the .eld becomes unreach\u00adable, which is the earliest time that \nit is safe to decrement the refer\u00adence count. For the third case (a variable going out of scope), this \nensures that the reference count will eventually be decremented, but this may be a signi.cant amount \nof time after the variable goes out of scope. To improve on this, we perform a static liveness anal\u00adysis \non all relation variables, and at each point where a variable may become dead, we decrement the reference \ncount of any BDD it may contain and remove the BDD from the container. In the face of exceptional interprocedural \ncontrol .ow, this is not always pos\u00adsible. We assume such control .ow to be unusual, and fall back on \nthe .nalizer to decrement the reference count in such cases. To summarize, Jedd manages BDD reference \ncounts automati\u00adcally without any help from the programmer. In all four cases, it frees BDDs as soon \nas it becomes safe to do so, so its performance should be no worse than that of a hand-coded reference \ncounting solution.  4.3 Pro.ler A common problem when tuning any algorithm using BDDs is choosing an \nef.cient variable ordering, the relative order of the individual bits of the physical domains. In complicated \nprograms with many relations and attributes, a related problem is tuning the physical domain assignment, \nand the replace operations which it dictates. Speci.cally, we are interested in removing those replace \noperations which are particularly expensive by modifying the phys\u00ad 2Here, we assume that the garbage \ncollector collects all unreach\u00adable objects in each collection. However, even when this is not true in \ngeneral, such as in a generational collector, it is very likely that the object containing the .eld and \nthe relation container will be reclaimed in the same collection, since they are allocated close together: \nthe latter is allocated in the constructor of the former. Analysis Component Relation Exprs. Attrs. \nPhys. Doms. Number of Constraints Con.ict Equality Assignment SAT Problem Variables Clauses Literals \nSolving Time (s) Virtual Call Resolution Hierarchy Points-to Analysis Side-effect Analysis Call Graph \nAll 5 combined 46 172 247 68 89 613 127 344 561 237 340 1586 5 5 8 9 8 10 184 173 70 242 442 143 637 \n802 259 484 282 108 929 442 187 4902 2141 767 1298 5600 3711 18140 7997 44405 4441 41772 7043 96514 31083 \n273986 11627 37764 93052 86482 197865 568597 0.016 0.062 0.161 0.165 0.284 4.607 Table 1: Size of physical \ndomain assignment problem ical domain assignment to make them unnecessary. For these tun\u00ading tasks, we \nneed some insight into the runtime behaviour of our program. In particular, we want to know which operations \nare ex\u00adpensive in terms of time and BDD size (and therefore space), in order to either remove them, or \nmake them cheaper by modifying the variable ordering. For tuning the variable ordering, knowing the shape \nof the BDDs involved in the operation is also useful. The shape of a BDD is the number of nodes at each \nlevel (testing each variable) of the BDD. In the code generated by Jedd, relational operations are imple\u00admented \nas calls into the Jedd runtime library. The runtime library optionally makes calls to a pro.ler which \nrecords, for each oper\u00adation, the time taken and the number of nodes and shape of the operand and result \nBDDs. This information is written out as an SQL .le to be loaded into a database, which provides a .exible \ndata store on which arbitrary queries can be performed to present the data to the user. Jedd also includes \nCGI scripts to provide ac\u00adcess to the pro.ling data through a web browser. We use SQLite for the database \nand thttpd for the web server because of their ease of installation, but in principle, any SQL database \nand CGI-capable web server should work. The overall pro.le view shows, for each relational operation \nin the program, the number of times it was ex\u00adecuted, the total time taken, and the maximum size of the \nBDDs involved. Clicking on an operation brings up a detailed view with a line of information for each \ntime the operation was executed. Click\u00ading on a speci.c execution of the operation generates a graphical \nrepresentation of the shape of the BDDs involved in the operation.  5. EXPERIENCE WITH JEDD We have \nimplemented in Jedd several test examples, our BDD points-to analysis algorithm [5], and a collection \nof interrelated whole-program analyses. Without Jedd, the latter would not have been feasible, since \nit would require us to assign physical domains by hand to the attributes of 613 subexpressions, with \nno automated way to verify that we had not made mistakes; in fact, we initially tried such an approach, \nand quickly gave up. Even the relatively short points-to analysis algorithm becomes much clearer when \nex\u00adpressed using attributes rather than physical domains directly, and without the clutter of low-level \nreplace operations. In general, we wrote the whole-program analyses without specifying any physical domains \nat all, and when it came time to compile, we assigned just enough attributes to physical domains to allow \nthe physical domain assignment algorithm to assign the rest. In this process, Jedd s error reporting \npointed us directly to the expressions that needed to have physical domains assigned by hand. The analyses \nthemselves were easy to implement compared to pure Java implementations, mainly thanks to the compact \nrepresentation provided by BDDs. For in\u00adstance, the Java version of the side-effect analysis consists \nof 803 non-comment lines of code, mostly implementing data structures to compactly represent the large, \nhighly redundant sets of side ef\u00adfects. In contrast, the Jedd version is only 124 lines. For now, this \nis just preliminary experience, but we hope that Jedd will enable the development of many other BDD-based \nprogram analyses. We have found the zchaff SAT solver [19] to be more than fast enough for solving the \ndomain assignment problem, even for sig\u00adni.cant programs such as the combination of all .ve program anal\u00adyses, \nas shown in Table 1. The .rst section of the table shows the number of relational expressions, attributes \nin these expressions, and physical domains. The second section lists the number of each type of constraint \nin the physical domain assignment problem. The third section gives the number of distinct variables, \nclauses, and literals in the resulting SAT formula. Finally, the fourth section shows the time taken \nby zchaff to parse and solve the formula on a 1833 MHz Athlon with 512 MB of RAM. To put the times into \nperspective, a complete build of Soot takes 5 minutes on the same machine, so 4.6 seconds to assign physical \ndomains is very accept\u00adable. The SAT encoding of the physical domain assignment prob\u00adlem was designed \nto be easy to understand rather than compact; it could easily be made smaller if the SAT solver ever \nbecame a bottleneck. To measure the runtime overhead of Jedd compared to using a BDD library directly \nin C++ [5], we timed the C++ and Jedd ver\u00adsions of our points-to analysis algorithm on .ve benchmarks. \nBoth versions used the BuDDy library as the backend. The timings are shown in Table 2. The overhead varied \nfrom 0.5% to 4%, which we attribute to having to have the Java VM in memory, and to the internal Java \nthreads that run even when not executing Java code. Benchmark Std. lib. version C++ Jedd javac 1.1.8 \n3.4 s 3.5 s compress 1.3.1 21.7 s 22.4 s javac 1.3.1 25.3 s 26.3 s sablecc 1.3.1 25.4 s 26.1 s jedit \n1.3.1 41.1 s 41.3 s Table 2: Running time comparison of hand-coded C++ [5] and Jedd points-to analysis \n 6. RELATED WORK We have organized related work into four categories. In the next section, we sample \nthe abundance of work on languages for ex\u00adpressing relational computation. In Section 6.2, we present \nvarious tools that have been written to interface with BDDs at a low level. Some work has been done on \nabstracting BDDs as relations, and we compare this work with Jedd in Section 6.3. Finally, a small, but \nrapidly growing, number of researchers have implemented program analyses using BDDs without a relational \nabstraction; we discuss their work in Section 6.4. 6.1 Languages with Relations The relational data model \nbased on relational algebra was pro\u00adposed by Codd [10], and has since been used for many applications, \nparticularly as the basis of relational databases. The SQL language has become a standard way of expressing \nrelational operations in database systems, and snippets of SQL code are often embedded in programs written \nin other languages. Prolog [9] and its derivatives are based on querying and updating a database of facts, \nwhich are analogous to relational tuples. Relations as .rst-class objects have appeared in many general-purpose \nlanguages ever since the days of SETL [23], which included binary relations as one of its basic data \ntypes. Support for n-ary relations is often present in languages for writing glue code between database \nsystems and client inter\u00adfaces, such as the <bigwig>project [7], a high-level language for web services. \nThe increasing popularity of XML is fuelling work on adapting languages for manipulating XML fragments, \nwhich of\u00adten resemble tuples, but are generally less homogeneous. A recent example of this work are extensions \nto the type system of C# for expressing both relational and XML data [16]. Jedd is similar to these languages \nin that it adds relations as a data type to Java. In contrast to these languages whose primary goal is \nto provide access to relations, the primary focus of Jedd is to enable program analysis developers to \nexploit the compact data representation provided by BDDs, using relations as an abstraction to make programming \nwith BDDs manageable. 6.2 Interfacing with BDDs Jedd is built on top of the BuDDy [14] and CUDD [25] \nBDD li\u00adbraries, which provide a low-level interface to a BDD implementa\u00adtion. These libraries implement \nthe basic operations on BDDs, with few higher-level abstractions. The .nite domain blocks of BuDDy are \none small exception; they provide a convenient way to group together BDD variables, much like the physical \ndomains in Jedd. Several small interactive languages have been developed for ex\u00adperimenting with BDDs. \nOne example is BEM-II [17], designed for manipulating Arithmetic BDDs and solving 0-1 integer pro\u00adgramming \nproblems. Another is IBEN [3], which provides a com\u00admand-line user interface to directly call the BuDDy \nlibrary func\u00adtions, as well as BDD visualization facilities. The JNI interface allows Java code to use \nBDD libraries written in C through specially written wrappers. We have found it very convenient to use \nthe wrapper generator Swig [2] to automatically generate these wrappers for us. However, others have \nchosen to write such wrappers by hand, resulting in JBDD [26], a Java in\u00adterface to both BuDDy and CUDD, \nlater extended and renamed JavaBDD [28]. Unlike Jedd, these JNI wrappers provide no ab\u00adstraction over \nthe underlying BDD libraries. They simply allow the library functions to be called from Java. 6.3 Relations \nwith BDD Back-ends Although relations have been included in many languages, and several BDD implementations \nand interfaces exist, the use of BDDs as back-ends for implementing relations has been comparatively \nrare. The RELVIEW system is an interactive manipulator of binary re\u00adlations with a graphical user interface \nfor visualizing them. It sup\u00adports multiple back-ends, and one of the newer back-ends stores re\u00adlations \nin BDDs [4]. The fundamental difference between RELVIEW and Jedd is that RELVIEW is designed around binary \nrelations, while much of the complexity of Jedd stems from the need to repre\u00adsent n-ary relations. As \npointed out by Fahmy, Holt, and Cordy [11], binary relations are insuf.cient for expressing certain problems \nin representing and querying graphs. For many program analysis prob\u00adlems which could be represented by \nbinary relations, this repre\u00adsentation would be more cumbersome than is possible using n-ary relations. \nGBDD [20] is a C++ library providing an abstraction of BDDs based on relations of integers. Although \nit has partial support for n-ary relations, some operations (such as composition) require bi\u00adnary relations. \nCompared to Jedd, GBDD lacks static type check\u00ading (the type of a relation is not known until run-time), \nthe concept of abstract attributes to be assigned to physical domains, automatic memory management, and \na pro.ler. The language most closely related to Jedd is CrocoPat [6], a tool for querying relations representing \nsoftware architecture ex\u00adtracted from source code. Like Jedd, CrocoPat is based on n-ary relations. CrocoPat \nuses a declarative, Prolog-like syntax in which attributes are identi.ed implicitly by their position, \nrather than ex\u00adplicitly by name, as in Jedd. CrocoPat also differs from Jedd in that it is primarily \na query language rather than an extension of a general-purpose language. The issue of assigning attributes \nto physical domains is not discussed in the CrocoPat paper. 6.4 Program Analysis using BDDs Several \nresearchers have implemented various program analyses using BDDs directly, without a relation-based abstraction. \nOne example of this is our own earlier work on points-to analy\u00adsis [5], which we are now extending using \nJedd. Ball and Rajamani [1] lifted a .ow-sensitive .nite-set data.ow analysis to keep track of a set \nof data.ow sets for each program point, in order to track correlations between elements of data.ow sets, \nachieving a path-sensitive analysis. They used BDDs to com\u00adpactly represent the otherwise large sets \nof sets. Sagiv, Reps, and Wilhelm [22] have constructed a framework based on three-valued logic for expressing \nprogram analyses, par\u00adticularly heap shape analyses. Although very expressive, this frame\u00adwork has memory \nrequirements that are often prohibitive when an\u00adalyzing non-trivial programs. Manevich et al. [15] compared \ndiffer\u00adent techniques for reducing the space required to represent the state required in these analyses; \nBDDs were one of these techniques. This work is related to Jedd in that it allows program analyses to \nbe expressed at a high level and can use BDDs as a back-end. It differs in that it uses three-valued \nlogic as the high-level represen\u00adtation, rather than relations. Sittampalam, de Moor, and Larsen [24] \nformulate program anal\u00adyses using conditions on control .ow paths. These conditions con\u00adtain free metavariables \ncorresponding to program elements (such as variables and constants). To perform an analysis, these metavari\u00adables \nare instantiated with speci.c elements from the particular pro\u00adgram being analyzed. BDDs are used to \nef.ciently represent and search the large space of possible instantiations. Zhang, Gupta and Zhang [31] \nrecord dynamic slices during pro\u00adgram execution for debugging purposes. These sets of slices get very \nlarge, making the space and time required for this instrumenta\u00adtion prohibitive when using traditional \nmethods. In order to reduce these costs, they store the sets of slices ef.ciently in BDDs. Interest in \nthe use of BDDs for static program analysis continues to grow; two other papers using BDDs for context-sensitive \npointer analysis appear in these same proceedings [29, 32]. Our hope is that Jedd will facilitate the \nimplementation of fur\u00adther, more complicated program analyses using BDDs.  7. CONCLUSIONS AND FUTURE \nWORK We have introduced Jedd, a high-level language extension to Java for expressing set-based algorithms \nso that they can be im\u00adplemented using BDDs. The motivation for designing the language was to provide \na convenient way of specifying program analyses so that they could be ef.ciently solved using existing \nBDD packages. The approach presented is one of designing an appropriate lan\u00adguage abstraction which: \n(1) provides the programmer with the correct abstraction of the problem, in this case a form of relations; \n(2) provides as much static type support as possible; (3) exposes only as much low-level detail as required \n(the programmer need only provide some of the key physical domain assignments); and (4) .ts naturally \nas an extension of a general purpose programming language, Java.  Based on this language, we have de.ned \nand implemented a translator to generate Java code and an associated runtime system. Key parts of the \ntranslator are: (1) the high-level relational oper\u00adations are translated into low-level BDD operations \nwhich can be provided by a variety of backend solvers; (2) the translator lever\u00adages the power of existing \nSAT solvers to automatically provide a complete assignment of attributes to physical domains (or pro\u00advides \na meaningful error message if no such assignment exists); (3) automatically supports a reference-count-based \napproach to mem\u00adory management at the Java level, compatible with the approaches taken in the C-based \nsolvers; and (4) provides support for debug\u00adging and pro.ling of the BDD-based operations. We have used \nour system to program .ve key program analysis modules in the Soot compiler framework [27] and have found \nthat it allows us to write compact programs which can be compiled in reasonable time, and that generated \nBDD-based code is about as ef.cient as the BDD solvers we coded by hand. Our next steps are to experiment \nwith more analyses written in Jedd and to integrate the Jedd-based analyses into the main Soot development \ntrunk. Another challenge will be to make Jedd com\u00adpatible with generics when Java 1.5 is released. Information \nabout the most recent versions of Jedd and its release status is found at http://www.sable.mcgill.ca/jedd/. \n 8. REFERENCES [1] Thomas Ball and Sriram K. Rajamani. Bebop: A Path-sensitive Interprocedural Data.ow \nEngine. In Proceedings of PASTE 01, pages 97 103, June 2001. [2] D. M. Beazley. SWIG: An easy to use \ntool for integrating scripting languages with C and C++. In Proceedings of the 4th USENIX Tcl/Tk Workshop, \npages 129 139, July 1996. [3] Gerd Behrmann. The interactive BDD environment. http://iben.sourceforge.net/. \n [4] R. Berghammer, B. Leoniuk, and U. Milanese. Implementation of relational algebra using binary decision \ndiagrams. In 6th International Conference RelMiCS 2001, volume 2561 of LNCS, pages 241 257, December \n2002. [5] Marc Berndl, Ond.rej Lhot\u00b4ak, Feng Qian, Laurie Hendren, and Navindra Umanee. Points-to analysis \nusing BDDs. In Proceedings of the ACM SIGPLAN 2003 Conference on Programming Language Design and Implementation, \npages 103 114. ACM Press, 2003. [6] Dirk Beyer, Andreas Noack, and Claus Lewerentz. Simple and ef.cient \nrelational querying of software structures. In Proceedings of the 10th IEEE Working Conference on Reverse \nEngineering (WCRE 2003), pages 216 225, 2003. [7] Claus Brabrand, Anders M\u00f8ller, and Michael I. Schwartzbach. \nThe <bigwig>project. ACM Transactions on Internet Technology (TOIT), 2(2):79 114, 2002. [8] Randal E. \nBryant. Symbolic boolean manipulation with ordered binary decision diagrams. ACM Computing Surveys, 24(3):293 \n318, 1992. [9] W. F. Clocksin and C. S. Mellish. Programming in Prolog. Springer-Verlag New York, Inc., \n1987. [10] E. F. Codd. A relational model of data for large shared data banks. Communications of the \nACM, 13(6):377 387, 1970. [11] H.M. Fahmy, R.C. Holt, and J.R. Cordy. Wins and losses of algebraic transformations \nof software architectures. In ASE 2001: Automated Software Engineering, pages 51 62, 2001. [12] James \nGosling, Bill Joy, and Guy Steele. The Java Language Speci.cation. Addison-Wesley, 1996. [13] Ond.rej \nLhot\u00b4ak and Laurie Hendren. Jedd: A BDD-based relational extension of Java. Technical Report 2003-7, \nMcGill University, Sable Research Group, 2003. [14] J\u00f8rn Lind-Nielsen. BuDDy, A Binary Decision Diagram \nPackage. Department of Information Technology, Technical University of Denmark, http://www.itu.dk/research/buddy/. \n[15] R. Manevich, G. Ramalingam, J. Field, D. Goyal, and M. Sagiv. Compactly Representing First-Order \nStructures for Static Analysis. In Manuel V. Hermenegildo and German Puebla, editors, Proceedings of \nSAS 02, volume 2477 of LNCS, Madrid, Spain, September 2002. Springer. [16] Erik Meijer and Wolfram Schulte. \nUnifying tables, objects, and documents. In Workshop on Declarative Programming in the Context of Object-Oriented \nLanguages, pages 145 166, August 2003. [17] S. Minato and F. Somenzi. Arithmetic boolean expression manipulator \nusing BDDs. Formal Methods in System Design, 10(2/3):221 242, 1997. [18] Shinichi Minato. Zero-suppressed \nBDDs for set manipulation in combinatorial problems. In Proceedings of the 30th ACM/IEEE Design Automation \nConference, pages 272 277. ACM Press, 1993. [19] Matthew W. Moskewicz, Conor F. Madigan, Ying Zhao, Lintao \nZhang, and Sharad Malik. Chaff: engineering an ef.cient SAT solver. In Proceedings of the 38th Conference \non Design Automation, pages 530 535. ACM Press, 2001. [20] Marcus Nilsson. GBDD A package for representing \nrelations with BDDs. http://user.it.uu.se/\u00ad marcusn/projects/rmc/docs/gbdd/index.html. [21] N. Nystrom, \nM. R. Clarkson, and A. C. Myers. Polyglot: An extensible compiler framework for Java. In 12th International \nConference on Compiler Construction, volume 2622 of LNCS, pages 138 152, 2003. [22] Mooly Sagiv, Thomas \nReps, and Reinhard Wilhelm. Parametric shape analysis via 3-valued logic. ACM Transactions on Programming \nLanguages and Systems (TOPLAS), 24(3):217 298, 2002. [23] J. T. Schwartz, R. B. K. Dewar, E. Dubinsky, \nand E. Schonberg. Programming with Sets -an Introduction to Setl. Springer, New York, 1986. [24] Ganesh \nSittampalam, Oege de Moor, and Ken Friis Larsen. Incremental execution of transformation speci.cations. \nIn Proceedings of the 31st ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, pages \n26 38. ACM Press, 2004. [25] Fabio Somenzi. CUDD: CU Decision Diagram Package. Department of Electrical \nand Computer Engineering, University of Colorado at Boulder, http://vlsi.colorado.edu/ fabio/CUDD/. [26] \nArash Vahidi. Arash s Java interface to BDDs. http://www.chl.chalmers.se/ vahidi/bdd/bdd.html. [27] Raja \nVall\u00b4ee-Rai, Etienne Gagnon, Laurie J. Hendren, Patrick Lam, Patrice Pominville, and Vijay Sundaresan. \nOptimizing Java bytecode using the Soot framework: is it feasible? In Compiler Construction, 9th International \nConference (CC 2000), volume 1781 of LNCS, pages 18 34, 2000. [28] John Whaley. JavaBDD Java binary \ndecision diagram library. http://javabdd.sourceforge.net/. [29] John Whaley and Monica Lam. Cloning-based \ncontext-sensitive pointer alias analyses using binary decision diagrams. In Proceedings of the ACM SIGPLAN \n2004 Conference on Programming Language Design and Implementation. ACM Press, 2004. [30] L. Zhang and \nS. Malik. Validating SAT solvers using an independent resolution-based checker: Practical implementations \nand other applications. In Proceedings of Design, Automation and Test in Europe (DATE2003), pages 880 \n885, 2003. [31] X. Zhang, R. Gupta, and Y. Zhang. Ef.cient forward computation of dynamic slices using \nreduced ordered binary decision diagrams. In 2004 IEEE/ACM International Conference on Software Engineering, \n2004. [32] Jianwen Zhu and Silvian Calman. Symbolic pointer analysis revisited. In Proceedings of the \nACM SIGPLAN 2004 Conference on Programming Language Design and Implementation. ACM Press, 2004.  \n\t\t\t", "proc_id": "996841", "abstract": "In this paper we present Jedd, a language extension to Java that supports a convenient way of programming with Binary Decision Diagrams (BDDs). The Jedd language abstracts BDDs as database-style relations and operations on relations, and provides static type rules to ensure that relational operations are used correctly.The paper provides a description of the Jedd language and reports on the design and implementation of the Jedd translator and associated runtime system. Of particular interest is the approach to assigning attributes from the high-level relations to physical domains in the underlying BDDs, which is done by expressing the constraints as a SAT problem and using a modern SAT solver to compute the solution. Further, a runtime system is defined that handles memory management issues and supports a browsable profiling tool for tuning the key BDD operations.The motivation for designing Jedd was to support the development of whole program analyses based on BDDs, and we have used Jedd to express five key interrelated whole program analyses in our Soot compiler framework. We provide some examples of this application and discuss our experiences using Jedd.", "authors": [{"name": "Ond&#345;ej Lhot&#225;k", "author_profile_id": "81100503314", "affiliation": "McGill University, Montreal, Canada", "person_id": "P677803", "email_address": "", "orcid_id": ""}, {"name": "Laurie Hendren", "author_profile_id": "81100646110", "affiliation": "McGill University, Montreal, Canada", "person_id": "PP14221385", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/996841.996861", "year": "2004", "article_id": "996861", "conference": "PLDI", "title": "Jedd: a BDD-based relational extension of Java", "url": "http://dl.acm.org/citation.cfm?id=996861"}