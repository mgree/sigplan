{"article_publication_date": "06-09-2004", "fulltext": "\n Verifying Safety Properties using Separation and Heterogeneous Abstractions Eran Yahav* School of Computer \nScience Tel-Aviv University Tel-Aviv, 69978 Israel yahave@post.tau.ac.il ABSTRACT In this paper, we \nshow how separation (decomposing a veri.ca\u00adtion problem into a collection of veri.cation subproblems) \ncan be used to improve the ef.ciency and precision of veri.cation of safety properties. We present a \nsimple language for specifying separation strategies for decomposing a single veri.cation problem into \na set of subproblems. (The strategy speci.cation is distinct from the safety property speci.cation and \nis speci.ed separately.) We present a gen\u00aderal framework of heterogeneous abstraction that allows different \nparts of the heap to be abstracted using different degrees of precision at different points during the \nanalysis. We show how the goals of separation (i.e., more ef.cient veri.cation) can be realized by .rst \nusing a separation strategy to transform (instrument) a veri.cation problem instance (consisting of a \nsafety property speci.cation and an input program), and by then utilizing heterogeneous abstraction during \nthe veri.cation of the transformed veri.cation problem. Some tasks are best done by machine, while others \nare best done by human insight; and a properly designed system will .nd the right balance. D. Knuth \n General Terms Algorithms, Languages, Theory, Veri.cation Keywords Abstract Interpretation,Veri.cation, \nSafety Properties, ProgramAnal\u00adysis, Typestate Veri.cation Categories and Subject Descriptors D.2.4 \n[Software Engineering]: Software/ProgramVeri.cation;F.3.1 [Logics and Meanings of Programs]: Specifying \nand Verifying *This research was supported in part by a grant from the Ministry of Science, Israel, and \nthe Israeli Academy of Science, and was done in part while the author was visiting IBM Research. Permission \nto make digital or hard copies of all or part of this work for personal or classroom use is granted without \nfee provided that copies are not made or distributed for pro.t or commercial advantage and that copies \nbear this notice and the full citation on the .rst page. To copy otherwise, to republish, to post on \nservers or to redistribute to lists, requires prior speci.c permission and/or a fee. PLDI 04, June 9 \n11, 2004, Washington, DC, USA. Copyright 2004 ACM 1-58113-807-5/04/0006 ...$5.00. G. Ramalingam IBM T.J. \nWatson Research Center P.O. Box 704 Yorktown Heights, NY 10598 USA rama@watson.ibm.com and Reasoning \nabout Programs; F.3.2 [Logics and Meanings of Programs]: Semantics of Programming Languages Program anal\u00adysis \n 1. INTRODUCTION Recently there has been signi.cant and growing interest in static veri.cation of safety \nproperties (e.g., see [3, 6, 2, 9, 8, 1, 14, 7, 5]). Such veri.cation is valuable since it can identify \nsoftware de\u00ad fects early on, thereby improving programmer productivity, reduc\u00ad ing software development \ncosts, and increasing software quality and reliability. Consider the Java program fragment shown in Fig. \n1. This pro\u00ad gram performs a number of database queries using JDBC [21]. This example violates one of \nthe usage constraints imposed by the JDBC library. Speci.cally, the execution of a query in line 28, \nusing a Statement object, has the implicit effect of discarding the re\u00ad sults to the previous query executed \nin line 27 (using the same Statement object). Hence, the subsequent attempt to use these discarded results, \nin line 40, is invalid. We are interested in verifying that a given program satis.es safety properties \nof the kind illustrated above. While signi.cant progress has been made recently in such lightweight veri.cation, \ndoing pre\u00ad cise veri.cation that can scale to large and complex programs still remains a challenge. In \nthis paper, we investigate a technique to improve the precision and ef.ciency of such veri.cation. The \nstarting point for our work is the notion of separation: the idea that separating or decomposing a veri.cation \nproblem into a collection of smaller subproblems can help scale veri.cation algo\u00ad rithms (e.g., see [5]). \nConsider again the example in Fig. 1. This example program executes 5 different queries, producing 5 \ndifferent ResultSets. We can verify that the program satis.es the desired safety property by independently \nverifying the property for each of these ResultSets. It may seem like we are just restating the problem, \nbut this restate\u00ad ment is important from the point of view of the underlying analysis. It can signi.cantly \nincrease the ef.ciency of the analysis by reducing the size of the state space that needs to be explored. \nIn our running example, Statement stmt1 and ResultSet rs1 can be in several possible states in line 28. \nWhile this information is relevant for verifying subsequent use of ResultSet rs1, it is irrelevant for \nverifying the usage of ResultSet rs2, for example. The motivation for separation is to exploit this to \nimprove ef.ciency, without losing precision. In this paper, we explore this approach by addressing the \nfollow\u00ad ing questions: (1) How do we decompose a veri.cation problem into a collection of subproblems? \n 10 ConnectionManager 11 Connection con1 = 12 Statement stmt1 = 15 ResultSet maxRs = 16 if (maxRs.next()) \n cm = new ConnectionManager(); cm.getConnection(); cm.createStatement(con1); stmt1.executeQuery(maxQry); \n 18 ResultSet rs1 = stmt1.executeQuery(balancesQry); 19 if (maxBalance1 < threshold) { 20 stmt1.close(); \n21 closed1 = true; 22 } 23 Connection con2 = cm.getConnection(); 24 Statement stmt2 = cm.createStatement(con2); \n 27 ResultSet rs2 = stmt2.executeQuery(balancesQry); 28 ResultSet maxRs2 = stmt2.executeQuery(maxQry); \n29 if (maxRs2.next()) 31 ResultSet minRs2 = stmt2.executeQuery(minQry);  40 while (rs2.next())  Figure \n1: JDBC example snippet. (2) How can we adapt the state abstractions to each subproblem (so that we may \nachieve the desired ef.ciency improvement)? One of the key characteristics of our approach is that we \nbreak up this question into two parts: (a) What are the objects that are relevant to a veri.cation subproblem? \n(b) Given the set of relevant objects, how can we adapt the state abstraction to utilize this information? \nIn this paper, we introduce the notion of a separation strategy as something that can help answer question \n(1) and partly help answer (2)(a). Rather than adopt a .xed strategy for separation, we introduce a simple \nlanguage for specifying separation strate\u00adgies that can be used to manually specify strategies. One strategy \nfor the JDBC problem would be to apply separation at the level of a Connection, where veri.cation of \nall ResultSets cre\u00adated over a single Connection is treated as a single veri.cation subproblem. Currently, \nwe see the strategy speci.cation language as a way for analysis designers, such as ourselves, to specify \nand experiment with different strategies. Our intuition, however, is that end users may be able to easily \nidentify objects of interest and relevance to some veri.cation subproblem and that the strategy speci.cation \nmay be a lightweight way to allow end user input to guide veri.cation. Given a veri.cation problem instance \n(consisting of a safety prop\u00aderty speci.cation and an input program) and a separation strategy, the .rst \nstep of our approach is to transform (or instrument) the ver\u00adi.cation problem instance to re.ect the \nseparation strategy. (Here, it is worth pointing out that when we talk about decomposing a veri.cation \nproblem into subproblems , we are talking at a concep\u00adtual level; the transformed veri.cation problem \nmentioned above is equivalent to solving the subproblems in parallel.) The second step is to perform \nveri.cation for the transformed pro\u00adgram and safety property in a way that exploits the separation. This \nleads us to question (2) above. One of the distinguishing character\u00adistic of our approach is that we \nrely on an integrated analysis that performs, e.g., heap analysis in conjunction with the veri.cation \n(as opposed to doing it as a separate preceding analysis). Thus, we are interested in exploiting separation \neven for the heap analysis. (In\u00addeed, the bene.ts of separation may be greatest for the heap analysis \ncomponent if the veri.cation utilizes precise, but expensive, heap analysis.) In this paper, we utilize \nheterogenous abstractions that allow us to model different parts of the heap with different degrees of \nprecision at different points in time as a technique to exploit separation. Consider the example in Fig. \n1. Fig. 2(a) informally shows two possible states of the heap at line 28, corresponding to different \nbranches taken at line 19. The Statement referenced by stmt1 and the ResultSet references by rs1 are \nin a closed state in C2 (as illustrated by the c inside the component node). Fig. 2(b) illus\u00adtrates the \nabstract representation produced by our technique (with a simple separation): the representation above \nthe line corresponds to one subproblem (corresponding to Connection con1), and a b con1stmt1rs1C1 st \n  mrs   con2stmt2rs2  mrs st con1stmt1rs1C1.1 st mrs    b con1stmt1rs1C2   stmrs 0 0  \n   c c con2stmt2rs2  mrs st con1stmt1rs1C2.1   stmrs 0  0  c c   b C1.2   e   . =1/2con2stmt2rs2 \nst mrs   Figure 2: Separation and heterogenous abstraction. the representation below the line corresponds \nto a different subprob\u00adlem (corresponding to Connection con2). (We present more details about these representations \nin later sections.) Main Results The main contributions of this paper are: We present a simple language \nfor specifying separation strate\u00adgies for decomposing a single veri.cation problem into a set of subproblems. \n We present a general framework of heterogeneous abstrac\u00adtions that allows different parts of the heap \nto be abstracted using different degrees of precision at different points during the analysis.  We show \nhow the goals of separation (i.e., more ef.cient ver\u00adi.cation) can be realized by .rst using a separation \nstrategy to transform (instrument) a veri.cation problem instance (con\u00adsisting of a safety property speci.cation \nand an input pro\u00adgram), and then utilizing heterogeneous abstraction during the veri.cation of the transformed \nveri.cation problem.  We have implemented a prototype of a separation veri.ca\u00adtion engine using TVLA, \nand applied it to verify properties of several Java programs, using several different separation  while \n(?) { f = new File(); f.read(); f.close(); } Figure 3: Program illustrating the dif.culty of verifying \nthat a .le component is never read after it has been closed. strategies. Initial results indicate that \nseparation does improve the ef.ciency, and possibly precision, of veri.cation results. One of the themes \nto emerge in recent work (e.g., see [14, 7, 5]) is that maintaining just the right correlation required \nbetween analysis facts can be the key to ef.cient and precise veri.cation: maintaining no correlations \n(independent attribute analysis) can lead to imprecision, while maintaining all correlations (relational \nanal\u00adysis) can lead to inef.ciency. However, .nding this intermediate ground can be hard for heap analyses \nthat, e.g., use graph-based representations of the heap. Our approach may be seen as a step towards achieving \nsuch a balance in a heap representation. Existing approaches to veri.cation range from more automated \ntechniques that rely on no extra human input (other than the safety property speci.cation) to techniques \nthat rely on end users to pro\u00advide signi.cant annotation, such as program invariants. We see the strategy \nspeci.cations we use as a potentially useful, lightweight, way for users to assist a veri.er.  Related \nWork ESP [5] is a system for typestate veri.cation [19] that utilizes a simple .xed separation technique. \nOur work differs from ESP in several respects. ESP uses a two-phase approach to veri.cation in which \npointer-analysis is performed .rst, followed by typestate ver\u00adi.cation. Often, this prevents ESP from \napplying strong updates necessary for successful veri.cation. Separation in ESP is exploited only in \nthe typestate veri.cation phase. We utilize an integrated analysis, where the heap analysis and veri.cation \nare performed si\u00admultaneously, allowing the heap analysis to bene.t from separation. We also explore \nseparation in a more general setting than ESP: we explore its applicability to .rst order safety properties, \nsuch as the ones shown earlier for JDBC, which involve relationships among multiple objects; we allow \nuser-speci.able separation strategies; .\u00adnally, our technique can achieve separation between multiple \nobjects allocated at the same allocation site. Since our analysis is capable of separating out a single \nobject (even from among multiple objects allocated at the same allocation site), it can utilize strong \nupdates when ESP is forced to use weak updates. This can lead to more precise results, as illustrated \nby the example in Fig. 3. Unlike ESP, our technique can successfully verify this example. The instrumentation \ntechnique we use to implement separation strategies may be seen as an extension of techniques previously \nused (e.g., by Bandera [3, 4] and SLAM [13]) to instrument a program with respect to a safety property \nspeci.cation prior to veri.cation. However, these approaches use such instrumentation purely to en\u00adcode \nthe veri.cation problem, and do not exploit it for separation and the generation of adaptive abstractions \nlike we do. Separation is similar in spirit to McMillan s functional decompo\u00adsition [12], which divides \nthe veri.cation task according to units\u00adof-work rather than dividing according to the program syntax. \nHis division, however, is applied at the speci.cation level since all en\u00adtities have static names. Guyer \n[10] shows that it is valuable to have pointer analyses that are client-driven. His analysis is a two \npass analysis, with a client-independent .rst pass pointer analysis, followed by a second pass pointer \nanalysis that uses different levels of context-sensitivity for different analyzed procedures, based on \nsources of imprecision identi.ed from the use of the results computed by the .rst pass. [14] explores \ntechniques to derive abstractions that are special\u00adized to a safety property. Our work on separation \nis orthogonal to these techniques. In [18], a heap-safety-automaton (HSA) is used to specify local heap \nproperties (corresponding to typestate proper\u00adties) which are later veri.ed without using any form of \nseparation. We believe that the separation techniques in this paper could be bene.cial for their analysis \nas well. Our heterogeneous abstraction technique is based on the paramet\u00adric analysis framework of Sagiv \net al. [17]. This analysis framework has been used to derive several powerful and precise, but very expen\u00adsive, \nheap analyses. We believe that successful veri.cation systems need to use such powerful analyses when \nneeded (to handle dif.cult cases when they arise), but scalability requires that the scope of such analyses \nbe restricted to a small enough universe. We believe that the identi.cation of relevant objects via our \nseparation technique is a step towards achieving this. An alternative separation technique would be to \ndecompose a veri.cation problem into subproblems that verify that each use of an object, such as a ResultSet, \nis safe, utilizing demand-driven analysis to solve the subproblems. This inherently involves back\u00adward \nanalysis , while our approach utilizes forward analysis . The motivation for our approach is that backward \nanalysis is inherently hard when complex heap analysis is involved. 2. SAFETY PROPERTIES We are interested \nin verifying that client programs that use a component (library) satisfy correct usage constraints imposed \nby the library API. In this paper, we use some of the usage constraints imposed by the JDBC library to \nillustrate our separation technique for veri.cation of such safety properties. The JDBC library allows \nclient programs to create Connections to databases. Any number of Statements may be created over a Connection.A \nStatement can be used to execute an SQL query over the database, via the executeQuery() method, which \nreturns the results to the query as a ResultSet. The next() method of a ResultSet can be used repeatedly \nto iterate over the results of the query. However, the execution of the executeQuery() method of a Statement \nimplicitly closes any ResultSet pre\u00adviously returned by the Statement, and it is invalid to use any of \nthose ResultSets any more. Similarly, after closing a Connection, it is invalid to use any of the Statements \ncreated from that Connection or any of the ResultSets returned by these Statements. Thus, the execution \nof line 28 in the example of Fig. 1 implicitly closes the ResultSet created in line 27, and this will \ncause an error when this closed ResultSet is used in line 40. We specify safety properties using Easl \n[14], a procedural lan\u00adguage for specifying an abstract semantics for a component library. Easl statements \nare a subset of Java statements containing as\u00adsignments, conditionals, looping constructs, and object \nallocation. Easl types are restricted to booleans, heap-references, and a built\u00adin abstract Set and Map \ntypes. Finally, Easl provides a requires statement to specify the correct usage constraints imposed by \nthe library: it is the responsibility of any program that uses the library to ensure that the condition \nspeci.ed by the requires clause will hold true at the corresponding program point. These are the safety \nproperties we are interested in checking. Easl supports object references and dynamic allocation. This \nallows us to naturally express the structural relationships between the objects of interest, as well \nas dynamic allocation of these objects. class Connection { class Statement { class ResultSet { boolean \nclosed; boolean closed; boolean closed; Easl.Set statements; ResultSet myResultSet; Statement ownerStmt; \nConnection() { Connection myConnection; ResultSet(Statement s) { closed = false; Statement(Connection \nc) { closed = false ; statements = {}; closed = false; ownerStmt = s; } myConnection = c; } Statement \ncreateStatement() { myResultSet = null; void close() { requires !closed; } closed = true; Statement st \n= new Statement(this); ResultSet executeQuery(String qry) { } statements = statements U { st }; requires \n!closed; boolean next() { return st; if (myResultSet != null) requires !closed; } myResultSet.closed \n= true; } void close() { myResultSet = new ResultSet(this); } closed = true; return myResultSet; for \neach st in statements } if (st.myResultSet != null) { void close() { st.closed = true; closed = true; \nst.myResultSet.closed = true; if (myResultSet != null) } myResultSet.closed = true; } } } } Figure 4: \nAn Easl speci.cation for a simpli.ed subset of the JDBC API. Fig. 4 shows an Easl speci.cation for the \nJDBC1 safety prop\u00aderties described above. Note the use of the set statements and the .elds myResultSet, \nmyConnection, and ownerStmt to specify the relationships be\u00adtween the components. Also note that applying \nexecuteQuery closes the ResultSet component referenced by myResultSet if one exists. In the rest of this \npaper we will address the problem of verifying that a given Java program satis.es the safety properties \nspeci.ed by an Easl speci.cation.  3. SEPARATION STRATEGIES The goal of a separation strategy is to \nseparate or decompose a ver\u00adi.cation problem into a collection of veri.cation subproblems. We now present \nan informal description of separation strategies. A more formal meaning will be given to separation strategies \nin Sec. 4.2. Consider a typestate property, such as an InputStream should not be read after it is closed \n. In this case, veri.cation of the safety property for one InputStream object does not depend on the \nstate of another InputStream object. Hence, the veri.cation can be done independently for each InputStream \nobject. This amounts to a very simple separation strategy. Some safety properties, such as the JDBC ResultSet \nprop\u00aderty, involve multiple related objects we refer to these as .rst order safety properties. Consequently, \nveri.cation of such properties can be separated into subproblems in several different ways, each with \npotentially different ef.ciency and precision tradeoffs. Before we present some of the possible separation \nstrategies, we introduce a simple language for specifying a separation strategy. In our approach, a separation \nstrategy represents a method for choosing a set of objects. A set of chosen objects identi.es a sub\u00adproblem \nwhere veri.cation is restricted to the chosen objects. For effective veri.cation, a strategy should identify \nother objects that may have an impact on a chosen object and choose them too. This motivates the de.nition \nof the following language for specifying strategies. An (atomic) separation strategy is a sequence of \nchoice opera\u00adtions, where each choice operation identi.es one or more objects that are chosen, as a function \nof previously chosen objects. <atomic-strategy> ::= <choice-spec> * 1Field names from Sun s SDK1.3.1 \nsun.jdbc.odbc implementation. <choice-spec> ::= choose (some|all) <var>:<constr> [/<condition>] <constr> \n= <type-name> ( <var-list> ) Each choice operation consists of a variable name, a signature of a constructor, \nand an optional condition. The choice operation choose some performs a non-deterministic selection of \nobjects created through the speci.ed constructor that satisfy the condition. The operation choose all \nchooses all objects created through the speci.ed constructor that satisfy the condition. Both choice \noperations evaluate the condition, and apply their choice on entry to the speci.ed constructor. We now \npresent some strategies for the JDBC ResultSet property. Single Choice. The motivation for our .rst strategy \nis the obser\u00advation that there is no interaction between different Connections: it should be possible \nto perform veri.cation for each Connection independently. Hence, the following strategy performs separation \nat the level of a Connection. choose some c : Connection() choose all s : Statement(x) / x == c choose \nall r : ResultSet(y) / y == s  The separation strategy described above .rst non-deterministically chooses \na single Connection, then proceeds by choosing all Statements created from this Connection, and then \nchoosing all ResultSets created from these Statements. For the run\u00adning example, this amounts to separating \nthe veri.cation problem into two independent subproblems, one for each Connection. Multiple Choice. However, \nit should be clear from the JDBC speci.cation that it is possible to perform a more .ne-grained sep\u00adaration \nthan the single choice strategy described above. In partic\u00adular, the correct usage of a ResultSet does \nnot really depend on how any other ResultSet is used. Thus, it is not necessary to perform veri.cation \nof the different ResultSets created from a single Statement together, for instance. However, the cor\u00adrect \nusage of a ResultSet does depend on the Statement and Connection underlying the ResultSet. These observations \nmotivate the following separation strategy. choose some c : Connection() choose some s : Statement(x) \n/ x == c choose some r : ResultSet(y) / y == s For the running example, this strategy produces a set \nof 5 sub\u00adproblems, one for each combination of matching Connection, Statement and ResultSet. Note that \nusing a .ner grained separation strategy may or may not lead to more ef.cient veri.cation. On one hand, \n.ner grained separation leads to smaller subproblems that can be veri.ed more easily. On the other hand, \nit also leads to a larger number of sub\u00adproblems. The relative performance of a strategy may depend on \nthe amount of work that is duplicated across the different subproblems. The strategy we present next \nis likely to reduce the amount of work duplicated across subproblems. Incremental. The two strategies \nwe have seen are examples of atomic strategies. In this paper, we also explore the possibility of applying \na sequence of increasingly complex separation strategies to perform veri.cation. The motivation for this \nis simple: usually many veri.cation subproblems may be amenable to simple and ef\u00ad.cient veri.cation, \nbut some veri.cation subproblems may require more precise analysis for successful veri.cation. An incremental \nstrategy is a sequence of atomic strategies, which are tried one after another, stopping when one of \nthe atomic strate\u00adgies completely veri.es the program. An atomic strategy can make use of failure information \nfrom the previous atomic strategy applied to the program. We restrict ourselves to a very simple form \nof fail\u00adure information, where the choice operation can restrict attention to individuals that failed \nveri.cation in the previous step. We will il\u00adlustrate this with examples .rst, and later explain how \nthese strategy speci.cations are interpreted. { choose some r : ResultSet(y) } on failure { choose \nsome s : Statement(x) choose some failing r : ResultSet(y) / y == s } on failure { choose some c : \nConnection() choose some failing s : Statement(x) / x == c choose some failing r : ResultSet(y) / y \n== s } The above strategy optimistically .rst attempts to verify usage of each ResultSet independent \nof even the Statement un\u00adderlying the ResultSet. If that fails, it then attempts to ver\u00adify usage of \nResultSets, while tracking usage of the underlying Statement. If that too fails, it then attempts veri.cation \nusing even more context. Note that an incremental strategy may be thought of as a very simple (.xed) \niterative re.nement scheme. For our running exam\u00adple, the very .rst atomic strategy in the sequence above \nsuccessfully veri.es all correct uses of ResultSet. Semantics and Correctness. Note that the language \npresented above is powerful enough to specify partial veri.cation problems, where the checking is done \nonly for the speci.ed subset of objects. This power is useful in some contexts. However, the goal of \na strat\u00adegy is typically to improve the precision and ef.ciency of veri.cation but not affect its correctness. \nIn order for a separation strategy to guarantee correctness, it has to cover all objects of the types \nbeing veri.ed. We later describe how a strategy speci.cation de.nes an instru\u00admented semantics for a \nprogram: every program-state in the stan\u00addard semantics corresponds to a set of instrumented-program-states \nPredicates Intended Meaning x(v) reference variable x points to the object v f ld(v1, v2) .eld f of the \nobject v1 points to the object v2 bv() boolean variable bv has true value bf (v) boolean .eld bf holds \nfor object v site[AS](v) object v was allocated in allocation site AS Table 1: Predicates for partial \nJava semantics. in the instrumented semantics, where an instrumented-program\u00adstate may be roughly thought \nof as a program-state plus a set of objects in the program-state (which are the chosen objects). A strategy \nis said to completely cover a type T if for every program\u00adstate ( in the standard semantics, for every \nobject obj of type T in (, there exists an instrumented-program-state in which obj is a chosen object. \nTheorem 1. A separation strategy that consists only of choice operations with no condition and choice \noperations of the form: chooseallx: T(w1, ,wk )/(wi == zj ) where wi (1 . i . k) is a parameter of the \nconstructor T, and zj is a variable bound by earlier choice operations, completely covers T. 4. SEPARATION \nIn this section, we show how a separation strategy is utilized to decompose a veri.cation problem into \na set of veri.cation subprob\u00adlems. We .rst illustrate how an Easl safety property speci.cation and a \nJava program together can be translated into an analysis prob\u00adlem instance in the parametric analysis \nframework of [17]. We then show how an Easl safety property speci.cation, a Java program, and a separation \nstrategy speci.cation together can be translated into a modi.ed analysis problem instance (corresponding \nto a set of veri.cation subproblems). (This translation provides the semantics of a separation strategy.) \n4.1 Background We now present an overview of .rst order transition systems (FOTS), the formalism underlying \nthe parametric analysis frame\u00adwork of [17]. FOTS may be thought of as an imperative language built around \nan expression sub-language based on .rst-order logic In a FOTS, the state of a program is represented \nusing a .rst\u00adorder logical structure in which each individual corresponds to a heap-allocated object \nand predicates of the structure correspond to properties of heap-allocated objects. De.nition 1. A 2-valued \nlogical structure over a set of predicates P is a pair C. = =U .,t.. where: U . is the universe of the \n2-valued structure. Each individual in U . represents a heap-allocated object.  t. is the interpretation \nfunction mapping predicates to their  truth-value in the structure: for every predicate p . P of arity \nk, t.(p): U .k -{ 0, 1 }. In the following we will use p(v) as shorthand for t.(p)(v) when no confusion \nis likely. Table 1 shows some of the predicates we use to record properties of individuals in this paper. \nA unary predicate x(v) holds when the reference (or pointer) variable x points to the object v. Simi\u00adlarly, \na binary predicate f ld(v1,v2) records the value of a reference (or pointer-valued) .eldfld. A nullary \npredicate bv() records the value of a local boolean variable bv and a unary predicate bf (v) Predicates \nIntended Meaning chosen[x](v) object v was chosen by choice operation for strategy variable x wasChosen[x]() \nsome object was chosen for strategy variable x chosen(v) object v was chosen by some choice operation \nrelevant(v) abstraction-directing predicate recording relevant objects Table 2: Additional predicates \nof the instrumented semantics. records the value of a boolean .eld bf. Finally, a unary predicate site[AS](v) \nrecords the allocation site AS in which an object was allocated. In order to enable interprocedural analysis \nwe explicitly repre\u00adsent stack frames and a corresponding set of predicates following [16]. Since this \ndoes not interfere with the material in this paper, to simplify presentation we do not describe these \npredicates. In this paper, program con.gurations are depicted as directed graphs. Each individual of \nthe universe is drawn as a node. A unary predicate p(o) which holds for a node u is drawn inside the \nnode u. A binary predicate p(u1,u2) which evaluates to 1 is drawn as directed edge from u1 to u2 labelled \nwith the predicate symbol. Example 1. Fig. 5 shows a concrete program con.guration rep\u00adresenting a global \nstate of the program before executing the state\u00adment at line 28. In this con.guration, three String objects \nwere allocated in the heap and are referenced by maxQry, minQry, balancesQry. The con.guration also contains \ntwo Connection objects referenced by con1 and con2, two Statement objects referenced by stmt1 and stmt2, \nand three ResultSet objects referenced by maxRs, rs1, and rs2. Note that the ResultSet referenced by \nmaxRs is closed. The meaning of the predicates relevant(u), chosen[c](u), chosen[s](u), and chosen[r](u) \nwill become clear in the next section.  4.2 Instrumentation For Separation In this section we explain \nhow we translate a Java program, an Easl speci.cation, and a strategy speci.cation into a FOTS. Specif\u00adically, \nthe strategy speci.cation is used to instrument the standard translation of a Java program and Easl speci.cation \ninto a FOTS. (This translation also directly provides a formal semantics for a separation strategy as \na method for non-deterministically choos\u00ading a set of objects during program execution.) We use the pred\u00adicates \nin Table 2 to instrument the semantics. Predicates of the form chosen[x](v), wasChosen[x](), and chosen(v) \nare used to express the separation strategy. The predicate relevant(v) is an abstraction-directing predicate \nthat controls the way in which an object is abstracted. Consider a choice operation chooseallx: T(w1,...,wi) \n/ e(w1,...,wi,z1,...,zk ) Here, we say that the choice operation binds variable x. Variables w1 through \nwi are free variables corresponding to parameters of a call to a constructor for type T, while z1 through \nzk are variables bound by earlier choice operations. In order to model the speci.ed choice operation, \nwe introduce an instrumentation predicate chosen[x](u). The idea is for the predicate chosen[x](u) to \nhold true for exactly the objects that are chosen by the above choice operation. We achieve this by translating \nthe condition e(...) speci.ed for the choice operation into a .rst-order logic formula which is evaluated \non entry to the speci.ed constructor T to compute the value of chosen[x](u) for the newly created object \nu. (Technically, this translation works by converting the free occurrences of a variable zj by occurrences \nof an existentially quanti.ed logical variable Oj that is constrained to satisfy predicate chosen[zj \n](Oj ).) The translation of a choose some x operation is similar, ex\u00adcept that the translation ensures \nthat at most one of the objects that is eligible for selection by the operation is chosen. This is done \nby introducing a second instrumentation predicate wasChosen[x]() that indicates if an object has already \nbeen selected during pro\u00adgram execution for the corresponding choice operation (thus, it is de.ned by \nthe instrumentation formula :O.chosen[x](O)). When a new T object O is constructed, chosen[x](O) is set \nto false if wasChosen[x]() evaluates to true or if the selection formula cor\u00adresponding to the choice \noperation evaluates to false. Otherwise, chosen[x](O) is non-deterministically assigned either true or \nfalse, and wasChosen[x]() is correspondingly updated. Given a simple strategy speci.cation consisting \nof n choice op\u00aderations over variables z1 through zn, we also introduce a unary predicate chosen(O) that \nindicates if an object was chosen by any of the n choice operations: thus, it is de.ned by the instrumentation \nformula chosen[z1 ](O) .\u00b7 \u00b7\u00b7. chosen[zn](O). Finally, the actual checks on objects that verify they satisfy \nthe necessary preconditions when methods are invoked on them are instrumented to do the check only for \nchosen objects. For now, the predicate relevant(u) may be thought of as being equivalent to chosen(u). \nWe will later see that the set of relevant objects includes all the chosen objects and potentially some \nother objects as well. Example 2. The single-choice strategy for JDBC is modelled using predicates chosen[c](u), \nchosen[s](u), and chosen[r](u). Upon entry to the constructor Statement(Connection c), the condition \nof the corresponding choice operation is evaluated and the Statement is chosen if the passed Connection \nis the one for which chosen[c](u) holds. Similarly, the condition for choosing a ResultSet is evaluated \non entry to constructor ResultSet(Statement s). As a result, for each subproblem chosen[c](u) holds for \n(at most) a single Connection compo\u00adnent, and chosen[s](u), chosen[r](u) hold for Statements and ResultSets \nthat are related to the chosen Connection. Part of the instrumented program for this strategy is shown \nin Fig. 6 (For clarity, we use Easl syntax to present the instrumented program). We now brie.y indicate \nhow incremental strategies are handled. The notion of a failed individual is fairly straightforward. \nA single strategy speci.cation produces multiple veri.cation subproblems, each over a set of chosen individuals. \nAn individual is said to be a failed individual if it is a chosen individual of a veri.cation sub\u00adproblem \nthat fails veri.cation. However, we want to utilize simple strategy speci.cations that restrict their \nattention to individuals that failed the previous simple strategy speci.cation. In general, this requires \ninstrumentation that can identify at object-allocation time whether the allocated object corresponds \nto a failed individual in the previous veri.cation step. This is hard to do in a very general way, and \nwe restrict ourselves to allocation-site based identi.cation of failed individuals: thus, if any one \nindividual allocated at an al\u00adlocation site fails veri.cation, then all individuals allocated at that \nsite are treated as failed individuals in the next veri.cation step.  Operational Semantics In a FOTS, \nprogram statements are modelled by actions that spec\u00adify how the statement transforms an incoming logical \nstructure into an outgoing logical structure. This is done primarily by de.ning the values of the predicates \nin the outgoing structure using .rst\u00adorder logic formulae with transitive closure over the incoming struc\u00adture \n[17]. Figure 5: Concrete program con.gurations representing a possible program state (a) at line 28 \nand (b) after execution of statement at line 28 class Connection { class Statement { class ResultSet \n{ ... ... ... Connection() { Statement(Connection c) { ResultSet(Statement s) { if (!wasChosen) { chosen \n= c.chosen chosen = s.chosen; if (?) { closed = false; closed = false ; chosen = true; myConnection \n= c; ownerStmt = s; wasChosen = true; myResultSet = null; } } else } ... chosen = false; ResultSet \nexecuteQuery(String qry) { boolean next() { } if (chosen) if (chosen) closed = false; requires !closed; \nrequires !closed; statements = {}; if (myResultSet != null) } } myResultSet.closed = true; } Statement \ncreateStatement() { myResultSet = new ResultSet(this); if (chosen) return myResultSet; requires !closed; \n} Statement st = new Statement(this); ... statements = statements U { st }; } return st; } ... }  Figure \n6: An instrumented Easl speci.cation for a simpli.ed subset of the JDBC API with single-choice separation \nstrategy. Example 3. Fig. 5(b) shows the effect of the statement maxRs2 = stmt2.executeQuery(maxQry) \nat line 28, where the state\u00adment is applied to the con.guration in Fig. 5. The effect of the statement \nis re.ected by its updates to predicate values. Here, we assume that the choice predicates and the instrumentation \npredicates are updated according to the single-choice strategy of Sec. 3. Since the constructor of the \nnew ResultSet is invoked with a chosen Statement object, the choice condition is satis.ed and the newly \ncreated ResultSet is chosen and made relevant. 4.3 Additional Instrumentation The predicate relevant \nis intended to identify objects that must be modelled precisely for a veri.cation subproblem. The separation \nstrategy speci.cation allows users to identify relevant objects (via choice clauses). An analysis designer, \nor a component library de\u00adsigner, can create separation strategies that re.ect the dependencies that \nexist among component library objects, while an end user can create separation strategies that provide \nmore dependency informa\u00adtion (speci.c to their own program). Currently, however, we do not assume that \nsuch extra dependency information will be available from an end user. Instead, we rely on a more automatic \napproach that considers objects which reach a relevant object as relevant themselves, thus creating a \nnotion of transitive relevance. Transitive relevance causes all objects that are on a path to a relevant \nobject to become relevant as well, thus separating heap paths that may reach a relevant object from heap \npaths that cannot. We achieve this by de.ning the instrumentation predicate relevant(u) to be true iff \nthere is a path from u to some chosen object v (i.e., some object v for which chosen(v) is true). We \nupdate this predi\u00adcate using the techniques of [15]. 5. HETEROGENEOUS ABSTRACTION The essence of our \nseparation-based veri.cation is the following: .rst, a separation strategy is used to choose a set of \nobjects (for a given program trace); second, we utilize specialized abstractions to perform veri.cation \nfor the chosen objects ef.ciently. These specialized abstractions represent the chosen objects much more \nprecisely than the remaining objects. We refer to these abstractions as heterogeneous abstractions as \nthey represent different parts of the heap with different degrees of precision. In this section we describe \nthe abstractions we use for separation-based veri.cation.  Abstract Program Con.gurations The goal \nof an abstraction is to create a .nite representation of a po\u00adtentially unbounded set of 2-valued structures \n(representing heaps) of potentially unbounded size. The abstractions we use are based on 3-valued logic \n[17], which extends boolean logic by introducing a third value 1/2 denoting values that may be 0 or 1. \nDe.nition 2. A 3-valued logical structure over a set of predicates P is a pair C = =U, t. where: U is \nthe universe of the 3-valued structure. An individual in U may represent multiple heap-allocated objects. \n t is the interpretation function mapping predicates to their truth-value in the structure: for every \npredicate p . P of arity k, t(p): U k -{ 0, 1, 1/2 }.  An abstract con.guration may include summary \nnodes, i.e., an indi\u00advidual which corresponds to one or more individuals in a concrete con.guration represented \nby that abstract con.guration. We use a designated unary predicate sm to maintain summary-node informa\u00adtion. \nA summary node u has sm(u)=1/2, indicating that it may represent more than a single individual. As in \n[17], the abstract interpretations we use work by abstracting the set of 2-valued structures that can \narise at a program point by a set of 3-valued structures. However, this can be done in a number of ways \nas shown below. Individual Merging. The basic abstraction primitive used by [17] is that of individual \nmerging: a larger structure s can be safely ap\u00adproximated by a smaller 3-valued structure by merging \nmultiple individuals into one, and by approximating the predicate values ap\u00adpropriately. Given an equivalence \nrelation . on individuals, let s/. denote the structure obtained by merging individuals of s that are \n.-equivalent together. The above primitive induces a function abs1[.] that abstracts a set of 2-valued \nstructures by a set of 3-valued structures, de.ned by abs1 [.](S)= {s/.| s . S}. (Strictly speaking, \nabs1[.](S) retains only a single representative of isomorphic structures, but we ignore the .ne distinction \nbetween isomorphism and equality for the sake of simplicity.) [17] utilizes the equivalence relation \n.A induced by a set of unary predicates A (referred to as the abstraction predicates) de.ned as follows: \no1.Ao2 iff p(o1)= p(o2) for every p . A. Structure Merging. Subsequently, TVLA [11] introduced more aggressive \nabstraction mechanisms based on the idea of merging multiple structures into one. De.ne the union s1 \n. s2 of two struc\u00adtures to be the structure whose universe is the disjoint union of the universes of \ns1 and s2, with the predicate interpretations of s1 and s2 extended appropriately. The union of a set \nof structures S is de.ned similarly. Structures are merged by .rst taking their union, and then merging \nindividuals of the union along the lines indicated previously: de.ne (S) to be (S)/.. * Now, consider \nan equivalence relation . de.ned on structures, indicating which structures must be merged together, \nand an equiv\u00adalence relation . de.ned on individuals. We can now de.ne a parameterized abstraction function \nabs2[., .](S) that .rst applies individual merging to every structure s in S, and then merges to\u00adgether \nthe resulting structures that are .-equivalent. Formally, abs2[., .](S) is de.ned to be: { (C) | C is \nan .-equivalence class of abs1[.](S) } * TVLA utilizes the following . de.nitions: (a) s1 . s2 iff s1 \nand s2 are isomorphic, (b) s1 . s2 iff s1 and s2 have the same values myConnnection  Figure 7: An abstract \nprogram con.guration representing the concrete con.guration of Fig. 5(b). for a speci.ed set B of nullary \nabstraction predicates, (c) s1 . s2 iff s1 and s2 have the same universes (modulo .). TVLA utilizes an \nextra unary predicate active, which indicates if an individual de.nitely exists in the universe or not, \nso that the structure (S) can be used as an abstraction of every structure * in S. Thus, if S is a set \nof 2-valued structures, then the predicate active is true for an individual o in (S) iff the equivalence \nclass * represented by o includes at least one individual from every structure in S. Heterogeneous Abstraction \nSeparation creates the possibility for achieving better ef.ciency by adapting the abstractions to model \nchosen individuals more pre\u00adcisely and the other individuals less precisely. In particular, this can \nbe done by: Adapting individual merging: We can make .ner distinctions between chosen individuals than \nfor unchosen individuals, when we decide which individuals should be merged together. E.g., we can choose \nto use the less expensive allocation-site based merging for unchosen individuals, and more expensive \nvariable-name based merging for chosen individuals.  Adapting structure merging: Similarly, when deciding \nwhich structures should be merged into one, we could choose to treat chosen and unchosen individuals \ndifferently.  Adapting predicate values retained: One could choose to not record the values of certain \npredicates for unchosen individ\u00aduals. While this can reduce the space required to represent a structure, \nthis does not, unlike the preceding techniques, re\u00adduce the number of structures in the abstraction. \nWe will not discuss this in this paper.  We now de.ne a new family of equivalence relations for identify\u00ading \nindividuals to be merged. Consider a quadruple =c, A1,A0 ,A1/2. where c is a unary predicate, and A1 \n, A0, and A1/2 are all sets of unary predicates. The equivalence relation ..c,A1 ,A0 ,A1/2 \u00d8 on in\u00addividuals \nis de.ned by: (c(o1)= c(o2) = 1) !\u00d8p . A1 .p(o1)= p(o2)) . ((c(o1)= c(o2) = 0) !\u00d8p . A0.p(o1)= p(o2)) \n. ((c(o1)= c(o2)=1/2) !\u00d8p . A1/2 .p(o1)= p(o2)) Given a set r of such tuples, we de.ne .r to be ,Er \n., . We similarly de.ne a new criteria for structure merging. Given a unary predicate c, de.ne s1 .c \ns2 iff the substructures of s1 and s2 consisting only of individuals i for which c(i)=1 are isomorphic. \nFor our separation-based veri.cation, we utilize the abstraction induced by the equivalence relations \n..relevant,A,.,A\u00d8 and .relevant, where A is the set of abstraction predicates utilized by the underlying \nseparation-less veri.cation. (In our implementation, this consists of the set of unary predicates). Implementation \nNotes. Our current implementation uses a very close approximation of the individual merging induced by \nthe equiv\u00adalence relation ..relevant,A,.,A\u00d8 as follows: for every predicate p in A, we introduce a new \ninstrumentation predicate pr (o)= p(o) ! relevant(o), and use the set of predicates { pr | p . A } as \nthe set of abstraction predicates. Example 4. Fig. 7 shows an abstract con.guration representing the \nconcrete con.guration of Fig. 5(b), obtained by heterogeneous relevance-based abstraction. Abstract program \ncon.gurations are depicted similarly to concrete con.gurations with an additional rep\u00adresentation of \nsummary nodes as nodes with double-line boundaries, and a 1/2-valued binary predicate as a dashed edge. \nAll individ\u00aduals for which relevant holds are abstracted by the values of the predicates in A1. Other \nindividuals, for which relevant does not hold, are merged into a single summary node since A0 = =. In \npar\u00adticular, this abstract con.guration abstracts away the current state of objects related to Connection \ncon1, including the state of Statement stmt1. In the .gure, we use ... =1/2 instead of listing all predicates \nthat have 1/2 value for the summary node. If we had used a homogeneous abstraction, the non-relevant \nobjects would have been abstracted using the same set of predicates as the relevant objects (A1), thus \nkeeping the objects related to the Connection referenced by con1 with the same precision, and cost, as \nthe ones related to Connection referenced by con2. The ability to treat these structurally-similar objects \nvery differently during analysis is a key to obtaining good results with our method.  Abstract Semantics \nWe will now brie.y describe the abstract semantics ( transfer func\u00adtions ) we utilize for program statements. \nA key idea underlying [17] is that the actions de.ning a standard operational semantics for a program \nstatement (as a transformer of 2-valued structures) also de.ne a corresponding abstract semantics for \nthe statement (as a transformer of 3-valued structures). This abstract semantics is simply obtained by \nreinterpreting logical for\u00admulae using a 3-valued logic semantics and serves as the basis for an abstract \ninterpretation. However, [17] also presents techniques, such as materialization, that improve the precision \nof such an ab\u00adstract semantics. We directly utilize the implementation of these ideas available in TVLA. \nWe described earlier (see Sec. 4.2) how we utilize instrumentation predicates to identify relevant objects. \nWe currently also utilize instrumentation predicates to achieve a heterogeneous abstraction. We use the \ntechniques in [15] for automatically generating, from the instrumentation formula, an instrumented abstract \nsemantics for statements to update the values of these instrumentation predicates. 6. PROTOTYPE IMPLEMENTATION \nWe have implemented a prototype of the separation veri.cation engine using TVLA [11]. To translate Java \nprograms and their spec\u00adi.cations to TVP (TVLA input language) we have extended an ex\u00adisting Soot-based \n[20] front-end for Java developed by R. Manevich. The implementation emulates heterogeneous abstraction \nusing in\u00adstrumentation predicates in TVLA, which adds some overhead. We believe that a native implementation \nof heterogeneous abstraction will yield better performance. Program Description Mode Line No. Space \n(MB) Time (Sec) Rep. Err. Act. Err. ISPath inp. streams / IOStreams vanilla single sim 71 9.17 2.51 3.94 \n145.5 17.4 12.3 0 0 0 0 Input Stream5 inp. streams holders / IOStreams vanilla single sim 64 16.35 17.65 \n21.35 439 240 202 1 0 0 0 Input Stream5b inp. streams holders err /IOStreams vanilla single sim 64 13.72 \n19.71 22.74 343 279 243 1 1 1 1 Input Stream6 inp. streams holders / IOStreams vanilla single sim 66 \n37.17 13.91 12.14 1344 69.4 51.3 1 1 1 0 JDBC Example extended example / JDBC vanilla single multi inc \n149 33.43 28.71 16 12.5 2500 1090 7340 3579 1 1 1 1 1 JDBC Example .xed extended example / JDBC vanilla \nsingle multi inc 153 32.8 28.8 29.5 25.7 2500 1090 7500 3339 0 0 0 0 0 db SpecJVM98 db / IOStreams vanilla \nsingle sim 644 89.25 90 91.17 10454 2500 1496 0 0 0 0 Kernel Bench.1 Collections benchmark / CMP vanilla \nsingle sim multi inc 82 42.23 13.15 13.84 14.45 14.45 8321 657 255 4552 960 1 1 1 1 1 1 Kernel Bench.3 \nCollections benchmark / CMP vanilla single sim multi inc 146 - 107.8 128.7 119 106 - 12098 7588 69631 \n12881 - 1 1 1 1 1 SQL Executor JDBC framework / JDBC vanilla single multi inc 1297 - 80.59 72.64 42.68 \n- 5028 4919 412 - 0 0 0 0 Table 3: Analysis results and cost for the benchmark programs. We applied \nour framework to verify various speci.cations for a number of example programs. Our speci.cations include \ncorrect usage of JDBC, IO streams, Java collections and iterators, and ad\u00additional small but interesting \nspeci.cations. The experiments were performed on a machine with a 1 Ghz Pentium 4 processor, 1 Gb2. Results \nare shown in Table 3. The column titled mode shows the analysis mode for each line in the table. Veri.cation \nwith TVLA with no separation is referred to as vanilla mode. Rep. Err. shows the number of reported errors, \nwhile Act. Err. shows the number of actual errors. When counting errors, we count all errors reported \nat the same program location as a single error. Our implementation allows control over which subproblems \nare veri.ed simultaneously. This allows veri.cation of subproblems re\u00adlated to one (or more) allocation-sites \nseparately from other subprob\u00adlems, reducing the maximal memory footprint of the veri.cation. The measurements \nin Table 3 correspond to this non-simultaneous mode. The space measurement shown in Table 3 for separation \nmodes (single, multi, incremental) is the maximal space required for analyzing a single set of subproblems. \nThe time is the accumulated time for analyzing all subproblems. The table also shows mea\u00adsurements for \nsimultaneous veri.cation of all subproblems using single-mode (sim mode). For the JDBC example, the simultaneous \nsingle-choice mode is identical to the non-simultaneous mode. 2SQLExecutor analyzed on a machine with \na 2.79Ghz processor. ISPath is a simple correct program manipulating input streams. InputStream5 is a \nheapful example program that manipulates input\u00adstreams in holder objects at arbitrary depth of the heap. \nFor this program, the vanilla version produces a false-alarm that is avoided by the separation-based \nanalysis. This is due to the use of tran\u00adsitive relevance which makes the separation-based analysis more \nprecise (for the relevant objects). Generally, since the separation\u00adbased analysis is more focused, it \nmay allow using a more precise abstraction than the one that could be used when applied uniformly. InputStream5b \nis an erroneous version of InputStream5 containing a single error. InputStream6 is another variation \nof InputStream5. JDBCExample is an extended version of the running example that uses 5 Connections. The \nhigh running-time result for incremen\u00adtal mode in this case is affected by the fact that there is small \nnumber of Statements (1) and ResultSets (up to 3) associated with each Connection. db is a program from \nSpecJVM98 performing multiple database functions on a memory resident database. KernelBenchmark1 and \nKernelBenchmark3 are part of a bench\u00admark suite for testing Collections and Iterators used in [14]. SQLEx\u00adecutor \nis an open source JDBC framework. For this benchmark, vanilla veri.cation failed to terminate after more \nthan 5 hours, but incremental-mode successfully veri.ed the program in 412 seconds. This is a result \nof the correct and relatively simple usage of JDBC objects in this benchmark. In some benchmarks separation \ngained an overall performance increase, while in others the total veri.cation time in some modes was \nlarger than the time for vanilla-mode veri.cation. In all cases, however, the average time for verifying \na single subproblem was signi.cantly lower than the time required for vanilla veri.cation. Thus, separation \nmay be useful for answering on-demand queries when one is only interested in checking whether an object \n(or a set of correlated objects) can produce an error. E.g., while the total time for multi-mode and \nincremental-mode in the JDBC example was larger than the time required for vanilla-mode, the average \ntime for verifying each subproblem was approximately 670 seconds. One interesting future direction is \nto exploit separation for in\u00adcreasing performance by parallelizing veri.cation of subproblems.  7. EXTENSIONS \nAND FUTURE WORK We have experimented with two classes of iterative re.nement schemes for approximating \nthe set of relevant objects for a sub\u00adproblem: the .rst iteratively identi.es more relevant program vari\u00adables \nand turns objects pointed-to by these variables relevant; the second iteratively identi.es relevant allocation \nsites and turns ob\u00adjects allocated at these sites relevant. Both classes of our re.nement schemes are \nguaranteed to terminate (with all objects being relevant in the worst case), but are not guaranteed to \nyield a successful veri.\u00adcation. Our initial experience indicates that these techniques work well for \nrelatively small examples. 8. ACKNOWLEDGEMENTS The authors wish to thank John Field and Mooly Sagiv \nfor their insightful comments, which helped improve the paper, and Roman Manevich for his considerable \ncontribution to the implementation.  9. REFERENCES [1] K. Ashcraft and D. Engler. Using programmer-written \ncompiler extensions to catch security holes. In Proc. IEEE Symp. on Security and Privacy, Oakland, CA, \nMay 2002. [2] T. Ball and S. K. Rajamani. Automatically validating temporal safety properties of interfaces. \nIn SPIN 2001, LNCS 2057, pages 103 122, 2001. [3] J. Corbett, M. Dwyer, J. Hatcliff, C. Pasareanu, Robby, \nS. Laubach, and H. Zheng. Bandera: Extracting .nite-state models from Java source code. In Proc. Intl. \nConf. on Software Eng., pages 439 448, June 2000. [4] J. Corbett, M. Dwyer, J. Hatcliff, and Robby. Expressing \ncheckable properties of dynamic systems: the bandera speci.cation language. STTT, 4(1):34 56, Oct. 2002. \n [5] M. Das, S. Lerner, and M. Seigle. ESP: Path-sensitive program veri.cation in polynomial time. In \nProc. Conf. on Prog. Lang. Design and Impl., pages 57 68, June 2002. [6] R. DeLine and M. F\u00e4hndrich. \nEnforcing high-level protocols in low-level software. In Proc. Conf. on Prog. Lang. Design and Impl., \npages 59 69, June 2001. [7] J. Field, D. Goyal, G. Ramalingam, and E. Yahav. Typestate veri.cation: Abstraction \ntechniques and complexity results. In Proc. of SAS 03, volume 2694 of LNCS, pages 439 462. Springer, \nJune 2003. [8] C. Flanagan, K. R. M. Leino, M. Lillibridge, G. Nelson, J. B. Saxe, and R. Stata. Extended \nstatic checking for java. In Proc. Conf. on Prog. Lang. Design and Impl., pages 234 245, Berlin, June \n2002. [9] J. S. Foster, T. Terauchi, and A. Aiken. Flow-sensitive type quali.ers. In Proc. Conf. on Prog. \nLang. Design and Impl., pages 1 12, Berlin, June 2002. [10] S. Guyer and C. Lin. Client-driven pointer \nanalysis. In Proc. of SAS 03, volume 2694 of LNCS, pages 214 236, June 2003. [11] T. Lev-Ami and M. Sagiv. \nTVLA: A framework for Kleene based static analysis. In Proc. Static Analysis Symp., volume 1824 of LNCS, \npages 280 301. Springer-Verlag, 2000. [12] K. L. McMillan. Veri.cation of in.nite state systems by compositional \nmodel checking. In Proc. of CHARME 99, volume 1703 of LNCS, pages 219 237, 1999. [13] Microsoft Research. \nThe SLAM project. http://research.microsoft.com/slam/, 2001. [14] G. Ramalingam, A. Warshavsky, J. Field, \nD. Goyal, and M. Sagiv. Deriving specialized program analyses for certifying component-client conformance. \nIn Proc. Conf. on Prog. Lang. Design and Impl., volume 37, 5, pages 83 94, June 2002. [15] T. Reps, \nM. Sagiv, and A. Loginov. Finite differencing of logical formulas for static analysis. In In Proc. European \nSymp. on Programming, 2003. [16] N. Rinetzky and M. Sagiv. Interprocedural shape analysis for recursive \nprograms. LNCS, 2027:133 149, 2001. [17] M. Sagiv, T. Reps, and R. Wilhelm. Parametric shape analysis \nvia 3-valued logic. ACM Trans. on Prog. Lang. and Systems (TOPLAS), 24(3):217 298, 2002. [18] R. Shaham, \nE. Yahav, E. Kolodner, and M. Sagiv. Establishing local temporal heap safety properties with applications \nto compile-time memory management. In Proc. of SAS 03, volume 2694 of LNCS, pages 483 503, June 2003. \n[19] R. E. Strom and S. Yemini. Typestate: A programming language concept for enhancing software reliability. \nIEEE Trans. Software Eng., 12(1):157 171, 1986. [20] R. Vall\u00e9e-Rai, L. Hendren, V. Sundaresan, P. Lam, \nE. Gagnon, and P. Co. Soot -a java optimization framework. In Proc. of CASCON 1999, pages 125 135, 1999. \n [21] S. White, M. Fisher, R. Cattell, G. Hamilton, and M. Hapner. JDBC API tutorial and reference. Addison-Wesley, \n1999.  \n\t\t\t", "proc_id": "996841", "abstract": "In this paper, we show how <i>separation</i> (decomposing a verification problem into a collection of verification subproblems) can be used to improve the efficiency and precision of verification of safety properties. We present a simple language for specifying <i>separation strategies</i> for decomposing a single verification problem into a set of subproblems. (The strategy specification is distinct from the safety property specification and is specified separately.) We present a general framework of <i>heterogeneous abstraction</i> that allows different parts of the heap to be abstracted using different degrees of precision at different points during the analysis. We show how the goals of separation (i.e., more efficient verification) can be realized by first using a separation strategy to transform (instrument) a verification problem instance (consisting of a safety property specification and an input program), and by then utilizing heterogeneous abstraction during the verification of the transformed verification problem.", "authors": [{"name": "Eran Yahav", "author_profile_id": "81100285431", "affiliation": "Tel-Aviv University, Tel-Aviv, Israel", "person_id": "PP35027073", "email_address": "", "orcid_id": ""}, {"name": "G. Ramalingam", "author_profile_id": "81100519054", "affiliation": "IBM T.J. Watson Research Center, Yorktown Heights, NY", "person_id": "PP31045870", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/996841.996846", "year": "2004", "article_id": "996846", "conference": "PLDI", "title": "Verifying safety properties using separation and heterogeneous abstractions", "url": "http://dl.acm.org/citation.cfm?id=996846"}