{"article_publication_date": "06-09-2004", "fulltext": "\n Dynamic Path-Based Software Watermarking* C. Collberg E. Carter S. Debray A. Huntwork J. Kececioglu \nC. Linn M. Stepp Department of Computer Science University of Arizona Tucson, AZ 85721, USA {collberg,ecarter,debray,ash,kece,linnc,steppm}@cs.arizona.edu \nCategories and Subject Descriptors K.5.1 [Legal Aspects of Computing]: Hardware/Soft\u00adware Protection \nProprietary rights General Terms Languages; Legal aspects,Security Keywords Software piracy,Software \nprotection,Watermarking ABSTRACT Software watermarking is a tool used to combat software piracy by embedding \nidentifying information into a pro\u00adgram. Most existing proposals for software watermarking have the shortcoming \nthat the mark can be destroyed via fairly straightforward semantics-preserving code transforma\u00adtions. \nThis paper introduces path-based watermarking,a new approach to software watermarking based on the dy\u00adnamic \nbranching behavior of programs. The advantage of this technique is that error-correcting and tamper-proo.ng \ntechniques canbe usedto make path-basedwatermarks re\u00adsilient against a wide variety of attacks. Experimental \nre\u00adsults,usingbothJavabytecodeand IA-32nativecode, indi\u00adcate that even relatively large watermarks can \nbe embedded into programs at modest cost. 1. INTRODUCTION It is estimated that fully 40% of the software \nin use around the world is pirated,with retail value of over $13 billion in 2002 [2]. It is therefore \ncrucially important to be able to protect software intellectual property rights. This means * The work \nof C. Collberg,E. Carter,A. Huntwork,and M. Stepp was supported in part by the National Science Foundation \nunder grant CCR-0073483 and the Air Force Research Lab under contract F33615-02-C-1146. The work of S. \nDebray andC. Linnwas supportedinpartby the National Science Foundation under grants EIA-0080123 and CCR-0113633. \nPermission to make digital or hard copies of all or part of this work for personal or classroom use is \ngranted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page. To copy otherwise, to republish, \nto post on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. PLDI \n04, June 9 11, 2004, Washington, DC, USA. Copyright 2004 ACM 1-58113-807-5/04/0006 ...$5.00. that the \nintellectual property owner of a piece of software should be able to demonstrate that ownership if called \nupon to do so; and in case of suspected piracy,it should be possible to trace a piece of software back \nto the person who originally obtained it prior to illegal distribution. Both of these goals can be met \nusing software watermarks. A software watermark is,in essence,an identi.er that is embedded into a piece \nof software in order to encode some identifying information. The utility of a software watermark depends \non its resilience to semantics-preserving code trans\u00adformations: if it iseasytodestroy awatermark viasimple \ntransformations,for example,by renaming identi.ers in the program,then it has relatively limited utility. \nIt is generally agreed that a su.ciently determined attacker will eventually be able to defeat any watermark. \nThe goal,then,is to de\u00adsign watermarking techniques that are expensive enough to break in time,e.ort,or \nresources that for most at\u00adtackers,breaking them isn t worth the trouble. While a number of researchers \nhave proposed schemes for software watermarking [6,8,9,17,20],most of these are not very di.cult to break \n(see Section 6). For example, watermarks that rely on static code properties,such as basic block ordering \n[9] or register interference [17] can be defeated using straightforward binary optimizers [10,18]; watermarks \nthat use the topology of dynamically constructed data [6] can be foiled via code obfuscations that modify \nthe pointer topology of such structures. The primary contribution of this paper is a new approach to \nsoftware watermarking, path-based watermarking,which embeds thewatermark in theruntime branch structureof \nthe program. The idea is based on the intuition that the branches executed by a program are an essential \naspect of its computation and part of what makes the program unique. However,an obvious drawback is that \nthe branch struc\u00adture of a program can be modi.ed quite extensively without a.ecting program semantics,using \nwell-known transforma\u00adtions such as basic block reordering,branch chaining (where the target of a branch \ninstruction is itself a branch to some other location),loop unrolling,etc. In order for a path\u00adbased \nwatermark to be resilient against such transforma\u00adtions,we must be able to either cause any such transforma\u00adtion \nto change the program semantics,or devise embedding techniques such that the watermark can survive such \ntrans\u00adformations. As we will see,path-based watermarking lends itself well to error-correction and tamper-proo.ng \nmore so than most previously proposed watermarking schemes. Fi\u00adnally,since branches are ubiquitous in \nreal programs,path\u00adbased watermarks are less likely to be susceptible to statis\u00adtical attacks. The remainder \nof this paper is organized as follows. Sec\u00ad . . . . int main ( int argc ) {if (argc == 3) printf ( secret \n\\n ) return 0; } . . int main ( int argc ) {int a= 1,b=0; if (argc == 3) {if (b==0) a =0; if (b!=0) \na=0; if (b==0) a =0; if (b!=0) a=0; if (b==0) a =0; if (b!=0) a=0; if (b!=0) a=0; if (b==0) a =0; printf \n( secret \\n ) }return 0; } . . (a) Original program. (b) A trivial embedding of the bit-string 01010110 \nFigure 1: A simple example of path-based watermark embedding. tion 2 gives some background on software \nwatermarking and describes the basic idea behind path-based watermarking. Section 3 discusses how path-based \nwatermarking can be ap\u00adplied to Java bytecode,and how error correcting codes can be used to protect against \nattacks on such watermarks. Sec\u00adtion 4 discusses the application of path-based watermarking to IA-32 \nexecutables using a very di.erent approach called branch functions,and describes how the resulting code \ncan be tamper-proofed. Section 5 gives experimental evaluations of our approach. Section 6 discusses \nrelated work. Section 7concludes.  2. PATH-BASED WATERMARKS Software watermarking protocols are chie.y \nclassi.ed along four axes: static/dynamic: In a static algorithm the watermark rec\u00adognizer directly examines \nthe code or data segments of the executable program. In contrast,a recognizer for a dynamic algorithm \nwill execute the watermarked pro\u00adgram on a particular (secret) input sequence and then extract the watermark \nfrom the state of the program at this point. watermark/.ngerprint: In apuresoftwarewatermark\u00ading algorithm \nthe recognizer returns a value represent\u00ading the likelihood that the mark is present. In a .n\u00adgerprinting \nalgorithm the recognizer returns the mark itself (a number) which can be di.erent for every dis\u00adtributed \ncopy of the program. blind/informed: In a blind watermarking algorithm the recognizer is given the watermarked \nprogram and the watermark key as input. In an informed algorithm the recognizer also has access to the \nunwatermarked program and/or the watermark itself. embedding technique: Typical software watermarking \nal\u00adgorithms embed the marks by 1. reordering parts of the code where such reordering can be shown to \nbe semantics preserving; 2. inserting new (non-functional or never executed) code that encodes a watermark \nnumber;  3. manipulating instruction frequencies. In this paper we will describe a new approach to soft\u00adware \nwatermarking, path-based watermarking,where the ba\u00adsicideaistoembed themarkin the branchingstructure \nof the program. This has several interesting consequences. First,the branches that a program takes are \nan essential part of what makes the program unique. This makes branches inherently di.cult to change \nor remove,making path-based watermarks resilient to many distortive attacks. Second, branches are inherently \nbinary in nature (they are either taken or not taken),making it easy to embed a bit-string. Third,as \nwe will see,path-based watermarking lends it\u00adself well to error-correction and tamper-proo.ng. Fourth, \nbranches are ubiquitous in real programs,hopefully making path-based marks invulnerable to statistical \nattacks. We will present two realizations of this basic idea,one for Java bytecode and one for IA-32 \nnative executables. For IA-32 code we tamper-proof the watermark branches, and for Java bytecode we use \nerror-correcting codes to in\u00adcrease resilience to attack. Both our implementations are dynamic blind \n.ngerprinting techniques. Thatis,(1)every distributed copy of a program encodes a unique integer; (2) \nonly the watermarked program itself is used during recog\u00adnition; and (3) during recognition the program \nis executed with a special input sequence. Figure 1 illustrates one possible realization of a basic path\u00adbased \nwatermarking technique. Figure 1(a) shows the origi\u00adnal program,and Figure 1(b) the code after bogus \nbranches have been inserted to embed the watermark w = 01010110. The secret input to the program,in this \ncase,is the number of arguments it is given: if it is invoked with three argu\u00adments (argc = 3),the watermark \ncode is executed. This is obviously a very simple example embedding that is trivial to break: a simple \nattack would be,for example,to randomly change the tests so that the branch and fall-through cases are \n.ipped. We can address the issue of resilience against semantics\u00adpreserving code transformations in a \nnumber of di.erent ways,including more sophisticated embedding techniques and tamper-proo.ng of the code. \nThese are discussed in more detail in the next two sections. . . . I0,I1,... . . w ; =00112 1 . . w = \n111100102 . . . ;. w=11002 . 2 . void main() { C B @. @. A . . int a=25,b=10,u=0,x=0x1a,c=8; . . . while((a%b)!=0) \n{ . . int t = b % a; Trace Information . . . b = a; a = t; Location Variables . . if (t==a) u++;  \nvoid main() {. abt @ . D @. if (t==a) u++; . int a = 25,b = 10; B1 2510 if (a==10) u++; B1:while((a \n% b) != 0) { B2 2510 if (a==10) u++; B2: int tmp = b % a; . . B3 102510 . } b = a; . . B1 1025 \n. for(int i=0; i<c; i++, x>>=1) a = tmp; . B2 1025 . if ((x&#38;1)==1) x|=1; B3: . . B3 5105 . println(b); \n} . } . B4:println(b); B1 510 . . . } B2 510 . . . B3 10510 . . . B1 105 . . I0,I1,... . B4 105 \n. 000110000000000011011 Figure 2: Overview of the embedding and recognition of a watermark w in aJavaprogram \n 3. WATERMARKING JAVA BYTECODE We have implemented path-based watermarking for Java bytecode within the \nSandMark [5] software protection re\u00adsearch framework. It can be downloaded from sandmark. cs.arizona.edu. \nIt is impossible to prevent code (or branch instruction) in\u00adsertion transformations in Java bytecode.1 \nInstead,the ro\u00adbustness of our implementation is the result of the dynamic nature of the algorithm,and \nour use of error correction and redundant insertion of the watermark. Our implementation consists of \nthree phases. In the trac\u00ading phase,the dynamic behavior of the program is deter\u00admined by tracing its \nexecution path on a particular input sequence (the secret watermarking key). In the embedding phase,a \nwatermark number is embedded in the input code by modifying the sequence of branches taken and not taken \non the secret input sequence. In the recognition phase,the program is traced again (using the same secret \ninput),and the branch sequence is checked for the watermark. Figure 2 illustrates the watermarking process. \nIn @ we Asplit the watermark number into two pieces. In B @ the orig\u00adinal program is executed with a \nspecial input sequence (the watermark key) in tracing mode. In C @ the watermark pieces are inserted \ninto the original program in the form of added branches. In D @ the watermarked program is executed with \nthe special input sequence,resulting in a trace that will con\u00adtain the watermark pieces,in the form of \nbranches that are taken and not taken in a particular pattern. We will next discuss these steps in detail. \n3.1 Tracing In the tracing phase,we instrument the input program to write to a .le the sequence of basic \nblocks it executes. At each trace point we also store the value of every local variable and every static \nand instance .eld of the containing class. We then execute the instrumented program with the secret input \nsequence I = I0,I1,...,In. The secret input 1In particular,using Java s subroutine instructions jsr and \nret to implement the native code branch function scheme presented in Section 4 is not possible. The reason \nis that bytecode return addresses are a primitive type and cannot be used in any computation. Furthermore,the \nJava byte\u00adcode veri.er requires that subroutines have a unique entry point and exit point. can consist \nof .le IO,user interaction through a graphical user interface,packets sent or received over a network,etc. \nThe only restriction is that the trace be reproducible during recognition. The trace information collected \nfrom a program that computes the greatest common divisor of 25 and 10 is shown in Figure 2. This trace \naids code generation and is used to .nd ap\u00adpropriate insertion positions in the embedding phase. For \npurposes of embedding and recognition,we de.ne the bit\u00adstring corresponding to a particular trace. There \nare many possible ways of doing this. For example,the binary rep\u00adresentation of the address of the .rst \ninstruction in every basic block could be written down. However,an attacker could change many of the \nbits in the resulting string simply by adding no-ops to the watermarked application. Alter\u00adnatively,the \nbit-string could be formed by looking at every branch instruction of the form if P goto Q else goto R \nand writing down 0 if P is true and 1 otherwise. However,an attacker can toggle bits by negating the \nP and exchanging Q and R. In order to survive these and other attacks that modify static program characteristics,we \nhave chosen an algorithm that uses the dynamic behavior of branches to generate bits. We de.ne the bit-string \ncorresponding to a trace as follows. For each conditional branch instruction i that occurs in the trace,we \n.nd its .rst occurrence,and .nd the block j that immediately follows that occurrence in the trace. Then \nwe decode the trace into a string of bits by scanning the trace from beginning to end and writing down \na 0 whenever a conditional branch is immediately followed by the same in\u00adstruction by which it was .rst \nfollowed,and a 1 otherwise. The resulting bit-string does not change if the input code is reordered,if \nbranch senses are inverted,or if instructions other than conditional branches are inserted or deleted. \nAd\u00addition and removal of branches has only local e.ect on the resulting bit-string.  3.2 Embedding The \nembedding phase adds branches to the input code so that the watermark number W can be extracted from \nthe bit-string corresponding to a trace of the basic blocks exe\u00adcuted on the input sequence I.To increase \nthe stealth of large watermark embeddings we split the mark into multi\u00adple pieces which are spread over \nthe program. To increase W = 5mod p1p2 5 =5 @@ @ W =17 AW = 7mod p1p3 Bp1p2 +7 =13 Cinsert into program \n.. . W = 2mod p2p3 p1p2 + p1p3 +2 = 18 Figure 3: Splitting the watermark value W = 17 via the Generalized \nChinese Remainder Theorem,with p1 =2,p2 =3,p3 =5 robustness we make the pieces redundant so that .nding \na subset of them will be enough to extract the watermark. The embedding phase consists of two steps. \nIn the .rst step,the watermark value is turned into a set of values to be embedded into the program. \nIn the second step,this set of values is embedded into the program in the form of additional branch instructions \nand other code. The process of turning W into a set of values to be em\u00adbedded into the program consists \nof several steps,illustrated with an example in Figure 3: 1. Let p1,...,pr be pairwise relatively prime,where \nW< Q r r(r-1) pk. W is split into up to pieces,each k=1 2 piece being of the form W = xk mod pik pjk \n,where 0 = xk <pik pjk Thisisstep A . @ in Figure 3. The Gen\u00aderalized Chinese Remainder Theorem [14] \nallows W to be reconstructed from these statements in a straight\u00adforward manner,since the p s are pairwise \nrelatively prime. 2. Each statement W = xk mod pik pjk is turned into a single integer by an enumeration \nscheme. In our scheme, ik-1rjk-1 XX X wk = xk + pnpm + pik pm. n=1 m=n+1 m=1 @. This is step B @,each \npiece wk is put through a block cipher. This step enables us to make randomness assumptions about any \ncorrupted data when decoding. 3. In step C We next insert code that causes the bit-string correspond\u00ading \nto the trace to contain each piece of the watermark. To prevent pattern matching attacks,several methods \nof gen\u00aderating code should be available. For example,code could be located so as to supplement bit-strings \nalready occurring in the program. For simplicity,our current implementation inserts code that generates \nan entire watermark piece. We insert code for each piece in a random location weighted inversely with \nrespect to its frequency in the trace. Thus,code is less likely to be inserted in program hotspots than \nin infrequently executed code. We generate two types of code to insert bits into the input code s bit-string. \nThe .rst is based on loops,and the second is based on simple tests using variable values collected as \npart of the trace. 3.2.1 Loop Code Generation Given a watermark piece wk,this technique generates a loop \nwith a body that contains a conditional branch. The code generator generates a prologue to the loop and \nloop body code that causes the inner branch to succeed and fail in the order of the bits of wk. For example,the \nfollowing code is generated to insert the bits 0101 into the input code: . . int bits = 0xa; int counter \n= 5; int j=0; for( int i=0; i <counter ; i++,bits >>=1) if (( bits &#38; 1)==1) j++; if ( PF ) live \nvar+=j ; . . Because the least signi.cant bit of 0xa is 0,the test inside the loop fails,thus indicating \nthat future failures of this test will produce a 0 and future successes of this test will produce a 1. \nThe remaining bits of 0xa in order from least to most signi.cant are 0,1,0,1,which causes the test inside \nthe loop to fail,then succeed,then fail,and .nally succeed. This test result pattern generates the desired \nbits 0101. This code generator inserts approximately 60 bytes of instructions per 64 bits of input. The \nexpression PF represents an opaquely false predi\u00adcate chosen from SandMark s Opaque Predicate Library \n(OPL). An opaque predicate [7] is a boolean-valued expres\u00adsion whose value (always-true,always-false,or \nsometimes\u00adtrue-sometimes-false) is di.cult for an adversary to deter\u00admine. For example,the predicate \nx(x- 1) = 0(mod 2) is true for all values of x. The opaque predicate makes it di.\u00adcult to determine through \nstatic analysis that the generated loop has no semantic e.ect on the program.  3.2.2 Condition Code \nGeneration A second code generation technique inserts sequences of predicates and branches at locations \nthat are executed mul\u00adtiple times on the secret input sequence. The .rst execution of the inserted code \non the input sequence identi.es which branch direction should generate which bit,and the remain\u00ading executions \ngenerate sequences of bits. Our embedder generates code so that at least one of the executions after \nthe priming execution generates the desired bit-string. Ideally,we would like the conditional branches \nwe insert to look inconspicuous so that they are less obvious targets for an attacker. To accomplish \nthis,we base our predicates on existing program variables. This is the purpose of saving variable values \nduring tracing. By examining the values of variables in the program,we can generate predicates that will \nbe true or false at a particular point of the program as it is executed with the secret input sequence. \nIn addition,for any set of predicates we determine to be true at a particular point in the program,we \ncan logically AND them together to produce compound conditions that will also be true. Thus we can construct \narbitrarily complex conditional statements using existing program variables,making it di.cult for an \nattacker to know that these statements are safe to remove while preserving correctness. It is possible \nthat some of the variable values may be environment dependent. For example,the value of a vari\u00adable could \nrepresent the current time or the process ID. In this case,the generated code would not generate the \ndesired branching pattern during recognition. We accept that possi\u00adbility and assume that it will not \nhappen frequently enough to destroy the watermark. The frequency of this kind of fault  5 W = 5mod p1p2 \n13 @W = 7mod p1p3 @ @ 5modp1p2 7modp1p3 @ C A B D W =17 mod p1p2p3 . . . . 17 W = 1mod p2p3 0 W = 0mod \np1p2 Figure 4: Re-combining the watermark value W =17,with p1 =2,p2 =3,p3 =5 is likely to be less than \nthe frequency of attacks against the watermark pieces. As an example,consider a trace that indicates \nthat a cer\u00adtain location is executed twice on the secret input sequence. Just before the .rst execution, \na = b and c = d,and just before the second execution, a= b and c =.d.The following code would be generated \nto produce the string 1010: . . int tmp = 0; if( c == d ) tmp++; if( a == b ) tmp++; if( c == d ) tmp++; \nif( a == b ) tmp++; if(PF ) live var += tmp; . . To prevent an optimizer from removing the inserted \ncode, we add a never executed assignment to a variable that is live at the the point of insertion.  \n 3.3 Recognition The recognition phase collects a trace of the input pro\u00adgram s execution on the secret \ninput I and attempts to lo\u00adcate and to recombine pieces of the watermark in the corre\u00adsponding bitstring. \nVarious attacks (such as inserting bogus branches or reordering non-dependent branches) may have distorted \nthe trace bits. However,because the watermark was split into many redundant pieces,it is enough for us \nto .nd a subset of pieces that have not been perturbed. The decoding algorithm is composed of three steps,illustrated \nwith an example in Figure 4. First,the bit-string b0b1 ...bn is split into a set of .xed-size blocks \nB0 = b0 ...b63,B1 = b1 ...b64,.... These blocks are decrypted using the same cryptosystem as in the embedding \nprocess. Finally,the resulting 64-bit blocks B0 d = dk(B0),B1 d = dk(B1) ... are passed to an algorithm \nthat attempts to .nd a group of blocks that agree on the watermark. In step A @of Figure 4,we invert \nour enumeration scheme to turn these 64-bit blocks into statements about W of the form W = xk mod pik \npjk . Some of these blocks may have errors in them as a result of attacks (such as 18 in Figure 3 being \nchanged to 17 in Figure 4),and there will be a very large number of blocks that have nothing to do with \nthe wa\u00adtermark (such as,in the .gure,the value 0). The remaining steps of the recombination algorithm \nattempt to determine which blocks to use for reconstructing the watermark. Sincethe tracecan potentiallybevery \nlong,it is helpful to reduce the number of statements to consider. To this end,we hold a vote on the \nvalue of W mod pi for each i. If there is a clear winner (which we de.ne as the .rst-place vote-getter \nbeing strictly greater than twice second-place), this winner is presumed to be the value of W mod pi,and \nall statements contradicting this are removed from considera\u00adtion. This step has been empirically observed \nto greatly im\u00adprove the average-case running time of the algorithm,while having a negligible e.ect on \nthe probability of success. Among the various pairs of statements,some are inconsis\u00adtent,some are consistent \nbecause the x s agree mod pi for some i,and some are consistent by the Chinese Remainder Theorem since \nthe 4 pi s referred to are all distinct and the pi s are pairwise relatively prime. The gist of the algorithm \nis that,if the p s are large,it is unlikely for statements about W to agree mod pi at random. Therefore,statements \nthat do agree mod pi are likely to be ones that were inserted during the embedding of the watermark. \nLet V = {v0,v1,...,vm} be the set of statements on W we are given. In step B @,we construct two graphs,Gand \nH, on V. (Figure 4 only shows G.) Two vertices are adjacent in G i. they are inconsistent. Two vertices \nare adjacent in H i. they are consistent because the x s agree mod pi for some i,not if they are consistent \nby the Chinese Remainder Theorem. For step @,we initialize U := \u00d8 and repeat the C following steps until \nG has no edges: 1. Let v be some vertex in the set V -U of maximum degree in H. Thisvertexispresumedtobeatrue \nstatement about W. 2. Let S be the set of v s neighbors in G.Set G := G-S, H := H -S,and U := U .{v}. \n Once G has no more edges,we have a set of statements about W that are consistent and can be combined \nby the Generalized Chinese Remainder Theorem in step D. @ In order for this algorithm to succeed in reconstructing \nW,we need to know the value of W mod pi for each i.If each pi is a node,we can think of each statement \nof the form W =x mod pipj as an edge between pi and pj. Then the e.ect of attacks on the watermark can \nbe modeled as edges being deleted at random. If q is the probability that each edge will be deleted and \nwe start with the complete graph on n nodes,then the probability that each node will still have at least \none incident edge is given by ! n X j+1 j n j(n- ) (-1)q2 . (1) j j=0 This serves as a good approximation \nfor the probability of W being successfully reconstructed. Figure 5 shows the em\u00adpirical probability \nof recovering a 768-bit value for W with a varying number of statements left intact versus the theo\u00adretical \napproximation of this probability as given by (1). 4. WATERMARKING NATIVE EXECUTA-BLES Native code executables \no.er signi.cantly greater .exibil\u00adity,compared to Java bytecode,in terms of the transforma\u00adtions that \ncan be applied during watermarking. This makes it possible to use techniques that cannot be used in the \ncase of bytecode. Herewediscuss onesuch technique forimple\u00admenting path-based watermarking,using branch \nfunctions. Probability of Success 1.0 0.8 0.6 0.4 0.2 0.0 Figure 5: Number of watermark pieces recovered \nintact ver\u00adsus the probability of successful watermark recovery  4.1 Branch Functions: An Overview A \nbranch function is a function that is called in the nor\u00admal manner,but which manipulates its return address \nsuch that,when it returns,control may be transferred to an ad\u00address di.erent from the original call site \n[15]. Consider a program containing a particular set of unconditional jumps of interest,at locations \na1,...,an,with targets b1,...,bn respectively,i.e.,the instruction at location ai is ai : jmp bi 1 = \ni = n With branch functions,we replace each of these jumps by a call to the branch function f,resulting \nin code of the form: ai : call f 1 = i = n The function f uses the return address to .gure out the location \nai(1 = i = n) it was called from,then uses this information to change its return address to the value \nbi. When it subsequently executes a ret instruction,therefore, control is transferred to the original \ntarget bi.The situation is illustrated in Figures 6(a) and 6(b). The implementationofbranchfunctions \ncanbe illustrated by .rst considering a very simple-minded variation of the idea above,where the call \nat location ai passes the o.set to its target address as an argument. The branch function then simply \nadds its argument to the return address,then returns. The corresponding code,on the Intel IA-32 archi\u00adtecture,has \nthe form: xchg %eax, 0(%esp) #I1 add %eax, 4(%esp) #I2 pop %eax #I3 ret #I4 Instruction I1 exchanges \nthe contents of register %eax with the word at the top of the stack,e.ectively saving the con\u00adtents of \n%eax and at the same time loading the return ad\u00address into %eax. Instruction I2 then has the e.ect of \nadding the displacement to the target (passed as an argument on the stack) to the returnaddress;the sum \nwhichisinfactthe target address bi is now written to the location 4(%esp). I3 restores the previously \nsaved value of %eax,leaving the address of the target on top of the stack. I4 then has the e.ect of branching \nto the address computed by the function. The straightforward implementation described above has two shortcomings. \nThe .rst is that it is not di.cult to detect a function that modi.es its own return address. On archi\u00adtectures \nsuch as the Intel IA-32,the return address is passed pushf # save flags push %edx # register save push \n%ecx # register save push %eax # register save mov 0x10(%esp,1),%edx mov %edx,%eax # begin perfect hash \ncomputation shl $0xc,%eax and $0x7ff,%edx shr $0x15,%eax movzwl 0x80d2bb0(%edx,%edx,1),%ecx xor %ecx,%eax \n # begin return address fix imul $0xc,%eax,%eax mov %eax,%edx mov 0x80c3c04(%eax),%eax xor %eax,0x10(%esp,1) \n # begin tamper-proofing lea 0x80c3c08(%edx),%eax cmpl $0x0,(%eax) je cleanup mov 0x4(%eax),%edx xor \n%edx,(%eax) movl $0x0,0x4(%eax) cleanup: pop %eax # register restore pop %ecx # restore restore pop \n%edx # restore restore popf # restore flags ret Figure 7: An example of branch function code at some \n.xed o.set from the stack pointer; on RISC archi\u00adtectures,the standard calling convention passes the \nreturn address in some .xed register. In either case,an observant attacker can detect when the location \ncontaining the return address happens to be the destination of an arithmetic (or move) instruction. The \nsecond shortcoming is that this sim\u00adple scheme uses just a single straightforward arithmetic op\u00aderation \nfor the return address modi.cation,and so is not as robust against reverse engineering as we would like. \nWe can address the .rst problem by using helper func\u00adtions with the branch function. The idea is as follows. \nThe branch function f does not itself do any tampering with its return address: instead,it calls a helper \nfunction f1,which might itself call another helper function f2,etc. The helper function calls cause the \noriginal return address to be saved on the stack regardless of whether the call\u00ading convention passes \nthe return address in a register or on the stack. Moreover,because the chain of helper func\u00adtions f .f1 \n.\u00b7\u00b7\u00b7.fm is .xed in a given implementation of branch functions,we know (based on knowledge of the stack \nframe sizes for the helper functions f1,...,fm note that these stack frame sizes can be chosen randomly \nby the implementation) how deep in the stack the original return address is located. The last helper \nfunction then reaches into the stack to modify the original return address. We address the second problem \nusing perfect hashing [12]. Given the control .ow mapping . = {.n ..b} a1 .b1,...,anwe want the branch \nfunction to implement,we create a per\u00adfect hash function h. : {a1,...,an. }.{1,...,n}.We then construct \na table T in the data section of the binary,that bit encodings 101  a2 call f a2 a2 . . .  a 0 lbegin \na 0 call f  lend : jmp b lend a11 b1 . . . a 1 call f a1 a1 a1 : call f . . . b1 a3 call f a 3 a3 \n. . . a2 : jmp b2 b2 a4 call f a 4 a4 . . . a2 : call f b2 . . . . . . f  an : jmp bn bnan : call \nf bn   (a) Original code (b) Code using a branch function (c) An example of branch-function-based \nwater\u00admarking (watermark = 1011) Figure 6: Branch functions contains the exclusive or of each (ai,bi)pair,2 \nas follows: T[h.(ai)] .ai .bi. Upon invocation,the branch function proceeds as follows. It saves the \nappropriate registers; applies the perfect hash function h. to its return address a to compute a hash \nvalue h.(a); uses the table T to obtain the value T[h.(a)]; xors this value into the return address,similarly \nto the scheme described earlier; and .nally,restores the saved registers and returns. Figure 7 shows \nan example of branch function code, taken from the SPECINT-2000 benchmark program parser for a 512-bit \nwatermark. 4.2 Using Branch Functions for Software Wa\u00adtermarking In order to use branch functions for \nsoftware watermark\u00ading,we have to specify how they should be used to encode the bits in the watermark,how \na watermark is to be em\u00adbeddedwithinan executable,andhow it canbe extracted. This section discusses these \nissues in more detail. 4.2.1 Bit Encoding As discussed above,a branch function implements a con\u00adtrol \n.ow mapping {a1 .n . bn}.We can choose . b1,...,a.any subset not necessarily proper of the pairs in this \nmap to encode the watermark: i.e.,the branch function imple\u00admenting the watermark can also be used to \nobfuscate other control transfers,elsewhere in the program,that have noth\u00adingtodowiththe watermarkitself[15]. \nFor simplicity of exposition,however,we will assume,in the discussion that follows,that all of the pairs \nin the branch function are used for encoding the watermark. Each pair of addresses ai . .bi in the branch \nfunction map encodes a single bit of the watermark. In principle,we can use any property of these pairs \nthat we want: for example, we could,if we wished,use the parity of ai and bi,using the predicate parity(ai)= \nparity(bi). Our implementation uses a forward jump (i.e., ai <bi)to encodea 1 and a backward jump (i.e., \nai >bi)to encode a 0. 2This is done so that the data section of the binary does not contain a sequence \nof text section addresses,since such a sequence of entries could be conspicuous to an attacker. 4.2.2 \nWatermark Embedding To embed a k-bit watermark w = w0w1 \u00b7\u00b7\u00b7wk-1 into an executable,we start with an unconditional \ncontrol .ow edge begin . end ; we will split this edge and insert the water\u00admark code between begin and \nend . We .rst construct a list of k+ 1 branch function calls (a0,a1,...,ak) such that the following hold: \n1. for each ai,0 <i=k,the instruction immediately be\u00adfore ai is an unconditional jump,i.e.,execution \ncannot fall through to ai;and 2. the addresses of adjacent pairs of instructions (ai,ai+1), 0 =i<k,encode \nbit wi of the watermark:  addr(ai) <addr(ai+1) if wi =1 addr(ai) >addr(ai+1) if wi =0. To construct \nthe list, a0 is inserted at address begin .We then iteratively construct ai+1 from the last instruction \nai added to the list: we use the value of wi,the ith bit of the watermark w,to scan either forward (if \nwi =1,i.e., ai need to jump forward) or backward (if wi = 0,i.e.,we need to jump backward),until we .nd \na location that satis.es the .rst condition above,and insert a call instruction at that location. This \nis repeated until all of the instructions a0,...,ak have been constructed. The last branch function call, \nak,has end as its target. Once these branch function calls have been inserted into the instruction stream,the \naddress of each such instruction is determined. Let bai denote the address of the instruction ai,then \nthe control transfer mapping for the branch function is {ba0 .ba1 .b,b.ak,b.end }. . a1,b.a2,\u00b7\u00b7\u00b7 ak-1 \n.bak . b Figure 6(c) illustrates an example of a branch-function\u00adbased embedding of the bit-string 1011 \nintoaprogram. Starting at a0,the .rst bit is 1,and is encoded by the for\u00adward branch a0 . a1,which isrealized \nviaacalltothe branch function f(); the next bit,0,is encoded by the back\u00adward branch a1 . a2; the third \nbit is a 1,and is encoded by the forward branch a2 . a3;and the last bit,which is again a 1,is encoded \nby another forward branch,a3 . a4. Finally,control returns from a4 to the end point end of the watermark. \n 4.2.3 Watermark Extraction To extract a watermark,we start with the pair of ad\u00addresses (begin ,end ) \nbracketing the watermark (currently, these are supplied manually; however,we expect to aug\u00adment the implementation \nin the near future to use a fram\u00ading scheme that would allow these addresses to be identi.ed automatically). \nWe use a tracer tool that uses hardware single-stepping to obtain a dynamic trace of the instructions \nexecuted between the time control reaches begin and when it subsequently reaches end . This trace is \nthen analyzed to identify the branch function fw,by observing functions that do not return to the instruction \nfollowing the call in\u00adstruction. Once the branch function has been identi.ed,we obtain,from the trace,the \nlist of locations from which fw is called,and for each such location ai the corresponding location bi \nto which control returns from that call. By com\u00adparing the values ai and bi,we can determine whether \nit corresponds to a forward or backward jump,and thereby extract the corresponding bit of the watermark. \nThis is repeated until all instructions in the trace have been pro\u00adcessed; this corresponds to having \nexecution return to end .  4.3 Tamper-proo.ng Branch Functions An important property of a software \nwatermark is its ro\u00adbustness under semantics-preserving code transformations. Since a branch function \nsynthesizes a mapping between pairs of absolute addresses,any transformation that causes code addresses \nto change,but which does not at the same time update the mapping implemented by the branch function, \nwill cause the resulting program to break. Moreover,the perfect hash functions used to compute these \nmappings tend to be quite cryptic and di.cult to reverse engineer (e.g.,see Figure 7). For this reason,we \nbelieve that branch-function\u00adbased watermarks are resilient against code transformations that cause addresses \nwithin the text section to change; in particular,this includes additive and distortive attacks. To guard \nagainst subtractive attacks,our basic idea is to have the branch function carry out a computation that \nis essential for the subsequent execution of the program. Re\u00adcall that the branch function is entered \nstarting at a location begin . We begin by taking an unconditional branch at a lo\u00adcation . such that \nbegin dominates . We then transform the branch instruction at . to an indirect branch through a memory \nlocation M,such that M contains the correct target address if and only if the branch function has been \nexecuted. For this, M is initialized to some random text sectionaddress,andcode is added within the branch \nfunc\u00adtion to update the contents of M to the correct target ad\u00address. In general,this update can occur \nincrementally,such that each time the branch function executes,some set of bits of the target address \nare computed. This is done for multiple jump instructions: in our current implementation, when embedding \na k-bit watermark we attempt to .nd up to k candidate branches that can be tamper-proofed in this manner; \neach branch function call updates a di.erent such candidate (a branch is considered to be a candidate \nif it oc\u00adcurs in an infrequently executed portion of the code and is not part of a loop; the last requirement \nis to avoid excessive performance degradation on inputs that may cause di.erent execution characteristics \nthan the training inputs). With this,if the branch function is identi.ed and snipped out of the execution \nby an attacker,the control .ow behavior of the program will no longer be correct.  5. EXPERIMENTAL RESULTS \nIn this section we present our evaluation of the Java byte\u00adcode and the native code implementations of \nthe path-based watermark. We have measured the cost of embedding the watermark in terms of the time and \nspace overhead incurred by the inserted watermark code and the resiliency of the wa\u00adtermark to attacks. \nBecause the implementations are very di.erent,so are the attacks that we evaluate. 5.1 Java Bytecode \nWe evaluated the watermarking scheme for Java bytecode described in Section 3 using an implementation \nbuilt on top of SandMark,a collection of obfuscation and watermark\u00ading algorithm implementation for Java \nbytecode. The sys\u00adtem reads in Java archives (jar-.les),applies one or more obfuscations or watermarks,and \nwrites the resulting code to another Java archive. We used two programs for our exper\u00adiments. The .rst \nis the Ca.eineMark benchmark suite [3]. Ca.eineMark contains several microbenchmarks that test the performance \nof integer and .oating point arithmetic op\u00aderations,loops,logical operations,and method calls. A high \npercentage of the instructions in Ca.eineMark are executed frequently. The second program we used was \nJess [13],a language interpreter included as part of the SpecJVM [1] benchmarking suite. We did not use \nthe entire SpecJVM suite because the resulting trace .les become very large. All tests were run using \nSun s JVM version 1.4.0 and Red\u00adhat Linux 9.0. Our hardware was a 2.4 GHz Pentium 4 system with 1 GB \nRAM. 5.1.1 Cost We evaluated the space and time cost of the path-based watermark using 128,256,and 512 \nbit watermarks. Fig\u00adure 8(a) shows that this watermark can slow down performance\u00adcritical code code similar \nto Ca.eineMark by up to 80 per\u00adcent. It is likely that performance does not su.er when few watermark \npieces are inserted because the weighted random location choice described in Section 3.2 selects infrequently \nexecuted locations as insertion points. As more pieces are inserted,the probability that some frequently \nexecuted lo\u00adcation will be chosen increases; when this eventually occurs, there is a dramatic performance \ndegradation. As many more pieces are inserted,more are inserted in hot locations,re\u00adsulting in further \nperformance degradation. In contrast,Jess contains more code (300KB as opposed to 9KB for Ca.eineMark) \nand a lower percentage of frequently executed code. It appears that our random insertion posi\u00adtion algorithm \nsuccessfully avoided the frequently executed portions of Jess,and therefore caused an insigni.cant slow\u00addown. \nFigure 8(b) shows that embedding carries a .xed cost of approximately 5 percent of the program size,plus \na variable cost of 25 bytes per watermark piece.  5.1.2 Resilience SandMark implements 40 distortive \nattacks against wa\u00adtermarks,including basic block copying,statement reorder\u00ading,and method and class \nsplitting and merging. Only class encryption and branch insertion were able to destroy the wa\u00adtermark. \nIn the class encryption attack,every class .le in an appli\u00adcation is replaced with an encrypted version \nof itself. The startup code for the application is then replaced by a new program that decodes and runs \nthe encrypted classes. While this attack has no e.ect on the branch sequence taken by Slowdown (Fraction) \n1.0 0.5 0.0  0 100 200 300 400 500  Number of Pieces Inserted Number of Pieces Inserted (a) Ca.eineMark \nand Jess slowdown resulting from (b) Ca.eineMark and Jess size increases resulting the insertion of a \nvarying number of watermark from the insertion of a varying number of wa\u00adpieces termark pieces Survivable \nBranch Insertion (%) 150 100 50 0   100200300400500 0 1 2 3 4 Number of Pieces Inserted Branch Increase \n(Fraction) (c) The path-based watermark can survive the ad- (d) Adding branches to code causes a slowdown \ndition of a percentage of branches that increases that varies with the number of branches added with \nthe number of watermark pieces inserted and the size of the watermark Figure 8: Java bytecode implementation \nevaluation results the program,it does prevent instrumentation by denying the instrumenter access to \nthe bytecode. When instrumen\u00adtation fails,a trace cannot be collected and recognition fails. While this \nis an interesting attack,it does not reveal an in\u00adherent .aw in our algorithm because the trace need \nnot be collected through the use of instrumentation. We could in\u00adstead collect a trace by using standard \nJava interfaces for pro.ling and debugging. Because the JVM necessarily has access to the unencoded form \nof the bytecode,this tracing method would be resilient to all forms of bytecode encoding. The branch \ninsertion attack randomly inserts branches into a program. If an attacker inserts a branch instruction \nat a random place in the program,he may cause random changes in the decoded bit-string. If he inserts \nmany random branches into the program,he is likely to cause widespread random changes in the decoded \nbit-string. Because of the error correcting qualities of our watermark encoding scheme, our implementation \ncan withstand a level of random branch insertion that varies with the number of watermark pieces embedded \nin the program and with the size of the water\u00admark. Thisisshown in Figure 8(c). The performance penalty \nassociated with this attack is likely to vary widely based on the code inserted to generate each branch. \nWehavemeasured the performancepenalty of this code (where x is an integer variable): . . if (x * (x - \n1)%2!=0) x++; . . The resulting slowdown is shown in Figure 8(d). Fig\u00adures 8(c) and 8(d) show that an \nadversary can destroy a 512-bit watermark by increasing the number of branches in a program by 150 percent,but \nthat this attack comes at a cost of slowing down the program by 50 percent.  Like all other known software \nwatermarking schemes,our implementation provides no protection against additive at\u00adtacks. We also have \nno inherent protection against collu\u00adsive attacks. However,collusive attacks can be prevented by obfuscating \nthe program before it is watermarked,and thus producing a highly diverse program population. Any attempt \nto .nd the watermark code through comparison of multiple watermarked copies of the program will be thwarted \nby this defense because the di.erences between any two copies of the program will contain much more than \njust the watermark code.  5.2 Native Code We evaluated the branch-function watermarking scheme described \nin Section 4.2,using an implementation built on top of PLTO,a binary rewriting system developed for Intel \nIA-32 executables [11]. The system reads in statically linked executables,disassembles the input binary,and \nconstructs a control .ow graph,which can then either be instrumented to obtain execution pro.les,or modi.ed \nto have a given wa\u00adtermark embedded into it. We used ten programs in the SPECint-2000 benchmark suite \nfor our experiments. Two benchmarks, eon and perl were omitted from our tests due to problems building \nthe harness. Our experiments were runonan otherwise unloaded 2.4GHz Pentium IVsystem with 1 GB of main \nmemory running RedHat Linux 9.0. The programs were compiled with gcc version 3.2.2 at optimiza\u00adtion level \n-O3. The programs were pro.led using the SPEC training inputs and these pro.les were used to identify \nany hot spots during our transformations. The .nal performance of the transformed programs were then \nevaluated using the SPEC reference inputs. Each execution time reported was derived by running .ve trials,discarding \nthe highest and lowest run times so obtained,and computing the average of the remaining three times. \n5.2.1 Cost We evaluated the space and time cost of path-based wa\u00adtermarking using watermarks of three \nsizes: 128 bits,256 bits,and 512 bits. Figure 9(a) shows the relative increase in total size (text + \ndata sections) incurred due to watermarking. All in all, the increases are fairly modest,ranging from \nabout 5% for crafty to about 16% for mcf. The rate of growth in size is also fairly small. The mean increase \nin size ranges from 10.8%, for 128-bit watermarks,to 11.4% for 512-bit watermarks. The runtime slowdowns \nexperienced as a result of water\u00admarking are shown in Figure 9(b). For most of the programs tested,the \nslowdown is quite small (less than 2%),and sev\u00aderal of the programs actually speed up by about 2 3%,pre\u00adsumably \ndue to cache e.ects. The mean slowdowns range from -0.65%,for 128-bit watermarks,to 0.85% for 512-bit \nwatermarks.  5.2.2 Resilience To evaluate the resilience of our watermarks against at\u00adtacks,we subjected \nthe watermarked programs to a number of code transformations of the sort that might be encoun\u00adtered in \na standard binary manipulation tool. We tried the following transformations: 1. No-op insertion. This \nis intended to simulate a dis\u00adtortive attack where the attacker tries to inject addi\u00adtional code into \nthe program,e.g.,using a code obfus\u00adcator. As discussed in Section 4.3,the use of branch func\u00adtions gives \nus a lock-down on a range of program addresses,such that a change to any of these addresses will cause \nthe program to malfunction. The e.ect of such insertions is to change text addresses. Every one of our \ntest programs breaks when even a single no-op is added to a watermarked binary. 2. Branch sense inversion. \nThis involves inverting the sense of conditional branches and rearranging basic blocks accordingly to \nmaintain program semantics,so that the roles of the branch-taken and branch-not\u00adtaken targets get reversed. \nThis is intended to simu\u00adlate a distortive attack of the sort that might occur if an attacker applies \ncode optimization or binary rewrit\u00ading techniques to a watermarked binary. For the same reason as for \nno-op insertion,every one of our test pro\u00adgrams breaks when branch senses are inverted. 3. Double watermarking. \nThis involves taking a water\u00admarked program and running it through the water\u00admarker again. This simulates \nan additive attack where the attacker hopes to overwrite or obscure part or all of the original watermark \nby a second round of water\u00admarking. As for the previous two attacks,this causes text addresses to change,and \ncauses each of our test programs to break. 4. Bypassing the branch function. This involves overwrit\u00ading \nsome number of calls to the branch function with a jump instruction of exactly the same size (in bytes),so \nthat there is no net change to any addresses; the tar\u00adget of this new jump instruction is the actual \naddress that the branch function would transfer control to for that particular call. This has the e.ect \nof realizing the control transfer that the branch function would real\u00adize,but bypassing the actual branch \nfunction code. It simulates a subtractive attack. As discussed in Section 4.3,calls to the branch function \nalso have the e.ect of updating the contents of memory locations that are used for indirect jumps. When \nthe branch function is bypassed,therefore,some such loca\u00adtions are not properly updated,and therefore \ncontain incorrect addresses. This causes execution to break. 5. Rerouting Branch Function Entries. This \ninvolves re\u00adplacingacalltothe branch function with acall toa di.erent location 3 which then transfers \ncontrol to the branch function. Consider the following transforma\u00adtion from the original branch function \ncall in (a) to the sequence in (b),where bf is the branch function, and Y is the address of the end of \nthe text.  This may require the header of the .le to also be modi.ed, (a) (b) X: call bf X: call Y ... \n... Y: jmp bf 3 but does not necessarily require any relocation to take place within the binary. If \nrelocation was needed the attack be\u00adcomes much more di.cult because of known static analysis challenges \nwith respect to native executables. slowdown (%) size increase (%) 20.0 15.0 10.0 5.0 0.0  (a) Space \ncost of watermarking native code 5.0  Watermark size 128 bits 256 bits 512 bits Watermark size 128 \nbits 0.0 256 bits 512 bits -5.0  (b) Time cost of watermarking native code Figure 9: Native code implementation \nevaluation results bzip2 crafty gap gcc gzip mcf parser twolf vortex vpr Mean This particular transformation \nallows the program to execute properly,since the branch function in (b) still sees X as the hash input \njust as it would have in (a).4 A tracer which relies on looking at the address transfer\u00adring control \nto the branch function to determine each bai,such as our simple tracer,is disabled in (b) since it would \ndeduce the bai to be Y instead of X. This attack can be obviated,however,simply by using a slightly more \nintelligent tracer that is constructed as follows. As explained above,one of the reasons that this partic\u00adular \nattack works is that the return address,i.e.,the hash input,remains unchanged and therefore main\u00adtains \nthe integrity of the tamper-proo.ng. From this fact we can see that each time the branch function ex\u00adecutes,it \nmust still be using the address of the instruc\u00adtion just after the bai as it s hash input. By construct\u00ading \na tracer that tracks the value of the hash input to the branchfunctioneachtime itexecutes (as opposed \nto inspecting the address of the invoking instruction) , the original mapping {ba0 .. ba1, ba1 .. ba2, \n\u00b7\u00b7\u00b7 , bak-1 .. bak, bak .end } can be easily retrieved and the water\u00ad . b mark can successfully be reconstructed. \n  6. RELATED WORK Qu and Potkonjak[17] embed the watermark in register in\u00ad terference graphs. The data-rate \nis minimal and the scheme is easily subverted by a register renumbering transforma\u00ad tion [16]. Venkatesan \net al. [20] embed the watermark in an extra control .ow graph that is added to the program. To distin\u00ad \nguish the watermark graph from the original .ow graphs,its 4The value it will see is actually X + 5 to \naccount for the length of the call instruction basic blocks are marked, for example by inserting identify\u00ading \ninstructions,reordering instructions,etc. The data-rate is high but the scheme is vulnerable to transformation \nwhich a.ect the basic block marks,such as basic block splitting and instruction reordering [4]. Davidson \nand Myhrvold [9] embed the watermark by re\u00adordering basic blocks. It is easily subverted by permuting \nthe order of the blocks. Stern et al. [19] embed the watermark in the relative fre\u00adquencies of instructions \nusing a spread spectrum technique. The data-rate is low and the scheme is easily subverted by inserting \nredundant instructions,code optimization,etc. Dynamic software watermarking was .rst proposed by Collberg \nand Thomborson [6]. Their scheme embeds the watermark in the topology of a data structure that is built \non the heap at runtime given some secret input sequence to the program. This scheme is vulnerable to \nany attack that is able to modify the pointer topology of the program s funda\u00admental data types. In the \ngeneral case such transformations are di.cult because of the hardness of alias analysis. Cousot and Cousot \n[8] embed the watermark in values as\u00adsigned to designated integer local variables during program execution. \nThese values can be determined by analyzing the program under an abstract interpretation framework, enabling \nthe watermark to be detected even if only part of the watermarked program is present. This scheme can \nbe attacked by obfuscating the program such that the local variables representing the watermark cannot \nbe located or such that the abstract interpreter cannot determine what values are assigned to those local \nvariables. This scheme also depends on keeping a variable v at a constant value mod n for some n throughout \nprogram ex\u00adecution. This constant congruence class represents the wa\u00adtermark,and the watermarked program \ncan vary v s value within this congruence class in order to make the values ap\u00adpear random. However,if \nthe sequence of values assigned to v is (v0,v1,v2,...,vk),then n will divide gcd(v1 - v0,v2 - v0,...,vk \n-v0). This allows the variables being used for wa\u00adtermarking to be identi.ed,since n has to be fairly \nlarge for the watermarking scheme to work and the gcd of random values that would be assigned to variables \nnot being used for watermarking is likely to be small. 7. CONCLUSIONS Software watermarking is an important \ntool for combating software piracy. It is important that software watermarks be resilient against semantics-preserving \ncode transforma\u00adtions. Unfortunately,most existing proposals for software watermarking turn out to be \nvulnerable to fairly straight\u00adforward code transformations. This paper introduces a new approach to watermarking,called \npath-based watermarking, that embeds the watermark in the dynamic branch structure of the program,and \nshows how error-correcting and tamper\u00adproo.ng techniques can be used to make path-based water\u00admarks resilient \nagainst a wide variety of attacks. Experimental results,using both Java bytecode and IA-32 native code,indicate \nthat the cost of watermarking is rela\u00adtively modest,even for relatively large watermarks (ranging from \n128 to 512 bits). For Java bytecode,we see that if the number of pieces that the watermark is broken \ninto is kept small,the runtime overhead of watermarking is essentially negligible. As the number of pieces \nincrease,making it more di.cult for an attacker to destroy the watermark,there is a concomitant increase \nin runtime overhead. The space cost of watermarking Java bytecode is independent of the size of the application \nbeing watermarked,and is quite small: it varies roughly linearly with the size of the watermark,and requires \nabout 8 Kilobytes for a 512-bit watermark. Native code watermarking on an Intel IA-32 platform incurs \nmean size increases of about 12 13% and mean runtime slowdowns of about 3.5%. 8. REFERENCES [1] Specjvm98. \nhttp://www.specbench.org/osg/jvm98, 1998. [2] Business Software Alliance. Eighth annual BSA global software \npiracy study: Trends in software piracy 1994 2002,June 2003. http: //global.bsa.org/globalstudy/2003_GSPS.pdf. \n[3] Ca.einemark. http://www.benchmarkhq.ru/cm30/info.html,1997. [4] Christian Collberg,Andrew Huntwork,Edward \nCarter,and Gregg Townsend. Graph theoretic software watermarks: Implementation,analysis,and attacks. \nIn 6th International Information Hiding Workshop,2004. [5] Christian Collberg,Ginger Myles,and Andrew \nHuntwork. SandMark A tool for software protection research. IEEE Magazine of Security and Privacy,1(4),July-August \n2003. [6] Christian Collberg and Clark Thomborson. Software watermarking: Models and dynamic embeddings. \nIn In Conference Record of POPL 99: The 26th ACM SIGPLAN-SIGACT Symposium on Principles of Programming \nLanguages (Jan. 1999),1999. [7] Christian Collberg,Clark Thomborson,and Douglas Low. Manufacturing cheap,resilient,and \nstealthy opaque constructs. In Principles of Programming Languages 1998, POPL 98,San Diego,CA,January \n1998. [8] Patric Cousot and Radhia Cousot. An abstract interpretation-based framework for software watermarking. \nIn POPL 04,Venice,Italy,2004. [9] Robert L. Davidson and Nathan Myhrvold. Method and system for generating \nand auditing a signature for a computer program. US Patent 5,559,884, September 1996. Assignee: Microsoft \nCorporation. [10] Saumya K. Debray,Robert Muth,Scott Watterson, and Koen De Bosschere. ALTO: A link-time \noptimizer for the Compaq Alpha. Software Practice and Experience,31:67 101,January 2001. [11] Saumya \nK. Debray,Ben Schwarz,Gregg R. Andrews, and Matthew Legendre. PLTO: A link-time optimizer for the Intel \nIA-32 architecture. In Proc. 2001 Workshop on Binary Rewriting (WBT-2001), September 2001. [12] MichaelL.Fredman,JanosKoml\u00b4os,and \nEndre Szemer\u00b4edi. Storing a sparse table with O(1) worst case access time. Journal of the ACM,31(3):538 \n544,July 1984. [13] Jess. http://web.njit.edu/all_topics/Prog_Lang_ Docs/html/jess51/intro.html,1997. \n[14] Donald E. Knuth. Seminumerical Algorithms, volume 2 of The Art of Computer Programming. Addison-Wesley,Reading,MA,USA,third \nedition, 1997. [15] Cullen .M. Linn and Saumya K. Debray. Obfuscation of executable code to improve resistance \nto static disassembly. In Proc. 10th. ACM Conference on Computer and Communications Security (CCS 2003), \npages 290 299,October 2003. [16] Ginger Myles and Christian Collberg. Software watermarking through register \nallocation: Implementation,analysis,and attacks. In ICISC 203, 2003. [17] Gang Qu and Miodrag Potkonjak. \nAnalysis of watermarking techniques for graph coloring problem. In IEEE/ACM International Conference \non Computer Aided Design,pages 190 193,November 1998. [18] Amitabh Srivastava and David W. Wall. A practical \nsystem for intermodule code optimization at link-time. Journal of Programming Languages,1(1):1 18,March \n1993. [19] Julien P. Stern,Ga\u00a8el Hachez,Franois Koeune,and Jean-Jacques Quisquater. Robust object watermarking: \nApplication to code. In 3rd International Information Hiding Workshop,pages 368 378,1999. [20] Ramarathnam \nVenkatesan,Vijay Vazirani,and Saurabh Sinha. A graph theoretic approach to software watermarking. In \n4th International Information Hiding Workshop,Pittsburgh,PA,April 2001.  \n\t\t\t", "proc_id": "996841", "abstract": "Software watermarking is a tool used to combat software piracy by embedding identifying information into a program. Most existing proposals for software watermarking have the shortcoming that the mark can be destroyed via fairly straightforward semantics-preserving code transformations. This paper introduces path-based watermarking, a new approach to software watermarking based on the dynamic branching behavior of programs. The advantage of this technique is that error-correcting and tamper-proofing techniques can be used to make path-based watermarks resilient against a wide variety of attacks. Experimental results, using both Java bytecode and IA-32 native code, indicate that even relatively large watermarks can be embedded into programs at modest cost.", "authors": [{"name": "C. Collberg", "author_profile_id": "81100590418", "affiliation": "University of Arizona, Tucson, AZ", "person_id": "PP40028856", "email_address": "", "orcid_id": ""}, {"name": "E. Carter", "author_profile_id": "81100562408", "affiliation": "University of Arizona, Tucson, AZ", "person_id": "PP14195165", "email_address": "", "orcid_id": ""}, {"name": "S. Debray", "author_profile_id": "81100148240", "affiliation": "University of Arizona, Tucson, AZ", "person_id": "P253058", "email_address": "", "orcid_id": ""}, {"name": "A. Huntwork", "author_profile_id": "81100362019", "affiliation": "University of Arizona, Tucson, AZ", "person_id": "P677797", "email_address": "", "orcid_id": ""}, {"name": "J. Kececioglu", "author_profile_id": "81100444575", "affiliation": "University of Arizona, Tucson, AZ", "person_id": "P677800", "email_address": "", "orcid_id": ""}, {"name": "C. Linn", "author_profile_id": "81100455010", "affiliation": "University of Arizona, Tucson, AZ", "person_id": "P677799", "email_address": "", "orcid_id": ""}, {"name": "M. Stepp", "author_profile_id": "81336493326", "affiliation": "University of Arizona, Tucson, AZ", "person_id": "PP14054969", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/996841.996856", "year": "2004", "article_id": "996856", "conference": "PLDI", "title": "Dynamic path-based software watermarking", "url": "http://dl.acm.org/citation.cfm?id=996856"}