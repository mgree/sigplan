{"article_publication_date": "06-09-2004", "fulltext": "\n Region Inference for an Object-Oriented Language Wei-Ngan Chin1,2, Florin Craciun2, Shengchao Qin1,2, \nand Martin Rinard3 1 Computer Science Programme, Singapore-MIT Alliance 2 Department of Computer Science, \nNational University of Singapore 3 Laboratory for Computer Science, Massachusetts Institute of Technology \n {chinwn,craciunm,qinsc}@comp.nus.edu.sg, rinard@lcs.mit.edu ABSTRACT Region-based memory management \noffers several important poten\u00adtial advantages over garbage collection, including real-time perfor\u00admance, \nbetter data locality, and more ef.cient use of limited mem\u00adory. Researchers have advocated the use of \nregions for functional, imperative, and object-oriented languages. Lexically scoped re\u00adgions are now \na core feature of the Real-Time Speci.cation for Java (RTSJ)[5]. Recent research in region-based programming \nfor Java has fo\u00adcused on region checking, which requires manual effort to augment the program with region \nannotations. In this paper, we propose an automatic region inference system for a core subset of Java. \nTo pro\u00advide an inference method that is both precise and practical, we sup\u00adport classes and methods that \nare region-polymorphic, with region\u00adpolymorphic recursion for methods. One challenging aspect is to ensure \nregion safety in the presence of features such as class sub\u00adtyping, method overriding, and downcast operations. \nOur region in\u00adference rules can handle these object-oriented features safely with\u00adout creating dangling \nreferences. Categories and Subject Descriptors D.3.3, D.3.4 [Programming Languages]: Language Constructs \nand Features, Processors; D.2.8 [Software Engineering]: Program Veri.cation; F.3.2 [Theory of Computation]: \nSemantics of Pro\u00adgramming Languages General Terms Languages, Veri.cation, Theory  Keywords Region Inference, \nObject-Oriented Languages, Type Systems, Mem\u00adory Management, Downcasts, Method Overriding 1. INTRODUCTION \nRegion-based memory management systems allocate each new object into a region with a designated lifetime, \nwith the entire set of objects in each region deallocated simultaneously when the region Permission to \nmake digital or hard copies of all or part of this work for personal or classroom use is granted without \nfee provided that copies are not made or distributed for pro.t or commercial advantage and that copies \nbear this notice and the full citation on the .rst page. To copy otherwise, to republish, to post on \nservers or to redistribute to lists, requires prior speci.c permission and/or a fee. PLDI 04, June 9 \n11, 2004, Washington, DC, USA. Copyright 2004 ACM 1-58113-807-5/04/0006 ...$5.00. is deleted. Various \nstudies have shown that region-based program\u00adming can provide safe memory management with good real-time \nperformance. Data locality may also improve when related objects are placed together in the same region. \nClassifying objects into re\u00adgions based on their lifetimes may deliver better memory utilization if regions \nare deleted on a timely basis. Dangling references are a safety issue for region-based memory management. \nA reference from (an object in) one region to (an ob\u00adject in) another region is said to be dangling if \nthe latter region has a shorter lifetime than the former. A region has a shorter lifetime than another \nregion if it is deleted before the latter. Using a dangling ref\u00aderence to access memory is unsafe because \nthe accessed memory may have been reallocated to store a new object. Researchers have identi.ed two approaches \nto eliminate this problem. The .rst ap\u00adproach allows the program to create dangling references, but uses \na type and effect system to ensure that the program never uses a dan\u00adgling reference to access memory[16]. \nThe second approach uses a type sytem to prevent the program from creating dangling refer\u00adences at all[9]. \nThe .rst approach (no-dangling-access) may yield more precise region lifetimes, but the latter approach \n(no-dangling) is required by the RTSJ and for co-existence with precise garbage collectors. Several projects \nhave recently investigated the use of region\u00adbased memory management for Java-based languages [21, 16, \n15, 9]. Most of these projects (e.g. [16, 9]) require programmers to manually annotate their programs \nwith region declarations. The type checker then uses these declarations to check that well-typed programs \nnever access dangling references, ensuring safe memory management and enabling the omission of run-time \ntests for dan\u00adgling references. An issue is that region annotations may impose a considerable mental \noverhead for the programmer and raise com\u00adpatibility issues with legacy code. In addition, the quality \nof the annotation may vary, with potentially suboptimal outcomes for less experienced programmers. In \nthis paper, we provide a systematic formulation of a region inference system for a core subset of Java. \nWe use the no-dangling approach and support programs that use a stack of lexically scoped regions in \nwhich the last region created is the .rst deleted. We adopt this approach for two reasons: to simplify \nour inference al\u00adgorithm and to conform to the RTSJ. Our main contributions are: Region Inference: We \npresent a new region inference al\u00adgorithm for a core subset of Java. This algorithm (based on type inference) \nautomatically augments unannotated pro\u00adgrams with region type declarations; when the program runs it \nuses region-based memory management and is guaranteed to never create dangling references. Our algorithm \nfully han\u00addles object-oriented features such as class subtyping, method overriding, and downcast operations. \nRegion Lifetime Constraints: Our region type rules prevent dangling references by requiring the target \nobject of each P ::= def* meth* def ::= class cn1 extends cn2{.eld* meth* } reference to live at least \nas long as the source object. We formalise this requirement explicitly through region lifetime prim ::= \nint | bool | void constraints, with support for region subtyping. t ::= cn | prim .eld ::= t f Region \nPolymorphism: We support classes and methods meth ::= t mn((tv) *) eb with region polymorphism. In addition, \nregion-polymorphic recursion is supported for methods (but not for classes). These eb ::= {(tv) * e} \nfeatures provide an inference algorithm that is precise and yet e ::= (cn) null | k | v | v.f | eb | \nnew cn(v *) | v.f = e | v = e | v.mn(v *) | mn(v *) | e1 ; e2 ef.cient. | if v then e1 else e2 Class \nInheritance: Our inference scheme supports class sub\u00ad typing and method overriding. Previous systems \n[16] require (a) The Source Language phantom regions to support inheritance, which causes a loss in lifetime \nprecision. We propose an improved solution P ::= def* meth* Q (without phantom regions) where modular \ncompilation can be guided by a global dependency graph. def ::= class ca1 extends ca2 where rc {.eld* \nmeth* } ca ::= cn(r +) Correctness: We state a correctness theorem that our infer\u00ad prim ::= int | bool \n| void ence scheme always leads to well-typed programs that are t ::= cn | prim region-safe. Such well-typed \nprograms are guaranteed not to t ::= t(r *) create dangling references in either the store or the stack. \n.eld ::= tf Downcast Safety: We provide a compile-time analysis which meth ::= tmn(r *)((t v) *) where \nrc eb ensures that downcast operations are region-safe. Previous eb ::= {(t v) * e} proposals (e.g. [7]) \nrequire runtime checks for downcast op\u00ad e ::= (ca) null | k | v | v.f | eb erations. | new ca(v *) | \nv.f = e | v = e | v.mn(r *)(v *) | mn(r *)(v *) | e1 ; e2 Implementation: We have built a prototype implementa\u00ad \n | if v then e1 else e2 | letreg r in eb tion of our region inference system. Preliminary experiments \nrc ::= r1 ; r2 | r1 = r2 | r1 = r2 | suggest that our inference is competitive with hand annota\u00ad | rc1 \n. rc2 | true | q(r1, .., rn) tion. Q ::= {(q(r1, .., rn) = rc) * } The remainder of the paper is organised \nas follows. Sec 2 intro\u00ad(b) The Target Language duces the Core-Java language and its region-annotated \ntarget form. Sec 3 presents a set of guidelines for good region annotations; we use these guidelines \nto structure our region inference rules. Sec 4 Figure 1: The Syntax of Core-Java is devoted to region \ninference. It formalises the region inference rules and describes how method override con.icts can be \nresolved. It also presents the key correctness theorem. Sec 5 deals with the + syntactic terms separated \nby appropriate separators, while s rep\u00adinference of additional regions to ensure safe downcast operations. \nresents a list of one or more distinct syntactic terms. The syntactic Sec 6 reports on preliminary experiments \nwith our implementation terms could be v, r, (tv), .eld, etc. For example, (tv) * denotesof the region \ninference algorithm. Sec 7 discusses related work; (t1 v1,...,tn vn) where n=0. Sec 8 contains the conclusion. \n The constraint r1;r2 indicates that the lifetime of region r1 is not shorter than that of r2. The constraint \nr1=r2 denotes that r1  2. CORE-JAVA AND REGION TYPES and r2 must be the same region, while r1 =r2 denotes \nthe converse. Fig 1(a) presents the syntax of a Java-like language named Core-Our algorithm will infer \nregion constraints only of the form r1;r2 Java. Core-Java is the source language for our region inference \nor r1 =r2 but never of the form r1=r2. However, r1=r2 is present system. Core-Java is designed in the \nsame minimalist spirit as in our syntax because a region checking system which we have also Featherweight \nJava[30]. It supports assignments but remains an built supports it. Note that this is a reserved data \nvariable referring expression-oriented language. Loops are omitted in our syntax as to the current object, \nwhile heap is a reserved region to denote a they are dealt with through conversion to equivalent tail-recursive \nglobal heap with unlimited lifetime, that is .r \u00b7 heap ; r. methods. To mimic the effects of loops, such \nconverted methods A constraint abstraction [27] of the form q(r1, .., rn) = rc de\u00addiffer from user-de.ned \nmethods in that they pass their parameters notes a parameterized constraint. For uniformity, the region \ncon\u00adby reference instead of by value. This conversion is for inference straint of each class and method \nwill be captured with a constraint purposes only; the generated program executes the loop directly. abstraction. \nThe region constraint for each class is also known as Fig 1(b) presents region-annotated Core-Java, the \ntarget language the class invariant and is denoted using inv.cn(r1, .., rn). The re\u00adfor our region inference \nsystem. This language extends Core-Java gion constraint for each method is also known as the method pre\u00adwith \nregion types and region constraints for each class and method. condition and is denoted using pre.m(r1, \n.., rn), where m is either In addition, letreg declarations introduce local regions with lexical cn.mn \nor mn, depending on whether it is an instance method or a scopes. static method. Note that mn denotes \na method name. The set of Note that r denotes a region variable and v represents a data vari-constraint \nabstractions generated for a given program is denoted by able. The suf.x notation s * denotes a list \nof zero or more distinct Q. It is possible to inline the constraint abstractions, after .xed\u00adgions of \nthe parameters and results of each method) distinct, class Pair(r1,r2,r3) extends Object(r1) where possible. \nwhere r2>r1 . r3>r1 {Object(r2) fst Object(r3) snd Keep region constraints on classes and methods separate. \nObject(r4) getFst(r4)() where r2>r4 {fst} Region constraints on classes capture the expected class in\u00ad \nvoid setSnd(r4)(Object(r4) o) where r4>r3 {snd=o}Pair(r4,r5,r6) cloneRev(r4,r5,r6)() variant (including \nthe no-dangling requirement) on the re\u00ad where r2>r6.r3>r5 gions of each object of the class. Region constraints \non meth\u00ad { Pair(r4,r5,r6) tmp=new Pair(r4,r5,r6)(null,null); ods denote the precondition for invoking \nthe method. tmp.fst=snd; tmp.snd=fst; tmp }void swap() where r2=r3 {Object(r2) tmp=fst; fst=snd; snd=tmp \n} Use region subtyping, where applicable, to improve the pre\u00ad } cision of the lifetimes of the regions. \n(a) class List(r1,r2,r3) extends Object(r1) The .rst principle allows more region polymorphism, where \nap\u00ad where r3>r1.r2>r3.r2>r1 {Object(r2) value plicable. The second principle places the region constraints \nthat List(r3,r2,r3) next must hold for every object of a given class in the class, while plac\u00ad Object(r4) \ngetValue(r4)() where r2>r4 {value} ing the region constraints for each method invocation in the method. \nList(r4,r5,r6) getNext(r4,r5,r6)() where r5=r2.r6=r3 {next} Placing region constraints with methods \nwhere possible allows these void setNext(r4,r5,r6)(List(r4,r5,r6) o) constraints to be selectively applied \nto only those objects which where r5=r2.r6=r3.r4=r6 {next =o} may invoke the methods. As we shall see \nlater, this principle is } helpful also to ensure the safety of method overriding. The third (b)  principle \nallows an object from a region with longer lifetime to be Figure 2: The Pair and List Classes assigned \nto a location where a region with a shorter lifetime is ex\u00adpected. This concept was pioneered in a safe \ndialect of C, called point analysis has been applied to obtain closed-form formulae for Cyclone[26], \nand is implemented as region subtyping. We shall recursive constraints. see how this idea improves \nthe precision of region lifetimes and Each class de.nition in the target language is parameterized with \nhow it can be further enhanced. one or more regions to form a region type [32, 33, 16, 9]. For instance, \ncn(r1, ..., rn) is a class annotated with region parameters 3.1 Regions for Field Declarations r1...rn. \nParameterization allows us to obtain a region-polymorphic Consider the Pairclass. As there are two .elds \n(or components) type for each class whose components can be allocated in different in this class, we \nintroduce a distinct region for each of them, as regions. The .rst region parameter r1 is special: it \nrefers to the shown in the region-annotated version in Fig 2(a). To ensure that region in which a speci.ed \nobject of this class will be allocated. every Pair object satis.es the no-dangling requirement, we also \nThe components (or .elds) of the objects, if any, are allocated in the add r2;r1.r3;r1 to the class invariant. \nother regions r2...rn which should outlive the region of the object. Next consider the List class with \nnext as its recursive .eld. This is expressed by the constraint .ni=2(ri ; r1), which captures There \nare many different ways of annotating such recursive .elds; the property that the regions of the components \n(in r2...rn) should the best choice depends on how the objects are manipulated. To have lifetimes no \nshorter than the lifetime of the region (namely keep matters simple, we use a special form of region-monomorphic \nr1) of the object that refers to them. This condition, called no\u00adrecursion for class declarations, similar \nto Tofte/Birkedal s han\u00addangling requirement, prevents dangling references completely, as dling of data \nstructures[32, 4], but with support for region subtyp\u00adit guarantees that each object will never reference \nanother object in ing. We introduce a distinct region especially for all the recursive a younger region. \nWe do not require region parameters for primitive .elds. This approach ensures that each recursive .eld \nwill have types, since primitive values are copied and therefore always stored the same annotation as \nits class, except for its .rst region. Given directly in either the stack or inside its owner object. \n* a recursive class declaration with region type cn(r1,r ,rn),we Each class declaration has a set of \ninstance methods whose main * shall annotate each of the .elds as cn(rn,r ,rn). In the case of purpose \nis to manipulate objects of the declared class. The instance the List class, the region r3 is reserved \nspecially for the recursive methods of a subclass can override the instance methods of the su\u00adnext .eld, \nas illustrated in Fig 2(b). We handle mutually recur\u00adperclass. For completeness, we also provide a set \nof static methods sive class declarations similarly. For simplicity, we ignore mutual with similar syntax \nas instance methods, but without overriding and recursive class declarations in this paper, even though \nour imple\u00adwithout access to the this object. These two categories of meth\u00admentation supports them. ods \nare easily distinguished by their calling conventions. Every Based on the above guidelines, the constraint \nabstractions for the method in the target language is decorated with zero or more re-Pair and List classes \nare: gion parameters; these parameters capture the regions used by each method s parameters and result. \nEach method also has a region inv.Pair<r1,r2,r3> = r2;r1.r3;r1 lifetime constraint that is consistent \nwith the operations performed inv.List<r1,r2,r3> = r3;r1.r2;r3.r2;r1 in the method body. Fig 2 presents \ntwo example classes, the Pair and List classes, in the target language. 3.2 Region Subtyping Principle \nWe investigate three versions of the region subtyping rules; the 3. REGION ANNOTATION GUIDELINES versions \ndiffer in the precision of the inferred region lifetimes: To support region-based programming, our region \ninference al\u00adgorithm adds region parameters and constraints to each class and no (region) subtyping \n its methods. There are a number of ways to perform such region object (region) subtyping annotations. \nThe following principles guide our approach: Keep the regions of components in each class (and the re- \n.eld (region) subtyping The .rst kind of subtyping was used in [9] and [16]. The second kind was introduced \nin [26]. In this paper, we advocate the third kind of region subtyping (which subsumes the second kind) \nwith enhanced support for the regions of immutable .elds. Object region subtyping relies on the fact \nthat once an object is allocated in a particular region, it stays within the same region and never migrates \nto another region. This immutability property allows us to apply covariant subtyping to the region of \nthe current object. However, the object .elds are mutable (in general) and must therefore use equivariant \nsubtyping to ensure the soundness of sub\u00adsumption. By reserving the .rst region exclusively for the region \nof each object, we can therefore use the following two subtype rules. . n .=(x1; (xi= .=[ .xi]n x1) . \ni=2xi) xii=1 ft(x1..n)<: t(x 1..n),. |. class cn(r1..n)extends cn\" (r1..m)\u00b7\u00b7\u00b7 .P\" fcn\" (x1..m)<: cn\"\" \n(x\"),.|. 1..p fcn(x1..n)<: cn\"\" (x\"1..p),.|. Note that x1;x 1 allows an object in a region with a longer \nlife\u00adtime to be assigned to a location that expects objects in a region with a shorter lifetime. For \nthe other regions (that are used by . n the .elds), a stronger equivariant constraint i=2(xi= xi) would \nbe used instead. The second rule is for the class subtype hierarchy. Both rules return a region constraint \n. and a region substitution .. The latter may be used if we are interested in only equivariant sub\u00adtyping. \nOne example where object region subtyping is useful is the following: void foo (Object a, Object b) \n{Object tmp; if ... then tmp=a else tmp=b; ... } Without object subtyping, the dual assignments of \nboth a and b to tmp cause their regions to be coalesced together and generate the constraint ra =rb (where \nra and rb are the regions for a and b). With object subtyping, regions of a and b may be different, as \nlong as they both outlive the region of tmp. This concept of region subtyping can be further extended \nto se\u00adlected .elds if they are immutable after object initialization. The .elds of recursive structures \nare particularly important as they may involve many objects that are typically grouped into the same \nre\u00adgion. We use an isRecReadOnly function to check if a class has immutable recursive .elds or not. With \nthis information, we can support a more precise region subtyping rule, namely: . n- 1 isRecReadOnly(t) \n.=(x1; (xi= xi) .(xx n) x1) . i=2 n;ft(x1,..,x x,.|[ n)<: t(x1,.., n)xi.xi]n i=1 One advantage of this \n.eld region subtyping rule is that it allows each recursive object to be placed in a region that is different \n(and may have a longer lifetime) from that of the prior object in the recursive chain. Such a feature \nis important for recursive methods that build temporary data structures during recursive invocations. \nAn example is the following function, called Reynolds3, that was highlighted in [22, 4]. Bool search \n(RList p, Tree t) {if isNull(t) then false else {Object x; x=t.value; if member(x,p) then true else \n{RList p2; p2=new RList(x,p); if search(p2,t.left) then true else search(p2,t.right) }}} We use RList \nto denote a list structure with an immutable re\u00adcursive .eld. Applying region inference with .eld subtyping, \nwe are able to obtain a target program where the region for variable p2 is localised. Unlike previous \nwork[32, 4], the performance of such a region-inferred program is comparable to that obtained by escape \nanalysis[22]. We thus advocate for region subtyping to be used, where possible, to obtain better region \nannotations. 3.3 Regions for Method Declarations For each method declaration, we must provide a set of \nregions to support the parameters and result of each method. For simplic\u00adity, no other regions will be \nmade available for our methods. All regions used in each method will thus be mapped to these region parameters, \nor to the heap. We must also provide region lifetime constraints over such re\u00adgion parameters (including \nthe regions of thisobject). These con\u00adstraints naturally depend on how the method manipulates the ob\u00adjects. \nConsider the getFst, setSndand cloneRevmethods of the Pairclass. We introduce a set of distinct region \nparameters for the methods parameters and results, as shown in Fig 2(a). Moreover, the region (lifetime) \nconstraints are based on the possible opera\u00adtions of the respective methods. For example, due to an assignment \noperation and region subtyping, we have r4;r3for setSnd, while r2;r6.r3;r5 are due to copying by the \ncloneRevmethod. Consider the swap method. No region parameters are needed in this method as it does not \nhave any parameters or result in its declaration. However, a region constraint r2=r3is still present \ndue to the swapping operation on the current object itself. Though this constraint is exclusively on \nthe regions of the current object, we associate the constraint with the method. In this way, only those \nobjects that might call the method will be required to satisfy this constraint. The region constraints \nfor methods also contain the class invari\u00adants of its parameters and result. For example, the region \nconstraint for cloneRevimplicitly includes the class invariant r6;r4.r5;r4 of the resulting type Pair(r4,r5,r6). \nFor simplicity, we omit the presentation of such constraints in this paper; these constraints can be \neasily recovered from the method s type signature. Except for this omission, the constraint abstractions \nfor the various methods of the Pair class are as shown below: pre.Pair.getFst<r1,r2,r3,r4> = r2;r4 pre.Pair.setSnd<r1,r2,r3,r4> \n= r4;r3 pre.Pair.cloneRev<r1,r2,r3,r4,r5,r6> = r2;r6.r3;r5 pre.Pair.swap<r1,r2,r3> = r2=r3 3.4 Regions \nfor SubClass Declarations Subclasses typically augment the superclass with additional .elds and methods. \nCorrespondingly, the regions of each subclass are ex\u00adtended from its superclass, while its invariant \nrepresents a strength\u00adening from the invariant of its superclass. These requirements are needed to support \nclass subsumption. Consider: class A(r1..rm) extends Object(r1) where .A ... class B(r1..rn) extends \nA(r1..rm) where .B ... We expect the regions of the subclass B, namely (r1..rn),tobe an extension of \nA, namely (r1..rm), with n=m. Likewise, the region invariant of .B is a strengthening of .A, with the \nlogical implica\u00adtion .B . .A. These requirements allow an object of the B class to be safely passed to \nany location that expects an A object, as the invariant of the latter will hold by implication. Method \noverriding poses another challenge which requires sub\u00adtyping of functions to be taken into account. In \ngeneral, the method of a subclass is required to be a subtype of the overridden method. Function subtyping \nin object-oriented programs is sound if the nor\u00admal parameters are contravariant and the selection parameters \nare covariant [12]. Consider a method mn in class A that is overridden by another method mnfrom the Bsubclass. \nLet us assume that these two meth\u00adods have the following method signatures, where X,Y denote some arbitrary \nclasses with regions r1\" ,...,r p\" . \"\" Y A.mn (r1,...,r )(X a) where .A.mn {...} p \"\" Y B.mn (r1,...,r \n)(X a) where .B.mn {...} p The constraints .A.mn and .B.mn are preconditions for the region parameters \nof A.mnand B.mn, respectively. These parameters must be contravariant for function subtyping, requiring \n.A.mn . .B.mn. With the class invariant of B (as selection parameter), it is also safe to weaken this \nsoundness check to .B . .A.mn . .B.mn. The class invariant of B can be used as this method is only invoked \nwhen the current object is of the B class. Hence, strengthening .B may help the method satisfy this soundness \ncheck. Its inclusion is critical to our approach for handling method overriding without phantom regions. \nMethod overriding is particularly challenging for region infer\u00adence. We shall introduce some techniques \nto ensure the compliance of the overriding checks in Sec 4.4, after the basic region inference method \nhas been presented.   4. REGION INFERENCE We formalise a comprehensive set of type rules for region \ninfer\u00adence. We then present some examples that illustrate the inference process. We also formalise the \nanalysis of the global dependency graph to guide the inference process, and describe how class sub\u00adtyping \nand method overriding can be supported. We then state a theorem on the correctness of our region inference. \n 4.1 Region Inference Rules The goal of region inference is to automatically derive region annotations. \nThat is, given any program P written in Core-Java, a program P \" with appropriate region annotations \ncan be derived via our region inference rules. For simplicity, we assume the inputs to our region inference \nal\u00adgorithm are well-normal-typed programs. The normal type sys\u00adtem for Core-Java can be derived from \nthe region type checking system (given in a companion report [14]) by erasing all region\u00adrelated notations. \nThat is, if . P \" , then .N erase(P \" ). Notice that .N denotes the well-normal-typedness of source programs \nwritten in Core-Java. The de.nition for the erasure function is straightfor\u00adward and thus omitted here. \nFig 3 presents the complete set of region inference rules. Our rules assume that source program P is \nglobally available. Some of our rules also assume that the target program P \" is also avail\u00adable. This \nis possible as we perform region inference in stages, in accordance with the calling hierarchy with the \nhelp of the global dependency graph. 4.1.1 Class Declarations The inference rule [CD] for class declarations \nhas the form: . def . def \" , Q Note that def is the source code, while def \" is the region-annotated \ntarget with Q to capture the constraint abstractions obtained during inference. For each class declaration, \nwe must designate regions for the objects of that class and their components. We also add region lifetime \nconstraints to each class based primarily on the constraints of its .elds. Region inference for class \ndeclaration is conducted in an induc\u00adtive manner, by inferring regions for the .elds .rst, and then sepa\u00adrately \napplying region inference to the instance methods. The rule uses split(fds, cn2 ) to separate out the \nnon-recursive .elds from the recursive .elds. Recursive (and mutual recursive) .elds should have the \nsame region annotation as the class, except for the .rst region. Note that the region invariant of each \nclass cn is captured by a constraint abstraction, named inv.cn. 4.1.2 Method Declarations The inference \nrule [MD] for method declarations has the form: G . meth . meth \" , Q This rule can be used for both \ninstance and static methods, with G={this : cn(r +)} for the former and G=\u00d8 for the latter. It infers \nnecessary region variables for each method, and calculates lifetime constraints that should be imposed \non them. Note that this rule generates a fresh set of regions for the parameters and result of each method. \nThe method s body is inferred with a type t0\" (x0* )and region lifetime constraint, .. This annotated \ntype must be a subtype of the expected output type, t0(r0 * ). 4.1.3 Expressions The inference rules \nfor expressions have the following form: G . e . e \" : t,. Note that G is the type environment where \ntypes are annotated with regions. e, e \" are resp. the unannotated expression and the region annotated \ncounterpart. t is a region type, while . is the derived region constraint. We next discuss the rules \nfor instance method invocations and local region declarations. Rule [EMI] is the region inference rule \nfor instance method invo\u00adcations. The rule gathers the respective method s region constraint suitably \nmodi.ed by a region substitution obtained from equivari\u00adant instantiation. We use a substitution to ensure \nthat the region of each actual argument is mapped to the region of its corresponding parameter. We implicitly \napply the region subtyping principle as we assign each parameter to its corresponding local variable \nin our implementation of the call-by-value parameters. The gathered re\u00adgion constraint is then imposed \nas a precondition on each method invocation. The rule [EB] is a key inference rule that governs how regions \nmay be localised at each expression block. It attempts to identify regions that are effectively dead \nthereafter. Those regions that may escape the block can be traced to regions that exist in either the \ntype environment or the result type. All regions that outlive these regions also escape. It may also \nbe possible that none of the regions can be localised. This is signi.ed by rs=\u00d8, where we would just \nreturn the annotated expression block without letreg.  4.2 Examples We next illustrate our region inference \nrules via some examples. 4.2.1 Localised Regions Consider an example with four Pair objects that are \nconnected as shown in Fig 4(a). Its code fragment is given in Fig 4(b). As shown in Fig 4(c), our inference \nrules would initially annotate each local variable and constructor with new distinct regions and pro\u00adceed \nto gather the constraints from each sub-expression. A set of equality and outlive constraints will be \ncollected and simpli.ed; these constraints can be applied to reduce the number of distinct regions. [CPT][OBJ][CCT][EF] \nr=fresh() class cn(r1..n)... where . {...}.P' a1..n =fresh() (v : cn(x+)) .G f(t(x'* )f) .cn(x+)fprim \nprim(), true fObject Object(r), true fcn cn(a1..n), ([ri i=1 .)G fv.f .ai]n v.f : t(x'* ), true [EV][EC1][EC2][ES] \nv : t(r * ). G fcn cn(r+),. G fei e': ti,.i i =1, 2 i '' G fv v : t(r *), true G f(cn)null (cn(r+))null \n: cn(r+), true G fk k : primk(), true G fe1 ; e2 e1 ; e2 : t2,.1..2 [EA][EN][EIF] lhs = v |v.f fcn cn(x \n+),.0 (v0 : bool()) . G G fe e' : t' ,.' .eldlist(cn(x +))= [(ti fi)]p G fe1 e1': t1,.1 i=1 ''' G flhs \nlhs : t, true (vi : t) .G fti <: ti,fi i=1..p G fe2 e2 : t2,.2 i ' p ft<: t,f . = .' .f. = .0 .(t, .3)= \nmsst(t1,t2) . = .1 ..2 ..3 i=1 fi G flhs = e lhs = e' : void,. G fnew cn(v1..p) new cn(x+)(v1..p): cn(x+),. \nG fif v0 then e1 else e2 if v0 then e1'else e2': t, . [EMI][EMS] *** + ** (t0(x0 )mn(y )((tj (x )vj \n)j:2..p) where .eb) . methlist(cn(x1 )) (t0(x0)mn(y * )((ti(x )vi)i:1..p) where .eb) . P' j i ''*''+ \n (v': t'(x'*)) .G i =1..p (vj : tj'(xj )) .G j =2..p v1 : cn(x1 ).G i ii *''** '* fti(xi )<: ti(xi ),.i \ni =1..p ftj (xj )<: tj (xj ),.j j =2..p ''*'''* 0] * .x.x . = .1 ... .p [x0.xx=fresh() . = .2 ... .p \n[x0 0] * [x1 1]+ x=fresh() 00 '''''*'''''* G fmn(v1, ..., v) mn(.y * )(v1, ..., v): t0(x0 ),.. G fv1.mn(v2, \n..., v') v1.mn(.y* )(v2, ..., v'): t0(x0 ),.. [CD] pppp [EB] def2 = class cn2 extends cn1 {fd* (methi)1..q} \n* ),.j ,j =1..p f tj * tj(xj ' split(fd* , cn2)= ([(ti fii=1, [(cn2 fii=p+1) tid=cn2 )]p )]n i=1..pG, \n{vj : tj(x j )}j:1..p fU e e: t(r * ),. fti ti(r * ),.i i=1..p .0 =(r>r1 . p<n . true) pp * i . = st(. \n.}, reg(G)) ** j=1 .j, Uj=1{xj ca2 =(cn2(r1..l,r1..p,r). p<n . cn2(r1..l,r1..p))G= {this : ca2} pp ** \n rs = ors(. .j=1 .j , reg(.) .j=1{xj }, {r }.reg(G)) fcn1 G fmethi meth'; Qi,i=1..q cn1(r1..l),.1 i \np pp * rsde = letreg r in .' )vj )j:1..p def r=fresh() .' = {x .' = .((. .j=1 .j )\\rs) Q' = {inv.ca2 \n=(.1 ..>r1) . .0)} .r |.x .rs} *' } 'i=1 .ii=1(ri =\u00d8. . {(tj(xe= class ca2 extends cn1(r1..l)where . \nj 2 *' ** rs=\u00d8.e = . {(tj (xj )vj )j:1..p e}{(ti(ri )fi)1..p, (cn2(r, r2..l,r1..p,r)fi)p+1..n, (methi')1..q} \nU q G f{(tj vj )j:1..p e} e : t(.r * ),.' fdef2 def2' ; Q' . i=1 Qi [MD] [PROG] * meth = t0 mn((tj \nvj )j:2..p) eb fti ti(ri ),.i i=0, 2..p P = def1..n meth1..m ** G, (vj : tj(rj ))j:2..p feb eb' : t0' \n(x0),. fdef defi def'i; Qi i . 1..n * + (m,r1 )= ((pre.cn.mn,r ) . (this : cn(r +).G) . (pre.mn, [])) \n{}fmethi meth'i; Q'i .1..m UU i * * **** ft0'(x0)<: t0(r0 ),f y = r1 ,..,r ,r .' = m(y * ) Q'' = nm \np0 i=1 Qi . i=1 Q'i meth' = t0(r0 * )mn(y * )((tj(r * )vj )j:2..p) where .' (eb' ) P' = def'meth'Q'' \nj 1..n 1..m p G fmeth meth' ; {.' =(. ..0 .i=2 .i .f)}fP P' fP P' def .P' fP P' meth .P' (tf) ..eldlist(cn(x \n* )) ft1 <: t2,. | . ft1 <: t2,. |. ft1 <: t2,. |. def .P meth .P f(tf) .cn(x *)ft1 <: t2,. ft1 <: t2,. \nt1 <: t2 fti<:t, fi,i=1, 2 class cn1(r1..n)extends cn2(r1..m).. {(ti fi)i:1..p methj:1..q}.P (.t \u00b7(t1<: \nt) .(t<: x1..n =fresh() )) t) .(t2<: t)(\u00a31,\u00a32)= mbrlist(cn2(x1..m. =[ri.xi]n i=1 msst(t1,t2)=df (t, \nf1.f2) mbrlist(cn1(x1..n))=df (\u00a31+i=1,\u00a32+j=1) mbrlist(Object(r))=df ([ ], []) +[(.ti) fi]p +[(. methj)]q \nmbrlist(cn(x1..n))=(\u00a31,\u00a32) mbrlist(cn(x1..n))=(\u00a31,\u00a32) name(meth)d) =name(meth' meth.\u00a3 .eldlist(cn(x1..n))=df \n\u00a31 methlist(cn(x1..n))=df \u00a32 meth.(\u00a3++[meth]) meth.(\u00a3++[meth' ]) split(fdl, cn)=(l1,l2) t=dcn split(fdl, \ncn)=(l1,l2) t=cn x.s split([ ], cn)=df ([ ], []) split([(tf)]++fdl, cn)=df ([(tf)]++l1,l2) split([(tf)]++fdl, \ncn)=df (l1, [(tf)]++l2) sel(s)=df x ** reg({})=df {} reg({(v : t(r ))}.G)=df {r }.reg(G) reg(true)=df \n{} reg(r1=r2)=df {r1,r2} reg(r1>r2)=df {r1,r2} reg(c..)=df reg(c).reg(.) name(t0 mn(..)..)=df mn st(., \ns1,s2)=df {x ) |x.s1 .sx ={y |y.s2...(x=y)}.sx=\u00d8} .sel(sxd ors(., s1,s2)=df {r |r .s1 ..r' . s2 \u00b7(. .r \n>r' )} ors(., s1,s2)=df s1 -ors(., s1,s2) {.1, if b fresh() returns one or more new/unused region names \n.1 . b . .2 = df .2, otherwise Figure 3: Region Inference Rules p1 {Pair(r4,r4a,r4b) p4 = letreg r in \n.. new Pair(r4,r4a,r4b)(null,null); { Pair(r4,r4a,r4b) p4 = p2 p3 //r4a>r4 . r4b>r4 new Pair(r4,r4a,r4b)(null,null); \n.. Pair(r3,r3a,r3b) p3 = //r4a>r4 . r4b>r4 p4 new Pair(r3,r3a,r3b)(p4,null); Pair(r,r,r) p3 = // r3a>r3 \n. r3b>r3 . r4>r3a new Pair(r,r,r)(p4,null); (a) Acyclic data structure Pair(r2,r2a,r2b) p2 = Pair(r2,r2a,r2b) \np2 = new Pair(r2,r2a,r2b)(null,p4); new Pair(r2,r2a,r2b)(null,p4);{Pair p4=new Pair(null,null); // r2a>r2 \n. r2b>r2 . r4>r2b // r2a>r2 . r2b>r2 . r4>r2b Pair p3=new Pair(p4,null);  Pair(r1,r1a,r1b) p1 = Pair(r,r,r) \np1 = Pair p2=new Pair(null,p4);  new Pair(r1,r1a,r1b)(p2,null); new Pair(r,r,r)(p2,null); Pair p1=new \nPair(p2,null);  // r1a>r1 . r1b>r1 . r2>r1a p1.setSnd(r)(p3); p1.setSnd(p3);  p1.setSnd(r3)(p3); // \nr3>r1b p2 p2 } p2 }} (d) Final region-annotated program. (b) Source program (c) Initial region-annotated \nprogram. Figure 4: Example with Localised Region {Pair(r1,r1a,r1b) p1 = {Pair(r1,r1a,r1) p1 = new Pair(r1,r1a,r1b)(null,null); \nnew Pair(r1,r1a,r1)(null,null); p1 p2  //r1a>r1 . r1b>r1 //r1a>r1 Pair(r2,r2a,r2b) p2 = Pair(r1,r1,r2b) \np2 = (a) Cyclic data structure new Pair(r2,r2a,r2b)(p1,null); new Pair(r1,r1,r2b)(p1,null); // r2a>r2 \n. r2b>r2 . r1>r2a // r2b>r1 p1.setSnd(r2)(p2); // r2>r1b p1.setSnd(r1)(p2); {Pair p1=new Pair(null,null); \n p2 p2 Pair p2=new Pair(p1,null);  }} p1.setSnd(p2); p2 } (c) Initial region-annotated program (d) \nFinal region-annotated program (b) Source program Figure 5: Example with Circular Structure The result \ntype of this block is Pair(r2,r2a,r2b), with the constraints r4a;r4.r4b;r4, r3a;r3.r3b;r3.r4;r3a, r2a;r2.r2b;r2.r4;r2b \n, r1a;r1.r1b;r1.r2;r1a, and r3;r1b. Based on these type and region lifetime constraints, our rule can \ndeduce that all the regions escape this block, except for regions r1,r1a,r1b,r3,r3a,r3b. These non-escaping \nregions will be localised to a single region (say r), as shown in Fig 4(d).  4.2.2 Circular Structures \nBecause of the outlives constraint from the no-dangling require\u00adment, every cyclic structure must be \nplaced in the same region. Consider the code fragment in Fig 5(b), which constructs a cyclic structure \ninvolving two Pairnodes, p1and p2, as shown in Fig 5(a). The initial region-annotated program is shown \nin Fig 5(c). Af\u00adter constraint simpli.cation to coalesce equal regions together, we obtain the target \nprogram in Fig 5(d). Notice that p1 and p2 are initially placed in regions r1 and r2, respectively. However, \nthe region constraint gathered, namely r2;r1b.r1b;r1.r1;r2a. r2a;r2, implies that r1=r2=r1b=r2a. Applying \nthis extra con\u00adstraint causes the two objects to be located in the same region. The resulting type of \nthis block is Pair(r1,r1,r2b)with the region constraint r2b;r1.r1a;r1. As all declared regions es\u00adcape \nfrom this expression block, the [EB] rule does not introduce any localised regions.  4.2.3 Recursive \nMethods We discuss the inference of region annotations and constraints for recursive methods. Fig 6(a) \ncontains a static method which merges two lists of objects. Because the method swaps its parame\u00adters \nat the recursive call, the resulting list contains alternating ele\u00adments from both lists. Region inference \nwould introduce a constraint abstraction, called pre.join, and build a de.nition for it, as shown in \nFig 6(c) (after simpli.cation). As the constraint abstraction is recursive, we ap\u00adply a .xed-point analysis \nto obtain its closed-form formula. Start\u00ading with the initial version of pre.join0, we progressively \nre.ne the de.nition of pre.join until a .xed-point is reached, as high\u00adlighted in Fig 6(d). Fixed-point \nanalysis always terminates for our constraint abstrac\u00adtion the .nite set of possible constraints is \nmade up from a bounded set of regions. This example relies on region-polymorphic recursion, without which \nsome loss in lifetime precision occurs. Note that each recursive call has a different region type (c.f \nregion parameters) from its caller.  4.3 Global Dependency Graph Because of the inter-dependency between \nclasses and methods, our region inference system must process the classes and methods in a speci.c order. \nThis order supports hierarchically structured programs and inheritance and is important for modular compila\u00adtion. \nFor this purpose, we propose a set of rules that identify the following kinds of dependencies: cni . \ncnj : denotes cnj is a component or superclass of cni.  mni . cnj : denotes mni made use of class cnj \nin its body.  mni . mnj : denotes mni calls mnj .  cn \" .mn . cn.mn : from override check.  cn . cn.mn \n: from override check.  The .rst three dependencies arise from the constituents of each class and method \n(static and instance), while the last two depen\u00addencies are induced by a method override check of the \nform: \" inv.cn(..).pre.cn .mn(..).pre.cn.mn(..) The inference mechanism for these dependencies is straightfor\u00adward. \nThe details are in our technical report [14]. The .nal depen\u00addency graph has the classes and methods \norganised into a hierarchy of strongly connected components (SCCs). Each set of classes in a SCC will \nbe regarded as a mutual-recursive class declaration for simultaneous processing. Correspondingly, each \nset of methods in a SCC is regarded as a mutual-recursive set for .xed-point analy\u00adsis. Through a bottom-up \nprocessing of each SCC, we are able to perform region inference in a modular and systematic fashion. \nList(r7,r8,r9)join(r1,..,r9)(List(r1,r2,r3)xs, List(r4,r5,r6)ys) List join(List xs, List ys) where pre.join(r1,..,r9) \n{if isNull(xs) then {if isNull(r1,r2,r3)(xs) then if isNull(ys) then (List)null if isNull(r4,r5,r6)(ys) \nthen (List(r7a,r8a,r9a))null // r7a>r7.r8a>r8.r9a>r9 else join(ys,xs) else join(r4,r5,r6,r1,r2,r3,r7b,r8b,r9b)(ys,xs) \n// r7b>r7.r8b>r8.r9b>r9 else {else {Object x; List res; Object(r10)x; List(r11,r12,r13)res; x=xs.getValue(); \nx=xs.getValue(r2)(); // r2>r10 res=join(ys,xs.getNext()); xs=xs.getNext(r1,r2,r3)(); new List(x,res) \nres=join(r4,r5,r6,r1,r2,r3,r7c,r8c,r9c)(ys,xs); // r7c>r11.r8c>r12.r9c>r13 } new List<r14,r15,r16>(x,res) \n} // r10>r15.r11>r14.r12>r15.r13>r16.r14>r17.r15>r8.r16>r9 }} (a) Source program (b) Initial region-annotated \nprogram List(r7..r9)join(r1..r9)(List(r1..r3)xs,List(r4..r6)ys) Q={pre.join(r1..r9)=(r2>r8).pre.join(r4..r6,r1..r3,r7..r9)}where \npre.join(r1..r9) {if isNull(r1,r2,r3)(xs) then pre.join0(r1..r9)= True if isNull(r4,r5,r6)(ys) then (List(r7,r8,r9))null \nelse join(r4,r5,r6,r1,r2,r3,r7,r8,r9)(ys,xs) pre.join1(r1..r9)=r2>r8 .pre.join0(r4..r6,r1..r3,r7..r9) \nelse {=r2>r8 Object(r8)x; List(r9,r8,r9)res; x=xs.getValue(r2)(); pre.join2(r1..r9)=r2>r8 .pre.join1(r4..r6,r1..r3,r7..r9)xs=xs.getNext(r1,r2,r3)(); \n=r2>r8 .r5>r8 res=join(r4,r5,r6,r1,r2,r3,r7,r8,r9)(ys,xs); new List<r7,r8,r9>(x,res) // r2>r8 pre.join3(r1..r9)=r2>r8 \n.pre.join2(r4..r6,r1..r3,r7..r9)}} =r2>r8 .r5>r8 (c) Final region-annotated program (d) Fixed-point analysis \nFigure 6: Region Inference for a Recursive Method 4.4 Override Con.ict Resolution As mentioned in Sec \n3.4, class subtyping and method overriding must comply with their respective checks to ensure the soundness \nof subsumption. The class subtyping check is relatively easy to enforce. The existing [CD] rule already \naccumulates the invariant from each class A to its subclass B in order to ensure: inv.B(r1 ..rn).inv.A(r1 \n..rm ) In contrast, the method overriding check is more complex. Con\u00adsider a class A, its subclass B, \nand a method A.mn overridden by B.mn. For method overriding to be sound, we require the following property \nto be satis.ed: inv.B(r1 ..rn ).pre.A.mn(r1 ..rm , r1 \" ..rp\" ) .pre.B.mn(r1 ..rn, r1 \" ..rp\" ) This \nproperty may not hold initially. To rectify this, the region inference can selectively augment the premise \nof each overriding check, with the following considerations: 1. We can strengthen either the premise \ninv.B(r1..rn) or the premise pre.A.mn(r1..rm,r1\" ..rp\" )or both. 2. Strengthening pre.A.mn(r1..rm,r1\" \n..rp\" )can be problematic as some regions, namely rm+1..rn, are present in class B but not A.  These \ntwo issues can be considered systematically by examining each basic constraint of pre.B.mn(r1 ..rn , \nr1 \" ..rp\" )to determine if it (i) is already valid, or (ii) can be added to pre.A.mn, or (iii) can be \nadded to inv.B, or (iv) can be split into an equality constraint for inv.B and a modi.ed constraint for \npre.A.mn. We formalise this con.ict resolution as the following inference rule: I, X, Y .I \" , X \" Note \nthat I denotes the class invariant of the subclass, X denotes the precondition of the overridden method \n(from the superclass), while Y represents the precondition of the overriding method (from the subclass). \nThe results I \" , X \" are strengthened versions of I, X which satisfy the soundness of overriding. Each \nconstraint is ex\u00ad . pressed as a set of atomic constraints in conjunctive form c, where c = r1=r2 |r1=r2. \nIn the following rules, we assume that RB = {r1..rn}, RX = {r1..rm,r1\" ..rp\" }and RA = {r1..rm}. Note \nthat . : R1.R2 denotes a region substitution with R1(R2) as its domain (co-domain). ctr(.) transforms \nthe substitution . into an equality constraint. For example, ctr([r1 r2,r3.r4]) = . (r1=r2.r3=r4). c \n. Y \u00ac(I . X . c) I . X . Y reg(c) . RX I, X . c, Y f I\" , X\" I, X, Y f I, X I, X, Y f I\" , X\" c . Y \n\u00ac(I . X . c) reg(c) . RB I . c, X, Y f I \" , X \" I, X, Y f I\" , X\" c . Y \u00ac(I . X . c) .. : reg(c) n (RB \n- RA) . RA I . ctr(.), X . .c, Y f I \" , X \" I, X, Y f I\" , X\" We use the following extension of the \nPairclass to illustrate this override resolution mechanism: class Triple(r1,r2,r3,r3a) extends Pair(r1,r2,r3)where \nr2>r1.r3>r1.r3a>r1 { Object(r3a)thd Pair(r4,r5,r6)cloneRev(r4,r5,r6)() where r2>r6.r3a>r5 {Pair(r4,r5,r6)tmp \n=new Pair(r4,r5,r6)(null,null); tmp.fst=thd; tmp.snd=fst; tmp} Two basic constraints are present in \nan overriding cloneRevmethod, namely r2;r6 and r3a;r5. The .rst constraint is already satis.\u00adable, but \nthe second constraint cannot be directly placed in the class invariant of Triple, nor in the precondition \nof Pair.cloneRev. Nonetheless, we can still split it into two constraints r3a=r3 and r3;r5that can be \nadded to inv.Tripleand pre.Pair.cloneRev, respectively. We have a choice of mapping the extra region \nr3a to either r3 or r2 using [r3a.r3] or [r3a.r2], respectively. We choose the former since (r3;r5) exists \nin pre.Pair.cloneRev but not (r2;r5). While multiple solutions exist, we choose a so\u00adlution which minimises \nthe number of new constraints.  5. HANDLING DOWNCASTS class A(r1,r2) ...; class B(r1,r2,r3) extends \nA(r1,r2) ...; One important feature that is missing from Core-Java is the down\u00ad class C(r1,r2,r3) extends \nA(r1,r2) ...; cast operation. In general, this operation may be type unsafe if the class D(r1,r2,r3,r4) \nextends C(r1,r2,r3) ...; object in question is not the expected subtype. Unless both the sub\u00ad class \nE(r1,r2,r3,r4,r5) extends A(r1,r2) ...; : type and supertype have the same set of regions, it may also \nbe A(r1,r2) a; A(r3,r4) a2; possible for the downcasted regions to be wrong. In [7], a type\u00ad if .. then \n passing approach was extended to carry ownership information to a = lb:new B(r1,r2,r5)(..) // B upcast \nto A else .. allow this property to be checked at runtime. If a region error is a = lc:new C(r1,r2,r6)(..) \n// C upcast to A detected at runtime, the blame can still be pinned on the program\u00ad else ..  mer for \nproviding an incorrect region annotation. With automatic a = le:new E(r1,r2,r7,r8,r9)(..) // E upcast \nto A B(r1,r2,r10) b = (B) a; // downcast to B region inference, it is the responsibility of the region \ninference sys\u00ad C(r1,r2,r11) c = (C) a; // downcast to C tem to (at compile time) prevent such a situation. \nLet us see how D(r1,r2,r11,r12) d = (D) c; //downcast to D this problem can be resolved. Downcast and \nupcast represent dual operations. In our present Figure 7: Program Fragment with Downcasts formulation, \nregions may be lost during upcast operations. As a consequence, we are unable to carry out region-safe \ndowncasts, as 4.5 Correctness the lost regions cannot be recovered. The correctness of the type inference \nalgorithm is often de.ned To illustrate the problem, consider the program fragment in Fig 7. in relation \nto a checking system. We have formalised a comprehen- Note that every new statement is labelled with \na unique program sive set of region type checking rules and proven their safety prop-point to identify \nits source location. During the upcast operations, erties in our technical report [14]. In our type system \nfor region-regions r5,r6,r7,r8,r9are lost. These lost regions cannot be re\u00adannotated Core-Java, P .def \ndef denotes that class declaration def is covered when subsequent downcast operations are performed, \nlead\u00adwell-region-typed (or well-typed in short), P;G;R;. .meth meth ing to unknown regions r10,r11,r12. \nindicates that a method meth is well-typed, P;G;R;. . e : t in- To support region-safe downcasting, a \nkey technique is to pre\u00addicates that an expression e is well-typed, while . P denotes that a serve the \nregions that were originally lost during the upcast opera\u00adregion-annotated program P is well-typed. tion. \nWe propose two techniques to preserve these regions. The following theorem states the correctness of \nthe region infer-Our .rst technique preserves lost regions during upcasting by ence algorithm. It guarantees \nthe existence of a well-region-typed equating them with the .rst region. In this way, downcasting can \ntarget program P \" for each well-normal-typed source program P. always be achieved through this .rst \nregion. For example, the fol-By region erasure, we can show that both programs have the same lowing upcast \noperation forces region r3 to be equivalent to r1: observable behaviour (through bisimulation) in the \nabsence of dan-A(r1,r2) a =new B(r1,r2,r3)(..) // r3=r1 gling accesses. The main safety property (proven \nin [14]) is that As a consequence, we can easily recover the lost region during a no dangling reference \nis ever created during the execution of any downcast operation, as follows: well-region-typed expression. \n\u00b7\u00b7\u00b7(B(r4,r5,r6))a\u00b7\u00b7\u00b7// r4=r1.r5=r2.r6=r1 Applying this technique to our earlier program fragment results \nin the following, where the imposed region constraints are shown THEOREM 1(CORRECTNESS). Given any well-normal-typed \nas comments. source program P in Core-Java, there exists a region-annotated program P \" , such that \n. P . and P \" is well-region-typed. P \" A(r1,r2) a; A(r3,r4) a2; if .. then a = lb:new B(r1,r2,r5)(..) \n// r5=r1 else .. The proof of Theorem 1 relies on a global dependency graph and the following Lemma. \nThe details of the proof can be found in a = lc:new C(r1,r2,r6)(..) // r6=r1 [14]. The Lemma states \nthat each part of the inferred program is else .. well-typed, assuming those parts it depends on are \nwell-typed. a = le:new E(r1,r2,r7,r8,r9)(..) // r7=r8=r9=r1 (B(r1,r2,r10)) b = (B) a; // r10=r1 (C(r1,r2,r11)) \nc = (C) a; // r11=r1 P \" LEMMA 2. Suppose . P . . (D(r1,r2,r11,r12)) d = (D) c; // r12=r1 While this \nsolution is simple and modular, some lifetime precision and all classes and static methods that e \" depends \non are are lost due to the additional region equality constraints. well-formed in P \" , then there exists \nR . reg(G) . reg(t), (a). If G . e . e \" : t,., Another solution is to maintain extra regions during \nupcasting such that P \" ;G;R;.. e \" :t. for objects that may be subsequently downcasted. Speci.cally, \nall objects that may be downcasted (to some subclasses) must be (b). If G . meth . meth \" ;Q, padded \nin advance with suf.cient number of extra regions to sup\u00ad and all classes and static methods that meth \n\" depends on are port subsequent region-safe downcasting. A global .ow-based anal\u00ad well-typed in P \" \n, then P \" ;G;R;. .meth meth \" ysis is required to determine the scope to which each object and its \nwhere R = {r1..n,heap},G= {this : cn(r1..n)},.= components may be downcasted. inv.cn(r1..n), if meth \n\" . cn(r1..n);R ={heap},G= \u00d8,.= Based on the earlier program fragment, we can determine that true, otherwise. \n the object a may be downcasted to B,C,D, while the object c may (c). If . def . def \" ;Q, be downcasted \nto D. As the subclass (D) has the maximum number and all classes and static methods that def \" depends \non are of regions, we shall pad both these types with up to four regions, well-typed in P \" , then .def \ndef \" . namely A(r1,r2)[r3,r4] for a, and C(r1,r2,r3)[r4] for c,to support region-safe downcast to either \nB,Cor D. Note that [r3,r4] and [r4] denote the padded regions for a and c, respectively. In contrast, \nthe objects a2 and b are never downcasted and hence we Programs Size (lines) Compile-Time (sec) Param. \nSpace Usage/Total Allocation Diff. in letreg Source Ann. Inference Checking Input No Sub Object Sub Field \nSub RegJava Sieve of Eratosthenes 80 12 0.08 0.14 50000 1 1 1 1 0 Ackermann 67 5 0.02 0.04 (4,7) 0.004 \n0.004 0.004 0.004 0 Merge Sort 170 16 0.35 0.47 50000 0.179 0.179 0.179 0.179 0 Mandelbrot 110 14 0.05 \n0.09 100 0.002 0.002 0.002 0.002 0 Naive Life 114 14 0.08 0.23 10 1 1 1 1 0 Optimized Life (array) 121 \n15 0.09 0.25 10 0.196 0.196 0.196 0.196 0 Optimized Life (dangling) 35 5 0.01 0.04 10 1 1 1 1 -1 Optimized \nLife (stack) 80 10 0.04 0.08 10 1 1 1 1 0 Reynolds3 59 12 0.11 0.29 10 1 1 0.004 - - foo-sum 65 10 0.11 \n0.24 100 0.340 0.010 0.010 - - Figure 8: Comparative Statistics on Inference/Checking and Region Subtyping \ndo not impose any extra regions on their class types. Our earlier program fragment can now be transformed \nto: A(r1,r2)[r3,r4] a; A(r1 ,r2 ) a2; if .. then a = lb:new B(r1,r2,r5)(..) //r5=r3 else .. a = lc:new \nC(r1,r2,r6)(..) //r6=r3 else .. a = le:new E(r1,r2,r7,r8,r9)(..) // not in downcast (B(r1,r2,r10)) b \n= (B) a; // r10=r3 (C(r1,r2,r11)[r12]) c = (C) a; //r11=r3 . r12=r4 (D(r1,r2,r11,r12)) d = (D) c; // \nr12=r4 Note that the extra regions of E, namely r7,r8,r9 are not made equal to the padded regions of \na. The reason is that the E class is not in the set to which this object may be downcasted. Hence, any \ndowncast on this object will fail, regardless of the padded regions. To support this approach to region-safe \ndowncast, we propose a backwards analysis technique to .nd a potential downcast set for each object in \nour program. We .rst provide a set of inference rules to gather a set of backward .ows. The inference \nrule is expressed using the relation: G,x fe, C Note that x is the receiver that may capture the result \nof e under type environment, G. The output C denotes a set of backward .ows that occur in e and its receiver \nx. Each backward .ow is represented using either v1 + v2 or v1- D. v2, where the arrows indicate that \nv1 captures a value from v2. In addition, the second arrow is annotated with a D-class to indicate that \nits source may be subjected to a downcast-to-D operation. The rule for downcast operation is de.ned as: \nG, x f(D) v, {x-D.v} The value of v may .ow into its outer receiver x and be subjected to a downcast \noperation. This is captured by x-D.v. Our technical report provides the details of this .ow inference[14]. \nFor our example, the initial set of .ows is: ......... {a lb, a lc, a le, b-B.a, c-C.a, d-D.c} We can \nproceed to perform a transitive closure to gather all pro\u00adgram points of variable declarations and object \nallocations that could be downcasted. The goal of our analysis is to .nd a set of classes that could \nbe subsequently downcasted for each object at a given location. For each variable, v, or object .eld, \nv.f, we associate a set of casts D using v[D]or v.f [D].These sets are initially empty and are initialised \nby the following rule: v-D.w . w[S] . vw . w[S .{D}] ... For our example, the initial .ow set is converted \nto: ..................a[B, C] . c[D] .{a lb, a lc, a le, ba, ca, dc} Applying a closure of backward .ows \n(see [14]) gives: {b lb, b lc, b le, c lb, clc, c le, d lb, ..................... d lc, d le, da} ......... \nApplying a downcast closure operation gives: a[B, C, D], c[D], lb[B, C, D], lc[B, C, D], le[B, C, D] \n This outcome can guide the padding of extra regions for each variable declaration and object creation \nsite. Moreover, the analysis can sometimes tell if the downcast is bound to fail. For example, all possible \ndowncasts at point le will fail since an E object is created that is not a subclass of B or C or D. Under \nthis scenario, we need not instantiate the padded regions, as region preservation is only required when \ndowncast succeeds. Our approach to downcast safety is achieved at compile-time through global .ow analysis. \nAnother approach is to make use of type polymorphism (advocated in Generic Java [10]). This ap\u00adproach \nis expected to alleviate the need for downcast operations but requires a fundamental change in the design \nof the language. 6. IMPLEMENTATION We have constructed a prototype region inference system for Core-Java. \nThe output from region inference can be veri.ed by a separate type checking system that we have also \nbuilt. The entire system was built using the Glasgow Haskell compiler[31]; we have also added a library \nto solve region outlive constraints. The primary objective of our initial experiments is to evaluate \nthe quality of our automatically inferred region annotations as com\u00adpared to region annotations produced \nby hand. We tested our sys\u00adtem on a set of eight RegJava benchmark programs from [16] that have been \nhand-annotated for their region checking system. Fig\u00adure 8 summarises the statistics for each program. \nThe last column indicates the difference in the number of lo\u00adcalised regions between our inferred annotations \nand those which were hand-annotated in [16]. All annotations are identical, ex\u00adcept for optimized life \n(with dangling). Our inference produces one less local region, since we use the no-dangling policy rather \nthan the no-dangling-access policy of the RegJava checker. For this set of programs, our region inference \nis therefore comparable in performance to human experts. Take note that the region annota\u00adtions occur \nin around 12.3% of the programs lines. This indicates that manually generating the region annotations \nmay represent a sizeable mental effort for a programmer with only a region type checker. Note also that \nthe region inference and region checking times are reasonable for this set of programs, running in less \nthan a second for all of the programs in this benchmark set. We have also compiled the programs to run \non a region-based custom allocator, called Titanium[29], and measured the resulting space utilization \nas compared with the total allocation space of the program. Due to the lack of space reuse, four of the \nprograms have a ratio of one, including optimized life (with dangling) despite an extra localized region. \nFour other examples have signi.cant space reuse but have the same performance for all three kinds of \nregion subtyping. How\u00adever, we achieved signi.cantly better space reuse for Reynolds3 and foo-sum when \nour inference is augmented with object/.eld region Programs bisort em3d health mst power treeadd tsp \nperim. n-body voronoi Source (lines) 340 462 562 473 765 195 545 745 1128 1000 Ann. (lines) 7 32 24 34 \n35 7 12 21 38 50 Inference (seconds) 0.14 0.61 3.58 0.48 0.4 0.07 0.28 1.38 2.88 4.63 Figure 9: Region \nInference Times for the Olden Benchmark Programs subtyping. To check the scalability of our region inference, \nwe con\u00adverted a set of ten programs from the Olden benckmark set[11] to Core-Java, and measured their \ninference times, as shown in Fig 9.  7. RELATED WORK Tofte and Talpin [32, 33] proposed a region inference \napproach for a typed call-by-value .-calculus. In their approach, all values (including function values) \nare put into regions at runtime, and all points of region placement can be inferred automatically using \na type-and-effect based program analysis. The treatment of reference types can be considered as a special \ncase of objects, as it has an out\u00adlives requirement for its values when compared to its location. This \nrequirement is speci.ed indirectly through region effects. Apart from this, their method is tailored \nmainly to functional languages. Christiansen and Velschow proposed a similar region-based ap\u00adproach to \nmemory management in Java [16]. They call their system RegJava and use a stack of lexically scoped regions \nfor memory management. They proposed a region type system and demon\u00adstrated its soundness by linking \nthe static semantics with the dy\u00adnamic semantics. However, their system requires programmers to manually \nannotate programs with region annotations. In their sys\u00adtem, each class is augmented with the full set \nof regions from the entire class hierarchy, including those from its subclasses and its sibling classes. \nWhile this makes downcast operations trivially safe, it uses phantom regions and has a closed-world assumption \non the class hierarchy. Researchers have recently advocated non-lexical regions to sup\u00adport tighter region \nlifetimes[24, 25, 28, 34]. Most of these ap\u00adproaches require programmers to at least indicate when regions \nare to be created, allocated and released. One technique [1] accepts a program with lexically scoped \nregions, then transforms the pro\u00adgram to allow, when possible, late creation and early deletion of these \nregions. This technique is complementary to our approach to region inference, as it could be used as \na post-phase. With an ex\u00adplicit outlives relation on the lexical regions, we have also exploited the \nconcept of region subtyping, as pioneered in [26]. Beebee and Rinard present an early implementation \nof scoped memory for Real-Time Java in the MIT Flex compiler infrastruc\u00adture[3]. They rely on both static \nanalysis and dynamic debugging to help locate incorrect uses of scoped memory. Later, Boyapati et. al. \n[9] combined region types [32, 33, 19, 26, 16] and ownership types [18, 17, 6, 8] in a uni.ed framework \nto capture object encap\u00adsulation and prevent dangling references. The static type system guaranteed that \nscope-memory runtime checks will never fail for well-typed programs. It also ensured that real-time threads \ndo not interfere with the garbage collector. Using object encapsulation, each object and all components \nit owns are put into the same region; in order to optimize on region lifetimes. Our region type system \nis similar to theirs, but we separate out object encapsulation and RTSJ issues. We also infer region \ntypes automatically across procedures, whilst they have limited support through intra-procedure inference \nand the use of defaults in region types. Deters and Cytron [21] automatically translated Java code into \nReal-Time Java using dynamic analysis to determine the lifetime of an object. Because the analysis is \ndynamic, it may not be sound it may miss some execution paths that create and use dangling references \ngiven their extracted object lifetime information. In research performed concurrently with ours, Cherem \nand Rug\u00adina have developed a region inference algorithm for Java [13]. This region inference algorithm \nhandles all of the features of Java, in\u00adcluding inheritance, dynamic dispatch, downcasts, and multithread\u00ading. \nUnlike our inference system, their system uses the no-dangling\u00adaccess principle and produces programs \nthat use non-lexically scoped regions. Our inference system is designed to produce an augmented program \nwith region type annotations; perhaps because non-lexically scoped regions are less amenable to formalisation \nin a region type system, their system produces a program with region handles and region-based memory \nmanagement, but without region types nor region subtyping. 8. CONCLUDING REMARKS Our aim is to provide \na fully-automatic region inference system for a core subset of Java. We achieved this by allowing classes \nand methods to be region-polymorphic, with region-polymorphic recursion for methods. As shown by the \nexamples, the inferred region constraints allow us to obtain fairly precise region annota\u00adtions. We have \nseen how the region lifetime constraints prevent dangling references and generate appropriate region \ninstantiations. There remain a number of areas where improvements are possible. Several directions can \nbe taken to improve memory utilization. The key idea is to put objects into regions with shorter lifetimes, \nwhenever it is safe to do so. As an example, component objects that are owned by another object can be \nplaced in the same region as the latter, since no references exist from outside the owner. This idea \nhas been explored in [9]. Coupled with alias (including ownership) annotations that can be automatically \ninferred, as described in [2], we believe that ownership information can be derived to make this optimization \nfully automatic. We currently give a distinct region type to each occurrence of null values, just like \nnormal objects. However, null values are more akin to primitive values as they can be freely moved between \nre\u00adgions and the stack. To take advantage of this, we could introduce a .ctitious region, denoted by \n., for each null value. Such a region would not exist during the execution of the program since null \nob\u00adjects do not occupy space. The following axioms hold at all times for any r: .;r, r ;., r = .and r \n= .. In combination with an analysis that tracks de.nite occurrences of null values (e.g. [23]), these \naxioms can improve the region lifetime constraints. Our region type rules are .ow-insensitive (within \neach method) but context-sensitive (across methods). The latter is due to our use of region polymorphism \nat method boundaries. Flow-insensitivity may cause some loss in region lifetime precision when the same \nlo\u00adcal variable is used for objects with different lifetime requirements. To rectify this, we could use \nStatic Single Assignment (SSA) in\u00adtermediate form[20] which is known to give better .ow-sensitive analysis \nresults. Conversion of programs to SSA form can be han\u00addled in a preprocessing step, prior to region \ninference. Our current set of rules may introduce localised regions at each expression block. These are \npresently mandated at the bodies of procedures, though in practice they can occur in any subexpression. \nEffective placement of local variable declarations, object alloca\u00adtions and expression blocks can therefore \naffect region placement and the extent to which memory is effectively reused. Another fu\u00adture work is \nto explore suitable liveness analysis and restructuring transformations to further improve the memory \nutilization. Acknowledgments The authors would like to thank William Beebee, Chandrasekar Boyapati, Mong \nLeng Sin, Siau-Cheng Khoo, Corneliu Popeea, Dana Xu and Huu Hai Nguyen for various pointers. Huu Hai \nalso helped with some coding. Special thanks to Fritz Henglein for insightful comments on an earlier \ndraft. The referees of PLDI04 provided many invaluable suggestions, including the use of region subtyping \nwhich we have now adopted. We acknowledge the support of Singapore-MIT Alliance and grant R252-000-092-112. \n 9. REFERENCES [1] A. Aiken, M. Fahndrich, and R. Levien. Better static memory management: Improving \nregion-based analysis of higher-order languages. In ACM PLDI, pages 174 185, 1995. [2] J. Aldrich, V. \nKostadinov, and C. Chambers. Alias Annotation for Program Understanding. In ACM OOPSLA, Seattle, Washington, \nNovember 2002. [3] W. Beebee and M. Rinard. An Implementation of Scoped Memory for Real-Time Java. In \nProceedings of Embedded Software, First International Workshop (EMSOFT 01), Tahoe City, California, October \n2001. [4] L. Birkedal, M. Tofte, and M. Vejlstrup. From region inference to von Neumann machines via \nregion representation inference. In ACM POPL, pages 171 183. ACM Press, January 1996. [5] G. Bollella, \nB. Brosgol, P. Dibble, S. Furr, J. Gosling, D. Hardin, and M. Turnbull. The Real-Time Speci.cation for \nJava. Addison-Wesley, 2000.  [6] C. Boyapati, R. Lee, and M. Rinard. Ownership types for safe programming: \nPreventing data races and deadlocks. In ACM OOPSLA, Seattle, Washington, November 2002. [7] C. Boyapati, \nR. Lee, and M. Rinard. Safe runtime downcasts with ownership types. In Proceedings of the 2003 ECOOP \nWorkshop on Aliasing, Con.nement and Ownership in Object-Oriented Programming, Darmstadt, Germany, July \n2003. [8] C. Boyapati, B. Liskov, and L. Shrira. Ownership Types for Object Encapsulation. In ACM POPL, \nNew Orleans, Louisiana, January 2003. [9] C. Boyapati, A. Salcianu, W. Beebee, and M. Rinard. Ownership \nTypes for Safe Region-Based Memory Management in Real-Time Java. In ACM PLDI, San Diego, California, \nJune 2003. [10] G. Bracha, M. Odersky, D. Stoutamire, and P. Wadler. Making the future safe for the past: \nAdding Genericity to the Java Programming Language. In ACM OOPSLA, October 1998. [11] M. C. Carlisle \nand A. Rogers. Software caching and computation migration in Olden. In ACM PPoPP, pages 29 38, Santa \nBarbara, California (ACM Press), May 1993. [12] G. Castagna. Covariance and contravariance: Con.ict without \na cause. ACM Trans. on Programming Lang. and Systems, 17(3):431 447, May 1995. [13] S. Cherem and R. \nRugina. Region Analysis and Transformation for Java Programs. Technical Report, Computer Science Dept, \nCornell University, April 2004. [14] W.N. Chin, F. Craciun, S.C. Qin, and M. Rinard. Region Inference \nfor an Object-Oriented Language. Technical report, School of Computing, National Univ. of Singapore, \nNovember 2003. avail. at (http://www.comp.nus.edu.sg/~qinsc/papers/reginf.ps.gz). [15] M. V. Christiansen, \nF. Henglein, H. Niss, and P. Velschow. Safe Region-Based Memory Management for Objects. Technical Report \nD-397, DIKU, University of Copenhagen, October 1998. [16] M. V. Christiansen and P. Velschow. Region-Based \nMemory Management in Java. Master s Thesis, Department of Computer Science (DIKU), University of Copenhagen, \n1998. [17] D. G. Clarke and S. Drossopoulou. Ownership, Encapsulation and Disjointness of Type and Effect. \nIn ACM OOPSLA, Seattle, Washington, November 2002. [18] D. G. Clarke, J. M. Potter, and J. Noble. Ownership \nTypes for Flexible Alias Protection. In ACM OOPSLA, October 1998. [19] K. Crary, D. Walker, and G. Morrisett. \nTyped Memory Management in a Calculus of Capabilities. In ACM POPL, January 1999. [20] R. Cytron, J. \nFerrante, B. K. Rosen, M. N. Wegman, and F. K. Zadeck. Ef.ciently computing static single assignment \nform and the control dependence graph. ACM Trans. on Programming Lang. and Systems, 13(4):451 490, 1991. \n [21] M. Deters and R. Cytron. Automated Discovery of Scoped Memory Regions for Real-Time Java. In Proceedings \nof the International Symposium on Memory Management (ISMM 02), June 2002. [22] A. Deutsch. On the complexity \nof escape analysis. In ACM POPL, pages 358 371. ACM Press, 1997. [23] M. Fahndrich and R. Leino. Declaring \nand checking non-null types in an object-oriented language. In ACM OOPSLA, Anaheim, CA, October 2003. \n[24] D. Gay and A. Aiken. Memory Management with Explicit Regions. In ACM PLDI, June 1998. [25] D. Gay \nand A. Aiken. Language support for regions. In ACM PLDI, pages 70 80, 2001. [26] D. Grossman, G. Morrisett, \nT. Jim, M. Hicks, Y. Wang, and J. Cheney. Region-Based Memory Management in Cyclone. In ACM PLDI, June \n2002. [27] J Gustavsson and J Svenningsson. Constraint abstractions. In Programs as Data Objects II, \npages 63 83, Aarhus, Denmark, May 2001. [28] F. Henglein, H. Makholm, and H. Niss. A direct approach \nto control-.ow sensitive region-based memory management. In Proceedings of the 3rd ACM SIGPLAN Conference \non Principles and Practice of Declarative Programming (PPDP), pages 175 186, Montr\u00b4eal, Canada, 2001. \nACM. [29] P. N. Hil.nger, D. Bonachea, D. Gay, S. Graham, B. Liblit, G. Pike, and K. Yelick. Titanium \nLanguage Reference Manual v1.11. Computer Science Division (EECS), University of California Berkeley, \nCalifornia, Mar 2004. [30] A. Igarashi, B. Pierce, and P. Wadler. Featherweight Java: A Minimal Core \nCalculus for Java and GJ. In ACM OOPSLA, Denver, Colorado, November 1999. [31] S Peyton-Jones and et \nal. Glasgow Haskell Compiler. http://www.haskell.org/ghc. [32] M. Tofte and J. Talpin. Implementing the \nCall-By-Value .-calculus Using a Stack of Regions. In ACM POPL, January 1994. [33] M. Tofte and J. Talpin. \nRegion-based memory management. Information and Computation, 132(2), 1997. [34] D. Walker and K. Watkins. \nOn regions and linear types (extended abstract). In ACM ICFP, pages 181 192. ACM Press, 2001.  \n\t\t\t", "proc_id": "996841", "abstract": "Region-based memory management offers several important potential advantages over garbage collection, including real-time performance, better data locality, and more efficient use of limited memory. Researchers have advocated the use of regions for functional, imperative, and object-oriented languages. Lexically scoped regions are now a core feature of the Real-Time Specification for Java (RTSJ)[5].Recent research in region-based programming for Java has focused on region checking, which requires manual effort to augment the program with region annotations. In this paper, we propose an automatic region inference system for a core subset of Java. To provide an inference method that is both precise and practical, we support classes and methods that are region-polymorphic, with region-polymorphic recursion for methods. One challenging aspect is to ensure region safety in the presence of features such as class subtyping, method overriding, and downcast operations. Our region inference rules can handle these object-oriented features safely without creating dangling references.", "authors": [{"name": "Wei-Ngan Chin", "author_profile_id": "81100655104", "affiliation": "Singapore-MIT Alliance and National University of Singapore", "person_id": "PP39052727", "email_address": "", "orcid_id": ""}, {"name": "Florin Craciun", "author_profile_id": "81100147492", "affiliation": "National University of Singapore", "person_id": "P456686", "email_address": "", "orcid_id": ""}, {"name": "Shengchao Qin", "author_profile_id": "81314485027", "affiliation": "Singapore-MIT Alliance and National University of Singapore", "person_id": "P493728", "email_address": "", "orcid_id": ""}, {"name": "Martin Rinard", "author_profile_id": "81100087275", "affiliation": "Massachusetts Institute of Technology", "person_id": "P192534", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/996841.996871", "year": "2004", "article_id": "996871", "conference": "PLDI", "title": "Region inference for an object-oriented language", "url": "http://dl.acm.org/citation.cfm?id=996871"}