{"article_publication_date": "01-21-2009", "fulltext": "\n State-Dependent Representation Independence Amal Ahmed Derek Dreyer Andreas Rossberg TTI-C MPI-SWS \nMPI-SWS amal@tti-c.org dreyer@mpi-sws.mpg.de rossberg@mpi-sws.mpg.de Abstract Mitchell s notion of representation \nindependence is a particularly useful application of Reynolds relational parametricity two dif\u00adferent \nimplementations of an abstract data type can be shown con\u00adtextually equivalent so long as there exists \na relation between their type representations that is preserved by their operations. There have been \na number of methods proposed for proving represen\u00adtation independence in various pure extensions of System \nF (where data abstraction is achieved through existential typing), as well as in Algol-or Java-like languages \n(where data abstraction is achieved through the use of local mutable state). However, none of these ap\u00adproaches \naddresses the interaction of existential type abstraction and local state. In particular, none allows \none to prove representa\u00adtion independence results for generative ADTs i.e., ADTs that both maintain \nsome local state and de.ne abstract types whose in\u00adternal representations are dependent on that local \nstate. In this paper, we present a syntactic, logical-relations-based method for proving representation \nindependence of generative ADTs in a language supporting polymorphic types, existential types, general \nrecursive types, and unrestricted ML-style muta\u00adble references. We demonstrate the effectiveness of our \nmethod by using it to prove several interesting contextual equivalences that in\u00advolve a close interaction \nbetween existential typing and local state, as well as some well-known equivalences from the literature \n(such as Pitts and Stark s awkward example) that have caused trouble for previous logical-relations-based \nmethods. The success of our method relies on two key technical inno\u00advations. First, in order to handle \ngenerative ADTs, we develop a possible-worlds model in which relational interpretations of types are \nallowed to grow over time in a manner that is tightly coupled with changes to some local state. Second, \nwe employ a step-indexed strati.cation of possible worlds, which facilitates a simpli.ed ac\u00adcount of \nmutable references of higher type. Categories and Subject Descriptors D.3.1 [Programming Lan\u00adguages]: \nFormal De.nitions and Theory; D.3.3 [Programming Languages]: Language Constructs and Features Abstract \ndata types; F.3.1 [Logics and Meanings of Programs]: Specifying and Verifying and Reasoning about Programs \nGeneral Terms Languages, Theory, Veri.cation Keywords Abstract data types, representation independence, \nex\u00adistential types, local state, step-indexed logical relations Permission to make digital or hard copies \nof all or part of this work for personal or classroom use is granted without fee provided that copies \nare not made or distributed for pro.t or commercial advantage and that copies bear this notice and the \nfull citation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. POPL 09, January 18 24, 2009, Savannah, Georgia, \nUSA. Copyright c &#38;#169; 2009 ACM 978-1-60558-379-2/09/01. . . $5.00 1. Introduction Reynolds notion \nof relational parametricity [23] is the essence of type abstraction clients of an abstract type behave \nuniformly across all relational interpretations of that type and thus cannot de\u00adpend in any way on how \nthe type is represented. Mitchell s notion of representation independence [17] is a particularly useful \nappli\u00adcation of relational parametricity two different implementations of an abstract data type can \nbe shown contextually equivalent so long as there exists a relation between their type representations \nthat is preserved by their operations. This is useful even when the type representations of the two ADTs \nare the same, because the choice of an arbitrary relational interpretation for the abstract type allows \none to establish the existence of local invariants. Originally these ideas were developed in the context \nof (vari\u00adants of) System F, but over the past two decades there has been a great deal of work on extending \nthem to the setting of more realis\u00adtic languages, such as those with recursive functions [20], general \nrecursive types [16, 1, 11], selective strictness [29], etc. In these functional languages, data abstraction \nis achieved through the use of existential types. Others have considered representation indepen\u00addence \nin the setting of imperative languages, such as Algol and Java, where data abstraction is achieved instead \nthrough the use of local mutable state (e.g., local variables or private .elds) [21, 5, 14]. Of course, \nmost modern languages (such as ML) are nei\u00adther purely functional nor imperative, but rather freely mix \nthe paradigms. However, none of the existing work on representation independence has considered a language \nsupporting both the func\u00adtional and the imperative approaches to data abstraction, i.e., both existential \ntypes and local state. This is unfortunate, since both ab\u00adstraction mechanisms play important, interdependent \nroles in the de.nition of generative abstract data types. 1.1 Reasoning About Generative Abstract Data \nTypes Existential type abstraction provides type generativity every unpacking of an existential package \ngenerates a fresh abstract type that is distinct from any other. This is similar to the behavior of Standard \nML s generative functors, which generate fresh abstract types at each application, and indeed the semantics \nof SML-style functors may be understood as a stylized use of existential type abstraction [25]. The clearest \nmotivation for type generativity is in the de.nition of ADTs that encapsulate some local state. In such \ninstances, generativity is sometimes necessary to achieve the proper degree of data abstraction. As a \nsimple motivating example, consider the SML mod\u00adule code in Figure 1, which is adapted from an example \nof Dreyer et al. [12]. (Later in the paper, we will develop a simi\u00adlar example using existential types.) \nHere, the signature SYMBOL describes a module implementing a mutable symbol table, which maps symbols \nto strings. The module provides an abstract type t describing the symbols currently in its table; a function \neq for comparing symbols for equality; a function insert, which adds a signature SYMBOL = sig type t \nval eq :t *t -> bool val insert : string -> t val lookup : t -> string end functor Symbol () :> SYMBOL \n= struct type t = int val size = ref 0 val table = ref nil fun eq (x,y)=x=y fun insert str = ( size := \n!size + 1; table := str :: !table; !size ) fun lookup n = List.nth (!table, !size -n) end Figure 1. \nGenerativity Example given string to the table and returns a fresh symbol mapped to it; and a function \nlookup, which looks up a given symbol in the table and returns the corresponding string. The functor \nSymbol implements the symbol type t as an integer index into a (mutable) list of strings. When applied, \nSymbol creates a fresh table (represented as a pointer to an empty list) and a mutable counter size (representing \nthe size of the table). The implementations of the various functions are straightforward, and the body \nof the functor is sealed with the signature SYMBOL, thus hiding access to the local state (table and \nsize). The call to List.nth in the lookup function might in general raise a Subscript exception if the \ninput n were an arbitrary inte\u00adger. However, we know that this cannot happen because lookup is exported \nwith argument type t, and the only values of type t that a client could possibly have gotten hold of \nare the values returned by insert, i.e., integers that are between 1 and the current size of table. Therefore, \nthe implementation of the lookup function need not bother handling the Subscript exception. This kind \nof reasoning is commonplace in modules that encap\u00adsulate local state. But what justi.es it? Intuitively, \nthe answer is type generativity. Each instantiation of the Symbol functor creates a fresh symbol type \nt, which represents the type of symbols that are valid in its own table (but not any other). Were Symbol \nnot gen\u00aderative, each application of the Symbol functor would produce a module with distinct local state \nbut the same symbol type. It would then be easy to induce a Subscript error by accidentally passing a \nvalue of one table s symbol type to another s lookup function.1 While this intuition about the importance \nof generativity is very appealing, it is also completely informal. The goal of this paper is to develop \na formal framework for reasoning about the interaction of generative type abstraction and mutable state. \nIn the case of an example like the Symbol functor, we will be able to show that the implementation of \nSymbol shown in Figure 1 is contextually equivalent to one whose lookup function is replaced by: fun \nlookup n = if n > 0 andalso n <= !size andalso !size = length(!table) then List.nth (!table, !size -n) \nelse \"Hell freezes over\" 1 This is the case, for example, in OCaml, which only supports applicative (i.e., \nnon-generative) functors [15]. In other words, there is no observable difference between the orig\u00adinal \nSymbol functor and one that dynamically checks the various invariants we claim to know. Hence, the checks \nare unnecessary. This kind of result can be understood as an instance of represen\u00adtation independence, \nalbeit a somewhat degenerate one in that the ADTs in question share the same type representation. As \nwith most such results, the proof hinges on the construction of an appropriate relational interpretation \nof the abstract type t, which serves to im\u00adpose an invariant on the possible values of type t. In this \ncase, we wish to assert that for a particular structure S de.ned by Symbol(), the only values of type \nS.t are integers between 1 and the current size of S s table. This will allow us to prove that any range \ncheck on the argument to S s lookup function is super.uous. The problem is that the relational interpretation \nwe wish to assign to S.t depends on the current values stored in S s local state. In effect, as S s insert \nfunction is called repeatedly over time, its table grows larger, and the relational interpretation of \nS.t must grow accordingly to include more and more integers. Thus, what we need is an account of state-dependent \nrepresentation independence, in which the relational interpretations of abstract types are permitted \nto grow over time, in a manner that is tightly coupled with changes to some local state.  1.2 Overview \nIn this paper, we present a novel method for proving state-dependent representation independence results. \nOur method extends previ\u00adous work by Ahmed on syntactic step-indexed logical relations for recursive \nand quanti.ed types [1]. We extend her technique with support for reasoning about local state, and demonstrate \nits effectiveness on a variety of small but representative examples. Although our primary focus is on \nproving representation indepen\u00addence for ADTs that exhibit an interaction of existentials and state, \nour method also handles several well-known simply-typed exam\u00adples from the literature on local state \n(such as Pitts and Stark s awkward example [21]) that have proven dif.cult for previous logical-relations-based \nmethods to handle. In order to reason about local state, we build into our logical relation a notion \nof possible worlds. While several aspects of our possible worlds are derived from and inspired by prior \nwork, other aspects are quite novel: 1. We enrich our possible worlds with populations and laws, which \nallow us to evolve the relational interpretation of an abstract type over time in a controlled, state-dependent \nfashion. For instance, we can use a population to grow a set of val\u00adues (e.g., the integers between 1 \nand some n), together with a law that explains what the current population implies about the current \nmachine state (e.g., that the symbol table has size n). 2. Second, our method provides the ability to \nreason locally about references to higher-order values. While ours is not the .rst method to handle higher-order \nstate, our approach is novel and arguably simpler than previous accounts. It depends critically on step-indexing \nin order to avoid a circularity in the construc\u00adtion of possible worlds.  The remainder of the paper \nis structured as follows. In Sec\u00adtion 2, we present F\u00b5!, our language under consideration, which is essentially \nSystem F extended with general recursive types and general ML-style references. In Section 3, we explain \nat a high level how our method works and what is novel about it. In Section 4, we present the details \nof our logical relation and prove it sound (but not complete) with respect to contextual equivalence \nof F\u00b5! programs. In Section 5, we show how to use our method to prove a num\u00adber of interesting contextual \nequivalences. Finally, in Section 6, we conclude with a thorough comparison to related work, as well \nas directions for future work. Types t ::= a | unit | int | bool | t1 \u00d7 t2 | t1 . t2 |.a. t |.a. t | \n\u00b5a. t | ref t Prim Ops o ::= + |-| = | < |=| ... Terms e ::= x | () | l |\u00b1n | o(e1,...,en) | true | false \n|if e then e1 else e2 |(e1,e2)| fst e | snd e |.x : t. e | e1 e2 | .a. e | e [t] |pack t, e as .a. t' \n| unpack e1 as a, x in e2 |fold e | unfold e | ref e | !e | e1 := e2 | e1 == e2 Values v ::= () | l |\u00b1n \n| true | false |(v1,v2)| .x : t. e | .a. e | pack t1,v as .a. t | fold v s, (.x : t. e) v -. s, [v/x]e \ns, (.a. e)[t] -. s, [t/a]e s, unpack (pack t, v as .a. t') as a, x in e -. s, [t/a][v/x]e s, unfold (fold \nv) -. s, v s, ref v -. s[l . v],l where l/. dom(s) s, !l -. s, v where s(l)= v s, l:= v -. s[l . v], \n() where l . dom(s) s, l == l -. s, true s, l == l' -. s, false where l = l' '' s, e -. s,e s, E[e] -. \ns',E[e'] Type Contexts . ::= \u00b7| .,a Value Contexts G ::= \u00b7| G,x : t Store Typing S ::= \u00b7| S,l : t where \nFTV (t)= \u00d8 G(x) = t S(l) = t .; G; S f e : t .; G; S f x : t . . . .; G; S f l : ref t .; G; S f ref \ne : ref t .; G; S f e : ref t .; G; S f e1 : ref t .; G; S f e2 : t .; G; S f !e : t .; G; S f e1 := \ne2 : unit .; G; S f e1 : ref t .; G; S f e2 : ref t .; G; S f e1 == e2 : bool Well-typed Store: .l . \ndom(S). \u00b7; \u00b7;S f s(l) : S(l) f s :S Figure 2. F\u00b5! Syntax + Dynamic and Static Semantics (excerpts) 2. \nThe Language F\u00b5! We consider F\u00b5!, a call-by-value .-calculus with impredicative polymorphism, iso-recursive \ntypes, and general ML-style refer\u00adences. The syntax of F\u00b5! is shown in Figure 2, together with ex\u00adcerpts \nof the static and dynamic semantics. We assume an in.nite set of locations Loc ranged over by l. Our \nterm language includes equality on references (e1 == e2), but is otherwise standard. We de.ne a small-step \noperational semantics for F\u00b5! as a rela\u00adtion between con.gurations (s, e), where s is a global store \nmap\u00adping locations l to values v. We use evaluation contexts E to lift the primitive reductions to a \nstandard left-to-right call-by-value seman\u00adtics for the language. We elide the syntax of evaluation contexts \nas it is completely standard, and we show only some of the reduction rules in Figure 2. F\u00b5! typing judgments \nhave the form .; G; S f e : t where the contexts ., G, and S are de.ned as in Figure 2. The type context \n. is used to track the set of type variables in scope; the value context G is used to track the term \nvariables in scope (along with their types t, which must be well formed in context ., written . f t); \nand the store typing S tracks the types of the contents of locations in the store. Note that S maps locations \nto closed types. We write FTV (t ) to denote the set of type variables that appear free in type t . The \ntyping rules are entirely standard, so we show only a few rules in Figure 2. We refer the reader to the \nonline technical appendix [3] for full details of F\u00b5! . 2.1 Contextual Equivalence A context C is an \nexpression with a single hole [\u00b7] in it. Typing judgments for contexts have the form f C : (.; G; S f \nt ) . (.';G';S' f t '), where (.; G; S f t ) indicates the type of the hole. Essentially, this judgment \nsays that if e is an expression such that .; G; S f e : t , then .';G';S' f C[e]: t '. The typing rule \nfor a hole [\u00b7] is as follows: '' ' . . .G . GS . S '' f [\u00b7] : (.;G;S f t ) . (.;G;S' f t ) The other \nrules are straightforward (see our online appendix [3]). We de.ne contextual approximation (.; G; S f \ne1 .ctx e2 : t) to mean that, for any well-typed program context C with a hole of the type of e1 and \ne2, the termination of C[e1] implies the termina\u00adtion of C[e2]. Contextual equivalence (.; G; S f e1 \nctx e2 : t) is then de.ned as approximation in both directions. De.nition 2.1 (Contextual Approximation \n&#38; Equivalence) Let .; G; S f e1 : t and .; G; S f e2 : t. def .; G; S f e1 .ctx e2 : t = .C, S',t', \ns. f C : (.; G; S f t) . (\u00b7; \u00b7;S' f t') .f s :S' . s, C[e1] . =. s, C[e2] . def .; G; S f e1 ctx e2 : \nt = .; G; S f e1 .ctx e2 : t . .; G; S f e2 .ctx e1 : t 3. The Main Ideas In this section we give an \ninformal overview of the main novel ideas in our method, and how it compares to some previous approaches. \n3.1 Logical Relations Broadly characterized, our approach is a logical relations method. We de.ne a relation \nV [t ] ., which relates pairs of values at type t , where the free type variables of t are given relational \ninterpreta\u00adtions in .. The relation is logical in the sense that its de.nition follows the structure \nof t, modeling each type constructor as a log\u00adical connective. For example, arrow types correspond to \nimplica\u00adtion, so functions are de.ned to be related at an arrow type iff re\u00adlatedness of their arguments \nimplies relatedness of their results. We will show that this logical relation is sound with respect to \ncontex\u00adtual equivalence for F\u00b5!. This is useful because, for many examples, it is much easier to show \ntwo programs are in the logical relation than to show they are contextually equivalent directly. Logical \nrelations methods are among the oldest techniques for proving representation independence results. We \nwill assume the reader is generally familiar with the .avor of these techniques, and instead focus on \nwhat is distinctive and original about ours. 3.2 Local Reasoning via Possible Worlds and Islands As \nexplained in Section 1, our core contribution is the idea of state-dependent relational interpretations \nof abstract types. That is, whether two values are related by some abstract type s relational in\u00adterpretation \nmay depend on the current state of the heap. But when de.ning such a relational interpretation, how can \nwe characterize the current state of the heap? As a starting point, we review the general approach taken \nby a number of prior works on reasoning about local state [21, 22, 7, 10]. This approach, which utilizes \na possible worlds model, has in.uenced us greatly, and constitutes the foundation of our method. However, \nthe form it has taken in prior work is insuf.cient for our purposes, and it is instructive to see why. \nThe general approach of these prior works is to index the logical relation not only by a type t but by \na world W . Instead of charac\u00adterizing the current state of the heap, W characterizes the properties \nwe expect the heap to have. In other words, it is a relation on ma\u00adchine stores, and we restrict attention \nto pairs of stores that satisfy it. If two values v1 and v2 are in the logical relation at type t and \nworld W , then it means they are related when considered under any two stores s1 and s2, respectively, \nthat satisfy W . Worlds in turn are constructed as a separating conjunction of smaller worlds (w1,...,wn), \nsometimes called islands, where each island is a relation that concerns a disjoint piece of the store. \nIntuitively, this means that each island distinguishes between pairs of stores only on the basis of a \nparticular set of memory loca\u00adtions, and the set of locations that one island cares about is disjoint \nfrom the set that any other one cares about. Exactly how the separation criterion on islands is formalized \nis immaterial; the important point is that it enables local reasoning. Suppose we want to prove that \none expression is related to another in world W . Each may allocate some fresh piece of the store, and \nbefore showing that the resulting values of the expressions are related, we are permitted to extend W \nwith a new island w describing how these fresh pieces of the store relate to each other. World extension \nis sound here precisely because the new island is (due to freshness of allocation) separate from the \nothers. So long as the expressions in question do not make the locations in their local stores publicly \naccessible, no other part of the program is capable of mutating the store in such a manner as to violate \nw. To make things concrete and to observe the limitations of possi\u00adble worlds (at least as we have described \nthem), let us consider the motivating example from Section 1. To prove that the two imple\u00admentations \nof the Symbol functor are contextually equivalent, we will show that their bodies are logically related \nin an arbitrary ini\u00adtial world W0. Both functors allocate local state in the same way, namely by allocating \none pointer for table and one for size, so we will want to extend W0 with an island wsym describing the \nlocal invariants on table and size. How should we de.ne wsym? One useful invariant that wsym can enforce \nis that, for both implementations of Symbol, the integer pointed to by size is equal to the length of \nthe list pointed to by table. By incorporating this property into wsym, we will be guaranteed that, in \nany future world (i.e., any extension of W0 l wsym) in which the lookup function is called, the dynamic \ncheck !size = length(!table) in the second implementation of Symbol will always evaluate to true. We \ncan also use wsym to enforce that !size is the same in the stores of both programs, and similarly for \n!table. Unfortunately, while this is a necessary condition, it is not suf.cient to prove that the range \ncheck on the argument of lookup in the second Symbol implementation always evaluates to true. For that, \nwe need a way of correlating the value of !size and the possible values of type t, but the islands we \nhave developed thus far do not provide one. 3.3 Populating the Islands and Enforcing the Laws The problem \nwith islands is that they are static entities with no potential for development. To address this limitation, \nwe enrich is\u00adlands with populations. A population is a set of values that in\u00adhabit an island and affect \nthe de.nition of the store relation for that island. An island s population may grow over time (i.e., \nas we move to future worlds), and its store relation may change accord\u00adingly. In order to control population \ngrowth, we equip every island with an immutable law governing the connection between its pop\u00adulation \nand its store relation. We denote populations by V , store relations by ., and laws by L. Consider the \nSymbol example. Let us de.ne Vn = {1,...,n}, and let .n be the store relation containing pairs of stores \nthat obey the properties concerning table and size described in Section 3.2 and that, in addition, both \nmap the location size to n. The idea is that Vn describes the set of values of type t, given that the \ncurrent stores satisfy .n. Thus, when we extend the initial world W0 with an island wsym governing Symbol \ns local state, we will choose that wsym to comprise population V0, store relation .0, and a law L de.ned \nas {(.n,Vn) | n = 0}. Here, V0 and .0 characterize the initial world, in which there are no values of \ntype t and the size of the table is 0. The law L describes what future populations and store relations \non this island may look like. In particular, L enforces that future populations may contain 1 to n (for \nany n), but only in conjunction with stores that map size to n. (Of course, the initial population and \nstore relation must also obey the law, which they do.) An island s law is established when the island \nis .rst added to the world and may not be amended in future worlds. Having extended the world W0 with \nthis new island wsym, we are now able to de.ne a relational interpretation for the type t, namely: values \nv1 and v2 are related at type t in world W if v1 = v2 = m, where m belongs to the population of wsym \nin W . In proving equivalence of the two versions of the lookup function, we can assume that we start \nwith stores s1 and s2 that are related by some world W , where W is a future world of W0 l wsym, and \nthat the arguments to lookup are related at type t in W . Consequently, given the law that we established \nfor wsym together with the interpretation of t, we know that the arguments to lookup must both equal \nsome m, that the current population of wsym must be some Vn, where 1 = m = n, and that the current store \nrelation must be .n. Since s1 and s2 satisfy W , they must satisfy .n, which means they map size to n \n= m. Hence, the dynamic range check in the second version of Symbol must evaluate to true. For the above \nrelational interpretation of t to make sense, we clearly need to be able to refer to a particular island \nin a world (e.g., wsym) by some unique identi.er that works in all future worlds. We achieve this by \ninsisting that a world be an ordered list of islands, and that new islands only be added to the end of \nthe list. This allows us to access islands by their position in the list, which stays the same in future \nworlds. In addition, an important property of the logical relation, which relational interpretations \nof abstract types must thus obey as well, is closure under world extension, i.e., that if two values \nare related in world W , then they are related in any future world of W . To ensure closure under world \nextension for relations that depend on their constituents inhabitation of a particular island (such as \nthe relation used above to interpret t), we require that island populations can only grow larger in future \nworlds, not smaller. For expository purposes, we have motivated our population technique with an example \nthat is deliberately simple, in the sense that the relational interpretation of t is completely dependent \non the current local state. That is, if we know that the current value of !size is n, then we know without \na doubt that the relational inter\u00adpretation of t in the current world must be {(1, 1),..., (n, n)}. In \nSection 5, we will see more complex examples in which the rela\u00adtional interpretation of t may depend \nnot only on the current state, but also on the history of the program execution up to that point. Our \npopulation techniques scales very nicely to handle such ex\u00adamples because it allows us to control the \nevolution of an abstract type s relational interpretation over time. 3.4 Mutable References to Higher-Order \nValues Most prior possible-worlds logical-relation approaches to reason\u00ading about local state impose \nserious restrictions on what can be stored in memory. Pitts and Stark [21], for example, only allow references \nto integers. Reddy and Yang [22] and Benton and Lep\u00aderchey [7] additionally allow references to data, \nwhich include in\u00adtegers and pointers but not functions. In the present work, however, we would like to \navoid any restrictions on the store. To see what (we think) is tricky about handling references to higher-order \nvalues, suppose we have two programs that both main\u00adtain some local state, and we are trying to prove \nthese programs equivalent. Say the invariant on this local state, which we will en\u00adforce using an island \nw, is very simple: the value that the .rst pro\u00adgram stores in location l1 is logically related to the \nvalue that the second program stores in l2. If these values were just integers, we could write the law \nfor w (as we did in the Symbol example) so that in any future world, w s store relation . must demand \nthat two stores s1 and s2 are related only if s1(l1)= s2(l2). This works because at type int, the logical \nrelation coincides with equality. If the locations have some higher type t, however, the de.nition of \nw s store relation . will need to relate s1(l1) and s2(l2) using the logical relation at type t , not \nmere syntactic equality. But the problem is: logical relations are indexed by worlds. In order for . \nto say that s1(l1) and s2(l2) are related at type t , it needs to specify the world W in which their \nrelation is being considered. Bohr and Birkedal [10] address this issue by imposing a rigid structure \non their store relations. Speci.cally, instead of having a single store relation per island, they employ \na local parameter, which is roughly a set of pairs of the form (P, LL), where P is a store relation and \nLL is a .nite set of pairs of locations (together with a closed type). The way to interpret this local \nparameter is that the current stores must satisfy one of the P s, and all the pairs of locations in the \ncorresponding LL must be related by the logical relation in the current world. In the case of our example \nwith l1 and l2, they would de.ne a local parameter {(P, LL)}, where P is the universal store relation \nand LL = {(l1,l2,t)}. Bohr and Birkedal s approach effectively uses the LL s to abstract away explicit \nreferences to the world-indexed logical relation within the store relation. This avoids the need to refer \nto a speci.c world inside a store relation, but it only works for store relations that are expressible \nin the highly stylized form of these local parameters. Instead, our approach is to parameterize store \nrelations over the world in which they will be considered. Then, in de.ning what it means for two stores \ns1 and s2 to satisfy some world W , we require that for every . in W , (s1,s2) . .[W ], i.e., s1 and \ns2 obey . when it is instantiated to the current world W . The astute reader will have noticed, however, \nthat this parameterization introduces a circularity: worlds are de.ned to be collections of store relations, \nwhich are now parameterized by worlds. To break this circularity, we employ step-indexed logical relations. \n 3.5 Step-Indexed Logical Relations and Possible Worlds Appel and McAllester [4] introduced the step-indexed \nmodel as a way to express semantic type soundness proofs for languages with general recursive and polymorphic \ntypes. Although its orig\u00adinal motivation was tied to foundational proof-carrying code, the technique \nhas proven useful in a variety of applications. In particu\u00adlar, Ahmed [1] has used a binary version of \nAppel and McAllester s model for relational reasoning about System F extended with gen\u00aderal recursive \ntypes, and it is her work that we build on. The basic idea is closely related to classic constructions \nfrom domain theory. We de.ne the logical relation V [t ] . as the limit of an in.nite chain of approximation \nrelations Vn[t] ., where n = 0. Informally, values v1 and v2 are related by the n-th approximation relation \nonly if they are indistinguishable in any context for n steps of computation. (They might be distinguishable \nafter n steps, but we don t care because the clock has run out.) Thus, values are re\u00adlated in the limit \nonly if they are indistinguishable in any context for any .nite number of steps, i.e., if they are really \nindistinguishable. The step-indexed strati.cation makes it possible to de.ne the semantics of recursive \ntypes quite easily. Two values fold v1 and fold v2 are de.ned to be related by Vn[\u00b5a. t] . iff v1 and \nv2 are related by Vk[[\u00b5a. t/a]t ] . for all k<n. Even though the un\u00adfolded type is larger (usually a \ndeal breaker for logical relations, which are typically de.ned by induction on types), the step in\u00addex \ngets smaller, so the de.nition of the logical relation is well\u00adfounded. Moreover, it makes sense for \nthe step index to get smaller, since it takes a step of computation to extract vi from fold vi. Just \nas we use steps to stratify logical relations, we can also use them to stratify our quasi-circular possible \nworlds. We de.ne an n-level world inductively to be one whose constituent store relations (the . s) are \nparameterized by (n-1)-level worlds. The intuition behind this strati.cation of worlds is actually very \nsimple: an n-level world describes properties of the current stores that may affect the relatedness of \npairs of values for n steps of computation. Since it takes one step of computation just to inspect the \nstores (via a pointer dereference), the relatedness of pairs of values for n steps can only possibly \ndepend on the relatedness of the current stores for n-1 steps. Thus, it is .ne for an n-level world to \nbe de.ned as a collection of (n-1)-level store relations, i.e., . s that only guarantee relatedness of \nmemory contents for n-1 steps. And these (n-1)-level . s, in turn, need only be parameterized by (n-1)\u00adlevel \nworlds. 4. Step-Indexed Logical Relations for F\u00b5! In this section, we present the details of our logical \nrelation for F\u00b5! and prove it sound with respect to contextual equivalence. The basic idea is to give \na relational interpretation V [t ] of a (closed) type t as a set of tuples of the form (k, W, v1,v2), \nwhere k is a natural number (called the step index), W is a world (as motivated in Section 3), and v1 \nand v2 are values. Informally, (k, W, v1,v2) .V [t ] says that in any computation running for no more \nthan k steps, v1 approximates v2 at the type t in world W . An important point is that to determine if \nv1 approximates v2 for k steps (at type t ), it suf.ces for the world W to be a k-level world. That is, \nthe store relations . in W need only guarantee relatedness of memory contents for k -1 steps, as discussed \nin Section 3.5. We make the notion of a k-level world precise in Section 4.1. Preliminaries In the rest \nof the paper, the metavariables i, j, k, m, and n all range over natural numbers. We use the metavariable \n. to denote sets of tuples of the form (k, W, e1,e2) where k is a step index, W is a world, and e1 and \ne2 are closed terms (i.e., terms that may contain locations, but no free type or term variables). Given \na set . of this form, we write .val to denote the subset of . such that e1 and e2 are values. As mentioned \nin Section 3.3, a world W is an ordered list (written (w1,...,wn)) of islands. An island w is a pair \nof some current knowledge . and a law L. The knowledge . for each island represents the current state \nof the island. It comprises four parts: a store relation ., which is a set of tuples of the form (k, \nW, s1,s2), where k is a step index, W is a world, and s1, and s2 are stores; a population V , which is \na set of closed values; and two store typings S1 and S2. The domains of S1 and S2 give us the sets of \nlocations that the island cares about (a notion we mentioned in Section 3.2). Meanwhile, a law L is a \nset of pairs (k, .). If (k, .) .L, it means that, at time k (representing the number of steps left on \nthe clock), the knowledge . represents an acceptable state for the island to be in. Below we summarize \nour notation for ease of reference. Type Interpretation . ::= {(k, W, e1,e2),... } Store Relation . ::= \n{(k, W, s1,s2),... } Population V ::= {v1,... } Knowledge . ::= (., V, S1, S2) Law L ::= {(k, .),...} \nIsland w ::= (., L) World W ::= (w1,...,wn) S def def CandAtomk = {(j, W, e1,e2) | j<k . W . CandWorldj \n} CandAtom. = CandAtomk k=0 def def S CandTypek = P(CandAtomval) CandType. = P(CandAtomval . CandTypek \nk. ) k=0 def CandStoreAtomk = {(j, W, s1,s2) | j<k . W . CandWorldj } def CandStoreRelk = P(CandStoreAtomk) \ndefdef CandKnowledgek = CandStoreRelk \u00d7 Population l.hk = {(j, W, e1,e2) | j<k . (j, W, e1,e2) . .} \ndef \u00d7 StoreTy \u00d7 StoreTy l.hk = {(j, W, s1,s2) | j<k . (j, W, s1,s2) . .} def def CandLawAtomk = {(j, \n.) | j = k . . . CandKnowledgej }l.h=(l.hk, V, S1, S2) where . =(., V, S1, S2) k def def CandLawk = \nP(CandLawAtomk) lLhk = {(j, .) | j = k . (j, .) . L} def def CandIslandk = CandKnowledgek \u00d7 CandLawk \nlwhk =(l.hk, lLhk) where w =(., L) def def CandWorldk = {W . (CandIslandk)n | n = 0}lW hk = (lw1hk,..., \nlwnhk) where W = (w1,...,wn) (. ' ,V ' , S ' 1, S ' 2 '' (w1,...,w n+m Atom[t1,t2]k Type[t1,t2]k StoreAtomk \nStoreRelk Knowledgek LawAtomk Lawk Islandk Worldk Atom[t1,t2] Type[t1,t2] def = def = def = def = def \n= def = def = def = def = def = def = def ) ; (., V, S1, S2)= def (. ' , L ' ) ; (., L)= def ); (w1,...,wn) \n= def (j, W ' ) ; (k, W )= def (j, W ' ) : (k, W )= V ' . V . S ' . S1 . S ' . S2 12 . ' ; . .L ' = \nL ' m = 0 ..i .{1,...,n}.w ; wi i '' j = k . W ;lW hj . W . W orldj . W . W orldk j<k . (j, W ' ) ; \n(k, W ) {(j, W, e1,e2) . CandAtomk | W . Worldj . S1(W ) f e1 : t1 . S2(W ) f e2 : t2} ' {. .P(Atom[t1,t2]val) \n|.(j, W, v1,v2) . .. .(j ' ,W ' ) ; (j, W ). (j ' ,W ,v1,v2) . .} k {(j, W, s1,s2) . CandStoreAtomk \n| W . Worldj } ' {. .P(StoreAtomk) |.(j, W, s1,s2) . .. .(i, W ' ) ; (j, W ). (i,W ,s1,s2) . .} {(., \nV, S1, S2) . CandKnowledgek | . . StoreRelk . '' .s1,s2,s 1,s 2. '' ( .l . dom(S1).s1(l)= s1(l) ..l \n. dom(S2).s2(l)= s2(l)) =. ' .j, W. (j, W, s1,s2) . . .. (j, W, s ' 1,s ) . .} 2 {(j, .) . CandLawAtomk \n| . . Knowledgej } {L. P(LawAtomk) |.(j, .) .L. .i < j. (i, l.hi) . L} {(., L) . Knowledgek \u00d7 Lawk | \n(k, .) . L} {W . (Islandk)n | n = 0 . .a, b .{1,...,n}.a = b =. dom(W [a].S1) # dom(W [b].S1) . dom(W \n[a].S2) # dom(W [b].S2)} S k=0 Atom[t1,t2]k S {. . CandType. |.k = 0. l.hk . Type[t1,t2]k}. Type[t1,t2]k \nk=0 Figure 3. Auxiliary De.nitions: Candidate Sets, k-Approximation, World Extension, and Well-Formedness \nConditions If W = (w1,...,wn) and 1 = j = n, we write W [j] as shorthand for wj . If w =(.i, Li) where \n.i =(.i,Vi, Si1, Si2), we use the following shorthand to extract various elements out of the island w: \nw.. = .i w.V = Vi w.L=Li w.S1 = Si1 w.. = .i w.S2 = Si2 If W is a world with n islands, we also use the \nfollowing shorthand: S def S1(W )= W [j].S1 1=j=n def S S2(W )= W [j].S2 1=j=n We write Val for the set \nof all values, Store for the set of all stores (.nite maps from locations to values), and StoreTy for \nthe set of store typings (.nite maps from locations to closed types). We write Population for the set \nof all subsets of Val. Finally, we write S1 # S2 to denote that the sets S1 and S2 are disjoint. 4.1 \nWell-Founded, Well-Formed Worlds and Relations Notice that we cannot na\u00a8ively construct a set-theoretic \nmodel based on the above intentions since the worlds we wish to construct are (effectively) lists of \nstore relations and store relations are them\u00adselves parameterized by worlds (as discussed in Section \n3.4). If we ignore islands, laws, populations, and store typings for the moment, and simply model worlds \nas lists of store relations, we are led to the following speci.cation which captures the essence of the \nproblem: StoreRel = P(N\u00d7 World \u00d7 Store \u00d7 Store) World = StoreReln A simple diagonalization argument shows \nthat the set StoreRel has an inconsistent cardinality (i.e., it is an ill-founded recursive de.nition). \nWe eliminate the inconsistency by stratifying our de.nition via the step index. To do so, we .rst construct \ncandidate sets, which are well-founded sets of our intended form. We then construct proper notions of \nworlds, islands, laws, store relations, and so on, by .ltering the candidate sets through some additional \nwell\u00adformedness constraints. Figure 3 (top left) de.nes our candidate sets by induction on k. First, \nnote that elements of CandAtomk and CandStoreAtomk are tuples with step index j strictly less than k. \nHence, our can\u00addidate sets are well-de.ned at all steps. Next, note that elements of CandLawAtomk are \ntuples with step index j = k. Informally, this is because a k-level law should be able to govern the \ncurrent knowledge (i.e., the knowledge at the present time when we have k steps left to execute), not \njust the knowledge in the future when we have strictly fewer steps left. While our candidate sets establish \nthe existence of sets of our intended form, our worlds and type relations will need to be well\u00adbehaved \nin other ways. There are key constraints associated with atoms, types, store relations, knowledge, laws, \nislands, and worlds that will be enforced in our .nal de.nitions. To specify these constraints we need \nsome additional functions and predicates. For any set . and any set ., we de.ne the k-approximation of \nthe set (written L.Jk and L.Jk, respectively) as the subset of its elements whose indices are strictly \nless than k (see Figure 3, top right). Meanwhile, for any set L, we de.ne the k-approximation of the \nset (written LLJk) as the subset of its elements whose in\u00addices are less than or equal to k. We extend \nthese k-approximation notions to knowledge ., islands w, and worlds W (written L.Jk, LwJk, and LW Jk, \nrespectively) by applying k-approximation to their constituent parts. Note that each of the k-approximation \nfunc\u00adtions yields elements of CandX k where X denotes the appropriate semantic object. Next, we de.ne \nthe notion of world extension (see Figure 3, middle). We write (j, W ' ) ; (k, W ) (where ; is pronounced \nextends ) if W is a world that is good for k steps (i.e., W . Worldk, see below), W ' is a good world \nfor j = k steps (W ' . Worldj ), and W ' extends LW Jj (written W ' ;LW Jj ). Recall from Section 3.3 \nthat future worlds accessible from W may have new islands added to the end of the list. Furthermore, \nfor each island w .LW Jj , the island w ' in the same position in W ' must extend w. Here we require \nthat w ' .L = w.L since an island s law cannot be amended in future worlds (see Section 3.3). We also \nrequire that w ' .. ; w.., which says that the island s population may grow (w ' .V . w.V ), as may the \nsets of locations that the island cares about (w ' .S1 . w.S1 and w ' .S2 . w.S2). Though it may seem \nfrom the de.nition of knowledge extension in Figure 3 that we do not impose any constraints on w ' .., \nthis is not the case. As explained in Section 3.3, an island s law should govern what the island s future \nstore relations, populations, and locations of concern may look like. The requirement W ' . Worldj (which \nwe discuss below) ensures that the future knowledge w ' .. obeys the law w ' .L. Figure 3 (bottom) de.nes \nour various semantic objects, again by induction on k. These de.nitions serve to .lter their corresponding \ncandidate sets. We proceed now to discuss each of these .ltering constraints. Following Pitts [20], our \nmodel is built from syntactically well\u00adtyped terms. Thus, we de.ne Atom[t1,t2]k as the set of tuples \n(j, W, e1,e2) where S1(W ) f e1 : t1 and S2(W ) f e2 : t2, and j<k. (Recall that Si(W ) denotes the global \nstore typing i.e., the union of the Si components of all the islands in W .) We also require the world \nW to be a member of Worldj . We de.ne Type[t1,t2]k as those sets . . Atom[t1,t2]k val that are closed \nunder world extension. Informally, if v1 and v2 are related for k steps in world W , then v1 and v2 should \nalso be related for j steps in any future world W ' such that (j, W ' ) is accessible from (i.e., extends) \n(k, W ). We de.ne StoreRelk as the set of all . . StoreAtomk . CandStoreAtomk that are closed under world \nextension. This property is critical in ensuring that we can extend a world with new islands without \nfear of breaking the store properties from the old islands. Knowledgek is the set of all tuples of the \nform (., V, S1, S2) . CandKnowledgek such that . . StoreRelk. As mentioned above, the domains of S1 and \nS2 contain the locations that an island cares about. What this means is that when determining whether \ntwo stores s1 and s2 belong to the store relation ., we cannot depend upon the contents of any location \nin store s1 that is not in dom(S1) or on the contents of any location in s2 that is not in dom(S2). Thus, \nS1 and S2 essentially serve as accessibility maps [7]. While Benton and Leperchey s accessibility maps \nare functions from stores to subsets of Loc, our accessibility maps are essentially sets of locations \nthat are allowed to grow over time. We de.ne Lawk as the set of laws L such that for all (j, .) .L we \nhave that . . Knowledgej . Furthermore, we require that the sets L be closed under decreasing step index \nthat is, if some knowledge . obeys law L for j steps, then it must be the case that at any future time, \nwhen we have i<j steps left, the i-approximation of knowledge . still obeys the law L. Islandk is the \nset of all pairs (., L) . (Knowledgek \u00d7 Lawk) such that the knowledge . obeys the law L at the current \ntime denoted by step index k i.e., (k, .) .L. Finally, we de.ne Worldk as the set of all W . (Islandk)n \n. We also require that the sets of locations that each island W [a] cares about are disjoint from the \nsets of locations that any other island W [b] cares about, thus ensuring separation of islands.  4.2 \nRelational Interpretations of Types Figure 4 (top) gives the de.nition of our logical relations for F\u00b5! \n. The relations Vn[t] . are de.ned by induction on n and nested induction on the type t . We use the \nmetavariable . to denote type substitutions. A type substitution . is a .nite map from type variables \na to triples (., t1,t2) where t1 and t2 are closed types, and . is a relational interpretation in Type[t1,t2]. \nIf .(a)= (., t1,t2), then .1(a) denotes t1 and .2(a) denotes t2. Note that, by the de.nition of Vn[t \n] ., if (k, W, v1,v2) . Vn[t ] ., then k<n, W . Worldk, and S1(W ) f v1 : .1(t) and S2(W ) f v2 : .2(t \n). Most of the relations Vn[t ] . are straightforward. For instance, the logical relation at type int \nsays that two integers are logically related for any number of steps k and in any world W as long as \nthey are equal. The relations for the other base types unit and bool are similar. The logical relation \nat type t \u00d7 t ' says that two pairs of values are related for k steps in world W if their .rst and second \ncomponents are related (each for k steps in world W ) at types t and t ' respectively. Since functions \nare suspended computations, their relatedness is de.ned based on the relatedness of computations (character\u00adized \nby the relation En[t ] ., discussed below). Two functions .x : .1(t).e1 and .x : .2(t).e2 are related \nfor k steps in world W at the type t . t ' if, in any future world W ' where there are j<k steps left \nto execute and we have arguments v1 and v2 that are related at the argument type t , the computations \n[v1/x]e1 and [v2/x]e2 are also related for j steps in world W ' at the result type t ' (i.e., they are \nin the relation En[t ' ] .). Intuitively, j<k suf.ces since beta-reduction consumes a step. Parameterizing \nover an arbi\u00adtrary future world W ' is necessary here in order to ensure closure of the logical relation \nunder world extension. Before we can specify when two computations are related, we have to describe what \nit means for two stores to be related. We write s1,s2 :k W , denoting that the stores s1 and s2 are related \nfor k steps at the world W (see Figure 4, top), if the stores are well-typed with respect to the store \ntypings S1(W ) and S2(W ), respectively, and if the stores are considered acceptable by i.e., they are \nin the store relations of all the islands in W at all future times when j<k. def s1,s2 :k W = f s1 :S1(W \n) .f s2 :S2(W ) . .w . W. .j <k. (j, lW hj ,s1,s2) . w.. = n Atom[.1(t),.2(t)]val Vn[t] . Vn[t] . n Vn[a] \n. = . where .(a)=(., t1,t2) Vn[unit] . = {(k, W, (), ())} Vn[int] . = {(k, W, v, v) | v . Z} Vn[bool] \n. = {(k, W, v, v) | v = true . v = false} '' Vn[t \u00d7 t '] . = {(k, W, (v1,v 1), (v2,v 2)) | (k, W, v1,v2) \n.Vn[t] . . ' (k, W, v 1' ,v ) .Vn[t '] .} 2 Vn[t . t '] . = {(k, W, .x : .1(t).e1, .x : .2(t).e2) |.(j, \nW ' ) : (k, W ). .v1,v2. ' (j,W ,v1,v2) .Vn[t] . =. ' (j,W , [v1/x]e1, [v2/x]e2) .En[t '] .} Vn[.a. t] \n. = {(k, W, .a. e1, .a. e2) | .(j, W ' ) : (k, W ). .t1,t2,. . Type[t1,t2]. ' (j,W , [t1/a]e1, [t2/a]e2) \n.En[t] .[a . (., t1,t2)]} Vn[.a. t] . = {(k, W, pack t1,v1 as .a. .1(t), pack t2,v2 as .a. .2(t)) | .. \n. Type[t1,t2]. (k, W, v1,v2) .Vn[t] .[a . (., t1,t2)]} Vn[\u00b5a. t] . = {(k, W, fold v1, fold v2) | k<n \n. .j <k. (j, lW hj ,v1,v2) .Vk[[\u00b5a. t/a]t] .} Vn[ref t] . = {(k, W, l1,l2) | k<n . wref (k, ., t, l1,l2) \n. W } wref (k, ., t, l1,l2)=(., L) where . =(., {}, {l1 : .1(t)}, {l2 : .2(t)}) '' . = {(j,W ,s1,s2) \n| (j,W ,s1(l1),s2(l2)) .Vk[t] .} L = {(j, l.hj ) | j = k} En[t] . = {(k, W, e1,e2) . Atom[.1(t),.2(t)]n \n| ' .j <k. .s1,s2,s 1,v1. ' s1,e1 -.j s1,v1 . s1,s2 :k W =. '' .s2,v2,W . (k - j, W ' ) ; (k, W ) . ''' \n' s2,e2 -.* s2,v2 . s1,s :k-j W . 2 ' (k - j,W ,v1,v2) .Vn[t] .} S S = = V [t] . n=0 Vn[t] . E [t] . \nn=0 En[t] . D [\u00b7= {\u00d8}D [.,a]] = {.[a . (., t1,t2)] | . .D [.] . . . Type[t1,t2]} G [\u00b7] . = {(k, W, \u00d8) \n| W . Worldk}G [G,x : t] . = {(k, W, .[x . (v1,v2)]) |(k, W, .) .G [G] . . (k, W, v1,v2) .V [t] .} S \n[S] = {(k, W ) |.(l : t) . S. (k, W, l, l) .V [ref t] \u00d8} def log .; G; S f e1 e2 : t = .;G;S f e1 : \nt . .; G; S f e2 : t . .k = 0. ..,.,W. . .D [.] . (k, W, .) .G [G] . . (k, W ) .S [S] =. (k, W, .1(.1(e1)),.2(.2(e2))) \n.E [t] . def .; G; S f e1 log e2 : t = .;G;S f e1 log e2 : t . log .; G; S f e2 e1 : t Figure 4. Step-Indexed \nLogical Relations for F\u00b5! The relation En[t ] . speci.es when two computations are logi\u00adcally related. \nTwo closed, well-typed terms e1 and e2 are related for k steps at the type t in world W if, given two \ninitial stores s1 and s2 that are related for k steps at world W , if s1,e1 evaluates to s1' ,v1 in j<k \nsteps then the following conditions hold. First, s2,e2 must evaluate to some s2' ,v2 in any number of \nsteps. (For details on why the number of steps e2 takes is irrelevant, see Ahmed [1].) Second, there \nmust exist a world W ' . Worldk-j that extends the world W . Third, the .nal stores s1 ' and s2 ' must \nbe related for the remain\u00ading k - j steps at world W '. Fourth, the values v1 and v2 must be related \nfor k - j steps in the world W ' at the type t. Notice the asymmetric nature of the relation on computations: \nif s1,e1 termi\u00adnates, then s2,e2 must also terminate. Hence, our relations Vn[t ] . model logical approximation \nrather than logical equivalence. The cases of the logical relation for .a.t and .a.t are essen\u00adtially \nstandard. The former involves parameterizing over an arbi\u00adtrary relational interpretation . of a, and \nthe latter involves choos\u00ading an arbitrary relational interpretation . of a. The way the worlds are manipulated \nfollows in the style of the other rules. The logical relation for \u00b5a.t is very similar to previous step-indexed \naccounts of recursive types, as described in Section 3.5. (Note that, although the type gets larger on \nthe r.h.s. of the de.nition, the step index gets smaller, so the de.nition is well-founded.) Any two \nlocations related at a type ref t are publicly accessible references. For reasoning about such visible \nlocations, existing log\u00adical relations methods usually employ some mechanism that is dis\u00adtinct from the \nmachinery used to reason about local or hidden state. Since there always exists a bijection between the \nvisible locations of the two computations, the mechanism usually involves having a special portion of \nthe world that tracks the bijection between visi\u00adble locations as well as the type t of their contents. \nUnlike previous methods, our worlds have no specialized machinery for reasoning about visible locations. \nOur technique for modeling (publicly ac\u00adcessible) references is simply a mode of use of our mechanism \nfor reasoning about local state. Intuitively, two locations l1 and l2 should be related at the type ref \nt in world W for k steps if, given any two stores s1 and s2 that are related for k steps at world W , \nthe contents of these locations, i.e., s1(l1) and s2(l2), are related for k - 1 steps at the type t . \nTo enforce this requirement, we simply install a special island wref that only cares about the one location \nl1 in s1 and the one location l2 in s2. Furthermore, wref has an empty population and a law that says \nthe population should remain empty in future worlds. Finally, the island s .xed store relation . relates \nall stores s1 and s2 whose contents at locations l1 and l2, respectively, are related at type t for j<k \nsteps. Here j<k suf.ces since pointer dereferencing consumes a step (see Section 3.5). The de.nitions \nof logical approximation and equivalence for open terms are given at the bottom of Figure 4. These de.nitions \nrely on the relational semantics ascribed to the contexts ., G, S, which we discuss next. We say a type \nsubstitution . belongs to the relational interpreta\u00adtion of . if dom(.)=., and whenever .(a)=(., t1,t2), \n. is a well-formed relational interpretation (i.e., . . Type[t1,t2]). We let the metavariable . range \nof relational value substitutions. These are .nite maps from term variables x to pairs of values (v1,v2). \nIf .(x)=(v1,v2), then .1(x) denotes v1 and .2(x) denotes v2. We say . belongs to the relational interpretation \nof G for k steps at world W (written (k, W, .) .G [G] ., where FTV (G) . dom(.)), if dom(.) = dom(G), \nand the values .1(x) and .2(x) are related for k steps in world W at type G(x). We say a world W satis.es \na store typing S for k steps (written (k, W ) .S [S]) if W contains an island of the form wref (k, \u00d8, \nt, l, l) for each (l : t ) . S i.e., if l is related to itself for k steps in world W at type ref t . \nWe write .; G; S f e1 log e2 : t (pronounced e1 logically approximates e2 ) to mean that for all k, given \na type substitu\u00adtion . .D [.] and a relational value substitution . such that (k, W, .) .G [G] ., where \nthe world W satis.es S for k steps, the closed terms .1(.1(e1)) and .2(.2(e2)) are related for k steps \nin world W at the type t. Finally, we say e1 and e2 are logically equivalent, written .; G; S f e1 log \ne2 : t , if they logically ap\u00adproximate each other.  4.3 Fundamental Property &#38; Soundness of Logical \nRelation Here we state some of the main properties of our logical relation and sketch interesting aspects \nof the proofs. Further details of the meta-theory are given in the online technical appendix [3]. Lemma \n4.1 (Closure Under World Extension) Let . f t and . .D [.]. If (k, W, v1,v2) .Vn[t ] . and (j, W ' ) \n; (k, W ), then (j, W ' ,v1,v2) .Vn[t ] .. Proof: By induction on n and nested induction on . f t. D \nAn important property of logical approximation is that it is a precongruence, i.e., it is compatible \nwith all the constructs of the language (see e.g., Pitts [20]). We state these compatibility lemmas, \nand give detailed proofs of the ones involving references, in the online technical appendix [3]. The \nmost involved cases are those for allocation (ref) and assignment, which we discuss below. Proofs of \ncompatibility lemmas that do not involve references essentially follow the proofs given in Ahmed [1] \nalthough we must now deal with additional hypotheses and goals involving stores and worlds, this does \nnot complicate the proofs in any fundamental way. The compatibility property for ref says that if .; \nG; S f log log e1 e2 : t then .; G; S f ref e1 ref e2 : ref t . In the proof, we .nd ourselves at a point \nwhere we have stores s1,s2 :k W and we allocate locations l1 ./dom(s1) and l2 ./dom(s2) to hold the values \nv1 and v2 respectively (where we know that (k, W, v1,v2) .V [t ] .). To proceed, we de.ne a new world \nW ' . Worldk-1, which is just LW Jk-1 extended with a new island wref (k - 1, ., t, l1,l2). In addition \nto showing that W ' is a valid world, which is straightforward, we must also show that (1) (k - 1,W ' \n) ; (k, W ) and (2) s1[l1 . v1],s2[l2 . v2]:k-1 W ' . For (1) we need to show that l1 and l2 are distinct \nfrom locations that any island w . W cares about that is, l1 ./dom(S1(W )) and l2 ./dom(S2(W )), which \nfollows easily since l1 and l2 are fresh for s1 and s2. For (2) we must show that for all w ' . W ' , \nand j<k - 1, (j, LW ' Jj ,s1[l1 . v1],s2[l2 . v2]) . w ' ... If w ' is the new island wref (k - 1, ., \nt, l1,l2), then the desired result follows from the knowledge that v1 and v2 are logically related. If \nw ' is any other island, it must be the (k-1)-th approximation of some island w . W . In this case, the \ndesired result follows from closure of w.. under world extension, together with the fact that si and \nsi[li . vi] are identical when restricted to the domain w.Si. The proof of the compatibility lemma for \nassignment is quite similar to that for ref, except that we do not add a new is\u00adland to W since we know \nthat W already contains an island wref (k, ., t, l1,l2) where l1 and l2 are the locations being updated. \nTheorem 4.2 (Fundamental Property) If .; G; S f e : t then .; G; S f e log e : t. Proof: By induction \non the derivation of .; G; S f e : t. Each case follows from the corresponding compatibility lemma. D \nSoundness To show that the logical relation is sound with respect to contextual approximation, we need \nan additional property we call store parametricity. This property says that if f s :S and W . Worldk \nis a world comprising one wref island for each location in S i.e., if S= {l1 : t1,...,ln : tn} and W \n= (w1,...,wn), where each wi = wref (k, \u00d8,ti,li,li)) then s, s :k W . Notice that, to prove store parametricity, \nwe need to show that for each (li : ti) . S, the value stored at location li in store s is related to \nitself at the type ti (i.e., (k, W, s(li),s(li)) .V [ti] \u00d8). Unfortunately, the latter does not follow \nfrom the Fundamental Property, which only allows us to conclude from \u00b7; \u00b7;S f s(li): ti that (k, W, s(li),s(li)) \n.E [ti] \u00d8. What we need is the notion of logical value approximation, log .; G; S f v1 val v2 : t, which \nwe de.ne exactly as .; G; S f v1 log v2 : t except that the E [t] . at the end of that de.nition is replaced \nwith V [t] .. Now we can prove that any well-typed value is related to itself in the appropriate value \nrelation V [t] ., not just in the computation relation E [t] . as established by the Fundamental Property. \nSpeci.cally, we show that .; G; S f v : t log implies .; G; S f v val v : t . (The proof is by induction \non .; G; S f v : t and for each case the proof is similar to that of the corresponding compatibility \nlemma.) With this lemma in hand, store parametricity follows easily. Theorem 4.3 (Soundness w.r.t. Contextual \nApproximation) log ctx If .; G; S f e1 e2 : t then .; G; S f e1 e2 : t . Proof: Suppose f C : (.; G; \nS f t ) . (\u00b7; \u00b7;S ' f t ' ), f s :S ' , and s, C[e1] -.k s1,v1. We must show that s, C[e2] .. If S= {l1 \n: t1,...,ln : tn}, let W = (w1,...,wn), where each wi = wref (k +1, \u00d8,ti,li,li). By the compatibility \nlemmas, we can show \u00b7; \u00b7;S ' f C[e1] log C[e2]: t '. Hence, noting that (k+1,W ) .S [S ' ], we have (k+1, \nW, C[e1],C[e2]) .E [t ' ] \u00d8. Since s, s :k+1 W (by store parametricity) and s, C[e1] -.k s1,v1 (from \nthe premise), it follows that s, C[e2] .. D 5. Examples In this section we present a number of examples \ndemonstrating applications of our method. Our examples do not make use of recursive types (or even recursion), \nbut Ahmed s prior work, which we build on, gives several examples that do [1]. We will walk through the \nproof for the .rst example in detail. For the remaining ones, we only sketch the central ideas, mainly \nby giving suitable island de.nitions and type interpretations. Full proofs for these examples and others \nappear in the online technical appendix [3]. 5.1 Name Generator Our .rst example is perhaps the simplest \npossible state-dependent ADT, a generator for fresh names. Nevertheless, it captures the essence of the \nSymbol example from the introduction: e = let x = ref 0 in pack int, (.z : unit. (++x), .z : int. (z \n= !x)) as s where s = .a. (unit . a) \u00d7(a . bool) and (++x) abbreviates the expression (x := !x+1; !x), \nand let is encoded in the standard way (using function application). The package de.nes an abstract type \na of names and provides two operations: the .rst one returns a fresh name on each invocation, and the \nsecond one checks that any value of type a it is given is a valid name, i.e., one that was previously \ngenerated by the .rst operation. Names are represented as integers, and the local counter x stores the \nhighest value that has been used so far. The intended invariant of this implementation is that no value \nof type a ever has a representation that is greater than the current content of x. Under this invariant, \nwe should be able to prove that the second operation, which dynamically checks this property, always \nreturns true. To prove this, we show that e is equivalent to a second expres\u00adsion e ', identical to e, \nexcept that the dynamic check (z = !x) is eliminated and replaced by true. We only show the one direction, \nlog ' f ee : s. The other direction is proven analogously. Because the terms are closed, this only requires \nshowing that (k0,W0, e, e ' ) .E [s] \u00d8 for all k0 = 0 and worlds W0. Assume stores s0,s 0 ' :k0 W0 and \nthe existence of a reduction sequence s0,e -.k1 s1,v1 with k1 <k0. According to the de.nition of '''' \nE [s] \u00d8, we need to come up with a reduction s0,e -. * s1,v 1 and a world W1 such that (k0 - k1,W1) ; \n(k0,W0) and: s1,s 1 ' :k0-k1 W1 . (k0 - k1,W1,v1,v 1' ) .V [s] \u00d8 By inspecting the de.nition of reduction, \nwe see that s1 = s0[l . 0],v1 = pack int, (.z.(++l), .z.(z = !l)) as s for some l/. dom(s0). In the same \nmanner, s0' ,e ' obviously can choose some l ' ./dom(s0' ) and reduce to: '''' ' s1 = s0[l . 0],v1 = \npack int, (.z.(++l ), .z.true) as s We now need to de.ne a suitable island that enables us to show that \nv1 and v1 ' are related. We know W0 has the form (w1,...,wp)for some p. Let W1 be LW0Jk0-k1 , extended \nwith a new island, wp+1, de.ned as follows: wp+1 =(.k0 0-k1 , Lk0-k1 ) .n =(.kn,Vn, {l : int}, {l ' : \nint}) k .n = {(j, W, s, s ' ) . StoreAtomk | s(l)= s ' (l ' )= n} k Vn = {i | 1 = i = n} Lk = {(j, .jn) \n. LawAtomk | n . N} The population Vn consists of all integers that are valid names in the current world, \ni.e., not greater than the current value of x. We have to show (k0 - k1,W1) ; (k0,W0) and s1,s 1 ' :k0-k1 \nW1. Both are straightforward. By de.nition of V [.a.t], we need to continue by giving a relation .a . \nType[int, int], such that: (k0 - k1,W1, (.z.(++l), .z.(z = !l)), (.z.(++l ' ), .z.true)) .V [(unit . \na) \u00d7 (a . bool)] . with . =[a . (.a, int, int)]. We choose the following one: .a = {(j, W, i, i) . Atom[int, \nint] | i . W [p + 1].V } This interpretation of a depends on the (valid) assumption that it will only \nbe considered at W s that are future worlds of W1 (in particular, it assumes that the (p+1)-th island \nin W , written W [p + 1], is a future version of the wp+1 we de.ned above). We could build this assumption \nexplicitly into the de.nition of .a, but as we will see it is simply not necessary to do so. By virtue \nof this assumption, a value i is only a valid inhabitant of type a in worlds whose (p+1)-th island population \ncontains i, that is, where !l = i. Note that the relation is closed under world extension because V may \nonly grow over time, as explained in Section 3.3. By de.nition of V [t \u00d7 t ' ], it remains to be shown \nthat: 1. (k0 - k1,W1, .z.(++l), .z.(++l ' )) .V [unit . a] . 2. (k0 - k1,W1, .z.(z = !l), .z.true) .V \n[a . bool] .  For each of these, we assume we begin in some strictly future world W2 in which (k2,W2) \n: (k0 - k1,W1) and s2,s 2 ' :k2 W2. First consider (1). We are given s2, (++l) -.k3 s3,v3 for ' '' some \nk3 <k2, and it remains to show that s2, (++l ' ) -. * s3,v 3, such that s3,s 3 ' and v3,v 3 ' are related \nin some future world W3 such that (k2 - k3,W3) ; (k2,W2). From (k2,W2) ; (k0 - k1,W1) we know that W2[p \n+ 1].L = LW1[p + 1].LJk2 = Lk2 . From that (k2,W2[p + 1]..) .Lk2 follows, and hence there exists n such \nthat W2[p+1].. = .kn 2 . That is, W2[p+1].. = .n and W2[p+1].V = Vn. From s2,s ' k2 2 :k2 W2 and k3 <k2 \nwe can conclude (k3, LW2Jk3 ,s2,s ' 2) . .kn 2 and thus s2(l)= s2' (l ' )= n. Consequently, v3 = v3 ' \n= n +1, s3 = s2[l . n + 1], and s ' 3 = s ' 2[l ' . n + 1]. Now we choose W3 to be LW2Jk2-k3 with its \n(p + 1)-th island updated to (.n+1 , Lk2-k3 ). Again, we have to check the relevant k2-k3 properties, \n(k2 - k3,W3) ; (k2,W2) and s3,s ' 3 :k2-k3 W3, which are straightforward. Last, we have to show that \nthe results v3,v 3 ' are related in V [a] . under this world, i.e., (k2-k3,W3,n+ 1,n + 1) . .a. Since \nn +1 . Vn+1 = W3[p + 1].V , this is immediate from the de.nition of .a. Now consider (2). The proof is \nsimilar to that for part (1), but simpler. We are given that (k2,W2,v2,v 2' ) .V [a] . = .a, and s2, \n(v2 = !l) -.k3 s3,v3 for some k3 <k2. The main thing to show is that v3 = true (we can pick the end world \nW3 to just be LW2Jk2-k3 ). As in part (1), we can reason that W2[p + 1].. = .kn 2 for some n, and therefore \nthat s2(l)= n and, by de.nition of .a, also that v2 = n. Hence, v2 = s2(l), and the desired result follows \neasily. 5.2 Using ref As a Name Generator An alternative way to implement a name generator is to represent \nnames by locations and rely on generativity of the ref operator. e = pack ref unit, (.z : unit. (ref \n()), .p :(ref unit\u00d7ref unit). (fst p == snd p)) as s where s = .a. (unit . a) \u00d7 (a \u00d7 a . bool). Here, \nthe second function implements a proper equality operator on names. We want to prove this implementation \ncontextually equivalent to one using integers, as in the previous example: e ' = let x = ref 0 in pack \nint, (.z : unit. (++x), .p :(int \u00d7 int). (fst p = snd p)) as s Here are a suitable island de.nition and \ntype interpretation for a: V) wp+1 =(.k0 , Lk0 ) Vl1,...,ln) .=(.kn,VVl1,...,ln), {li : unit | 1 = i \n= n}, {l ' : int}) k .n = {(j, W, s, s ' ) . StoreAtomk | s ' (l ' )= n} k VVl1,...,ln) = {(li,i)| 1 \n= i = n} Vl1,...,ln) Lk = {(j, .) . LawAtomk | n . N} j .a = {(j, W, l, i) . Atom[ref unit, int] | (l, \ni). W [p + 1].V } Here, and in the examples that follow, k0 represents the current step level, and p \nthe number of islands in the current world W0, at the point in the proof where we extend W0 with the \nisland wp+1 governing the example s local state. In this example, we assume that all labels in a list \n(l1,...,ln) are pairwise disjoint, and l ' is a distinguished label, namely the one that has been allocated \nfor x (as in the previous example). In the de.nitions above, the population not only records the valid \nnames for e ' (as in Section 5.1), but also relates them to the locations allocated by e. The latter \nare not guessable ahead of time, due to nondeterminism of memory allocation, but the law Lk is .exible \nenough to permit any partial bijection between {1,...,n}and Loc to evolve over time. We (ab)use term-level \npairs (l, i) to encode this partial bijection in V . This is suf.cient to deduce i = j iff li = lj when \nproving equivalence of the equality operators. 5.3 Twin Abstraction Another interesting variation on \nthe generator theme involves the de.nition of two abstract types (we write pack t1,t2,e as .a, \u00df.t to \nabbreviate two nested existentials in the obvious way): e = let x = ref 0 in pack int, int, (.z : unit. \n(++x), .z : unit. (++x), .p :(int \u00d7 int). (fst p = snd p)) as s where s = .a, \u00df. (unit . a) \u00d7 (unit . \n\u00df) \u00d7 (a \u00d7 \u00df . bool). Here we use a single counter to generate names of two types, a and \u00df, and a comparison \noperator that takes as input names of different type. Because both types share the same counter, it appears \nimpossible for a name to belong to both types (either it was generated as a name of type a or of type \n\u00df but not of both). The example is interesting, however, in that we have no way of knowing the interpretations \nof a and \u00df ahead of time, since calls to the name generation functions can happen in arbitrary combinations. \nWe can verify our intuition by proving that e is equivalent to an e ' where the comparison operator is \nreplaced by .p :(int \u00d7 int). false. The following w and . de.nitions enable such a proof: wp+1 =(.k00 \n,\u00d8 , Lk0 ) .n,S =(.kn,Vn,S , {l : int}, {l ' : int}) k .n = {(j, W, s, s ' ) . StoreAtomk | s(l)= s ' \n(l ' )= n}Vn,S = {(1,i)| i . S} . {(2,i)| i .{1,...,n}\\ S}Lk = {(j, .n,S ) . LawAtomk | n . N. S .{1,...,n}} \nk j .a = {(j, W, i, i) . Atom[int, int] |(1,i). W [p + 1].V } .\u00df = {(j, W, i, i) . Atom[int, int] |(2,i). \nW [p + 1].V } The population here is partitioned into the valid names for a and the valid names for \u00df, \nbasically recording the history of calls to the two generator functions. To encode such a disjoint union \nin V , each value is wrapped in a pair with the .rst component marking the type it belongs to (1 for \na, 2 for \u00df). When proving equivalence of the two comparison operators, the de.nitions of .a, .\u00df and W \n[p + 1].V directly imply that the arguments must be from disjoint sets. 5.4 Cell Class The next example \nis a more richly-typed variation of the higher\u00adorder cell object example of Koutavas and Wand [13]: e \n=.a. pack ref a, (.x : a. ref x, .r : ref a. !r, .(r, x) : ref a \u00d7 a. (r := x)) as s where s = .\u00df. (a \n. \u00df) \u00d7 (\u00df . a) \u00d7 (\u00df \u00d7 a . unit). We use pattern matching notation here merely for clarity and brevity \n(imagine replacing occurrences of r and x in the third function with fst and snd projections, respectively, \nof the argument). This example generalizes Koutavas and Wand s original version in two ways. First, we \nparameterize over the cell content type a, which can of course be instantiated with an arbitrary higher \ntype, thus exercising our ability to handle higher-order stored values. Second, instead of just implementing \na single object, our example actually models a class, where \u00df represents the abstract class type, and \nthe .rst function acts as a constructor for creating new cell ob\u00adjects. (A subsequent paper by Koutavas \nand Wand also considers a class-based version of their original example [14], but it is modeled with \na Java-like nominal type system, not with existential types.) Similar to [13], we want to prove this \ncanonical cell implemen\u00adtation equivalent to one using two alternating slots: e ' =.a. pack (ref int \n\u00d7 (ref a \u00d7 ref a)), (.x : a. (ref 1, (ref x, ref x)), .(r0, (r1,r2)) :(ref int \u00d7 (ref a \u00d7 ref a)). if \n!r0 =1 then !r1 else !r2, .((r0, (r1,r2)),x) :(ref int \u00d7 (ref a \u00d7 ref a)) \u00d7 a. if !r0 =1 then (r0 := \n2; r2 := x) else (r0 := 1; r1 := x)) as s When e or e ' is instantiated with a type argument, neither \none immediately allocates any new state. Correspondingly, no island is introduced at that point in the \nproof. Rather, a new island is added to the world at each call to the classes constructor functions, \nfor it is at that point when fresh state is allocated in both programs. So, assuming we have been given \na relational interpretation .a . Type[ta,t a' ] for the type parameter a, consider the proof that the \nconstructor functions are logically related. When the con\u00adstructors are called, we allocate fresh state: \nl in the .rst program, and (l0' , (l1' ,l 2' )) in the second program. For convenience, we will package \nthese together notationally as ls = (l, (l0' , (l1' ,l 2' ))). We now extend the current world W with \nwp+1, de.ned as follows: k0 , Lls wp+1 =(.ls k0 ) .ls '' k =(.kls , {ls}, {l : ta}, {l0 ' : int,l 1 \n' : ta,l 2 ' : ta}) .ls = {(j, W, s, s ' ) . StoreAtomk | k .i .{1, 2}.s ' (l0' )= i . (j, W, s(l),s \n' (li' )) . .a}Llsk = {(j, .jls) | j = k} The store relation .kls ensures that the contents of l are \nrelated (by .a) to the contents of the proper slot l1 ' or l2' , depending on the current .ag value stored \nin l0' . Note how the de.nition of .kls relies crucially on the presence of the world parameter W . Without \nit, ' (l ' we would not know in which world to compare s(l) and s i). Note also that in this example \nwp+1 does not evolve (i.e., its store relation remains the same in all future worlds). Finally, when \nproving equivalence of the existential packages, we represent the cell class type \u00df with .\u00df de.ned as \nfollows: .\u00df = {(j, W, l, (l0' , (l1' ,l 2' ))) | W . Worldj . j , Lls 0, (l ' .w . W. w =(.ls j ), where \nls = (l, (l ' 1,l 2' )))} Note that .\u00df includes ls s owned by any island of the right form. This might \nadd some junk to the relation (e.g., objects that were created by some other class s constructor function), \nbut any such junk is harmless since it adheres to the same invariants that the objects created by e and \ne ' do. 5.5 Irreversible State Changes A well-known example that has caused trouble for previous logical \nrelations methods is Pitts and Stark s awkward example [21]. Although this example does not involve existentials, \nit has proven dif.cult to handle because it involves an irreversible state change: e = let x = ref 0 \nin .f :(unit . unit). (x := 1; f(); !x) e ' = .f :(unit . unit). (f(); 1) The idea here is that e and \ne ' are equivalent because, as soon as they are applied, the contents of x are set to 1, after which \npoint !x will always return 1. In other words, the .rst application of e marks an irreversible state \nchange from x . 0 to x . 1. Intuitively, irreversible state changes are hard to handle if the knowledge \nabout a piece of local state is .xed once and for all at the point it is allocated. Using traditional \npossible-worlds models, the most precise invariant one can enforce about the contents of x is that they \nare either 0 or 1. With such a weak invariant, it is impossible to know when returning from f() whether \n!x is still 1. Using populations, however, we can prove the equivalence of e and e ' quite easily. A \nsuitable island de.nition is: wp+1 =(.k\u00d8 0 , Lk0 ) .kV =(.kV , V, {lx : int}, {}) .kV = {(j, W, s, s \n' ) . StoreAtomk | s(lx)= |V |} Lk = {(j, .jV ) | j = k .|V |= 1} The intuition here is that we use V \nto encode a .ag telling us whether x has already been set to 1. Initially, !x is 0, signi.ed by V = \u00d8. \nWhen x is set to 1, we add some arbitrary value to V , making it a singleton set of size 1. Because V \nis only allowed to grow, we know that x can never be changed back to 0. In addition, since the law Lk \nrequires |V |= 1, x must remain at 1 permanently. 5.6 Callback with Lock The proofs for the examples \npresented so far do not use step indices in an interesting way. The last of our examples, which is inspired \nby the reentrant callback example of Banerjee and Naumann [6], demonstrates an unexpected case where \nthe steps come in handy. Relying as it does on subtle stepwise reasoning, our proof for this example \nis rather involved (some might say ugly), but like a dog walking on its hind legs, one is surprised to \n.nd it done at all. Consider the following object encoding of higher-order type t = ((unit . unit) . \nunit) \u00d7 (unit . int): e = C[f (); x := !x + 1] where C = let x = ref 0 in (.f : unit . unit. [\u00b7], .z \n: unit. !x) It implements a counter object with two methods: an increment function, and a get function \nrequesting the current counter value. An interesting feature of this object is that its increment method \ntakes a callback argument, which is invoked before the counter is incremented. Now, consider the following \nalternative implementation for this object, in which x is dereferenced before the callback: e ' = C[let \nn = !x in f (); x := n + 1] One might na\u00a8ively assume that the two versions are equivalent, because x \nis not publicly accessible. But f might perform arbitrary operations, including recursively calling the \nincrement function! In this case, x may be modi.ed between read and write access in e ' . Such reentrance \ncan be prevented by adding a lock: C = let b = ref true in let x = ref 0 in (.f : unit . unit. (if !b \nthen (b := false;[\u00b7]; b := true) else ()) .z : unit. !x) Note that it is still possible for f to invoke \nthe get function, which just reads the current x. With C reimplemented using a lock, e and e ' are now \ncontextu\u00adally equivalent. But how do we go about actually proving this? To show the two increment functions \nequivalent, we need to establish that f cannot modify x. But how can we set up an island that en\u00adsures \nthat? After all, the island s law must certainly allow updates to x in general. How can we formulate \na law that allows the store to change, but still can temporarily prohibit it? Steps to the rescue! When \nproving that the two increment func\u00adtions are related, we assume that one terminates with j steps. As\u00adsuming \nb is set to true (i.e., assuming that x is unlocked ), we can partition the reduction sequence for its \nexecution into 3 phases of length j1 +j2 +j3 = j, where j2 spans the steps spent in the call to f. These \nj2 steps are the time window in which x is not allowed to change. So the idea is to de.ne a law that \nallows setting up time windows of this kind, during which !x must remain constant. The following island \nde.nition does the trick: {Vk0,k0,0)} wp+1 =(.k0 , Lk0 ) min(V ) .V k =(.,V, {lb : bool,lx : int}, {lb \n' : bool,l x ' : int}) k Vk1,k2,n) .= {(j, W, s, s ' ) . StoreAtomk | k (j = k1 . s(lb)= s ' (lb' ) \n. s(lx)= s ' (lx' )) . (j = k2 . (s(lb)= false . s(lx)= n))} Lk = {(j, .jV ) . LawAtomk | 1,n1),..., \n(kmm V = {(k1,k ' ,k ' ,nm)} . k1 = k1 ' >k2 = \u00b7 \u00b7 m-1 >km = k ' } \u00b7= k ' m Each window is represented \nby a triple (k1,k2,n) in V (assuming the obvious encoding of triples using pairs), with k1 and k2 giving \nits .rst (upper) and last (lower) step, and n being the value to which x is .xed during the window. The \nside condition in Lk ensures that windows do not overlap. Consequently, there is always a unique lowest \n(newest) window min(V )= (k1,k2,n), i.e., the one with the least .rst projection (the k1). The store \nrelation . ensures that, if the step level j has not yet passed the lower bound k2 of the newest window \n(i.e., if j = k2), then !x must equal the n from that window, and the lock must be held. The de.nition \nof . also prohibits windows from starting in the future by requiring j = k1. To prove equivalence of \nthe increment functions, starting at step k with s0(lx)= s0' (lx' )= n and s0(lb)= s0' (lb' )= true (the \ninteresting case), we proceed in j1 steps to set b to false, and then add a new lowest window (k - j1,k \n- j1 - j2 - 1,n) to the population of the (p+1)-th island. Next, we know f() returns after exactly j2 \nsteps in some future world W , and the stores s1 and s1 ' that it returns must be related by W at step \nm = k -j1 -j2, which means that (m - 1, LW Jm-1,s1,s 1' ) . W [p + 1]... Since the step level m - 1 is \nstill in the range of the window we installed, we know that f() could not have added an even lower window \nto the population of the (p+1)-th island (as the law disallows adding windows that start in the future). \nThus, we know that W [p+1].. = Vm+j2,m-1,n)' .m , and consequently s1(lx)= s1(lx' )= n and s1(lb)= s \n' 1(lb' )= false. That is, thanks to our use of the lock, the call to f () could not have affected our \nlocal state. 5.7 Well-Bracketed State Changes To conclude, we give two examples that our method appears \nunable to handle. The .rst one, suggested to us by Jacob Thamsborg, is a variant of Pitts and Stark s \nawkward example (Section 5.5): e = let x = ref 0 in .f :(unit . unit). (x := 0; f(); x := 1; f(); !x) \ne ' = .f :(unit . unit). (f(); f (); 1) Here, unlike in the awkward example, the state of x changes back \nand forth between 0 and 1. The reason we believe e and e ' to be equivalent (we do not have a proof!) \nis that the state changes occur in a well-bracketed fashion i.e., every change to 0 is guaranteed to \nbe followed later on in the computation by a change to 1. This implies (informally) that invoking the \ncallback function f will either leave the state of x unchanged or will return control with x set to 1. \nHowever, it is not clear to us how to formally establish this. The trick of representing irreversible \nstate changes via population growth is inapplicable since the state changes are not irreversible, and \nthe time windows idea from Section 5.6 is inapplicable as well since the example does not make use of \nlocks. 5.8 Deferred Divergence Here is another example we cannot handle, due to Hongseok Yang:2 e1 = \n.f :(unit . unit) . unit.f (.z : unit. diverge) e2 = .f :(unit . unit) . unit. let x = ref 0 in let y \n= ref 0 in f (.z : unit. if !x =0 then y := 1 else diverge); if !y =0 then x := 1 else diverge Here, \nf may either call its argument directly, in which case the computation clearly diverges (in e2 this happens \neventually because y is set to 1), or it may store its argument in some ref cell. In the latter case, \nany subsequent call to the stored argument by the program context will also cause divergence (in the \ncase of e2, because x will be 1 at that point). Only if neither f nor the context ever tries to call \nf s argument may the computation terminate. 2 A similar example is discussed in Benton and Leperchey \n[7], at the end of their section 5. However, the two terms in their example are not actually equivalent \nin our language, because we have higher-order store. For us to prove e1 and e2 equivalent, we would need \nsome way of relating the two arguments to f. Initially, however, when the arguments are invoked, one \nterminates and the other does not, so it is not obvious how to relate them. In fact, they are only related \nunder the knowledge of what e1 and e2 will do after the call to f. This suggests to us that one way to \nhandle such an example might be to de.ne a relation on terms coupled with their continuations. 6. Related \nand Future Work There is a vast body of work on methods for reasoning about local state and abstract \ndata types. In the interest of space, we only cite a representative fraction of the most closely related \nrecent work. Logical Relations Our work continues (and, to an extent, synthe\u00adsizes) two lines of recent \nwork: one on using logical relations to reason about type abstraction in more realistic languages, the \nother on using logical relations to reason about local state. Concerning the former, Pitts [20] provides \nan excellent overview, although it is now slightly outdated in the last few years, several different \nlogical relations approaches have been proposed for han\u00addling general recursive (as well as polymorphic) \ntypes [16, 1, 11], which Pitts considers an open problem. Much of the work on this topic is concerned \nwith logical relations that are both sound and complete with respect to contextual equivalence. Completeness \nis useful for establishing various extensionality properties at different types, e.g., that two values \nof type .a.t are contextually equiva\u00adlent iff their instantiations at any particular type t ' are equivalent. \nIn general, however, just because a method is complete with re\u00adspect to contextual equivalence does not \nmean that it is effective in proving all contextual equivalences. In fact, Pitts gives a repre\u00adsentation \nindependence example for which existing techniques are effectively incomplete.3 For a logical relation \nto be complete it must typically be what Pitts terms equivalence-respecting. There are different ways \nto achieve this condition, such as ..-closure [20], biorthogo\u00adnality [16], or working with contextual \nequivalence classes of terms [11]. Pitts ..-closure neatly combines the equivalence\u00adrespecting property \ntogether with admissibility (or continuity, nec\u00adessary for handling recursive functions) into one package. \nWe build on the work of Ahmed [1] on step-indexed logical relations for recursive and quanti.ed types. \nOne advantage of the step-indexed approach is that admissibility comes for free, in the sense that it \nis built directly into the model. By only ever reasoning about .nite approximations of the logical relation \n(Vn[t ] .), we avoid the need to ever prove admissibility. (In other words, an inadmissible relation \nis indistinguishable from an admissible one if one only ever examines its step-indexed approximations.) \nOf course, the price one pays for this is that one is forced to use stepwise reasoning everywhere, so \nadmissibility is not really free after all. To ameliorate this burden, we are currently investigating \ntechniques for proving logical approximation in our model without having to do explicit stepwise reasoning. \nAs we saw in Section 5.6, though, sometimes the presence of the step indices can be helpful. Like Ahmed \ns previous work, our logical relation is sound, but not complete, with respect to contextual equivalence. \n(Hers is com\u00adplete except for the case of existential types.4) While our method cannot in its current \nform prove extensionality properties of con\u00ad 3 Pitts example is actually provable quite easily by a transitive \ncombination of logical relations proofs (www.mpi-sws.org/~dreyer/pitts.txt). Dreyer has suggested a harder \nexample, mentioned on page 25 of Sumii and Pierce [28], for which there is not even any known brute-force \nproof. 4 The published conference version of her paper claims full completeness, but the proof contains \na technical .aw uncovered by the second author. The extended version of her paper corrects the error \n[1]. textual equivalence, it is still useful for proving representation in\u00addependence results, which \nis our primary focus. Recent work by Ahmed and Blume [2] involves a variant of [1] that is complete with \nrespect to contextual equivalence, where completeness is ob\u00adtained by essentially Church-encoding the \nlogical interpretation of existentials (this is roughly similar to what ..-closure does, too). We are \ncurrently attempting to develop a complete version of our method, using a similar approach to Ahmed and \nBlume. Concerning the second line of work logical relations for reasoning about local state most of \nthe recent previous work we know of employs possible-worlds models of the sort we discussed in Section \n3.2, so we refer the reader to that earlier section for a thorough comparison [21, 22, 7, 10]. However, \nthere are two recent pieces of work that are worth discussing in further detail. Perhaps the closest \nrelated work to ours is Nina Bohr s PhD thesis [9], which extends her work with Lars Birkedal [10] in \ntwo directions. First, she gives a denotational possible-worlds model for a language with general recursive \ntypes, polymorphism, and higher-order references, with the restriction that references must have closed \ntype. This restriction seems to imply that her method is inapplicable to the cell class example in Section \n5.4 because it involves references of type ref a. Second, she proposes a more re.ned (and complex) notion \nof possible world in which an island s store relation has the ability to change over time. This is similar \nin certain ways to our population technique, except that her islands do not contain anything resembling \na population. Her approach is designed to handle examples involving irreversible state changes, like \nPitts and Stark s awkward example (Section 5.5), but not generative ADTs (Sections 5.1 5.3). Bohr s possible \nworlds also include the ability to impose invariants on the continuations of related terms, so we believe \nher technique can handle at least one, if not both, of the examples in Section 5.7 and 5.8, which we \ncannot. In a paper conceived concurrently with ours, Birkedal, St\u00f8vring, and Thamsborg [8] present a \nrelationally parametric denotational model of a language with general recursive types, polymorphism, \nand references of arbitrary type. Their model improves on Bohr s in the .exibility of its references, \nbut it offers only a weak notion of possible worlds, with which one can only do very simple reasoning \nabout local state. Their model cannot handle any of our examples. Bisimulations For reasoning about contextual \nequivalences (in\u00advolving either type abstraction or local state), one of the most suc\u00adcessful alternatives \nto logical relations is the coinductive technique of bisimulations. Pierce and Sangiorgi [19] de.ne a \nbisimulation for reasoning about polymorphic p-calculus, and they demonstrate its effectiveness on an \nexample that is similar to our symbol table example. Due to the low-level, imperative nature of the p-calculus, \nit is dif.cult to give a precise comparison between their technique and ours, but the basic idea of their \ntechnique (described below) has been quite in.uential on subsequent work. Sumii and Pierce de.ne bisimulations \nfor an untyped lan\u00adguage with a dynamic sealing operator [27], as well as an ex\u00adtension of System F with \ngeneral recursive types [28]. Koutavas and Wand [13] adapt the Sumii-Pierce technique to handle an untyped \nhigher-order language with general references; in the process, they improve on Sumii-Pierce s treatment \nof contextual equivalences involving higher-order functions. Interestingly, the Koutavas-Wand technique \ninvolves the use of inductive stepwise reasoning when showing that two functions are in the bisimulation. \nSubsequently, Sangiorgi, Kobayashi, and Sumii [26] propose envi\u00adronmental bisimulations, which generalize \nSumii and Pierce s pre\u00advious work to an untyped framework subsuming that of Koutavas\u00adWand s, but in a \nway that does not appear to require any stepwise reasoning. While all of these bisimulation approaches \nare sound and complete with respect to contextual equivalence, none handles a language with both existential \ntype abstraction and mutable state. There are many similarities between bisimulations and logical relations, \nalthough a precise comparison of the techniques remains elusive (and an extremely interesting direction \nfor future work). With bisimulations, one de.nes the relational interpretations of ab\u00adstract types, or \nthe invariants about local state, up front, as part of a relation also containing the terms one wishes \nto prove contextually equivalent, and then one proceeds to show that the relation one has de.ned is in \nfact a bisimulation. With logical relations, the proof proceeds backward in a structured way from the \ngoal of showing two terms logically equivalent, and the invariants about type rep\u00adresentations or local \nstate are chosen in mid-proof. It is arguably easier to sketch a bisimulation proof (by just stating \nthe bisimu\u00adlation), whereas the islands and . de.nitions in our proof sketches must be stated in medias \nres. On the other hand, our islands and . s are more minimal than bisimulations, which must often explicitly \ninclude a number of redundant intermediate proof steps. The Sumii-Pierce-Koutavas-Wand-Sangiorgi-Kobayashi-Sumii \napproach is roughly to de.ne bisimulations as sets of relations, with each relation tied to a particular \nenvironment, e.g., a type interpretation, a pair of stores, etc. Various up-to techniques are used to \nmake bisimulations as small as possible. This approach seems conceptually similar to possible-worlds \nsemantics, but the exact relationship is unclear, and we plan to explore the connection further in future \nwork. Separation Logic To reason about imperative programs in a lo\u00adcalized manner, O Hearn, Reynolds \net al. introduced separation logic [24] as an extension to Hoare logic. Separation logic has been enormously \nin.uential in the last few years, but it has not to our knowledge been used to reason about higher-order \ntyped func\u00adtional languages with type abstraction and higher-order store. No\u00adtably, however, the desire \nto scale separation logic to reason about a functional programming language has led to Hoare Type Theory \n(HTT) [18]. HTT is a dependently typed system where computa\u00adtions are assigned a monadic type in the \nstyle of a Hoare triple. Un\u00adder this approach, programs generally have to pass around explicit proof \nobjects to establish properties. Currently, HTT only handles strong update (where a location s type can \nvary over time), not ML\u00adstyle references with weak update (and thus stronger invariants). Relational \nReasoning About Classes There is a large body of work on reasoning techniques for object-oriented languages. \nFor example, Banerjee and Naumann [5] present a denotational method for proving representation independence \nfor a Java-like language. Koutavas and Wand [14] have adapted their bisimulation approach to a subset \nof Java. The languages considered in these works do not provide generativity and .rst-class existential \ntypes, but rather tie encapsulation to static class de.nitions. On the other hand, subse\u00adquent work by \nBanerjee and Naumann [6] addresses the issue of ownership transfer, which we do not. We believe that \nthe genera\u00adtivity of existential quanti.cation and the separation enforced by possible-island semantics \nare closely related to various notions of ownership and ownership types, but we leave the investigation \nof this correspondence to future work. References [1] Amal Ahmed. Step-indexed syntactic logical relations \nfor recursive and quanti.ed types. In ESOP, 2006. Extended/corrected version of this paper available \nas Harvard University TR-01-06. [2] Amal Ahmed and Matthias Blume. Typed closure conversion preserves \nobservational equivalence. In ICFP, 2008. [3] Amal Ahmed, Derek Dreyer, and Andreas Rossberg. State-dependent \nrepresentation independence (Technical appendix), 2008. Available at: http://ttic.uchicago.edu/~amal/papers/sdri/. \n[4] Andrew W. Appel and David McAllester. An indexed model of recursive types for foundational proof-carrying \ncode. Transactions on Programming Languages and Systems, 23(5):657 683, 2001. [5] Anindya Banerjee and \nDavid A. Naumann. Ownership con.nement ensures representation independence in object-oriented programs. \nJournal of the ACM, 52(6):894 960, 2005. [6] Anindya Banerjee and David A. Naumann. State based ownership, \nreentrance, and encapsulation. In ECOOP, 2005. [7] Nick Benton and Benjamin Leperchey. Relational reasoning \nin a nominal semantics for storage. In TLCA, 2005. [8] Lars Birkedal, Kristian St\u00f8vring, and Jacob Thamsborg. \nRelational parametricity for references and recursive types, July 2008. Draft, submitted for publication. \n[9] Nina Bohr. Advances in Reasoning Principles for Contextual Equivalence and Termination. PhD thesis, \nIT University of Copenhagen, 2007. [10] Nina Bohr and Lars Birkedal. Relational reasoning for recursive \ntypes and references. In APLAS, 2006. [11] Karl Crary and Robert Harper. Syntactic logical relations \nfor polymorphic and recursive types. In Computation, Meaning and Logic: Articles dedicated to Gordon \nPlotkin. 2007. [12] Derek Dreyer, Karl Crary, and Robert Harper. A type system for higher-order modules. \nIn POPL, 2003. [13] Vasileios Koutavas and Mitchell Wand. Small bisimulations for reasoning about higher-order \nimperative programs. In POPL, 2006. [14] Vasileios Koutavas and Mitchell Wand. Reasoning about class \nbehavior. In FOOL/WOOD, 2007. [15] Xavier Leroy. Applicative functors and fully transparent higher-order \nmodules. In POPL, 1995. [16] Paul-Andre Melli\u00b4es and J`\u00b4ome Vouillon. er Recursive polymorphic types \nand parametricity in an operational framework. In LICS, 2005. [17] John C. Mitchell. Representation independence \nand data abstraction. In POPL, 1986. [18] Aleksandar Nanevski, Greg Morrisett, and Lars Birkedal. Hoare \ntype theory, polymorphism and separation. Journal of Functional Programming, 18(5&#38;6):865 911, September \n2008. [19] Benjamin C. Pierce and Davide Sangiorgi. Behavioral equivalence in the polymorphic pi-calculus. \nJournal of the ACM, 47(3):531 586, 2000. [20] Andrew Pitts. Typed operational reasoning. In B. C. Pierce, \neditor, Advanced Topics in Types and Programming Languages, pages 245 289. The MIT Press, 2005. [21] \nAndrew Pitts and Ian Stark. Operational reasoning for functions with local state. In HOOTS, 1998. [22] \nUday Reddy and Hongseok Yang. Correctness of data representations involving heap data structures. In \nESOP, 2003. [23] John C. Reynolds. Types, abstraction and parametric polymorphism. In Information Processing, \n1983. [24] John C. Reynolds. Separation logic: A logic for shared mutable data structures. In LICS, 2002. \n[25] Claudio V. Russo. Non-dependent types for Standard ML modules. In PPDP, 1999. [26] Davide Sangiorgi, \nNaoki Kobayashi, and Eijiro Sumii. Environmental bisimulations for higher-order languages. In LICS, 2007. \n[27] Eijiro Sumii and Benjamin Pierce. A bisimulation for dynamic sealing. Theoretical Computer Science, \n375(1 3):161 192, 2007. [28] Eijiro Sumii and Benjamin Pierce. A bisimulation for type abstraction and \nrecursion. Journal of the ACM, 54(5):1 43, 2007. [29] Janis Voigtl\u00a8ander and Patricia Johann. Selective \nstrictness and parametricity in structural operational semantics, inequationally. Theoretical Computer \nScience, 388(1 3):290 318, 2007.   \n\t\t\t", "proc_id": "1480881", "abstract": "<p>Mitchell's notion of representation independence is a particularly useful application of Reynolds' relational parametricity -- two different implementations of an abstract data type can be shown contextually equivalent so long as there exists a relation between their type representations that is preserved by their operations. There have been a number of methods proposed for proving representation independence in various pure extensions of System F (where data abstraction is achieved through existential typing), as well as in Algol- or Java-like languages (where data abstraction is achieved through the use of local mutable state). However, none of these approaches addresses the interaction of existential type abstraction and local state. In particular, none allows one to prove representation independence results for generative ADTs -- i.e. ADTs that both maintain some local state and define abstract types whose internal representations are dependent on that local state.</p> <p>In this paper, we present a syntactic, logical-relations-based method for proving representation independence of generative ADTs in a language supporting polymorphic types, existential types, general recursive types, and unrestricted ML-style mutable references. We demonstrate the effectiveness of our method by using it to prove several interesting contextual equivalences that involve a close interaction between existential typing and local state, as well as some well-known equivalences from the literature (such as Pitts and Stark's \"awkward\" example) that have caused trouble for previous logical-relations-based methods.</p> <p>The success of our method relies on two key technical innovations. First, in order to handle generative ADTs, we develop a possible-worlds model in which relational interpretations of types are allowed to grow over time in a manner that is tightly coupled with changes to some local state. Second, we employ a step-indexed stratification of possible worlds, which facilitates a simplified account of mutable references of higher type.</p>", "authors": [{"name": "Amal Ahmed", "author_profile_id": "81100287263", "affiliation": "TTI-C, Chicago, IL, USA", "person_id": "P1301011", "email_address": "", "orcid_id": ""}, {"name": "Derek Dreyer", "author_profile_id": "81100381796", "affiliation": "MPI-SWS, Saarbr&#252;cken, Germany", "person_id": "P1301012", "email_address": "", "orcid_id": ""}, {"name": "Andreas Rossberg", "author_profile_id": "81100550426", "affiliation": "MPI-SWS, Saarbr&#252;cken, Germany", "person_id": "P1301013", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1480881.1480925", "year": "2009", "article_id": "1480925", "conference": "POPL", "title": "State-dependent representation independence", "url": "http://dl.acm.org/citation.cfm?id=1480925"}