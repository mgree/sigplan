{"article_publication_date": "01-21-2009", "fulltext": "\n Masked Types for Sound Object Initialization XinQi AndrewC.Myers Computer Science Department Cornell \nUniversity {qixin,andru}@cs.cornell.edu Abstract Thispaperpresentsatype-based solutiontothe long-standingprob\u00adlem \nof object initialization. Constructors, the conventional mech\u00adanism for object initialization, have semantics \nthat are surprising to programmers and that lead tobugs. Theyalso contribute to the problem of null-pointer \nexceptions, which make software less reli\u00adable. Masked types are a new type-state mechanism that explicitly \ntracks the initialization state of objects and prevents reading from uninitialized .elds. In the resulting \nlanguage, constructors are or\u00addinary methods that operate on uninitialized objects, and no spe\u00adcial defaultvalue(null)is \nneeded in the language. Initialization of cyclic data structures is achieved with the use of conditionally \nmasked types. Masked types are modular and compatible with data abstraction.Thetypesystemis presentedina \nsimpli.edobjectcal\u00adculus and is proved to soundly prevent reading from uninitialized .elds. Masked types \nhave been implemented as an extension to Java, in which compilation simply erases extra type information. \nExperience using theextended language suggests that masked types work well on real code. Categories and \nSubject Descriptors D.2.4 [Software/Program Veri.cation]: Class invariants, programming by contract; \nD.3.2 [Language Classi.cations]: Object-oriented languages General Terms Languages, Reliability Keywords \ninvariants, null pointer exceptions, conditional masks, cyclic data structures, data abstraction 1. Introduction \nObject initialization remains an unsatisfactory aspect of object\u00adoriented programming. In the usual approach, \nobjects of a given class are created and initialized only by class constructors. There\u00adfore, when implementing \nclass methods, the programmer can as\u00adsume that object .elds satisfy an invariant established by the con\u00adstructors. \nHowever, in the presence of inheritance, the methods of partly initialized objects may be invoked before \nthe invariant has been established. As a result, reasoning about object initialization can be challenging \nand non-modular. No fully satisfactory solution to object initialization currently exists. This paper \npresents a new solution to the object initialization problem, based on a new type mechanism, masked types. \nAs Sec- Permission to make digital or hard copies of all or part of this work for personal or classroom \nuse is granted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page.To copyotherwise, to republish, \nto post on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. POPL \n09, January 18 24, 2009, Savannah, Georgia, USA. Copyright c &#38;#169; 2009ACM 978-1-60558-379-2/09/01... \n$5.00. tion2describes,amaskedtypekeepstrackofthepartsofanobject thathave not been initialized.Forexample, \nthe type T\\ f describes an object of type T whose .eld f may not be initialized yet, and the type T\\* \nrepresents an object none of whose .elds are neces\u00adsarily initialized. As an object is constructed, the \ntype of the object changes to re.ect the .elds that are initialized. Thus, the type sys\u00adtem for masked \ntypesis .ow-sensitive; it has typestate [31]. The type of an object conservatively tracks its initialization \nstate, so a partially initialized object cannot be used where a fully initialized object is expected. \nThe problem of object initialization is intertwinedwith the prob\u00adlem of null pointer exceptions, which \nsigni.cantly hurt software reliability [2]. Because object initialization is unsound, most lan\u00adguages \naiming for type safety (e.g., Java, C#, Modula-3) .rst ini\u00adtialize .elds with null. This semantics implies \nthat null must bea legal value for all object types, leading to ubiquitous, implicit null checks that \ncan generate null pointerexceptions. Recently there has been interest in controlling null pointer exceptions \nthrough non\u00adnull annotations and other means[7,2,19,6]. Non-null annotations by themselves do not solve \nthe problem of object initialization; in fact, theymake it more important because non-null .elds must \nbe initialized before use. But with masked types, there is no need for a default initialization value. \nIt is then straightforward to eliminate null values entirely from the language. There are legitimate \nuses of null other than as an initialization placeholder, but for these uses, an option or maybe type \nis a better approach, because it makes null checks explicit and rare. Alanguage with masked types can \nbe simpler in another way. There is no need to give constructors a special status in the lan\u00adguage, because \ntypes track initialization state. Rather than a lan\u00adguage feature, constructors become a design pattern: \nthey are ordi\u00adnary methods that change the initialization state of the receiver. Cyclic data structures \npose a challenge for object initialization. However, conditionally masked types make it possible to create \ncyclic data structures, such as doubly-linked lists and trees with parent pointers, without resorting \nto placeholder null values. Con\u00additional masks record dependencies between initialization of differ\u00adent \n.elds, so that initializing one .eld can tie the knot , changing the initialization state of many.elds \nat once. Perhaps the most closely related priorworkis thatofF\u00a8 ahndrich and Xia [9], who introduce delayed \ntypes for static reasoning about partially initialized objects. Masked types supportcyclic data struc\u00adtures \nthat delayed types do not. Masked types also support richer initialization abstractions: for example, \nhelper methods for par\u00adtial initialization and reinitialization of recycled objects. Abstract masks, \ndescribed in Section 3, support initialization abstractions that are compatible with data abstraction \nand inheritance. Masked types have been formalized for a simpli.ed object lan\u00adguage, described in Section \n4. Thekeysoundness theorem is for\u00admalized and has been proved for this language: well-typed pro\u00adgrams \nnever read uninitialized .elds. 1 class Point { 2 int x, int y; 3 Point(int x, int y) { 4 this.x = x; \n5 this.y = y; 6 display(); 7 } 8 void display() { 9 System.out.println(x + \" \" + y); 10 } 11 } 12 13 \nclass CPoint extends Point { 14 Color c; 15 CPoint(int x, int y, Color c) { 16 super(x, y); 17 this.c \n= c; 18 } 19 void display() { 20 System.out.println(x + \" \" + y + \" \" + c.name()); 21 } 22 } Figure \n1. Code with an initializationbug Section5reports on the implementationof masked types asa mostly backward-compatible \nextension to the Java language called J\\mask. Section 6 discusses experience using J\\mask in the con\u00adtext \nof the Java Collections Framework, where masked types are showntodoagoodjobof capturing desirable initialization \nidioms. Relatedworkis discussedin Section7. Section8concludes. 2. Masked types Figure 1 illustrates a \nbug that can easily happen in an object\u00adoriented language like Java. In the class Point, representing \na 2D point, the constructor callsavirtual method display that prints the coordinates of the point. The \ntwo .elds x and y are properly initial\u00adized before display is called. However, in the subclass CPoint \nrepresenting a colored point, the display method has been over\u00adridden in a way that causes the added \nc .eld to be read before it is initialized, resulting in a null pointer exception. Thisexampleis simple,butin \ngeneral, initializationbugs are dif.cult to prevent in an automatic way. It would be too restrictive \nto rule out virtual method calls on partially constructed objects. Further,thebuginvolvesthe interactionofcodefromtwodifferent \nclasses(Point and CPoint).An implementer ofCPoint might not have access to the code of Point and would \nnot realize the danger of overriding the display method in this seemingly reasonable way. Our goal is \nto prevent code like that of class Point from type\u00adchecking,but to allow complex, legitimate initialization \npatterns. Thekey observation is that before the call to display on line 6, the .elds in Point are initialized,but \n.eldsof subclassesof Point are not. However,the type of the method display does not prevent the partially \ninitialized receiverfrombeing passedtoanoverridden version of the method that reads uninitialized .elds, \nas in CPoint. 2.1 Types for initialization state Amasked typeT\\M, where Mis a mask that denotes some \nobject .elds, is the type T but without read access to the denoted .elds. Masked types are a completely \nstatic mechanism, so a J\\mask programis compiledby erasing masks.No run-time penaltyispaid for safe object \ninitialization. The simplest form of a mask is just the name of a .eld. For example, an object of type \nCPoint\\c is an instance of the CPoint class whose .eld c cannot be read, perhaps because it has not been \ninitialized.We say that the .eld c is masked in this type. Atype with no mask means that the object is \nfully initialized. In typical programming practice, this would be the ordinary state of the object, in \nwhich its invariant is already established. On entry to a constructor such as Point(), the newly created \nobject has all its .elds masked. The actual class of the new object might be a subclass (for example, \nCPoint), so on exit, subclass .elds remain to be initialized.A subclass mask, written C.sub, is used \nto mask all .elds introduced in subclasses of C, not including those of C itself. Therefore, just before \nline 4 in Figure 1, the object being constructed hastype Point\\x\\y\\Point.sub. (While this type looks \ncomplicated, it can be inferred automatically.) When a .eld is initialized by assigning to it, the correspond\u00ading \nmask is removed from the type of the object. For example, line4in Figure1assigns to .eld x, so the type \nof this becomes Point\\y\\Point.sub. After the assignment to y on the next line, the type of this becomes \nPoint\\Point.sub. Thus, the initializa\u00adtion of various .elds is recorded in the changing type of this. \nBecause variables may have different types at different program points,J\\mask has a .ow-sensitive type \nsystem. Subclass masks such as Point.sub can be removed when the exact run-time class of an object is \nknown, because there are no subclass .elds left to initialize. The type of a new expression is known \nexactly, as is the type of a value of anyclass known not to have a subclass (in Java, a .nal class). \nJ\\mask has a special mask * as a convenient shorthand for masking all .elds, including those masked by \nthe subclass mask. On entry to the CPoint constructor, the object can be given type CPoint\\*, which is \nequivalent to CPoint\\x\\y\\c\\CPoint.sub. 2.2 Mask effects In J\\mask, methods and constructors can have \neffects [23] that propagate mask information across calls.Forexample, theJ\\mask signatures for the Point \nconstructor and the display method can be annotated explicitly with effect clauses: Point(int x, int \ny) effect * -> Point.sub void display() effect {} -> {} The effect of this Point constructor says that \nat entry to the constructor, all .elds are uninitialized (precondition mask *)and therefore unreadable; \nat the end of the constructor, only .elds in\u00adtroduced by subclasses of Point remain uninitialized (postcondi\u00adtion \nmask Point.sub). Because the initial and .nal masks of the display method are both {}, denoting the absence \nof anymask, the method can be called only with a fully initialized object, and it leaves the object fully \ninitialized. With theseeffects, thebugin Figure1 wouldbe caught stati\u00adcally. The method display cannot \nbe invoked on line 6, because there the type of this is Point\\Point.sub, which does not sat\u00adisfy the \nprecondition of display. TheJ\\mask compiler detects this unsafe call without inspecting anysubclass of \nPoint. Thisexample suggestshow maskeffects make theJ\\mask type system modular. Mask effects explicitly \nrepresent the contract on initialization states that a method is guaranteed to follow. This explicit \ncontract allows the compiler to type-check programs one class at a time, and also enables programmers \nto reason about initialization locally. Indeed, masked types and mask effects capture changes to ini\u00adtialization \nstate with enough precision that constructors inJ\\mask are essentially ordinary methods that remove masks \nfrom the re\u00adceiver. However,for convenience and backward compatibility, the J\\mask language still has \nconstructors. To reduce the annotationburden, theJ\\mask language provides default effects for methods \nand constructors.Programmers do not normallyhaveto annotatecodewitheffectsor masks.For ordinary methods, \nthe default is {}-> {}; for constructors, the default effect is close to that shown above (see Section \n2.3). The effects shown capture changes to the initialization state of the parameter this, the receiver \nobject. J\\mask also supports effects on other parameters, as shown in Section 2.5. For simplicity, exceptions, \nwhich are rarely thrown during ini\u00adtialization anyway, have been ignored in this paper. However, ex\u00adceptions \ncan be supported by providing a postcondition for each exceptional exit path in the effect clause. 2.3 \nMust-masks All the masks shown in Section 2.1 are simple masks. A simple mask S, e.g., f, *, or C.sub, \nmeans that the .elds it describe may be uninitialized. Thus, there is a subtyping relationship T= T\\S, \nbecause it is safe to treat an initialized .eld as one that may be uninitialized. However, when an object \nis created, it is known that all the .elds must be uninitialized.J\\mask uses must-masks, written S!, \nto describe .elds that must de.nitelybe uninitialized.Amust-masked type T\\S!is also a subtype ofT\\S,but \nT is not a subtype of T\\S!. One use of must-masks is for initialization of .nal .elds, which is only \nallowed when the .eld is must-masked, ensuring that the .eld is initialized exactly once. Must-masks \nand the absence of masks roughly correspondto the notions of de.nite unassignment and de.nite assignment \nin the Java Language Speci.cation [12]. However,J\\mask ensures that a .nal .eld cannot be read before \nit is initialized, whileJava does not.J\\mask also lifts the limitation in Java that .nal .elds can only \nbe initialized in a constructor or an initializer. Must-masks are also used to express the default effect \nof a con\u00adstructor of class C, which is *! -> C.sub!. Objects start with all .elds de.nitely uninitialized, \nwhich is represented with the initial mask *!. Constructors usually do not initialize .elds declared \nin subclasses, so the default postcondition mask is C.sub!. Must-masks impose restrictions on how an \nobject can be aliased: if there is a reference with a must-masked type, it must be the only reference \nthrough which the object may be accessed; otherwise, the must-masked .eld might be initialized through \nan\u00adother reference to the object, invalidating the must-mask. This does not preclude aliasing,but implies \nrather that other references have to be through .elds that are themselves masked. J\\mask uses typestate \nto keep track of initialization state. A problem with most previous typestate mechanisms is that they \nre\u00adquire reasoning about potential aliasing, to prevent aliases to the same object that disagree about \nthe current state. Aliasing makes it notoriously dif.cult to check whether clients and implementa\u00adtions \nare compliant with protocols speci.ed with typestate [1], and muchpreviousworkon typestates requires \ncomplicated aliasingan\u00adnotations or linear types.J\\mask is designed to work with no extra aliasing control \nmechanism, which provides the added bene.t of soundness in a multi-threading setting, since operations \non an ob\u00adject through aliases from other threads do not invalidate typestates in the current thread. \nThekeytoavoiding reasoningabout aliasingisthatifanassign\u00adment creates an unmasked alias, then must-masks \non both sides are conservatively converted to corresponding simple ( may ) masks. For example, after \nthe following code, the type of bothx and y is the simply masked type C\\f: C\\f! x = ...; C\\f! y= x; \nSimilarly the following code also removes the must annotation from the type binding of variable x, because \nz.g becomes an alias and the .eld g is not masked in the type D of variable z: C\\f! x = ...; D z = ...; \n z.g = x; The non-aliasing requirement on must-masks might seem re\u00adstrictive,butitis usually nota problem: \nmust-masks typicallyap\u00adpear near allocation sites, where no alias has been created. 2.4 Reinitialization \nBeyond initialization, masked types can help reasoning about reini\u00adtialization.Amask can represent not \nonly an uninitialized .eld,but alsoa .eld that mustbe reassigned before further read accesses.To enforce \nreinitialization, a mask can be introduced on the .eld, via the subtyping rule T= T\\ f. Forexample, Figure2illustratesacustom \nmemory management system that manages a pool of recycled objects of the class Node. Actively used objects \nare not in the pool and store data in their d .elds. Objects in the pool are threaded into a freelist \nusing their next .elds. When a Node object is no longer used, it is put into a pool by calling the recycle \nmethod; when a new instance of Node is needed, the getNode method returns an object from the pool, if \nthere is any. Masked types can help ensure that the .eld d is reinitialized whenever a Node object is \nretrieved from the pool and gets a second life. Of course, like most custom memory management systems, \nthe codein thisexample does not guarantee that no alias exists after an object is recycled. Masked types \nare not intended to enforce this kind of general correctness. 1 class Node { 2 Data d; 3 Node\\d next; \n4 } 5 6 class Pool { 7 Node\\d head; 8 ... 9 Node\\d\\next getNode() { 10 if (head != sentinel) { 11 Node\\d\\next \nresult = head; 12 head = head.next; 13 return result; 14 } else 15 return new Node(); 16 } 17 void recycle(Node\\next \nn) { 18 n.next = head; 19 head = n; 20 } 21 } Figure 2. Object recycling The type Node is a subtype \nof Node\\d, and therefore the sec\u00adond assignment (line 19) in method recycle type-checks, causing Node \nobjects in the pool to forget about the data stored in .eld d. Masked types provide an additional bene.t \nhere. Objects in active use have type Node\\next,preventing traversal of the freelist from outside the \nPool class.  2.5 Initializing cyclic data structures Many data structures that arise in practice contain \ncircular refer\u00adences: for example, doubly linked lists and trees whose nodes have parent pointers. Safe \ninitialization of these cyclic data structures posesa challenge.In object-oriented languages, storinga \nreference to a partially initialized object is normally required, with no guar\u00adantee that the object \nis fully initialized before use. J\\mask explicitly tracks .elds that point to partially ini\u00adtialized \nobjects with conditionally masked types, written T\\ f[x1.g1,..., xn.gn]. The conditional mask f[x1.g1,...,xn.gn] \ndescribes a .eld f referencing a partially initialized object, which will become fully initialized when \nall .elds xi.gi are initialized. In other words, the removal of the mask on f is conditioned on the removal \nof all masks on xi.gi. Conditional masks are normally introducedbyan assignmentto a must-masked .eld \nf, when the right-hand side of the assignment has more masks than the declared .eld type. Consider,forexample, \na .eld assignment x.f= y, where x has type T\\ f!, y has type T'\\g, and the .eld f of class T has type \nT'. Note that T'\\gis not a subtype of T'.J\\mask makes this assignment safe by changing the type of x \nto T\\ f[y.g] after the assignment, showing that the .eld x.f is still masked,but its mask should be removed \nupon the removal of the mask on y.g. 1 class Node { 2 Node parent; 3 Node() effect *! -> *! { } 4 } \n5 6 final class Leaf extends Node { 7 Leaf() effect *! -> parent! { } 8 } 9 10 final class Binary extends \nNode { 11 Node left, right; 12 Binary( 13 Node\\parent!\\Node.sub[l.parent] -> *[this.parent] l, 14 Node\\parent!\\Node.sub[r.parent] \n-> *[this.parent] r) 15 effect *! -> parent!, left[this.parent], 16 right[this.parent] { 17 this.left \n= l; 18 this.right = r; 19 l.parent = this; 20 r.parent = this; 21 } 22 } 23 24 Leaf\\parent! l = new \nLeaf(); 25 Leaf\\parent! r = new Leaf(); 26 Binary\\parent!\\left[root.parent]\\right[root.parent] 27 root \n= new Binary(l, r); 28 root.parent = root; // Now root has type Binary. Figure 3. Initialization of \na tree with parent pointers Figure3showshowto safely initializea binary treewith parent pointers.For \nconvenience, we assume all localvariables, including formal parameters, are final. (Section 5 discusses \nhow to relax this.) Figure3also demonstrateseffects on parameters other than the receiver this: the parameters \nl and r of the Binary constructor both have the type Node\\*[this.parent] upon the exit of the constructor. \nIn this example, initialization is bottom-up, as it would be, for example, in a shift-reduce parser. \nChild nodes are created, initialized, and then used to construct their parent node. However, child nodes \ncannot be fully initialized before their parent .elds are set, and moreover, theycannot even be considered \nfully initialized before the .elds of all the objects that are transitively reachable are set. (Top-down \ninitialization of this data structure creates similar issues.) The parent .eld of a node will eventually \npoint to an object that is created later and that contains child pointers pointing back to the current \nnode, creating parent child cycles. Of course, the parent .eld of the root of the tree must point to \nsomething special. For example, it can point to the root itself, as shown on line 28, or to a sentinel \nnode. The dependencies between masks after line 20 in Figure3 are summarized in Figure 4, where the mask \nat the tail of an arrow is removed when the mask at its head is removed. The masks on this.left and this.right \nafter line 20 transitively depend on the mask on this.parent. Figure 4. Mask dependencies The postcondition \nin the effect of the Binary construc\u00adtor summarizes the dependencies in the .gure: parameters l and r \nboth have mask *[this.parent], which means that all their .elds are conditionally masked, and this has \ntype Binary\\parent!\\left[this.parent]\\right[this.parent], which is compatible with the parameter type \nof the Binary constructor. Therefore, the construction can proceed to build higher trees. Finally, the \ntree is fully initialized when the parent .eld of the root is initialized, because removing its mask \nenables removing all the masks in Figure 4. In general, a .eld f should be unreadable unless every object \ntransitively reachable through f has been appropriately initialized. That is, its masks have been removed \nat least to the level according to the type of the .eld through which the object is referenced. Therefore, \nthere are three ways to remove a conditional mask on .eld f: Likeother kinds of masks, the conditional \nmask can be removed by directly initializing the .eld f.  As shown in Figure 3, on line 28, conditional \nmasks on root.left and root.right are removed by removing the mask root.parent they(transitively) depend \non.  Thelastwayto removea conditionalmaskisby creatingcyclic dependencies.Forexample, the following \ncode creates cyclic dependencies between x.f and y.g, which cancel each other.  // x starts with type \nC\\f!, and y starts with D\\g! x.f = y; // now x has type C\\f[y.g] y.g = x; // now y has type D\\g[x.f] \n// x can be typed C, and y can be typed D In general, if some dependencies form a strongly connected \ncomponent in which no mask depends on a mask outside the component, theycan all be removed together. \nSubtyping generalizes to conditionally masked types: T = T\\ f[x1.g1,...,xn.gn] = T\\ f.Infact,a type T \nwith unmasked .eld f can be viewed as a type that has empty conditions for the mask on f, that is, T\\ \nf[], and a simply masked type T\\ f can be seen as having an unsatis.able condition on f, because a simple \nmask cannot be removed by removing other masks. Conditional masks and simple masks do not impose anyrestric\u00adtion \non aliasing, because mask subtyping ensures that theycannot beinvalidatedbyanyfuturechangetotheobject.This \npropertyhas been called heap monotonicity [8]. Conditional masks also provide a way to create temporarily \nunreadable aliases for must-masked objects. Becausethe aliases are unreadable,themust annotationsneednotberemoved.InFigure3, \nfor example, the assignment on line 17 creates an alias this.left for the left child object stored in \nvariable l, but l remains of type Node\\parent!, since the .eld this.left is masked with the conditional \nmask left[l.parent] after line 17. Not losing the must information means the initialization state of \nl is tracked more precisely. For simplicity, .elds currently must be declared with unmasked or simply \nmasked types; no conditional masks or must-masks are allowed. It should be straightforward to add support \nfor condition\u00adally masked .eld types,but thisis left for futurework. 3. Abstract masks With the exception \nof * and C.sub, the masks we have seen so far areconcrete, explicitly naming instance .elds. Concrete \nmasks create dif.culties for data abstraction, because the .elds might not be visible where the masks \nare needed.Forexample,in Figure3, if the two .elds left and right of class Binary were private, it wouldbe \nimpossibletodeclarethelocalvariableroot as shown on line 26, because its type mentions the names of the \n.elds outside the class de.nition. 1 class Node { 2 mask Children; 3 ... 4 } 5 6 final class Binary extends \nNode { 7 private Node left, right; 8 mask Children += left, right; 9 Binary(...) 10 effect *! -> parent!, \n11 Children[this.parent] { ... } 12 ... 13 } 14 ... 15 Binary\\parent!\\Children[root.parent] 16 root = \nnew Binary(l, r); 17 root.parent = root; Figure 5. The tree example with abstract masks ThereforeJ\\mask \nintroduces abstract masks that abstract over sets of concrete .elds, providing a way to write types that \nmask .elds that are not visible. Figure5shows an updatedversionof the code from Figure 3, where the two \n.elds left and right are now private, and an abstract mask Children is introduced to mask them outside \nthe class Binary. The Children mask is .rst declared in class Node (line 2), with an empty set of .elds, \nand is overridden in Binary (line 8) to include the two children of a binary node. J\\mask currently allows \nabstract masks to be overridden only to include more.elds; morecomplexoverridingislefttofuturework. The \n* mask, introduced in Section 2.1, is not much different from any other abstract mask, except that it \nis built-in, and is automatically overridden in every class to include all the .elds declared in that \nclass. 3.1 Modular checking of abstract masks Subclass masks. The Point/CPoint example in Section 2.1 \nshowed that unsafe calls to overridden methods could be caught in a modular way with the help of the \nsubclass mask Point.sub. The mask Point.sub can be connected to the abstract mask * through the equivalence \nof the two types Point\\* and Point\\x\\y\\Point.sub. Any type with an ab\u00adstract mask can be similarly expanded. \nFor example, given the code in Figure 5, the masked type Binary\\Children is equivalent to Binary\\left\\right\\Binary.Children.sub, \nwhere Binary.Children.sub represents all the concrete masks that are added into overriding declarations \nof Children in subclasses of Binary, excluding Binary itself. The set {left,right,Binary.Children.sub} \nis the interpretation of Children in the context of Binary. In general, C.M.sub represents the subclass \nmask of abstract mask Mwith respect to class C, and the interpretation of M in the context of Cis a set \nconsisting of all the concrete masks added into Min Cand its superclasses, together with subclass mask \nC.M.sub. Before type checking, theJ\\mask compiler internally expands all abstract masks into their interpretations. \nSubclass masks are important for modular type checking, be\u00adcause theymake it possible to distinguish \nthe current de.nition of an abstractmaskandoverriding de.nitionsin subclasses,whichare generally unavailable \nin a modular setting. 1 class C { 2 T f; 3 mask M+= f; 4 void initM() effect M -> {} { 5 this.f = ...; \n6 } 7 } 8 9 class D extends C { 10 T g; 11 mask M+= g; 12 void initM() effect M -> {} { 13 this.g = ...; \n14 super.initM(); 15 } 16 } Figure 6. Code that needs mask constraints Mask constraints. Subclass masks \nhelp prevent unsafe calls,but since theydescribe .elds that are generally not known in the cur\u00adrent class, \nsafely removing them by initialization requires some additional mechanism. Figure6 illustrates an initialization \nhelper method initM, which is intended to remove the abstract mask M from its receiver. It is properly \noverridden in the subclass D to han\u00addle the overridden abstract mask M. However, the initM method would \nnot type-check as written in Figure 6, because right after line 5, the type of this is actually C\\C.M.sub, \nrather than the un\u00admasked type C. J\\mask uses mask constraints to solve this problem. Ev\u00adery J\\mask method \ncan declare a mask constraint of the form captures M1,..., Mn, where M1,...,Mn are abstract masks. This \nconstraint means that the body of the method is type-checked as\u00adsuming that the masks Mi are the same \nas their concrete de.nition in the class where the method is de.ned, with no subclass masks. For example, \nthe signature ofinitM on lines4and 12 can be updated with a mask constraint: void initM() effect M -> \n{} captures M The example then type-checks, because at the entries to initM in classes C and D, the type \nof this becomes C\\f and D\\f\\g respectively, rather than C\\f\\C.M.sub and D\\f\\g\\D.M.sub. However, when \ntype-checking callers against the public signa\u00adture of the method, the abstract mask should still be \ninterpreted to include the subclass mask. A method de.ned in class C with a mask constraint on an abstract \nmask M depends on the set of .elds that M denotes in C. It would be unsound to allow that method to be \ninherited by a subclass that overrides the abstract mask. Therefore, the type system requires such methods \nto be overridden when the masks they depend on are overridden. Consequently, constructors, .nal methods, \nand static methods cannot havemask constraints, because theycannot be overridden in subclasses. programs \nPr ::= (L, e) class declarations L ::= class Cextends C'{FMt} .eld declarations F ::= Tf method declarations \nMt ::= Tm(Tx) effect M1 . M2 {e} simple masks S ::= f | subC masks M ::= S | S! | S[p.Sp] paths p ::= \nf | x unmasked types U ::= .| C | C! types T ::= U | T\\M expressions e ::=(Tp) | new C | e1; e2 | e. \nf | (T1 p1). f =(T2 p2) | (T0 p0).m((Tp)) | let Tx = e1 in e2 typing environments G ::= 0/ | G, x:T \n| G,f :T heaps H ::= 0/ | H,f . o objects o ::= C!\\M{ f = f}evaluation contexts E ::=[\u00b7] | E. f | E; \ne | let Tx = Ein e Figure 7. Grammar  3.2 Mask algebra J\\mask supports two algebraic operations on masks \nthat make ab\u00adstract masks more useful: (M1+ M2) and (M1- M2). An abstract mask can be interpreted as \na set of concrete masks on .eldsand possiblyasubclass mask.Thetwooperatorson masks correspond to the \nset union(+) and set difference (-) of the interpretations of the abstract masks. Concrete masks can \nappear in algebraic masks, where they are interpreted as singleton sets. Algebraic masks enable the programmer \nto express initializa\u00adtion state abstractly, without knowing all the .elds masked by an abstract mask. \nFor example, suppose there is a local variable x, starting with the type T\\Mwhere Mis an abstract mask, \nand .eld x. f is initialized: T\\M x = ...; x.f = ...; // The type of x is now T\\(M -f) Here, one needs \nnot knowwhich concrete masks are included in M, nor even whether Mincludes f. Mask algebra also helps \nprogrammers compose masks tokeep the typestates in J\\mask compact. For example, if a class has n .elds, \neach of which might independently be initialized or unini\u00adtialized,itwould require2n different typestates \nto represent all pos\u00adsible initialization states, were there no mask algebra.With mask algebra, one can \nsimply use the sum of the masks corresponding to all the uninitialized .elds. J\\mask currently only supports \nthese two algebraic operations on masks,but they seem to suf.ce. Richer operators on masks are left to \nfuture work. 4. TheJ\\mask calculus Wenowformalizemaskedtypesaspartofasimpleobject calculus. Unfortunately, \nprevious object calculi are not suitable for modeling masked types. 4.1 Grammar Figure7shows the grammar \nof the coreJ\\mask calculus.We use the notation afor both the list a1,..., an and the set {a1,..., an},for \nn = 0.We abbreviate terms with list subtermsintheobviousway, e.g., Tx stands for T1 x1,...,Tn xn, T\\Mstands \nfor T\\M1\\...\\Mn, and p.Sstands for p.S1,..., p.Sn. AprogramPr is a pair (L,e) of a set of class declarations \nLand an expression e (the main method). Each class Cis declared with a superclass C', a set of .eld declarations \nF and a set of method declarations Mt.To simplify presentation, all the class declarations are assumed \nto be global information. J\\mask only supports single inheritance. The root of the class hierarchy is \ndenoted by .. We write C-C' to mean that class C is a direct subclass of C', and the relation -* is the \nre.exive and transitive closure of -. Notably, there is no null value in the language, because none is \nneeded for object initialization. There are three kinds of masks: simple masks S, must-masks S!, and \nconditional masks S[p.Sp]. The auxiliary function simple elides the must annotation and conditions of \na mask. simple(S)= S simple(S!)= S simple(S[p.Sp]) = S There are two kinds of simple masks: concrete \n.eld masks f, and subclass masks subC, that is, C.sub in theJ\\mask language. The calculus does notexplicitly \nmodel the abstract mask *,because it can be expanded into a collection of .eld masks and a subclass mask.Forthe \nsimplicityofthe semantics, other abstract masksand mask constraints are omitted. We require thatina well-formed \ntype, no two masks mention the same .eld, and every variable appearing in a condition is in the domain \nof the typing environment. The order of masks in a type does not matter, so T\\ f1\\ f2 = T\\ f2\\ f1. An \nunmasked type U is either a normal class type Cor an exact class type C!. An object of C!must be an instance \nof classC, and not of any proper subclass of C. (This overloads the ! symbol, which is also used for \nmust-masks.) The source of exactly typed values is object creation, because the expression new C has \ntype C!. Exact types are useful because theymake removal of subclass masks possible, as discussed in \nSection 2.1. An object is created with expression new C, which adds a fresh memory location to the heap, \nwith all .elds uninitialized. Uninitial\u00adized .elds are not represented in the heap, so there is no need \nfor null. Initialization is done by calling appropriate methods. To simplify presentation of the semantics \nand the proof of soundness, we allowonly paths p(localvariables xat compile time, or heap locations f \nat run time) to appear in .eld assignments and method calls. This does not restrict expressiveness, because \nof let expressions. Every read through a path p is represented as an expression (Tp), where the annotation \nT is a statically known type. The annotation is primarily to make the proof of soundness easier; in the \nactualJ\\mask implementation, T is inferred by the compiler. Typing environmentsG contain type bindings \nfor bothvariables x and heap locations f. Bindings for locations are extracted from the heap and are \nused to type-check expressions during evaluation. TheJ\\mask calculus models the heap as a function from \nmem\u00adory locations lto objects o.The formalization attachesa typetoev\u00adery object on the heap, in addition \nto value bindings for the .elds. The object type is always based on some exact class type, which is known \nat run time. The type might also have masks, and since the base class is always exact, no subclass mask \nmay appear on the heap. Masks in the operational semantics are included only for the soundness proof \nand can be erased in the implementation.  4.2 Class member lookup Figure 8 shows auxiliary functions \nfor looking up class mem\u00adbers. For a class C, ownFields(C) and ownMethods(C) are the set of .elds and \nmethods declared in C itself, and .elds(C) and methods(C) also collect those declared in all the superclasses \nof C. fnames(F) is the set of all the .eld names in .eld declarations F.For simplicity, we assume no \ntwo .elds have the same name. ' Gf T= T G f T1= T2 G f T2= T3 f C-C' G f T= T (S-REFL) (S-TRANS) (S-SUP) \nG f C!=C(S-EXACT) G f T1= T3 G f C=C' G f T1= T2 (S-MASK) G f T\\S[] T (S-EMPTY-COND) G f T\\S[p.Sp] \n= T\\S[p.Sp, p ' .S'] (S-COND-SUB) G f T1\\M= T2\\M S= simple(M) subC = simple(M) p ' :C!\\M. G (S-SIMPLE) \n(S-EXACT-MASK) (S-EXACT-COND) G f T\\M= T\\S G f C!\\M C! G f T\\S[p.Sp, p ' .subC] T\\S[p.Sp] f C-C' fnames(ownFields(C)) \n= f subC' = simple(M) f C-C' fnames(ownFields(C)) = f (S-SUBMASK) (S-SUBMASK-COND) G f T\\M T\\expand(M, \n{ f, subC}) G f T\\M[p.subC' , p ' .S] T\\M[p. f, p.subC, p ' .S] G f p:T p:T . GG f f:T1 G f T1= T2 \nG f p:T\\ f[p. f, p ' .S] (TP-PATH) (TP-SUB) (TP-COND-CYCLE) G f p:T G f f:T2 G f p:T\\ f[p ' .S] . f, \np '' ' , p '' .S''] '\\S'[p ''' .S'''] G f p:T\\S[p ' .S'] G f p ' :Tf . masked(T') G f p:T\\S[p ' .S' \nG f p ' :T (TP-COND-ELIM) (TP-COND-TRANS) G f p:T\\S[p '' .S''] G f p:T\\S[p '' .S'' , p ''' .S'''] G fRe:T,G' \n G f x:T x:Tx . G G f f :T G f T= T' G' = G{ x:noMust(Tx)} f :Tf . G G f e1:T1,G1 G f e:T,G' G' f noMust(T) \n= T' G fR (T x):T' , G' (TR-VAR) G' = G{ f:noMust(Tf)} G fR (T f) :T' ,G' (TR-LOC) G1 fR e2:T2, G2 G \nfR e1; e2:T2, G2 (TR-SEQ) e = (T x) . e = e1; e2 G fR e:T,G' (TR-OTHER) G f e:T,G' G f e:T1,G' G f \ne1:T1,G1 G f T1= T2 G f p:T G1 f e2:T2,G2 f = fnames(.elds(C)) (T-SUB) (T-PATH) (T-SEQ) (T-NEW) G f \ne:T2,G' G f (Tp):T,GG f e1; e2:T2, G2 G f new C:C!\\ f!, G ' G fRe1:T,G1 x . dom(G1) G f (T1 p1) :T1,G \nT1= T1\\ f! G1,x:T f e2:T2,G2 G f e:T,G' G fR (T2 p2):ftype(grant(T1, f), f),G' ' G'' G2 = G2' ,x:T= \nremove(G2' ,x) Tf = ftype(T, f) p1:T . G' G'' = G'{ p1:grant(T, f)} 2 (T-LET) (T-GET) (T-SET) G f let \nTx = e1 in e2:T2,G'' G f e. f:Tf,G' G f (T1 p1). f =(T2 p2):.\\sub.,G'' 2 G f (T0 p0):T0, G T0 = U\\Mp0:U0\\M'. \nG ' ' mbody(T0,m)= Tn+1 m(Tx) effect M1 M2 {e} G f (T1\\ f! p1):T1\\ f!,GG f T0=U\\M1{p0/this}{p/x} '' \n' G f (T2 p2):T2,G T2 = U2\\M .i. 1..n+ 1. T= Ti {p0/this}{p/x} i '' ftype(T1, f)= Uf\\Sf G f U2=Uf .i. \n1..n. G f (Ti pi) :Ti ,G S= {S|S. simple(M) . (S!. M. S . Sf)}.i. 0..n. Ti = T'''\\S!. (T'' = T''''\\S!.. \nj= i. pi= pj) i p1:T\\ f!. GG' = G{ p1:T\\ f[p2.S]} G' = G{ p0:update(p0,M' ,U0\\M2{p0/this}{p/x})} (T-SET-COND) \n(T-CALL) ' G f (T1\\ f!p1). f =(T2 p2):.\\sub.,G' G f (T0 p0).m((Tp)):Tn+1,G' Figure 9. Static semantics \nclass Cextends C'{FMt} ownFields(C)= F ownMethods(C)= Mt [ .elds(C)= ownFields(C') C' : C-*C' [ methods(C)= \nownMethods(C') C' : C-*C' F= Uf fnames(F)= f Figure 8. Class member lookup  4.3 Subtyping Subtyping \nrules are de.ned in Figure 9. The judgment G f T1= T2 states that type T1 is a subtype of T2 in context \nG. The judgment G f T1 T2 is sugar for the pair of judgments G f T1= T2 and G f T2= T1. Most subtyping \nrules are intuitive. S-COND-SUB states that adding conditions makes a conditional mask more conservative. \nS-SIMPLEstates thatatype withamust-mask oraconditional mask is a subtype of the corresponding simply \nmasked type. The subtyping rule S-SUBMASK uses an auxiliary function expand, which expands a mask Sinto \na set of masks S', while pre\u00adserving anyannotation on S: expand(S, S')= S' expand(S!, S')= S'! expand(S[p.Sp], \nS')= S'[p.Sp] As shown in Figure 9, there are often a number of dif\u00adferent ways of writing equivalent \ntypes. The .ve type equiva\u00adlence rules (S-EMPTY-COND, S-EXACT-MASK, S-EXACT-COND, S-SUBMASK, and S-SUBMASK-COND)can \nbe read as normaliza\u00ad masked(U)= 0/ class(C)= C C= class(T) C= class(T) C-C' masked(T\\S!)= masked(T\\S) \nclass(C!)= C f . masked(T) Mt = ... m(...) ...  masked(T\\S[p.Sp]) = masked(T\\S) class(T\\M)= class(T) \n.elds(C)= F Mt. ownMethods(C). Fi = Tff Mt . ownMethods(C) . mbody(C' , m)= Mt masked(T\\ f)= { f}. masked(T) \nftype(T, f)= Tf mbody(T,m)= Mt masked(T\\subC)= masked(T) . . . noMust(U)= U ' Tif T = T'\\ f ' Tif T \n= T'\\ f[p.S] noMust(T)\\S if M= S! grant(T, f)= noMust(T\\M)= noMust(T)\\M otherwise . . ' Tif T = T'\\ \nf! T otherwise remove(0/,x)= 0/ update(x,M, T)= T remove((G, p:T),x)= remove(G,x), p:remove(T,x) update(f,M,U)= \nU remove(U,x)= U remove(T\\S[x.Sx,...],x)= remove(T, x)\\S update(f,M, T\\M')= . .. .. update(f,M,T)\\M' \nif Mi = simple(M')! update(f,M,T)\\Mi if simple(Mi)= simple(M') update(f,M,T) otherwise Figure 10. Auxiliary \nde.nitions tion rules, where the types on the left-hand side of are reduced to those on the right-hand \nside. Note that in each of the .ve rules, the type on the right-hand side is either syntactically simpler \nthan that on the left-hand side, or converts an occurrence of a class on the left-hand side to its subclass. \nThis ensures type normalization terminates. Normalized types have the following characteristics: A type \nC\\M has at most one subclass mask, which must be subC.Atype C!\\Mhas no subclass mask.  The condition \np.subC does not show up if the path p has an exact type.  Conditional masks have non-empty conditions. \n For convenience of presentation, from now on, types are as\u00adsumed to be in normal form, unless otherwise \nnoted.  4.4 Expression typing In theJ\\mask language, the evaluation of an expression might up\u00addate some \ntype bindings.Forexample, initializinga .eld removes the mask on that .eld, if there is one. Therefore, \ntyping judgments, shown in Figure 9, are of the form G f e:T,G', where G' is the typing environment after \nevaluating e.We write G{ p:T} for envi\u00adronment G with the type binding of pupdated to T. There are two \nother kinds of judgments in Figure 9. The judg\u00adment G f p:T types a path pwithout updating the typing \nenviron\u00adment. The subsumption rule TP-SUB is limited to locations l, not anyvariablesx,to ensure that \ntheexpression(Tx) has the most pre\u00adcise type annotation T (see T-PATH and TR-VAR). The judgment G fRe:T,G' \nis used in T-LET and T-SET for typing the right-hand side of assignment, and in M-OK for typing the return \nexpression (see Section 4.5). It avoids creating aliases for variables with type bindings that have must-masks. \nHowever, aliases are allowed if theyare createdwith conditionalmasks,asshowninT-SET-COND, where noTR-ruleis \nused. Figure 10 de.nes auxiliary functions used in the typing rules. Most of them are self-explanatory. \nThe function update, used in T-CALL, updates the type binding of the receiver according to the effect, \nand ensures monotonicity if the receiver is a location. J\\mask has several expression well-formedness \nrules, written f e wf, shown in Figure 11. The important rule is LET-WF, which imposes two requirements \non let expressions: Alet expression cannot end with a variable bound outside the scope of the let. For \nexample, one cannot write let Tx= e1 in (e2;y) where yis freein the let expression,but rather the equivalent \nexpression (let Tx = e1 in e2); y. This helps sim\u00adplify type-checking of right-hand sides of assignments(G \nfRe: T,G'),sothata separateTR-LET isnot necessary.  If thevariable xis boundtoalocation alreadyinthe \nscopeofthe let expression, the declared type of x cannot have any must\u00admask. This prevents x from being \nan alias with must-masks.  Theexpression well-formednessruleshelpsimplifytheproofof the substitution \nlemma (Lemma 4.5), without limiting the expres\u00adsiveness of the calculus. f e1 wf f e2 wf .x '. FV(let \nTx = e1 in e2). e2 = x '. e2 = e ' ; x ' ((e1 =(Tff) . e1 = e '' ; (Tff)) . f . locs(e2)) . T = T'\\S! \n (LET-WF) f let Tx = e1 in e2 wf f e1 wf f e2 wf f e wf (SEQ-WF) (GET-WF) f e1; e2 wf f e. f wf e= let \nTx = e1 in e2 e= e1; e2 e = e ' . f (OTHER-WF) f e wf Figure 11. Well-formed expressions 4.5 Program \ntyping Figure 12 shows the rules for checking the well-formedness of .eld and method declarations in \na class C. For a .eld declaration, the declared type may not use must\u00admasks or conditional masks. For \na method declaration, the special variablethis is assumed to havethe precondition masks M1 at the entry \npoint of the method, and it must be typable with the postcondition masks M2 when the method exits. Method \nparameters other than the receiver should remain typable with the same types at the entry. J\\mask permits \neffects on other parameters, but for simplicity, the calculus does not support this feature. M-OK also \nspeci.es some constraints on the method effect: it cannot introduce must-masks, which is only allowed \nwith the new expression; a mask in the precondition that is not a must-mask can only be replaced with \na corresponding mask that is more conservative. T = U\\S (F-OK) Cf Tf ok f e wf G = this :C\\M1, x:T G \nfRe:Tr,Gr Gr f this :C\\M2 Gr f x:T S!. M2 . S!. M1 M. M1. M'. M2. M= S! .f C\\M=C\\M' .simple(M)= simple(M') \n(M-OK) Cf Tr m(Tx) effect M1 M2 {e} ok Figure 12. Program typing 4.6 Decidability of type checking The \ntype systemofJ\\mask is decidable: For T-SUB and TP-SUB, we disallow the use of re.exivity of subtyping, \nand require all the rules about type equivalence( ) to be used in the direction of normalization (see \nSection 4.3).  The three rules TP-COND-CYCLE, TP-COND-ELIM, and TP-COND-TRANS actually characterize \na graph-theoretic reachability problem on the dependencygraph (such as in Fig\u00adure 4), which can be solved \nwith depth-.rst search.  All other rules are syntax-directed. Therefore, type checking is decidable \nforJ\\mask. 4.7 Operational semantics Figure 13 shows the judgments for the small-step operational se\u00ad \n' mantics ofJ\\mask, where e,H -. e , H' means that expression e '' and heap Hstep to expression e and \nheap H. Most of the rules in Figure 13 are standard, and the notable ones are those for .eld assignments \n(R-SET and R-SET-COND), which aresimilartothe correspondingexpressiontypingrules(T-SETand T-SET-COND). \nInthe operational semantics andin the soundness proof, typing environments are extracted from the heap, \nrepresented as lHJ: l0/J = 0/ lH,f . T { f = f}J = lHJ,f:T The notation H{ f := o} meansthatthevalue \nbindingof f in the heap His updated to another object o. Figure14showstheheaptyping rules.Aheap His well-formed, \nwritten f H, if every .eld that is not masked in its container s type is bound to a location, and that \nlocation can be given a type compatible with the declared type of the .eld. In H-LOC, H(f, f) refers \nto the value binding of the .eld f of the object stored in H(f). 4.8 Type safety The soundness theorem \nof the J\\mask calculus states that if an expression e is well-typed, and it can reduce to a value (Tff), \nthen (Tff) has the same type as e. A corollary of this theorem is that object initialization is sound \nin the sense used elsewhere in the paper: if a program tried to read an uninitialized .eld, the evaluationwouldget \nstuck accordingtoR-GET. THEOREM 4.1. (Soundness) If f e wf, and f e:T, ande,0/ .* (Tff),H, thenlHJf (Tff) \n:T. The proof uses the standard technique of proving subject reduc\u00adtion and progress [35]. LEMMA 4.2. \n(Subject reduction) If f e wf, and f H, andlHJf '' e:T,G, and e,H-. e , H', then f e wf, and f H', and \nlH'J f e ' : T, G', and G' is an extension of G. ' e, H-. e , H' e,H-. e ' ,H' (R-CONG) E[e],H-. E[e \n'], H' let Tx =(Tff) in e,H-. e{f/x}, H (R-LET) H(f)= T { f = f} Ti = ftype(T, fi) (R-GET) (Tff). fi,H-. \n(Ti fi),H H(f)= T { f = f} Tf = T'\\ f! H' = H{ f := grant(T, f) {..., f = f '}}} (R-SET) ' (Tff). f \n=(Tf '),H-. (.\\sub. f '),H' f H(f)= T\\ f!{ f = f} ftype(T, f)= Uf\\Sf S= {S|S. simple(M) . (S!. M. S. \nSf)} H' = H{ f := T\\ f[f ' .S] {..., f = f '}}} (R-SET-COND) (Tf\\ f!f). f =(U\\Mf '),H-. (.\\sub. f '),H' \nmbody(T0,m)= Tr m(Tx x) ... {e} (R-CALL) (T0 f0).m((T f)), H-. e{f0/this}{f/x},H f . dom(H) fnames(.elds(C)) \n= f H' = H,f . C!\\ f!{} (R-ALLOC) new C,H-. (C!\\ f!f), H' (T f); e,H-. e, H (R-SEQ) Figure 13. Small-step \noperational semantics f:C!\\M.lHJ f = fnames(.elds(C)) lHJf f:T f . masked(T) . . f . f. H(f, f)= f '. \nlHJf f ' :ftype(T, f) (H-LOC) Hf f .f . dom(H). Hf f (HEAP-WF) f H Figure 14. Well-formed heaps LEMMA \n4.3. (Progress) If f H, and lHJf e:T then either e= (Tff) or thereisanexpressione' anda heapH' suchthat \ne,H-. ' e ,H' . Progressisprovedbystructural inductionon e.Toprovesubject reduction, we need some preliminary \nlemmas. Lemma 4.4 characterizes extensions of typing environments.A typing environment G' is an extension \nof G if: For every type bindingx:T . G, there is x:T . G' ; '  For every type binding f :T . G, there \nis f :T. G' and G'f T'= T.  LEMMA 4.4. If G2 is an extension of G1, and G1 f e:T,G' 1, then G2 f e:T,G' \n2, and G' 2 is an extension of G' 1. PROOF: By induction on the derivation ofG1 f e:T,G' 1. D Lemma 4.5 \nshows that substituting a location for a variable preserves typing. It is used in the proof of Lemma \n4.2 for method calls and let expressions. Before stating the substitution lemma, we .rst de.ne substitution \nfor typing environments: An environment G' is the result of substituting a location f of type T for a \nvariable x in G, written G' = G{ f/x; f :T} , if G = G'' ,f :Tf,x:Tx, and G' = G''{f/x},f :T, and G'f \nf :Tf{f/x}, and G'f f:Tx{f/x}. LEMMA 4.5. If G = G' ,f:Tf,x:Tx,andG f e:T, Gr,andTf = T'\\S!, ' andTx \n= T'\\S! when f . locs(e), then G{ f/x; f :T} f e{f/x} : f '' '' T{f/x}, Gr{ f/x; f:T} for someTf . f \nPROOF: By induction on the derivation ofG f e:T,Gr. D With these lemmas, we prove subject reductionby \nan induction on the derivation of lHJf e:T,G. Then soundness (Theorem 4.1) follows directly. The proofs \nappear in the companion technical report [27]. 5. Implementation Wehave implementeda prototype compilerofJ\\mask \nas an exten\u00adsion in the Polyglot framework [26]. The extension code has about 3,700 lines of code, excluding \nblank lines and comments. J\\mask is implemented as a translation to Java. The translation is mostly by \nerasure, that is, by erasing all the masks, effects, and mask constraints from the code. The compiler \nalso applies several transformations to theJ\\mask source code, before erasing masks. Default effects \nare inserted for constructors and methods that do not have them already. To simplify type checking, initialization \ncode, including initializers, constructors, and new expressions, is also transformed. J\\mask requires \nthat in a conditionally masked type T\\ f[x.g], every xi, including this, is a .nal local variable. However, \nthe compiler uses a simple analysis to automatically insert the final modi.er for local variables that \nare assigned only once, and for formal parameters that are never reassigned. 5.1 Inserting default effects \nFor a constructor of classC, the default effect is *! -> C.sub!, which describes the behavior of most \nconstructors. The construc\u00adtor starts with all the .elds uninitialized, and it initializes all the .elds \ninherited from superclasses of C by calling the super constructor and the .elds declaredby C, leaving \nthe .elds in sub\u00adclasses of C uninitialized. The default effect for a virtual method is {} -> {} because \nvirtual methods normally work on fully initialized objects. In our experience with using J\\mask (see \nSection 6), these default effects work well. Programmers only have to annotate code that uses interesting \ninitialization patterns. 5.2 Transforming initialization code Java .eld declarations can include initialization \nexpressions that are implicitly called from constructors in the same order that they appear in the class \nbody. The J\\mask compiler collects all these initializers and inserts them directly in constructors, \nright after super constructor calls. This initializer code is type-checked in the same way as anyother \nconstructor code. Aconstructor inJ\\mask is just an initialization method that is calledafteranobjectis \nallocatedontheheap.TheJ\\mask compiler convertsevery constructorinthe sourcecodetoa.nal methodwith the \nsame name asthe class. The transformed constructor can then be type-checked just as anyother method. \nThe compiler also inserts an empty default constructor in the generated Java code. Every new expression \nnew C(...) is split into a call to the empty default constructor to allocate the memory on the heap, \nand then a call to the initialization method generated from the corresponding constructor,as shown in \nthe following piece of code: final C!\\(* -C.sub)! temp = new C(); temp.C(...); Then the fresh localvariable \ntemp replacesthe originalexpression. 5.3 Type checking FlowsensitivityintheJ\\mask type system shows \nup only on masks, and not on anyof the classes appearing in masked types. Therefore, each method is type-checked \nin two phases. The .rst phase is just normal Java type checking of the erased method code; the second \nphase, built upon the data.ow analysis framework provided in Polyglot, is .ow-sensitive, and uses the \nresult of the .rst phase as its starting point. Once type checking is complete, masks are erased to generate \nJava code. This works because resolution of method overloading does not depend on parameter masks. 5.4 \nInner classes A(nonstatic) inner class is a class that is nested in the body of an\u00adother class and contains \nan implicit reference to an instance (the outer instance)of the enclosing class. Every constructor of \nan in\u00adner class has an implicit formal parameter for the outer instance. J\\mask assumes that the type \nof the outer instance has no masks, that is, the outer instance has been fully initialized before an \nin\u00adstance of the inner class is created. If an inner class with a partially initialized outer instance \nis really needed, a transformation as de\u00adscribed in [15] can be applied to make the outer instance explicit. \nJ\\mask currently does not directly support local classes and anony\u00admous classes, which are inner classes \nnested in method bodies, al\u00adthough these could be converted to normal inner classes. 6. Experience The \nlanguage was evaluated by porting several classes in the Java Collection Framework (Java SDK version \n1.4.2) to J\\mask. The ported classes are ArrayList, HashMap, LinkedList, TreeMap, and Vector, together \nwith all the classes andinterfaces that they depend on. There are in total 29 source .les, comprising \n18,000 lines ofJ\\mask code (exclusive of empty lines and comments). Porting these classes toJ\\mask was \nnot dif.cult. It was com\u00adpletedbyoneofthe authors withinacoupleofdays, includingtime to debug the compiler. \nOnly 11 constructors and methods required annotation with effects or mask constraints, thanks to the \ndefault effects provided by the compiler (Section 5.1). Besides effects and mask constraints, only 11 \nother masked types were needed, a very small number compared to the size of the code. The port of this \ncode eliminated all nulls used as placeholders for initialization. However, some nulls were not removed: \n Java allows storing the null value into collections and maps.  Some method parameters and local variables \ncan be intention\u00adally set to null, indicating that theyare not available.  Among the classes we ported, \nthe following three exhibited nontrivial initialization patterns: 6.1 LinkedList The LinkedList class \nimplements a doubly-linked cyclic list. When an instance of LinkedList is constructed, a sentinel node, \nwhich is an instance of the nested class Entry, needs to be created with its previous and next .elds \nboth pointing to itself. The Java code .rst constructs an instance of Entry with its previous and next \n.elds set to null, and then initializes the two .elds with the header node itself. The following code \nis extracted from the constructor of LinkedList, where header is the .eld pointing to the sentinel node: \nheader = new Entry(null, null, null); header.previous = header.next = header; With masked types, the \ntwo .elds cannot be read before they are initialized. In the constructor of the ported LinkedList class, \nthe .eld header is initialized as follows: header = createHeader(); The method createHeader is shown \nbelow: private static Entry createHeader() { Entry\\(* -Entry.sub)! h = new Entry(); h.element = dummyElement; \nh.next = h; h.previous = h; return h; } The static .eld dummyElement points to an object of java.lang.Object \nbecause the header node does not store anyreal data element. Therefore, there is no need to use null. \n 6.2 HashMap The HashMap class has an empty method init, which, according to comments in the source code, \nis an initialization hook for subclasses . When a subclass of HashMap is created, it should override \nthe init method to initialize any new subclass .elds,but Javahasnowayto enforcethis.Witheffectsandmask \nconstraints, theJ\\mask version of HashMap can explicitly express the contract in the signature of the \nmethod init: void init() effect HashMap.sub -> {} captures * 6.3 TreeMap TreeMap implements a map as \na red-black tree where elements are sorted accordingtotheirkeys.Eachnodeinthetree contains .elds for \nthe left and right children, and a .eld pointing to its parent. A method buildFromSorted is used to build \nthe tree from the bottom up, similarly to the example shown in Figure 3. Masked types support sound initialization \nof TreeMap nodes without using null. 6.4 Summary Our experience is that J\\mask is expressive, since \nit was easy to port classes with the various initialization patterns found in the Java Collection Framework. \nThe explicit annotations in the ported code are infrequent and seem easy to understand, suggesting masked \ntypes are a natural way for programmers to enforce proper initialization of objects. 7. Related work \nNon-null types. The importance of distinguishing non-null ref\u00aderences from possibly-null references at \nthe type level has long been recognized. Manylanguages, including CLU [21], Theta [22], Moby [11], Eiffel \n[16], ML [24], and Haskell [17], support some form of non-null and possibly-null types in their type \nsystem. In the context of Java, several proposals [2, 19, 6] have been made to support non-null types. \nWith non-null types, sound object initialization is usually ac\u00adcomplished by severely restricting expressiveness. \nMost existing languages with non-null types restrict how objects can be initial\u00adized; for example, some \nrequire all (non-null) .elds to be initial\u00adized at once [11, 22]. This means .elds and methods of an \nobject under construction cannot be used. Further, cyclic data structures are impossible to initialize \nwithout using a placeholder value such as null. Masked types are different from non-null types: when \na .eld is masked, it is potentially uninitialized and unreadable, and therefore reading that .eld is \nstatically disallowed; with non-null types, a .eld is always accessible regardless of how it is declared. \nF\u00a8ahndrich and Leino [7] make use of raw types to represent ob\u00adjects that are in the middle of being \nconstructed, that is, objects with some non-null .elds containing nulls. Methods can be declared to expect \nrawobjects, and therefore can be called from within the con\u00adstructors. Delayed types [9], extended from \n[7], provide a solution to the problemof safely initializingcyclic data structures,by intro\u00adducing labels \non object types, which represent the timebywhich an object is fully initialized. Delay times are associated \nwith scopes, and form a stack at run time. Objects created with a delay time remain raw until execution \nexits the corresponding scope. Initial\u00adization of cyclic structures is supported by giving objects the \nsame delay, and theybecome initialized together at once. Compared to raw types, masked types provide \na .ner-grained representation of objects under construction. Conditional masks and delayed types are \nboth means to track dependencies between objects under construction. However, delay times are an indirect \nway to represent dependencies, whereas conditional masks capture dependencies directly and explicitly. \nMoreover, the fact that de\u00adlay times must form a stack restricts the expressiveness of delayed types \nin initializing cyclic structures. For example, trees where nodeshave parent pointers cannotbebuilt from \nthe bottomup with delayed types, because one cannot coordinate the delay times of child nodes. Masked \ntypes, on the other hand, easily support this pattern, as shown in Figure 3. Masked types also have richer \nsub\u00adtyping relationships, which can be used to enforce reinitialization. Typestates. In most object-oriented \nprogramming languages, an object has the same type for its entire lifetime. However, objects often evolve \nover time, that is, having different states at different times.Typestates [31] abstractly describe object \nstates, and when an object is updated, its typestate may also change. Typestates have been used to express \nand verify various proto\u00adcols[31,4,5,1,10].Typestateshavebeen interpretedas abstract states in .nite \nstate machines and as predicates over objects. Masked types are not intended for checking general protocols, \nbut rather just focus on safe object initialization. However, masks cannot be easily encoded in terms \nof previous typestate mecha\u00adnisms. Algebraic masks, for instance, provide compact representa\u00adtions of \npartial initialization states without requiring abstract states potentially exponential in the number \nof .elds. Conditional masks represent dependencies generated at use sites, rather than being .xed at \ndeclaration sites of predicates. Mask subtyping enriches the state space, and previous work on typestates \ndoes not appear to have anything like it. J\\mask uses subclass masks and mask constraints to ensure modular \ntype checking. These techniques are related to rest types\u00adtates and sliding methods in Fugue [5]. However, \nFugue requires that sliding methods are overridden in every subclass, whereas mask constraints in J\\mask \nforce methods to be overridden only when their watched abstract masks are overridden. Aliasing has always \nbeen a hard problem for any typestate mechanism: .rst, it is not easy to maintain correct typestate in\u00adformation \nin the presence of aliasing; second, although there are typing mechanismslike lineartypesthathelpkeeptrackof \naliases, they are inconvenient for ordinary programmers. Previous work on typestates has proposed various \ntreatments to the aliasing problem: Nil [31] completely rules out aliasing;Vault [4] and Fugue disal\u00adlow \nfurther state changes once an object becomes aliased unless the changes are temporary; Bierhoffand Aldrich \n[1] re.ne the two aliasing annotations not aliased and maybe aliased in Fugue to a richer setof permissions;F\u00a8 \nahndrich and Leino [8] also identify a kind of typestates that are heap-monotonic and work without alias\u00ading \ninformation; Fink et al. [10] conduct whole-program veri.ca\u00adtion and rely on a global alias analysis. \nThe treatment of the alias\u00ading problem inJ\\mask is inspired by [8]: simple masks and con\u00additional masks \nare heap-monotonic, and must-masks, though not heap-monotonic, are associated with newly created objects \nwhose aliasing informationis easyto track.We believeJ\\mask achieves a good trade-offbetween expressiveness \nand simplicity for the alias\u00ading problem in the context of object initialization. Masked types are reminiscent \nof type-based access control mechanisms that statically restrict access to individual .elds or methods, \ne.g., [18, 28]. However, maskedtypes are very different; they are designed for reasoning about initialization, \nand access is granted by the act of assignment to the resource, which makes little sense as an access \ncontrol feature. Static analysis. J\\mask, similar to other typestate mechanisms, hasa.ow-sensitivetype \nsystem, which canbeviewedasadata.ow analysis. An alternative to masked types is an interprocedural def\u00aduse \nanalysis,butthiswouldlosemanyoftheadvantagesofmasked types. Java already has an intraprocedural analysis \n[32] to ensure that every local variable is de.nitely assigned before it is used. However, Java cannot \nsafely prevent reading from uninitialized .elds. There has been work on interprocedural def-use analysis \nin the context of object-oriented languages [30, 29], with varying cost and precision. This prior work \ndetects initializationbugs on .elds,but requires non-modular whole-program def-use analyses and is subject \nto the typically limited accuracyof whole-program alias/points-to analyses. By contrast, type checking \nin J\\mask is modular and therefore scalable. Masked types bring another bene.t because theyspecify the \ninitialization contracts of methods, help\u00ading programmers reason about the code. Explicitly capturing \nthis aspect of programmer intent seems valuable. FindBugs [13] contains an analysis [14] that is designed \nspecif\u00adicallyto detect null-pointerbugs.The analysisis neither sound nor complete,but focusesonimproving \naccuracy.The basic analysisis interprocedural,butextensions are proposedin which non-null an\u00adnotations \nare inserted into method signatures to represent contracts. Shape analyses are aimed at extracting heap \ninvariants that de\u00adscribe the shape of recursive data structures [34]. Conditional masks capture some \npart of the shape information of the data struc\u00adture under construction. However, conditional masks are \nnot con\u00adcerned with initialized .elds, and also are more about dependencies than the shape of references, \nand therefore have transitivity and cycle cancellation. Shape analyses are normally built upon alias \nanalyses, and contain explicit representation of heap locations, nei\u00adtherof whichis presentintheJ\\mask \nlanguage.J\\mask only tracks mask changes on local variables, which gives it a .avor of local reasoning \nsomewhat similar to the analysis in [3]. Becausetheysummarizeasetof concrete .elds, abstract masks have \nsome similarity to data groups [20], a mechanism used for modular program veri.cation. Data groups do \nnot have the equiva\u00adlent of mask algebra. Moreover, masked types are about more than just abstracting \n.elds; must-masks and conditional masks are new mechanisms that enable sound initialization of complicated \ndata structures. Other kinds of languages. The initialization problem is not unique to object-oriented \nlanguages. In a purely functional pro\u00adgramming style,values are constructedallat once,avoidingthe cre\u00adation \nof partially initialized values. However, functional languages typicallydonoteasily supportthe constructionofcyclicdata \nstruc\u00adtures well, though it can be achieved in some cases with value re\u00adcursion [33]. The typed assembly \nlanguage in [25] supports initial\u00adization.agsthatare similartothesimplemasksinJ\\mask. 8. Conclusions \nand future work This paper introduces masked types, implemented in the language J\\mask,asasolutiontotheproblemofobject \ninitialization.Masked types provide a strong safety guarantee for initialization: unini\u00adtialized .elds \nare never read. Further, masked types are expres\u00adsive enough to support many useful initialization idioms, \ninclud\u00ading objects with cyclic references. Methods and constructors in the J\\mask languages explicitly \nexpress their initialization contracts through effects, which enable modular type checking, rather than \nrequiring an expensive whole-program analysis. Because default annotations are very effective, and J\\mask \nrequires little reason\u00ading about aliasing,J\\mask hasalow annotationburden. This could make the language \nmore accessible to average programmers. Fi\u00adnally,byplacing object initialization onasound footing, we \nbelieve masked types can also enable other language mechanisms. Acknowledgments We would like to thank \nSigmund Cherem, Steve Chong, Michael Clarkson, Jed Liu, and RuijieWang for helpful feedback on early \ndrafts of this paper, and Doug Lea,Wojciech Moczydlowski, and Nate Nystrom for discussions. Thanks also \nto Jonathan Aldrich and the POPL reviewers for useful comments and suggestions. This work was supported \nby National Science Foundation grants 0430161, 0627649, and CCF-0424422 (TRUST), and by the AirForce \nResearch Laboratory, under contract#FA8750-08-2\u00ad0079. The views and conclusions contained herein are \nthose of the authors and should not be interpreted as necessarily representing the of.cial policies or \nendorsements, either express or implied, of these organizations or the U.S. Government. The U.S. Government \nis authorized to reproduce and distribute reprints for Governmental purposes notwithstanding anycopyright \nnotation thereon. References [1] Kevin Bierhoffand Jonathan Aldrich. Modular typestate checking of aliased \nobjects. In Proc. 22ndACM Conference on Object-Oriented Programming Systems, Languages and Applications \n(OOPSLA), pages 301 320, October 2007. [2] Patrice Chalin and Perry James. Non-null references by default \nin Java: Alleviating the nullity annotationburden. In Proceedings of the 21st European Conference on \nObject-Oriented Programming, 2007. [3] Sigmund Cherem and Radu Rugina. Maintaining doubly-linked list \ninvariants in shape analysis with local reasoning. In Veri.cation, Model Checking, and Abstract Interpretation, \n8th International Conference (VMCAI 2007), Nice, France, January 2007. [4] Robert DeLine and ManuelF\u00a8ahndrich. \nEnforcing high-level protocols in low-level software. In Proc. SIGPLAN 2001 Conference on Programming \nLanguage Design and Implementation, pages 59 69, June 2001. [5] Robert DeLine and Manuel F\u00a8ahndrich. \nTypestates for objects. In Proceedings of 18th European Conference on Object-Oriented Programming (ECOOP \n04), 2004. [6]Torbj\u00a8Ekman andG \u00a8Pluggable checking and orn orel Hedin. inferencing of non-null types \nfor java. Journalof ObjectTechnology, 6(9):455 475, October 2007. [7] ManuelF\u00a8ahndrichandK. RustanM. \nLeino. Declaringand checking non-null types in an object-oriented language. In Proc. 2003ACM Conference \non Object-Oriented Programming Systems, Languages, and Applications (OOSPLA), pages 302 312, October \n2003. [8] ManuelF\u00a8ahndrich and K. Rustan M. Leino. Heap monotonic typestate. In Proceedings of the .rst \nInternational Workshop on Alias Con.nement and Ownership(IWACO), July 2003. [9] ManuelF\u00a8ahndrich and \nSongtao Xia. Establishing object invariants with delayed types. In Proc. 22nd ACM Conference on Object-Oriented \nProgramming Systems, Languages and Applications (OOPSLA), October 2007. [10] StephenFink,EranYahav,NuritDor,G. \nRamalingam,and Emmanuel Geay. Effective typestate veri.cation in the presence of aliasing. In ISSTA 06: \nProceedings of the 2006 international symposium on Software testing and analysis, pages 133 144, 2006. \n[11] Kathleen Fischer and John Reppy. The design of a class mechanism for Moby. In Proc. SIGPLAN 1999 \nConference on Programming Language Design and Implementation, pages 37 49, 1999. [12] James Gosling, \nBill Joy, Guy Steele, and Gilad Bracha. TheJava Language Speci.cation. AddisonWesley, 3rd edition, 2005. \nISBN 0321246780. [13] David Hovemeyer and William Pugh. Finding bugs is easy. In OOPSLA 04: Companion \nto the 19th annual ACM SIGPLAN conference on Object-oriented programming systems, languages, and applications, \npages 132 136, 2004. [14] David Hovemeyer, Jaime Spacco, and William Pugh. Evaluating and tuning a static \nanalysis to .nd null pointer bugs. In PASTE 05: Proceedings of the 6thACM SIGPLAN-SIGSOFT workshop on \nProgram analysis for software tools and engineering, pages 13 19, 2005. [15] Atsushi Igarashi and Benjamin \nC. Pierce. On inner classes. In Informal Proceedings of the Seventh International Workshop on Foundations \nof Object-Oriented Languages (FOOL 7), Boston, MA, January 2000. [16] ECMA International. Eiffel analysis, \ndesign and programming language. ECMA Standard 367, June 2005. [17] Haskell 98:Anon-strict, purely functionallanguage, \nFebruary 1999. Available athttp://www.haskell.org/onlinereport/. [18] Anita K. Jones and Barbara Liskov. \nA language extension for expressing constraints on data access. Comm.of theACM,21(5):358 367, May 1978. \n[19] JSR 308: Annotations on Java Types. Available at http://groups.csail.mit.edu/pag/jsr308/. [20] K. \nRustan M. Leino. Data groups: specifying the modi.cation of extended state. In Proc. 13thACM Conference \non Object-Oriented Programming Systems, Languages and Applications (OOPSLA), pages 144 153, 1998. [21] \nB. Liskov and J. Guttag. Data abstraction. In Abstraction and Speci.cationin ProgramDevelopment, chapter \n4, pages 56 98. MIT Press and McGraw Hill, 1986. [22] Barbara Liskov,DorothyCurtis, Mark Day,Sanjay Ghemawat, \nRobert Gruber,Paul Johnson, and AndrewC. Myers. Theta Reference Man\u00adual. Programming Methodology Group \nMemo 88, MIT Laboratory for Computer Science, Cambridge, MA, February 1994. Available at http://www.pmg.lcs.mit.edu/papers/thetaref/. \n[23] J. M. Lucassen and D. K. Gifford. Polymorphic effect systems. In Proc. 15thACM Symp. on Principles \nof Programming Languages (POPL), pages 47 57, 1988. [24] Robin Milner, MadsTofte, and Robert Harper. \nThe De.nition of StandardML. MIT Press, Cambridge, MA, 1990. [25] Greg Morrisett, DavidWalker, Karl Crary, \nand Neal Glew. From System F to typed assembly language. ACM Transactions on Programming Languages and \nSystems, 21(3):528 569, May 1999. [26] Nathaniel Nystrom, Michael R. Clarkson, and Andrew C. Myers. Polyglot: \nAn extensible compiler framework for Java. In Proc. 12th International Compiler Construction Conference \n(CC 03), pages 138 152, April 2003. LNCS 2622. [27] Xin Qi and Andrew C. Myers. Masked types. Technical \nreport, Computer and Information Science, Cornell University, October 2008. http://hdl.handle.net/1813/11563. \n[28] Joel Richardson, Peter Schwarz, and Luis-Felipe Cabrera. CACL: Ef.cient .ne-grained protection for \nobjects. In Proc. 1992 ACM Conference on Object-Oriented Programming Systems, Languages, and Applications, \npages 154 165,Vancouver, BC, Canada, October 1992. [29] Amie L. Souter and Lori L. Pollock. The construction \nof contextual def-use associations for object-oriented systems. IEEETrans. Softw. Eng., 29(11):1005 1018, \n2003. [30] Amie L. Souter, Lori L. Pollock, and Dixie Hisley. Inter-class def-use analysis with partial \nclass representations. In PASTE 99: Proceedings ofthe1999ACM SIGPLAN-SIGSOFT workshoponProgram analysis \nfor software tools and engineering, pages 47 56, 1999. [31] RobertE. Strom and ShaulaYemini.Typestate:Aprogramming \nlan\u00adguage concept for enhancing software reliability. IEEETransactions on Software Engineering (TSE), \n12(1):157 171, January 1986. [32] Sun Microsystems. Java LanguageSpeci.cation,version 1.0 beta edi\u00adtion, \nOctober 1995.Availableat ftp://ftp.javasoft.com/docs/ javaspec.ps.zip. [33] Don Syme. Initializing mutually \nreferential abstract objects: The value recursion challenge. Electronic Notes in Theoretical Computer \nScience, 148(2):3 25, 2006. [34] ReinhardWilhelm, Shmuel Sagiv, and ThomasW. Reps. Shape anal\u00adysis. In \nProc. 9th International Compiler Construction Conference (CC 00), pages 1 17, 2000. [35] Andrew K. Wright \nand Matthias Felleisen. Asyntactic approach to type soundness. Information and Computation, 115(1):38 \n94, 1994.    \n\t\t\t", "proc_id": "1480881", "abstract": "<p>This paper presents a type-based solution to the long-standing problem of object initialization. Constructors, the conventional mechanism for object initialization, have semantics that are surprising to programmers and that lead to bugs. They also contribute to the problem of null-pointer exceptions, which make software less reliable. Masked types are a new type-state mechanism that explicitly tracks the initialization state of objects and prevents reading from uninitialized fields. In the resulting language, constructors are ordinary methods that operate on uninitialized objects, and no special default value (null) is needed in the language. Initialization of cyclic data structures is achieved with the use of conditionally masked types. Masked types are modular and compatible with data abstraction. The type system is presented in a simplified object calculus and is proved to soundly prevent reading from uninitialized fields. Masked types have been implemented as an extension to Java, in which compilation simply erases extra type information. Experience using the extended language suggests that masked types work well on real code.</p>", "authors": [{"name": "Xin Qi", "author_profile_id": "81322503996", "affiliation": "Cornell University, Ithaca, NY, USA", "person_id": "P1300928", "email_address": "", "orcid_id": ""}, {"name": "Andrew C. Myers", "author_profile_id": "81100011022", "affiliation": "Cornell University, Ithaca, NY, USA", "person_id": "P1300929", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1480881.1480890", "year": "2009", "article_id": "1480890", "conference": "POPL", "title": "Masked types for sound object initialization", "url": "http://dl.acm.org/citation.cfm?id=1480890"}