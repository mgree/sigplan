{"article_publication_date": "01-21-2009", "fulltext": "\n AutomatedVeri.cationof Practical Garbage Collectors Chris Hawblitzel Microsoft Research One MicrosoftWay \nRedmond,WA98052 USA Chris.Hawblitzel@microsoft.com Abstract Garbage collectors are notoriously hard \nto verify, due to their low\u00adlevel interaction with the underlying system and the general dif\u00ad.culty in \nreasoning about reachability in graphs. Several papers have presentedveri.ed collectors,but either the \nproofs were hand\u00adwritten or the collectors were too simplistic to use on practical applications. In this \nwork, we present two mechanically veri.ed garbage collectors, both practical enough to use for real-world \nC# benchmarks. The collectors and their associated allocators consist of x86 assembly language instructions \nand macro instructions, an\u00adnotated with preconditions, postconditions, invariants, and asser\u00adtions.We \nused the Boogieveri.cation generator and theZ3 auto\u00admated theorem prover to verify this assembly language \ncode me\u00adchanically.We provide measurements comparing the performance of the veri.ed collector with that \nof the standard Bartok collectors on off-the-shelf C# benchmarks, demonstratingtheir competitive\u00adness. \nCategories and Subject Descriptors D.2.4[Software Engineer\u00ading]: Software/ProgramVeri.cation GeneralTerms \nVeri.cation 1. Introduction Garbage collectors automatically reclaim dynamically allocated objects that \nwill never be accessed again by the program. Garbage collectionis widely acknowledgedfor supportingfastdevelopment \nof reliable and secure software. It has been incorporated into mod\u00adern languages, such as Java and C#. \nMany recent projects have at\u00adtemptedtoverifythe safetyor correctnessofgarbage collectors. Thegoalofthisveri.cationisto \nreducethe trusted computingbase of a system and increase the system s reliability. This is particu\u00adlarly \nimportant for secure systems based on proof-carrying code (PCC) [23] or typed assembly language (TAL) \n[22]; typical large\u00adscale PCC/TAL systems can verify the safety of the mutator (the program),butnotofthe \nrun-timesystemthat manages memoryand * Part of this work was done while the author was on a sabbatical \nleave at Microsoft Research. Supported by THE ISRAEL SCIENCE FOUNDA-TION (grant No. 845/06). Permission \nto make digital or hard copies of all or part of this work for personal or classroom use is granted without \nfee provided that copies are not made or distributed for pro.t or commercial advantage and that copies \nbear this notice and the full citation on the .rst page.To copyotherwise, to republish, to post on servers \nor to redistribute to lists, requires prior speci.c permission and/or a fee. POPL 09, January 18 24, \n2009, Savannah, Georgia, USA. Copyright c &#38;#169; 2009ACM 978-1-60558-379-2/09/01... $5.00 * Erez \nPetrank Dept of Computer Science Technion Haifa 32000 Israel erez@cs.technion.ac.il other resource \non the mutator sbehalf. This prevents untrusted pro\u00adgramsfrom customizingthe run-time system. Furthermore,bugsin \nthe unveri.ed run-time systems could result in security vulnerabil\u00adities that undermine the guarantees \npromisedby PCC andTAL. Proving thatgarbage collectors are safe and correct has beena challenge. In this \nwork, we provide the .rst fully mechanized cor\u00adrectnessproofsofgarbage collectorsand allocators realisticenough \nto run large, off-the-shelf benchmarks. To make this veri.cation tractable, we exploit recent advances \nin automated theorem prov\u00ading technology, using the Boogie [3] and Z3 [8] tools to provide automated \nveri.cation of the correctness properties. Ourkey con\u00adtributionis theexpressionofgarbage collector speci.cations \nand invariants in a style that allows ef.cient, automated veri.cation. We verify two collectors, both \npractical enough for use with real-world C# benchmarks: a Cheney copying collector [20, 7], with a bump \nallocator; and a mark-sweep collector [18], with a local-cache allocator that allowsfastbump-pointer \nallocation. Both are simple enoughtoverify,yetef.cient enoughto support realistic benchmarks competitively. \nThe collectors and their associated al\u00adlocators consist of x86 assembly language instructions and macro \ninstructions, annotated with preconditions, postconditions, invari\u00adants, and assertions. These annotations \nrequire signi.cant human effort to write,but once they are written, the Boogie veri.cation condition \ngeneratorandtheZ3 theoremproververifythe annotated collectors automatically, with no further human intervention. \nThe collectors and allocators are entirely self-contained, relying on no unveri.edlibrarycode,andtheveri.cationreliesononlyaminimal \nset of trusted axioms and de.nitions describing 32-bit arithmetic, x86 instructions, memory words, and \nthe interface to the mutator. We show how to de.ne higher-level abstractions, particularly abstractions \ndrawn from region-based type systems, in terms of these trusted axioms and de.nitions; these higher-level \nabstractions provide forms of local reasoning that make automated veri.cation tractable. Theveri.cation \nensures thatif an allocation orgarbage collection operation completes, then thephysical heap managedby \nthe allocator and collectorfaithfully represents the abstract graph of objects de.nedby the mutator. \nTheveri.cation also ensures that thegarbage collector deallocates all objects unreached during the collection. \nTheveri.cation does not provetermination;veri.ed col\u00adlectors or allocators couldfail to terminate because \nof an in.nite loop,orfailto terminateproperly becauseofa 32-bit integerover\u00ad.ow exception, or an explicit \nhalt operation. (The allocators and collectors halt if theyrun out of memory, or if the mutator relies \non a feature not supportedby our collectors, suchas multithreading.) The collectors and allocators include \nsupport for objects, ar\u00adrays, strings, header words, interior pointers, static data scanning, stack scanning, \nobject descriptors, stack frame descriptors, return\u00adaddress lookup tables, and bit-level data manipulation, \nmaking them realistic enough to support off-the-shelf single-threaded C# benchmarks compiled with the \nBartok compiler, using the native Bartok memory layouts and descriptor formats.To assess the ef.\u00adcacyof \nthe proposed collectors, we ran the veri.ed collectors with the Bartok runtime and compared their performance \nwith the stan\u00addard Bartok mark-sweep and generational copying collectors. The veri.ed collectors demonstrated \ncompetitiveperformance. The contributions in this paper include: 1. We provide the .rst mechanically \nveri.ed garbage collectors that support a real-world object model, including vtables, ar\u00adrays, object \ndescriptors, stacks, etc. 2. We provide the .rst mechanically veri.ed garbage collectors that can link \nto code generated by a real-world, optimizing compiler (Bartok). 3. Wedemonstrate howto apply automated \nveri.cation togarbage collectors, including both copying and mark-sweep garbage collectors. This automation \nallows scaling the veri.cation to realistic collectors without employing a huge human effort. 4. We \npropose a simple, ef.cient, easy-to-verify mark-sweep col\u00adlector and allocator based on local caches. \n 5. Weprovide the .rst performance measurements of off-the-shelf C# benchmarks runningontopofveri.edgarbage \ncollectors.  Outline. Section2discusses previouswork ongarbagecollector veri.cation. Section3describes \nBoogie and Z3. Section4presents a complete example mark-sweep collector and allocator in the BoogiePL \nprogramming language [3], describing the speci.cation and invariants in detail. Section5generalizes Section \n4 s ideas to cover copying collectors, borrowing ideas from region-based type systems. Section 6 presents \ntwo simple, yet practical, collectors (and their allocators): a Cheney-queue copying collector and an \niterative mark-sweep collector. Section7 shows that the practical collectors perform reasonably well \ncompared to Bartok s native collectors on a range of off-the-shelf C# benchmarks. Section 8 concludes. \nCode availability. Thegarbage collectors were coded in an x86\u00adlike subset of the BoogiePL language; a \nsmall tool automatically extracted the x86 instructions, which were assembled and linked with the benchmarks \n(see Section 6.3). The complete BoogiePL codeforthetwopractical collectorsisavailableaspartofthe public \nMicrosoft Research Singularity RDK2 source (in Source Code , in the base/Imported/Bartok/runtime/veri.ed/GCs \ndirectory, which can be browsed without downloading all of Singularity) at: http://www.codeplex.com/singularity \nThe Boogie and Z3 tools (April 2008 release), used to verify the two collectors, are available from: \nhttp://research.microsoft.com/specsharp/ 2. Background and related work Hand-written proofs ofgarbage \ncollector correctness, at least for abstract models of garbage collectors, go back decades (e.g., [9, \n10, 4, 17]). The work of Birkedal et al[4] is noteworthy for for\u00admally proving a Cheney copying collector \ncorrect, rather than a mark-sweep collector, and emphasizing local reasoning based on separation logic. \nNevertheless, the local reasoning is used mainly to separatepiecesoftheinvariantata coarse granularity(e.g. \nseparat\u00ading invariants about forwarded objects from unforwarded objects); we offer a different perspective \non local reasoning in section 5. Other work [25, 13, 14, 15, 12] has mechanically proven garbage collector \ncorrectness,but only for mark-sweep collectors, and only using abstract models of memory (for instance, \nrepre\u00adsenting the heap as just a mathematical graph and the root set as just a mathematical set), and \nonly using abstract models of pro\u00adgrams rather than programs executable on real hardware. These papers \nused interactive theorem provers, with the exception of Russinoff[25], and even this paper required over \n100 explicitly user-declared lemmas (each of which was automatically proved). More recently, McCreight \net al [19] used an interactive theorem prover to verify the correctness of both mark-sweep and copying \ncollectors written in a RISC-like assembly language, with a more realistic memory model. This required \nan enormous effort though, relying on over 10000 lines of Coq scripts per collector, and the treatment \nof the memory stillfalls short of what realistic compil\u00aders expect: the collectors assume that every \nobject has exactly two .elds, and there is no stack, no static data area, no object and stack frame descriptors, \nand so on.We adopt McCreight et al s de.nition of correctness as a starting point for our work. Several \npapers [27, 21] use typed regions to implement type\u00adsafe copyinggarbage collectors; thesegarbage collectors \ncopylive data from an old region to a new region, and then (safely) delete the old region.Type safetyisa \nweaker property than correctness, though,andthese techniquesdon tobviouslyextendto mark-sweep collection.We \nborrow ideas from typed regions to help usverify our copying collector. Vechev et al. [26] describe how \nto mechanically .t prefabri\u00adcated, high-levelgarbage collectionbuilding blocks togetherina provably correctway,buttheydonot \nmechanicallyverifythebuild\u00ading blocks themselves. 3. Boogie and Z3 BoogiePL is a simple imperative programming \nlanguage designed to support automated program veri.cation. It includes pure (side\u00adeffectfree)expressions, \nwritteninastandard C/C#/Javasyntax,im\u00adperative statements (which may update local variables and global \nvariables), pure functions, and imperative procedures. Procedures support preconditions and postconditions, \nwritten with the key\u00adwords requires and ensures, that specify what must be true upon entry to the procedure \nand what the procedure guarantees is trueuponexitfromthe procedure.Withina procedure,loopinvari\u00adants \nfor while loops are written with the invariant keyword. The following example shows a pure function Pos, \nwhich returns true if its argument is positive, and a procedure IncreaseX that adds a positive number \ny to a global variable x: function{:expand true} Pos(i:int)returns(bool){i>0} var x:int; procedure IncreaseX(y:int) \n requires Pos(y); modifies x; ensures x > old(x); { x :=x+y; } In this example, the expression old(x) \nrefers to the value of x at the beginning of the procedure s execution, so that the post\u00adcondition ensures \nx > old(x); says that x will have a larger value upon exit from the procedure than upon entry to the \nprocedure. A procedure must disclose all the global vari\u00adables it modi.es (just x in this example); this \nallows callers of the procedure to know which variables remain unmodi.ed by the procedure. The expand \ntrue annotation turns a function de.\u00adnition into a macro that is expanded to its de.nition whenever it \nis used, so that requires Pos(y); is just an abbreviation for requires y > 0; . (Recursive or mutually \nrecursive macro de.ntions are disallowed.) Our programs occasionally use the statement assert P; , which \naskstheveri.ertoprove P,whichisthenusedasalemmafor subsequent proving. (We do not use the statement assume \nP; , which introduces a new lemma P without proof, since this would make our veri.cation unsound.) The \nBoogie tool generatesveri.cation conditions from the Boo\u00adgiePL code. Theseveri.cation conditions are \nlogical formulas that, ifvalid, guarantee that each procedure call satis.es the procedure s precondition, \neach procedure guarantees its postcondition, and each loop invariant holds on entry to the loop and is \nmaintained by each loop iteration. Boogie passes theseveri.cation conditions to an au\u00adtomated theorem \nprover, which attempts to prove the validity of theveri.cation conditions.We usetheZ3 theoremprover, \nwhichis ef.cient, scales to large formulas, and reasons about manyuseful .rst-order logic theories, including \nintegers, bitvectors, arrays, and uninterpreted functions. BoogiePL s data types are more purely mathematical \nthan the data types in conventional programming languages. The type int represents mathematical integers, \nranging from negative in.nity to positive in.nity, while bv32 represents 32-bit values. The theorem prover \nsupport for int is more mature and ef.cient than for bv32, so we used int wherever possible (section \n6 describes how we reconciled this approach with the x86 s native 32-bit words). BoogiePL also supports \narray types [int]t for any element type t,de.ning arrays as simple mappings from mathematical inte\u00adgers \nto elements. The BoogiePL select expression a[i] retrieves element i from array a, where i can be anyinteger. \nThe BoogiePL update expression a[i := v] generates a new array, equal to a except at element i, where \nthe new array contains the value v, so that (a[i := v])[i] == v is true for any a, i, and v. For convenience, \nthe statement a[i] := v; is an abbreviation for a := (a[i := v]); . Arrays can also be multidimensional: \nan array a of type [int,int]t supportsaselectexpression a[i1,i2] and an update expression a[i1,i2 := \nv]. Note that BoogiePL arrays lack manypropertiesof say,Java arrays.Forexample, Boo\u00adgiePL arrays are \nnot references, so there s no issue of aliasing: the statement a := b; assigns a copyof array b to variable \na. Due to formatting constraints, the BoogiePLcode shown in this paper omits most type annotations.We \nabbreviate a<=b &#38;&#38; b<c as a<=b<c, and function{:expand true} as fun. The notation .T is an abbreviation \nfor the universal quanti.er . with a particular trigger T , used as a hint to Z3, as described further \nin Section 4.3.For now, the reader may ignore the T . 4. Aminiature collector in BoogiePL This section \npresents a miniature allocator and mark-sweep col\u00adlector written in the BoogiePL programming language, \nintroducing some of the invariants used by the more realistic collectors in sub\u00adsequent sections. The \nallocator and collector are implemented as a single BoogiePL .le, shown in its entirety in Figures 1-5. \nWhen run on thisexamplegarbage collector, Boogieveri.es all7proce\u00addures in the collector in less than2seconds; \nsince Boogie and Z3 process BoogiePL .les entirely automatically, no human assistance or proof scripts \nare required. The miniature collector assumes that every object has exactly two .elds, numbered 0 and \n1, and each .eld holds a non-null pointer to some object. The collector manages memory addresses in the \nrange memLo...memHi -1,wherememLo and memHi are con\u00adstants such that 0 < memLo <= memHi -1,but whose \nvalues are otherwise unspeci.ed (see Figure 1). Memory is object addressed, rather than byte addressed \norword addressed, so that each memory location in the range memLo...memHi -1 contains either an entire \nobject, or free space big enough to allocate an object in. The vari\u00adable Mem, of type [int,int]int, represents \nall of memory; for each address i in the range memLo...memHi -1 and .eld field in the range 0...1, the \nvalue Mem[i,field] holds the contents of the .eld field in the object at address i. function{:expand \nfalse} T(i) { true } const NO_ABS:int, memLo:int, memHi:int; axiom 0 < memLo <= memHi; fun memAddr(i) \n{ memLo <= i < memHi } fun Unalloc(i) { i == 0 } fun White(i) { i == 1 } fun Gray(i) { i==2 } fun Black(i) \n{ i == 3 } var Mem:[int,int]int, Color:[int]int; var $toAbs:[int]int, $AbsMem:[int,int]int; fun WellFormed($toAbs) \n{ (.Ti1..Ti2. memAddr(i1) &#38;&#38; memAddr(i2) &#38;&#38; $toAbs[i1] != NO_ABS &#38;&#38; $toAbs[i2] \n!= NO_ABS &#38;&#38; i1!=i2  ==> $toAbs[i1] != $toAbs[i2]) } fun Pointer($toAbs, ptr, $abs) { memAddr(ptr) \n&#38;&#38; $abs != NO_ABS &#38;&#38; $toAbs[ptr] == $abs } fun ObjInv(i, $toAbs, $AbsMem, Mem) { $toAbs[i] \n!= NO_ABS ==> Pointer($toAbs, Mem[i,0], $AbsMem[$toAbs[i],0]) &#38;&#38; Pointer($toAbs, Mem[i,1], $AbsMem[$toAbs[i],1]) \n} fun GcInv(Color, $toAbs, $AbsMem, Mem) { WellFormed($toAbs) &#38;&#38; (.Ti. memAddr(i) ==> ObjInv(i, \n$toAbs, $AbsMem, Mem) &#38;&#38; 0 <= Color[i] < 4 &#38;&#38; (Black(Color[i]) ==> !White(Color[Mem[i,0]]) \n&#38;&#38; !White(Color[Mem[i,1]])) &#38;&#38; ($toAbs[i] == NO_ABS <==> Unalloc(Color[i]))) } fun MutatorInv(Color, \n$toAbs, $AbsMem, Mem) { WellFormed($toAbs) &#38;&#38; (.Ti. memAddr(i) ==> ObjInv(i, $toAbs, $AbsMem, \nMem) &#38;&#38; 0 <= Color[i] < 2 &#38;&#38; ($toAbs[i] == NO_ABS <==> Unalloc(Color[i]))) } Figure \n1. Miniature Collector: De.nitions. The allocator and collector use a variable Color to repre\u00adsent the \nstate of memory at each address. If Color[i] is 0, the memory at address i is free. Otherwise, the memory \nis occupied by anobject andis either colored white(Color[i] == 1), gray (Color[i] == 2), or black(Color[i] \n== 3). 4.1 Concrete and abstract states Toverifyagarbage collector,we must specify whatit means fora \ncollectortobe correct.Forthe mark-sweep collector,the mostobvi\u00adous criterion is that it frees all objects \nunreachable from the root and leaves all reachable objects unmodi.ed. However, this de.nition of correctness \nis speci.c to one particular class of collectors; it doesn t account for collectors that move objects, \nand doesn t account for mutator-collector interaction, such as write barriers andread barri\u00aders.We dlike \none de.nitionof correctness that encompasses many classes of collectors, so we follow a more general \napproach advo\u00adcated by McCreight et al [19]. In this approach, the mutator de\u00ad Figure 2. Concrete and \nabstract graphs procedure Initialize() modifies $toAbs, Color; ensures MutatorInv(Color, $toAbs, $AbsMem, \nMem); ensures WellFormed($toAbs); { var ptr; ptr := memLo; while (ptr < memHi) invariant T(ptr) &#38;&#38; \nmemLo <= ptr <= memHi; invariant (.Ti. memLo <= i <ptr ==> $toAbs[i] == NO_ABS &#38;&#38; Unalloc(Color[i])); \n{ Color[ptr] := 0; $toAbs[ptr] := NO_ABS; ptr := ptr + 1; } } procedure ReadField(ptr, field) returns \n(val) requires MutatorInv(Color, $toAbs, $AbsMem, Mem); requires Pointer($toAbs, ptr, $toAbs[ptr]); requires \nfield == 0 || field == 1; ensures Pointer($toAbs, val, $AbsMem[$toAbs[ptr],field]); { assert T(ptr); \nval := Mem[ptr,field]; } procedure WriteField(ptr, field, val) requires MutatorInv(Color, $toAbs, $AbsMem, \nMem); requires Pointer($toAbs, ptr, $toAbs[ptr]); requires Pointer($toAbs, val, $toAbs[val]); requires \nfield == 0 || field == 1; modifies $AbsMem, Mem; ensures MutatorInv(Color, $toAbs, $AbsMem, Mem); ensures \n$AbsMem == old($AbsMem)[$toAbs[ptr],field := $toAbs[val]]; { assert T(ptr) &#38;&#38; T(val); Mem[ptr,field] \n:= val; $AbsMem[$toAbs[ptr],field] := $toAbs[val]; } Figure 3. Miniature Collector: Initialize, ReadField, \nWriteField. procedure GarbageCollect(root) requires MutatorInv(Color, $toAbs, $AbsMem, Mem); requires \nroot != 0 ==> Pointer($toAbs, root, $toAbs[root]); modifies Color, $toAbs; ensures MutatorInv(Color, \n$toAbs, $AbsMem, Mem); ensures root != 0 ==> Pointer($toAbs, root, $toAbs[root]); ensures (.Ti.memAddr(i) \n&#38;&#38; $toAbs[i] != NO_ABS ==> $toAbs[i] == old($toAbs)[i]); ensures root != 0 ==> $toAbs[root] == \nold($toAbs)[root]; { assert T(root); if (root != 0) { call Mark(root); } call Sweep();  } procedure \nAlloc(root, $abs) returns (newRoot,ptr) requires MutatorInv(Color, $toAbs, $AbsMem, Mem); requires root \n!= 0 ==> Pointer($toAbs, root, $toAbs[root]); requires $abs != NO_ABS; requires (.Ti. memAddr(i) ==> \n$toAbs[i] != $abs); requires $AbsMem[$abs,0] == $abs; requires $AbsMem[$abs,1] == $abs; modifies Color, \n$toAbs, Mem; ensures MutatorInv(Color, $toAbs, $AbsMem, Mem); ensures root != 0 ==> Pointer($toAbs,newRoot,old($toAbs)[root]); \nensures Pointer($toAbs, ptr, $abs); ensures WellFormed($toAbs); { while (true) invariant MutatorInv(Color, \n$toAbs, $AbsMem, Mem); invariant root != 0 ==> Pointer($toAbs, root, $toAbs[root]); invariant (.Ti. memAddr(i) \n==> $toAbs[i] != $abs); invariant root != 0 ==> $toAbs[root] == old($toAbs)[root]; { ptr := memLo; while \n(ptr < memHi) invariant T(ptr) &#38;&#38; memLo <= ptr <= memHi; { if (Unalloc(Color[ptr])) { Color[ptr] \n:= 1; // make white $toAbs[ptr] := $abs; Mem[ptr,0] := ptr; Mem[ptr,1] := ptr; newRoot := root; return; \n } ptr:=ptr +1; } call GarbageCollect(root);  } } Figure 4. Miniature Collector: Garbage Collection \nand Allocation. .nes an abstract state, consisting of an abstract graph of abstract nodes.Amemory manager \nis responsible for representing the ab\u00adstract state in memory. The memory manager exposes procedures \nto initialize memory, allocate memory, read memory, and write memory (see Initialize, Alloc, ReadField, \nand WriteField in Figures 3, 4). Correctness means that each of these procedures faithfully represent \nthe abstract state. Tomakethis notionof correctness precise,thevariable$AbsMem of type [int,int]int de.nes \nthe abstract state as a mapping from abstract nodes and .elds to abstract values. In the miniature memory \nmodel presented so far, each .eld contains a pointer to a node, so the abstract values stored in the \nabstract graph are al\u00adways abstract nodes. (Section6 extends the setof abstractvalues with othervalues, \nsuch as primitive integers and null.)Forexam\u00adple, Figure 2 shows an abstract graph consisting of 4 nodes, \nA1, A2, A3, and A4, each having two .elds numbered 0 (on top) and 1 (on the bottom).In thisexample, A1 \ns bottom .eld points to A3, so $AbsMem[A1,1] == A3. Integers represent abstract nodes,but these integers \ncan be any mathematical integers, and need not be related to the addresses used by the computer s actual \nmemory. In fact, the variable $AbsMem is not represented at run-time at all; it is used solely forveri.cation.We \ncall suchvariables ghostvari\u00adables (also known as auxillary variables ), and we use a naming convention \nthat pre.xes each ghost variable with a dollar sign. The function MutatorInv(...) de.nes the invariant \nthat holds on the memory manager s data while the mutator is running. Ini\u00adtialize establishes MutatorInv, \nwhile Alloc, ReadField, and WriteField require MutatorInv as a precondition and guar\u00adantee MutatorInv \nas a postcondition. Each collector de.nes MutatorInv(var1...varn) as it wishes. The mutator is not al\u00adlowed \nto modify any of the variables var1...varn directly, but instead must use ReadField, WriteField, and \nAlloc to affect thesevariables. Since MutatorInv varies across collectors,amuta\u00adtor that wants to work \nwith all collectors should treat MutatorInv as abstract. In this framework, the speci.cations for Initialize, \nAlloc, ReadField, and WriteField are exactly the same across all collectors, except for the differing \nde.nitions of MutatorInv. The function $toAbs:[int]int maps each concrete mem\u00adory address in the range \nmemLo...memHi -1 to an abstract node, or to NO_ABS. The memory management procedures ensure that $toAbs \nis well formed(WellFormed($toAbs)), which says that anytwo distinct concrete addresses i1 and i2 map \nto distinct ab\u00adstract nodes,unlesstheymapto NO_ABS.In Figure2, $toAbs maps addresses C1, C2, and C3 to \nabstract nodes A1, A2, and A3, re\u00adspectively, while all other concrete addresses map to NO_ABS. The function \nPointer($toAbs,ptr,$abs) says that $toAbs maps the concrete address ptr to the abstract node $abs. Suppose \nthe mutator calls ReadField(C1,0), which will re\u00adturn the contents of .eld 0 of the object at address \nC1. The precon\u00addition Pointer($toAbs,ptr,$toAbs[ptr]) requires C1 to bea valid pointer,mapped to some \nabstract node(A1 in thisexample).In the miniature memory model presented sofar, all .elds hold point\u00aders, \nso the return value will also be a pointer; the postcondition for ReadField ensures that the returned \nvalue is the pointer corre\u00adsponding to the abstract node $AbsMem[$toAbs[ptr],field] = $AbsMem[A1,0] = \nA2. Since only one pointer, C2, maps to A2, the postcondition forces ReadField(C1,0) to return exactly \nthe ad\u00address C2. (The well-formedness condition, WellFormed($toAbs) ensures that no node other than C2 \nmaps to A2.) Once the mutator obtains the pointer C2 from ReadField(C1,0), it may call, say, ReadField(C2,1) \nto obtain the pointer C3. In this way, the spec\u00adi.cation of ReadField allows the mutator to traverse \nthe reach\u00adable portion of memory, even though the speci.cation never men\u00adtions reachability directly. \nThe speci.cation does not obligate the memory manager to retain unreachable objects. Since A1, A2, and \nA3 do not point to A4, the memory manager need not devote any physical memory for representing A4. In \nFigure 2, there is no concrete address that maps to A4. (Note: in our practical veri\u00ad.ed collectors, \nthe mutator does not make actual run-time proce\u00addure calls to ReadField and WriteField;instead, the postcon\u00additions \nof ReadField and WriteField prove the properties that the mutator needs to read or write memory, without \nactually read\u00ading or writing the memory.Forexample, ReadField ensures that Pointer($toAbs,Mem[ptr,field],...).) \n The mutator allocates new abstract nodes by calling Alloc, passing in a fresh abstract node $abs whose \n.elds initially point to itself. Unlike ReadField and WriteField, Alloc modi.es $toAbs, whichpotentially \ninvalidates anypointers that the muta\u00adtor possesses. (The mutator can t use an invalid pointer that refers \nto an old version of $toAbs, because Pointer($toAbs,...) for an old $toAbs won tsatisfy the preconditions \nfor ReadField and WriteField, which are in terms of the current $toAbs.) There\u00adfore, the mutator may \npass in a root pointer, and the Alloc pro\u00adcedure returns a new root pointer that points to the same abstract \nnode as the old pointer. We could also allow ReadField and WriteField to modify $toAbs, in which case \nthese procedures would also requirea roottobepassedin.In practice, though, this wouldbe an onerousburden \non the mutator. 4.1.1 Verifying collection effectiveness The speci.cation described so far hides the \ngarbage collection process behind the Initialize, ReadField, WriteField, and Alloc interfaces. We also \nverify one internal property of the garbage collector, invisible to the mutator: after a collection, \nonly abstract nodes that the collector reached have physical memory dedicated to them; unreached abstract \nnodes are not represented in memory. It seasy to de.ne an axiom for reachability for anypartic\u00adular abstract \ngraph: for anynode A, if A is reachable, then A s chil\u00addren are also reachable. It sdif.cult, though, \nto track reachability as theedgesinagraphevolve.Forthetwo collectors presentedhere, the $AbsMem graph \nremains unmodi.ed throughout collection,but in general, this is not true: incremental collectors interleave \nshort spans of garbage collection with short spans of mutator activity, and the mutator activity modi.es \n$AbsMem. Therefore, we adopt a looser criterion: rather than checking that all remaining allocated nodes \nat the end of a collection are reachable from the root, we merely check thatall remaining allocated nodes \nwere reached from the rootat sometime sincethe startofthe collection.Verifyingthis property was only \na small extension to the rest of the veri.cation.  4.2 Allocation, marking, and sweeping Figure 4 s \nAlloc procedure performs an (inef.cient) linear search for a free memory address; if no free space remains, \nAlloc calls the garbage collector. The collector recursively marks all nodes reachable from some root \npointer (the mark phase ), and then deallocates all unmarked objects (the sweep phase ). Figure 5 shows \nthe code for both the Mark and Sweep procedures. The next fewparagraphs trace the preconditions and postconditions \nfor Mark and Sweep backwards, starting with Sweep s postconditions. A key property of Sweep is that it \nleaves no dangling point\u00aders (pointers from allocated objects to free space). This prop\u00aderty is part \nof MutatorInv: each memory address i satis.es ObjInv(i, ...), which ensures that if some object lives \nat i (if $toAbs[i] != NO_ABS), then the object s .elds contain valid pointers to allocated objects (see \nFigure 1). Speci.cally, the .elds Mem[i,0] and Mem[i,1] are, like i, mapped to some abstract nodes, so \nthat $toAbs[Mem[i,0]] != NO_ABS and $toAbs[Mem[i,1]] != NO_ABS.Tomaintain this property, Sweep must ensure \nthat anyobject it deallocates had no pointers from ob\u00adjects that remain allocated. Since Sweep deallocates \nwhite objects procedure Mark(ptr) requires GcInv(Color, $toAbs, $AbsMem, Mem); requires memAddr(ptr) \n&#38;&#38; T(ptr); requires $toAbs[ptr] != NO_ABS; modifies Color; ensures GcInv(Color, $toAbs, $AbsMem, \nMem); ensures (.Ti. !Black(Color[i]) ==> Color[i] == old(Color)[i]); ensures !White(Color[ptr]); { if \n(White(Color[ptr])) { Color[ptr] := 2; // make gray call Mark(Mem[ptr,0]); call Mark(Mem[ptr,1]); Color[ptr] \n:= 3; // make black } } procedure Sweep() requires GcInv(Color, $toAbs, $AbsMem, Mem); requires (.Ti. \nmemAddr(i) ==> !Gray(Color[i])); modifies Color, $toAbs; ensures MutatorInv(Color, $toAbs, $AbsMem, Mem); \nensures (.Ti. memAddr(i) ==> (Black(old(Color)[i]) ==> $toAbs[i] != NO_ABS) &#38;&#38; ($toAbs[i] != \nNO_ABS ==> $toAbs[i] == old($toAbs)[i])); { var ptr; ptr := memLo; while (ptr < memHi) invariant T(ptr) \n&#38;&#38; memLo <= ptr <= memHi; invariant WellFormed($toAbs); invariant (.Ti. memAddr(i) ==> 0 <= \nColor[i] < 4 &#38;&#38; !Gray(Color[i]) &#38;&#38; (Black(old(Color)[i]) ==> $toAbs[i] != NO_ABS &#38;&#38; \nObjInv(i, $toAbs, $AbsMem, Mem) &#38;&#38; (Mem[i,0] >= ptr ==> !White(Color[Mem[i,0]])) &#38;&#38; (Mem[i,1] \n>= ptr ==> !White(Color[Mem[i,1]]))) &#38;&#38; ($toAbs[i] == NO_ABS <==> Unalloc(Color[i])) &#38;&#38; \n($toAbs[i] != NO_ABS ==> $toAbs[i] == old($toAbs)[i]) &#38;&#38; (ptr <= i ==> Color[i] == old(Color)[i]) \n&#38;&#38; (i < ptr ==> 0 <= Color[i] < 2) &#38;&#38; (i < ptr &#38;&#38; White(Color[i]) ==> Black(old(Color)[i]))); \n{ if (White(Color[ptr])) { Color[ptr] := 0; // deallocate $toAbs[ptr] := NO_ABS; } else if (Black(Color[ptr])) \n{ Color[ptr] := 1; // make white } ptr := ptr + 1; } } Figure 5. Miniature Collector: Mark and Sweep. \n and leaves gray and black objects allocated, Sweep s preconditions requires that no gray-to-white or \nblack-to-white pointers exist. Torule out gray-to-white pointers,Sweep ssecond precondition requires \nthat no gray objects exist at all: requires (.Ti. memAddr(i) ==> !Gray(Color[i])); The GcInv function \n(see Figure 1) prohibits black-to-white point\u00aders: every black object has .elds pointing to non-white \nobjects. (This is known as the tri-color or three color invariant [9].) The Mark procedure s postconditions \nmust satisfy Sweep s pre\u00adconditions.To ensure thatno gray objectsexistattheendofthe mark phase, Mark \ns second postcondition says that anynon-black object at the end ofthe mark phase retained its original \ncolor from the beginning of the mark phase.For example, any leftover gray objects must have been gray \nat the beginning of the mark phase. Since no gray objects existed at the beginning, no gray objects ex\u00adist \nat the end. Mark obeys the ban on black-to-white pointers by coloring an object black after its children \nare black. (Before col\u00adoring a node s children, Mark temporarily colors the nodegray to indicate the \nnode is in progress ; without this intermediate step, a cycle in the graph would send Mark into an in.nite \nloop.) 4.3 Quanti.ers and triggers In the absence of universal and existential quanti.ers, manytheo\u00adries \nare decidable and havepractical decision procedures. These in\u00adclude the theory of arrays, the theory \nof linear arithmetic, the theory of uninterpreted functions, and the combination of these theories. Unfortunately, \nadding quanti.ers makes the theories either unde\u00adcidableorveryslowto decide:the combinationof linear \narithmetic and arrays, for example, is undecidable in the presence of quanti\u00ad.ers. This forces veri.cation \nto rely on heuristics for instantiating quanti.ers. The choice of heuristics determines the success of \nthe veri.cation. Manyautomated theorem provers, including Z3, use programmer\u00adsupplied triggers to guide \nquanti.er instantiation. Consider again Sweep s precondition prohibiting gray objects. Here are two ways \nto write this in BoogiePL syntax, each with a different trigger: forall i::{memAddr(i)}memAddr(i)==>!Gray(Color[i])) \nforall i::{Color[i]} memAddr(i)==>!Gray(Color[i])) Both have the same logical meaning, but use different \ninstantia\u00adtion strategies. The .rst asks i to be instantiated with expression e whenever an expression \nmemAddr(e) appears during an attempt to provea theorem. The second asks i to be instantiated with e when\u00adever \nColor[e] appears. Selecting appropriate triggers is challeng\u00ading in general. With an overly selective \ntrigger, a quanti.ed for\u00admula may never get instantiated, leavinga theorem unproved.With an overly liberal \ntrigger, a quanti.ed formula may be instantiated too often (even in.nitely often), drowning the theorem \nprover in unwanted information. Shaz Qadeer suggested that we look at formulas of form forall i::{f(i)}f(i) \n==> P, using f(i) as a trigger. For example, we could use memAddr(i) as a trigger, although this appears \nin so many places that it would be easy to acciden\u00adtally introduce an in.nite instantiation loop. (The \nappearance of memAddr(ptr) inside the Pointer function, which in turn ap\u00adpears in the ObjInv function, \nwhich in turn appears in the GcInv function,is oneexampleof sucha loop.)Toavoid accidental loops, we \nintroduce a function T(i:int), de.ned to be true for all i, solely for use as a trigger, writing the \ninvariants above as: forall i::{T(i)}T(i)==>memAddr(i)==>!Gray(Color[i])) (Note that the ==> operator \nis right associative.) For concise\u00adness, we abbreviate forall i::{T(i)}T(i)==> as .T i. To avoid instantiation \nloops, we never write a formula of the form .T i.(...T(e)...), where e is some expression other than \na simple quanti.ed variable. Based on the trigger T(i), we use two strategies to ensure suf\u00ad.cient instantiationofquanti.ed \nformulas. First,we writeexplicit assertions of T(e) for various expressions e that appear in the pro\u00adgram. \nThis helps Z3 prove formulas (.T i.P(i))==>P(e). For example, the ReadField procedure explicitly asserts \nT(ptr) to instantiate the quanti.ers in MutatorInv at the value ptr. Second, we use the trigger T(i) \nto prove formulas of the form (.T i.P(i))==>(.T j.Q(j)). In this case, since T ap\u00adpears in both quanti.ers, \nZ3 automatically instantiates P at i=j to prove Q(j). This second strategy isn t suf.cient for all P \nand Q; for example, knowing .T i.a[i+5] ==0 does not prove .T j.a[j +6]==0, even though mathematically, \nboth these formulas are equivalent. Nevertheless, this strategy works well for purely local reasoning.Forexample, \nSweep s loop invariant main\u00adtains the property .T i.memAddr(i)==>!Gray(Color[i]). If the loop updates \nColor by changing Color[ptr] to 1 (white), then the theorem prover attempts to prove: (memAddr(i)==>!Gray(Color[i])) \n==> (memAddr(i)==>!Gray(Color [i])) where Color == Color[ptr := 1]. In the case where i != ptr, Color[i] \n== Color [i] and the proof is trivial. In the case where i == ptr, !Gray(Color [i]) == !Gray(1) == true. \nThe proof is easy because the formula memAddr(i) ==> !Gray(Color[i]) is entirely local; it depends only \non array ele\u00adments at index i. Many formulas depend on non-local array elements, though. Consider how \nMark maintains this piece of the tri-color invariant (no black-to-white pointers) from GcInv in Figure \n1: Black(Color[i]) ==> !White(Color[Mem[i,0]]) This depends not only on i s color,but on the colorof \nsome other node Mem[i,0]. For non-local formulas, the local instantiation strategy suf.ces for some programsbut \nnot for others.Forexample, it suf.ces for the collector in Figures 1-5 (we invite the reader to write \nout the veri.cation conditions by hand to see), but did not suf.ce for an analogous copying collector \nthat we wrote (it did not suf.ciently instantiate information about objects pointed to by forwarding \npointers). 5. Regions Amark-sweep collector appears easiertoverifythanacopyingcol\u00adlector, because the \nmark-sweep collector doesn t modify pointers inside objects. As the previous section mentioned, the mark-sweep \ncollectorin Figures1-5 passedveri.cation even withavery sim\u00adple triggering strategy, while the analogous \ncopying collector did not. Therefore, this section augments the two strategies described in the previous \nsection with a third instantiation strategy, based on regions.Together, these three strategies were suf.cient \nfor both mark-sweep and copying collectors. Regions have proven useful for verifying the type safety \nof copying collectors [27, 21], which suggests that they might also help verify the correctness of copying \ncollectors.Type systems for regions are similar to the veri.cation presented in section 4: sec\u00adtion 4 \ns veri.cation mapped concrete addresses to abstract nodes, while type systems type-check a region by \nmapping concrete ad\u00addressesintheregiontotypes(e.g.,atype systemwithtypes Parent and Child might map Figure \n2 s C1 to Parent and C2 and C3 to Child). This suggests a strategy for importing regions (and the ease \nof verifying copying collectors via regions) from type sys\u00adtems: rather than de.ning just one concrete-to-abstract \nmapping $toAbs, allow multiple regions, where each region is an indepen\u00addent concrete-to-abstract mapping. \n For example, consider how Figure 1 s object invariant uses $toAbs: ObjInv(i,$toAbs,$AbsMem,Mem) = $toAbs[i] \n!= NO_ABS ==> Pointer($toAbs, Mem[i,0], $AbsMem[$toAbs[i],0]) ... Expanding the Pointer function exposes \na non-local invariant: $toAbs[i] != NO_ABS ==> ... $toAbs[Mem[i,0]] != NO_ABS ...  This invariant is \ncrucial; as discussed in section 4, it ensures that no dangling pointersexist.However,it snotobvioushowtoprovethat \nthis invariant is maintained when $toAbs[Mem[i,0]] changes. Therefore,the remainderofthispaperadoptsaregion-basedobject \ninvariant: ObjInv(i,$rs,$rt,$toAbs,$AbsMem,Mem) = $rs[i] != NO_ABS ==> Pointer($rt, Mem[i,0], $AbsMem[$toAbs[i],0]) \n... This object invariant describes an object living in a source region $rs, whose .elds point to some \ntarget region $rt. Expanding the Pointer function yields: $rs[i] != NO_ABS ==> ... $rt[Mem[i,0]] != NO_ABS \n...  Now we adopt another idea from region-based type systems: re\u00adgions only grow over time, and are \nthen deallocated all at once; deallocating a single object from a region is not allowed. In our setting, \nthis means that for any address j and region $r, $r[j] may change monotonically from NO_ABS to some particular \nab\u00adstract node,but thereafter $r[j] is .xed at that abstract node. The function RExtend expresses this \nrestriction;the memory manager only changes $r to some new $r if RExtend($r,$r ) holds: fun RExtend($r:[int]int,$r \n:[int]int) { (forall i::{$r[i]}{$r [i]} $r[i] != NO_ABS ==> $r[i] == $r [i]) } RExtend s quanti.er is \nnot based on T;instead, it can trigger on either $r[i] or $r [i]. (Note that RExtend introduces no instan\u00adtiation \nloops, because it only mentions r and r at index i, and does not mention T at all.) In combination with \nthe second strategy from section 4, this triggering allows Z3 to prove formulas of the form (.T i.P(r[e]))==>(.T \ni.P(r [e])), where e depends on i.Forexample,given the guarantee that RExtend($rt,$rt ),the object invariant \nensures that if $rt[Mem[i,0]] != NO_ABS, then $rt [Mem[i,0]] != NO_ABS. Giventhisregion-basedobjectinvariant,amemorymanagercan \nexpress all other invariants about node i as purely local invariants. For example, our region-based mark-sweep \ncollector relates i s color to i s region state using purely local reasoning: (White(Color[i]) ==> $r1[i] \n!= NO_ABS &#38;&#38; $r2[i] == NO_ABS &#38;&#38; ObjInv(i,$r1,$r1,$toAbs,$AbsMem,Mem)) &#38;&#38; (Gray(Color[i]) \n==> $r1[i] != NO_ABS &#38;&#38; $r2[i] != NO_ABS &#38;&#38; $r1[i] == $r2[i] &#38;&#38; ObjInv(i,$r1,$r1,$toAbs,$AbsMem,Mem)) \n&#38;&#38; (Black(Color[i]) ==> $r1[i] != NO_ABS &#38;&#38; $r2[i] != NO_ABS &#38;&#38; $r1[i] == $r2[i] \n&#38;&#38; ObjInv(i,$r2,$r2,$toAbs,$AbsMem,Mem)) If i is black, then ObjInv(i,$r2,$r2,...) ensures that \ni s.elds point to members of region $r2. Members of $r2 cannot be white, since the invariant above forces \nwhite nodes to not be members of $r2. Thus, the invariant indirectly expresses the standard tri-color \ninvariant (no black-to-white pointers), and the collector need not state the tri-color invariant directly. \nWe brie.y sketch the region lifetimes during a mark-sweep garbage collection. The collector s mark phase \nbegins with $r1 equal to $toAbs and $r2 empty (i.e. $r2 maps all nodes to NO_ABS). At the beginning of \nthe mark phase, all allocated objects are white, so the invariant aboveneeds ObjInv(i,$r1,$r1,...), and \nrequires that no objects be members of $r2. As the mark phase marks each reached node i gray, it adds \ni to $r2, so that $r2[i] != NO_ABS. At the end of the mark phase, $r2 con\u00adtains exactly the reached objects, \nwhile $r1 and $toAbs are the same as at the beginning of the mark phase. The sweep phase then removes \nunreached objects from $toAbs until $toAbs == $r2; Sweep leaves $r1 and $r2 unmodi.ed. After sweeping, \nthe mu\u00adtator takes an action analogous to deallocating region $r1: it simply forgets about $r1, throwing \nout all invariants relating to $r1 andkeeping only theinvariants for $r2. In the next collection cycle, \n$r2 becomes the new $r1, and the process repeats. 6. Practical veri.ed collectors This section applies \nthe previous section s region-based veri.ca\u00adtion to realistic copying and mark-sweep collectors, replacing \nthe naive recursive algorithm of Figures 1-5 with more ef.cient itera\u00adtivealgorithms in subsections 6.1 \nand 6.2, then replacing high-level language constructs with assembly language in subsection 6.3, and \nthen replacing the miniature 2-.eld, 1-root memory model with a Bartok-compatible memory model in subsection \n6.4. If sections 1\u00ad5were the inspiration, this section is the perspiration; the code for the realistic \ncollectorsisfar longer than Figures 1-5,but not funda\u00admentally much more interesting.We present only \nshort description and selected highlights of invariants; the reader can .nd the full code and complete \ninvariants in the public release. 6.1 Acopying collector The copying collector is a standard two-space \nCheney-queue col\u00adlector [7]. The heap consists of two equally sized spaces. At any given time, one of \nthe spaces is called from-space and the other is called to-space. The mutator allocates objects in from-space \nun\u00adtil from-space .lls up. Then the collector traverses all from-space objects reachable from the root \npointer, and copies these objects into to-space. (All objects left in from-space aregarbage, and are \nsimply ignoredby the mutator and collector.) From-space becomes to-space, to-space becomes from-space, \nand control returns to the mutator. For each object copied to to-space, the collector sets aforward\u00ading \npointer that points from the old from-space object to the new to-spacecopy.Thisprovidesa meansto.ndthecopiedversionof \neach object in to-space and ensures that the collector doesn t copy the same object twice. When the collector \ncopies an object to to-space, the .elds of the copied object initially point back to from-space. The \ncollector later .xes up the pointers to point to to-space, by either copying the referent into to-space, \nor using the forwarding pointer of an already-copied object. The set of objects not yet .xed form a contiguouswork \nareain to-space.The collection algorithm(shown in Figure 6) treats this work area as a queue, adding \nnewly copied objects to the back of the queue, and .xing objects from the front of the queue. When the \nqueue is empty, all objects are .xed, and the collection is done. The real collector stores the forwarding \npointer in the header .eld of a from-space object after the from-space object is copied, while (QFront \n< QBack) for each pointer field f of object QFront target := Mem[QFront,f]; if(FwdPtr[target] != null) \n// target object already copied Mem[QFront,f] := FwdPtr[target]; else // copy target object to QBack \nMem[QBack,0] := Mem[target,0]; Mem[QBack,1] := Mem[target,1]; $toAbs[QBack] := $r1[target]; $r2[QBack] \n:= $r1[target]; $toAbs[target] := NO_ABS; FwdPtr[target] := QBack; Mem[QFront,f] := QBack; QBack++; QFront++; \nFigure 6. Copying collector pseudo-code (including ghost variable up\u00addates) overwriting the vtable (virtual \nmethod table) pointer in the header. (The collector can distinguish a vtable pointer from a forwarding \npointer, because vtables do not live in to-space.) The copying collector shares the same region-based \nObjInv from section 5. Other invariants differ from the mark-sweep col\u00adlector, though.Forexample, the \ncopying collector has no colors, so there is no invariant to relate colors to regions. There are invariants \nthat relatethe forwarding pointertoregions, though.Forexample, each object i in from-space satis.es this \ninvariant, which ensures that only unforwarded objects are present in $toAbs, and that any forwarding \npointer points to a resident of $r2: (FwdPtr[i]!=null <==> $toAbs[i]==NO_ABS) &#38;&#38; (FwdPtr[i]!=null \n==> Pointer($r2,FwdPtr[i],$r1[i])) The region $r2 is empty at the start of the collection. The collector \nadds each object that it creates in to-space to $r2,while leaving$r1 unchanged. The collector also updates \n$toAbs to point to to-space objects rather than from-space objects; at the end, the collector assigns \n$r2 to $toAbs,andthrowsoutallinvariants relatedto$r1. During the collection, each .xed object in to-space \npoints from region $r2 to region $r2: ObjInv(i,$r2,$r2,$toAbs,$AbsMem,Mem) Each object still in the to-space \nqueue points from region $r2 back to region $r1: ObjInv(i,$r2,$r1,$toAbs,$AbsMem,Mem) 6.2 Amark-sweep \ncollector Ourveri.ed mark-sweepcollector usesthe standard 3-colorinvari\u00adant. In the beginning of the \ncollection all objects are white and the goal is to mark black all objects reachable from the roots. \nAfter this marking process, the sweep process can go over the objects to reclaim all white objects and \nto mark all black objects white in preparation for the next collection. In the beginning of the collec\u00adtion \nall objects directly reachable from the roots are put into a list denoted the mark-stack. All objects \nin this list are colored gray, meaning that they have been reached,but their descendants have not yet \nbeen traversed. After the roots have been scanned, the col\u00adlector proceeds by iteratively choosing a \ngray object O from the mark-stack, inserting O s direct descendants into the mark-stack and marking O \nblack. The black color signi.es that the object is reachable and all its direct descendants have been \nnoticed (i.e., put in the mark-stack). The unallocated color labels free space. Keeping theobject color \nrequires twobits per object. The colors canbekeptin the object header orina separate table.Following \nprevious work (e.g., [11, 1, 16]) we have chosen the latter. Bartok assumes that objects are 4-byte aligned. \nTherefore, it is enough to keeptwocolorbitsper4bytes (creatingaspaceoverheadof6%). The algorithm follows \na very simple collection scheme. One could choose a simpler scheme for veri.cation, for example, by giving \nup the mark-stack and searching the heap for gray objects, or employing recursion. One could also complicate \nthe scheme and make it more ef.cient, for example, by using bit-wise sweep. However, we attempted to \n.nd the middle way between simplicity andef.ciency,in orderto enableveri.cationwhile maintainingthe practicability \nof the collector. 6.2.1 The allocator A major performance consideration is the allocator. Therefore, \nwe paid special attention to making the allocator ef.cient, cache\u00adfriendly, scalable, and simple.We chose \nthe local allocation cache method that was .rst invented and used with the IBM JVM alloca\u00adtor [5] and \nlater employed and explained in [2, 16]. This method provides ef.ciency by allowing bump-pointer allocation \nwith a mark-sweep collection. The mutator holds a local cache in which it allocates small objectsby simplybumpinga \npointer.When the space in the cache is exhausted, the mutator acquires a new local cache from the .rst \nchunk in the free list. If that chunk is too large (larger than some threshold maxCacheSize), then only \nmaxCache-Size bytes of the .rst chunk are taken for the local cache, and the rest is left for future \ncache allocations. Allocation of large objects use the free list directly; however, since most allocated \nobjects in typical programs are small, most allocation work is ef.cient. Fur\u00adthermore, these allocations \nare cache-friendly since the spatial or\u00adder of allocated objects in the memory matches the temporal order \nin which the program allocates them. Since the mutator only acquires objects or spaces of substantial \nsize fromthe free list, thereisnoneedtokeep small chunksinit. Thus, sweep only .lls the free-list with \nlarge enough spaces; in our implementation the minimum cache size was set to 256 bytes and objects of \nsize 192 or up are considered large (and are thus directly allocated from the free list). The mark-sweep \ncollector invariants follow the region-based approach of section 5, sharing the de.nition of Pointer \nand ObjInv with the copying collector. Unlike earlier sections, though, this mark-sweep collector has \na free list with non-trivial structure. We use two ghost variables,$fs and $fn to represent the size \nof each free list entry and the next-list-entry pointer in each free list entry. Any address i where \n$fs[i] != 0 holds a free list entry. Each free list entry must be at least8 bytes:4 bytes to store the \nnextpointer,and4bytestostorethesize.The centralinvarianten\u00adsures, among other things, that the space \noccupied by each free list entry does not overlap with anyobject or anyother free list entry: $fs[i] \n!= 0 ==> $toAbs[i] == NO_ABS &#38;&#38; i+8<= i+$fs[i]&#38;&#38;i+ $fs[i]<=memHi &#38;&#38; (.T j.i< \nj&#38;&#38;j< i+ $fs[i]==> $toAbs[j] == NO_ABS &#38;&#38; $fs[j] == 0) &#38;&#38; ...  6.3 From BoogiePL \nto x86 Sofar, this paper hasexpressed all memory management codein BoogiePL or in pseudocode, neither \nof which were designed to execute on real computers.We decided to write our real copying and mark-sweep \ncollectors (and allocators) in x86 assembly lan\u00adguage,fortwo reasons. First,we didn t wantahigh-level \nlanguage compiler in our trusted computing base. Second, the mutator-to\u00adallocator interface requires \nsome assembly language to read the stack pointer, so that the collectors can scan the roots on the stack. \nWe still wanted to use Boogie to verify our code, so this left us with a choice: translate annotated \nx86 into BoogiePL, or translate BoogiePL into x86. The former approach is the most common way to use \nBoogiePL,but we chose the latter approach, for the follow\u00ading reason. Since thegarbage collectors are \nwritten in BoogiePL, the Boogie and Z3 tools guarantee that we really have veri.ed the collectors, at \nleast in BoogiePL form, even if our BoogiePL-to-x86 translation subsequently turns theveri.ed BoogiePL \ninto erroneous x86 code. (If we had translated x86 to BoogiePL, we would have had to ask the reader to \ntrust that our translator didn tjust produce a trivially veri.able BoogiePL program.) We wrote a small \ntool to automatically translate an x86-like subset of BoogiePL into MASM-compatible x86 code, which we \nthen assemble and link with Bartok-compiled benchmarks. The x86-like subset of BoogiePL consists of top-level \nvariable declara\u00adtions, non-recursive pure function declarations, and non-recursive procedure declarations. \nEach procedure is either a macro that gets inline-expanded, orarun-time procedure called with the x86 \nCALL instruction. The tool enforces matching CALL and RETURN in\u00adstructions; the BoogiePL code may read \nthe stack pointer at any time,butmaynotwriteit.Each procedure consistsoflocalvariable declarations followedbyasequenceof \nstatements. Since there sno recursion, local variables are statically allocated, as in early FOR-TRAN. \nGlobal and local variables may be ghost variables, of any type,orphysicalvariables,of type int. The prede.ned \nglobalvari\u00adables eax, ebx, ecx, edx, esi, edi, ebp, and esp, all of type int, represent the x86 registers.We \nmaintain the invariant that all reg\u00adisters, physical variables, and words in memory hold an integer in \nthe range 0..232 - 1 at all time. Each statement in a procedure is a label (used as a jump or branch \ntarget), an assignment to a ghost variable (ignored by the translation), an assignment to a register \nor physical variable, a procedure call, ora control statement. Control statements are either unconditional \njumps ( goto label; ) or conditional branches: if(operand1 cmp operand2) { goto label; } where operand1 \nand operand2 are registers, physical variables, or integer constants, and cmp is a comparison operator. \nMost state\u00adments are translated into single x86 instructions, but conditional branches translate into2x86 \ninstructions(acompareandabranch). A procedure call either translates into an inline expansion of the \ncalled procedure, or a single x86 CALL instruction. Each assignment statement is either a simple move \noperation operand1 := operand2; , an arithmetic operation, or a mem\u00adory operation. Arithmetic operations \ncan either statically check for 32-bit integer over.ow, or check at run-time. For example, the statement \ncall eax := Sub(eax, 5); statically veri.es that eax -5 does not over.ow, because of the (tool-supplied) \nspeci.\u00adcation of Sub (where word(e) means that0=e< 232): procedure Sub(x:int, y:int) returns(ret:int); \nrequires word(x -y); ensures ret == x -y; The program is not allowed to modify prede.ned global variables, \nlike Mem, directly.To read or write memory, the program must call tool-supplied Load and Store procedures, \nwhich the tool trans\u00adlates into x86MOVinstructions. The preconditions for Load and Store guarantee that \nthe veri.ed code does not read or write out\u00adside its allowed memory area, and that all reads and writes \nare to 4-byte aligned addresses. In contrast to the two-dimensional mem\u00adory Mem[objAddress,field] presented \nearlier, Load and Store work with a one-dimensional memory Mem[byteAddress]. 6.4 The Bartok memory model \nOurveri.edgarbage collectors forma critical pieceof our long\u00adterm goal: an entire veri.ed run-time system \nfor Bartok-compiled code. Because the existing Bartok run-time system contains over 70,000 lines of code, \nwe decided to take an incremental approach towards creating a veri.ed run-time system, starting with \nas small a run-time system as possible, so as to make the veri.cation as easy as possible. We still wanted \nto be able to run real Bartok\u00adcompiled benchmarks, though, and these benchmarks rely on many non-trivial \nrun-time system features.So before attemptingtoverify anyrun-time system code, we examined the 12 large \nbenchmarks used in previous papers [6, 24] to see which features could be evicted from the run-time system.We \nfound that we could remove two major features, while still supporting 10 of the 12 benchmarks: Only \none benchmark (SpecJBB) was multithreaded, so we omitted support for multithreading from our run-time \nsystem.  Only one of the remaining benchmarks (mandelform) relied on GC support for unsafe code, such \nas pinning objects (to cast GC-managed pointers to unmanagedpointers for unsafe code) and handling callbacks \nfrom unsafe code to safe code. Our veri.ed GC simply halts any program that tries to use these features. \n This still left a moderately large set of features to support: Objects have a header word, pointing \nto a virtual method table (vtable). Before the header word, there is a pre-header that holds a hash code \nor other primitive value.  Non-indexed object types can have any number of .elds. In\u00addexed object types \ncan be strings, single-dimensional arrays, or multi-dimensional arrays, each having a different memory \nlayout. Array element types can be pointers, primitive values, structs without pointers, or structs with \npointers. We imple\u00admented only partial support for arrays of structs with pointers, since the 10 benchmarks \ndid not rely on full support.  Pointers point to an object s header word, with one exception: root pointers \nmay be interior pointers that point to data inside an object, ranging from the header word up to, and \nincluding, the address of the end of the object.  An object s virtual method table has .elds that the \ncollector can read to compute the length of an object and to determine which .eldsof an object arepointers. \nBartok s pointer-tracking representation consists of2compact bit-level formats for non\u00adindexed objects,1non-compact \nformat for non-indexed objects, 1 format for strings, 2 formats for single-dimensional arrays, and2formats \nfor multi-dimensional arrays. Our collectors sup\u00adport all of these (except for some arrays of structs \nwith point\u00aders).  Roots may liveon the stack or in static data segments. Each sta\u00adticdatasegmenthasabitmap,withonebitper \nstaticdataword, indicating pointers and non-pointers in the segment. Finding pointers on the stack is \nmore complicated; the collector has to traverse frame pointers to .nd the stack frames, and it has to \nlook up return addresses in a sorted table of return addresses to .nda descriptor for each frame.To simplify \n.nding point\u00aders, we set a compiler .ag telling Bartok to treat all registers as caller-save registers, \nwith no callee-save registers.  Space constraints preclude a complete, detailed description of the speci.cation \nand collector implementation of the features above. We provide just one example. One of the compact pointer-tracking \nformats is a dense format, using one bit per .eld. The speci.cation for this says that if the tag of \nan object for abstract node $abs, with vtable vt, is DENSE_TAG, then each .eld is a pointer if and only \nif the corresponding bit in the vtable s mask .eld is 1: tag(vt)==DENSE_TAG ==> (.T j.2<=j<numFields($abs)==> \nVFieldPtr($abs,j)==(j<30 &#38;&#38; getBit(mask(vt),2+j))) where mask looks up a 32-bit value from the \nvtable (in readonly memory), and tag and getBit extract bits from words: fun mask(vt:int) { ro32(vt + \n?VT_MASK) } fun tag(vt:int) { and(mask(vt), 15) } fun getBit(x:int,i:int) { 1 == and(shr(x, i), 1) } \nThe mutator-allocator interface speci.cation uses the uninterpreted function VFieldPtr to state which \nphysical values are primitive values, and which are pointervalues. TheValue function states the meaning \nof values in each of these two cases: fun Value(isPtr,$r,v,$abs) { (isPtr &#38;&#38; word(v) &#38;&#38; \ngcAddrEx(v) &#38;&#38; !word($abs) &#38;&#38; Pointer($r, v -4, $abs)) || (isPtr &#38;&#38; word(v) \n&#38;&#38; !gcAddrEx(v) &#38;&#38; $abs == v) || (!isPtr &#38;&#38; word(v) &#38;&#38; $abs == v) } For \nprimitive data, the data s abstract value equals its concrete value. Pointer data may point to GC memory, \nunder the collector s control, or theymay point outside GC memory, in which case the collector treats \nthem the same as primitive values. The -4 in the Pointer speci.cation converts a pointer to a header \nword into a pointer to the beginning of the object (the pre-header). Interior pointers are de.ned like \nthe ordinary pointers shown above, but may have offsets larger than 4, which forces the col\u00adlector to \nsearch for the beginning of the object. The mark-sweep collector already has a table of colors, so it \nsimply searches back\u00adwards from the interior pointer to .nd the .rst word whose color isn t unallocated.We \nalso had to add an analogous bit map to the copying collector, with one bit per heap word, solely for \nthe purpose of handling interior pointers. (On the bright side, these bit mapsdidgiveusa chancetoexerciseZ3 \nsbitvector support.) Before we added support for Bartok s memory model, the trusted mutator-allocator \nspeci.cation was fairly short and read\u00adable. After adding Bartok s memory model, the speci.cation bal\u00adlooned \nto hundreds of lines of bit-level details. At this point, we started to wonder if the speci.cation itself \nhad bugs. We used two techniques to test the speci.cation. First, we used Boogie s smoke feature, which \nattempts to prove false at various points in the program. This did not turn up anybugs. Second, we hand\u00adtranslated \nthe speci.cation into C# code, and then added run-time assertions to the original Bartokgarbage collectors \nbased on this C# code.Wesaw manyassertion violations, whichledusto5spec\u00adi.cationbugs, ranging from mundane(forgettingto \nmultiplyby4 to convert a word address to a byte address) to subtle (forgetting that Bartok compresses \nthe sorted return address tablesby omitting anyentry whose descriptor is identical to the previous entry). \n7. Performance This section presents performance results, measured on a single core of a 4-core, 2.4GHz \nIntel Core2 with 4GB of RAM, 4MB of L2 cache, and a 64KB L1 cache. Verifying the copying collector, mark-sweep \ncollector, and the code shared between the collectors took 115 seconds, 70 seconds, and 12 seconds, respectively \n(see Table 1). This fast veri.cation re.ects our choice of a simple trigger T(i). The copying col\u00adlector \nand mark-sweep collector contained 802 x86 instructions (before inlining) and 865 x86 instructions (before \ninlining), plus 177 x86 instructions (before inlining) shared between the collec\u00ad Figure 7. OthelloPerformance \nComparison:overall running time (in Figure 12. ZingerPerformance Comparison:overall running time(in seconds)versusheap \nsize(inKB). seconds)versusheap size(inKB).       BoogiePL code (non-comment, non-blank lines) x86 \ninstructions (before inlining) Time to verify (seconds) Trusted defs 546 Shared code 779 177 12 Copying \n2398 802 115 Mark-sweep 3038 865 70 Table 1. Veri.cation times for practical collectors tors. The BoogiePL \n.les for the copying and mark-sweep collec\u00adtors contained 2398 non-comment, non-blank lines and 3038 \nnon\u00adcomment, non-blank lines, plus 779 non-comment, non-blank lines of BoogiePL code shared between the \ncollectors. The trusted de.\u00adnitions, including x86 instruction speci.cations and the Bartok in\u00adterface \nspeci.cation, occupied 546 non-blank, non-comment lines. Figures 7-16 show the performance of the 10 \nbenchmarks de\u00adscribedin section6 asa functionofheapsize,bothforourveri.ed memory managers and for Bartok \ns native run-time system.We de\u00adnote the veri.ed copying collector by VC, the veri.ed mark-sweep collector \nby VMS, the generational copying Bartok collector by GEN, and the Bartok standard mark-sweep collector \nby MS. These results demonstratethat(a)our collectorsworkonreal benchmarks, and (b) the space and time \nconsumption is in the same ballpark as Bartok s native run-time system.We emphasize the ballpark na\u00adture \nof the comparison between the veri.ed collectors and the na\u00adtive Bartok collectors, because this comparison \nis highly unfair to the native collectors, which support more features than the veri.ed collectors. In \nparticular, Bartok s native run-time system supports multithreading, which adds synchronization overhead \nto the muta\u00adtor and memory manager. Bartok s native collectors were not designed to be used with a .xed \nheap size; they expect to grow the heap as needed. To get a time vs. space plot for the Bartok collectors, \nwe varied the triggering mechanism used for heap growth, and then measured the actual heap space used.For \nthe generational collector, we set the nursery size to 4MB or1/4 of the maximum heap size, whichever \nwas smaller. Several benchmarks created fragmentation that made it dif.cult for the veri.ed mark-sweep \ncollector to .nd space for very large objects. The standard Bartok mark-sweep collector simply grows \nthe heap when the current heap lacks space for a very large ob\u00adject; we con.gured the veri.ed mark-sweep \ncollector to set aside part of the heap as a wilderness area, used as a last resort for very large object \nallocation. While this wilderness area enabled these benchmarks tokeep running under heavy fragmentation, \nthe per\u00adformance still suffered.For other benchmarks, though, theveri.ed mark-sweep collector performed \nwell across a large spectrum of heap sizes. The veri.ed copying collector, as expected, required a larger \nminimum heap size, but performed asymptotically well as the heap size increased. 8. Conclusion We have \npresented two simple collectors with the minimal set of properties required to make them reasonably ef.cient \nin a prac\u00adtical setting. We have mechanically veri.ed that these collectors maintainaheap representationthatisfaithfultoa \nmutator-de.ned abstract heap, and have run the collector on large, off-the-shelf C# benchmarks. Given \nthe large size of the mutator-allocator speci.cation, we were very curious to see whether our collectors \nwould run cor\u00adrectly the .rst time. Alas, running the veri.ed copying collec\u00adtor revealed two speci.cationbugs \nthat we hadn t caught before: Initialize s postcondition forgot to ensure that the ebp register wassaved,andthe \nallocation postcondition speci.eda returnvalue thatwasoffby4bytes(a header/pre-header confusion).Thus,the \ncopying collector ran correctly the third time we tried it, which is still no small achievement for a \ngarbage collector hand-coded in assembly language. Furthermore, we were then able to verify the mark-sweep \ncollector against the debugged speci.cation, so that the mark-sweep collector ran correctly the .rst \ntime we tried it. In addition, having a clear and well-tested speci.cation is use\u00adful for TAL/PCC veri.ers: \nbased on the speci.cation, we found abugin ourTALveri.er [6], which didn t check that the sparse pointer \ntracking formats mention no .eld more than once; thisbug can allowTAL code to crash when linked to Bartok \ns native slid\u00ading/compacting collector. Thefastveri.cation timesgiveushopethat thereis still room to \ngrow to support more features and better GC algorithms. In par\u00adticular, multithreading and pinning are \nessential for many appli\u00adcations and libraries. Pinning should be easy for the mark-sweep collector,butwould \ncomplicate the copying collector: pinned ob\u00adjects fragment the heap, forcing the allocator to allocate \nfrom a non-contiguous free space. Multithreadingwould require reasoning about mutualexclusion(e.g.tokeep \nallocatorsindifferent threads from allocating the same memory simultaneously), reasoning about suspending \nmutator threads during collection, and support for a more elaborate object pre-header word (for monitor \noperations on objects). As the collectors grow, modularity becomes more impor\u00adtant, so we re interested \nto see if the Boogie/Z3 approach can be combined with modular veri.cation approaches based on separa\u00adtion \nlogic and/or higher-order logic; hopefully, the automation pro\u00advided by Boogie/Z3 will allow veri.cation \nat a scale where modu\u00adlarity becomes essential. Acknowledgments The authors would like to thank Nikolaj \nBj\u00f8rner, Shaz Qadeer, Shuvendu Lahiri, Bjarne Steensgaard, Jeremy Condit, Juan Chen, Zhaozhong Ni, and \nthe anonymous reviewers for many helpful discussions, suggestions, and comments. References [1] Hezi \nAzatchi,Yossi Levanoni, HarelPaz, and Erez Petrank. An on\u00adthe-.y mark and sweepgarbage collector based \non sliding view. In OOPSLA 03 ACM Conference on Object-Oriented Systems, Languages and Applications,ACM \nSIGPLAN Notices, Anaheim, CA,November 2003.ACM Press. [2] Katherine Barabash, Ori Ben-Yitzhak, Irit Goft, \nElliot K.Kolodner, Victor Leikehman,Yoav Ossia,Avi Owshanko, and Erez Petrank. A parallel, incremental, \nmostly concurrent garbage collector for servers. ACMTransactionsonProgramming Languagesand Systems, 27(6):1097 \n1146, November 2005. [3] Mike Barnett, Bor-Yuh Evan Chang, Robert DeLine, Bart Jacobs, and K. Rustan \nM. Leino. Boogie:AModular ReusableVeri.er for Object-Oriented Programs. InFormal Methods for Components \nand Objects: 4th International Symposium, FMCO 2005. [4] Lars Birkedal, Noah Torpe-Smith, and John C. \nReynolds. Local reasoning abouta copyinggarbage collector. In POPL, pages 220 231,Venice, January 2004.ACM \nPress. [5] Sam Borman. Sensible sanitation understanding the IBM Java garbage collector, part 1: Object \nallocation. IBM developerWorks, August 2002. [6] Juan Chen, Chris Hawblitzel, Frances Perry, Mike Emmi, \nJeremy Condit, Derrick Coetzee, and Polyvios Pratikakis. Type-preserving compilation for large-scale \noptimizing object-oriented compilers. In PLDI, pages 183 192,Tucson, AZ, June 2008. [7] C. J. Cheney. \nAnon-recursive list compacting algorithm. Communi\u00adcationsof theACM, 13(11):677 8, November 1970. [8] \nLeonardo de Moura and Nikolaj Bjorner. Z3: An Ef.cient SMT Solver. Conference onTools and Algorithms \nfor the Construction and Analysis of Systems (TACAS), 2008. [9] EdsgarW. Dijkstra, Leslie Lamport, A. \nJ. Martin, C. S. Scholten, andE.F.M. Steffens. On-the-.ygarbage collection:Anexercisein cooperation. \nIn Lecture Notes in Computer Science, No. 46. Springer\u00adVerlag,NewYork, 1976. [10] Damien Doligez and \nGeorges Gonthier. Portable, unobtrusivegarbage collection for multiprocessor systems. In POPL, Portland, \nOR, January 1994.ACM Press. [11]Tamar Domani, ElliotKolodner, and Erez Petrank. Agenerational on-the-.ygarbage \ncollectorforJava.In PLDI,Vancouver, June 2000. ACM Press. [12] Healfdene Goguen, Richard Brooksby, and \nRod Burstall. An abstract formulation of memory management, December 1998. draft. [13] Georges Gonthier. \nVerifying the safety of a practical concurrent garbage collector. In R. Alur andT. Henzinger, editors, \nComputer AidedVeri.cation CAV 96, Lecture Notes in Computer Science, New Brunswick, NJ, 1996. Springer-Verlag. \n[14] Klaus Havelund and N. Shankar. A mechanized re.nement proof foragarbage collector. Technical report, \nAalborgUniversity, 1997. SubmittedtoFormal Aspectsof Computing. [15] Paul B. Jackson. Verifying a garbage \ncollection algorithm. In Proceedings of 11th International Conference on Theorem Proving in Higher Order \nLogics TPHOLs 98, volume 1479 of Lecture Notes in Computer Science, pages 225 244, Canberra, September \n1998. Springer-Verlag. [16] Haim Kermany and Erez Petrank. The Compressor: Concurrent, incremental and \nparallel compaction. In PLDI, pages 354 363, Ottawa, June 2006.ACM Press. [17] Yossi Levanoni and Erez \nPetrank. An on-the-.y reference counting garbage collector for Java. In PLDI, 28(1), January 2006. [18] \nJohn McCarthy. Recursive functions of symbolic expressions and their computation by machine. Communicationsof \ntheACM, 3:184 195, 1960. [19] Andrew McCreight, Zhong Shao, Chunxiao Lin, and Long Li. A general framework \nfor certifying garbage collectors and their mutators. In PLDI, San Diego, CA, June 2007. [20] MarvinL. \nMinsky. ALispgarbage collector algorithm using serial secondary storage. Technical Report Memo 58 (rev.), \nProject MAC, MIT, Cambridge, MA, December 1963. [21] Stefan Monnier,Bratin Saha, and Zhong Shao. Principled \nscavenging. In PLDI, Snowbird, Utah, June 2001. [22] Greg Morrisett, DavidWalker, Karl Crary, and Neal \nGlew. From System F to typed assembly language. In POPL, pages 85 97, January 1998. [23] George Necula. \nProof-Carrying Code. In POPL, pages 106 119. ACM Press, 1997. [24] Filip Pizlo, Erez Petrank, and Bjarne \nSteensgaard. A study of concurrent real-time garbage collectors. In PLDI, pages 33 44, Tucson, AZ, June \n2008. [25]DavidM. Russinoff.A mechanicallyveri.ed incrementalgarbage collector. Formal Aspects of Computing, \n6:359 390, 1994. [26] Martin Vechev, Eran Yahav, David Bacon, and Noam Rinetzky. CGCExplorer: A semi-automated \nsearch procedure for provably correct concurrent collectors. In PLDI, San Diego, CA, June 2007. [27] \nDaniel C.Wang and AndrewW. Appel. Type-preservinggarbage collectors. In POPL, January 2001.  \n\t\t\t", "proc_id": "1480881", "abstract": "<p>Garbage collectors are notoriously hard to verify, due to their low-level interaction with the underlying system and the general difficulty in reasoning about reachability in graphs. Several papers have presented verified collectors, but either the proofs were hand-written or the collectors were too simplistic to use on practical applications. In this work, we present two mechanically verified garbage collectors, both practical enough to use for real-world C# benchmarks. The collectors and their associated allocators consist of x86 assembly language instructions and macro instructions, annotated with preconditions, postconditions, invariants, and assertions. We used the Boogie verification generator and the Z3 automated theorem prover to verify this assembly language code mechanically. We provide measurements comparing the performance of the verified collector with that of the standard Bartok collectors on off-the-shelf C# benchmarks, demonstrating their competitiveness.</p>", "authors": [{"name": "Chris Hawblitzel", "author_profile_id": "81100064145", "affiliation": "Microsoft Research, Redmond, WA, USA", "person_id": "P1301033", "email_address": "", "orcid_id": ""}, {"name": "Erez Petrank", "author_profile_id": "81100377919", "affiliation": "Technion, Haifa, Israel", "person_id": "P1301034", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1480881.1480935", "year": "2009", "article_id": "1480935", "conference": "POPL", "title": "Automated verification of practical garbage collectors", "url": "http://dl.acm.org/citation.cfm?id=1480935"}