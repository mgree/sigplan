{"article_publication_date": "01-21-2009", "fulltext": "\n Modeling Abstract Types in Modules with Open Existential Types Beno\u00eet Montagu Didier R\u00e9my INRIA {Benoit.Montagu, \nDidier.Remy}@inria.fr Abstract We propose FY,a calculus of open existential types that is an ex\u00adtension \nof System F obtained by decomposing the introduction and elimination of existential types into more atomic \nconstructs. Open existential types model modular type abstraction as done in mod\u00adule systems. The static \nsemantics of FY adapts standard techniques to deal with linearity of typing contexts, its dynamic semantics \nis a small-step reduction semantics that performs extrusion of type ab\u00adstraction as needed during reduction, \nand the two are related by sub\u00adject reduction and progress lemmas. Applying the Curry-Howard isomorphism, \nFY can be also read back as a logic with the same ex\u00adpressive power as second-order logic but with more \nmodular ways of assembling partial proofs. We also extend the core calculus to handle the double vision \nproblem as well as type-level and term\u00adlevel recursion. The resulting language turns out to be a new \nfor\u00admalization of (a minor variant of) Dreyer s internal language for recursive and mixin modules. Categories \nand Subject Descriptors D.3.1 [Programming Lan\u00adguages]: Formal De.nitions and Theory Semantics; D.3.3 \n[Pro\u00adgramming Languages]: Language Constructs and Features Abstract data types, Modules; F.3.3 [Logics \nand Meanings of Programs]: Studies of Program Constructs Type structure; F.4.1 [Mathematical Logic and \nFormal Languages]: Mathematical Logic Lambda calculus and related systems. General Terms Design, Languages, \nTheory Keywords Lambda-Calculus, Modules, Type systems, Abstract types, Generativity, Existential Types, \nLinear type systems, Mod\u00adularity. 1. Introduction Modularity has always been the key to robust, manageable, \nand maintainable large software. It is even more so as the size and complexity of software keeps increasing. \nModular programming requires good discipline from programmers but also good support from programming \nlanguages. Unsurprisingly, module systems and type systems for modules have been an area of intensive \nresearch in the programming language community for more than two decades. The module system for ML, .rst \nproposed by MacQueen (12) in the mid 80 s and independently improved and simpli.ed in the Permission \nto make digital or hard copies of all or part of this work for personal or classroom use is granted without \nfee provided that copies are not made or distributed for pro.t or commercial advantage and that copies \nbear this notice and the full citation on the .rst page. To copy otherwise, to republish, to post on \nservers or to redistribute to lists, requires prior speci.c permission and/or a fee. POPL 09, January \n18 24, 2009, Savannah, Georgia, USA. Copyright c &#38;#169; 2009 ACM 978-1-60558-379-2/09/01. . . $5.00 \nmid 90 s by Harper and Lillibridge (6) and by Leroy (10), is still the one in use in all dialects of \nML, with relatively minor differences. Abstract types, higher-order functors, and sharing a posteriori,are \nkey ingredients of its expressiveness and success. However, while the successful history of the ML module \nsystem shows a relative ease of use, at least for the most frequent cases, its metatheoretical study \nhas probably been one of the most dif.\u00adcult parts of the ML language. Even with today s state-of-the-art \ntechnology, it is still usually considered involved. The discrepancy between the intuitive, perhaps misleading \nintelligibility of modules and their intricate formal description is inconveniently surprising. In earlier \nworks, abstract types were usually identi.ed with existential types. However, it has been realized in \nthe mid 80 s that existential types do not adequately model type abstraction as used in modules. Since \nthen, an abstract type has been considered as a type whose de.nition has been forgotten. Consequently, \nan abstract type cannot be referred to by how it is de.ned; instead, it is referred to by where it is \nde.ned, i.e. as a projection path from a value variable bound to the module where it is de.ned. Two decades \nlater, paths are still at the foundation of the ML-based module systems in use (11; 13; 19), and of more \nrecent designs such as Scala (16). Unfortunately, this formalization is still the source of a major dif.culty \nwith module systems: because types appear as compo\u00adnents of module expressions, abstract types, which \nare designed by paths, syntactically depend on values, which pulls into the lan\u00adguage all the complexity \nof dependent types. In fact, an important property of a module system called the phase distinction (7), \nwhich states that types should not dynamically depend on values and so ensures static typechecking and \npermits separate compilation, ap\u00adpears to be in contradiction with the use of dependent types. Hence, \na large amount of work has been dedicated to showing that dependencies used in module systems are in \nfact purely static, and that types used to formalize them are not truly dependent on values1. This restriction \nis now well understood and has been ele\u00adgantly formalized using singleton kinds (4; 22) to capture the \nab\u00adsence of dynamic dependencies. Among other bene.ts, this line of work treats type abstraction as subtyping, \nis highly expressive, and rather close to ML. Moreover, its metatheory has been formalized in Twelf (9), \nand thus mechanically veri.ed. The robustness of the approach has also been demonstrated by adapting \nthe framework to model type abstraction in a distributed setting (17). However, despite these many positive \nresults, there remain sev\u00aderal drawbacks with this approach or with the ML module sys\u00adtem. At the source \nof all dif.culties, the tension between the pres\u00adence of type components in values and the phase distinction \nis still present: in fact much of the formalism sophistication is for ensuring that types do not actually \ndepend on values. One tech\u00ad 1 There seems to be no name agreement yet on how to call this very limited \nform of dependent types. nical dif.culty, known as the avoidance problem (8), forces much more type annotations \nin source expressions than what would other\u00adwise be necessary. As a consequence, the internal calculus \nof mod\u00adules, which has a clean and standard mathematical formalization is mostly used as an internal \nlanguage for a surface language with a rather sophisticated elaboration mechanism, which therefore does \nnot inherit the properties of the internal calculus. While quite gen\u00aderal and expressive, this modeling \nof modules is perhaps further from the programmers intuitions than other aspects of the language. In \naddition, this approach does not seem to easily accommodate to recursive or mixin modules. These arguments \nare as many invitations to pursue the investi\u00adgation for .nding alternative explanations of modules. \nHopefully, it should be conceptually economical and should more closely re.ect the intuitive simplicity \nof the underlying mechanisms: our goal is not, at least in a .rst step, to increase expressiveness. Interestingly, \nin the purpose of explaining type abstraction and generativity for recursive modules and solving the \ndouble vision problem, Dreyer introduced an internal language, called RTG,as a target of the elaboration \nfor a surface language of recursive modules (2; 3). Remarkably, the elaboration process is rather simple \nand compositional, while the internal language provides neither type components nor dependent types. \nHence, although this does not seem to have been Dreyer s goal, it appears as a corollary that these two \ningredients do not seem to be necessary to model modules in an accurate and easy manner. This is a great \nmotivation to pursue investigation in this direction. A closer look at RTG shows an expressive but intriguing \nset of primitives that allows to create unde.ned type references and later assign a de.nition to them: \nnew a in M introduces a type reference named a in the scope of M that should be set at most once, with \nthe type reference update set a := t in M : t ' . Then, M and only M will see the concrete de.nition \nt for a while other parts of the program will see a abstractly. In this way, RTG can handle two views \nfor a given type variable: an abstract one, without de.nition, and a concrete one, equipped with a de.nition. \nRTG is obviously quite expressive, since it can be used to model recursive modules. However, its static \nsemantics is surprising and somewhat ad hoc: its typechecking rules use assignments in a global store \nto keep track of type de.nitions, which makes the sys\u00adtem non compositional and unnecessarily asymmetrical, \nand devi\u00adates from the traditional presentation of typing rules. The dynamic semantics of RTG is also \ngiven through an abstract machine that carries a global type store to record type assignments in an im\u00adperative \nmanner, unnecessarily enforces a deterministic evaluation order, and confuses the uses of assignment \nfor building recursive values and for modeling type abstraction. Thus, although primitives of RTG seem \nto be adequately chosen, the presentation of its static and dynamic semantics raises questions on the \nfundamental rea\u00adsons of its suitability and therefore turns RTG away from the status and potential applications \nthat it really deserves: a truly interesting calculus that could be used not only as an internal language, \nbut hopefully also as the core of a surface language in which modules could directly be programmed. Our \ngoal in this work is to give an alternate presentation of a minor variant of RTG, that attempts to improve \nits foundations and metatheoretical properties, and that hopefully gives a justi.cation for its set of \nprimitives. Thus, like RTG, our system focuses on type abstraction only: the study of other features, \nsuch as translucent signatures or sharing constraints, is deferred to future work. We .rst present core \nFY,a calculus of open existential types (\u00a72) without recursion, that is obtained by decomposing the usual \nintro\u00adduction and elimination constructs for existential types into more atomic ones. We observe that \nFY already permits modular type ab\u00adstraction, without any recursion mechanism. We use known techniques \nto deal with linearity of typing con\u00adtexts (\u00a73) instead of RTG s static effect calculus, thus keeping \na symmetric and compositional presentation (\u00a73.3). We give FY a traditional small-step reduction semantics \n(\u00a73.4) that expresses the inherent notion of sharing behind generativity through the extru\u00adsion of some \nbinder. This permits to .nely trace abstraction during reduction. The static and dynamic semantics of \nFY are related by subject reduction and progress lemmas (\u00a73.5). Thanks to the Curry-Howard isomorphism, \nFY can be read back as a logic with the same expressive power as second-order logic but with more modular \nways of assembling partial proofs (\u00a73.6), and in which the essence of ML modules can already be modeled. \nWe build a series of conservative extensions (\u00a74) on top of this core to increase its expressiveness \nwith, namely, more liberal non\u00adrecursive type de.nitions (\u00a74.1), a solution to the double vision problem \n(\u00a74.2), mutually recursive type equations (\u00a74.3), and term\u00adlevel recursion (\u00a74.4). A crucial point is \nthat these extensions are independent from each other. We end with a discussion of related work (\u00a75) \nand concluding remarks. 2. Open existential types 2.1 Abstract types as existential types Mitchell and \nPlotkin (14) showed that abstract types could be understood as existential types. However, it has also \nbeen noticed that existential types do not accurately model type abstraction in modules, because they \nlack some modular properties. In System F, existential types are introduced by the pack con\u00adstruct: provided \nthe term M has some type t '[a . t ], the expres\u00adsion pack (t, M) as .a. t ' hides the type information \nt , called the witness of the existential, from the type of M so that the resulting type is .a. t '. \nPACK G f M : t '[a . t ] '' G f pack (t, M) as .a. t : .a. t Existential types are eliminated by the \nunpack construct: pro\u00advided M has type .a. t , the expression unpack M as (a, x) in M' binds the type \nvariable a to the witness of the existential and the value variable x to the unpacked term M in the body \nof M'.The resulting type is the one of M',in which a must not appear free. The reason for this restriction \nis that otherwise a, which is bound in M', would escape its scope. UNPACK '' ' G f M : .a. t G,a,x : \nt f M: t a/. ftv(t ) '' G f unpack M as (a, x) in M: t From now on, we assume that System F is equipped \nwith records and with the above primitive constructs, although they could also be provided as a well-known \nsyntactic sugar (18). 2.2 Atomic constructs for existential types In this section we split off the constructs \nfor existential types. Indeed, both pack and unpack have modularity problems. The crucial issue with \nunpack is non-locality: it imposes the same scope to the type variable a and the value variable x,which \nis emphasized by the non-escaping condition on a. As a result, all uses of the unpacked term must be \nanticipated. In other words, the only way to make the variable a available in the whole program is to \nput unpack early enough in the program, which is a non local, hence non modular, program transformation. \nThe reason is that unpack is doing too many things at the same time: opening the existential type, binding \nthe opened value to a variable, and restricting the scope of the fresh type variable. The problem with \npack is mostly verbosity: it requires to com\u00adpletely specify the resulting type, thus duplicating type \ninformation in the parts that have not been abstracted away. This can be annoy\u00ading when hiding only a \nsmall part of a term, whereas this term has a very long type. This duplication happens, for instance, \nwhen hiding the type of a single .eld of a large record, or maybe worse, when hiding some type information \ndeeply inside a record. It is caused by the lack of separation between the introduction of an existential \nquanti.er, and the description of which parts of the type must be abstracted away under that abstract \nname. In both cases, the lack of modularity is related to the lack of atomicity of the constructs. Therefore, \nwe propose to split both of them into more atomic pieces, recovering modularity while pre\u00adserving expressiveness \nof existential types. To achieve this decom\u00adposition, we .rst need to enrich typing environments with \nnew items. 2.2.1 Richer contexts for typing judgments The contexts of typing judgments in System F are \nsequences of items, where an item is either a binding x : t from a value variable to a type, which is \nintroduced while typing functions, or a universal type variable .a, which is introduced while typing \npolymorphic expressions. We augment typing environments with two new items: existential type variables \n.a to keep track of the scope of (open) abstract types, and type de.nitions .(a = t) to concisely mediate \nbetween the abstract and concrete views of types. That is, typing environments are as follows: G ::= \ne | G,b (Environments) b ::= x : t |.a |.(a = t) |.a (Bindings) Wellformedness of typing environments \nwill ensure that no vari\u00adable is ever bound twice. We shall see below that existential vari\u00adables have \nto be treated linearly. It is sensible to consider them as Skolem s constants and to understand type \nde.nition bindings as explicit type substitutions. For the moment, we consider environ\u00adments as sequences \nmodulo reordering of independent items. Their structure will be enriched again in \u00a74.1. We de.ne the \ndomain of a binding as follows: dom(x : t) . x dom(.a) . dom(.(a = t)) . dom(.a) . a The domain of an \nenvironment is, as usual, the union of the do\u00admains of the bindings it contains. In addition, we may \nuse the fol\u00adlowing notations for speci.c domains: dom= G . {a |.(a = t) .G} dom. G . {a |.a .G} dom. \nG . {a |.a .G}  2.2.2 Splitting unpack We replace unpack with two orthogonal constructs, opening and \nrestriction, that implement scopeless unpacking of existential val\u00adues and scope restriction of abstract \ntypes, respectively. The opening open (a)M expects M to have an existential type .a. t and opens it under \nthe name a,which is tracked in the typing environment by the existential item .a. The rule can also be \nread bottom-up, treating the item .a as a linear resource that is consumed by the opening. OPEN G fM \n: .a. t G, .a fopen (a)M : t The restriction .a. M implements the non-escaping condition of Rule UNPACK. \nFirst, it requires a not to appear free in the type of M, thus enforcing a limited scope. Second, it \nprovides an existential resource .a in the environment, that ought to be consumed by some open (a)M ' \nexpression occurring within M. NU G, .a fM : t a/.ftv(t) G f.a. M : t As with RTG, one may recover unpack \nas syntactic sugar: unpack M as (a, x)in M ' . .a. (let x = open (a)M in M ' ) This makes explicit the \nsimultaneous operations performed by un\u00adpack, which turns out not to be atomic at all: .rst, it de.nes \na scope for the name a of the witness of the existential type of M; then, it opens M under the name a; \n.nally, it binds the resulting value to x in the remaining expression M ' . The main .aw of unpack, i.e. \nthe scope restriction for the abstract name, is essentially captured by the restriction construct. However, \nsince the scope restriction has been separated from the unpack, it needs not (always) be used anymore. \nThe abstract type a may now be introduced at the outermost level or given by the typing context and freely \nmade available to the whole program. 2.2.3 Splitting pack We replace pack with three orthogonal constructs: \nexistential intro\u00adduction, which creates an existential type, open witness de.nition, which introduces \na type witness and gives it a name, and coercion, which determines which parts of types are to be hidden. \nWe present this separation in two stages: .rst, we separate the (closed) de.ni\u00adtion of a witness from \nthe information of which parts are abstracted away; then, we split the de.nition of a witness again into \ntwo pieces that introduce an existential quanti.er and the witness, separately. The closed witness de.nition \n.(a = t) M introduces an exis\u00adtential type variable a with witness t (more precisely, the de.nition .(a \n= t)) in the environment while typing M, and binds a exis\u00adtentially in the resulting type. G, .(a = t) \nfM : t ' G f.(a = t) M : .a. t ' The coercion (M : t) replaces the type of M with some com\u00adpatible type \nt. The compatibility relation under context G, writ\u00adten =, is the smallest congruence that contains all \ntype-de.nitions occurring in G. A coercion is typically employed to specify where some abstract types \nshould be used instead of their witnesses in the typing of M. COERCE G fM : t ' G ft ' =t G f(M : t): \nt The expressiveness of pack is retained, since it can be provided as the following syntactic sugar: \npack (t, M)as .a. t ' . .(a = t)(M : t ' ) if a/.ftv(M) However, the description of what is being hidden \ncan now be separated from the action of hiding, which avoids repeating some type information. Hence, \nit makes the creation of existential values, shorter, thus easier, and more maintainable. Indeed, it \nallows for putting the information of hiding parts of a type deeply inside a term, like in the following \nrecord, in which some leaves have been abstracted away. .(a = int) let x = {\u00a31 =(1 : a); \u00a32 =2}in let \ny = {\u00a31 = x ; \u00a32 = x}in {\u00a31 = y ; \u00a32 = y} The corresponding System F term requires to repeat the type \nof the whole term. let z = let x ={\u00a31 =1; \u00a32 =2} in let y ={\u00a31 =x ; \u00a32 =x} in {\u00a31 =y ; \u00a32 =y} in pack \n(int,z) as .a. {\u00a31 :{\u00a31 :{\u00a31 :a ;\u00a32 :int} ;\u00a32 :{\u00a31 :a ;\u00a32 :int}} ; \u00a32 :{\u00a31 :{\u00a31 :a ;\u00a32 :int} ;\u00a32 :{\u00a31 \n:a ;\u00a32 :int}}} Moreover, whereas the information of hiding was located at a single place in the FY term, \nit is duplicated in the F term, as if each leaf of the record had been abstracted independently. To complete \nthe separation, we now split .(a =t)M further. The existential introduction .a. M introduces an existential \ntype variable in the environment while typing M,and makes a existen\u00adtially bound in the resulting type. \nThis is the exact counterpart of the open construct. EXISTS G, .a f M : t Gf.a. M : .a. t The open witness \nde.nition S(\u00df) (a = t)M introduces the witness t for the type variable a: similarly to what is done for \n.(a =t)M, the equation .(a =t)is added to the context while typing M. In addition, an external name \u00df \nis provided, in the same way as for the open construct. The internal name a and its equation are only \nreachable internally, but the witness is denoted externally by the abstract type variable \u00df. The resulting \ntype does not mention the internal name, since it has been substituted for the external one. In other \nwords, the witness de.nition de.nes a frontier between a concrete internal world and an abstract external \none. To keep the system sound, we ensure that a unique witness is hidden behind an external name, hence \nthe use of an existential resource. The typing rule will be re.ned later to handle the double vision \nproblem. SIGMA G, .(a =t)f M : t ' G, .\u00df f S(\u00df) (a =t)M : t ' [a . \u00df] Again, the split construct .(a \n=t)M can be recovered by the following syntactic sugar: .(a =t)M .\u00df. S(\u00df) (a =t)M if \u00df/. ftv(t, M) It \nis worth noting that the open witness de.nition corresponds to type abstraction as it is currently done \nin module languages: a type de.nition is kept hidden for the outer environment and a type name is generated \nso that we can refer to it without knowing its concrete de.nition. Usual existential types are recovered \nby closing the open witness de.nition, i.e. by hiding the external name for the witness. As an example, \nthe following piece of program, written in an ML-like syntax, de.nes an abstract module of integers: \nmodule X :sig type t val z :t val s :t . t end = struct type t =int val z =0 val s =.(x :int)x +1end \nIt provides the zero constant z and the successor function s.The type X.t is abstract and available in \nthe whole program. Its coun\u00adterpart in FY is de.ned hereafter: S(\u00df) (a =int) ({z =0; s =.(x :int)x +1} \n:{z :a ; s :a . a}) The two pieces of code look similar, except for the fact that the sig\u00adnature ascription \nhas been replaced with an open witness de.nition. The counterpart of the signature is the type in the \ncoercion. Note that no type component, hence no name for the module, is needed: the counterpart of X.t \nis the abstract type \u00df, which is present in the G, .(a =t ' ) f t[a . t ' ] ([ )[\u00b7] .\u00df.[\u00b7] if \u00df/. ftv(t[a \n. \u00df]) .\u00df.[\u00b7] open \u00df [\u00b7] G f.\u00df. t [a . \u00df] G f t[a . \u00df] Figure 1. Open existential constructs typing \ncontext. It is available in the whole program and does not refer to a value variable. Notice that it \nis also possible to rewrite this program in two parts, by .rst creating an existential term and then \nopening it under the name \u00df. let x = .(a =int) ({z =0; s =.(x :int)x +1} :{z :a ; s :a . a})in open (\u00df) \nx It has essentially the same effect: in fact the latter will reduce to the former. It shows however \nthat the mechanisms for type abstraction and opening of existentials are the same. 2.2.4 Generative \nfunctors Following Russo (21), generative functors are functions that have a type of the form .a. (t1 \n..\u00df. t2).In ML, generativity is im\u00adplicitly released when the functor is applied. In FY,however, the \nresult of the function must be explicitly opened, because generativ\u00adity and evaluation are two separate \nnotions. To get the same result with another fresh type, it suf.ces to open it again under another name. \n 2.2.5 A summary of the constructs for open existential types The different constructs introduced for \nopen existential types are gathered on the diagram of Fig.1, which describes their impact on both the \ntyping environment and the resulting type. To increase readability, terms are not printed on the judgments. \nThe topmost judgment corresponds to a concrete program (of type t[a . t ' ]) with an equation .(a =t \n' )in its environment. With the use of coercions one can mediate to a type t where the equation has been \nfolded and then go back to the concrete version. Then, using a S, we can make the witness abstract by \nremoving the de.nition from the typing environment and using the external name \u00df instead. In this process, \nthe variable \u00df is marked as existential and the internal name is replaced with the external one. If the \nexternal name does not occur free in the resulting type, we can remove the existential item from the \nenvironment, without changing the type, to get the bottom right judgment. If this is not the case, we \ncan close the type by transferring the existential quanti.er to the type (bottom left judgment). We can \nthen go back by re-opening the existential. 2.2.6 Linearity to control openings and open witness de.nitions \nAs openings and open witness de.nitions use abstract names given by the environment, one must be careful \nto avoid abstraction b Y b = b if b a .a Y .a = .a .a Y .a = .a = . Figure 2. Zipping of bindings (preliminary \nde.nition). capture , as in the following (ill-typed) example. let f =S (\u00df)(a = int)(.(z : int) z +1: \na .a) in let x =S (\u00df)(a = bool)(true : a) in fx Here, f and x result from two different openings under \nthe same name \u00df. Hence, f and x are assigned types \u00df .\u00df and \u00df, respectively, using the same abstract \nname \u00df. However, each branch uses a different witness for \u00df (int and bool respectively). This yields \nto the unsound application fx, which evaluates to 1+ true. To prevent abstraction capture, it suf.ces \nthat every name \u00df be used in exactly one opening or open witness de.nition under name \u00df. This may be \nachieved by treating the existential items of the typing environment in a linear way. As usual in the \nliterature, linearity can easily be enforced in typing rules by a zipping opera\u00adtion that describes how \ntyping environments of the premises must be combined to form the one of the conclusion. We give in Fig.2 \nand in this paragraph a preliminary de.nition of zipping to convey the intuition. It will be completed \nlater. Zipping is a binary opera\u00adtion (\u00b7Y \u00b7) that proceeds by zipping individual bindings pointwise. \nFor all items but existential type variables, zipping requires the two facing items to be identical, \nas usual. The interesting case is when one of the two items is an existential variable .a: the intuition \nis that, in this case, the other item must be the universal variable .a, hence the zipper image. This \nensures that an existential variable in the conclusion can only be used up in one of the premises. Zipping \ncan also be explained in terms of internal and external choice: the side that makes use of .a will make \nan internal choice by giving the witness. Therefore the other side must consider the choice of the witness \nas external, which is why it is given the item .a. Note that an equivalent presentation, using two contexts, \none of them being linear, is also feasible. However, the current presenta\u00adtion makes extensions easier \nto de.ne.  2.3 The appearance of recursive types The above idea of zipping is unfortunately too generous: \nit makes recursive types appear naturally without any control. Indeed the decomposition of unpack into \nopening and restriction opens up the way to recursive types, because it allows to use an abstract type \nvariable before its witness has been given. Recursive types can appear through type abstraction, i.e. \nthrough openings or open witness de.nitions, in two ways. We call internal recursion the .rst way, which \nis highlighted by the following example: let x = .(a = \u00df .\u00df) M in open (\u00df)x The abstract type variable \n\u00df is used in a witness to de.ne x which is then opened under the name \u00df. By reducing this expression \nwe get open (\u00df).(a = \u00df .\u00df) M, which leads us to the recursive equation \u00df = \u00df .\u00df. We call external recursion \nthe second way, which is hereafter exempli.ed: {\u00a31 =S (\u00df1)(a1 = \u00df2 .\u00df2) M1 ; \u00a32 =S (\u00df2)(a2 = \u00df1 .\u00df1) \nM2 } The above code is a pair whose components have been abstracted away and the witnesses are mutually \ndependent. If we remove the type abstractions we get the recursive equation system \u00df1 = \u00df2 . \u00df2 and \u00df2 \n= \u00df1 .\u00df1. Notice that recursive types never arise when using System F s unpack. Consider the following \npiece of code, where C1 and C2 t ::= a |t .t |{(\u00a3i : ti)i.1..n} (Types) |.a. t |.a. t M ::= x |.(x : \nt) M |MM (Terms) | let x = M in M |.a. M |Mt |{(\u00a3i = Mi)i.1..n}|M.\u00a3 |.a. M |S (\u00df)(a = t) M |(M : t) | \nopen (a)M |.a. M v ::= u |(u : t) (Values) u ::= x |.(x : t) M |.a. M (Pre-values) |{(\u00a3i = vi)i.1..n}|.\u00df. \nS (\u00df)(a = t) v w ::= v |S (\u00df)(a = t) w (Results) Figure 3. Syntax: types, terms, values, and results. \ndenote contexts: .a. C2[let x = C1[open (a)M1] in M2] If we consider this program as an unpack, then \nthe contexts C1 and C2 are empty. Consequently, a cannot occur free in C1 or C2.By splitting unpack, \nhowever, this restriction has been waived.  3. Core Fi We now present the core of our system, which \nprevents the appear\u00adance of recursive types in a simple manner. We present its semantics and show that \nits expressive power corresponds exactly to the one of System F. The translation used for this purpose \nbrings interest\u00ading insight on the gain of modularity that FY achieves. 3.1 A more restrictive zipping \nThe zipping we de.ned above is too liberal in the sense that the introduction of abstract types does \nnot follow the scope of term variables, but this can be enforced again. Hence, we de.ne a special zipping, \nwritten r , specialized for the let rule, that requires that, if G1r G2 is de.ned and if .a appears in \nG2,then .a must not appear in G1, while, if .a appears in G1,then .a should also appears in G2, as before. \nZipping for the other rules Y is symmetric and requires that if .a appears on one side, then .a must \nnot be present on the other side. This restriction easily permits to reproduce the usage of type variables \nin System F, while keeping the .exibility of our constructs. 3.2 Syntax The language FY is based on \nthe explicitly typed version of Sys\u00adtem F with records and is extended with constructs of \u00a72.2. Types \nand terms are described in Fig.3. As open existentials do not introduce new forms of types, types of \nFY are type variables, arrow types, record types, universal types, ti)i.1..n and existential types. The \nnotation (\u00a3i : stands for a sequence of n pairs, each composed of a label and a type. Type wellformedness \nis de.ned as usual. Terms of FY are variables, functions (whose arguments are ex\u00adplicitly typed), applications, \nlet-bindings, type generalizations and applications, introductions and projections of records, and the \n.ve constructs for open existentials described above: existential intro\u00adductions, open witness de.nitions, \ncoercions, openings, and restric\u00adtions. Record .elds are pairs \u00a3 = M of a label name \u00a3 and a term M. \nThe label name is used to access the .eld externally, as usual with records. For conciseness, we also \nuse the following syntactic sugar in technical developments for closed witness de.nitions : .(a = t) \nM .\u00df. S (\u00df)(a = t) M if \u00df/.ftv(t,M) We write ftv(t )(respectively ftv(M)) to denote the set of free type \nvariables of a type t (respectively a term M). 3.3 Typing rules Typing rules for open existentials have \nalready been presented in \u00a72.2. The remaining typing rules (Fig.7) are as in System F with two small \ndifferences: .rst, as mentioned above, typing rules with several typing judgments as premises use zipping \ninstead of equality to relate their typing environments. This is the case of Rules APP,LET,and RECORD. \nSecond, typing rules must also ensure that values can be substituted without breaking linearity, which \nis the case when the typing environment does not contain existential items. De.nition 1. When dom. Gis \nempty, we say that Gis pure and write Gpure. D This condition appears as an additional premise of typing \nrules of expressions that are also values (namely, Rules VAR,LAM,GEN, and EMPTY). Purity will be used \nand explained in more details in \u00a73.4. Because Rule OPEN makes the environment decrease (if it is read \nbottom-up), the property of weakening is not provable in its whole generality: one can only weaken a \njudgment by a non-linear item that does not depend on linear items. This is suf.cient for the proof of \nsoundness. A primitive weakening rule will be added when considering extensions of core FY .  3.4 Reduction \nsemantics The language FY is equipped with a small-step call-by-value re\u00adduction semantics. We begin \nwith important remarks about substi\u00adtutability, then de.ne and explain values, and .nally describe the \nreduction steps. Substitution and purity Some terms cannot be safely substituted, since substitution \nmay violate the linear treatment of openings and open witness de.nitions. It turns out that pure terms, \ni.e. terms that are typable in a pure environment, behave well with respect to substitution: Lemma 1 \n(Substitution lemma). Assume that G f M : t and ' '''' ' G,x :t, G fM : t hold, where Gis pure and Gr \nG is well '''' ' de.ned. Then (Gr G), G fM [x .M]: t also holds. Therefore, values are substitutable \nif we restrict them to pure terms. But conversely, every irreducible term is not necessarily a pure term. \nResults and values Results are well-behaved irreducible terms. Results include values. In System F (as \nin many other languages) results actually coincide with values. However, this need not be the case. In \nFY, results also include terms such as S(\u00df)(a =t ).(x : a)x, which are well-behaved and cannot be further \nreduced, but are not values, as they are not pure and thus not substitutable. More precisely, values \nare de.ned in Fig.3. They are either pre-values or coerced pre-values, where pre-values are variables, \nfunctions, generalizations, records of values or existential values. Note that nested coercions are not \nvalues they must be further reduced. Note also that no evaluation takes place under .sor .s. Finally, \nresults are values preceded by a (possibly empty) sequence of Ss. The purity premises in some of the \ntyping rules ensure that values are pure, hence, by Lemma 1, substitutable. Lemma 2 (Purity of values). \nIf Gfv : t holds, then Gis pure. Extrusions Values are substitutable, but some results are not val\u00adues, \nnamely a sequence of Ss pre.xing a value. How can we handle these results, when they ought to be substituted, \nwithout breaking let x =S(\u00df)(a =int)(1:a)in {\u00a31 =x ;\u00a32 =(.(y :\u00df)y)x} S(\u00df)(a =int) let x =(1:a)in {\u00a31 \n=x ; \u00a32 =(.(y :a)y)x} S(\u00df)(a =int){\u00a31 =(1:a); \u00a32 =(.(y :a)y)(1:a)} S(\u00df)(a =int){\u00a31 =(1:a); \u00a32 =(1:a)} \nFigure 4. Example of extrusion. linearity? Our solution is to extrude the Ss just enough to expose and \nperform the next reduction step. For example, consider the reduction steps on Fig.4. The initial expression \nis a let-binding of the form let x =w in M where w is the result form S(\u00df)(a =int)(1:a). Hence, the next \nexpected reduction step is the substitution of w for x in M. However, since x occurs twice in M, this \nwould duplicate the opening appearing in w, thus breaking the linear use of \u00df. The solution is to .rst \nextrude the S binding outside of the let-binding, so that the expression bound to x becomes the substitutable \nvalue form (1:a).However, by enlarging the scope of S, we have put M in its scope, in which the external \nname \u00df occurs. Therefore, we replace it with the internal one in the enlarged scope. Then, we may perform \nlet\u00adreduction safely and further reduce the redex that has been created. More generally, the reduction \nsemantics will be set so that Ss can always be extruded out of redex forms. Note that the separation \nof witness de.nitions from coercions (i.e. splitting pack)plays here an essential role: if the two constructs \nwere bound together, coercions should be necessarily extruded too, which would be hard to achieve in \na local manner. Here, only the witness de.nitions are extruded, while the coercions simply stay where \nthey are. Openings also introduce linear items into the environment and thus preclude substitution. Note \nhowever that they are neither part of values nor of results, because they can be eliminated: by reduc\u00adtion, \nan opening open (\u00df)M will eventually lead to an open\u00adexists pattern open (\u00df).a. M ' . This combination \njust performs a transfer of an existential resource from the inner name a to the outer one \u00df, as demonstrated \nby the following derivation: G, .a f M : t EXISTS G f.a. M : .a. t OPEN G, .\u00df fopen (\u00df).a. M : t [a .\u00df] \nTherefore, the pattern open (\u00df).a. M can simply be eliminated into a renaming from the internal to the \nexternal name M[a .\u00df]. This way, reduction makes the bottom-left cycle of Fig.1 vanish. Reduction The \nsemantics of FY is given by a call-by-value re\u00adduction strategy, described by a small-step reduction \nrelation, that does not rely on types (it is compatible with type erasure). We .x a left-to-right evaluation \norder so that the semantics is determinis\u00adtic, although we could have left the order unspeci.ed. By contrast, \nhaving a call-by-value strategy and a weak-reduction is essential. Evaluation contexts are described \nin Fig.5. Note that, as op\u00adposed to Dreyer (2), evaluation also takes place under existential bindings. \nWe de.ne the exposed type variables of a context E, written etv(E), that are either binding type variables \nor type vari\u00adables that are carried by an opening or an open witness de.nition. A one-step reduction \nis the application of a reduction rule in some evaluation context. The reduction relation is the transitive \nclosure of the one-step reduction relation. Reduction steps are sorted into four groups. Rules of the \nmain group describe the contraction of redexes. The let-reduction, the \u00df-reduction, the reduction of \ntype appli\u00adcations, and the record projection are as usual. The last rule of this group is the reduction \nof the open-exists pattern explained above. Notice that type substitution is a partial function on terms, \nbecause syntax is not stable under type substitution: for instance, let x = v in M (.(x : t) M) v (.a. \nM) t = vi)i.1..n}.\u00a3k {(\u00a3i open (\u00df).a. w E [S (\u00df)(a = t) w] S (\u00df1)(a1 = t1)S (\u00df2)(a2 = t2) w ((.(x : t0) \nM): t1 .t2) v (u : .a. t ' ) t (u : {(\u00a3i : ti)i.1..n}).\u00a3k open (a)(u : .a. t) ((u : t): t ' ) .\u00df. S (\u00df)(a \n= t) w .\u00df. S (\u00df)(a = t) w .\u00df. S (\u00df)(a = t) w M[x .v] let x = v in M M[a .t] vk w[a .\u00df] S (\u00df)(a = t) \nE [w][\u00df .a] S (\u00df1)(a1 = t1)S (\u00df2)(a2 ((.(x : t0) M)(v : t0): t2) (ut : t ' [a .t]) (u.\u00a3k : tk) (open \n(a)u : t) (u : t ' ) .\u00df. S (\u00df)(a = t) w[\u00df .a] .\u00df. S (\u00df)(a = t) w[a .t] w E ::= [\u00b7] | EM | vE | let \nx = E in M | if 1 =k =n if a/.ftv(E) and ({a, \u00df}.ftv(t)) netv(E)= \u00d8 = t2[a1 .t1]) w if a1 .ftv(t2) if \n1 =k =n if \u00df .ftv(w) if a .ftv(w) and \u00df/.ftv(w) if a,\u00df /.ftv(w) REDEX-LET REDEX-APP REDEX-INST REDEX-PROJ \nREDEX-OPEN EXTRUDE SIGMA-SIGMA COERCE-APP COERCE-INST COERCE-PROJ COERCE-OPEN COERCE-COERCE ERASE-NU-SIGMA1 \nERASE-NU-SIGMA2 ERASE-NU-SIGMA3 CONTEXT Et ' MM |{(\u00a3i |.a. E | S (\u00df)(a = t) E | (E : t) | open (a)E \n| .a.E E[M] etv([\u00b7]) = \u00d8 etv(S (\u00df)(a = t) E)= {a, \u00df}.etv(E) 9 etv(.a. E) = etv(EM) etv(ME) etv(let \nx = E in M) etv(.a. E)= {a}.etv(E) etv(Et) etv(E.\u00a3) etv((E : t)) etv(open (a)E) ; etv({(\u00a3i = Mi)i.1..k \n= E ;(\u00a3i = Mi)i.k+2..n}) ; \u00a3k+1 = vi)i.1..k = Mi)i.k+2..n}| ; \u00a3k+1 = E ;(\u00a3i E.\u00a3 ' E[M ] 9 = = etv(E) \n; Figure 5. Reduction rules (open (\u00df)M)[\u00df .t] is unde.ned. The type system ensures that type substitution \nis only performed when it is well-de.ned. The second group of rules implements the extrusion of Ss through \nevery other construct: Rule EXTRUDE permits extrusion through evaluation contexts, provided this is valid \nwith respect to scopes of (exposed) type variables. To make the exchange of two Ss possible, Rule SIGMA-SIGMA \nsubstitutes the de.nition of the outer one to delete dependencies. The third group of reduction rules \nkeeps track of coercions during reduction, as exempli.ed by Rule COERCE-APP. Notice that nested coercions \nare merged, the outer one taking priority (Rule COERCE-COERCE),whichmakesthetop-mostcycleofFig.1 vanish. \nFinally, the fourth group of rules is responsible for the erasure of restricted open witness de.nitions. \nRule ERASE-NU-SIGMA1 replaces the external name with the internal one. The role of Rule ERASE-NU-SIGMA2 \nis to replace the type variable of a witness with the witness itself: the same substitution occurs in \nSystem F while unpack-ing a pack-ed term. Finally, the restricted de.nition is erased by Rule ERASE-NU-SIGMA3. \nRemark that only Ss are extruded: every local introduction of resources by a . stays local and is eventually \neliminated. Similarly, coercions are not extruded either.  3.5 Type soundness Type soundness results \nfrom the combination of the subject re\u00adduction and progress properties. The subject reduction proof is, \nas usual, mainly built on the substitution lemma (Lemma 1) and the instantiation lemma, which comes in \ntwo forms: Lemma 3 (Instantiation by equation). Assume that G ft wf and G, .a, G ' f M : t ' hold and \nthat no free type variable of t is existentially bound in G.Then G, .(a = t), G ' fM : t ' holds. Lemma \n4 (Instantiation by substitution). Assume that G, .(a = t),G ' f M : t ' holds. Then M[a . t] is well-de.ned \nand G, G ' [a .t] fM[a .t]: t ' [a .t] holds. The proof of subject reduction itself is not really informative, \nbut it is particularly interesting that the proof is absolutely standard and almost straightforward. \nIt proceeds by induction on the reduc\u00adtion relation. Proposition 1 (Subject reduction). If G fM : t and \nMM ' , then G fM ' : t. Progress is proved by induction on the typing derivation. Proposition 2 (Progress). \nIf G f M : t and G does not contain value variable bindings, then either M is a result, or it is reducible. \nThe side condition that G does not contain any value variable is as usual. However, we cannot require \nthe more restrictive hypothe\u00adsis that G be empty, since evaluation takes place under the binders . and \n.. Moreover, this allows to consider the reduction of open programs, i.e. programs with free type variables. \nThis is the case of programs with abstract types, which come from unrestricted open\u00adings or open witness \nde.nitions. This closely corresponds to ML programs composed of modules with abstract types.  3.6 Translation \nto System F From F to FY As mentioned in \u00a72.2, the encoding of pack and unpack is unsurprisingly straightforward. \nIt preserves typing and abstraction as well as semantics: the encoding keeps the underlying untyped skeleton \nunchanged. From FY to F Conversely, it is also possible to globally reorganize everyclosedterm of FY \nso that it uses (the encodings of) pack and unpack. We sketch out this transformation that consists in \n.ve rewriting stages, which we review now: Qa ::= open (a)M | S(a)(\u00df = t)M | Qa M | MQa | Qa t | pack \n(t,Qa)as .\u00df.t ' | .\u00df.Qa | Qa.\u00a3 | open (\u00df)Qa | S(\u00df)(. = t)Qa where \u00df,. = a |{(\u00a3i = Mi)i.I ; \u00a3 = Qa ;(\u00a3j \n= Mj )j.J }| let x = M in Qa | let x = Qa in M .a.(Qa M) -(.a.Qa) M.a.let x = Qa M in M ' -.a.let y = \nQa in let x = yM in M ' .a.(MQa) -M (.a.Qa) .a.let x = MQa in M ' -.a.let y = Qa in let x = My in M \n' .a.(let x = M in Qa) -let x = M in .a. Qa Figure 6. Translation to System F (excerpts): extrusion of \nopensand Ss, intrusion of .s. 1. From the typing derivation, insert coercions around Ssand .s in order \nto get S(\u00df)(a = t ' )(M : t)and .a.(M : t). 2. Replace existential quanti.ers by uses of pack, according \nto the rule: .a.(M : t) -.a.let x = M in pack (a,x)as .a.t 3. Extrude opensand Ssusing let-bindings \n(as described by a representative set of rules on left-hand side of Fig.6) and intrude .s so that they \nget closer to each other (right-hand side of Fig.6). 4. Recover System F constructs: .a.let x =open \n(a)M in M ' -unpack M as (a,x)in M '  .a.let x =S(a)(a = t0)(M : t)in M ' -unpack (pack (t0,M[a .t0])as \n.a.t)as (a,x)in M ' 5. Finally, remove all coercions. All stages but (3) are compositional. Proposition \n3. The translation is type-preserving, abstraction\u00adpreserving and semantics-preserving. The property \nholds for each stage of the translation and each rewriting rule. Abstraction is unchanged since the scopes \nof Ssare not altered by the transformation. Semantics is preserved in the fol\u00adlowing way: the untyped \nskeleton of the image of the translation let-reduces to the skeleton of the source. Thus, while the evalu\u00adation \norder is kept unchanged, reducing the image requires more \u00df-reduction steps than reducing the source. \nThe latter point highlights the increase of modularity brought by FY over System F: it allows for organizing \nthe code more freely. The logical facet By erasing the terms from the typing rules, we can consider the \nlogic underlying core FY: not only the expressible formulas are exactly those of second-order arithmetic, \nbut also we can deduce from the translations above that the valid formulas are identical. In particular, \nFY s logic is consistent. Moreover, since the reduction steps are increased by the translation and since \nthe untyped skeletons of System F terms are terminating, the untyped skeleton of every closed program \nof FY is also terminating. In addition, the fact that the untyped skeleton of the image let-reduces to \nthe untyped skeleton of the source essentially tells us that the two pieces of program compute the same \nthings and in the same way: the translation to System F just performs a reorganization of the type derivation. \nHence, the correspondence with System F is twofold: it holds on the static as well as on the dynamic \nviewpoint, which connects FY with System F in a very tight manner. The gain of modularity brought by \ncore FY in terms of program\u00adming can be read back in terms of proofs: it allows new assembling of partial \nproofs (i.e. with abstract types), where environments are zipped when combining proof-terms. One can \nwonder what is the logical status of the typing rules we presented: Rule COERCE has the form of a subtyping \nrule with the semantics of the identity (coercions are erased by the translation); Rule EXISTS is the \nright introduction rule for the existential quanti.er; Rule OPEN is the right elimination rule; Rule \nSIGMA is a left introduction rule; Rule NU is a left elimination rule.  4. Extensions of Fi In this \nsection we consider several extensions for FY,for which soundness properties (lemmas 1 and 2) of FY extend. \n 4.1 More .exible non-recursive type equations Core FY imposed a simple but strong restriction to enforce \ntype equations to be acyclic. In this section we present a more general technique to control recursive \ntypes, by enriching the structure of typing environments in a natural way: we no longer consider them \nas sequences, i.e. totally ordered sets, but as partially ordered sets, where the order relation expresses \ndependencies between bindings and is required to be acyclic, which means that no binding can (transitively) \ndepend on itself. This disallows the zipping of two environments when this condition could not be satis.ed. \nMore speci.cally, a typing environment G is a dag represented as a pair (E,.) of a .nite set of bindings \nEand an acyclic partial order .on dom E, i.e. there exists no binding b such that dom b . dom b. We sometimes \nwrite b .b ' instead of dom b .dom b ' . If b . b ' , we say that b depends on b ' . We use the following \nnotation for composing and decomposing typing environments so that typing rules look familiar: Notation \n1. We write G1,(b -D), G2 when no binding in G1 depends on b,and b does not depend on bindings of G2,and \nD is the set of bindings b depends on. In particular, when G2 is empty, b is minimal for the dependency \nrelation. De.nition 2 (Zipping). Let G1 and G2 be two typing environments of the form (E1,.1) and (E2,.2).Let \n.be the transitive closure (.1 ..2)+.If .is acyclic, the zipping of G1 and G2, written G1 Y G2,is (E1 \nY E2,.),where E1 Y E2 is: {b1 Y b2 |b1 .E1 .b2 .E2 .dom b1 = dom b2},if E1 and E2 have the same domain. \n'' ' E Y E where E is E1 .{(.a) | (.a) .E2 .a/. 12 1 ' '' dom E1}and symmetrically for E2,when E and \nE have the same domain. 12 unde.ned otherwise. The zipping of G1 and G2 is unde.ned if .is not acyclic \nor if E1 Y E2 is unde.ned. D The second item in the de.nition of zipping extends the environ\u00adments before \nconsidering their zipping. This performs an implicit weakening on each side that re.nes the detection \nof cycles, as will be exempli.ed below. Rules SIGMA,OPEN and LET introduce new dependencies to keep track \nof cycles. We review them now. SIGMA '' ' G,(.(a = t )-D) fM : t D .D G,(.\u00df -D) fS(\u00df)(a = t ' )M : t[\u00df \n.a] Unsurprisingly, Rule SIGMA speci.es that the external name has at least all dependencies of the internal \nname, among which lay the (dependencies of the) free type variables of the witness. This prevents the \nexample of external recursion seen in \u00a72.3, which we LET VAR Gpure G1 fM1 : t2 .t dom. G1 ndom. G2 .D \nGpure Gfok G, (x : t1 -D) fM : t2 G2 fM2 : t2 G1 fM1 : t1 G2, (x :t1 -D) fM2 : t2 LAM APP G fx :G(x)Gf.(x \n: t1)M : t1 .t2 G1 Y G2 fM1 M2 : t G1 Y G2 flet x =M1 in M2 : t2 GEN INST EMPTY Gpure Gft wf Gpure RECORD \n ' i.1..n i.1..n G, (.a -D) fM : t G fM : .a. t Gfok (Gi fMi : ti)injective (i .\u00a3i) ' i.1..ni.1..n Gf.a. \nM : .a. t GfMt : t [a .t]Gf{} : {} G1 Y \u00b7\u00b7\u00b7Y Gn f{(\u00a3i =Mi)} : {(\u00a3i :ti)} PROJ COERCE SIGMA ' '' 1 =k \n=n G ft =t D\\({\u00df}.dom G).D,if .is = EXISTS GfM : {(\u00a3i : ti)i.1..n' ''' } G, (.a -D)fM : t GfM : t G, \n(.\u00df -D), G , (.(a<\u00df .t )-D)fM : t GfM.\u00a3k : tk Gf.a. M : .a. t Gf(M : t): t G, (.\u00df -D), G ' fS(\u00df)(a .t \n' )M : t[a .\u00df] NU WEAKEN SIM OPEN a/.ftv(t)G ' l GGft< t ' FIX G fM : .a. t G, (.a -D) fM : t GfM : t \nGfM : t ' G, (x : t -D)fs : t G, (.a -dom G\\dom. G)fopen (a)M : t G f.a. M : t G ' fM : t GfM : t Gf\u00b5(x \n:t)s : t Figure 7. Typing rules of the extended system recall below, to be well-typed: {\u00a31 =S(\u00df1)(a1 \n=\u00df2 .\u00df2)M1 ; \u00a32 =S(\u00df2)(a2 =\u00df1 .\u00df1)M2 } The dependency \u00df1 .\u00df2 is required to type the .rst component, \nsince the witness depends on \u00df2. Symmetrically, \u00df2 .\u00df1 is also required to type the second component. \nConsequently, the zipping is forbidden because of the obvious cycle. As opposed to the case of Rule SIGMA, \nthe witness is unknown in the open construct. Hence, the condition placed on Rule OPEN is stronger: the \nabstract type variable (possibly) depends on every type variable present in the context, except on type \nde.nitions since these are only indirections: it is unnecessary to track dependen\u00adcies on internal names \nsince they are always included in the depen\u00addencies of the external names, as described by Rule SIGMA. \nCon\u00adversely, taking dependencies on internal names into account would be too coarse and impede subject \nreduction, since a consequence of extrusions is the expansion of the scope of internal names. OPEN G \nfM : .a. t G, (.a -dom G\\dom= G)fopen (a)M : t As a result, the above example would again be rejected \nif the Ss were replaced with open-exists patterns. By contrast, the following example is well-typed, \nsince the witness of the .rst branch does not depend on \u00df2. {\u00a31 =S(\u00df1)(a1 =int)M1 ; \u00a32 =S(\u00df2)(a2 =\u00df1 \n.\u00df1)M2 } Rewriting this piece of code with open-exists patterns is again well-typed, in spite of the \nstronger condition on Rule OPEN, thanks to the implicit weakening in zipping: we can type the .rst branch \nwithout using .\u00df2 in the environment (provided M1 does not mention \u00df2). Therefore, the requirement \u00df1 \n.\u00df2 is not required in the .rst branch and no cycle is detected. Finally, Rule LET (see Fig.7) highlights \nvariables that are used, hence possibly hidden in an existential value, in the .rst branch of the let \nand used in an opening in the second branch. Therefore, the value variable that is bound in the let must \ndepend on these variables. These are indeed responsible for the cycle in the example of internal recursion \nseen in \u00a72.3 and reminded below: let x =.(a =\u00df .\u00df)M in open (\u00df)x The binding .\u00df is required in the typing \nenvironment of the bound expression, whereas the binding .\u00df appears in the typing environ\u00adment for the \nbody. Thus, the constraint x . \u00df is required in the typing environment of the body, which prevents typing \nopen(\u00df)x, as Rule OPEN requests that .\u00df must be minimal in the dependency relation.  4.2 Addressing \nthe double vision problem De.ning an expression that manipulates an abstract type before its witness \nhas been given is sometimes desirable, as it brings more freedom in the code structure. It may also become \nnecessary when building recursive values. Currently, the following term is considered as ill-typed: .\u00df. \nlet f =.(x :\u00df)x in S(\u00df)(a =int)(1:a) This is because Rule SIGMA (see \u00a72.2.3) does not let the external \nname \u00df visible in its premise. It is easy to correct this by leaving a .\u00df in the premise instead of .\u00df \n(see below). However, the following piece of code would still be rejected: .\u00df. let f =.(x : \u00df)x in S(\u00df)(a \n=int)f (1: a) After the existential resource \u00df is introduced, it de.nes f as the identity on \u00df and then \nuses f in the context of the open witness de.nition S(\u00df)(a =int). However, we do not know that a and \n\u00df denote the same witness: the application f (1:a)is ill-typed. This is called the double vision problem: \nit characterizes the in\u00adability to maintain a link between the internal and external view of a given \ntype. This problem is well-known in the study of recur\u00adsive modules, but as we can see it already happens \nin the absence of recursion. To solve this problem, is suf.ces to carry the missing information in the \ncontext (for clarity, dependencies are omitted): SIGMA G, .\u00df, G ' , .(a<\u00df =t ' )fM : t G, .\u00df, G ' fS(\u00df)(a \n=t ' )M : t[a .\u00df] The typing environment is enriched with a new kind of equation .(a<\u00df=t ' ), which says \nthat the witness t ' is denoted by the internal name a, and, in addition, that the external name \u00df can \nbe viewed internally as a. This is realized through the use of the similarity relation de.ned under a \ncontext G and written < that satis.es all the equalities between internal and external names that are \npresent in the context G. It is used through Rule SIM (Fig. 7). The reader may wonder why the authors \ndecided to use both an external and an internal name, while they denote the same object, instead of using \nonly one name as done in RTG where a single type reference is used along with two scopes, only one of \nwhich contains a type de.nition. We give two reasons for handling two names and an equation relating \nthem: .rst, it corresponds to practice in recursive modules, where a single type component is reached \nthrough two different paths, which leads to the double vision problem. Second, the use of two names makes \nprograms more maintainable in the sense that it is more respectful to the notion of interface: whatever \nis the internal name, the external name will always be the same. Thus, one can apply an internal renaming \nwithout changing the external type. 4.3 Extending FY with type-level recursion Extended non-recursive \ntype de.nitions lead to a .ner type check\u00ading but do not require a change in the semantics. By contrast, \nper\u00admitting recursive type de.nitions has the reverse effect: typing is unchanged, but semantics must \nbe adapted. We extend the type al\u00adgebra with a .xpoint and specify with the use of the symbol in\u00adstead \nof = when a type equation is allowed to contribute to a cycle. Wellformedness ensures that recursive \ntypes are contractive. ::= = | M ::= ... |S (\u00df)(a t) M t ::= ... |\u00b5a.t w ::= ... |S (\u00df)(a t) w We also \nextend the type compatibility relation with the usual un\u00adfolding rule for recursive types (see Fig.12) \nand consider that type compatibility is co-inductively de.ned. We add the following rules to the reduction \nrelation: ' t ' S (\u00df)(a t)S (\u00df ' )(a ) w S (\u00df ' )(a ' t ' [a .\u00df]) S (\u00df)(a t) w ' '' i.I .\u00df.S (\u00df )(a t \n' )(S (\u00dfi)(ai ti))v ' '' '' .\u00df.S (\u00df )(a = close(a <\u00df t ' ,(ai <\u00dfi ti)i.I )) (S (\u00dfi)(ai ti))i.I v where \n.stands for . or . When two Ss have to be exchanged, it is no longer possible to substitute the .rst \nwitness into the second one for wellformedness reasons. Instead, we replace the .rst internal name with \nthe exter\u00adnal one during swapping, as described by the .rst reduction rule. It should be applied when \nneeded, to put a S closer to its correspond\u00ading . or ., when there is one, so that the second rule can \napply. The second rule speci.es that a closed or restricted, potentially recursive type de.nition can \nbe resolved into a non-recursive one, that involves a recursive witness. To do this, the close operator, \nthat is de.ned in Fig.8, gathers the other witnesses and ties the recursive knot. Thanks to co-induction, \nthe provable equalities are unchanged. The reduction below exempli.es the closure operation: .\u00df1.S (\u00df1)(a1 \na1 \u00d7\u00df2)S (\u00df2)(a2 a1 \u00d7a2) v .\u00df1.S (\u00df1)(a1 = t)S (\u00df2)(a2 a1 \u00d7a2) v S (\u00df2)(a2 t \u00d7a2) .\u00df1.S (\u00df1)(a1 = t) \nv S (\u00df2)(a2 t \u00d7a2) v[a1 .t] where t = close(a1 <\u00df1 a1 \u00d7\u00df2,a2 <\u00df2 a1 \u00d7a2) = \u00b5a1.(a1 \u00d7\u00b5a2.(a1 \u00d7a2)) The \nterm we consider contains two mutually recursive type de.ni\u00adtions, and the external name \u00df1 of the .rst \none is restricted. The close operator computes the closed witness t, which becomes the new, recursive \nwitness of \u00df1, de.ned by a non-recursive equation. Then, the innermost S can be extruded, and the restricted \nequation is eventually eliminated. By de.nition, this semantics ensures that only equations that are \nmarked as potentially recursive may actually create recursive types during reduction. Type soundness \nensures that this is suf.cient to reduce well-typed programs, i.e. that recursive types are never needed \nin other con.gurations. Hence, although abstract types can be used in a .exible manner, the risk of inadvertently \nusing recur\u00adsive types via type abstraction can be tracked by the type system and tightly tuned by the \nuser. It is also interesting that mutually recursive equations are ex\u00adplicitly resolved during reduction, \nand moreover in a standard way. 4.4 Extending FY with term-level recursion In this section, we extend \nFY with recursive values \u00b5(x:t) v,which are necessary to de.ne recursive modules. Although it is possible \nto use the well-known backpatching se\u00admantics for .xpoints, we prefer a storeless, unrolling-based seman\u00adtics, \nso as to avoid the need for references. Our unrolling semantics lies between the backpatching semantics, \nwhich computes recur\u00adsive values at their creation and fails if they are ill-founded, and the lazy semantics, \nwhich unfolds recursive values only at their use. As the former we evaluate recursive de.nitions at their \ncreation, by letting evaluation proceed under .xpoints, but without unrolling them. Instead, .xpoints \nare unrolled on demand when they need to be destructed, as with the lazy semantics. (Ill-founded recursion \nmay thus loop at its use instead of its creation, as with the lazy semantics.) The two aspects of our \nsemantics are captured by the form of evaluation contexts and the following reduction rule, re\u00adspectively: \nE ::= ... | \u00b5(x: t) E R[\u00b5(x: t) v] R[let x = \u00b5(x: t) v in v] where R is a redex-form, that is, an application \n[\u00b7] v, an instantia\u00adtion [\u00b7] t, a projection [\u00b7].\u00a3, or an opening open (a)[\u00b7]. In order to enable unrolling, \none must ensure that reducing un\u00adder .xpoints and extruding Ss always give rise to a value, because impure \nresults cannot be substituted. For this purpose, we restrict the body of .xpoints to be extended results, \ndenoted by s, which are either results or themselves records, let-bindings, or projections of extended \nresults. M ::= ... | \u00b5(x: t) s u ::= ... | \u00b5(x: t) v | x.\u00a31 \u00b7\u00b7\u00b7.\u00a3n s ::= w | let x = s in s |{(\u00a3i = si)i}| \ns.\u00a3 Pre-values are extended with both .xpoints of values and (possibly empty) sequences of projections \nof variables. Soundness properties are straightforwardly preserved by this extension. In conclusion, \nadding term-level recursion to FY is not an issue. Indeed, this is a direct consequence of the modularity \nof FY s constructs. Moreover, our approach permits to keep a standard style of presentation: it uses \nevaluation contexts, and avoids using references to model recursion.  5. Related work Russo (21) justi.es \nthe meaninglessness of dependent types for modules, by interpreting modules and signatures into semantic \nobjects with System F types. He also uses existential quanti.ers to track type generativity. It seems \nhowever that his existential types are implicitly opened and automatically extruded. Unfortunately, the \ndynamic semantics of semantic objects is not described. In the context of run-time type inspection, Rossberg \n(20) intro\u00adduces .N, a version of System F with a construct to de.ne abstract types and a mechanism of \ndirected coercions. His abstract types can be automatically extruded to allow sharper type analysis, \nand are thus close to our S binder. His coercions resemble ours, though i.I '' ' i.I close(a<\u00df = t) \nt close((ai <\u00dfii ti),a <\u00df = t ' ) close((ai <\u00dfii ti[\u00df . t ' ])) i.I '' '''' i.I close(a<\u00df t) \u00b5a.t[\u00df \n. a] close((ai <\u00dfii ti),a <\u00df t ' ) close((ai <\u00dfii ti[\u00df . \u00b5a .t ' [\u00df . a ]])) Figure 8. Closing mutually \nrecursive type equations ours are symmetric, because they never cross the abstraction bar\u00adrier. Although \nboth systems seem kindred in spirit, they are subtly different, because they have been designed for quite \ndifferent pur\u00adposes: in particular, .N is only partially related to traditional exis\u00adtential types, since \nparametricity is purposely violated. In spite of strong similarities, some deep technical differences \nremain between RTG and FY. The treatment of the linear resources differs signi.cantly: RTG s semantics \nemploys a type store to model static but imperative type reference updates, whereas we just use extrusions \nof S binders. These two approaches might be related by seeing our extrusion as a local treatment of his \ntype store, as has already been proposed for value references (23). Dreyer uses assignment in a global \nstore to guarantee the uniqueness of writ\u00ading: this exposes the evaluation order in the typing rules \nof RTG and makes them asymmetrical, moving away from a logical spec\u00adi.cation, whereas we zip contexts \nto enforce sound openings and maintain a close correspondence with logic. Intuitively, we think of existential \nvalues as generating a fresh type when opened, while he considers them as functions in destination passing \nstyle (DPS). Despite these strong technical differences, the two systems have similar constructs: the \nnew primitive is similar to our . binder; the set a := t in M is related to the S (a) (a = t) M con\u00adstruct. \nNote the use of a single type name here (as mentioned in \u00a74.2). The two systems differ a little more \nin other constructs. In a. RTG, the creation of an impure function of type t1 - .t2, whose body de.nes \na witness for a type variable a, is always pre.xed by the DPS construct, namely the generalization by \na writable type variable .a.K.M. The former is useful to write typical examples of recursive modules \nand allows for their separate compilation. However, this construct taken alone would have to be treated \nlin\u00adearly, which would require the introduction of linearity in types, and would raise type wellformedness \nissues with respect to type substitution. Hence, the two constructs are combined into a single form. \nIt is said that a term with type .a.K.t can be understood as a. aDPS function of type .a.K.()- .t. In \nother words, an existen\u00adtial value is a term where the assignment for the witness is frozen. This implies, \nhowever, that the body of a DPS function, hence the body of an existential term, is not evaluated. One \ncould argue that it would suf.ce to prede.ne the body with a let-binding, so that it is evaluated, but \nthis is not always feasible since the body can depend itself on the type variable a. By contrast, FY \ndisallows the de.\u00adnition of impure functions, but the existential introduction .a.M correspondsto RTG \nstypevariablegeneralization .a.K.M taken alone. However, evaluation does take place under existential \nquan\u00adti.ers in FY. To make it possible, our local management of exis\u00adtential resources and their elimination \nis of primordial importance. The approach followed in RTG treats type abstraction as a side ef\u00adfect and \ntherefore correlates type abstraction with evaluation. To our point of view, the two must be separated, \nand FY demonstrates that this is achievable. Moreover, it leads to a .ner semantics. Flatt and Felleisen \n(5) introduced constraints within signatures to track dependencies, whereas we used constraints only \nin envi\u00adronments, thus enabling a natural generalization of their structure.  Concluding remarks We \nde.ned core FY, a variant of explicitly-typed System F with primitive open existential types that generalize \nthe usual notion of (closed) existential types by splitting their creation and elimination into more \natomic constructs. The subject reduction and progress theorems hold for FY and have routine proofs. We \nshowed how openings of existential values and open witness de.nitions tightly correspond to type abstraction \nand generativity in modules. More importantly, we highlighted that type abstraction and generativity \nshould and can be separated from evaluation, and need not be explained as a side effect. Instead, the \nmechanism of extrusion plays a central role. We exhibited a tight correspondence between core FY and \nSys\u00adtem F: it has exactly the same expressive power, but allows to write programs more modularly. This \ngives strong theoretical founda\u00adtions to FY and, by extension, to RTG. The language FY handles liberal \nnon-recursive type de.nitions, gives a solution to the double vision problem, and allows mutually recursive \nequations as well as recursive values. We believe that FY is promising as the core of a programming language \nwith .rst-class modules. The bare simplicity of the no\u00adtions FY is based on is its best asset. It would \nbe interesting to di\u00adrectly integrate our approach in existing works on mixin modules. We limited FY \nto the de.nition of pure functions to keep the system simple enough: impure functions would indeed need \nto be treated linearly and would certainly introduce dependencies constraints into types. Yet, this extension \nis worth considering: it would make the system more canonical and would correlate functions with contexts \nas it is usually the case. For instance we could recover let-binding as a derived construct. In addition, \nit would permit to re-explore the duality between existentials and universals that is already visible \nin the typing rules. Among future work remains the study of representation inde\u00adpendence properties, \nas well as the integration of programming fea\u00adtures such as higher-order types or value references. Higher-order \ntypes are motivated by Russo s work on applicative functors. This work only realizes the .rst half of \nour project of de.n\u00ading a core calculus for a module language with simple and log\u00adical foundations. Indeed, \nFY still misses a signi.cant, orthogonal ingredient to scale up: a path system must complete it, that \nwould permit to write compact programs and overcome the diamond im\u00adport problem. This second half, already \nbrie.y introduced in an earlier work (15), will be developed independently in another pa\u00adper. Of course, \nsome form of type inference will eventually be needed in a surface language based on FY.Aneasysolutionis \nto stratify the type system, just for the purpose of type inference. We could infer ML-like types for \nthe base level and require explicit type information for the module level, as for ML. Another more ambitious \ndirection is to use a form of partial type inference with .rst-class polymorphism. Acknowledgments The \nauthors would like to thank Paul-Andr\u00e9 Melli\u00e8s, Fran\u00e7ois Pottier and Robert Harper for fruitful discussions, \nand anonymous referees for their helpful comments on earlier versions of this paper. References [1] \nLuca Cardelli and Xavier Leroy. Abstract types and the dot notation. In M. Broy and C.B.Jones, editors, \nProceedings IFIP TC2 working conference on programming concepts and methods, pages 479 504. North-Holland, \n1990. [2] Derek Dreyer. Recursive type generativity. Journal of Functional Programming, pages 433 471, \n2007. [3] Derek Dreyer. A type system for recursive modules. In Proceedings of ACM SIGPLAN International \nConference on Functional Program\u00adming, pages 289 302, 2007. [4] Derek Dreyer, Karl Crary, and Robert \nHarper. A type system for higher-order modules. In Proceedings of ACM SIGPLAN Symposium on Principles \nof Programming Languages, pages 236 249, 2003. [5] Matthew Flatt and Matthias Felleisen. Units: Cool \nmodules for hot lan\u00adguages. In Proceedings of ACM SIGPLAN Conference on Program\u00adming Language Design \nand Implementation, pages 236 248, 1998. [6] Robert Harper and Mark Lillibridge. A type-theoretic approach \nto higher-order modules with sharing. In Proceedings of ACM SIGPLAN Symposium on Principles of Programming \nLanguages, pages 123 137, New York, NY, USA, 1994. ACM. [7] Robert Harper, John C. Mitchell, and Eugenio \nMoggi. Higher-order modules and the phase distinction. In Proceedings of ACM SIGPLAN Symposium on Principles \nof Programming Languages, pages 341 354, San Francisco, CA, January 1990. [8] Robert Harper and Benjamin \nC. Pierce. Design considerations for ML\u00adstyle module systems. In Benjamin C. Pierce, editor, Advanced \nTopics in Types and Programming Languages, chapter 8, pages 293 345. The MIT Press, 2005. [9] Daniel \nK. Lee, Karl Crary, and Robert Harper. Towards a mechanized metatheory of Standard ML. SIGPLAN Not., \n42(1):173 184, 2007. [10] Xavier Leroy. A syntactic theory of type generativity and sharing. Journal \nof Functional Programming, 6(5):667 698, 1996. [11] Xavier Leroy, Damien Doligez, Jacques Garrigue, Didier \nR\u00e9my, and J\u00e9r\u00f4me Vouillon. The Objective Caml system release 3.10.INRIA, May 2007. [12] David MacQueen. \nModules for Standard ML. In ACM Symposium on LISP and functional programming, pages 198 207, New York, \nNY, USA, 1984. ACM. [13] Robin Milner, Mads Tofte, Robert Harper, and David MacQueen. The De.nition of \nStandard ML (Revised). The MIT Press, May 1997. [14] John C. Mitchell and Gordon D. Plotkin. Abstract \ntypes have existen\u00adtial type. ACM Trans. Program. Lang. Syst., 10(3):470 502, 1988. [15] Beno\u00eet Montagu \nand Didier R\u00e9my. Towards a simpler account of modules and generativity: Abstract types have Open existen\u00adtial \ntypes. Available at http://gallium.inria.fr/~remy/ modules/, March 2008. [16] Martin Odersky, Vincent \nCremet, Christine R\u00f6ckl, and Matthias Zenger. A nominal theory of objects with dependent types. In Pro\u00adceedings \nof European Conference on Object-Oriented Programming, pages 201 224, 2003. [17] Gilles Peskine. Abstract \ntypes in collaborative programs. PhD thesis, Universit\u00e9 Paris VII Denis Diderot, June 2008. [18] John \nC. Reynolds. Types, abstraction and parametric polymorphism. In Information Processing 83, pages 513 \n523. Elsevier Science, 1983. [19] Sergei Romanenko, Claudio Russo, and Peter Sestoft. Moscow ML Owner \ns Manual, June 2000. [20] Andreas Rossberg. Generativity and dynamic opacity for abstract types. In Proceedings \nof ACM SIGPLAN International Conference on Principles and Practice of Declarative Programming, pages \n241 252, Uppsala, Sweden, September 2003. [21] Claudio V. Russo. Types for modules. Electronic Notes \nin Theoretical Computer Science, 60, January 2003. [22] Christopher A. Stone and Robert Harper. Deciding \ntype equivalence in a language with singleton kinds. In Proceedings of ACM SIGPLAN International Conference \non Principles and Practice of Declarative Programming, pages 214 227, Boston, January 2000. [23] Andrew \nK. Wright and Matthias Felleisen. A syntactic approach to type soundness. Information and Computation, \n115(1):38 94, 1994. ENTAIL-BINDING ENTAIL-REFL ENTAIL-TRANS b = .a G fok G1 l G2 G2 l G3 G, (b -D) fok \nG l G G1 l G3 G, (b -D) l G Figure 9. Entailment of environments OK-VAR OK-EXISTS ftv(t ) .D.dom G D.dom \nG G ft wf x/.dom GG fok a/.dom G G, (x : t -D) fok G, (.a -D) fok OK-EQ OK-FORALL ftv(t ) .D.dom G D.dom \nG G ft wf a/.dom G \u00df/.ftv(t )G fok a/.dom G G, (.(a<\u00df = t ) -D{\u00df}) fok G, (.a -D) fok OK-EQREC ftv(\u00b5a. \nt ) .D.dom G OK-EMPTY G f\u00b5a. t wf \u00df/.ftv(t ) G, (.(a<\u00df t ) -D{a, \u00df}) fok e fok Figure 10. Wellformed \nenvironments WF-VAR WF-ARROW G fok a .dom GG ft1 wf G ft2 wf G fa wf G ft1 .t2 wf WF-RECORD i.1..n injective \n(i .\u00a3i) WF-EMPTY WF-FORALL i.1..n (G fti wf)G fok G, (.a -D) ft wf i.1..n G f{(\u00a3i : ti)}wf G f{}wf G \nf.a. t wf WF-MU WF-EXISTS \u00b5a. t contractive G, (.a -D) ft wf G, (.a -D) ft wf G f.a. t wf G f\u00b5a. t wf \nFigure 11. Wellformed types EQ-REFL G ft wf G ft =t EQ-EQ-LEFT G ft [a .t '' ] =t ' .(a< \u00df t '' ) .G \nG ft =t ' EQ-EQ-RIGHT G ft =t ' [a .t '' ] .(a< \u00df t '' ) .G G ft =t ' EQ-FIX-LEFT EQ-FIX-RIGHT G ft \n[a .\u00b5a. t ] =t ' G ft ' =t [a .\u00b5a. t ] G f\u00b5a. t =t ' G ft ' =\u00b5a. t (Rules for congruence are omitted.) \nFigure 12. Compatible types (co-inductive de.nition) SIM-REFL SIM-EQ G fok G fok SIM-EMPTY a .dom G .(a<\u00df \nt ) .GG fok G fa<a G fa<\u00df G f{} < {} (Rules for transitivity and congruence are omitted.) Figure 13. \nSimilar types  \n\t\t\t", "proc_id": "1480881", "abstract": "<p>We propose F-zip, a calculus of open existential types that is an extension of System F obtained by decomposing the introduction and elimination of existential types into more atomic constructs. Open existential types model modular type abstraction as done in module systems. The static semantics of F-zip adapts standard techniques to deal with linearity of typing contexts, its dynamic semantics is a small-step reduction semantics that performs extrusion of type abstraction as needed during reduction, and the two are related by subject reduction and progress lemmas. Applying the Curry-Howard isomorphism, F-zip can be also read back as a logic with the same expressive power as second-order logic but with more modular ways of assembling partial proofs. We also extend the core calculus to handle the double vision problem as well as type-level and term-level recursion. The resulting language turns out to be a new formalization of (a minor variant of) Dreyer's internal language for recursive and mixin modules.</p>", "authors": [{"name": "Beno&#238;t Montagu", "author_profile_id": "81392616543", "affiliation": "INRIA, Paris, France", "person_id": "P1301014", "email_address": "", "orcid_id": ""}, {"name": "Didier R&#233;my", "author_profile_id": "81100311096", "affiliation": "INRIA, Paris, France", "person_id": "P1301015", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1480881.1480926", "year": "2009", "article_id": "1480926", "conference": "POPL", "title": "Modeling abstract types in modules with open existential types", "url": "http://dl.acm.org/citation.cfm?id=1480926"}