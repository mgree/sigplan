{"article_publication_date": "01-21-2009", "fulltext": "\n Verifying Liveness for Asynchronous Programs * Pierre Ganty Rupak Majumdar Andrey Rybalchenko CS Department, \nUniversity of California, CS Department, University of California, Max Planck Institute for Software \nLos Angeles, CA, USA Los Angeles, CA, USA System, Germany pganty s.ula.edu rupak s.ula.edu rybal mpi-sws.mpg.de \n Abstract Asynchronous or event-driven programming is a popular tech\u00adnique to ef.ciently and .exibly \nmanage concurrent interactions. In these programs, the programmer can post tasks that get stored in a \ntask buffer and get executed atomically by a non-preemptive sched\u00aduler at a future point. We give a decision \nprocedure for the fair termination property of asynchronous programs. The fair termina\u00adtion problem asks, \ngiven an asynchronous program and a fairness condition on its executions, does the program always terminate \non fair executions? The fairness assumptions rule out certain unde\u00adsired bad behaviors, such as where \nthe scheduler ignores a set of posted tasks forever, or where a non-deterministic branch is always chosen \nin one direction. Since every liveness property reduces to a fair termination property, our decision \nprocedure extends to live\u00adness properties of asynchronous programs. Our decision procedure for the fair \ntermination of asynchronous programs assumes all variables are .nite-state. Even though vari\u00adables are \n.nite-state, asynchronous programs can have an un\u00adbounded stack from recursive calls made by tasks, as \nwell as an unbounded task buffer of pending tasks. We show a reduction from the fair termination problem \nfor asynchronous programs to fair ter\u00admination problems on Petri Nets, and our main technical result \nis a reduction of the latter problem to Presburger satis.ability. Our de\u00adcidability result is in contrast \nto multi-threaded recursive programs, for which liveness properties are undecidable. While we focus on \nfair termination, we show our reduction to Petri Nets can be used to prove related properties such as \nfair non\u00adstarvation (every posted task is eventually executed) and safety properties such as boundedness \n(.nd a bound on the maximum number of posted tasks that can be in the task buffer at any point). Categories \nand Subject Descriptors: D.2.4 [Software Engineer\u00ading]: Software/Program Veri.cation. General Terms: \nLanguages, Veri.cation, Reliability. Keywords: asynchronous (event-driven) programming, liveness, fair \ntermination, Petri Nets. * This research was sponsored in part by the NSF grants CCF-0546170, CCF-0702743, \nCNS-0720881, and by Microsoft Research through the Eu\u00adropean Fellowship Programme. Permission to make \ndigital or hard copies of all or part of this work for personal or classroom use is granted without fee \nprovided that copies are not made or distributed for pro.t or commercial advantage and that copies bear \nthis notice and the full citation on the .rst page. To copy otherwise, to republish, to post on servers \nor to redistribute to lists, requires prior speci.c permission and/or a fee. POPL 09, January 18 24, \n2009, Savannah, Georgia, USA. Copyright c &#38;#169; 2009 ACM 978-1-60558-379-2/09/01. . . $5.00 1. Introduction \nAsynchronous programming is a ubiquitous idiom to manage con\u00adcurrent interactions with the environment \nwith low overhead. In this style of programming, rather than waiting for a time-consuming operation to \ncomplete, the programmer can post asynchronous pro\u00adcedure calls which are stored in a task buffer for \nlater execution, instead of being executed right away. In addition, the programmer can also make the \nusual synchronous procedure calls where the caller blocks until the callee .nishes. A co-operative scheduler \nre\u00adpeatedly picks posted calls from the task buffer and executes them atomically to completion. Execution \nof the posted calls can lead to further calls being posted. The interleaving of different picks\u00adand-executes \n(a pick-and-execute is often referred to as a dispatch) hides latency in the system. Asynchronous programming \nhas been used to build fast servers and routers [23, 13], embedded systems and sensor networks [8], and \nforms the basis of web programming using Ajax. Writing correct asynchronous programs is hard. The loose \ncou\u00adpling between asynchronous calls obscures the control and data .ow, and makes it harder to reason \nabout them. The program\u00admer must keep track of concurrent interactions, manage data .ow between asynchronously \nposted calls (including saving and pass\u00ading appropriate state between calls), and ensure progress. Since \nthe scheduling and resource management is co-operative and per\u00adformed by the programmer, one mis-behaving \nprocedure (e.g., one that does not terminate, or takes up too many system resources) can bring down the \nentire system. In this paper, we focus on verifying liveness properties of asyn\u00adchronous programs. Informally, \nliveness properties specify that something good eventually happens, and can be used to specify progress \nproperties such as every posted call eventually gets dis\u00adpatched. Speci.cally, we develop algorithms \nto check that an asyn\u00adchronous program terminates under certain fairness constraints on the scheduler \nand external events. We call this the fair termination problem. The fairness conditions on the scheduler \nrule out certain undesired paths, in which for example the scheduler postpones for\u00adever some posted task. \nIt is known that general liveness properties can be reduced to checking fair termination [35]. In the \nfollowing, we restrict attention to asynchronous programs in which the data ranges over a .nite domain \nof values. The .nite\u00adness assumption on the data is necessary, since fair termination is already undecidable \nfor 2-counter machines [22]. However, we do not restrict the depth of the stack or the size of the task \nbuffer which could both be unbounded. For sequential programs with synchronous calls, there has been \na lot of work in automatic techniques to proving fair termination [20, 15, 30, 21]. It seems natural \nthat one can reduce reasoning about asynchronous programs to reasoning about synchronous pro\u00adgrams by \nexplicitly modeling the task buffer and the scheduling. For example, we can add a counter representing \nthe number of pending instances for each procedure, increment the appropriate counter at each post, and \nmodel the scheduler as a dispatch loop which picks a non-zero counter, decrements it, and executes the \ncorresponding procedure. While the reduction is sound, applying sequential fair termination checking \non this sequential program is not guaranteed to be complete (i.e., terminate with the correct an\u00adswer \non all inputs), since checking termination for programs with integer counters is undecidable in general. \nThe dif.culty arises be\u00adcause the number of pending calls in the task buffer (a call is pend\u00ading if it \nhas been posted but not yet picked), and hence the counters, can grow unboundedly large. Our main result \nis that fair termination is decidable for asyn\u00adchronous programs. This is unlike the case for multi-threaded \nprograms communicating through shared variables, for which the problem is undecidable [27]. Our decidability \nproof uses constructions on Petri Nets [28] (an in.nite state concurrency model with many decidable properties), \nvia some language-theoretic reductions. As noted in [2, 11, 32], we use the fact that the two sources \nof unboundedness unbounded program stack from recursive synchronous calls and unbounded counters from \npending asynchronous calls can be decoupled: while a (possibly recursive) procedure is executing, the \nnumber of pending calls can only increase, and the number of pending calls decreases precisely when the \nprogram stack is empty. Accordingly, our proof of decidability combines two technical constructions. \nFirst, we use Parikh s theorem [24] from language theory to pre\u00adcisely summarize the effect of a synchronous \ncall on the state of the counters. Second, with this summarization, we can construct a Petri Net that \ncaptures the effect of the execution of a posted call in the system. Note that by using Parikh s theorem \n(which preserves .nite ex\u00adecutions only) we implicitly assume that each executed procedure eventually \nterminates. We check this property using a decision pro\u00adcedure for synchronous program termination. For \nthis check, the task buffer can be abstracted away (as no dispatches occur from within a call) and we \ncan use techniques for liveness checking for .nite-state pushdown systems [1, 36]. With the above check, \nit remains to show that the Petri Net is fairly terminating. Using known constructions on Petri Nets \n[33], we reduce this question to proving the absence of certain .nite paths in the coverability graph \nof the Petri Net (for now, think a coverability graph as a .nite automaton that captures the runs of \nthe Petri Net). Finally, we reduce the existence of such .nite runs to the satis.ability of a formula \nin the Presburger arithmetic which can be effectively constructed from the coverability graph of the \nPetri Net. Since each step of the reduction is effective, and satis.ability of Presburger arithmetic \nis decidable [25], we get our decision procedure. Our reduction of problems on asynchronous programs \nto prob\u00adlems on Petri Nets enables the use of an extensive algorithmic repertoire built for Petri Nets. \nIndeed, we show two alternate proofs for fair termination which follow from the decidability of more \ngen\u00aderal model checking questions on Petri Nets [10, 37]. Moreover, algorithmic analysis on Petri Nets \ncan be used to provide decision procedures for related questions on asyn\u00adchronous programs. We mention \ntwo applications. First, the fair non-starvation question asks, given an asynchronous program and a fairness \ncondition on executions, whether every pending call is eventually dispatched (i.e., no posted call waits \nforever). Fair non\u00adstarvation is practically relevant to ensure that an asynchronous program (such as \na server) is responsive. We show a decision pro\u00adcedure for this problem by adding new constraints to \nthe Presburger formula for the fair termination problem. Second, we show a decision procedure for boundedness,a \nsafety property that computes the maximum possible size of the task buffer at any point in any execution. \nFor the boundedness prop\u00aderty we again use a known result on Petri Nets which allows to compute the maximum \npossible size Dof the task buffer at any point in any execution (or return in.nity, if the task buffer \nis un\u00adbounded). Since the task buffer is often implemented as a .nite buffer, let us say of size d,if \nD>dholds then there is an execu\u00adtion of the system that leads to an over.ow of the buffer, and to a possible \ncrash. Our decision procedure for the boundedness prob\u00adlem uses the above reduction to Petri Nets, and \nthe construction of a coverability graph [12, 33, 34]. Related Work. Event driven programming is a popular \nway to write high-performance systems, and the style is supported in most programming environments either \nas libraries (such as libasync [17], libevent [18], or libeel [4]), or as language features [6, 7, 14, \n16]. However, it is widely recognized that while the style optimizes for low overhead and ef.cient execution, \nprograms written in this style may be hard to read and debug. While we focus on analyzing asynchronous \nprograms writ\u00adten in C and using a library for asynchronous calls, there have been several recent attempts \nat language-level support for writ\u00ading asynchronous programs to enable better automatic reasoning [3, \n6, 14, 16]. Many of these language extensions compile down to our basic model, and hence, our decidability \nresults apply. It will be interesting to see how language level support can be combined with our algorithms \nto prove deeper properties of systems. Our work is inspired by recent results that show the decidability \nof safety properties of asynchronous programs [32, 11, 2], and in particular, of precise meet-over-all-paths \ndata.ow analysis [11]. Our correctness arguments through Petri Nets use powerful al\u00adgorithmic tools developed \nfor Petri Nets [12, 33, 34]. The reduction from the existence of a fair non-terminating run in a Petri \nNet to the existence of a certain .nite run in its coverability graph uses tech\u00adniques similar to [33]. \nThe reduction of this latter problem as the satis.ability problem of a Presburger formula is inspired \nby the en\u00adcoding found in [31].  2. Asynchronous Programs and Properties We motivate our problem on \na simple imperative language. In our examples, we use C-like syntax with an additional construct postf(e) \nwhich asynchronously posts a procedure call f with arguments e. Figure 1(a) shows a simpli.ed asynchronous \nimplementation of windowed RPC, in which a client makes n asynchronous procedure calls in all, of which \nat most w = n are pending at any one time. (Assume that n and w are .xed constants). Windowed RPC is \na common systems programming idiom which enables concurrent interaction with a server without overloading \nit. The windowed RPC client is implemented in the procedure wrp. Two global counters, sentand rev, respectively \ntrack the number of posted calls and the number of calls that have returned (i.e., that have been completed). \nWe abstract the server by the procedure rpallwhich increments the number of calls that have returned. \nThe procedure wrp.rst checks how many posted calls have returned. If the number of returned calls is \nn or more, it terminates. If fewer than n calls have returned, it posts new calls if required. A new \ncall is posted if (1) the number of calls already posted is fewer than n, and (2) the number of pending \ncalls (equal to sent - recv) is lower than the window size w. If these conditions are satis.ed, an asynchronous \ncall to rpallis posted, and the variable sentis incremented. In either case, wrpreposts a call to itself \n(this is done by an asynchronous recursive call), either to post more calls or to wait for pending calls \nto return. globalintsent=0,rev=0; globalintn,w; wrp0){ if0rev<n){ if0sent<n&#38;&#38;sent-rev<w){ postrpall0); \nsent++; } postwrp0); }else{ return; } } rpall0){ rev++; } Initially:wrp0); (a) Windowed RPC implementation \nglobalbit=0; h10){ if0bit==0){ posth10); posth20); } } h20){ bit=1; } Initially:h10); (b) A fairly terminating \nasynchronous program Figure 1. Examples of asynchronous programs. As mentioned in [14], already in this \nsimple case, asynchronous code with windowed control .ow is quite complex as the control decisions are \nspread across multiple pieces of code. 2.1 Programming Model We represent programs using a generalization \nof control .ow graphs, that include special edges corresponding to asynchronous procedure calls. Let \nP bea.nite set of procedure names.An asyn\u00adchronous control .ow graph (ACFG) Gp for a procedure p. P is \na pair (Vp,Ep) where Vp is the set of control nodes of the procedure p, including a unique start node \nvps and a unique exit node vpe,and Ep is a set of directed intraprocedural edges between the control \nnodes Vp. The edges in Ep are partitioned into edges E(o), E(s), and E(a), corresponding to one of the \nfollowing: an operation edge corresponding to a basic block of assign\u00adments or an assume predicate derived \nfrom a branch condition (E(o));  a synchronous call edge to a procedure q . P (E(s)); or  an asynchronous \ncall edge to a procedure q . P (E(a)).  ' For each call edge, synchronous or asynchronous, from v to \nvwe call the source node v the call-site node, and the target node v' the return-site node. A program \nGrx comprises a set of pairwise disjoint ACFGs Gp for each procedure in p . P (we also say handler). \nThe S control locations of Grx are given by Vrx = : the union p.P Vp of the control locations of the \nindividual procedures. The edges S of Grx are given by Erx = p.P Ep . E(i), the union of the (intraprocedural) \nedges of the individual procedures and a special set E(i) of interprocedural edges de.ned as follows. \nFor each (v,v') . E(s) that calls procedure q, that is for each synchronous ' call edge from call-site \nv to procedure q returning to return-site v, we have: an interprocedural call-to-start edge from the \ncall-site v to the ss start node vq of q (i.e., (v,v q ) . E(i)); and an interprocedural exit-to-return \nedge from the exit node vqe of e ' q to the return-site v' (i.e., (vq ,v) . E(i)). As in [29], the call-to-start \nedges (or exit-to-return edges) allow us to model parameter passing and context restoration in our frame\u00adwork. \nAn asynchronous program A=(P,Grx,main) consists of a set of procedure names P, a program Grx, and an \ninitial procedure main . P which we assume has no parameters and is never called by any procedure (either \nsynchronously or asynchronously). Semantics. We consider abstract semantics of asynchronous pro\u00adgrams \nrelative to .nite data.ow domains (D,M,d0),where Dis a .nite set of data.ow facts, M: S . D . Dis a data.ow \ntransfer S (o) es function and S = {Ep }.E(i) .{(v q ) | q . P}. p.P main,v ee {(vq ,vmain) | q . P},and \nd0 . Dthe initial data.ow state. The abstract semantics of an asynchronous program A = (P,Grx,main) relative \nto the data.ow domain (D,M,d0) is given by a transition system where each state ((v,d),w,m) consists \nin: the abstract state (v,d) . Vrx\u00d7D,the program stack w . (Vrx) * , and a multiset m over P called the \nmultiset of pending calls.The se initial state is ((vmain ,d0),vmain ,\u00d8) in which the abstract state \nis se (vmain ,d0), the stack content is given by the word vmain and the mul\u00adtiset is empty. There is \na transition from a state ((v,d),s,m) to the ''' state ((v,M(v,v)(d)),s,m) if there is an edge (v,v) \n. E(o) (internal operation). There is a transition from ((v,d),s,m) to ss ' ((vq ,M(v,v q )(d)),s \u00b7 v,m) \nif there is a synchronous call edge ' (v,v) calling q in E(s) (procedure call). There is a transition \ne ''e ' from ((vq ,d),s \u00b7 v,m) to ((v,M(vq ,v)(d)),s,m) if there is ' a synchronous call edge (v,v) calling \nq in E(s) (procedure re\u00ad ' turn). There is a transition from ((v,d),s,m) to ((v,d),s,m l 'E(a) {q}) if \nthere is an asynchronous call edge (v,v) . to a procedure q (asynchronous post).1 There is a transition \nfrom e ses e ((vmain ,d),E,m) to ((vq ,M(vmain ,vq )(d)),vmain ,m\\{q}) if q . m(asynchronous call dispatch). \nFinally, there is a transition from e e eee ((vq ,d),s \u00b7 vmain ,m) to ((vmain ,M(vq ,vmain )(d)),s,m) \n(asyn\u00ad chronous return). A run of an asynchronous program relative to the data.ow domain is a path in \nthe associated transition system, starting with the initial state. By abuse of notation, we write A to \ndenote the abstract semantics over a .xed data.ow domain. e We now give some intuition about the control \nlocation vmain which plays a special role in the above semantics. If the current e state is such that \nthe control location is vmain and the stack content e is empty (i.e., ((vmain ,d),E,m) for some multiset \nmand data.ow fact d), then a procedure call from the multiset of pending calls, if 1 The symbol l denotes \nthe union between multisets. any, is dispatched. Otherwise, if the multiset of empty, the program e terminates. \nThus vmain models a special dispatch loop. For simplicity of exposition, we assume that procedures are \nparameterless and there are no local variables. For a .xed .nite data.ow domain, parameters can be modeled \nby copying and re\u00adnaming the functions, one copy for each parameter value, and local variables can be \nencoded into the nodes of the control .ow graph. 2.2 Progress Guarantees Consider the desirable property \nthat the windowed RPC fairly ter\u00adminates, which implies that, at some point in time, every posted call \nhas returned and the multiset of pending calls is empty. Informally, this property is true because the \nprocedure wrpposts rpccall at most n times, and posts itself only as long as recv is less than n. Each \nrun of rpccall increments recv,so thatafter n dispatches of rpccall,the value of recv reaches n, and \nfrom this point, all calls to wrpc do not post any new call. Thus, eventually, the multiset of pending \ncalls becomes empty. Notice that we need the assumption that the scheduler fairly dispatches posted calls: \na posted call to q is followed by a dispatch to q. Without that assumption the program does not terminate: \nconsider the in.nite trace where the scheduler always picks wrp in preference to rpall. Fair Termination. \nWe now de.ne the fair termination property on the model. An asynchronous program (P, Grx , main) fairly \nterminates if (i) every execution of a procedure that is called (synchronous or asynchronous) eventually \nreturns; and (ii) there is no in.nite run that is fair. An in.nite run is said to be fair if for every \nstate ((v, d),w, m)along this run, if the multiset m contains a call to procedure q then eventually a \ncall to q is dispatched. The fairness constraint is expressible as a .-regular property. Of course, for \nmost server applications, the asynchronous pro\u00adgram implementing the server should not terminate (indeed, \nter\u00admination of a server points to a bug). However, each request to the server should fairly terminate \nas de.ned above. Many event li\u00adbraries (e.g., libeel [4]) allow identifying individual requests using \nmechanisms such as group-ids or session-ids. Fair Non-starvation. A second progress condition is fair \nnon\u00adstarvation. When an asynchronous program does not terminate, we can still require that (i) every \nexecution of a procedure that is called (synchronous or asynchronous) eventually returns; and (ii) along \nevery in.nite fair execution no handler is starved. A starving handler corresponds to a pending call \nwhich is never dispatched, and hence which waits forever to be executed. Consider a handler h that posts \ntwo calls to itself. An in.nite fair execution dispatches a call to heach time a dispatch takes place, \neven though a particular call to hmay never be run. Proving fair termination and fair non-starvation \nfor asyn\u00adchronous programs is dif.cult for several reasons. First, as the win\u00addowed RPC example suggests, \nreasoning about termination may require reasoning about the data.ow facts (e.g., the fact that recv eventually \nreaches n in the example). Second, at each point, there can be an unbounded number of pending calls. \nThis is illustrated by the program in Fig. 1(b), which terminates on each fair execu\u00adtion, but in which \nthe multiset contains unboundedly many pending calls (to h2). Third, each handler can potentially be \nrecursive, so the program stack can be unbounded as well. We remark that if the .nite data.ow domain \ninduces a sound abstraction of a concrete asynchronous program in which data vari\u00adables range over in.nite \ndomains, that is, if the .nite abstraction has more behaviors, then our analysis is sound: if the analysis \nwith the .nite data.ow domains shows the asynchronous program fairly ter\u00adminates (resp. is fair non-starving) \nthen the original asynchronous program fairly terminates (resp. is fair non-starving).  3. Asynchronous \nAutomata We now formally introduce asynchronous automata, an automaton model for asynchronous programs. \nWe give the semantics of asyn\u00adchronous programs using asynchronous automata, and develop our theoretical \nresults on asynchronous automata. Prerequisites. Let S be an alphabet. We denote by S * (respec\u00adtively, \nS. ) the set of .nite (respectively, countably in.nite) se\u00adquences over S. We write SE for the language \nS.{E}.Given w .S * ,we use |w|to denote its length. A counter map is a mapping from Sto N. For a counter \nmap c, we write c[a . i]for the counter map that maps a . Sto i . N and maps every b .S\\{a}to c(b). The \ncounter map 0 maps every a .Sto 0. The Parikh image Parikh :S * . NS maps a word w . S * to a counter \nmap Parikh(w)such that Parikh(w)(a)is the number of occurrences of a in w. For example, Parikh(abbab)(a)=2and \nParikh(abbab)(b)=3. For a language L,we de.ne Parikh(L)= {Parikh(w)|w .L}. LEMMA 1. [Parikh s Lemma [24]] \nFor any context free language L there is an effectively computable regular language L ' such that Parikh(L)=Parikh(L \n' ). 3.1 Asynchronous Automata An asynchronous automaton A =(Q, S,d,q0,a0)consists of a .nite set Q of \nglobal states, a .nite alphabet S, a transition relation d . (Q \u00d7S)\u00d7(Q \u00d7S * \u00d7SE ), an initial state q0 \n. Q,and an initial handler call a0 .S. A con.guration of an asynchronous automaton is a tuple (q, w, \nc).Q \u00d7S * \u00d7NS where q is a global state, w is a word of S * called the stack content,and c is a counter \nmap of pending calls (or simply the counter map). The initial con.guration is (q0,a0, 0), where the global \nstate is q0, the stack content is a0, and the counter map is 0. We de.ne a transition relation .on con.gurations \nas the union of a transition relation .s modeling handler steps and a transition relation .d modeling \na dispatch, where .s and .d are de.ned as follows: ' '' Handler Step There is a transition (q, wa, c) \n.s (q ,ww , c ), '' '' where ((q, a), (q ,w ,a ' )). d and c =c[a . c(a ' )+1]if ' '' a .Sand c =c if \na =E. Handler Dispatch There is a transition (q, E, c) .d (q, a, c ' ), where c(a)> 0and c ' =c[a .c(a)-1]. \nIn the former case, if a ' E then we say that a call to a ' =has been posted. In the latter case we say \nthat a pending call to procedure a is dispatched, or that a is dispatched or simply that a dispatch occurs. \nA run of an asynchronous automaton is a (.nite or in.\u00adnite) sequence (q0,a0, 0) . (q1,w1, c1) . \u00b7\u00b7\u00b7.Let \n. * (respectively, .s *) denote the re.exive transitive closure of . (respectively, .s ). A con.guration \n(q, w, c) is reachable iff (q0,a0, 0) . * (q, w, c). Finally, we write ReachE (A)for the set of pairs \n{(q, c)|.q .Q:(q0,a0, 0). * (q, E, c)}, that is the set of reachable con.gurations in which the stack \nis empty. In.nite Runs. The in.nite runs of an asynchronous automaton fall into two categories: 1. [Runs \nof the First Form] in.nite runs of the form * '* (q0,a0, 0).s (q1,E, c1).d (q1,a1, c1).s (q2,E, c2).d \n... in which there are in.nitely many .d steps; and 2. [Runs of the Second Form] in.nite runs in which \nthere are .nitely many .d steps (and so, in which in.nitely many han\u00addler steps take place consecutively). \nparse0){ postread0); } read0){ postsend0); } send0){ } Initially:parse0); Figure 2. A simple event processor \n 3.2 From Programs to Automata In the following, we prove our theoretical results on asynchronous automata. \nWe now show that the abstract semantics of asyn\u00adchronous programs relative data.ow domain (D,M,d0) can \nbe given by translation to an asynchronous automaton. Given an asynchronous program A =(P,Grx ,main) \nwith rx =(Vrx ,Erx G) we de.ne an asynchronous automaton AG x = (Q,S,d,q0,a0) as follows: = Vrx Q\u00d7D; \n'' e S= P .{v |.(v,v ) .E(s )}.{vmain }; e a0 = vmain ; s q0 =(vmain ,d0);and  dis the smallest set \nsuch that  let (v,v ' ) . E(o ),for every u . S and d . D we have (((v,d),u),((v ' ,M(v,v ' )(d)),u,E)) \n.d  let (v,v ' ) .E(s ) be an synchronous call edge to procedure q .P for every u.S and d.Dwe have \n  ss ' (((v,d),u),((vq ,M(v,v q )(d)),u\u00b7v ,E)) .d e '' e ' (((vq ,d),v ),((v ,M(vq ,v )(d)),E,E)) .d \n let (v,v ' ) . E(a ) be an asynchronous call edge to proce\u00addure q .P,for every u.S and d .Dwe have (((v,d),u),((v \n' ,d),u,q)) .d for every q .P, d.D e ses e (((vmain ,d),q),((vq ,M(vmain ,vq )(d)),vmain ,E)) .d eee \nee (((vq ,d),vmain ),((vmain ,M(vq ,vmain )(d)),E,E)) .d 3.3 Fair Termination We now translate the fair \ntermination property of an asynchronous program into the asynchronous automata model. An in.nite run \nis a-fair for a handler a . S iff for every state (q,w,c) along this run, if c(a) > 1 then eventually \na handler dispatch transition of the form (q1,E,c1) .d (q2,a,c2) where c1(a) > 0 and c2 = c1[a . c(a) \n-1] must occur. An in.nite run is fair iff it is a-fair for all handlers a . S. An asynchronous automaton \nterminates iff it has no in.nite runs. An asynchronous automaton terminates fairly iff (i) all in.nite \nruns are of the .rst form (hence there is no in.nite run of the second form), and (ii) there is no in.nite \nrun of the .rst form that is fair. The asynchronous program of Fig. 2, initialized with the parse handler, \nimplements a simple request processor: The program is terminating: there is only one run, starting with \nparse, followed by read, and then by send. On the other hand, the program in Fig. 1(b) is fair terminating, \nbut not terminating. There is an in.nite run in which the scheduler always chooses h1over h2. This run \nis not h2fair, and hence not fair. 3.4 Recursion-free Asynchronous Automata We now address one source \nof unboundedness: the potentially un\u00adbounded stack. Our .rst step will transform, using Parikh s Lemma, \na given asynchronous automaton Ainto an equivalent recursion\u00adfree asynchronous automaton A ' in which \nthe stack height is always bounded by one. This equivalence ensures that Adoes have a (fair) in.nite \nrun of the .rst form iff A ' does. Moreover, their reachable con.gurations coincide as long as we restrict \nour attention to those with an empty stack (Lem. 2). An asynchronous automaton A is recursion-free if \nno handler step of Apushes on to the stack, that is, if d . (Q\u00d7S) \u00d7(Q\u00d7 SE \u00d7SE ). Intuitively, in a recursion-free \nasynchronous automaton, no handler makes additional synchronous calls, and in particular, there is no \nrecursion. We now show that given an asynchronous automaton A,there exists a recursion-free asynchronous \nautomaton A ' that preserves the existence of (fair) in.nite runs and such that ReachE (A)= ReachE (A \n' ). Since we use a construction over .nite languages, the transformation we present below preserves \nruns of the .rst form but eliminates runs of the second form. Proving that an asynchronous automaton \nhas no in.nite runs of the second form is a separate problem which is addressed in Sect. 4.4. Below we \nassume the reader is familiar with the de.nitions of pushdown automaton and .nite state automaton (see \n[9] for further details). LEMMA 2. Let A =(Q,S,d,q0,a0) be an asynchronous automaton. There exists an \nasynchronous automaton A ' = ' ''' ' (Q,S,d ,q0,a0) such that A is recursion-free and such that * '* \n(q0,a0,0) .s (q1,E,c1) .d (q1,z1,c1) \u00b7\u00b7\u00b7 .s (qi ,E,ci ) .d (qi ,zi ,ci ' ) is a run of A iff it is a \nrun of A ' . In particular, ReachE (A)= ReachE (A ' ). PROOF:Given A =(Q,S,d,q0,a0) we de.ne a .nite \nfamily of pushdown automata (PDAs) as follows. De.ne T . ((Q\u00d7S \u00d7 SE ) \u00d7(Q\u00d7S * )) to be such that ((q,a,b),(q \n' ,w)) . T iff there exists b.SE and ((q,a),(q ' ,w,b)) .d. The family is given by if if {Pj }= {(Q,S,S,T,z,q \n,{q }) |q ,q .Q, z .S} . j .J Each member of the family is such that the stack and input alpha\u00adbets are \ngiven by S; z is the initial stack symbol; q i and q f are the initial and .nal locations. They share \nthe same transition relation T. The only accepting con.guration for each PDA is (q f ,E). From the family \n{Pj }of PDAs we de.ne the family j .J {Fj }where Fj =(Qj ,S,dj ,qji ,Fj ) is a .nite automaton j .J such \nthat Parikh(L(Fj )) = Parikh(L(Pj )) . (1) By Lemma 1, we can effectively construct such a .nite automaton \nfor a given PDA. Now let us de.ne an asynchronous automaton A ' = ' ''' (Q,S,d ,q0,a0) such that [ Q \n' = Q.{Qj |Fj =(Qj ,S,dj ,qji ,Fj )} . j .J Moreover, we de.ne d ' to be the smallest set such that for \neach automaton Fj and the associated tuple q1,z,q2 we have ((q1,z),(qji ,z,E)) .d ' ; '' ' ((qj ,z),(qj \n,z,a)) .d for each (qj ,a,q j ) .dj ; f ' f ((q ,z),(q2,E,E)) .d for each q .Fj . Finally we set q0 ' \n= q0 and a ' 0 = a0. It is easily seen from the above construction that A ' is recursion\u00adfree. Then our \nresult is proved by induction on the number i of times that a dispatch (viz., .d) occurs. ' ' ' Case \ni =0: (q0,a0,0)=(q0,a0,0)holds by de.nition of a0 and q0' . Case i+1: In this case we consider a run \nof the form: (q0,a0,0). * s (q1,E,c1).d (q1,z1,c1' )... (qi,E,ci).d (qi,zi,ci' ). * s (q,E,c) . (2) \nFor the only-if direction, consider the run of A given by (2). By induction hypothesis we have a run \nin A ' which successively visits con.gurations (q0,a0,0),(q1,E,c1),...,(qi,E,ci). By the de.ni\u00adtion of \nthe asynchronous automaton A ' ,we have (qi,E,ci) .d (qi,zi,ci' ).Now,let Pk be the PDA de.ned above \nfor the triple (qi,zi,q). (1) shows that the .nite automaton Fk is such that Parikh(L(Fk)) = Parikh(L(Pk)). \nBy de.nition of A ' , we ob\u00adtain that (qi,zi,ci' ) . * s (q,E,cx). Moreover cx = c because of Parikh(L(Fk))=Parikh(L(Pk)), \nhence the only if direction fol\u00adlows. The if direction can be proved using a similar reasoning. 0  \n4. Decision Procedures We will show that there is a straightforward encoding of recursion\u00adfree asynchronous \nautomata as Petri Nets [28]. Hence, we reduce our fair termination problem on recursion-free asynchronous \npro\u00adgrams to an equivalent one on Petri Nets. Provided the given asyn\u00adchronous automaton is recursion-free, \nthe encoding into a Petri Net will be carried out in linear time. 4.1 Petri Nets A Petri Net N =(S,T,F,m0)consists \nof a .nite set S of places, a .nite set T of transitions disjoint from S,a weight function F:(S\u00d7T).(T\u00d7S) \n,1},and an initial marking m0 . NS .{0. A marking is a map from Sto N. For a marking m of N and p. S, \nwe say that, in m, the place pcontains m(p)tokens. For markings m, m ' , we write m +m ' for the marking \nobtained by point wise addition of place contents. We write m = m ' if for all p . S we have m(p)= m \n' (p)and write m <m ' if m = m ' and m =m ' . The marking 0 maps every a. Sto 0.The size of a Petri Net \nN is |S| +|T| where |\u00b7| denotes the cardinality of a set. The semantics of a Petri Net N =(S,T,F,m0)is \ngiven as a labeled transition system (LTS) (C,[\u00b7),c0)where the set C of states is the set of markings \nNS, the initial state c0 = m0,and the labeled transition relation [\u00b7) . C \u00d7 T \u00d7 C is de.ned as follows. \nA transition t . T is enabled at m, written m [t),if m(p) = F(p,t)for each p . S. A transition t that \nis enabled at m can .re, yielding a marking m ' such that m ' = m +.(t) where .(t),the effect of a transition \nt, is a function from T to NS given by .(t)(p)= F(t,p)- F(p,t)for every p . S.In this case, we have (m,t,m \n' ). [\u00b7), which we write as m [t)m ' . Consider a path m1 [t1)m2 [t2)...[tn)mn+1 in the LTS. Since each \ntransition is deterministic, we can equally speak about the word that labels the path starting at m1, \nforgetting about the intermediate markings. Using the LTS de.nition we naturally lift the enabledness \nand .ring notion from transition to sequences (or set of sequences) of transitions as follows. Given \nL. T * and w . T * .T. we de.ne: m1 [L)m2 iff some v . Llabels a path of LTS from m1 to m2 m1 [w) iff \nwlabels a path of LTS which starts in m1. From the above de.nition we .nd that m is a reachable state \niff m0 [T *)m and the set of reachable states coincides with {m | m0 [T *)m}. Also we lift the effect \n. of a single transition to sequences (and sets of sequences) in a natural way: .(E)=0 and .(vu)= .(v)+.(u).Sofor \nevery w . T * such that m [w)m ' we have m ' =m +.(w). The converse, however, does not hold. 4.2 From \nAsynchronous Automata to Petri Nets Let A ' =(Q,S,d,q0,a0)be a recursion-free asynchronous au\u00adtomaton, \nits associated Petri Net NA, =(G. S,T,F,m0)is de\u00ad.ned as follows: G=Q\u00d7 SE;  T =Ts . Td (with Ts n Td \n=\u00d8)and F are the smallest sets which satisfy:  Ts contains a transition tfor each ((q,a),(q ' ,b,c)). \nd ' such that F((q,a),t)=1F(t,(q ' ,b))=1and F(t,c)=1if c. S(F(t,x)=F(x,t)=0elsewhere); S Td is given \nby a.S Ta such that for (q,E) . Gthe set Ta d d contains a transition tsuch that F((q,E),t)=1, F(a,t)= \n1and F(t,(q,a))=1(F(t,x)=F(x,t)=0elsewhere); m0 is such that m0(p)=1if p=(q0,a0)and 0otherwise. Notice \nthat T is well de.ned since A ' is recursion-free. Also we conclude from Sand Qare .nite that G. Sis \n.nite and also T is .nite as A ' is recursion-free. In the sequel we often refer to a place a . Sas the \ncounter of pending calls to a. As in the case of asyn\u00adchronous automaton, whenever a transition t . Tda \n.res, we say that a pending call to handler ais dispatched. The following lemma connects reachable con.gurations \nof an asynchronous automaton with the reachable markings of the associated Petri Net, and allows us to \nuse algorithms on Petri Nets to solve decision questions on asynchronous automata. LEMMA 3. Let A ' be \na recursion-free asynchronous automaton and let NA, =(G. S,T,F,m0)be the associated Petri Net. (1) The \nsize of NA, is linear in the size of A ' . (2) Given the following relation between con.gurations of \nA ' and markings of NA, : 8 8 >1 if p=(q,E) >1 if p=(q,zi) < < ' mi(p)= ci(p) if p. S m ' i(p)= ci(p) \nif p. S > > : : 0 otherwise 0 otherwise we have (q0,a0,0) .s * (q1,E,c1) .d ' '' (q1,z1,c1)...(qi,E,ci) \n.d (qi,zi,ci) is a run of A iff m0 [Ts *)m1 [Td)m1 ' [Ts *)...mi [Td)mi ' is a path in the LTS of NA, \n. We now translate the fair termination property from recursion\u00adfree asynchronous automata to Petri Nets \nas follows. Let A ' be a recursion-free asynchronous automaton. As we say above, because the translation \nfrom an asynchronous automaton to a recursion-free one does not preserve in.nite runs made of handler \nsteps only, that is runs of ..s , it is a separate problem to check that all in.nite runs are of the \n.rst form. Assuming this, what remains to check is that, in A ' there is no in.nite run of the .rst form \nthat is fair. Accordingly, on the associated Petri Net NA, =(G. S,Td . Ts,F,m0)we check that there is \nno path in the LTS starting from m0 that is of the form (Ts * \u00b7 Td). (i.e., of the .rst form) and also \nfair. We de.ne fairness of an in.nite path m1 [t1)m2 [t2)...[tn)mn+1 ... as follows. An in.nite path \nis a-fair for a handler a . S if for every marking mj along this path, if mj (a)> 1then a transition \nmi [Tda)mi+1 for some i>j must .re. An in.nite path is fair if it is a-fair for all handlers a. S. 4.3 \nCoverability Graph Our decision procedure to check fair termination on a Petri Net N is based on the \ncoverability graph of N [33]. We start with some de.nitions. Let N. = N .{.}.An .-marking for a .nite \nset S of places is a mapping from Sto N.. Intuitively, .-markings extend markings, where .represents \nan arbitrary large natural. The arithmetic on N. is de.ned as follows .\u00b1 c = . = .+ . for each c . N.Further, \nc<. for each c . N and . = .. (In the sequel, whenever . occurs, it should be clear from the context \nif . refers to the one used in markings or to the one used in .-word or .-language.) For aset X of .-markings \nover S,the downward closure of X (written .X) is given by the set {m . NS |.m ' . X: m = m ' }. De.ne \nAccel to be the acceleration function that takes as input aset M of .-markings and an .-marking m and \nreturns an .\u00admarking such that for each p . S we have Accel(M,m)(p)= . ' '' if there exists m . M such \nthat m < m and m (p) < m(p), and Accel(M,m)(p)= m(p) otherwise. Given a Petri Net N =(S,T,F,m0), a coverability \ngraph G(N) is a .nite labeled transition system (nodes,[[\u00b7)) ,m0) where the set of states nodes is a \n.nite subset of .-markings, [[\u00b7)) . nodes \u00d7 T \u00d7 nodes is the labeled transition relation, and m0 is the \ninitial state. In this section we often refer to an element of the transition relation [[\u00b7)) of a coverability \ngraph as a edge. Algorithm 1 shows an algorithm from [33, 34] which given a Petri Net N builds a coverability \ngraph G(N). The algorithm constructs a coverability graph by a worklist-based algorithm. The set worklist \ncontains the set of pairs of .-markings m and transitions t enabled at m that are to be explored. The \nset log stores the set of .-marking, transition pairs that have been explored already. The main loop \nof the algorithm (lines 5 15) iterates over the worklist, choosing a pair (m,t) and .ring tfrom m to \nget m ' .If m ' is not already in G(N), it is accelerated w.r.t. all states that can reach m (lines 9, \n10), and the accelerated node is added to nodes. The transition relation is updated to re.ect an edge \nfrom m to m ' through transition t(line 13), and both log and worklist are updated. Consider a path m1 \n[[t1)) m2 [[t2)) ...[[tn)) mn+1 in G(N). Since Algorithm 1 consider every pair (m,t) at most once, we \ncan equally speak about the word that labels the path starting at m1, forgetting about the intermediate \nmarkings. This is as for the LTS of N. LEMMA 4. [33] Given a Petri Net N =(S,T,F,m0) Algorithm 1 always \nterminates and returns a coverability graph G(N)= (nodes,[[\u00b7)) ,m0) such that the following hold: ? 1. \n.nodes = y{m | m0 [T * ) m} . 2. Let v be a .nite path of G(N) with .(v) = 0. There exists u. T * such \nthat m0 [uv). 3. If m [w) for some m . nodes and w . T * then there exists a unique node m ' . nodes \nsuch that m [[w)) m ' holds and for each p . S: m ' (p)= . . m ' (p)= m(p)+ .(w)(p) (hence, {p. S | m(p)= \n.}.{p . S | m ' (p)= .}).  In the following, for a Petri Net N,we de.ne G(N) to be the coverability \ngraph computed by Algorithm 1. 4.4 Proving the Absence of Runs of the Second Form We now show how to \ncheck the absence of runs of the second form, in which in.nitely many handler steps take place consecutively. \nIn\u00adtuitively, we have to prove that every handler that is called termi\u00adnates. We start with some observations. \nGiven an asynchronous automaton A =(Q,S,d,q0,a0),an in.nite sequence of handler steps is enabled at a \nreachable con.gu\u00adration iff an in.nite sequence of handler steps is enabled at a reach\u00adable con.guration \nthat follows a handler dispatch or q0.Every in.\u00adnite sequence of handler steps remains enabled when pre.xed \nwith a .nite sequence of handler steps. Then we observe that, as far as the handler steps are concerned, \nthe values of the counters of pending calls are irrelevant. In fact, Algorithm 1: Coverability graph \nconstruction Input:A Petri Net N =(S,T,F,m0) Output: A coverability graph G(N)=(nodes,[[\u00b7)) ,m0) 1 begin \n2 nodes := {m0}, [[\u00b7)) := \u00d8 3 worklist := {(m0,t) | m0 [t)}4 log := \u00d8 5 while worklist = \u00d8 do 6 choose \n(m,t) . worklist and remove from worklist 7 let m ' = m +.(t) 8 if m ' ./nodes then 9 Let M = {m '' . \nnodes | m '' [[T * )) m}10 m ' := Accel(M,m ' ) 11 nodes := nodes .{m ' } 12 end 13 [[\u00b7)) := [ \u00b7)) . \n{(m,t,m ' )}; log := log .{(m,t)}14 worklist := worklist .{(m ' ,t) ./log | m ' [t)} 15 end 16 return \nG(N) 17 end counters do not disable/enable handler steps. Hence we see that an in.nite sequence of handler \nsteps is enabled at a con.gura\u00adtion (q,w,c) iff the same sequence is enabled at every con.gura\u00adtion {(q,w,c \n' ) | c ' . NS}. This shows that we can abstract away counters of pending calls for the check. Accordingly \nwe obtain a model where the unique source of unboundedness is given by the stack. For this setting, the \nabsence of in.nite sequences (of handler steps) can be established by known model checking algorithms \nfor pushdown systems [1, 36]. Our procedure to check for the absence of run of the sec\u00adond form uses \none of the above algorithm to check for the absence of in.nite sequence of handler steps starting from \na .nite set of con.gurations given by {(q0,a0)}. (Q \u00d7 {a. S |.m .G(NA, ) with m(a) >0}) (counters are \nomitted for the above mentioned reason). Recall that in the above de.ni\u00adtion A ' is the recursion-free \nasynchronous automaton of Lem. 2.  4.5 Termination In what follows we de.ne the decision procedure to \ncheck the fair termination of a Petri Net. We proceed in two steps. First we give a general decision \nprocedure to check that there is no in.nite path (fair or unfair) in the LTS of a Petri Net. Then we \nwill extend this decision procedure to check that there is no fair in.nite path in the LTS of NA, along \nwhich some t . Td occurs in.nitely often. Our decision procedure for termination relies on the following \nlemma from [33] which reduces the existence of an in.nite path in theLTS of aPetri Net N to the existence \nof a .nite path in G(N). LEMMA 5. [33] Given a Petri Net N =(S,T,F,m0), there exists w . T. : m0 [w) \nin the LTS of N iff in G(N) there exists a path v such that .(v) = 0. We reduce the search for such a \npath in G(N) to the satis.ability of a quanti.er-free Presburger formula. Our reduction is inspired by \na similar encoding in [31]. Recall that existential Presburger formulas f are de.ned by the following \ngrammar and interpreted over natural numbers: t::= 0 | 1 | x| t1 + t2 | t1 - t2 where xis a variable \nf::= t1 = t2 | t1 >t2 | f1 . f2 | f1 . f2 |\u00acf1 . X zn =1 (3) n.nodes X X x( n,,t,n) - x( n,t,n,) =0 \nfor n . nodes (4) n,.nodes,t.T t.T,n,.nodes n,[[ t n n[[ t n, zn > 0. un =0 for n . nodes (5) 0 1 X \nB C B @zn =0. n,.nodes,t.T n,[[ t n x( n,,t,n) > 0C A . un = 1 for n . nodes (6) un = 1. _ un >un, = \n1- zn, for n . nodes (7) t.T,n,.nodes n[[ t n, or n,[[ t n X x( n,t,n,) = 1 (8) n,n,.nodes,t.T n[[ t \nn, X .(t)(p)\u00d7 x( n,t,n,) = 0 for p . S (9) n,n,.nodes,t.T n[[ t n, Figure 3. Presburger constraints \nfor termination In the following we use standard abbreviations like c\u00d7 x for c . N for the c-times addition \nx+... +x, t1 = t2 for t1 >t2 . t1 =t2 , and f1 . f2 for \u00acf1 . f2 . The encoding as a Presburger formula \nis based on the notion of .ows. A multigraph M * =(V, W,8)consists of a set V of nodes, a multiset W \nof edges, and a node 8. V . The multigraph M * is consistent if every node of V has as many incoming \nedges as outgoing edges. The multigraph M * is said to be connected if there exists an undirected path \nbetween every pair of distinct nodes of M *.A .ow is a consistent and connected multigraph. Consistency \nand connectedness imply that there exists a cycle in M * from 8 to itself which traverses each edge of \nW exactly once [31]. Given a coverability graph G(N)=(nodes, [[\u00b7)) , m0 )of a Petri Net N and 8. nodes,we \nde.ne .ows M * =(V, W,8) of G(N)in which V . nodes and each edge e . (nodes \u00d7 T \u00d7 nodes)of the multiset \nW belongs to [[\u00b7)). Because clearly a .ow induces an Eulerian circuit, we know that a .ow de.nes a (not \nnecessarily simple) cycle in G(N). The converse also holds: each (not necessarily simple) cycle of G(N)from \n8 to itself corresponds to a .ow M * =(V, W, 8)where V is the set of nodes along the cycle and W is the \nmultiset of all the edges along the cycle. So in what follows, we often equally speak of cycles and .ows. \nWe now explain how to encode the set of .ows of G(N)= (nodes, [[\u00b7)) , m0 ) from 8 to itself as a Presburger \nformula. In particular, the formula is such that the set of .ows from 8 to itself coincides with the \nset of its satisfying valuations. Given a coverability graph G(N)=(nodes, [[\u00b7)) , m0 )of a Petri Net \nN =(S, T, F, m0 ),we de.ne .N to be the conjunction of the constraints in Figure 3. We now describe each \nconstraint in the formula in more detail. The formula .N uses the following set of variables. First, \nfor each n . nodes, de.ne the variables zn which tracks from which node n the .ow starts and ends. Second, \nfor each edge (n, t, n ' ). [[\u00b7)), de.ne the weight variable x( n,t,n,) which tracks the number of times \nthe edge (n, t,n ' )occurs in the .ow. Third, for each node n . nodes,the variable un gives a rank to \nnode n, and ranks are used (as described below) to ensure connectedness. The constraint (3) encodes the \nfact that exactly one of the zn s valuates to 1(viz., z8), the others to 0. This allows the constraint \nto choose 8 arbitrarily. Consistency of the .ow is encoded by (4) which ensure that at each node, the \nsum of weights on the incoming edges is equal to the sum of weights on outgoing edges. To encode connectedness \nof the .ow we use the rank variables un. The nodes of the .ow coincide with the nodes with a positive \nrank (6), except for 8 which is ranked 0(5). Hence a node n belongs to the .ow iff un +zn = 1. Then we \nrely on the property that a .ow is connected iff each of its nodes but 8 is adjacent to some node that \nbelongs to the .ow and has a strictly lower rank. This encoding of this property is given by (7) which \ncan be intuitively interpreted as follows. If node n belongs to the .ow and n = 8 (i.e., un = 1)then \nthere exists an adjacent node n ' (quanti.cation is encoded by the disjunction) that belongs to the .ow \n(un, = 1)and therank of n ' is strictly lower than the rank of n (un >un, ). The constraint 1-zn, allows \nto deal with the case in which n is adjacent to n ' = 8.It follows that in the disjunct of (7) we have \nun >u8 = 0(since z8 =1) which holds for every positive value of un since u8 =0 by (5). Conjunct (9) ensures \nthat the global effect of the selected se\u00adquence of transitions is of positive weight and (8) prohibits \nselect\u00ading the empty sequence. Note that .(t)(p)is a constant value. Flows and Valuations. Consider a \nsatisfying valuations of .N it naturally induces a .ow (or equally a cycle). On the other hand con\u00adsider \na .ow M * =(V, W, 8)of G(N), M * naturally translates to a valuation of the variables of .N as follows. \nThe node 8 gives which of the {zn}valuates to 1else valuates to 0and the n.nodes multiset W of edges \ngives the valuation of the variables {xe} e.[[ \u00b7 such that the edge e occurs c times in W iff xe valuates \nto c.Since a .ow is consistent and connected by de.nition, we can extend the valuation to the variables \n{un}such that it satis.es the con\u00ad n.nodes straints (4), (5), (6), (7). Because of the above translation, \nwe will sometimes say that a .ow M * of G(N)satis.es some Presburger formula built upon .N if the valuation \ncorresponding to the .ow M * satis.es the Presburger formula. From these explanations, it can be seen \nthat the following holds. LEMMA 6. Given a Petri Net N =(S,T,F,m0) we have that .N is satis.able iff \nthere exists a cycle labeled by v in G (N) such that .(v) = 0. We also have the following relation between \ncycles and paths in the coverability graph. LEMMA 7. Given a Petri Net N =(S,T,F,m0) and v . T+ such \nthat .(v) = 0, there exists a path labeled by v in G (N) iff there exists a cycle labeled by vin G (N). \nPROOF: The if direction trivially follows from the fact that every cycle is also a path. For the only \nif direction, since v labels a path of G (N) and .(v) = 0, by Lem. 4 (point 2), there exists u . T * \nsuch that m0 [u\u00b7 v) . Lemma 4 (point 3) shows that there exists a unique path in G (N) starting at m0 \n. nodes and labeled by u\u00b7 v. Let m1,m2 . nodes be such that m0 [[u)) m1 and m1 [[v)) m2. Since .(v) = \n0 we have that m2 = m1. We now prove that m1 [v) . We conclude from m0 [u\u00b7 v) that there exists a unique \nmarking ' '' m1 such that m0 [u) m1, hence m1 = m0 +.(u) by de.nition of [u) and .nally that m1 . nodes \nis such that m1 = m1 ' by Lem. 4 (point 3). By monotonicity of Petri Nets and m1 ' [v) it follows that \nm1 [v) . Lemma 4 (point 3), m1 [v) and m1 . nodes shows that there exists m2 . nodes such that m1 [[v)) \nm2 andalsothat for every p. S such that m2(p)= .we have m2(p)= m1(p)+ .(v)(p) (hence { p. S | m1(p)= \n.}.{ p. S | m2(p)= .} ). We conclude from .(v) = 0 that m2 = m1, hence that m2 [v) by monotonicity of \nPetri Nets and .nally that there exists m3 . nodes such that m2 [[v)) m3 by Lem. 4 (point 3). By repeatedly \napplying the above reasoning we de.ne a sequence of nodes of G (N) such that m1 [[v)) m2 [[v)) ...mi \n[[v)) mi+1 .... Moreover using Lem. 4 (point 3) and .(v) = 0 we .nd that for every i> 1 we have mi+1 \n= mi. Now using the observation that since G (N) is .nite and thus that the .nite set of natural values \nthat appear in the nodes can be bounded by some b . N we conclude that there exists j such that mj = \nmj+1 andsowe havea cycle from mj to mj+1 labeled by v. 0 Finally Lem. 6 and Lem. 7 shows that the following \ncorollary. COROLLARY 1. Given a Petri Net N =(S,T,F,m0) we have: .N is satis.able iff there exists w \n. T. : m0 [w) in the LTS of N. Since Presburger satis.ability is decidable, and each step in our construction \nfrom asynchronous automata to the Presburger formula is effective, we have that the termination problem \nis de\u00adcidable. The problem is EXPSPACE-hard by reduction from the EXPSPACE-hardness for termination of \nsimple programs [5, 19, 32]. THEOREM 1. [Termination] The termination problem for asyn\u00adchronous automata \nis decidable and EXPSPACE-hard.  4.6 Fair Termination Recall that for fair termination, the de.nition \nsays that in the LTS of the Petri Net NA, =(G. S,Ts . Td,F,m0) associated with the recursion-free asynchronous \nautomaton A ' , there is no path that is of the form (Ts * \u00b7 Td). which is also fair. Let s . (Ts * \u00b7 \nTd). be such that m0 [s), we thus have the in.nite path m0 [s1) m1 [s2) m2 ... where s = s1s2 .... By \nde.nition we have that sis fair iff . a. S . i= 0: mi(a) = 1 .. j = i: mj [Tda) mj+1 . (10) Since s . \n(Ts * \u00b7 Td). for every i = 0 such that mi(a) = 1 we have . e= i: mi [Ts * ) me [Tda) . Hence we have \nthat (10) is equivalent to . a. S. i = 0: mi [Tda).. j = i: mj [Tda) mj+1 . (11) As for termination our \nsolution to the fair termination problem checks whether some Presburger formula is satis.able. The for\u00admula \nfor fair termination is given by .NA, of Fig. 3 in conjunction with FNA, given by (12) . (13) where: \nX un + zn = 1 . x(n1,t,n2) = 1 (12) n1,n2.nodes t.T a d n1[[tn2 for a. S, n . nodes such that n[[Tda)) \n. Intuitively, we require that for each node n of G (NA, ) with an outgoing dispatch a edge, if n occurs \nin the .ow (given by un + zn = 1) then make sure a dispatch to aoccurs in the .ow as well. X x(n,t,n,) \n= 1 . (13) n,n,.nodes,t.Td , n[[tn The above constraint requires that at least one dispatch occurs (note \nthat this entails (8)) since Td . T. LEMMA 8. Given a Petri Net NA, =(G . S,Td . Ts,F,m0) let M * =(V,W,8 \n) be the .ow associated to a satisfying valuation for .N. FN.Let m . V be such that m(a) = 1 for A, A, \na . S, then there is a m1 [[t)) m2 in G (NA, ) such that t . Ta d and m1 [[t)) m2 occurs in W. PROOF: \nWe distinguish two cases: (i) each node m ' of M * is such that m ' (a) = 1 or (ii) some node m ' of \nM * is such that m ' (a)=0. In case (i), constraints (13) shows that at least one dispatch transition \nt . Td must occur in M * which means by de.nition of tthat some place p. G of the form p=(q,E) is such \nthat m '' (p) = 1 at some node m '' . V. Hence we .nd that there is tda . Ta with m '' [tda) (both m \n'' (p) and m '' (a) contain tokens) d a and so that m '' [[td)) mx for some mx holds by Lem. 4 (point \n3). Finally m '' . V shows that um,, = 1 and so the precondition of constraint (12) holds, thus some \nt. Tad must occur in M * . For the case (ii), i.e., some node m ' of M * is such that m ' (a)=0, hypothesis \nm(a) = 1 for some node m of M * shows that m and m ' are distinct. Furthermore observe that m(a) . N \n\\{ 0} because we cannot get to 0 if we were at . as shown by Lem. 4 (point 3). Moreover since m is a \nnode of M * we have that either (a) m occurs before m ' in M * or (b) m ' occurs before m in M *. In \ncase (a) some t . Tda must occur in M * between node m and m ' which concludes the proof. In case (b) \nwe .nd that a call to handler a . S must be posted between m ' and m. Because the .ow starts and ends \nin 8 some t. Tda must occur in M * either between m and 8 or between 8 and m ' . We next show that the \nLTS of NA, has an in.nite path of the form (Ts * \u00b7 Td). that is fair iff the Presburger formula .NA, \n. FNA,is satis.able. PROPOSITION 1. Given a Petri Net NA, =(G. S,Td. Ts,F,m0) we have there exists s \n. (Ts * \u00b7 Td). such that m0 [s) and ssatis.es (11) iff there is a .ow M * =(V,W,8 ) in G (NA, ) which \nsatis.es .N. FN. A, A, PROOF: . By hypothesis, there exists s . (Ts * \u00b7 Td). such that m0 [s) such that \ns satis.es (11), that is, . a . S. i = 0: mi [Tda).. j = i: mj [Tda) mj+1. Our next step is to split \ns into t0t1 ...tn ... where each ti . (Ts * \u00b7Td) *.Let mIi be such that m0 [t0 ...ti-1)mIi , the split \nis such that for each a.S : \u00b8 '* ' m: mIi {w |.w .T : ww = ti}m and m [Tda) or ti nTda = \u00d8 . (14) This \nintuitively says that along ti for each a .S we have that no Tda is enabled ti or some Tda occurs. Splitting \nthis way is possible because for each a.S we have that either (i) there are no pending call at the beginning \nof ti and none is posted along ti or (ii)there are no pending call at the beginning of ti but eventually \nsome call to a is posted along ti in which case ti must contain a Tda which exists by (11) or (iii) there \nare pending calls to aat the beginning of ti and so ti must contain a Tda which exists by (11). Finally, \nwe show that each ti is .nite by contradiction, suppose there is a ti that is in.nite: ti .(Ts * \u00b7Td)..So \nwe have s = t0 ...ti.Since by hypothesis ssatis.es (11) we .nd that for each a.S either no transition \nof Tda is enabled along ti or that whenever some Tda is enabled eventually some transition of Tda .res, \nthat is ti nTda = \u00d8 for ti .(Ts * \u00b7Td) *. Hence a contradiction. Now using Dickson s Lemma over the in.nite \nse\u00adquence mI0 ,mI1 ,...,mIn ,... of markings given by m0 [t0)mI0 [t1)mI1 ...mIn-1 [tn)mIn ... we .nd \nthat there exists i>j such that mIj =mIi . Let u = t0 ...tj,and let v = tj+1 ...ti. By de.nition of the \nt s we .nd that u\u00b7v . .(Ts * \u00b7Td). and so v . .(Ts * \u00b7Td). . Next we show that u\u00b7v . satis.es (11). Since \nv . .(Ts * \u00b7Td). we .nd that v repeatedly enables some Tda for every a . S for which there is a pending \ncall. So, if some transition of Tda is enabled somewhere along t, some transition tof Tda must .re in \nt because of (14). Remark also that because v is repeated in.nitely often, we have that t eventually \n.res (if not in the same t, in its next occurrence) which shows that u\u00b7v . satis.es (11). It follows \nthat m0 [u\u00b7v .)(m0 [s)and there is w .T. such i\u00b8 that s = u\u00b7v\u00b7wshows that m0 [u\u00b7v). Moreover m0 u\u00b7v for \nevery i=1 since .(v) =0). We conclude from m0 [u\u00b7v)and Lem. 4 that there is a path in G(NA, ) labeled \nby v, hence that there is a cycle (or equally a .ow) in G(NA, ) labeled by v because of .(v) =0 and Lem. \n7. The proof ends by showing that the cycle labeled by v (or equally a .ow) satis.es .NA, .FNA, . (12) \nfollows because u\u00b7v . satis.es (11);  (13) follows because u\u00b7v . .(Ts * \u00b7Td).;  (3), (4), (5), (6) \n(7) of .NA, follows because v labels a .ow;  (8) of .NA, is entailed by (13) as we said before;  (9) \nof .NA, follows by .(v) =0.  . Let v . T * be a word corresponding to the .ow M * = (V,W,8).Since .(v) \n= 0, Lem. 4 (point 2) shows that there exists u .T * such that m0 [uv). Then we show that the following \nfacts hold: m0 [u\u00b7v .)(which follows by (9) that says: .(v) =0);  u\u00b7v . .(Ts * \u00b7Td). (by (13) that \nsays: at least one Td occurs in v);  u\u00b7v . satis.es (11). In fact suppose by contradiction that u\u00b7v \n. does not satis.es (11) that is: .a.S .i =0: mi [Tda).(.j =  i: mj [Tda)mj+1 does not hold) Since u\u00b7v \n. .(Ts * \u00b7Td). and by de.nition of Td we can assume that i is such that i =|u|. Hence, .i =|u|: mi [Tda) \nis true shows that mi(a) = 1 andsobyLem.8we .ndthat there is an edge m ' [[t))m '' of G(NA, ) such that \nt . Ta and t occurs in W, hence a d contradiction since no t . Tda is supposed to occur in W by (.j =i: \nmj [Tda)mj+1 does not hold). Hencewehave m0 [u\u00b7v .)is a fair in.nite path in the LTS. To sum up, the \noverall decision procedure to check fair termi\u00adnation combines the above steps: .rst, translate an asynchronous \nautomaton Ainto a recursion-free automaton A ' ; second, construct the associated Petri Net NA, ; third, \nconstruct a coverability graph G(NA, ); and fourth, construct and check if the Presburger formula FN..Nis \nsatis.able. The decision procedure also separately A, A, checks that every handler reachable in the coverability \ngraph is terminating using the algorithm in Section 4.4. The EXPSPACE\u00adhardness of the problem again follows \nfrom the reduction from simple programs. THEOREM 2. [Fair Termination] The fair termination problem is \ndecidable for asynchronous automata and EXPSPACE-hard. 4.7 Fair Non-Starvation Recall that an asynchronous \nautomaton is fair non-starving if (i) every execution of a handler that is called (synchronously or asyn\u00adchronously) \nterminates, and (ii) along every in.nite fair execu\u00adtion no handler is starved. A starving handler corresponds \nto a particular pending call that is never dispatched, thus that waits forever to be executed. Formally, \nan asynchronous automaton is fair non-starving if (i) there is no in.nite run of the second form and \n(ii) for every fair in.nite run (q0,a0,0) .s * (q1,E,c1) .d (q1,a1,c1' ) ...of the .rst form, for every \nhandler a .S,we have ci(a)=0 for in.nitely many i =0. As before, we check (i) sep\u00adarately using the decision \nprocedures of Sect. 4.4. We focus on the decision procedure for (ii). The decision procedure for fair \nnon-starvation is similar to the one for fair termination, the two decision procedure differs when it \ncomes to the Presburger formula. The Presburger formula for fair non-starvation is stronger than the \nformula for fair termination, and obtained by adding constraints to the Presburger formula for fair termination. \nOur encoding is based on the observation that if the asyn\u00adchronous automaton does not satisfy the fair \nnon-starvation there exists an in.nite run (q0,a0,0) .s * (q1,E,c1) .d (q1,a1,c2) ... that is fair and \nfor some a .S along this path some pending call to ais never dispatched (or equally .i=0 .j =i: cj (a) \n>0). We now de.ne the Presburger formula .NA, the variables of which is given by those of FNA, and .NA, \ntogether and the set a {wm |m .nodes .a.S}. De.ne a constraint for each variable aa wm such that wm is \npositive iff in the .-marking m the counter of pending calls to ais positive: w a =1 if m(a) =1 and wm(a)= \nm 0 otherwise. The formula .NA, is de.ned as the conjunction of the above constraints with: _^` \u00b4 a un \n+ zn =1 .wn =1 . a.S n.nodes If FN..N..Nis satis.able we have that there exists A, A, A, w .T. such that \nm0 [w)is a fair path in the LTS of NA, (given by FN..N) and along w some counter of pending calls A, \nA, never gets null (given by .NA, ). That means, in the asynchronous automaton A ' , that some pending \ncall might never be dispatched. Hence wehavethat if FNA, ..NA, ..NA, is satis.able then some in.nite \npath is fair and along this path some pending call is never dispatched. THEOREM 3. [Fair non-starvation] \nFair non-starvation is decid\u00adable for asynchronous automata and EXPSPACE-hard.  5. Alternative Proofs \nfor Fair Termination Our reduction to Petri Nets enables the use of powerful algorith\u00admic techniques \non Petri Nets to be used to analyze asynchronous programs. Indeed, we now show two alternate proofs for \nthe de\u00adcidability of fair termination by encoding the problem into more expressive logics whose model \nchecking question remains decid\u00adable on Petri Nets. Path Logics [37]. We recall a class of path formulas \n(from [37]) for which the model checking problem is decidable. Fix a Petri Net N =(S,T,F,m0). We de.ne \na subset of the logic of [37] that we need to give an alternative decision procedure for fair ter\u00admination. \nLet \u00b51,\u00b52,... be a family of marking variables rang\u00ading over markings and s1,s2,... a family of transition \nsequence variables ranging over T *.A basic predicate is either a marking predicate of the form \u00b5j = \n\u00b5i where \u00b5j and \u00b5i with j>i are marking variables or markings, or a transition predicate of the form \ny .Parikh(s) = c or y .Parikh(s)= c,where s is a transition variable, c . N is a constant, y is a vector \nof in\u00adtegers of dimension |T|,and . denotes the inner product (i.e., Pk (a1,...,ak).(b1,...,bk)= i=1 \nai \u00d7bi). A predicate is either a marking predicate, a transition predicate, or of the forms P1 .P2 or \nP1 .P2 where P1 and P2 are predicates. A path formula is a formula of the form .\u00b51,...,\u00b5m :.s1,...,sm \n: `\u00b4 s1s2sm m0 -.\u00b51 -....\u00b5m-1 --.\u00b5m .F(\u00b51,...,\u00b5m,s1,...,sm) where F is a predicate. The model checking \nproblem for such a path formula asks if there exists a path in the LTS of N of the form m0 [s1)m1 [s2)...mm-1 \n[sm)mm for markings m1,...,mm and transition sequences s1,...,sm . T *,such that F(m1,...,mm,s1,...,sm)is \ntrue. In this case we say N satis.es the path formula. Let NA, =(G.S,Ts .Td,F,m0)be the Petri Net associated \nwith a recursion-free asynchronous automaton A ' .Let r =|T|.We de.ne a path formula such that NA, satis.es \nthe path formula iff there is an in.nite fair path in the LTS of NA, : s1s2 .\u00b51,\u00b52 :.s1,s2 :m0 -.\u00b51 -.\u00b52 \n^ 1r .Parikh(s2)=1.\u00b52 =\u00b51 ^ za .Parikh(s2)=0. a.S `\u00b4 (xa -za).Parikh(s1)=0.xa .Parikh(s2)=0 . where \nza and xa are two vectors of integers of dimension r such ( a(t)= that za(t)=(1 0 if t.Td .F(a,t)=1 otherwise \nand 1 if t.Ts .F(t,a)=1 x 0 otherwise . In the above path formula, the .rst two lines intuitively say \nthat we want to .nd a path m0 [s1 \u00b7s2)in the LTS of NA, where s2 =Eand \u00b52 =\u00b51. The monotonicity property \nof Petri Nets and \u00b52 = \u00b51 shows that m0 [s1 \u00b7s2 .). Intuitively the .rst two lines require that s1 \u00b7s2 \n. .T. is an in.nite path of the LTS of NA, .Let us now turn to the fairness. The fairness constraint \nof the formula requires the path m0 [s1 \u00b7s2 .)to be such that for each handler a . S if no Ta d occurs \nin.nitely often (za .Parikh(s2)=0)then after .ring s1 and before .ring s2 there is no pending call to \na ((xa - za) .Parikh(s1)=0) and no call to a is posted along s2 xa .Parikh(s2)=0. Above we de.ned an \nin.nite path to be fair if it is a-fair for every a . S. An in.nite path is a-fair iff for every marking \nmj along this path, if mj (a)=1then a transition mi [Tda)mi+1 for some i = j must occur. If the in.nite \npaths we consider are of the form s1 \u00b7s2 . (we have shown above this is not restrictive) then apath is \na-fair iff there exists s1 . T * and s2 . T+ such that some Tda occurs in s2 or if the following condition \nholds: there is no pending call to aafter .ring s1 and no call to ais posted along s2. This last condition \nintuitively says that after .ring s1,it always holds that there is no pending call to a, i.e., mj(a)=0for \nevery marking mj in the sequence after .ring s1. Temporal Logic Model Checking [10]. We recall a class \nof for\u00admulas L(GF)(from [10]) for which the model checking problem is decidable. Given a Petri Net N \n=(S,T,F,m0),we de.ne the language L(GF)as follows: atomic formulas (predicates) are ge(p,c)and .(t)where \np . S, t . T, c . N with the following interpretation: for any in.nite path s =m1 [u1)m2 [u2)... in the \nLTS of N and for any n .N, (N,s,n)|=ge(p,c)iff mn(p)=c (N,s,n)|=.(t)iff un+1 =t. formulas are either \nliterals, i.e., atomic formulas or their nega\u00adtions (ge(p,c), \u00acge(p,c), .(t), \u00ac.(t)), or of the form \nGF f, f1 .f2, f1 .f2 where f,f1,f2 are formulas. GF f (it is al\u00adways true that f will hold in future) \ncan be formally de.ned as follows: (N,s,n)|=GF f iff .i=n.j =i:(N,s,j)|=f. The rest of the interpretation \nis natural. Given NA, =(G.S,Ts .Td,F,m0)the Petri Net associated with a recursion-free asynchronous automaton \nA ' we now de.ne a formula such that there is an in.nite path in the LTS of NA, satisfying the formula \niff there is an in.nite path in the LTS of NA, that is fair: ^ _ GF \u00acge(a,1). .(t) . a.S t.T a d The \nformula intuitively says that along every path in the LTS of NA, for every handler a, if there is a pending \ncall to athen there is an eventual dispatch to a. While these produce alternate proofs of decidability, \nwe believe that our presentation of the problem is most amenable to an im\u00adplementation (the model checking \nalgorithm from [37] unrolls the transition relation a doubly exponential number of steps, and the model \nchecking algorithm of [10] reduces to Petri Net reachabil\u00adity, and both have a computability-theoretic \nrather than practical value). 6. Boundedness The reduction of Lem. 3 shows that to every recursion-free \nasyn\u00adchronous automaton, there is a Petri Net with the same set of reachable states. This allows algorithmic \ntechniques from the Petri Net literature to be applied to asynchronous automata. We show how these techniques \ncan be used to prove boundedness properties. An asynchronous automaton is bounded if there exists N .N \nsuch that for every reachable con.guration (q,w,c),for every a . Swe have c(a) = N.The boundedness problem \ntakes as input an asynchronous automaton, and asks if it is bounded. (Note that boundedness is a safety \nproperty.) We can decide the boundedness problem for recursion-free asynchronous automaton by deciding \nthe boundedness problem on the associated Petri Net. This problem is de.ned as follows. Given aPetri \nNet N =(S,T,F,m0),we say N is bounded if there exists n . N such that for every reachable marking m, \nfor every place p . S we have m(p) = n.The boundedness problem takes as input a Petri Net, and asks if \nit is bounded. Let A ' be a recursion-free asynchronous automaton and NA, = (G.S,T,F,m0) be the associated \nPetri Net, Lem. 3 shows that A ' is bounded iff NA, is bounded. Furthermore, the Petri Net NA, is bounded \niff for each m . nodes of any coverability graph G(NA, ) we have m . NP . The reason why a coverability \ngraph is precise enough to check for boundedness is given by Lem. 4 (point 1). Since the size of the \nPetri Net is linear in the size of the recursion-free asynchronous automaton, which can be exponential \nin the size of the original asynchronous automaton, and the search for unbounded executions in the coverability \ngraph can be stopped after a number of steps that is doubly exponential in the size of the Petri Net \n[26], we get a triply exponential algorithm. The hard\u00adness of the algorithm again follows from a reduction \nfrom simple programs to asynchronous automata. THEOREM 4. [Boundedness] The boundedness problem is decid\u00adable \nfor asynchronous automata. It is EXPSPACE-hard. We note that boundedness is neither a necessary nor a \nsuf.cient condition for fair termination. On the one hand, the asynchronous program with one handler \nhwhich posts itself is bounded but not terminating. On the other hand, the asynchronous program from \nFig. 1(b) is fair terminating but unbounded. For each n,there is a fair terminating run which dispatches \nthe handler h1ntimes before dispatching h2.  References [1] O. Burkart and B. Steffen. Pushdown processes: \nParallel composition and model checking. In CONCUR 94, volume 836 of LNCS, pages 98 113. Springer, 1994. \n[2] R. Chadha and M. Viswanathan. Decidability results for well\u00adstructured transition systems with auxiliary \nstorage. In CONCUR 07, volume 4703 of LNCS, pages 136 150. Springer, 2007. [3] P. Chandrasekaran, C.L. \nConway, J.M. Joy, and S.K. Rajamani. Pro\u00adgramming asynchronous layers with CLARITY. In ESEC/SIGSOFT FSE, \npages 65 74. ACM, 2007. [4] R. Cunningham and E. Kohler. Making events less slippery with Eel. In HotOS-X, \n2005. [5] J. Esparza and M. Nielsen. Decidability issues for Petri nets -a survey. Journal of Informatik \nProcessing and Cybernetics, 30(3):143 160, 1994. [6] J. Fischer, R. Majumdar, and T. Millstein. Tasks: \nLanguage support for event-driven programming. In PEPM 07. ACM, 2007. [7] D.Gay,P.Levis, R.von Behren, \nM.Welsh,E.Brewer, and D.Culler. The nesC language: A holistic approach to networked embedded systems. \nIn PLDI 03, pages 1 11. ACM, 2003. [8] J. Hill, R. Szewczyk, A. Woo, S. Hollar, D. Culler, and K. Pister. \nSystem architecture directions for networked sensors. In ASPLOS 00, pages 93 104. ACM, 2000. [9] John \nE. Hopcroft, Rajeev Motwani, and Jeffrey D. Ullman. Introduc\u00adtion to Automata Theory, Languages, and \nComputation (2nd Edition). Addison Wesley, 2000. [10] P. Jan.Decidability of a temporal logic problem \nfor petri nets. car. Theoretical Computer Science, 74(1):71 93, 1990. [11] R. Jhala and R. Majumdar. \nInterprocedural analysis of asynchronous programs. In POPL 07, pages 339 350. ACM, 2007. [12] R.M. Karp \nand R.E. Miller. Parallel program schemata. Journal of Comput. Syst. Sci., 3(2):147 195, 1969. [13] E. \nKohler, R. Morris, B. Chen, J. Jannotti, and M.F. Kaashoek. The Click modular router. ACM TOCS, 18(3):263 \n297, 2000. [14] M. Krohn, E. Kohler, and M.F. Kaashoek. Events can make sense. In USENIX Annual Technical \nConference, 2007. [15] D.J. Lehmann, A. Pnueli, and J. Stavi. Impartiality, justice and fairness: The \nethics of concurrent termination. In ICALP 81, volume 115 of LNCS, pages 264 277. Springer, 1981. [16] \nP. Li and S. Zdancewic. Combining events and threads for scalable network services. In PLDI: Programming \nLanguages Design and Implementation, pages 189 199. ACM, 2007. [17] Libasync. http://pdos.csail.mit.edu/6.824-2004/async/. \n[18] Libevent. http://www.monkey.org/~provos/libevent/. [19] R. Lipton. The reachability problem is exponential-space \nhard. Technical Report 62, Department of Computer Science, Yale University, 1976. [20] Z. Manna and A. \nPnueli. Temporal veri.cation of reactive systems: Progress. Draft, 1996. [21] P. Manolios and D. Vroon. \nTermination analysis with calling context graphs. In CAV 06, volume 4144 of LNCS, pages 401 414. Springer, \n2006. [22] M. Minsky. Finite and In.nite Machines. Prentice-Hall, 1967. [23] V.S. Pai, P. Druschel, and \nW. Zwaenepoel. Flash: An ef.cient and portable web server. In Proc. USENIX Tech. Conf., pages 199 212. \nUsenix, 1999. [24] R.J. Parikh. On context-free languages. Journal of the ACM, 13(4):570 581, 1966. [25] \nM. Presburger. \u00dcber die vollst\u00e4ndigkeit einer gewissen systems der arithmetik ganzer zahlen, in welchem \ndie addition als einzige opera\u00adtion hervortritt. In Comptes Rendus du I congr\u00e8s de Math\u00e9maticiens des \nPays Slaves, pages 92 101. 1929. [26] C. Rackoff. The covering and boundedness problems for vector addition \nsystems. Theoretical Computer Science, 6(2):223 231, 1978. [27] G. Ramalingam. Context-sensitive synchronization-sensitive \nanalysis is undecidable. ACM TOPLAS, 22(2):416 430, 2000. [28] W. Reisig. Petri nets: An introduction. \nSpringer, 1986. [29] T. Reps, S. Horwitz, and M. Sagiv. Precise interprocedural data.ow analysis via \ngraph reachability. In POPL 95, pages 49 61. ACM, 1995. [30] A. Rybalchenko. Temporal Veri.cation with \nTransition Invariants. PhD thesis, Universit\u00e4t des Saarlandes, 2004. [31] H. Seidl, A. Muscholl, T. Schwentick, \nand P. Habermehl. Counting in trees for free. In ICALP 04, volume 3142 of LNCS, pages 1136 1149. Springer, \n2004. [32] K. Sen and M. Viswanathan. Model checking multithreaded programs with asynchronous atomic \nmethods. In CAV 06, volume 4144 of LNCS, pages 300 314. Springer, 2006. [33] R. Valk and M. Jantzen. \nThe residue of vector sets with applications to decidability problems in Petri nets. Acta Informatica, \n21:643 674, 1985. [34] R. Valk and G. Vidal-Naquet. Petri nets and regular languages. Journal of Computer \nand System Sciences, 23(3):299 325, 1981. [35] M.Y. Vardi. Veri.cation of concurrent programs the automata\u00adtheoretic \napproach. Annals of Pure and Applied Logic, 51:79 98, 1991. [36] I. Walukiewicz. Pushdown Processes: \nGames and Model-Checking. Information and Computation, 164(2):234 263, 2001. [37] H.-C. Yen. A uni.ed \napproach for deciding the existence of certain Petri net paths. Information and Computation, 96(1):119 \n137, 1992. \n\t\t\t", "proc_id": "1480881", "abstract": "<p>Asynchronous or 'event-driven' programming is a popular technique to efficiently and flexibly manage concurrent interactions. In these programs, the programmer can post tasks that get stored in a task buffer and get executed atomically by a non-preemptive scheduler at a future point. We give a decision procedure for the fair termination property of asynchronous programs. The fair termination problem asks, given an asynchronous program and a fairness condition on its executions, does the program always terminate on fair executions? The fairness assumptions rule out certain undesired bad behaviors, such as where the scheduler ignores a set of posted tasks forever, or where a non-deterministic branch is always chosen in one direction. Since every liveness property reduces to a fair termination property, our decision procedure extends to liveness properties of asynchronous programs. Our decision procedure for the fair termination of asynchronous programs assumes all variables are finite-state. Even though variables are finite-state, asynchronous programs can have an unbounded stack from recursive calls made by tasks, as well as an unbounded task buffer of pending tasks. We show a reduction from the fair termination problem for asynchronous programs to fair termination problems on Petri Nets, and our main technical result is a reduction of the latter problem to Presburger satisfiability. Our decidability result is in contrast to multithreaded recursive programs, for which liveness properties are undecidable. While we focus on fair termination, we show our reduction to Petri Nets can be used to prove related properties such as fair nonstarvation (every posted task is eventually executed) and safety properties such as boundedness (find a bound on the maximum number of posted tasks that can be in the task buffer at any point).</p>", "authors": [{"name": "Pierre Ganty", "author_profile_id": "81392617027", "affiliation": "University of California, Los Angeles, CA, USA", "person_id": "P1300938", "email_address": "", "orcid_id": ""}, {"name": "Rupak Majumdar", "author_profile_id": "81100319213", "affiliation": "University of California, Los Angeles, CA, USA", "person_id": "P1300939", "email_address": "", "orcid_id": ""}, {"name": "Andrey Rybalchenko", "author_profile_id": "81100483883", "affiliation": "Max Planck Institute for Software System, Germany", "person_id": "P1300940", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1480881.1480895", "year": "2009", "article_id": "1480895", "conference": "POPL", "title": "Verifying liveness for asynchronous programs", "url": "http://dl.acm.org/citation.cfm?id=1480895"}