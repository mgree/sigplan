{"article_publication_date": "01-21-2009", "fulltext": "\n Types and Higher-Order Recursion Schemes for Veri.cation of Higher-Order Programs Naoki Kobayashi Tohoku \nUniversity koba@ecei.tohoku.ac.jp Abstract We propose a new veri.cation method for temporal properties \nof higher-order functional programs, which takes advantage of Ong s recent result on the decidability \nof the model-checking problem for higher-order recursion schemes (HORS s). A program is trans\u00adformed \nto an HORS that generates a tree representing all the possi\u00adble event sequences of the program, and then \nthe HORS is model\u00adchecked. Unlike most of the previous methods for veri.cation of higher-order programs, \nour veri.cation method is sound and com\u00adplete. Moreover, this new veri.cation framework allows a smooth \nintegration of abstract model checking techniques into veri.cation of higher-order programs. We also \npresent a type-based veri.cation algorithm for HORS s. The algorithm can deal with only a frag\u00adment of \nthe properties expressed by modal \u00b5-calculus, but the al\u00adgorithm and its correctness proof are (arguably) \nmuch simpler than those of Ong s game-semantics-based algorithm. Moreover, while the HORS model checking \nproblem is n-EXPTIME in general, our algorithm is linear in the size of HORS, under the assumption that \nthe sizes of types and speci.cations are bounded by a constant. Categories and Subject Descriptors D.2.4 \n[Software Engineer\u00ading]: Software/Program Veri.cation; F.3.1 [Logics and Meaning of Programs]: Specifying \nand Verifying and Reasoning about Pro\u00adgrams General Terms Languages, Veri.cation 1. Introduction With \nthe increasing importance of software reliability, program ver\u00adi.cation techniques have been studied \nextensively. There are still limitations in the current veri.cation technology, however. Soft\u00adware model \nchecking [3 5] has been mainly applied to impera\u00adtive programming languages, and applications to programming \nlan\u00adguages with more dynamic control, such as higher-order languages with dynamic allocation of resources \n(such as heap memory), have been limited. For higher-order programs, type systems have been recognized \nas effective techniques for program veri.cation. How\u00adever, they either require explicit type annotations \n(as in dependent type systems), or suffer from many false alarms. In this paper, we propose a novel veri.cation \ntechnique for tem\u00adporal properties of higher-order programs. We consider the prob- Permission to make \ndigital or hard copies of all or part of this work for personal or classroom use is granted without fee \nprovided that copies are not made or distributed for pro.t or commercial advantage and that copies bear \nthis notice and the full citation on the .rst page. To copy otherwise, to republish, to post on servers \nor to redistribute to lists, requires prior speci.c permission and/or a fee. POPL 09, January 18 24, \n2009, Savannah, Georgia, USA. Copyright c . 2009 ACM 978-1-60558-379-2/09/01. . . $5.00 lem of resource \nusage veri.cation [19] for higher-order functional languages with dynamic resource creation and access \nprimitives. The goal of the veri.cation is to check that each dynamically cre\u00adated resource is accessed \nin a proper manner (like an opened .le is eventually closed, and it is not read or written after being \nclosed ). Assertion-based model-checking problems (like X>0 holds at program point p ) can also be recasted \nas the resource veri.cation problem, by regarding an assertion failure as an access to a global resource. \n(For example, assert(b) can be transformed into if b then skip else fail, where fail is an action to \nthe global resource. Then the problem of checking lack of assertion failures is reduced to the resource \nusage veri.cation problem of checking whether the fail action occurs.) Our veri.cation technique is built \non the recent result on model checking of higher-order recursion schemes (HORS s, for short) [29]. A \nhigher-oder recursion scheme is a grammar for de\u00adscribing an in.nite tree. HORS is a generalization of \nregular tree grammars; they are described by HORS s of order 0. Ong [29] has recently shown the decidability \nof the problem of checking whether the in.nite tree generated by G satis.es ., given a modal \u00b5-calculus \nformula .and an HORS G. The .rst main idea of this paper is to transform a higher-order functional program \ninto an HORS that produces an in.nite tree, each of whose path (from the root) corresponds to a possible \nac\u00adcess sequence to each resource. By the transformation, the problem of checking a regular property \nof resource-wise access behaviors of a functional program is reduced to that of checking the cor\u00adresponding \nregular property of the in.nite tree generated by the HORS. The latter can be solved by Ong s model checking \nalgo\u00adrithm for HORS [29]. For programs having only resources and functions as values, the transformation \ninto HORS is achieved by CPS conversion and .-lifting, along with an additional trick to ex\u00adtract resource-wise \naccess behavior. For programs with ordinary values (such as integers), we can apply the technique of \npredicate abstractions and counter-example-guided abstraction re.nement. The resulting veri.cation framework \nis sketched in Figure 1. Given a source program, we .rst apply CPS conversion and .-lifting to get a \nsystem of top-level function de.nitions (Step 1). We then apply predicate abstractions to get a higher-order \nboolean program (Step 2). It is then converted to HORS (Steps 3 and 4), and the HORS is model-checked \n(Step 5). If the model checking fails, a counterex\u00adample is investigated, and the abstraction is re.ned \n(Steps 6 and 7). The second main idea of this paper is to use types for model\u00adchecking HORS, instead \nof Ong s algorithm based on game se\u00admantics. For a fragment of modal \u00b5-calculus (for describing safety \nproperties, which are suf.cient for the purpose of resource usage veri.cation), we develop an intersection \ntype system that is sound and complete, in the sense that an HORS is well-typed if and only if the HORS \nsatis.es the given property. Thus, a type inference algo\u00adrithm for that type system serves as an alternative \nmodel checking algorithm for HORS. The resulting veri.cation algorithm is (ar\u00adguably) simpler and easier \nto understand than Ong s algorithm [29]. Moreover, although the resulting algorithm suffers from the \nsame worst-case time complexity (i.e., n-EXPTIME for order-nHORS) as Ong s algorithm, our algorithm runs \nin time linear in the size of the rules of HORS, under the assumption that the size of types and speci.cations \nare bound by a constant. An additional advantage of the type-based veri.cation of HORS is that it makes \neasier to compare the new resource usage veri.cation method with previous type-based methods for resource \nusage veri.cation (or, typestate checking) [12, 19, 32], and combine them together. In fact, previ\u00adous \ntype systems for resource usage veri.cation may be viewed as a restriction of our intersection type system, \nwith a limited form of intersection types. Thus, we can .rst apply previous type sys\u00adtems to veri.cation \nof HORS, and then gradually re.ne types (by allowing more .exible intersection types). Since the full \nintersec\u00adtion type system is complete, the re.nement process will eventually terminate and produce a \nyes/no answer. The whole veri.cation framework thus obtained is an integra\u00adtion of model checking and \ntype-based veri.cation techniques. We use model-checking techniques (predicate abstraction with counter-example-guided \nabstraction re.nement) to abstract infor\u00admation about data (or base values), and type-based techniques \nto abstract information about control (or functions). The rest of this paper is structured as follows. \nSection 2 reviews the de.nitions and the decidability result on higher-order recursion schemes. Section \n3 de.nes the resource usage veri.cation problem for a language having only resources and functions as \nvalues, and shows the reduction of the resource usage veri.cation to the model\u00adchecking problem of HORS. \nSection 4 discusses how to extend the veri.cation method to deal with source programs (having ordinary \ndata such as integers), by using techniques of abstract model check\u00ading. Section 5 presents an intersection \ntype system that is sound and complete for (safety properties of) HORS, and discusses its type in\u00adference \nalgorithm. Section 6 (informally) compares the intersection type system with existing type systems for \nresource usage veri.ca\u00adtion. Section 7 discusses related work, and Section 8 concludes. Omitted proofs \nand more examples are found in the extended version of this paper [25]. 2. Preliminaries 2.1 Higher-Order \nRecursion Schemes This subsection reviews the de.nition of higher-order recursion schemes and decidability \nresults [29]. A higher-order recursion scheme (HORS, for short) is a gram\u00admar for describing an in.nite \ntree. The set of types is de.ned by: . ::=o | .1 . .2 Intuitively, o describes trees, while .1 . .2 describes \na function that takes an entity of type .1 and returns an entity of type .2.The order and arity of ., \nwritten order(.)and arity(.)respectively, are de.ned by: order (o)=0 order (.1 . .2)=max(order (.1)+1,order(.2)) \narity(o)=0 arity(.1 . .2)=arity(.2)+1 A (deterministic) HORS G is a 4-tuple (S,N ,R ,S),where Sis a \nmapping from a .nite set of symbols called terminals to types of order 0or 1.  N is a mapping from a \n.nite set of symbols called non\u00adterminals to types.  source program  Step 7: top-level abstraction \nfunction def.  re.nement no Program is unsafe Step 6: higher-order real counter- boolean program \n example? yes counterexampleabstract program Step 5: model checking HORS (Section 5)  success Program \nis safe Figure 1. Veri.cation Framework R is a set of rewriting rules of the form: { F1 xe1 . t1,...,Fn \nxen . tn} Here, xeabbreviates a sequence of variables, and t is a term constructed from non-terminals, \nterminals, and variables (see below). There must be exactly one rule of the form Fxe. t for each non-terminal \nF .N .1 S is a special non-terminal called the start symbol. We require that N (S)= o. The set of (typed) \nterms is de.ned in the standard manner: A symbol (i.e., a terminal, non-terminal, or variable) of type \n.is a term of type ..If terms t1 and t2 have types .1 . .2 and .1 respectively, then t1 t2 is a term \nof type .2.For each rewriting rule Fxe. t, Fxeand t must be terms of type o. The order of an HORS is \nthe highest order of its non-terminals. By abuse of notation, we often write a . S and F .N for a. dom(S)and \nF . dom(N ). The rewriting relation -. G is de.ned inductively by: Fse-. G [s/ex. tis a ruleof G . ex]tif \nF e '' If t-. G t',then ts-. G tsand st-. G st. We omit the subscript G if it is clear from the context. \nWe need auxiliary de.nitions to de.ne the (possibly in.nite) tree generated by G .Let n be the maximum \narity of symbols in S. A (possibly in.nite) tree over S is a partial function t from { 0,...,n - 1} * \nto dom(S), such that: (1) E . dom(t);(2) the domain of tis closed under pre.x operations; and (3) if \nt(w)=a and arity(S(a)) = m,then w0,...,w(m - 1) . dom(t).A (possibly in.nite) sequence p over { 0,...,n- \n1} is a path of tif every .nite pre.x of pis in dom(t). We often use the usual term representation for \ntrees. For exam\u00adple, we write br ab for the tree: { E . br,0. a,1. b} . 1 This restriction is not present \nfor non-deterministic HORS. We consider only deterministic HORS s in this paper. br /. ca br /. ba c \nbr /. ba b br /. c .. .. Figure 2. The value tree [[G 0]] Given a term t, wede.ne a(.nite) tree t. by: \n8 < f if tis a terminal f t. = t1 .t2 . if tis of the form t1t2 and t1 . = . : . otherwise For example, \n(f (Fa) b). = f . b.Let . be the partial order on dom(S) .{.} de.ned by . a . dom(S)... a. It is extended \nto the partial order on trees by: t . s iff . w . dom(t).(w . dom(s) . t(w) . s(w)). For example, .. \nf .. . f . b . F fab.For a set T of trees, we write T for the least upper bound of elements of T with \nrespect to . . The value tree of G , written [[G ]], is de.ned by: G [[G ]] = { t . | S -. G* t} . EXAMPLE \n2.1. Consider the recursion scheme G 0 =(S,N ,R ,S),where: S= { br : o . o . o,a,b : o . o,c : o} N = \n{ S : o,F : o . o} R = { S . F c,Fx . br x(a(F(b(x))))} S can be reduced as follows. S -. F c -. br c \n(a(F(b(c)))) -. br c (a(br (b(c)) (a(F(b(b(c))))))) -. \u00b7\u00b7\u00b7 The value tree [[G 0]] is shown in Figure \n2. 0 In general, the value tree of HORS may have a non-regular structure. For example, in the example \nabove, the set of paths from the root of the value tree is { br(abr)nc | n = 0} . According bn to the \nrecent result [29], however, given an HORS G and a regular property ., it is decidable whether the value \ntree of G satis.es .. THEOREM 2.1 (Ong [29]). Let G be an HORS of order n, and . be a formula of modal \n\u00b5-calculus. The problem of checking whether [[G ]] satis.es .is n-EXPTIME-complete. REMARK 2.1. In this \npaper, we only consider HORS s whose value trees do not contain . . That condition is indeed satis.ed \nby the higher-order recursion schemes generated by our veri.cation method discussed in Section 3.  2.2 \nTree Automata for In.nite Trees We use tree automata for describing properties of (the value tree of) \nHORS, instead of modal \u00b5-calculus formulas. We recall below some basic de.nitions of (top-down) tree \nautomata for in.nite trees. See [33] for a good survey of logics and automata for in.nite trees. AB\u00a8uchi \nautomaton is a 5-tuple M =(Q,S,qS ,.,QF ) where: Qis a .nite set of states.  S is a mapping from a \n.nite set of input symbols to types of order 1.2  qS (. Q) is a state called an initial state.  S \n. . k(Q\u00d7 dom(S) \u00d7 Qk), such that if (q,a,q1,...,qk) . .,then arity(S(a)) = k(that is, the arity of ais \nrespected).  QF (. Q) is a set of states, called accepting states.  A run of M on the tree t over S \nis a tree . over Q, such that .(E)= qS and (.(w),t(w),.(w0),...,.(w(k - 1))) . . for any w . dom(t) and \nk =S(t(w)).The run .is successful if for each in.nite path p, there are in.nitely many pre.xes w0,w1,... \nof p such that .(wi) . QF . (In other words, a run is successful if every in.nite path of the run visits \naccepting states in.nitely often.) The automaton M accepts tif there is a successful run of M on t. Actually, \nin this paper, we will consider only the case where QF = Q,sothat M accepts t if there is a run of M \non t.This is called a trivial automaton in [1]. Such automata can be used to express safety properties, \nmeaning that a bad thing never happens (when a tree is traversed from the root). 3. Resource Usage Veri.cation \nBased on Higher-Order Recursion Scheme In this section, we de.ne the problem of resource usage veri.cation \nand show how to reduce it to the model-checking problem for an HORS. The target language for resource \nusage veri.cation in this section is a simply-typed functional language with resources and non-deterministic \nbranches. Extensions of the language with values (such as booleans and integers) and conditional branches \nwill be discussed in Section 4. 3.1 Overview The idea of reducing a resource usage veri.cation problem \nto an HORS model-checking problem is to transform a program into an HORS that generates a tree denoting \nall the possible resource access sequences. For example, consider the following program (written in OCaml-like \nlanguage): let rec g x = if b then close(x) else read(x); g(x) in let r = open_in \"foo\" in g(r) It opens \na read-only .le foo, reads it several times, and then closes it. We shall transform the above program \nto a recursion scheme that generates a tree like the one in Figure 3. In the .gure, the terminals c r \nand c stand for read and close operations, and the terminal .r * stands for creation of a read-only .le \n(descriptor). br and *denote a non-deterministic branch and a program termination respectively. The tree \ncan be generated by the following higher-order recursion scheme: Gxk . br (c(k)) (r(Gxk)) .rc S . * (Gd \n*) Note that this is essentially a CPS-transformation! G has an addi\u00adtional parameter k for expressing \nthe rest of the computation, and close(x) has been replaced by c, followed by k. Unlike in the usual \nCPS program, however, resource access primitives read and close have been replaced by the terminals (or, \ntree constructors) r 2 S may also be regarded as a mapping from input symbols to non-zero arities. We \nrequire that the arity is non-zero, so that every branch of a tree has an in.nite path. * .rc br /. cr \n* br /. cr * br /. cr * .. Figure 3. A tree that represents possible resource access sequences and c. \nThe conditional branch in g has been replaced by the termi\u00adnal br, which expresses a non-deterministic \nbranch. In the recur\u00adsion scheme above, d is a dummy symbol; the .rst argument of G above is in fact \nunnecessary. As the example above shows, for a program that accesses a single resource, an HORS generating \nthe resource access tree is obtained by CPS transformation followed by .-lifting (that moves local function \nde.nitions up to top-level; this is necessary since higher-order recursion schemes do not have local \nrewriting rules). An additional trick is required, however, for a program that creates and accesses more \nthan one (possibly an in.nite number of) resources. For example, consider the following program: let \nrec f x y = if b then close(x);close(y) else read(x);write(y);f x y in let r1 = open_in \"foo\" in let \nr2 = open_out \"bar\" in f r1 r2 Since we need to verify that each of r1 and r2 will be accessed in a valid \nmanner, we transform the program into an HORS that generates a tree that represents resource-wise access \nsequences. The required HORS is: Fxyk . br (xc (yc k)) (xr (yr (Fxyk))) c S . br (C1 K)(.r * (C1 I)) \nc C1 x . br (FxK*)(.w * (FxI*)) Ixk . xk Kxk . k Here, upon a resource creation, the resource is non-deterministically \ninstantiated to I or K, of type (o . o) . o . o (see the rules for Sand C1). When the resource is instantiated \nto I, it is recorded that a resource has been created, by .. I and K take a resource access operation \nx as an argument; I attaches x to the access tree, while K just ignores x. Intuitively, I is a resource \nfor which we should keep track of access sequences, while K is a resource for which we should ignore \naccess sequences. An access to a resource x(which is bound to either I or K) is now transformed into \nxak,where a is the name of the access primitive, and k is the tree representing the rest of the computation. \nIf x is I, then it is evaluated to a(k); otherwise (if xis K), it is evaluated to k, with abeing ignored. \nThe tree generated by the above recursion scheme is shown in Figure 4. The four sub-trees marked by dashed \nboxes express possible access sequences obtained by keeping track of different resources. In t1, both \nthe resources are ignored. In t2, the write\u00adonly .le is focused on, while in t3, the read-only .le is \nfocused on. Both .les are focused on in t4. For the purpose of resource usage veri.cation, we need to \ncheck only t2 and t3; we can blindly accept the subtrees t1 and t4, which either contain no ., or more \nthan one .. * * br .r * br br .r * c t1 .wc t4 t2 t3 Figure 4. A tree that represents access sequences \nfor two resources In the rest of this section, we .rst introduce a functional lan\u00adguage and formally \nde.ne the resource usage veri.cation problem in Section 3.2. We then de.ne the transformation from programs \ninto HORS s, and prove the correctness in Section 3.3. 3.2 Resource Usage Veri.cation We introduce a \nfunctional language and the resource usage veri.\u00adcation problem for it. Since the CPS transformation \nand .-lifting have been well studied, we consider programs that are already in the continuation-passing \nstyle, having only top-level function def\u00adinitions.3 The language we consider here has essentially the \nsame expressive power as Igarashi and Kobayashi s .-calculus with re\u00adsources [19]. (Their calculus does \nhave booleans, but their type\u00adbased analysis does not distinguish between true and false, treating a \nconditional as a non-deterministic choice.) A program D is a set of function de.nitions {F1 xe1 = e1,...,Fn \nxen = en},where Fi denotes a de.ned function sym\u00adbol, and eranges over the set of expressions, de.ned \nby: e::= * | x| F | e1e2 | if* e1 e2 | new L e| acca xe We assume that F1,...,Fn are different from each \nother, and that any program D contains exactly one de.nition for S (which is the main function), of the \nform S = e. The expression *is the unit-value. The expression e1e2 applies the function e1 to e2,and \nif* e1 e2 non-deterministically executes e1 or e2. The expression new L ecreates a resource that should \nbe used according to the speci.cation L, and passes it to e(which is a function that takes a resource \nas an argument). Here, Lis the set of access sequences that may occur until the program terminates. For \nexample, the speci.cation for read-only .les is {c,rc,rrc,...}. Note that the set does not contain the \nsequence r, since .les must be closed before the program termination. In this paper, we assume that Lis \na regular language.4 acca xeapplies an operation of name ato the resource x, and then evaluates e. aranges \nover a .nite set of the names of resource access primitives (like r, w,and c). We write [e1/x]e2 for \nthe expression obtained by replacing all the occurrences of x in e2 with e1. A sequence of expressions \ne1,...,en is often abbreviated to e . 3 Note that the CPS transformation and .-lifting do not change \nthe resource access sequences that we are interested in. 4 Most of the previous methods for resource \nusage or typestate veri.ca\u00adtion [12, 32] impose essentially the same restriction. Replacing the class \nof regular languages with that of context-free languages make the problem undecidable. We consider only \nwell-typed programs below. The set of types is given by: t (types) ::=R | unit | t1 . t2 Here, R is the \ntype of resources and unit is the type of the unit value. A type environment, denoted by G, is a mapping \nfrom variables (including function names F1,...,Fn) to types. The type judg\u00adment relation Gf e :t for \nexpressions is the least relation closed under the following rules: Gf * :unit G,x:t f x:t G,F :t f F \n:t Gf e1 :t1 . t2 Gf e1 :unit Gf e2 :t1 Gf e2 :unit Gf e1e2 :t2 Gf if* e1 e2 :unit Gf e:R . unit Gf \ne1 :R Gf e2 :unit Gf new L e:unit Gf acca e1 e2 :unit A program D ={F1 xe=e1,...,Fn xe=en} is well-typed, \nif there exists a type environment G=F1 :te1 . unit,...,Fn:ten . unit such that G,xe:tei f ei : unit \nholds for each i; Here, te. unit and xe:teare abbreviations of t1 . \u00b7\u00b7\u00b7 . tn . unit and x1 :t1,...,xn \n:tn respectively. Note that all the de.ned function symbols have types of the form te. unit. That condition \nis met by programs in CPS form. REMARK 3.1. The above language contains programs that are not images \nof CPS transformation. The transformation in the rest of this section applies not only to images of CPS \ntransformation but to the whole language. We now de.ne an operational semantics by using the relation \n(H,e) -.D (H ' ,e ' ) on run-time states. A run-time state is expressed by a pair (H,e),where eis the \ncurrent expression, and H maps each resource to a pair (w,L),where Lis the speci.cation of the resource, \nand w is the sequence of accesses that have occurred so far. The relation (H,e) -.D (H ' ,e ' )is the \nleast relation closed under the following rules. (H,F e ' )-.D.{Fxe=e} (H,[e ' /xe]e) (H,if* e1 e2)-.D \n(H,e1) (H,if* e1 e2)-.D (H,e2) (H,new L e)-.D (H .{x. (E,L)},ex) (x. dom(H)) (H l{x. (w,L)},acca xe)-.D \n(H .{x. (wa,L)},e) Here, H l{x . (w,L)} is de.ned to be H .{x . (w,L)}only if x. dom(H). wais the concatenation \nof the two strings w and a. REMARK 3.2. Note that the reduction is allowed only at the top\u00adlevel; For \nexample, (H,F(if* e1 e2))-.D (H,F e1)is not al\u00adlowed. This is not a limitation, since we are dealing \nwith programs in CPS form. The following is the standard type soundness property. LEMMA 3.1. Suppose \nD is well-typed. If (\u00d8,S) -. * (H,e), D '' '' then either eis *or (H,e)-.D (H ,e )for some (H ,e ). We \nnow de.ne the problem of resource usage veri.cation. The .rst condition says that no invalid resource \naccess occurs, and the second condition says that all the required accesses must have occurred when the \nprogram terminates. DEFINITION 3.1 (resource safety, resource usage veri.cation). A (well-typed) program \nDis resource-safe if the following conditions are satis.ed. 1. If (\u00d8,S)-. * D (H,e)and H(x)=(w,L),then \nww ' . Lfor some w ' . 2. If (\u00d8,S)-. * x)=(w,L),then w . L.  D (H,*)and H( Resource usage veri.cation \nis the problem of checking whether a given (well-typed) program is resource-safe or not.  3.3 Transformation \ninto HORS We now give a transformation of a program Dinto a pair consisting of an HORS H(D)and a tree \nautomaton M(D)(for in.nite trees), such that D is resource-safe if and only if [[H(D)]]is accepted by \nM(D). Let Fnames(D), Anames(D),and Specs(D) be the sets of de.ned function symbols, access primitive \nnames (such as r, w), speci.cations (Lthat appears in the form new L) respectively. The transformation \nH from programs to HORS s is de.ned by: H(D)=(S,N ,R,S) where: S=Anames(D).{.L | L . Specs(D)}.{call,t,br}N \n=Fnames(D).{new L | L . Specs(D)}.{acca | a. Anames(D)}.{if*,I,K,*} R ={Fxe. call(e)| Fxe=e. D} .{acca \nxy . xay,| a. Anames(D)} .{new L x. br (xK)(.L(xI))| L. Specs(D)} .{if* xy . br xy, Ixy . x(y), Kxy . \ny, * . t(*)} Here, the types of terminals and non-terminals are given by: * :o a,t,call,.L :o . o I,K \n:(o . o). o . o if*,br :o . o . o new L :(((o . o). o . o). o). o acca :((o . o). (o . o)). o . o The \ntransformation above follows the ideas sketched in Sec\u00adtion 3.1, except the following points. For each \nfunction de.nition, an extra node call is inserted, to ensure that the value tree of H(D) does not contain \n. (recall Remark 2.1). Unlike in Figures 3 and 4, the symbol * (which expresses a termination) is a non-terminal, \nand reduced to the in.nite tree t(t(t(\u00b7\u00b7\u00b7 ))). This is for ensuring that all the branches of the value \ntree of H(D)are in.nite. The following lemma guarantees that H(D) is certainly a higher-order recursion \nscheme. LEMMA 3.2. If D is well typed, then H(D) is a higher-order recursion scheme. Proof It suf.ces \nto show that the generated rewriting rules are well-typed. We de.ne H(t), the translation of types into \ntree types, by: H(unit)= o, H(R)=(o . o) . o . o,and H(t1 . t2)= H(t1) .H(t2). Then, it is easy to see \nthat G f e : t implies e is a term of type H(t)under the typing context H(G), and that all the rewriting \nrules (in the de.nition of R above) are well-typed. D The tree automaton M(D) is constructed as follows. \nLet Specs(D)= {L1,...,Ln}.Let M1 =(Q1,S1,d1,qS,1,QF,1), ..., Mn =(Qn,Sn,dn,qS,n,QF,n)be deterministic \n.nite state automata (for strings) that accept L1,...,Ln respectively. Here, S1 .\u00b7\u00b7\u00b7. Sn . Anames(D). \nWe assume that the sets of states Q1,...,Qn are disjoint from each other. Then, M(D)is a B\u00a8uchi tree \nautomaton (Q,S,qS,.,QF ) where: Q= QF = {qS,qt}.Q1 .\u00b7\u00b7\u00b7.Qn .= {(qi,a,qj) |dk(qi,a)= qj for some k}.{(qS,.Li \n,qS,i) |i.{1,...,n}}.{(q,t,qt) |q .QF,1 .\u00b7\u00b7\u00b7.QF,n .{qt,qS}}.{(q,.Li ,qt) |q .Q\\{qS},i .{1,...,n}}.{(q,br,q,q) \n|q .Q}.{(q,call,q) |q .Q}.{(qt,a,qt) |a.Anames(D)} The 3rd set of . describes transitions for the program \ntermi\u00adnation. The transitions are de.ned if the focused resource (i.e., the resource that has been instantiated \nto I) has been used up (i.e. if q . QF,1 . \u00b7\u00b7\u00b7. QF,n), if no resource has been instantiated to I (i.e., \nif q = qS), or if the automaton is already in the .nal state qt. The 4th set of . describes transitions \nfor the case where more than one resources have been instantiated to I (as in the subtree t4 in Figure \n4); in that case, the automaton goes to the .nal state qt, so that all the remaining subtrees are ignored \n(by the last set of .). The 6th set of . says that call is just skipped (recall Remark 2.1). EXAMPLE \n3.1. Recall the second program in Section 3.1: let rec f x y = if b then close(x);close(y) else read(x);write(y);f \nx y in ... It is expressed as the following program D: S = new r * c C1 C1 x = new w * c (C2 x) C2 xy \n= Fxy* Fxyk = if*(accc x(accc yk)) (accr x(accw y (Fxyk))) The recursion scheme H(D) is (S,N,R,S) where: \nc c dom(S) = {r,w,c,.r * ,.w * ,call,t,br} rc wc dom(N)= {S,C1,C2,F,new * ,new * ,accr ,accw ,accc , \nif*,I,K,*} R= {S .call(new r * c C1), C1 x.call(new w * c (C2 x)), C2 xy .call(Fxy*), Fxyk .call(if*(accc \nx(accc yk)) (accr x(accw y (Fxyk)))), accr xy .xr y,accw xy .xw y, accc xy .xc y, rc c new * x.br (xK)(.r \n* (xI)), wc c new * x.br (xK)(.w * (xI)),\u00b7\u00b7\u00b7} The tree automaton M(D) is shown in Figure 5. All the states \nare accepting states, so that a tree is rejected only if there is no run for the tree. For example, a \ntree of the form .w * c (r(\u00b7\u00b7\u00b7)) will be rejected. 0 The correctness of the transformation is stated \nas follows. THEOREM 3.3. Let D be a (well-typed) program. Then, D is resource-safe if and only if [[H(D)]] \nis accepted by M(D). To prove the theorem above, it suf.ces to establish a correspon\u00addence between the \nexecution of D and the reduction of H(D). More speci.cally, (i) if (\u00d8,S) -. * (H,e), then there exists \nt D such that S -.H* (D) t and t. has a path that matches a shuf.e of .L1 w1,...,.Lk wk (with br and \ncall being ignored) where H(xi)=(wi,Li) for some x1,...,xn . dom(H). and (ii) if S -.H* (D) t, then for \nevery path p of t. that does not con\u00adtain t, there exists H and e such that (\u00d8,S) -.D * (H,e) and p \n  r,w,t,.r * c ,.w * c Figure 5. The transition diagram for the automaton M(D) in Example 3.1 (transitions \nfor br and call are omitted) matches a shuf.e of .L1 w1,...,.Lk wk where H(xi)=(wi,Li) for some x1,...,xn \n.dom(H). See the extended version [25] for the proof. The following corollary follows immediately from \nTheorems 2.1 and 3.3. COROLLARY 3.4. The resource usage veri.cation problem is de\u00adcidable. REMARK 3.3. \nInstead of generating a single HORS and a tree automaton from a program, we can also generate a pair \nof an HORS and a tree automaton for each occurrence of new L. Then, the resource usage veri.cation problem \nis reduced to aset of model-checking problems for HORS. For instance, the program in Example 3.1 can \nbe transformed into the following two HORS s. * R1 = {S .call(new r c C1), C1 x.call(C2 xK) C2 xy .call(Fxyk), \nFxyk .call(if*(accc x(accc yk)) (accr x(accw y(Fxyk)))),...} R2 = {S .call(C1 K) C1 x.call(new w * c \n(C2 x)), C2 xy .call(Fxyk), Fxyk .call(if*(accc x(accc yk)) (accr x(accw y(Fxyk)))),...} This alternative \napproach may be preferable in practice, as the size of each tree automaton is kept small. 4. Abstract \nModel Checking for Higher-Order Programs We have so far considered the language having only resources \nand functions. This section informally discusses how to extend the veri.cation method to deal with ordinary \nvalues (such as booleans and integers), by using the existing techniques for abstract model checking. \nA naive approach would be to throw away all the values except resources and functions. That, however, \nleads to many false alarms. For example, consider the following program: let f b x = (if b then lock(x) \nelse ()); (if b then unlock(x) else ()) in f true (newlock()) If b is true, then fbx locks and unlocks \nx; otherwise it does nothing on x. Therefore, it safely uses the lock x. If we ignore the parameter b, \nhowever, we get the following abstract program (in CPS): Fkx= if*(acclck x(Cxk)) (Cxk) Cxk= if*(acculck \nxk) k (lck ulck) * S= new(F*) Here, lck and ulck stand for lock and unlock operations respec\u00adtively. \nThe abstract program is not resource-safe, since it may un\u00adlock xwithout having locked x. We can use \ntechniques for abstract model checking to deal with the above problem. First, let us consider boolean \nhigher-order programs, where we have only booleans, resources, and functions as values. The program given \nabove is in fact a boolean program. It can be expressed in CPS as follows. Fbkx= if b(acclck x(Cbxk)) \n(Cbxk) Cbxk= if b(acculck xk) k (lck ulck) * S= new(F 1 *) Here, weexpresstrueand falseby 1 and 0 respectively. \nWe can easily eliminate the boolean parameters, and obtain:5 F0 kx= C0 xk F1 kx= acclck x(C1 xk) C0 xk= \nkC1 xk= acculck xk (lck ulck) * S= new(F1 *) The resulting program can be veri.ed by using the method \nin the previous section. Thus, the resource-safety veri.cation problem re\u00admains decidable (Corollary \n3.4) for the extension of the language in the previous section with booleans and conditionals. As the \nboolean elimination may cause the size of the program to blow up, it might be better to extend an HORS \nmodel checking algorithm (Ong s al\u00adgorithm or the type-based algorithm discussed in Section 5) to deal \nwith booleans directly. If the language is extended with in.nite value domains (such as integers and \nrecursive data structures), then the resource usage veri.cation problem becomes undecidable. For such \nan extension, we can use predicate abstractions together with counter-example\u00adguided abstraction re.nement \n[3]. An important point is that if an HORS fails to satisfy a property, a counter-example can be con\u00adstructed \nby our model-checking algorithm for HORS s discussed in Section 5, as in the ordinary model checking \nfor .nite state sys\u00adtems. Therefore, the abstraction-re.nement cycle can be organized in a standard manner. \nThe entire framework of veri.cation is illustrated in Figure 1. A source program is .rst transformed \ninto a system of top-level function de.nitions in CPS (Step 1 in Figure 1). Predicate abstrac\u00adtion is \nthen applied to obtain a (non-deterministic) higher-order boolean program (Step 2). As in the standard \nabstract model check\u00ading with counter-example-guided abstraction re.nement [3], we can start with the \nsimplest abstraction (which ignores values com\u00adpletely), and then gradually re.ne abstractions. As explained \nabove, boolean values are then eliminated and an abstract program of the language in Section 3.2 is obtained \n(Step 3). Then, the program is converted to a higher-order recursion scheme, as discussed in Sec\u00adtion \n3.3 (Step 4). The higher-order recursion scheme is then veri\u00ad.ed by using the type-based method described \nin Section 5 (Step 5). If the veri.cation succeeds, we can conclude that the source pro\u00adgram is resource-safe. \nOtherwise, we can construct a counterexam\u00adple (which is a straight-line program without function calls) \nbased on the veri.cation algorithm for HORS described in Section 5. By investigating the corresponding \nexecution sequence of the original program, we can check whether the counterexample is a real one (Step \n6). For this purpose, the standard weakest precondition com\u00adputation would suf.ce. If it is a real counterexample, \nthen we can 5 In general, we can express a function F of type bool . \u00b7\u00b7\u00b7. bool . t (where t is not of \nthe form bool . t ') by a (.nite) set of functions Fb1\u00b7\u00b7\u00b7bn ,where Fb1\u00b7\u00b7\u00b7bn behaves like F(b1,...,bn). \nconclude that the program is unsafe. Otherwise, infer new predi\u00adcates (by heuristics), and re-do predicate \nabstraction (Step 7). Re\u00adpeat this cycle (which may not terminate) until the program is found to be safe \nor unsafe. In the extended version of this paper [25], we demonstrate how the whole veri.cation framework \nworks by using an example. 5. Intersection Types for Higher-Order Recursion Schemes This section discusses \na veri.cation method for higher-order recur\u00adsion schemes (Step 5 in Figure 1). We restrict our attention \nto safety properties (the properties expressed by trivial automata [1]: recall Section 2.2). Note that \nthe transformation described in Section 3 generates only safety properties. One approach to veri.cation \nof HORS would be to use Ong s algorithm based on game semantics [29]. In this section, however, we present \nan alternative, type-based method for veri.cation of HORS. Advantages of our type-based method are as \nfollows. Our type-based algorithm seems (arguably) much simpler than Ong s algorithm.  The veri.cation \nproblem of HORS of order nis n-EXPTIME\u00adcomplete [29], so that both our algorithm and Ong s algorithm \nsuffer from the n-EXPTIME worst-case bottleneck.6 Under the assumption that both the maximum size of \nthe type of each non\u00adterminal and that of the speci.cation are bound by constants, however, the running \ntime of the algorithm is linear in the size of the recursion scheme. On the other hand, it is not clear \nhow to optimize Ong s algorithm so that it runs in linear time under thesameassumption.  By restricting \nthe underlying type system, we can obtain a va\u00adriety of approximate (i.e., incomplete) but more ef.cient \nver\u00adi.cation algorithms for HORS. In fact, as discussed in Sec\u00adtion 6, previous type-based methods for \nresource usage veri\u00ad.cation can be regarded as restrictions of the type system given in this section. \n HORS is simply-typed ; however, our type-based veri.cation method may be used for extensions of HORS \nwith a limited form of polymorphic types.  Aehlig [1] has also proposed a model-checking algorithm for \nthe same class of properties for HORS. His algorithm is closely related to ours, but less ef.cient than \nour algorithm (see Section 7). 5.1 Type System for HORS Let M =(QM ,SM ,qM,S,.M ,QM,F ) beaB\u00a8uchi tree \nautoma\u00adtonsuchthat QM = QM,F . (Note that the B\u00a8uchi tree automaton M(D) in Section 3 satis.es the condition \nQM = QM,F .) We omit the subscript M when it is clear from the context. We shall con\u00adstruct a type system \nfor higher-order recursion schemes, such that an HORS G has type qM,S if and only if [[G]] is accepted \nby M. The idea is to re.ne the tree type o to an intersection type of the form q1 .\u00b7\u00b7\u00b7.qk. Intuitively, \nqi describes trees that are accepted by M from state qi (i.e., accepted by (QM ,SM ,qi,.M ,QM,F )). q1 \n.\u00b7\u00b7\u00b7.qk denotes the intersection of the sets of trees accepted from the initial states q1,...,qk. The \ntypes of function terms are also re.ned accordingly. The type q1 . q0 describes functions that take a \ntree accepted from state q1, and return a tree accepted from state q0. For example, in Example 3.1, c \nhas type (q1,2 . V q1,1) .(q2,2 . q2,1). The terminal br has type {q . q . q | 6 Actually, our algorithm \ndeals with only safety properties. We are currently investigating whether the worst-case complexity remains \nthe same for the safety properties. q .QM }. To avoid the confusion between types denoted by .and intersection \ntypes, we shall call the types denoted by .kinds below. The set of well-formed intersection types is \nde.ned by the relations s::.and .::a ., which should be read sis a type of kind ., and . is an atomic \ntype of kind ., respectively. We exclude out ill-formed types like q1 .(q2 .q3). DEFINITION 5.1 (intersection \ntypes). The relations s :: . and . ::a . are the least relations closed under the following rules: s:: \n.1 .::a .2 qi ::a o s ..::a .1 ..2 .i ::a . for each i .{1,...,n} V {.1,...,.n}:: . Note that we exclude \nout types like q1 . (q2 .q3). That is for a technical convenience in discussing a type inference algorithm \nlater. Note that q1 . (q2 . q3) can be replaced by (q1 . q2) . (q1 . q3) (according to the intuitions \nexplained above). V We often write .1 .\u00b7\u00b7\u00b7..for {.1,...,.n}. We write .for V n V {}. We identify q with \n{q}. A type judgment for terms of HORS is of the form T fM t: s, where T, called a type environment, \nis a mapping from variables and de.ned function symbols to types. T fM t : s is the least relation closed \nunder the following rules. T fM t: .i (for each i .{1,...,n}) V T fM t: {.1,...,.n} T,x: .1 .\u00b7\u00b7\u00b7..n fM \nx: .j (j .{1,...,n}) T,F : .1 .\u00b7\u00b7\u00b7..n fM F : .j (j .{1,...,n}) (q,a,q1,...,qn) ..M T fM a: q1 .\u00b7\u00b7\u00b7.qn \n.q T fM t1 : s .. T fM t2 : s T fM t1t2 : . Let G =(S,N,R,S) be a higher-order recursion scheme where \nS=SM . (G,t) is de.ned to have type s, written fM (G,t): s, if there exists T such that: 1. dom(T) = \ndom(N); 2. T(F):: N(F) for each F .dom(T); 3. If Fxe.e.Rand T fM F : se.q, then T,xe: sefM e: q holds; \nand  4. T fM t: s.  EXAMPLE 5.1. Recall the HORS in Example 3.1 (and its speci.\u00adcation automaton in \nFigure 5). S has type qS under the following assignment of types to C1, C2, and F. C1 :(sK .qS) .(sI \n.q1,1) C2 :(sK .sK .qS) .(sI .sK .q1,1) .(sK .sI .q2,1) .(sI .sI .qt) F :(sK .sK .qS .qS) .(sI .sK .q1,2 \n.q1,1) .(sK .sI .q2,2 .q2,1) .(sI .sI .qt .qt) where V sI = {(qi .qj) .qi .qj |qi,qj .Q} V sK = {(qi \n.qj) .qk .qk |qi,qj,qk .Q}  5.2 Soundness and Completeness We .rst prove the soundness of the type system. \nTHEOREM 5.1 (soundness). Let G be an HORS and M =(QM ,SM ,qM,S,.M ,QM ) be a B\u00a8uchi tree automaton. If \nfM (G,S): qM,S,then [[G]] is accepted by M. The proof of the theorem above is similar to standard type \nsoundness proofs. We .rst prove that typing is preserved by re\u00adductions. LEMMA 5.2 (type preservation). \nIf fM (G,t): s and t -.G t ' , then fM (G,t ' ): s. Proof Straightforward case analysis on the rule used \nfor deriving t-.G t ' . D Next, we show that if (G,t) is well-typed, then the con\u00adcretized part of t, \ni.e., the part of tthat has been already evaluated to tree nodes, is accepted by the automaton. The concretized \npart of t is expressed by t. de.ned in Section 2. Here, we regard . as the in.nite tree .(.(\u00b7\u00b7\u00b7)). For \nexample, r(c(Ft)). is the in\u00ad.nite tree r(c(.(.(\u00b7\u00b7\u00b7))))).. We write M. for the following automaton, obtained \nfrom M by adding a dummy transition for .: (QM ,SM .{.},qM,S,. .{(q,.,q) |q .QM },QM ). LEMMA 5.3. If \nfM (G,t): q,then t. is accepted by M. from state q. Proof The proof proceeds by induction on the structure \nof t. . If t. = ., the result follows immediately. Otherwise, t. is of the form at1 ' \u00b7\u00b7\u00b7 tn' . In this \ncase, t is of the form at1 \u00b7\u00b7\u00b7 tn with ti . = ti ' for i =1,...,n.By fM (G,t): qS,we have fM a : q1 .\u00b7\u00b7\u00b7 \n. qn . q and fM (G,ti): qi (i =1,...,n). By the induction hypothesis, ti . is accepted by M from state \nqi. fM a : q1 .\u00b7\u00b7\u00b7qn . q implies also that M has the transition (q,a,q1,...,qn). Therefore, t. must be \naccepted by M from state q. D We are now ready to prove Theorem 5.1. Proof of Theorem 5.1 The proof proceeds \nby contradiction. Sup\u00adpose that fM (G,t): qS holds, but [[G]] is not accepted, i.e., the run of M over \n[[G]] gets stuck. Then, there must exist t such that S -.G* t andthe runof M. for t. gets stuck. By Lemma \n5.2, fM (G,t): qS. Thus, by Lemma 5.3, t. must be accepted by M.; hence a contradiction. D Next, we prove \nthe completeness of the type system. THEOREM 5.4 (completeness). Let G be an HORS and M = (QM ,SM ,qM,S,.M \n,QM ) be a B\u00a8uchi tree automaton. If [[G]] is accepted by M,then fM (G,S): qM,S. We prepare a few de.nitions \nand lemmas before proving the theorem. We write [[(G,t)]] for the in.nite term generated from tby the \nrewriting rules of G. (In other words, for G =(S,N,R,S), '' ''' [[(G,t)]] is [[G ]] where G =(S,Nl{S \n},Rl{S .t},S ).) We add the axiom T fM . : q (for any q . Q) to the type system. We identify the in.nite \ntree .(.(\u00b7\u00b7\u00b7)) with the term . below: When we are talking about typing, . is interpreted as the term \n., while when .is an input to an automaton, it is interpreted as the in.nite tree. LEMMA 5.5. If t. is \naccepted by M. from state q,then \u00d8fM t. : q. Proof The proof proceeds by induction on the structure of \nt. . If t. = ., the result follows immediately. Otherwise, t. is of the form at1 ' \u00b7\u00b7\u00b7 tn' . In this \ncase, t is of the form at1 \u00b7\u00b7\u00b7 tn .' . with ti = ti for i =1,...,n. By the assumption that tis accepted \nby M. from state q, there must be states q1,...,qn such that (i) M has the transition (q,a,q1,...,qn), \nand (ii) t1' ,...,tn ' are accepted by M. from states q1,...,qn respectively. By the induction hypothesis \nand the condition (ii), we have \u00d8fM ti ' : qi for each i. The condition (i) implies that \u00d8fM a : q1 . \n\u00b7\u00b7\u00b7 . qn .q. Thus, we have \u00d8fM t. : qas required. D The following lemma says that typing is preserved \nby the in\u00adverse of the reduction relation (c.f. Lemma 5.2). LEMMA 5.6. If fM (G,t ' ): sand t-.G t ',then \nfM (G,t): s. Proof This follows by induction on the derivation of t -.G t ' . Since the induction step \nis trivial, we show only the base case, where t = F e' =[ex]t0. Here, Fxe. t0 is a rewrit\u00ad s and t s/eing \nrule of G. We can assume without loss of generality that s is a type of the form q.Let T be the type \nenvironment witness\u00ading fM (G,t ' ): s. Note that we have T fM t ' : q.Let {.i1,...,.iki } be the set \nof atomic types assigned to si in the type derivation for T fM t ' : q. Then, we can construct a deriva- \nV V tion for T,x1 : {.11,...,.1k1 },...,xn : {.n1,...,.nkn }fM t0 : q.Let T ' be the type environment \nobtained from T by re- V placing the type of F with T(F) .( {.11,...,.1k1 } . \u00b7\u00b7\u00b7 . V {.n1,...,.nkn }. \nq). Then, we have T ' fM t : q,which implies fM (G,t): q. D We are now ready to prove Theorem 5.4. Proof \nof Theorem 5.4 Let G =(S,N,R,S) where R = {F1 xe1 . t1,...,Fn xen . tn}.Let TE be the set of type environments: \n{T |dom(T) = {F1,...,Fn},T(Fi):: N(Fi) for each i}. We de.ne a mapping F from TE to TE by: ^ F(T)(Fi)= \n{se.q |T,xei : sefM ti : q} V We write T1 T2 if T1(Fi)= {.1,...,.m} and T2(Fi)= V {.1,...,.n}holds for \neach Fi with {.1,...,.m}.{.1,...,.n}. Note that F is monotonic with respect to . Let Tgfp be the greatest \npost-.xed point of F, i.e., the greatest type environment such that T .F(T).Since TE is a .nite V Fm \nset, .gfp = (T0) for some m,where T0(Fi)= {. | .::a N(Fi)}. Then, fM (G,S): qS if and only if Tgfp fM \nS : qS . (Note that the third condition in the de.nition of fM (G,t): s is equivalent to T .F(T).) Now, \nsuppose that [[G]] is accepted by M. From G, we construct a recursion-free HORS G(m) as follows. For \neach de.ned function symbol Fi, prepare new de.ned function symbols Fi,0,...,Fi,m (where S = Sm). Then \nreplace each rewriting rule Fi xe.ti with the following rewriting rules: Fi,k xe.[F1,k-1/F1,...,Fn,k-1/Fn]ti \nfor k .{1,...,m} Fi,0 xe.. By the de.nition, [[G(m)]] is an approximation of [[G]], i.e., [[G(m)]] is \nobtained by replacing some subtrees of [[G]] with ..So, [[G(m)]] is accepted by M.. Thus, by Lemma 5.5, \nwe have fM (G(m) ,[[G(m)]]) : qS . Because G(m) is recursion-free, S -.G* (m) [[G(m)]].Thus,By Lemma \n5.6, fM (G(m),S): qS . By the construction of G(m), Tgfp fM S : qS (recall that Tgfp = Fm(T0)), which \nimplies fM (G,S): qS. D  5.3 Type Checking Algorithm We discuss a type checking algorithm and its time \ncomplexity in this subsection. The proof of Theorem 5.4 gives the following type checking algorithm: \nV V 1. Let T0 be F1: {. |.::aN(F1)},...,Fn: {. |.::aN(Fn)}. 2. Compute F1(T0),F2(T0),...,and .nd m such \nthat either Fm(T0)= Fm+1(T0) or Fm(T0) fM S : qS . 3. Answer whether Fm(T0) fM S : qS holds.  Note \nthat the second step must terminate, as Fi(T0) ranges over a .nite set, and decreases monotonically. \nm is bound by the max\u00adimum length of a decreasing sequence, which is |N(F1)|+ \u00b7\u00b7\u00b7+ |N(Fn)|. When the \ntype checking fails, a type error slice [13] of G(m) serves as a counter-example, which will be given \nas an input for Step 6inFigure1. We now discuss the time complexity of the above algorithm. Let G be \na higher-order recursion scheme of order N(= 1),and M be aB\u00a8uchi tree automaton M =(Q,S,qS ,.,Q).Let \n|G|and |Q|be the size of (the rules of) G and that of Qrespectively. The number of atomic types of kind \no is |Q|, and the number of atomic types of kind o . \u00b7\u00b7\u00b7 . o . o is 2|Q| \u00d7\u00b7\u00b7\u00b7\u00d72|Q| \u00d7(|Q|). In general, \nif .has order N and arity k, the number of atomic types of kind . is bound by expN (O(k|Q|))),where expN \n(x) is de.ned by: exp0(x)= x expi+1(x)=2expi(x) Thus, m is bound by (expN (O(K|Q|))) \u00d7 n,where K is the \nmaximum arity of F1,...,Fn. The cost for computing F(T) is also bound by expN (O(K|Q|)) \u00d7|G|, so that \nthe running time of the algorithm is bound by expN (O(|Q||G|)). (Note that K and n are bound by |G|.) \nThis time complexity is analogous to that of Ong s algorithm using game semantics [29].7 Note,however,that \nour algorithm can deal with only safety properties, while Ong s algorithm can deal with arbitrary properties \nexpressed by modal \u00b5-calculus. The extremely high time complexity above may be disappoint\u00ading. Note, \nhowever, that the high time complexity is attributed to the explosion of the size of the set of intersection \ntypes. Let us as\u00adsume that the size of the kind of each de.ned function symbol is bound by a constant \n(hence so are K and N above). Here, the size of .is de.ned by |o| =0 and |.1 . .2| = |.1|+ |.2|+1.Let \nus also assume that |Q| is also bound by a constant. Then, for a given ., the size of the set of intersection \ntypes of kind .is bound by a constant. Therefore, in the above algorithm, both the number of iterations \nmand the cost for each iteration is O(|G|), so that the algorithm runs in time O(|G|2). By using Rehof \nand Mogensen s method [30] for solving constraints in .nite semi-lattices, we can further optimize it \nto obtain a linear time algorithm. For the purpose of resource usage veri.cation, the above as\u00adsumption \nabout the size of kinds seems to be reasonable. Note that the kinds of de.ned function symbols correspond \nto the simple types of function variables of source programs. In realistic pro\u00adgrams, the type size does \nnot necessarily increase with the increase of the program size. In fact, the boundedness of type size \nis often assumed in the context of type-based program analysis [15, 21]. The assumption on the number \nof states of M also seems reason\u00adable, because the automaton M is determined solely by the kinds of resources \nused in the program. 5.4 Type Re.nement Towards Ef.cient Type-Based Model Checking of HORS The most \nsigni.cant bottleneck of the veri.cation framework in Figure 1 is probably the phase for model-checking \nHORS (Step 7 Actually, Ong s time complexity result is with respect to the size of a modal \u00b5-calculus \nformula. Since the size of the equivalent tree automaton can be exponential in the size of the formula, \nwe should modify the above type system and type checking algorithm to deal with alternating tree automata \n[9]. That modi.cation is easy: just change the types of terminal symbols. Thus, the above time complexity \nresult should hold even when a property is given by a modal \u00b5-calculus formula.   HORS Figure 6. Type-Based \nVeri.cation of HORS with Type Re.ne\u00adment. The dotted box corresponds to Step 5 in Figure 1 5). As discussed \nabove, the complexity of the algorithm for order\u00adnHORS is in general n-EXPTIME. Although the algorithm \nruns in time linear in the program size with the assumption on the boundedness of the type and speci.cation \nsizes, the constant factor would be extremely large. A possible solution to this problem would be to \nuse an incom\u00adplete but ef.cient type system .rst, and then gradually re.ne the type system, as illustrated \nin Figure 6. Given an HORS Gand an automaton M, use a simple type system .rst to check whether G has \ntype qS . If the type-checking succeeds, then the program is resource-safe. Otherwise, compute a type \nerror slice [13]. Analyze the type error slice and check whether there is a real reduction se\u00adquence \nof Gthat violates the property. If so, output it as a possible counterexample for the original program \n(which is passed to Step 6 in Figure 1). Otherwise, re.ne the type system, and continue the cycle. Thus, \nwe have now two re.nement cycles in the veri.ca\u00adtion framework in Figure 1; a cycle for predicate re.nement, \nand another cycle for type re.nement. We have not yet studied exactly how types should be re.ned in the \nframework sketched above, but the intersection type system seems convenient for the type re.nement framework \nabove. By re\u00adstricting the form of intersection types, we can obtain type systems of varying ef.ciency \nand expressive power. In fact, as we discuss in the next section, previous type systems for resource \nusage veri.\u00adcation may be considered restricted forms of our intersection type system. 6. Comparison \nwith Previous Type Systems for Resource Usage Veri.cation In this section, we discuss relationships between \nour intersection type system for HORS and three previous type systems for re\u00adsource usage veri.cation \n(or typestate): typestates [32], Igarashi and Kobayashi s type system [19], and .ow-sensitive type quali\u00ad.ers \n[12]. The discussion would provide a hint for designing the type re.nement framework sketched in Section \n5.4. First, a straightforward consequence of Theorems 5.1 and 5.4 is that, for the language of Section \n3, our method (the combination of the transformation in Section 3 and the type system in Section 5) is \nalways at least as accurate as any method (including type systems, .ow analysis, or whatever) for resource \nusage veri.cation. That is also the case for languages with ordinary values (such as booleans and integers) \nfor the three type systems [12, 19, 32], as they do not capture value-dependent information. p L p . \n   g g tt Figure 7. The speci.cation automaton for 2-place buffer (unim\u00adportant transitions are omitted). \nWe use the program in Example 3.1 and the example below to compare our intersection type system and the \nthree type systems in more detail. EXAMPLE 6.1. Consider the following program that accesses 2\u00adplace \nbuffers. fun fx y=g xy; hx y; fun g x y = put(x); put(y); fun h x y = get(x); get(y); if * then f (newbuf()) \n(newbuf()) else let x=newbuf() in f x x Here, newbuf() creates a new 2-place buffer, on which the opera\u00adtion \nput can be performed twice before get is performed. The program can be transformed into the following \nprogram D in our language. S = if*(new L C1)(new L C2) C1 x = new L (C3 x) C2 x = Fxx* C3 xy = Fxy* Fxyk \n= Gxy(Hxyk) Gxyk = accp x(accp yk) Hxyk = accg x(accg yk) Here, Lis the set of sequences s.{p,g}such \nthat (i) #g (s)= #p (s), and (ii) for any pre.x s ' of s, #g (s ' )=#p (s ' )=#g (s ' )+ 2,where #a(s)is \nthe number of occurrences of ain s. The speci.cation automaton M(D)is shown in Figure 7. The HORS H(D)has \ntype qS under the following assignment of types. F :s.(sI .sI .q0 .q0).(sI .sK .q0 .q0) .(sK .sI .q0 \n.q0).(sK .sK .qS .qS ) G:s.(sI .sI .q2 .q0).(sI .sK .q1 .q0) .(sK .sI .q1 .q0).(sK .sK .qS .qS ) H:s.(sI \n.sI .q0 .q2).(sI .sK .q0 .q1) .(sK .sI .q0 .q1).(sK .sK .qS .qS ) Here, sI and sK are the same as those \nin Example 5.1, and sis sI .sI .qt .qt. 0 6.1 Typestate Typestates [32] have been proposed as an extension \nof types with states, which determine what operations can be performed at each program point.8 The states \nroughly correspond to the automaton states in this paper. Each program point is associated with a map\u00adping \nfrom variables to typestates. A function s type is expressed as a pair of the type environments at the \nentry point and the exit point. For example, the function f in Example 3.1 is given type x:R(q1,1),y:R(q2,1)at \nthe entry point, and x:R(q1,2),y:R(q2,2) 8 Actually, the original algorithm for checking typestates [32] \nis presented as a .ow analysis. The following discussion is based on our interpretation of the original \nwork from the viewpoint of type systems. at the exit point. Here, R(q)is the type of a resource in state \nq.(We use states of the automaton in Figure 5.) Notice that this contains the same information as the \nfollowing type of F given in Exam\u00adple 5.1: F :\u00b7\u00b7\u00b7.(sI .sK .q1,2 .q1,1).(sK .sI .q2,2 .q2,1) The part \nsI . sK . q1,2 . q1,1 expresses the change of the state of the .rst resource, while sK . sI . q2,2 . \nq2,1 expresses the change of the state of the second resource. (Notice that since F is in the continuation-passing \nstyle, the types q1,2 and q2,2 of continuations describe the states at the exit point of f.) In general, \na function that has typestates x1 :R(q1),x2 : R(q2),...,xn :R(qn) at the entry point and x1 :R(q1' ),x2 \n: R(q2' ),...,xn :R(qn' )at the exit point will be given the following type in our type system: (sI .sK \n. \u00b7\u00b7\u00b7.sK .q1 ' .q1) .(sK .sI .\u00b7\u00b7\u00b7.sK .q2 ' .q2) .\u00b7\u00b7\u00b7.(sK .\u00b7\u00b7\u00b7.sK .sI .qn ' .qn).\u00b7\u00b7\u00b7 A difference arises \nfor the program in Example 6.1. f, g and h will be given the following typestates: entry point exit point \nf x:R(q0),y:R(q0) x:R(q0),y:R(q0) g x:R(q0),y:R(q0) x:R(q1),y:R(q1) h x:R(q1),y:R(q1) x:R(q0),y:R(q0) \n In the typestates of [32], aliases are not allowed, so that x and y are assumed to be different resources. \nTherefore, the function call fxxis not typable. On the other hand, the HOSC generated from the program \nis typable in our type system. The difference lies in the following parts of the types of F, Gand H: \nF :(sI .sI .q0 .q0).\u00b7\u00b7\u00b7 G:(sI .sI .q2 .q0).\u00b7\u00b7\u00b7 H :(sI .sI .q0 .q2).\u00b7\u00b7\u00b7 Those parts take care of the case \nwhere the two arguments are the same resource. Another difference is polymorphism. In our type system, \nthe term accp y in the de.nition of Gis given the following polymor\u00adphic type when yhas type sI : (q1 \n.q0).(q2 .q1) On the other hand, in typestates, a unique type is assigned to each program point. To summarize, \nthe main differences between our type system and typestates are in the treatment of aliasing and polymorphism. \n 6.2 Igarashi and Kobayashi s type system In Igarashi and Kobayashi s type system [19] (IK type system, \nfor short), resource types are extended with a set of valid access sequences. For example, the function \nf in Example 3.1 is given the following type: File(r * c).File(w * c).unit Here, the part File(r * c)means \nthat the .rst argument will be read and then closed by the function. The set of access sequences r * \nc corresponds to the transition from q1,1 to q1,2 in the automaton. Thus, it expresses the same information \nas the part sI . sK . q1,2 .q1,1 of F s type in the intersection type system. IK type system can deal \nwith polymorphism and aliasing in a restricted manner. The function g in Example 6.1 is given the following \ntype: R(p).R(p).unit. Since the action p corresponds to the transition from q1 to q2 and also the one \nfrom q2 to q3, the .rst occurrence of R(p)subsumes the information expressed by: (sI .sK .q2 .q1).(sI \n.sK .q3 .q2). Moreover, IK type system does not require that the .rst and second arguments are different \nresources. Given the call fxx, IK type system assigns to xthe type R(p .p). Here, L1 .L2 represents the \nshuf.e of the languages L1 and L2; In this case, p .p denotes the singleton set {pp}. Thus, the above \ntype expresses the same information as: G:(sI .sI .q3 .q1).(sK .sK .q1 .q1). (sI .sK .q2 .q1).(sK .sI \n.q2 .q1). (sI .sK .q3 .q2).(sK .sI .q3 .q2) Handling of aliasing and polymorphism in IK type system is, \nhowever, limited. For example, consider the following function: Fxyc =accr x(accc yc) The intersection \ntype system can assign to F the following type: \u00b7\u00b7\u00b7.(sI .sI .q2 .q1).\u00b7\u00b7\u00b7 , which expresses the information \nthat if x and y are the same resource, then the resource state will change from q1 to q2.On the other \nhand, IK type system assigns to (the direct-style counterpart of) F the following type: File(r).File(c).unit \nGiven the call Fxx, x is given the type File(r .c). The type means that xwill be either read and then \nclosed, or closed and then read. Thus, Fxxwill be rejected. IK type system also suffers from lack of \nenough polymorphism: If F1 and F2 are passed to the same function G(as in G(F1)and G(F2)), the same type \nis assigned to F1 and F2. 6.3 Flow-Sensitive Type Quali.ers Foster et al. [12] proposed a type-based \nanalysis for checking typestates (or .ow-sensitive type quali.ers in their terminology). A resource type \nis annotated with a region, like File(.). A region is an abstract set of concrete resources (or locations). \nThe type system then keeps track of the state of each region. For example, the function f in Example \n3.1 is given the following type: ({.1 .q1,1,.2 .q2,1},File(.1)\u00d7File(.2)) .({.1 .q1,2,.2 .q2,2},unit) \nHere, the type means that the function takes a pair of resources in regions .1 and .2, and that the states \nof regions .1 and .2 are q1,1 and q2,1 before the function call and q1,2 and q2,2 after the call. Thus, \nregion names serve as the same role as variables in typestates [32], for keeping track of resource states, \nand the relationship between our intersection type system and the type quali.ers is similar to that between \nours and typestates, except the treatment of aliases through the special construct restrict. As in typestates, \nthe type quali.ers also suffer from the problem of aliases: Suppose that .les xand yhave different resources \nof the same type File(.), and that the state of . is q1,1. Then, close(x) cannot change the state of \n. to q1,2, because x is closed, but y is still opened. To deal with the alias problem, Foster et al. \n[12] introduces a special construct called restrict. For example, consider the follow\u00ading program fragment: \nlet x=hd(l) in lock(x); unlock(x) Here, l is a list of locks. Since all the elements of l are abstracted \nto the same region (say, .), the above program cannot be typed. It can, however, be rewritten to: .l \nlet x=hd(l) in restrictz=x in lock(z); unlock(z) Here, the region for x is locally renamed to . ' and \nthe state of . ' can be changed inside the body of restrict, as long as (i) the state of . ' is changed \nback to the original state at the end of the body and (ii) the region .is not accessed in the body. A \nsimilar mechanism is also employed in the type system of Vault [8]. When a region . expresses more than \none resources, the re\u00adsource type R(.) corresponds to the union type sI . sK in our type system. Given \na resource of type sI . sK , we do not know whether we should keep track of the resource state. Thus, \nthe rea\u00adsoning for restrict above seems to be related to the following rule for union types: T,x: sI \n,k : qi f t: qj T,x: sK ,k : qi f t: qj T,x: sI . sK ,k: qi f t: qj Here, k denotes the continuation. \nThe reasoning for restrict seems to be a special case of the above rule, where qi = qj and t does not \naccess resources in the same region as x. In that case, the assumption T,x: sK ,k : qi f t : qi follows \nimmediately, so that it suf.ces to check T,x: sI ,k : qi f t: qi. 7. Related Work HORS model checking \nThe present work owes much to the the\u00adoretical studies of the model-checking problem for higher-order \nre\u00adcursion schemes [2, 14, 22 24, 29]. The modal \u00b5-calculus model\u00adchecking problem for HORS has been \nextensively studied recently. Knapik [22] showed that the problem is decidable for order-2 safe higher-order \nrecursion schemes (where safety is a certain syntac\u00adtic condition), and later extended the result to \nsafe HORS of any or\u00adder [23]. Knapik et al. [24] and Aehlig et al. [2] then independently showed that \nthe model checking problem is decidable for order-2 HORS, without the safety assumption. Finally, Ong \n[29] has shown that the problem is decidable for HORS of arbitrary order. Their al\u00adgorithms are based \non automata and game theories and are rather involved. It would be interesting that, for the restricted \nfragment of modal \u00b5-calculus, the same problem can be solved in a rather sim\u00adple manner by using types. \nAehlig [1] has also proposed a model\u00adchecking algorithm of HORS for the same class of safety proper\u00adties \nas ours. His algorithm is much closer to our algorithm than Ong s algorithm, although Aehlig assigns \nset-theoretic functions to terms instead of our intersection types. His algorithm guesses an assignment \nof set-theoretic functions to terms, and then checks the correctness of the guess. Thus, his algorithm \nis less ef.cient than our algorithm; for example, for order-1 recursion scheme, their al\u00adgorithm is double \nexponential in the number of states, while our algorithm is exponential. As far as the author knows, \napplications of these decidability results to program veri.cation have been limited so far, except some \nwork on veri.cation of higher-order pushdown systems [14]. Software model checking Thanks to the advance \nof abstract model-checking techniques (such as counter-example-guided ab\u00adstraction re.nement and lazy \nabstractions), model checking has become a popular technique for software veri.cation [3 5, 16]. The \nexisting model checkers are mainly targeted for imperative lan\u00adguages with .rst-order procedures. The \ntreatment of higher-order functions is limited; for example, in SLAM [3], a call to function pointer \nin a C program is replaced by a non-deterministic choice of all the functions that it may point to. Thus, \ninformation is lost in this pre-processing phase for software model checking. A trick similar to the \none used in Section 3 (of instantiating a new resource to I or K non-deterministically) is used also \nin software model checking [7]. Resource usage veri.cation A number of type-based or .ow\u00adbased techniques \nfor veri.cation of temporal properties have been proposed, under various names (resource usage veri.cation, \ntypes\u00adtate checking, etc.) [10 12, 19, 20, 26, 32]. Unlike our intersection type system, they are incomplete \nfor higher-order programs. Since our intersection type system is complete (for value-free programs), \nit may be used as a good device for comparing different techniques; three of them have been already discussed \nin Section 6. Some of the veri.cation techniques [10, 11, 26] can analyze value-dependent information. \nIn our veri.cation framework (Fig\u00adure 1), the value-dependent information is handled in Step 2, a sep\u00adarate \nphase from HORS model checking. Model checking vs type systems Naik and Palsberg [27, 28] stud\u00adied type \nsystems equivalent to model checkers for an imperative language and an interrupt calculus. Their type \nsystems and ours have some similarity: a state or a value is represented by an atomic type, and the effect \nof a statement is expressed by an intersection of function types (each of which represents a state transition). \nA ma\u00adjor difference is that they consider only types of order 1, while we consider types of higher-orders \nto deal with higher-order functions. Naik and Palsberg [27, 28] uses union types also, while we do not \nuse them. That is because we consider only deterministic higher\u00adorder recursion schemes. Union types \nmay be useful for veri.cation of a non-deterministic HORS (which generate a set of trees). In the context \nof the p-calculus, there is an approach to com\u00adbining types and model checking [6, 18]. In that approach, \na type\u00adbased analysis is used to extract abstract programs, and then the ex\u00adtracted programs are model-checked. \nInformation is lost in the type inference phase, which causes false alarms. On the other hand, our intersection \ntype system is complete; Information is lost only in the phase for predicate abstractions (Step 2 in \nFigure 1). Dependent types Dependent types have been a popular method for semi-automatic veri.cation \nof higher-order programs. Heuristic techniques for automated inference of dependent types have been studied \nrecently [31, 34], but their applicability seems to be still limited. Our veri.cation framework in Figure \n1 provides an alter\u00adnative approach to inference of dependent types. A higher-order program with assertions \ncan be expressed in our language, by us\u00ading a single global resource and a single action fail to express \nan assertion violation. Using the framework in Figure 1, we can start with simple types, and then gradually \nre.ne dependent types until the whole program is type-checked. Tree types Connections between types and \ntree automata have been studied in the context of languages for XML processing [17]. They deal with .nite \ntrees, while our type system deals with in.nite trees. 8. Conclusion We have proposed a novel framework \nfor veri.cation of temporal properties of higher-order programs, based on the recent result on the decidability \nof HORS model checking. There are two main con\u00adtributions in this work. The .rst one is the reduction \nof the resource usage veri.cation problem to the HORS model checking problem. As far as the author knows, \nthis is the .rst practical application of the decidability of HORS model checking to program veri.ca\u00adtion. \nThe reduction enables a smooth integration of the techniques for abstract model checking (in particular, \ncounter-example-guided abstraction re.nement) into veri.cation of higher-order programs. The second contribution \nis a type-based algorithm for HORS model checking. Although only a fragment of the modal \u00b5-calculus is \nhandled, our algorithm and its correctness proof seem to be signi.cantly simpler than the previous algorithm \n[29] (for the full modal \u00b5-calculus). The new type system also serves as a good device for comparing \nprevious type systems for veri.cation of temporal properties. A lot of work is left for future work. \nOn the practical side, the two re.nement cycles in Figures 1 and 6 should be substantiated. A veri.cation \ntool should be implemented to test the feasibility of the veri.cation method. Extending the method to \ndeal with recursive data structures and pointers would also be important. On the theoretical side, it \nwould be interesting to .nd a type system for the full modal \u00b5-calculus model checking of HORS. Acknowledgment \nI would like to thank Luke Ong for introducing me to higher\u00adorder recursion schemes and providing useful \ncomments, Sriram Rajamani for references on model checking, Jens Palsberg for references on the work \non types vs model checking. We would also like to thank anonymous referees and members of our research \ngroup for useful comments. This work was partially supported by Kakenhi 20240001. References [1] K. Aehlig. \nA .nite semantics of simply-typed lambda terms for in.nite runs of automata. Logical Methods in Computer \nScience, 3(3), 2007. [2] K. Aehlig, J. G. de Miranda, and C.-H. L. Ong. The monadic second order theory \nof trees given by arbitrary level-two recursion schemes is decidable. In TLCA 2005, volume 3461 of LNCS, \npages 39 54. Springer-Verlag, 2005. [3] T. Ball, R. Majumdar, T. D. Millstein, and S. K. Rajamani. Automatic \npredicate abstraction of C programs. In PLDI 2001, pages 203 213, 2001. [4] T. Ball and S. K. Rajamani. \nThe SLAM project: debugging system software via static analysis. In POPL, pages 1 3, 2002. [5] D. Beyer, \nT. A. Henzinger, R. Jhala, and R. Majumdar. The software model checker blast. International Journal on \nSoftware Tools for Technology Transfer, 9(5-6):505 525, 2007. [6] S. Chaki, S. Rajamani, and J. Rehof. \nTypes as models: Model checking message-passing programs. In Proc. of POPL, pages 45 57, 2002. [7] B. \nCook, A. Gotsman, A. Podelski, A. Rybalchenko, and M. Y. Vardi. Proving that programs eventually do something \ngood. In Proc. of POPL, pages 265 276, 2007. [8] R. DeLine and M. F\u00a8ahndrich. Adoption and focus: Practical \nlinear types for imperative programming. In Proc. of PLDI, 2002. [9] E. A. Emerson and C. S. Jutla. Tree \nautomata, mu-calculus and determinacy (extended abstract). In FOCS 1991, pages 368 377, 1991. [10] J. \nField, D. Goyal, G. Ramalingam, and E. Yahav. Typestate veri.cation: Abstraction techniques and complexity \nresults. Sci. Comput. Program., 58(1-2):57 82, 2005. [11] S. J. Fink, E. Yahav, N. Dor, G. Ramalingam, \nand E. Geay. Effective typestate veri.cation in the presence of aliasing. ACM Trans. Softw. Eng. Methodol., \n17(2), 2008. [12] J. S. Foster, T. Terauchi, and A. Aiken. Flow-sensitive type quali.ers. In Proc. of \nPLDI, pages 1 12, 2002. [13] C. Haack and J. B. Wells. Type error slicing in implicitly typed higher-order \nlanguages. Science of Computer Programming, 50(1\u00ad3):189 224, 2004. [14] M. Hague and C.-H. L. Ong. Symbolic \nbackwards-reachability analysis for higher-order pushdown systems. In FoSSaCS 2007, volume 4423 of LNCS, \npages 213 227. Springer-Verlag, 2007. [15] N. Heintze and D. A. McAllester. Linear-time subtransitive \ncontrol .ow analysis. In Proc. of PLDI, pages 261 272, 1997. [16] T. A. Henzinger, R. Jhala, R. Majumdar, \nand G. Sutre. Lazy abstraction. In Proc. of POPL, pages 58 70, 2002. [17] H. Hosoya, J. Vouillon, and \nB. C. Pierce. Regular expression types for xml. ACM Trans. Program. Lang. Syst., 27(1):46 90, 2005. [18] \nA. Igarashi and N. Kobayashi. A generic type system for the pi\u00adcalculus. Theor. Comput. Sci., 311(1-3):121 \n163, 2004. [19] A. Igarashi and N. Kobayashi. Resource usage analysis. ACM Trans. Prog. Lang. Syst., \n27(2):264 313, 2005. Preliminary summary appeared in Proceedings of POPL 2002. [20] F. Iwama, A. Igarashi, \nand N. Kobayashi. Resource usage analysis for a functional language with exceptions. In Proceedings of \nACM SIGPLAN 2006 Workshop on Partial Evaluation and Program Manipulation (PEPM 2006), pages 38 47. ACM \nPress, 2006. [21] D. Kikuchi and N. Kobayashi. Type-based veri.cation of corre\u00adspondence assertions for \ncommunication protocols. In Proceedings of APLAS 2007, volume 4807 of LNCS, pages 191 205. Springer-Verlag, \n2007. [22] T. Knapik, D. Niwinski, and P. Urzyczyn. Deciding monadic theories of hyperalgebraic trees. \nIn TLCA 2001, volume 2044 of LNCS, pages 253 267. Springer-Verlag, 2001. [23] T. Knapik, D. Niwinski, \nand P. Urzyczyn. Higher-order pushdown trees are easy. In FoSSaCS 2002, volume 2303 of LNCS, pages 205 \n222. Springer-Verlag, 2002. [24] T. Knapik, D. Niwinski, P. Urzyczyn, and I. Walukiewicz. Unsafe grammars \nand panic automata. In ICALP 2005, volume 3580 of LNCS, pages 1450 1461. Springer-Verlag, 2005. [25] \nN. Kobayashi. Types and higher-order recursion schemes for veri.cation of higher-order programs. An extended \nversion, available from http://www.kb.ecei.tohoku.ac.jp/~koba/papers/ hors.pdf, 2008. [26] P. Lam, V. \nKuncak, and M. C. Rinard. Generalized typestate checking for data structure consistency. In VMCAI 2005, \nvolume 3385 of LNCS, pages 430 447. Springer-Verlag, 2005. [27] M. Naik. A type system equivalent to \na model checker. Master Thesis, Purdue University. [28] M. Naik and J. Palsberg. A type system equivalent \nto a model checker. In ESOP 2005, volume 3444 of LNCS, pages 374 388. Springer-Verlag, 2005. [29] C.-H. \nL. Ong. On model-checking trees generated by higher-order recursion schemes. In LICS 2006, pages 81 90. \nIEEE Computer Society Press, 2006. [30] J. Rehof and T. Mogensen. Tractable constraints in .nite semilattices. \nScience of Computer Programming, 35(2):191 221, 1999. [31] P. M. Rondon, M. Kawaguchi, and R. Jhala. \nLiquid types. In PLDI 2008, pages 159 169, 2008. [32] R. E. Strom and S. Yemini. Typestate: A programming \nlanguage concept for enhancing software reliability. Transactions on Software Engineering, 12(1):157 \n171, 1986. [33] W. Thomas. Languages, automata, and logic. In Handbook of formal languages, vol. 3, pages \n389 455, 1997. [34] H. Unno and N. Kobayashi. On-demand re.nement of dependent types. In Proceedings \nof FLOPS 2008, volume 4989 of LNCS, pages 81 96. Springer-Verlag, 2008.   \n\t\t\t", "proc_id": "1480881", "abstract": "<p>We propose a new verification method for temporal properties of higher-order functional programs, which takes advantage of Ong's recent result on the decidability of the model-checking problem for higher-order recursion schemes (HORS's). A program is transformed to an HORS that generates a tree representing all the possible event sequences of the program, and then the HORS is model-checked. Unlike most of the previous methods for verification of higher-order programs, our verification method is sound and complete. Moreover, this new verification framework allows a smooth integration of abstract model checking techniques into verification of higher-order programs. We also present a type-based verification algorithm for HORS's. The algorithm can deal with only a fragment of the properties expressed by modal mu-calculus, but the algorithm and its correctness proof are (arguably) much simpler than those of Ong's game-semantics-based algorithm. Moreover, while the HORS model checking problem is n-EXPTIME in general, our algorithm is linear in the size of HORS, under the assumption that the sizes of types and specification formulas are bounded by a constant.</p>", "authors": [{"name": "Naoki Kobayashi", "author_profile_id": "81100603931", "affiliation": "Tohoku University, Sendai, Japan", "person_id": "P1301031", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1480881.1480933", "year": "2009", "article_id": "1480933", "conference": "POPL", "title": "Types and higher-order recursion schemes for verification of higher-order programs", "url": "http://dl.acm.org/citation.cfm?id=1480933"}