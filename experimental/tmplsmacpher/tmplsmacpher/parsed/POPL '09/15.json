{"article_publication_date": "01-21-2009", "fulltext": "\n Bidirectionalization for Free! (Pearl) Janis Voigtl\u00a8ander Technische Universit\u00a8 at Dresden 01062 Dresden, \nGermany janis.voigtlaender@acm.org Abstract A bidirectional transformation consists of a function get \nthat takes a source (document or value) to a view and a function put that takes an updated view and the \noriginal source back to an updated source, governed by certain consistency conditions relating the two \nfunc\u00adtions. Both the database and programming language communities have studied techniques that essentially \nallow a user to specify only one of get and put and have the other inferred automatically. All approaches \nso far to this bidirectionalization task have been syntac\u00adtic in nature, either proposing a domain-speci.c \nlanguage with lim\u00adited expressiveness but built-in (and composable) backward com\u00adponents, or restricting \nget to a simple syntactic form from which some algorithm can synthesize an appropriate de.nition for \nput. Here we present a semantic approach instead. The idea is to take a general-purpose language, Haskell, \nand write a higher-order func\u00adtion that takes (polymorphic) get-functions as arguments and re\u00adturns appropriate \nput-functions. All this on the level of semantic values, without being willing, or even able, to inspect \nthe de.nition of get, and thus liberated from syntactic restraints. Our solution is inspired by relational \nparametricity and uses free theorems for proving the consistency conditions. It works beautifully. Categories \nand Subject Descriptors D.3.3 [Programming Lan\u00adguages]: Language Constructs and Features Data types and \nstructures, Polymorphism; D.1.1 [Programming Techniques]: Ap\u00adplicative (Functional) Programming; D.2.4 \n[Software Engineer\u00ading]: Software/Program Veri.cation Correctness proofs; F.3.1 [Logics and Meanings \nof Programs]: Specifying and Verifying and Reasoning about Programs; H.2.3 [Database Management]: Languages \nData manipulation languages, Query languages General Terms Design, Languages, Veri.cation Keywords generic \nprogramming, program transformation, view\u00adupdate problem 1. Introduction Imagine we have written the \nfollowing Haskell function: halve :: [a] . [a] halve as = take (length as div 2) as Clearly, it outputs \nonly an abstraction of its input list, as that list s second half is omitted. Now assume this abstracted \nvalue, or view, Permission to make digital or hard copies of all or part of this work for personal or \nclassroom use is granted without fee provided that copies are not made or distributed for pro.t or commercial \nadvantage and that copies bear this notice and the full citation on the .rst page. To copy otherwise, \nto republish, to post on servers or to redistribute to lists, requires prior speci.c permission and/or \na fee. POPL 09, January 18 24, 2009, Savannah, Georgia, USA. Copyright c &#38;#169; 2009 ACM 978-1-60558-379-2/09/01. \n. . $5.00 is updated in some way, and we would like to propagate this update back to the original input \nlist. Here is how to do so: put1 :: [a] . [a] . [a] put1 as as' | length as' == n ' = as++ drop n as \nwhere n = length as div 2 Note that the backwards propagation of the assumed updated view as' into the \noriginal source as is only possible if as' is itself also half as long as as. This is so because otherwise \nthere is no consistent way to combine as' and the second half of as into an ' updated source from which \nhalve would indeed lead to as. Let us consider another example: data Tree a = Leaf a | Node (Tree a)(Tree \na) .atten :: Tree a . [a] .atten (Leaf a) =[a] .atten (Node t1 t2)= .atten t1 ++ .atten t2 Now the abstraction \namounts to forgetting the tree structure of the input source. But if the list view is updated in any \nway preserving its length, the new content can be propagated back into the original tree as follows: \nput2 :: Tree a . [a] . Tree a put2 sv = case go sv of (t, [ ]) . t where go (Leaf a)(b : bs)=(Leaf b, \nbs) go (Node s1 s2) bs =(Node t1 t2, ds) where (t1, cs)= go s1 bs (t2, ds)= go s2 cs Finally, consider \na function that removes duplicate occurrences of elements from a list, with implementation taken over \nfrom a standard library: rmdups :: Eq a . [a] . [a] rmdups = List.nub An appropriate backwards propagation \nfunction looks as follows: put3 :: Eq a . [a] . [a] . [a] put3 sv | v == List.nub v &#38;&#38; length \nv == ' length s' = map (fromJust . .ip lookup (zip sv)) s ' where s= List.nub s For example, in a Haskell \ninterpreter: > put_3 \"abcbabcbaccba\" \"aBc\" \"aBcBaBcBaccBa\" Clearly, always having to explicitly write \nboth forwards/back\u00adwards-related functions is not the ideal situation. Thus, there has been a lot of \nrecent research into bidirectionalization (Hu et al. 2004; Bohannon et al. 2006; Foster et al. 2007; \nMatsuda et al. 2007; Bohannon et al. 2008; Foster et al. 2008). One approach is to de\u00ad sign a domain-speci.c \nlanguage, fencing in a certain subclass of transformations, in which a single speci.cation denotes both \na for\u00adward and a backward function. Another approach is to devise an algorithm that works on a syntactic \nrepresentation of (restricted) forward functions and tries to .nd the missing backward compo\u00adnents. In \nthis paper we present a completely novel approach that works for polymorphic functions such as those \nabove. We write, directly in Haskell, a higher-order function b. (named for an ab\u00adbreviation of the paper \ns title). This function takes a source-to-view function as input and returns an appropriate backward \nfunction. For example, we expect, and will get, b. halve = put1 b. .atten = put2 b. rmdups = put3 . Note \nthat applying b. to halve, for example, will not return the exact syntactic de.nition of put1 given above, \nbut merely a func\u00adtional value that is semantically equivalent to it. Hence the use of = instead of = \nhere. But this is absolutely enough from an applica\u00adtion perspective. We want automatic bidirectionalization \nprecisely because we do not want to be bothered with thinking about the backward function. So we do not \ncare about its syntactic form, as long as the function serves its purpose. And the same level of syn\u00adtactic \nignorance applied to the input, rather than output, side of b. means that we can pass any Haskell function \nof appropriate type and obtain a good backward component for it. We are not restricted to drawing forward \nfunctions from some sublanguage only. Of course, the concept of a good backward component needs to be \naddressed. As evaluation criteria we use the standard con\u00adsistency conditions (Bancilhon and Spyratos \n1981) that a for\u00adward/backward pair of functions get/put should satisfy the laws put s (get s) = s and, \nif put sv is de.ned, get (put sv) = v , known as GetPut and PutGet, respectively. These consistency con\u00additions \nare why all the put-functions given above are partial func\u00adtions only. For example, > put_3 \"abcbabcbaccba\" \n\"aBB\" should, and does, fail, because a view with duplicate elements can never be in the image of rmdups. \nAn alternative that is used in some of the related literature would be to statically describe, or even \ncalculate, the domain on which a put-function is well-de.ned, thus capturing a notion of permitted updates. \nWe have not yet investigated whether this way of recovering totality is possible for our purely semantic \napproach to bidirectionalization. Even so, a natural question is how often a put-function obtained via \nb. will be unde.ned on some input. For example, a trivial put\u00adfunction that is unde.ned whenever the \nv in put sv is not equal to get s would satisfy the GetPut and PutGet laws, but is clearly undesirable \nin practice. Our approach usually does better than that, but one signi.cant limitation that it has in \nits current state is that any update that changes the shape of a view, say the length of a list, will \nlead to failure. Further discussion is contained in Section 7. Instead of a single function b. , we will \nactually give three functions b. , b.Eq, and b.Ord, the choice from which depends on whether the source-to-view \nfunctions to be handled may involve equality and/or ordering tests on the elements contained in the data \nstructures to be transformed. This re.ects that for a function like rmdups conceptually more involved \nconditions are required for safe bidirectionalization than for halve or tail, or any other function of \ntype [a] . [a] without an Eq-constraint. So b.Eq will be used for rmdups and its like, and b.Ord for \nfunctions like the following one: top3 :: Ord a . [a] . [a] top3 = take 3 . List.sort . List.nub But \nit is indeed the case that the single function b. applies to both halve and .atten, even though the former \nonly deals with lists while the latter also involves trees. That is, b. , as well as b.Eq and b.Ord, \nwill be generic over both input and output structures. To get a rough idea of what kind of structures \nwill be in reach, think of containers: shape plus data content (Abbott et al. 2003). Proving that for \nany get a put obtained as b. get, b.Eq get, or b.Ord get satis.es the GetPut and PutGet laws will be \ndone by us\u00ading free theorems (Reynolds 1983; Wadler 1989). Our formal rea\u00ad soning there will be morally \ncorrect in the sense of Danielsson et al. (2006). That is, our proofs of the GetPut and PutGet laws will \napply to total get-functions and total, .nite data structures. In par\u00adticular, we do not take into account \nHaskell intricacies like those studied by Johann and Voigtl\u00a8 ander (2004). This simpli.cation is done \nsolely for the sake of exposition, not because of any funda\u00admental problems with doing elsewise. All \ncode in this paper was developed and tested using the Glas\u00adgow Haskell Compiler 6.8.2. The .nal, generic \nversion of the code is available as Hackage (http://hackage.haskell.org) pack\u00ad age bff-0.1. An online \ntool based on it is also available at http: //linux.tcs.inf.tu-dresden.de/~bff/cgi-bin/bff.cgi. Throughout, \nwe sometimes use common Haskell functions and types without further comment, like fromJust, lookup (and \nthus Maybe), and zip above. Where these are not clear, Hoogle (http: //haskell.org/hoogle) has the answer. \n2. Getting Started We .rst deal only with lists as both input and output structures, aiming at a bidirectionalizer \nof type b. :: (.a.[a] . [a]) . (.a.[a] . [a] . [a]) . Note that the local universal quanti.cations over \na are essential here, and require compiler .ag -XRank2Types. Now, how can b. possibly learn anything \nabout its input func\u00adtion, so as to exploit that information for producing a good back\u00adward function? \nThe idea is to use the assumption that the input function get is polymorphic over the element type a. \nThis entails that its behavior does not depend on any concrete list elements, but only on positional \ninformation. And this positional information can even be observed explicitly, for example by applying \nget to ascending lists over integer values. Say get is tail, then every list [0..n] is mapped to [1..n], \nwhich allows b. to see that the head element of the original source is absent from the view, hence can\u00adnot \nbe affected by an update on the view, and hence should re\u00admain unchanged when propagating an updated \nview back into the source. And this observation can be transferred to other source lists than [0..n] \njust as well, even to lists over non-integer types, thanks to parametric polymorphism (Strachey 1967; \nReynolds 1983). Let us develop this line of reasoning further, still on the tail example. So b. tail \nis supposed to return a good put. To do so, it must determine what this put should do when given an original \nsource s and an updated view v. First, it would be good to .nd out to what element in s each element \nin v corresponds. Assume s has length n +1. Then by applying tail to the same-length list [0..n], b. \n(or, rather, b. tail = put) learns that the original view from which v was obtained by updating had length \nn, and also to what element in s each element in that original view corresponded. Being conservative, \nwe will only accept v if it has retained that length n. For then, we also know directly the associations \nbetween elements in v and positions in the original source. Now, to produce the updated source, we can \ngo over all positions in [0..n] and .ll fromAscList :: [(Int,a)] . IntMap a empty :: IntMap a notMember \n:: Int . IntMap a . Bool insert :: Int . a . IntMap a . IntMap a union :: IntMap a . IntMap a . IntMap \na lookup :: Int . IntMap a . Maybe a Figure 1. Functions from module Data.IntMap. them with the associated \nvalues from v. For positions for which there is no corresponding value in v, because these positions \nwere omitted when applying tail to [0..n], we can look up the correct value in s rather than in v. For \nthe concrete example, this will only concern position 0, for which we naturally take over the head element \nfrom s. The same strategy works also for general b. get. In short, given s, produce a kind of template \ns ' = [0..n] of the same length, together with an association g between integer values in that template \nand the corresponding values in s. Then apply get to s ' and produce a further association h by matching \nthis template view versus the updated proper value view v. Combine the two associations into a single \none h ', giving precedence to h whenever an integer template index is found in both h and g. Thus, it \nis guaranteed that we will only resort to values from the original source s when the corresponding position \ndid not make it into the view, and thus there is no way how it could have been affected by the update. \nFinally, produce an updated source by .lling all positions in [0..n] with their associated values according \nto h ' . For maintaining the associations between integer values and values from s and v, we use the \nstandard library Data.IntMap. Concretely, we import from it the functions given in Figure 1. Their names \nand type signatures should be enough documentation here, the only necessary additions being that IntMap.fromAscList \nexpects a list with integer keys in ascending order and that IntMap.union is left-biased for integers \noccurring as keys in both input maps. The latter will precisely realize the desired precedence of h over \ng. The described strategy is now easily implemented as follows: b. :: (.a.[a] . [a]) . (.a.[a] . [a] \n. [a]) b. get = .s v . let s ' = [0..length s - 1] g = IntMap.fromAscList (zip s ' s) h = assoc (get \ns ' ) v h ' = IntMap.union hg in map (fromJust . .ip IntMap.lookup h ' ) s ' assoc :: [Int] . [a] . IntMap \na assoc [] [] = IntMap.empty assoc (i : is)(b : bs) | IntMap.notMember im = IntMap.insert ibm where m \n= assoc is bs Note that the function assoc, realizing the matching between the template view and the \nupdated proper value view, needs to check that no index position is encountered twice, because otherwise \nit would not (yet) be clear how to deal with two potentially different update values. Our current version \nof b. works quite nicely already. For ex\u00adample, > bff tail \"abcd\" \"bCd\" \"abCd\" and for sieve :: [a] . \n[a] sieve (a : b : cs)= b : sieve cs sieve = [] we automatically get > bff sieve \"abcdefg\" \"123\" \"a1c2e3g\" \n(Note that sieve abcdefg = bdf .) However, ultimately the current version is too weak. It fails as soon \nas a source-to-view function duplicates a list element. For example, > bff (\\s -> s ++ s) \"a\" \"aa\" fails, \ndefeating the GetPut law. (Note that the GetPut law would demand that b. (.s . s ++ s) a ((.s . s ++ \ns) a ) = a .) And also, a bit more subtly, the PutGet law is violated for empty source lists: > bff halve \n\"\" \"a\" \"\" (Note that the PutGet law would demand that, if b. halve  a is de.ned, halve (b. halve  a \n) = a , but it is not the case that halve = a .) On the other hand, apart from this empty list weirdness \nwe truly have b. halve = put1. So it seems we have made a good start, on which to extend in the next \nsection. 3. Correct Bidirectionalization In order to .x b. to adhere to the GetPut law, we need to deal \nwith duplication of list elements. Consider again the source-to-view function .s . s ++ s. Applied to \na template [0..n], it will de\u00adliver the template view [0, . . . , n, 0,...,n]. Under what conditions \nshould a match between this template view and an updated proper value view be considered successful? \nClearly only when equal in\u00addices match up with equal values, because only then we can pro\u00adduce a meaningful \nassociation re.ecting a legal update. However, equality tests are not possible in Haskell at arbitrary \ntypes. So we will have to weaken the type of b. as follows: b. :: (.a.[a] . [a]) . (.a. Eq a . [a] . \n[a] . [a]) That is, the get-function given to b. will still (have to) be fully polymorphic, but the returned \nput-function will only be applicable to lists over an element type satisfying the Eq-constraint. This \nis not expected to cause any problems in practice, because applica\u00adtion scenarios for view-update will \ntypically involve data domains for which equality tests are naturally available (as opposed to, say, \noperating on lists of functions). And in any case, we could always recover the law-wise weaker but also \ntype-wise slightly wider ap\u00adplicable version of b. from the previous section by simply de.n\u00ading bogus \ninstances of Eq where the equality test == invariably returns False. Armed with equality tests, we can \nrewrite the function assoc as follows. We also take the opportunity to introduce more useful error signaling \nthan pattern-match errors as implicitly used before. assoc :: Eq a . [Int] . [a] . Either String (IntMap \na) assoc [] [] = Right IntMap.empty assoc (i : is)(b : bs)= either Left (checkInsert ib) (assoc is bs) \nassoc = Left Update changes the length. checkInsert :: Eq a . Int . a . IntMap a . Either String (IntMap \na) checkInsert ibm = case IntMap.lookup im of Nothing . Right (IntMap.insert ibm) Just c . if b == c \n then Right m else Left Update violates equality. From now on, we assume that every instance of Eq gives \na de.nition for == that makes it re.exive, symmetric, and transitive. Then, the following two lemmas \nhold. Lemma 1. For every is :: [Int], type t that is an instance of Eq, and f :: Int . t, we have assoc \nis (map f is) = Right h for some h :: IntMap t with IntMap.lookup ih = if elem i is then Just (fi) else \nNothing for every i :: Int. Lemma 2. Let is :: [Int], let t be a type that is an instance of Eq, and \nlet v :: [t] and h :: IntMap t . We have that if Right h = assoc is v , then map (.ip IntMap.lookup h) \nis == map Just v . We do not explicitly prove either of the two lemmas here. Both are easily established \nby induction on the list is, taking the spec\u00adi.cations of functions in Data.IntMap into account. Note \nthat in the conclusion of Lemma 2 we cannot simply replace == by =, because the instance of Eq for t \nmay very well give x == y for some x = y. We will continue to be careful about this distinction in what \nfollows. Of course, the instances of Eq used in practice will often have == agree with semantic equivalence \n(such as for integers, characters, strings, . . . ). The improved version of assoc can now be used for \nan im\u00adproved version of b. as follows: b. :: (.a.[a] . [a]) . (.a. Eq a . [a] . [a] . [a]) b. get = .s \nv . let s ' = [0..length s - 1] g = IntMap.fromAscList (zip s ' s) h = either error id (assoc (get s \n' ) v) h ' = IntMap.union hg in seq h (map (fromJust . .ip IntMap.lookup h ' ) s ' ) Note that the use \nof error turns a potential failure in assoc (or, via assoc, in checkInsert) into an explicit runtime \nerror with meaningful error message. The use of seq prevents such an error going unnoticed in the case \nthat s, and thus s ', is the empty list. (This solves the problem with the PutGet law observed at the \nend of Section 2.) Instead of the polymorphic strict evaluation primitive we could also have used an \nemptiness test or any other strict operation on h. The new version of b. now does not only work for halve, \ntail, sieve, and the like, but also for get-functions that duplicate list elements. For example, > bff \n(\\s -> s ++ s) \"a\" \"aa\" \"a\" > bff (\\s -> s ++ s) \"a\" \"bb\" \"b\" > bff (\\s -> s ++ s) \"a\" \"ab\" \"*** Exception: \nUpdate violates equality. Formally, we establish the GetPut and PutGet laws as follows. Theorem 1. For \nevery function get :: .a.[a] . [a], type t that is an instance of Eq, and s :: [t ], we have b. get s \n(get s) = s . Proof. By the function de.nition for b. we have b. get s (get s) = (1) seq h (map (fromJust \n. .ip IntMap.lookup h ' ) s ' ) , where: s ' = [0..length s - 1] (2) g = IntMap.fromAscList (zip s ' \ns) (3) h = either error id (assoc (get s ' ) (get s) ) (4) h ' = IntMap.union h g . (5) Clearly, (2) \nimplies s = map (s !!) s ' , (6) where the operator !! is used for extracting a list element at a given \nindex position. Thus, get s = get (map (s !!) s ' ) . By a free theorem of Wadler (1989), every get :: \n.a.[a] . [a] satis.es get . map f = map f . get for every choice of f. Thus, in particular, get s = map \n(s !!) (get s ' ) . Together with (4) and Lemma 1, this gives that h is de.ned (i.e., not a runtime error) \nand that for every i :: Int, IntMap.lookup ih = if elem i (get s ' ) then Just (s !! i) else Nothing \n. Since by (2), (3), and the speci.cation of IntMap.fromAscList, for every i :: Int, IntMap.lookup ig \n= if elem is ' then Just (s !! i) else Nothing , we have by (5) and the speci.cation of IntMap.union \nthat for every i :: Int, ' IntMap.lookup ih ' = if elem i (get s ) then Just (s !! i) else if elem is \n' then Just (s !! i) else Nothing . Together with (1), the de.nedness of h, and (6), this gives the claim. \nTheorem 2. Let get :: .a.[a] . [a], let t be a type that is an instance of Eq, and let v, s :: [t ]. \nWe have that if b. get sv is de.ned, then get (b. get sv) == v . The proof of this second theorem, relying \non Lemma 2 and using a similar style of reasoning as above, is given in Appendix A. Note that the theorem \nestablishes the PutGet law only up to ==, rather than for true semantic equivalence. As mentioned earlier, \nin practice == will typically agree with = for the types of data under consideration, so this is no big \nissue. 4. Source-to-View Functions with Equality Tests In the previous section we already used Eq-constraints \nfor deliver\u00ading good put-functions. On the other hand, the get-functions taken as input had to be fully \npolymorphic, and for good reason. Tempt\u00ading as it may be to simply change the type of b. to b. :: (.a. \nEq a . [a] . [a]) . (.a. Eq a . [a] . [a] . [a]) , so that it would also accept get-functions like the \nrmdups :: Eq a . [a] . [a] from the introduction, this would be inviting disaster: > bff rmdups \"abcbabcbaccba\" \n\"aBc\" \"*** Exception: Update changes the length. > bff rmdups \"abcbabcbaccba\" \"abc\" \"*** Exception: Update \nchanges the length. > bff rmdups \"abc\" \"aaa\" \"aaa\" > bff rmdups \"aaa\" \"abc\" \"abc\" All four experiments \ndisagree with our expectations. For exam\u00adple, since rmdups abcbabcbaccba = abc , we would have ex\u00adpected \nin the .rst experiment that a view update into aBc leads to an update of the source into aBcBaBcBaccBa \n. But instead, b. rmdups fails. In the second experiment, where the view abc has not even been changed \nat all, we would have expected that b. rmdups returns the original source abcbabcbaccba . After all, \nthat is what the GetPut law demands. But it does not happen. Sim\u00adilarly, the third experiment violates \nthe PutGet law. The main reason for failure here is that it is not necessarily true that one can always \nunderstand the behavior of a function get :: Eq a . [a] . [a] on a source list s by simply ob\u00adserving \nits behavior on the template list [0..n] of the same length. For this would completely lose track of \npotentially duplicated el\u00adements in s and how get might react to them. Note that this issue is nonexistent \nin Section 3, because a fully polymorphic function get :: [a] . [a] is unable to react to duplicated \nelements, as it cannot even detect them. Since here this is different, the .rst step to\u00adwards a solution \nis a more intelligent template manufacture. For ex\u00adample, instead of [0..12] the template for abcbabcbaccba \nshould be [0, 1, 2, 1, 0, 1, 2, 1, 0, 2, 2, 1, 0], together with an association of 0 to a , 1 to b , \nand 2 to c . In writing a function to do this job, one needs to keep track of which elements have already \nbeen seen while going through the source list. Thus, it makes sense to use a state monad (Wadler 1992). \nAnd since for every element already seen one needs to be able to determine the template integer value \nto which it has been associated, it makes sense to extend the IntMap abstraction with a facility for \nbackwards lookup. We have imple\u00admented such a new abstraction, with API as given in Figure 2. Of immediate \ninterest here are only the functions IntMapEq.empty, IntMapEq.insert, and IntMapEq.lookupR. Using them, \nwe ob\u00adtain the following piece of code. The state that is carried around consists of an IntMapEq containing \nthe elements that have already been encountered and an integer denoting the next available key. The function \nnumberEq describes the action to be performed for every element found in a source list, and by which \ninteger key to replace it in the template list. templateEq :: Eq a . [a] . ([Int], IntMapEq a) templateEq \ns = case runState (go s)(IntMapEq.empty, 0) of (s ' , (g, )) . (s ' ,g) where go [] = return [] go (a \n: as)= do i . numberEq a is . go as return (i : is) numberEq :: Eq a . a . State (IntMapEq a, Int) Int \nnumberEq a = do (m, i) . State.get case IntMapEq.lookupR am of Just j . return j Nothing . do let m ' \n= IntMapEq.insert iam State.put (m ' ,i + 1) return i empty :: IntMapEq a insert :: Int . a . IntMapEq \na . IntMapEq a checkInsert :: Eq a . Int . a . IntMapEq a . Either String (IntMapEq a) union :: Eq a \n. IntMapEq a . IntMapEq a . Either String (IntMapEq a) lookup :: Int . IntMapEq a . Maybe a lookupR :: \nEq a . a . IntMapEq a . Maybe Int Figure 2. Functions from module IntMapEq. Then, for example, > template_Eq \n\"transformation\" ([0,1,2,3,4,5,6,1,7,2,0,8,6,3],fromList [(0, t ),( 1, r ),(2, a ),(3, n ),(4, s ),(5, \nf ),(6, o ),(7, m ),(8, i )]) More generally, the following lemma holds. Lemma 3. Let t be a type that \nis an instance of Eq and let s :: [t], s ' :: [Int], and g :: IntMapEq t . We have that if (s ' ,g) = \ntemplateEq s , then map (.ip IntMapEq.lookup g) s ' == map Just s ,  for every i :: Int not in s ' \n, IntMapEq.lookup ig = Nothing ,  for every i/= j in s ' ,  IntMapEq.lookup ig/= IntMapEq.lookup jg \n. Here /= is the complement of ==. Again we refrain from giving an explicit proof of this auxiliary lemma. \nIt is quite similar to an example of Hutton and Fulger (2008), and we have nothing con\u00ad ceptually new \nto contribute right here regarding proof techniques. The .nal statement in Lemma 3, about different integers \nbeing mapped to different (according to /= at type t ) values by g is very essential. The proofs of both \nTheorems 1 and 2 use the free theorem get .map f = map f .get. But that was for get :: [a] . [a]. For \nthe get :: Eq a . [a] . [a] of interest now, we know from Wadler (1989, Section 3.4) that f cannot be \narbitrary anymore. Rather, it must respect Eq in the sense that x == y if and only if fx == fy. And since \nultimately the f for which we will want to apply the free theorem are connected to g and later h ' , \nwe need an injectivity invariant for the IntMapEqs under use. This is why both IntMapEq.checkInsert and \nIntMapEq.union have Either String (IntMapEq a) as return type in Figure 2, so that they can give a meaningful \nerror message in case of a violation of this invariant. The IntMapEq.insert used in numberEq, on the \nother hand, has no such safeguards. But Lemma 3 tells us that everything is still okay with templateEq. \nOf course, we also need to adapt assoc, but only slightly. Basically, we just switch from operations \non IntMaps to op\u00aderations on IntMapEqs, the most important change being that IntMapEq.checkInsert does \nnot only prevent insertion of two dif\u00adferent update values for the same integer key, but does also prevent \ninsertion of equal update values for different integer keys (so as to prevent the b. rmdups abc aaa \n= aaa disaster with its violation of the PutGet law). The variant of assoc to use is then as follows: \nassocEq :: Eq a . [Int] . [a] . Either String (IntMapEq a) assocEq [] [] = Right IntMapEq.empty assocEq \n(i : is)(b : bs)= either Left (IntMapEq.checkInsert ib) (assocEq is bs) assocEq = Left Update changes \nthe length. For it, we claim the following two lemmas. The notion of a function f :: Int . t, for a \ntype t that is an instance of Eq, being injective on a list is :: [Int] is de.ned as for every i/= j \nin is, also f i/= fj . Lemma 4. Let is :: [Int], let t be a type that is an instance of Eq, and let f \n:: Int . t and v :: [t]. We have that if map f is == v and f is injective on is, then assocEq is v = \nRight h for some h :: IntMapEq t with IntMapEq.lookup ih == if elem i is then Just (fi) else Nothing \nfor every i :: Int. Lemma 5. Let is :: [Int], let t be a type that is an instance of Eq, and let v :: \n[t] and h :: IntMapEq t . We have that if Right h = assocEq is v , then map (.ip IntMapEq.lookup h) \nis == map Just v ,  for every i :: Int not in is, IntMapEq.lookup ih = Nothing ,  .ip IntMapEq.lookup \nh is injective on is.  Like for Lemmas 1 and 2, the proofs are by induction on the list is, but now \nrelying on the correct implementation (in particular, regarding the injectivity invariant) of the operations \nin module IntMapEq. Now we are prepared to give a correct bidirectionalizer for source-to-view functions \npotentially involving equality tests: b.Eq :: (.a. Eq a . [a] . [a]) . (.a. Eq a . [a] . [a] . [a]) b.Eq \nget = .s v . let (s ' ,g)= templateEq s h = either error id (assocEq (get s ' ) v) h ' = either error \nid (IntMapEq.union hg) in seq h ' (map (fromJust . .ip IntMapEq.lookup h ' ) s ' ) Let us do some sanity \nchecks: > bff_Eq rmdups \"abcbabcbaccba\" \"aBc\" \"aBcBaBcBaccBa\" > bff_Eq rmdups \"abcbabcbaccba\" \"abc\" \"abcbabcbaccba\" \n> bff_Eq rmdups \"abc\" \"aaa\" \"*** Exception: Update violates differentness. > bff_Eq rmdups \"aaa\" \"abc\" \n\"*** Exception: Update changes the length. This looks much better than what we saw at the beginning \nof the current section. Indeed, we now truly have b.Eq rmdups = put3 for put3 as given in the introduction \n(except that b.Eq rmdups gives more meaningful error messages). A small, but important, detail in the \nde.nition of b.Eq is that the computation of h ' via IntMapEq.union may now also lead to an error being \nraised. This is essential for properly dealing with examples like the following one: > bff_Eq (tail . \nrmdups) \"abcbabcbaccba\" \"ba\" \"*** Exception: Update violates differentness. Note that the view obtained \nfrom abcbabcbaccba by applying tail .rmdups is bc . Updating bc to ba does not yet introduce a differentness \nviolation on the view level. But blindly propagating this change from c to a back into the original source \nwould give ababababaaaba . And this would contradict the PutGet law, be\u00adcause tail.rmdups applied to \nababababaaaba gives b , which is different from the supposed ba . The solution employed to detect such \nlate con.icts (arising when the updates learned by comparing the template view with the updated proper \nvalue view encounter those values from the original source that did not make it into the view and thus \nare simply kept unchanged) is to make sure that no unwarranted equalities occur when combining the associations \nh and g into h '. Our implementation of IntMapEq.union takes care of that. This does not change its left-biased \nnature. That is, an error is only reported if a pair (i, b) in h con.icts with a pair (j, a) in g in \nthe sense that a == b and there is no pair (j, c) in h that renders (j, a) irrelevant. Before proving \nthe GetPut and PutGet laws for b.Eq, let us clarify the situation of free theorems for functions of the \ntype get :: .a. Eq a . [a] . [a]. The general form, as obtained for example from our online free theorems \ngenerator http://linux. tcs.inf.tu-dresden.de/~voigt/ft, is that for every choice of types t1 and t2 \nthat are instances of Eq, relation R between them that respects Eq, and lists l1 :: [t1] and l2 :: [t2] \nof the same length and element-wise related by R, the lists get l1 and get l2 are also of the same length \nand element-wise related by R. The notion of R respecting Eq here means that for every (a, b) and (c, \nd) in R, a == c if and only if b == d. This general free theorem easily gives the following specialized \nversion. Lemma 6. Let get :: .a. Eq a . [a] . [a], let t be a type that is an instance of Eq, and let \nf :: Int . t, s ' :: [Int], and s :: [t ]. We have that if map fs ' == s and f is injective on s ' , \n' '' then map f (get s ) == get s and every i in get s is also in s . The relation R used for this specialization \nis the one which contains exactly all pairs (i, a) with i :: Int, a :: t , i in s ', and fi == a. Now, \nwe can go about proving the GetPut and PutGet laws for b.Eq. The former is now also established only \nup to ==. Theorem 3. For every get :: .a. Eq a . [a] . [a], type t that is an instance of Eq, and s :: \n[t], we have b.Eq get s (get s) == s . Theorem 4. Let get :: .a. Eq a . [a] . [a], let t be a type that \nis an instance of Eq, and let v, s :: [t ]. We have that if b.Eq get sv is de.ned, then get (b.Eq get \nsv) == v . The proofs of these two theorems, relying on Lemmas 3 6, are given in Appendices B and C. \n5. Source-to-View Functions with Ordering Tests Having dealt with equality tests, how about ordering \ntests? Can we produce a correct bidirectionalizer of type b.Ord :: (.a. Ord a . [a] . [a]) . (.a. Ord \na . [a] . [a] . [a]) ? The roadmap to follow should be relatively clear from the previous section. First, \nwe need an appropriate template manufacture. Now the template integer values should not only re.ect which \nelements in the original source are equal, but also need to re.ect their rel\u00adative order. Since this \nmeans that we cannot assign integer values until we have seen the full source list, it turns out that \nthe monadic traversal used in templateEq is not suf.cient anymore. Instead, we use the framework of applicative \nfunctors, or idioms (McBride and Paterson 2008). It is captured by the following Haskell type con\u00ad structor \nclass, de.ned in the standard library Control.Applicative: class Functor f . Applicative f where pure \n:: a . fa (<*>) :: f (a . \u00df) . fa . f\u00df For ordered template generation we conceptually need two phases, \na .rst to collect all values occurring in the original source list, so that after sorting them a second \nphase can assign appropriate integer values. It turns out that for both tasks there already exist prede.ned \napplicative functors. For the collection of values, we can simply use the constant functor (Control.Applicative.Const) \nmapping to the monoid (Data.Monoid) of sets (Data.Set): collect :: Ord a . [a] . Const (Set a)[\u00df] collect \ns = traverse (.a . Const (Set.singleton a)) s traverse :: Applicative f . (a . f\u00df) . [a] . f [\u00df] traverse \nf [] = pure [] traverse f (a : as)= pure (:) <*>fa<*> traverse f as To build a proper association between \ninteger values and (ordered) source values, we need an abstraction similar to IntMapEq but maintaining \nan order-preservation invariant as well. We provide this in module IntMapOrd, with API as given in Figure \n3. Note that fromAscPairList expects a list with both keys and values in ascending order. Together with \nthe function Set.toAscList that transforms a set into a sorted list, we can de.ne set2map :: Ord a . \nSet a . IntMapOrd a set2map as = IntMapOrd.fromAscPairList (zip [0..](Set.toAscList as)) and then have, \nfor example: > set2map . getConst $ collect \"transformation\" fromList [(0, a ),(1, f ),(2, i ),(3, m \n),(4, n ), (5, o ),(6, r ),(7, s ),(8, t )] For propagating knowledge about such a proper assignment \nbe\u00adtween integer values and ordered source values, we can use a par\u00adtially applied function arrow functor:1 \npropagate :: Ord a . [a] . ((.)(IntMapOrd a)) [Int] propagate s = traverse (.a . fromJust . IntMapOrd.lookupR \na) s For example, with m being the IntMapOrd Char returned above, we have: > propagate \"transformation\" \nm [8,6,0,4,7,1,5,6,3,0,8,2,5,4] Since we do not want to spend two traversals on the collection and propagation \nphases, we pair the involved applicative functors together with a lifted product bifunctor. Altogether, \nwe realize the new template generator as follows: templateOrd :: Ord a . [a] . ([Int], IntMapOrd a) templateOrd \ns = case traverse numberOrd s of Lift (Const as,f) . let m = set2map as in (f m,m) numberOrd :: Ord \na . a . Lift (, )(Const (Set a)) ((.)(IntMapOrd a)) Int numberOrd a = Lift (Const (Set.singleton a), \nfromJust . IntMapOrd.lookupR a) Note that numberOrd, which serves as argument to traverse in the de.nition \nof templateOrd, is essentially obtained as a split 1 Note that the type of propagate could equivalently \nbe written as follows: Ord a . [a] . IntMapOrd a . [Int]. fromAscPairList :: Ord a . [(Int,a)] . IntMapOrd \na empty :: IntMapOrd a checkInsert :: Ord a . Int . a . IntMapOrd a . Either String (IntMapOrd a) union \n:: Ord a . IntMapOrd a . IntMapOrd a . Either String (IntMapOrd a) lookup :: Ord a . Int . IntMapOrd \na . Maybe a lookupR :: Ord a . a . IntMapOrd a . Maybe Int Figure 3. Functions from module IntMapOrd. \nof the corresponding arguments in the de.nitions of collect and propagate above. This kind of tupling \nis an old trick to avoid mul\u00adtiple traversals of data structures (Pettorossi 1987). An alternative approach \nto ordered template generation would be to use an order\u00admaintenance data structure (Dietz and Sleator \n1987). Under the assumption that in addition to the conditions we have already imposed on instances of \nEq every instance of Ord satis.es that the provided < is transitive, that x<y implies x/= y, and that \nx/= y implies x<y or y<x, the following analogue of Lemma 3 now holds. The notion of a function f :: \nInt . t, for a type t that is an instance of Ord, being order-preserving on a list s ' :: [Int] is de.ned \nas for every i<j in s ', also fi<fj . Lemma 7. Let t be a type that is an instance of Ord and let s :: \n[t ], s ' :: [Int], and g :: IntMapOrd t. We have that if (s ' ,g) = templateOrd s , then map (.ip IntMapOrd.lookup \ng) s ' == map Just s ,  for every i :: Int not in s ' , IntMapOrd.lookup ig = Nothing ,  .ip IntMapOrd.lookup \ng is order-preserving on s ' .  We omit a formal proof, but the following example should be reassuring: \n> template_Ord \"transformation\" ([8,6,0,4,7,1,5,6,3,0,8,2,5,4],fromList [(0, a ),( 1, f ),(2, i ),(3, \nm ),(4, n ),(5, o ),(6, r ),(7, s ),(8, t )]) On the view association side, the changes from assocEq \nto assocOrd are almost trivial: assocOrd :: Ord a . [Int] . [a] . Either String (IntMapOrd a) assocOrd \n[] [] = Right IntMapOrd.empty assocOrd (i : is)(b : bs)= either Left (IntMapOrd.checkInsert ib) (assocOrd \nis bs) assocOrd = Left Update changes the length. and analogues of Lemmas 4 and 5 for assocOrd instead \nof assocEq are obtained by simply replacing Eq by Ord, injective by order\u00adpreserving , and IntMapEq by \nIntMapOrd. Finally, our bidirectionalizer for source-to-view functions po\u00adtentially involving ordering \ntests takes the following, by now prob\u00adably expected, form: b.Ord :: (.a. Ord a . [a] . [a]) . (.a. Ord \na . [a] . [a] . [a]) b.Ord get = .s v . let (s ' ,g)= templateOrd s ' h = either error id (assocOrd (get \ns ) v) h ' = either error id (IntMapOrd.union h g) ' seq h ' (map (fromJust . .ip IntMapOrd.lookup h \n' in ) s ) Showing off its power, for the function top3 from the introduction: > bff_Ord top3 \"transformation\" \n\"abc\" \"transbormatcon\" > bff_Ord top3 \"transformation\" \"xyz\" \"*** Exception: Update violates relative \norder. For proving the GetPut and PutGet laws for b.Ord, we need an appropriate free theorem that holds \nfor every function of type get :: .a. Ord a . [a] . [a]. Again consulting the online free theorems generator \nhttp://linux.tcs.inf.tu-dresden.de/ ~voigt/ft, we obtain that for every choice of types t1 and t2 that \nare instances of Ord, relation R between them that respects Ord, and lists l1 :: [t1] and l2 :: [t2] \nof the same length and element\u00adwise related by R, the lists get l1 and get l2 are also of the same length \nand element-wise related by R. The notion of R respecting Ord here means that for every (a, b) and (c, \nd) in R, a<c if and only if b<d (and assuming that the other operations of the Ord type class relate \nto the de.nitions for == and < in the natural way). Setting t1 = Int, t2 = t, R = {(i, a) | elem is ' \n&#38;&#38; fi == a}, l1 = s ', and l2 = s, we obtain the following specialized version. Lemma 8. Let \nget :: .a. Ord a . [a] . [a], let t be a type that is an instance of Ord, and let f :: Int . t , s ' \n:: [Int], and s :: [t ]. We have that if map fs ' == s and f is order-preserving on s ' , ' '' then map \nf (get s ) == get s and every i in get s is also in s . Now, quite pleasingly, the proofs of the following \ntwo theorems are exact replays of the proofs given for Theorems 3 and 4 in Appendices B and C, respectively, \nexcept that Lemma 7 is used instead of Lemma 3, that Lemma 8 is used instead of Lemma 6, and that the \nanalogues of Lemmas 4 and 5 mentioned above are used instead of those two lemmas themselves. Theorem \n5. For every get :: .a. Ord a . [a] . [a], type t that is an instance of Ord, and s :: [t], we have b.Ord \nget s (get s) == s . Theorem 6. Let get :: .a. Ord a . [a] . [a], let t be a type that is an instance \nof Ord, and let v, s :: [t]. We have that if b.Ord get sv is de.ned, then get (b.Ord get sv) == v . 6. \nGoing Generic So far, we have focused on list data structures for sources and views. In this section, \nwe lift this restriction, both on the input and output sides of get-functions. Let us start with the \ninput side, and with b.Ord. Where in the de.nition of b.Ord is the fact important that the input data \nstructure is a list? The answer is: at two places; once in the de.nition of traverse as used in templateOrd \nand thus in b.Ord, and once when using map inside b.Ord itself. But note that even though we have provided \nour own de.nition of traverse in the previous section, a function with that name already exists in the \nstandard library Data.Traversable, where it is a method of the type constructor class Traversable and \nhas the following type: traverse :: (Applicative f, Traversable .) . (a . f\u00df) . .a . f (.\u00df) . Moreover, \nthere is also a prede.ned instance of Traversable for the type of lists, and the de.nition for traverse \nin that instance is exactly the one seen in the previous section. So we could have avoided de.ning our \nown traverse and instead used the prede.ned one. But more importantly, we can give templateOrd the following \nmore general type, without changing anything about its de.nition: templateOrd :: (Traversable ., Ord \na) . .a . (. Int, IntMapOrd a) . Providing an instance de.nition for the data type Tree from the introduction \nas follows: instance Traversable Tree where traverse f (Leaf a)= pure Leaf <*>fa traverse f (Node t1 \nt2)= pure Node <*> traverse ft1 <*> traverse ft2 we then have, for example: > template_Ord (Node (Leaf \na ) (Leaf b )) (Node (Leaf 0) (Leaf 1),fromList [(0, a ),(1, b )]) Actually, for dependency reasons, \nwe also need to add the follow\u00ading two instance de.nitions: instance Foldable Tree where foldMap = foldMapDefault \ninstance Functor Tree where fmap = fmapDefault But these will always be the same for every new data type, \nand so do not impose any real burden. And even the burden of hav\u00ading to write Traversable instances can \nbe avoided. Namely, by us\u00ading the modules Data.DeriveTH and Data.Derive.Traversable of Hackage package \nderive-0.1.1 (authored by N. Mitchell and S. O Rear), as well as compiler .ag -XTemplateHaskell, we could \ninstead of the above manual instance de.nition for Tree simply have written $( derive makeTraversable \n'' Tree ) Back to b.Ord itself. Since every Traversable is also a Functor, it now suf.ces to replace \nmap by fmap :: Functor . . (\u00df . a) . .\u00df . .a in b.Ord s de.nition to allow a generalization of its type \nas well: b.Ord :: Traversable . . (.a. Ord a . .a . [a]) . (.a. Ord a . .a . [a] . .a) . This means that \nwe can now bidirectionalize functions of type get :: .a. Ord a . .a . [a] for any instance . of Traversable, \nnot just for lists. For example, we can use b.Ord on functions get :: .a. Ord a . Tree a . [a] just as \nwell. Can we pro.t from the same kind of genericity also for b.Eq and b. ? Concentrating on b.Eq .rst, \nit seems that we cannot readily use the generic traverse, because templateEq is based on a monad, not \non an applicative functor. But actually every monad can be wrapped to form an applicative functor, and \nthere are even prede.ned facilities for this in Control.Applicative. So without changing anything at \nall about numberEq we can rewrite templateEq as follows: templateEq :: (Traversable ., Eq a) . .a . (. \nInt, IntMapEq a) templateEq s = case runState (go s)(IntMapEq.empty, 0) of (s ' , (g, )) . (s ' ,g) where \ngo = unwrapMonad . traverse (WrapMonad . numberEq) and then obtain a generic bidirectionalizer b.Eq \n:: Traversable . . (.a. Eq a . .a . [a]) . (.a. Eq a . .a . [a] . .a) simply by replacing map by fmap \nin the de.nition of b.Eq. And even for b. we can replace the template generation via s ' = [0..length \ns - 1] and g = IntMap.fromAscList (zip s ' s) by a more streamlined one amenable to Traversable. Again \nwe use a state monad, wrapped up as an applicative functor. In full:2 b. :: Traversable . . (.a. . a \n. [a]) . (.a. Eq a . .a . [a] . .a) b. get = .s v . let (s ' ,g)= template s ' h = either error id (assoc \n(get s ) v) h ' = IntMap.union h g ' seq h (fmap (fromJust . .ip IntMap.lookup h ' in ) s ) template \n:: Traversable . . .a . (. Int, IntMap a) template s = case runState (go s) ([], 0) of (s ' , (l, )) \n. (s ' , IntMap.fromAscList (reverse l)) where go = unwrapMonad . traverse (WrapMonad . number) number \n:: a . State ([(Int,a)], Int) Int number a = do (l, i) . State.get State.put ((i, a): l, i + 1) return \ni This version is now also applicable to get-functions with source data structures other than lists. \nFor example, for the function .atten from the introduction we obtain: > bff flatten (Node (Leaf a ) (Leaf \nb )) \"xy\" Node (Leaf x ) (Leaf y ) Indeed, b. .atten = put2. Clearly, a similar generalization from lists \nto other data struc\u00adtures is desirable for the output sides of get-functions as well. The key task then \nis to replace assoc, assocEq, and assocOrd by generic versions that are not anymore speci.c to lists. \nUnfortunately, there is no prede.ned class like Traversable that we can simply use here. But there is \na common core to the different assoc-functions. Namely, they all traverse two lists in lock-step, pairing \nup the ele\u00adments found in corresponding positions, and inserting those pairs into some variation of integer \nmaps. It is very natural to capture the .rst aspect, of traversing two data structures in a synchronized \nfashion and collecting pairs of corresponding elements, by a new type constructor class as follows: class \nZippable . where tryZip :: .a . .\u00df . Either String (. (a, \u00df)) Since such a zipping can also fail, for \nexample if two lists have unequal length, we provide for potential error messages in the return type \nof tryZip. Now, for example, instances of Zippable for lists and for the data type Tree can be given \nas follows: instance Zippable [] where tryZip [] [] = Right [] tryZip (i : is)(b : bs)= Right (:) <*> \nRight (i, b) <*> tryZip is bs tryZip = Left Update changes the length. instance Zippable Tree where tryZip \n(Leaf i)(Leaf b)= Right (Leaf (i, b)) tryZip (Node t1 t2)(Node v1 v2)= Right Node <*> tryZip t1 v1 <*> \ntryZip t2 v2 tryZip = Left Update changes the shape. 2 The use of reverse in the de.nition of template \nis necessary to ensure that IntMap.fromAscList indeed receives a list with keys in ascending order. Note \nthat for convenient propagation of potential errors we use an appropriate instance of Applicative for \nEither String. Now, the assoc-functions can be factorized into applications of tryZip followed by folding \nsome insertion functions over the zipped structure containing pairs of integers and updated view values. \nBy folding , we of course mean a generic operation not speci.c to lists, and fortunately there is already \na type constructor class for just this purpose in the standard library Data.Foldable. The class method \nof interest here is the following one: Data.Foldable.foldr :: Foldable . . (a . \u00df . \u00df) . \u00df . .a . \u00df Using \nit, we get for example: assoc :: (Zippable ., Foldable ., Eq a) . . Int . .a . Either String (IntMap \na) assoc = makeAssoc checkInsert IntMap.empty makeAssoc checkInsert empty s '' v = either Left f (tryZip \ns '' v) where f = Data.Foldable.foldr (either Left . uncurry checkInsert) (Right empty) Then we can change \nthe type of b. into b. :: (Traversable ., Zippable . ' , Foldable . ' ) . (.a. . a . . ' a) . (.a. Eq \na . .a . . ' a . .a) without having to change anything at all about the function s cur\u00adrent de.nition. \nAnalogously, with assocEq :: (Zippable ., Foldable ., Eq a) . . Int . .a . Either String (IntMapEq a) \nassocEq = makeAssoc IntMapEq.checkInsert IntMapEq.empty and assocOrd :: (Zippable ., Foldable ., Ord \na) . . Int . .a . Either String (IntMapOrd a) assocOrd = makeAssoc IntMapOrd.checkInsert IntMapOrd.empty \n and without any changes to the current function de.nitions of b.Eq and b.Ord, we get more generic types \nfor them in the spirit of the .nal type for b. given above, that is, generalizing [a] to . ' a for any \n. ' that is an instance of both Zippable and Foldable. Note that instances of Foldable are already automatically \nderiv\u00adable in the same fashion using Data.DeriveTH as instances of Traversable are, or alternatively \ncan be obtained from Traversable instances using the kind of default de.nition seen earlier in this section. \nThus, all the remaining effort required to make b. , b.Eq, and b.Ord successfully deal with a new data \ntype on both the in\u00adput and output sides of get-functions is to provide an appropri\u00adate Zippable instance. \nThis could be done manually, but Hackage package bff-0.1 also contains an automatic deriver (contributed \nby J. Breitner) that generalizes the Zippable instances seen earlier in this section.3 What about the \ncorrectness of the generic versions? Of course, for their speci.c instantiations to the case of lists \nour proofs as given previously continue to apply. For the generic case some gen\u00aderalization effort is \nrequired. For example, Lemmas 3 and 7 need to be replaced by versions involving fmap instead of map, \nand a similar statement is necessary for template in order to replace the 3 Actually, it produces slightly \ndifferent de.nitions using an ef.ciency im\u00adprovement trick inspired by Voigtl\u00a8ander (2008). Also, it \nbecame necessary to add a Traversable class restriction as precondition to the de.nition of class Zippable. \nuse of (2) and (3) in the proof of Theorem 1. We need to derive generic versions of the free theorems \nwe have used, and we need to replace the lemmas about assoc-functions (i.e., Lemmas 1, 2, 4, 5, and the \nanalogues of Lemmas 4 and 5 for the Ord-setting as men\u00adtioned in Section 5) by corresponding generic \nversions. Actually, these lemmas can now be factorized into statements about instances of Zippable and \nstatements about the checkInsert-and empty\u00adfunctions being folded over the zipped structures. We refrain \nhere from exercising all this through. 7. Discussion and Evaluation We have presented a new bidirectionalization \ntechnique for a wide range of polymorphic functions. One might wonder whether what we achieve is true \nbidirectionalization. After all, for a given forward function, we do not really obtain a backward component \nthat is somehow tailored to it in the sense that it is based on a deep analysis of the forward function \ns innards. Rather, the put-function we obtain will, at runtime, observe the get-function in forward mode, \nand draw conclusions from this kind of simulation . Is not that cheating? While this might .rst appear \nto be a serious objection casting our overall approach in doubt, we think it is ultimately unnecessary \nconcern. At the end of the day, what counts is whether or not the obtained put-function is extensionally \nthe one we want and need, and its genesis and intensional, syntactic aspects are completely ir\u00adrelevant \nfor this evaluation. So how good are our b. get and so on, under such impartial judgment? Having established \nthe GetPut and PutGet laws is one step towards an answer. Moreover, even though we have not included \nthe additional proofs here, also the PutPut law holds. That is, for every pair get/put with put = b. \nget, put = b.Eq get, or put = b.Ord get, we have that if put sv and put (put sv) v ' are de.ned, then \nput (put sv) v ' == put sv ' . And undoability is also a given; i.e., if put sv is de.ned, then put (put \nsv)(get s) == s . And even beyond just those base requirements, the put-functions returned by our bidirectionalizers \noften do exactly The Right Thing. Examples for this can be seen in the introduction and throughout the \npaper, and more are easy to come by. Of course, it should not be expected that an automatic approach \ncan always deliver the ab\u00adsolutely best backward component one could write by hand. For example, for \nthe function halve from the introduction a slight im\u00adprovement to put1 would be possible by weakening \nthe condition length as ' == n to length as ' == n || odd (length as) &#38;&#38; length as ' == n+1 . \nOur technique does not detect this, i.e., b. halve is semantically equivalent to the original version \nof put1 without this small im\u00adprovement. But that much comes for free, and is arguably suf.cient in most \ncases. Maybe a good way to think about possible application scenarios for our technique is to consider \nit as a very useful tool for rapid prototyping. Imagine one wants to build some system with built-in \nbidirectionality support, such as the structured document editor of Hu et al. (2004). Would not it be \nnice to have at one s command much of the Haskell Prelude and polymorphic functions from other standard \nlibraries, all with backward components obtained at no cost? Even if the automatically provided backward \ncomponents are not perfect in each and every case, they give an initial solution and enable progress \nto be made quickly on the overall design without getting lost in the bidirectionality aspect. And once \nthat design has solidi.ed, it is possible to see which forward functions are actually going to be used, \nwhich of them are critical and did not get assigned a suf.ciently good backward component the free and \neasy way, and then to provide .ne-tuned versions for those by hand. For programming in the large, it \nwould also be worthwhile to look at connecting our technique to the combinatory approach pi\u00adoneered by \nFoster et al. (2007). Their framework provides for sys\u00ad tematic and sound ways of assembling bigger bidirectional \ntrans\u00adformations from smaller ones, but naturally depends on a supply of correctly behaving get/put-pairs \nbeing available on the lowest level of granularity. Our free bidirectionalizers promise to provide a \nrich and safe source to be used in this context. It would also be interesting to investigate how our \ndevelopment relates to recent ex\u00adtensions of the combinatory approach for ordered data (Bohannon et al. \n2008) and for correctness modulo equivalence relations (Fos\u00ad ter et al. 2008). Other pragmatic questions \nworth investigating include whether it is possible to use a similar technique to ours for deriving create\u00adfunctions \nthat produce a new source from a given view without having access to an original source, and whether \nit is possible to meaningfully augment b. , and its two variants, with additional parameters that steer \nits choice of a backward component. The latter may be useful, for example, when an update changes the \nshape of a view, causing the current regime to report failure. A somewhat secondary concern is that about \nthe ef.ciency of the obtained put-(and potentially create-) functions. Clearly, a purely semantic approach \nlike ours here cannot in general hope to produce as ef.cient backward components as a more syntac\u00adtic, \nbut also more restricted, approach might achieve. After all, de\u00adtached from the realm of syntax, no intensional \nknowledge about the get-function s underlying algorithm can be gained and thus used. But this does not \nimpair the prototyping scenario sketched above. And dumping premature optimization, the safety and pro\u00adgrammer \n(rather than program) productivity boon offered by free bidirectionalization may often be more essential \nin practice than ef.ciency differences that may only show up at rather large scales of data. That said, \nthere is room for improving the ef.ciency of put\u00adfunctions as obtained by our technique. For one thing, \nthe variations of integer maps used are currently implemented rather naively. Some data structure and \nalgorithm engineering would likely have a bene.cial impact here. Also, even though our bidirectionalizers \nare, by design, ignorant of the de.nition of the get-function provided as argument, nothing stops us, \nor a compiler, from inlining that function de.nition in a particular application like b. get for a concrete \nget-function. Then, the door is open to applying any of the program specialization and fusion methods \nthat abound in the .eld of functional languages. In combination with rules about the integer map interface \nfunctions, it might even be possible in some cases to thus transform the automatically obtained put-functions \ninto ones with ef.ciency close to hand-coded versions. And yet, just how bad is the current performance? \nTo evaluate this, we have run a few simple experiments on a 2.2 GHz AMD Opteron 248 processor (core) \nwith 2GB memory. Every experiment consists of comparing the ef.ciency of one of the hand-coded put-functions \nfrom the introduction to that of the corresponding automatically obtained version, on input data structures \nof varying sizes and with views that actually represent permitted updates. The elements contained in \nsource and view data structures are integers, so that each equality test on them takes constant time \nonly. To make asymptotic behavior more apparent, runtimes are plotted normalized through division by \ninput size. The results can be seen in Figures 4 7. Figure 4. Evaluation of put1 vs. b. halve. Figure \n5. Evaluation of put2 vs. b. .atten, on nasty input. Figure 6. Evaluation of put2 vs. b. .atten, on \nnice input. Figure 7. Evaluation of put3 vs. b.Eq rmdups. Acknowledgments I thank Edward A. Kmett and \nStuart Cook for additions to their Hackage packages category-extras-0.53.5 and bimap-0.2.3 that made \nreuse easier for me. I thank Joachim Breitner for his work on the automatic deriver for Zippable instances, \nthe implementa\u00adtion of the online tool, his assistance with ef.ciency measurements, and general release \nsupport. Finally, I thank the reviewers for their enthusiasm about the paper. I am sorry that I could \nnot realize all their suggestions for addressing remaining shortcomings in the presentation. References \nM. Abbott, T. Altenkirch, and N. Ghani. Categories of containers. In Foun\u00addations of Software Science \nand Computational Structures, Proceedings, volume 2620 of LNCS, pages 23 38. Springer-Verlag, 2003. F. \nBancilhon and N. Spyratos. Update semantics of relational views. ACM Transactions on Database Systems, \n6(3):557 575, 1981. A. Bohannon, B.C. Pierce, and J.A. Vaughan. Relational lenses: A language for updatable \nviews. In Principles of Database Systems, Proceedings, pages 338 347. ACM Press, 2006. A. Bohannon, J.N. \nFoster, B.C. Pierce, A. Pilkiewicz, and A. Schmitt. Boomerang: Resourceful lenses for string data. In \nPrinciples of Pro\u00adgramming Languages, Proceedings, pages 407 419. ACM Press, 2008. N.A. Danielsson, R.J.M. \nHughes, P. Jansson, and J. Gibbons. Fast and loose reasoning is morally correct. In Principles of Programming \nLanguages, Proceedings, pages 206 217. ACM Press, 2006. P.F. Dietz and D.D. Sleator. Two algorithms for \nmaintaining order in a list. In Symposium on Theory of Computing, Proceedings, pages 365 372. ACM Press, \n1987. J.N. Foster, M.B. Greenwald, J.T. Moore, B.C. Pierce, and A. Schmitt. Combinators for bidirectional \ntree transformations: A linguistic ap\u00adproach to the view-update problem. ACM Transactions on Programming \nLanguages and Systems, 29(3):17, 2007. J.N. Foster, A. Pilkiewicz, and B.C. Pierce. Quotient lenses. \nIn Inter\u00adnational Conference on Functional Programming, Proceedings, pages 383 395. ACM Press, 2008. \n Z. Hu, S.-C. Mu, and M. Takeichi. A programmable editor for developing structured documents based on \nbidirectional transformations. In Partial Evaluation and Semantics-Based Program Manipulation, Proceedings, \npages 178 189. ACM Press, 2004. G. Hutton and D. Fulger. Reasoning about effects: Seeing the wood through \nthe trees. In Trends in Functional Programming, Draft Proceedings, 2008. P. Johann and J. Voigtl\u00a8ander. \nFree theorems in the presence of seq. In Prin\u00adciples of Programming Languages, Proceedings, pages 99 \n110. ACM Press, 2004. K. Matsuda, Z. Hu, K. Nakano, M. Hamana, and M. Takeichi. Bidirection\u00adalization \ntransformation based on automatic derivation of view comple\u00adment functions. In International Conference \non Functional Program\u00adming, Proceedings, pages 47 58. ACM Press, 2007. C. McBride and R. Paterson. Applicative \nprogramming with effects. Jour\u00adnal of Functional Programming, 18(1):1 13, 2008. A. Pettorossi. Derivation \nof programs which traverse their input data only once. In Advanced School on Programming Methodologies, \nProceed\u00adings, pages 165 184. Academic Press, 1987.  J.C. Reynolds. Types, abstraction and parametric \npolymorphism. In Infor\u00admation Processing, Proceedings, pages 513 523. Elsevier, 1983. C. Strachey. Fundamental \nconcepts in programming languages. In Interna\u00adtional Summer School in Computer Programming, Lecture Notes, \n1967. Reprint appeared in Higher-Order and Symbolic Computation, 13(1 2): 11 49, 2000. J. Voigtl\u00a8ander. \nAsymptotic improvement of computations over free monads. In Mathematics of Program Construction, Proceedings, \nvolume 5133 of LNCS, pages 388 403. Springer-Verlag, 2008.  P. Wadler. Theorems for free! In Functional \nProgramming Languages and Computer Architecture, Proceedings, pages 347 359. ACM Press, 1989. P. Wadler. \nThe essence of functional programming (Invited talk). In Principles of Programming Languages, Proceedings, \npages 1 14. ACM Press, 1992. A. Proof of Theorem 2 Let get :: .a.[a] . [a], let t be a type that is \nan instance of Eq, and let v, s :: [t ]. If b. get sv is de.ned, then we necessarily have ' (and the \nvalues of s and g are unimportant in what follows). Thus, b. get s v = map f s , where Right h = assoc \n(get s ' ) v (7) h ' = IntMap.union h g (8) f = fromJust . .ip IntMap.lookup h ' (9) ' by the free theorem \nmentioned in the proof of Theorem 1, get (b. get sv) = map f (get s ' ) . (10) By (7) and Lemma 2 we \nhave map (.ip IntMap.lookup h)(get s ' ) == map Just v . (11) In particular, for every i in get s ', \nwe have IntMap.lookup ih = Just b for some b :: t. But then by (8) and the speci.cations of IntMap.union \nand IntMap.lookup, map (.ip IntMap.lookup h ' )(get s ' ) = map (.ip IntMap.lookup h)(get s ' ) . Together \nwith (9), the well-known anti-fusion law map (f1 .f2) = map f1 . map f2, and (11), this implies map f \n(get s ' ) == map fromJust (map Just v) , which gives get (b. get sv) == v by (10). B. Proof of Theorem \n3 Let get :: .a. Eq a . [a] . [a], let t be a type that is an instance of Eq, and let s :: [t]. By the \nfunction de.nition for b.Eq we have b.Eq get s (get s) = (12) seq h ' (map (fromJust . .ip IntMapEq.lookup \nh ' ) s ' ) , where: (s ' ,g) = templateEq s (13) h = either error id (assocEq (get s ' )(get s)) (14) \nh ' = either error id (IntMapEq.union hg) . (15) By (13) and Lemma 3, we have map (.ip IntMapEq.lookup \ng) s ' == map Just s , (16) as well as that for every i :: Int not in s ' , IntMapEq.lookup ig = Nothing \n, and that  .ip IntMapEq.lookup g is injective on s ' .  Consequently, setting f = fromJust . .ip IntMapEq.lookup \ng , (17) we have map fs ' == s (18) and that f is injective on s '. By Lemma 6, this gives map f (get \ns ' ) == get s and that every i in get s ' is also in s '. Together with (14) and Lemma 4, we can conclude \nthat h is de.ned and that for every i :: Int, IntMapEq.lookup ih == if elem i (get s ' ) then Just (fi) \nelse Nothing . On the other hand, we have by (16), (17), and the fact (derived above) that for every \ni :: Int not in s ' , IntMapEq.lookup ig = Nothing , that for every i :: Int, IntMapEq.lookup ig = if \nelem is ' then Just (fi) else Nothing . Hence, by (15), the injectivity of .ip IntMapEq.lookup g on s \n' (derived above), the fact (also derived above) that every i in get s ' is also in s ', and the speci.cation \nof IntMapEq.union, we have that h ' is de.ned and that for every i in s ' , IntMapEq.lookup ih ' == Just \n(fi) . Together with (12) and (18), this gives b.Eq get s (get s) == s . C. Proof of Theorem 4 Let get \n:: .a. Eq a . [a] . [a], let t be a type that is an instance of Eq, and let v, s :: [t]. If b.Eq get \nsv is de.ned, then we necessarily have b.Eq get sv = map fs ' , (19) where (s ' ,g) = templateEq s (20) \nRight h = assocEq (get s ' ) v (21) Right h ' = IntMapEq.union hg (22) f = fromJust . .ip IntMapEq.lookup \nh ' . (23) By (20) and Lemma 3 we have that for every i in s ', it holds IntMapEq.lookup ig = Just a \nfor some a :: t . Moreover, by (21) and Lemma 5 we have map (.ip IntMapEq.lookup h)(get s ' ) == map \nJust v , (24) as well as that for every i :: Int not in get s ' , IntMapEq.lookup ih = Nothing , and \nthat  .ip IntMapEq.lookup h is injective on get s ' .  Putting all these facts together with (22), \nthe speci.cation of IntMapEq.union, and (23), we get that f is injective on s '. Thus, by (19) and Lemma \n6, get (b.Eq get sv) == map f (get s ' ) . (25) The remainder of the proof is analogous to the second \nhalf of that for Theorem 2 in Appendix A, where now (22) (25) take the roles of (8) (11). \n\t\t\t", "proc_id": "1480881", "abstract": "<p>A bidirectional transformation consists of a function get that takes a source (document or value) to a view and a function put that takes an updated view and the original source back to an updated source, governed by certain consistency conditions relating the two functions. Both the database and programming language communities have studied techniques that essentially allow a user to specify only one of get and put and have the other inferred automatically. All approaches so far to this bidirectionalization task have been syntactic in nature, either proposing a domain-specific language with limited expressiveness but built-in (and composable) backward components, or restricting get to a simple syntactic form from which some algorithm can synthesize an appropriate definition for put. Here we present a semantic approach instead. The idea is to take a general-purpose language, Haskell, and write a higher-order function that takes (polymorphic) get-functions as arguments and returns appropriate put-functions. All this on the level of semantic values, without being willing, or even able, to inspect the definition of get, and thus liberated from syntactic restraints. Our solution is inspired by relational parametricity and uses free theorems for proving the consistency conditions. It works beautifully.</p>", "authors": [{"name": "Janis Voigtl&#228;nder", "author_profile_id": "81100011863", "affiliation": "Technische Universit&#228;t Dresden, 01062 Dresden, Germany", "person_id": "P1300962", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1480881.1480904", "year": "2009", "article_id": "1480904", "conference": "POPL", "title": "Bidirectionalization for free! (Pearl)", "url": "http://dl.acm.org/citation.cfm?id=1480904"}