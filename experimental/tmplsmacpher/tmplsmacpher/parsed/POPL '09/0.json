{"article_publication_date": "01-21-2009", "fulltext": "\n Language Constructs for Transactional Memory TimHarris MicrosoftResearch tharris@microsoft.com Abstract \nBuilding concurrent shared-memory data structures is a notori\u00adously dif.cult problem, and so the widespread \nmove to multi-core and multi-processor hardware has led to increasing interest in lan\u00adguage constructs \nthat may make concurrent programming easier. One technique that has been studied widely is the use of \natomic blocks[3]built over transactional memory(TM)[2]: theprogram\u00admer marks a section of code as atomic, \nand the language imple\u00admentation speculatively executesit using transactions[1].Transac\u00adtions can run \ninparallel solong as they access differentdata. In this talk I ll introduce some of the challenges that \nI ve seen in building robust implementations of this idea. What are the lan\u00adguage design choices that \nexist? What language features can be used inside atomic blocks, and where can atomic blocks oc\u00adcur? Which \nuses of atomic blocks should be considered correct, and which uses should be considered racy ? What are \nthe likely impacts of different design choices on performance? What are the impacts on .exibility for \nthe language implementer, and what are theimpactson .exibilitytotheprogrammerusingtheseconstructs? I \nll argue that one way of trying to resolve these questions is to be rigorous about keeping the ideas \nof atomic blocks and TM separate; in practice they ve often been con.ated (not least in languages that \nI ve worked on). I ll argue that, when thinking about atomic blocks, we should keep a wide range of possible \nimplementations in mind (for example, TM, lock inference, or simply control over pre-emption). Similarly, \nwhen thinking about TM, we should recognize that it can be exposed to programmers through a wide range \nof abstractions and language constructs. Acknowledgements Thistalkisbased onjoint work with colleagues \natMicrosoftRe\u00adsearch, theMicrosoft ParallelComputing Platformgroup, theUni\u00adversity of Cambridge Computer \nLaboratory, and the Microsoft / BarcelonaSupercomputing CenterJointResearchCenter. Categories and Subject \nDescriptors D.1.3[Programming Tech\u00adniques]:Concurrent Programming Parallelprogramming General Terms Algorithms,Languages, \nPerformance Keywords Transactional Memory, STM,AtomicBlocks References [1] Tim Harris and Keir Fraser. \nLanguage support for lightweight transactions. In OOPSLA 03: Proc. 18th Annual ACM SIGPLAN Conference \non Object-Oriented Programming, Systems, Languages, and Applications, pages 388 402, 2003. [2] Maurice \nHerlihy and J. Eliot B. Moss. Transactional memory: Architectural support for lock-free data structures. \nIn ISCA 93: Proc. 20th Annual International Symposium on Computer Architecture, pages 289 301.1993. [3] \nDavid B. Lomet. Process structuring, synchronization, and recovery using atomic actions. In Proceedings \nof an ACM conference on Language design for reliable software,pages 128 137, 1977. Copyright isheldby \nthe author/owner(s). POPL 09, January18 24,2009,Savannah,Georgia,USA. ACM978-1-60558-379-2/09/01.  \n\t\t\t", "proc_id": "1480881", "abstract": "<p>Building concurrent shared-memory data structures is a notoriously difficult problem, and so the widespread move to multi-core and multi-processor hardware has led to increasing interest in language constructs that may make concurrent programming easier. One technique that has been studied widely is the use of atomic blocks built over transactional memory (TM): the programmer marks a section of code as atomic, and the language implementation speculatively executes it using transactions. Transactions can run in parallel so long as they access different data.</p> <p>In this talk I'll introduce some of the challenges that I've seen in building robust implementations of this idea. What are the language design choices that exist? What language features can be used inside atomic blocks, and where can atomic blocks occur? Which uses of atomic blocks should be considered correct, and which uses should be considered \"racy\"? What are the likely impacts of different design choices on performance? What are the impacts on flexibility for the language implementer, and what are the impacts on flexibility to the programmer using these constructs?</p> <p>I'll argue that one way of trying to resolve these questions is to be rigorous about keeping the ideas of atomic blocks and TM separate; in practice they've often been conflated (not least in languages that I've worked on). I'll argue that, when thinking about atomic blocks, we should keep a wide range of possible implementations in mind (for example, TM, lock inference, or simply control over pre-emption). Similarly, when thinking about TM, we should recognize that it can be exposed to programmers through a wide range of abstractions and language constructs.</p>", "authors": [{"name": "Tim Harris", "author_profile_id": "81406593835", "affiliation": "Microsoft Research, Cambridge, United Kingdom", "person_id": "P1300960", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1480881.1480883", "year": "2009", "article_id": "1480883", "conference": "POPL", "title": "Language constructs for transactional memory", "url": "http://dl.acm.org/citation.cfm?id=1480883"}