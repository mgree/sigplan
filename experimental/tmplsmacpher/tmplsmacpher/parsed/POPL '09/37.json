{"article_publication_date": "01-21-2009", "fulltext": "\n Verifying Distributed Systems: the Operational Approach Thomas Ridge University of Cambridge thomas.ridge@cl.cam.ac.uk \nAbstract This work develops an integrated approach to the veri.cation of behaviourally rich programs, \nfounded directly on operational se\u00admantics. The power of the approach is demonstrated with a state\u00adof-the-art \nveri.cation of a core piece of distributed infrastructure, involving networking, a .lesystem, and concurrent \nOCaml code. The formalization is in higher-order logic and proof support is pro\u00advided by the HOL4 theorem \nprover. Dif.cult veri.cation problems demand a wide range of tech\u00adniques. Here these include ground and \nsymbolic evaluation, local reasoning, separation, invariants, Hoare-style assertional reason\u00ading, rely/guarantee, \ninductive reasoning about protocol correctness, multiple re.nement, and linearizability. While each of \nthese tech\u00adniques is useful in isolation, they are even more so in combination. The .rst contribution \nof this paper is to present the operational ap\u00adproach and describe how existing techniques, including \nall those mentioned above, may be cleanly and precisely integrated in this setting. The second contribution \nis to show how to combine veri.ca\u00adtions of individual library functions with arbitrary and unknown user \ncode in a compositional manner, focusing on the problems of private state and encapsulation. The third \ncontribution is the example veri.cation itself. The infrastructure must behave correctly under arbitrary \npatterns of host and network failure, whilst for performance reasons the code also includes data races \non shared state. Both features make the veri.cation particularly challenging. Categories and Subject \nDescriptors D.1.3 [Concurrent Pro\u00adgramming]: Distributed programming; F.3.1 [Specifying and Ver\u00adifying \nand Reasoning about Programs] General Terms Performance, reliability, theory, veri.cation. Keywords Distributed, \ninfrastructure, persistent queue, opera\u00adtional semantics, HOL, OCaml, network protocol, ground and symbolic \nevaluation, local reasoning, separation, invariants, Hoare\u00adstyle assertions, rely/guarantee, inductive \nreasoning, re.nement, linearizability. 1. Introduction The veri.ed computing stack is gradually becoming \na reality. At the bottom of the stack, (partial) processor veri.cation is routine. Permission to make \ndigital or hard copies of all or part of this work for personal or classroom use is granted without fee \nprovided that copies are not made or distributed for pro.t or commercial advantage and that copies bear \nthis notice and the full citation on the .rst page. To copy otherwise, to republish, to post on servers \nor to redistribute to lists, requires prior speci.c permission and/or a fee. POPL 09, January 18 24, \n2009, Savannah, Georgia, USA. Copyright c &#38;#169; 2009 ACM 978-1-60558-379-2/09/01. . . $5.00. Higher \nup, veri.ed operating systems and compilers are emerging. However, at the top of the stack, there is \na huge gap between ab\u00adstract mathematical models of programs and implementations in real code. Distributed \ninfrastructure exempli.es this gap. The ide\u00adalised models of distributed components may be reasonably \nclean, but implementations, forced to contend with failing hosts, failing network connections etc, while \nretaining good performance, are of\u00adten signi.cantly more complex. Formal techniques are rarely capa\u00adble \nof addressing the full complexity of such implementations. This paper describes the successful application \nof operational methods to mechanically verify a core piece of distributed infrastructure. This sets a \nnew high-water-mark for the veri.cation of executable code in a behaviourally rich language and environment, \ndemon\u00adstrating that such veri.cation is feasible. At the same time it es\u00adtablishes a challenge to make \nsuch proofs more automatic, and to develop veri.cation techniques that can address even richer pro\u00adgrams. \nThe distributed infrastructure in question is a persistent message queue [29]. Persistent message queues \nprovide reliable message delivery in the presence of host and network failure. As such, they are a core \npiece of enterprise computing infrastructure and are widely deployed in many large companies. They are \nincluded in several enterprise application stacks, such as J2EE [8], and marketed by competing vendors \nsuch as TIBCO and IBM. The implementation discussed here was written by the author to exhibit many of \nthe issues that would be expected in a produc\u00adtion implementation, albeit on a somewhat smaller scale. \nIts perfor\u00admance is reasonably good and competitive with other implementa\u00adtions. Excerpts from the code \nare given in Section 2. To verify such code, one needs a formal model of the system. This includes a \nmodel of the implementation language or languages (in this case OCaml), a model of a live host (in this \ncase including mutexes, condition variables, the store, network connections, and the .lesystem), and \na model of the network, including hosts which may crash and network connections which may fail. Section \n3 describes these models. In this work, all models are expressed using operational semantics, as popularized \nby Plotkin [24, 23]. The models build on much previous work, both formal and informal, including the \nmodel of OCaml in higher-order logic by Owens [18]; the very detailed model of TCP/IP, also in higher-order \nlogic, by the NetSem team (which includes the current author) [2, 3, 27]; a previous operational veri.cation \nof OCaml code by the author [26]; and POSIX manuals and OpenGroup speci.cations [1]. A key choice was \nto model the code directly, as a program in an executable programming language equipped with an operational \nsemantics, instead of some idealised state-machine or algorithm. Thus, the executable code is veri.ed, \nsubject only to the assump\u00adtions that the compiler is correct with respect to the operational semantics, \nand that the models of the .lesystem, host and network are accurate. Section 4 contains a brief overview \nof the veri.cation, which sets the scene for the later sections. The veri.cation involves rea\u00adsoning \ndirectly about the operational semantics, rather than the more usual approach via a program logic, primarily \nfor the prag\u00admatic reason that operational reasoning can support all the tech\u00adniques that were needed \nfor the veri.cation. The overhead of using these techniques is very low: one can omit the separate de.nition \nof a program logic and the accompanying soundness proof and in\u00adstead work within the .exible environment \nof higher-order logic. Moreover, the uniform foundation allows these techniques to be in\u00adtegrated together \ncleanly, as described later. In Section 5 the speci.cation of the persistent queue is pre\u00ad sented. This \nspeci.cation is further re.ned in Section 6. The queue is not a whole program that runs in its own process, \nbut a concur\u00adrent library intended for use by user applications. The infrastruc\u00adture must perform correctly \nwhatever actions the user application performs. The speci.cation therefore needs to address library cor\u00adrectness \nin arbitrary context, which is a form of compositionality. The infrastructure is distributed, so the \nspeci.cation needs to de\u00adtail what happens when other hosts crash or the network fails. The speci.cation \ncrucially also needs to support proofs of correctness of user applications which use the library, since \nthis is one of the main purposes of a speci.cation. The speci.cation establishes complex properties far \nremoved from simple generic safety properties such as memory safety. To prove that the implementation \nmeets the speci.cation in\u00advolves several existing techniques, which need to be integrated and used in \ncombination. In Section 7 I recall these existing techniques, show how they are expressed formally in \nan operational setting (as lemmas and proof idioms about the operational semantics rather than as proof \nrules in some program logic), and most importantly show how they are integrated together to provide strong \nsupport for veri.cation. In Section 8 a particularly interesting part of the correctness proof involving \ndata races on shared state is discussed. In Section 9 several new techniques are developed, which cap\u00ad \nture intuitive notions of privacy and encapsulation. These are used when reasoning about the composition \nof the queue library code (which involves private state shared between several library func\u00adtions) and \narbitrary user code. These notions are simple and gen\u00aderal: several of the main lemmas are applicable \nto arbitrary OCaml code, and can therefore be reused in future veri.cations. The veri.cations of the \nqueue API methods are independent of each other, and these veri.cations are composed with a veri.cation \nof arbitrary user code to give a correctness proof for the whole system. This process of composition \nis described in Section 10. References to related work are included in the body of the paper, and further \nreferences appear in Section 11. Finally I evaluate what has been achieved, draw conclusions, and look \nto the future in Section 12. Reasoning directly about the operational semantics is only fea\u00adsible with \nmachine assistance. Most of the arguments described in this paper, including the re.nement of the abstract \nqueue to the alternating bit protocol, the veri.cation of the individual OCaml functions, and the veri.cation \nof the privacy metatheory, have been mechanized in HOL4. The part of the proof that deals with host and \nnetwork failure at the implementation level has so far not been been mechanized, although these behaviours \nare dealt with at the intermediate level of the alternating bit protocol.  2. Implementation code The \nqueue is written in OCaml and makes use of the OCaml Unix and Thread libraries. The signature for the \nqueue is given in Fig. 1, the code shared between sender and receiver in Fig. 2, and the code for the \nsender in Fig. 3. The code for the receiver is similar to that for the sender and so is omitted. type \nfilename = string type ip = Unix.inet_addr type port = int type quad = ip*port*ip*port type rqueue = \n... type squeue = ... val listen : quad . filename . rqueue val available : rqueue . bool val peek : \nrqueue . string val remove : rqueue . unit val connect : quad . filename . squeue val send : squeue . \nstring . unit Figure 1. Queue signature (OCaml) type queue = {(* shared state *) lock : Mutex.t ; cond \n: Condition.t ; msgs : (string list) ref ; (* active thread local state *) b : bool ref ; fd : Message.conn \noption ref ; (* constant *) quad : quad ; fn : string ; } let mk_queue quad fn is_sender = {lock = Mutex.create \n() ; cond = Condition.create () ; msgs = ref [] ; b = ref is_sender ; fd =refNone; quad = quad ; fn =fn \n; } in let init q = let _ = Mutex.lock q.lock in let _= try let ( b :: msgs ) = File.read q.fn in let \n_ = q.b := bool_of_string b in let _ = q.msgs := msgs in () with _ . () in let _ = Mutex.unlock q.lock \nin () in let save q = let b = string_of_bool ( ! ( q.b ) ) in try File.write q.fn ( b :: ( ! ( q.msgs \n) ) ) ; None with | File.Exception . Some File.Exception in ... Figure 2. Queue shared sender/receiver \ncode (OCaml) The queue endpoints communicate over TCP/IP, using a proto\u00adcol based on the alternating \nbit protocol, and log their state to per\u00adsistent store. To abstract slightly from the details of TCP/IP \nand the .lesystem, we use two libraries for messaging (Message)and .le access (File). The messaging library \nallows communication us\u00ading strings rather than a byte stream. The .le library allows atomic .le update \nby .rst writing to a temporary .le and then renaming to the real target (POSIX-compliant .lesystems provide \natomic .le rename). Although small, these libraries are written above rather complex APIs, so that their \ncorrectness is far from obvious. Ideally they should also be veri.ed, but in this work their correctness \nis assumed. let private_send q = let _ = Mutex.lock q.lock in let _= while ! ( q.msgs ) = [] do Condition.wait \nq.cond q.lock done in let _ = Mutex.unlock q.lock in let msgs = [ string_of_bool ( ! ( q.b ) ) ; List.hd \n( ! ( q.msgs ) ) ] in let _ = Message.send ( dest_Some ( ! ( q.fd ) ) ) msgs in () in  let private_recv \nq = let msg = List.hd ( Message.recv ( dest_Some ( ! ( q.fd ) ) ) ) in if ! ( q.b ) = bool_of_string \nmsg then ( let _ = Mutex.lock q.lock in let _ = q.msgs := List.tl ( ! ( q.msgs ) ) in let _ = q.b := \nnot ( ! ( q.b ) ) in let e = save q in let _ = Mutex.unlock q.lock in maybe_raise e ) else () in let \nsender q = while true do try q.fd := Some ( Message.connect q.quad ) ; while true do private_send q ; \nprivate_recv q done with | Message.Exception . ( match ! ( q.fd ) with | None . () | Some fd . ( Message.close_noerr \nfd ; q.fd := None ) ) |e . ( raise e) done in let _connect quad fn = let q = mk_queue quad fn true in \nlet _ = init q in let _ = Thread.create sender q in q in let _send q s = let _ = Mutex.lock q.lock in \nlet _ = q.msgs := ( ( ! ( q.msgs ) ) @ [ s ] ) in let e = save q in let _ = Mutex.unlock q.lock in let \n_ = Condition.broadcast q.cond in let _ = maybe_raise e in () in let connect quad fn = let q = _connect \nquad fn in _send q in let send q s = q s in ... Figure 3. Queue sender code (OCaml) A queue endpoint \nis created when the user calls listen or connect. In both cases, the user supplies a quad, identifying \nthe local and remote endpoint addresses, and the .lename of the log .le used to store persistent information \nabout the endpoint state. In the case of connect, a call is made to the auxiliary function connect, which \ncreates and initializes the queue and then starts up the active management thread which runs the sender \nfunction. The thread sits in an outer loop, initializing and reinitializing the TCP/IP connection to \nthe other endpoint, and then running an inner loop until an exception is raised. On each iteration of \nthe inner loop, the sender sends the .rst pending message to the other endpoint (private send) then waits \nfor the subsequent acknowledgement (private recv). a exp = Wrap of a | Var of var | Lam of (var # exp) \n| App of (exp # exp) | LetVal of (var # exp # exp) | ... expr = unit exp closure = Cl of expr#((var#closure)list) \nhole_or_clo = Hole | Clo of closure context = hole_or_clo exp framestack = context list Figure 4. Core \nOCaml datatypes (HOL) The queue is asynchronous: a call to connect may return a queue before any network \ncommunication has taken place, whilst a call to send affects only the local endpoint. The active management \nthread handles all communication with the other endpoint.  3. Formal models The correctness of the queue \nis a formal statement in higher-order logic. Before this statement can be constructed, the various parts \nof the system must be formally de.ned. At the heart of the model is an operational semantics for a pure \nOCaml expression. This is extended to a model of arbitrarily many individual threads exe\u00adcuting in the \ncontext of a host. Threads can create other threads dynamically. Threads share access to a store, mutexes \nand condi\u00adtion variables, a .lesystem, and a set of network connections. At the next level up, a network \nconsists of many hosts communicat\u00ading using messages sent over TCP/IP. To capture the transient na\u00adture \nof hosts and network connections, the model allows them to fail at any time, although host .lesystems \npersist. All code ex\u00adcerpts from now on are written in the HOL4 syntax of higher\u00adorder logic, which is \nsimilar to the syntax of OCaml. The pair type constructor is written #. Finite map update is written \nFUPDATE f (arg,result) or alternatively f |+ (arg,result). Records are written <| fld:=val; fld :=val \n|>. List append is writ\u00adten xs++ys. Logical negation is written as a tilde. OCaml expressions Previous \nwork by the author [26] used .at expressions, whereas here the operational semantics for OCaml is based \nclosely on the CEK machine [5], which uses closures and a framestack. The use of closures and a framestack \nintroduces more structure into the representation of program state, which is helpful for veri.cation. \nFor example, substitution instances of a function are easier to identify because, using a closure representation, \nthe body of the function remains constant. The fragment of OCaml that is modelled is suf.cient to express \nthe implementation code given previously. The most important omission is the OCaml module language. The \nHOL datatype for a core subset of OCaml expressions exp is given in Fig. 4. If we ignore the Wrap constructor, \nthis gives a standard .at datatype for expressions. The Wrap constructor is used to model closures, contexts, \nand framestacks. The reduction rules for a closure cl in a framestack fs are given in Fig. 5. A thread \nis a pair where the second component is a framestack, and the .rst component is either the currently \nexecuting closure or a blocking system call. System calls are the interface be\u00adtween threads and the \nrest of the host. System calls include those re\u00adlated to the store (eg SC Assign), locks and condition \nvariables (eg SC Mutex Lock), the .lesystem (eg SC File Write), and network reduce raise (cl,fs) = case \nfs of [] .NONE || f::fs .( case f of TryWith(Wrap(Hole),Wrap(Clo(cl2))) .( case push env cl of Raise(Wrap(cl)) \n. SOME(cl2,App(Wrap(Hole),Wrap(Clo cl))::fs) || .NONE) || .SOME(cl,fs)) reduce nonval (cl,fs) = let addfs \n= . (cl,f). (cl,f::fs) in let new cl fs push env cl = case push env cl of App (Wrap(cl1),Wrap(cl2)) . \nSOME(cl2, App(Wrap(Clo(cl1)),Wrap Hole)) || LetVal (x,Wrap(cl1),Wrap(cl2)) . SOME(cl1, LetVal(x,Wrap \nHole,Wrap(Clo(cl2)))) || While (Wrap(cl1),Wrap(cl2)) .( let cl = mk cl (LetVal(\" \",Var\"do\",Var\"while\")) \n[(\"do\",cl2);(\"while\",cl)] in SOME(cl1,IfThenElse(Wrap Hole,Wrap(Clo(cl )), Wrap(Clo unit)))) || ... in \n... reduce val (cl,fs) = ... reduce (cl,fs) = let e=cl toecl in if is Raise e then reduce raise (cl,fs) \nelse if isval e then reduce val (cl,fs) else reduce nonval (cl,fs) Figure 5. OCaml reduction (HOL) host \n= <| cs : (connectionid,connection)finite map; ts : (threadid,thread)finite map; s : store; m : (mutexid,threadid \noption)finite map; w : condition set; f : filesystem |>  Figure 6. Host type (HOL) communication (eg \nSC Listen). Finally the trans t function ties these components together to give the transitions for a \nthread. transtt= case (t:thread) of (T Run(cl),fs) .(case dest Call (cl to e cl,fs) of NONE .(OPTION \nMAP (. (cl,fs). (T Run(cl),fs)) (reduce (cl,fs))) || SOME(call,fs) .SOME(T Block(call),fs)) || (T Block(call),fs) \n.failwith NONE \"trans t\" The host In Fig. 6 the type host includes threads, a store, a set of mutexes \nand condition variables, a .lesystem, and a set of network connections. The behaviour of the host is \nalso de.ned using small\u00adstep operational semantics; an excerpt describing mutex transitions appears in \nFig. 7. The network A network consists of hosts communicating using TCP/IP. As mentioned previously, \nthe model assumes a thin mes\u00adsaging layer on top of TCP/IP that allows hosts to communicate us\u00ading strings \nrather than a byte stream. The transitions of the network consist of transitions of host threads, transitions \nwhere a connec\u00adtion on the host sends a message to the network, transitions where a message is received \nfrom the network, and transitions represent\u00ading host and connection failure. An excerpt is given in Fig. \n8.  4. Veri.cation overview In Section 5 an abstract model of a queue is de.ned. Informally the OCaml \nimplementation is said to be correct if it behaves in the trans mutex (h,tid,call) = case call of SC \nMutex Create .( let l = free (FDOM h.m) in let m = FUPDATE h.m (l,NONE) in [(h with <| m:=m |>, SC Ret(mk \ncon \"Mut\" l))]) || SC Lock(l) .( option case [] (. x. case x of NONE .( (* acquire the mutex *) let \nm = FUPDATE h.m (l,SOME tid) in [(h with <| m:=m |>, SC Ret unit)]) || SOME . (* mutex owned by another \nthead *) []) (FLOOKUP h.m l)) || SC Unlock(l) .( option case [] (. x. case x of (* mutex is not held \n*) NONE .[(h,SC Ret mutex exception)] (* mutex is held *) || SOME tid .( if tid = tid then (* we hold \nthe mutex, so unlock it *) let m = FUPDATE h.m (l,NONE) in [(h with <| m:=m |>, SC Ret unit)] else (* \nmutex owned by another thead *) [(h,SC Ret mutex exception)])) (FLOOKUP h.m l)) || .[] Figure 7. Host \nmutex transitions (HOL) msg trans ((quad:quad),(msg:msg)) (n:net) = let (i1,p1,i2,p2) = quad in let hid=i2 \nin let h1 = FLOOKUP n.hs hid in case h1 of NONE .{} || SOME(H Dead ) .{} || SOME(H Alive h) .( (* expected \nconnection state, given msg *) let st = case msg of SYN . LISTEN || SYNACK .SYN SENT || ACK . SYN RECV \n|| DATA .ESTABLISHED in (* relevant (connectionid,connection) pair *) let cidc = get cidc quad st h.cs \nin (* updated connection and new messages *) let g (cid,c) = let quad = rev quad quad in let (c ,msgs) \n= case msg of SYN . (c with <| st:=SYN RECV |>,[(quad ,SYNACK)]) || SYNACK . (c with <| st:=ESTABLISHED \n|>,[(quad ,ACK)]) || ACK . (c with <| st:=ESTABLISHED |>,[]) || DATA(ss) . (c with <| in :=(c.in ++[ss]) \n|>,[]) in ((cid,c ),msgs) in (* updated network *) option case {} (set eta o cmsgs in n n (hid,H Alive \nh) o g) cidc) Figure 8. Network transitions for messages received (HOL) same way as this abstract queue. \nFormally an abstraction function maps concrete implementation states to abstract queue states. Every \ntransition of the implementation must map, via the abstraction function, to a transition of the abstract \nqueue. The proof is factored into an abstraction function from the con\u00adcrete OCaml implementation to \nan intermediate speci.cation, and a further abstraction function from the intermediate speci.cation to \nthe abstract queue. The composition gives the single abstraction function we seek. In Section 6 this \nintermediate speci.cation is de\u00ad .ned. It captures the communication protocol used by the queue, which \nis a version of the alternating bit protocol (ABP). The func\u00adtion from the ABP to the abstract queue \nis also de.ned, but the standard proof that it is an abstraction function is omitted. The in\u00adteresting \npart of the veri.cation involves the abstraction function from the implementation to this intermediate \nspeci.cation. De.n\u00ading this function is straightforward because the states of the imple\u00admentation and \nthe ABP are closely related: the OCaml code is a direct implementation of the ABP. The main proof obligation \nis to check that this function is indeed an abstraction function. This is an invariant property, that \nis, a property of all reachable states. We examine all reachable states using symbolic evaluation. The \nreachable states are too complicated to use symbolic evaluation directly, so we use rely/guarantee to \nrephrase the transition system from the point of view of some arbitrary thread t. Whereas the original \nsystem used an interleaving model of concurrency, in this new system, steps of t alternate with steps \nof interference from other threads, the host, and the network. We are now in a position to execute through \na trace of the system from the point of view of a thread t. There are two possibilities for t. Either \nit is the active management thread, or it is some other user thread. If it is the active management thread, \nthe thread state is largely known, eg for the sender endpoint it is the function sender, with a symbolic \nvalue for the q parameter. In this case, we can execute the code, checking the reachable states as we \ngo. The other possibility is that t is a user thread. There are two further possibilities. Either the \nuser thread calls a queue API method, or it executes some arbitrary user code. For each queue API method, \nthe state of the thread t is again largely known: it is the code for the queue method itself. As before, \nwe execute the code, checking each state in turn. Veri.cation ends when the method returns to user code. \nFor a transition involving arbitrary user code, queue resources are private and inaccessible, so the \nstate of the queue is unchanged. 5. Abstract speci.cation The abstract queue is formed by concatenating \nthe pending mes\u00adsages at the sender endpoint (as recorded on the host .lesystem) to those at the receiver \nendpoint, taking care to avoid duplicate mes\u00adsages. The abstract speci.cation of a queue is straightforward. \nabstract queue trans xs xs = . msg msgs. (* msg appended to end *) ( (xs =msgs ) . (xs =msgs++[msg])) \n. (* msg removed from front *) ( (xs =[msg]++msgs) . (xs = msgs)) How is this a useful speci.cation? \nIn the simplest scenario, user code establishes a send queue and sends a message msg to the receiver \nendpoint. During the execution of send,the msg is written to the log .le on the sender endpoint. The \nchange to the sender s .lesystem translates, via the abstraction function, to a change in the abstract \nqueue, so that the abstract queue now contains msg. On the receiver endpoint, user code establishes the \ncorresponding receive queue and then peeks at the contents. If peek returns, it is because the head of \nthe pending messages on the receiver endpoint was non-empty. The head of the pending messages corresponds, \nvia the abstraction function, to the head of the abstract queue. Since the front of the abstract queue \nis the message msg,the peek must return msg. This reasoning is completely independent of the abp host \n= <| b:bool; ss:string list |> abpnet = <| s : abp host; msgs : (bool#string) list;  r : abp host; \n acks : bool list |> abp trans sender n n = . n0 s0 b s ss acks msgs. (* a user thread makes a send call \ntransition *) ((n =n0 with <| s:=s0 with <| ss:=ss |> |>) . (n =n0 with <| s:=s0 with <| ss:=(ss++[s]) \n|> |>)) . (* a msg moves to the network *) ((n =n0 with <| s:=s0 with <| b:=b; ss:=(s::ss) |>; msgs:=msgs \n|>) . (n =n0 with <| s:=s0 with <| b:=b; ss:=(s::ss) |>; msgs:=(msgs++[(b,s)]) |>)) . (* an ack for \nprevious msg is received *) ((n =n0 with <| s:=s0 with <| b:=b |>; acks:=( b::acks) |>) . (n =n0 with \n <| s:=s0 with <| b:=b |>; acks:= acks |>)) . (* an ack for current msg is received *) ((n =n0 with \n<| s:=s0 with <| b:= b; ss:= ss |>; acks:=(b::acks) |>) . (n =n0 with <| s:=s0 with <| b:= b; ss:=TL \nss |>; acks:=( acks) |>)) abp trans receiver n n = ... abp trans n n = . n0 xs ys zs. abp trans sender \nn n . abp trans receiver n n . (* host or connection failure, transient messages lost *) ( (n = n0 with \n<| msgs:=(xs++ys++zs) |>) . (n = n0 with <| msgs:=(xs++zs) |>)) Figure 9. Alternating bit protocol (HOL) \ninternal functioning of the queue, including the details of how the message makes its way from the sender \nendpoint to the receiver endpoint. 6. The alternating bit protocol The queue endpoints use a version \nof the alternating bit protocol (ABP) to communicate. The ABP is described in [13]. The proto\u00ad col can \nbe veri.ed independently of the implementation, so we in\u00adtroduce an intermediate system between the abstract \nspeci.cation and the concrete implementation which captures the ABP. This sys\u00adtem is de.ned in Fig. 9. \nThe relationship between the ABP and the abstract queue is expressed as an abstraction function. abp \nto abstract queue n = n.r.ss++(if n.s.b=n.r.b then TL n.s.ss else n.s.ss) The abstraction function takes \nthe pending messages at the receiver, n.r.ss, and appends the pending messages at the sender, n.s.ss \nto form the abstract queue. If the b values at the endpoints are equal, then the message at the head \nof the sender s queue has already been accepted onto the receiver s queue, and as a result the message \nis omitted when forming the abstract queue. The proof that this abstraction function respects transitions \nuses inductive reasoning to establish protocol correctness, in the style of Paulson [20]. Because it \nis a well understood technique, the details of the proof are omitted, and inductive reasoning about protocol \ncorrectness is not discussed further. How does the ABP relate to the OCaml implementation? The endpoint \nstate in the ABP, b and ss, corresponds to the endpoint state in the implementation, b and msgs, as recorded \non the host .lesystem. The msgs and acks at the ABP level correspond to transient messages, on the network, \nin connection objects on hosts, and even in the active management threads before pending changes to state \nhave been logged to disk. Thus, a connection failure may result in messages being lost from the network, \nbut messages in the connection object on the receiving host, and in the active thread, remain. Similarly, \na single endpoint failure still leaves messages on the network and on the other endpoint that can be \nreceived by that endpoint s active thread. For space reasons, details of the abstraction function abstract \nfrom the implementation to the ABP model are omitted. The main property we want to prove is that transitions \nof the OCaml implementation, when mapped by the abstraction function, are respected by the ABP. Formally \nwe have the invariant inv main below. This invariant is parameterized by nps, which records infor\u00admation \nsuch as the quad for the queue that we are interested in. Where this invariant is used, the state n is \na successor of n. invmain nps n n = let trns = RC abp trans in (* reflexive closure *) let abstrct = \nabstract nps in trns (abstrct n) (abstrct n ) This invariant is further decomposed into several invariants \ncov\u00adering common situations. For example, the case where a thread on the sender endpoint takes a step \nis dealt with by the following in\u00advariant. The parameter ps records information about the endpoint. For \nexample, ps.tid is the thread id of the active management thread. inv main sender ps h h = let trns = \nRC abp trans sender in (* reflexive closure *) let abstrct = abstract sender to abp net ps in trns (abstrct \nh) (abstrct h ) 7. Proof techniques and their integration This section describes several existing proof \ntechniques, how they were used in the veri.cation, and how they were integrated together on top of the \noperational foundation. Basic setup At the heart of the operational approach to veri.ca\u00adtion is symbolic \nevaluation. Program execution deals with ground terms. Symbolic evaluation deals with parametric terms, \nwhere subterms are replaced by variables (logical, not program). While ground evaluation can enumerate \nthe reachable states of a particu\u00adlar instance of a program, such as fact 5, symbolic evaluation can \ndeal with the reachable states of all possible instances of a program, such as fact n. Symbolic execution \ncan be automated fairly easily (although the current implementation in HOL4 is rather slow). This affects \nthe structure of proofs: rather than describe the behaviour of a func\u00adtion in a way that echoes the operational \nsemantics, we can simply execute the function. For example, consider an increment func\u00adtion that takes \na mutable variable and increments its value by one. The behaviour of increment as given by the operational \nseman\u00adtics cannot be abstracted in any meaningful way. Such functions are handled directly rather than \nby separating out their properties as a lemma. In the case of the queue, the functions mk queue, init \nand save are like this. The queue code is structured into functions, some of which are part of the queue \nAPI, and some of which are internal to the queue itself. It is natural to structure the proof similarly, \nand so the bulk of the veri.cation consists of separate lemmas, with each lemma corresponding to a particular \nfunction in the code. This makes the proof modular, and, since the veri.cation of each function is independent \nof the others, one can hope that the effort scales with the number of functions. Each function is veri.ed \nby symbolically executing it. Global invariants are assumed to hold initially, and veri.cation must es\u00adtablish \nthat they hold at successor states. The operational semantics uses an interleaving model of concurrency, \nand other threads may interfere with the thread executing the function. Rely/guarantee style reasoning \ncan be used to rephrase the transition systems so that every step of the thread executing the function \nis followed by a single rely step which represents interference from other threads. The cost of this \ntransformation is that the corresponding guaran\u00adtee of the thread in question must be show to hold at \neach step. Symbolic execution Symbolic execution is used to explore the set of reachable states. A reachable \nstate lies at the end of a .nite se\u00adquence, or trace, whose head is a start state, and whose consecu\u00adtive \nstates are related by the transitions of the system. Symbolic execution works with such traces p,where \npn is a symbolic repre\u00adsentation of the system at step n. It is important to note that these symbolic \nstates are characterized by arbitrary HOL formulae. Each of the positions in the trace is dealt with \nin turn, using information about pn to derive pn+1. If the system is non-deterministic, ie there is more \nthat one successor state, then there is a corresponding branch in the proof. In fact, a network involving \na queue is highly concurrent and non-deterministic, so rely/guarantee is used to mitigate this non\u00addeterminism: \nas mentioned previously, every step of a thread is followed by a step representing interference from \nother threads and the environment. Loops and recursion are handled using induction. Typically, traces \nare allowed to start in any state that may recur, and before symbolic execution commences, there is an \nouter induction on the length of the trace p. If a state recurs as the head of some suf.x p' of p, the \ninduction hypothesis is invoked to deduce that the invariant holds on the remainder p' of p. Auxiliary \nvariables and Hoare-style assertions History variables [15] are used to record facts about previous states. \nFor example, a proof might note the value of pm, which is later used when examining pm+n. At its simplest, \npm is used to determine pm+1. Since the whole trace is directly accessible at any point in the proof, \nprophecy variables can also be used freely: when examining pm one is free to case split on the value \nof pm+n. If, as is often the case, n is not known exactly, one can case split on the .rst n such that \nsome useful property P holds of pm+n. Prophecy variables are not used in this work, but history variables \nare used extensively. Hoare-style assertions [7] are used in a similar way to history variables. Rather \nthan record the exact value pm of a previous state, the assertion P (pm) is established, where P is some \npredicate of interest. This information is used at some later stage, typically to derive some further \nassertion P1(pm+1), which is itself used to derive P2(pm+2), and so on. In Section 8 there is an example \nof the use of history variables and Hoare-style assertions. Invariants Invariants are properties which \nhold of every reachable state. As an example, the following invariant describes how the state of the \nqueue in memory relates to the state of the queue as recorded on the host .lesystem. inv mem disk none \nps h = let q1 = mem queue of host ps h in let q2 = disk queue of host ps h in (h.m ps.lock = NONE) -. \n((q1.msgs,q1.b) = (q2.msgs,q2.b)) The variable ps.lock identi.es the queue lock. Given this, the invariant \nmay be paraphrased if the queue lock is not held, then the in-memory queue1 and the on-disk queue are \nthe same . Because the queue code contains data races, a further invariant is required to characterize \nthe relationship between the in-memory and on-disk representations when the lock is held by a user thread. \ninv mem disk some ps h = 1 Rather, the .elds msgs and b of the relevant queues. let q1 = mem queue of \nhost ps h in let q2 = disk queue of host ps h in . tid. tid IN FDOM h.ts . (tid = ps.tid) -. (h.m ps.lock \n= SOME tid) -. (q1.msgs = q2.msgs) . (. msg. q1.msgs = q2.msgs++[msg]) The other interesting invariant \nrelates to encapsulation and the contents of the store, and is described in Section 9. Further invari\u00ad \nants deal with wellformedness conditions. All host invariants are combined in a single invariant inv \nh. Rely/guarantee Rely/guarantee [9] is a core technique for reason\u00ad ing about concurrent systems. The \nstandard reference is Jones PhD thesis [9]. Jones helpfully maintains an annotated bibliography on rely/guarantee \nonline2. Given a particular thread of interest, the idea is to characterize the interference that may \nbe caused by other threads. As an example, the following rely condition describes how interference affects \nthe value of the in-memory list of pending mes\u00adsages at the sender endpoint. rly msgs non empty ps tid \nh h = let q = mem queue of host ps h in let q = mem queue of host ps h in (tid = ps.tid) -. (q.msgs \n= []) -. (q .msgs = []) . (HD q .msgs = HD q.msgs) A rely condition characterizes the interference \ncaused by a thread transition from a host h to a host h . This rely condition is parameterized by two \nvariables, ps and tid.The variable tid is the thread identi.er of the thread that may assume the rely \ncondition, while ps.tid identi.es the active management thread on the host. The condition tid = ps.tid \nimplies that this rely is trivial unless the thread identi.ed by tid is the active management thread. \nThe rely condition can therefore be paraphrased: If you are the active management thread, you may assume \nthat if msgs is non-empty and other threads take steps and so interfere with the system state, then msgs \nwill still be non-empty, and moreover the head of msgs will be preserved . If the queue correctly maintains \nthe privacy of its internal data structures, then this is obvious from the code: user threads on the \nsender endpoint can call the queue API function send to add messages to the end of msgs, but the active \nmanagement thread is the only one that can remove messages from the front of msgs. A rely condition should \nbe re.exive and transitive because it represents zero or more steps of interference. is rly gty rg = \nreflexive rg . transitive rg is_rly_gty (rly_msgs_non_empty ps tid) There is no need to state the guarantee \nconditions separately. A rely condition rly is parameterized by the thread identi.er tid.If the host \nstate is h, and other threads take steps causing the state to change to h , then thread tid can rely \non property rly tid hh . Conversely, when thread tid itself takes a step from state h causing the state \nto change to h , it must be sure to guarantee rly tid h h for all other threads tid . There is an example \nof this in the statement of send lemma below. Thus, if the thread identi.er is made explicit, then the \nrely and guarantee conditions become identical. This clari.es the often observed symmetry be\u00adtween rely/guarantee \nconditions. What is the bene.t of using rely/guarantee style reasoning? Usually a thread t executes in \nparallel with other threads. Instead of interleaving steps of other threads with those of t, one can \ninstead interleave steps of interference. If the interference is re.exive and transitive, then one can \nfollow each step of t with a single step of 2 homepages.cs.ncl.ac.uk/cliff.jones/ftp-stuff/rg-hist.pdf \n interference. The reachability of this system is at least that of the original. Thus, any invariant \nof this system is an invariant of the original. Crucially, this approach abstracts from the details of \nthe other threads, making veri.cation signi.cantly more manageable. Linearizability Linearizability [6] \nis the requirement that an ac\u00ad tion composed of multiple atomic actions appear to happen at a single \npoint in time. The use of an abstraction function from a concrete implementation to an abstract speci.cation \noften requires reasoning about linearizability, since an atomic action of the spec\u00adi.cation may require \nseveral steps in the implementation. In this paper, linearizability is dealt with using invariants, auxiliary \nvari\u00adables, Hoare-style assertions, and rely/guarantee. The proof of the correctness of the code with \ndata races in Section 8 illustrates lin\u00ad earizability in detail. Integration The veri.cation is only \nmade possible by using these techniques in combination. The key to integration is to express all the \ntechniques using the core techniques of symbolic evaluation and invariants. Symbolic execution is used \nto explore the state space of the sys\u00adtem. During symbolic evaluation, Hoare-style assertions are used \nto abstract from the details of a particular state, and history variables are used to record details \nof previously seen states. The property that the OCaml implementation re.nes the ABP speci.cation is \nalso an invariant: recall that the implementation re\u00ad.nes the ABP speci.cation if, for every reachable \nimplementation state and every transition from that state there is a corresponding transition of the \nspeci.cation. Rely/guarantee states that for a given thread tid and for all reachable implementation \nhost states h, any successor state h arising from a transition of a thread tid tid =tid satis.es rly \nhh . Again, this is an invariant of implementation states h.As with re.nement, the invariant makes reference \nto successor states. There are therefore three different kinds of invariant. For each transition of a \nthread tid, we must prove the guarantee correspond\u00ading to the rely, the correctness of the abstraction \nfunction, and the other basic invariants. For example, the part of the veri.cation deal\u00ading with the \nsend queue API method involves the following typical goal, parts of which have been omitted for clarity. \nsend lemma p = . ps tid tid h h . ... (* variables are set appropriately *) -. invhpsh -. invhpsh . rlyh \nps tid h h . inv main sender ps h h The aim is to prove that for any path p, if the last two states h \nand h in the path arise as a transition of thread tid, then assuming the basic invariants inv h hold \nof state h, we must show that they hold of state h (invhpsh ), that the transition of thread tid guarantees \nthe relies of other threads tid (rlyh ps tid h h ), and that there is a corresponding transition of the \nABP model (inv main sender ps h h ). In this way, all techniques used in the proof, including privacy \n(part of inv h), rely/guarantee, and re.nement, are cleanly combined. 8. Data races Races on shared \nresources are dangerous, but they can be pre\u00advented using locks. For performance reasons, it is important \nto hold locks for the shortest time possible. The queue uses locks wherever shared state may be accessed \nconcurrently, with one interesting ex\u00adception. In order to improve performance, the private send func\u00adtion \npermits q.msgs to be dereferenced outside the locked region (private send is reproduced below). In the \nrest of this section, I discuss why this might cause problems, why it does not cause problems in this \ncase, and how this is handled in the proof. Recall that the main property we are proving is that, from \na reachable state, every step of the implementation corresponds to a step of the alternating bit protocol. \nThe possible problem arises in the last line of private send, when a message is sent to the network (in \nfact, its immediate destination is the relevant connection object on the host). The alternating bit protocol \nrequires that the message that is sent at this point is the .rst message pending at this point. However, \nthe dereference of the head of the pending messages, List.hd(!( q.msgs ) ), occurs some steps before \nthe message is sent. Potentially the head of q.msgs could have changed in the intervening time, in which \ncase the dereferenced value would not be current, and there would be no corresponding step of the alternating \nbit protocol. The problem is one of linearizability. It is important to realise that even if q.msgs were \ndereferenced inside the locked region, the fact that the send occurs outside the locked region still \ncauses problems. If both the dereference and the send occur inside the locked region, then there is no \nproblem. However, depending on the size of the message, the send may take a long time, and thus impact \nperformance considerably. Fortunately the code is correct as it stands. The function private send is \nexecuted only by the active management thread. Although other threads may read and update q.msgs, they \ncan only add messages to the end. Once q.msgs is non-empty, the head remains constant until the active \nmanagement thread itself removes it in response to a new acknowledgement received from the other endpoint. \nThus, it does not matter that q.msgs is deref\u00aderenced some time before the send occurs since the value \nwill not change in the intervening time. The situation is only slightly more complicated by the fact \nthat the abstraction to the alternating bit protocol uses the on-disk rather than in-memory queue. For\u00adtunately \nthe inv mem disk none, inv mem disk some invariants guarantee that the two representations are the same \n(or, at least, that the head of the in-memory queue is the same as the head of the on-disk queue, since \na user thread may be calling send, which has appended a message to the in-memory queue, but not yet logged \nthe results to disk). The reasoning may be presented slightly more formally using Hoare-style assertions. \nBecause the invariants inv mem disk none, inv mem disk some are involved in the reasoning, I also show \nhow they are preserved. let private_send q = (* 1 *) let _ = Mutex.lock q.lock in (* 2 *) let _ = while \n! ( q.msgs ) = [] do Condition.wait q.cond q.lock done in (* 3 *) let _ = Mutex.unlock q.lock in (* 4 \n*) let msgs = [ string_of_bool ( ! ( q.b ) ) ; List.hd ( ! ( q.msgs ) ) ] in (* 5 *) let _ = Message.send \n( dest_Some ( ! ( q.fd ) ) ) msgs in () in At 1, the global invariant holds by assumption. In particular, \nwe restrict attention to the relevant part of the global invariant, inv mem disk none and inv mem disk \nsome.At2,the thread has successfully taken the lock. Immediately prior to this step, the lock is not \nheld, so the condition of the invariant inv mem disk none is satis.ed, and the in-memory and on-disk \nqueues are the same. This is not altered by the lock being taken, so immediately af\u00adter the lock is taken, \nthe in-memory and on-disk queues are still the same. Other threads may interfere at this point, but they \nguar\u00adantee not to alter (the shared parts of) the queue state while the lock is taken. Thus, while the \nlock is held, the conclusion of inv mem disk none remains true. inv mem disk some is trivially true since \nthe condition is false, and this remains the case while the lock is held. At 3, the lock is still taken, \nand q.msgs is non-empty. Again, other threads may interfere, but the active thread can rely on rly msgs \nnon empty to ensure that the head of q.msgs is con\u00adstant. In fact, the head of the queue remains constant \nalso because the lock is held, indicating that rly msgs non empty is really only necessary outside the \nlocked region. This is related to the fact that the mutex and condition variable are used here primarily \nfor inter\u00adthread communication, not to protect shared access to resources. At 4 the lock is released. \nThe conclusion of inv mem disk none holds immediately before the lock is released, so inv mem disk none \nholds immediately after the lock is released. inv mem disk some is trivially true because the condition \nis false. From this point on, user threads may interfere, and the lock may be free, or taken by a user \nthread. However, rly msgs non empty guarantees that the head of the list remains constant. At 5, q.b \nand q.msgs have been dereferenced. The only thread that can alter the value of q.b is the sender thread, \nwhich we are currently executing, and rly msgs non empty ensures q.msgs remains current. When the send \n.nally occurs, the lock can either be free, or held by one of the user threads (nothing can make the \nlock be held by the active sender thread). The invariants inv mem disk none, inv mem disk some ensure \nthat, regardless of whether the lock is held or not, the pre\u00adviously read values q.b and List.hd(!( q.msgs \n) ) corre\u00adspond to the values currently on disk. There is thus a corresponding transition of the alternating \nbit protocol respecting the abstraction function.  9. Context, privacy and encapsulation The queue is \nintended to be used as a library by other applica\u00adtions. It should behave correctly regardless of the \ncontext in which it is called. This is achieved by keeping queue resources private. If resources are \nprivate, then invariants on the resources can be en\u00adforced. In this work, resources are unforgeable references \nto host state, typically store locations, mutex identi.ers, condition variable identi.ers and network \nconnection identi.ers. Even a thread iden\u00adti.er might be considered a resource, although in the current \nmodel of OCaml there is no way to manipulate a thread via its identi.er, so whether thread identi.ers \nare private or not is immaterial. The exact nature of a resource is orthogonal to privacy concerns nothing \nis lost by considering all resources to be store locations. The idea of privacy is very simple. A single \nresource r is private to a function f if, wherever it occurs, it is syntactically within the body of \nf. For example, location Loc i is private to function . x. Loc i in App(. x. Loc i, unit). In general \nthere may be more than one resource and more than one function. For example, the queue API methods for \nthe receiver all share the same resources. A resource r may be private to f initially, but subsequently \nf may leak r to user code. Possible ways f can leak r are by making r accessible via shared store, or \nby returning r to user code (either normally, or during exceptional return). To ensure that r remains \nprivate throughout an execution, f must be privacy-preserving.In particular, f must not return r to user \ncode (directly, or during an exceptional return). In a single-threaded setting, f must ensure that r \nis not accessible via other locations in the store when f .nishes executing. In a concurrent setting \nf must ensure that r is not accessible to other threads via other locations in the store at any point \nduring execution. For the queue, resources are never accessible via other locations in the store. Thus, \nas far as privacy is concerned, veri.cation must establish that the queue API functions do not return \nprivate resources to user code. OCaml can support notions of privacy for in-memory data struc\u00adtures. \nHowever, the queue also uses the network and the .lesystem. External restrictions must be placed on how \nthese are used by the context. For example, no user thread should write directly to the log .les otherwise \nchaos might ensue. The de.nition of privacy The .rst de.nition gives all subclosures of a closure cl, \nomitting those that match one of the functions fns. This is then lifted to contexts and framestacks in \nthe obvious way. subcls fns cl = if cl IN fns then [] else cl::(case cl of Cl(e,env) . FLAT (MAP (. (v,cl). \nsubcls fns cl) env)) A set of resources rs are private to a set of functions fns if, when occurrences \nof fns are removed, there are no occurrences of rs. private cl fns rs cl = . r. r IN rs -. (MEM r (subcls \nfns cl)) private fs fns rs fs = . r. r IN rs -. (MEM r (subcls fs fns fs)) private clfs fns rs (cl,fs) \n= private cl fns rs cl . private fs fns rs fs Recall that thread state consists of a pair, where the \nsecond component is a framestack, and the .rst component represents a running thread evaluating a closure, \nor a thread blocking on a system call. private thread fns res t = let rs = restocls res in case t of \n(T Run cl,fs) . private clfs fns rs (cl,fs) || (T Block call,fs) . private fs fns rs fs . case call of \nSC Ref(cl) . private cl fns rs cl || SC Deref(l) . (l IN res.locs) || SC Assign(l,cl) . (l IN res.locs) \n. private cl fns rs cl || ... Store invariant Queue resources are never accessible from other store locations, \neither while user code executes or while queue API functions execute. This is captured by the following \ninvariant. The de.nition private cl is .rst lifted to the host store. private store fns res s = let rs \n= restocls res in . loc:loc. loc IN FDOM s -. private cl fns rs (s loc) inv private store ps h = let \nres = ps tores ps in let fns = qfns ps in private store fns res h.s The invariant is checked while user \ncode executes and while queue API functions execute. Since the resources are private to user code, there \nis no way user code can write them into the store (except by writing a queue API function itself into \nthe store, but this preserves privacy). For the queue API functions it is clear from the code that this \ninvariant is satis.ed. Privacy veri.cation Veri.cation starts by considering an arbitrary thread, with \nresources res private to functions fns. In this work, fns are the queue API functions. There are two \ncases. Either a function executes, or arbitrary user code executes. For arbitrary user code, by considering \nall possible cases, one can show that after a step of execution the resources remain private, and the \nstate of the resources is unchanged. This is described in more detail below. Since the proof is independent \nof the resources res and the set of functions fns, the result is OCaml metatheory and may be reused in \nother veri.cations. The second case arises when one of the queue API functions fns executes. For each \nfunction, veri.cation must establish that resources are not written to the store while the function executes, \nnor returned to user code when the function .nishes executing. The functions are speci.c to the code \nbeing veri.ed, in this case the queue, and therefore this part of the veri.cation cannot be reused. Resources \nremain private while executing user code The follow\u00ading lemma describes the case that arbitrary user \ncode executes with resources res private to functions fns. user lemma = . tid h h t t fns res. ... (* \nvariables are set appropriately *) -. (. fs f arg. f IN fns . (t = (T Run f,App(Wrap Hole,Wrap(Clo arg))::fs))) \n-. private thread fns res t . private store fns res h.s -. h IN set (trans h tidt h (tid,t)) -. private \nthread fns res t . private store fns res h .s . (eval res res h = eval res res h) Thread t is identi.ed \nby thread identi.er tid. The .rst condi\u00adtion restricts thread t to user code rather than (an application \nin\u00advolving) one of the fns. The inductive assumption is that the re\u00adsources are private in both the thread \nstate t and in the host store h.s. The next condition restricts h to a successor of h (within h, the \nthread making the transition is t). The conclusion is that re\u00adsources remain private in both the thread \nstate t and in the host store h .s, and moreover the value of any resource is unchanged. This lemma is \nproved by analysing all the possible cases for the user code, and all the possible ways each case might \nevaluate. Resources remain private after executing queue API functions Recall that the proof consists \nof two cases: either arbitrary user code executes, or one of the queue API methods executes. Prior to \nthis case split, there is an outer induction on the length of the trace p, as described in Section 7. \nIn the case that a queue API method executes, resources are private to functions in the frames\u00adtack context \nfs. The function executes, private queue resources may be manipulated, and eventually the method returns \na value to the user code context fs. Providing the method has not returned private resources to user \ncode, the remaining suf.x p ' of p satis.es the in\u00adductive assumption that at p0 ' resources are private \nto the queue API functions. The inductive assumption is invoked to conclude that on p ' , the remainder \nof p, the resources remain private. 10. Proof skeleton, composing the fragments The previous sections \ndetail the veri.cation of the internal queue function private send, the queue API method send, and arbi\u00adtrary \nuser code. How are these separate veri.cations combined? When we talk about verifying a function, we \nreally mean veri\u00adfying a function executed by a thread. Similarly, verifying arbitrary user code means \nverifying a thread executing arbitrary user code. The task of composing the veri.cation fragments involves \nassem\u00adbling the individual thread veri.cations into a veri.cation of the host. The host is more than \na set of threads. Most of the components of the host are passive, that is, they do not of themselves \ncause transitions to occur. The store is an example. Some parts of the host are active, such as the network \nconnections. Network connections cause transitions, but they do not directly affect threads a thread \nhas to make an explicit system call to interact with a connection object. Some parts of the host are \nactive and directly affect the threads. For example, a thread might be sleeping, waiting on a condition \nvariable, and the system may decide to wake the thread up, even if the condition has not been signalled3. \nMoreover, the system behaviour is not just the behaviour of the hosts. Clearly the additional behaviours \nof the host and the behaviour of the network are important; however, in this section we limit the discussion \nto host thread transitions only. Further composition steps treat the additional host behaviours and the \nnetwork behaviour. 3 This is the reason waits are wrapped in while loops. Modern implemen\u00adtations may \nnot exhibit this traditional behaviour, but of course, it is safer to assume they do. We .rst de.ne a \nstate transition system whose reachability is at least that of the system we are interested in. sender \nendpoint thread starts ps tid (int,h) = let t = h.ts tid in let fns = qfns ps in let res = ps tores \nps in (int = T) . case tid = ps.tid of T . (t = sender active thread ps) || F . (private thread fns res \nt) sender endpoint thread trans ps tid (int,h) (int ,h ) = let t = h.ts tid in (int = int) . case int \nof T . ((rly h ps tid) h h . invh ps h ) || F . (h IN set (trans h tidt h (tid,t))) sender endpoint thread \nsts ps tid = let s = sender endpoint thread starts ps tid in let t = sender endpoint thread trans ps \ntid in (s,t) The sender endpoint thread sts describes transitions of the network from the point of view \nof thread tid.Asusual,weuse symbolic execution to examine traces p of this system. The start states sender \nendpoint thread starts constrain p0. Recall that ps.tid is the active management thread. The .rst case \nsplit on tid = ps.tid (from sender endpoint thread starts) deter\u00admines whether we are executing the active \nthread, or a user thread. If we are executing the active thread we use the veri.cation of the sender \nfunction. Otherwise we are executing a user thread. The start states are further constrained by private \nthread fns res t. Recall that this predicate, de.ned in Section 9, says that resources res are private \nto queue API functions fns in thread t. Then either the currently evaluating closure is one of the functions \nfns or it is not. If it is not, then arbitrary user code executes, and we invoke the metatheory from \nSection 9. Otherwise we case split on which of the queue API functions from fns the closure is and invoke \nthe appropriate queue API method veri.cation. 11. Related work Operational semantics is a standard technique \nfor de.ning pro\u00adgramming languages and proving metatheory, but is less often used directly as a basis \nfor program veri.cation. An example of a large operational semantics is the formal description of TCP/IP \n[27, 2]. Symbolic evaluation is a natural counterpart to operational seman\u00adtics. For example, the work \non TCP/IP involved signi.cant testing using symbolic evaluation inside a theorem prover [3]. One researcher \nwho has advocated reasoning directly about the operational semantics is Moore, although he explicitly \nrecognizes that this approach has only recently become feasible: had there been decent theorem provers \nin the 1960s, Floyd and Hoare would never have had to invent Floyd-Hoare semantics! 4 His work [12] focuses \non Java programs, which have .rst been compiled to byte\u00adcode. Correctness properties are phrased as properties \nof the byte\u00adcode, and reasoning occurs above the bytecode, not above the orig\u00adinal Java program. The \nexamples treated, such as an add one pro\u00adgram and a Java function that implements factorial, are signi.cantly \nsimpler than the work presented here. A rare example of operational reasoning applied to a high-level \nlanguage is the work of Compton [4], who veri.es a version of Stenning s protocol for a restricted model \nof Caml and UDP. This work is similar, but again much simpler, than that presented here. The most directly \nrelated piece of work is the author s ver\u00adi.cation of Peterson s algorithm for mutual exclusion [26]. \nThis work was simpler than that presented here, but several of the core 4 http://www.cs.utexas.edu/users/moore/best-ideas/vcg/. \n techniques, including symbolic evaluation and rely/guarantee, were used in the same way that they are \nhere. Hoare popularized the use of assertions for reasoning about pro\u00adgramming languages [7]. Owicki \nand Gries extended Hoare s work to treat concurrent systems [19]. Since then, many variations on the \noriginal Hoare logic have been proposed. For example, a recent mechanization of a novel Hoare logic for \nrecursive procedures and unbounded nondeterminism is [16]. Hoare logic has been used to reason about \nreal languages such as Java [17]. Completeness of the re.nement approach is considered by Lam\u00adport and \nAbadi [15]. The authors note that the technique of re.ne\u00ad ment is not new and point to the slightly earlier \napplication of re\u00ad.nement by Lynch and Tuttle [14] and even earlier work of Lam\u00ad port [11] and Lam and \nShankar [10]. In this work, linearizability arises because of the need to match many implementation \ntransitions to a single speci.cation transi\u00adtion. However, linearizability has been proposed as a form \nof spec\u00adi.cation independent of re.nement [6]. This avoids the overhead of de.ning an abstract model; \nhowever, in this paper the abstract model (the alternating bit protocol) is also used to reason about \nprotocol correctness. Local reasoning, separation, privacy and encapsulation are currently areas of rapid \ngrowth in theoretical computer science. The most popular approaches derive from Reynolds separa\u00adtion \nlogic [25]. Like its ancestor, Hoare logic, separation logic has been adapted in various directions, \nfor example, to include rely/guarantee style reasoning [28]. A more operational approach to local state \nand privacy has been pursued by Pitts and others [22, 21]. 12. Conclusion and future work This work \npresented the operational approach to veri.cation, in\u00adcluding details of how it was applied to verify \na persistent queue. The mechanization involves around 3000 lines of de.nitions, and 3000 of proof, representing \napproximately 6 months of effort. The proof scripts take about an hour to process, with most of that \ntime spent evaluating symbolic expressions. The proof was constructed to suit mechanization. Essentially \nall the proof obligations were reduced to checking a single invariant of the reachable states of a transition \nsystem. Symbolic evaluation was used to generate the reachable states, and invariant checking was based \non HOL4 s rewriting and simpli.cation. The heavy reliance on symbolic evaluation had advantages and disadvantages. \nThe main advantage was that mechanization was fairly straightforward. In the common case where a single \nstep of evaluation does not affect the rest of the host state, all invariants are proved automatically. \nThis makes the scripts robust against trivial changes to the queue code and the OCaml semantics. The \nmain dis\u00adadvantage of this approach is the slow speed of symbolic evaluation in HOL4. Much effort, was \nspent trying to address this problem, both in terms of writing specialized tactics and in reshaping the \nproof. Even so, it can take 10 seconds or more to execute a single step of the system (including automatically \ndischarging invariants), and a single queue API function may require hundreds of steps to execute. Thus, \nit takes a long time to construct an initial proof, and to rework existing proofs. Moreover, waiting \nfor symbolic evalu\u00adation to complete results in low productivity for the human being driving the proof \nprocess. An obvious conclusion is that to make the operational approach more feasible would require investment \nin theorem prover infrastructure, particularly in the areas mentioned. Several aspects of the case study \nmake it particularly suited to the operational approach. The abstract queue in Section 5 has a natural \noperational speci.cation, as does the intermediate model of the alternating bit protocol. At the implementation \nlevel, opera\u00adtional semantics is the standard for de.ning realistic programming languages such as OCaml, \nand can also be used to describe the rest of the system, including the hosts and the network. The OCaml \nim\u00adplementation is a direct re.nement of the alternating bit protocol, and checking the existence of \nsuch a re.nement is well suited to mechanization. The techniques that were needed in the veri.cation \nwere all easily expressed and integrated above the operational se\u00admantics. Furthermore, new techniques, \nsuch as the simple approach to privacy and encapsulation, could also be developed above the operational \nfoundation. For this case study at least, operational rea\u00adsoning was a natural approach, which proved \n.exible, and imposed little overhead on the proof process. Presumably similar systems could be handled \nin a similar manner. This work addresses the question of what is needed to reason about systems that \nhave been de.ned operationally. Since opera\u00adtional semantics is the standard for formally de.ning complex \nsys\u00adtems, this is a natural and important question. Since most veri.ca\u00adtion is not based directly on \noperational semantics, it is natural to wonder why. Hopefully this work demonstrates some of the poten\u00adtial \nof operational reasoning, as well as indicating to some extent where problems lie. There is much scope \nfor future work. More complex examples There are many exciting opportunities for verifying implementations \nof interesting algorithms. For ex\u00adample, Amazon currently use an implementation of the Paxos al\u00adgorithm \nas a core part of their network infrastructure. Reports suggest that most errors are errors introduced \nwhile re.ning the Paxos speci.cation to production code. Using the techniques pre\u00adsented here, I believe \nthat implementations of such complex algo\u00adrithms are now well within reach of mechanized veri.cation. \nOther interesting targets are concurrency libraries, such as Doug Lea s java.util.concurrent. Other languages \nAlthough this work treats the case of two OCaml endpoints, the queue could just as easily have been written \nin, say, Java. The model of OCaml would be replaced by a model of Java, but the rest of the model would \nremain unchanged. Moreover, the ABP model and abstract speci.cation are language neutral, and the notion \nof privacy would be the same, so the general structure of the proof should be preserved. Given a reasonable \nde.nition of the Java operational semantics, it should even be straightforward to treat a queue where \none endpoint is implemented in OCaml and the other in Java, giving a veri.ed proof of interoperability. \nOther approaches to privacy The approach to privacy and encap\u00adsulation presented here is based on restricting \naccess to (mutable) resources. In a typed setting it is more natural perhaps to restrict ac\u00adcess to values \nthrough types ie by using abstract types or signatures to hide type information. There are obvious similarities \nbetween these approaches. The approach of this paper restricts resources to appear only within a known \nset of functions. The type-based approach allows resources to appear anywhere, but only within a known \nset of functions can they be accessed and manipulated. The type-based approach is supported by the language \nitself, which is one reason it is more natural. To support the type-based approach would require a model \nof OCaml modules, together with details of the module type system, so the initial overhead is higher. \nThe higher initial overhead was the reason that the type-based approach was not taken here. However, \nmodelling these parts of OCaml is certainly a long term aim of this work. Models The models of OCaml, \nhosts and the network are abstract, but reasonably realistic. For example, the control messages on the \nnetwork are modelled directly on those used by TCP/IP. However, the models could be improved further. \nThe model of core OCaml should be linked to that of Owens [18]. That model was not used directly because \nit is based on .at expressions, whereas this work required a more structured representation based on \nclosures and framestacks. Owens work includes a de.nition of the OCaml type system and a proof of type \nsoundness. The veri.cation described above makes no use of types, although type information can make \nveri.cation easier. It would also be good to incorporate other static analyses, not only those based \non types, into this framework. The current model of the host includes several unrealistic as\u00adsumptions. \nFor example, the model assumes an in.nite number of .le descriptors, none of which are ever re-allocated. \nConse\u00adquently, errors involving .le descriptor exhaustion, wrap-around or re-allocation are not addressed \nin this work. A long term aim is to make the model of the host more detailed and realistic. This should \nbe possible without modelling the operating system or the network stack in detail (although these make \ninteresting comple\u00admentary projects). The model of networking is based on the author s previous work \n[26], although there is no formal connection. The current model does not fully re.ect the behaviour of \nTCP/IP; for example, it omits certain rare behaviours such as simultaneous connection. The previous work \nincludes these behaviours, but is not abstract enough: the size of the speci.cation alone makes it dif.cult \nto use in veri.cation. The previous work needs to be revisited and abstracted even further with an eye \nto replacing the current network model. Alternative queue implementations The current OCaml imple\u00admentation \nof the queue could be improved in several ways. Rewrit\u00ading the whole log .le every time state changes \nis clearly unnec\u00adessary. A better approach would be to store individual updates in separate .les. Lock \ncontention could be reduced by splitting the endpoint queue in half, with API functions accessing one \nhalf, and the active management thread accessing the other. Only when the half used by the active thread \nbecomes empty would a lock need to be taken, and the contents of the other half copied over. A .nal improvement \nwould be to send more than one message at a time. This would involve changing from an implementation \nbased on the alternating bit protocol to one based on the sliding window pro\u00adtocol. Unfortunately the \nsliding window protocol is signi.cantly more complicated to work with because it requires restrictions \non the rate at which messages are sent, in order to avoid wrapping the message identi.er too quickly. \nIndeed, despite lots of attention, the sliding window protocol has yet to be veri.ed satisfactorily, \nie including precise conditions on the rate that messages are sent. On the other hand, the standard sliding \nwindow protocol assumes messages can be reordered, whereas the underlying TCP used here guarantees that \nno messages are reordered, so that it should be pos\u00adsible to avoid issues of identi.er wrap-around altogether. \nLiveness This work treats safety properties of the queue, but it would also be good to tackle liveness. \nAlthough the use of locks is fairly elementary (there is only one lock per queue) liveness is still non-obvious. \nEven during normal operation, liveness depends on invariants about the way the network is used. In the \npresence of host and network failure, liveness is not obvious. Liveness should be veri.ed. Denotational \nsemantics In the functional programming commu\u00adnity, there is a tradition of algebraic reasoning, using \nequalities between (purely functional) program fragments. The absence of side-effects and the restriction \nto terminating functions justi.es this form of reasoning. Higher-order theorem provers, such as HOL4 \nand Coq, directly support such equational reasoning for their own internal (pure) languages. Operational \nreasoning stresses the step\u00adby-step nature of computation, which handles side-effects well, but is ill-suited \nto this form of reasoning. For the pure fragment of OCaml it is important to support such reasoning. \nTherefore, a long term goal is to reason about the theorem prover equivalents of structures such as lists, \nand then to transfer the results directly to the OCaml code. For example, in the pure fragment of OCaml \nwe can already prove that list append is associative. The next step is to show that any equality concerning \nlists, that is established in the theorem prover, is valid for the purely functional fragment of OCaml. \nThis avoids the need to transfer results individually, in\u00adstead making the full range of HOL equalities \navailable to reason about OCaml code, thereby providing strong support for algebraic reasoning. Acknowledgements \nI thank the anonymous referees for their com\u00adments, which improved the paper signi.cantly. I also wish \nto thank Peter Sewell, who commented extensively on this and previous ver\u00adsions of the paper. I gratefully \nacknowledge the support of EPSRC grants GR/T11715 and EP/C510712.   References [1] IEEE standards association, \nPOSIX. Available online at http://standards.ieee.org/regauth/posix/. [2] S. Bishop, M. Fairbairn, M. \nNorrish, P. Sewell, M. Smith, and K. Wansbrough. Rigorous speci.cation and conformance testing techniques \nfor network protocols, as applied to TCP, UDP, and Sockets. In Proc. SIGCOMM 2005 (Philadelphia), Aug. \n2005. [3] S. Bishop, M. Fairbairn, M. Norrish, P. Sewell, M. Smith, and K. Wansbrough. Engineering with \nlogic: HOL speci.cation and symbolic-evaluation testing for TCP implementations. In POPL 06: Conference \nRecord of the 33rd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, pages 55 66, \nNew York, NY, USA, 2006. ACM Press. [4] M. Compton. Stenning s protocol implemented in UDP and veri.ed \nin Isabelle. In M. D. Atkinson and F. K. H. A. Dehne, editors, CATS, volume 41 of CRPIT, pages 21 30. \nAustralian Computer Society, 2005. [5] M. Felleisen and M. Flatt. Programming languages and lambda cal\u00adculi. \nAvailable online at http://www.cs.utah.edu/plt/publications/pllc.pdf. [6] M. Herlihy and J. M. Wing. \nLinearizability: A correctness condition for concurrent objects. ACM Transactions on Programming Languages \nand Systems, 12(3):463 492, July 1990. [7] C. Hoare. An axiomatic basis for computer programming. CACM: \nCommunications of the ACM, 12, 1969. [8] R. Johnson. J2EE development frameworks. IEEE Computer, 38(1):107 \n110, 2005. [9] C. B. Jones. Development Methods for Computer Programmes Including a Notion of Interference. \nPhD thesis, Prgr.Res.Grp. 25, Oxford Univ., Comp. Lab., UK, June l981. [10] S. S. Lam and A. U. Shankar. \nProtocol veri.cation via projections. IEEE Transactions on Software Engineering, 10(4):325 342, July \n1984. [11] L. Lamport. Specifying concurrent program modules. ACM TOPLAS, 5(2):190 222, Apr. 1983. [12] \nH. Liu and J. S. Moore. Java program veri.cation via a JVM deep embedding in ACL2. Lecture Notes in Computer \nScience, 3223:184 200, 2004. [13] N. A. Lynch. Distributed Algorithms. Morgan Kaufmann, 1996. [14] N. \nA. Lynch and M. R. Tuttle. Hierarchical correctness proofs for distributed algorithms. Technical Report \nMIT/LCS/TR-387, MIT, 1987. [15] M. Abadi and L. Lamport. The Existence of Re.nement Mappings. In Proc. \nof the 3rd Symposium on Logic in Computer Science, pages 165 175, Edinburgh, July 1988. IEEE. [16] T. \nNipkow. Hoare logics for recursive procedures and unbounded nondeterminism. In J. Brad.eld, editor, Computer \nScience Logic (CSL 2002), volume 2471, pages 103 119, 2002. [17] D. v. Oheimb and T. Nipkow. Hoare logic \nfor NanoJava: Auxiliary variables, side effects and virtual methods revisited. In L.-H. Eriksson and \nP. Lindsay, editors, Formal Methods Europe (FME 2002), volume 2391, pages 89 105, 2002. [18] S. Owens. \nA sound semantics for OCaml light. In S. Drossopoulou, editor, ESOP, volume 4960 of Lecture Notes in \nComputer Science, pages 1 15. Springer, 2008. [19] S. Owicki and D. Gries. Verifying properties of parallel \nprograms: An axiomatic approach. Communications of the ACM, 19(5):279 285, May 1976. [20] L. C. Paulson. \nThe inductive approach to verifying cryptographic protocols. Journal of Computer Security, 6:85 128, \n1998. [21] A. M. Pitts. Operational semantics and program equivalence. In G. Barthe, P. Dybjer, and J. \nSaraiva, editors, Applied Semantics, Advanced Lectures, volume 2395 of Lecture Notes in Computer Science, \nTutorial, pages 378 412. Springer-Verlag, 2002. [22] A. M. Pitts and I. D. B. Stark. Operational reasoning \nfor functions with local state. In A. D. Gordon and A. M. Pitts, editors, Higher Order Operational Techniques \nin Semantics, Publications of the Newton Institute, pages 227 273. Cambridge University Press, 1998. \n[23] G. D. Plotkin. The origins of structural operational semantics. Journal of Logic and Algebraic Programming \n(JLAP), 60:3 15, 2004. [24] G. D. Plotkin. A structural approach to operational semantics. Journal of \nLogic and Algebraic Progamming (JLAP), 60:17 139, 2004. [25] J. Reynolds. Separation logic: a logic for \nshared mutable data structures, 2002. [26] T. Ridge. Operational reasoning for concurrent Caml programs \nand weak memory models. In K. Schneider and J. Brandt, editors, Theorem Proving in Higher Order Logics, \n20th International Conference, TPHOLs 2007, Kaiserslautern, Germany, September 10\u00ad13, 2007, Proceedings, \nvolume 4732 of Lecture Notes in Computer Science, pages 278 293. Springer, 2007. [27] T. Ridge, M. Norrish, \nand P. Sewell. A rigorous approach to networking: TCP, from implementation to protocol to service. In \nJ. Cu\u00b4ellar, T. S. E. Maibaum, and K. Sere, editors, FM, volume 5014 of Lecture Notes in Computer Science, \npages 294 309. Springer, 2008. [28] V. Vafeiadis and M. J. Parkinson. A marriage of rely/guarantee and \nseparation logic. In CONCUR 07: Conference on Concurrency Theory, volume 4703 of LNCS, pages 256 271. \nSpringer, 2007. [29] G. Weikum and G. Vossen. Transactional Information Systems. Morgan Kaufmann, 2002. \n \n\t\t\t", "proc_id": "1480881", "abstract": "<p>This work develops an integrated approach to the verification of behaviourally rich programs, founded directly on operational semantics. The power of the approach is demonstrated with a state-of-the-art verification of a core piece of distributed infrastructure, involving networking, a filesystem, and concurrent OCaml code. The formalization is in higher-order logic and proof support is provided by the HOL4 theorem prover.</p> <p>Difficult verification problems demand a wide range of techniques. Here these include ground and symbolic evaluation, local reasoning, separation, invariants, Hoare-style assertional reasoning, rely/guarantee, inductive reasoning about protocol correctness, multiple refinement, and linearizability. While each of these techniques is useful in isolation, they are even more so in combination. The first contribution of this paper is to present the operational approach and describe how existing techniques, including all those mentioned above, may be cleanly and precisely integrated in this setting.</p> <p>The second contribution is to show how to combine verifications of individual library functions with arbitrary and unknown user code in a compositional manner, focusing on the problems of private state and encapsulation.</p> <p>The third contribution is the example verification itself. The infrastructure must behave correctly under arbitrary patterns of host and network failure, whilst for performance reasons the code also includes data races on shared state. Both features make the verification particularly challenging.</p>", "authors": [{"name": "Thomas Ridge", "author_profile_id": "81322504917", "affiliation": "University of Cambridge, Cambridge, United Kingdom", "person_id": "P1301032", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1480881.1480934", "year": "2009", "article_id": "1480934", "conference": "POPL", "title": "Verifying distributed systems: the operational approach", "url": "http://dl.acm.org/citation.cfm?id=1480934"}