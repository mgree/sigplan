{"article_publication_date": "01-21-2009", "fulltext": "\n Static Contract Checkingfor Haskell Dana N. Xu Simon Peyton Jones Koen Claessen University of Cambridge \nMicrosoft Research Chalmers University of Technology nx200@cam.ac.uk simonpj@microsoft.com koen@chalmers.se \n Abstract Program errors are hard to detect and are costly both to program\u00admers who spend signi.cant \nefforts in debugging, and for systems that are guarded by runtime checks. Static veri.cation techniques \nhave been applied to imperativeand object-oriented languages, like JavaandC#,butfewhavebeen appliedtoahigher-orderlazy \nfunc\u00adtional language,likeHaskell.Inthispaper,we describeasoundand automatic static veri.cation framework \nfor Haskell, that is based on contracts and symbolic execution. Our approach is modular and gives precise \nblame assignments at compile-time in the presence of higher-order functions and laziness. Categories \nand Subject Descriptors D.3[Software]: Program\u00adming Languages General Terms veri.cation, functional language \nKeywords contract satisfaction, static contract checking 1. Introduction Program errors are common in \nsoftware systems, including those that are constructed from functional languages, and much research attention \nhas been paid to the early and accurate detection of such errors.Formulating and checking (dynamically \nor statically) logi\u00adcal assertions [22, 13, 4], especially in the form of contracts [24, 2], is one popular \napproach to error discovery. Assertions state logical properties of an execution state at arbitrary points \nin the program; contracts specify agreements concerning thevalues that .owacross a boundary between distinct \nparts of a program (modules, proce\u00addures, functions, classes). In functional languages, the presence \nof higher-order values and lazily-constructed values complicate as\u00adsertion and contract checking,but \nconsiderable progress has been made, especially for dynamically-checked contracts [11, 10, 18]. In addition, \nrecent proposals haveintroduced static pre/post-condition checking andhybrid (mixed static/dynamic) contract \nchecking for functional languages [38, 12, 21, 20, 16]. In this paper, we present a sound and automatic \nmethod for static contract checking for a higher-order lazy functional language, Haskell, by combining \nthe ideas of higher-order contract seman\u00adtics [11, 3] and static veri.cation through symbolic execution \n[38]. Consider: f :: [Int] -> Int f xs = head xs max 0 Permission to make digital or hard copies of all \nor part of this work for personal or classroom use is granted without fee provided that copies are not \nmade or distributed for pro.t or commercial advantage and that copies bear this notice and the full citation \non the .rst page.To copyotherwise, to republish, to post on servers or to redistribute to lists, requires \nprior speci.c permission and/or a fee. POPL 09, January 18 24, 2009, Savannah, Georgia, USA. Copyright \nc &#38;#169; 2009ACM 978-1-60558-379-2/09/01... $5.00. where head is de.ned in the module Prelude as \nfollows: head :: [a] -> a head (x:xs) = x head [] = error \"empty list\" If we have a call (f []) in our \nprogram, its execution will result in the following error message: Exception: Prelude.head: empty list \nThis gives no information on which part of the program is wrong except that head has been wrongly called \nwith an empty list. Pre\u00adsumably, the programmer s intention is that head should not be called with an \nempty list.Toexpress this intention, programmers can give a contract to the function head. Contracts \nare imple\u00admented as pragmas: {-# CONTRACT head :: {s | not (null s)} -> {z | True} #-} where not and \nnull are just ordinary Haskell functions: null :: [a] -> Bool not :: Bool -> Bool null [] = True not \nTrue = False null xs = False not False = True This contract places the onus on callers of head to ensure \nthat the argument to head satis.es the expected precondition. With this contract, our compiler would \ngenerate the following warning (by giving a counter-example) when checking the de.nition of f: Error: \nf [] calls head which fails head s precondition! This paper makes the following speci.c contributions: \n Wegiveacrisp, declarativespeci.cationforwhatit meansfora termto satisfya contract(\u00a74). This is unusual, \nwith the notable exceptionof Blume&#38;McAllester[3].  Unlike Blume &#38; McAllester and most other \nrelated work on higher-order contracts, we focus on static veri.cation, and tar\u00adget a lazy language. \n Our contracts themselves contain unrestricted Haskell terms, so we tackle head-on the question of what \nhappens if the contract itself crashes(\u00a76) ordiverges(\u00a77).  Despite this generality, we are able to \ngive a very strong the\u00adorem expressing the soundness and completeness of contract wrappers as compared \nto contract satisfaction(\u00a75).  We develop a concise notation(e and <)for describing con\u00adtract checking, \nthat enjoys manyuseful properties(\u00a75.3). Thus equipped, we give a new proof of the soundness and complete\u00adnessof \ncontract wrappers. This proofis quite simple,but setting up the design to make it simple was much trickier \nthan we ex\u00adpected.  Our framework neatly accommodates some subtle points that others have encountered, \nincluding: ensuring that all contracts are inhabited(\u00a74.3), and the Any contract(\u00a74.4).  Wedescribe \nhowto augment the contract decision procedure so thatit maintainsextra informationthathelpsthe programmerto \nlocalise the error(\u00a78). 2. Overview The type of a function constitutes a partial speci.cation to the \nfunction. For example, sqrt :: Int -> Int says that sqrt is a function that takes an integer and returns \nan integer. A con\u00adtract ofa functiongives more detailed speci.cation.Forexample: {-#CONTRACTsqrt::{x|x>=0}->{z| \nz<= x}#-} says that the function sqrt takes a positive value and returns a value that is smaller than \nthe input. A contract can therefore be viewed as a re.nement to a type; it is therefore also known as \nre.nement type in [15, 7, 12]. This paper describes a system that allows a programmer to write a contract \non some (but, like type signatures, not necessarily all) de.nitions, and then statically checks whether \nthe de.nition satis\u00ad.es the contract. This check is undecidable, and so may give the result de.nitely \nsatis.es , de.nitely does not satisfy , or don t know . In the latter two cases we emitinformation that \nhelps to lo\u00adcalise the (possible)bug.Webegin,however,bygiving the .avour of contracts themselves with \nvarious examples, concentrating on aspects where our approach differs from other contract systems. \u00a74 \nmakes contracts precise. 2.1 Base and Dependent Function Contracts We adopt the basic contract notation \nfrom [11, 12].Forexample, here is a contract that declares that the length of the result rs is the same \nas the length of the argument xs (where Ok is short for {x | True}): reverse :: [a] -> [a] {-# CONTRACT \nreverse :: xs:Ok -> {rs | length xs == length rs} #-} reverse = ... The expression (length xs == length \nrs) is an arbitrary boolean-valued Haskell expression. Programmers do not need to learn a new language \nof predicates; theyjust use Haskell. Notice too that this is a dependent function contract, because the \nargument xs is used in the result contract. The contract notation is more expressive than the requires, \nensures notation used in our earlier work [38], because it scales properly to higher-order functions. \nConsider an example adapted from [3]: f1 :: (Int -> Int) -> Int f1g= (g1)-1 {-# CONTRACT f1 :: ({x | \nTrue} -> {y | y >= 0}) ->{z|z>=0} #-} f2 = f1 (\\x -> x -1) The contract of f1 says that if f1 takes a \nfunction that returns a natural number when given any integer, the function f1 itself returns a natural \nnumber. The Findler-Felleisen algorithmin[11](a dynamic contract check\u00ading algorithm) can detect a violation \nof the contract of f1. How\u00adever, it cannot tell that the argument of f1 in the de.nition of f2 failsf1 \ns precondition (due to the lack of witness at run-time). On theotherhand,theSagesystemin[21](ahybrid \ncontractchecking system) can detect thefailure in f2 statically, and can report con\u00adtract violation of \nf1 at run-time. Our system reports bothfailures at compile-time with the following messages: Error: f1 \ns postcondition fails when (g 1) >= 0 holds (g 1) -1 >=0maynothold Error: f2 calls f1 which fails f1 \ns precondition  2.2 Laziness Laziness can causefalse alarms.Forexample: fst (a, b) = a f3 = fst (5, \nerror \"f\") Syntactically, the call fst (5, error \"f\") appears unsafe be\u00adcause the existence of a call \nto error,but in a lazy language like Haskell the call is perfectly safe. The only static veri.cation \ntool that caters for laziness is the ESC/Haskell system [38], which can reducefalse alarmsdueto lazinessby \ninlining.Intheabove case, the function fst is inlined, so the call to fst in f3 becomes 5 which is syntactically \nsafe. However, if the size of the lazy func\u00adtion is big, or the function is recursive, the inlining strategy \nbreaks down. In this paper we therefore introduce a special contract Any, which every expression satis.es. \nNow we can give fst a contract {-# CONTRACT fst :: (Ok, Any) -> Ok #-} which says that fst does not care \nwhat the second component of the argument is, as long as the .rst component is crash-free, the result \nis crash-free. Here, with the contract Any, without inlining anyfunction, our system can tell that f3 \nis safe. This means that wegiveacrashingexpression (such as error \"msg\") the contract Any, while in [3] \nan expression that unconditionally crashes satis.es no contract. This is one of thekeydifferences in \ndesigning the contract semantics. 2.3 Data Constructors in Contracts In the previous section we gave \nfst s argument the contract (Ok, Any);thatis,theargument shouldbeapair whose .rst com\u00adponent satis.es \nOk, and whose second satis.es Any.We generalise this form for any user-de.ned data constructor.Forexample: \ndata A = A1 Int Bool | A2 A f4:: A->Int {-#CONTRACTf4:: A1{x|x>0}Ok -> {z| z> 0}#-} f4(A1xy)=ify then \nx+ 1 else error \"f4\" Note that, the data constructor A1 is used in the above contract while the data \ntype A is used in the type speci.cation. Besides checking the sub-components of A1, a call (f4 (A2 z)) \nis re\u00adjected because the contract of f4 says that f4 can only be applied to data constructed by A1. \n2.4 Partial Functions in Contracts Apartial function is one that maycrash or diverge.For example, the \nfunction head crashes when given an argument []. Since we allow arbitrary Haskell code in contracts, \nwhat are we to say about contractsthatcrashordiverge?One possibilityistosimplyexclude all such contracts \nbutexcludingdivergence requiresatermination checker, andexcluding functions like head isextremely restrictive. \nFor example: headPlus :: [Int] -> Int {-# CONTRACT headPlus :: {xs | not (null xs)} ->{z |z >headxs}#-} \nheadPlus [] = error \"Urk\" headPlus (x:xs) = x+1 Here the postcondition uses head (which may crash), but \nthat seems entirely reasonable in view of the precondition that xs is non-empty.Nevertheless,suchacontractis \nrejectedby[3], because of the call to head. pgm := def1 ,..., defn Programs Our approach is to permit \ndivergence in contracts (which avoids def . De.nition the requirement for a termination checker), but \nto require them def := data T Ta = K1 tTi | \u00b7 \u00b7\u00b7 | Kn tTi tobe crash-free . Our de.nition of crash-free-ness \nfor contracts | f . t Contract attribution takes account of dependency, and hence is much more liberal \nthan | f Tx = e Top-level de.nition requiring each Haskell term in the contract to be independently crash-free \n(whichexcludes head).This liberalityis,webelieve,key x, y, f, g . Variables to making contracts usablein \npractice.Wediscuss crash-freenessof T . Type constructors contracts in \u00a76.1 and divergence in \u00a77.1. K \n. Data constructors  2.5 The PlanforVeri.cation a, e, p . Exp Expressions It is all very well for programmers \nto claim that a function satis.es a, e, p ::= n integers a contract,but how can we verify the claim statically \n(i.e. at com\u00ad | r exception pile time)?Ouroverallplan, whichis similartothatof Blume&#38; | x | .(x : \nt ).e | e1 e2 McAllester [3], is as follows. | case e0 of {alt1 ... altn } case-expression | K Te constructor \nso we must .rst say what programs are, and what it means to Our overall goal is to prove that the program \ndoes not crash, | finn e .nite evaluation crash (\u00a73.3). r ::= BAD | UNR Exceptions Next, we give a semantic \nspeci.cation for what it means for an expression e to satisfy a contract t, written e . t (\u00a74). alt ::= \nK (x1 : t1) ... (xn : tn) . e Alternatives From a de.nition f = e we form a term eet pronounced e | \nDEFAULT . e ensures t . This term behaves just like e except that (a) if e disobeys t then the term crashes; \n(b) if the context uses e in a val ::= n | r | K Te | .(x: t).e Values way not permitted by t then the \nterm loops. The term eet is essentially the wrapper mechanism .rst describedby Findler&#38; t ::= Int \n| Bool | () | T Tt | t1 . t2 Types Felleisen [11], with some important re.nements(\u00a75). Figure 1: Syntax \nof the language H With these pieces in place, we can write down our main theorem for crash-free contracts \nt (\u00a75), namely that e . t .. (eet) is crash-free contracts are well-typed.Typechecking for contracts \ncanbe found in [39]. We must ensure that everything works properly, even if e di\u00adverges, or laziness \nis involved, or the contract contains diver-There are two exception values adopted from [38]: gent or \ncrashing terms. BAD is anexpression that crashes.Aprogram crashes if and only if itevaluates to BAD.For \nexample, a user-de.ned function error follows: we attempt to prove that (eet) is crash-free that Using \nthis theorem, we may check whether f . t holds as can be explicitly de.ned as: is, does not crash under \nall contexts. We conduct this proof error :: String -> a in a particularly straightforward way: we perform \nsymbolic error s = BAD evaluation of (eet). If we can simplify the term to a new term A preprocessor \nensures that source programs with missing e', where e' is syntactically safe that is, contains no crashes \ncases of pattern matching are explicitly replaced by the cor\u00adeverywhere in the expression then we are \ndone. This test is responding equations with BAD constructs. For example, after suf.cient,but not necessary; \nof course, the general problem is preprocessing, function head s de.nition becomes: undecidable. head \n(x:xs) = x 3. The Language head [] = BAD UNR (shortfor unreachable )isanexpressionthatgets stuck.We \nThe language presented in this paper, named language H, is use it to make the program halt when its context \nhas mis\u00adsimply-typed lambda calculus with case-expression, constructors behaved it is unreachable when \nthe context is well-behaved. and integers. Language H is simpler than the language we use in Hence UNR \nis not considered a crash .A program that loops our implementation, which is the GHC Core Language [33], \nwhich foreveralsodoesnotcrash,anddoesnotdelivera result,soyou is similar to SystemFand includes parametric \npolymorphism. can think of UNR asaterm that simply goes into an in.nite loop. 3.1 Syntax 3.2 Operational \nSemantics The syntax of our language H isshownin Figure1.Aprogramisa The semantics of our language is \ngiven by the con.uent, non\u00admodule that contains a set of data type declarations, contract spec\u00addeterministicrewriterulesinFigure2.Weuseasmall-step \nreduction\u00adi.cations and function de.nitions. Expressions include variables, rule semantics, rather than \n(say) a deterministic more machine\u00adterm abstractions and applications, constructors and case expres\u00adoriented \nsemantics, because the more concrete the semantics be\u00adsions.We treat let-expressions as syntactic sugar: \ncomes, the more involved the proofs become too. let x = e1 in e2 =s (.x.e2) e1 Most of these rules are \nentirely conventional. The rule [E-top] We omit local letrec,infavourof recursive(or mutually recur-deals \nwitha top-level function call f.We fetch its de.nition from sive) top-level functions. The language is \ntyped, and to save clutter the environment ., which maps a variable to its type, contract in this paper \nwe silently assume that allexpressions, contexts and and de.nition.To save clutter, we usually leave \nthis environment (f = .x.e) . . [E-top] f .M .x.e e .M e ' n<M ' [E-.n1] finn e .M finn+1 e finn UNR \n.M True [E-.n2] finn val .M val [E-.n3] (val = UNR and n<M) finM e .M True [E-.n4] (.x.e1) e2 .M e1[e2/x] \n[E-beta] case Ki aTi of { ... ; .M ei[ai/xi] [E-match1] Ki xTi . ei; ...} case K Ta of .M e [E-match2] \n{pti . ei; for all i. DEFAULT . e} K Ta ~ pti case .x.e0 of .M e [E-match3] {DEFAULT . e} re .M r [E-exapp] \ncase r of alts .M r [E-excase] e1 .M e2 [E-ctx] C[ e1] .M C[ e2] Contexts C ::= [ ] |C e | e C| .x.C \n| case C of {alt1; ... ; altn} | case e of { ... ; pi .C; ... } Figure 2: Semantics of the language H \nimplicit, rather than writing (say) . f e1 .M e2. Rules [E-exapp] and [E-excase] deal with exception \nvalues in the usual way. Rule [E-ctx]allowsareductionsteptotakeplaceanywhere.The relation e1 .M e2 performs \na single step reduction and the relation . * M is the re.exive-transitive closure of .M . The unconventional \nfeatures are the M subscript on the reduction arrow, the form finn e, and the reduction rules [E-.n1-4]. \nThese aspects all concern divergence, and are discussed in detail in \u00a77.1, where we de.ne . * in terms \nof . * M . For the present, simply ignore the subscripts and fin. Now we cangive the usual de.nitionof \ncontextual equivalence: DEFINITION 1 (Semantically Equivalent). Twoexpressionse1 and e2 are semantically \nequivalent, namely e1 =s e2, iff .C, r. C[ e1] . * r .. C[ e2] . * r Two expressions are said to be semantically \nequivalent, if under all (closing) contexts,if oneevaluatesto anexception r, the other also evaluates \nto r.  3.3 Crashing We use BAD to signal that something has gone wrong in the pro\u00adgram: it has crashed. \nDEFINITION 2 (Crash). Aclosed terme crashes iffe . * BAD. Our technique can only guarantee partial correctness: \na diverging program does not crash. DEFINITION 3 (Diverges). Aclosedexpressione diverges, written e ., \niff either e . * UNR, or there is no value val such that e . * val. At compile-time, one decidable way \nto check the safety of a pro\u00adgram is to see whether the program is syntactically safe. DEFINITION 4 (Syntactic \nsafety). A (possibly-open) expression e is syntactically safe iffBAD ./s e. Similarly, a context C is \nsyntacti\u00adcally safe iffBAD ./s C. The notation BAD ./s e means BAD does not syntactically appear anywhere \nin e, similarly for BAD ./s C. For example, .x.x is syntactically safe while .x. (BAD,x) is not. DEFINITION \n5 (Crash-free Expression). A(possibly-open)expres\u00adsion e is crash-freeiff: .C. BAD ./s C and fC[ e] :: \n() .C[ e] . * BAD The notation fC[ e] :: () means C[ e] is closed and well-typed. By closed we mean that \nno variable is free in C[ e] , not even a top\u00adlevel function like head. The quanti.ed context C serves \nthe usual role of a probe that tries to provoke e into crashing. Notice that a crash-free expression \nmay not be syntactically safe, for example: \\x. case x*x >= 0 of {True -> x+1; False -> BAD} The tautology \nx * x>=0 is always true, so the BAD can never be reached. On the other hand, (BAD, 3) is not crash-free \nbecause there exists a context, fst [ ] , such that: fst (BAD, 3) . BAD In short, crash-freeness is a \nsemantic concept, and hence undecid\u00adable, while syntactic safety is syntactic and readily decidable. \nCer\u00adtainly, a syntactically safe expression is crash-free: LEMMA 1 (Syntactically Safe Expressionis Crash-free). \ne is syntactically safe . e is crash-free 4. Contract Syntax and Semantics t . Contract t ::= {x | p} \nPredicate Contract | x: t1 . t2 Dependent Function Contract | (t1, t2) Data Constructor Contract | Any \nPolymorphic AnyContract Figure 3: Syntax of contracts Having discussed the language of programs, we \nnow discuss the languageof contracts. Figure3gives their syntax.For reasonsof notational simplicity, \nwe restrict data constructor contracts to pairs only,but the idea generalises readily. 4.1 Contract Satisfaction \nWegive the semanticsof contractsby de.ning e satis.es t , writ\u00adten e . t, in Figure 4. This is a purely \ndeclarative speci.cation of contract satisfaction, that says whichterms satisfy a contract, with\u00adout \nsaying how asatisfaction checkmightbe performed.Weregard the ability to give a simple, declarative, programmer-accessible \nspeci.cationof contract satisfaction asvery important,butitisa property that few related works share, \nwith the notable and inspir\u00ading exception of [3]. As that paper says For a well-typed expressione, de.ne \ne . t thus: e . {x | p} .. e. or (e is crash-free and p[e/x] . * {BAD, False}) [A1] e . x : t1 . t2 .. \ne. or (e . * .x.e2 and .e1 . t1. (e e1) . t2[e1/x]) [A2] e . (t1, t2) .. e. or (e . * (e1, e2) and e1 \n. t1, e2 . t2) [A3] e . Any .. True [A4] Figure 4: Contract Satisfaction The structure of a non-compositional \nsemantics like [the Findler-Felleisen wrapping algorithm] is dif.cult to under\u00adstand.With just De.nition1[which \nsays thataterm satis.es a contract if its wrapping cannot crash] to hand, an answer to the question Does \ne satisfy t? is not easy because it in\u00advolves consideration of every possible context. Nor can we ignore \nthis problem, since in our experience most people s intuition differs from [De.nition 1]. To a .rst approximation, \nthe rules in Figure 4 should be self\u00adexplanatory.For example, e satis.es {x | p} if p[e/x] evaluates \nto True. More interestingly, e satis.es the (non-dependent) function contract t1 . t2 iff (ee1) satis.es \nt2 for any term e1 satisfying t1.To get dependent function contracts we must simply remember to substitute \n[e1/x] in t2. However, these de.nitions are carefully crafted at the edges, and we now discuss the less-obvious \nchoices. In Figure 4, both e and t may mention functions bound in the top\u00adlevel de.nitions .. These functions \nare necessary for theevaluation relation of rule [A1] to make sense. To reduce clutter, we do not make \nthese top-level bindings explicit, by writing . f e . t,but instead allow rule [E-top]of Figure2to consult \n. implicitly. 4.2 Only Crash-freeTerms SatisfyPredicate Contracts The alert reader will notice that \n[A1] speci.es that only crash\u00adfree terms satisfy a predicate contract {x | p}. This means that the contract \n{x | True}, which we abbreviate to Ok, is satis.ed precisely by the crash-free terms. Even the identity \nfunction only guarantees a crash-free result if it is given a crash-free argument! Other choices are \npossible,but we postpone the discussion to \u00a75.4, when we have more scaffolding in place. 4.3 DivergingTerms \nThe de.nitionsin Figure4specify thatadivergent term e satis.es every contract.We made this choice because \notherwise wewould often have to prove termination in order to prove that e . t.For example: fx=if x<10thenx \nelsef(x/2) Does f . Ok .{x | x< 10}?Thethen branch clearly satis.es the postconditionbut what about the \nelse branch? Specifying that divergence satis.es anycontract allows us to answer yes without proving \ntermination. Furthermore, despite divergence, a caller of f can still rely on f s postcondition: g y \n= if (f y > 10) then error \"Urk\" else True Here g cannot crash, because f guarantees a result less than \n10, or else diverges. Our choice has the nice consequence that every contract is inhab\u00adited (by divergence). \nThis matters. Consider whether (.x.BAD) sat\u00adis.es {x | False}. Ok. If {x | False} was uninhabited, the \nan\u00adswerwouldbe yes ,since[A2]holdsvacuously.Butthat choiceis incompatible withbuildingarigorous connection(sketchedin \n\u00a72.5) between contract satisfaction and Findler-Felleisen-style wrapping. Indeed, Findler and Blume are \nforced to invent an awkward (and entirely informal) predicate form non-empty-predicate [10], which we \ndo not need. 4.4 The Any Contract If we only have [A1]-[A3], the expression BAD would not satisfy anycontract,butwesawin \n\u00a72.2 that this choice is too conservative for a lazy language. We therefore introduce a special contract, \nnamed Any, which is satis.ed by any expression, including BAD (case [A4] in Figure 4). Now we can give \na contract to fst: {-# CONTRACT fst :: (Ok, Any) -> Ok #-} fst (x,y) = x Any is also useful in post-conditions: \na function whose postcondi\u00adtion is Any isafunction that may crash. Haskell programmers often write packaged \nversions of Haskell s error function, such as myError :: String -> a {-# CONTRACT myError :: Ok -> Any \n#-} myError s = error (\"Fatal error: \" ++ s) So BAD satis.es Any. In fact, BAD satis.es only the contract \nAny becauseitfails the constraints statedin [A1]-[A3]: BAD . (Any, Any) BAD . Any . Any  4.5 Open Expressions \nWe have mentioned that e and t may mention functions bound in the top-level environment. These functions \nparticipate in the evaluation of rule [A1]. But suppose that the programmer declares {-# CONTRACT f :: \n{x | x>0} -> Ok #-} f = ... When checkingthe contractsofa function g that calls f, we should presumably \nassume only f s declared contract, without looking at its actual de.nition. Doing so is more modular, \nand allows the programmer to leave room for future changes by specifying a contract that is more restrictive \nthan the current implementation. This goal is easily achieved. Suppose the declared contracts for f and \ng are tf ,tg respectively,and the de.nition of g is g = eg where f is called in eg. Then, instead of \nchecking that eg . tg, we check that (.f.eg) . tf . tg That is, simply lambda-abstract over any variables \nfree in eg that have declared contracts. As an alternative, we also allow the pro\u00adgrammer to omit a contract \nspeci.cation (just as type signatures are often omitted), in which case the contract checker selectively \ninlines the function when proving the correctness of its callers (for recursive functionssee[39]).Theexact \ndetailsareasoftwareengi\u00adneering matter; our point here is that the underlying infrastructure allows a \nvariety of choices. The same technique simpli.es the problem of checking satisfaction for recursive functions. \nIf the programmer speci.es the contract tf for a de.nition f = e, then it suf.ces to check that .f.e \n. tf . tf which is easier because .f.e does not call f recursively. There is nothing new here it is \njust the standard technique of loop invariantsin another guise butitis packagedvery conveniently. BAD \nUNR r1,r2 .{BAD, UNR} eet = ee< t e<t = e e< t UNR BAD r1 e e< {x | p} = e seq case (finp[e/x]) of \n{True . e; False . r1} [P1] 0 r2 r1 r2 r1 r2 e e< x: t1 . t2 = e seq .v.((e (v e< t1)) e< t2[v e< t1/x]) \n[P2] r2 r1 r2 r1 e r1 e< (t1, t2) = case e of (x1, x2) . (x1 r1 e< t1, x2 r1 e< t2) [P3] r2 r2 r2 e r1 \ne< Any = r2 [P4] r2 Figure 5: Projection De.nition 5. Contract Checking Sofar wehavea nice declarative \nspeci.cationof whena term e satis.es a contract t. Of course, e . t is undecidable in general, but if \nwe could statically check many(albeit not all) such claims, wewouldhaveapowerful tool.Forexample,ifwe \ncouldshowthat main . Ok, then we would have proved that the entire program is crash-free. In their ground-breaking \npaper [11], Findler&#38; Felleisen describe how to wrap a term in a contract-checking wrapper, that checks \nat run-time (a) that the term obeys its contract, and (b) that the context of the term respects the contract. \nHow can we do the same at compile time?Apromising approach, .rst suggested in [38] and sketched in \u00a72.5, \nis to wrap the term in the Findler-Felleisen way, and check that the resulting term is crash free. But \nisthat sound? That is, does that prove that e . t?What about the other way round? These questions are \nanswered by our main theorem: THEOREM 1 (Soundness and Completenessof Contract Checking). For all closed \nexpressionse, and closed crash-free contracts t, (eet) is crash-free .. e . t The form (eet) wraps e \nin a Findler-Felleisen-style contract checker, speci.ed in Figure 5. As in the case of contract satisfac\u00adtion, \nthere are trickydetails, as we discuss in \u00a75.1. Another subtle but important point is the requirement \nthat the contractt be crash\u00adfree ; this deals with contracts that crash and is discussed in \u00a76.1. The \nstatement of Theorem 1 differs only in its technical details from soundness and completeness theorems \nin [3], although our proof technique is different to theirs. The reader may .nd a com\u00adplete proof in \n[39]. The result is very strong. It states that the wrapped term eet is crash-free if and only if e . \nt. Certainly, then, if we can prove that eet is crash-free, we have proved that e . t. But how can we \nprove that eet is crash-free? That, in turn, is undecidable,but there are manyuseful approximations.Forexample, \nthe approach we take is to perform meaning-preserving transformations on eet, of precisely the kind that \nan optimising compiler might perform (inlining, \u00df-reduction, constant folding, etc). If we can optimise \n(i.e. symbolically simplify) the term to a form that is syntactically safe(\u00a73.3), then we are done. The \nbetter the optimiser, the more contract satisfaction checks will succeed but noneof thataffects Theorem1.For \ndetails see [38]. 5.1 Wrapping Our goal is to de.ne eet such that Theorem 1 holds. Figure 5 gives the \nde.nition of a single, general combinator e<, and two no\u00adtational abbreviations e (pronounced ensures \n) and < (pronounced requires ). None of these operators are part of the syntax of ex\u00adpressions (Figure \n1); rather they are thought of as macros, which expand to a particular expression. Informally: r1 et \ne< r2 is a term that behaves just like e, except that it throws exception r1 if e does not respect t, \nand throws exception r2 if the wrapped term is used in a way that does not respect t. In the vocabulary \nof blame , r1 means blame e while r2 means blame the context . Figure5de.nes the convenient abbreviations \nBAD UNR eet = e t e<t = et e< e< UNR BAD So eet crashes (with BAD)ife does not satisfy t,and diverges \n(with UNR)if the context does not respectt. Temporarily ignoring the occurrencesof seq and .n , the main \nstructureofFigure5is standardfrom earlierworks[11],andwedo not belabour it here. In particular, note \nthe inversion of r1 and r2 in the expansion of function contracts. The wrapping of Any, while new,is \nalsoobvious aftera moment s thought.Forexample, fst e (Ok, Any) . Ok = .v.((fst (v< (Ok, Any))) e Ok) \n= .v.((fst (v< (Ok, Any)))) = .v.((fst (case v of(a, b) . (a< Ok,b< Any)))) = .v.((fst (case v of(a, \nb) . (a, BAD)))) Here we have used thefact that e e< Ok = e e< {x | True} = e. That is, considered as \na wrapper Ok does nothing at all. In this example we see that the wrapper replaces the second component \nof the argument to fst with BAD, so that if fst should ever look at it,theprogramwillcrash.Thatisexactlyright,becausethe \ncontract says that the second component can be anything, with contract Any. 5.2 The Use of seq The reader \nmay wonder about the uses of seq in [P1] and [P2] of Figure 5. The function seq (short for sequence ) \nis de.ned as follows: e1 seq e2 = case e1 of { DEFAULT . e2 } It is necessary in the de.nition of e< \nto ensure that Theorem1holds for(a)divergent and(b) crashing terms.Forexample,if bot is a diverging term \n(de.ned by bot = bot), then Figure 4 says that bot .{x | False}. But if [P1] lacked the seq, we would \nhave bot e {x | False} = case False of { True -> bot; False -> BAD } = BAD, which is not crash-free thus \ncontradicting Theorem 1. Dually, we must ensure that BAD . Ok . Any.Without the seq in [P2] we would \nget BAD e Ok . Any = .v. ((BAD (v< Ok)) e Any) = .v. UNR, which is crash-free again contradicting Theorem \n1. Have we covered all the cases?A quick check shows that for anycontract t, BAD . t and UNR . t, whichis \nreassuring.Moresolidly,Theorem1goesthroughwiththe de.nitions of Figure 5. 5.3 Properties of Contracts \nOur contract combinators possess manynice properties.We sum\u00admarise these results in Figure 6. It took \nus some while to evolve a set of de.nitions for ., e<, etc that validated such crisp results. These lemmasformabasisforprovingourmain \nresult: Theorem1. Figure6employsauseful orderingoverexpressions, called crashes more often: DEFINITION \n6 (Crashes more often). e1 crashes more often than e2, written e1 . e2, ifffor all closing contexts C \nC[ e2] . * BAD .C[ e1] . * BAD Informally e1 crashes more often than e2 if theybehave in exactly the \nsame way except that e1 may crash when e2 does not. The proofof our main Theorem1isby induction on the \nsizeof the contract t. To give a .avour of the proof we show the only interesting case here, that for \nfunction contracts when e . * val /. {BAD, UNR}. We give only the proof for non-dependent function contracts \nbecause the dependent case is more intricate and it is harder to see the wood for the trees. Full proofs \ncan be found in [39]. The cf stands for crash-free . eet1 . t2 is cf .. (By de.nition of e) e seq .v.(e \n(v<t1)) et2 is cf .. (Since e . * val /.{BAD, UNR}) .v.(e (v<t1)) et2 is cf .. (Property of crash-freeness) \n( ) . closed, cf e ' . (e (e ' <t1)) et2 is cf Nowthe proof splits into two. In the reverse direction, \nwe start with the assumption e . t1 . t2: e . t1 . t2 . (By defn of e . t) . e1 . t1. (ee1) . t2  . \n(ByKeyLemma (Figure 6)) . closed, cf e ' . (e (e ' <t1) . t2  .. (By induction) ( ) . closed, cf e ' \n. (e (e ' <t1)) et2 is cf and nowwe havereached the desired conclusion ( ). In the forward direction, \nwe start with ( ): ( ) . closed, cf e ' . (e (e ' <t1)) et2 is cf . (By induction, e1 . t1 . e1 et1 is \ncf) . closed e1 . t1. (e ((e1 et1) <t1)) et2 is cf . (By ProjectionPair and Congruence (Figure6))  \n. e1 . t1. (ee1) et2 is cf . (By induction) . e1 . t1. (ee1) . t2 .. (by de.nition of .) e . t1 . t2 \n There are two key steps in this short sequence. First, we choose a particular crash-free e ', namely \n(e1 et1) where e1 . t1. The secondstepisthe appealtothe ProjectionPair lemma, which itself is non-trivial. \n 5.4 WhyOnly Crash-freeTerms SatisfyPredicate Contracts In \u00a74.2 we promised to explain whywe chose to \nallow only crash\u00adfree terms to satisfy a predicate contract, regardless of the predi\u00adcate. An obvious \nalternative design choice for contract satisfaction would be to drop the e is crash-free condition in \nthe predicate contract case: e .{x | p} .. e. or p[e/x] . * {BAD, False} [B1] Then we could get rid of \nAny, because {x | True} would do instead.Ontheotherhand,apolymorphic contractmeaning crash\u00adfree is extremely \nuseful in practice, so we would probably need a new contract Ok (now not an abbreviation) de.ned thus: \ne . Ok .. e is crash-free [B2] This all seems quite plausible, but it has a fatal .aw: we could not .nd \na de.nition for e that validates our main theorem. That is, our chosen de.nition for . makes Figure5work \nout, whereas the otherwise-plausible alternative appears to prevent it doing so. Suppose we have [B1] \ninstead of [A1], that means (BAD, BAD) . {x | True}. However, according to [P1], we have (BAD, BAD) e \n{x | True} =(BAD, BAD) which is not crash-free. This means Theorem 1 fails. Can we change [P1] to .x \nthe theorem? It is hard to see how to do so. The revised rule must presumably look something like ee{x \n| p} = case fin p[e/x] of { True .???; False . BAD } But what can we put for ??? ? Since eet is supposed \nto behave like e if p[e/x] holds, the ??? must be e but thenBAD e {x |True} would not be crash free. \nThis dif.culty motivates our choice that predicate contracts are satis.ed only by crash-free terms. 6. \nContracts that Crash Our goal is to detect crashes in a program with the help of con\u00adtracts; we do not \nexpect contracts themselves to introduce crashes. One approach,takenby Blume&#38;McAllester[3],isto prohibita \ncontract from mentioning anyfunction that might crash. But that is an onerous restriction, as we argued \nin \u00a72.4. It is attractive simply to allow arbitrary crashes in contracts; af\u00adter all, Figure4speci.esexactly \nwhich terms inhabiteven crash\u00ading contracts. Alas, if we drop the (still-to-be-de.ned) condition crash-free \ncontract from Theorem1,the (.) direction still holds, but the(.) directionfails. Hereisa counter-exampleinvolvinga \ncrashing contract.We know that: .x.x .{x | BAD}. Ok because the only expression that satis.es {x | BAD} \nis an expres\u00adsion that diverges and a diverging expression satis.es Ok. But we have: .x.x e {x | BAD}. \nOk = .v.(.x.x (v< {x | BAD})) = .v.(v< {x | BAD}) = .v.(v seq BAD) which is not crash-free 6.1 Crash-free \nContracts So unrestricted crashes in contracts invalidates (the . direction of) Theorem 1. But no one \nis asking for unrestricted crashes!For example, this contract doesn tmake much sense: tbad = xs : Ok \n.{r | r> head xs} What does tbad mean if the argument list is empty? Much more plausible is a contract \nlike this (see \u00a72.4): tgood = xs : {xs | not (null xs)}.{r | r> head xs} Congruence .e1,e2.e1 . e2 .. \n.C. C[ e1] .C[ e2] Conditional Projection (w.r.t. .,C) For alle and crash-free t, if e . t, then (a) \ne<t . e; (b)eet C e. KeyLemma For all crash-freee, crash-free t, e<t . t. Monotonicity of . If e1 . t \nand e1 . e2, then e2 . t Idempotence .e, t. (a) (eet) et = eet (b) (e<t) <t = e<t ProjectionPair .e, \nt. (eet) <t . e ClosurePair .e,t. e . (e<t) et r1 r3 r1 Telescoping Property For alle, crash-free t. \n(e e< t) e< t = e e< t r2 r4 r4 Figure 6: Properties of e and < which speci.es that the argument list \nis non-empty, and guarantees to returna resultbiggerthanheadoftheargument.Thusmotivated, we de.ne a notation \nof a crash-free contract: DEFINITION 7 (Crash-free Contract). Acontractt is crash-free iff or t is {x \n| p} and p is crash-free t is x: t1 . t2 and t1 is crash-free and for all e1 . t1, t2[e1/x] is crash-free \nor t is (t1, t2) and both t1 and t2 are crash-free or t is Any The de.nition is essentially the same \nas that of Tsafe in [3], al\u00adthoughperhapsa little more straightforward.Itsimplyasksthatthe predicatesinacontract \nare crash-free under the assumption that the dependent function arguments satisfy their contracts. So, \nunder this de.nition, tbad is ill-formed while tgood is crash-free. The latter is crash-free because \nhead xs is crash-free for every xs that satis.es not (null xs).  6.2 Wrapping dependent function contracts \nRecall [P2] from Figure 5: r1 r2 r1 r2 e e< x : t1 . t2 = e seq .v. ((e (v e< t1)) e< t2[(v e< t1)/x]) \nr2 r1 r2 r1 r2 Notice that v is wrapped by v e< t1 even in the contract t2, as well r1 as in the argument \nto e. Could we simplify [P2] by omitting this wrapping, thus? r1 r2 r1 e e< x: t1 . t2 = e seq .v. ((e \n(v e< t1)) e< t2[v/x]) r2 r1 r2 No,we could not: Theorem1wouldfailagain. Hereisa counter\u00adexample. {-# \nCONTRACT h :: {x | not (null x)} -> {z| headx==z} #-} h (y:ys) = y Now h satis.es its contract th,but \nh eth is not crash-free, as the reader may verify. We remarked earlier that Blume &#38; McAllester require \nthat con\u00adtracts only call crash-free functions. But the wrapping of v inside t2 in rule [P2] might itself \nintroduce crashes, at least if t2 uses x in a way that does not respect t1. Theytherefore use another \nvariant of [P2], as follows: r1 r2 r1 r2 e e< x : t1 . t2 = e seq .v. ((e (v e< t1)) e< t2[(v e< t1)/x]) \nr2 r1 r2 UNR Notice the UNR introduced out of thin air in the wrapping of v in t2, which is enough to \nmaintain their no-crashing invariant. Happily, if the contracts are crash-free (which we need anyway, \nso that it is possible to call head)there is no need for this somewhat ad-hoc .x. 6.3 Practical consequences \nOne mightworry that the crash-freeness conditionin Theorem1 makes the veri.cation task more onerous: \nperhaps to prove e . t now we must check two things (a) that t is crash-free formed and (b) that eet \nis crash-free. Happily, this is not necessary, because the(.)of Theorem1holds for arbitraryt: THEOREM \n2. For all closed expressione, for all contract t, (eet) is crash-free . e . t The proof of Theorem2is \nthe same as the proof for the direction (.)of Theorem1because only the proof for the direction(.)of Theorem1requires \nthe condition that t to be crash-free. 7. Contracts that diverge Our system allows non-termination both \nin the programs weverify, and in their speci.cations (contracts), which is most unusual for a system \nsupporting static veri.cation. As we discussed in \u00a74.3, we allow non-termination for programs because \nwe work with a real-life programming language, in which many functions actuallydo not terminate.Wedo \nnotwanttoex\u00adclude non-termination in general, even for speci.cations, because we do not want to be forced \nto perform termination proofs. Since the current advances in automatic termination proofs are still lim\u00adited, \nespecially for lazy programs, requiring termination would put a substantialextraburden on the userof \nour system. What about divergent contracts? Many program veri.cation sys\u00adtems for functional programming, \nsuch as HOL, systems based on dependent types (Coq, Agda), andACL2, do not allow any non\u00adterminating \nde.nitions. The main reason is that divergent terms in\u00adtroduce an immediate unsoundnessin these systems.Forexample, \nby an (unsound) induction proof, a constant de.ned as letx =x could be proven equal to both 1 and 2, \nconcluding that 1=2. But it would be onerous to insist that all contracts terminate, be\u00adcause the programmer \ncan write arbitrary Haskell in contracts, and proving termination of arbitrary Haskell programs is hard. \nFurther\u00admore, allowing non-termination in speci.cations is of direct bene\u00ad.t. Considera function zipE \nwhich requires two inputs to have the same length: {-# CONTRACT zipE :: xs:Ok -> {ys | sameLen xs ys} \n-> Ok #-} zipE[] [] =[] zipE (x:xs) (y:ys) = (x,y) : zipE xs ys zipE _ _ = error unequal lengths sameLen \n[] [] = True sameLen (x:xs) (y:ys) = sameLen xs ys sameLen _ _ = False Here, two in.nite lists satisfy \nthe contract for ys, since (sameLen xs ys) diverges, and indeed zipE does not crash for such argu\u00adments. \nCare is necessary in writing the contract: if we had in\u00adstead said length xs == length ys,the contractwoulddiverge \nif only one argumentwas in.nite,but zipE would crash for such arguments, so it would not satisfy this \nalternative contract. In this way, safety properties over in.nite structures are allowed. (Safety properties \nare properties that always have .nite counter-examples whenever there exists anycounter-example.) Whyisour \napproach sound?First,anycontractweverifyforapro\u00adgram only deals with partial correctness. In other words, \nall con\u00adtracts are inhabited by non-terminating programs as well. Second, our system does not include \nreasoning mechanisms like equational reasoning.Infact, our system has no meansofexpressing equality at \nall!Everythingisexpressedin termsof Haskellexpressionseval\u00aduating to boolean values, crashing, or not-terminating. \nThird, any speci.cation that does not terminate is semantically the same as a True contract. Why? Because \nof the mysterious fin construct, as we discuss next. 7.1 Using fin in contract wrappers Suppose we have \nthe top-level de.nition bot = bot;that is,bot diverges. Now consider e = (BAD,BAD) and t = {x | bot}. \nThen e . t (since e is not crash-free). If we did not use fin in the de.nition of e< (Figure 5), eet \nwould reduce to this term: case bot of { True -> (BAD, BAD); False -> BAD } This term is contextually \nequivalent to bot itself, and so it is crash\u00adfree, contradicting our main theorem(\u00a75). What to do? Execution \nhas gotten stuck evaluating the diverging contract, and has thereby missed crashes in the term itself. \nOur solutionistolimittheworkthatcanbespenton contractevaluation. The actual de.nition of e< makes eet \nequal to case (fin0 bot) of { True -> (BAD, BAD); False -> BAD } The operational semantics of fin (Figure \n2) gives a .nite M units of fuel to each fin. Each reduction under a fin increases the subscript on the \nfin until it reaches the maximum M (rule [E\u00ad.n1]). When the fin subscript n reaches the limit M , fin \ngives up and returns True (rule [E-.n4]).Now,intheaboveexample, for any .nite M, we have . * eet (BAD,BAD) \nSo we de.ne our full-scale reduction relation . * in terms of . * M : DEFINITION 8. We say thate . * \nval iffthere exists N suchthat for any M = N we have e . * val. M Under this de.nition, eet . * (BAD,BAD), \nand Theorem1holds. 7.2 Practical consequences This may all seem a bit complicated or arti.cial, but \nit is very straightforward to implement. First, remember that we are con\u00adcerned with static veri.cation, \nnot dynamic checking. Uses of fin are introducedonlyto check contract satisfaction,and areneverex\u00adecuted \nin the running program. Second, our technique to check that eet is crash-freeistooptimiseitandcheckforsyntacticsafety.To \nbefaithful to the . * semantics, we need only refrain from opti\u00admising (case (fin bot) of <alts>) to \nbot, thereby retain\u00ading any BADs lurking in <alts>. Since this particular optimisation is a tricky one \nanyway, it is quite easy to omit! In other words, in our static contract checking, we can safely omit \nfin and the rules [E-.n1-4]. By being careful with our de.nition of . *, we can retain Theo\u00adrem1 in its \nfull, bi-directional form. This approach is, of course, only available to us because we are taking a \nstatic approach to ver\u00adi.cation.Adynamic checker cannotavoiddivergencein contracts (since it must evaluate \nthem), and hence must lose the (.) direc\u00adtionof Theorem1,as indeedisthe casein[3].Toputit another way, \nshould our static checkerfail,wecannothave recourse toa dynamic check(as happensinhybrid systems), becauseifthe \ncon\u00adtract can diverge an otherwise perfectly correct program might di\u00adverge because the dynamic check \nloops. In any dynamic system, the run-time checks must terminate if they are to avoid changing the program \nsemantics. 8. Error Reporting Given f . t, we have shown that to check f . t, we check f et is crash-free \ninstead. What happens if f et is not crash-free? That means when we try to optimize the term f et to \nsome e ' and there are some residual BADsine ',what we can report to the programmer from the contract \nviolation? To know which function to blame [11], we need to give eachBAD a tag. That is BAD lbl where \nthe label lbl isa function name.For a function f with contract t, we check f et is crash-free or not, \nwhere BAD \"f\" UNR f et = f t f<t = ft e< e< UNR BAD \"f\" AresidualBAD \"f\" tells us that we should blame \nf. That means assuming f takes arguments satisfying their corresponding precon\u00additions, f failstoproducea \nresultthat meetsits postcondition.For example: {-#CONTRACTinc::{x|x>0} ->{z|z>x}#-} incx =x -1 after \noptimizing (i.e. simplifying) inc etinc, we have: \\x->(case x>0of True-> casex-1> xof True ->x-1 False \n-> BAD \"inc\" False -> UNR) We can report to the programmer at compile-time: Error: inc fails its postcondition \nwhen x > 0 holds x -1 > x does not hold This error message is generated directly from the path that \nleads to the BAD \"inc\". case x > 0 of True-> case x-1>xof False -> BAD \"inc\" How about precondition \nviolation? Suppose we know f . tf . If f is called in a function g with contract tg, recalling the reasoning \nin \u00a74.5, we shall check (.f.eg) . (tf . tg). That means we check: (.f.eg) e (tf . tg) is crash-free or \nnot. By the de.nition of e, we have: .f. ((eg (f <tf )) etg). In order to trace which function calls \nwhich function that fails which function s precondition , instead of using (f <tf ), we use: Inside lbl \nloc (f <tf ) The lbl is the function name( f in this case) and the loc indicates the location (e.g. (row,column)) \nof the de.nition of f in the source .le. For example, we have: f1x=1+inc x {-# CONTRACT f2 :: {x | True} \n#-} f2[] z= 0 f2(x:xs) z=ifx >zthen f1xelse0 In our system, since f1 lacks a contract, we inline it at \nevery call site, thus avoiding the necessity of supplying a contract for many trivial functions. (For \nrecursive functions see [39].) After optimizing f2 e {x | True}, we have: \\xs -> \\z -> case xs of [] \n-> 0 (x:y) -> case x > z of True -> Inside \"f1\" <l1> (Inside \"inc\" <li> (BAD \"inc\")) False -> ... Note \nthat, the \"inc\" in (BAD \"inc\") indicates which function s precondition is not ful.lled. Thus, the residual \nfragment enables us to give one counter-example with the following meaningful message at compile-time: \nError <l2>: f2 (x:y) z when x > z holds calls f1 which calls inc which may fail inc s precondition! where \nthe location <l2> indicates the location of the de.nition of f2 in the source .le. This error tracing \ntechnique is adapted from ESC/Haskell [38], which achieves the same goal as thatin [23]butina much simpler \nway. However, unlike [23] we have not yet formalised the correct\u00adness of its blame assignment. 9. RelatedWork \nStatic veri.cation of software is a .eld dense with related work, of which we can only summarise a limited \nfraction here. 9.1 Type systems In the functional language community, type systems have played signi.cant \nroles in guaranteeing better software safety. Advanced type systems, such as dependent types, have been \nadvocated to capture stronger properties. While full dependent type system (such as Cayenne [1]) is undecidable \nin general, Xi and Pfenning [37] have designed a smaller fragment based on indexed objects drawn from \na constraint domain C whose decidability closely follows that of the constraint domain. Typical examples \nof objects in C include linear inequalities over integers, boolean constraints, or .nite sets. In a more \nrecent Omega project [32], Sheard shows how extensible kinds can be built to provide a more expressive \ndependent-style system. In comparison, our approach is much more expressiveand programmer friendly as \nwe allowarbitrary functions to be used in the pre/post annotations without the need to encode them as \ntypes. It is also easier for programmers to add properties incrementally. Moreover, our symbolic evaluation \nis formulated to adhere to lazy semantics and is guaranteed to terminate when code safety is detected \nor when a preset bound on the unrollings of each recursive function is reached. Compared with the dependent \ntype approaches [37, 6, 32, 36] in general, we separate type and contract declarations so that type related \nwork (e.g. type inference) and contract related techniques can be developed independently. In HoareType \nTheory (HTT) [29, 28], higher-order predicates and recursive predicates can be used in speci.cations. \nAnother work along this line is [31]. We allow higher-order functions and re\u00adcursive functions to be \nused in contracts so in terms of these two aspects, we share the same expressiveness. As we use symbolic \nexecution, inlining and induction make the job of verifying such contracts easier compared withtheorem \nproving higher-order pred\u00adicates and recursive predicates. But our contracts do not contain quanti.ers \nwhile quanti.ers are supported in [29, 28, 31]. 9.2 Extended static checking In an inspiring sequence \nof papers [22, 14, 13, 4], Leino, Nelson, Flanagan, and their colleagues showed the feasibility of applying \nan extended static checker to Modula-3 and then Java. Since then, sev\u00aderal other similar systems have \nbeen further developed, including Spec# s and its automatic veri.er Boogie [2] that is applicable to \ntheC# language.Weadaptthe sameideaofallowing programmers to specify properties about each function (in \nthe Haskell language) with pre/post annotations, but also allow pre/post annotations to be selectively \nomitted where desired. Furthermore, unlike previous approaches based on veri.cation condition (VC) generation \nwhich rely solelyona theoremprovertoverify,we usean approach based on symbolic evaluation that can better \ncapture the intended seman\u00adtics of a more advanced lazy functional language. With this, our reliance \non the use of theorem provers is limited to smaller frag\u00adments that involve the arithmetical parts of \nexpressions. Symbolic evaluationgives us much better controlover the processof thever\u00adi.cation where \nwe have customised sound and effective simpli.\u00adcation rules that are augmented with counter-example guided \nun\u00adrolling. More importantly, we are able to handle speci.cations in\u00advolving recursivefunctions and/or \nhigher-order functions which are not supportedby either ESC/Java or Spec#. 9.3 Contracts Theideaof contract \nwas.rst establishedbyParnas[30]andpop\u00adularized by Meyer in its use in Eiffel [24]. More recently, Findler \nand Felleisen introduced the notion of higher-order contracts, in\u00adcludingacareful treatmentof blame [11]. \nThis paper unleasheda series of papers about contract checking in higher-order languages, including [3, \n10, 3, 18, 35, 12, 21, 20, 16]. Although theyshare a common foundation, these papers differ in their \nnotation and ap\u00adproach, which makes like-for-like comparisons dif.cult. Of these papers,theworkof Blumeand \nMcAllester[3]isbyfar the most closely related because theygive a declarative semantics for contract satisfaction, \nand prove a connection with the dynamic wrappers of Findler and Felleisen. Here is a brief summary of \nthe differences between someofthiswork, especially[3],andourown: We aim at static contract checking, \nfor a statically typed lan\u00adguage, whereas most of the related work deals with dynamic checks, orahybrid \nchecking strategy fora dynamically typed language.  We deal with a lazy language; all other related \nwork is for a strict languages. In particular, we give a crashing expression a contract Any while a contract \nis only given to non-crashing expressions in [11, 3, 10].  We deal with dependent function contracts \nwhich [10] does not.  We lay great emphasis on crashing and diverging contracts, which are either not \nthe focus of these other works, or are ex\u00adplicitly excluded. Our solution appears less restrictive than \n[3], by allowing crashing functions to be called within contracts ( non-total contracts in their terminology), \nwhile still support\u00ading Theorem 1 in both directions, rather than the less-useful (.) direction only. \n The telescoping property (Figure 6) is .rst discovered in [3], but it does not seem to be used in anyof \ntheir proofs, while we use it intensively to make manyproofs much simpler.  Findler and Blume discovered \nthat contracts are pairs of projec\u00adtions in [9, 10]. That means given a contract t, .e.Wt(e) is a projection \nwhere Wt isa wrapper function.Tobea projection  w.r.t. ., a function p must satisfy these two properties: \n1. p . p = p (idempotence) 2. p . 1 (result of projection contains no more information than its input) \nOur( et)and( <t)(i.e..x.(xet) and .x.(x<t))satisfy the idempotence property as shown in Figure 6, but \ndoes not satisfy (2). They only satisfy (2) under the condition that the input of the projection satis.es \nits contract t as shown in Fig\u00adure 6. Moreover, we discover the projection pair property (in Figure 6), \nwhich plays a crucial role in our proof. Blume&#38;McAllester dealt with recursive contracts, which we \ndo not. Inspired by [11, 3], Hinze et al. [18] implement contracts as a li\u00adbrary in Haskell and contracts \nare checked at run-time. The frame\u00adwork also support contract constructors such as pairs, lists, etc. \nAn\u00adother dynamic contract checking work is the Camila project [34] which use monads to encapsulate the \npre/post-conditions checking behaviour. Thehybrid contract checking framework [12, 21, 20, 16], in the\u00adory, \ncan be as powerful as our system. (Hybrid checking means a combination of static and dynamic contract \nchecking.) But in prac\u00adtice,oursymbolicexecution strategyadoptedfrom[38]givesmore .exibility to the veri.cation \nas illustrated in \u00a72.1. In [35],Wadler and Findler show how contracts .t withhybrid types and gradual \ntypesby requiring castsinthe source code.The casts are similarto the job of our e and <. 9.4 Other work \nIn [19], a compositional assertion checking framework has been proposed with a set of logical rules for \nhandling higher-order functions. Given arguments satisfying their precondition, they check whether function \nde.nition satis.es its postcondition and the checking is currently a manual proof based on the logical \nrules. Apart from our focus on automaticveri.cation, we cangiveprecise blame when a contract violation \nis detected. The work in [19] has the strengthinveri.cation,but notin assigning blames. Amongst the Haskell \ncommunity, there have been several works that are aimedatprovidinghigh assurance software throughvalida\u00adtion \n(testing) [5], program veri.cation (Programatica project [17]) or a combination of the two [8]. In the \nProgramatica project, P-Logic has been introduced to specify properties for Haskell pro\u00adgrams. P-Logic \nallows programmers to express relations among multiple functions and it is more comprehensive then contracts, \nwhich only allow programmers to specify pre/postcondition of one function. The design of P-Logic focuses \non proof construction while our focus is to .nd the right function to blame based on contract violation. \nCertainly, the more properties we can prove, the more precise the contract violation checking will be. \nSome design of P-Logic could be adopted in future. Our approach eliminates the effort of inventing and \nlearning a new logic together with its theorem prover. Furthermore, our veri.ca\u00adtion approach does not \ncon.ict with the validation assisted ap\u00adproachusedby[5,8]andcanplay complementary roles. Mitchells s \nCatch system statically infers the possibility of pattern matchingfailure, without anyhelp from the programmer \n[26, 25]. The domain of a function is described by a language of regular expressions, which is incomparable \nwith our contract language, and the technical details are very different. Moreover, Catch applies to \n.rst-order programs, so can be used only after a whole-program .rsti.cation transformation has removed \n(most of) the higher-order functions. In contrast, we analyse higher-order functions directly,in a modular \n(not whole-program) way. 10. Conclusion and FutureWork We have presented a sound and automatic static \nveri.cation tool for a functional language, Haskell. Based on contracts and sym\u00adbolic execution, our \napproach gives precise blame assignments at compile-time in the presence of higher-order functions and \nlazi\u00adness. We lay particular emphasis on allowing the programmer to use all of Haskell in contracts, \nincluding functions that may crash or diverge. We have developed a prototype implementation in the context \nof the Glasgow Haskell Compiler.It can prove some simple contract satisfaction checks,but is still incomplete \nfor more sophisticated examples involving the use of recursive functions in predicates, such as sorting \norAVL trees. Such predicates are also outside the reachofother staticcheckers,buttheyareimportantinHaskellpro\u00adgrams. \nThe shortcoming lies in the optimiser(\u00a75)and, in particular, the choiceof precisely whento inlinea function.Wehave \nmanual proofs of manyof our motivating examples (including sorting and AVL trees), and are working on \nheuristics to enable the optimiser to prove them too. In future, we may introduce conjunctive/disjunctive \ncontracts, re\u00adcursive contracts, and contracts with quanti.ers. Another impor\u00adtant direction is to offer \nways in which the programmer can help the system by suggesting suitable lemmas. Acknowledgments We would \nlike to thank Philip Wadler, Robby Findler, Matthias Felleisen, and the anonymous referees for their \ncareful comments. This work was partially supported by Microsoft Research through its Ph.D. Scholarship \nprogram. References [1] Lennart Augustsson. Cayenne -language with dependent types. In Proceedings of \nthe third ACM SIGPLAN interna\u00adtional conference on Functional programming, pages 239 250,NewYork,NY, \nUSA, 1998.ACM. [2] Mike Barnett,K. RustanM. Leino,andWolfram Schulte.The Spec# programming system: An \noverview. CASSIS, LNCS 3362, 2004. [3] Matthias Blume and David McAllester. Sound and complete models \nof contracts. J. Funct. Program., 16(4-5):375 414, 2006. [4]L.Burdy,Y. Cheon,D.Cok,M. Ernst,J. Kiniry,G.Leavens, \nK. Leino, and E. Poll. An overview of JML tools and applica\u00adtions, 2003. [5]Koen Claessen and John Hughes. \nSpeci.cation-based testing with QuickCheck. In Fun of Programming, Cornerstones of Computing, pages 17 \n40.Palgrave, March 2003. [6] Sa Cui,Kevin Donnelly, and Hongwei Xi.ATS:Alanguage that combines programming \nwith theorem proving. In Bern\u00adhard Gramlich, editor, FroCos, volume 3717 of Lecture Notes in Computer \nScience, pages 310 320. Springer, 2005. [7] Rowan Davies. Re.nement-type checker for standard ML. In \nAMAST 97: Proceedings of the 6th International Conference on Algebraic Methodology and Software Technology, \npages 565 566, London, UK, 1997. Springer-Verlag. [8] Peter Dybjer, Qiao Haiyan, and MakotoTakeyama.Verifying \nHaskell programs by combining testing and proving. In Pro\u00adceedings of Third International Conference \non Quality Soft\u00adware, pages 272 279. IEEE Press, 2003. [9] R. B. Findler, M. Blume, and M. Felleisen. \nAn investigation of contracts as projections. Technical report, University of Chicago Computer Science \nDepartment, 2006. Technical Report TR-2004-02. [10] Robert Bruce Findler and Matthias Blume. Contracts \nas pairs of projections. In Functional and Logic Programming, pages 226 241. Springer Berlin/Heidelberg, \n2006. [11] Robert Bruce Findler and Matthias Felleisen. Contracts for higher-order functions. In Proceedings \nof the seventhACM SIGPLAN international conference on Functional program\u00adming, pages 48 59,NewYork,NY, \nUSA, 2002.ACM. [12] Cormac Flanagan. Hybrid type checking. In Morrisett and Peyton Jones [27], pages \n245 256. [13] Cormac Flanagan, K. Rustan M. Leino, Mark Lillibridge, Greg Nelson, James B. Saxe, and \nRaymie Stata. Extended static checking for Java. In PLDI 02: Proceedings of the ACM SIGPLAN 2002 Conference \non Programming language design and implementation, pages 234 245, NewYork, NY, USA, 2002.ACM. [14] Cormac \nFlanagan and James B. Saxe. Avoiding exponential explosion: generating compact veri.cation conditions. \nIn POPL 01:Proceedingsofthe 28thACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, \npages 193 205,NewYork,NY, USA, 2001.ACM. [15] Tim Freeman and Frank Pfenning. Re.nement types for ML. \nIn PLDI 91:ProceedingsoftheACM SIGPLAN1991 confer\u00adence on Programming language design and implementation, \npages 268 277,NewYork,NY, USA, 1991.ACM. [16] Jessica Gronski and Cormac Flanagan. Unifyinghybrid types \nand contracts. In Eighth Symposium onTrends in Functional Programming, April 2007. [17] Thomas Hallgren. \nHaskell tools from the Programatica project. In Haskell 03: Proceedings of the 2003ACM SIG-PLAN workshop \non Haskell, pages 103 106, NewYork, NY, USA, 2003.ACM. [18] Ralf Hinze, Johan Jeuring, and AndresL\u00a8oh. \nTypedcon\u00adtracts for functional programming. In Functional and Logic Programming: 8th International Symposium, \npages 208 225, 2006. [19] Kohei Honda and Nobuko Yoshida. A compositional logic for polymorphic higher-order \nfunctions. In PPDP 04: Pro\u00adceedings of the 6thACM SIGPLAN international conference on Principles and \npractice of declarative programming,pages 191 202,NewYork,NY, USA, 2004.ACM. [20] Kenneth Knowles and \nCormac Flanagan. Type reconstruc\u00adtion for general re.nement types. In ESOP 07: Program\u00adming Languages \nand Systems, 16th European Symposium on Programming. Springer-Verlag, April 2007. [21]KennethKnowles, \nAaronTomb, Jessica Gronski, StephenN. Freund, and Cormac Flanagan. SAGE: Uni.edhybrid check\u00ading for .rst-class \ntypes, general re.nement types, and dy\u00adnamic (extended report). Technical report, UC Santa Cruz, 2006. \nhttp://sage.soe.ucsc.edu/sage-tr.pdf. [22] K. Rustan M. Leino and Greg Nelson. An extended static checker \nfor Modula-3. In CC 98: Proceedings of the 7th International Conference on Compiler Construction, pages \n302 305, London, UK, 1998. Springer-Verlag. [23] Philippe Meunier, Robert Bruce Findler, and Matthias \nFelleisen. Modular set-based analysis from contracts. In Mor\u00adrisett and Peyton Jones [27], pages 218 \n231. [24] Bertrand Meyer. Eiffel: The Language. Prentice Hall Interna\u00adtional, London, 1992. [25] Neil \nMitchell. Transformation and Analysis of Functional Programs. PhD thesis, UniversityofYork, 2008. [26] \nNeil Mitchell and Colin Runciman. Not all patterns, but enough: an automaticveri.er for partialbut suf.cient \npattern matching. In Haskell 08: Proceedings of the .rst ACM SIGPLAN symposium on Haskell, pages 49 60, \nNew York, NY, USA, 2008.ACM. [27] J. Gregory Morrisett and Simon L. Peyton Jones, edi\u00adtors. POPL 06: \nProceedings of the 33rd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Lan\u00adguages, Charleston, \nSouth Carolina, USA, January 11-13, 2006.ACM, 2006. [28] Aleksandar Nanevski, Amal Ahmed, GregMorrisett, \nand Lars Birkedal. Abstract predicates and mutable ADTs in Hoare Type Theory. In Rocco De Nicola, editor, \nESOP, volume 4421 of Lecture Notes in Computer Science, pages 189 204. Springer, 2007. [29] Aleksandar \nNanevski, Greg Morrisett, and Lars Birkedal. Polymorphism and separation in hoare type theory. In Pro\u00adceedingsofthe11thACM \nSIGPLAN International Conference on Functional Programming, Portland, Oregon, USA, Sept., pages 62 73, \n2006. [30]D.L.Parnas. Atechniquefor software module speci.cation with examples. Communicationsof theACM, \n15(5):330 336, May 1972. [31] Yann R\u00b4egis-Gianas and Franc\u00b8ois Pottier. A Hoare logic for call-by-value \nfunctional programs. In P Audebaud and C Paulin-Mohring, editors, MPC, volume 5133 of Lecture Notes in \nComputer Science, pages 305 335. Springer, 2008. [32] Tim Sheard. Languages of the future. In OOPSLA \n04: Companion to the 19th annualACM SIGPLAN conference on Object-oriented programming systems, languages, \nand appli\u00adcations, pages 116 119,NewYork,NY, USA, 2004.ACM. [33] The GHCTeam. The GlasgowHaskell Compiler \nuser sguide. www.haskell.org/ghc/documentation.html, 1998. [34] J Visser, J. N. Oliveira, Barbosa L. \nS., J. F. Ferreira, and A. Mendes. CAMILA revival: VDM meets Haskell. In Nico Plat and Peter Gorm Larsen, \neditors, OvertureWorkshop (co\u00adlocated with FM 05), 2005. [35] PhilipWadler and Robert Bruce Findler.Well-typed \nprograms can t be blamed. In Workshop on Scheme and Functional Programming, Sept 2007. [36] Edwin M. \nWestbrook, Aaron Stump, and Ian Wehrman. A language-based approach to functionally correct imperative \nprogramming. In Proceedingsof the 10thACM SIGPLAN In\u00adternational Conference on Functional Programming,Tallinn, \nEstonia, pages 268 279, Sept. 2005. [37] Hongwei Xi and Frank Pfenning. Dependent types in practical \nprogramming. In POPL 99: Proceedings of the 26thACM SIGPLAN-SIGACT symposium on Principles of programming \nlanguages,pages 214 227,NewYork,NY,USA, 1999.ACM. [38] Dana N. Xu. Extended static checking for Haskell. \nIn Haskell 06: Proceedings of the 2006 ACM SIGPLAN workshop on Haskell, pages 48 59,NewYork,NY, USA, \n2006.ACM. [39] Na Xu. Static Contract Checking for Haskell. PhD thesis, University of Cambridge, 2008. \nhttp://www.cl.cam.ac. uk/techreports/.     \n\t\t\t", "proc_id": "1480881", "abstract": "<p>Program errors are hard to detect and are costly both to programmers who spend significant efforts in debugging, and for systems that are guarded by runtime checks. Static verification techniques have been applied to imperative and object-oriented languages, like Java and C#, but few have been applied to a higher-order lazy functional language, like Haskell. In this paper, we describe a sound and automatic static verification framework for Haskell, that is based on contracts and symbolic execution. Our approach is modular and gives precise blame assignments at compile-time in the presence of higher-order functions and laziness.</p>", "authors": [{"name": "Dana N. Xu", "author_profile_id": "81100195505", "affiliation": "University of Cambridge, Cambridge, United Kingdom", "person_id": "P1300925", "email_address": "", "orcid_id": ""}, {"name": "Simon Peyton Jones", "author_profile_id": "81100271851", "affiliation": "Microsoft Research, Cambridge, United Kingdom", "person_id": "P1300926", "email_address": "", "orcid_id": ""}, {"name": "Koen Claessen", "author_profile_id": "81100206977", "affiliation": "Chalmers University of Technology, Gothenburg, Sweden", "person_id": "P1300927", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1480881.1480889", "year": "2009", "article_id": "1480889", "conference": "POPL", "title": "Static contract checking for Haskell", "url": "http://dl.acm.org/citation.cfm?id=1480889"}