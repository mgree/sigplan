{"article_publication_date": "01-21-2009", "fulltext": "\n FlexibleTypes Robust type inferencefor .rst-classpolymorphism Daan Leijen Microsoft Research daan@microsoft.com \nAbstract We present HML, a type inference system that supports full .rst\u00adclass polymorphism where few \nannotations are needed: only func\u00adtion parameters with a polymorphic type need to be annotated. HML is \na simpli.cation of MLF where only .exibly quanti.ed types are used. This makes the types easier to work \nwith from a programmers perspective, and simpli.es the implementation of the type inference algorithm. \nStill, HML retains much of the ex\u00adpressiveness of MLF, it is robust with respect to small program transformations, \nand has a simple speci.cation of the type rules with an effective type inference algorithm that infers \nprincipal types. A small reference implementation with many examples is available at: http://research.microsoft.com/users/daan/ \npubs.html. Categories and Subject Descriptors D.3.3[Programming Lan\u00adguages]: Language Constructs and \nFeatures Polymorphism General Terms Languages, Design, Theory Keywords First-class polymorphism, SystemF, \nMLF 1. Introduction Mosttype inference systemsusedin practicearebasedon Hindley-Milner type inference \n(Hindley 1969; Milner 1978; Damas and Milner 1982). This is an attractive type system since it has a \nsim\u00adple logical speci.cation, and an effective type inference algorithm that can automatically infer \nmost general, or principal, types for expressions without any further type annotations. Unfortunately, \nHindley-Milner inference does not support .rst-class polymorphic values, and only allows a simple form \nof polymorphism on let\u00adbound values. This is a severe restriction in practice. Even though uses of .rst-class \npolymorphism occur infrequently, there is usu\u00adally no good alternative or work around (see (Peyton Jones \net al. 2007) for a good overview). The reference calculusfor .rst-class polymorphismis SystemF whichisexplicitly \ntyped.As remarkedbyR\u00b4emy (2005) onewould liketohavetheexpressivenessofSystemFcombinedwiththe con\u00advenience \nof Hindley-Milner type inference. Unfortunately,full type inference for SystemFis undecidable(Wells 1999). \nTherefore, the onlywaytoachieveourgoalisto augment Hindley-Milnertypein- Permission to make digital or \nhard copies of all or part of this work for personal or classroom use is granted without fee provided \nthat copies are not made or distributed for pro.t or commercial advantage and that copies bear this notice \nand the full citation on the .rst page.To copyotherwise, to republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. POPL 09, January 18 24, 2009, Savannah, Georgia, \nUSA. Copyright c . 2009ACM 978-1-60558-379-2/09/01... $5.00 ference with just enough programmer provided \nannotations to make programming with .rst-class polymorphism practical. There is a long list of research \npapers that propose type infer\u00adence systems for SystemF(Peyton Jones et al. 2007;R\u00b4 emy 2005; Jones 1997; \nLe Botlan andR \u00b4 emy 2003; Le Botlan 2004; Odersky andL\u00a8emy 1999; Vytiniotis et al. 2006; aufer 1996; \nGarrigue andR\u00b4Dijkstra 2005; Leijen 2008a). All of these systems mostly differ in where type annotations \nare needed in the program, and how easy it isforthe programmerto determinewheretoputthemin practice. \nThe MLF type inference system (Le Botlan and R\u00b4 emy 2003; Le Botlan 2004) is the most expressive inference \nsystem to date, and requires type annotations on function parameters that are used at two or more polymorphic \ntypes. Despite its good properties, MLF has found little acceptance in practice, perhaps partly due to \nthe intricate type structure with both .exible and rigid quanti.ca\u00adtion, and a more involved type inference \nalgorithm. In this article, we present a simpli.cation of MLF, called HML, that uses only .exible types. \nThis simpli.es both the types and the inference algorithm, while retaining manyof the good properties \nof MLF. In particular: HMLisa simpli.cationand restrictionofMLF,andhasexactly the sameexpressivenessof \nImplicitMLF(Le BotlanandR\u00b4emy 2007).Anovel featureisthatHMLonly uses.exibletypesand avoids rigidly quanti.ed \ntypes completely. This makes types easier to work with from a programmers perspective, and we show that \nit also simpli.es the type inference algorithm.  HML hasaclear annotation rule: only function parameters \nwith a polymorphic type need to be annotated.  Asaconsequence,HMLisaconservativeextensionof Hindley-Milner: \nevery program that is well-typed in Hindley-Milner is also a well-typed HML program and type annotations \nare never required for such programs.  Thetype rulesofHML arevery similartoMLF, where.exible types enable \nprincipal derivations where every expression can be assigned a most general type. This allows a programmer \nto use modular reasoning about a program, and enables ef.cient type inference.  HML is very robust with \nrespect to small program transforma\u00adtions. It has the property that whenever the application e1 e2 is \nwell-typed, so is the abstraction apply e1 e2 and reverse application revapp e2 e1. Moreover, we can \nalways inline a let-binding, or abstract a common expression into a shared let\u00adbinding.We consider this \nan important property asit forms the basis of equational reasoning where we expect to be able to re\u00adplace \nequals by equals.  In the following section we give an overview of HML in practice. Section4presents \nthe formal logical type rules of HML followed by a discussion on the type equivalence and instance relation \n(Sec\u00adtion 5). Section 6 shows how any System F program can be ex\u00adpressed in HML. In Section 7 we discuss \na restriction of HML where all boundvalueshavea regular SystemFtype. Finally, Sec\u00adtion 8 and Section \n9 describe the uni.cation and type inference algorithm. 2. Anoverview As said in the introduction, one \nwould like to have a language with theexpressivenessof SystemFcombinedwiththe convenienceof Hindley-Milner \ntype inference. However, since type inference for .rst-class polymorphism is undecidable in general (Wells \n1999) some type annotation are always needed. Previously proposed type inference systems that support \n.rst-class polymorphism mostly differ where such annotations are needed in the program, and how easy \nit is for the programmer to apply the those rules in practice. HML has a very clear annotation rule: \nfunction parameters with a polymorphic type need an annotation and that s it! In practice this means \nthat an annotation is only needed when de.ning a function with polymorphic parameters. Take for example \nthe following function: poly = .(f :: .a. a . a). (f 1, f True) The parameter f of the poly function \nmust be annotated with a polymorphictypesinceitisappliedtobothanintegerandaboolean value. In general, \none can never infer a type for such parameter since there are many possible types that f can have; for \nexample .a. a . a . a or .a. a . Int. Therefore HML simply requires annotations on all parameters with \na polymorphic type. These are the only annotations that are ever required, and poly\u00admorphic functions \nand data structures can be used freely without further annotations. Assuming the following de.nitions: \nid :: .a. a . a apply :: .a\u00df. (a . \u00df) . a . \u00df revapp :: .a\u00df. a . (a . \u00df) . \u00df HML can type poly id or \npoly (.x. x) for example. Impred\u00adicativeinstantiations are also inferred automatically.Forexample apply \npoly id, or revapp id poly, are accepted where the a quan\u00adti.er of apply and revapp is instantiated to \nthe polymorphic type .a. a . a. In general, HML is not sensitive to the order of ap\u00adplications and whenever \nthe application e1 e2 is accepted, so is apply e1 e2 and revapp e2 e1. This is an important property \nin practice since it allows us to apply the usual abstractions uniformly over polymorphic values too. \n2.1 Flexible types Type inference works well with data structures with polymorphic elements too. Assuming: \ninc :: Int . Int single :: .a. a . List a append :: .a. List a . List a . List a map :: .a\u00df. (a . \u00df) \n. List a . List \u00df we can for example map the poly function over a list of polymor\u00adphic identity functions \nas map poly (single id), where single id has type List (.a. a . a). Of course, sometimes a monomor\u00adphic \ntype is inferred the expression single id. Take for example append (single inc)(single id) where single \nid must get the type List (Int . Int).We can wonder now what happens when we share the single id expression, \nas in the following program: let ids = single id in (map poly ids, append (single inc) ids) Of course, \naccording to our annotation rule, this program is ac\u00adcepted as is in HML. This implies that we must be \nable to use ids both as a list of polymorphic elements, List (.a. a . a), and as a list of integer functions, \nList (Int . Int), even though these types are incomparablein SystemF. Toaddress this, HML uses.exible \ntypes to assignamost general type to ids, namely .(\u00df . .a. a . a). List \u00df.We can read this as for anytype \n\u00df that is an instance of .a. a . a, this is a list of \u00df ,andwecan instantiatethistypetobothoftheabovetypes,i.e.: \n.(\u00df . .a. a . a). List \u00df . List (.a. a . a) .(\u00df . .a. a . a). List \u00df ..a. List (a . a) .(\u00df . .a. a . \na). List \u00df . List (Int . Int) ... Flexible types are key to enable modular type inference where everyexpression \ncanbe assigneda most general,or principal, type. By putting the bound on the quanti.er, .exible types \nalso neatly keep track shared polymorphic types.Take forexample thechoose function: choose :: .a. a . \na . a Theexpression choose id can be assigned two incomparable types in System F, namely .a. (a . a) \n. a . a or (.a. a . a) . (.a. a . a). In HML, we can assign a principal type to this expression, namely \n.(\u00df . .a. a . a).\u00df . \u00df that can be instantiatedtobothoftheabove SystemFtypes. 2.2 Robustness Flexible \ntypes make the system very robust under rewrites. We have seen for example the system is insensitive \nto the order of arguments: whenever e1 e2 is accepted, so is apply e1 e2 and revapp e2 e1. Also, we can \nalways abstract or inline a shared ex\u00adpression: whenever let x = e1 in e2 is accepted, so is [x := e1 \n]e2, and the other way around, where we share a common ex\u00adpression throughalet-binding.Weconsider this \nan important prop\u00aderty as it stands at thebasis of equational reasoning where equals can be substituted \nfor equals. The system is not entirely robust with regard to .-expansion though since all polymorphic \nparameters must be annotated. For example we cannot .-expand poly to .f . poly f since f has a polymorphic \ntype, and we need to write .(f :: .a. a . a). poly f . In HML, we only allow.exible types on let-bindings \nand cannot pass values of a .exible type as an argument. Therefore, we cannot replace let-bindings with \na .exible type by lambda abstractions. This situation is similar in Hindley-Milner where only let-bindings \ncan have a quanti.ed type scheme and where lambda bindings are restricted to monomorphic types. Similarly, \nin HML only let\u00adbindings can have a .exibly quanti.ed type scheme and lambda bindings are restricted \nto regular SystemFtypes.  2.3 Implicit MLF Implicit MLF(iMLF) is a restriction of MLF where .exible \ntypes cannot be assigned to function parameters (Le Botlan and R\u00b4emy 2007). This restriction was introduced \nto make it possible to as\u00adsign a semantic meaning to .exible types in terms of System F types. Implicit \nMLF has no type annotations at all though and type inference is undecidable for this system. Le Botlan \nandR\u00b4emy de\u00adscribea decidablevariant called ExplicitMLF(eMLF) that needs annotations on all function \nparameters that are used at two or more polymorphic instances. Unfortunately, this annotation rule leads \nto the introduction of rigidly quanti.edtypes that complicate the type system and its inference algorithm(but \ndoes support .-expansion). HML can be seen as another decidable variant of Implicit MLF, and hasexactly \nthe sameexpressiveness. Thekey differenceisa slightly more conservativeannotation rule than eMLF where \nwe re\u00ad  an instance of a derived type, where we write Q . .1 . .2 to denote that .2 is an instance of \n.1 under a pre.x Q. The generalization rule GEN moves an assumed bounded type from the pre.x to the type, \neffectively generalizing over that type variable. The application rule APP requires the argument and \nparameter type to be equivalent.Note that since the parameter type occurs under the arrow, the types \nin an application are s types (and not type schemes). In contrast, the rule for let-bindings binds a \ngeneralized type scheme . to the binding variable. Therulefor lambdaexpressions FUN iskey totheHMLsys\u00adtem. \nLike Hindley-Milner, it restricts the type of the parameter to monomorphic types t only. As we saw in \nthe introduction, this is essential to avoid guessing polymorphic types. Note that it is still possible \nto derive a type for a parameter that has free type variables with a .exible bound. For example, for \nthe abstraction .x. choose id x,we can derive the principal type .(\u00df . .a. a . a).\u00df . \u00df without further \nannotations. At this point the reader may worry that it is possible to hide a polymorphic type in the \npre.x to derive polymorphic type for a parameterbutsuchisnotthe case:In particular,theinvariantthatall \nbounds in Q are non-trivially quanti.ed types . , ensures that we can never use the parameter x ina polymorphicway.We \ndiscuss this in more detail in Section 5.4 In order to pass polymorphic parameters, the rule FUN-ANN \nmustbeusedwherethe annotationis restrictedtoregularSystemF types s. In this rule, the annotated (polymorphic) \ntype of the pa\u00adrameteris assumedin the environment.Anicepropertyof HMLis that SystemFannotations onexpressions \ne :: s can be encoded as an application to an annotated identity function (.(x :: s). x) e. General annotations \non expressions would include .exible types though, and in practice we can add the following rule for \nexpres\u00adsion annotations: Q, G . e : . ANN Q, G . (e :: .): . Of course, expression annotations are never \nnecessary in a typ\u00ading derivation (as implied by our annotation rule in the introduc\u00adtion). 4.1 Some \nexample derivations As an example of a complete derivation using these type rules, we derive the type \nfor the expression single id under some initial pre.x Q0 and environment G. First, we show how we can \ndirectly derive the type List (.a. a . a) for single id, using sid as a shorthand for .a. a . a: Q0, \nG . single : .a. a . List a Q0 ..a. a . List a . (sid . List sid) Q0, G . single : sid . List sid Q0, \nG . id : sid Q0, G . single id : List (.a. a . a) Note that the instance relation includes the normal \nSystem F in\u00adstance relation and we can immediately instantiate the type of single to (.a. a . a) . List \n(.a. a . a). Of course, as shown in the introduction, the most general type in HML for single id is .(\u00df \n. .a. a . a). List \u00df,and we can derivethis type as follows, using Q1 as a shorthand for (Q0,\u00df . .a. a \n. a): Q1, G . single : .a. a . List a Q1, G . id : .a. a . a Q1 . .a. a . List a . \u00df . List \u00df Q1 . .a. \na . a . \u00df Q1, G . single : \u00df . List \u00df Q1, G . id : \u00df Q1, G . single id : List \u00df \u00df/. ftv(G) Q0, G . single \nid : .(\u00df . .a. a . a). List \u00df Since the pre.x contains the assumption (\u00df . .a. a . a), we know that \u00df \nwill be instance of .a. a . a and therefore, we can safely instantiate the type of id to \u00df (but not the \notherway around). It remains to makethis intuition precise, we de.ne the type instance (.)and type equivalence \nrelation(=)formally in the next section. 5. Type equivalence and type instance Before de.nining the type \ninstance(.)and equivalence relation (=), we .rst we establish some notation for substitutions. 5.1 Substitution \nA substitution . is a function that maps type variables to types. The empty substitution is the identity \nfunction and written as []. We write .x for the application of a substitution . to x where only the free \ntype variables in x are substituted.We often writea substitution as a .nite map [a1 := s1, ..., an := \nsn ] (also written as [a := s ])which mapsai to si and all other type variables to themselves.The domainofasubstitution \ncontainsalltypevariables that map to a different type: dom(.)= {a | .a .a}. The = codomain is a set of \ntypes and de.ned as: codom(.)= {.a |a . dom(.)}. We write (a := s) . . if a . dom(.) and .a = s. The \nexpression (. - a) removes a from the domain of ., i.e. (. - a)=[a := s | (a := s) . . . a/. a]. Finally, \nwe only consider idempotent substitutions . where .(.x)= .x (and therefore ftv(codom(.)) # dom(.)). \n5.2 Asemantic de.nition of type equivalence and instance The equivalence relationde.nes when types are \nconsidered equal and abstracts from syntactical artifacts like unbound quanti.ers or the order of quanti.ers. \nThe instance relation is an extension of the SystemFinstance relation that takes .exible bounds into \naccount. The standard SystemFinstance relation(.F)is de.ned as: \u00df # ftv(.a. s1) .a. s1 .F .\u00df. [a := s \n]s1 where we write(#)for disjoint sets. Note that only outer quanti\u00ad.ers can be instantiated, for example: \n.a. a . a .F Int . Int .a. a . a .F .\u00df. List (.a. a . \u00df) . List (.a. a . \u00df) To extend this de.nition \nto .exible types, we are going to interpret .exible types as sets of SystemFtypes.We can naturally interpret \na type .(a . s1).s2 as all instances of type s2 where a is an instance of s1. We write ... for the semantics \nof . as the set of SystemF types that are instances of ..For example, ..(\u00df . .a. a . a). List \u00df. is the \nset of types: {List (.a. a . a), .\u00df. List (\u00df . \u00df), List (Int . Int), ...} Following the approach in (Le \nBotlan andR\u00b4 emy 2007) we de.ne the semantics of types formally as: De.nition 1 (Semantics of types): \nThe semantics of a type ., written as ...,is the setof its SystemFinstances de.nedas: = ..a. a. ... = \n{s. | s .F s. } .s. ..(a . .1)..2. = {s. | s1 . ..1.,s2 . ..2., \u00df # ftv(.(a . .1)..2), s. . ..\u00df. [a := \ns1 ]s2.} Types are considered equivalent whenever their semantics are equal: De.nition2 (Type equivalence): \nWe write .1 = .2 for equiva\u00adlence between types. It holds if and only if ..1. = ..2.. In contrast to \n(Implicit) MLF we do not de.ne equivalence under a pre.x which is a consequence of restricting the bounds \nin a pre.x EQ-VAR .(a . .).a = . EQ-SUBST .(a . .).. = [a := .]. a/. ftv(.2) EQ-FREE .(a . .1)..2 = .2 \n.1 = .2 EQ-CONTEXT .(a . .1).. =.(a . .2).. .1 = .2 EQ-PREFIX .(a . .)..1 =.(a . .)..2 EQ-COMM a1 .a1 \n. ftv(.2) / = a2 /a2 . ftv(.1) .(a1 . .1)(a2 . .2).. =.(a2 . .2)(a1 . .1).. Figure 3. Syntactic type \nequivalence. to non-trivial types only. As we will see in the Section 5.4 this is an essential part of \nHML to ensure that unannotated parameters cannot be assigned a polymorphic type. The de.nitionofthe instance \nrelation must stillbe stated undera pre.x Q though. In particular, we would like to have the following \nhypothesis rule to hold: (a . . ) . Q I-HYP Q . . . a This rule states that whenever we have the assumption \nthat a is an instance of . in the pre.x Q, we can instantiate that type . to a. The example type derivation \nof single id in the previous section shows an example of the use of this rule. Therefore, to de.ne instantiation, \nwe .rst give an interpretation of pre.xes.A pre.x Q is meant to capture all the possible types that may \nbe substituted for the type variables in the domain of the pre.x, and we interpret a pre.x as a set of \nsubstitutions. De.nition3 (Semantics of pre.xes): The semantics of a pre.x Q is written as .Q., and represents \nthe set of SystemFsubstitutions that capture all possible types that can be substituted for the type \nvariables in the domain of Q.We de.ne this formally as: = {[]} .\u00d8. .Q,a . . . = {. . [a := s ] | . . \n.Q.,s . .. .} We can now de.ne the instance relation simply as a subset relation on the setof SystemFinstances: \nDe.nition4 (Type instance): We write Q . .1 . .2, if a type .2 isan instanceofatype .1 undera pre.x Q. \nIt holds if and only if forall . . .Q., we have ...2. . ...1.. Usually, we write .1 . .2 when \u00d8 . .1 \n. .2. 5.3 Asyntactic de.nition of equivalence and instantiation In practice, a semantic de.nition is \nnot always easy to work with, and we discuss an equivalent formulation of equivalence and in\u00adstantiation \nbased on syntactic rules that are inductive. In particular, we can de.ne equivalence as the smallest \ntransi\u00adtive, symmetric, and re.exiverelation that satis.es the rules of Fig\u00adure 3. The .rst two rules \nare the most interesting: the rule EQ-VAR inlines the bound of a variable type that is directly quanti.ed, \nand EQ-SUBST allows the inlining of trivial . bounds (that can no longer be instantiated). The rules \nEQ-FREE andEQ-COMM ensure that un\u00adbound quanti.ers are irrelevant, and that quanti.ers can be rear- I-BOTTOM \nQ . . . . I-EQUIV .1 = .2 Q . .1 . .2 I-HYP (a . .) . Q Q . . . a I-SUBST a /. etv(.) Q . .(a . s). . \n. [a := s ]. I-CONTEXT Q . .1 . .2 Q . .(a . .1). . . .(a . .2). . I-PREFIX (Q, a . .) . .1 . .2 a /. \ndom(Q) Q . .(a . .). .1 . .(a . .). .2 Figure 4. Syntactic type instance. ranged. The rules EQ-CONTEXT \nand EQ-PREFIX allow us to apply equivalence aribrarily deep inside a type. Similarly, we de.ne the instance \nrelation as the smallest transi\u00adtive relationthat satis.estherulesofFigure4.Therule I-EQUIVin\u00adcludes \nthe equivalence relation. The rule I-BOTTOM shows that bot\u00adtom can be instantiated to anytype. The substitution \nrule I-SUBST allows us to inline an instantiated bound s. A small technicality is that the bound should \nnot occur in the exposed type variables, de.ned as: etv(.)= \u00d8 etv(c s1 ... sn)= \u00d8 etv(a)= {a} etv(.(a \n. .1)..2)= etv(.1) . (etv(.2) -{a}) This condition prevents the loss of sharing through trivial bounds. \nFor example, take the type.(a . s).a . a which is equivalent to .(a . s). .(\u00df . a). .(. . a).\u00df . ..Without \nthe condition, we would be able to conclude in error that we can instantiate this type to .(\u00df . s). .(. \n. s).\u00df . . where the original sharing is lost and where \u00df and . can be instantiated separately. Finally, \nthe rules I-CONTEXT and I-PREFIX ensure that we can apply instantiation arbitrarily deep inside bounds. \nTheorem 5 (Syntactic type equivalence and instance is sound): The semantic de.nitions of type equivalence \nand type instance satisfy all the rulesin Figure3and Figure4. Conjecture 6 (Syntactic type equivalence \nand instance is com\u00adplete): Anytype equivalence and instance relation can be derived using the rulesin \nFigure3and Figure4. The proof of soundness is straightforward induction on the equiv\u00adalence and instance \nrules and similar to the proof of soundness for the iMLF instance relation in (Le Botlan andR\u00b4 emy 2007). \nIn the same work,R\u00b4emy and Le Botlan conjecture the completeness of the iMLF relation based on a proof \nsketch based on an intermedi\u00adate graphic representationof types(R\u00b4emy andYakobowski 2007).  5.4 Restricted \nequivalence The equivalence relation in HML differs from the one of (Implicit) MLFasitisnot statedunderapre.x.Thisisan \nimportant technical distinction to maketype inference decidable for HML. In particular, iMLF allows the \nequivalence relation to inline trivial bounds from the pre.x: (a . .2) . QQ . .2 = .2 IEQ-HYP Q . .1 \n= [a := .2 ].1  ftype(.)= ft(nf (.)) where ft(s)= s ft(.)= .a. a ft(.(a . .)..)= .a. ft(.) ft(.(a . \n.Q..)..)= ft(.Q. [a := .].) Figure 7. Forcea.exibletypetoa SystemFtype. ii. If ftype(.)= s then we have \n. . s. Formally, HMLF consists of the normal HML type rules given in Figure 2, where the LET rule is \nreplaced by the rule LET-F de.ned in Figure 8. The rule LET-F requires that the type .1 derived for e1 \nis the most general type possible, i.e. forall .0 such that Q, G . e1 : .0 holds, we have that Q . .1 \n. .0. The restriction to most general typesis neededto ensure thatwestillhaveprinciple type derivations. \nFinally, the derived type for e1 is instantiated to a System F type using the function ftype(.1) and \nbound in the environment. Anice property of HMLF, is that we can give a clear (but con\u00adservative) annotation \nrule for let-bindings: Only let bindings with a higher-rank type may require an annotation. As a consequence, \nHMLF is stilla conservativeextensionof Hindley-Milner.Forex\u00adample, the following expression: let ids \n= single id in append (single inc) ids is accepted without annotations where ids gets the expected Hindley-Milner \ntype .a. List (a . a). To construct a list of polymorphic elements though, we need to add an annotation: \nlet ids =(single id :: List (.a. a . a)) in map poly ids to accept this program in HMLF. The annotation \nrule is clear,but abit conservative.Forexample,no annotationis needed whenthe most general typeofa let-bindingis \nalreadya plain SystemFtype (since ftype(s) equals s).Forexample, the following bindings are accepted \nwithout further annotations: let ids =(single id :: List (.a. a . a)) xs = cons id ids ys = tail ids \nzs = map id (tail (cons id ids)) All of the above bindings have a principal type that is already a SystemFtype(List \n(.a. a . a)),and no annotations are needed. Only when the most-general type of a let-binding is a .exible \ntype, and we have a choice whichSystemFtypes we can assign, an annotation may be required. If there is \nno annotation, HMLF always disambiguates .exible types in a prede.ned way that leads the SystemFinstance \nwith the least inner polymorphism. Note that restricting let-bindings to System F types makes HMLF less \nexpressive than HML, since we can no longer share an expression like ids at different polymorphic instances, \ni.e. in contrast to HML, the program: let ids = single id in (map poly ids, append (single inc) ids) \nis always rejected in HMLF asthereexists no SystemF type for ids to make this well typed. In practice, \na language may choose to use rule LET-F if a let binding is unannotated, while still allow\u00ading the programmer \nto annotate such bindings with .exible types, maintaining the expressiveness of original system. Q, G \n. e1 : .1 ..0. if Q, G . e1 : .0 then Q . .1 . .0 Q, (G, x : ftype(.1)) . e2 : .2 LET-F Q, G . let x \n= e1 in e2 : .2 Figure 8. Environment restricted to SystemFtypes. 7.1 Acomparison with FPH At this point \nit is interesting to compare HMLF with the recently introduced FPH system (Vytiniotis et al. 2008). The \nFPH type sys\u00adtem supports .rst-class polymorphism and has a similar annotation rule as HMLF:all polymorphic \nparameters mustbe annotated, and only let-bindings with a higher-rank type may require an annota\u00adtion. \nFPH achieves this by distinguishing between inferred boxy types and known regular types. An advantage \nof this approach is that FPH does not need to require most general types at let-bindings as in HMLF.Adrawback \nthough is that FPH cannot always assign principal typestoexpressions.Forexample,thetypeof single id can \nhave both the (incomparable) types .a. List (a . a) and List ( .a. a . a ) in FPH,but we cannot assigna \nprincipal type like .(\u00df . .a. a . a). List \u00df as in HMLF . Given the similar annotation rules, we were \nhoping that the expressiveness of HMLF would co\u00a8incide with FPH but HMLF accepts slightly more programs \ndue to the following reasons: FPH restricts functionresults to unquanti.ed . types.Forexam\u00adple, if we \nhave a function foo :: (Int . (.a. a . a)) . Int, then the application poly (.x. x) is accepted,but the \nsimilar application foo (.y..x. x) is rejected (since(.y..x. x gets the type .a\u00df. a . \u00df . \u00df which is \nnot polymorphic enough). In HMLF, the sub-expression .y..x. x has the principal type .a. .(\u00df . .a. a \n. a).a . \u00df and both applications are accepted.  FPH restricts the type of let-bindings to non-boxy types \nonly, evenif the typeis unambiguous.Take forexample our earlier example that is accepted in HMLF:  let \nxs = cons id ids FPH rejects this de.nition without annotation since the result type contains boxes (similarly, \nthe previous ys and zs de.ni\u00adtions are also rejected). Therefore, even though FPH and HMLF are not equal, \nwe conjec\u00adturethatFPHisapure restrictionofHMLF,whichis itselfarestric\u00adtionof HML.To bring these systemscloser, \nwe can restrict HMLF further by allowing function results with . types only,but unfor\u00adtunately we have \nnot yet found a satisfactory formalization for the latter of the above restrictions. 8. Uni.cation Uni.cation \nof .exible types is more involved than the usual uni\u00ad.cation used in Hindley-Milner, but is easier than \nstandard MLF uni.cation since there are no rigid bounds, and we no longer have to compute polynomial \nweights over types (Le Botlan 2004). The uni.cation algorithm usestwo kindsof substitutions, namelyapre\u00ad.x \nQ and a normal substitution .. In actual implementations both substitutions are usually merged and implemented \ndirectly using updateable references on typevariables (see (Leijen2008b) fora reference implementation). \nAgain, we have as an invariant that Q only contains bounds with quanti.ed types. Dually, the substitu\u00adtion \n. containsonlyFtypes:if . . codom(.) then nf (.)= s for some s. Before discussing the actual uni.cation \nalgorithm,we .rst lookattwo helper functionsover pre.xesde.nedin Figure11.  (update the pre.x) update(Q,a \n. .2) let (Q0, (Q1,a . . 1, Q2)) = split(Q, ftv(.2)) if (nf (.2)= .) then return ((Q0, Q1, [a := .]Q2), \n[a := .]) else return ((Q0, Q1,a . .2, Q2), [ ]) update(Q,a := s) let (Q0, (Q1,a . ., Q2)) = split(Q, \nftv(s)) return ((Q0, Q1, [a := s ]Q2), [a := s ]) (extend a pre.x extend(Q,a . .)= if (nf (.)= .) then \nreturn (Q, [a := .]) else return ((Q,a . .), [ ]) (split a pre.x) split :: (Q,a) . (Q, Q) split(\u00d8,a)= \nreturn (\u00d8, \u00d8) split((Q,a . . ),a)= with a . a let (Q1, Q2)= split(Q, ((a - a) . ftv(.))) return ((Q1,a \n. . ), Q2) split((Q,a . . ),a)= with a/. a let (Q1, Q2)= split(Q,a) return (Q1, (Q2,a . . )) Figure 11. \nHelper functions. 8.3 Subsumption and type scheme uni.cation The subsumption algorithm subsume(Q, s, \n.) in Figure 10 takes a pre.x Q, an F-type s and a .exible type ., and returns a new pre.x Q. and a substitution \n., such that Q. . .. . .s. The algorithm is very similar to HMF subsumption (Leijen 2008a). It .rst skolemizes \nthe s type and instantiates ., and uni.es the remaining unquanti.ed types. Next, we need to ensure that \nno skolem constants escape into the environment which is done by checking that the relevant parts of \nthe pre.x and substitution do not contain anyintroduced skolem constant. Finally, unifyScheme(Q,.1,.2) \nin Figure 10 uni.es two.ex\u00adible types and returns a new pre.x Q., a subsitution . and a type . such that \n. is the most general type where Q. . ..1 . . and Q. . ..2 . .. Note how the split function is used here \nto generalize over the result type .. 9. Type inference The type inference algorithm for HML is de.ned \nin Figure 12 and is very similar to MLF inference. It is surprisingly straightforward since the uni.cation \nalgorithm is rather powerful. The rule for variables just looks up the type in the environment. Inference \nfor let bindings is very simple and we only need to bind the inferred type for the bound expression in \nthe environment. For a lambda expression, we assume a fresh type a for the parameter x. After doing inference \nfor the body, we check if the inferred type for x is a monotype. This is to prevent inferring polymorphic \ntypes for function parameters as required by the FUN type rule. This check is suf.cient because we also \nensure that Q only contains polymorphic bounds. Afterwards split is used to generalizeoverthe resulttype.The \nresulttypeis.exibly quanti.ed infer :: (Q, G, e) . (Q, ., .) infer(Q, G, x)= return (Q, [], G(x)) infer(Q, \nG, let x = e1 in e2) let (Q1,.1,.1)= infer(Q, G, e1) let (Q2,.2,.2)= infer(Q1, (.1G, x : .1), e2) return \n(Q2,.2 . .1,.2) infer(Q, G,.x. e)= assume a, \u00df are fresh let (Q1,.1,.1)= infer((Q,a . .), (G, x : a), \ne) fail if not(.1a = t ) for some t let (Q2, Q3)= split(Q1, dom(Q)) let (Q3. ,.3. )= extend(Q3,\u00df . .1) \nreturn (Q2,.1, .Q3. ..1a . .3. \u00df) infer(Q, G,.(x :: s). e)= assume \u00df is fresh, s is closed let (Q1,.1,.1)= \ninfer(Q, (G, x : s), e) let (Q2, Q3)= split(Q1, dom(Q)) let (Q3. ,.3. )= extend(Q3,\u00df . .1) return (Q2,.1, \n.Q3. .s . .3. \u00df) infer(Q, G, e1 e2)= assume a1,a2,\u00df are fresh let (Q1,.1,.1)= infer(Q, G, e1) let (Q2,.2,.2)= \ninfer(Q1,.1G, e2) let (Q2. ,.2. )= extend(Q2,a1 . .2.1,a2 . .2,\u00df . .) let (Q3,.3)= unify(Q2. ,.2. a1,.2. \na2 . \u00df) let (Q4, Q5)= split(Q3, dom(Q)) return (Q4,.3 . .2 . .1, .Q5..3\u00df) Figure 12. Type inference. \nusing (\u00df . .1).For example, the most general type for the const function is: const :: .a. .(. . .\u00df. \u00df \n. a).a . . (inferred) const = .x..y. x whereitstypecanbe instantiatetobothoftheusualSystemFtypes that \nwe can assign to the const function: .a. .(. . .\u00df. \u00df . a).a . . ..a\u00df. a . \u00df . a .a. .(. . .\u00df. \u00df . a).a \n. . ..a. a . (.\u00df. \u00df . a) This means that we need no special rules for deep instantiation or prenex conversions \non types (Peyton Jones et al. 2007). The application case .rst infers the types .1 and .2 for the expressions \ne1 and e2. It then uni.es the types a1 and a2 . \u00df under a pre.x that assumes (a1 . .2.1), (a2 . .2), \nand an unconstrained (\u00df . .). Finally, it generalizes the result using split. Theorem 11 (Soundness of \ninference): Ifinfer(Q0, G, e) succeeds with (Q, ., .), then Q, (.G) . .e : .. holds where Q0 . Q. Theorem \n12 (Completeness of inference): Assume a Q0 where ftv(G) . dom(Q0) and Q0 . Q. If Q, G . e : . holds \nthen infer(Q0, G, e) succeeds too withaprincipal solution (Q.,..,..), such that Q. . .... . . and Q. \n. Q. Wehave donea paperand pencil proofof soundnessbutwehave not done all cases of the completeness proof \nyet. Since the algo\u00adrithm is basically a simpli.cation of the usual MLF inference algo\u00adrithm, the proofs \nare very similar in structure to the ones for MLF (Le Botlan 2004). One way to potentially simplify the \nproofs is to formulate the inference algorithm in terms of recent work on MLF uni.cation usingagraphical \nrepresentationof MLF types(R \u00b4 System Types Flexible types on bindings Annotations HMF Regular F-types \nNo On polymorphic parameters and ambiguous impredicative applications FPH HMLF Boxy F-types Flexible \nF-types No No On polymorphic parameters and some let bindings with higher-rank types On polymorphic parameters \nand some let bindings with higher-rank types HML MLF Flexible F-types Flexible and Rigid Let-bound only \nLet-and .-bindings On polymorphic parameters On parameters that are used polymorphically Figure 13. Ahigh \nlevel comparision between different inference systems.  emy andYakobowski 2007)but thisis stillworkin \nprogress. 9.1 Implementing HMLF The HMLF variant is very straightforward to implement. Since the algorithm \nby construction always derives most-general types, we just need to call the ftype function when binding \na let-bound value in the environment: infer(Q, G, let x = e1 in e2) let (Q1,.1,.1)= infer(Q, G, e1) let \n(Q2,.2,.2)= infer(Q1, (.1G, x : ftype(.1)), e2) return (Q2,.2 . .1,.2) and no further changes are required. \n10. Related work MLFwas .rst describedbybyR\u00b4emyandLe Botlan (2004; 2003; 2007; 2007). The extension of \nMLF with quali.ed types is de\u00adscribedin (Leijen andL\u00a8oh 2005). Leijen latergivesa type directed translation \nof MLF to System F and describes Rigid-MLF (Lei\u00adjen 2007), a variant of MLF that does not assign polymorphically \nboundedtypesto let-boundvaluesbut internallystillneedsthefull inference algorithm of MLF. R\u00b4emy and Le \nBotlan introduce Implicit MLF (2007) as a sim\u00adpler version of MLF where only let-bindings can have types \nwith .exible quanti.cation. This simpli.cation allows them to give a semanticsof .exible typesin termsofsetsof \nSystemFtypes. Un\u00adfortunately, inferencefor Implicit MLFis undecidable. Thevariant with type annotations \nis introduced as eMLF and uses rigid quan\u00adti.cation to enable type inference. Leijen describes HMF (Leijen \n2008a): a type inference sys\u00adtem for .rst-classpolymorphism that is based on regular Hindley-Milner inference. \nAnnotations are required onfunction parameters with a polymorphic type and on all ambiguous impredicative \nap\u00adplications. Even though the annotation rule is harder than that of HML or MLF, it represents an interesting \ndesign point since the speci.cation and the type inference algorithm are very simple: the declarativetype \nrules use only regular SystemFtypes and the in\u00adference algorithmisa smallextensionof algorithmW. Vytiniotis \net al. (2006) describe boxy type inference which is made principal by distinguishing between inferred \nboxy types, and checked annotated types.Acritique of boxy type inference is that its speci.cation hasastrong \nalgorithmic .avor which can make it fragile under small program transformations(R\u00b4 emy 2005). The FPH \ntype system (Vytiniotis et al. 2008) is an improvement on earlier work and also uses boxy types to enable \ntype inference for .rst-class polymorphism. FPH only requires annotations on polymorphic parameters and \nmay require an annotation for let\u00adbindings with a higher-rank type. See also Section 7.1 for a more detailed \ncomparison with HML. As a reference, Figure 13 gives a high-level comparison be\u00adtween these proposed \ntype systems for .rst-class polymorphism. Note that type inference for HMF is signi.cantly simpler than \nfor the other systems in this table. Also, systems that allow .exible types on let-bindings (MLF and \nHML) add true expressiveness since theyallow the sharing of values at different polymorphic in\u00adstances(as \nshownin Section 2.1 and Section7). To the best of our knowledge, a type inference algorithm for the simplytypedlambda \ncalculuswas.rst describedbyCurryandFeys (1958). Later, Hindley (1969) introduced the notion of principal \ntype, proving that the Curry and Feys algorithm inferred most gen\u00aderal types. Milner (1978) independently \ndescribed a similar algo\u00adrithm,but also introduced the important notion of .rst-order poly\u00admorphism where \nlet-bound values can have a polymorphic type. Damas and Milner (1982) later proved the completeness of \nMil\u00adner s algorithm, extending the type inference system with poly\u00admorphic references (Damas 1985).Wells \n(1999)shows that general type inference for unannotated SystemFis undecidable. Jones (1997) extends Hindley-Milner \nwith .rst class polymor\u00adphismbywrapping polymorphicvalues into type constructors. This isasimpleandeffectivetechniquethatiswidelyusedinHaskellbut \none needs to de.ne a special constructor and operations for every polymorphic type. Garrigue andR\u00b4emy \n(1999) usea similar tech\u00adniquebut can usea generic box operation to wrap polymorphic types. OderskyandL\u00a8aufer \n(1996) describea type system that has higher-rank typesbut no impredicative instantiation. Peyton Jones \net al. (2007) extend this work with type annotation propagation. Dijkstra (2005) extends this further \nwith bidirectional annotation propagation to support impredicative instantiation. 11. Conclusion WepresentedHML,atype \ninference system that supports full .rst\u00adclass polymorphism with few annotations: only function parame\u00adters \nwith a polymorphic type need to be annotated. It has logical type rules with principal derivations where \n.exible types ensure thateveryexpressioncanbe assignedamostgeneraltype.Thetype inference algorithm is \nstraightforward and we have implemented a reference implementation that represents substitutions using \nup\u00addateable references and uses ranked type variables to do ef.cient generalization (Leijen 2008b). Given \nthese good properties of HML, we think it can be an excellent type system in practice for languages that \nsupport .rst\u00adclass polymorphic values. References H. Curry and R. Feys. Combinatory Logic, volume 1. \nNorth-Holland, 1958. Luis Damas. Type Assignment in Programming Languages. PhD thesis, University of \nEdinburgh, April 1985. Technical report CST-33-85. Luis Damas and Robin Milner. Principal type-schemes \nfor func\u00adtional programs. In 9thACM symp. onPrinciples of Program\u00ad ming Languages (POPL 82), pages 207 \n212, 1982. Atze Dijkstra. Stepping through Haskell. PhD thesis, Universiteit Utrecht, Nov. 2005. JacquesGarrigue \nand DidierR\u00b4emy. Semi-explicit .rst-class poly\u00admorphism for ML. Journal of Information and Computation, \n155:134 169, 1999. J.R. Hindley. The principal type scheme of an object in combina\u00adtory logic. Transactions \nof the American Mathematical Society, 146:29 60, Dec. 1969. MarkP. Jones. First-class polymorphism with \ntype inference. In 24thACM Symposiumon PrinciplesofProgrammingLanguages (POPL 97), January 1997. GeorgeKuan \nand David MacQueen. Ef.cient ML type inference using ranked type variables. In The 2007ACMSIGPLANWork\u00adshop \non ML (ML 2007), Freiburg, Germany, October 2007. Didier Le Botlan. MLF:Une extension de ML avec polymorphisme \nde second ordre et instanciation implicite. PhD thesis, INRIA Rocquencourt, May 2004. Also in English. \nDidierLe Botlanand DidierR\u00b4emy. MLF: RaisingMLtothepower of System-F. In The International Conference \non Functional Programming (ICFP 03), pages 27 38, aug 2003. Didier Le Botlan and Didier Remy. \u00b4Recasting \nMLF. Research Report 6228, INRIA,Rocquencourt, BP 105, 78 153 Le Chesnay Cedex, France, June 2007. Daan \nLeijen. HMF: Simple type inference for .rst-class poly\u00admorphism. In 13thACM symp. of the InternationalConference \non Functional Programming (ICFP 08), September 2008a. Ex\u00adtended version available as a technical report: \nMSR-TR-2007\u00ad118, Sep 2007, Microsoft Research. Daan Leijen. A reference implementation of HML. Available \nat http://research.microsoft.com/users/daan/pubs. html, April 2008b. Daan Leijen. Atype directed translation \nfrom MLF to System F. In The International Conference on Functional Programming (ICFP 07), Oct. 2007. \nDaan Leijen and AndresL\u00a8oh. Quali.ed types for MLF. In The In\u00adternational Conference on Functional Programming \n(ICFP 05). ACM Press, Sep. 2005. Robin Milner. A theory of type polymorphism in programming. Journal \nof Computer and System Sciences, 17:248 375, 1978. Martin Odersky andKonstantinL\u00a8aufer. Putting type \nannotations to work. In 23th ACM symp. on Principles of Programming Languages (POPL 96), pages 54 67, \nJanuary 1996. Simon Peyton Jones, Dimitrios Vytiniotis, StephanieWeirich, and Mark Shields. Practical \ntype inference for arbitrary-rank types. Journal of Functional Programming, 17(1):1 82, 2007. DidierR\u00b4Simple, \npartial type-inference for System-F based emy. on type-containment. In The International Conference on \nFunc\u00adtional Programming (ICFP 05), September 2005. DidierR\u00b4emy and BorisYakobowski. Agraphical presentation \nof MLF types withalinear-time uni.cation algorithm. In TLDI 07, pages 27 38, 2007. DimitriosVytiniotis, \nStephanieWeirich, and Simon Peyton Jones. Boxy types: type inference for higher-rank types and impredica\u00adtivity. \nIn The International Conference on Functional Program\u00adming (ICFP 06), September 2006. DimitriosVytiniotis, \nStephanieWeirich, and Simon Peyton Jones. FPH:First-class polymorphism for Haskell. In 13thACM symp. \nof the International Conference on Functional Programming (ICFP 08), September 2008. J.B.Wells.Typabilityandtype \ncheckinginSystem-Fareequivalent and undecidable. Ann. Pure Appl. Logic, 98(1 3):111 156, 1999. x : . \n. G VAR-G G . x : . G . e : .1 .1 . .2 INST-G G . e : .2 G . e : .2 a/. ftv(G) GEN-G G . e : .a. .2 G \n. e1 : .Q.s2 . s G . e2 : .Q.s2 APP-G G . e1 e2 : .Q.s G . e1 : .1 (G, x : .1) . e2 : .2 LET-G G . let \nx = e1 in e2 : .2 (G, x : t) . e : . a/. ftv(t ) FUN-G G . .x. e : .(a . .).t . a (G, x : s) . e : . \na/. ftv(s) FUN-ANN-G G . .(x :: s). e : .(a . .).s . a Figure 14. Type rules for HMLG . A. Restricting \nparameter types As shown in Section 4, the principal type of the expression .x. choose id x is .(\u00df . \n.a. a . a).\u00df . \u00df. This type can be instantiated to either the Hindley-Milner type .a. (a . a) . a . a, \nor the SystemFtype (.a. a . a) . (.a. a . a). The lattertypeis somewhat surprising areweabletoinferapolymor\u00adphic \ntype for the parameter after all? Of course, thederivation is sound since we are unable to use the parameter \npolymorphically in the body of the lambda expression. In that sense, the instantiation is equivalent \nto anyother impredicative instantiation. Nevertheless, one may want to disallow derivations where the \nfree type variables in a parameter type have a polymorphic bound. We call this system HMLG. The only \nchange to the type rules of HML would be in the FUN rule: Q, (G, x : t ) . e : s .Q.t =.a. t FUN-MONO \nQ, G . .x. e : t . s With this rule, the principal type of.x. choose id x becomes the Hindley-Milner \ntype .a. (a . a) . a . a. One may feel that this restriction is not very useful in practice but it has \nan interesting side effect that with this restriction there is no need anymore to state the type rules \nand type instantiation under a pre.x! Figure 14 de.nes HMLG formally where we no longer need anexplicit \npre.x. Therules VAR-G,INST-G,andGEN-G stay the same except that instantiation is no longer stated under \na pre.x. The application rule APP-G now requires that the types of the function and argument have the \nsame quanti.ers Q. This rule is also applicable in HML (and can be derived directly (Le Botlan 2004)). \nThe rule for let bindings is unchanged, and the rules for functions simply generalize directly over the \nresult type. Of course, even though the HMLG is simpler than HML, it is also less general. In particular, \nan .-expandedexpressionmay have a less general types than the original expression which may be undesirable \nin practice. B. Back to SystemF Interestingly,we can combine HMLF and HMLG such that we don t even need \n.exible types anymore. Figure 15 describes the type rules of HMLFG. The type rules should look very familiar \nsince they are just the rules of System F, extended with a rule for let x : s . G VAR-FG G . x : s G \n. e : s1 s1 .F s2 INST-FG G . e : s2 G . e : s a/. ftv(G) GEN-FG G . e : .a. s G . e1 : s2 . s G . e2 \n: s2 APP-FG G . e1 e2 : s G, x : t . e : s FUN-FG G . .x. e : t . s G . e1 : s1 minimal(s1) G, x : s1 \n. e2 : s2 LET-FG G . let x = e1 in e2 : s2 G . e1 : s1 G, x : s1 . e2 : s2 LET-ANN-FG G . let x : s1 \n= e1 in e2 : s2 G, x : s1 . e : s2 FUN-ANN-FG G . .(x :: s1). e : s1 . s2 Figure 15. Type rules for HMLFG \n. bindings, annotated functions, and annotated let bindings. Even thoughthisisarestrictionofHML,itmaybeinterestingin \npractice as programmersareonlyexposedtoregularSystemFtypesandcan reason about type derivations using \njust SystemFtypes! Of course,bygivingup .exible types, wedo nothave principal type derivations anymore.Forexample, \ntheexpression single id can have both the type List (.a. a . a) and .a. List (a . a). However, we are \ngoing to ensure that anylet-bound expression has a principal type through the rule LET-FG. In particular, \nthe constraint minimal(s1) should ensure the we can infer a unique principal type for the let-boundexpression.Wehave \nsome choice here for the de.nition of this constraint. A conservative choice would be to ensure that \ns1 is a Hindley-Milner rank-1 type, i.e. minimal(s) . s =.a. t By choosing this de.nition, let-bound \nexpressions with a higher rank type must be annotated (together with parameters with a polymorphic type).Asimilar \ntype system as this hasbeen described too as a restriction of boxy types (Vytiniotis et al. 2008). The \ninference algorithm of HML (Section 9) can readily be adapted to use the ftype function as described \nin Section 9.1 to instantiate the type of a let binding, and simply reject let-bound expressions with \na higher-rank type. Note that even though the type rules just use SystemFtypes, the type inference algorithm \nstill uses .exible types internally to represent the set of derivable System F types ef.ciently. Unfortunately, \nthe aboverestriction rejects manyprograms with unique higher-rank types, for example: let xs = cons id \nids We can also formulate a minimality constraint as in HMLF where we only allow the most general System \nF type with the least number of inner quanti.ers(or lowest rank). This variant can be implementedvery \neasilybyjust applyingthe ftype function on the inferred let-boundexpressionas describedin Section9.1.Weleave \na proper investigation of these different variants to future work.    \n\t\t\t", "proc_id": "1480881", "abstract": "<p>We present HML, a type inference system that supports full first-class polymorphism where few annotations are needed: only function parameters with a polymorphic type need to be annotated. HML is a simplification of MLF where only flexibly quantified types are used. This makes the types easier to work with from a programmers perspective, and simplifies the implementation of the type inference algorithm. Still, HML retains much of the expressiveness of MLF, it is robust with respect to small program transformations, and has a simple specification of the type rules with an effective type inference algorithm that infers principal types. A small reference implementation with many examples is available at: http://research.microsoft.com/users/daan/pubs.html.</p>", "authors": [{"name": "Daan Leijen", "author_profile_id": "81100572466", "affiliation": "Microsoft Research, Redmond, WA, USA", "person_id": "P1300930", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1480881.1480891", "year": "2009", "article_id": "1480891", "conference": "POPL", "title": "Flexible types: robust type inference for first-class polymorphism", "url": "http://dl.acm.org/citation.cfm?id=1480891"}