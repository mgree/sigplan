{"article_publication_date": "01-21-2009", "fulltext": "\n Feedback-Directed Barrier Optimization in a Strongly Isolated STM Nathan G. Bronson Christos Kozyrakis \nKunle Olukotun Computer Systems Laboratory Stanford University {nbronson, kozyraki, kunle}@stanford.edu \nAbstract Speed improvements in today s processors have largely been de\u00adlivered in the form of multiple \ncores, increasing the importance of abstractions that ease parallel programming. Software transactional \nmemory (STM) addresses many of the complications of concur\u00adrency by providing a simple and composable \nmodel for safe access to shared data structures. Software transactions extend a language with an atomic \nprimitive that declares that the effects of a block of code should not be interleaved with actions executing \nconcurrently on other threads. Adding barriers to shared memory accesses pro\u00advides atomicity, consistency \nand isolation. Strongly isolated STMs preserve the safety properties of trans\u00adactions for all memory \noperations in a program, not just those inside an atomic block. Isolation barriers are added to non\u00adtransactional \nloads and stores in such a system to prevent those accesses from observing or corrupting a partially \ncompleted trans\u00adaction. Strong isolation is especially important when integrating transactions into an \nexisting language and memory model. Isola\u00adtion barriers have a prohibitive performance overhead, however, \nso most STM proposals have chosen not to provide strong isolation. In this paper we reduce the costs \nof strong isolation by cus\u00adtomizing isolation barriers for their observed usage. The cus\u00adtomized barriers \nprovide accelerated execution by blocking threads whose accesses do not follow the expected pattern. \nWe use hot swap to tighten or loosen the hypothesized pattern, while pre\u00adserving strong isolation. We \nintroduce a family of optimization hypotheses that balance veri.cation cost against generality. We demonstrate \nthe feasibility of dynamic barrier optimization by implementing it in a bytecode-rewriting Java STM. \nFeedback\u00addirected customization reduces the overhead of strong isolation from 505% to 38% across 11 non-transactional \nbenchmarks; persis\u00adtent feedback data further reduces the overhead to 16%. Dynamic optimization accelerates \na multi-threaded transactional benchmark by 31% for weakly-isolated execution and 34% for strongly\u00adisolated \nexecution. Categories and Subject Descriptors D.3.4 [Programming Lan\u00adguages]: Processors Code generation, \nCompilers, Optimization, Run-time environments; D.1.3 [Programming Techniques]: Con\u00adcurrent Programming \n Parallel programming; D.3.3 [Program- Permission to make digital or hard copies of all or part of this \nwork for personal or classroom use is granted without fee provided that copies are not made or distributed \nfor pro.t or commercial advantage and that copies bear this notice and the full citation on the .rst \npage. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior \nspeci.c permission and/or a fee. POPL 09 January 18 24, 2009, Savannah, Georgia, USA. Copyright c . 2009 \nACM 978-1-60558-379-2/09/01. . . $5.00 public class BigDecimal { private volatile transient String stringCache; \npublic String toString() { if (stringCache == null) stringCache = layoutChars(true); return stringCache; \n} } Figure 1. A fragment of java.math.BigDecimal. The interface has immutable semantics, so it is dif.cult \nfor a programmer to detect accesses that are incorrect in a weakly isolated STM. ming Languages]: Language \nConstructs and Features Concurrent programming structures General Terms Algorithms, Design, Experimentation, \nLanguages, Measurement, Performance Keywords Transactional Memory, Strong Isolation, Weak Isola\u00adtion, \nHot Swap, Bytecode Rewriting, Deoptimization 1. Introduction Speed improvements in today s processors \nhave largely been de\u00adlivered in the form of multiple cores, increasing the importance of abstractions \nthat ease parallel programming. Software transactional memory (STM) addresses many of the complications \nof concur\u00adrency by providing a simple and composable model for safe access to shared data structures. \nSoftware transactions extend a language with an atomic primitive that declares that the effects of a \nblock of code should not be interleaved with actions executing concur\u00adrently on other threads. Implementation \ntechniques for atomic re\u00adgions have been studied extensively [1, 2, 6, 9, 10, 18, 23]. Unfor\u00adtunately, \nSTMs for imperative languages have struggled to provide good performance while retaining intuitive semantics. \n1.1 Strong vs. Weak Isolation An STM proposal that integrates atomic regions into an exist\u00ading imperative \nlanguage must de.ne the outcome when a non\u00adtransactional access is made to a memory location that is \nalso read or written by a transaction. A system in which non-transactional code cannot observe or corrupt \na partially completed transaction is said to provide strong isolation. The alternative is weak isola\u00adtion, \nin which consistency is guaranteed only when heterogeneous accesses do not occur. Strong isolation is \neasy for the programmer to reason about and straightforward to integrate into a language s memory model. \nGrossman et al. show how to add successful transactions to the set of actions included in Java s happens-before \nordering [8]. Strong isolation allows the programmer to ignore the effect of partially completed or failed \ntransactions when reasoning about the correct\u00adness of their program,1 and it allows the programmer to \nreason about whether or not a memory location is currently shared. The weakest form of isolation provides \ncorrect execution for a program only if each memory location is either never accessed in an atomic region \nor always accessed in an atomic region. Programs that violate this convention can observe arbitrarily \nbad behavior, including producing values from thin air. Libraries often hide stores to shared data inside \noperations that are semantically read-only, making it dif.cult or impossible to reason about the correctness \nof the whole program under weak isolation. As a speci.c example, consider the snippet of Java code in \nFig\u00adure 1. BigDecimal presents an immutable interface, so it is not un\u00adreasonable for a user to expect \nto be able to call toString() for a shared instance both inside and outside an atomic region. However, \nbecause weak isolation breaks the carefully de.ned semantics of volatile, the result might be a string \nfull of \\0 . In an STM that performs updates in-place, the non-transactional invocation might race with \nrollback of a transaction that populated the cache and sub\u00adsequently rolled back. A write-buffering STM \ncan cause a problem during a normal commit because the buffered writes may be issued in an order that \nviolates the Java memory model. Transaction isolation is broken when non-transactional code on a concurrent \nthread observes or affects the loads and stores used internally by the STM implementation. Those loads \nand stores are not actually performed atomically, so a direct access to memory is not a party to the \nSTM s illusion of serializability and consis\u00adtency. Concurrent execution with strong isolation requires \nthat non\u00adtransactional threads be prevented from observing the internal state of a partially completed \ntransaction by adding isolation barriers to non-transactional loads and stores [11]. Despite its subtle \nsemantics, weak isolation is attractive because it does not involve modi.cations to non-transactional \ncode. This lo\u00adcalizes any performance impact from atomic to code that actually uses transactions. As \na result there is now active research in mod\u00adels that constrain the STM s execution schedule to enable \nsome of the useful programming idioms precluded by weak isolation while avoiding the use of isolation \nbarriers [14,20,23]. These models still require whole-program reasoning by the programmer to establish \nthe correctness of individual critical regions. Static whole-program analysis has been used to identify \nisola\u00adtion barriers that may be safely removed [21]. This approach seems promising for environments that \ncan include such an analysis in their development work.ow, but is dif.cult to reconcile with the dynamic \nfeatures of managed languages such as Java and C#.  1.2 Our Contributions Research into weakly isolated \nsoftware transactions is predicated on the assumption that strong isolation adds a prohibitive perfor\u00admance \noverhead. In this paper we tackle those overheads by dy\u00adnamically optimizing isolation barriers while \npreserving strong iso\u00adlation:2 We construct a family of customized memory barriers that dy\u00adnamically \ncheck that accesses to a class s .eld or array ele\u00adments follow an optimization hypothesis. Conforming \naccesses are accelerated (often optimally), while threads that attempt a nonconforming access are blocked. \nWe include stateless access patterns and patterns that are sensitive to the object instance s history \n(Section 3). 1 We assume that the STM guarantees forward progress. 2 We compare our work to the concurrent \nresearch of Schneider et al. [19] in Section 9, Dynamic NAIT. // Initially x==0 // Thread 1 atomic { \n++x; ++x; } // Thread 2 r1 = x; assert (r1 % 2 == 0);  Figure 2. An intermediate dirty read in a weakly \nisolated STM. Thread 2 observes an inconsistent value for x because it ignores Thread 1 s lock. The middle \ncolumn represents the current value of x in memory, and the dotted line represents the dirty read. We \ndescribe how to hot swap barrier implementations in a running system, with minimal impact on unaffected \nthreads. We use this hot swap mechanism reactively to rescue threads blocked due to an incorrect optimization \nhypothesis (Section 5).  We use runtime pro.ling to identify .elds whose access pattern is compatible \nwith a more aggressive optimization hypothesis, and proactively hot swap the barriers for those .elds. \nBecause incorrect optimizations will be corrected by a reactive relax\u00adation, this dynamic analysis does \nnot need to be conservative or sound (Section 6).  We demonstrate the practicality of dynamic barrier \ncustomiza\u00adtion by implementing it in an STM for Java. Our evaluation shows that the dynamically optimizing \nsystem converges on the performance achieved by an oracle static analysis, the cost of hot swap is quickly \nrecovered, and barrier optimization reduces the overheads of both isolation and transaction barriers \n(Sec\u00adtion 8).  2. Barriers for Strong Isolation Strong isolation can be provided by adding barriers \nto non-transac\u00adtional code. Direct memory loads and stores from another thread can break a transaction \ns isolation because the STM implemen\u00adtation cannot actually perform all of its loads and stores atomi\u00adcally. \nIsolation barriers must be used to protect an atomic region from concurrent non-transactional accesses \n[11]. The details of how those barriers interact with the transactional metadata are spe\u00adci.c to the \nSTM implementation, but in all systems they must guar\u00adantee that reads do not observe uncommitted data \nand that writes are either communicated to active transactions or blocked until af\u00adter all con.icting \ntransactions commit. To simplify our discussion we will assume, unless otherwise noted, an update-in-place \nSTM implementation similar to that of McRT-STM [18]. Our work is also applicable to write-buffering STMs \nthat use strict two-phase locking to protect updates, includ\u00ading TL2 [6]. In our assumed STM: Updates \nare performed in-place and protected by strict two\u00adphase locking;  An undo log is used to restore values \non rollback;  Reads are lazily validated using version numbers;  Versions and locks are maintained \nat an object granularity; and  Each object contains its own metadata.  // Initially x==0 // Thread \n1 atomic { r1 =x; r2 =x; assert (r1 == r2); } // Thread 2 x = 1; Figure 3. A non-repeatable read in \na weakly isolated STM. Thread 2 does not increment the version metadata, so Thread 1 s read set (RS) \nvalidation incorrectly allows commit. The center columns give the current value of x and x s metadata, \nand the dotted line represents the non-repeatable read. 2.1 Isolation Requirements Consider the code \nand execution described in Figure 2, which il\u00adlustrates the intermediate dirty read problem (examples \nare adapted from [21]). Thread 1 is using an atomic region to enforce the invari\u00adant that x is even, \nbut Thread 2 can observe an inconsistent interme\u00addiate state because it has no read isolation barrier. \nWeak isolation can also cause atomic regions to behave incorrectly. Figure 3 shows a non-repeatable read. \nThread 1 might commit despite perceiving a spontaneous change in x, because Thread 2 does not increment \nthe version metadata. Many more weak isolation anomalies have been described, but all share a cause with \none of the problems we have just described: non-transactional reads bypass the STM s locks and non-transactional \nwrites bypass the STM s transaction validation.  2.2 Ordering Requirements One of the lock-based idioms \nthat must be supported by atomic regions is privatization, in which a critical section is used to obtain \nexclusive access to an object that was previously shared. After pri\u00advatization the object can be modi.ed \nwith no danger of concurrent access. Weakly isolated transactions can confound the program\u00admer s reasoning \nin this case, however, because after the privatiz\u00ading transaction s commit there might still be zombie \ntransactions accessing the data. Although these zombie transactions will even\u00adtually roll back (after \ndiscovering that their read set is inconsistent) they may perform spurious writes to the privatized object. \nThe privatization problem was .rst recognized for the special case of memory reclamation, in which a \nzombie transaction might access memory that has been reused or returned to the operating system [6]. \nMore recently researchers have studied it in a more general form, and restrictions on transaction commit \norder have been proposed that provide correctness without isolation barriers for thisparticularidiom \n[1,20,23]. The complementary publication problem has also been studied. Publication without non-transactional \nbarriers can be made safe by additional restrictions on commit order if an atomic region is used to read \nthe reference to the published object [14]. Many existing usages of the publication idiom, however, use \nvolatile .elds. Java s memory model guarantees release semantics for a volatile store [12]. This can \nbe used to implement a lockless cache, as in Figure 1. It can also be used to (correctly) implement the \ndouble\u00adchecked locking idiom. When an object s construction and publi\u00adcation are wrapped in a weakly \nisolated transaction, however, the memory model s guarantees are no longer provided. In a write\u00adbuffering \nSTM the actual stores might be issued out of order dur\u00ading commit. In an update-in-place STM the stores \nare issued in the original order, but if the transaction rolls back then additional stores Algorithm \n1 Generic read and write isolation barriers. procedure OPTIMISTICREAD(ref ) repeat v0 . version[ref ] \nif v0 < 0 then . Negative means locked v0 . WAITUNTILUNLOCKED(ref ) end if x . .eld[ref ] until v0 = \nversion[ref ] return x end procedure procedure LOCKEDWRITE(ref , x) repeat v0 . version[ref ] if v0 \n< 0 then . Negative means locked v0 . WAITUNTILUNLOCKED(ref ) end if until COMPAREANDSWAP(version[ref \n], v0 , -v0 - 1 ) .eld[ref ] . x version[ref ] . v0 + 1 end procedure will be made to undo the previous \nwrites. If a non-transactional volatile load has observed the uncommitted publication then it might access \nan object whose updates have been undone. 53 of the 66 volatile references found in classes that are \nin java.*, but not java.util.concurrent.*, are vulnerable to this prob\u00adlem. A weak model that correctly \nexecutes this idiom could be constructed, but it would still require the programmer to reason globally \nabout the correctness of code. Weak isolation sacri.ces one of the most important character\u00adistics of \nmemory transactions: the ability to reason locally about correctness [13]. An analogy has been made with \nmemory man\u00adagement, in which the system primitive of garbage collection re\u00adplaces local reasoning about \nthe whole-program property of reach\u00adability [7]. Without strong isolation both transactional and non\u00adtransactional \naccesses can produce surprising results because of an interaction in some other part of the code. 2.3 \nIsolation Barrier Implementation Algorithm 1 shows implementations of read and write isolation barriers \nfor our representative STM. OPTIMISTICREAD checks the version metadata before and after loading the .eld \ns value, retrying if a lock or race is detected. This mimics the optimistic con.ict de\u00adtection used by \ntransactions, which maximizes scalability by using invisible reads [18]. LOCKEDWRITE acquires exclusive \naccess to the .eld before storing, and then updates the version when the lock is released. This guarantees \nthat any transaction that has read the old value will eventually detect that its read set is inconsistent. \nThe code for the read and write isolation barriers reveals why almost all STM implementations to date \nhave adopted weak iso\u00adlation: extra loads, extra stores, conditional branches, and atomic compare-and-swaps. \nIn addition to the direct costs of the instruc\u00adtions, barriers complicate compiler optimizations and \ndecrease the effectiveness of both software and hardware code caches. 2.4 Static Optimizations Several \nstatic optimizations have been proposed that can reduce the overhead of isolation barriers, either by \neliminating barriers that can be proved unnecessary or by aggregating operations to reduce the amortized \nsynchronization cost. The analyses required to justify these optimizations vary from local to whole-program. \nEscape Analysis Concurrent access to a .eld can only occur after it has become reachable from another \nthread, so accesses to an unescaped object do not require a barrier. Shpeisman et al. use static escape \nanalysis to eliminate isolation barriers. They also implement a dynamic escape analysis that allows faster \nexecution of isolation barriers for object instances that are not dynamically reachable from a shared \nroot object but for which the static analysis fails [21]. Barrier Aggregation If a sequence of barriers \nis observed that protect the same memory location, they can be replaced with a single barrier that protects \nall of the accesses. This may merge multiple reads, multiple writes, or reads and writes (if the STM \ns write barriers also serve as read bar\u00adriers). When con.ict detection is performed at object granularity, \nbarrier aggregation can often be used to merge consecutive accesses to different .elds of the same object. \nFor example, the non-transactional code .eld[ref ] . .eld[ref ]+ 1 might be initially expanded into x \n. OPTIMISTICREAD(ref ) ACQUIRELOCK(ref ) .eld[ref ] . x + 1 RELEASELOCK(ref ) After barrier aggregation \nthe sequence would be ACQUIRELOCK(ref ) .eld[ref ] . .eld[ref ]+ 1 RELEASELOCK(ref ) This optimization \nhas been shown to be effective for transactional code [2]. Barrier aggregation has also been evaluated \nfor reducing the overhead of isolation barriers in non-transactional code [21]. Static Not-Accessed-In-Transaction \nAnalysis If a .eld is never accessed inside an atomic region then no isolation barriers are required \nby non-transactional reads and writes. A static analysis that proves this not-accessed-in-transaction \n(NAIT) prop\u00aderty can thus be used to remove isolation barriers3. Shpeisman et al. implement NAIT in a \ntransactional compiler that provides strong isolation for Java [21]. Isolation barrier removal requires \na whole\u00adprogram analysis, which restricts the use of dynamic class loading and re.ection. It also requires \na conservative analysis, which may restrict its use for utility classes that are used both inside and \nout\u00adside transactions, e.g. java.util.HashMap. 3. Acceleration Using Optimization Hypotheses We propose \noptimizing by forming a hypothesis about the dynamic interleaving of a .eld s accesses, and then choosing \na set of barrier implementations customized for that pattern. Isolation and transac\u00adtion barriers must \ncooperate to safely access a .eld. However only barriers that return to the caller must synchronize with \neach other. By allowing customized implementations to inde.nitely block non\u00adconforming accesses, we can \nmake the remaining barriers smaller and faster. We provide a mechanism to rescue blocked threads, so \nan incorrect hypothesis only affects performance. All of our bar\u00adrier implementations provide strong \nisolation whether or not the program conforms to the hypothesis, allowing us to use runtime pro.ling \nto safely guide our optimization. As a motivating example consider a .eld protected by the barriers shown \nin Algorithm 2. These barriers allow direct non\u00adtransactional access to the .eld, but prevent access \nfrom inside an 3 As originally described NAIT also refers to a not-written-in-transaction analysis that \ncan only be used to remove read isolation barriers; we use NAIT to refer to the stronger property. Algorithm \n2 Barriers customized for the optimization hypothesis NAIT. procedure NONTXNREAD(ref ) return .eld[ref \n] . Access OK end procedure procedure NONTXNWRITE(ref , x) .eld[ref ] . x . Access OK end procedure procedure \nTXNOPENFORREAD(ref ) ROLLBACKANDBLOCK . Nonconforming access end procedure procedure TXNOPENFORWRITE(ref \n) ROLLBACKANDBLOCK . Nonconforming access end procedure atomic region. No matter how they are invoked, \nthe underlying ac\u00adcess to the .eld will follow the NAIT access pattern and hence be strongly isolated. \nIf the barrier invocations do not follow the NAIT pattern then the rescue mechanism must be invoked to \nresume for\u00adward progress. An optimization hypothesis (OH) is an access pattern enforced by a customized \nbarrier implementation. If and only if the invoca\u00adtions of the barrier conform to that access pattern \nthe accesses will be passed through to the protected .eld or array element. We say that the OH or the \nbarrier admits those accesses. If the barriers are invoked in a disallowed pattern then they block the \ncalling thread, after .rst rolling back any enclosing transaction. An OH is both a hypothesis about the \ncustomized barrier s invocation pattern and a guarantee about the actual memory accesses that will be \nperformed by the corresponding specialized barrier. To rescue threads that have violated the optimization \nhypothesis of a .eld we use the hot swap feature of a managed runtime to replace all of the barriers \nfor that .eld. Continuing the NAIT example, if an invocation of TXNOPENFORWRITE is detected for the .eld \nthen all barriers for the .eld will be replaced with the unoptimized versions before the blocked thread \nis resumed. In Section 5 we discuss the details of safely hot swapping barriers without quiescing unaffected \nthreads. 3.1 Will an OH Actually Allow Optimization? Dynamic veri.cation of an OH incurs extra costs \ncompared to optimization based on a static proof: the cost of verifying that an access pattern is followed, \nand the cost of retaining the ability to revert to full isolation barriers. For NAIT (and for several \nother hypotheses introduced in Section 3.3) all of the veri.cation code is outside the isolation barriers, \nso there is no checking cost when the OH is correct. Preserving the ability to revert to the full isolations \nbarriers requires the system to add transactional metadata to objects even if their .elds are currently \nhypothesized to be NAIT. If the .eld is never accessed in a transaction then this .eld is unused. The \ncomplexity of a pro.table OH is limited by the complexity of the original isolation barriers OPTIMISTICREAD \nand LOCKED-WRITE. Ifthespecialized barriers aremore expensive thanthe orig\u00adinal (when weighted by their \nrelative usage) then no acceleration will be achieved. This is especially limiting for stateful optimiza\u00adtion \nhypotheses that require their customized read isolation barriers to modify metadata. The cost to rescue \na blocked thread from an incorrect OH is much higher than the savings from an individual barrier, so \nthe sys\u00adtem will not experience an overall speedup if rescues are common. If two optimization hypotheses \nadmit barriers with similar perfor\u00admance characteristics, it is better to choose the OH that admits more \nexecutions. Figure 4. A .nite state machine that enforces UAHA. The abbreviations are nt for non-transactional, \ntx for transactional, RO for read-only, and RW for read+write. The .x OH state corresponds to a violation \nof the optimization hypothesis; the invoking thread will be blocked pending hot swap.  3.2 UAHA Unmodi.ed-after-heterogeneous-access \nBy moving the burden of proof from a static analysis to the barriers we gain the ability to check access \npatterns that are sensitive to an object instance s history. We introduce here unmodi.ed-after\u00adheterogeneous-access \n(UAHA), an access pattern that is expensive to check but general. In Section 3.3 we will describe a family \nof patterns (including NAIT) that allow a subset of the behaviors allowed by UAHA but that are practical \nto check. Intuitively UAHA corresponds to a three-stage lifecycle for a .eld of an individual object. \nDuring the .rst stage no write barriers have been observed, so it is not known which type of reads should \nbe considered heterogeneous. After a write barrier has been observed then the .eld is biased toward either \ntransactional or non\u00adtransactional access. During this second stage both reads and writes are allowed, \nbut they must be exclusively from inside an atomic region or exclusively from outside. The .nal stage \nis read-only, during which all reads are allowed. If both modes of reads are encountered then the read-only \nstate must be entered. We observe that a customized implementation of NONTXN-READ can skip checking an \nobject s version and lock metadata if every actual .eld store performed by a transaction happens-before \nthe read isolation barrier s actual .eld load. Similarly, a customized implementation of NONTXNWRITE \ndoes not need to lock the ob\u00adject and increment the version number if every .eld store by the write isolation \nbarrier happens-before every actual load or store to that .eld from a transaction. An instance is UAHA \nif: 1. No object instance is passed to both NONTXNWRITE and TXNOPENFORWRITE; 2. Every TXNOPENFORREAD \nhappens-after every call to NON-TXNWRITE; and 3. Every NONTXNREAD happens-after the completion of every \ntransaction that called TXNOPENFORWRITE on the instance.  UAHA covers uses of the publication pattern \nthat are not proved safe by a static escape analysis. It is even more general than dy\u00adnamic escape analysis, \nbecause it detects actual shared accesses in\u00adstead of reachability. Metadata is stored per object but \noptimization hypotheses concern individual .elds, so maximum sensitivity is ob\u00adtained by tracking heterogeneous \naccess separately for each .eld. Verifying that barrier invocations for a .eld follow the UAHA pattern \nrequires that heterogeneous accesses (HA) be recorded. Un\u00adtil a write barrier is invoked we don t know \nwhether HA corre\u00adsponds to a read isolation barrier or transactional read barrier, so the checker must \ninclude states that record both types of reads. The resulting FSM has 6 states that return control to \nthe caller (the 7th state is .), so it would require three bits of metadata per .eld (Fig\u00adure 4). Synchronization \nis required for each state transition. In contrast, consider the checking FSM for NAIT:  We can reproduce \nthe customized barriers in Algorithm 2 by ob\u00adserving that zero bits are required to encode the single \nnon-blocked state. NAIT implies UAHA, so clearly if the less general optimiza\u00adtion hypothesis is suf.cient \nwe should use it instead. There are several ways in which we can construct optimization hypotheses that \nimply UAHA, while having a lower checking over\u00adhead than the full FSM. We can reduce the number of states, \nreduce the number of state transitions, share some of the bits of the state representation between all \n.elds of an object, and/or separate the starting states for transactional and non-transactional construction. \n 3.3 Our Family of Optimization Hypotheses We augment each mutable object with a single transactional\u00adcreation \n(TC) bit and a .xed number of heterogeneous-access (HA) bits. TC is initialized to 1 if and only if the \nobject is created inside an atomic block. Each .eld is mapped at compile time to one of the HA bits. \nIf there are few mutable .elds each one will be able to track heterogeneous accesses exactly; if an object \nhas many .elds then multiple .elds will use the same HA bit, so false negatives are possible (this does \nnot affect correctness). HA is used to record invocations of NONTXNREAD for transactionally created objects \n(TC =1) and invocations of TXNOPENFORREAD for objects constructed outside an atomic region. A .eld s \nfull optimization hypothesis is composed of a simple OH p for object instances with TC =0 and a simple \nOH q for objects where TC =1, written .p|q.. Thus an optimization hypothesis p that is not dependent \non the construction context can be written .p|p., e.g. NAIT = .NAIT|NAIT.. The simple optimization hypotheses \nare: ANY any access. No limitations are made on the access pattern, and no acceleration is possible. \n NONE no access. No barriers for the .eld may be executed.  RO read-only. No calls to NONTXNWRITE \nor TXNOPEN-FORWRITE are allowed. All write barriers for the .eld must have been eliminated by a static \nescape analysis.  NAIT not-accessed-in-transaction. No calls to TXNOPEN-FORREAD or TXNOPENFORWRITE \nare allowed for the .eld.  UATX unmodi.ed-after-transactional-access. No calls to TXNOPENFORWRITE are \nallowed. TXNOPENFORREAD sets the .eld s HA bit, and NONTXNWRITE is allowed only if the HA bit has not \nyet been set.  NAOT not-accessed-outside-transaction. No calls to NON-TXNREAD or NONTXNWRITE are allowed. \n UATC unmodi.ed-after-transaction-commit. NONTXNWRITE is not allowed. TXNOPENFORWRITE is not allowed \nunless the object is already locked by the current transaction and its ver\u00adsion number is zero, indicating \nthat it must have been locked during creation and never been committed4.  UANT unmodi.ed-after-non-transactional \naccess. NONTXN-WRITE is not allowed. NONTXNREAD sets the .eld s HA bit, and TXNOPENFORWRITE is allowed \nonly if the HA bit has not yet been set.  4 Alternately a bit could be added to the metadata to record \nthe .rst commit. Figure 5. Enforcing the .UATX|UANT. optimization hypothesis. Edges with (*) are heterogeneous \naccesses. Note that .ANY|NONE. is not the same as .NAIT|NAIT.. The for\u00admer speci.es that any access is \nallowed to objects created outside a transaction, while the latter speci.es that non-transactional access \nis allowed to all objects. The UATX and UANT checkers use the HA bit to implement a two-stage lifecycle, \nso all actions that require HA =0 must happen-before actions that set the HA bit. This means that the \nwrite barriers must lock .elds that are changing, the heterogeneous read barriers may only set the HA \nbit on an unlocked object, and an atomic compare-and-swap must be used to set the HA bit. The .rst non-transactional \nread of an instance using a barrier customized for .*|UANT. will be more expensive than the full .*|ANY. \nbarrier; subsequent non-transactional reads will be faster. Because the de.nition of the HA bit is conditional \non TC, the optimization hypotheses .UANT|*. and .*|UATX. are not sup\u00adported. While we could successfully \nimplement these possibilities with only a single bit by relaxing the de.nition of TC (perhaps calling \nit merely a mark bit ), we would require additional stor\u00adage when performing our dynamic analysis (Section \n6). Also, we exclude .UATC|*. because those hypotheses allow the same set of behaviors as .RO|*. (objects \ncreated outside a transaction can never meet UATC s criteria for TXNOPENFORWRITE).  3.4 Approximating \nUAHA with .UATX|UANT. The most general OH supported by our de.nitions of TC and HA is .UATX|UANT., whose \nchecker is illustrated in Figure 5. This FSM can be derived from UAHA s checker (Figure 4) by immediately \nbiasing transactionally created objects to the tx RW state and non\u00adtransactionally created objects to \nthe nt RW state. This change is based on the intuition that the constructor and the .rst write to a .eld \n(not eliminated by escape analysis) are likely to be executed in the same context. The simpli.cation \nreduces the storage cost from three bits per .eld to one bit per .eld plus one bit per object, and reduces \nthe maximum number of state transitions for a .eld from three to one when the hypothesis is followed. \n 3.5 Synergy with Static Escape Analysis The applicability of an optimization hypothesis can be substantially \nwidened if a static escape analysis is .rst used to remove barriers that occur before an object might \nbe concurrently accessed. For many .elds this eliminates all write barriers [22]. Although this stationary \n.eld analysis most effective as a whole-program analy\u00adsis, our implementation maintains compatibility \nwith dynamic lan\u00adguage features by limiting itself to an intraclass analysis performed during class loading. \nTo prevent confusion between optimizations performed stati\u00adcally at compile time and those performed \noptimistically at run time, we use the terms removed or eliminated only to refer to barriers statically \nproven to be unnecessary. Barriers that are unnec\u00adessary due to a currently valid optimization hypothesis \nare referred to as optimally accelerated. Eliminated barriers will never be re\u00adplaced, while optimally \naccelerated barriers may be hot swapped if the OH ceases to be correct.  3.6 Inheritance Statically \ntyped object-oriented languages such as C++ or Java associate every .eld access with a single declaration, \neven when inheritance is present. This means that no dynamic dispatch is re\u00adquired for .eld barriers \neven if the object s exact type is unknown. Optimization hypotheses are therefore associated with .elds \nin\u00adstead of classes. Each instance contains only one set of associated STM metadata bits, so .elds from \nsubclasses must share access to the .xed number of HA bits. The mapping with the least bit aliasing can \nbe computed when generating the barriers by counting the number of mutable instance .elds declared by \nall superclasses. In the evaluated system 16 HA bits are provided for object instances. 3.7 Arrays Arrays \nof references are covariant in Java, so an array isolation barrier typed to receive an Object[] may actually \nbe accessing a String[]. This means that we must either use dynamic dispatch when calling array barriers \nor lose the bene.ts of optimization hypotheses that only hold for some array types. We choose the latter, \nsince when successful it will yield better performance. For Java we track optimization hypotheses for \n9 array types: the 8 primitive array types and Object[]. Multidimensional arrays are considered to be \nreference arrays. An STM must choose the granularity at which data and meta\u00addata are associated. Object \ngranularity is a widely accepted choice for instances, but the situation is less clear for arrays. Like \nadjacent .elds of an object, consecutive array elements are likely to be ac\u00adcessed at the same time. \nWe can optimize for this by using a single lock to protect all elements of an array. On the other hand, \narrays form the basis of important shared data structures like HashMap. If the STM uses a single lock \nto cover such an array then concurrency will be lost. Our compromise is to use a single lock and HA bit \nto protect access to primitive arrays, and four locks and four HA bits to protect access to reference \narrays. Reference array elements are mapped to the locks based on their index modulo four, so adjacent \nelements are protected by distinct locks. 4. Customized Barriers Customized barriers provide strong isolation \nfor all access patterns, but block threads that attempt accesses that do not conform to the optimization \nhypothesis for which they were specialized. The read and write isolation barriers and read and write \ntransaction barriers for a .eld are all customized together. 4.1 Generating Barrier Specializations Figure \n6 gives an overview of the implementation required by iso\u00adlation and transaction memory barriers. A barrier \nfor a compound (TC-sensitive) OH is constructed by referring to the corresponding table entries for TC \n=0 and TC =1. If the entries specify the same operation, then no dynamic check of tc[ref ] is required. \nIf they do not specify the same operation then an additional condition branch is required in the barrier. \nEven after removing combinations that are not useful there are 44 barrier implementations. Rather than \nhand-code each of these possibilities we generate the specializations using traditional com\u00adpilation \ntechniques. We start with customizable code that uses conditional tests of the optimization hypothesis \nto select between possible mechanisms for .eld access, then specialize for a single ANYRONAITNAOTUATCUANT \nOH non-txn read non-txn write txn read txn write NONE not allowed not allowed not allowed not allowed \nANY full full full full RO direct not allowed no-op not allowed NAIT direct direct not allowed not allowed \nUATX direct full+check HA set HA not allowed NAOT not allowed not allowed full full UATC direct not allowed \nno-op check version UANT set HA+direct not allowed full full+check HA Figure 6. Implementations for simple \noptimization hypotheses, or for half of a compound OH after branching on the transactional creation (TC) \nbit. Only if TC =0 Only if TC =1 Algorithm 3 Customizable read isolation barrier, before specialization. \n1: procedure NONTXNREAD(ref ) IMPL = { NONE . FAILURE, ANY . SLOW, RO . FAST, NAIT . FAST, 2: UATX . \nFAST, NAOT . FAILURE, UATC . FAST, UANT . HA FAST } 3: .p|q.. OH . OH is constant during specialization \n4: if IMPL(p)= IMPL(q) . tc[ref ]= 0 then 5: op . IMPL(p) 6: else 7: op . IMPL(q) 8: end if 9: if op \n= FAILURE then 10: BLOCKUNTILOHCHANGE 11: return NONTXNREAD(ref ) . Call new self after hot swap 12: \nelse if op = SLOW then 13: return OPTIMISTICREAD(ref ) . Original slow barrier 14: else 15: if op = HA \nFAST . ha[ref ]= 0 then 16: SETHA(ref ) . Uses COMPAREANDSWAP 17: end if 18: return .eld[ref ] . Direct \nload 19: end if 20: end procedure OH by performing constant folding, constant propagation, dead code \nelimination, and common subexpression elimination5. To reproduce Algorithm 2 s .NAIT|NAIT. read isolation \nbar\u00adrier, for example, we perform the following transformations on the customizable barrier of Algorithm \n3: Substitute the OH, after which p = NAIT and q = NAIT;  Propagation and folding show that the conditional \non line 4 evaluates to true;  Additional propagation and folding shows that the conditionals on lines \n9, 12, and 15 are all false; and  Dead code elimination removes every line from NONTXN-READ except line \n18.   4.2 Useful Optimization Hypotheses Not all optimization hypotheses are useful. Consider the OH \n.ANY|NONE.. When accessing a non-transactionally created ob\u00adject (TC =0) no acceleration is possible, \nsince ANY requires full barriers. For objects created inside an atomic region (TC =1) no access is allowed, \ndespite all of the required code being present in the barrier. In addition, the conditional check required \nto detect nonconformance for the TC =1 case makes the barriers larger and slower than those for the baseline \n.ANY|ANY.. 5 These transformations can also be performed in an integrated development environment with \nsupport for refactoring. TC=0\\TC=1 ANY * .. .. RO ..+ .+ .++ .+ NAIT ..++ .+ .+ .+ UATX ..+ .+ .+ .+ \nNAOT Figure 7. Optimization hypotheses that allow isolation barriers to be accelerated: * = base case, \n. = faster for some invocations, .+ = faster and smaller, and .++ = optimal. Blank entries are subsumed. \nCodifying this reasoning leads us to compare paid costs. The size or execution speed of a barrier are \nonly important for conform\u00ading accesses, because the cost of the hot swap triggered by an op\u00adtimization \nfailure dominates that case. Conversely, if oh1 and oh2 have the same costs for conforming accesses and \noh1 admits a strict superset of the behaviors admitted by oh2 then there is no utility to ever choosing \nthe second hypothesis. We say oh1 subsumes oh2 if: 1. oh1 admits every execution allowed by oh2; 2. \nFor every execution admitted by oh2, the barriers for oh1 are no slower than the barriers for oh2; and \n 3. Every barrier in oh2 that does not always fail is at least as large as the corresponding barrier \nin oh1.  Although the relative size and performance of different barri\u00aders is platform-speci.c, we can \nreasonably assume that adding a conditional branch to the underlying implementation results in a larger \nand slower barrier, and that a direct barrier is no larger than a not allowed barrier. We can then conclude \nthat .p|RO. and .p|NAIT. subsume .p|NONE., that .RO|p. and .NAIT|p. subsume .NONE|p., that .NONE|NONE. \nis subsumed by any other OH, and that .q|RO. is subsumed by .q|UATC. for q . {RO, NAIT, UATX}. In Section \n6.3 we will address the more dif\u00ad.cult task of choosing the best OH when there is not a consensus among \n(1), (2), and (3). Figure 7 shows which optimization hypotheses are useful for reducing the overhead \nof strong isolation. Of special note are the hypotheses .NAIT|NAIT. and .RO|UATC., for which all checking \ncode is either outside the isolation barriers or in barriers that are not invoked unless the OH is incorrect. \n5. Hot Swapping Barriers Customized barrier implementations are faster when accesses con\u00adform to a .eld \ns optimization hypothesis, but they block threads that attempt a nonconforming access. Isolation barriers \nblock internally, while transactional barriers roll back their transaction before block\u00ading. To rescue \na blocked thread we must relax the offending .eld s optimization hypothesis, hot swap its barrier implementations, \nand restart the offending access. The HotSpot JVM has a robust on-stack deoptimization sys\u00adtem to support \nspeculative optimizations such as devirtualization. Deoptimization allows executing compiled code to \nbe reverted to bytecode interpretation, reconstructing any eliminated local vari\u00adables and stack frames. \nThis system is required for aggressive op\u00adtimization in an environment supporting dynamic class loading. \nIt also underlies the JVM s hot swap feature, allowing hot swap to coexist with compiler transformations \nsuch as inlining and dead code elimination [15]. Java s hot swap mechanism is suf.cient to replace all \nof the code for a .eld s isolation and transaction barri\u00aders. However we must ensure that the old and \nnew barriers do not run simultaneously. 5.1 Ordering Requirements During an OH Change Strong isolation \ncannot be guaranteed if barriers specialized for two optimization hypotheses run at the same time. The \nsemantics of Java s hot swap, though, are to continue executing the old byte\u00adcodes for swapped methods \nthat already have an activation record. This means that we can t merely invoke the JVM s hot swap and \nthen proceed, because an old barrier implementation may still be active. To change an optimization hypothesis \nwe must establish a happens-before relationship between all invocations of the old spe\u00adcialized barriers \nand all invocations of the replacements. The simplest way to guarantee safety during the swap would be \nto quiesce all threads, blocking them outside isolation barriers and outside transactions (after waiting \nfor commit or rollback). All old specializations happen before the quiesce is completed, the quiesce \ncompletion happens before the swap, and any subsequent barrier invocations will happen after the swap \nand hence use the new specialization. This stop-the-world approach is correct, but it blocks threads \nregardless of whether they require access to a changing barrier.  5.2 Swapping Without Stopping the \nWorld Ideally we would like to quiesce only threads that might actually invoke a new specialization while \na stale implementation is still active. In fact we can identify exactly these threads, by using hot swap \nto replace the stale barriers with a stub that quiesces the caller. Once this preliminary swap has been \ncompleted and all stale barrier implementations have .nished we can install the new barriers. After installing \nthe required QUIESCE barriers the swapping thread increments a shared counter, the swap clock. When a \nthread is at a safepoint (somewhere outside a barrier) it copies the swap clock to a thread-local .eld. \nThe swapping thread then polls the copies until it has observed that every thread has either become quiesced \nor passed a safepoint, at which time it can conclude that no copies of the old specialization are still \nactive. Safepoints inside an atomic region verify that the transaction has neither read nor written any \nof the .elds affected by a hypoth\u00adesis change before witnessing the updated swap clock. Some hy\u00adpothesis \nchanges could be safely tolerated but our current imple\u00admentation simply rolls back any transaction that \nmight be affected. The situation is complicated by system calls, monitors, and by stale barriers blocked \nwhile acquiring an STM lock. Threads blocked on system calls or on monitor entry can be detected by checking \nthe thread status; no swap clock witness is required for them because they cannot be executing a stale \nbarrier. Blocking performed from inside a stale barrier specialization is handled by explicitly checking \nthat the OH hasn t changed after the blocking call returns. This check is performed by comparing the \nreturn value of a trivial static method with a constant. The JIT will inline the static method call and \nperform dead code elimination on the branch. During an OH change the static method is replaced, resulting \nin de\u00adoptimization of the checking code and reappearance of the branch. If a barrier detects that it \nhas been replaced, it forwards to the new implementation by making what appears to be a recursive call \nto itself. Once it is certain that no stale implementations are still active (or rather that any remaining \nstale barriers are blocked and hence will behave properly once awoken) a second hot swap is used to install \nbarriers customized for the new optimization hypothesis. The QUIESCE barriers are then instructed to \nunblock and forward to the new specializations, and execution continues. 6. Feedback-Directed Customization \nTo reap rewards from specialized barriers we must select optimiza\u00adtion hypotheses that are speci.c enough \nto allow faster execution If TC = 0 NC NR set by NONTXNREAD NC NW BHA set by NONTXNWRITE if HA =0 NC \nNW AHA set by NONTXNWRITE if HA =1 NC TR set by TXNOPENFORREAD NC TW set by TXNOPENFORWRITE If TC = 1 \nTC NR set by NONTXNREAD TC NW set by NONTXNWRITE TC TR set by TXNOPENFORREAD TC TW BC set by TXNOPENFORWRITE \nif never committed TC TW BHA set by TXNOPENFORWRITE if HA =0 TC TW AHA set by TXNOPENFORWRITE if HA =1 \n Figure 8. Observation bits. NC and TC abbreviate non\u00adtransactionally-created and transactionally-created, \nrespectively. BC is before-commit, BHA is before-heterogeneous-access, and AHA is after-heterogeneous-access. \nbut general enough to admit all accesses actually performed by the program. Two basic strategies are \npossible: optimistic and pes\u00adsimistic. The optimistic strategy starts with an OH that allows op\u00adtimization \n(perhaps .NAIT|NAIT.), and then reactively relaxes the OH as needed. The pessimistic strategy starts \nwith a general OH and then proactively tightens it for .elds identi.ed as pro.table op\u00adportunities. Side \ninformation may be used to choose an optimistic strategy for some .elds and a pessimistic strategy for \nothers. The optimal strategy for a .eld depends on the expected cost of hot swaps relative to the expected \nsavings from accelerated barri\u00aders. Frequently accessed .elds will be successfully accelerated by either \nthe optimistic or pessimistic strategy. Infrequently accessed .elds, however, do not provide the opportunity \nto recover the cost of an incorrect speculation, because each hot swap is much more expensive than an \nunaccelerated isolation barrier. We therefore choose the proactive tightening (pessimistic) strat\u00adegy. \nFor all .elds we start with generic .ANY|ANY. barriers that are augmented to record accesses. If many \naccesses are observed for a .eld we consider tightening it, because the computed OH is likely to be accurate \nand there are likely to be suf.cient future ac\u00adcesses to recover the cost of the customizing swap. 6.1 \nObservation Bits The RECORD barriers include the safe but slow functionality of generic isolation and \ntransaction barriers, and they update the het\u00aderogeneous access (HA) bits. For each .eld declaration \nor array class we maintain an observation word and an invocation counter. The observation word contains \n11 bits as described in Figure 8; each RECORD barrier invocation sets one bit and increments the counter. \nReads and writes of pro.ling data are performed racily; the observation word will converge on the correct \nvalue and the invo\u00adcation counter need only be a proxy for the activity of a .eld. The 11 observation \nbits correspond directly to the disallowed behaviors used to de.ne our family of optimization hypotheses \nin Section 3.3. Figure 9 shows the mapping from observation word to allowed OH. A background thread polls \nobservations and initiates proactive tightening of an OH. Because hot swap occurs on a per-class ba\u00adsis, \nthe incremental cost of customizing additional .elds of a class is much smaller than the initial cost. \nWe de.ne two thresholds for initiating a proactive OH change, an activation threshold and an in\u00adclusion \nthreshold (10,000 and 100 respectively for .eld barriers in the evaluated system, 100,000 and 1,000 respectively \nfor array bar\u00adriers). Only classes with a .eld that exceeds the activation threshold are rewritten, but \nwhen rewriting those classes we tighten all of the .elds whose access count exceeds the inclusion threshold. \nNC NR NC NW BHA NC NW AHA NC TR NC TW TC NR TC NW TC TR TC TW BC TC TW BHA TC TW AHA .ANY|*. ..... .RO|*. \n.NAIT|*. ... .UATX|*. .. . .NAOT|*. .. .*|ANY. ...... .*|RO. .*|NAIT. .. .*|NAOT. .... .*|UATC. . .. \n.*|UANT. . ... Figure 9. Optimization hypotheses allowed by the 11 observa\u00adtions.  6.2 Persistence of \nPro.ling Data Pro.le data can be persisted across multiple executions of an appli\u00adcation to decrease \nthe number of hot swaps required during warm up. Because OH choices do not affect the correctness of \nthe system this information can be used even after dynamic class loading or recompilation. For many applications \nthis pro.le data is an oracle, eliminating the need to perform any swaps at all.  6.3 Choosing Between \nAllowed Hypotheses The best OH for a given set of observations is the one whose barriers will produce \nthe fastest execution of the overall program. Isolation barriers impact performance in many direct and \nindirect ways, so to actually build a system we must make simplifying assumptions. The direct cost of \na barrier is the expected number of cycles required to execute its instructions. Indirect costs include \nlost op\u00adtimization opportunities, increased memory bandwidth and cache line contention, reduced instruction \nlocality, and pressure on the virtual machine s compilation cache. The branches and volatile memory operations \nin a barrier limit the compiler s ability to re\u00adorder and eliminate memory references, while the overall \nsize of a barrier has a large effect on the compiler s inlining choices. We model the performance characteristics \nof an OH as a 23\u00adelement vector. For each of the four kinds of barriers {non-txn, txn}\u00d7{read, write} \nwe include three elements: the relative execution ranking if TC =0, the relative execution ranking if \nTC =1, and the relative size of the barrier. The remaining 11 elements come from the observations that \nare compatible with the OH, with a 1 if the corresponding observation bit is allowed and a 2 if it is \nnot. This de.nition means that smaller is better for each of the 23 elements. The execution orderings \nare as follows: NT read: direct < test TC+direct < set HA+direct < full  NT write: direct < test TC+direct \n< full < full+check HA  TX read: no-op < test TC < set HA < full  TX write: check version < full < \nfull+check version  The execution cost of branching on TC for a compound OH comes mostly from fetching \nan object s metadata, so we separate it out only for barriers that would not otherwise perform that load. \nBarrier size is the number of words of bytecode in the evaluated system. As an example, consider cost(.UATX|UANT.)= \n.2, 3, 52, 5, 0, 136, 3, 5, 47, 0, 4, 73, 1, 1, 2, 1, 2, 1, 2, 1, 1, 1, 2. The .rst three elements of \nthe vector indicate that the non\u00adtransactional read barriers for this OH are second fastest (test TC+direct) \nif TC =0 and third fastest (set HA+direct) if TC =1, and that they consist of 52 words of bytecode. The \nsecond three elements correspond to non-transactional write barriers. Because non-transactional writes \nare not allowed for this OH when TC =1 the execution score for that case is given as 0. Starting with \nthe cost vector we then use the observation word to construct a paid cost vector by zeroing the execution \ncost el\u00adements where the execution is not compatible with the observa\u00adtion, and zeroing the size cost \nelements where neither TC =0 nor TC =1 executions are allowed. If obs = NC NR + NC TR then paid(.UATX|UANT., \nobs)= .2, 0, 52, 0, 0, 0, 3, 0, 47, 0, 0, 0, 1, 1, 2, 1, 2, 1, 2, 1, 1, 1, 2. The corresponding paid \ncost vector for .RO|UATC. is .1, 0, 5, 0, 0, 0, 1, 0, 2, 0, 0, 0, 1, 2, 2, 1, 2, 1, 2, 1, 1, 2, 2. Element-wise \ncomparison of these two vectors shows that .RO|UATC. is faster and smaller for every executed barrier \n(each of the .rst 12 elements is =), but that .UATX|UANT. admits more executions (each of the last 11 \nelements is =). We choose to com\u00adpare paid cost vectors by reordering the elements and then compar\u00ading \nlexicographically, effectively giving absolute preference to the costs earlier in the order. This avoids \nthe need to compute weights that allow comparison between metrics of different types. When choosing the \nelement preference order we give highest priority to execution time and second priority to barrier size. \nBe\u00adcause our focus is on reducing the overhead of strong isolation we prefer faster isolation barriers \nto faster transactional barriers, and we prefer acceleration for non-transactionally created instances \nto acceleration for transactionally created ones. Reads are typically more common than writes so we prioritize \nread performance [5]. The resulting order is: .1, 4, 2, 5, 10, 7, 11, 8, 3, 6, 9, 12, 13, 14, 15, 18, \n19, 20, 21, 22, 23, 16, 17. This means that the .rst element of the paid cost vector is given priority, \nfollowed by the fourth element, and so on. This priority scheme reproduces the subsumption results from \nSec\u00adtion 4.2 automatically, and correctly prefers the perfect hypothe\u00adses .RO|UATC. or .NAIT|NAIT. whenever \nthey are compatible with the observation word. We precompute the mapping from obs to optimal OH and store \nit in a lookup table with 2048 entries. 7. AJ: a Bytecode-Rewriting Java STM in Java To evaluate the \nfeasibility of dynamic barrier customization we implemented it in AJ, a strongly isolated STM for Java. \nAJ is written in Java and uses the ASM toolkit [4] to rewrite bytecodes during class loading. Transactional \nmetadata is added to classes containing mutable .elds, methods are split into non-transactional and transactional \nversion, and barriers are inserted. Re.ection and dynamic class loading are allowed. Conditional retry, \nwatch sets, and task composition are provided. AJ does not extend the Java language; rather it provides \na static method TM.atomic(Runnable task) that causes task.run() to be executed atomically. AJ is implemented \nalmost entirely in Java by making use of Sun s sun.misc.Unsafe extension. The exception is a small JNI \nstub that allows the hot swap system to call JVMTI s GetCurrent-ContendedMonitor function, required to \ndetect threads blocked on the hidden monitor that guards a class static initializer. AJ has been tested \non Sun s J2SETM1.6.0 06 on the i686, x86 64, and sun4v architectures, and on J2SETM1.7.0-ea-b29 on the \nx86 64 architecture. It has been tested under Linux and Solaris. Barriers are inserted into both application \nand library code. To reduce the number of circularity issues the JRE s classes are instrumented ahead \nof time. All other code is instrumented during class loading. 16 HA bits are provided for object instances. \nWe map array instances to version and lock metadata by hashing. On 32-bit platforms we must assume TC \n=1 and HA =1. However, on 64-bit platforms current versions of HotSpot have 25 unused bits in each object \ns header, allowing us to store the TC and HA bits exactly for arrays. Class initialization cannot be \nrolled back because the JVM maintains C++ shadows of the .elds in java.lang.Class, out\u00adside AJ s reach. \nWe therefore suspend transactions during execu\u00adtion of static initializers. Barriers are implemented \nas static method calls to synthetically generated helper classes. Barrier customiza\u00adtion is accomplished \nby using the Instrumentation API to swap these helper classes. AJ s implementation of dynamic optimization \nhas reasonable overheads, and the cost of hot swaps during warm up can be re\u00adduced or eliminated by persisting \npro.le data across executions. AJ duplicates analyses already performed by the compiler, must perform \nmethod splitting for all loaded classes, and cannot inform the JVM of invariants that are preserved during \nswaps. While the per-barrier and per-swap overhead of the STM would be reduced by tighter integration \nwith the underlying JVM, AJ s all-Java im\u00adplementation allows us to leverage Sun s mature hot swap imple\u00admentation. \nWe have implemented all of the optimization hypothe\u00adses from Section 3.3, the hot swap mechanism described \nin Sec\u00adtion 5, the feedback-directed customization of Section 6, and the pro.le persistence from Section \n6.2. Barrier customization is sup\u00adported for both application and JDK classes. 8. Evaluation We evaluated \ncosts of strong isolation without optimizations, ef\u00adfectiveness of our specialized barriers at reducing \nthose costs, and overheads involved in pro.ling and customizing barriers dynami\u00adcally. We used benchmarks \nwith no transactions and benchmarks that spend substantial time both inside and outside atomic regions. \nWe measured performance and scalability impacts by running each of the benchmarks without isolation barriers, \nwith unoptimized bar\u00adriers, with specialized barriers installed before class loading, and with specialized \nbarriers installed by hot swap based on runtime feedback. Dynamic barrier customization reduced the overhead \nof providing strong isolation in an STM and lowered STM overheads during transactional execution. We \nperformed experiments on computers with two quad-core 2.33Ghz Intel R.CPUs and 32GB of shared memory. \nWe .Xeon Rused Linux x86 64 kernel 2.6.18 and the 64-bit Server VM in Sun s JavaTMSE Runtime Environment, \nbuild 1.7.0-ea-b29, with a 1GB heap. We ran each con.guration .ve times and averaged the results. Error \nbars illustrate the standard deviation of the samples. 8.1 Overheads of Basic Isolation Barriers We \nmeasured the overhead of unoptimized isolation barriers by ex\u00adecuting non-transactional benchmarks from \nthe DaCapo suite with and without isolation barriers [3]. Of the .xed optimizations dis\u00adcussed in Section \n2.4 only intraclass static escape analysis was used. To account for JVM warm up we timed the third repetition \nof the DaCapo programs. Figure 10 shows the additional execution time when unoptimized isolation barriers \nare used, normalized to the execution time of a program with no barriers, STM transforma\u00adtions, or AJ \noverheads. Execution time is also shown for programs that contain isolation barriers only for .eld accesses \n(object and static .elds) and for programs that contain isolation barriers only for accesses to array \nelements. To measure the impact of isolation barriers on scalability we also ran SpecJBB2005 in these \ncon.gura\u00adtions with thread counts from 1 to 8. Each invocation of the bench\u00admark produces scores for \nall thread counts, with an extra single\u00adthreaded execution providing a warm up for the other values. \nFig\u00adure 11 shows the gain in the average execution time of a business operation, normalized to the average \nexecution time with no STM overheads for the corresponding thread count.  As expected, programs containing \nunoptimized isolation barri\u00aders were signi.cantly slower and less scalable. Barriers protecting both \n.eld and array accesses were signi.cant sources of overhead, with the ratio of importance varying between \napplications. fop ex\u00adperienced the smallest isolation barrier overhead (59%) because it performs a great \ndeal of I/O. lusearch experiences the most slow\u00addown (~14 \u00d7 slower) because its many query threads are \nimpacted by the sequential and scaling overheads of isolation barriers. 8.2 Overheads of Dynamic Barrier \nCustomization We evaluated the cost of feedback-directed optimization by exe\u00adcuting the DaCapo and SpecJBB2005 \nbenchmarks with isolation barriers chosen by an oracle and with isolation barriers customized at runtime \nusing the analysis of Section 6. We further examine the source of overheads by running the benchmarks \nwith STM s method splitting and metadata injection but no isolation barriers, with and without swap safepoints. \nFigure 12 shows the perfor\u00admance overhead of the DaCapo benchmarks relative to an execu\u00adtion with no \nbarriers or STM support. The weak system includes method splitting and STM metadata for object instances, \nbut has no isolation barriers. The weak+safepoints system adds swap safe\u00adpoints, which are required for \nsafe hot swap of barriers. The oracle strong system adds isolation barriers that are customized during \nclass loading for the .NAIT|NAIT. optimization hypothesis. The dynamic strong system starts with unoptimized \nRECORD barri\u00aders and uses hot swap to customize frequently used barriers using the scheme from Section \n6. Figure 13 shows scaling of these con\u00ad.gurations for SpecJBB2005. Figure 13. Isolation barrier overheads \nfor non-transactional execution of SpecJBB2005 with oracle and dynamic barrier customization, normalized \nto performance with no STM for the corresponding number of threads. The oracle strong overheads represent \nan execution in which the system uses persistent pro.ling data to correctly select the ini\u00adtial optimization \nhypotheses, as described in Section 6.2. For many situations the oracle behavior is feasible even in \ndeployed environ\u00adments. The average overhead for DaCapo in this case was 16% and for fully threaded SpecJBB2005 \n(8 threads for 8 processors) it was 7%. We tested the stability of this overhead by measuring the 15th \nDaCapo iteration instead of the third; no improvement was seen. Oracle strong demonstrates that isolation \nbarriers can be ef\u00ad.ciently optimized while preserving the ability to deoptimize. The average difference \nbetween weak+safepoints and oracle strong (counting SpecJBB2005 peak scores as a single datum) is 2.2%. \nThis indicates that HotSpot does an excellent job of inlining barriers optimized for .NAIT|NAIT.. The \naverage overhead from method splitting and metadata in object instances is 5.3%. Adding swap safepoints \nintroduces an additional 8.5% overhead. Tightly coupling the STM and JVM would reduce all of these overheads. \nThe dynamic strong values show that feedback-directed bar\u00adrier optimization is practical for applications \nwith a warm up pe\u00adriod. The average overhead for the third DaCapo iteration was 24% higher than oracle \nOH. Reasonably, hot swap s impact is largest for programs with the shortest execution (fop is shortest, \nfollowed by luindex then antlr). All benchmarks except fop recovered their swapping costs during the \n.rst iteration. fop s .rst iteration with feedback-directed optimization was 16% slower than the .rst \niteration using unoptimized isolation barriers. Dynamic optimiza\u00adtion results in a peak SpecJBB2005 score \nwithin 1% of the oracle s score. Figure 14 shows average counts and elapsed times for the dy\u00adnamic strong \nexecutions. On average, 5.9 .elds had their optimiza\u00adtion hypothesis changed during each hot swap. Dynamic \nstrong  # swaps # .elds msec/.eld antlr 72.8 426 13.9 bloat 110.0 425 36.8 chart 76.2 427 22.2 fop 71.4 \n384 16.2 hsqldb 49.0 375 18.9 jython 83.4 498 32.5 luindex 91.6 429 10.6 lusearch 30.6 300 26.2 pmd 78.8 \n345 22.6 xalan 97.8 892 27.6 SpecJBB2005 63.0 339 14.8 Figure 15. Overhead of strong isolation relative \nto weak isolation for SpecJBB2005 modi.ed to use atomic regions and lazy transaction log construction. \nIncreases in average business op execution time are shown, normalized to a weakly isolated STM with the \nsame thread count. demonstrates that the feedback-directed optimization quickly pro\u00advides most of the \nbene.ts of an oracle static analysis, and that the extra costs incurred by hot swap can be recovered. \n 8.3 Optimizations in a Mostly-Transactional Program To evaluate the cost of providing strong isolation \nfor a program that has both transactional and non-transactional execution, we replaced some of SpecJBB2005 \ns synchronized blocks with atomic re\u00adgions. The benchmark simulates a multi-tier system by performing \nsynchronized transactional and then performing an unsynchronized presentation phase. These phases are \ncontained in the process and processTransactionLog portions, respectively. The presen\u00adtation workload \nconsists of creating XML and simulating a text\u00adbased client terminal using many character arrays. We \nmodi.ed the benchmark so that the setup and process portions of each benchmark transaction executed in \nan STM transaction and the processTransactionLog remained non-atomic. This split causes the benchmark \nto spend between 60% and 85% of its non-startup CPU time in atomic regions. SpecJBB2005 constructs the \ncharacter arrays that model the client terminal (the transaction log ) inside process and .lls those \narrays in processTransactionLog. Our initial naive transacti.\u00adcation thus causes char[] to receive an \noptimization hypothesis of .ANY|ANY., preventing acceleration for the most common bar\u00adrier type. Our \ngoal was not to evaluate automatic parallelization or lock elision, so we moved the offending construction \ncode outside of the atomic section by using the lazy initialization pattern. After this transformation \nchar[] allows an OH of .UATX|ANY.. In this use case lazy initialization would also be required to optimize \nusing NAIT or dynamic escape analysis. NT Read 14.5% (%) .UATX|ANY. 45 .UATX|UATC. 13 .NAIT|ANY. 12 .RO|UATC. \n11 .UATX|NAIT. 8 .NAIT|UATC. 7 NT Read 28.8% (%) .RO|UATC. 45 .UATX|ANY. 22 .ANY|ANY. 13 .UATX|UATC. \n12 .NAIT|ANY. 6 TC =0 NT Write TX Read TX Write 3.8% (%) 14.9% (%) 0.6% (%) .UATX|ANY. 56 .ANY|ANY. 54 \n.ANY|ANY. 100 .UATX|NAIT. 13 .UATX|NAIT. 33 .ANY|ANY. 13 .RO|UATC. 12 .NAIT|ANY. 12 .NAIT|UATC. 6 TC \n=1 NT Write TX Read TX Write 6.7% (%) 26.1% (%) 4.6% (%) .ANY|ANY. 41 .ANY|ANY. 39 .NAIT|UATC. 67 .UATX|ANY. \n38 .RO|UATC. 28 .ANY|ANY. 12 .NAIT|ANY. 21 .NAIT|UATC. 19 .ANY|ANY. 6 .UATX|UATC. 6 .UATX|UATC. 6 .NAIT|ANY. \n5 Figure 16. Relative barrier invocation counts for dynamic strong execution of SpecJBB2005 modi.ed to \nuse atomic regions and lazy transaction log creation. OH percentages are relative within the corresponding \ncolumn. Hypotheses accounting for < 5% of a column are not shown. Figure 15 shows the performance of \nSpecJBB2005 modi.ed to use atomic regions, normalized to single-threaded performance with weak isolation \nand no barrier customization. We observe that as in the previous experiments, the feedback-directed analysis \nper\u00adforms almost identically to the oracle analysis once the system has warmed up. Customization of the \nisolation barriers improves the peak score by 34% compared to unoptimized strong isolation. Some of this \nimprovement results from acceleration of the isolation barriers and some from acceleration of the transactional \nbarriers. Because all barriers must work together to verify the OH, it is not possible to apply these \noptimizations separately. Figure 16 shows the barrier invocation counts from a dynamic strong con.gura\u00adtion. \nThe relatively large performance difference between weak and strong isolation in this experiment comes \nfrom write isolation bar\u00adriers. When we examine the left half of the NT Write hypotheses in the upper \nhalf of the table (TC =0) and the right half of the hypotheses for the lower half, we see that almost \nall write isolation barriers must use locking.  8.4 Acceleration of Transactions Although we are primarily \nmotivated to produce a practical strongly isolated STM, we can also use our feedback-directed barrier \nopti\u00admization to accelerate a weakly isolated STM. No changes to the feedback or OH selection algorithm \nare required, because if no isolation barriers are inserted then the system observes only trans\u00adaction \nbarriers and con.nes itself to optimizing those. Dynamic optimization improved the peak SpecJBB2005 score \nby 31% over the weakly isolated transactional execution. 55% of the read bar\u00adrier invocations and 75% \nof the write barrier invocations went to barriers customized for .RO|UATC.. This OH is almost entirely \nresponsible for the speedup, as the only other hypothesis with sub\u00adstantial use was .ANY|ANY.. 9. Related \nWork Dynamic NAIT Recently published concurrent work by Schnei\u00adder et al. explores a nearby point in \nthe design space of strongly isolated STMs [19]. This work adds a dynamic not-access-in\u00adtransaction analysis \n(D-NAIT) to an STM-enabled JVM. This is the same JVM used by Shpeisman et al. to evaluate static whole\u00adprogram \nNAIT analysis [21]. D-NAIT considers only the removal of barriers, rather than se\u00adlection among alternate \nnon-empty implementations. This restric\u00adtion, along with the cooperation of the JIT (and the negligible \ncost of NOP instructions on a modern architecture) allow for barrier patching at a lower cost than in \nour evaluation system. The reduced decision space and the reduced cost of rescue lead them to prefer \nan initially tight hypothesis (.NAIT|NAIT.) that is reactively relaxed as needed. The reactive strategy \nincreased AJ s swap time by 48% for the transacti.ed SpecJBB2005. Dynamic escape analysis plays a similar \nrole in the D-NAIT system to the TC and HA bits in ours, allowing short-cut execu\u00adtion of barriers for \ninstances that meet a dynamic safety property. Because dynamic escape analysis marks objects as escaped \nbefore they are shared, it does not need to synchronize access to an in\u00adstance s state. This allows acceleration \nof both read and write iso\u00adlation barriers for unescaped instances, as there is no potential race between \nobserving that an instance has not escaped and a subse\u00adquent write to a .eld. .UATX|*. or .*|UANT. are \npotentially more accurate, detecting actual sharing instead of potential sharing and operating at .eld \ngranularity. The tradeoff, however, is that homo\u00adgeneous write barriers must perform extra work to guard \nagainst concurrent setting of the HA bit. HA bits need only be read or updated for optimization hypotheses \ninvolving UATX or UANT, while dynamic escape analysis must be performed for all objects. Schneider et \nal. stop the world during barrier patching, while we propose a two-swap scheme that only blocks threads \nif they access a .eld whose optimization hypothesis is changing. D-NAIT handles optimization failures \nfor all barriers of a method on entry, which reduces the number of swaps required but slightly decreases \nthe ef\u00adfectiveness of the analysis. Per-method generation of optimization failures is not possible in \nour system, at least not for any optimiza\u00adtion hypotheses that reference the TC or HA bits. D-NAIT s \ntight integration with the JVM (in particular with the GC, which already has code to ef.ciently quiesce \nall threads) reduces the performance penalty of stopping the world. Our two-swap scheme would bene.t \nsimilarly from a tight coupling, and may have scaling advantages. Static NAIT The analysis of Shpeisman \net al. can produce smaller and faster code than dynamic barrier customization, even when barrier customization \nis seeded with the oracle OH [21]. The static analysis is conservative, so it does not need to retain \nthe abil\u00adity to revert to full isolation barriers. Shpeisman et al. also optimize for .elds that are \nnot written in a transaction. This access pattern is not accepted by UAHA, the most general optimizable \nOH we con\u00adsider. Shpeisman et al. s dynamic escape analysis plays a similar role in their system to the \nTC and HA bits in ours, providing for a partial speedup based on an instance s dynamic history. Automatic \nData Partitioning The family of optimization hy\u00adpotheses we present are brittle when applied to arrays. \nchar[] is particularly important because its use is ubiquitous via String and StringBuilder. The coupling \nbetween type and OH in our sys\u00adtem is a degenerate form of pointer analysis, in which we assert that \naccesses to different .elds cannot alias. More sophisticated analysis may ease the dif.culties we encountered \nin Section 8.3. Riegel et al. s automatic data partitioning approaches the alias\u00ading problem from the \nanalysis end, constructing data partitions using pointer analysis that include multiple types in each \nparti\u00adtion [16]. This results in tens of partitions per application, rather than the thousands created \nour system. Their dynamic selection of the STM used for each partition is similar to our choice of opti\u00admization \nhypothesis, but they dynamically dispatch to the currently chosen STM in each barrier instead of swapping \nin customized bar\u00adriers, and they only attempt to accelerate transactional barriers. In\u00adterestingly, \nthey consider not only the accesses allowed by an STM specialization but also the relative costs. To \nextrapolate this idea to our system we would construct multiple barrier implementations for .ANY|ANY., \nwith implementations tailored for high and low contention and for read-mostly or write-heavy access pattern. \nBiased Locking Our family of optimization hypotheses is unable to provide acceleration for .elds that \nare written both inside and outside a transaction, even if those accesses don t break strong iso\u00adlation. \nThe rebiasing techniques of biased locking might be used to switch the allowed accesses without requiring \nsynchronization by each barrier, because the rebias causes a happens-before relation\u00adship to exist between \naccesses with different biases [17]. 10. Conclusion Many of the simplicity and safety advantages of memory \ntrans\u00adactions are lost if strong isolation is not provided, but the advan\u00adtages are also lost if the \nperformance penalty of isolation barriers is too high. We have described how to dynamically optimize \nisola\u00adtion barriers based on feedback gathered during execution, and we have shown that the overhead \nof performing these optimizations at runtime is reasonable. Our customized barriers take responsibility \nfor guaranteeing strong isolation, allowing optimizations to be per\u00adformed in the presence of dynamic \nclass loading. Dynamic barrier customization is also effective at accelerating STM s transactional execution \nunder weak and strong isolation. We reduced the overhead imposed by strong isolation from 505% to 38% \nfor 11 non-transactional benchmarks, and then used persistent feedback data to further reduce that overhead \nto 16%. We accelerated a benchmark with mixed transactional and non\u00adtransactional execution by 31% under \nweak isolation and 34% under strong isolation. Acknowledgments This work was supported by the Stanford \nPervasive Parallelism Lab, by Dept. of the Army, AHPCRC W911NF-07-2-0027-1, and by the National Science \nFoundation under grant CNS 0720905. References [1] Intel C++ STM Compiler, Prototype Edition. http://software. \nintel.com. [2] A.-R. Adl-Tabatabai, B. Lewis, V. Menon, B. R. Murphy, B. Saha, and T. Shpeisman. Compiler \nand runtime support for ef.cient software transactional memory. In PLDI 06: Proceedings of the 2006 ACM \nSIGPLAN Conference on Programming Language Design and Implementation, New York, NY, USA, 2006. ACM Press. \n[3] S. M. Blackburn, R. Garner, C. Hoffman, A. M. Khan, K. S. McKinley, R. Bentzur, A. Diwan, D. Feinberg, \nD. Frampton, S. Z. Guyer, M. Hirzel, A. Hosking, M. Jump, H. Lee, J. E. B. Moss, A. Phansalkar, D. Stefanovi\u00b4c, \nT. VanDrunen, D. von Dincklage, and B. Wiedermann. The DaCapo benchmarks: Java benchmarking development \nand analysis. In OOPSLA 06: Proceedings of the 21st annual ACM SIGPLAN conference on Object-Oriented \nPrograming, Systems, Languages, and Applications, pages 169 190, New York, NY, USA, Oct. 2006. ACM Press. \n[4] E. Bruneton, R. Lenglet, and T. Coupaye. ASM: a code manipulation tool to implement adaptable systems. \nAdaptable and Extensible Component Systems, 2002. [5] J. Chung, H. Cha., C. Cao Minh, A. McDonald, B. \nD. Carlstrom, C. Kozyrakis, and K. Olukotun. The Common Case Transactional Behavior of Multithreaded \nPrograms. In Proceedings of the 12th International Conference on High-Performance Computer Architecture, \nFebruary 2006. [6] D. Dice, O. Shalev, and N. Shavit. Transactional locking II. In DISC 06: Proceedings \nof the 20th International Symposium on Distributed Computing, March 2006. [7] D. Grossman. The transactional \nmemory / garbage collection analogy. SIGPLAN Not., 42(10):695 706, 2007. [8] D. Grossman, J. Manson, \nand W. Pugh. What do high-level memory models mean for transactions? In MSPC: Workshop on Memory Systems \nPerformance and Correctness, October 2006. [9] T. Harris, M. Plesko, A. Shinnar, and D. Tarditi. Optimizing \nmemory transactions. In PLDI 06: Proceedings of the 2006 ACM SIGPLAN Conference on Programming Language \nDesign and Implementation, New York, NY, USA, 2006. ACM Press. [10] M. Herlihy, V. Luchangco, M. Moir, \nand I. William N. Scherer. Software transactional memory for dynamic-sized data structures. In PODC 03: \nProceedings of the 22nd annual symposium on Principles of distributed computing, pages 92 101, New York, \nNY, USA, 2003. ACM. [11] B. Hindman and D. Grossman. Atomicity via source-to-source translation. In MSPC: \nWorkshop on Memory Systems Performance and Correctness, October 2006. [12] Java Speci.cation Request \n(JSR) 133: Java Memory Model and Thread Speci.cation, September 2004. [13] V. Luchangco. Against lock-based \nsemantics for transactional memory. In SPAA 08: Proceedings of the 20th ACM Symposium on Parallelism \nin Algorithms and Architectures, pages 98 100, New York, NY, USA, 2008. ACM. [14] V. Menon, S. Balensieger, \nT. Shpeisman, A.-R. Adl-Tabatabai, R. L. Hudson, B. Saha, and A. Welc. Practical Weak-Atomicity Semantics \nfor Java STM. In SPAA 08: Proceedings of the 20th ACM Symposium on Parallel Algorithms and Architectures, \n2008. [15] M. Paleczny, C. Vick, and C. Click. The Java HotSpotTM Server Compiler. In JVM 01: Proceedings \nof the JavaTMVirtual Machine Research and Technology Symposium. USENIX, 2001. [16] T. Riegel, C. Fetzer, \nand P. Felber. Automatic data partitioning in software transactional memories. In SPAA 08: Proceedings \nof the 20th ACM Symposium on Parallelism in Algorithms and Architectures, pages 152 159, New York, NY, \nUSA, 2008. ACM. [17] K. Russell and D. Detlefs. Eliminating synchronization-related atomic operations \nwith biased locking and bulk rebiasing. In OOPSLA 06: Proceedings of the 21st ACM SIGPLAN conference \non Object-Oriented Programming Systems, Languages, and Applications, pages 263 272, New York, NY, USA, \n2006. ACM. [18] B. Saha, A.-R. Adl-Tabatabai, R. L. Hudson, C. Cao Minh, and B. Hertzberg. McRT-STM: \nA high performance software transactional memory system for a multi-core runtime. In PPoPP 06: Proceedings \nof the 11th ACM SIGPLAN symposium on Principles and practice of parallel programming, New York, NY, USA, \nMarch 2006. ACM Press. [19] F. T. Schneider, V. Menon, T. Shpeisman, and A.-R. Adl-Tabatabai. Dynamic \noptimization for ef.cient strong atomicity. In OOPSLA 08: Proceedings of the 23rd ACM SIGPLAN conference \non Object-Oriented Programming Systems, Languages, and Applications, New York, NY, USA, October 2008. \nACM. [20] M. L. Scott, M. F. Spear, L. Dalessandro, and V. J. Marathe. Transactions and privatization \nin delaunay triangulation. In PODC 07: Proceedings of the 26th ACM symposium on Principles of Distributed \nComputing, pages 336 337, NY, USA, 2007. ACM. [21] T. Shpeisman, V. Menon, A.-R. Adl-Tabatabai, S. Balensiefer, \nD. Grossman, R. L. Hudson, K. Moore, and B. Saha. Enforcing isolation and ordering in STM. In PLDI 07: \nProceedings of the 2007 ACM SIGPLAN Conference on Programming Language Design and Implementation, June \n2007. [22] C. Unkel and M. S. Lam. Automatic inference of stationary .elds: a generalization of java \ns .nal .elds. In POPL 08: Proceedings of the 35th annual ACM SIGPLAN-SIGACT symposium on Principles of \nProgramming Languages, pages 183 195, New York, NY, USA, 2008. ACM. [23] C. Wang, W.-Y. Chen, Y. Wu, \nB. Saha, and A.-R. Adl-Tabatabai. Code generation and optimization for transactional memory constructs \nin an unmanaged language. In CGO 07: Proceedings of the International Symposium on Code Generation and \nOptimization, March 2007.    \n\t\t\t", "proc_id": "1480881", "abstract": "<p>Speed improvements in today's processors have largely been delivered in the form of multiple cores, increasing the importance of abstractions that ease parallel programming. Software transactional memory (STM) addresses many of the complications of concurrency by providing a simple and composable model for safe access to shared data structures. Software transactions extend a language with an atomic primitive that declares that the effects of a block of code should not be interleaved with actions executing concurrently on other threads. Adding barriers to shared memory accesses provides atomicity, consistency and isolation.</p> <p>Strongly isolated STMs preserve the safety properties of transactions for all memory operations in a program, not just those inside an atomic block. Isolation barriers are added to non-transactional loads and stores in such a system to prevent those accesses from observing or corrupting a partially completed transaction. Strong isolation is especially important when integrating transactions into an existing language and memory model. Isolation barriers have a prohibitive performance overhead, however, so most STM proposals have chosen not to provide strong isolation.</p> <p>In this paper we reduce the costs of strong isolation by customizing isolation barriers for their observed usage. The customized barriers provide accelerated execution by blocking threads whose accesses do not follow the expected pattern. We use hot swap to tighten or loosen the hypothesized pattern, while preserving strong isolation. We introduce a family of optimization hypotheses that balance verification cost against generality.</p> <p>We demonstrate the feasibility of dynamic barrier optimization by implementing it in a bytecode-rewriting Java STM. Feedback-directed customization reduces the overhead of strong isolation from 505% to 38% across 11 non-transactional benchmarks; persistent feedback data further reduces the overhead to 16%. Dynamic optimization accelerates a multi-threaded transactional benchmark by 31% for weakly-isolated execution and 34% for strongly-isolated execution.</p>", "authors": [{"name": "Nathan G. Bronson", "author_profile_id": "81361595088", "affiliation": "Stanford University, Palo Alto, CA, USA", "person_id": "P1300975", "email_address": "", "orcid_id": ""}, {"name": "Christos Kozyrakis", "author_profile_id": "81350597257", "affiliation": "Stanford University, Palo Alto, CA, USA", "person_id": "P1300976", "email_address": "", "orcid_id": ""}, {"name": "Kunle Olukotun", "author_profile_id": "81100603292", "affiliation": "Stanford University, Palo Alto, CA, USA", "person_id": "P1300977", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1480881.1480909", "year": "2009", "article_id": "1480909", "conference": "POPL", "title": "Feedback-directed barrier optimization in a strongly isolated STM", "url": "http://dl.acm.org/citation.cfm?id=1480909"}