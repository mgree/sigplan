{"article_publication_date": "01-21-2009", "fulltext": "\n Copy-on-Write in the PHP Language Akihiko Tozawa Michiaki Tatsubori Yasuhiko Minamide Tamiya Onodera \nDepartment of Computer Science University of Tsukuba IBM Research, Tokyo Research Laboratory minamide@cs.tsukuba.ac.jp \natozawa@jp.ibm.com, mich@acm.org,tonodera@jp.ibm.com Abstract PHP is a popular language for server-side \napplications. In PHP, as\u00adsignment to variables copies the assigned values, according to its so-called \ncopy-on-assignment semantics. In contrast, a typical PHP implementation uses a copy-on-write scheme to \nreduce the copy overhead by delaying copies as much as possible. This leads us to ask if the semantics \nand implementation of PHP coincide, and ac\u00adtually this is not the case in the presence of sharings within \nvalues. In this paper, we describe the copy-on-assignment semantics with three possible strategies to \ncopy values containing sharings. The current PHP implementation has inconsistencies with these seman\u00adtics, \ncaused by its na\u00a8ive use of copy-on-write. We .x this problem by the novel mostly copy-on-write scheme, \nmaking the copy-on\u00adwrite implementations faithful to the semantics. We prove that our copy-on-write implementations \nare correct, using bisimulation with the copy-on-assignment semantics. Categories and Subject Descriptors \nD.3.0 [Programming Lan\u00adguages]: General General Terms Design, Languages 1. Introduction Assume that we \nwant to maintain some data locally. This local data is mutable, but any change to it should not affect \nthe global, master data. So, we may want to create and maintain a copy of the master data. However such \ncopying is often costly. In addition, the copied data may not be modi.ed after all, in which case the \ncost of copy is wasted. This kind of situation leads us to consider the copy-on\u00adwrite technique. Copy-on-write \nis a classic optimization technique, based on the idea of delaying the copy until there is a write to \nthe data. The name of the technique stems from the copy of the original data being forced by the time \nof the write. One example of copy-on\u00adwrite is found in the UNIX fork, where the process-local memory \ncorresponds to the local data, which should be copied from the address space of the original process \nto the space of the new process by the fork operation. In modern UNIX systems, this copy is usually delayed \nby copy-on-write. Permission to make digital or hard copies of all or part of this work for personal \nor classroom use is granted without fee provided that copies are not made or distributed for pro.t or \ncommercial advantage and that copies bear this notice and the full citation on the .rst page. To copy \notherwise, to republish, to post on servers or to redistribute to lists, requires prior speci.c permission \nand/or a fee. POPL 09, January 18 24, 2009, Savannah, Georgia, USA. Copyright c . 2009 ACM 978-1-60558-379-2/09/01. \n. . $5.00 Another example is found in the PHP language, a popular script\u00ading language for server-side \nWeb applications. Here is an example with PHP s associative arrays. $r[\"box\"] = \"gizmo\"; $l = $r; // \nassignment from $r to $l $l[\"box\"] = \"gremlin\"; echo $r[\"box\"]; // prints out gizmo The change of $l \nat Line 3, following the assignment $l= $r, only has local effects on $lwhich cannot be seen from $r. \nThe behavior or semantics in PHP is called copy-on-assignment, since the value of $r seems to be copied \nbefore it is passed to $l. We can consider the copy-on-write technique to implement this behavior. Indeed, \nthe by far dominant PHP runtime, called the Zend runtime1, employs copy-on-write and delays the above \ncopy until the write at Line 3. For readers in the functional or declarative languages commu\u00adnity, the \nsemantics of PHP arrays may .rst sound like a familiar one, e.g., PHP arrays are similar to functional \narrays. However their similarity becomes less clear as we learn how we can share values in PHP. In PHP, \nwe have the reference assignment state\u00adment, =&#38;, with which we can declare a sharing between two \nvari\u00adables. Such a sharing breaks the locality of mutation. For example, the write to $yis visible from \n$x in the following program. $x[0] = \"shares me\"; $y =&#38; $x; // creates sharing $y[0] = \"shared you\"; \necho $x[0]; // shared you Now, our question is as follows. The copy-on-write is consid\u00adered as a runtime \noptimization technique to reduce useless copies. Then, does the use of copy-on-write preserve the equivalence \nto the original semantics, in which we did not delay copying? This equiv\u00adalence might be trivial without \na sharing mechanism as above, but is not clear when we turn to PHP. In PHP, we can even share a location \ninside a value. This is where the problem gets extremely dif.cult. $r[\"box\"] = \"gizmo\"; $x =&#38; $r[\"box\"]; \n// creates sharing inside $r $l = $r; // copies $r $l[\"box\"] = \"gremlin\"; echo $r[\"box\"]; // what should \nit be ?  The result of this program should re.ect how exactly PHP copies arrays when they contain sharings. \nOur discussion will start from clarifying such PHP s copy semantics. In this paper, we investigate the \nsemantics and implementation of PHP focusing on the copy-on-write technique and its problems. Our contributions \nin this paper are as follows. 1 Available at http://www.php.net. We develop three copy-on-assignment \nmodels of PHP, each dif\u00adfering in the copy semantics, i.e., how sharings inside arrays are copied. Three \ncopy semantics are called shallow copy, graphi\u00adcal copy, and deep copy. To capture sharings inside values, \nour formal model uses graphs and their rewriting.  We identify several problems in the current PHP implementa\u00adtion, \nincluding the inconsistency from the copy-on-assignment semantics. In particular, we point out the inversion \nof execution order problem, which is caused by the copy-on-write optimiza\u00adtion.  We propose copy-on-write \nimplementations of PHP based on the novel mostly copy-on-write scheme, which .xes the inver\u00adsion problem \nby adding moderate overhead to the implementa\u00adtion. This .x works for all three copy strategies.  We \nprove that the corresponding copy-on-assignment and mostly copy-on-write models do coincide. We use a \nbisimu\u00adlation to state this coincidence. We develop proof techniques for our graph rewriting semantics \nusing a domain theoretic ap\u00adproach.  We report that our experimental implementation of the mostly copy-on-write \nscheme gives a desirable performance without signi.cant overhead.  1.1 Outline Let us outline the remainder \nof this paper. Section 2 covers the basics and the copy-on-assignment models. Section 3 explains the \ncopy-on-write, its problem, and our solution by mostly copy-on\u00adwrite. Section 4 discusses the correctness \nof our solution. Section 5 reports the experimental results. Section 6 surveys the related work, and \nSection 7 concludes. 2. Copy-On-Assignment Model In this section, we discuss the semantics of PHP, called \ncopy-on\u00adassignment, focusing on how array values are copied when they contain sharings. 2.1 Preliminaries \nIn this paper, we use graph representations to capture the data and store in PHP. In a graph G, each \nnode and edge of G is labeled. Edges of G are labeled by c . Const . Each node is labeled by an element \nof Const l{D} where D denotes array nodes. Each array node has a .nite number of outgoing edges with \nnon-overlapping labels c reaching nodes representing each element of the array associated with key c. \nOtherwise nodes are leaves representing constants. c We denote by G f v -. v' that there is a c-labeled \nedge from v to v'. The dynamic environment is modeled by adding the root node . to G. The root node is \nitself labeled by D, and may have several successor edges labeled by either $x . Var or c . Const representing \nthe variable environment and constant pool2, respectively. Each c-labeled edge is associated with a node \nc v c, which is again labeled by c, such that G f . -. v c . The subset of PHP we deal with follows the \nsyntax given in Figure 1, in which the overline \u00af is used to denote possibly 0\u00adlength sequences. Now \nthe semantics of variable and array lookup expressions are given as follows. c G f e . vG f e' . v c \n$xG f v -. v' G f . -. v c '' G f c . vG f $x . vG f e[e]. v 2 We introduce such edges from .to vc for \ntechnical reasons, i.e., to avoid garbage collection of constant nodes. Stmt : s ::= $x[e]= e | $x[e]=&#38; \n$x[e]| unset($x[e]) | echo e | s;s Expr : e ::= $x | c | e[e]|\u00b7 \u00b7\u00b7 Const : c ::= null | 0 | 1 | \u00b7 \u00b7\u00b7 \n| | a | b | \u00b7 \u00b7\u00b7 Var : $x ::= $x,$y,\u00b7\u00b7\u00b7 Figure 1. Reduced Syntax of PHP We skip the side effects of \nexpressions since they are irrelevant to the topic of the paper. To simplify the presentation, the syntax \nin Figure 1 even accepts some expressions rejected by the Zend implementation as syntax error, e.g., \nnull[0]. 2.2 Copy-on-Assignment The assignment, or store, statement $x[e]= e' updates the dy\u00adnamic environment. \nWe model this behavior by a binary relation $x[e]= e G -. 'G'. Now consider the following program. $r[\"val\"] \n= 1; $l =$r; $l[\"val\"] = 2; echo $r[\"val\"]; // prints 1 As explained in the introduction, $l= $r creates \na copy of $r, and subsequent writes to $l do not affect $r. This behavior can be illustrated by the following \ngraph rewrites. $r val . D 1 $l= $r$r val -. . D $l val . D - $l[ val ] = 2$r val -. . D 1 $l val . \nD - 2 When drawing a graph we elide constant edges under .. The $x[e]= e rewrite G -. 'G' is broken \ndown into several steps. Copying the subgraph at v' such that G f e' . v'. $xc1cn Looking up a path . \n- . v1 - . \u00b7\u00b7\u00b7 vn - . vn+1 where e evaluates to constant nodes for c1,...,cn.  The copied graph replacing \nthe node vn+1.  The formal de.nition will be given later, after we look through PHP references and \ntheir problems. 2.3 References in PHP As long as we use the ordinary assignment $x[e]= e', the graph \nrepresenting PHP s dynamic store does not contain any sharing structure. At this moment, programmers \nare in a safer but restricted world, where updates of values have no destructive effects seen from remote \nplaces. However, PHP also provides the reference ' assignment operator $x[e']=&#38; $x[e], by which \none can enjoy any advantage of destructive effects as in C or Java, e.g., creating sharing structures, \ncreating back edges or cycles, implementing algorithms otherwise inef.cient, and so on. The syntax =&#38; \nindicates the combination of address-of (&#38;) and assignment operator (=) in C. However, there is an \nimportant dif\u00adference in the meaning between PHP and C. $r[\"hand\"] = \"empty\"; $x =&#38; $r[\"hand\"]; // \ncreates a sharing 1 1 $x$x$x 1: $r[0] = \"empty\";   2: $x =&#38; $r[0]; $l[0] = coin $r 0 $r 0 $r 0 \n $l= $r \"empty\" \"empty\" \"coin\" 3:$l =$r; . D -. . D -. . D   4: $l[0] = \"coin\"; $l $l 00 5: echo \n$r[0]; DD $x 1: $r[0] = \"empty\"; 2: $x =&#38; $r[0]; unset($x)$r $l[0] = plenty $r $r 0 $l= $r$r 0 - \n0 - - 0 - \"empty\" \"empty\" \"empty\" \"empty\" 3: unset($x); - D - -. . D -. . D -. . D . 4:$l =$r; $l0 \n5: $l[0] = \"plenty\"; 0 $l. D - \"empty\" \"plenty\" 6: echo $r[0]; . D - 1: $r[0] = \"trick\"; $x$x 2: $x \n=&#38; $r[0];   unset($x)$r 0 $l[0] = treat $r 0$r 0 $r 0 3:$l =$r; $l= $r - D - \"trick\" \"trick\" \n\"trick\" \"treat\" -. . D -. . D -. . D . 4: unset($x);    5: $l[0] = \"treat\"; $l $l $l 0 00 6: echo \n$r[0]; D D D Figure 2. Some examples in copy-on-assignment PHP(s) $r[\"hand\"] = \"coin\"; unset($r); // \nfreeing $r echo $x; // safe This example demonstrates that in PHP, there is no dangling pointer problem, \ni.e., reading from a reference whose referent already does not exist. We here model references by shared \nnodes, i.e., nodes with multiple incoming edges. References in PHP do not indicate any direction from \na reference to its referent. Rather, two references, which are symmetric to each other, simply share \nthe same value. So, removing the one side, i.e., $r[ hand ], results in a value still seen from the other \nside $x being no longer shared3. $x =&#38; $r[ hand ] $r hand \"empty\" -. . D $r[ hand ] = coin $r hand \n\"empty\" -. . D $x unset($r)$x$r hand - -. . \"coin\" \"coin\" . D $x Now, by combining two types of assignments \n= and =&#38;, we may even copy a value, e.g., $l= $r, in which a reference assignment, e.g., $x =&#38; \n$r[ hand ], has introduced a sharing. What will happen then? The right answer is not readily obvious, \nand actually it seems to be an important design point of the language. Let s see what happens by running \nthe .rst program in Figure 2. The Zend runtime interpreting this program prints out coin , which means \nthat array entries $r[0] and $l[0] are shared before the write at Line 4. Such a sharing should have \nbeen created at $l= $r at Line 3. This evidently shows that while copying a value held by $r, the Zend \nruntime skips the shared node, and instead adds $l[0] to the sharing. We call this behavior shallow copy. \n 2.4 Discussion of PHP s Copy Semantics Having a speci.cation of a language is important in many respects. \nSuch a speci.cation is necessary for creating new implementations of the language. It also helps us discuss \nthe correctness of opti\u00admizations, or design a program analysis, e.g., PHP string analysis by Minamide \n(Minamide 2005). Unfortunately, in the case of PHP, 3 PHP references are also close to hard links in \nUNIX .le systems. PHP(s) $r - D  PHP(d) $r - D  PHP(g) $r - D  $l $l= $r- D -. $l $l= $r- - - DD \n\u00b7\u00b7\u00b7 -. $l $l= $r- D -. Figure 3. Copying a value in three semantics we think speci.cations are not \ngiven suf.ciently. The of.cial man\u00adual4 explains the copy-on-assignment as follows: In PHP, variables \nare always assigned by value. That is to say, when you assign an expression to a variable, the entire \nvalue of the original expression is copied into the destination variable. However, it is not clear from \nhere, or elsewhere in the manual, how values containing references are copied. As a result, the current \nbehavior of the implementation sometimes causes a confusion, and is often criticized, e.g., in the PHP \nbugzilla mailing list5. In this paper, we give a formal copy-on-assignment model of the shallow copy. \nFor comparison, we also discuss two other possible copy semantics classi.ed as variations of deep copy, \nin the sense that they do not create sharings between the original and copy. Note that our intent here \nis not to discuss which one of the copy semantics is superior, but is rather to give their better understanding \nthat might improve the current situation. The following three PHP semantics differ in the way they copy \nvalues in assignment statements. (s)hallow copy semantics, referred to as PHP(s). 4 http://www.php.net/docs.php \n5 http://bugs.php.net/. For example, some classi.es the shallow copy in PHP as a bug, and the other argues \nthat the shallow copy may cause a security problem by leaking references to copied values. (d)eep copy, \nor unraveling semantics, referred to as PHP(d).  (g)raphical copy semantics, referred to as PHP(g). \n The .rst is closest to the Zend runtime. It does not copy shared nodes, which are then further shared \nby original and copied values. The deep copy semantics may involve an in.nite unraveling of a graph when \nwe try to copy cyclic structures. The last alternate semantics is graphical copying, which copies the \ninduced subgraph, preserving the structure. See Figure 3 for their differences when copying a cycle. \nLet us give some examples. First, go back to the .rst example in Figure 2. In PHP(d) and PHP(g), $l= \n$r at Line 3 completely copies an array, so that $l[0] = coin does not affect $r. Hence we get results \ndifferent from PHP(s). Then, move to the second program in the same .gure. This time, even if we use \nthe shallow copy semantics, $l= $r at Line 4 copies the entire array. The difference from the .rst program \nis the unset($x)at Line 3, which removes variable $x, which had shared a node with $r[0]. This is another \npoint where PHP references differ from C pointers or ML references. In PHP, a sharing once created can \ndisappear if the other side of the sharing is removed. This poses some dif.culty in the implementation \nof shallow copy, in which copying a node requires the information as to whether or not the node is shared. \nIn other words, how values are copied in PHP(s) relies on reference counts. Indeed, the Zend runtime \nuses a reference counting mechanism here. In contrast, PHP(d) and PHP(g) do not require reference counting, \nat least for correct implementation. Let us give another example that might illustrates how the differ\u00adence \nin copying strategy has a practical relevance. Look at function calls in PHP. function foo($a) { $a[\"passwd\"] \n= \":-X\"; } $x = null; foo($x); echo $x[\"passwd\"]; // prints nothing As we see, by default, parameter \npassing at function calls corre\u00adspond to the assignment = from actual parameters to formal pa\u00adrameters. \nSo, writes to formal parameters inside the function body should not be seen from the caller. On the other \nhand, if we really need a function that updates given actual parameter variables, we use the pass-by-reference \nmechanism, corresponding to =&#38;. function bar(&#38;$a) { $a[\"answer\"] = \":-)\"; } $x = null; bar($x); \necho $x[\"answer\"]; // prints :-) One might see the similarity of the pass-by-reference annotation in \nPHP, to const modi.ers in C++, final .elds in Java, or even ML  2.5 Graph Transformation In the rest \nof this section, we de.ne the formal copy-on-assignment semantics of PHP. First, let us summarize the \nnotations and graph operations used throughout. The graphs we deal with are the rooted graphs studied \nin the context of term graph rewriting systems (Barendregt et al. 1987; Barendsen and Smetsers 1992). \nFormally, a graph Gis a tuple (VG,.G,dG)where VG is a node set,  .G . VG . C is a labeling function \non a certain node label set C,  dG . VG \u00d7 L-VG is a partial edge function on the edge label set L. \n  We write G f v-. dG(v,e)when dG(v,e)is de.ned. A rooted graph G =(VG ,.G,.G,dG)is a graph with unique \nroot node .G . VG. We denote by EG the set of edges in G, i.e., the domain of the partial function dG. \nHere are some additional de.nitions. De.nition 1 (BASIC OPERATORS AND RELATIONS OVER GRAPHS).  (i) We \ndenote by G = {v-. w} a graph with two nodes v and w, and a single edge (v,e). w. (ii) The union . and \ndisjoint union l of graphs are the union and disjoint union of their nodes, and edge functions seen as \nbinary relations over EG \u00d7 VG .  (iii) By the notation G[(v,e) . v ' ], we denote a graph G ' = (VG,.G,dG[(v,e) \n. v ' ]) whose edge function is updated. Also G[v . c]denotes a graph G ' =(VG,.G[v . c],dG)obtained \nby relabeling a node. (iv) We denote by rcG(v)the reachable node set from v on G. (v) The induced subgraph \nof Gon node set V . VG, written G|V , is a subgraph of G with its node set V and containing all edges \nin G from V to V. We denote by G|v  V a rooted subgraph with its root v . V. This v can be omitted if \nv =.G(. V). We de.ne gc(G)= G|. rcG(.G) (vi) We write inG(w) for a set of edges (v,e) . EG such that \ndG(v,e)= w. A set of outgoing edges, written out G(V), is de\u00ad.ned for a node set V . VG as a set such \nthat (v,e). out G(V) (. EG) iff v . V and dG(v,e)./V. (vii) A rooted graph H is homomorphic to G written \nG . H, if there is a label-preserving mapping . . VH . VG such that 1) .(.H) =.G, 2) (v,e) . EH iff (.(v),e) \n. EG, and 3) .(dH(v,e)) = dG(.(v),e)if (v,e). EH. We say G and H are isomorphic, written G . H, if G \n. H and H . G. The redirections are the basic steps of our transformation. We use two kinds of redirections: \nedge redirection and node redirec\u00adtion, denoted by [E'. v] and [v .\"w], respectively. Here are examples. \n  . v .v  (w,\u00a3)'. v =   w- \u00b7\u00b7\u00b7 w types identifying data structures with destructive references. \nWe think their similarity is the enforcement of the program safety. A program can be safer if it restricts \nthe portion of unwanted updates A - v . w of values, and is given annotations wherever any such destructive \n- . v w - D .=  update may or may not occur. Let us return to the discussion of PHP s copy semantics. \nIf we can measure the safety of program semantics by the possibility of unsafe updates, PHP(d) may be \nthe safest strategy as it creates the least numbers of references by erasing them at each assignment. \nOn the other hand, PHP(s) is less safe than other copying strategies. For example, PHP(s) can cause a \nleakage of password information from foo($x)by doing $passwd =&#38; $x[ passwd ] before calling foo($x). \nw - D The edge redirection redirects a single edge E (=(w,e)) to a node v. Note that some nodes in G \nmay become unreachable after this rewrite, and will be removed. We can also simply remove an edge E by \nwriting [E'..]. The node redirection means that all incoming edges to v are redirected to w. The edge \nredirection is formally de.ned as G[E'. v]= gc(G[E . v]). We can extend this rewrite .G(v ' ) c$x'' \n'' G f e . vG f e . vG f v -. v G f . - . vG f . -. v [CONST] [VAR] [LOOKUP] G f c . vG f $x . vG f \ne[e ' ]. v '' G f e . vG f e ' . v ' (G ' ,E)= .nd (copy(x)(G,v ' ),.,$x;.G(v)) [ASSIGN] $x[e]= e G \n-.(x) 'G ' [dG ' (E).\"dG ' (.,$$)][(.,$$) '..] '' '' G f e . v (G1,E1)= .nd (G, .,$x;.G(v)) G1 f e . \nv (G2,E2)= .nd (G1,.,$x ;.G1(v )) [ASSIGNREF] $x ' [e ' ]=&#38; $x[e]G -.(x) G2[E2 '. dG2(E1)] G f e \n. v (G ' ,E)= .nd ' (G,.,$x;.G(v)) G f e . vG -.s(x) c,G ' [UNSET] [ECHO] [SEQ] unset($x[e])echo ec \nG -.(x) [E'..] G -.(x) .G(v),G (G,s;s) =.(x) (G ' ,s) G ' Figure 4. Copy-on-assignment PHP(x) to G[E \n'. v]for a set of edges E. EG, so as to simultaneously redirect all edges E .E to v. Then the node redirection \nG[v .\"w] is de.ned as G[inG(v)'. w]. Slightly more dif.cult, but a useful graph rewrite is the graph \nextension, written G[E'.. G ' ]where .is a mapping from VG ' to VG. Here is an example. . \u00b7\u00b7\u00b7 .(v) .(w) \nD XX X X   ... D - . \u00b7\u00b7\u00b7  =  \" (.,\u00a3)'.. vw  .(v) .(w) D - X X X X  vw - D  The idea is to \nextend G by G ' by .rst redirecting an edge E to G ' s root, and then by redirecting G ' s outgoing edges \nto G. More precisely, we look at the counterpart G|G ' of G ' , and for .(V ) each outgoing edge (.(v),e) \n. out G(.(VG ' )) from there, we create a copy (v,e)of this edge and redirect it to G. Note that in graph \nextension G[E'.. G ' ], we always assume that G and G ' are disjoint graphs. Otherwise, we create a fresh \ncopy of G ' and perform the extension using this copy. Formally, G[E'.. G ' ]= . .G ' . dG (G l G ' )[E'][(v1,e1) \n'(.(v1),e1)]\u00b7\u00b7\u00b7 [(vk,ek) '. dG(.(vk),ek)] where (.(vi),ei). out G(.(VG ' )). We sometimes consider path-preserving \n. in the de.nition G[E'.. G ' ]. In that case we write G[E'.v G ' ] where v corresponds to .(.G ' ). \nHere we say . is path preserving if .(dG ' (w,e)) = dG(.(w),e) wherever .(w) and dG ' (w,e)are de.ned. \nNote that a path-preserving mapping is close to homomor\u00adphism, but it disregards node labels and graphs \nroots, and also does not preserve the number of edges from a node. Such a mapping ., if exists, is uniquely \ndetermined from v(= .(.G ' )). Finally, the graph unraveling is illustrated as follows. DD - '' unravel \n .- D = '' '' J '' . - . ' - \u00b7\u00b7\u00b7 The result of unravel (G)is a possibly in.nite graph, whose node set \nof unravel (G) has one-to-one correspondence to the set of paths e such that . - . v in G. We give the \nedge function by dunravel (G) (e,e)= e;e if e and e;e are in Vunravel (G). Here we write e;e for a concatenation. \nAn important property of unravel is that for any G, H such that GH, we have H unravel (H) unravel (G). \n 2.6 Copy-on-Assignment PHP(x) The copy-on-assignment operational semantics of PHP(x) is given in Figure \n4. Let us .rst explain several utility functions used in the de.nition. The function copy(x)(G,v), parameterized \nby the copying strategy x .{s,d,g} de.nes how we copy values at assignment. De.nition 2 (COPY OPERATION). \ncopy(x)(G,v)= G[(.,$$)'..(x) G(x)] Given a graph G and target node v, this returns a new graph, in which \nthe copy of a subgraph of G is created and stored in the temporary variable $$. We de.ne each G(x) as \nfollows. G(g) is G|v rcG(v). G(d) is unravel (G|v ). rcG(v) G(s) is G|v . c1ck {v}.{w|Glv- .w1\u00b7\u00b7\u00b7- .wk(=w)s.t. \n|inG(wi)|=1} The intuition here is as follows: The graphs G(g), G(d), and G(s) are G s induced subgraph \nfor the reachable node set from v, the unraveling of G s induced subgraph for nodes reachable from v, \nand G s induced subgraph for nodes reachable from v without passing references, respectively. We also \nneed to specify a mapping .(x) used in the extension operator. For x .{d,g}, we de.ne .(x) as a path-preserving \nmapping, explained earlier, that maps a node in G(x) to the other node in G reached by the same path6. \nFor PHP(s), we de.ne this .(s) similarly except that we leave .(s)(.G(s) )unde.ned. The de.nition of \nPHP(s) requires an explanation. Let us give one example. In PHP(s), we should repair the sharing between \nthe original and copied graphs. - Dv - Dw - Du G :.   $$' - ' G(s) : Dv Dw Here we create a copy \nG(s) of the subgraph of G at v excluding references. Assume that copied nodes are v ' and w '. According \nto the de.nition of .(s), in this case, .(s)(VG(s) )= {w}. So, the edge w -. u is an outgoing edge from \n.(VG(s) ), and is copied as an edge w ' -. u to the shared node u. Now, we similarly add an edge w ' \n-. v. Note that any edge to the root node v ' in 6 We also write G[(.,$$) '..(x) G(x)] as G[(.,$$) '.v \nG(x)] for x .{g,d}. G(s) implies that v is shared, so that such an edge to v ' should be redirected to \nv. This is why we exclude v from .(s)(V G(s) ). G(x)) In other copy semantics, the node set .(x)(Vdoes \nnot have any outgoing edge, so we never create sharings between the original and copied graphs. The .rst \nstep of the assignment statement $x[e]= e ' is to copy the value of e ' . The second step is called the \n.nd step which is to search inside arrays for the target node corresponding to $x[e]. We also use .nd \nin the reference assignment $x ' [e ']=&#38; $x[e]to .nd the targets of both $x[e]and $x ' [e ' ]. In \nPHP, not only missing target array entries, but also new arrays that are not found on the path to the \ntarget node are created, as shown in the following example. $y $a[0] =&#38; $y . -. . $a - D 0 - null \n The assignment statement performs the copy operation earlier than the .nd operation. This order is crucial, \nsince the latter rewrites the graph for creating the path to the target node, e.g., consider $x[0] = \n$x. Also during the .nd operation, PHP raises an error if nodes other than null and D already exist where \nwe need arrays. The following function .nd (G,v,c)is unde.ned in such a case. Note also that the function \ndoes not return the target node, but rather $r . the edge reaching the target node. The latter half \nof this section discusses our re.ned copy-on\u00adwrite scheme, and gives its formal treatment. 1 1 3.1 Sharing \nand Splitting In copy-on-assignment graphs, sharings are by references through which we write to the \nsame location from different places. In the copy-on-write graph, there are two kinds of sharings: one \nwhich corresponds to references, and the other for delaying copies. In copy-on-write, the assignment \n$l= $r also creates a sharing: $r $r 0  0 $l= $r . -. . D - . . - .D - . \"a\" \"a\"  . $l We use circles \n. within graphs to indicate ports, which are means to distinguish sharings created by assignment = from \nthose created by reference assignment =&#38;. Multiple edges to the same port represent sharing by reference, \nwhile multiple edges to the same node, with distinct ports, represent temporary sharing for a copy-on-write \nop\u00aderation. We denote by reference ports those with multiple incoming edges, and by copying ports those \non nodes with multiple ports. If a write occurs on a path containing copying ports, we split the graph. \n$r - 0 - .D . . 1 \"a\" 0 1 - . - D  . \"a\" .. $l[0] = b  1 11  .-.  . 1 0  - . c If G f v \n-. v ' ( The split operation above is similar to the copy operation. The G, (v,c)) Otherwise (*) difference \nis that we do not duplicate the entire subgraph, but only unde.ned If .G.{null,D} (v) / the path to \nthe node to be written. c .nd (G,v ' ,c) If G f v -. v ' D \u00b7\u00b7\u00b7 De.nition 3 (FIND OPERATION). $l (i) \n$l 8<:8< :  If .G (v) / .{null,D} unde.ned D .D\u00b7\u00b7\u00b7 . \"b\" .nd (G,v,c)(G, (v,c)) = .nd (G,v,c;c) =  3.2 \nCopy-on-Write Inverts Execution Order .nd ( v,c) G, Otherwise (*) c where v is a fresh node, and G =(G.{v \n- . v })[v . D,v . null]. (ii) .nd ' (G,v,c)is de.ned similarly, but is unde.ned for the cases (*). Now \nwe can de.ne the semantics of PHP(x) as in Figure 4. The last rewrite step for $x[e]= e ' , called the \nredirection step, .rst redirects all edges to the location $x[e], to the value at the temporary variable, \nand then we remove the temporary variable. The last step for $x ' [e ']=&#38; $x[e] is a single edge-redirection, \ni.e., we redirect an edge to $x ' [e '] to the node at $x[e]. The c small-step semantics =.(x) is a binary \nrelation over pairs of dy\u00adnamic environment graphs G and sequences of statements s. In c (G,s;s) =.(x) \n(G ' ,s), each step corresponds to the execution s -.(x) of the atomic statement s. The side-effect c \nis either an empty sequence, or a singleton sequence of a literal value, corre\u00adsponding to the output \nof echo e. 3. Copy-On-Write Model The copy-on-assignment models of PHP de.ned in Section 2 give the semantics \nor speci.cation of the language. In this section, we .rst informally introduce a new graph-rewriting \nmodel for the copy-on-write scheme, corresponding to the implementation. We then explain that a straightforward \ncopy-on-write model, which co\u00adincides with the Zend runtime, exposes a discrepancy from the copy-on-assignment \nmodel by inverting the execution of some statements in a program. Since there is no complete speci.cation \nof PHP, this does not imply that the implementation is wrong. However, this discrepancy is still very \nunintuitive for users, whose understanding should be based on copy-on-assignment. We have to be careful \nhere. The copy-on-write delays copying, and we are not sure if such a delay never exposes itself, e.g., \nas an inversion of the expected execution order. Unfortunately, it indeed does. We take the third program \nin Figure 2 as an example. Let us use the shallow copy semantics, PHP(s), to interpret this program: \n1: $r[\"hand\"] = \"trick\"; 2: $x =&#38; $r[\"hand\"]; 3:$l = $r; // <\u00ad 4: unset($x); // <\u00ad 5: $l[\"hand\"] \n= \"treat\"; 6: echo $r[\"hand\"]; // \"treat\" expected We expect here the same result as the case without \nunset($x), since this unset($x) comes after $l= $r which already added $l[ hand ] to the sharing at $r[ \nhand ]. However the Zend run\u00adtime gives a different answer it answers trick , which is the result expected \nif unset($x)was executed before $l= $r. In other words, the execution order was inverted between the \ncopy at Line 3 and the unset at Line 4. This inversion can be explained by the copy-on-write model, which \nwe believe is not far from the implementation of the Zend runtime. $x $x $r $l= $r. $r. - - . - .D \n. -. . D . \"trick\" \"trick\" . hand hand $l The difference from the copy-on-assignment graph is the reference \ncounts. Since this time we share the node at $r by $l= $r, the ref\u00aderence count of the trick node remains \nas 2, while it was 3 in the copy-on-assignment graph. However this is already problem\u00adatic, because in \nthe graph after unset($x), the trick node is no longer considered as shared. unset($x) $r . - -. . D \n. \"trick\" . hand $l $l[ hand ] = treat $r -. . .- D .- \"trick\" hand $l .D . \"treat\" hand Now the delayed \ncopy is resumed at $l[ hand ]= treat , copy\u00ading the port on the trick node before the write, and giving \nthe same result for echo as the Zend runtime. Note that what we see here is not a problem inherent to \nshallow copy. Other copy semantics also have similar, and rather obvious, inversion problems. For example, \nconsider the following program: 1: $r[\"hand\"] = \"trick\"; 2: $x =&#38; $r[\"hand\"]; 3:$l = $r; // <\u00ad 4: \n$x = \"treat\"; // <\u00ad 5: echo $l[\"hand\"]; // \"trick\" expected When a value is copied deeply (or graphically), \nreferences inside it are also copied rather than skipped, so that we expect that the write to $x at Line \n4 is only visible from $r[ hand ]. However in the copy-on-write model, we are in the following state \nbefore this write. $x $r . . D .- \"trick\" . hand $l Here it is dif.cult for $x = treat to modify only \n$r[ hand ] but not $l[ hand ]. If we modi.ed both, we see the inversion of the execution of Line 3 and \nLine 4.  3.3 Mostly Copy-on-Write Scheme We propose a novel solution for the inversion problem. The \nkey idea is to force a split at the assignment, if the value at the right hand side is dirty, i.e., containing \nreferences. We assume that PHP programs do not create dirty arrays very often, so that the cost of additional \ncopies is not signi.cant. We can still safely delay copying in other common cases. We call our solution \nmostly copy\u00adon-write. Let us look into the problem again. It seemed that we went wrong with states such \nas this: . - .D2 . D1 . We think that the above state is already too late. At this state, nothing prevents \nus from, without splitting the node 1, modifying the node 2, either by an unset reducing the reference \ncounts, or by a write updating the content of the node. The root of the inversion problem comes from \nthis unset or write, which should have taken place after we split the node 1. It is also dif.cult to \nforce such a split at the time of the unset or write, which requires the reverse traversal of the graph \nto .nd the targets of splits, adding additional complexity and signi.cant costs to the implementation. \nInstead, our scheme forces a split one step before the too late state, i.e., when we try to share the \nnode 1. In fact, we do not allow such a sharing. This node 1 is called dirty, which we indicate with \na marker . $r -- $r - - $r $l= $r - . D .D -. . D . D or . - D .D $l $l . D .D This time the statement \n$l= $r forces a split of the graph by copy\u00ading the array node. This results in the left side graph in \nPHP(s)7, and the right side graph in PHP(g). PHP(d) also creates the right side graph with a minor change \nexplained later. Con.rm that the subsequent unset or write on the result graphs then will not cause inversion \nproblems. Then, when should a node be called dirty? A simplistic answer is if it represents a value containing \nreferences . However this de.nition can be re.ned by carefully examining when an update of a reference \nis seen from the other nodes. We say a graph is well-colored if it correctly marks ports on dirty nodes. \nHere are examples of well-colored graphs according to our de.nition. . D 1111  (B) . .. D1 . rD(A) \n . - D0  D1 .- r D . D0 In graph (A), either unset of an upper edge to port .r, or a write through \nit has an effect, which can be seen from either node 0 or 1, and thus nodes 0 and 1 are dirty. On the \nother hand, the well\u00adcoloredness of graph (B) says that node 0 is clean. This is because any update through \nthe upper path to the reference port .r .rst triggers the split of this path, which blinds the effect \nof the update from node 0. For example, even if we try to unset one of the edges to .r in PHP(s), the \nreference count of .r does not drop to 1, since the split at node 1 raises the reference count of .r \nto 4 before its drop. Likewise, in PHP(d) or PHP(g), we cannot see from node 0 any write to the node \nat .r through the upper path, since the split at node 1 duplicates port .r before the write. Let us also \nlook at the following graph (C). D / / //  . D (C) .  . D0 The graph (C) is not safe in PHP(g) and \nPHP(d), but is safe in PHP(s), e.g., unset of an upper edge does not turn a reference to non-reference, \nso that the effect of unset is not visible from node 0. In this paper, we de.ne the well-coloredness \nfor PHP(s) differently from that for other copy semantics. We .rst explain PHP(g) and PHP(d), and then \nwill later repeat the discussion for PHP(s). In what follows, we say well-colored to denote the graph \ncoloring property for PHP(g) and PHP(d), and use shallowly well-colored to denote the property for PHP(s). \nThe copy-on-write graphs consist of nodes and ports. Let us use p,q,r,. . . to range over ports, v,w,. \n. . to range over nodes, and n, m, . . . to range over both ports and nodes. For example, each port p \nwhich itself is a successor of a certain node v, always has a single node successor w. We say a node \nv dominates n if all paths from . to n pass this v, and in particular, v strictly dominates n if v dominates \nn and v n. We denote by a dominance frontier of v = a set of m such that i) m is not strictly dominated \nby v, and ii) m is a successor of a certain port or node n dominated by v. 7 So in the mostly copy-on-write \nmodel of PHP(s), we keep the color of the entry port of the copied subgraph, while such port becomes \nclean in other copy semantics. This is because some references may be still shared by the original and \ncopied values in PHP(s). De.nition 4. 1) We say a non-port node v is dirty iff its dominance frontier \ninclude ports. 2) A graph G is well-colored iff i) the ports on dirty nodes are marked dirty, and ii) \nthe copying ports are marked clean. In graph (A), node 0 s dominance frontier is {.r}, while in graph \n(B), it only contains node 1. Hence node 0 is dirty in graph (A) but not in graph (B). Note that the \nwell-coloredness does not require the minimality of marking, e.g., we can mark the port on node 0 in \ngraph (B) dirty, since it is not a copying port.  3.4 Maintaining the Well-Coloredness Before giving \nformal models of mostly copy-on-write, we discuss the coloring process required to maintain well-coloredness. \nThe key idea of mostly copy-on-write was to force splits of the graph one step before the too late states. \nThat means the coloring process should take place two steps before such states, i.e., at the reference \nassignment $x=&#38; $r[ hand ]. $x $x =&#38; $r[0] $r - - -. . $r .* D . \"trick\" . - .D .- \"trick\" \n00 We call the port . * a false-negative, which should be marked dirty after the reference assignment. \nFor PHP(g) and PHP(d), the only chances for introducing false negatives are at =&#38;, while this is \nnot the case in PHP(s). Fortunately, we have linear time algorithms to identify false negatives in either \ncase. Here, we give an algorithm for PHP(g) and PHP(d) that .nds false negatives after the execution \nof =&#38;. Algorithm 1 (MARKING FALSE-NEGATIVES AT =&#38;). In the mostly copy-on-write models given \nlater, rewrites for $x ' [e ' ] =&#38; $x[e]consist of .rst .nding two paths, as illustrated below, reach\u00ad \ning the ports to be shared as a reference, and then redirecting the edge drawn as  - to port p. Assume \nthat during the .nd steps, we split the paths to the ports to be shared, i.e., none of p1,..,pk-1 and \nq1,..,qh-1 are copying ports.8 $x - - =qJ D - - . .p1D .pI pk-1D .pD ' ' / $x .q - .q1D - qh-1D  \n- The coloring algorithm then proceeds as follows. We identify the largest I and J such that pI appearing \nin q1,..,qh-1 and qJ appearing in p1,..,pk-1. This process is done in O(k + h)-time. Let I = J =0if there \nare no such pI and qJ. Then we mark all pi and qj such that i . I +1,..,k - 1and j. J +1,..,h- 1. The \ncorrectness of this algorithm follows from the following remark. Remark 1. If the graph is well-colored, \nthe above redirection introduces a false negative port r only when either r = pi such that i . I +1,..,k \n- 1, or r = qj such that j. J +1,..,h- 1. This is proved as follows. Assume that r is on node v. If the \nredirection is about to turn v dirty, either p or q is reachable from v. If q is reachable, q is dominated \nby v, since v is clean before the rewrite. So, v appears on any path from . to q, and thus r = qj for \nsome j. 1,..,h- 1. The other case is the same. Furthermore, we have r = pi for i . 1,..,I and r = qj \nfor j . 1,..,J. Otherwise, v dominated both p and q, in which case p is still dominated by v after the \nrewrite. 8 The .gure might indicate that all ports pi (i . 1,...,I - 1) and qj (j. 1,...,J-1) are dirty \naccording to the de.nition of well-coloredness. However, this is not the case if some of them overlap, \ne.g., p1 = q1. Also we later introduce shallowly well-colored graphs, in which some of pi and qj can \nbe non-dirty even if there is no overlap. While it is enough to remove false-negatives to guarantee \nsafety, we can also consider the reverse problem, i.e., unmarking false pos\u00aditives. By reducing false \npositives, we can reduce the chance of unnecessary copies during assignments. Unfortunately, this reverse \nproblem is dif.cult. For example, rewrites like unset($x)intro\u00adduce false-positives on ports not visited \nduring the rewrite. $x  . - D - D - .D In general, the removal of all false-positives seems to require \nthe traversal of the entire graph. However we may still remove some false-positives by using several \ntechniques. For example, when copying an array, it may be possible to traverse all its elements. If none \nof the elements inside the array is dirty or a reference, then the array is clean. Alternatively, we \ncan use the the algorithm by Cytron et al. (Cytron et al. 1991), also known as the minimal SSA algo\u00adrithm, \nwhich computes dominance frontiers in super-linear time to the size of the graph. The cost is high but \nthe algorithm can guar\u00adantee the minimality of markings. For example, we may run this algorithm periodically \naccording to the estimated numbers of false positives. To summarize, compared to the original copy-on-write \nscheme, the overhead added by the mostly copy-on-write scheme comes from Additional splits at assignment \n$x[e]= e when e evaluates to a dirty array.  Linear-time maintenance of the well-coloredness invariant \nafter each execution of statement, in particular at $x[e]=&#38; $x[e]in PHP(d) and PHP(g).  The latter \noverhead is linear with the depth of the nested array accesses. We think this overhead is small. 3.5 \nMostly Copy-on-Write PHP(g) A copy-on-write graph is a tuple G =(PG l WG,.G,dG)whose node set is partitioned \ninto a set of ports PG, and the set of non\u00adport nodes WG . .G is a node labeling that maps v . WG to \nConst l{D}, and port p . PG to {., ,o}. Note that o is used in PHP(d). The edge function dG maps WG \u00d7 \n(Varl Const )to PG , c and PG \u00d7{ } to WG. We write G f v -. pv ' for an edge from v to v ' going through \nport p. We construct mostly-copy-on-write models for all three PHP(x). We start with PHP(g). The other \ncopying semantics will be covered next as variations. In copy-on-write schemes, the split operation is \na basic oper\u00adation used in several places. In case of the mostly copy-on-write scheme, a single split \nmay duplicate a certain subgraph, not just a single node as with the original copy-on-write scheme. We \ncannot place multiple ports on dirty nodes, which would break our invari\u00adant. Hence a single split step \nforces, rather than delays, splits of all dirty nodes reachable from a given port. The rewrite split \n(g)(G,p) is de.ned on copy-on-write graphs Gand port p. dG(p,-) split (g)(G,p)= G[(p, -)'. G|] V If \nthe subscript of '.v is omitted, it means v = dG(p, -). Here V is the minimal set satisfying dG(p, -). \nV ,  dG(w,c). V if w . V , and  '' ' dG(p,-). V if p . V such that p is marked dirty. ' .G(v ) c$x \n'' '' G f . -. pv G f . -. pv G f e . vG f e . vG f v -. pv [CONST] [VAR] [LOOKUP] G f c . vG f $x . \nv G f e[e ' ]. v '' G f e . vG f e ' . v ' (G ' ,E)= .nd2 (x)(share(x)(G,v ' ),.,$x;.G(v)) G '' G ' [dG \n' (E).\"dG ' (.,$$)][(.,$$) '..] G '' is (x)-well-colored [ASSIGN] $x[e]= e G -.(x) 'G '' '' '' G f e \n. v (G1,E1)= .nd2 (x)(G, .,$x;.G(v)) G1 f e . v (G2,E2)= .nd2 (x)(G1,.,$x ;.G1(v )) G '' G '' G2[E2 '. \ndG2(E1)] is (x)-well-colored [ASSIGNREF] ' $x [e ' ]=&#38; $x[e]G '' G -.(x) G f e . v (G ' ,E)= .nd2 \n' (x)(G, .,$x;.G(v)) G '' G ' [E'..] G '' is (x)-well-colored [UNSET] unset($x[e]) G -.(x) G '' G '' \nG '' G f e . v G is (x)-well-colored G -.s(x) c,G ' [ECHO] [SEQ] echo e c (v),G '' G -.(x) .G (G,s;s) \n=.(x) (G ' ,s) $l[ foo ] = 2$r bar bar .\\- . -. .D o Figure 5. Mostly copy-on-write PHP(x) The set \nV includes all nodes reachable from dG(p, -) with-colored, which we de.ne later, if x =s. We write G \n'' G ' if out going through .-ports. For example, consider the follow-two graphs are isomorphic by ignoring \nthe differences between \u00ading graph. When we split this graph at port .0, we have V = ports and .-ports. \nThe de.nition in Figure 5 does not mention any {D1 , 2 ,D3 ,.4}. Then the induced subgraph of V is copied \nand .xed algorithm, e.g., Algorithm 1, for choosing well-colored G '' extends the graph at port .0, giving \nthe following result. as the result of -.s(x). Rather, the de.nition is non-deterministic and chooses \narbitrary such G '' . The execution should not stop at the coloring process, which is guaranteed by the \nfollowing lemma. $r split (g) Let us discuss the assignment statement G 0@1A $r ,.0 =. - .D1 - 2D3 .- \n4D . Lemma 1 (PROGRESS IN COLORING). If G is (x)-well-colored,  . .0 D1 - 2D3 .- 4 D . $l $l -  the \nrewrite G -.s(x) G ' never fails in its coloring process. .D - D ' $x[e]= e G ' -.(g) in the  3.6 Other \nCopy Semantics mostly copy-on-write model. The de.nition is given as the rule We move to mostly copy-on-write \nmodels for other two semantics,ASSIGN in Figure 5. The split operation is used here in two places; PHP(d) \nand PHP(s), by giving minor changes to the model of(1) at sharing, when the target is dirty and not sharable, \nand (2) in PHP(g).the process of .nding the target node of the write. Recall that the deep copy semantics \ndistinguishes the copied The .rst step in the copy-on-assignment was the copying of the value at $l \nfrom the original $r, at $l= $r. The copied value is ' treated as a pure value without any references \ninside. We indicateassigned value. However this time, this occurs only when v this pureness by introducing \no-port. For example, such that G f e ' . v ' is under a dirty port, in which case we split the graph. \nOtherwise we place a fresh clean copying port foo foo on v ' . In either case, the root port of the \ncopied value is put in $r the temporary variable $$. The graph after this step is given by share(g)(G,v \n' ). Similarly to the copy-on-assignment model, we .nd the follow\u00ad ing path. $xc1cn . -. p1v1 -. p2v2 \n\u00b7\u00b7\u00b7 vn -. pn+1(= p) where e evaluates to a sequence of constants c1 \u00b7\u00b7\u00b7 cn. In this step, de.ned by (G \n' ,(vn,cn)) = .nd2 (g)(share(g)(G,v), .,$x;c1;..;cn), any time we encounter a node with multiple ports, \nwe split the graph. The last redirection step is the same. We switch the incoming edges directed to pto \nthe port at the temporary variable $$. The formal de.nitions of share(x) and .nd2 (x) are given in Fig\u00adure \n6. Rewrites for other statements are given similarly. Note that the rule for each statement in Figure \n5 contains non-deterministic coloring processes. By saying G is (x)-well-colored, we denote .0 D .- D \nthat G is well-colored if x .{d,g}, and that G is shallowly well\u00ad 0 B@ . 1 . 2 This rewrite is again \nimplemented by split (d)(G,p) operation. Here one idea to de.ne split (d)(G,p)is to use an unraveling \nof the subgraph G|v in the de.nition of split (g)(G,p). However the V problem of this idea, with a \ngraph below for example, is that unrav\u00adeling of a copied subgraph for {D1 , 2 ,D3 ,.4} results in an \nin.nite tree. If we consider a copy-on-write model as an implementation model, such an in.nite unraveling \nis not desirable. Instead, in our scheme, we delay such an unraveling: split (d) 1 D . . $l o  bar \n$l .D foo 1 CA  . D1 2D3 .4 D o ,o0 =  . - 2 D1 o0 - D3 .4 D   .* De.nition 5 (FIND2 AND SHARE \nOPERATION). 1) Function dG(w,c). V if w . V where |inG(dG(w,c))| =1, and .nd2 (x)(G,v,c)is de.ned as \nfollows. '' ' dG(p,-). V if p . V such that p is marked dirty. .nd2 (x)(G,v,c)= The remainder of the \nmostly copy-on-write semantics of both 8unde.ned If .G.{null,D} (v) / cPHP(d) and PHP(s) are the same \nas PHP(g), except that we need a < ' (G, (v,c)) If G f v -. pv different well-coloredness invariant \nin PHP(s) case. ( .nd2 (x)(G,v,c;c)= 3.7 Shallow Well-Coloredness If .G.{null,D} : G, (v,c)) Otherwise \n(*) 8 unde.ned (v) /The original well-coloredness invariant does not .t well for PHP(s). .nd2 (x)(G,v \n' ,c) This is due to the dif.culty to guarantee the progress property at c > < If G f v -. pv ' , .G(p)= \no and |inG(v ' )| =1 coloring, i.e., Lemma 1. For instance, some rewrites can break the well-coloredness \nin a manner that it cannot easily be .xed. .nd2 (x)(G ' ,dG ' (p, ),c) /// . D . - 1 D .D D c If G f \nv -. pv ' and G ' = split (x)(G,p) $a / / / . D  0 > :  ' .  . ( v,c) G, Otherwise (*) . $b[2] \n= 0 -. D unset($a[1]) -. . .nd2 (x) \" ' . D . D .  .   G = p, p , p . v $b - . G l{ . null,v . D],dG[(v,c). \np, ( v are fresh},.G,.G[ p, -). v ]). D D where v | ., (V 2) .nd2 ' (x)(G,v,c)is de.ned similarly except \nthat it is unde.ned for the cases (*). 3) We de.ne share(x)(G,v)as follows. $$ (G.{. - pv} . If v has \n.-or o-port share(x)(G,v)= $$ split (x)(G.{. . p)If v has -port - pv}, where p is a fresh .-port if x \n=g, and is o-port if x =d. In case of x =s, it is .-port or -port depending on the color of v s ports. \nFigure 6. De.nition of .nd2 (x) and share(x) To delay unraveling, we supply suf.cient ports, e.g., the \nport . * above, corresponding to each edge in the copied graph. We de.ne split (d)(G,p)as follows. j \nsplit (g)(G,p) if .G(p)= o split (d)(G,p)= (G[(p, -)'. G ])[p ..] otherwise Let V be the set appearing \nin the de.nition of split (g)(G,p), from which the above G is de.ned as follows. The node set VG contains \nall non-port nodes in V and a set of ports pEeach having one-to-one correspondence to an edge Ein G| \n. V (v,c) . V ' For each pG and v = dG(v,c;-), we have an edge c(v,c)' v - . pv . Each port p(v,c) is \no-port if dG(v,c;-) ./V , and is .-port otherwise. Let us move to the shallow copy semantics PHP(s). \nIn this The above graph after the split caused by $b[2] =0 is not well\u00adcolored in the original sense. \nIt is nor easy to turn this graph well\u00adcolored, since it requires marking of the port at $a. As an alternative \nsolution, we may accept this graph by using a different invariant in the case of PHP(s). We call the \ngraph after $b[2] =0 shallowly well-colored. By carefully examining this case, we can observe that actual \nproblems do not occur immediately, but rather they occur several steps later, e.g., after we unset $a[1], \nshare the node at $a, and then we unset $b. During these steps, we have a second chance to mark the port \nat $a, e.g., at unset($a[1]). We have devised a new de.nition of the shallow well-coloredness as follows. \nWe write cl(v)to denote a set of nodes reachable from v without going through reference ports. We denote \nby p s refer\u00adence count from V, a number of edges (v,c) . inG(p)such that v . V. De.nition 6. 1) We call \na node v shallowly dirty iff there is a reference port p such that p s reference count from cl(v)is equal \nto 1. 2) A graph is shallowly well-colored if i) ports on shallowly dirty nodes are marked dirty, and \nii) copying ports are marked clean. Let us discuss the progress property in PHP(s). In PHP(g) and PHP(d), \nat least for identifying false negatives for the safety, we need the coloring process only after the \nreference assignment $x ' [e ' ]=&#38; $x[e]. On the other hand, PHP(s) is not so simple, in which any \nstatements rewriting the graph may introduce false neg\u00adatives that should be immediately .xed after rewrites. \nWe can clas\u00adsify the sources of false negatives in PHP(s) into the following three categories. The .rst \nsource comes from rewrites like unset as shown in the following example. Such false negatives may also \nresult from = and =&#38;, if the rewrites erase existing edges in the graph. case, split (s) does not \nduplicate ports containing multiple incoming edges. 00 . . 000 D .D unset($a[0]) -. . . D . - . D D \nD . . D1 . .2 ,.0)=. $a $a split (s)( . D1 .2 DD .0 .0 D The second source is the rewrite by $x[e]= e \n' . Note that the  V for de.ning split (s) which is de.nition of share for PHP(s) says that the port \nat $$ becomes ' is dirty. If so, some ports on the path This is explained from the set dirty if the port \nat rvalue e this time {D1}, and does not include .2. Here is a de.nition of split (s)(G,p). to $x[e]may \nbecome false negative. dG(p,-) split (s)(G,p)= G[(p, -)'. G|] V - $b[0] = $a$a - $a - . D .D -. . \n - . DD Here V is the minimal set satisfying $b 0 -  dG D D (p, -). V , The third source of false \nnegatives comes at reference assign\u00adment. The coloring algorithm here is similar to that for PHP(g) and \nPHP(d), but actually it is more conservative. Look at the following example. 2 - 1 - - $a[2] =&#38; $a[1] \n. .D D .D 1 -. . - D - D .- D $a $a Note that the new coloring invariant for PHP(s) itself is neither \nweaker nor stronger than the original invariant. For example, the port at $a in the third example should \nbe marked only in PHP(s). For PHP(s), the following algorithm is at least suf.cient for .xing the graph \nafter the rewrites. Algorithm 2 (MARKING FALSE-NEGATIVES IN PHP(S)). 1) The rewrite at UNSET in Figure \n5 removes an existing edge E. In PHP(s), if there is a reference port reached from E, we mark all . \no Theorem 1 (EQUIVALENCE OF COPY-ON-ASSIGNMENT AND MOSTLY COPY-ON-WRITE). Let s be a PHP program. Two \nstates (G 0 ,s) and (G0 ,s), in the copy-on-assignment and mostly copy\u00ad c on-write semantics =.(x), \nrespectively, are bisimilar to each other. 4.2 Domain-Theoretic Approach Intuitively speaking, the bisimilarity \nrelation should be obtained by suf.ciently splitting the given copy-on-write graph, which should give \nthe canonical form that has the same shape as the copy-on\u00adassignment graph. However formalizing this \nintuition requires care. For example, for the following graph, we may split the upper cycle  forever \nwithout ever reaching the desired canonical form.   o o . D .D .- D - .-   (d) \u00b7\u00b7\u00b7 (d) D D o ports \nencountered during the .nd step before the rewrite. 2) The redirection step at ASSIGN replaces the content \nat the target port with the content of $$. If either i) the target port of the redirection is non-reference, \nbut from which we reach a certain reference port, or ii) the port at $$ is dirty, we mark any port en\u00adcountered \nduring the .nd step dirty. 3) Similarly to Algorithm 1, at ASSIGNREF, we mark ports found during the \n.nd steps. The difference is that we cannot skip ports p1,...,pI and q1,...,qJ, if either i) there is \na reference port reachable from the node under q(= qh), ii) a reference port is reached from the node \nunder p(= pk), or iii) one of pI+1,...,pk-1 and qJ+1,...,qh-1 is a reference port. Remark 2. Let us discuss \nthe correctness of Algorithm 2. We say a path is split if it does not go through copying ports. Case \n1). Assume that a node v is about to turn shallowly dirty after the removal of E, which would drop the \nreference count of a certain p from cl(v). This means that there is a path from v to p, which goes through \nEbut not any reference port. Now note that the .nd step in UNSET guarantees the existence of a split \npath from the root to E, which implies that any node which can reach Ewithout passing reference ports \ndominates E. Hence v dominates E, so that v is on the path found in the .nd step. A similar discussion \napplies to cases 2.i) and 3.i). The case 2.ii) is similar to Remark 1. Cases 3.ii) and 3.iii) come from \nthe fact that a reference introduced by the reference assignment may remove some nodes from cl(v). Combining \nRemark 1 and 2, we obtain the .rst half of the proof of Lemma 1. Note that in any semantics PHP(x), the \nlast redirection steps of the rewrites introduce false negatives only on non-copying ports, so that we \ncan safely .x the graph by marking such ports dirty. The detail is omitted, but we can complete the proof \nof our progress lemma by showing that other rewrite steps, i.e., sharing and splitting steps, never break \nwell-coloredness or shallow well\u00adcoloredness. 4. Correctness of Mostly Copy-On-Write Scheme The mostly-copy-on-write \nscheme is correct with respect to the copy-on-assignment semantics. In this section, we use a bisimu\u00adlation \nto show this result. 4.1 Equivalence by Bisimulation If two systems are bisimilar, we cannot distinguish \nbetween the two from their behaviors, which in our case, are observed from the output of echo statements. \nLet G 0 and G0 be initial copy-on\u00adassignment and copy-on-write graphs, including only constants but no \nvariables. To formally de.ne the canonical form, we use a domain-theoretic approach, in which the suf.cient \nsplitting means to take the lub of arbitrary possible results of splitting. We say a graph G is regular \nif G ' G for some .nite graph G '. We use G to denote the set of all regular graphs, for which the following \nresult is known. Theorem 2 (REGULAR GRAPHS FORM CPO). (Barendsen and Smetsers 1992) (G, )is an unpointed-cpo. \nIn other words, any directed subset D . G of regular graphs has a lub F D in (G, ). In the following, \nwe mean by copying ports either ports on nodes with multiple ports or o-ports. We say a path in the copy\u00adon-write \ngraph is split if it does not go through copying ports. A port or node n, or an edge E, is split if there \nis a split path from .to n, or E. Now we de.ne the binary relation r(x) of copy-on-write graphs as follows. \nDe.nition 7 (DEFINITION OF r(x)). 1) A set of (x)-well-colored graphs is denoted by W(x). 2) A set of \nweakly well-colored graphs, denoted by W0(x), is the set of copy-on-write graphs such that dirty (or \nshallowly dirty if x =s) nodes have neither non-split clean ports nor copying ports. 3) Let G,G ' . W0(x), \nwe write G r(x) G ' , if there is a copying port p . VG such that i) p is split, and ii) G ' = split \n(x)(G,p). Proposition 1 (PROPERTY OF r(x)). We write erase(G)for a graph obtained by erasing all ports \nin G. (i) G r(x) G ' implies erase(G) erase(G ' ). (ii) r(x) is con.uent. With r(x), the canonical form \nof the copy-on-write graph, cano(x)(G), is de.ned as follows. ' cano(x)(G)= G erase(G ) G * G ' (x) \nThe bisimulation relation for Theorem 1 relates a copy-on-write graph G and copy-on-assignment graph \nG iff i) G . W(x), and ii) cano(x)(G) G . Proposition 2. (CONTINUITY OF REDIRECTION) Let D be a directed \nset on (G, ). Let C be a set of paths and c be a path GG' '' ''' such that for each G . D, i) E = {(d \n(.,c ),c )| c ;c . C} GGG is a set of edges to a single node, and ii) v = d (.,c). V . G G [EG '. v \nG]c (G D)[EF D '. vF D]. G.D Lemma 2. (REDIRECTION AND SPLIT COMMUTE) Let G . W0(x). Let p,q,r be ports, \nand E (= (v,e)) be an edge such that p,q,r, and v are split. We also assume that r is a copying port. \nsplit (x)(G,r)[E'..] split (x)(G[E'..],r) split (x)(G,r)[E'. p] split (x)(G[E'. p],r) split (x)(G,r)[q \n.\"p] split (x)(G[q .\"p],r) Now by combining the results obtained so far, we can show the following lemma, \nwhich states that each rewrite step be\u00adtween two models preserves the bisimulation relation. In particular, \nLemma 3(ii) is a direct consequence of Proposition 2 and Lemma 2. Notation 1. 1) For n . VG, we write \n[n]G for a set of paths c to reach n, i.e., [n]G = {c | G f . - . n}. 2) Given a path c on copy-on-write \ngraphs G, a path c . on cano(x)(G) is obtained by removing all occurrences of from c. 3) Given a split \nnode n . G, we write n . . Vcano(x)(G) for a node such that [n]. = .]cano(x)(G), and E. for an edge (v \n. G [n ,c)such that E =(v,c). Lemma 3. (EACH STEP PRESERVES BISIMULATION) Let Gbe a copy-on-write graph \nin W0(x). (i) Let G cano(x)(G) and v . VG be a split node. 1) (G ' , (w,c)) = .nd2 (x)(G,v,c)is de.ned \niff (G ' w, G, ,( c)) = .nd ( . G ' v ,c) is de.ned. If both are de.ned, 2) cano(x)(G ' ), 3) [ G ' = \nG ' and = . w] [w]. cc, and 4) w is split in G ' (ii) cano(x)(G[E'. p]) cano(x)(G)[E. '. p .], if E and \np are split. Similarly, for [E'..]and [q . p]where E,pand qare split. (iii) cano(x)(share(x)(G,v)) copy(x)(cano(x)(G),v \n), if G . W(x) and [ v]cano(x)(G) . [v]G. (iv) cano(x)(G) cano(x)(G ' )if G G ' and G ' . W0(x). Now \nTheorem 1 is a straightforward consequence of Lemma 1 and Lemma 3. 5. Experimental Implementation We \nimplemented the mostly copy-on-write scheme on top of the PHP Runtime, called P9, which is a native compiler-based \nruntime currently developed in IBM Tokyo Research Lab. In the actual implementation, we need some extensions \nto the model de.ned in Section 3. Our graph model has a single root, which represents a univer\u00adsal variable \ntable. In reality, PHP has multiple variable tables for global variables, local variables, and so on. \nMoreover, P9 some\u00adtimes performs an optimization to decompose a variable table to separate variables \non local frame. In such a case, each single variable becomes a root of the graph. Similarly, PHP also \nhas objects which are assigned by pointers9, rather than by copying. Each object also corresponds to \na root of the graph whose suc\u00adcessors are .eld members. In the implementation we extended our scheme \nto deal with such multi-rooted graphs.  We have not discussed so far language constructs other than \n=&#38; in PHP for creating references. For example, PHP supports pass-by-reference and return-by-reference \nmechanisms at func\u00adtion calls. Such mechanisms can be implemented by adaptation of =&#38;. PHP also has \nan array initializer, i.e., array expression, which can directly create an array value containing references. \nIn our implementation, arrays created by array expression sim\u00adply inherit the dirtiness information of \ntheir elements.  9 P9 is an implementation of PHP5. Historically, PHP4 objects are treated by values, \nand this has changed during the move to PHP5. array array-ref specweb PHP(g) coa 62.8 95.2 1624.2 PHP(g) \nm-cow 38.3 95.0 1482.7 PHP(d) m-cow 38.5 95.0 1479.6 n\u00a8aive cow 38.5 39.3 1431.2 Table 1. Benchmark results \n(elapsed time \u00b5sec) Recall the explanation of .nd2 (x)() during which we split any node encountered if \nit has multiple ports. We use approximate reference counting to implement this function. It is easy to \nsee that for PHP(d) and PHP(g), we can perform splits according to such over-approximated reference counts. \nOn the other hand, we do not currently have a faithful implementation of PHP(s). This is because as argued \nearlier in Section 2, such an imple\u00admentation requires the exact reference counting. Table 1 summarizes \nthe preliminary benchmark results of our im\u00adplementation. In addition to mostly-copy-on-write implementa\u00adtions \nof PHP(d) and PHP(g), we also prepared copy-on-assignment PHP(g), and a na\u00a8ive copy-on-write of the shallow \ncopy close to the Zend runtime. In Table 1, the results of .rst two columns use microbenchmark scripts, \nwhich repeat array assignments for clean and dirty arrays, respectively. The third one is a script taken \nfrom the SPECweb2005 benchmark10 whose result is measured using an actual web-server con.guration. The \nbehaviors of all scripts are not affected by the difference in copy semantics. The measure\u00adments were \nmade on Windows XP, Intel Core2 2.0GHz for array and array-ref, and Linux Pentium (R) 3.4 GHz for specweb. \nThe use of copy-on-assignment degrades the performance by 13.5 % on specweb. In contrast, the mostly \ncopy-on-write imple\u00admentations reduce the performance degrade for specweb to around 3%, while guaranteeing \nthe equivalence to the copy-on-assignment semantics. 6. Related Work PHP arrays are close to functional \narrays, whose optimization is a recurring problem in the study of functional languages. Indeed, copy-on-write \ntechniques for functional arrays were already pro\u00adposed for IFP (Robison 1987) and SETL (Schwartz 1975) \nin early days. More recently, after the dynamic reference counting becomes less popular as a memory management \nscheme, optimization tech\u00adniques using the static approximation of reference counts are pro\u00adposed (Hudak \nand Bloss 1985; Bloss 1989; Odersky 1991; Wadler 1990; Turner et al. 1995; Hofmann 2000; Shankar 2001). \nSuch work tries to determine when we can perform in-place update on functional data structures. Regarding \nef.cient runtime techniques for functional arrays, alternatives to copy-on-write arrays, called version \ntree arrays or trailer, are proposed (Baker 1978; Aasa et al. 1988; O Neill and Burton 1997; Conchon \nand Filli atre 2007). Term graph rewriting systems (TGRS) (Barendregt et al. 1987) extend the term rewriting \nsystem to graph rewriting. Our graph rewriting semantics and proofs are largely inspired by the work \non TGRS. Barendsen and Smetsers (Barendsen and Smetsers 1992) discussed the lazy copying in this setting, \nwhose idea is close to copy-on-write. Speaking in a broader context, formal semantics approaches have \nbeen identifying and solving intricate problems in real-life programming languages, e.g., co-/contra-variance \nproblems in Eif\u00adfel, C++, Java, and other object oriented languages (Castagna 1995; Igarashi and Viroli \n2002), or dynamic loading problems in Java 10 http://www.spec.org/web2005/. We used bank/transfer.php. \n(Qian et al. 2000), etc. Our work can be considered as one on this line of researches. 7. Conclusion \nWe have discussed the semantics of PHP focusing on the copy semantics for arrays. We have also presented \nthe ef.cient mostly copy-on-write implementation faithful to the semantics. Our future work directions \ninclude: Exploring the implementation of PHP without costly reference counting. For this, we may combine \nour mostly copy-on-write technique with existing work on functional arrays and in-place update problems. \n Developing compiler optimization techniques for PHP s arrays and references, including deforestation, \nescape analysis, etc., based on the semantics de.ned in this paper.  8. Acknowledgment We would like \nto thank Rob Nicholson for early discussions on PHP arrays problems. Minamide s work was partly supported \nby Grant-in-Aid for Scienti.c Research 20300001 and 18700018, and CREST of JST (Japan Science and Technology \nAgency). References A. Aasa, S\u00a8om, and Christina Nilsson. An ef.ciency compar\u00ad oren Holmstr\u00a8ison of some \nrepresentations of purely functional arrays. BIT, 28(3): 490 503, 1988. Henry G. Baker. Shallow binding \nin LISP 1.5. Communications of the ACM, 21(7):565 569, 1978. H. P. Barendregt, M. C. J. D. Eekelen, J. \nR. W. Glauert, J. R. Kennaway, M. J. Plasmeijer, and M. R. Sleep. Term graph reduction. In Volume II: \nParallel Languages on PARLE: Parallel Architectures and Languages Europe, pages 141 158, 1987. Erik Barendsen \nand Sjaak Smetsers. Graph rewriting and copying. Techni\u00adcal Report 92-20, University of Nijmegen, 1992. \nAdrienne Bloss. Update analysis and the ef.cient implementation of func\u00adtional aggregates. In FPCA 89: \nProceedings of the fourth international conference on Functional programming languages and computer archi\u00adtecture, \npages 26 38, New York, NY, USA, 1989. ACM. Giuseppe Castagna. Covariance and contravariance: con.ict \nwithout a cause. ACM Trans. Program. Lang. Syst., 17(3):431 447, 1995. Sylvain Conchon and Jean-Christophe \nFilli atre. A persistent union-.nd data structure. In ML 07: Proceedings of the 2007 workshop on Workshop \non ML, pages 37 46, New York, NY, USA, 2007. ACM. Ron Cytron, Jeanne Ferrante, Barry K. Rosen, Mark \nN. Wegman, and F. Kenneth Zadeck. Ef.ciently computing static single assignment form and the control \ndependence graph. ACM Transactions on Programming Languages and Systems, 13(4):451 490, October 1991. \n Martin Hofmann. A type system for bounded space and functional in-place update. Nordic J. of Computing, \n7(4):258 289, 2000. Paul Hudak and Adrienne Bloss. The aggregate update problem in func\u00adtional programming \nsystems. In POPL 85: Proceedings of the 12th ACM SIGACT-SIGPLAN symposium on Principles of programming \nlan\u00adguages, pages 300 314, New York, NY, USA, 1985. ACM. Atsushi Igarashi and Mirko Viroli. On variance-based \nsubtyping for para\u00admetric types. In ECOOP 02: Proceedings of the 16th European Confer\u00adence on Object-Oriented \nProgramming, pages 441 469, London, UK, 2002. Springer-Verlag. Yasuhiko Minamide. Static approximation \nof dynamically generated Web pages. In Proceedings of the 14th International World Wide Web Con\u00adference, \npages 432 441. ACM Press, 2005. Martin Odersky. How to make destructive updates less destructive. In \nPOPL 91: Proceedings of the 18th ACM SIGPLAN-SIGACT symposium on Principles of programming languages, \npages 25 36, 1991. Melissa E. O Neill and F. Warren Burton. A new method for functional arrays. Journal \nof Functional Programming, 7(5):487 514, September 1997. Zhenyu Qian, Allen Goldberg, and Alessandro \nCoglio. A formal speci.\u00adcation of Java class loading. In Proc. 15th ACM Conference on Object-Oriented \nProgramming, Systems, Languages, and Applications (OOP\u00adSLA 00), volume 35 of ACM SIGPLAN Notices, pages \n325 336, October 2000. A. D. Robison. The Illinois functional programming interpreter. In SIG-PLAN 87: \nPapers of the Symposium on Interpreters and interpretive techniques, pages 64 73, 1987. Jacob T. Schwartz. \nOptimization of very high level languages, parts I, II. Comput. Lang., 1(2-3):161 218, 1975. Natarajan \nShankar. Static analysis for safe destructive updates in a func\u00adtional language. In Proc. of LOPSTER \n2001, 11th International Work\u00adshop on Logic Based Program Synthesis and Transformation, Paphos, Cyprus, \nNovember 28-30, 2001, LNCS 2372, pages 1 24, 2001. David N Turner, Philip Wadler, and Christian Mossin. \nOnce upon a type. In Functional Programming Languages and Computer Architecture, San Diego, California, \n1995. P. Wadler. Linear types can change the world! In IFIP TC 2 Working Conference on Programming Concepts \nand Methods, pages 347 359, 1990.   \n\t\t\t", "proc_id": "1480881", "abstract": "<p>PHP is a popular language for server-side applications. In PHP, assignment to variables copies the assigned values, according to its so-called <i>copy-on-assignment</i> semantics. In contrast, a typical PHP implementation uses a <i>copy-on-write</i> scheme to reduce the copy overhead by delaying copies as much as possible. This leads us to ask if the semantics and implementation of PHP coincide, and actually this is not the case in the presence of sharings within values. In this paper, we describe the copy-on-assignment semantics with three possible strategies to copy values containing sharings. The current PHP implementation has inconsistencies with these semantics, caused by its na&#239;ve use of copy-on-write. We fix this problem by the novel <i>mostly copy-on-write</i> scheme, making the copy-on-write implementations faithful to the semantics. We prove that our copy-on-write implementations are correct, using bisimulation with the copy-on-assignment semantics.</p>", "authors": [{"name": "Akihiko Tozawa", "author_profile_id": "81100142483", "affiliation": "IBM Research, Tokyo Research Laboratory, Tokyo, Japan", "person_id": "P1300971", "email_address": "", "orcid_id": ""}, {"name": "Michiaki Tatsubori", "author_profile_id": "81100553410", "affiliation": "IBM Research, Tokyo Research Laboratory, Tokyo, Japan", "person_id": "P1300972", "email_address": "", "orcid_id": ""}, {"name": "Tamiya Onodera", "author_profile_id": "81100474003", "affiliation": "IBM Research, Tokyo Research Laboratory, Tokyo, Japan", "person_id": "P1300973", "email_address": "", "orcid_id": ""}, {"name": "Yasuhiko Minamide", "author_profile_id": "81100225818", "affiliation": "University of Tsukuba, Tsukuba, Japan", "person_id": "P1300974", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1480881.1480908", "year": "2009", "article_id": "1480908", "conference": "POPL", "title": "Copy-on-write in the PHP language", "url": "http://dl.acm.org/citation.cfm?id=1480908"}