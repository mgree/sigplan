{"article_publication_date": "01-21-2009", "fulltext": "\n AFoundationfor Flow-BasedProgram Matching UsingTemporal Logic and Model Checking Julien Brunel Damien \nDoligez Ren\u00b4e Rydhof Hansen DIKU, University of Copenhagen, INRIA, Gallium Project, Department of Computer \nScience Denmark France AalborgUniversity, Denmark brunel@diku.dk damien.doligez@inria.fr rrh@cs.aau.dk \n Julia L. Lawall Gilles Muller DIKU, University of Copenhagen, Denmark Ecole des Mines de Nantes, France \n\u00b4 julia@diku.dk Gilles.Muller@emn.fr Abstract Reasoning aboutprogram control-.ow pathsis an important \nfunc\u00ad tionalityofa numberof recent programmatchinglanguagesand associated searchingandtransformation \ntools.Temporallogicpro\u00ad vides a well-de.nedmeans of expressing properties of control-.ow pathsin programs,and \nindeedanextensionofthetemporallogic CTLhasbeenappliedtotheproblemof specifyingandverifying the transformations \ncommonly performed by optimizing compilers. Nevertheless,indeveloping theCoccinelle program transformation \ntool for performing Linux collateral evolutions in systems code, we havefoundthat existingvariantsofCTLdo \nnotadequately support rulesthat transform subterms other thanthe ones matching an entire formula. Being \nable to transform anyof the subterms of a matched term seems essential in the domain targeted by Coccinelle. \nIn this paper, we propose an extension to CTL named CTL-VW (CTL with variables and witnesses) that is \na suitable basis for the semantics andimplementationof theCoccinelle sprogram matching language. Our \nextension to CTL includes existential quanti.cation over program fragments, which allows metavariables \nintheprogrammatchinglanguageto rangeoverdifferentvalues withindifferent control-.owpaths,andanotionofwitnessesthat \nrecordsuchexistential bindings for useinthe subsequentprogram transformationprocess.We formalize CTL-VW \nand describeits use in the contextof Coccinelle.We then assess the performanceof the approachin practice, \nusinga transformation rulethat .xes several reference countbugsin Linux code. Categories and Subject \nDescriptors D.3.1[Formal De.nitions and Theory]: Semantics; F.4.1[Mathematical Logic]:Temporal logic \nGeneral Terms Algorithms, Languages, Theory Keywords Programtransformation,bug .nding, programmatch\u00ad \ning, CTL, model checking Permission to make digital or hard copies of all or part of this work for personal \nor classroom use is granted without fee provided that copies are not made or distributed for pro.t or \ncommercial advantage and that copies bear this notice and the full citation on the .rst page.To copyotherwise, \nto republish, to post on servers or to redistribute to lists, requires prior speci.c permission and/or \na fee. POPL 09, January 18 24, 2009, Savannah, Georgia, USA. Copyright c . 2009ACM 978-1-60558-379-2/09/01... \n$5.00 1. Introduction Programmatchingisthe processofsearchingwithinthesourcecode ofa program forcode \nfragmentsmatchingagiven pattern, described using some language. Recently, program matching languagesthat \ncombine descriptions of code fragments with information about the control-.ow paths between them have \nbeen found useful in specifying rules for programmanipulationtasks such ascompiler optimizations[16, \n17],bug .nding[10], refactorings[24], and evolution [20]. In recent work, we have developed the transformation \nsystem Coccinelle[20], which providesthelanguage SmPL(Semantic Patch Language) for specifying desired \nmatches andtransformations. Coccinelle is targeted towards performing collateral evolutions in systems \ncode. Such evolutions comprise the changes that are neededin client codein responsetoevolutionsin libraryAPIs,and \nmay include modi.cations such as renaming a function, adding a function argument whose value is somehow \ncontext-dependent, and reorganizingadatastructure.Collateralevolutionsmayinvolve fragments of code that \nare scattered throughout a function or a .le, such asa function call andits corresponding error-handling \ncode, andthusitis often necessaryto take into account the control-.ow relationships betweentherelevantcodefragments.Beyondcollateral \nevolutions, we have alsofound Coccinelle usefulfor .nding and .xingbugsinthe useof APIfunctions[18], \nfor whichcontrol-.ow relationships must also be taken into account. Indeveloping Coccinelle,itwas necessaryto \nchooseafoundation on whichto basethematching process.Inthe contextof specifying compileroptimizations, \nLaceyandDe Moorhave observedthat thetemporallogicCTL canprovidea convenientfoundation for the semantics \nof program matching languages that take control\u00ad .owpaths into account,becauseitis designed for reasoningabout \npaths[16].Inthis setting,apatternis compiledintoa formulaof thelogic anda programis translated intoitscontrol-.ow \ngraph. CTL model checking[7, 12]is then usedto .ndthe nodes in the control-.owgraphthat satisfy the formula, \nthus identifying where the pattern matchesin the program.Tosupport thespeci.cationof compileroptimizations, \nLaceyandDeMoorextended CTL .rst with predicatesoverfreevariables, producingthelogicCTL-FV[17], and then \nwithpredicates over variables that may be existentially quanti.ed, producingalogicthatwerefertoas CTL-V[15]. \nThe former allows collecting information about the program during the matching process,viavariable bindings, \nandimposing constraints on the allowed subterms whenagivenvariableismatchedmore than once. The latter \nenableslocalizing collected information and imposed constraints to within individual subsets of the possible \ncontrol-.ow paths, such as the different branches of a conditional statement. The needsofCoccinelle,however,havemade \napparent some inadequacies ofCTL-V as the back end of a program matching language. While the use of existentially \nquanti.ed variables allows variablestohavedifferentvalues within different control .ow paths, thesemanticsofCTL-V \ndoes notprovidea meansof retrievingthe valuesofsuchvariables for use during subsequenttransformation. \nFurthermore, CTL-V model checking,like standardCTLmodel checking, only providesinformation about the \nstate at which the entire formulais satis.ed, and not aboutthe results for subformulas that contribute \nto a successful match. Information about such inter\u00admediateresults,however,isimportant whena single formula \ncan describe transformations of subterms, as is needed for Coccinelle. In this paper, we present a variant \nof CTL named CTL-VW (CTL with variables andwitnesses), thataddressestheabove needs for program matching. \nThe syntax of CTL-VW is the same as that of CTL-V, extending that of CTL with predicates de.ned over \nmetavariables that can be existentially quanti.ed over the set of program fragments. The semantics of \nCTL-VW maintains a collection of witnesses thatrecord thestates and bindingsthat satisfy existentially \nquanti.ed subformulas. We exploit these witnesses both to record variable bindings and to identify states \nat which transformation shouldtakeplace.Inpractice,wehaveusedCTL- VW as the basisof theimplementationof \nCoccinelle.Wehave used Coccinelletoimplementover60 collateralevolutions,affecting in totalover 5800 .lesinvariousrecentversionsof \nLinux[20]. Performing these transformations automatically both eases the collateral evolution process \nand helps avoid the many errors that have been introduced in the course of manually-done collateral evolutions[20].Wehavealso \nusedCoccinelleto.ndover90bugs in Linux code. The contributions of this paper are as follows: We present \nthe semantics of CTL-VW. We show that this semantics is a conservative extension of that of CTL-V. We \npresentintwo stepsamodel checking algorithmfor CTL-VW. In the .rst step, we extend the CTL model checking \nalgorithm with environments, producing a new model checking algorithm for both CTL-FV and CTL-V. In the \nsecond step, we furtherextendthis model checking algorithmwithwitnesses,for CTL-VW. We show that the \nmodel checking algorithm forCTL-VWis sound and complete with respect to the semantics of CTL-VW. We show \nhow to translate the core of Coccinelle s program matching language SmPLinto CTL-VW. This coreis suf.cient \ntoexpressa semanticpatch for .nding and .xing somebugs in the use of reference counts in Linux code. \nThe resulting corrections have been validated by Linux experts and accepted intothe Linuxkernel.1 Our \nexamples, both the ones for core SmPL considered in this paper and the ones for full SmPL consideredin \npreviouswork[20], showthat theCTL-VW based implementationofCoccinelleisef.cientenoughtobe usable on a \n1.4GHz laptop with 635MB of RAM. The restofthe paperis organized asfollows.Section2brie.y presents Coccinelle \nin terms of a real example that highlights the above-citedrequirements. Section3describesCTL and some \nvariantsthat areprecursorsto ourwork. Section4describes our .rst contribution:abottom-upmodelcheckingalgorithmforCTL-V. \nSection5introduces our second contribution: CTL-VW,including 1http://www.emn.fr/x-info/coccinelle/#impact \nitssyntax, semantics,anda model checkingalgorithm.Section6 describeshowCTL-VWisusedinthe contextofCoccinelle. \nFinally, Section7presents relatedwork and Section8concludes. 2. Overview of Coccinelle Our motivation \nfor this work was to be able to use CTL as a foundation for the semantics and implementation of SmPL, \nthe program matching and transformation language of Coccinelle [20]. The syntax of SmPL is derived from \nthat of a Linux patch .le [19], whichisa notationfamiliartoLinux programmers. Unlike a standard patch, \nhowever, which is text-based, a semantic patch takes into account the semantics of the matched code, \nin particular itsintraprocedural control-.ow.FromthepointofviewofCTL, therelevantfeaturesofa semanticpatch \narethatitmaydescribea complex region of code, speci.ed in terms of programfragments that should be connected \nby control-.ow paths, and that it may needto specifytransformations at anypoint withinthe described region. \nFurthermore, the region mayinvolve multiple control-.ow paths, e.g., dueto conditionals, and different \ncontrol-.ow paths may involve different computations, each of which may be relevant to the transformation \nprocess. In this section, we present the SmPL language via a short example thatillustratesthe aboveissues.We \ndefera more formal presentationofSmPLtoSection6,whereweshowhowto de.ne the semantics of its core language \nby translation into the CTL-VW logic developed in the next three sections. 2.1 Asimple SmPL sample Managing \nreference countsisacommonsourceof errorsinCcode. In particular, we have observed that Linux error handling \ncode sometimes does not appropriatelydecrement reference counts for objectsacquiredin the current function. \nFigure1showsa semantic patch type ref for correcting such problems involving the function of find node \nby type.This function increases a reference count that should subsequentlybe decrementedby calling the \nfunction of node put.ThesemanticpatchinFigure1insertsacallto of \u00adnode put after checking the validity \nof the result of of find \u00adnode by type (line8) andjust beforea returnin error handling code(indicatedbyareturnof \nanexplicit negativevalue,lines13 and 14). The semantic patch furthermore speci.es that there is not a \nprevious call to of node put (lines9and 15) and that the value returnedby of find node by type has not \nbeen saved in a possibly more permanent data structure, either directly(lines 10 and 16) or via a function \ncall (lines 11 and 17). The type ref semantic patch consists of a single rule, which .rst declares a \ncollection of metavariables and then de.nes a transformation speci.cation. The metavariables are designated \naccording to the kind of terms they can match, such as a statement, an identi.er, or an expression (line \n2). An expression metavariable canbe further constrainedbyitstype(line3).Thetransformation speci.cation \nessentiallyhastheformofCcode,exceptthatlines to remove are annotated with -in the .rst column, and lines \nto add are annotated with + (line 13).Atransformationspeci.cation can also use dots, ... (line7), describing \nan arbitrarysequence offunction arguments or instructionswithina control-.ow path. Dots maybe modi.ed \nwith a when clause (lines 9-11), indicating a pattern that should not occuranywhere within the matched \nsequence. Finally,lines 12-19specifyadisjunctionofpatterns,oftheform ( pat1 | ... | patn ). Full SmPL, \nas implemented in Coccinelle, provides manyfea\u00ad tures notillustratedby thisexample,such as multiple rules,subpat\u00ad \nternsthatmatch0ormoretimes,dots withinarbitrary subterms,and the abilityto use both universal andexistential \npath quanti.cation [20].Allofthesefeaturescanbeencodedsimilarlytothe basic strategies presented in Section \n6. @type ref@ 1 statement S; identi.er f1,f2; expression E1,E2; constant C; 2 struct device node *n; \nstruct device node *n1; struct device node *n2; 3 @@ 4 5 n = of .nd node by type(. . .) 6 ... 7 if (!n) \nS 8 ... when != of node put(n) 9 when != E1 = n 10 when != n1 = f1(n,. . .) 11 ( 12 + of node put(n); \n13 return -C; 14 | of node put(n); 15 | E2 = n 16 | n2 = f2(n,. . .) 17 | return . . .; 18 ) 19 Figure \n1. The semantic patch type ref writteninsimpli.ed SmPL  2.2 Requirements Ourgoalisto encodethe semanticpatchof \nFigure1 asasingle formula of a CTL-like logic. For this, the main issues are 1) to manage the metavariables \nn1, n2, C, etc., 2) to allow metavariables to match different terms along different control-.ow paths, \nas e.g., the return value Cmaybedifferentateachreturnsite whenthere are multiple returns under conditionals \n3) to record the various bindingsofthemetavariables withinthedifferent control-.owpaths, as e.g., the \nbinding of C may be neededto transform the enclosing return, and 4) to record the sites where transformation \nis needed. For thelast point,in our case, the completeformula representing the semantic patch would match \nat a call to of find node by \u00adtype, but transformation is required at the various matches of the subformula \nrepresenting return -C;.A semantic patch may indeedspecify a transformation anywhere within the matched \nterm. Among these requirements, CTL-FV provides only a representa\u00ad tion of metavariables, and CTL-Vadditionally \nallows metavariables tomatchdifferent termsalongdifferent control-.owpaths.We thus develop the logic \nCTL-VW that permits an encoding of a semantic patches that addresses the remaining requirements, i.e.,3) \nand 4). 3. Background Inthis section, we present the theoreticalbackgroundfor thework in the presentpaper. \nFirst, we brie.y reviewthe syntax, semantics, and algorithmic implementation of the well-known Computational \nTreeLogic(CTL)[7].Next,we presentavariantof CTL called CTL-FV(CTL withfreevariables) usedby Lacey et \nal. to show the correctnessofsome classical compiler optimizations[17].Finally, we present CTL-V (CTL \nwith variables), a CTL variant with existentiallyquanti.edvariablesthatwasusedinLacey ssubsequent work \n[15], and formally de.ne its semantics. 3.1 ComputationalTree Logic ComputationalTree Logicisatemporallogicbasedon \nthe notionof branchingtime[7].It has beenimplementedinavarietyof model checkers and usedto modelcheck \npropertiesrangingfrom hardware veri.cation [11, 14] to program analysis [22]. Inwhatfollowswe brie.yreviewthe \nsyntax and semanticsof CTLwithout going into detail.Foratextbooktreatment, see[12]. CTLisalogicfor reasoning \nabout statesand the paths between them. Its syntax is as follows: f ::= p | f . f | f . f |\u00acf |AXf | \nEXf | A[f U f] | E[f U f] (a) (b) (c) Figure 2. Some simple CTL models illustrating differences be\u00ad \ntween control-.ow paths Intuitively, the formulas p (propositions), f . f, f . f, and \u00acf arethe sameasin \npropositionallogic,andpermitreasoning about the properties of a given state. The remaining formulas permit \nreasoning about paths. AXf holds if all the successors of the current state satisfy f, while EXf holdsif \natleast one successor of the current state satis.es f. A[f1 U f2] expresses that along all paths thereissome \nstate where f2 holds, and requires that f1 hold at allpreceding states. E[f1 U f2] is similar, except \nthat there need beonly onepath withtheseproperties.Forexample,inFigure2a, the formula A[(f(1) . g(2)) \nU h(1, 2)] holds at state 1, because all pathseventuallyreachastate, i.e.,state3or5, where the proposition \nh(1, 2) holds, and atall previous states, i.e., states 1, 2, and 4, either f(1) or g(2) holds. On the \nother hand, in Figure 2c, AX(g(2)) does not hold at state 1, because g(2) does not hold at one of the \nneighbors, state 4. The semantics of CTL is de.ned over a model: DEFINITION 1. A model is a triple, (States, \n., Label), where States isa.nite setof states; .. States \u00d7States is the successor relation suchthat .s..r.s \n. r, i.e.,every state has atleast one successor;and Label : States .P(Atom) isa labellingfunction that \nassigns a set of atomic propositions to eachstate. The setofin.nite paths startingin state s is denoted \nPath(s).For a path p = s0 . s1 . \u00b7 \u00b7\u00b7 . sj . \u00b7 \u00b7\u00b7 the jth element is denoted by p[j], i.e., p[j]= sj \n. Notethatthesetofpathsmaybein.nite. Finally,the next function computes the setof successors of a given \nstate: next(s)= {s ' | s . s '}. We now formally de.ne the semantics for CTL as a set of judgementsof \nthe form M,s |= f,whereM isamodel, s . States and f isa CTL formula.Forconvenience, weelide themodelin \nthe judgements: s |= p . p . Label(s) s |= f1 . f2 . s |= f1 . s |= f2 s |= f1 . f2 . s |= f1 . s |= \nf2 s |= \u00acf . s |= f s |= AXf ..s ' . next(s).s ' |= f s |= EXf ..s ' . next(s).s ' |= f s |= A[f1 U f2] \n..p . Path(s)..i = 0.p[i] |= f2 . .0 = j < i.p[j] |= f1 s |= E[f1 U f2] ..p . Path(s)..i = 0.p[i] |= \nf2 . .0 = j < i.p[j] |= f1 Figure3presentsa modelchecking algorithm,SAT,for CTL. Givena formula anda \nmodel,SATreturnsthe setof statesatwhich theformulaistruein the model. The algorithmis based onthat presented \nin[12], but we have reorganized it so that it can be easilyextendedtothelogicsCTL-FV,CTL-VandCTL-VW thatwe \nconsider subsequently.Inparticular,thealgorithmacceptspredicates parameterizedbya list of variables x, \nwhich in the case of CTLwill alwaysbeanemptylist,andit includesalineforformulas .x.f, which are notpartofCTL.Inthe \nlattercase, the instantiationof the model checking algorithm for CTL simplyfails. SATfunction: SAT(p(x)) \n= {inj(s, .) | p(.(x)) . Label(s) . dom(.)= fv(p(x))}SAT(f1 . f2)= conj(SAT(f1), SAT(f2)) SAT(f1 . f2)= \ndisj(SAT(f1), SAT(f2)) SAT(\u00acf)= neg(SAT(f)) SAT(.x.f)= exists(x, SAT(f)) SAT(AX f)= pre.(SAT(f)) SAT(EX \nf)= pre.(SAT(f)) SAT(A[f1 U f2]) = SATAU (SAT(f1), SAT(f2)) SAT(E[f1 U f2]) = SATEU (SAT(f1), SAT(f2)) \nOperators on SATresults: conj(T1,T2)= {t1 n t2 | t1 . T1 . t2 . T2 . t1 n t2 is de.ned} Conj = fold \nconj {inj(s, \u00d8) | s . States} disj(T1,T2)= T1 . T2 Disj = fold disj \u00d8 neg(T )= Conj {negone(t) | t . \nT } exists(x, T )= {existsone(x, t) | t . T . ex binding(x, t)} S pre.(T )= s.States(Conj {shift(s',T,s) \n| s' . next(s)}) S pre.(T )= s.States(Disj {shift(s',T,s) | s' . next(s)}) SATAU (T1,T2)= localvar W \n= T1,Y = T2,X; repeat X = Y ;Y = disj(Y, conj(W, pre.(Y ))); until same(X, Y ); return Y ; SATEU (T1,T2)= \nlocalvar W = T1,Y = T2,X; repeat X = Y ;Y = disj(Y, conj(W, pre.(Y ))); until same(X, Y ); return Y ; \nElement level operators, for CTL: inj(s, .)= s s1 n s2 = s1, if s1 = s2 negone(s)= {s' | s' . States \n-{s}}shift(s1,T,s2)= {s2}, if s1 . T, \u00d8 otherwise same(T1,T2)= T1 = T2 existsone and ex binding are not \nde.ned Figure 3. Ageneric model checking algorithm and its instantiation for CTL.In CTL,fora predicate \np(x), the sequence of variables x is always empty. The same is thus true of the environment .. In this \nalgorithm, the SATfunction simply serves to recursively traversethe formula,exceptinthe caseofa proposition, \nwhereit returns each state where the propositionis satis.ed (recall that x is emptyfor CTL). Thefunctions \nappliedtothe intermediateSAT results then perform the main calculation of the algorithm. The function \nconj combines compatible information from two sets of results, andthusimplements conjunction.Inthe caseof \nCTL, this amountsto intersection. The function disj collects allinformation from two sets of results, \nand thus implements disjunction. The functions Conj and Disj fold conj and disj over a set of results, \nrespectively,andareusedto de.ne someoftheother functions.The function neg computes the complement of \na set of results, and in the case of CTL amounts to returning the difference between the completesetofstatesandthegivensetofstates.The \nfunctions pre. and pre. havetheeffectof checkingwhetherall neighborsofa state areinagiven setof results \norwhetherthereexistsa neighborofa statethatisinagivensetofresults, respectively.These functions are used \nin the implementation of AX and EX, respectively, and in the de.nition of the functions SATAU and SATEU \nthatimplement AU and EU. The remainingfunctions manipulate the elementsof the setsof results,whicharestatesinthe \ncaseofCTL.The function inj takes as arguments a state s and an environment . (always emptyfor CTL) andinjectsit \nintothetypeofresultsforthegivenlogic,whichinthe case of CTLimpliesjust droppingthe environment. The (partial) \nfunction n determines whethertworesults are compatible, which simply means thatthey are equalinthe caseof \nCTL. The function negone computes the complement of a single result. The function shift returns all resultsin \na set T that are associated with a state s1,butreplacesthe stateinformationineachcaseby another state \ns2;thisfunctionmakesit convenienttoimplementpre. and pre.. Finally, thefunction same makesitpossibletovarythetermination \ncondition for the .xpoint iterations in SATAU and SATEU . It is straightforward to show that this algorithm \nis sound and complete with respect to the semantics [12]: THEOREM 1 (Soundness and completeness). s |= \nf . s . SAT(f) 3.2 ComputationalTree Logic withfreevariables WhileCTL has proventobevery usefulin thecontextofprogram \nanalysis[22], Lacey et al. showed that the extension CTL-FV, supporting not propositionsbutpredicatesoverfreevariables, \ncould be usedinthe contextof program transformation [17]. In particular CTL-FVhasbeenusedtoformalizeandprove \ncorrectanumber of classical compiler optimizations[17, 21]. The introduction of variablesimpliesthat \nthelogic satis.es our .rstrequirement for Coccinelle (Section 2.2). The syntaxofCTL-FVis essentiallythesameas \nthatofCTL withthe additionof predicatesover freevariables.We refertothese variables as metavariables: \nf ::= p(x) | f . f | f . f |\u00acf |AXf | EXf | A[f U f] | E[f U f] fv(f) is the set of free metavariables \nof a formula f. The semanticsof CTL-FVisalmostthe sameasthatofCTL; indeed,theyarebasedonthesame models.Thenewfeaturesarethat \nthe semanticsofpredicatesnowtakesfreevariablesintoaccountand alljudgements now carry an environment ., \nmapping metavariables to an arbitrary set of values, Val: Env = MetaVar . Val The semantics is de.ned \nas follows. Again we elide the model: s |= . p(x) . p(.(x)) . Label(s) s |= . f1 . f2 . s |= . f1 . s \n|= . f2 s |= . f1 . f2 . s |= . f1 . s |= . f2 s |= . \u00acf . s |= . f s |= . AXf ..s' . next(s).s' |= f \ns |= . EXf ..s' . next(s).s' |= f s |= . A[f1 U f2] ..p . Path(s)..i = 0.p[i] |= . f2 .0 = j < i.p[j] \n|= . f1 s |= . E[f1 U f2] ..p . Path(s)..i = 0.p[i] |= . f2 .0 = j < i.p[j] |= . f1 Model checking for \nCTL-FV has been done using a standard CTL model checker by instantiating the formula with respect to \nall possible bindingsof the metavariables[21], where Val is limited to the set of subterms in the program. \n 3.3 ComputationalTree Logic with quanti.edvariables Lacey further extended CTL-FV with the ability \nto existentially quantifyover metavariables[15],producinga logicthat we referto as CTL-V. The syntax \nof CTL-V is as follows: f ::= p(x) | f . f | f . f |\u00acf |.x.f | AXf | EXf | A[f U f] | E[f U f] The semantics \nis the same as that of CTL-FV, augmented with: s |=. .x.f ..v . Val.s |= .[x .v] f f(x) . AX(g(y) . AX(h(x, \ny))) f(x) . AX(.y.(g(y) . AX(h(x, y)))) Figure 4. CTL-FV and CTL-V formulas Introducing the ability to \nquantify over metavariables allows metavariables to have different values within different control\u00ad.ow \npaths (our second requrement forCoccinelle) and thus adds .exibility as compared to CTL-FV. For example, \nconsider the formulasin Figure4,ofwhichthe .rstisin bothCTL-FV and CTL\u00adV,andthesecondisonlyinCTL-V.Bothformulas \naresatis.edat state1in the modelin Figure2(a), asitis possibleto uniformly assign x to1and y to2.Only \nthesecondformulaissatis.edatstate 1in the modelinFigure 2(b), asin the leftbranch(states2and3), y mustbe2,whilein \ntheright branch(states4and5), y must be 3. Finally, neither formulais satis.edatstate1in themodelinFigure \n2(c),asitisnotpossibletochoosea consistentvaluefor y inthe left branch (states2and3). Lacey has presenteda \nmodel checking algorithmforCTL-V [15]. This algorithmfollowsatop-downstrategy,inwhichittriesto satisfy \nthe complete formula at each state of the model, rather than following a bottom-up strategy, which is \nthe source of the ef.ciency ofthestandardCTLmodelchecking algorithmpresentedinFigure3. No precise performance \nmeasurements are provided. 4. AModel Checking Algorithmfor CTL-V In this section, we present a new, bottom-up, \nmodel checking algorithmforCTL-V thatis based on the CTLmodel checking algorithm presentedinFigure 3. \nThis algorithmis not suf.cient asafoundation for Coccinelle, asit does notrecord information aboutthebindingsofexistentially \nquanti.edvariables.Nevertheless, it permits to introduce a representation of environments that is commonto \nmodel checking for bothCTL-V andCTL-VW, and the algorithmmaybeofindependentinterestin contextoftheworkof \nLaceyandDe Moor[16].While the CTL model checking algorithm identi.esthesetofstateswherea formulaissatis.ed,theCTL-V \nmodel checking algorithm must identify the set of pairs of a state and an environment that satisfy theformula.The \nalgorithmis applicable to both CTL-V and CTL-FV, and even to CTL, although the environment it collects \nis unnecessary in the latter case. We .rst present a representation of environments that allows the CTL-V \nmodel checking algorithm to ef.ciently represent in\u00adformation about bindings,then present theCTL-Vmodel \nchecking algorithm,and .nallyconsiderits soundnessand completeness with de.ne .1 . .2 iff .1 = .. respect \nto the semantics of Section 3.3. dom(.1)..+(x)= .+(x) . .+(x) ./.-(x) . .-(x) . .-(x) 1 2121 2 \u00b4 Ratherthan \nnegatinga bindingby creatinga disjunctionof all ofthe possible bindings for thevariable other thanthecurrent \none, weaddtheabilityto representnegative bindings directly.Thus,we de.ne an extendedform of environment, \nEnv\u00b1,in which a variable is mapped eitherbya positive bindingtoan elementof Val or by a negative binding \nto an element of P(Val): Env\u00b1 =(MetaVar . Val + P(Val)). Theaddedbottom elementis usedtorepresentanenvironmentthat \ncontains con.ictinginformation. The domain of . is unde.ned. ` The following notationfacilitates reasoningabout \nthe positive and negative bindings of an environment: DEFINITION 2. Let . . Env\u00b1.We de.ne 1. dom+(.)= \n{x . dom(.) | .(x) . Val} 2. dom-(.)= {x . dom(.) | .(x) .P(Val)} 3. .+(x)= .(x) iff x . dom+(.) 4. \n.-(x)= .(x) iff x . dom-(.)  Env+ = {. . Env\u00b1 | dom(.) . dom+(.)} is the set of the environments thathave \nonly positive bindings. Env+ isthe same as Env, andthusistheformof environment acceptedbythe semantics. \nEnv+ = {. . Env\u00b1 | dom(.)= dom+(.) n fv(f)} is the subset f of Env+ restricted to the free variables \nof the formula f. NOTATION 1. For convenience, wede.nethefollowingexplicit no\u00ad tation forenvironments.Let \n{x1,...,xn,y1,...,ym}. MetaVar be a set of pairwise different meta-variables. Then [x1 . v1,..., xn . \nvn,y1 . V1,...,yn . Vn] represents the environ\u00adment . such that .(xi)= vi . Val for every i . 1..n and \n.(yj )= Vj .P(Val) for every j . 1..m. DEFINITION 3 (Con.ict). Two environments .1,.2 . Env\u00b1, with .1 \n= ., .2 = ., con.ict iff .x . dom(.1) n dom(.2) .1+(x)= .2+(x) . .1+(x) . .2 -(x) . .2+(x) . .1 -(x) \nOtherwise, .1 and .2 are said to be compatible. Next, we introduce an ordering on environments. This \nordering is neededtorelate the environments that are returnedbythealgorithm, which can contain negative \nbindings, to the ones that satisfythe formula according to the semantics. Intuitively an environment \nwithmore speci.c informationis less than one withlessspeci.c information, e.g., [x = 42,y = 12] . [x \n= 42] . [x = 87]. DEFINITION 4 (Environment ordering). Let .1,.2 . Env\u00b1 and . dom(.1) . dom(.2) ..x \n4.1 Environmentsfor CTL-V model checking A recurring problem in model checking is how to represent the \nresult of negation; the size of the complement of a set of states dependsonthe numberofstatesinthe model,whichcanbevery \nlarge. For CTL-V, where the result of model checking is a set of state-environment pairs, taking the \ncomplement of the result includes taking the complement of the environment, where the size of the result \ndepends on the size of Val. In the case of program matching, Val containsatleastthesetofsubtermsofthe \nprogram. In ourexperience,the setofbindings thatderivefrom matchinga predicate againstthe source code \nis quite small, and thus taking the Accordingtothis ordering, the environment with the empty set as its \ndomain is the greatest element T and . is the least element. To compute the environment that satis.es \na conjunction in agiven state, the algorithmjoins the environmentsthat satisfy eachoftheconjunctformulasin \nthe samestate. The joinoftwo environments is de.ned as follows: DEFINITION 5 (Environment join). Let \n.1,.2 . Env\u00b1.We de.ne .1 n .2 to be . if .1 = . or .2 = .,i.e., .1 n. = .n .2 = .. For.1 = ., .2 = .,if \n.1 and .2 arecompatible, .1 n .2 is de.ned as follows: complement in this manner wouldincur a substantial \nperformance overhead.To address this issue, we use constructive negation [6]. 2 8 >>< >>: v if .1+(x)= \nv . .2+(x)= v V1 if .1 -(x)= V1 . x/. dom(.2) V2 if .2 -(x)= V2 . x/. dom(.1) (.1 n .2)(x)= 2Another \napproach would be to use BDDs, for which negation can be performedin constanttime.Wehavenottakenthisoption,however,because \nV1 . V2 if .1 -(x)= V1 . .2 -(x)= V2 itisnotclearhowitscalestoinclude witnesses, whichweaddinCTL-VW. \nIf .1 and .2 con.ict, then .1 n .2 = .. Itisstraightforwardtoshowthatthejoinoperator computesthe greatestlower \nboundoftwoenvironmentsaccordingtotheenviron\u00ad ment ordering. Finally,we concludewiththe de.nitionofthenegationofan \nenvironment. This operation can create negative bindings. DEFINITION 6 (Negationof an environment). For. \n. Env\u00b1, we de.ne 8 <{T} if . = . \u00ac. = {[x .{v}] | v = .+(x)}.{[x . v] | v . .-(x)} : otherwise Notice \nthat \u00ac. .P(Env\u00b1).  4.2 Abottom-up CTL-V model checking algorithm ThealgorithmSATforCTL-Vtakes asargumentsamodel \nanda formulaandreturnsaresultinthe formofasetofpairs (s, .) . State \u00d7 Env\u00b1.As comparedto the de.nitionofSATinFigure3, \nit is only necessary to rede.ne the element-level functions inj, n, negone, existsone, shift, and same \nto take environmentsinto account. The new de.nitions are as follows: inj(s, .) =(s, .) (s1,.1) n(s2,.2) \n=(s1,.1 n .2), if s1 = s2 . .1 n .2 = . negone(s, .)= {(s ' , [ ]) | s ' . States -{s}} . {(s, . ' ) \n| . ' .\u00ac.}existsone(x, (s, .)) =(s, . - [x . v]), if .+(x)= v (s, . - [x . V ]), if .-(x)= V (s, .), \notherwise ex binding(x, (s, .)) = .(x)= Val shift(s1,T,s2)= {(s2,.) | (s1,.) . T }same(T1,T2)= T1 = T2 \nThefunction inj, usedtoinjectthe resultof matchingapredicate into the codomain of SAT, now keeps both \nthe state and the environment arguments. The function n, used in computing a conjunctionofresults,extendstheCTL \nde.nitionbytaking the joinofthe associated environments. The function negone, used in computingthe negationofa \nresult, similarlyextends the de.nition for CTL by including not only eachelement of the complement of \nthegiven state,pairedwiththeemptyenvironment,butalsopairs for the current state combined witheach element \nofthe negation of the current environment. These pairs represent the least speci.c ones that areincompatible \nwiththegiven stateand environment pair. The function existsone discardsthe bindingofa quanti.edvariable \nxfromtheenvironmentofastate/environmentpair.This function is calledby exists on all the result elements \nthat satisfy ex binding forthevariablex,i.e., thatdonotexcludeall valuesforx.The function shift selects \nthe pairs in T thathavethe samestateasits .rstargumentandreplacesthestatein eachpairwiththestateinits \nthird argument, asis neededtoimplementthe operators AX and EX. Finally,thefunction same simplychecks \nwhethertheresultsitis given represent equivalent sets, as in the CTL de.nition. Model checkingfor CTL-Vis \nguaranteedtoterminatebyan extensionoftheargumentthatthemodel checkingalgorithmfor CTLis guaranteedto \nterminate[12]. In particular, we observe that the set of pairs (s, .) that can be generated by the algorithm \nis determinedbythe numberofstatesinthe control-.owgraph,the number of variables in the CTL-V formula, \nand the number of subterms in the program, all of which are .nite. 4.3 Examples As examples of the CTL-Vmodelchecking \nprocess, we consider again the models of Figure 2 and the formulas of Figure 4. In checking the formula \nf(x) . AX(g(y) . AX(h(x, y))) with respect the model in Figure 2b, the result for the subformula g(y) \n. AX(h(x, y)) is {(2, [x . 1,y . 2]), (4, [x . 1,y . 3])} Model checking of the enclosing AX, howeverfails, \nbecause al\u00ad though bothof the neighborsof state1arein the above result, they are associated with con.icting \nenvironments.On the other hand, in checking the formula f(x) . AX(.y.(g(y) . AX(h(x, y)))), with respect \nto the same model, the same result is obtained for g(y) . AX(h(x, y)),but for .y.(g(y) . AX(h(x, y))), \nthe result is {(2, [x . 1]), (4, [x . 1])} in which the con.icting bindings of y have beendropped. Thistime, \nthe result ofthe enclosing AX is {(1, [x . 1])}, which inturnis the result of checking the entire formula. \n 4.4 Soundness and completeness The modelchecking algorithmfor CTL-V can return environments thatcontain \nnegativebindings, whilethe semantics forCTL-V only acceptsenvironments withpositivebindings. Thus,the \nrelationship between themis not as direct as in the case ofCTL(Theorem 1). Instead,the soundnessandcompleteness \ntheorem for the CTL-V model checking algorithm relates an environment produced by the algorithm, which \nmay contain negative bindings,to thesetof more speci.cenvironmentsthatcontainonlypositivebindingsand \nare accepted by the semantics: THEOREM 2 (Soundness and completeness). Let f be a formula, and T .P(State \n\u00d7 Env\u00b1). Let us de.ne .f(T )= {(s, .) . State \u00d7 Env+ |.(s ' ,. ' ) . T.s = s ' . .. ' }. Then, f .s.. \n(. . Env+ . s |= . f) . (s, .) . .f(SAT(f)) f The proof of this theorem has been validated with Coq [3]. \n3 5. CTL-VW CTL-Vallows variables to have different values in different control\u00ad .ow paths, but discards \ntheir bindings, making it impossible to referto suchvariablesina subsequenttransformation phase. The \ngoal of CTL-VWis to collect the bindings of such variables, as witnesses, in a way that does not affect \nthe rest of the matching process. Thissatis.es thethirdof ourrequirements for Coccinelle (Section 2.2).We \n.rst de.newitnesses,thengivethe semantics and model checking algorithmof CTL-VW, and .nallysketchthe \nproof of the soundness and completeness of the model checking algorithm. 5.1 Witnesses Awitness is essentially \na record of a state, a binding, and the set of witnesses for other bindings thatcontributedto establishing \nthe bindinginthegiven state.Awitnessthushasatreestructure,which correspondstothestructureofthe nestedexistentialquanti.ersin \nthe formula. DEFINITION 7 (Witnesses). The set Wit of witnesses is de.ned as: Wit = States \u00d7 MetaVar \n\u00d7 (Val + P(Val)) \u00d7 WitForest A witness forest O . WitForest is a multiset of witnesses, i.e., a pair \n(W, f), where W . Wit is a set of witnesses, and f : W . N* is a function that associates each witness \nwith its multiplicity(a nonnegative integer).We de.ne WitForest+ as the set of the witness forests in \nwhichall bindings are positive. 3URL: http://www.emn.fr/x-info/coccinelle/ctlv.tar.gz The operator l \nproducesthejoinoftwomultisets.For easeof reading, we sometimes use the set-like notation {...} to enumerate \nthe elements of a multiset. Then, {a, a, b} represents the multiset whose underlying set is {a, b}, andwhere \nthemultiplicitiesof a and b are2and1, respectively. We use multisets rather than sets for technical reasons. \nHowever, in order to specify a termination criterion in the model checking algorithm, we need to reason \nabout the underlying sets of witness forests.We de.ne the binary operator . as follows: O1 . O2 iff wit \nred(O1)= wit red(O2) wit red(O) translates O into the corresponding underlying set. As for environments, \nwe de.ne an ordering on witnesses, and on witness forests.These orderings are usefulto relate the results \nofthealgorithm, which can containnegative bindings,towitness forests that satisfy the formula according \nto the semantics. DEFINITION 8 (Witness ordering). Let w = (s, x, a, O) and w ' = ''' ' (s ,x ,a , O \n') be two witnesses.We de.ne ww ' iff s = s . x = x ' . [x . a][x ' . a ' ] . OO ' . The ordering for \nwitness forests is de.ned as follows: (W, f)(W ' ,f ' ) iffthere is a bijection h suchthat 1. h : {(w, \ni) | w . W . i . 1..f(w)}. {(w ' ,j) | w ' . W ' . j . 1..f ' (w ' )} 2. .w . W..i . 1..f(w).w w ', \nwherethereis some j such that (w ' ,j)= h(w, i) 5.2 Asemanticsfor CTL-VW The newfeatureof the semanticsofCTL-VWisto \nde.ne whatit means to be a witness forest for a formula f, with respectto some state and environment. \nIf f = .x.., thenawitnessforestfor f should record a binding of x that satis.es ., as well as a witness \nforest that recordsinformation about the bindingsassociatedwith any existential quanti.ers in ..If f \n= f1 . f2, then a witness forest for f hastobea witnessforest foreither f1 or f2, because the information \nneeded to satisfy f1 or f2 also satis.es f1 . f2. Awitness forest forf = f1 . f2 has to contain the information \nthat makes f1 true andtheinformationthatmakes f2 true. Thus, the semantics joins a witness forest for \nf1 and a witness forestfor f2 to obtain a witness forest for f1 . f2. Similarly, for AX.,the semantics \ncollects, for eachsuccessorofthecurrentstate, a witness forest thatmakes . truein thissuccessor.Onthe \notherhand,since EX is relatedtodisjunction(c.f.,Figure 3), a witness forestfor EX. isa witness forestfor \n. in oneof the successorsofthe current state. If f = A[f1 U f2], then we can de.nea witness forestfor \nf by analogy with conjunction and AX. Then, the usualsemantics of AU implies that a witness forest of \nf collects as many witnesses asthere are paths starting from the current state. Thisleads to an in.nite \nnumber of witness forests, carrying redundant information. Inordertocollectonlywitnessforests thatprovidenewinformation, \nthe semantics reasons about a .nite unfolding of the model when de.ning the semantics of AU, rather that \nreasoning about all the paths. Then, a witness forest of A[f1 U f2] collects a witness forest of f1 for \nevery state in the .nite unfolding that is not a leaf, and a witness forest of f2 for every leaf. A witness \nforest for f = E[f1 U f2] collects,for somepathleadingtoaleaf,a witness forest for f1 inevery non-leafstateinthispath,andawitness \nforest for f2 in the leaf. DEFINITION 9 (Finite paths). Given a model and a state s, we de.ne FPath(s) \nas the setof the .nite paths starting from s. Given a .nite path p . FPath(s), |p| is the lengthof p, \ni.e., |p| +1 is the number of states in p, pre.x(p) representsthe setof the (.nite) proper pre.xes of \np, and p.n, for n . |p|, represents the pre.x of p containing the .rst n +1 states (from p[0] to p[n]). \n Figure 5. Illustration of .nite unfolding DEFINITION 10 (Finite unfolding). Givena state s,a .nite unfold\u00ad \ning from s isa set S . FPath(s) where every path p . S satis.es the following constraints: .p ' . pre.x(p).p \n' ./S (no redundancy) p ' .i . 0..|p|- 1. .s ' . next(p[i]). .p ' . S. = p.i .i . s ' = p ' [i + 1] (full \nbranching) The setof the .nite unfoldings starting from s is denoted .(s). The set of the states that \nappear in some path of S is denoted S. Considerthe model shownin Figure5. Then {s0} and {s0 . s1,s0 . \ns2 . s2} are two valid.nite unfoldings starting from s0. Onthe other hand, {s0 . s1,s0 . s2,s0 . s2 . \ns2} violates the .rst constraintofDe.nition10,and {s0 . s1} does notexplore the right branch, and thus \ndoes not satisfy the second constraint. DEFINITION 11 (Semantics). Given a model (States, ., Label), \na state s . States, a formula f, an environment . . Env+, and a witness forest O . WitForest+,the semanticsofCTL-VWis \nde.ned as the following relation: s |= .,\u00d8 p(x) . p(.(x)) . Label(s) s |= .,O1cO2 f1 . f2 . s |= .,O1 \nf1 . s |= .,O2 f2 s |= .,O f1 . f2 . s |= .,O f1 . s |= .,O f2 s |= .,\u00d8 \u00acf ..O.s |= .,O f s |= .,{(s,x,v,O)} \n.x.f . s |= .[x.v],O f s |= .,O AXf ..(OsI )sI.next(s). U OsI =O ..s ' . next(s).s ' |=.,O f sI.next(s)sI \ns |= .,O EXf ..s ' . next(s).s ' |= .,O f s |= .,O A[f1 U f2] ..S . .(s). .(OsI )sI.S. .p . S.p[|p|] \n|= .,Op[|p|] f2 ..0 . j< |p|.p[j] |= .,Op[j] f1 U . sI =O I.SOs s |= .,O E[f1 U f2] ..S . .(s). .p . \nS..(Oi)i.0..|p|. p[|p|] |= .,O|p| f2 ..0 . j< |p|.p[j] |= .,Oj f1 U . Oj =O j.|p| Notethatthe semanticsdoesnotallowanywitnesstobesatis.ed \nundera negation. Thisfacilitates the proofofthe soundness and completeness of the model checking algorithm. \nIndeed, a negation turns the nature of an existential quanti.cation to a universal quanti.cation, for \nwhich witnesses would not make any sense. However, one couldjustifytheinterestofawitnessforanexistential \nquanti.erthatappears underaneven numberofnegations.Wedonot considera special treatmentforthis case.Becauseof \nthis constraint on negation,we mustinclude both AX and EX in thelogicexplicitly, because a de.nition \nof e.g., EX in terms of AX and negation, would preclude witnesses under EX. 5.3 Amodel checking algorithmfor \nCTL-VW ThealgorithmSATforCTL-VWtakesasargumentsa modeland a formula and returns a set of triples of the \nform (s, ., O) . States \u00d7 Env\u00b1 \u00d7 WitForest.The new de.nitions of the element\u00ad level functionsof Figure3are \nas follows: inj(s, .) =(s, ., \u00d8) (s1,.1, O1) n(s2,.2, O2)= (s1,.1 n .2, O1 l O2), if s1 = s2 . .1 n .2 \n= . negone(s, ., O) = {(s ' , [], \u00d8) | s ' . States -{s}} . {(s, . ' , \u00d8) | . ' .\u00ac.} existsone(x, (s, \n., O)) = (s, . - [x . v], {(s, x, v, O)}), if .+(x)= v (s, . - [x . V ], {(s, x, V, O)}), if .-(x)= V \n(s, ., {(s, x, \u00d8, O)}), otherwise ex binding(x, (s, ., O)) = .(x)= Val shift(s1,T,s2)= {(s2, ., O) | \n(s1, ., O) . T } same(T1,T2)= triple red(T1)= triple red(T2) where triple red(T )= {(s, ., wit red(O)) \n| (s, ., O) . T } These de.nitions augmentthecorresponding de.nitions forCTL- Vtomaintainthe witnesses.As \nthere are noexistentialquanti.ers under a predicate, the function inj just uses an empty witness forest. \nThefunction n takes thejoinoftheprovided witnessforests,if the provided states and environments are compatible. \nThe function existsone considers the same cases asfor CTL-V,but ratherthan discarding the binding of \nthe quanti.ed variable converts it to a witness, encapsulating the current witnessforest. Thefunction \nshift is analogousto theCTL-V de.nition. Finally, the function same, usedto identifya.xedpoint,.rst convertsallwitnessforestsinits \nargumentstotheirunderlyingsets,using wit red,andthen compares the obtained results. It remains to considerthe \nde.nition of negone. This function negates the state component, and then the environment component, asinthe \nCTL-V de.nition,but completely discards the witness component. This strategy corresponds to the semantics \nof negation presented in Section 5.2, where the subformula should not be satis.ableatthegiven stateandenvironmentforanywitnessforest. \nModelcheckingforCTL-VWis guaranteedtoterminate,bythe same argument as was used for CTL-V (Section 4.2). \n 5.4 Examples As in Section 4.3, we consider the models of Figure 2 and the formulasof Figure4.In checking \ntheformula f (x) . AX(g(y) . AX(h(x, y))) withrespectthemodelin Figure2b,theresultforthe subformula g(y) \n. AX(h(x, y)) is {(2, [x . 1,y . 2], \u00d8), (4, [x . 1,y . 3], \u00d8)} Model checkingfor the enclosing AX fails \nas before, becausethe environments are incompatible.In checking theformula f(x) . AX(.y.(g(y) . AX(h(x, \ny)))), with respect to the same model, the sameresultis obtained for g(y) . AX(h(x, y)),but now for .y.(g(y) \n. AX(h(x, y))), the result is {(2, [x . 1], {(2, y, 2, \u00d8)}), (4, [x . 1], {(4, y, 3, \u00d8)})} in which theinformation \nabout thevariousbindingsof y is still available. The result of the enclosing AX is then {(1, [x . 1], \n{(2, y, 2, \u00d8), (4, y, 3, \u00d8)})} whichisinturnthe resultfortheentireformula.This resultincludes the possible \nbindings of y andthestatesatthe rootofthepathsin which those bindings are applicable.  5.5 Soundness \nand completeness As for CTL-V, theCTL-VWmodelchecking algorithm may return an environment with negative \nbindings. We thus extend the . function of Section 4.4 to take witnesses into account. Let f beaformula, \nand T .P(States \u00d7 Env\u00b1 \u00d7 WitForest). Let us de.ne .f(T )= {(s, ., O) . States\u00d7Env+\u00d7WitForest+ | f .(s \n' ,. ' , O ' ) . T. s = s ' . .. ' . OO ' }. THEOREM 3 (Soundness). .s, ., O. (s, ., O) . .f(SAT(f)) \n=. s |= .,O f Proof sketch Theproofisbystructural inductionon f.Wepresent the case f = A[f1 U f2].We \n.rstde.ne a bounded semantics for AU, and a bounded SAT algorithmfor AU. s |= .,O A[f1 U f2] N iff there \nis a .nite unfolding S whose maximum length is less than or equal to N,and such thatthe semantic de.nitionof \nAU is satis.ed with S. SATAU (f1,f2) N corresponds to N iterations of the algorithm described in SATAU \n(f1,f2). The followinglemma relates the bounded semantics to the bounded algorithm. LEMMA 1. Let f = \nA[f1 U f2]. Then, .s, ., O,N (s, ., O) . .f(SATAU (f1,f2) N ) . s |=.,O A[f1 U f2] N We omit the proofof \nthis lemma, also doneby induction. Let (s, ., O) . .f(SATAU (f1,f2)). Then, .N. (s, ., O) . .f(SATAU \n(f1,f2) N ). By Lemma 1, s |= .,O A[f1 U f2] N , so s |= .,O A[f1 U f2]. . The completeness theorem cannot \nbe stated as directly as the soundnesstheorem. Indeed,if f contains AU or EU,awitnessforest accepted \nby the semantics may contain duplications of witnesses, duetotheuseofmultisets.Inthis case,thewitnessforestisnot \nreturned by the algorithm in its exact form, but the algorithm producesa shorterandequivalent(inthesenseof \n)witnessforest. THEOREM 4 (Completeness). .s, ., O. . . Env+ . s |= .,O f =..O ' O. (s, ., O ' ) . .f(SAT(f)) \nf Proof sketch The proofis doneby induction.In the AU case, we use a lemma analogous to Lemma 1. . To \nconclude, we consider the relationship between CTL-VW andCTL-V.CTL-VWisa conservativeextensionof CTL-V:the \ncollection of witnesses does not have anyimpact on the satis.ability of a formula. PROPERTY 1 .s, ..s \n|= . f .. .O . WitForest+ .s |= .,O f CTL-V CTL-VW 6. Applying CTL-VW in the context of Coccinelle Inthissection,we \nde.neacore SmPL language, thatis suf.cient to treat theexample presentedinSection 2.1 (Figure1), present \nits translation intoCTL-VW, describe the matching andtransformation process, and then present a few benchmarks. \nManymore examples of the use of SmPL and the associated performance are available in our previouswork[18, \n20]. The section concludes with a brief example illustrating the bene.t of being able to mix existential \nand universal path quanti.cation, as providedby temporal logics based on CTL. For the purposes of this \npresentation, we have slightly simpli.ed thesemanticsofSmPL,inthatour encodinginCTL-VWallowsdots ( ... \n)to matchanypath,whileinSmPLdotsrepresenttheshortest path between terms matching the preceding and following \npatterns. This shortest pathconstraint can be encoded straightforwardlyin CTL-VW. Furthermore, it is \npossible to drop the shortest path constraint in full SmPL by annotating the dots with when any. 6.1 \nSyntax of a simpli.ed SmPL The syntaxofthetransformation speci.cation partofasemantic patchis quite complex, \nbecause -and + annotations canbefreely mixed. In a transformation speci.cation, the combination of the \nunannotated code and the -code represents the pattern to match against,andthe combinationofthe unannotatedcodeandthe \n+ code represents the code to generate. Each must have the structure of validCcode. Expressingthese constraintsis, \nhowever, unrelated to the useofCTL-VW. Instead, we de.ne the grammarof patterns to match against, and \nassume that the elements of these patterns areimplicitly annotatedwiththetransformationtoperform.For \nexample, in the type ref semantic patch of Figure 1, the pattern return -C; wouldbe annotatedtoindicatethat \nof node put(n); should be inserted before it. In our simpli.ed SmPL, the transformation speci.cation \npart of asemantic patch hasthe formofa Sequence S, as de.nedbythe following grammar: S . Sequences ::= \nES | e E . Elements ::= T | D | (S|S) T . Terms ::= Atomic | if (exp) T D . Dots ::= ... | D when != \nS ASequence shouldnot contain consecutive dots(D),butwedo not complicate the grammar with this constraint. \nAtomic is an arbitrary atomicterm, suchas an assignment orfunction call, and exp is an arbitraryexpression. \nAtomic and exp maycontain metavariables.We consider conditionals with only one branch, because that is \nall that isrequiredfor ourexample. The treatmentofa conditional withtwo branches is similar.  6.2 Quanti.cation \nof metavariables The .rststepinthetranslationofSmPLto CTL-VWistointroduce existentialquanti.erstodelimitthe \nscopeofeachmetavariable.For this,weextendthesyntaxof Sequences,Elements,andTermsto include existential \nquanti.ers, as shown below: S . Sequences ::= ES | e |.x.S E . Elements ::= T | D | (S|S) |.x.E T . Terms \n::= Atomic | if (exp) T |.x.T D . Dots ::= ... | D when != S The scopeofametavariableisthe smallestSequence, \nElement, orTermthat containsallreferencestoit,includingreferencesin + code.Insertingexistential quanti.ers \naccordingto this strategyis straightforward.ForthesemanticpatchinFigure1,the scopeofthe metavariable \nn extends aroundthe entire semantic patch,but the scopeofthe other metavariablesis onlytheimmediate containing \nTerm.In particular,the scopeof the metavariableC in the modi.ed term return -C; is local to the pattern \nitself, i.e., .C. return -C;, allowing it to match a return of anynegative constant within the different \ncontrol-.ow paths. This property is essential, as the matched code mayneedtoreturnan error codefor manyreasons, \nreturning a different value in each case (see Figure 8).  6.3 Translation to CTL-VW Figure6de.nesthe \ntranslationofapatternintoCTL-VW.The entry pointofthe translationisthefunction Cs,whichtakes as arguments \na Sequence and a formula describing how to match the remainder of the semantic patch. Initially, atransformation \nspeci.cation S is translated as Cs[ S] true.4 The translation contains two sets of rules: 1) the C rules \nCs, Ce, and Ct,fortranslating Sequences,Elements,andTerms, respectively, at thetoplevel, and2)the G rules \nGs, Ge, Gt, and Gd, for Sequences, Elements,Terms, and Dots, respectively, when these occur undera when \nclause. The connection between the two sets of rules is made bythe rule Gd, whichis usedin Ce in thetranslationof \n... (D) and processes eachoftheassociated when clauses. The difference betweenthetwosetsofrulesisonlyinthe \nuseoftheargument a, describingtherestof the SmPL code.Forthe C rules, a represents a pattern at the same \nlevel as the pattern being translated, whichthus mustbematchedafterthe currentpattern,whileforthe G rules, \na 4We de.netrue as an abbreviation for p() .\u00acp(), foran arbitrarypredicate p(). Cs[ ES] a = Ce[ E] (Cs[ \nS] a) Cs[ e] a = a Cs[ .x.S] a = .x.Cs[ S] a Ce[ T ] a = Ct[ T ] a Ce[ D] a = A[Gd[ D] a U a] Ce[ (S1|S2)] \na = Cs[ S1] a . (\u00ac(Cs[ S1] a) .Cs[ S2] a) Ce[ .x.E] a = .x.Ce[ E] a Ct[ Atomic] a =(Atomic .. v. v = \nAtomic ) . AX a Ct[ if (exp) T ] a =(if (exp) .. v. v = if (exp) ) . AX((trueBranch . AX(Gt[ T ] )) . \nfallThrough . (after . AXAX a)) . EX(after) Ct[ .x.T ] a = .x.Ct[ T ] a Gs[ E] a = Ge[ E] a Gs[ ES] a \n= Ge[ E] (Gs[ S] a) Gs[ e] a = true Gs[ .x.S] a = .x.Gs[ S] a Ge[ T ] a = Gt[ T ] Ge[ D] a = A[Gd[ D] \na U a] Ge[ (S1|S2)] a = Gs[ S1] a . (\u00ac(Gs[ S1] a) .Gs[ S2] a) Ge[ .x.E] a = .x.Ge[ E] a Gt[ Atomic] = \nAtomic .. v. v = Atomic Gt[ if (exp) T ] =(if (exp) .. v. v = if (exp) ) . AX((trueBranch . AX(Gt[ T \n] )) . fallThrough . after) Gt[ .x.T ] = .x.Gt[ T ] Gd[ ...] a = true Gd[ D when != S] a = Gd[ D] a \n.\u00ac(Gs[ S] a) Figure 6. Asimpli.edtranslationof semantic patchesto CTL-VW represents the code thatfollows \nthe associated dots, andthus only servestodelimitanydotsthat appearattheendofthe when code. In particular,therule \nGt forTerms does not have an argument a, becauseaTerm cannot endin dots. We examine in more detail the \nC translation rules for dots, disjunctions, atomicpatterns,andconditionals.Theserulesillustrate the main \nconcepts of the translation process. Dots Dots represent a sequence of arbitrarycode, possibly con\u00adstrained \nby when clauses, alonga control-.ow path.In the trans\u00adlation, the end of this sequence is indicated by \nthe formula a that describesthe restoftheSmPLcode.Suchadelimitedpathcanbe expressed by an until pathoperator, \nAU or EU. Our simpli.ed language only supports universal quanti.cation over paths, and thus we use AU. \n5 The left argument of AU is constructed using the rule Gd,whichcreatesaformulacheckingthat noneofthepatternsin \nthe when clauses are matchedwithinthe path. Theright argument of AU is the formula a matching the rest \nof the semantic patch. Disjunction Adisjunction(S1|S2) matches S1 if possible, and otherwise S2.The translation \nre.ects the priority of S1 over S2 by encoding S2 as \u00ac(Cs[ S1] a) .Cs[ S2] a. Thistranslation duplicates \nthe previous processing of S1.In theimplementation,weuseinstead a sequential disjunction operator, that \nuses the negation of the previously computed result of processing S1, andthus eliminates this duplication. \nThe translation of a disjunction propagates the formula a separatelyintothetranslationof eachbranch.Inthisway, \ntherestofthesemanticpatchismatchedatapoint startingfromthe end of the code matching S1 or S2. Atomic \nAnatomic patternmayinvolveatransformation,as illus\u00ad tratedinline13of our type ref semantic patch(Figure1).Thus, \nthe matching process must remember information about the position atwhicheach atomicpatternmatches.Tocollectthisinformation, \n5Coccinelle automatically converts AU to AW, which can be de.ned using EU andnegation,whenthesourceprogramisfoundto \ncontainaloop. AW canacceptapaththatgoesaroundaloop in.nitelywithoutsatisfying f2, butAW is implemented \nmuch less ef.ciently than AU. .n.(n = of find node by type(...) .. v. v = ...) . AXA[true U ((if (n == \nNULL)|if (NULL == n)|if (!n)) .. v. v = ...) . AX((trueBranch . AX(.S.(S .. v. v = ...))) . fallThrough \n. (after . AXAX(A[\u00ac(of node put(n); .. v. v = ...) . \u00ac(.n1..f1.(n1 = f1(n,...)) .. v. v = ...) . \u00ac(.E1.(E1 \n= n .. v. v = ...)) U .C.(return -C; .. v. v = ...) |(of node put(n); .. v. v = ...) |.n2..f2.(n2 = f2(n,...) \n.. v. v = ...) |.E2.(E2 = n .. v. v = ...) |.E2.(return E2; .. v. v = ...)]))) . EX(after)] Figure 7. \nCTL-VWtranslation of the semantic patch type ref.The right argument of the equality constraint on v is \nelided as ... in each case, for conciseness. The actual equality constraint is analogous to that shown \npreviously for return -C;. whichis our fourthrequirementfor Coccinelle (Section 2.2), we use witnesses. \nSpeci.cally, we introduce a new existentially quanti.ed metavariable v and create a predicate = that \nsimply matches this variabletoatextualrepresentationofthe atomicpattern,including any annotationsabout \nthe transformation required.Forexample, the pattern return -C; withthe annotation that of node put(n); \nshould be inserted before it would be translated as follows: of node put(n); return -C; .. v. v = \"+ \nreturn -C;\" The witnesses for v will containthe currentstateandthebinding of v to thetextual representationof \ntheatomicpattern,indicating where and how to perform the transformation. Conditionals Thetranslationofa \nconditionalisdeterminedbythe representation of a conditional in a Coccinelle control-.ow graph. For conciseness, \nwe omitfurtherdetails.Note,however,that the translation of the header of a conditional introduces a metavariable \nv, asinthetranslationof an atomicpattern, thus makingit possible to .nd and transform the matched code. \nFigure 7 shows the result of translating the semantic patch type ref into CTL-VW. The formula usesthe \nsequential disjunc\u00adtion operator, denoted as |, that was described above. The pattern n == NULL has beenexpandedintoavarietyofwaystomakeaNULL \ntest, using Coccinelle s isomorphisms [20].For type ref,the size oftheformulais comparabletothesizeofthesemanticpatch.In \ngeneral, however, subformulas can be duplicated 1) in the branches of a disjunction, 2) when a when clause \nends in dots, and 3) in full SmPLtoimplementtheshortestpath constraint,althoughinthe latter case, only \nthe atomicterms immediatelypreceding andfol\u00adlowing the dots are duplicated. In practice, however, we \nhave found thatitisthecomplexityofthe sourcecoderatherthanthesizeof the formula that has an impact on \nthe performance [20]. 6.4 Matching and transformation AsillustratedbytheCTL-VW formulain Figure7,aformula \nresult\u00ad ing from the translationalways has thefollowingproperties:1) All metavariablesareexistentially \nquanti.ed,2) Theexistential quan\u00adti.ers forthe introduced metavariables v recordingthe positions of the \natomictermsarealways innermost,and3) Thetranslationof an atomic term, including the quanti.er of its \nv variable, is nested within quanti.ers for allofits free metavariables. The .rst point implies thatin \nthe resultof matching theCTL-VW formulaagainst the sourcecode,theenvironmentcomponentofeachtripleisalways \nempty.The secondandthirdpointsimplythatthewitnessesaretrees in whichtheleavesare thebindingsof the v \nmetavariables, repre\u00ad np = of find node by type(NULL, \"smu\"); 1 if (np == NULL) 2 return -ENODEV; 3 printk(KERN \nINFO \"SMU: Driver %s %s\\n\", VERSION, AUTHOR); 4 if (smu cmdbuf abs == 0) {printk(KERN ERR \"SMU: Command \nbuffer not allocated !\\n\"); 5 6 return -EINVAL; 7 } smu = alloc bootmem(sizeof(struct smu device)); 8 \n9 if (smu == NULL) {return -ENOMEM; 10 11 } . . . // unrelated straightline code 12 13 smu->of node = \nnp; 14 Figure 8. An extract of the function smu init in the .le drivers/macintosh/smu.c state: 1 environment: \n\u00d8 witnesses: {.1, n, np, {.1, v, n = of find node by type(...), \u00d8., .2, v, if (n == NULL), \u00d8., .3, S, \nreturn -ENODEV;, {.3, v, S, \u00d8.}., .7, C, EINVAL, {.7, v, return -C;, \u00d8.}., .11, C, ENOMEM, {.11, v, return \n-C;, \u00d8.}., .14, E2, smu->of node, {.14, v, E2 = n, \u00d8.}.} Figure 9. Resultof applyingthesemanticpatchofFigure1tothe \nfunction smu init.The statenumberscorrespondtotheline numbers in Figure8 sentingthecodetotransform,andthepathfromthe \nrootofawitness toagiven leaf contains the bindingsof thefree metavariables that may be involved in the \ntransformation process. Asa concreteexample, Figure8shows anextractofthe function smu init in the .le \ndrivers/macintosh/smu.c,6 which is matched by the type ref semantic patch, and Figure 9 shows the single \ntriple that results from the matching process. In Figure 9, we have replaced thestate numbers generatedbyCoccinelleby \nthe correspondingline numbersinFigure8for easy reference. The result shows that the various atomic terms \nof the semantic patch match on lines 1, 2, 3, 7, 11, and 14. Only the pattern return -C; encapsulates \na transformation, as shown in Figure 1: adding the code of node put(n);. Therearetwo matchesof thispattern, \non lines7and 11.For the former, tracingup from the v to the root of the witness gives the binding of \nC to EINVAL and n to np.Forthe latter,thisgives the bindingof C to ENOMEM and n to np.In each case, this \nis suf.cient information to carry out the transformation. Based ontheresultof the matching process, Coccinelle \ncollects the setof sequencesof bindingsleading from the rootofawitness to eachof its leaves that containsa \ntransformation.Coccinelle only acceptsasetoftransformationsifthestatesinvolved aredisjoint and are only \nreachable from the states associated with the set of triples. Theseconditions help avoid ambiguityin \nthetransformation process.Ifthe setof transformationsisacceptable, codeisgenerated 6Thiscode comes from \nhttp://git.kernel.org/?p=linux/kernel/git/torvalds/linux\u00ad2.6.git;a=summary, using the version of Linux \nfrom just before the commit bad5232ba266ae2c666c17be236152fb2d8ada3b,in whichthe .rstofthe patches based \nonthis semantic patchwasaccepted. Thisversiondates from June, 2008. To simplify the example, we have \nadded the braces around thereturn online 11, so thatitisvalid to add code before this statement. Coccinelleautomatically \nadds such braces, when needed,but forsimplicity this issue is not addressed in the translation presented \nin Figure 6. accordingly, in our case adding a call to of node put above lines7 and 11 of Figure 8. Otherwise, \nCoccinelle aborts. 6.5 Experiments The type ref semantic patch shown in Figure 1 transforms four .lesin \ntheLinuxkernel: arch/powerpc/platforms/pseries/nvram.c, drivers/macintosh/smu.c, drivers/macintosh/therm \npm72.c, and dri\u00ad vers/video/fsl-diu-fb.c.7 Figure10 summarizesthesizesofthese .les andthe performanceof \nCoccinellewhen applying the type ref se\u00ad manticpatchtothem.Allexperiments wereperformedona 1.4GHz uniprocessor \nCentrinolaptopwith635MBofRAM.Executiontimes are the average of .ve runs. The result of applying the semantic \npatchtonvram.c,fsl-diu-fb.c and smu.chas beenintegratedintothe Linuxkernel.We observed that theresultofapplying \nthe semantic patchtotherm pm72.cisprobablyafalsepositive,duetoaninter\u00ad proceduraleffectthat the semanticpatch \ndoes nottake into account. Nevertheless,the codestructureinthis caseistypical, and thusit also serves \nas a representative example. The.les rangeinsizefrom149toover 2000linesofC code, including comments and \nwhitespace. In each case there is a single function that is relevant to the semantic patch, in that it \ncontains at least one callto of find node by type, and this function ranges insizefrom27to94lines. Coccinelleskipsoverirrelevant \nfunctions quickly, essentially only parsing them, and thus the CTL-VW algorithm is only applied to the \nrelevant functions. Because the .les aremuchlarger than the relevant functionsin this case, the timeforparsing \ndominatestheoverall runningtimeformost .les. We canneverthelessgeta senseofthe performanceofthe CTL-VW \nalgorithminpractice,byconsideringitsperformanceontherelevant functions, in terms of both time and space \nusage. We considertwoimplementationsofthemodel checkingalgo\u00adrithmfor CTL-VW: an unoptimized one that \ncloselyfollows the algorithm presentedinSection5.3,andtheoptimized onethatis implementedinthe Coccinelle \ntool.Theoptimizationsaffectboth thetranslationintoCTL-VWand theexecutionof thealgorithm, and are summarized \nas follows: Optimizations to the translation These optimizations seek to reducethe numberofwitnesses, \nandthus the amountofinformation that the algorithm has to propagate. Some metavariables, such as n1, \nE1, and f1 inFigure1, only occur underanegation.TheCTL-VWalgorithmdropswitnesses created underanegation,soasanoptimization,we \naugmentthe translationof Figure6to quantify suchmetavariablesusinga variant of . that does not create \nanywitnesses. Some patterns, such as n1 = f1(n,...), are used in matching, but arenotaffectedbythetransformation.Inthis \ncase,wedonot needtointroducea metavariable v to record where the pattern has matched, thus eliminating \na further set of witnesses. Optimizations to the algorithm These optimizations seek to re\u00ad duce the number \nof triples that are manipulated. TheCTL-VW formulas generatedby our translation algorithm oftenhavethe \nform f1 . AX(f2) (see Figure 7).We propagate information aboutthe processing of f1 intothe processing \nof f2, to ensure that the states considered for the subformulas of f2 are reachable from the states at \nwhich f1 is satis.ed, and the environments considered for the subformulas of f2 are compatible with the \nenvironments that satisfy f1. The path operator AU is implemented by an incremental al\u00adgorithm that considers \nonly the newly added triples on each iteration.Variousoptimizations arealsointegratedintotheim\u00ad 7This \ncode comes from the same source as mentionedinFootnote6. @kmalloc ref@ expression x,E; identi.er .d; \nstatement S; @@ 1 2 x = kmalloc(. . .) 3 . . . when != x = E 4 when != x->.d 5 ( 6 if ((x == NULL) | \n| . . .) { . . . when forall 7 8 return . . .; 9 } else S |* x->.d 10 11 12 ) 13 Figure 11. Asemanticpatchthatmixesuniversalandexistential \n path quanti.cation plementationsof conjunctionandnegation,as comparedtothe speci.cations shown in Figure \n3. Thereisno needtokeeptrackofmultisetsofwitnessesinthe implementation,asthese arejustadevicetofacilitatetheproofs \nofsoundness and completeness; thesetof witnessis suf.cient to support matching and transformation. AsshowninFigure10,thecombinationofthese \noptimizations reducestheCTL-VW processingtimebyuptoover150times,due to reduced memory requirements, and \nthe sum of the number of triplesmanipulatedateachstepbyaround50%.In otherwork[20], we have use the full \nSmPL language to create over 60 semantic patchesbasedon collateralevolutionsthathavetakenplaceinLinux \n2.5andLinux2.6.Inapplyingthese semanticpatchestoatotalof over 5800relevantLinux .les ona 3.4GHz uniprocessor \nPentium 4 PC with 1024MB of RAM, the time for applying a semantic patchtoarelevant .leisrarely more than0.5 \nseconds. Thus, our optimizations for CTL-VW model checking provide acceptable performance forinteractive \nuse without resorting to ef.cientbut more complex encoding strategies such as BDDs [5].  6.6 An extension: \nMixing path quanti.ers An advantage of CTL is the ability to mix universal and existential quanti.cation \nover paths within a single formula. To conclude, we consider how full SmPL can take advantage of this \nfacility. By default,SmPL uses universalquanti.cation whenasemantic patch performstransformation, as \nindicatedby -and + annotations, and existential quanti.cation when a semantic patch performs only searching(makingit \ninsteada semantic match),in which lines are annotated with * toindicateitems of interest. These conventions \ncan be overridden globally, by indicating forall or exists at the beginningoftherule. But the quanti.er \nusedfor individual dotscan also be controlled locally using when forall or when exists. The semantic \nmatchshowninFigure11 mixespath quanti.ers. This semanticmatch searchesfor caseswherethereexistsa derefer\u00ad \nenceofthe resultoftheLinuxkernel memoryallocation function kmalloc without .rst checkingthattheresultisvalid.Asthese\u00admantic \nmatch marks lines using *, paths are existentiallyquanti.ed bydefault.Inlines7-10,however,wewouldliketoidentifya \ncondi\u00adtionalthatalways abortsiftheallocatedvalueis NULL,as subsequent dereferencesareknowntobesafe. Thus,the \ndotsinthebodyof this conditional are annotated with when forall. 7. RelatedWork LaceyandDeMoorwrite CTL-FVformulastospecifycompilerop\u00ad \ntimizations[16]. In this setting, a CTL formula describes properties of the contextofa termthatallow \nan optimizationsuch as constant File total lines in the unoptimized optimized lines relevant total CTL \n steps triples total CTL steps triples function time time time time nvram.c 149 27 0.309 0.009 77+29 \n541 0.306 0.005 67+14 261 therm pm72.c 2279 32 1.466 0.010 77+29 678 1.457 0.006 67+12 276 fsl-diu-fb.c \n1721 57 1.226 0.039 77+47 1093 1.205 0.011 67+27 532 smu.c 1323 94 7.707 6.818 77+81 2270 0.888 0.043 \n67+61 1176 Figure 10. The performanceofapplying the semantic patchofFigure1tothe.les thatitaffectsin \nLinux.Timesarein seconds.Stepsisthe numberofCTLoperators consideredinprocessingtheformulaaddedto(+)the \nnumberofstepsinvolvedin computing.xpointiterationsfor the operator AU.Triplesis the sumofthe numberoftriplesinthe \nresultofprocessing each CTL operator. The unoptimized and optimized variants both use an implementation \nof disjunction that does not duplicate the processing of subformulas. propagationtobe appliedtotheterm. \n\u00b0 Aberg et al. used CTLto spec\u00adifythe transformations required to integrate the run-time system of theBossa \nschedulingframework intothe Linuxkernel source code[1].Inboth cases,thestate representingcodethatisaffected \nby the transformationis the onethat satis.es the entire formula, so thereis no needfor witnesses. Furthermore, \nthespeci.cations are fairly simple, so it is possible to write CTL code directly. De Moor et al. observedthat \nfull CTLwas notalways necessaryforsuch speci.cations, and proposed universal regular path queries, which \nare based on regular expressions[9].Suchqueries,however,do not permitmixing universal and existentialpath \nquanti.ers and also do not permit specifying transformations within formulas. Other approachestobug.ndingthattakeprogramcontrol-.ow \ninto account includeMetal[10]and SDV[2]. Metal is based on speci.cations expressed as state machines. \nThe expressiveness of state machines and CTL is incomparable. Metal is not publicly available,soitisnotpossibleto \nassesstheimpactofthisdifference ofexpressivenessin practice.Nevertheless,inSection 6.6, wehave shown \nthe value of mixing existential and universalpath quanti.ers; itisnotobvioushowto achievethiseffectusingastatemachine. \nSDVfocusesmainlyoneliminatingfalsepositivesbytakingpossible run-time values into account. Coccinelle \ndoes not currentlyaddress this issue. Arefactoring is a semantics-preserving reorganization of source \ncode. While some refactorings can be expressedusing Coccinelle, the goalof Coccinelleis to carry out \nany user-speci.ed transfor\u00admation, whichinthe caseof e.g.,bug .xes may be intrinsically not semantics \npreserving. Some work has been done on formalizing refactorings,to ensurethattheyareappliedonlyin contextsinwhich \nthey aresemantics-preserving[23, 24]. The formalization presented here,ontheotherhand,hasthegoalof de.ningthesemanticsofthe \ntransformation language. Bohn et al. also propose a variant of CTL with universal and existentiallyquanti.edvariables[4]. \nTheir goalisto reason about propertiesinvolvingvariablesthat rangeoververylarge or in.nite domains, and \ntheyprovide a syntactic approach to model checking that allows constraints about suchvariablestobesimpli.edin \nad hoc ways. Theirsemanticsis somewhat differentthan oursin that environments areexplicitin the semanticsofstate \noperators,but integrated intothelabellingfunctionofa specializedversionof the initial model in the semantics \nof path operators. Our use of constructive negation can be viewed as a restricted version of their more \ngeneral predicates on variable values. SinceSmPLsemantic patches canbetranslatedintoCTL-VW, theycouldalsobe \nwritten usingCTL-VWdirectly. Doingso,how\u00ad ever,wouldbevery tediousforcomplexsemanticpatches,as already \nillustratedbyFigure7. Thedif.cultyof creatingCTL speci.cations has been recognized in other areas. Corbett \net al. propose a high levellanguage for describing desired propertiesofJava programs, for use with the \nBandera model checking framework [8]. Jones and Hansen present a translation of a toy version of SmPL \nintoCTL-V[13]. They concentrate on matching, and do not providesupport for transformation, asis enabledby \nCTL-VW. They implement CTL-V by translation into CTL, at the cost of increasing the size of the formula \nexponentially in the size of Val. 8. Conclusion In this paper,wehaveidenti.edfour requirements foralogic \nthatis toserveasthefoundationofa control-.ow based programmatching language, and wehaveincrementally \nderived from CTLalogic, CTL-VW,thatmeets these requirements.Inpractice,wehavefound thedecisionto basetheimplementationofCoccinelleonanexten\u00ad \nsionofCTLverybene.cial,asitnaturallyseparatesthespeci.cation of the semantics of the program matching \nlanguage, representedby the translation intothelogic, fromthe implementation, represented bythe model \ncheckingalgorithm. Indeed,inthecaseof Coccinelle, weiteratedmanytimesover the language semantics,but \nmodi.ed the implementation of the modelchecking algorithm only rarely, to improve performance. Our extensive \nexperiments[20]show thatthe approach is ef.cient enough for practical use, on a standard PC. Alimitation \nof the formalization of CTL-VW presented here is thatit does notallowfor collectingwitnesses under negation. \nWhile this featureis not neededin theexampleswehave considered in practice with Coccinelle, there could \nbe other contexts in which suchwitnesseswouldbe useful.Wewanttoextendtheformalization toaccommodatethem. \nCurrently,onlytheproofof soundnessand completenessof theCTL-V model checkingalgorithm has been validatedbya \nproof assistant.Weplantovalidate theproof for the CTL-VW model checking algorithm as well. Acknowledgments \nThiswork has been supportedin partby the Agence Nationaledela Recherche (France),the INRIAcooperative \nresearchinitiativeVeriTLA+, and the DanishResearchCouncil for Technology and Production Sciences.Wewould \nalsoliketo thank YoannPadioleau forhis comments onadraftofthis paper and for his contributions to the \ndevelopment of Coccinelle. Availability Coccinelle is available from the following URL: http://www.emn.fr/x-info/coccinelle/. \nReferences [1] R. A. \u00b0udholt, G. Muller, and A.-F. Le Meur. Aberg, J. L. Lawall, M.S\u00a8 On theautomaticevolutionof \nanOSkernel using temporal logic and AOP. In18thIEEE International Conference onAutomated Software Engineering \n(ASE 2003), pages 196 204,Montreal,Canada, Oct. 2003. IEEE. [2] T. Ball,E. Bounimova,B.Cook,V.Levin,J. \nLichtenberg,C. McGarvey, B. Ondrusek,S.K.Rajamani,andA. Ustuner.Thoroughstaticanalysis of device drivers. \nIn The .rstACM SIGOPS EuroSys conference (EuroSys 2006), pages 73 85, Leuven, Belgium, Apr. 2006. [3] \nY.Bertot andP.Cast\u00b4Interactive TheoremProving andProgram eran. Development. Springer, 2004. [4] J. Bohn,W.Damm,O. \nGrumberg,H.Hungar,andK.Laster. First\u00ad Order-CTL modelchecking. In Foundations of Software Technology \nand TheoreticalComputer Science, number 1530 in Lecture Notes in Computer Science, pages 283 294, Chennai, \nIndia, Dec. 1998. [5] R. E. Bryant. Graph-based algorithms for Boolean function manipulation. IEEETransactions \nonComputers, 35(8):677 691, 1986. [6] D. Chan.Constructive negation basedonthe completeddatabase.In FifthInternational \nConferenceandSymposiumonLogicProgramming, pages 111 125, Seattle,WA, Aug. 1988. [7] E.M. Clarke,E.A.Emerson,andA.P. \nSistla. Automaticveri.cation of .nite-state concurrent systems using temporal logic speci.cations. ACM \nTransactions on Programming Languages and Systems (TOPLAS), 8(2):244 263, 1986. [8] J. C. Corbett,M. \nB.Dwyer, J. Hatcliff, and Robby. Alanguage frameworkfor expressing checkable properties of dynamic software. \nIn Proceedings of the SPIN SoftwareModelCheckingWorkshop, number 1885in Lecture NotesinComputer Science,pages \n205 223, Stanford, CA, USA, Aug. 2000. [9] O.de Moor,D. Lacey,andE.VanWyk. Universalregularpathqueries. \nHigher Order and Symbolic Computation, 16:15 35, 2003. [10] D.R. Engler,B. Chelf,A. Chou,andS. Hallem. \nCheckingsystem rules using system-speci.c, programmer-written compiler extensions. In FourthUSENIX Symposium \nonOperating Systems Design and Implementation (OSDI), pages 1 16, San Diego, CA, Oct. 2000. [11] A.Gupta.Formal \nhardwareveri.cationmethods:A survey. Formal Methods in System Design, 1(2 3):151 238, 1992. [12] M. Huth \nand M. Ryan. Logic in Computer Science: Modelling and reasoning about systems. Cambridge University Press, \n2000. [13] N.Jones andR.R. Hansen. The semanticsof semanticpatches in coccinelle:Program transformation \nfor theworking programmer.In Fifth ASIANSymposium on Programming Languages and Systems, number 4807in \nLecture NotesinComputer Science,pages 303 318, Singapore, Nov. 2007. [14] C.KernandM.R. Greenstreet.Formalveri.cationinhardware \ndesign: a survey. ACMTransactions on DesignAutomation of Electronic Systems (TODAES), 4(2):123 193, 1999. \n[15] D. Lacey. ProgramTransformation usingTemporal Logic Speci\u00ad.cations. PhD thesis, Oxford University \nComputingLaboratory, 2003. [16] D. Lacey and O. de Moor. Imperative program transformation byrewriting.InR.Wilhelm, \neditor, Compiler Construction, 10th International Conference, CC 2001, number 2027inLecture Notesin Computer \nScience, pages 52 68, Genova, Italy, Apr. 2001. [17] D. Lacey,N.D. Jones,E.VanWyk, andC.C. Frederiksen. \nCompiler optimization correctness by temporal logic. Higher Order and Symbolic Computation, 17(3):173 \n206, 2004. [18] J. L. Lawall, J. Brunel, R. R. Hansen, H. Stuart, and G. Muller. WYSIWIB:Adeclarativeapproachto \n.nding protocols andbugsin Linux code.TechnicalReport08/1/INFO, Ecole desMinesdeNantes, Nantes, France, \n2008. [19] D.MacKenzie,P.Eggert,andR. Stallman. Comparing and Merging FilesWithGnu DiffandPatch. Network \nTheoryLtd,Jan. 2003.Uni.ed Format section, http://www.gnu.org/software/diffutils/ manual/html node/Unified-Format.html. \n[20] Y.Padioleau,J.Lawall,R.R. Hansen, andG.Muller.Documenting and automating collateralevolutionsin \nLinuxdevice drivers. In Eurosys 2008, pages 247 260, Glasgow, Scotland, Mar. 2008. [21] M. Sassa and \nS. Sahara. Validating correctness of compiler optimizer execution using temporallogic. In Compiler Optimization \nmeets CompilerVeri.cation, Budapest, Hungary, Apr. 2008. [22] D.A. SchmidtandB.Steffen. Programanalysisas \nmodelchecking of abstract interpretations. In SAS 98: Proceedings of the 5th International Symposium \non Static Analysis, pages 351 380,London, UK, 1998. Springer-Verlag. [23] F.Tip.Refactoring usingtype \nconstraints.InStatic Analysis, 14th International Symposium, number 4634in LectureNotesinComputer Science, \npages 1 17,KongensLyngby, Denmark, Aug. 2007. [24] M.Verbaere,R.Ettinger,andO.de Moor. JunGL:a scriptinglanguage \nfor refactoring. In International Conference on SoftwareEngineering (ICSE), pages 172 181, Shanghai, \nChina, May 2006.    \n\t\t\t", "proc_id": "1480881", "abstract": "<p>Reasoning about program control-flow paths is an important functionality of a number of recent program matching languages and associated searching and transformation tools. Temporal logic provides a well-defined means of expressing properties of control-flow paths in programs, and indeed an extension of the temporal logic CTL has been applied to the problem of specifying and verifying the transformations commonly performed by optimizing compilers. Nevertheless, in developing the Coccinelle program transformation tool for performing Linux collateral evolutions in systems code, we have found that existing variants of CTL do not adequately support rules that transform subterms other than the ones matching an entire formula. Being able to transform any of the subterms of a matched term seems essential in the domain targeted by Coccinelle.</p>  <p>In this paper, we propose an extension to CTL named CTLVW (CTL with variables and witnesses) that is a suitable basis for the semantics and implementation of the Coccinelles program matching language. Our extension to CTL includes existential quantification over program fragments, which allows metavariables in the program matching language to range over different values within different control-flow paths, and a notion of witnesses that record such existential bindings for use in the subsequent program transformation process. We formalize CTL-VW and describe its use in the context of Coccinelle. We then assess the performance of the approach in practice, using a transformation rule that fixes several reference count bugs in Linux code.</p>", "authors": [{"name": "Julien Brunel", "author_profile_id": "81339491789", "affiliation": "DIKU, University of Copenhagen, Copenhagen, Denmark", "person_id": "P1300942", "email_address": "", "orcid_id": ""}, {"name": "Damien Doligez", "author_profile_id": "81100592225", "affiliation": "INRIA, Gallium Project, Le Chesnay, France", "person_id": "P1300943", "email_address": "", "orcid_id": ""}, {"name": "Ren&#233; Rydhof Hansen", "author_profile_id": "81350580130", "affiliation": "Aalborg University, Aalborg, Denmark", "person_id": "P1300944", "email_address": "", "orcid_id": ""}, {"name": "Julia L. Lawall", "author_profile_id": "81100529486", "affiliation": "University of Copenhagen, Copenhagen, Denmark", "person_id": "P1300945", "email_address": "", "orcid_id": ""}, {"name": "Gilles Muller", "author_profile_id": "81339518523", "affiliation": "Ecole des Mines de Nantes, Nantes, France", "person_id": "P1300946", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1480881.1480897", "year": "2009", "article_id": "1480897", "conference": "POPL", "title": "A foundation for flow-based program matching: using temporal logic and model checking", "url": "http://dl.acm.org/citation.cfm?id=1480897"}