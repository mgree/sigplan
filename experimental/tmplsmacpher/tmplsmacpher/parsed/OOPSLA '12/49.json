{"article_publication_date": "10-19-2012", "fulltext": "\n k-Calling Context Pro.ling Giorgio Ausiello Camil Demetrescu Irene Finocchi Dept. of Computer and System \nSciences Dept. of Computer and System Sciences Dept. of Computer Science Sapienza University ofRome Sapienza \nUniversityof Rome Sapienza Universityof Rome ausiello@dis.uniroma1.it demetres@dis.uniroma1.it .nocchi@di.uniroma1.it \n DonatellaFirmani Dept.ofComputer andSystemSciences SapienzaUniversityofRome .rmani@dis.uniroma1.it \nAbstract Calling context trees are one of the most fundamental data struc\u00adturesfor representingtheinterproceduralcontrol.ow \nofaprogram, providingvaluableinformationforprogram understanding and op\u00adtimization. Nodes of a calling \ncontext tree associate performance metrics to whole distinct paths in the call graph starting from the \nrootfunction.However, no explicitinformationisprovidedforde\u00adtecting short hot sequences of activations, \nwhich may be a better optimization targetinlarge modularprograms wheregroups of re\u00adlatedfunctions are \nreusedin manydifferentparts of the code.Fur\u00adthermore,calling contexttrees cangrowprohibitivelylargein \nsome scenarios. Another classical approach, called edge pro.ling, col\u00adlects performance metrics for caller-callee \npairs in the call graph, allowingittodetecthotpathsof .xedlength one.Westudy agen\u00aderalization of edge \nand context-sensitive pro.les by introducing a noveldata structure calledk-calling contextforest(k-CCF).Nodes \nin ak-CCFassociateperformance metricstopathsoflengthat most k that lead to each distinct routine of the \nprogram,providing edge pro.les for k =1, full context-sensitive pro.les for k = 8, as well as any otherintermediatepointin \nthe spectrum. We study the properties ofthe k-CCFboth theoretically and experimentally on a large suite \nof prominent Linux applications, showing how to con\u00adstruct it ef.ciently and discussingits relationships \nwith the calling context tree.Our experiments show that the k-CCF canprovide ef\u00adfective space-accuracytradeoffsforinterproceduralcontextualpro\u00ad.ling,yielding \nuseful clues to the hot spots of aprogram that may be hidden in a calling context tree and using less \nspace for small values of k, which appear tobe the mostinterestinginpractice. Categories and Subject \nDescriptors D.2.8[Software Engineer\u00ading]:Metrics performancemeasures; D.2.2[SoftwareEngineer\u00ading]:DesignTools \nandTechniques programmer workbench GeneralTerms Algorithms,Measurement,Performance. Keywords Call graph, \ncalling context tree, dynamic program analysis, edgepro.ling,pro.ling, vertexpro.ling. Permission to \nmake digital or hard copies of all or part of this work for personal or classroom useisgranted without \nfeeprovided that copies are not made ordistributed forpro.tor commercial advantage andthat copiesbearthis \nnotice and thefull citation onthe .rstpage.Tocopy otherwise,torepublish,topost onserversortoredistribute \ntolists, requiresprior speci.cpermission and/or afee. OOPSLA 12, October19 26,2012,Tucson,Arizona,USA. \nCopyright c &#38;#169;2012ACM978-1-4503-1561-6/12/10. . .$10.00 1. Introduction Pro.lers attribute performance \nmetrics to portions of a program s execution. Such metrics can be associated to isolated synctactic units, \nsuch as statements orprocedures, or to richer contexts, such aspathsinthecontrol .oworthecallgraph.Accuratepro.lescan \nprovide valuableinformationforprogram understanding,optimiza\u00adtion,testcoverage,and other softwareengineeringtasks[20,25,33, \n34]. In this paper we study pro.ling techniques for interprocedural control .ow,whereperformancemetricsareassociated \nwithpaths in the callgraph.In a spectrum ofpossible representations of call\u00ading behavior that trade space \noverhead for information accuracy, vertex pro.ling [15]provides the most compact solution. It main\u00adtains \naperformance counterfor each routine oftheprogram,but no information is given on the contexts in which \nhot routine invoca\u00adtions occur.Thislimitation canplay a crucial roleinpro.linghard\u00adware events such as \ninstruction stalls or cache misses, which can be very context-dependent[2]. Edgepro.ling [15]makes one \nstep further by maintaining a single level of context sensitivity. How\u00adever, since measurements are collected \nonly for one-edge paths in the callgraph, this can stillyield misleading results[23,28].At the other \nend of the line, dynamic call trees record the complete history of routine invocations and can be used \nto maintain accu\u00adratepro.linginformation,butthey cangrowprohibitivelylargefor long-runningprograms. Calling \ncontext trees (CCT) provide an intermediate solution by keeping track of all distinct calling contexts \nof a program, i.e., sequences of procedures that are active during intervals of a program s execution[2].In \naCCT, each nodeislabeled with the name of a routine and eachpathfromthetree rootto a nodelabeled with \nv represents a distinct calling context of v. Since there is no distinctionbetweendifferentinvocationsofthe \nsame routinewithin the same context, a CCTis typically smaller than a call tree, butit can still remain \nverylargein many applications[12,13,27,35]. The CCT encodes full information on the distinct call paths \nof a program s execution and supports context-sensitive pro.ling by associatingperformance measurementstocalling \ncontextsthat start from the program s root. Unfortunately, calling context trees may fail to reveal certain \nrelevant hot spotsin the code, as discussedin thefollowing example. Motivating example. Consider the \nedge pro.ling report of Fig\u00adure 1(a), which shows the call graph of a program along with the number of \ntimes each routineis calledby another routinein apar\u00adticular execution. It is easy to see that c, which \nis called 4 times,  (a)Callgraph. (b) Calling contexttree. Figure1. Motivatingexamplefor k-calling contextpro.ling. \nis one of the mostfrequently activated routines.To understand and optimize the program, we would like \nto trace back the context in which most invocations of c arise. By analyzing the edge weights of the \ncall graph, we discover that c is called 1/4 of the times by r and 3/4 of the times by b. We notice however \nthat it is impos\u00adsible to determine from the call graph if a longer hot context of c exists, i.e., if \nmost activations of c via b happened from e or from a.Figure1(b) showsthe calling contexttree ofthe same \nexecution. Observe thatalldistinct contexts of c are only reached once, which againyieldsno cluestothe \nexistence of ahotpathlongerthan1that leadstoc.A more careful analysis oftheCCT revealsthat callpath (a,b,c), \nshown with a shaded background in Figure 1(b), appears three distinct times as a subtree of the CCT. \nThis implies that 3/4 of the calls of c arise via bwhen a is active,i.e., thereis a callpath of 2 edges \nthat accounts for75% of all calls of the hottest routine, whereas there is no interesting call path longer \nthan 2. From this example, we argue that sometimespro.ling shortpathsthatlead to a hot routine may be \nmore useful than considering whole contexts constrained to startfrom theprogram s root: this seems tobe \nespe\u00adcially thecaseinlarge modularprograms wheregroupsof related functions are reused in many differentparts \nof the code. Since the CCT provides frequency counters only for full contexts, extract\u00adinginformation \non shorterpaths maybedif.cult.Additionally, we notice that short paths may be repeated several distinct \ntimes in a CCT,offeringtheopportunityformorecompact andspace-ef.cient representations. Pro.ling call \npaths of bounded length. Different authors have discussed the bene.ts of pro.ling call paths of bounded \nlength, ratherthan entirepaths constrainedto startfromtheprogram sroot. Forinstance, theN-level call \nencodings ofReiss andRenieris[24] were proposed in a different setting as a technique for compact\u00ading \nraw execution traces. When the size of the CCT is large, the callgrind cache simulator[31] exploitsareducedCCTk, \nwhere two contexts are collapsed if the trailing k contexts of the cor\u00adresponding call chains are identical. \nAmmons et al. [3] advocate the use of bounded-length calling contexts and show that they can be computed \nby analyzing of.ine a previously recorded call tree. While showing interesting practical results in applying \ntheir tool to improve the performance of several Java applications, their ap\u00adproach scalespoorly tolargeprograms,which \nmay requiretocol\u00adlect andprocess call trees ofbillions of nodes. Our contributions. To answer the above \nconcerns, we study a space and time-ef.cient pro.ling methodology that we call k\u00adcalling contextpro.ling.The \napproach consists of computingper\u00adformance metrics for all call paths of length up to k that lead to \na program s routine. The k-calling context pro.ling problem is a generalization of other approaches, \nyielding vertex pro.les for k =0, edge pro.les for k =1, full context-sensitive pro.les for k = 8, as \nwell as any other intermediate point in the spectrum. Wedevelop this conceptin several noveldirections: \n Wedesign a novelcombinatorial structurefor k-calling context pro.lingthatwe call k-calling contextforest(k-CCF), \nshowing that it has several relevant properties and discussing its space requirements(Section4).  We \nshow thata k-CCF canbe constructedfrom aCCT; we also design a new ef.cientdata structure calledk-slabforest(k-SF), \nwhich provides a more space-ef.cient alternative to the CCT for constructingthe k-CCF when k is small(Section5). \n We perform an extensive experimental evaluation of our data structureson a suiteoflarge-scaleLinuxapplications(Section6 \nandSection7), showing that:  hot callpaths typicallydo not startfrom theprogram s root and are much \nshorter thanthedepth oftheCCT, con.rming that short paths that lead to a hot routine can be a better \npro.ling target for detecting performance bottlenecks than thefull calling contexts of aCCT; it ispossible \nto convert a CCT into apruned version of the 8-CCFthatis extremely compact(on average,just1.5% of the \nCCT on our benchmarks) and includes explicit pro.les forall hotpaths; if room for storing an entire CCT \nis not available, small values of k can greatly reduce space at theprice of a small increase of the running \ntime, while still preserving useful informationfordetectingmosthot callpaths. In Section 2 and in Section \n3 we introduce the k-calling context pro.ling problem and we provide some preliminary notation and tools \nused in the de.nition of our data structures. Related work is discussed in Section 8 and concluding remarks \nare given in Section9. 2. k-CallingContextPro.ling Inthissection weformalizethek-calling contextpro.ling \nproblem, discussingits connections withother classicalforms ofinterproce\u00adduralperformancepro.ling. Let \nG =(V,E) be the (dynamic) call graph of a program, where V isthe setof routine names and E isthe setof \ncaller-callee relationships, and let r . V be the root function of the program. We assume that the length \nof a path is its number of hops. At any time during the execution of the program, the current execution \ncontext is described by a path p = (r, ...,u)in G starting from r, representing the sequence of pending \nroutine activations on the runtime stack. The input of the pro.ler is a trace of call/return program \noperations,which updatethe currentcontextstartingfroman empty context asfollows: call(v) updates the \ncurrent context p = (r,...,u)by adding a node v s.t. (u,v). E. The resulting context is p ' = (r, ...,u,v). \n return updatesthe current context p = (r,...,u,v)bydeleting thelast node v.The resulting contextis \np ' = (r,...,u).  Figure 2(a) shows an example of execution trace along with the current context after \neach operation. We nowde.nethek-calling context of a routine,whichgeneral\u00adizes classicalcalling contexts[2]byfocusing \non abounded number of the topmost consecutive activations on the runtime stack, rather than considering \nthe wholepath all the waydown to the rootfunc\u00adtion: De.nition 1 (k-calling context). Let p = (r,...,v)be \na calling context of v.The k-(calling)context of v in p is the maximal suf.x of p oflength at most k. \n operation curr. context start () call(r) ( r) call(a) ( r, a ) call(b) ( r, a, b ) return (r, a) call(c) \n ( ) return (r, a return (r) call(c) call(a) call(b) ) return call(b) ) q activated p c(p) 0 (r)* \n(a) (b) (c) 1 2 3 2 1 (r, a)* (a, b) (a, c) (r, c)* (c, a) 1 3 1 1 1 2 (r, a, b)* (r, a, c)* (r, c, a)* \n(c, a, b) 1 1 1 2 3 (r, c, a, b)* 2 return (r, c, a ) (b) Distinct paths p of any return (r, c) length \nq activated by the trace return (r) ofFigure2(a).Counter c(p) de\u00ad return () notes the number of activations \n(a)Executiontrace. ofpath p in the execution trace. Figure 2. Running example. The CCT corresponding \nto the exe\u00adcution traceis showninFigure4. k-calling contexts correspondtotheN-depthcall sequencesin[24]. \nFor instance, if p = (r,a,b,c,d)is the calling context of d, its 2\u00adcontextis (b,c,d).Another exampleisgiveninFigure2(a), \nwhich shows asframedboxes all the0,1, and2-contexts oftheprogram s routines during the execution. As \na special case, when k is larger than the length of p, the k-context of v coincides with its full context \np. De.nition 2 (path activation). A path p of length q in the call graph G is activated by a call(v)operation \nif p is the q-context of v resultingfrom the operation. In our example of Figure 2, all activations of \nlength q = 2 are highlightedasframedboxes.Thedistinct activatedpaths arelisted inFigure2(b)groupedby \ntheirlength. De.nition 3 (k-calling context pro.ling). Given a trace of call and return operations, the \nk-(calling) context pro.ling problem consists of computing, for each activated path p of length q = k, \nthe number c(p)of times p is activated. Figure 2(b) shows all activation counters c(p) computed by 3\u00adcontextpro.lingfor \nthe sample trace ofFigure2(a). 2-contextpro\u00ad.ling would compute all countersforpaths up tolength q =2.We \nnotice that, since thelongest activatedpathhaslength 3, k-context pro.lingfor anyk> 3computesthe same \nvalues as 3-contextpro\u00ad.ling.We remark that only counters of starredpathsinFigure2(b), which startfrom \nthe rootfunction, wouldbe maintainedin aCCT. Although we focus on counting routine activations, this \napproach can be adapted to deal with other performance metrics, including execution times,branch mispredictions, \ncache misses, etc. The k-contextpro.lingproblemis ageneralization ofdifferent classical performance pro.ling \napproaches at the interprocedural level.Inparticular: vertex pro.ling [15] is equivalent to k-context \npro.ling with k =0;  edgepro.ling [15]is solvedbyk-contextpro.ling with k = 1;  context-sensitive pro.ling \n[2] is solved by k-context pro.ling with k = 8.  InSection8 wediscussfurther connectionsbetween this \napproach andprevious workin theliterature. (a) T1 ,T2 (b) join(T1,T2) Figure 3. Weighted treejoin operation:for \neach node v we report itslabel l(v)andits counter c(v). 3. Preliminaries Inthis section weintroduce somepreliminarynotation \nand a useful operator on trees, called treejoin, that will be used to de.ne the data structuresdiscussedin \nthepaper. Let T be a labeled tree where l(v) denotes the label of node v.We assume that,for each tree \nnode, allits childrenhavedistinct labels.Letr bethe rootofT.Throughoutthispaper we will assume that a \ntree root has level 0. A root-path is any path starting at r. A root-to-leaf path is a root-path ending \non a leaf. We also say that a label path is the sequence of labels of a path in a labeled tree. A root-label \npath is the sequence of labels of a root-path and a root-to-leaf label path is the sequence of labels \nof a root\u00adto-leafpath.Wedenoteby pR = (z, . . .,b,a)the reverse of apath p = (a,b,. . .,z). Treejoin. \nWede.ne the treejoin operation asfollows: De.nition 4 (Treejoin). The joinof two labeled trees T1 and \nT2 , denoted as join(T1,T2),is the minimallabeledforest F such that F contains a root-labelpath p if \nand onlyif T1 or T2 contain p. By the minimality of F, if two root-paths of T1 and T2 share a commonpre.x \noflabels, thatpre.xis representedin F only once. We can thereforedistinguishtwo cases,depending on thelabels \nof tree roots r1 and r2 : if l(r1 ) l(r2 ), then F simply consists of T1 and T2; = ifl(r1 )= l(r2), then \nT1 and T2 are mergedin F into a unique tree with root r andlabel l(r)= l(r1)= l(r2). Weighted treejoin. \nThejoin operation can be easily extended to deal with the weighted case where a counter c(v)is associated \nto each node v of T1 and T2. Let z be a node of F and let pz the unique root-path thatleads to z inF.Wede.ne \nc(z)as the sum of all counters c(v)of nodes v in V1 .V2 such that the root-path pv thatleads to v in \nT1 or T2 has the same sequence oflabels as pz. Forestjoin. Thejoin operator canbe alsogeneralizedto arbitrary \nsets of trees {T1 ,...,Th}, with h = 3: if all trees have distinct root labels, then F coincides with \nthe input forest {T1,...,Th}. Otherwise, let T1 and T2 be two labeled trees with the same root labels, \nthen: join(T1, ...,Th)= join(join(T1,T2 ),T3, ...,Th). Examples. An exampleof weightedjoinapplicationisshownin \nFigure3.As another example, we notice that thejoin operator can be used toprovide an alternatede.nition \nof theCCT, compared to the classicalformulationbased on an equivalence relation onpairs of nodes ofthe \ncall tree[2].Let T be a calltree,let hbeits number ofleaves, andlet p1 ,...,ph be the root-to-leafpaths \nofT: theCCT of the program s execution encoded by T is exactly the result of the join(p1, ...,ph) operation.Since \nallpaths share the same root, theyhave a non-empty commonpre.x and thejoin will return a unique tree(theCCT)instead \nof aforest.  Figure4. CCTand k-CCFfor the example ofFigure2. 4. k-CallingContextForest In this section \nwe study data structures for k-context pro.ling. In particular, we introduce a novel data structure called \nk-calling contextforest,discussingitsproperties and space requirements. 4.1 De.nitionandProperties A \nk-calling context forest maintains information on all activated paths oflengthup to k and canbe simplyde.ned \nas thejoin of the reverse of thosepaths: De.nition5(k-calling contextforest). Thek-calling contextforest \n(k-CCF) of the execution of a program is a labeled forest de.ned as join(p1 R ,...,psR), where {p1,...,ps}is \nthe set of all distinct paths oflengthat most k activatedby the execution. Figure 4 shows the k-CCF for \nthe running example of Figure2(a) for different values of k. k-calling contextforestshave thefollow\u00adingrelevantproperties: \n1. each node . of theforestislabeled with a routine name l(.); 2. there is a tree Tu of depth at most \nk for each distinct routine u in the program; the root of Tu is labeled with u; there is a one-to-one \nmapping between nodes of the callgraph and roots of the k-CCF; 3. there is a one-to-one mapping between \nk-CCF nodes and dis\u00adtinct callpaths oflength up to k activatedduring theprogram s execution;inparticular,thereis \na root-labelpath (a,b. . .,z)of length q = k in Ta if and only if (z, . . .,b,a)is an activated q-context \nof a; 4. 0-CCF .1-CCF .2-CCF .... .8-CCF; 5. for all k = d, k-CCF = d-CCF = 8-CCF, where d is thelength \nof thelongestdistinct context(i.e.,thedepth of the CCT); 6. allleavesofthe 8-CCF arelabeled withthe \nname r ofthe root function of theprogram; 7. each leaf of the 8-CCF corresponds to a distinct context \nof theprogram; therefore, thereis a one-to-one mappingbetween CCTnodes and 8-CCFleaves.  Performance \nmetrics. Wenowextendthede.nitionofthek-CCF toincludethe number of activations of each callpath representedin \nthe forest. We assume that each node . of the k-CCF is equipped with a counter c(.). Let Tl(a) be the \nk-CCF tree containing ., and let (a,\u00df...,.)be the unique root-path that leads to . in Tl(a). Then c(.) \nis the number of activations of the call path p = (l(.),...,l(\u00df),l(a)),i.e., c(.)= c(p).Therefore,building \na k-CCF solves the k-calling contextpro.lingproblem. Counters associated to k-CCF nodes have some relevant \nprop\u00aderties: (a) let . be a nodein a k-CCF and let . be its parent. Then c(.)= c(.); (b) let . be a \nnodein a k-CCF and let .1,...,.h be the children of ..For anyprogram trace such that the rootfunctionis \nnever  Ph recursively called, c(.)= i=1 c(.i); P (c) let Lk be the set of leaves of a k-CCF. Then ..Lk \nc(.)is equal to the number of call operationsin the execution trace. 4.2 SpaceAnalysis In this section \nweprovide upperbounds on the size of a k-CCFin terms of the sizes of theCCT and the callgraph and show \nthat the bounds are tight in the worst case. We also show that the k-CCF canbe considerably smaller than \ntheCCTin some scenarios. Theorem 1. The number of nodes of a k-CCF is bounded by O(min{kn,dn,|V|k+1})inthe \nworstcase, where n isthe number of nodes of the CCT, d is the depth of the CCT, and |V|is the number \nof routines of theprogram. Proof. We .rst bound the size of a tree Tu of the k-CCF. By De.nition5,Tu \nis obtainedbyjoiningthe reverse ofall activated q\u00adcontexts of u oflength q = k.The number of such contexts \ncannot exceed the number nu of nodes of the CCT labeled with u. Since each q-contextis notlonger than \nmin{k,d}, where d is thelength of thelongestdistinct context(i.e., thedepth of theCCT), then the number \nof nodes of Tu is O(nu \u00b7 min{k,d}). The claim follows P from the observation that u.V nu = n, where \nn is the number of nodes of the CCT, and from the fact that there can be at most |V|q+1 distinctq-contextsfor \neach q = k. As special cases, we notice that a 0-CCF contains |V|nodes and a 1-CCF contains |V|+|E|nodes, \nwhere |E|isthe number ofedges of thedynamic callgraph. Discussion. The worst-case spaceboundprovedinTheorem1is \ntight. Consider for instance a CCT of n = |V|nodes consisting of a chain (v1,v2 ,...,vn)in whichall nodelabels \naredistinct(i.e., l(vi)= l(vj)for all i = j).For eachnode vi, the k-CCF contains one chain rooted at \nvi, whichincludes the(at most k)predecessors of vi intheCCT,takenin reverse order.Hence,thek-CCF contains \n(n -k)(k+1)+k(k+1)/2nodes.If k = n/2, the k-CCFforest hasquadratic size T(n 2)with respect to theCCT. \nInSection7we willprovide experimental evidencethatthe size of the k-CCF for typical real-world applications \ncan be consider\u00adably smaller than the size of the CCT for small values of k. We conclude this section \nby showing a scenario that illustrates why a k-CCF canbe more compact than theCCTin some cases. Theorem1andthe \nchain exampledescribed aboveshowthatthe k-CCF canbe up to k timeslarger than theCCTin the worst case. \nHowever,in that example each k-context appears in the CCT only once(all nodelabels aredistinct).Onthe \notherhand, all repeated occurrencesofthe same k-contextintheCCTwill appear onlyonce in the k-CCF, and \nin that case we can expect a space reduction. Consider the exampleinFigure5,in which k =2 and n = t2 \n+1 for any appropriate integer t = 2: in this example, any two CCT nodesatthe samedistancefromthe roothavethe \nsamelabel, except for the children ofthe root.Hence, each2-context endingin a node at level = 4 appears \nexactly t times in the CCT, but only once in the 2-CCF.Itis notdif.cult to see thatin this scenario the \nnumber v of nodes of the k-CCFis O(t)= O( n)for anyconstant value of k,i.e.,quadratically smaller than \ntheCCT. 5. ConstructionAlgorithms In this section we discuss algorithms for building the k-CCF. We .rst \nobserve that, since each call event activates up to k paths si\u00adFigure5. Example showingthatthek-CCFcanbe \nasymptotically smaller than the CCT. Shaded label paths of length t - 2 are duplicatedt timesin theCCT. \n multaneously, maintaining explicitly the k-CCF concurrently with program execution would require updating \nup to k nodes at each routineinvocation.This may considerablyslowdown theprogram even for small values \nof k. We therefore discuss of.ine solutions that construct the k-CCFattheend of theexecution.We .rst \nshow that the k-CCFcanbe constructed startingfrom theCCT, and then we propose a more space-ef.cient approach \nbased on a new data structure that canbe maintained ef.cientlyduringthe execution of theprogram. 5.1 \nBuildingthe k-CCFfrom theCCT Since a CCT represents all distinct contexts of a program, by De.nition \n1 it includes all distinct q-contexts for any value of q. Hence, the CCT contains implicitly all the \ninformation needed to construct the k-CCF. In this section we show that the k-CCF can be constructed \nstarting from the CCT by joining the maximal reversed suf.xes of length at most k of allitsrootpaths.We \nabstractthisoperation byintroducinga usefulforestinversionprimitive and showhow to implementit. De.nition \n6 (k-inverse forest). Let F be a labeled forest with n nodes v1 ,...,vn.For all i . [1,n],let pi be the \nmaximal suf.x of length at most k of the unique root path that leads to vi in F. The k-inverse of F, \ndenoted as invk(F), is thelabeled forest obtained as join(p1 R ,. . .,pR). n Theproof of thefollowinglemmaprovides \na simple algorithmfor computingthe k-inverse of alabeledforest. Lemma1. Given alabeledforestF withn nodes,theinverseforest \ninvk(F)canbe computedin O(kn)time. Proof. Tobuildtheinverseforest,we .rst computefor eachdistinct label \nx of F alist Lx of all nodes v . F such that l(v)= x.This canbedonein O(n)time.Wethen constructone outputtree \nTx at a time:for eachlabel x, we startfrom an emptytree Tx andfor each node v . Lx we trace at most k \nancestorsbackin F,joining with Tx thepath of scanned nodes. To trace all ancestors in O(k)time, we assume \nthat thereis apointerin F from eachnode toitsparent. Sincejoining atreewith apath oflength at most k \nrequires O(k) time and we have |Lx|pathstojoin, each tree canbe constructed in O(k|Lx|) time. The bound \nfollows from the observation that P |Lx|= n. x The following claim follows directly by De.nition 5 and \nDe.ni\u00adtion6: Property 1. k-CCF = invk(CCT). By Lemma 1 and Property 1, the k-CCF can be computed from \na CCTwith n nodesin O(kn)time.  Figure 6. Example of CCT and k-SF with k =2 computed over the same execution \ntrace. 5.2 A MoreSpace-ef.cientApproach The approach discussed in Section 5.1 has the disadvantage that \nan entire CCT has to be constructed in order to produce a k-CCF. We notice that the CCT contains all \nthe information suf.cient to build a k-CCF for any value of k. This may be super.uous when the k-CCFis \nsmaller than theCCT.Thequestion that we tacklein this sectionishow todesign adata structure that: 1. \nmaintains information on all activated paths of length up to k, and thus canbe usedfor constructingthe \nk-CCF;  2. is more compact than theCCT, atleastfor smallk; 3. canbeconstructed ef.cientlyonthe.yduringprogramexecu\u00adtion. \n  To this aim, wepropose a noveldata structure called k-slab forest (k-SF), whichcanbede.nedin terms \nof theCCTasfollows: De.nition 7 (k-slab forest). Let v1,...,vt be the t nodes at levels multiple of k \nin theCCT(including the root, whichhaslevel0). For any k> 0 and each i . [1,t], let Tvi be the maximal \nsubtree of theCCT ofdepth at most 2k-1rooted at vi.The k-slabforest, denotedas k-SF,isthelabeledforestde.nedbyjoin(Tv1 \n, ...,Tvt ). If nodes at levels multiple of k have z distinct node labels in the CCT, then the k-SF will \ncontain exactly z trees, one per label. An example of k-SF for k =2 is illustrated in Figure 6. The example \nshows that k-SF trees are not necessarily subtrees of the CCT,duetothejoin operation.Forinstance,thek-SFtree \nrootedat the node withlabel h has no corresponding subtreein theCCT, as itis obtainedbyjoiningthe twoCCTsubtrees \nwithlabels (h,f,b)and (h,x). Properties. ByDe.nition7, k-SF = CCTfor all k>d, where d is the depth of \nthe CCT. Therefore, the k-SF can be regarded as a generalization oftheCCT. To analyze the k-SF, we consider \nthe CCT to be conceptually divided into slabs of height k - 1, where the i-th slab consists of nodes \nwithlevel . [ik,(i+1)k).We willsaythat a nodeis a slab boundarynode ifitslevelis a multiple ofk (see \nshadedCCTnodes in Figure 6). Each tree Tj of the k-SF can be also divided into a top region and a bottom \nregion: the top region consists of nodesin levels upto k -1,i.e., top(Tj)= {u . Tj |level(u)<k}, while \nthebottom region contain all the remaining nodes: bottom(Tj)= {u . Tj |k = level(u)< 2k}.Eachtree Tj \nofthe k-SFspanstwo consecutive slabs of T: the top and bottom regions contain nodes belongingtothei-thandthe \n(i+1)-thslabs, respectively,for some i. Lemma2. The sizeofthek-SFis upperboundedbymin{2n,|V|2k}, where \nn if the number of nodes of the CCT and |V|is the number of routines of theprogram. Proof. Each slab \nof theCCT(exceptfor slab 0)appearsbothinthe topregion andinthebottom region of some k-SFtree.Thisimplies \nthat each node of the CCT appears at most twice in the k-SF, and therefore |k-SF|= 2n. Since thejoin \noperationpreserves the tree height, the depth of any k-SF tree is at most 2k -1. The number ofdistinctlabeledpaths \noflength 2k-1startingfrom a node with a given label is at most |V|2k-1, and any two occurrences of the \nsamepathintheCCT arejoined.Theinequality |k-SF|=|V|2k followsbysumming up over alldistinctlabels. When \nk is not too large and the number |V|of routines is small compared to theCCT size n, the k-SF canbe considerably \nsmaller than theCCT, as we will seeinSection7. We nowshowthatthek-SFincludesall activatedpaths oflength \nup to k, and thus canbe usedfor constructing the k-CCF: Lemma 3. For each activated path p = (v1,...,vq)of \nlength q = k, thereis a treein k-SF containing p. Proof. Let v be thedeepest slabboundary node that is \nan ancestor of v1. Since the distance between v and v1 in the CCT is smaller thank, phaslengthat most \nk, andthe k-SFtreeshavedepth 2k-1, then p isfullycontainedin the k-SF tree with rootlabel l(v). Property \n2. k-CCF = invk(k-SF). Proof. By Lemma 3 any q-context in the CCT with q = k also appearsin some k-SF \ntree.Since theinverseis obtainedbyjoining reversed q-contexts,itfollowsthat invk(CCT). invk(k-SF).The \noppositeinclusion canbeprovedby observingthat any root-to-leaf label path in the k-SF is also a label \npath starting at some slab boundary node of the CCT, and thus invk(k-SF) . invk(CCT). The claimfollowsbyProperty1. \nBy Lemma 1 and Property 2, the k-CCF can be computed from a k-SF with n nodesin O(kn)time.As a technical \nnote, we observe that computing correct frequency counters in the k-CCF using the invk primitive requires \nall counters of nodes in the top regions of the k-SF, exceptfor the tree with rootlabel r,tobe .rst cleared \nto zero. Algorithm. We now show an online algorithm for building the k-SFin constant worst-casetimepertrace \noperation.The approach is similartothe classicalCCTconstruction algorithm[2].The main difference is that, \ninstead of having one current location as in the CCT, in the k-SF we have two current locations, working \non two trees at a time.One location t points to a nodein a top region(top location); the other, denoted \nby b, points to a node in a bottom region(bottom location).Both locations are locallyupdated in the same \nway as the CCT. The algorithm starts with an empty k-SF and maintains thefollowingdata: A set R of roots \nof k-SF trees. Since each tree has a distinct root label, R is stored in a mapping table so that,given \na label x,itispossibleto .ndin O(1)time the tree associated with x: wedenote this operation find(R,x). \n The topandbottompointers t and b.  A shadow stack S containing, for each pending routine activa\u00adtion,the \ncorresponding (t,b)pair oflocations.  Figure 7 shows how to update the k-SF at each call and return \nevent.The stack S isinitializedwiththe specialpair (null,null). When the root function r is called, the \nalgorithm creates the .rst root of the k-SF, pointed to by t (line 6). Let d = |S|- 1 denote thelength \nof the current calling context.Aslong as d<k, b = null and we work only on the top region of the tree \nrooted procedure call(x): 1: (t,b). top of stack S //update top region 2: if (|S|- 1) mod k =0 then \n3: b . t 4: t . find(R,x) 5: if t = null then 6: add root t with l(t)= x and c(t)=0 to k-SF and R 7: \nendif 8: else 9: .nd child w of node t withlabel l(w)= x 10: ifw = null then 11: add node w with l(w)= \nx and c(w)=0 to k-SF 12: add arc (t,w) to k-SF 13: endif 14: t . w 15: endif 16: increase c(t) by 1 //update \nbottom region 17: ifb .null then = 18: .nd child u of node bwithlabel l(u)= x 19: ifu = null then 20: \nadd node u with l(u)= x and c(u)=0 to k-SF 21: add arc (b,u) to k-SF 22: endif 23: b . u 24: increasec(b) \nby 1 25: endif 26: push (t,b) onto stack S procedure return: 1: pop stack S Figure7. k-SF construction \nalgorithm. at r, adding nodes and updating counters atlocation t (lines9 14). When d = k, both t and \nb locations are updated(lines2 16 and 17 25, respectively).Every time dreaches apositive multiple of \nk (line6),t enters abottom region of theforest, and thus we move b to tand raise t backtothetopbylettingitpointto \na(possiblynew) tree rootin the k-SF(lines3 7). If lookups at lines9 and18 areimplemented with ahash table, \nthe algorithm requires constant timeper call event. Exhaustive Instrumentation vs. Sampling. For the \nsake of sim\u00adplicity, the algorithm we presented for on-line construction of the k-SF assumes all call/return \nevents are traced using exhaustivein\u00adstrumentation. Notice that full event tracing is required in all \nap\u00adplications whereperfect accuracy is needed, e.g.,debugging orin\u00adtrusiondetection[12].If we can settlefor \napproximate results, a simpler alternative to the k-SF couldbe tojust walk up tokframes onthetop ofthe \nstackperiodically,joining thetraced k-contexts to an initially empty k-CCF. In this way, one could build \ndirectly a k-CCF onthe .y,withouthaving to .rst constructa k-SF.How\u00adever, asdiscussedin[12,35], alow-overhead \nsolutionusing sam\u00adpledstack-walkingalone canbe ratherinaccurate.To overcomethis problem,the authors of[35]use \nan effectivetechnique called burst\u00ading, where stack-walking is immediately followed by a short pe\u00adriod, \ncalled aburst,during which thepro.ler traces each and every routine call and return.This substantiallyincreases \naccuracy while keeping the running time reasonablylow.We remark thatbuilding a k-CCF onthe .yduring aburst \ncanberatherexpensive,requiring O(k)timeper call.A natural way to take advantage of thebene.ts of bursting \nin collecting k-context pro.les consists of feeding the k-SF algorithm with an event tracegeneratedby \nsampledbursting. By suitably tuning the sampling frequency and the burst duration, this approach can \nyield effective time/accuracy tradeoffs. We ana\u00adlyze this methodexperimentallyinSection7. Call CCT Call \nCCT Application CCT graph (callsites) tree depth amarok 13957 6212090 13794470 1254852066 210 ark 10081 \n3859081 8171612 238179120 192 audacity 6880 5264498 13131115 960243960 305 dolphin 9349 3451678 11667974 \n185785164 160 evince 4869 2003454 6772430 92775397 226 .refox 6076 12670331 30294063 617296926 433 gedit \n5934 3927949 4183946 419970719 263 ghex2 3778 960781 1868555 145049522 158 gimp 5275 11350729 26107261 \n819811432 291 gwenview 11510 4970270 9987922 459196696 281 inkscape 6426 5854809 13896175 624835038 299 \nkile 12280 5450415 12936360 484246000 230 oowriter 16541 16371565 41395182 657189223 268 sudoku 5347 \n1335864 2794177 186644308 266 vlc 5808 1844857 3295907 122164908 173 Table 1. Number of nodes of call \ngraph, CCT (both with and without call sites), call tree, and depth of the CCT for different Linux applications. \nHandling Recursion. A major problem related to the construc\u00adtion of theCCTis thatitsdepth maybe unboundedin \nthepresence of recursion.Toovercomethisproblem,Ammons et al. [2]de.ne a vertex equivalence relation on \nthe call tree so that all occurrences of agivenprocedure name on a samepathfromthe rootto aleaf are equivalent. \nWhilethisallowsittoboundthedepth oftheCCTtothe number ofdistinct routinesin theprogram,itimplies addingback\u00adedges, \nwhich break the tree structure of the CCT and its context\u00aduniquenessproperty with respect tothedynamic \ncall tree[2].In contrast, by De.nition 7 the k-SF has a depth boundedby 2k -1 and maintains the context-uniqueness \nproperty by avoiding back\u00adedges. 6. ExperimentalSetup In this section wegive somedetails on ourimplementation,bench\u00admarks, \nand experimental methodology. Tree implementation. We implemented our data structures in C in a common \nframework that makes the different versions directly comparable.We used twodifferent representationsfor \ntree nodes: astandard.rst-child,next-sibling representation,whichisvery space-ef.cient andguaranteesthatthe \nexistence of a node child canbe checkedin timeproportional to the number of children;  an indexed representation \nobtained by statically analyzing the code of each routine and associating an integer key to each called \nsubroutine.Each tree node storesits childrenin adirect\u00adaccess array, which is indexed by the integer \nkeys. With this representation we can check the existence of a node child in constanttime withjust onetablelookup.Theindexing \nworks only for direct calls: indirect calls are added to a separate list, similarly to the standard representation. \n According to our experiments with several benchmarks, the aver\u00adage degree of CCT nodes is a small constant \naround 2-3, making the classical .rst-child, next-sibling tree representation a simple and ef.cient solutionfor \nmaintaining aCCT.Conversely, since the k-SFtendstohavelargerdegreesdueto thetreejoin operations (see \nDe.nition 7), the indexedrepresentation can deliver substan\u00adtial speedups especiallyfor small values \nof k. We willdiscuss this issuein moredepthinSection7. Data structures. In addition to the CCT, k-CCF, \nand k-SF, we also considered variants of the k-CCF obtained by pruning nodes according to twodifferent \nrules: pruned k-CCF. Obtained by removing from the k-CCF all chain subtrees that lead to a leaf. For \neach such chain, we maintain in the partial k-CCF only its .rst node, along with apointer to a corresponding \nk-SF orCCT nodefrom which the prunedchain canbe univocally reconstructed.Thispruning rule is motivatedby \nthe worst-case example ofSection4: in aCCT chain withdistinct nodelabels, each node canbe representedin \nT(k)trees of the k-CCF, while these repeated occurrences are eliminatedby chainpruning.  x%-similar \n8-CCF. Contains all calling contexts of maximal length in which most invocations of each routine occur. \nThese paths are the most interesting from a performance pro.ling perspective and, as we will see in Section \n7, they tend to be rather short. The x%-similar 8-CCF is formally de.ned as follows.We saythata node \nu in ak-CCFtree with root r isx%\u00adsimilar tor ifitscounterissuf.cientlylarge w.r.t.the counterof r,namelyif \nc(u)= (x/100)c(r).Otherwise,thenodeiscalled x%-dissimilar.Monotonicityof countersdiscussedinSection4 \nguarantees that all descendants of a dissimilar node are also dissimilar. The x%-similar 8-CCF is obtained \nby removing from the 8-CCF all x%-dissimilar nodes.  We also considered two scenarios for constructing \nthe CCT and the k-SF: exhaustive instrumentation and static bursting with a 2 msec samplinginterval and \na0.2 msecburstlength(seeSection5.2 and[13,35]). Benchmarks. Tests were performed on a variety of large-scale \nLinuxapplications,includinganInternetbrowser(firefox),graph\u00adics programs (inkscape and gimp), an archiver \n(ark), an hex\u00adadecimal .le viewer (ghex2), audio players/editors (amarok and audacity), and the Open \nOf.ce word processor (oowriter). To ensure deterministic replay of the execution of the interactive ap\u00adplications, \nfollowing [13] we used recorded execution traces of typical usage sessions. Statistical information about \ntest sets is shown in Table 1. In our experiments, we considered the simplest scenario where distinct \ncall sites within the same routine are re\u00adgarded as equivalent. We notice that, even in this case, the \ncalling context trees of the benchmarks we analyzed contain several mil\u00adlion nodes.By maintainingdistinct \nnodesfordistinct call sites, the number ofCCT nodesgrowsby afactorbetween about2 and 3in our test suite, \nmaking thequestfor space-ef.cient techniques even moreimportant(see also[27]). Platform. Runningtimes \nwere measuredon a2.8GHzIntelCore i7with3GB of main memory, runningDebian6.0.4,LinuxKernel 2.6.32,32bit. \n7. ExperimentalResults In this section we present an experimental analysis of our data structures.Theexperimentsaimatstudying \naccuracy of k-context pro.ling, at quantifying running time and space requirements of ourdata structures, \nand attuningparameter kinpracticalscenarios. Accuracy of k-contextpro.les. The motivating example inSec\u00adtion \n1 shows that relevant pro.ling information may be missing in the call graph and hidden in the CCT. For \nthe example we dis\u00adcussed, a 2-contextpro.leappearstobe moreinformativethanboth edgepro.les andfull context \nsensitivepro.les.Ingeneral,the most interesting call paths that lead to a routine appear to be those \nof maximallength in whichmostinvocations of the routine occur.We notice that the notion of similarityintroducedin \nSection 6 charac\u00adterizes suchinterestingpathsin a natural way:theinterestingpaths are precisely those \nthat lead to a leaf in the x%-similar 8-CCF. Thequestion we addresshereis whichvalues of karelarge enough \ninpractice so that the k-CCF contains most suchpaths. averagedepth of x%-similar 8-CCF k-contexts(firefox) \n108 70  107 106 105 104 average depth of trees 50 40 30 20 103 102 k-contexts withthehighest activation \ncounters accountingfor90% 0 5 10 15 20 25 30 35 40 45 50 k Figure 10. Number of k-contexts(k-CCF leaves) \nand number of Figure 8. Average depth of trees in the x%-similar 8-CCF for differentsimilaritythresholds \nx. ofthecalls(hot k-contexts)for k = 50onthe firefox benchmark. hotroutines vs. hot calling contexts \ndata structures size(firefox) 107 109 numberof routinesor calling contexts 106 108 107 106 105 104 \n104 nodes Figure9. Number ofroutines and calling contexts withthehighest Figure 11. Data structures \nsize as afunction of k on the firefox activationcountersaccountingfor90% ofthecalls(hotroutines benchmark. \nandhot calling contexts). of the total number of calls. In Figure 10 we compare the num-In Figure 8 \nwe report the outcome of an experiment in which we ber of k-contexts and hot k-contexts for k = 50 on \nthe firefox evaluatetheaveragedepthof x%-similar 8-CCFtreesfordifferent benchmark.Valuesof k larger than \n50 up to the CCT depth(433) similarity thresholds x.Asexpectedby thede.nitionof similarity, exhibitnegligiblevariationsand \narenotplotted.Thechartshows the depth decreases as we increase the threshold: the larger x,the aninitial \nexponentialgrowthfollowedby aslowconvergence,con\u00ad more nodes are pruned from 8-CCF trees. In practice, \nthe depth .rming that small values of k are the most interesting in practice. is a small constant, whichdepends \non x butisquitesimilaracross Asaframeof comparison,wealsoreportthenumberofhotrou\u00adthedifferentbenchmarks.ComparingthesevalueswiththeCCT \ntinesandthenumberoffulldistinct calling contexts(CCT size)for depthsreportedinTable1,theexperimentsuggeststhatrathersmall \nthesamebenchmark. values of k are suf.cient on average todetect thehottest callpaths, without the need \ntobuild an entireCCT.Forinstance,by choosing Space usage. We .rst evaluate the space required by our \ndata k . [10,20], the k-CCF records for each routine v most partial structures as a function of k. Figure \n11 plots the number of nodes contexts of v whose countersdifferby at most10%(x = 90%) in the CCT, k-CCF, \nk-SF, and pruned k-CCF for k . [1,500] from c(v), independently of the speci.c benchmark. Although not \nfor the firefox benchmark(notice that 500islarger than theCCT reportedinFigure8, wealsoobservedthattheaveragedepth \nwould depthreportedinTable1 andProperty5 ofSection4holds).While beevensmallerbyfocusingonhottreesonly,i.e.,by \nomittingfrom thenumberofCCT nodesisobviously constant,thesizesofthe the average depth computation trees \nwhose root counter is small other data structures can differ by up to .ve orders of magnitude enough. \nSuch hot trees are the natural target of context sensitive and largely bene.t from small values of k. \nWhen k = 12, all our pro.ling. datastructuresaresmallerthantheCCT,suggesting thatthespace bound given \nin Theorem 1 is overly pessimistic. For larger values Size and skewness of k-context pro.les. Figure \n9 compares the of k, the k-CCF can be much larger than the CCT, but the chain numbers of hot routines \nand hot distinct calling contexts, show-pruning rule is very effective and reduces the size considerably. \ning that these numbers can differ by up to four orders of magni-The k-SF curve has an increasing trend \nup to a maximum value tude. This suggests that full individual calling contexts tend to be roughly equal \nto 1.6n (the theoreticalboundis2n, seeLemma2). substantially colderthanindividual routinesintypical applications, \nThen,itconvergestotheCCT size:thelarger k, the smaller the motivating our effort in exploring partial \ncontexts. In our experi-number of trees in the k-SF. For k = 8 the forest consists of a ment,hotitems(routinesorcontexts) \narethoseaccountingfor90% singletree,equal totheCCT.Figure11 alsoshowsthesizeof the max k for whichdata \nstructures are smaller than theCCT CCT 1-SF 8-SF Application 1-SF k (8-SF) (indexed) (indexed) k k-CCF \n18 k-SF prunedk-CCF 15 12 9 6 3 amarok 11.66 2029.90 33.05 14.52 70 ark 2.29 178.18 12.90 3.33 43 audacity \n11.05 118.84 25.41 13.36 40 dolphin 1.64 45.11 6.16 2.40 21 evince 1.96 8.76 2.64 2.28 14 .refox 5.33 \n55.38 7.07 6.85 38 gedit 4.50 34.85 8.19 5.78 13 ghex2 1.48 6.31 2.14 1.93 6 gimp 9.61 93.73 30.45 12.18 \n15 gwenview 4.12 381.16 26.21 6.20 45 inkscape 4.89 25.47 6.82 6.43 5 kile 4.12 315.80 17.13 5.99 41 \noowriter 6.05 38.21 9.57 7.56 10 sudoku 2.34 11.43 2.87 2.60 13 vlc 1.11 49.58 1.60 1.50 28 Table2. Comparison \nof running times. Figure 12. Max values of k for which k-CCF, k-SF, and pruned k-CCF are smaller than \ntheCCT. outcome is exempli.ed by Figure 14a on the firefox benchmark, show that the time required by \nthe indexed k-SFisbarely affected by varying k, while the running time decreases steeply for the standard \nrepresentation(thetime spentfor constructing theCCT is independent of k, and therefore constant). This \ndepends on the fact that the averagedegree ofinternalnodes ofthe k-SFdecreases when k becomes larger \nas shown in Figure 14b, and the indexed representationis more effective onlargedegrees. InTable2wesummarizeperformance \n.guresof ourdatastruc\u00adtures on allbenchmarks, reporting the running timesfor construct\u00ading CCT and k-SF \nfor k =1 and k = 8. We remark that k =1 yields the largest construction times for the k-SF and that CCT \nand 8-SF are exactly the same data structure. The indexed im\u00ad  plementations of the CCT and of the 1-SF \nproved to be respec\u00adtively slower and much faster than the standard implementations: on average,the construction \nalgorithmfortheindexed 1-SFis 2.8x slower than the CCT, but can save more than two orders of mag\u00adnitudesinspace \ncompared tomaintaining theCCT(see, e.g.,Fig\u00ad ure 11). The table also reports the smallest value of k \nfor which Figure 13. Minimum and maximum k-CCF size and size of x%\u00ad similar 8-CCF for different similarity \nthresholds x, normalized over the number ofCCT nodes. CCTand of the k-SF as afunction of k constructed \non a call/return event stream generated with static bursting: notice that the size of theCCT with staticbustingis \nabout30% of the size resultingfrom exhaustiveinstrumentation.Theburstingtechniqueyields a similar space \nreduction for the k-SF, showing that it can be effectively combined with our method. Similar results \nare con.rmed on the entire set of benchmarks. This is shown in Figure 12, which plots the largest value \nof k for which our data structures are smaller than the CCT, and in Figure 13, which plots the best-case \nratio (corresponding to the case k =0) and the worst-case ratio(corresponding tothe case k = 8, both \nwith and without pruning) between the numbers of k-CCF andCCT nodes. Finally, we have measured the number \nof nodes of the x%\u00adsimilar 8-CCF for different similarity thresholds x. The results, reported in Figure \n13, show that this number is very small com\u00adpared to the size of the CCT even for small values of x,providing \nan extremely compact explicit representation of all hot paths of a program, withnolength restrictions. \nRunning time. As a .rst experiment, we analyzed the impact of k on the performance of the construction \nalgorithms of the differentdata structures.Since our approachisindependent of any speci.c instrumentation \nmechanisms, and different techniques for tracing routine enter and exit events might incur rather different \noverheadsinpractice, wefocus onthetime requiredbythe analysis routines only, omitting instrumentation \ntimes. Our tests, whose the standardimplementation of the 1-SFbecomespreferable to the indexed version: \nfor almost all benchmarks, this breakpoint value is ratherlarge,provingthe usefulness ofsupportingdirect \naccessto tree node children.We remark thatperformance canbegreatlyim\u00adprovedbyusing sampledbursting techniques(see[13]) \nalong with ourdata structures. 8. RelatedWork Thereis a vastliteraturerelatedto softwarepro.ling.Inthis \nsection we survey research on context-sensitivepro.lingthat appears tobe most relevant to our work. Callpathpro.ling. \nCallgraphpro.lesproduced by gprof intro\u00adduceforthe .rsttimeaformof context sensitivity[15],by associ\u00adatingproceduretiming \nwith caller-calleepairsand relatingit with edges of the callgraph(hence the alternative name edgepro.ling). \nIt has been later observed that a single level of context sensitivity mayyield to severalinaccuracies[23,28].To \novercometheseis\u00adsues,Goldberg andHall[17]propose callpathpro.les: a callpath is a sequence of function \npairs in a caller-callee relationship, and the pro.le is a sorted list of call paths along with their \nmetrics. The space usage with this approach, however, can be prohibitive. Limiting the length of pro.led \ncall paths as we do is mentioned in[24,31]as apossibleuseful calltree/CCT compactiontechnique. However,differentlyfrom \nour work,in[24,31] theimplications of the basic idea are not further explored and no data structures \nforshortpathsareprovided.Theworkin[3] introduces Bottle\u00adnecks , aninteractive toolforhelpingdevelopersidentifyhot \ncall\u00ad overallprocessing time(firefox) averageinternal nodedegree(firefox) 60 7 50 6 5 k- CCT k-SF SF \n(indexed)     elapsed time (sec) 40 30 20 4 3 2 10 1 0 0 0 5 10 15 20 25 30 35 40 45 50 kk (a) (b) \nFigure14. Runningtime of the k-SF construction algorithms and averageinternaldegree ofCCT and k-SF as \nafunction of k. ingcontexts ofboundedlength.Differentlyfrom our approach,the Bottlenecks tool works of.ine \non a previously recorded call tree allowing users tointeractively mine hot callpaths.Their approach scalespoorlytothelargeC/C++ \napplications we considered, which produce call trees up to billion nodes. They do not provide any time/spacebounds, \nneithertheoretically nor experimentally.Ourk-SFdata structureis constructed online withprovable timebounds, \nis orders of magnitude smaller than a call tree, and supports fully automaticidenti.cation ofhot callpaths \nusing a k-CCF. Callingcontext trees. Callingcontexttreeshavebeenintroduced in[2]as a compactdata structure \nto associateperformance metrics with paths through a program s call graph: Ammons, Ball, and Larus showhowtobuild \naCCTby instrumentingprocedure code and to compute metrics by exploiting hardware counters available in \nmodernprocessors.Since exhaustiveinstrumentation canleadto a large slowdown, a variety of techniques \nhave been proposed to reduce the time overhead of context-sensitivepro.lers.Bernat and Miller[9]generatepathpro.lesincludingonly \na subset of methods ofinterest, while statisticalpro.lers[6,14,17,32] attribute metrics to calling contexts \nthrough periodic sampling of the call stack. Although much faster than exhaustive instrumentation, sample\u00addriven \nstack-walking might incur signi.cant loss of accuracy with respect to the completeCCT[12,35].More accurate \nresults can be obtainedby combining sampling withbursting[5,18,35],i.e., byperforming stack-walkingfollowedby \naburstduring which the pro.ler traces every routine call and return. As we have discussed in Section \n5.2, sampling and bursting can be integrated with our algorithms to reducepro.ling overhead. Space issues \nin context-sensitive pro.ling. Although the CCT compactly represents all distinct calling contexts encountereddur\u00ading \nthe execution of a program, it has been noticed in previous worksthatit couldbe still verylarge anddif.cultto \nanalyze[12, 13, 35], especially if collected pro.les are not only complete, but also call-site aware[27].Differenttechniqueshavebeenthuspro\u00adposed \nto reduce eitherpro.ledata or the amount ofdatapresented to the user. Most previous works focus on performance \nanalysis applications, where identifying a few hot contextsis typically suf\u00ad.cient to guide code optimization. \nIncremental call-path pro.ling letsthe user choose a subset of routinestobe analyzed[9], while callpath \nre.nementhelps usersfocusthe attention onperformance bottlenecksbylimitingand aggregatingtheinformation \nrevealedto the user[16].Tothis end,in[27]the authorsprovide adumper that serializes the CCT as a dynamic \ncall graph. The hot calling con\u00adtexttreeproposedin[13]is a subtree oftheCCTthatincludes only hot nodes \nand their ancestors, compactly representing thehot call\u00ading contexts encountered during a program s execution. \nOur data structures provide another solution to the pro.le data abundance problem, allowing programmers \nto control the space usage by ap\u00adpropriatelychoosing the value of k. Other approaches are based on compactly \nencoding the calling contexts encounteredduring the execution of aprogram[12,29], which is especially \nuseful for tasks such as residual testing, opti\u00admization, statisticalbugisolation, and anomaly-basedintrusionde\u00adtection.In \ncontrast, our workfocuses on explicit context encoding forperformancepro.lingapplications. Flow-sensitive \npro.ling. At the intraprocedural level, the semi\u00adnal work ofBall andLarus[7]hasspawned much research \non .ow\u00adsensitivepro.ling[1,2,4,8,10,11,19,21,22,30].Apathpro.le determineshowmanytimeseachpathinthecontrol.owgraphex\u00adecutes: \npath pro.les terminate either at backedges or at procedure exits, and arethus acyclic.Though useful atdriving \nmany compiler optimizations,ithasbeen observedin[26] that more opportunities canbe exploitedin thepresence \nofinformation aboutlongerpaths: k-iterationpaths are intraprocedural cyclicpaths spanning up to k loopiterations, \nandcanbe computed ef.cientlybygeneralizingthe Ball-Laruspro.ling algorithm.The work on k-iterationpaths[26] \nhas some similarities with our approach, although the focus there is onintraproceduralpro.les. 9. Conclusions \nIn thispaper wehave studied ageneralization of the classical call\u00adingcontextpro.ling approach, motivatedby \nakey observation:full calling contexts starting from the program s root can be substan\u00adtiallycolderthanindividualroutines.In \nsome cases,there mayeven be hot routines having no hot calling context at all. On the other hand, performance \nbottlenecks may still arise in short sequences of callsleadingto ahot routine, makingthem a usefulpro.lingtar\u00adget. \nWehave shown thatpro.lesfor callpaths oflengthup to k can be compactlyrepresented using a simplebut richdata \nstructurethat we called k-calling context forest. Our experiments con.rm that this data structure can \nprovide effective space-accuracy tradeoffs forinterproceduralperformancepro.ling. We regard it as an \ninteresting openquestionhow to construct a x%-similar 8-CCFforpro.ling allhot callpaths usingless space \nthantheCCT.Weexpectthatthetechniquesdevelopedinthispaper could be successfully applied to intraprocedural \npro.ling as well, allowingittodetecthotpathsofboundedlengthinthecontrol.ow graph. Acknowledgments. We \nare indebted to Daniele Cono D Elia for his help in generating some of the test suites of this paper \nand to Fabrizio D Amore, Bruno Ciciani, and Giuseppe F. Italiano for allowing us to use their computing \nequipmentfor our experiments. We would also like to thank the anonymous reviewers and the ProgramCommitteefor \nmany useful comments on our work. References [1] G.Ammons andJ.R.Larus. Improving data-.ow analysiswithpath \npro.les. SIGPLANNot.,39(4):568 582, 2004. [2] G. Ammons, T. Ball, and J. R. Larus. Exploiting hardware \nperfor\u00admance counters with .ow and context sensitive pro.ling. SIGPLAN Not., 32(5):85 96, 1997. ISSN0362-1340. \n[3] G. Ammons, J.-D. Choi, M. Gupta, and N. Swamy. Finding and removing performance bottlenecks in large \nsystems. In ECOOP, volume 3086 of LNCS, pages 170 194, 2004. [4] T. Apiwattanapong and M. J. Harrold. \nSelective path pro.ling. In Proc. ACM SIGPLAN-SIGSOFT workshop on Program analysis for software tools \nand engineering,pages35 42.ACM,2002. [5] M. Arnold and B. Ryder. A framework for reducing the cost of \ninstrumented code. In PLDI,pages168 179. ACM,2001. [6] M.ArnoldandP.Sweeney.Approximating the calling \ncontexttreevia sampling. TechnicalReportRC21789,IBMResearch,2000. [7] T. Ball and J. R. Larus. Ef.cient \npath pro.ling. In MICRO 29: Proceedings of the 29th annual ACM/IEEE international symposium onMicroarchitecture,pages46 \n57,1996. [8] T.Ball,P.Mataga, andM.Sagiv.Edgepro.lingversuspathpro.ling: the showdown. In POPL,pages134 \n148.ACM,1998. [9] A.R.BernatandB.P.Miller.Incremental call-pathpro.ling.Techni\u00adcal report,University \nofWisconsin,2004. [10] M. D. Bond and K. S. McKinley. Continuous path and edge pro.l\u00ading. In Proc. 38th \nannual IEEE/ACM International Symposium on Microarchitecture,pages130 140.IEEEComputerSociety,2005. [11] \nM.D.Bond andK.S.McKinley.Practicalpathpro.lingfordynamic optimizers. In CGO,pages205 216.IEEEComputerSociety,2005. \n[12] M.D.Bond andK.S.McKinley. Probabilistic calling context. SIG-PLAN Not. (proceedings of the 2007 \nOOPSLA conference), 42(10): 97 112,2007. [13] D. C. D Elia, C. Demetrescu, and I. Finocchi. Mining hot \ncalling contextsinsmall space. InM.W.HallandD.A.Padua,editors, PLDI, pages516 527.ACM,2011. [14] N. Froyd, \nJ. Mellor-Crummey, and R. Fowler. Low-overhead call path pro.ling of unmodi.ed, optimized code. In Proc. \n19th Annual International Conf. onSupercomputing,pages81 90.ACM,2005. [15] S.L.Graham,P.B.Kessler,andM.K.McKusick.gprof: \na callgraph executionpro.ler(with retrospective).InK.S.McKinley, editor, Best ofPLDI,pages49 57.ACM,1982. \n[16] R.J.Hall. Callpath re.nementpro.les. IEEE Trans.Softw. Eng.,21 (6):481 496, 1995. [17] R. J. Hall \nand A. J. Goldberg. Call path pro.ling of monotonic pro\u00adgram resources in UNIX. In Proc. Summer 1993 \nUSENIX Technical Conference,pages1 19.USENIXAssociation,1993. [18] M. Hirzel and T. Chilimbi. Bursty \ntracing: A framework for low-overhead temporal pro.ling. In Proc. 4th ACM Workshop on Feedback-Directed \nand DynamicOptimization,2001. [19] R. Joshi, M. D. Bond, and C. Zilles. Targeted path pro.ling: Lower \noverhead path pro.ling for staged dynamic optimization systems. In CGO,pages239 250, 2004. [20] Z.Lai,S.-C.Cheung, \nandW.K.Chan.Inter-context control-.ow and data-.owtestadequacycriteriafornescapplications.InM.J.Harrold \nandG.C.Murphy, editors, SIGSOFTFSE,pages94 104.ACM,2008. ISBN978-1-59593-995-1. [21] J. R. Larus. Whole \nprogram paths. SIGPLAN Not., 34(5):259 269, 1999. [22] D. Melski and T. W. Reps. Interprocedural path \npro.ling. In S.J\u00a8ahnichen, editor, CC, volume 1575 of Lecture Notes in Computer Science,pages47 62.Springer,1999. \nISBN3-540-65717-7. [23] C.Ponder andR.J.Fateman.Inaccuraciesinprogrampro.lers. Softw., Pract.Exper.,18(5):459 \n467, 1988. [24] S. P. Reiss and M. Renieris. Encoding program executions. In Pro\u00adceedings of the 23rd \nInternational Conference on Software Engineer-ing,ICSE 01,pages221 230,2001. [25] T. W. Reps, T. Ball, \nM. Das, and J. R. Larus. The use of program pro.ling forsoftware maintenancewith applicationstotheyear2000 \nproblem. In M. Jazayeri and H. Schauer, editors, ESEC/ SIGSOFT FSE, volume1301 of LectureNotesinComputerScience,pages432 \n449.Springer,1997. ISBN3-540-63531-9. [26] S.RoyandY.N.Srikant.Pro.lingk-iterationpaths:Ageneralization \nof theball-laruspro.lingalgorithm.In CGO,pages70 80,2009. [27] A. Sarimbekov, A. Sewe, W. Binder, P. \nMoret, and M. Mezini. JP2: Call-siteaware calling contextpro.lingforthejavavirtualmachine. Science of \nComputer Programming, 2012. ISSN 0167-6423. doi: 10.1016/j.scico.2011.11.003. [28] J.M.Spivey.Fast, accurate \ncallgraphpro.ling. Softw.,Pract.Exper., 34(3):249 264, 2004. [29] W. N. Sumner, Y. Zheng, D. Weeratunge, \nand X. Zhang. Precise calling context encoding. InJ.Kramer,J.Bishop,P.T.Devanbu, and S. Uchitel, editors, \nICSE, pages 525 534. ACM, 2010. ISBN 978-1\u00ad60558-719-6. [30] K.Vaswani,A.V.Nori, andT.M.Chilimbi. Preferentialpathpro.l\u00ading:compactly \nnumberinginterestingpaths.In POPL,pages351 362. ACM,2007. [31] J. Weidendorfer, M. Kowarschik, and C. \nTrinitis. A tool suite for simulationbased analysisof memory accessbehavior.In International Conference \non Computational Science, volume 3038 of LNCS,pages 440 447,2004. [32] J. Whaley. A portable sampling-based \npro.ler for Java virtual ma\u00adchines. In Proceedings of theACM2000Conference onJavaGrande, pages78 87.ACMPress,2000. \n[33] M. R. Woodward, D. Hedley, and M. A. Hennell. Experience with path analysis and testing of programs. \nIEEE Trans. Software Eng.,6 (3):278 286,1980. [34] X. Zhang, S. Tallam, and R. Gupta. Dynamic slicing \nlong running programs through execution fast forwarding. In M. Young and P. T. Devanbu, editors, SIGSOFT \nFSE, pages 81 91. ACM, 2006. ISBN 1-59593-468-5. [35] X. Zhuang, M. J. Serrano, H. W. Cain, and J.-D. \nChoi. Accurate, ef.cient, and adaptive calling contextpro.ling. In PLDI,pages 263 271,2006.  \n\t\t\t", "proc_id": "2384616", "abstract": "<p>Calling context trees are one of the most fundamental data structures for representing the interprocedural control flow of a program, providing valuable information for program understanding and optimization. Nodes of a calling context tree associate performance metrics to whole distinct paths in the call graph starting from the root function. However, no explicit information is provided for detecting short hot sequences of activations, which may be a better optimization target in large modular programs where groups of related functions are reused in many different parts of the code. Furthermore, calling context trees can grow prohibitively large in some scenarios. Another classical approach, called edge profiling, collects performance metrics for caller-callee pairs in the call graph, allowing it to detect hot paths of fixed length one. We study a generalization of edge and context-sensitive profiles by introducing a novel data structure called k-calling context forest (k-CCF). Nodes in a k-CCF associate performance metrics to paths of length at most k that lead to each distinct routine of the program, providing edge profiles for k=1, full context-sensitive profiles for k equal to infinity, as well as any other intermediate point in the spectrum. We study the properties of the k-CCF both theoretically and experimentally on a large suite of prominent Linux applications, showing how to construct it efficiently and discussing its relationships with the calling context tree. Our experiments show that the k-CCF can provide effective space-accuracy tradeoffs for interprocedural contextual profiling, yielding useful clues to the hot spots of a program that may be hidden in a calling context tree and using less space for small values of k, which appear to be the most interesting in practice.</p>", "authors": [{"name": "Giorgio Ausiello", "author_profile_id": "81100125349", "affiliation": "Sapienza University of Rome, Rome, Italy", "person_id": "P3856196", "email_address": "ausiello@dis.uniroma1.it", "orcid_id": ""}, {"name": "Camil Demetrescu", "author_profile_id": "81100357279", "affiliation": "Sapienza University of Rome, Rome, Italy", "person_id": "P3856197", "email_address": "demetres@dis.uniroma1.it", "orcid_id": ""}, {"name": "Irene Finocchi", "author_profile_id": "81502771811", "affiliation": "Sapienza University of Rome, Rome, Italy", "person_id": "P3856198", "email_address": "finocchi@di.uniroma1.it", "orcid_id": ""}, {"name": "Donatella Firmani", "author_profile_id": "81488669651", "affiliation": "Sapienza University of Rome, Rome, Italy", "person_id": "P3856199", "email_address": "firmani@dis.uniroma1.it", "orcid_id": ""}], "doi_number": "10.1145/2384616.2384679", "year": "2012", "article_id": "2384679", "conference": "OOPSLA", "title": "k-Calling context profiling", "url": "http://dl.acm.org/citation.cfm?id=2384679"}