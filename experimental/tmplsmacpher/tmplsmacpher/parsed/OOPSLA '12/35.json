{"article_publication_date": "10-19-2012", "fulltext": "\n Formal Speci.cation of a JavaScript Module System Seonghoon Kang Sukyoung Ryu KAIST KAIST kang.seonghoon@mearie.org \nsryu.cs@kaist.ac.kr Abstract The JavaScript programming language, originally developed as a simple scripting \nlanguage, is now the language of choice for web applications. All the top 100 sites on the web use JavaScript \nand its use outside web pages is rapidly growing. However, JavaScript is not yet ready for programming \nin the large: it does not support a module system. Lack of names\u00adpaces introduces module patterns, and \nmakes it dif.cult to use multiple JavaScript frameworks together. In this paper, we propose a formal \nspeci.cation of a JavaScript module system. A module system for JavaScript will allow safe and incremental \ndevelopment of JavaScript web applications. While the next version of the JavaScript standard proposes \na module system, it informally describes its design in prose. We formally specify a module system as \nan extension to the existing JavaScript language, and rigor\u00adously describe its semantics via desugaring \nto .JS , a prior core calculus for JavaScript. We implement the desugaring process and show its faithfulness \nusing real-world test suites. Finally, we de.ne a set of properties for valid JavaScript pro\u00adgrams using \nmodules and formally prove that the proposed module system satis.es the validity properties. Categories \nand Subject Descriptors D.3.3 [Programming Languages]: Language Constructs and Features General Terms \nLanguages Keywords JavaScript, module system, desugaring, formal\u00adization 1. Introduction JavaScript [13], \noften called the language of the Web, was .rst envisioned as a scripting language for simple tasks; it \nwas not especially designed for programming in the large. As its namesake from the JavaTM Programming \nLan\u00adguage [5] suggests, it did not intend to replace Java but to Permission to make digital or hard copies \nof all or part of this work for personal or classroom use is granted without fee provided that copies \nare not made or distributed for pro.t or commercial advantage and that copies bear this notice and the \nfull citation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. OOPSLA 12, October 19 26, 2012, Tucson, Arizona, \nUSA. Copyright c &#38;#169; 2012 ACM 978-1-4503-1561-6/12/10. . . $10.00 provide the language for the \nniche. However, with the advent of Dynamic HTML [18], Web 2.0 [30], and most recently HTML5 [1], JavaScript \nis now being used on a much larger scale than intended. All the top 100 most popular web sites according \nto the Alexa list [3] use JavaScript and its use outside web pages is rapidly growing [2]. One missing \nfeature from JavaScript, when program\u00adming in the large, is a module system. A module system allows programmers \nto develop large software mostly in\u00addependently, depending only on interfaces, and guarantees interoperability \nbetween modules via static checking of the interfaces. However, JavaScript supports only one global namespace \nshared by all program units, and the program\u00admers have to ensure that there are no name con.icts between \nthe program units. To alleviate the problem of namespace handling, the JavaScript community recommends \nthe module pattern [27]. The module pattern uses function-local namespaces to sim\u00adulate modules, but \nit does not avoid name con.icts between multiple modules. For example, jQuery [22] exports two global \nsymbols jQuery and $ by default and many other JavaScript libraries also often export $ as a global symbol. \nTherefore, if one uses another JavaScript library alongside jQuery, the jQuery.noConflict() method relinquishes \nthe control of $ so that the other JavaScript library uses $. However, it does not prohibit jQuery-dependent \nextension libraries (called plugins ) from using $ to refer to jQuery. The lack of a module system for \nJavaScript also leads to a vulnerability to security attacks. In JavaScript web appli\u00adcations, it is \nextremely common to mix untrusted third-party JavaScript code with the trusted web page, where the third\u00adparty \ncode can access the global JavaScript scope. Therefore, it is much desirable to control such accesses \nto the global scope, but there is currently only one standardized way to include third-party code: via \nthe <script> element. Since the element always injects a code into the global scope, no .ner-grained \ncontrol is possible. While a combination of XMLHttpRequest and eval can solve some of this prob\u00adlem, \nit is no use when the code is not in the current domain name because the same-origin policy of HTML prohibits \nloading the code. More robust approach could be using a presumably safe subset of JavaScript: Yahoo! \nADsafe [7], Facebook FBJS [36], and Google Caja [35]. While they are intended to be safe subsets of JavaScript, \nnone of them has been shown safe. Rather, researchers have reported security vulnerabilities with ADsafe \nand FBJS [25, 26, 33, 34].  Recently, the JavaScript community reached a consen\u00adsus that JavaScript \nindeed needs a language-level sup\u00adport for a module system, and the next major revision of the ECMAScript \nstandard, ECMAScript Harmony (or ECMAScript.next [11]), will have modules as described in their proposal \n[8, 37]. The proposed 4th edition of ECMA\u00ad 262 including a more ambitious module system was aban\u00addoned \ndue to the lack of backward compatibility and other reasons, and it has been scaled down into ECMAScript.next. \nThis module system is built on top of the highly dynamic and unusual semantics of JavaScript, and consequently \nit differs from many other module systems for statically-and dynamically-typed languages. As with the \nECMAScript standard [10], the proposal describes the module system in\u00ad formally in prose. In this paper, \nwe present a formal speci.cation of a JavaScript module system. To resolve the problem of back\u00adward compatibility, \nwe extend the existing JavaScript syntax with a module system and desugar away the module syn\u00adtax at \ncompile time. Unlike the informal proposal [8], we rigorously describe the semantics of the module system \nvia formal description of the desugaring process. In addition to implementing and testing the desugaring \nprocess using real-world test suites, we de.ne a set of properties for valid JavaScript programs that \nuse modules and formally prove that our module system satis.es the properties. The contributions of this \npaper are: 1. To present a formal model of the current ECMAScript proposal [8] to add a module system \nto JavaScript. This model serves as a tool to describe and evaluate the module-system proposal. While \nthe design modeled by the paper is still a proposal, the proposal is widely ac\u00adcepted and the implementation \nof the proposal has started in Firefox [28]. We believe that a precise description of the JavaScript \ns name resolution in the presence of the module system would be a useful guideline to implement the proposed \nmodule system correctly. 2. To state and prove soundness principles for the module system. By using \nthe formal speci.cation of the module system, we can lay out several consistency properties of the module \nsystem such as checking for the absence of free variables in a program and correct handling of im\u00admutability, \nand prove them rigorously. The formal spec\u00adi.cation allows any interested researchers to de.ne and prove \nother module properties in addition to the proper\u00adties stated and proved in this paper. Moreover, the \nfor\u00admal speci.cation opens a gate to mechanically check and prove the desired properties. 3. In passing, \nto provide a test suite for JavaScript applica\u00adtions using modules. Our tests are available online, which \ncover all the module-related constructs.  The remainder of this paper is organized thus. Sec\u00adtion 2 \npresents our JavaScript module system, based on ECMAScript.next. Section 3 introduces .JS [20], a core \ncal\u00ad culus for JavaScript, and describes its desugaring including scope manipulation, which is omitted \nfrom [20] but serves an important role in our module desugaring. Section 4 presents the desugaring rules \nto mechanically translate JavaScript with modules into our variant of .JS. Section 5 establishes and \nproves the properties of valid JavaScript programs in our module system. Section 6 describes related \nwork and Sec\u00ad tion 7 discusses future work of our research and concludes. 2. Modules for JavaScript We \npropose a JavaScript module system, which is based on the informal description of ECMAScript.next [8]. \nBecause not all the current web browsers fully support the 5th edition of ECMA-262, our module system \nuses the 3rd edition of ECMA-262 as the base JavaScript language to experiment our system with current \nbrowsers. This section provides a high-level description of our JavaScript module system and Section \n4 presents the for\u00ad mal speci.cation of its syntax and semantics. The module system has the following \ncharacteristics: Modules may be nested.  Modules may be mutually recursive as long as there are no \ncyclic module aliases.  References used in modules are resolved at compile time. (Property 6 proved \nin Section 5.3.)  Private names in a module are safely isolated inside the module. (Property 7 proved \nin Section 5.3.)  External modules are not supported; this is the only se\u00admantic difference from the \nECMAScript.next proposal.  2.1 Syntax: Module Declarations and Uses A module de.nition introduces a \nnew module scope: any variable or function declaration within a module scope is only visible in that \nmodule scope, but names declared in an enclosing module scope are visible in inner mod\u00adule scopes. For \nexample, in Figure 1, the name Browser in the global scope is available within Design. Module names may \nbe aliased as in the statement module DOM = Browser.DOM;. Names declared in a module scope are exposed \nto other module scopes by import and export statements. An import statement declares a local name that \nis exported from other module, but the local name may be different from the exported name when the import \nstatement introduces an alias. Figure 1 shows that Browser.DOM.document is re\u00adnamed to DOMdoc in Design \nbecause document is already in use in Design. When an import statement uses * instead of an explicit \nname to import, as in import DOM.*;, it im\u00adports all the exported names except module names from the \ngiven module. With this restriction, we can guarantee that  module Browser { export module DOM { var \ndocument = ...; export document; } } module Design { import Browser.DOM.document: DOMdoc; export function \ninitialize() { document = DOMdoc.createElement( iframe ); ... } export var document; } module DOM = Browser.DOM; \nimport DOM.*; Design.initialize(); document.body.appendChild(Design.document); Figure 1. Module declarations \nand uses only module declarations declare module names, which makes it simple to check module references \nstatically. An export statement declares exported names from a mod\u00adule. The export keyword may be a modi.er \non a func\u00adtion, a variable, or a module declaration. A module may export the modules declared in it but \nnot the modules de\u00adclared elsewhere; all the names declared in the exported modules are also exported. \nAn export statement may in\u00adtroduce an alias just like import: export y:x; exports a local name x declared \nin the current module as a new name y. In order to resolve module references at compile time, all the \nmodule references in import statements and module alias declarations should be simple module paths such \nas Browser.Canvas.WebGL and declared by module decla\u00adrations. Unlike ECMAScript.next, our module system \ndoes not allow external modules. In ECMAScript.next, an external module may be loaded by require(\"location\") \nunder an empty scope, which means that the loaded module cannot access any of the enclosing scope and \nit may be customized via a module loader. Because the module loader proposal [9] itself is quite complicated \nand it does not support back\u00adward compatibility by desugaring, we consider it as beyond our scope and \ndo not address external modules in this pa\u00adper, which is the only difference from the ECMAScript.next \nmodule system.  2.2 Static Semantics: Resolution of Module References Given all the source code of modules, \nmodule references are resolved at compile time and the resolution process always terminates: Because \nECMAScript.next does not allow catch-all export statements like export *;, each module has only a .\u00adnite \nnumber of exported names that should be checked statically. Because only module declarations declare \nmodule names, resolving module references requires only static check\u00ading.  Because ECMAScript.next does \nnot allow non-local module exports, the declared modules and the exported module names together form \nan acyclic directed graph, which means that the number of possible module paths is always .nite.   \n2.3 Dynamic Semantics: Module Instances A module is evaluated to a module instance, which contains a \nlexical environment with a set of exported names. It is helpful to distinguish between a module instance \nand a mod\u00adule instance object, which is an immutable JavaScript object that exposes exported names from \nthe environment. Since exported names and internal names may be different, a mod\u00adule instance object \nand an environment record1 are not the same. While modules may have cyclic references, meaning that modules \nmay refer to other modules yet to be de.ned, any side effects within a module de.nition should be exe\u00adcuted \nin their textual order. For example, module Browser and module Design de.nitions can be textually swapped \nsafely if there are no side effects within them. Because side effects should occur in their textual order, \nmodule-level en\u00advironment records and module instance objects should be initialized before any side effects \noccur. We call such an ini\u00adtialization a module instantiation; it initializes only the ex\u00adported functions \nof the module instance object and it leaves the other exported names as undefined, just like func\u00adtion \nde.nitions are initialized before variable de.nitions in JavaScript. As ECMAScript.next clearly states, \nboth import and export statements respectively import and export bindings not values. Therefore, any \nchanges to imported variables should be visible to their corresponding exported variables as well as \nthe module instance object. 3. .JS with Explicit Scope Desugaring In this section, we describe .JS, a \ncore calculus for JavaScript developed by Guha et al. [20]. The authors formally describe .JS in a conventional \nsmall-step operational semantics, de\u00ad.ne a set of desugaring rules from JavaScript to .JS except for \neval, and implement the desugaring. However, because they present only a small portion of the desugaring \nrules for simple cases, the full desugaring process is not well docu\u00admented especially for scope desugaring. \nTo formally specify our module system via desugaring in Section 4, we rigor\u00ad ously describe the missing \nscope desugaring. Due to space limitations, we present only the central parts of the scope desugaring \nin this section and its full speci.cation is avail\u00adable in our companion report [23]. 1 In JavaScript, \nan environment record maintains identi.er bindings that are created within the scope of its associated \nlexical environment.  l ::= \u00b7\u00b7\u00b7 location c ::= num number | str string | true true | false false | unde.ned \nunde.ned | null null v ::= c primitive value | func (x \u00b7\u00b7\u00b7 ) { return e } function |{str: v \u00b7\u00b7\u00b7} object \n| l location e ::= x variable | v value | let (x = e \u00b7\u00b7\u00b7 ) e binding | e(e \u00b7\u00b7\u00b7 ) function application \n| opn(e1 \u00b7\u00b7\u00b7 en) operator application |{str: e \u00b7\u00b7\u00b7} object literal | e[e] .eld access | e[e]= e .eld \nupdate | delete e[e] delete | e = e assignment | ref e mutable reference | deref e dereference | if (e) \n{e} else {e} conditional | e; e sequence | while (e) {e} loop | label:{e} label | break label e break \n| try {e} catch (x) {e} try-catch | try {e} .nally {e} try-.nally | err v error | throw e exception throw \nFigure 2. Simpli.ed syntax of .JS 3.1 .JS : Core Calculus for JavaScript Because the peculiar features \nof JavaScript make it dif.cult to analyze JavaScript programs statically, Guha et al. present a core \ncalculus, .JS, that captures the JavaScript language except for eval. They present a desugaring process \nfrom JavaScript to .JS and test their implementation with the Mozilla JavaScript test suite. Figure 2 \nshows a simpli.ed syntax of .JS . We typeset .JS code in a sans-serif typeface, and JavaScript in a fixed-width \ntypeface. Unlike JavaScript values, .JS values are immutable; mu\u00adtable objects and variables should be \nmodelled with .rst\u00adclass mutable references using ref and deref. Functions and objects are also .JS values: \na function has a body expres\u00adsion and it requires the number of its formal parameters and the number \nof actual arguments at a call site to match; when an object accesses a .eld, it implicitly accesses its \nprototype when it does not de.ne the .eld, and returns unde.ned when there is no prototype. // original \nexample print(f(5)); y = 12; function f(x){ return x + 42; } var y; print(f(y)); // desugared version \n var f = function(x){ return x + 42; }; var y = undefined; print(f(5)); y = 12; print(f(y)); Figure \n3. Reordering and initialization via desugaring By desugaring, JavaScript becomes lexically scoped .JS \n, which does not need scope objects any more. In .JS , only one construct introduces a new scope: let \nbinds immutable values to names within its body. Most n-ary operators are implemented as side-effect-free \nprimitive functions, dn. Similarly, expressions that manipulate an object such as e[e]= e and delete \ne[e] are free from side effects and re\u00adturn a copy of the updated object. Most control constructs remain \nthe same in .JS, except that else clauses are manda\u00adtory, for and do..while statements are desugared \ninto the while expression, and continue and return statements are desugared into the break expression. \n 3.2 Explicit Scope Desugaring While Guha et al. [20] provide only some fraction of the desugaring rules, \nthe full description of the desugaring pro\u00adcess including scope desugaring is necessary to formally specify \nour module system via desugaring. A scope in JavaScript is basically a set of bindings from names to \nval\u00adues, but its behavior is greatly different from most other languages. In JavaScript, with and catch \nblocks and func\u00adtions create new scopes, but neither a var statement nor a block statement introduces \na new scope. Moreover, when a function is de.ned in a scope, the function is initialized right after \nthe creation of the scope. The quirky semantics of JavaScript scopes often leads to confusing results, \nand the desugaring from JavaScript to .JS should capture this semantics correctly. First, the desugaring \nshould reorder variable and function de.nitions, which we call hoisting. For example, the orig\u00adinal example \nin Figure 3 includes declarations of f and y after their uses. To capture the JavaScript scope semantics \nin a conventional way, the desugared version reorders the dec\u00adlarations of f and y, and initializes y \nto undefined. Secondly, the desugaring should emulate environment records while desugared code does not \nhave any environ\u00adment records: any changes to desugared variables should be re.ected in the corresponding \nenvironment record and  // original example var x =42; print(window.x); // 42 window.x = 54; print(x); \n// 54 function f(y){ return x -y; } print(f(4)); // 50 // desugared version window.f = function(y){ \nreturn window.x -y; }; window.x = 42; print(window.x); // 42 window.x = 54; print(window.x); // 54 print(window.f(4)); \n// 50 Figure 4. Desugaring global variables x ::= identi.er name t ::= var desugaring type . ::= E desugaring \nscope | local . ::= tx desugaring binding S ::= {(x,. .) \u00b7\u00b7\u00b7} desugaring environment S* ::= E desugaring \nenvironment chain | S* S | S* x Figure 5. Desugaring environment for .JS vice versa. The prominent example \nof this restriction is a global object, often called window. For example, the orig\u00adinal example in Figure \n4 illustrates how the global object and the global scope interact. Since not only the changes to the \nglobal variable x but also the changes to the global ob\u00adject window should be synchronized, every global \nvariable is desugared as a reference to the global object, as shown in the desugared version. As the \nbody of the desugared function window.f shows, the desugaring process should be able to determine whether \na particular name is global or local: the global name x is desugared as window.x and the local name y \nis desugared as y. To keep track of such information, the desugaring process maintains binding and scope \ninformation for each name, a desugaring environment.  3.3 Desugaring Environments The desugaring process \nmaintains desugaring environments to keep track of static information of names. While not ex\u00adplicitly \nmentioned, the implementation of the .JS desug\u00adaring also maintains such environments. Figure 5 presents \nour desugaring environments. A desugaring environment is a mapping from names to their desugaring bindings \nand desugaring scopes. A desugaring binding is a desugaring type and a name; a desugaring type describes \nwhat kind of value a desugaring binding binds to. While only one kind of value var for read-write bindings \nexists in this section, the desugaring process for modules described in Section 4 extends desugaring \nenvironments with more information. A desugaring scope describes the scope of a desugaring bind\u00ading: \nlocal for a function body and E for otherwise. Because a desugaring environment can shadow other desugaring \nenvi\u00adronments when a nested scope introduces names also present in an enclosing scope, we model nested \nscopes with a desug\u00adaring environment chain. Because the with statement intro\u00adduces a new scope in JavaScript, \nwe model an environment introduced by the with statement as an identi.er x denoting the corresponding \nwith object. The rightmost environment in a chain denotes the innermost scope, and subsequent en\u00advironments \nare looked up only when a name is not bound in the rightmost environment. In order to make it easier \nto rewrite a given JavaScript program to a corresponding .JS program, we .rst build a desugaring environment \nwhich maps local variables and lo\u00adcal functions to their unique binding and scope information via Envf \n[] as follows: Envf [var x [= e];] = {(x, var x local)} Envf [for (var x [= e]; e\"; e\"\") s] = {(x, var \nx local)} . Envf [s] Envf [for (var x in e) s] = {(x, var x local)} . Envf [s] Envf [function f(x \u00b7\u00b7\u00b7 \n){s \u00b7\u00b7\u00b7}] = {(f, var f local)} Envf [Stmt(s1 \u00b7\u00b7\u00b7 sk)] = Envf [s1] . \u00b7\u00b7\u00b7 . Envf [sk] where metavariables \ne ranges over expressions, s ranges over statements, and f ranges over function names. For presen\u00adtation \nbrevity, we use Stmt(s1 \u00b7\u00b7\u00b7 sk) (k = 0) to denote a JavaScript statement with k substatements, and its \nfull de.\u00adnition is available in a companion report [23]. 3.4 Desugaring of JavaScript The desugaring \nprocess uses three kinds of desugaring: desugarS [] : scope desugaring desugarL[] : l-value desugaring \ndesugarR[] : r-value desugaring Figure 6 presents desugaring a program p, desugar[p], which consists \nof building a top-level environment from the global environment (lines 2 5), building a desugaring envi\u00adronment \nEnvf [p], initializing local variables and functions via desugarS [], and rewriting the program to a \ncorrespond\u00ading program in .JS via desugarR[]. Built-in names that are de.ned in the global environment \nsuch as Object and Array are declared at top level as $Object and $Array. We assume that names starting \nwith $ are reserved for .JS, so that the names such as $global, $Object, and $Array are never directly \nupdated or rede.ned by any JavaScript code.  1 desugar[p] = 2 let ($global = ref { Object : \u00b7\u00b7\u00b7 , Array \n: \u00b7\u00b7\u00b7 , \u00b7\u00b7\u00b7}) 3 let ($Object =(deref $global)[ Object ], $Array =(deref $global)[ Array ], \u00b7\u00b7\u00b7 ) 4 let \n($scope E = $global) 5 let (this = $scope E) 6 desugarS [p](Envf [p]; desugarR[p](E Envf [p])) Figure \n6. Desugaring of a JavaScript Program 1 desugarR[function f (x \u00b7\u00b7\u00b7 ){s \u00b7\u00b7\u00b7}](S*)= 2 let (f = ref unde.ned) \n3 f = ref { $code : func(this, $arg x \u00b7\u00b7\u00b7 ) { 4 return $return:{ 5 // where S= {(x, var x local) \u00b7\u00b7\u00b7}. \nEnvf [s \u00b7\u00b7\u00b7 6 desugarS [s \u00b7\u00b7\u00b7 ](S,x = $arg x \u00b7\u00b7\u00b7 ; ] 7 desugarR[s \u00b7\u00b7\u00b7 ](S* {(f, var f local)} S)); 8 \nunde.ned 9 } 10 }, 11 prototype : ref { $proto : (deref $Object)[ prototype ]}}; 12 deref f Figure 8. \nR-value desugaring of the function statement 1 desugarS [s](S,e)= 2 let (xlocal = ref unde.ned)\u00b7\u00b7\u00b7 3 \n// where xlocal .{x | (x,t x local) . S} 4 earlyinitS [s](S); 5 e Figure 7. Scope Desugaring As Figure \n7 shows, scope desugaring hoists local vari\u00ad ables (lines 2 3) and initializes function de.nitions early \n(line 4) via earlyinitS []: earlyinitS [function f(x \u00b7\u00b7\u00b7 ){s \u00b7\u00b7\u00b7}](S) = desugarL[f](E S; desugarR[function(x \n\u00b7\u00b7\u00b7 ){s\u00b7\u00b7\u00b7}](E S) L-value desugaring rewrites each l-value JavaScript con\u00adstruct to its corresponding \nl-value .JS expression, and r\u00advalue desugaring rewrites r-value JavaScript constructs to the corresponding \nr-value .JS expressions. Due to space limitations, we describe the full desugaring rules in a com\u00adpanion \nreport [23] and show only the r-value desugaring rule for the function statement in Figure 8. The desugaring \nis mostly from the original .JS desugaring except that we ex\u00adplicitly describe scope desugaring here. \nIt creates local vari\u00adable bindings for formal parameters, x = $arg x \u00b7\u00b7\u00b7 , to han\u00addle such cases when \nlocal variables and formal parameters have the same names (line 6). Because a function introduces a new \nscope, it creates a local desugaring environment S from local bindings (line 5). Finally, using a new \ndesugaring environment chain, S* {(f, var f local)} S, it desugars the function body (line 7). 4. Module \nSystem via Desugaring Now, we are ready to formally de.ne our module system for JavaScript. We .rst extend \nthe JavaScript syntax for modules and adjust the syntax and semantics of .JS slightly in Sec\u00adtion 4.1. \nTo maintain scope information for module names, we extend the desugaring environments in Section 4.2 \nand describe the static name resolution via desugaring environ\u00adments in Section 4.3. Finally, Section \n4.4 presents the desug\u00ad aring process from the extended module syntax into the (modi.ed) .JS syntax, \nand Section 4.5 shows our experi\u00ad ment results and discusses some limitations of our desugar\u00ading mechanism. \n 4.1 Syntax and Semantics for Modules We extend the original syntax of JavaScript with module declarations, \nand import and export statements. Figure 9 shows the additional concrete syntax for modules. We can declare \na module by an explicit de.nition or an alias. Names de.ned in other modules may be imported directly, \nas an alias, or by the catch-all syntax, *. A module may export its variable, function, and module declarations, \nand local and quali.ed names. To represent module instance objects that are not modi.\u00adable after their \nde.nitions, we introduce slight modi.cations to .JS as shown in Figure 10. We add a new accessor value \n((vg)) to denote a read-only .eld. Figure 11 presents the op\u00ad erational semantics of the extended .JS \nsyntax. The rule  module M {s \u00b7\u00b7\u00b7} module de.nition module M = M \u00b7\u00b7\u00b7 .M; module alias import M \u00b7\u00b7\u00b7 .x; \nquali.ed import import M \u00b7\u00b7\u00b7 .x: x; aliased import import M \u00b7\u00b7\u00b7 .*; import all export var x [= e]; exported \nvariable export function x(x \u00b7\u00b7\u00b7 ){s \u00b7\u00b7\u00b7} exported function export module M {s \u00b7\u00b7\u00b7} exported module export \nmodule M = M \u00b7\u00b7\u00b7 .M; exported module alias export x; exported local export x: x; exported local alias \nexport x: M \u00b7\u00b7\u00b7 .x; exported quali.ed alias Figure 9. Extended syntax for JavaScript modules v ::= \u00b7\u00b7\u00b7 \n| a value a ::= ((vg)) accessor vg ::= func(){ return e } getter Figure 10. Extended syntax for .JS to \nallow accessors [E-GETFIELD] v )) = ((vg {\u00b7 \u00b7 \u00b7 , str: v, \u00b7\u00b7\u00b7}[str] '. v [E-GETFIELD-ACCESSOR] {\u00b7 \u00b7 \n\u00b7 , str: ((vg)), \u00b7\u00b7\u00b7}[str] '. vg() [E-UPDATEFIELD] vi )) = ((vg{str1: v1 \u00b7\u00b7\u00b7 , stri: vi, \u00b7\u00b7\u00b7 strn: vn}[stri]= \nv '.{str1: v1 \u00b7\u00b7\u00b7 , stri: v, \u00b7\u00b7\u00b7 strn: vn} [E-DELETEFIELD] vi )) $frozen . (str1 \u00b7\u00b7\u00b7 strn = ((vg) delete \n{\u00b7 \u00b7 \u00b7 , stri-1: vi-1, stri: vi, stri+1: vi+1 \u00b7\u00b7\u00b7}[stri] '. {\u00b7 \u00b7\u00b7 , stri-1: vi-1, stri+1: vi+1 \u00b7\u00b7\u00b7} [E-CREATEFIELD] \nstrx . (str1 \u00b7\u00b7\u00b7 strn) $frozen . (str1 \u00b7\u00b7\u00b7 strn) {str1: v1 \u00b7\u00b7\u00b7 strn: vn}[strx]= vx '.{strx: vx, str1: \nv1 \u00b7\u00b7\u00b7 strn: vn} Figure 11. Extended semantics for .JS to allow accessors and the $frozen internal property \n[E-GETFIELD-ACCESSOR] describes that accessing a .eld str whose value is an accessor ((vg)) invokes the \ngetter func\u00adtion vg. The rules [E-UPDATEFIELD] and [E-DELETEFIELD] describe that if a .eld has an accessor \nvalue, it cannot be updated nor deleted from the enclosing object. f ::= x \u00b7\u00b7\u00b7 path .i ::= f.(x) internal \nquali.ed name .e ::= f.x external quali.ed name . ::= .i quali.ed name | .e .\u00af::= f.* expanded quali.ed \nname t ::= var desugaring type | module . ::= E desugaring scope | local | export .e . ::= . desugaring \nbinding | t. .\u00af::= . expanded desugaring binding |T S ::= {(., . .) \u00b7\u00b7\u00b7} desugaring environment .{(\u00af., \n.\u00af) \u00b7\u00b7\u00b7} S* ::= E desugaring environment chain | S* S | S* x Figure 12. Desugaring environment for the \nmodi.ed .JS Another addition to the operational semantics of .JS is the special $frozen internal property \nto denote mod\u00adule instance objects. The rules [E-CREATEFIELD] and [E-DELETEFIELD] describe that when \nan object has the $frozen internal property, it is not possible to add a new .eld nor delete an existing \n.eld from it. With accessors and the $frozen internal property, we can create read-only objects and read-only \nproxies of existing objects. Accessors and the $frozen internal property are largely inspired by the \nECMAScript 5th edition [10]: accessors are like own properties but support only getters not setters, \nand the $frozen internal property captures both [[Extensi\u00adble]] and [[Con.gurable]] internal properties. \nWe make such simpli.cations to minimize the differences between the orig\u00adinal .JS and our extended .JS \n. We would be able to elimi\u00adnate this slight modi.cations once the upgrade of .JS from the ECMAScript \n3rd edition to the ECMAScript 5th edi\u00adtion [32] .nishes.  4.2 Desugaring Environments for Modules To \nsimplify module desugaring, we statically resolve aliases due to import and export statements before \nthe desug\u00adaring process. For the static name resolution, we extend the desugaring environments described \nin Section 3.3 with mod\u00ad ule information in three ways as shown in Figure 12. First, we extend the domain \nof a desugaring environment from a set of simple names x to a set of quali.ed names . and a set of expanded \nquali.ed names .\u00af. A quali.ed name is either an internal name .i or an external name .e: an internal \nquali.ed name consists of a path f followed by .(x), and an external quali.ed name consists of a path \nf followed by .x. For example, an export statement export y:x; within a module f declares an internal \nname f.(x) and an external name f.y at the same time. An expanded quali.ed name consists of a path f \nfollowed by .*, which denotes the catch-all imports such as import M.*;.  Secondly, we extend the desugaring \ntypes and desugaring scopes to handle modules. A desugaring type is either var for a read-write binding \nor module for a binding to a module instance object. A desugaring scope describes the scope of a desugaring \nbinding: local for a function body, export .e for the external quali.ed name .e, and E for otherwise. \nFinally, we extend the range of a desugaring environment to include expanded desugaring bindings .\u00af, \nand we also extend the desugaring bindings to include .. An expanded desugaring binding denotes the names \nimported by a catch\u00adall import statement from a module M, and it is either . or T. When an expanded desugaring \nbinding is resolved to T, every external name in the module M should have been resolved. When a desugaring \nbinding or an expanded desugaring binding is ., the corresponding quali.ed name may be bound to an unknown \nvalue; a quali.ed name is bound to . when the name refers to a module that is yet to be de.ned. This \nis similar to hoisted functions, but while names in functions may be resolved at run time, names in modules \nshould be resolved at compile time. 4.2.1 Construction of Desugaring Environments As we described in \nSection 2, modules may be mutually re\u00adcursive as long as there are no cyclic module aliases. For example, \nexcept for such cyclic module aliases as the fol\u00adlowing: module M { export module B = N.A; } module N \n{ export module A = M.B; } modules may refer to each other. To resolve mutually re\u00adcursive bindings between \nmodules, we de.ne the meta\u00adfunction Env[], which constructs a desugaring environ\u00adment for an entire JavaScript \nprogram p, as the least .xed point of a single-pass environment construction metafunc\u00adtion Env m []: \n Env[p] = Envi m [p](\u00d8; E) i=0 where Env0 s (S; f)=S m Envim [ s] (S; f) = Envm [s](Envi-1 [s](S; f); \nf) m for i> 0 which is de.ned in Section 4.3. Because we use the . sym\u00adbol to denote name resolution \nfailures, we can guarantee the existence of the least .xed point if we prove that the desug\u00adaring environments \ndo not grow in.nitely. In our companion report [23], we prove that a function derived from Env m [] and \na correct program p is monotonic, and thus Env[] is in\u00addeed the least .xed point of Envm [] due to the \nTarski s .xed point theorem. module Num { function pred(n) { return n <= 0? 0 :n -1; } export module \nEven { import Odd.odd; export odd; export function even(n) { return n == 0 || odd(pred(n)); } } export \nmodule Odd { import Even.even; export even; export function odd(n) { return n != 0 &#38;&#38; even(pred(n)); \n} } } Figure 13. Mutually recursive modules  4.2.2 Example of Desugaring Environments Figure 13 shows \nan example of mutually recursive modules: module Even refers to module Odd and vice versa. For example, \nmodule Even imports odd from module Odd and exports it again. It is evident that a single scan of this \nprogram p does not produce all static information available from the code. Indeed, the .rst pass of the \ndesugaring envi\u00adronment construction builds the following environment leav\u00ading several names unknown: \nEnv1 m [p](\u00d8; E)= {((Num), module (Num)), (Num.(pred), var Num.(pred)), (Num.(Even), module Num.(Even)), \n(Num.Even, module Num.(Even)), (Num.Even.(odd), .), (Num.Even.(odd), . export Num.Even.odd), (Num.Even.odd, \n.), (Num.Even.(even), var Num.Even.(even) export Num.Even.even), (Num.Even.even, var Num.Even.even), \n(Num.(Odd), module Num.(Odd)), (Num.Odd, module Num.(Odd)), (Num.Odd.(even), .), (Num.Odd.(even), . export \nNum.Odd.even), (Num.Odd.even, .), (Num.Odd.(odd), var Num.Odd.(odd) export Num.Odd.odd), (Num.Odd.odd, \nvar Num.Odd.odd)} For example, it maps Num.Even.(odd), Num.Even.odd, Num.Odd.(even), and Num.Odd.even \nto placeholders de\u00adnoted by ., which means that their bindings are not yet resolved. Thus, we need to \nrun another pass. The second pass adds a few more entries to the desugaring environment as follows: \n Env2 p (\u00d8; E)= m Envp (Env1 m [p](\u00d8; E); E)= m Env1 m [ p] (\u00d8; E) .{(Num.Even.(odd), var Num.Odd.odd), \n(Num.Even.odd, var Num.Even.odd), (Num.Odd.(even), var Num.Even.even), (Num.Odd.even, var Num.Odd.even)} \nThe additional entries replace the prior placeholder bindings for Num.Even.(odd), Num.Even.odd, Num.Odd.(even), \nand Num.Odd.even, and they are resolved now. This is the .nal desugaring environment the third pass does \nnot add any more entries and we reached the least .xed point: Env3 m [p](\u00d8; E) = Env2 m [p](\u00d8; E) When \na program is invalid, it is possible to construct an invalid desugaring environment. For example, let \ns assume that a program p' is the same as p except that import Odd.odd; is replaced by import Odd.old; \nby mistake. We cannot .nd any binding for the name old from the module Odd for import Odd.old; and we \ncannot .nd any binding for the name odd from the module Even for export odd; either. Repeated computations \nof Envm [p ] reveals that these two names have not been resolved at all: ' Env1 ](\u00d8; E)= m [p {((Num), \nmodule (Num)), (Num.(pred), var Num.(pred)), (Num.(Even), module Num.(Even)) (Num.Even, module Num.(Even)) \n(Num.Even.(old), .) (Num.Even.(odd), . export Num.Even.odd) (Num.Even.odd, .) (Num.Even.(even), var Num.Even.(even) \nexport Num.Even.even) (Num.Even.even, var Num.Even.even) (Num.(Odd), module Num.(Odd)) (Num.Odd, module \nNum.(Odd)) (Num.Odd.(even), .) (Num.Odd.(even), . export Num.Odd.even) (Num.Odd.even, .) (Num.Odd.(odd), \nvar Num.Odd.(odd) export Num.Odd.odd) (Num.Odd.odd, var Num.Odd.odd)} ' Env2 ](\u00d8; E)= m [p ' Env1 ](\u00d8; \nE) . m [p {(Num.Odd.(even), var Num.Even.even), (Num.Odd.even, var Num.Odd.even)} '' Env3 ](\u00d8; E) = Env2 \nm [pm [p](\u00d8; E) The resulting desugaring environment Env[p'] contains unresolved mappings such as (Num.Even.(odd), \n.) and (Num.Even.odd, .) which implies that p' is not a valid pro\u00adgram according to the set of properties \ndescribed in Sec\u00adtion 5.1. Note that for a valid program p, Envm [] is a monotonic function, and Envim \n[p](\u00d8; E) for i = j. m [p](\u00d8; E) . Envj We designed Envm [] carefully so that the desugaring en\u00advironment \nis immutable and still able to distinguish valid programs from invalid programs.  4.2.3 Lookup of Desugaring \nEnvironments Before de.ning Envm [], we .rst describe the lookup meta\u00adfunction: lookup[f](S; f0) looks \nup the path f within the module path f0 in the desugaring environment S. This pro\u00adcess consists of two \nsteps. The metafunction lookup handles the .rst step by looking up the .rst module name of the path f \ninternally: lookup[M.f](S; f0)= ( \"\" \" lookup [f](S; f \" .M ) if (f0.(M), module f \" .(M ) .) . S lookup.[M.f](S; \nf0) otherwise lookup[x](S; f0)= ( t. if (f0.(x), t..) . S lookup.[x](S; f0) otherwise lookup.[f](S; \nf0)= ( lookup[f](S; f \" 0) if f0 = f0\" .M . otherwise and the metafunction lookup' handles the second \nstep by looking up the remaining module names of the path exter\u00adnally (since they should belong to an \nexternally available module instance object): lookup \" [M.f](S; f0)= ( \"\" \" lookup [f](S; f \" .M ) if \n(f0.M, module f \" .(M ) .) . S . otherwise lookup \" [x](S; f0)= ( t. if (f0.x,t ..) . S . otherwise To \nsimplify membership testing in a desugaring environ\u00adment S, we de.ne the . operator as follows: (., . \n.) . S if and only if {.}.{.' | (., .'.') . S}.{., .} . {.}.{.' | (., .'.') . S}.{.,E} The . operator \nsimply extracts non-. bindings and non-E scopes. A desugaring environment may contain multiple mappings \nfor a single quali.ed name. Because a desugar\u00ading environment is immutable, when a previously unresolved \nquali.ed name gets resolved, the desugaring environment adds another mapping from the name to a resolved \ndesug\u00adaring binding. It is an error if a single quali.ed name maps to multiple non-. bindings that are \ndifferent, and we show that valid desugaring environments do not include such er\u00adroneous mappings in \nSection 5.1.  {(f.(x), var f.(x) export f.x), (f.x, var f.x)} if f = E {(f.(x), var f.(x))} otherwise \nEnvm [var x [= e];](S; f) =Envm [module M {s \u00b7\u00b7\u00b7}](S; f) ](S; f.M)= {(f.(M), module f.(M))}. Envm [s\u00b7\u00b7\u00b7 \n{(f.(M), .), (f.(M), module .)} .Mk](S; f)= module . Envm [module M = M1 \u00b7\u00b7\u00b7 .Mk;](S; f) = if lookup[M1 \n\u00b7\u00b7\u00b7 {(f.(M), .)} otherwise {(f.(x), .), (f.(x), var .)} if lookup[M \u00b7\u00b7\u00b7 .x](S; f)= t. {(f.(x), .)} otherwise \nEnvm [import M \u00b7\u00b7\u00b7 .x;](S; f) = \" ), .), (f.(x \" ), var .)} if lookup[M \u00b7 otherwise {(f.(x {(f.(x \u00b7\u00b7 \n.x](S; f)= t. \" Envm [import M \u00b7\u00b7\u00b7 .x: x ;](S; f) = \" ), .)} {(f \" .M \" .*, .), (f \" .M \" .*, T)}. \"\"\"\"\" \n\" . \" . \" {(f.(x ),t ) | (f \" .M .x,t .) . S . t = module} if lookup[M \u00b7\u00b7\u00b7 ](S; f)= module f \" .(M \" \n) . .x. (f \" .M \" .x, .) . S=. (f \" .M \" .x, t.) . S for some t , . {(f \" .M \" .*, .)} Envm [import M \n\u00b7\u00b7\u00b7 .*;](S; f) = if lookup[M \u00b7\u00b7\u00b7 ](S; f)= module f \" .(M \" ) . \u00ac.x. (f \" .M \" .x, .) . S=. (f \" .M \" \n.x, t.) . S for some t , . otherwise {} 8 >>>>< Envm [export var x [= e];](S; f) = {(f.(x), var f.(x) \nexport f.x), (f.x, var f.x)} Envm [export function f(x \u00b7\u00b7\u00b7 ){s \u00b7\u00b7\u00b7}](S; f) = Envm [export var f;](S; \nf) Envm [export module M {s \u00b7 = {(f.(M), module f.(M)), (f.M, module f.(M))}. Envm [s }](S; f) ](S; \nf.M) \u00b7\u00b7 \u00b7\u00b7\u00b7 \"\" {(f.(M), .), (f.(M), module f.f .(M )), (f.M, .), (f.M, module f.f \" .(M \" ))} Envm [export \nmodule M=M1 \u00b7\u00b7\u00b7 .Mk;](S; f) = .Mk](S; f)= module f.f \" .(M \" ) if lookup[M1 \u00b7\u00b7\u00b7 {(f.(M), .), (f.M, .)} \notherwise Envm [export x;](S; f) 8 >>>>>>< = Envm [export x: x;](S; f) {(f.(x0), . export f.x), if (f.(x0), \nvar f \" .(x \" ) .) . S (f.x, .), (f.x, var f.x)}{(f.(x0), . export f.x), if (f.(x0), var f \" .x \" (f.x, \n.), (f.x, var f \"\" Envm [export x: x0;](S; f) .) . S = >>>>>>: )} .x otherwise {(f.(x0), . export f.x), \n(f.x, .)} {(f.x, .), (f.x, var .)} if lookup[M \u00b7\u00b7\u00b7 .x](S; f)= var . {(f.x, .)} otherwise ( =Figure 14. \nStatic Name Resolution for Modules Envm [export x: M \u00b7\u00b7\u00b7 .x0;](S; f) (8 >< >: ((8 >>>>>>>>>>>>>>< >>>>>>>>>>>>>>: \n>>>>:  1 desugar[p] = 2 let ($global = ref { Object : \u00b7\u00b7\u00b7 , Array : \u00b7\u00b7\u00b7 , \u00b7\u00b7\u00b7}) 3 let ($Object =(deref \n$global)[ Object ], $Array =(deref $global)[ Array ], \u00b7\u00b7\u00b7 ) 4 let ($scope E = $global) 5 let (this = \n$scope E) 6 desugarI [p](Env[p]; desugarR[p](E Env[p]; E)) Figure 15. Desugaring of JavaScript Modules \n  4.3 Static Resolution of Module Names Now, we de.ne the metafunction Envm [], which handles construction \nof desugaring environments and therefore static resolution of module names. Because the cases not related \nto modules are very similar to the metafunction Envf [] de\u00adscribed in Section 3.3, we describe only the \ncases related to modules in Figure 14. While we have desugaring scopes for module-local vari\u00adables (with \nthe desugaring scope E), local variables (with the desugaring scope local), and exported variables (with \nthe desugaring scope export), we do not have a speci.c desugar\u00ading scope for the global scope. Because \nany changes in the global object and a module instance object are also re.ected in their corresponding \nenvironment records, we can consider global variables as implicitly exported variables from the empty \nmodule path E. Therefore, a top-level variable decla\u00adration introduces an exported desugaring binding \nas shown in the .rst case in Figure 14. The case for module declarations is similar to the case for variable \ndeclarations, except that the desugaring type of a name is module. The desugaring binding for a module \nalias points to the original module path. Quali.ed import and aliased import statements intro\u00adduce immutable \nbindings that bind to names looked up from the desugaring environment. A catch-all import statement is \nmore complicated mainly because the expanded desugar\u00ading binding should be resolved after all the external \nnames in the module path are resolved. The .rst four cases for the export statements are similar to the \ncorresponding declarations without the export mod\u00adi.er, except that non-local modules should not be exported. \nThe remaining three export statements deserve more at\u00adtention, because they should expose the correct \ndesugar\u00ading bindings to the external names depending on the loca\u00adtions of the actual variable or module \ndeclarations. Note that export statements themselves do not declare variable and module bindings; they \nshould be de.ned elsewhere by var, function and module declarations. Therefore, exported module aliases \nand exported quali.ed aliases look up the aliased names within the module path f in the desugaring environment \nS. Similarly, exported local and exported local aliases look up the local names in the desugaring environ\u00adment \nS using the . operator.  4.4 Desugaring of Modules Finally, the desugaring process of modules is presented \nin Figure 15. Compared to the desugaring process in Figure 6, a new desugaring phase desugarI [] is introduced. \n 4.4.1 Module-Scope Instantiation and Initialization The instantiation-time desugaring phase desugarI \n[] serves dual purposes: it binds all the module-level bindings in ad\u00advance, and it initializes exported \nfunctions. The latter is anal\u00adogous to the ordinary function hoisting. However, because the instantiation \ntime and run time are clearly separated, we should make sure that functions initialized early should \nrun in the same environment with the modules at run time: desugarI [s](S; e)= // where .var .{f \" .(x \n\" ) | (f.(x), var f \" .(x \" )) . S} // fmodule .{f \" .M | (f.(x), module f \" .(M) .) . S} let ($var .var \n= ref unde.ned)\u00b7\u00b7\u00b7 let ($scope fmodule = instantiate(S; fmodule))\u00b7\u00b7\u00b7 let ($scope. fmodule = instantiate.(S; \nfmodule))\u00b7\u00b7\u00b7 earlyinitI [s](S; E); e Module instance objects are also instantiated from the desugaring \nenvironment. There are actually two objects as\u00adsociated with a module binding: the interim module instance \nobject $scope f is mutable, and it gets modi.ed whenever any exported variable changes: instantiate(S; \nf)= // where x .{x | (f.x, . .) . S} ref { $frozen : true, x : unde.ned\u00b7\u00b7\u00b7}and the actual module instance \nobject $scope. f is a read\u00adonly proxy of the interim module instance object, which we construct by setting \nevery .eld to an accessor that returns the value of the interim module instance object and disallowing \nany further creation or removal of the .elds: instantiate.(S; f)= // where x .{x | (f.x, . .) . S} ref \n{ $frozen : true, x : ((func() { return (deref $scope f)[ x ] }))\u00b7 \u00b7 \u00b7 }In fact, creating a read-only \nobject using accessors and the $frozen internal property by instantiate.() is the very description of \nthe Object.seal built-in function in the ECMAScript speci.cation (Section 15.2.3.8 of [10]). Note that \ndesugarI [] does not initialize the global object $scope E, because it includes the initial global environment \nlike Ob\u00adject, Array and Function. The initialization of $scope E oc\u00adcurs much earlier as seen in Figure \n15 (line 4).  desugarL[x](S * * S; f; e)= let ($old = deref $var f \" x \") if (f.(x), var f \" .(x \" )) \n. S 8 >>>>>>>>>>>>>>>>>>>>>>>>< $var f \" x \" = e; deref $var f \" x \" let ($old = deref x) if (f.(x), \nvar f \" .(x \" ) local) . S x = e; deref x earlyinitI [[export] function f(x desugarL[f](E S; f; 8 >>>>>>< \ndesugarR[function(x \u00b7\u00b7\u00b7 let ($old = (deref $scope f \")[ x \" ]) if (f.(x), var f \"\" .(x \"\" ) export f \n\" .x \" ) . S $scope f \" = ((deref $scope f \")[ x \" ] =e); (deref $scope f \")[ x \" ] \" let ($old = (deref \n$scope f \")[ x ]) if (f.(x), var f \" .x \" .) . S $scope f \" = ((deref $scope f \")[ x \" ] =e); (deref \n$scope f \")[ x \" ] throw (invalid assignment) if (f.(x), module ..) . S desugarL[x](S * ; f; e) otherwise \nFigure 16. L-value desugaring for a module scope >>>>>>>>>>>>>>>>>>>>>>>>: In the interim module instance \nobject, we .rst initialize both exported variable names and exported module names to unde.ned, and use \nearlyinitI [] to bind proper values later: earlyinitI [module M {s \u00b7\u00b7\u00b7}](S; f)= // where (f.(M), module \nf \" .(M) .) . S let (this = $scope. f \" M) earlyinitI [s\u00b7\u00b7\u00b7 ](S; f.M) earlyinitI [export module M=M1\u00b7\u00b7\u00b7 \n.Mk;](S; f)= // where (f.(M), module f \" .(M \" ) .) . S $scope f = ((deref $scope f)[ M ] = $scope. f \n\" M \") earlyinitI [export module M {s \u00b7\u00b7\u00b7}](S; f)= // where (f.(M), module f \" .(M) .) . S $scope f = \n((deref $scope f)[ M ] = $scope. f \" M); let (this = $scope. f \" M) earlyinitI [s\u00b7\u00b7\u00b7 ](S; f.M) The metafunction \nearlyinitI [] also initializes functions re\u00adcursively for all the exported functions and modules declared \nat module level: \u00b7\u00b7\u00b7 ){s \u00b7\u00b7\u00b7}](S; f)= ){s \u00b7\u00b7\u00b7 }]  4.4.2 Function-Scope Initialization Scope desugaring \nrules for modules are similar to the origi\u00adnal rules described in Section 3.4: desugarS [s](S* S; f; \ne)= // where xlocal .{x | (f.(x),. local) . S} let (xlocal = ref unde.ned)\u00b7\u00b7\u00b7 earlyinitS [s](S* S; f); \ne except that we do not desugar exported functions and mod\u00adules because the instantiation-time desugaring \ndesugarI []have already desugared them: earlyinitS [export function f(x \u00b7\u00b7\u00b7 ){s \u00b7\u00b7\u00b7}](S * ; f)= unde.ned \n// do nothing earlyinitS [[export] module M {s \u00b7\u00b7\u00b7}](S * ; f)= unde.ned // do nothing (no nesting) \u00b7\u00b7 \n; f)= earlyinitS [Stmt(s1 \u00b7 sk)](S * earlyinitS [s1](S * ; f) \u00b7\u00b7\u00b7 earlyinitS [sk](S * ; f) Scope desugaring \ninitializes functions using l-value and r\u00advalue desugarings as follows: }](S * ){s \u00b7 S; f)= \u00b7\u00b7\u00b7 ){s\u00b7\u00b7\u00b7 \n}] \u00b7\u00b7\u00b7 \u00b7\u00b7 (E S; f)) 8 >>>>>>< earlyinitS [function f(x desugarL[f](S * S; f; desugarR[function(x >>>>>>: \nif (f.(f),. local) . S unde.ned otherwise (S * S; f)) Note that local nested functions are already handled \nby desugarS . When an imported name is exported again, >>>>>>: if (f.(f),. local) . S unde.ned otherwise \nearlyinitI[] initializes it to a read-only accessor, making it impossible to update the imported name \neven in the interim module instance object: earlyinitI [export x: M \u00b7\u00b7\u00b7 .x0;](S; f)= // where (f.x, var \nf0.x0 .) . S $scope f = ((deref $scope f)[ x ] = Note that module-scoped functions are already handled \nby desugarI [], but bindings to local names are still constructed at this level; desugarS [] initializes \nlocal variables and local functions which are not initialized by desugarI [].  4.4.3 Rewriting L-values \n((func() { return (deref $scope f0)[ x0 ] }))) Finally, earlyinitI [] recursively applies to the substatements \nof each statement: \u00b7\u00b7 Desugaring l-values is also similar, except the new case for exported names where \nthe corresponding interim module in\u00adstance object should be updated as well as shown in Fig\u00ad earlyinitI \n[Stmt(s1 \u00b7 sk)](S; f)= earlyinitI [s1](S; f) \u00b7\u00b7\u00b7 earlyinitI [sk](S; f) ure 16. Note that desugarL[x](S* \n* S; f; e) binds a local  desugarR[[export] module M=M1 \u00b7\u00b7\u00b7 .Mk;](S * ; f)= // do nothing; // all the \nmodule bindings are resolved separately unde.ned desugarR[[export] var x;](S * ; f)= // do nothing; \nunde.ned desugarR[[export] var x = e0;](S * ; f)= desugarR[x = e0;](S * ; f) desugarR[[export] function \nf(x \u00b7\u00b7\u00b7 ){s \u00b7\u00b7\u00b7}](S * ; f)= // do nothing; unde.ned desugarR[import \u00b7\u00b7\u00b7 ;](S * ; f)= // do nothing; unde.ned \ndesugarR[export \u00b7\u00b7\u00b7 ;](S * ; f)= // do nothing; unde.ned desugarR[[export] module M {s \u00b7\u00b7\u00b7}](E S; f)= \n// Because with cannot contain modules, // the environment can have only one layer. let (this = $scope. \nfM) desugarR[s\u00b7\u00b7\u00b7 ](E S; f.M) desugarR[lval++](S * ; f)= let ($coerced = ref unde.ned) desugarL[lval](S \n* ; f; $coerced = ToNumber1(D($old)); +2(deref $coerced, 1)); deref $coerced the import and export statements, \ndesugaring import and export statements are now no-ops, too. However, be\u00adcause module declarations set \nthis to the corresponding module instance object, it should be separately desugared: this = $scope. fM. \nIn JavaScript, compound assignments such as x++ may not return the same value with x (besides a side \neffect) if the type of x is not Number. In order to capture this semantics correctly, we desugar them \nin multiple steps as shown in the eighth case in Figure 17. Before actually changing the value of x, \nwe .rst coerce the original value kept in $old by desugarL[] to a number, add 1 to the coerced value, \nand bind it to x. Because we have added various desugaring types and scopes to the desugaring environment, \ndesugaring of vari\u00adables should be updated appropriately. The updated desug\u00adaring is similar to the l-value \ndesugaring in Figure 16, but we have to make sure that the desugared expressions return (immutable) module \ninstance objects rather than (mutable) interim module instance objects for module bindings.  4.5 Experiments \nand Discussion We have implemented our module system for JavaScript on top of the existing .JS implementation \n[19]. We con.rmed that our implementation successfully passes both the exist\u00ading Mozilla JavaScript test \nsuite and our own harness tests for module features, which cover all the module-related con\u00adstructs. \nOur implementation and tests are available at: http://plrg.kaist.ac.kr/research/software We have described \ndesugaring of modules in terms of the desugaring environment, which we construct via computing S; f)= \ndesugarR[x](S * deref $var f \" x \" if (f.(x), var f \" .(x \" )) . S 8 >>>>>>>>>>>>>>< deref x if (f.(x), \nvar f \" .(x \" ) local) . S the least .xed point of Envm []. While we can compute the least .xed point \nby applying Envm [] repeatedly until there is no change, such multi-pass computations could be too ex\u00adpensive \nin practice. There are two features that might trig\u00ad (deref $scope f \")[ x \" ] if (f.(x), var f \"\" .(x \n\"\" ) export f \" .x \" ) . S ger particularly expensive computations: non-child module exports and catch-all \nexports, export *;. Non-child mod\u00ad (deref $scope f \")[ x \" ] ule exports might make the length of a \nmodule export chain \" if (f.(x), var f \" .x .) . S exceed the length of the longest module path, and \ncatch\u00ad$scope. f \" M if (f.(x), module f \" .(M) .) . S all exports will make it hard to determine the \nset of ex\u00ad >>>>>>>>>>>>>>: * ported names in a module from its local context. Because desugarR[x](S ; \nf) otherwise ECMAScript.next explicitly disallows these two features, we believe that computing the least \n.xed point of Env Figure 17. R-value desugaring for representative cases m [] would not be too expensive. \nAlso, these restrictions do not affect the correctness of our module system. name $old that does not \nseemed to be used in the desugared Our formal speci.cation of modules does not take ac\u00ad .JS expression. \nIn fact, it is actually used in the expression e as we describe in r-value desugaring. 4.4.4 Rewriting \nR-values At the level of desugaring for r-values, almost all the module-related constructs have been \nreplaced with plain as\u00adsignments or no-ops as the .rst four cases in Figure 17 show. Because the environment \nconstruction already resolved all count for the compositionality of desugaring rules. If the module desugaring \nis compositional, we may be able to ap\u00adply the results of our static checks on the desugared .JS programs \nto the original JavaScript programs. However, it is not obvious whether our desugaring rules are composi\u00adtional \nespecially because of the mutually recursive de.ni\u00adtions of desugaring metafunctions such as desugarL[] \nand desugarR[]. We are currently looking into this issue.  8 >>>< >>>: verify[s1](S; f) .\u00b7 \u00b7\u00b7. verify[sk](S; \nf) if .i. verify[si](S; f)= . and .i. .j. (i = j =. verify[si](S; f) n verify[sj ](S; f)= \u00d8) otherwise \nverify[Stmt(s1 \u00b7\u00b7\u00b7 sk)](S; f) = . verify[[export] function f(x \u00b7\u00b7\u00b7 ){s\u00b7\u00b7\u00b7}](S; f) verify[module M=M1\u00b7\u00b7\u00b7 \n.Mk;](S; f) = = {} {f.M} if lookup[M1 \u00b7\u00b7\u00b7 .Mk](S; f)= module . . otherwise if lookup[M1 \u00b7 .Mk](S; f)= \nmodule f.f \" (( .(M \" ) {f.M}. \u00b7\u00b7 verify[export module M =M1\u00b7\u00b7\u00b7 .Mk;](S; f) =verify[[export] module \nM {s}](S; f) otherwise ](S; f.M) if lookup[M \u00b7 otherwise = \u00b7\u00b7\u00b7 \u00b7\u00b7\u00b7 verify[s {} . ( \u00b7\u00b7 .x](S; f)= t. \n\" verify[import M \u00b7\u00b7\u00b7 .x[: x ];](S; f) = 8 >< >: .(M \" ) . if lookup[M \u00b7 .x. (f \" .M \" otherwise {} \u00b7\u00b7 \n](S; f)= module f \" .x, .) . S=. (f \" .M \" .x, t.) . S for some t , . verify[import]; M \u00b7\u00b7\u00b7 .*;](S; \nf) = . (( {} if (f.(x0), var f \" .(x \" ) .) . S . (f.(x0), var f \" .x \" .) . S . verify[export [x:] \nx0;](S; f) =verify[export x: M \u00b7\u00b7\u00b7 .x0;](S; f) otherwise {} if lookup[M \u00b7\u00b7\u00b7 .x0](S; f)= var . . otherwise \nFigure 18. Static rules for reference resolution = 5. Properties of the Module System While we have implemented \nand tested the formal speci.ca\u00adtion of our JavaScript module system, we should prove that the module \nsystem satis.es some desired properties to guar\u00adantee its correctness. In Section 5.1, we de.ne the primary \nconditions for valid desugaring environments such as resolu\u00adtion conditions and unambiguity conditions. \nFor a JavaScript program satisfying the conditions, we show that valid desug\u00adaring environments include \nall the bindings necessary for name resolution and module paths lookup in Section 5.2. In Section 5.3, \nwe show that evaluation of a valid desug\u00adared program does not stuck due to any absent bindings and the \nprivate names of a module are safely isolated inside the module. 5.1 Valid Desugaring Environments We \nsay that a desugaring environment S is valid for a pro\u00adgram p when the following conditions are satis.ed: \nCondition 1 (Resolution Condition 1) For every quali.ed name ., there should exist at least one non-. \ndesugaring binding .. ... (... ... (., . .) . S=. ' .t. .. ' . ... (.,t . ' . ') . S) Condition 2 (Resolution \nCondition 2) For every expanded quali.ed name .\u00af, there should exist exactly one non-. expanded desugaring \nbinding .\u00af. Note that every non-. expanded desugaring binding is the same, T. ...\u00af(...\u00af(\u00af., .\u00af) . S=. \n(\u00af., T) . S) Condition 3 (Unambiguity Condition 1) For every quali.ed name ., there should exist at most \none non-. desugaring binding .. ... ..1. ..2. (..1. (., .1.1) . S ...2. (., .2.2) . S=. .1 = .. .2 = \n.. .1 = .2) Condition 4 (Unambiguity Condition 2) For every quali.ed name ., there should exist at most \none non-empty desug\u00adaring scope .. ... ..1. ..2. (... (., . .1) . S .... (., . .2) . S=. .1 = E . .2 \n= E . .1 = .2) Condition 5 For every reference in import and export statements and module aliases, there \nshould exist a dec\u00adlaration of the reference, which also should be unique when it is a module de.nition \nor a module alias. We show the static rules that check this condition in Fig\u00adure 18. The metafunction \nverify[] looks up the desugar\u00ading environment and makes sure that every reference has a corresponding \ndeclaration and every module de.nition or module alias is unique. verify[p](S; E)= . We write valid[p] \nwhen the desugaring environment Env[p] for a program p is valid.  5.2 Properties of Valid Desugaring \nEnvironments A valid desugaring environment S satis.es the following desired properties: Property 1 (Validity \nof Name References 1) Each quali.ed name . used as a desugaring binding in S should have a binding in \nS. ' ... .. ' . (.t. ... (. ' ,t ..) . S=.... ... (., . . ') . S) Property 2 (Validity of Name References \n2) Each quali.ed name . used as a desugaring scope in S, which means it is exported, should have a binding \nin S. ... .. ' . (... (. ' ,. export .) . S=. .. ' . ... (., . ' .) . S) Property 3 (Validity of Module \nPaths 1) If an internal name x in a module path f.M has a binding in S, then there should exist a module \ndesugaring binding for an internal name f.(M) in S. .f. .M. .x. (... ... (f.M.(x),..) . S=. ' ... (f.(M), \nmodule f.(M) . ') . S) Property 4 (Validity of Module Paths 2) If an external name x in a module path \nf.M has a binding in S, then there should exist a module desugaring binding for an internal name f.(M) \nin S. .f. .M. .x. (... ... (f.M.x, ., .) . S=. ... (f.(M), module f.(M) .) . S) Property 5 (Validity \nof Module Paths 3) If an expanded quali.ed name f.M.* has a binding in S, then there should exist a module \ndesugaring binding for an internal name f.(M) in S. .f. .M. (...\u00af(f.M.*,.\u00af) . S=. ... (f.(M), module \nf.(M) .) . S) The .rst two properties (Validity of Name References) state that all the names used in \nS should have their own bindings in S, and the next three properties (Validity of Module Paths) state \nthat the module path of each quali.ed name should have a binding in S. We formally prove that the conditions \nof valid desugar\u00ading environments described in Section 5.1 imply the above properties in our companion \nreport [23]. In the report, we also prove that a function derived from Envm [] and a cor\u00adrect program \nis monotonic, so that Env[] is indeed the least .xed point due to the Tarski s .xed point theorem. These \nproperties justify our representation of module paths, which consists of internal names of module declarations: \nbecause there should always exist a corresponding module declara\u00adtion for each module path, such a module \npath is unique per module declaration.  5.3 Properties of Valid Programs For a valid JavaScript program \np, its desugared program in .JS does not include any un-desugared bindings; the desugared program does \nnot include any free variables. Property 6 (Validity of Desugaring Rules) The desugared program of a \nvalid program p should not cause any er\u00adror due to an absent (.JS) binding. Note that because the operational \nsemantics of .JS always replaces all the oc\u00adcurrences of the let construct in an expression, a valid \n.JS program should not evaluate to an identi.er. \u00ac.x. .s. E desugar[p] . * sE(x) Proof: [Proof Sketch] \nIt is obvious that the property is in fact equivalent to the statement that there exists no free variable \nin the desugared program. We .rst de.ne free variables FV (e) of the .JS expression e, and show that \nevaluations do not add free variables: s1e1 . s2e2 for any s1, e1, s2, and e2 implies FV (e2) . FV (e1). \nAlso, applying the evaluation context does not remove any free variables: FV (E(e)) . FV (e). Assume \nthat the property is false, that is, E desugar[p] .* sE(x) for some x and s. By the properties of free \nvariables, we have: FV (desugar[p]) . FV (E(x)) . FV (x)= {x}. Because we can show that FV (desugar[p])= \n\u00d8, the as\u00adsumption is false and a valid .JS program cannot evaluate to an identi.er. D In a valid program \np, the module scopes are isolated from outside. Property 7 (Isolation of Module Scopes) A module-scope \nvariable that is not exported does not affect outside its enclosing module. (M) . dom(Env[p]) . valid \nmodule M {var x = v1;} p . valid[ module M {var x = v2;} p] . .*' E desugar module M {var x = v1;} p \ns1 v1 . ' E desugar[ module M {var x = v2;} p] .* s2 v =. 2 '' v = v 12 Proof: [Proof Sketch] For presentation \nbrevity, we write p(v) for module M {var x = v;} p. By establishing the exact desugaring environments \nfor p and p(v), we can show that the desugaring environment of p(v) is a simple exten\u00adsion of the desugaring \nenvironment of p. We can also show that two environments Env[p] and Env[p(v)]\\Env[p] are disjoint. Therefore, \nwe can show that every shares a similar structure that is independent of the choice of desugar[p(v)] \nv. By showing that the r-value desugaring desugarR[p](E S; E) for some S derived from E desugar[p(v)] \ndoes not contain l$var Mx, we can .nish the proof. D Due to space limitations, we omit the full proofs \nof the above properties in this paper and refer interested readers to our companion report [23] for the \ndetailed proofs.  6. Related Work JavaScript does not support a language-level module sys\u00adtem but there \nexist several implementations of language\u00adindependent modules. Mozilla has supported JavaScript code \nmodules [29] since Gecko 1.9 where exported names are loaded to the global scope or a speci.ed object. \nSome server-side JavaScript implementations have module sys\u00adtems that are now standardized as a Modules \nspeci.\u00adcation [6] in the CommonJS API where exported names are collected in a single object. However, \nthese language\u00adindependent module systems do not provide any static reso\u00adlution and veri.cation. There \nare two proposals to add a module system to the ECMAScript standard. The abandoned ECMAScript 4th proposal \n[12] intends to bring classes, a module system, and optional static typing among other signi.cant features; \nsince it sacri.ces some backward compatibility, the proposed module system is very different from ours. \nOn the other hand, the ECMAScript.next proposal that our work is based on intends to reuse as many features \nof the ECMAScript 5th edition as possible; the proposed module system is more tuned for dynamic aspects \nof JavaScript. Our module system, which is based on ECMAScript.next, is untyped and .rst order and it \nsupports static checking of name resolution. The Racket module system [14, 15] is particularly similar \nto our module system in the way that a .ne-grained control on both imported and exported names is possible. \nHerman and Tobin-Hochstadt [21] also note the similarity in a module loader design, which allows replac\u00ading \nthe existing mechanism of creation and initialization of module instance objects by customizable module \nloaders. Because we do not formalize external modules yet, this sim\u00adilarity is not present in our module \nsystem. However, our module system with .rst-order modules and static checking of name resolution is \nmore advanced than simple module systems typically used for dynamically typed languages: the Python module \nsystem [16, Section 6.11], for example, does not support any static checks at all, and the Erlang mod\u00adule \nsystem [4, Chapter 4] does not support recursive mod\u00ad ules. Also, because JavaScript s scoping rule is \nvery different from other dynamically typed languages, our module system provides mechanisms like early \ninitialization. Regarding formal speci.cations of JavaScript, there ex\u00adist two approaches that cover \na signi.cant (if not all) por\u00adtion of the language: an operational semantics [24] that di\u00ad rectly translates \nthe ECMA-262 speci.cation, and a core cal\u00adculus, .JS [20], and its desugaring rules. Both approaches \nhave their own pros and cons. The former intends to faith\u00adfully capture the various aspects of JavaScript \nand translate the ECMA-262 speci.cation in prose into a formal seman\u00adtics, while the latter desugars \naway the quirky features of JavaScript and translates them to a standard core calculus with a conventional \nsemantics. Consequently, the former is well suited for analyzing existing JavaScript programs and applying \nthe analysis results back to the JavaScript pro\u00adgrams, though reasoning about the programs and proving \ntheir properties using the semantics are not conventional and complicated [17]. On the contrary, the \nlatter is well suited for extending and reasoning about the JavaScript language thanks to its conventional \ncalculus, though extra work is nec\u00adessary to scale the analysis results back to the full JavaScript language. \nTo formally specify a proposed module system for JavaScript, implement and test the module system with \nreal\u00adworld test suites, and rigorously prove that the system satis\u00ad.es some desired properties, we have \nfound that .JS works very well for us. We believe that our mechanism to add a module system to JavaScript \nwould be applicable to other languages such as Python and Ruby, if we add a set of reasonable restrictions \non their module systems. Because Python s modules are im\u00adplemented as object-like constructs, and Ruby \nuses modules to implement mixins by adding the members of a module to a class object, they seem to be \namenable to our mecha\u00adnism. Also, because Python programs may have various im\u00adporting problems when two \nPython modules de.ne the same name, they already need a checker to enforce the properties described in \nSection 5.2. However, because Python supports sys.modules to expose low-level details and Ruby allows \nextensions of module objects, we should restrict them ac\u00adcordingly to apply our mechanism. It is an interesting \nfuture direction for our work. 7. Conclusion We present a formal speci.cation of a module system for \nJavaScript, based on the informal, work-in-progress proposal for ECMAScript.next. We extend the original \nJavaScript language with module de.nitions, module aliases, and import and export statements, and describe \ntheir se\u00admantics by desugaring them away and translating them to a core calculus of JavaScript, .JS. \nBecause desugaring of scope manipulation serves an important role in our module desugaring, we explicitly \nspecify the scope desugaring rules, which have never been formally described prior to this pa\u00adper. In \naddition to implementing and testing our JavaScript module system with the Mozilla JavaScript test suite \nand our own harness tests for module features, we identify desired properties of valid JavaScript programs \nwith modules and formally prove that static checking of the module system guarantees the properties. \nOur module system for JavaScript will allow safe and in\u00adcremental development of JavaScript web applications, \nmak\u00ading JavaScript well suited for programming in the large. The module system will enable JavaScript \ndevelopers to use mul\u00adtiple modules seamlessly without worrying about name con\u00ad.icts. If one provides \nmodularized versions of JavaScript frameworks such as jQuery and Prototype, JavaScript de\u00advelopers will \nbe able to use multiple JavaScript frameworks safely. Also, instead of designing and developing yet another \nsafe subset of JavaScript, we may want to provide lan\u00adguage levels of JavaScript from a very small core \nsafe subset of JavaScript to the full JavaScript language, just like the language levels in DrRacket \n[31].  While we have designed a complete module system with desired properties, our module system lacks \nexternal mod\u00adules in the ECMAScript.next proposal and we intend to do future work to address it. Other \nfuture directions include de\u00adveloping a desugaring mechanism that translates JavaScript programs with \nmodules to corresponding programs in the original JavaScript language; this will allow mixing module\u00adenabled \nprograms and legacy JavaScript programs smoothly, and the existing JavaScript engines will be able to \nsupport JavaScript modules right away. We also plan to adjust our work to the upcoming .JS 2.0 [32], \nwhich intends to sup\u00ad port the new features of the ECMAScript 5th edition, so that we can get rid of \nour simple modi.cations to .JS. Acknowledgments The authors are grateful to the anonymous referees for \ncomments and suggestions. This work is supported in part by the Engineering Research Center of Excellence \nPro\u00adgram of Korea Ministry of Education, Science and Technol-ogy(MEST) / National Research Foundation \nof Korea(NRF) (Grants 2012-0000469 and 2012-0005256), Microsoft Re\u00adsearch Asia, and S-Core. References \n[1] HTML5: A vocabulary and associated APIs for HTML and XHTML. http://www.w3.org/TR/html5/. [2] JavaScript. \nhttp://en.wikipedia.org/wiki/ JavaScript. [3] Alexa the Web Information Company. http://www. alexa.com/, \n2011. [4] Ericsson AB. Erlang Reference Manual User s Guide. http://www.erlang.org/doc/reference_ manual/users_guide.html. \n[5] Gilad Bracha, Guy Steele, Bill Joy, and James Gosling. JavaTM Language Speci.cation, The 3rd Edition \n(Java Series). Addison-Wesley Professional, July 2005. [6] CommonJS contributors. Modules. http://wiki. \ncommonjs.org/wiki/Modules. [7] Douglas Crockford. ADsafe: Making JavaScript safe for ad\u00advertising. http://www.adsafe.org, \n2008. [8] Dave Herman and Sam Tobin-Hochstadt. Har\u00admony Proposals Modules. ECMAScript Wiki, http://wiki.ecmascript.org/doku.php?id= \nharmony:modules. [9] Dave Herman and Sam Tobin-Hochstadt. Module Loaders, Harmony Proposals. ECMAScript \nWiki, http://wiki.ecmascript.org/doku.php?id= harmony:module_loaders. [10] ECMA. ECMA-262: ECMAScript \nLanguage Speci.cation. 5th edition, December 2009. [11] Brendan Eich. http://brendaneich.com/2011/05/ \nmy-jsconf-us-presentation/, 2011. [12] ES4 working group. Proposed ECMAScript 4th Edition Language Overview. \nhttp://www.ecmascript.org/ es4/spec/overview.pdf, October 2007. [13] David Flanagan. JavaScript: The \nDe.nitive Guide. O Reilly, 5th edition, 2009. [14] Matthew Flatt. Composable and compilable macros:: \nyou want it when? In Proceedings of the 7th ACM SIGPLAN International Conference on Functional Programming, \n2002. [15] Matthew Flatt and PLT. The Racket Reference. http://docs.racket-lang.org/reference/ index.html. \n[16] Python Software Foundation. The Python Language Reference. http://docs.python.org/py3k/ reference/index.html. \n[17] Philippa Gardner, Sergio Maffeis, and Gareth Smith. A pro\u00adgram logic for JavaScript. In Proceedings \nof the 39th ACM Symposium on Principles of Programming Languages, 2012. [18] Danny Goodman. Dynamic HTML: \nThe De.nitive Reference. O Reilly Media, 1998. [19] Arjun Guha. .JS 1.0. https://github.com/ brownplt/LambdaJS, \n2011. [20] Arjun Guha, Claudiu Saftoiu, and Shriram Krishnamurthi. The Essence of Javascript. In Proceedings \nof the 24th Eu\u00adropean Conference on Object-Oriented Programming, 2010. [21] David Herman and Sam Tobin-Hochstadt. \nModules for JavaScript. Preprint, April 2011. [22] jQuery Team. jQuery. http://jquery.com/. [23] Seonghoon \nKang and Sukyoung Ryu. .JS with modules. Technical report, KAIST, 2011. [24] Sergio Maffeis, John C. \nMitchell, and Ankur Taly. An Op\u00aderational Semantics for JavaScript. In Proceedings of the 6th Asian Symposium \non Programming Languages and Systems, 2008. [25] Sergio Maffeis, John C. Mitchell, and Ankur Taly. Object \nCapabilities and Isolation of Untrusted Web Applications. In Proceedings of IEEE Security &#38; Privacy, \n2010. [26] Sergio Maffeis and Ankur Taly. Language-Based Isolation of Untrusted JavaScript. In Proceedings \nof the 22nd IEEE Computer Security Foundations Symposium, 2009. [27] Eric Miraglia. A JavaScript Module \nPattern. Yahoo! User In\u00adterface Blog, http://yuiblog.com/blog/2007/06/ 12/module-pattern/, June 2007. \n[28] Mozilla Developer Network. Harmony modules. https://bugzilla.mozilla.org/show_bug. cgi?id=568953. \n[29] Mozilla Developer Network. JavaScript code mod\u00adules. https://developer.mozilla.org/en/ JavaScript_modules. \n[30] Tim O Reilly. What Is Web 2.0. http://oreilly.com/ web2/archive/what-is-web-20.html. [31] PLT. DrRacket \nlanguage levels. http://docs. racket-lang.org/unstable/DrRacket_ Language_Levels.html.  [32] Joe Politz \nand Matt Carroll. .JS semantics for ecmascript 5.0 (work in progress). https://github.com/brownplt/ LambdaS5, \n2011. [33] Joe Gibbs Politz, Spiridon Aristides Eliopoulos, Arjun Guha, and Shriram Krishnamurthi. Adsafety: \nType-based veri.ca\u00adtion of javascript sandboxing. In USENIX Security, 2011. [34] Ankur Taly, Ulfar Erlingsson, \nMark S. Miller, John C. Mitchell, and Jasvir Nagra. Automated analysis of security\u00adcritical JavaScript \nAPIs. In Proceedings of IEEE Security &#38; Privacy, 2011. [35] Google Caja Team. Google-Caja: A Source-to-source \ntrans\u00adlator for securing JavaScript-based web content. http: //code.google.com/p/google-caja/. [36] The \nFacebook Team. FBJS (Facebook JavaScript). http: //developers.facebook.com/docs/fbjs/. [37] Sam Tobin-Hochstadt \nand Dave Herman. Modules for JavaScript, 2011.    \n\t\t\t", "proc_id": "2384616", "abstract": "<p>The JavaScript programming language, originally developed as a simple scripting language, is now the language of choice for web applications. All the top 100 sites on the web use JavaScript and its use outside web pages is rapidly growing. However, JavaScript is not yet ready for programming in the large: it does not support a module system. Lack of namespaces introduces module patterns, and makes it difficult to use multiple JavaScript frameworks together.</p> <p>In this paper, we propose a formal specification of a JavaScript module system. A module system for JavaScript will allow safe and incremental development of JavaScript web applications. While the next version of the JavaScript standard proposes a module system, it informally describes its design in prose. We formally specify a module system as an extension to the existing JavaScript language, and rigorously describe its semantics via desugaring to LambdaJS, a prior core calculus for JavaScript. We implement the desugaring process and show its faithfulness using real-world test suites. Finally, we define a set of properties for valid JavaScript programs using modules and formally prove that the proposed module system satisfies the validity properties.</p>", "authors": [{"name": "Seonghoon Kang", "author_profile_id": "81485649568", "affiliation": "KAIST, Daejeon, South Korea", "person_id": "P3856149", "email_address": "kang.seonghoon@mearie.org", "orcid_id": ""}, {"name": "Sukyoung Ryu", "author_profile_id": "81100170344", "affiliation": "KAIST, Daejeon, South Korea", "person_id": "P3856150", "email_address": "sryu.cs@kaist.ac.kr", "orcid_id": ""}], "doi_number": "10.1145/2384616.2384661", "year": "2012", "article_id": "2384661", "conference": "OOPSLA", "title": "Formal specification of a JavaScript module system", "url": "http://dl.acm.org/citation.cfm?id=2384661"}