{"article_publication_date": "10-19-2012", "fulltext": "\n A Variability-Aware Module System Christian K\u00e4stner Klaus Ostermann Sebastian Erdweg Philipps University \nMarburg, Germany Abstract Module systems enable a divide and conquer strategy to software development. \nTo implement compile-time variability in software product lines, modules can be composed in different \ncombinations. However, this way, variability dictates a dominant decomposition. As an alternative, we \nintroduce a variability-aware module system that supports compile-time variability inside a module and \nits interface. So, each module can be considered a product line that can be type checked in isolation. \nVariability can crosscut multiple modules. The module system breaks with the antimodular tradition of \na global variability model in product-line development and provides a path toward software ecosystems \nand product lines of product lines developed in an open fashion. We discuss the design and implementation \nof such a module system on a core calculus and provide an implementation for C as part of the TypeChef \nproject. Our implementation supports variability inside modules from #ifdef preprocessor directives and \nvariable linking at the composition level. With our implementation, we type check all con.gurations of \nall modules of the open source product line Busybox with 811 compile-time options, perform linker check \nof all con.gurations, and report found type and linker errors without resorting to a brute-force strategy. \nCategories and Subject Descriptors D.3.3 [Programming Languages]: Language Constructs and Features Modules, \npackages; D.2.2 [Software Engineering]: Reusable Soft\u00adware; D.2.2 [Software Engineering]: Design Tools \nand Techniques Modules and interfaces; D.3.4 [Programming Languages]: Processors Compilers, Preprocessors \nGeneral Terms Design, Languages Keywords variability, module system, composition, linker, C, preprocessor, \n#ifdef, conditional compilation, Busybox, software product lines Permission to make digital or hard copies \nof all or part of this work for personal or classroom use is granted without fee provided that copies \nare not made or distributed for pro.t or commercial advantage and that copies bear this notice and the \nfull citation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. OOPSLA 12, October 19 26, 2012, Tucson, Arizona, \nUSA. Copyright c &#38;#169; 2012 ACM 978-1-4503-1561-6/12/10. . . $10.00 1. Introduction A module system \nallows developers to decompose a large system into manageable subsystems, which can be developed and \nchecked in isolation [15]. A module hides information about internal implementations and exports only \na well\u00adde.ned and often machine-enforced interface. This enables an open-world development style, in \nwhich software can be composed from modular self-contained parts. The need for compile-time variability, \nfor example in soft\u00adware product lines [7, 12, 19], challenges existing module sys\u00ad tems. To tailor a \nsoftware system, stakeholders may want to select from compile-time con.guration options (or features) \nand derive a speci.c con.guration (or variant, or product) of the system. At compile-time, a user selects \nwhich con.gu\u00adration options code should be compiled into the system. In a modular scenario, we can derive \ndifferent con.gurations by composing different subsets of modules. However, to en\u00adcode variability only \nat the composition level, variability must align with the modular structure, and each compile-time con\u00ad.guration \noption must be expressed as a separate module. When variability crosscuts the dominant decomposition, \na modular implementation becomes tricky: A con.guration option, such as transaction support in a database, \nmay affect multiple modules and may even change their interfaces [35]. In fact, state-of-the-art product-line \nimplementations often use antimodular concepts: Conditional compilation, typically with #ifdef directives \nof the C preprocessor, is common and crosscuts entire implementations [39]. Intended variability of the \nproduct line is commonly described in a single global vari\u00adability model in a closed-world fashion. As \nlong as product\u00adlines are developed entirely by a small team inside a single company, this closed-world \nview may suf.ce. But, for larger product lines developed by multiple teams, for product lines that should \nbe reused in other contexts, and for product lines that span organizational units, a modular solution \nis needed. An additional challenge comes from the combinatorial explosion of con.guration options. There \nare O(2n) compile\u00adtime con.gurations of a product line with n Boolean con\u00ad.guration options. Checking \nall con.gurations, one by one, in a brute-force fashion is infeasible in practice due to the sheer number \nof con.gurations. Likewise, checking only spe\u00adci.c con.gurations at module-composition-time de.es the \npurpose of modularity, since con.icts are detected only late.  To enable modular product-line development, \nwe intro\u00adduce a variability-aware module system that supports both inner variability inside a module \nand crosscutting variability that affects multiple modules. In the module system, each module can be \nconsidered as a product line in itself. Module composition becomes the composition of entire product \nlines including their variability. We formalize our variability-aware module system as a calculus. The \ndistinguishing feature of this module calculus is that interfaces and implementations are variable depend\u00ading \non the selection of con.guration options. Furthermore, each module de.nes its own local variability model \n the constraints on its environment. The formalization is based on Cardelli s seminal formalization of \nseparate type checking and linking [15] and a more recent generalization of this work towards propositions \nin interfaces [36]. We show that the cal\u00ad culus is sound in two ways: (1) well-typedness of a module \nimplies well-typedness of all con.gurations of the module, and (2) module composition preserves well-typedness. \nWe implement a variant of our variability-aware module system for the C programming language with #ifdef \nvari\u00adability and build-system variability. Taking every translation unit (.c .le) as a module with inner \nvariability (from #ifdef directives), we ef.ciently and modularly check all con.gu\u00adrations of a module \nand infer an interface with variability. Subsequently, we perform composition checks for all con.gu\u00adrations, \nequivalent to linker checks in C. We encode expensive compatibility checks and type checks as Boolean \nsatis.ability problems, building on prior work on variability-aware analy\u00adsis [3, 17, 20, 33, 55, 56]. \nWe provide a full open-source im\u00ad plementation as part of our TypeChef project and type check the entire \nBusybox product line with 811 compile-time con\u00ad.guration options (and, thus, more potential con.gurations \nthan the estimated number of atoms in the universe [37]) to demonstrate practicality. Modularity allows \nus to type check each of Busybox s 522 .les in parallel. We show that Type-Chef is able to .nd actual \ntype errors in Busybox. In summary, our central contributions are the following: (1) We motivate the \nneed for inner and crosscutting variabil\u00adity. (2) We design a novel module system for product lines and \ndiscuss design decisions. (3) We formalize the module system as a formal calculus and prove its soundness. \n(4) To demonstrate practicality, we present a practical implementa\u00adtion strategy, we implement the module \nsystem for C and the C preprocessor, and we .nd type errors with this implemen\u00adtation in a medium-size \nreal-world product line. To the best of our knowledge, this is the .rst implementation of modular type-checking \nfor practical product-line implementions in C with #ifdef variability. 2. Modules and variability Modularity \nas enforced by most module systems serves a simple means: It allows splitting a system into smaller sub\u00adsystems \n(modules), each of which are divided into an internal implementation and an external interface. The module \ns inter\u00adface describes a contract with the rest of the system in terms of imports and exports. Ideally, \na developer (or compiler) can understand (or type-check and compile) a module separately, by looking \nonly at its internal implementation and interface, but not at implementations of other modules. Internals \nof the module can be changed without affecting (and even know\u00ading) any other module. This separation \ninto modules with interfaces enables modular reasoning and reuse of modules in unplanned contexts. For \nuniformity, we adopt Cardelli s notion that modules have explicit imports and are closed un\u00adder composition \n[15]. That is, two modules can be composed (or linked) to form a larger module, in which imports that \nare exported by the other module are removed. When com\u00adposing two compatible modules, module composition \nshould preserve well-typedness. In practical software development, frequently a demand for variation \narises. Different con.gurations of a system should be compiled for different platforms, customers, and \nuse cases. Especially in software product lines, such variation is planned and used as strategic advantage. \nInstead of develop\u00ading a software system only for a single customer, product lines cover related systems \nin a whole domain. Such a product-line approach promises lower costs, better quality, shorter time to \nmarket, and .exibility to react to market changes, due to strategic reuse [7, 12, 19]. For illustration \nand demonstration, we use two examples of product lines. First, we introduce a tailorable embedded database \nmanagement system that can be con.gured with two different storage mechanisms per\u00adsistent and in-memory, \n an optional XML layer, and other options. Second, we analyze Busybox, a real-world resource\u00adef.cient \nproduct line of UNIX utilities. In both scenarios, resource constraints of embedded systems demand compile\u00adtime \nreduction and specialization to the necessary core; hence, for different scenarios, different tailor-made \nsolutions should be provided. In the following, we outline how to implement variability with conventional \nmodule systems, we discuss their limita\u00adtions, we outline our concept of a variability-aware module system, \nand we survey how variability is implemented in the real-world product line Busybox. 2.1 Variable module \ncomposition To implement product lines modularly, developers usually develop a module for each con.guration \noption and express variability by composing different sets of modules (which we also call intermodule \nvariability). This style of programming, in which modules align with con.guration options, is also known \nas feature-oriented programming [8, 47] and popular in the form of plug-in systems [2, 7]. In our database \nexample, we could decompose a sys\u00adtem into four modules as illustrated in Figure 1: a core database module \ncore, an in-memory-storage module inmem, a persistent-storage module persist, and an XML module xml. \nNow, we derive different systems by composing ( )  core =( xml =( import write: Key.Table.Bool; import \nupdate: String.Bool; import read: Key.Table; fun parse(s: String): XML = ...; fun log(msg: String): Unit \n= ...; fun unparse(x: XML): String = ...; export fun select(q: String): Table = ... read(...) ...; export \nfun storeXML(x: XML): Bool = ... update(...) ...; export fun update(q: String): Bool = ... write(...) \n...; ) export fun main(p: String): Int = ...; ) inmem =( persist =( export fun write(k: Key, t: Table): \nBool = ...; fun fopen(f: Int): Handle = ...; export fun read(k: Key): Table = ...; export fun write(k: \nKey, t: Table): Bool = ...; ) export fun read(k: Key): Table = ...; ) Figure 1. Simple database example \nwithout inner variability. modules in different combinations: core inmem yields an in-memory database, \ncore persist a persistent database, core inmem xml an in-memory XML database, and so forth. Composing \ntwo modules merges their de.nitions. Imports of one module are matched by exports of the other module \nas far as possible; nonexported (private) functions are renamed or inlined if necessary. Two modules \nexporting the same function, such as inmem and persist in our example, are incompatible and cannot be \ncomposed. If desired, we can automate the generation of tailored sys\u00adtems for a given selection of con.guration \noptions with a build system. Build systems range from simple shell scripts to sophisticated compilation \nmanagers [11, 13, 48]. Build sys\u00ad tems typically introduce explicit con.guration options (and possibly \ndependencies between them in a variability model). The con.guration options are then mapped to modules \n[19]. For a given selection of con.guration options, the build sys\u00adtem compiles and composes the corresponding \nmodules. In such a setting, variability is expressed globally for a .xed set of modules at composition \nlevel: The modules themselves have no notion of variability, especially no variability in in\u00adterfaces. \n 2.2 A case against variability-induced decomposition When variability is expressed only at the composition \nlevel, modules align with con.guration options. On one hand, this alignment enforces separation of concerns \nregarding con.guration options; but, on the other hand, then, variability dictates a dominant decomposition \n[53] of the system, which might not be the desired one. There are at least three problems of a variability-induced \ndecomposition: Variability is known as a crosscutting concern [29, 39, 41, 47, 54]. In our database example, \ncon.guration options such as READONLY affect many modules and concerns. Even with advanced and controversial \nmodule constructs, such as aspects, it is not clear whether the implementation of crosscutting con.guration \noptions can be speci.ed modularly in a single module [35]. Con.guration options are not independent. \nIn our example, con.guration option READONLY would affect both in\u00admemory and persistent storage. A typical \nsolution of the module-per-con.guration-option approach is creating more modules (e.g., inmem-common, \ninmem-write, and inmem-readonly) [41], leading to an explosion of micro\u00ad modules [32].  Con.guration \noptions (and interactions between con.gu\u00adration options) that affect only few lines of code must be extracted \ninto their own function and module, even if they are just a minor concern in a larger context. Such small \nadditional modules reduce the bene.t of an open-world module system, because they are typically hard \nto reuse and tightly coupled to the rest of the system [32].  We argue that variability should not necessarily \ndictate the dominant decomposition. Although tool support could potentially address the problem of many \nsmall modules, we explore a language-based solution. In the remainder of the paper, we introduce a variability-aware \nmodule system that enforces modular checks in the presence of inner and crosscutting variability.  2.3 \nVariability inside modules Instead of encoding variability using module composition, we propose to encode \nvariability inside modules (which we also call intramodule variability), such that con.guration options \nand modules do not need to align. Each module can be inter\u00adpreted as a product line that can be con.gured. \nFor example, we implement a module storage for the storage subsystem that can be con.gured to use in-memory \nor persistent storage and to provide read-only or read-and-write access. However, with variability in \ninterfaces, the composition process and the role of the variability model (previously part of the build \nsystem) changes. We introduce variability with presence conditions.A presence condition on a code element \nis a formula over con.guration options that speci.es in which con.gurations the element should be included. \nFor example, we say module storage de.nes function fopen only if con.guration option  storage =( query \n=( config PERSIST \"persistent storage\" default; import config READONLY; config INMEM \"in-memory storage\" \nimport write: Rec . Tid if \u00acREADONLY, config READONLY \"read-only access only (faster, smaller)\"; read: \nTid . Rec; variability (PERSIST .INMEM) .\u00ac(PERSIST .INMEM); config TXN, INDEX; fun fopen(f: Int): Handle \nif PERSIST = ...; export fun write(x: Rec): Tid if \u00acREADONLY .PERSIST = ...; fun createIndex(t: T): \nI if INDEX = ...; export fun write(x: Rec): Tid if \u00acREADONLY .INMEM = ...; fun log(m: String): Bool = \n...; export fun read(x: Tid): Rec if PERSIST = ... fopen ...; export fun select(q: String): Tab = ...; \nexport fun read(x: Tid): Rec if INMEM = ...; export fun update(q: String): Bool if \u00acREADONLY = ...; ) \nexport fun main(p: String): Int = ...; ) xml =( import config READONLY, TXN, INDEX; import select: String \n. Table, update: String . Table if \u00acREADONLY, read: Tid . Rec; config XQUERY; variability XQUERY . INDEX; \n fun parse(e: String): Xml = ...; fun toXML(x: Xml): String = ...; export fun storeXML(x: Xml): Tid if \n\u00acREADONLY = ...; export fun query(q: String): Xml if XQUERY = ...; ) ) Figure 2. Extended database \nexample with inner variability. PERSIST is selected (fopen if PERSIST). In the simplest case, presence \nconditions can be implemented by conditional compilation with #ifdef directives; we discuss alternatives \nin Section 4.3. To reason about con.guration options inside a module, we declare them explicitly or import \nthem like functions. Hence, for every con.guration option there is a unique module that declares the \ncon.guration option (and possibly related con\u00ad.guration information, such as description, defaults, costs, \nand interested stakeholders). Hence, there is a well-de.ned distinction between con.guration option de.nition \nand con\u00ad.guration option usage, which yields a well-de.ned scoping concept for con.guration options and \nenables standard tech\u00adniques such as a-renaming of con.guration options. Declared con.guration options \nare always part of the interface (they cannot be hidden, because users must be able to con.gure the module). \nFinally, each module can have a local variability model that constraints possible combinations of con.gura\u00adtion \noptions; for this purpose, we specify a formula, but other notations, including graphical feature diagrams, \nare possi\u00adble [9, 11, 19, 57]. Composing two modules in our variability-aware module system is similar \nto composing two modules in a traditional module system. Composing two modules with variability (i.e., \ntwo product lines) yields another module that combines the variability of both (i.e., another product \nline). Imports are matched by exports as far as possible, and con.guration options and functions are \nmerged. Local variability models are combined, requiring now the constraints of both models. We will \nexplore additional constraints on the variability model in case of function con.icts later. In Figure \n2, we illustrate module-system concepts with an extended database example. The system is divided into \nthree modules storage, query, and xml, not aligned with variability. Each of these modules has inner \nvariability. Furthermore, we exemplify the result of the composition storage xml.  2.4 Crosscutting \nand inner-module variability in Busybox Before we get to a formal description, we want to emphasize once \nmore the need for a proper variability-aware module sys\u00adtem with a look into practice. We report data \nfrom the open\u00adsource product line Busybox. Like in many product-lines, the Busybox developers did not \npursue a strictly modular approach and used the C preprocessor to encode variability inside and across \nmodules. We selected Busybox (release 0.18.5, available at http: //busybox.net/) as a paradigmatic case, \nrepresenting many other product-line implementations based on conditional com\u00adpilation [39]. Busybox \nhas 522 .c .les and 260 000 lines of unpreprocessed C code. BusyBox combines custom imple\u00admentations \nof many common UNIX utilities into a single small executable for small or embedded devices. Targeted \nat resource-constraint environments, BusyBox is highly cus\u00adtomizable with 811 explicitly declared Boolean \ncompile-time con.guration options, allowing users to select which utilities to include and with which \nfacilities. As common in C, we regard every translation unit (.c .le with inlined header .les) as a module. \nA C compiler translates each module independently and a linker composes modules. Variability in Busybox \nuses both intermodule variability at the composition level, automated by the build system, and intramodule \nvariability at source-code level, encoded with #ifdef directives inside modules.  We illustrate variability \nin Busybox from different per\u00adspectives: Variable module composition. There is a high amount of intermodule \nvariability at composition level. Of 522 mod\u00adules, 413 modules (79 %) are composed only under some condition. \nOf 811 con.guration options, 386 (48 %) in.u\u00adence variable module composition, ov which 270 con.g\u00aduration \noptions (33 %) exclusively control composition, but not intramodule variability. Variability at composition \nlevel mostly re.ects the selection of compression libraries and entire tools to be linked into the Busybox \nexecutable, such as grep, .nd, and chmod.  Variability inside modules. Of 811 con.guration options, \n499 (62 %) control intramodule variability at source-code level with #ifdef directives. All 522 translation \nunits contain intramodule variability at source-code level. Many translation units provide con.guration \noptions that are local to that module and occur in no other module. For example, .nd.c has 22 local inner \ncon.guration options, hush.c has 13, and httpd.c has 11. There are 69 translation units with at least \ntwo local inner con.guration options. Between con.guration options inside a translation unit, there are \noften dependencies in the variability model, such as HUSH_JOB . HUSH_INTERACTIVE. Hence, Busybox shows \npotential for local declarations of con.guration options and local variability models.  Crosscutting \nvariability. In addition to 391 (48 %) con.g\u00aduration options local to a single translation unit (usually \ncon.guration options of individual tools, such as MOD-PROBE_BLACKLIST), there are 109 (13%) con.guration \noptions that crosscut multiple translation units. Crosscut\u00adting is mostly moderate with 46 con.guration \noptions affecting between two and ten translation units, and 15 between 11 and 50 translation units. \nHowever, 47 con.gu\u00adration options affect over 500 (essentially all) translation units. Con.guration options \ncrosscut when several trans\u00adlation units together implement the same concepts, such as UNICODE_SUPPORT \nand SHADOWPASSWDS. Heavy crosscutting comes mostly from variability in header .les that are included \nin most translation units, independent of whether the functionality is used. Our analysis con.rms that \ncrosscutting con.guration options are common, and we argue that they should be supported natively by \nthe implementation approach.  Variability in module interfaces. Source-level intramodule variability \ndoes not only affect module implementations, but also their interfaces. We regard imported and exported \n functions of a translation unit in C as its interface (for details, see Section 5.2). So, conditional \ncompilation that controls only statements, expressions, or unused declara\u00adtions does not cause variability \nin module interfaces. Overall, 11 % of all exports and 7 % of all imports are vari\u00adable. Of all 811 con.guration \noptions, 303 (37 %) affect imports or exports in at least one translation unit. While again variability \nis mostly local to the interface of a single translation unit, 45 con.guration options affect interfaces \nin up to ten translation units (e.g., HUMAN_READABLE, SHADOWPASSWDS), and 11 con.guration options affect \nmore than ten interfaces, with the maximum of 41 in\u00adterfaces affected by IOCTL_HEX2STR_ERROR (a con.g\u00aduration \noption adjusting how errors are reported). Our analysis indicates that a large amount of source-level \nvari\u00adability is hidden inside modules and does not in.uence interfaces, but also that handling variability \nin interfaces is crucial nonetheless. In summary, Busybox illustrates that both intermodule variability \nat composition level and intramodule variability at source-code level are used. There is potential for \nlocal de.nitions of con.guration options and for hiding variability implementations inside a module. \nMany translation units can be considered as small product lines. At the same time, crosscutting is also \ncommon. Based on our experience with other open-source systems with compile-time variability implemented \nin C [39], we judge Busybox as a paradigmatic case. Traditional module systems cannot handle implementa\u00adtions \nwith intramodule variability at source-code level. En\u00adforcing decomposition by variability would require \nmany additional modules and rewrites, which we regard as imprac\u00adtical for Busybox. On the other hand, \nin the current form with inner-module variability, a C compiler only determines im\u00adported and exported \nsymbols after running the preprocessor to remove all variability from the code. Modules are composed \nonly after selecting con.guration options. There is no means to check module compatibility for all con.gurations, \nother than applying a brute-force strategy. We conclude that our motivation for variability-aware modules \nis also supported by current software practice. 3. Formalization In our module system, a module has a \nwell-de.ned interface that describes the names and types of imported and exported functions. A type system \nchecks each module in isolation against its interface and a composition engine ensures that composed \nmodules have type-compatible interfaces without name clashes. The formalization can be seen as the speci.ca\u00adtion \nof the desired behavior, quite distinct from our implemen\u00adtation. We use the formalization to prove that \nour module sys\u00adtem is sound. Although the formal de.nitions are simple, the soundness properties are \nnot obvious; in fact, it took several iterations of proving and .xing to get the de.nitions right.  \nNotation: Auxiliary functions: x . X function names sig :(X . E \u00d7 T) . (X . T) e . E expressions sig(.)(x)= \nt where .(x)=(e, t) t . T types .x . dom(G1) n dom(G2). G1(x)= G2(x) G . X . T contexts / function imports \ntypecompatible(G1, G2) . . X . E \u00d7 T function de.nitions m =(G, .) . M module Module typing: dom(G) \nn dom(.)= \u00d8 G f . .x . dom(.). G . sig(.) f e : t where .(x)=(e, t) (G, .) OK G f . Module compatibility \nand composition: dom(.1) n dom(.2) = \u00d8 typecompatible(G1, G2) typecompatible(G1, sig(.2)) typecompatible(sig(.1), \nG2) (G1, .1) \u00f7(G2, .2) G ' = G1 . G2 \\ (sig(.1) . sig(.2)) .' = .1 . .2 (G1, .1) (G2, .2) = (G ', .') \n Figure 3. Module system M without variability. 3.1 A base module system M without variability To illustrate \nthe basic concepts, let us start with a small calculus of a module system without intramodule variability \nin Figure 3. The calculus follows the spirit of Cardelli s module system formalization [15]. A module \nconsists of a set of imported function declara\u00adtions with their associated type, and a list of typed \nfunction de.nitions with a body. Imports are modeled as partial .nite maps (we overload the function \narrow . to denote partial maps) from names to types, de.nitions are maps from names to types and expressions. \nThe interface of a module consists of all imported declarations and the signatures of all locally de.ned \nfunctions. We could easily model a distinction be\u00adtween private de.nitions and exported de.nitions, but \nexcept for the need of renaming during composition, this adds little to our discussion; we instead assume \nthat private functions have been inlined. Translating the example from Figure 1 into this calculus is \nstraightforward. We leave the exact form of expressions and types open; we just assume that there is \na type system for the expression language that can perform a type-check of the form G f e : t. The only \nrequirement on the typing relation is that it must be monotonic (if G ' is an ex\u00adtension of G and G f \ne : t, then G ' f e : t), otherwise module composition would not preserve well-typedness. Almost all \ntype systems used in practical programming languages have this property.1 We type check each module in \nisolation. A module is well-typed (m OK) if all function bodies are well-typed in the context of imported \nand de.ned functions and if a function is not both imported and de.ned. Two modules are compatible (m1 \n\u00f7 m2) unless they con\u00adtain a function con.ict. There are three kinds of possible function con.icts: (1) \nboth modules export a function with the same name, (2) both modules import a function with the same name \nbut with different types, and (3) one mod\u00adule imports a function de.ned in the other with a different \ntype. Composing two modules essentially merges imports and exports, and imports provided by the other \nmodule are removed. To compose two modules with a function con.ict, .rst the con.ict must be resolved; \nfor example, developers can rename the function in one module to make both modules compatible (see also \nthe rename operator of the composition language in Section 3.4). Module system M has the following desirable \nproperties: (P1) The module system is closed under composition, that is, composing two modules yields \na new module ( : M \u00d7 M . M). (P2) We can type check each module in isolation (against its own interface), \nindependent of other modules (m OK). (P3) To determine whether two modules are compatible (m1 \u00f7 m2), \nwe only need to investigate their interfaces, not their internal implementations. (P4) When composing \ntwo well-typed compatible modules, and the typing relation is monotonic, then the composed module is \nwell-typed as well (m1 OK . m2 OK . m1 \u00f7 m2 . m1 m2 OK). 1 Often called weakening; substructural type \nsystems [59] that violate this property (such as linear types) are uncommon in practice. (P5) Composition \nis associative and commutative.  Additional notation: Auxiliary functions: f . F con.guration options \nSig : (C . X . E \u00d7 T) . (C . X . T) c . C = 2F con.gurations Sig(.)(c)(x) = t where .(c)(x) = (e, t) \nv . V = 2C G . C . X . T . . C . X . E \u00d7 T variability models variable contexts variable de.nitions Module \ntyping: v . dom(G) v . dom(.) .c . v. (G(c), .(c)) OK v = \u00d8 m =(v, G, .) . Mv module (v, G , .) OK \n con.ictpresence(G1, G2)= c . dom(G1) n dom(G2) | dom(G1(c)) n dom(G2(c))= \u00d8 con.icttype(G1, G2)= c \n. dom(G1) n dom(G2) | .x . dom(G1(c)) n dom(G2(c)). G1(c)(x)= G2(c)(x) con.ictpresence(Sig(.1), Sig(.2)), \ncon.icttype(G1, G2),con.ict(G1, .1, G2, .2)= con.icttype(G1, Sig(.2)), con.icttype(Sig(.1), G2) Module \ncompatibility and composition: ' v = v1 n v2 \\ con.ict(G1, .1, G2, .2) ' v = con.ict(Gx, .x, Gy, .y) \nG ' (c)= G1(c) . G2(c) \\ (sig(.1(c)) . sig(.2(c))) x =y ' v = v1 n ... n vn v\\v = \u00d8 . ' (c)= .1(c) . \n.2(c) '' \u00f7(v1, G1, .1),..., (vn, Gn, .n)(v1, G1, .1) (v2, G2, .2)=(v , G , . ' ) Figure 4. Module \nsystem Mv with inner-module variability. (P6) Module compatibility is closed under module com\u00adposition \n(m1 \u00f7 m2 . m1 \u00f7 m3 . m2 \u00f7 m3 . m1 \u00f7 (m2 m3)), as proved in the appendix. We want to preserve these properties \nwhen we move to a variability-aware module system.  3.2 A variability-aware module system Mv Now, let \nus introduce variability into the module system M. For clarity, we proceed in two steps: First, we add \nvariability with a global name space for con.guration options in Mv, as speci.ed in Figure 4. Subsequently, \nin the next subsection, we add a scoping concept for con.guration options in Mvl. The calculus models \nsemantics and is hence rather abstract: We leave open how sets of con.guration options are represented \n(usually with propositional formulas) and just represent them semantically as sets of (or mappings from) \ncon.gurations. It also leaves open the question of an ef.cient implementation, since the formal de.nitions \nquantify over (possibly in.nite) sets of con.gurations. We will outline an ef.cient implementation strategy \nlater in Section 5.1. From the (countably in.nite) set of names of con.guration options F, we can derive \nall possible con.gurations (c . 2F). Of those, a variability model describes the subset of intended valid \ncon.gurations (v . 2F). A module is a 3-tuple (v, G, .) that consists of a variability model v, imported \nfunction signatures G, and de.ned functions .. When considering variability, a function may be imported \nonly in a subset of all con.gurations or may even be imported with different types in different con.gurations. \nHence, we model imports as a partial map from con.gurations and function names to types (G . C . X . \nT). This model ensures the invariant that, in each con.guration, each name is mapped to at most one type. \nSimilarly, we model function de.nitions as map from con.gurations and function names to expressions with \ncorresponding type declarations. Despite variability, type checking (m OK) is still modu\u00adlar. Reusing \nthe formalism of the module system M without variability, we check that function de.nitions are well-typed \nand do not overlap with imports in all valid con.gurations described by the variability model v. Furthermore, \nwe assert that for each valid con.guration the partial map of imports and de.nitions is well-de.ned (v \n. dom(G)). Finally, we ex\u00adpect that the variability model describes at least a single valid con.guration \n(v = \u00d8, a property called model consistency in [19, 42]) otherwise module compatibility would be trivial.2 \nBased on well-typed modules, we de.ne module compati\u00adbility and module composition. There are actually \ndifferent designs of compatibility and composition possible. Here, we .rst introduce a notion with some \nresemblance to type in\u00adference: We infer a variability model that describes valid con.gurations and only \nreport an error when no valid con.g\u00aduration remains. In Section 4.1, we discuss alternative designs and \ntheir bene.ts and drawbacks. Modules are incompatible if their variability models do not share a single \ncon.guration (v1 n ... n vn = \u00d8). In addition, modules are incompatible if all shared con.gurations contain \na function con.ict (as in M, two modules de.ne the same function, two modules import the same function \nbut with different types, or one module de.nes a function imported by 2 Requiring a single valid con.guration \nis merely a consistency check. Asserting that a module provides speci.c con.gurations can be checked \nat composition-language level, see Section 3.4.  Additional notation: Module typing: i . F con.guration-option \nimports v . dom(G) v . dom(.) j . F con.guration-option de.nition .c . v. (G(c), .(c)) OK v = \u00d8 m =(v, \ni, j, G, .) . Mvl module i n j = \u00d8 varmodel(v) . i . j varmap(v, G) . varmap(v, .) . i . j (v, i, j, \nG, .) OK varmodel(v)= f . F | .c . v. (c \\{f}) ./v . (c . {f}) ./v varmap(v, .)= f . F | f/. varmodel(v) \n. .c . v. .(c \\{f})= .(c . {f}) Module compatibility and composition: ' ''' ' m =(v , i , j , G , . ' \n) ' mx =(vx, ix, jx, Gx, .x) v = v1 n v2 \\ con.ict(G1, .1, G2, .2) ' v = con.ict(Gx, .x, Gy, .y) G \n' (c)= G1(c) . G2(c) \\ (sig(.1(c)) . sig(.2(c))) x=y v = v1 n ... n vn . ' (c)= .1(c) . .2(c) ' '' v\\v \n= \u00d8.x = y. jx n jy = \u00d8 i = i1 . i2 \\ (j1 . j2) j = j1 . j2 ' \u00f7 m1, . . . , mn (v1, i1, j1, G1, .1) \n(v2, i2, j2, G2, .2)= m Figure 5. Module system Mvl extends Mv with scoped con.guration options. another \nmodule but with different types). Auxiliary function con.ict returns the set of con.gurations containing \na function con.ict. In this design, we allow con.icts in some con.gura\u00adtions, as long as not all con.gurations \nare affected. Further\u00admore, pairwise checking of compatibility is not suf.cient to guarantee preservation \nof compatibility under composition (P6), because incompatibilities, say, due to a mutual exclusion property \nasserted by one module, only show up when consid\u00adering the compatibility of all modules to be composed \n(see discussion in Section 4.1). Hence, we model compatibility as a predicate on a set of modules (\u00f7 \nm1, . . . , mn ). Composing two compatible modules yields a new mod\u00adule. The new module contains the \ncommon con.gurations of both modules, excluding con.gurations that contain function ' con.icts (v = v1 \nn v2 \\ con.ict(G1, .1, G2, .2); we essen\u00adtially add additional constraints to the variability model for \nfunction con.icts). Imports are merged but reduced by the corresponding function de.nitions for each \nvalid con.gura\u00adtion separately. The exclusion of con.icting con.gurations from the new variability model \nv ' ensures that the partial map\u00adpings of imports and function de.nitions are well-de.ned on ' the full \nvariability model v . Our module system Mv with variability preserves prop\u00aderties (P1) (P5) of the module \nsystem M. Since pairwise compatibility is not suf.cient to preserve compatibility, as argued above, we \nrelax (P6) to (P6 ): (P6 ) Module compatibility is closed under module composi\u00adtion (\u00f7 m1, m2, . . . \n, mn .\u00f7 m1 m2, . . . , mn ). Note that (P6 ) is compatible with an open-world assumption because a composed \nmodule can still be composed with arbitrary other modules (provided that they are compatible with the \ncomposed module). In addition, Mv satis.es a new property con.guration preserves typing: (P7) All module \ncon.gurations derivable from a well\u00adtyped module are well-typed, that is, .(v, G, .) . Mv . (v, G , .) \nOK ..c . v. (G(c), .(c)) OK. Properties (P1) (P3) and (P7) follow directly from the de.ni\u00adtion of Mv. \nProofs of the remaining properties can be found in the appendix.  3.3 Locality of con.guration options \nin Mvl So far, our module system has global con.guration options. In a .nal step, we introduce a scoping \nconcept that allows declaring and explicitly importing con.guration options, as illustrated in our motivating \nexample in Figure 2. We model con.guration options in direct analogy to func\u00adtions: A con.guration option \nis de.ned in a module. Equiv\u00adalent to a function body, a con.guration option can provide additional speci.cations, \nsuch as descriptions and defaults. Other modules can import a con.guration option to use it, and referencing \na con.guration option as part of a presence condition is the equivalent of a function call. In line with \nfunc\u00adtions, we check, in each module separately, that only de.ned or imported con.guration options are \nreferenced. Similar to name clashes between functions, name clashes between con.guration options can \nbe resolved with a-renaming (see Section 3.4). As function names in our basic module system, con.guration \noptions share a global namespace; however, declarations and imports provide a means to enforce scoping \nof names, so modules that declare the same name are in\u00adcompatible. As with functions, it does not technically \nmatter which of two modules de.nes and which imports a con.gura\u00adtion option; selecting where to place \nthe de.nition is a design choice. For example, similar to bundling function de.nitions in separate modules \nas libraries, designers may decide to bun\u00addle multiple con.guration options in one separate module. \n We extend our module system to M vl as speci.ed in Figure 5. A module now additionally contains imports \nof names of con.guration options (i . F) and de.nitions of con.guration options (j . F). Since additional \ndescription or defaults of con.guration options are relevant only for external concerns, we omit them \nfrom our formalization. Locally, we check that a con.guration option is not both imported and declared \n(i n j = \u00d8). Furthermore, variability in the variabil\u00adity model, in function imports, and in function \ndeclarations must be expressed only in terms of declared or imported con.guration options. Auxiliary \nfunction varmodel yields all con.guration options that affect the variability model and varmap yields \ncon.guration options that make a difference in the de.nition of a variable mapping (a con.guration option \nf makes a difference if and only if two otherwise equal con\u00ad.gurations with and without f are distinguished \nby a model or mapping). This way, we enforce well-de.ned scoping of con.guration options. In a practical \nimplementation, in which sets of con.guration options are represented by propositional formulas, these \nchecks can be conservatively approximated by considering the set of con.guration options that occur syntactically \nin presence conditions in the module. Compatibility and composition require only minimal, straightforward \nextensions: Two modules are incompatible if they declare the same con.guration option. During compo\u00adsition, \ndeclarations and imports of con.guration options are matched and merged like functions. Mvl also preserves \nprop\u00aderties (P1) (P5), (P6 ), and (P7), as proved in the appendix.  3.4 Composition language So far, \nwe have discussed the module-composition operator ( : M \u00d7 M . M) and module compatibility. There are \nadditional useful operators at the level of the composition language, such as renaming, hiding, partial \ncon.guration, and variability checking. Here, we outline useful operators to give a more complete picture \nof typical and .exible module composition. We have the following syntax of module expressions in the \nmodule-composition language on top of Mvl: Mvl Z ::= atomic modules | Z Z composed modules | closed \nZ completeness check | rename X . X in Z function renaming | renameC F . F in Z configuration-option \nrenaming | hide X in Z function hiding | configure F . {T, .} in Z partial configuration | assert V in \nZ variability check Since the operators and their formalization are straightfor\u00adward, we provide only \nan intuition of how they work. A module is closed if it has no remaining imports of functions or con.guration \noptions in any con.guration. The operation closed returns a closed module unmodi.ed and gets stuck on \nmodules that are not closed. A module check is easy to specify and implement on a module s interface \nby inspecting G and i. Operation rename takes a module and produces a new module in which all occurrences \nof a function name (in func\u00adtion imports, function de.nitions, and function calls in all con.gurations) \nare replaced by a different name. As precon\u00addition, we expect a well-typed module in which the new func\u00adtion \nname is not already imported or de.ned. For example to compose inmem and persist in Figure 1, we could \nrename functions write to writemem and read to readmem: persist (rename read.readmem in (rename write.writemem \nin inmem)). Similarly, operation renameC renames all occurrences of a con.guration option. The operation \nassumes a well-typed module and a target name that is not yet imported or de.ned as con.guration option \ninside the module. Technically, we simply exchange the names in con.gurations during lookups; in a more \nsyntactic implementation, we would rewrite vari\u00adables in presence conditions. For example, in the source \ncode in Figure 2, we could simply replace all syntactic occurrences of READONLY by DB_READONLY_ACCESS \nto avoid possible name clashes with other modules that also have a con.gura\u00adtion option READONLY. Operation \nhide hides a function inside a module so that it is no longer exported. The notion of hiding is especially \nuseful in hierarchical module systems [13]. We can either explicitly model private functions, or we implement \nhiding by inlining the function. For example, after composing the modules core and inmem in Figure 1, \nwe could hide functions read and write to clean the namespace before further compositions. Operation \ncon.gure removes a con.guration option from a well-typed module, by selecting or deselecting it. As dis\u00adcussed \npreviously, there are no private con.guration options, but every con.guration option must be exported \nto enable a choice. Therefore, we cannot hide a con.guration option without deciding whether the corresponding \ncode should be included or not. Syntactically, this operation replaces all occurrences of the con.guration \noption in presence condi\u00adtions by true or false and removes the corresponding decla\u00adration. For example, \nwe could decide to select feature READ-ONLY of module storage in Figure 2 (note that on subse\u00ad quent \ncomposition of that module with query, the imported feature READONLY would no longer be matched by a \ncor\u00adresponding de.nition, that is, the resulting module is not closed). Finally, we provide a variability \ncheck for a module that asserts that the given module provides expected variability (roughly similar \nto a type cast). The operation simply returns the module if the expected variability (provided as a vari\u00adability \nmodel) is a subset of the module s variability model, or gets stuck otherwise. So, we can compare a composed \nmodule with a separately de.ned speci.cation, as we discuss in Section 4.2. Based on this composition \nlanguage and the formalization of Mvl, we could de.ne a type system that statically checks that a composition \ndoes not get stuck. However, such a type system adds little new to our discussion of variability, so \nit is outside the scope of this paper.  3.5 Formalization summary We have shown that it is possible \nto make modules variability\u00adaware while preserving the basic properties of traditional module systems. \nTo do so, we replaced the globals of tra\u00additional feature-oriented programming variability model and \nscope of con.guration options by modular counterparts and enriched the interface language with variability, \nsuch that separate checking becomes possible. 4. Design decisions The variability-aware module system \nthat we de.ned in the previous section makes several design decisions that deserve discussion. 4.1 Constraint \ninference The most controversial design decision of our calculus is to infer constraints during composition \nwhen function con.icts are detected. In our calculus, two modules are compatible even if they contain \nfunction con.icts, as long as at least one con.guration is without con.ict. As alternative design, we \ncould regard two modules as incompatible, if they have function con.icts in any con.gu\u00adration. We would \nde.ne compatibility as follows: v1 n v2 n con.ict(G1, .1, G2, .2)= \u00d8 j1 n j2 = \u00d8 (v1, i1, j1, G1, .1) \n\u00f7(v2, i2, j2, G2, .2) x=y mx \u00f7 my \u00f7 m1, . . . , mn A main difference between both designs is associativity \nof module composition (P5). Consider the following modules: a =( b =( vm =( config A; config B; import \nconfig A,B; fun foo(): Int fun foo(): Int variability if A = ...; if B = ...; \u00ac(A.B); ))) Modules a and \nb export the same function in overlapping con.guration sets, but module vm excludes all overlapping con.gurations. \nIn an open-world scenario, modules a and b do not know about each other or their con.guration options. \nNevertheless, the inference-based design decision allows us to compose modules a and b without knowing \nabout a dependency between con.guration options A and B; the composition operator infers that A and B \nmust be mutually exclusive. In the alternative design, in which we do not allow any function con.icts, \nwe can compose a with b only after composing one of it with vm. That is, a (b vm) is a valid composition, \nwhereas (a b) vm is unde.ned. In the inference-based design, the composition operator in\u00adfers additional \nconstraints that are added to the feature model. If needed, we can use the assert operator of the composition \nlanguage to ensure that we do not accidentally restrict the module s variability model too much (see \nSection 3.4). In contrast, in the alternative design, a developer is forced to compose one module with \na glue-code module before com\u00adposing it with another module with partial function con.icts. Along those \nlines, the variability model to be used as glue code can be integrated into the composition operator, \nsuch as m1 v m2 as shorthand for (m1 (v, \u00d8, \u00d8, \u00d8, \u00d8)) m2. There are trade-offs between both designs: \n Associativity vs. pairwise compatibility: On the one hand, the inference-based design enables associativity \nof module composition (P5). On the other hand, in the alternative design, already pairwise module compatibility \nis closed under module composition; thus it satis.es the stronger property (P6) in addition to (P6 ). \n Local errors vs. speci.cation effort: In the alternative de\u00adsign, function con.icts are always reported \nlocally when composing two modules. When these function con.icts do not matter due to additional constraints, \nthe developer must provide additional speci.cations at composition time. Conceptually, the alternative \ndesign roughly relates to ex\u00adplicit type annotations for type checking, where precise local error messages \nare possible at the expense of addi\u00adtional speci.cation effort. In contrast, the inference-based design \nroughly aligns with type inference, because we in\u00adfer which compositions are correct but only report \nan error when we actually use one of the excluded con.gurations. As in languages based on type inference, \nerror reporting is less immediate and less local, but less speci.cations are required.  Both designs \nhave their merits. For us, .exible, associative composition (P5, P6 ) was the more important goal, so \nwe decided to present and implement the inference-based design as main mechanisms. Furthermore, our experimental \nevaluation suggests that compatibility in the inference-based design is not trivial and can .nd type \nerrors in real-world code. Nevertheless, the alternative design is straightforward to formalize (actually, \nthe different compatibility rule above is the only necessary change) and to implement. Finally, there \nis a third alternative that would allow both associativity (P5) and pairwise compatibility checks (P6): \nWe could restrict variability models such that only positive constraints can be expressed, for example, \nby restricting constraints to Horn clauses. Unfortunately, that design choice reduces expressiveness \nbeyond what is acceptable in product\u00adline practice: We could not even express mutual exclusion as in \nmodule vm.  4.2 Local variability models and con.guration-option imports One of our design goals was \nto eliminate the inherently anti\u00admodular global variability model, which is common in prod\u00aduct line engineering \n[19]. A global variability model does not align with the open-world design of our module system. Instead, \nwe allow specifying the relevant constraints distribut\u00adedly in different modules. Thereby, our variability-aware \nmodule system allows decomposing large global variabil\u00adity models into small local variability models. \nWe believe that modules with local variability models can be more eas\u00adily reused, because local variability \nmodels make weaker assumptions on the context.  If desired, a global variability model can still be \nencoded as just another module. This module would declare all con\u00ad.guration options and their constraints. \nThe pattern of having a separate variability model may be useful for the common case that a domain expert \nmodels constraints not re.ected or detected by the type system, such as a read-only database does not \nrequire transactions . Such an additional variability model can simply be linked into any other module \nto restrict valid con.gurations. Optionally, we could extend our module system such that a module can \nspecify expected variability in the form of a minimal con.guration space that should not be restricted \nby other modules; this can also be encoded with the assumes operator of the composition language (cf. \nSection 3.4). One could criticize that we still have a global namespace for con.guration options. While \nthis is true, the same holds for the namespace of function names. In both cases, we enforce scoping with \nexplicit imports and compatibility checks detect accidental rede.nitions. Furthermore, renaming operations \nof the composition language can be used to resolve naming con.icts. A arguable aspect of our design is \nthat we need to locally redeclare constraints between crosscutting con.guration op\u00adtions in every module \nthat needs those constraints for modu\u00adlar type checking. This could easily be addressed by adding named \nimports in which lists of constraints (and function signatures) or entire modules can be imported with \na single import statement. In principle, we could also infer a local variability model that describes \nexactly all well-typed con.g\u00adurations (similar to how we infer constraints during linking), but in this \ncase we prefer immediate modular reporting of lo\u00adcal errors. We could even argue that repeating constraints \nfor modular type checking provides even useful documentation.  4.3 Abstraction from variability implementation \nOur calculus abstracts from a concrete language and type system at expression level. We intentionally \nfocus on module interfaces to allow different inner implementation approaches and different strategies \nto type check all con.gurations of a module s implementation. There are many examples of how variability \ninside a module can be implemented and type-checked. Conditional compilation as introduced in Section \n2, even though usually frowned upon from the research commu\u00adnity [52], is a perfect match for our calculus: \nDevelopers can encode presence conditions on code fragments with #ifdef directives. Even variability \nat expression level is not uncommon in practice [39]. Variability-aware type checking [33] can be used \nto type check all con.gura\u00ad tions ef.ciently as we will show. Our implementation for C, discussed in \nSection 5.2, is entirely based condi\u00ad tional compilation in C code. Although we do not want to encourage \nusing lexical preprocessors, we acknowledge their widespread use and the huge amount of legacy code and \nprovide corresponding tool support. We can use an approach with intermodule variability, in which we \nprovide one module per con.guration option (without variability inside modules; cf. Section 2.1), to \nencode variability inside a composite module [58]. Several mechanisms, called safe composition, can be \nused to ef.ciently check whether all compositions of a .xed set of inner modules allowed by a local variability \nmodel are well-typed [3, 17, 22, 55]. In our module system, we can nest even variable modules and guarantee \na common interface.  Finally, we can use any other implementation strategy, including runtime variability \n[49], sophisticated metapro\u00ad gramming systems [30, 36], and con.guration manage\u00ad ment systems [12, 37]. \nFor most of these implementa\u00ad tion mechanisms, no ef.cient means to type check all con.gurations is available \nyet. However, if variability in each module is suf.ciently restricted, a brute-force approach of checking \neach distinct implementation of the module s con.gurations may suf.ciently scale. Using a variability-aware \nmodule system, we can apply brute\u00adforce type checking to each module in isolation, whereas, once we determined \nthat a module is well-typed, there is no need to recheck it for composition (P3).  To summarize, the \nvariability-aware module system can pro\u00advide uniform interfaces to many different forms of variability \nimplementation and type checking inside modules. As such, it also helps us to reason about the composition \nof variable modules implemented with different approaches and bridges intermodule and intramodule variability. \n 4.4 Product lines of product lines Developing product lines of product lines (also known as nested \nproduct lines [37], multi product lines [50], or product populations [58]) has received increasing attention \nas the size of industrial product lines has grown and the need for a divide-and-conquer strategy arose \nagain. Since each module can be considered as a product line of its own, composing multiple product lines \nand reusing product lines in different (even unplanned) contexts is a natural use case of our module \nsystem. For example, we could reuse the storage-subsystem product line from Figure 2 in a product line \nof consumer electronics. Our module system offers a clean solution to decompose a product line into smaller \nsubproduct lines, including a suitable decomposition of the variability model, enforcing information \nhiding with variable interfaces. In this context, it is useful to adopt the notion of hierarchi\u00adcal modularity \n[13] and provide a rich composition language as outlined in Section 3.4. Supporting composition in hierar\u00ad \nchical form allows resolving possible composition con.icts locally, at lower levels of the hierarchy. \nAt each level, devel\u00adopers control what functions and variability the composed module exposes. To that \nend, renaming, hiding exported func\u00adtions after composition, and partially con.guring a module by selecting \nor deselecting con.guration options become es\u00adsential operations to prepare modules for composition with \nindependently developed product lines. We believe that most concepts of the SML/NJ compilation manager \n[13] can be adopted for product lines in our module system as well; but an in-depth analysis is outside \nthe scope of this work.  5. Implementation and practical scenario We demonstrate a practical application \nof our variability\u00adaware module system as follows. First, we outline an imple\u00admentation strategy that \nis suf.ciently ef.cient for real-world product-line implementations. Second, we actually imple\u00admented \na variant of the module system for C code with #ifdef variability as part of our TypeChef project. Third, \nwe apply our implementation to the medium-size product line Busy\u00adbox, which we already introduced in \nSection 2.4, and report detected type and linker errors. We do not intend to perform rigorous benchmarks; \ninstead, we demonstrate that it is pos\u00adsible to implement such a module system that is suf.ciently ef.cient, \nand we illustrate practical potential of the module system in a realistic setting. 5.1 Implementation \nstrategy The calculus leaves open how to represent variability and describes checks by quantifying over \nlarge con.guration spaces (e.g., .c . v. . . .). In our implementation, we en\u00adcode sets of con.gurations \nas propositional formulas (p . P), in which variables are names of con.guration options, as exempli.ed \nalready in Section 2.3. Each model of the for\u00ad mula corresponds to a con.guration. This allows us to \nencode module well-formedness and compatibility as Boolean sat\u00adis.ability problem. We describe an encoding \nin line with a long tradition of prior work on variability-aware analy\u00adsis [3, 6, 17, 20, 33, 34, 54 \n56]. Despite exponential worst-case time, reasoning about all con.gurations induced by a formula is suf.ciently \nef.cient in practice with modern Boolean satis.ability solvers [42]. An empty con.guration set corresponds \nto an unsatis.able formula ([false] = \u00d8), the intersection of two con.guration sets is equivalent to \nthe conjunction of the corresponding formula ([p1 . p2] = v1 n v2), and so forth. We encode the map from \ncon.gurations and names to types (G . C . X . T ) as a map from names and formulas to types (. . X . \nP . T). This has two bene.ts: We can iterate over a typically small set of formulas describing only distinct \ntypes, and, due to the reversed mapping order, we do not need to copy the entire environment when changing \na single function. In this encoding we need to enforce the invariant that all formulas for a name are \nmutually exclusive with a SAT solver. As optimization, two entries with the same name pointing to the \nsame type can be joined by disjuncting their formulas. Module compatibility. To determine compatibility \nbetween module interfaces, we check whether there is at least one sat\u00adis.able con.guration that satis.es \nboth variability models and is not a function con.ict: SAT(p1 . p2 .\u00accon.ict(...)). To determine function \ncon.icts, we derive a formula that de\u00adscribes all con.icting con.gurations. Let us illustrate this en\u00adcoding \nwith con.ictpresence: For a name x, we determine the e condition when x is exported with any type ( dom(.i(x))); \nsubsequently, we require exports from both modules must be re eb mutually exclusive (\u00ac dom(.1(x)) . dom(.2(x)) \n); .nally, we return the disjunction of these mutually-exclusive constraints for all x de.ned in both \nmodules. That is, to de\u00adtermine con.ictpresence, we iterate over a small set of names and with a small \nset of formulas per name to create a sin\u00adgle formula describing all con.gurations with con.icts. We encode \ncon.icttype similarly, but additionally compare (a usually small number of) types. All checks are performed \nsolely on interfaces (P3). Module composition. During module composition, we cre\u00adate a new variability \nmodel as conjunction of the original ones without con.icts (p1 . p2 .\u00accon.ict(...)). When both modules \nimport the same function with the same type, we import it only once using the disjunction of the respective \npresence conditions. To remove a function import with for\u00admula a by an export with formula b, the resulting \nmodule imports the function with formula a .\u00acb. Finally, all en\u00adtries with formulas a that are unsatis.able \nin the resulting ' variability model p (i.e., \u00acSAT(p ' . ai)) can be removed. Type checking all con.gurations \nof a module. As dis\u00adcussed in Section 4.3, many different implementation mech\u00ad anisms can be used inside \na module; even a brute-force approach to type check all con.gurations may be feasi\u00adble in some cases. \nStill, more sophisticated checks have been developed for certain variability-implementation ap\u00adproaches \n[3, 6, 17, 20, 22, 33, 55, 56]. Here, we brie.y out\u00ad line how to type check code with conditional compilation. \nWith variability, each expression can have alternative types, just as each name in the current context \ncan have alter\u00adnative types. All expressions are type checked in a variability context pctx (a formula \ndescribing the subset of con.gura\u00adtions that are checked, for example, the presence condition of the \nfunction that contains the expression). When looking up a function call, we .nd all declared types ti \nwith the cor\u00adresponding formulas pi. We can discard types with formulas never satis.able in the current \ncontext (\u00acSAT(pctx . pi)). We raise an error if, in any con.guration in the context, there is no type \n(SAT (pctx .\u00acp1 . ... .\u00acpn)) and hence no func\u00adtion; a violation of a property that we call reachability \n[33]. Again, the key idea is using propositional formulas to reason about (typically few) alternative \ntypes instead of iterating over all con.gurations.  For operations that involve comparing two types, \nsuch as function application (e.g., e1(e2)), we look up alternative types for both subexpressions. We \ncheck all combinations of both alternative types, if the conjunction of their formulas is satis.able \nin the current context. Worst-case effort is exponential and the number of types can explode, but, in \npractice, expressions rarely have a large number of alternative types [3, 6, 17]. For more details on \nvariability-aware type checking see the rich body of prior work [3, 6, 17, 22, 33, 55]. We determine \nrelevant con.guration options (varmodel, varmap in Mvl) syntactically with a sound and conserva\u00adtive \napproximation (all properties still hold): We collect all variable names in formulas, including the variability \nmodel. Due to SAT solving, determining compatibility and well\u00adtypedness of modules is NP-complete. However, \nwith modern SAT solvers, the complexity of SAT solving is not of practical concern even for large product \nlines [33, 42, 55].  5.2 Implementation for C We provide the .rst approach to type check all con.gura\u00adtions \nof realistic C code, beyond actually preprocessing and checking all con.gurations in isolation in a brute-force \nfash\u00adion (prior work focused on Java dialects [3, 22, 33, 55], the lambda calculus [17], and UML [20], \nor only sketched a possible strategy [6]). Our implementation of variability\u00ad aware module system supports \nboth modular checking of all con.gurations of a translation unit and variability-aware compatibility \nchecks. The implementation is part of the Type-Chef project, which pursues variability-aware analysis \nof real-world C code. TypeChef is open source and available at http://ckaestne.github.com/TypeChef/. \nFor experimen\u00ad tation, a simple interactive online version is available at that site as well. Based on \nthe outlined implementation strategy, we im\u00adplemented the variability-aware module system Mvl for C. \nInstead of modifying a C compiler and linker, we wrote the module system as a separate analysis tool \nin Scala. It sep\u00adarately detects errors that the normal compiler and linker would .nd when compiling \nand composing .les in a spe\u00adci.c con.guration. The implementation consists of four main parts: parsing, \nmodular variability-aware type checking of translation units, interface inference, and composition checks \nbetween interfaces. Variability-aware parsing. A challenge in analyzing #ifdef variability in C code, \nwhich hampered prior approaches, is preserving variability during parsing. Conventional C parsers only \nparse a single con.guration after the preprocessor has inlined includes, expanded macros, and evaluated \nconditional\u00adcompilation directives. Instead, we parse C code without eval\u00aduating #ifdef directives and \nproduce an abstract syntax tree that contains variability information (including information from header \n.les). In case of #ifdef directives, we parse both branches and encode variability in the abstract syntax \ntree. Typically only explicitly declared con.guration options are considered for variability, whereas \nother macros, such as in\u00adcluded guards, are processed as in a traditional preprocessor. The actual process \nis precise but much more complex, due to lexical use of #ifdef directives on arbitrary tokens and because \nof interactions between macros, includes, and condi\u00adtional compilation. The parser has been discussed \nin detail in prior work [34]; here, we use it as black-box component. Modular variability-aware type \nchecking. For each trans\u00adlation unit, we perform modular variability-aware type check\u00ading (m OK of Mvl) \non the abstract syntax tree with vari\u00adability, as outlined above in Section 5.1. The type system determines \n(alternative) types for all expressions. In C, this means it checks reachability (as described in Section \n5.1) of function calls and variables access, reachability of .eld access of structures, and compatibility \nof types. In princi\u00adple, a sound and complete variability-aware type system is possible [3, 17, 22, 33]. \nHowever, due to the size and the informal description of the C standard, our prototype covers only a \nlarge subset of the standard but is incomplete and un\u00adsound regarding, for example, goto labels, unreachable-code \nremoval, and several GNU C extensions. The type system in\u00adcorporates a local variability model (de.ned \nin a separate .le for each translation unit) and reports errors only within valid con.gurations. It checks \neach translation unit in isolation (P2). Interface inference. Based on the type system s result, we infer \nan interface for each translation unit. C .ts particularly well to our module-system design, because \nit distinguishes between function declarations without bodies (prototypes; typically de.ned in header \n.les) and function de.nitions with bodies. Function de.nitions are exported unless marked static, whereas \ncalled functions that are declared but not de.ned are imported. From the presence conditions of function \nde.ni\u00adtions and function calls, we derive presence conditions for the interface; for imports, we derive \na presence condition as disjunction of all presence conditions of calls of this function within the translation \nunit.3 Types of imports and exports are directly recognized from function declarations and function de.nitions, \nrespectively (i.e., no type inference and no investi\u00adgation of other modules is necessary). Furthermore, \nthe inter\u00adface contains imports for all con.guration options used within presence conditions in the translation \nunit. We do not automat\u00adically infer declarations of con.guration options or local vari\u00adability models, \nbut users can de.ne them manually if desired. We decided to infer interfaces instead of writing them \nexplicitly, because, except for declarations of con.guration options and variability model, all information \nis already avail\u00adable in the C code. Developers can decide when to import a 3 In fact, the GNU C compiler \ncreates symbols only for functions called after the optimizer removed unreachable code. We do not yet \nperform such optimizations; so, functions called only from unreachable code are part of the inferred \ninterface. Adopting variability-aware constant folding and variability-aware static analysis in C to \ndetect unreachable code in all con.gurations is an interesting avenue for future work.  function by \nadding an #ifdef around the prototype declara\u00adtion and can explicitly decide when to export a function \nwith the static speci.er, which can also be guarded by an #ifdef. Maintaining a separate manual interface \nspeci.cation and checking it against the implementation is possible, but does not provide additional \nbene.ts: An interface cannot be more restrictive than the implementation, unless we change the C compiler \nas well to enforce our interfaces. Compatibility checks. Compatibility checks between in\u00adferred interfaces \n(\u00f7 m1, . . . , mn ) implement Mvl as out\u00adlined in Section 5.1. Our implementation works on inferred interfaces \nin separate .les, not directly on C code.  5.3 Type checking Busybox Finally, we used our variability-aware \nmodule system to parse all translation units in Busybox, type check each translation unit in isolation, \ninfer interfaces, and check all compositions. Errors. In the analyzed release 0.18.5, all 522 translation \nunits are syntactically correct and well-typed in all valid con.gurations. The development process of \nBusybox, which includes some random-con.guration testing before releases, seems to catch most type errors \nalready. However, in recent development revisions, we found and reported three compile\u00adtime errors speci.c \nto certain con.gurations.4 In addition, occasionally compile-time errors in development revisions are \nreported on the mailing list; we reproduced some known (and now .xed) compiler errors throughout the \nrevision history. Here, we exemplify a type error and a linker error. In September 2011, a user reported \na compile-time er\u00adror reporting two undeclared variables now and info in .le procps/ps.c.5 After some \ninvestigation, the user eventually traced down the problem to a con.guration without fea\u00adture FEATURE_PS_LONG \nand posted a con.guration that would reproduce the error. The patch that .xed the prob\u00adlem adds an additional \n#ifdef directive around the prob\u00adlematic code fragment. Running TypeChef on the revision at the time \nof the bug report (git commit b64bd16459) yields two type errors in .le procps/ps.c. Without man\u00adual \ninvestigation, TypeChef pinpoints the problem precisely to a set of con.gurations with the following \nconstraint: \u00acDESKTOP . PS .\u00acFEATURE_PS_LONG . (SELINUX . FEATURE_SHOW_THREADS . FEATURE_PS_WIDE). In \nthe same month, another user provided a patch for a linker error.6 An incorrectly placed #ifdef directive \n(intro\u00adduced in git commit 128543721) caused that library func\u00adtion match_fstype was no longer exported \n(instead of being exported when feature PLATFORM_LINUX is selected). At 4 Bug reports https://bugs.busybox.net/show_bug.cgi?id=4994 \nand http://lists.busybox.net/pipermail/busybox/ 2012-April/077683.html; .xed in subsequent commits. 5 \nSee http://lists.busybox.net/pipermail/busybox/ 2011-September/076730.html for the full discussion and \npatch. 6 http://lists.busybox.net/pipermail/busybox/ 2011-September/076576.html the same time, the function \nwas still imported in modules mount and umount when the corresponding features MOUNT or UMOUNT were selected. \nIn that revision, TypeChef re\u00adports that the composed module still conditionally imports function match_fstype; \nthat is, the module is not closed in con.gurations with MOUNT . UMOUNT. For other kinds of linker errors, \nsuch as con.icting types of imports, multiple function exports with the same name, and type mismatch \nbetween imports and exports, we have not found actual instances in Busybox. For testing purposes, we \ndeliberately introduced and detected several of them. Overall, our experiments con.rm that TypeChef .nds \ntype errors and linker errors in real-world product lines, which is especially helpful as rapid feedback \nduring the development process, for instance as part of an automated build in a continuous\u00adintegration \nprocess. Local and crosscutting variability. Our module system supports local and crosscutting variability. \nIn Section 2.4, we already presented several metrics from Busybox that we gath\u00adered ex post from our \ninfrastructure. When relying on inter\u00admodule variability by providing one module per con.guration option, \nwe would have been forced to decompose translation units with inner variability into smaller modules, \njust for tech\u00adnical reasons. Furthermore, we would have been forced to create many additional modules \nfor con.guration options that crosscut the entire implementation. Such encoding appears cumbersome and \nunpractical, whereas our module system allows modular checks without restructuring the code. Our module \nsystem explicitly supports encapsulating local inner variability, enables variability to crosscut multiple \nmodules, and supports variability in interfaces. Whereas previously every con.guration had to be checked \nin isolation in a brute-force fashion, we can type check all con.gurations of each module in isolation \nand we can check compatibility of all modules with their variability. Performance. The advantage of modular \nchecks shows most prominently regarding performance. In total, we need 57 minutes to type check all modules.7 \nOn average we need 5 seconds to parse a single translation unit with all its headers and with its variability, \n0.7 seconds to type check all con\u00ad.gurations in a variability-aware fashion, and 0.03 seconds to infer \nits interface. Compared to a brute-force approach of checking all con.gurations in isolation, our analysis \nis extremely fast. The slow down compared to conventional compilers is a tribute to the inherent complexity \n(we parse and type check all, potentially billions of possible con.g\u00adurations) and the necessity to solve \nmany Boolean satis.a\u00adbility problems. With our module system, we easily paral\u00ad 7 We measured performance \non a normal lab computer (Intel quad-core 3.4 GHz with 8 GB RAM; Linux; Java 1.6, OpenJDK). We did not \nperform low-level optimizations and still compute debug information and statistics. Measured times provide \nonly rough indicators about what performance to expect and that variability-aware analysis is feasible; \nthey are not meant as rigorous benchmarks.  lelize type checking with multiple machines. Furthermore, \nafter a change, we only need to recheck affected .les and corresponding compatibility checks instead \nof reperforming whole-program analysis. Checking compatibility and composing all interfaces in\u00adcrementally \n(in alphabetical order) requires 29 seconds. Com\u00adposing them in a divide and conquer fashion (pairwise \ncom\u00adposition, then pairwise composition of the results, and so on) reduces effort to 4 seconds, with \nadditional potential for parallelization. Overall, the opportunity for quick compatibil\u00adity checks, for \nparallelization, and for incremental checking allows us to scale variability-aware analysis to real-world \nC code. 6. Related work Variable module composition. Product-line implementa\u00adtions that target some notion \nof modularity (e.g., compo\u00adnents, plug-ins, feature modules, functors, or aspects) typi\u00adcally follow \nan approach in which compile-time variability is expressed as intermodule variability during composition, \nnot inside modules [2, 4, 8, 16, 19, 29, 30, 47, 48, 51]. Sev\u00ad eral of these approaches offer notions \nof function re.nement, orthogonal to our discussion, for which composition is not commutative [5]. When \nconstructing product lines from mod\u00ad ules without inner variability, type checking each module in isolation \nis usually straightforward; for languages without explicit module interfaces, such as AHEAD, AspectJ, \nand DeltaJ, corresponding interfaces can be inferred [22, 38, 51]. However, since variability is encoded \nas variable composition, there is still an exponential number of possible con.gurations. Checking them \nall is usually infeasible; modular type check\u00ading reduces the costs for each composition check but does \nnot reduce their number. Inheritance and subtype polymorphism is the traditional way to model variability \nin object-oriented languages. In classical object-oriented languages, these mechanisms are restricted \nto single classes and hence not suitable for features that affect multiple classes; more advanced approaches \nsuch as class boxes [10] or virtual classes [24] generalize these notions (with different restrictions) \nto sets of collaborating classes. In contrast to our approach inheritance with subtyp\u00ading supports dynamic \nvariability, it is more restricted with regard to the structural changes that a feature entails. Due \nto the highly dynamic nature of subtyping, subsumption re\u00adquires that subtypes can only add methods or \nre.ne types of existing methods subject to co-and contravariance restric\u00adtions. For instance, it would \nnot be possible to have a function return an integer value in one con.guration and a Boolean value in \na different con.guration and be totally absent in a third con.guration. The idea to use con.guration \nknowledge for type checking occurred in different contexts, for example, to make con.gu\u00adration options \nexplicit during type checking [4] or to check all con.gurations of an entire product lines [55, 56]. \nFor a .xed set of modules (i.e., in a closed world), safe compo\u00adsition explores all con.gurations against \na global variabil\u00adity model using an encoding as Boolean satis.ability prob\u00adlem [3, 22, 55]. The same \ntechnique was explored also as variability-aware type checking for closed-world nonmod\u00adular implementations \n[6, 17, 20, 33] and for other analysis approaches [14, 18]. Although following a different technical \nroute, the implementation of our type-checking mechanism inside modules with alternative types was particularly \nin\u00adspired by the structures of the choice calculus [17, 26] and the concept of variational programming \n[27]. Overall, in our module system, we use similar algorithms and encodings for type checking a module \nand for implementing linker checks, but a closed-world assumption is never required; an exist\u00ading (composed) \nmodule can always be composed with more modules while retaining the soundness guarantees. Variability \ninside modules. Variability inside modules has been explored in different contexts. Our work was initially \nin\u00adspired by prior work on modular logic metaprogramming [36]. In logic metaprogramming, programs are \nderived from a de\u00adductive database; by using a logic to describe the effect of metaprograms in interfaces, \nsound modular type checking can be achieved. We adopted the underlying idea of logic formu\u00adlas in interfaces, \nbut restricted and specialized it to a level that is practical for large-scale product line development \nand ef.\u00adcient to check with automated provers. From the perspective of logic metaprograming, we reduce \nmetaprogramming to propositional presence conditions over con.guration options and local variability \nmodels. Several programming languages support some form of type-conditional methods, a form of parametric \npolymor\u00adphism in which the applicability of a method call can depend on the type parameter of the enclosing \nclass [23, 31, 40, 45]. Invoking a conditional method is only well-typed when the condition is satis.ed \nin the context of the invocation. For example, in a collection class, such as List, clients should only \nbe allowed to invoke a method print if the class is pa\u00adrameterized with a type that can be printed. The \npurpose of type-conditional methods is to improve static type-safety; the operational semantics of the \nlanguage does not change. For instance, it is not possible to de.ne several alternative vari\u00adants of \na method (with different implementations or types) or to de.ne dependencies between con.guration options. \nThis means that the applicability of these approaches to variability management in software product lines \nis rather limited. Approaches to increase the .exibility of method dispatch, such as multi-methods [44], \npredicate dispatch [25], or de\u00adpendent classes [28] could be used for modules with inner variability, \nbut since the dispatch only depends on method arguments, it is not obvious how to encode variability \nthat can not be deduced from the dynamic arguments of a method call. Furthermore, a set of methods with \nthe same name typically needs a default implementation, which is called if none of the other methods \nis applicable, which is less safe than the checks in our approach, which do not need default implementations \nbut can detect statically when no applicable function exists. Also, modular type checking of these approaches \nis quite hard [43, 44]. On the other hand, these approaches are much more powerful with regard to expressing \ndynamic variability, which is not in the scope of this work.  Compile-time metaprogramming, such as \nC++ templates or the C preprocessor, is often used to express inner compile\u00adtime variability [19], but \nthese approaches suffer from the problem that type checking can only take place after special\u00adization \nto a speci.c instance of the product line. Also the product-line community has explored compo\u00adnents with \ninner variability. Most prominently, the Koala component system has mechanisms for run-time and compile\u00adtime \nvariability inside a module, exposed through a diversity interface in Koala [58]. A Koala module can \nexpress variable module composition of inner modules; the condition for the composition can be exposed \nin the diversity interface. If a con.guration parameter is known at compile-time, only the corresponding \ninner module is included (a specialized form of partial evaluation), otherwise all modules are included \nand function calls are dispatched at run-time. In contrast to our module system, Koala does not support \nvariability in the func\u00adtional interface: Diversity interfaces may change the behavior (and which inner \ncomponent is used to provide the behavior) but not the interface. Dependencies between con.guration options \nand crosscutting variability are not explicitly sup\u00adported, but can be encoded. Since compile-time variability \nis expressed with variable module composition (possibly nested inside another module), Koala enforces \na variability-induced dominant decomposition. Along similar lines, de Jonge [21] introduced con.gu\u00ad ration \ninterfaces into a package mechanism: Each package can declare con.guration options and bind them in imported \npackages. Similarly, plastic partial components [46] introduce variability interfaces for architectural \ncomponents and realize variability internally with aspect-oriented programming. Van der Storm [57] subsequently \nextended this approach with local variability models and con.guration checks by encod\u00ading variability \ninformation as Boolean satis.ability problem. However, all these approaches do not enforce modularity \nof the host language modules with code-level interfaces; at most they check consistency between packages. \nComposing variability models. Finally, there are many mechanisms to specify and compose variability models \nand to reason about them. In practice, some .avor of graphical feature diagrams are typically used [19], \nwhich represent con\u00ad .guration options in a hierarchical form and have a straight\u00adforward translation \nto propositional logic [57]. Busybox uses the textual feature-modeling language KCon.g with a similar \nconcept and translation [11]. Advanced composition mech\u00ad anisms attempt to retain the hierarchical form \nof variability models [1]; they are orthogonal to our discussion. If variabil\u00ad ity model and reasoning \nshould include non-Boolean con\u00ad.guration options, other logics and solvers can be used [9]. For our calculus \nand our implementation, composing propo\u00adsitional formulas was suf.cient. 7. Conclusion We introduced \na variability-aware module system for soft\u00adware product lines that overcomes the variability-induced \ndominant decomposition of traditional module systems, by allowing variability inside modules and in module \ninterfaces. Each module can be type checked in isolation, covering all con.gurations allowed by the module \ns local variability model. Composing two compatible well-typed modules with variability yields another \nwell-typed module with the com\u00adbined variability. The module system breaks with the product\u00adline tradition \nof closed-world implementations with a global variability model and takes it into an open environment, \nto\u00adward software ecosystems and product lines of product lines. We de.ned the module system formally \nin a calculus, out\u00adlined a general implementation strategy, and presented an implementation for C, which \nwe applied to the open source product line Busybox. Our next step is to type check the entire Linux kernel \nwith 10 000 con.guration options, a task for which the module system is an important foundation, but \nfor which various engineering problems still have to be solved. Acknowledgments. The work was inspired \nby Karl Klose s work on modular metaprogramming. We thank Tillmann Rendel, Sven Apel, Yannis Smarakdakis, \nDon Batory, Chung\u00adchieh Shan, Martin Erwig, and Paolo G. Giarrusso for their valuable discussions on \nearly presentations of this work. This work is supported by ERC grant #203099. References [1] M. Acher, \nP. Collet, P. Lahire, and R. France. Comparing approaches to implement feature model composition. In \nProc. European Conf. Modelling Foundations and Applications (ECMFA), volume 6138 of LNCS, pages 3 19. \nSpringer-Verlag, 2010. [2] M. Anastasopoules and C. Gacek. Implementing product line variabilities. In \nProc. Symposium on Software Reusability (SSR), pages 109 117. ACM Press, 2001. [3] S. Apel, C. K\u00e4stner, \nA. Gr\u00f6\u00dflinger, and C. Lengauer. Type safety for feature-oriented product lines. Automated Software Engineering, \n17(3):251 300, 2010. [4] S. Apel, C. K\u00e4stner, and C. Lengauer. Research challenges in the tension between \nfeatures and services. In Proc. ICSE Workshop on Systems Development in SOA Environments (SDSOA), pages \n53 58. ACM Press, 2008. [5] S. Apel, C. Lengauer, B. M\u00f6ller, and C. K\u00e4stner. An algebraic foundation \nfor automatic feature-based program synthesis. Science of Computer Programming (SCP), 75(11):1022 1047, \n2010. [6] L. Aversano, M. D. Penta, and I. D. Baxter. Handling preprocessor-conditioned declarations. \nIn Proc. Int l Work\u00adshop Source Code Analysis and Manipulation (SCAM), pages 83 92. IEEE CS, 2002.  \n[7] L. Bass, P. Clements, and R. Kazman. Software Architecture in Practice. Addison-Wesley, Boston, MA, \n1998. [8] D. Batory, J. N. Sarvela, and A. Rauschmayer. Scaling step\u00adwise re.nement. IEEE Trans. Softw. \nEng. (TSE), 30(6):355 371, 2004. [9] D. Benavides, S. Seguraa, and A. Ruiz-Cort\u00e9s. Automated analysis \nof feature models 20 years later: A literature review. Inf. Systems, 35(6):615 636, 2010. [10] A. Bergel, \nS. Ducasse, and O. Nierstrasz. Classbox/J: Control\u00adling the scope of change in Java. In Proc. Int l Conf. \nObject-Oriented Programming, Systems, Languages and Applications (OOPSLA), pages 177 189. ACM Press, \n2005. [11] T. Berger, S. She, R. Lotufo, A. W .asowski, and K. Czarnecki. Variability modeling in the \nreal: A perspective from the operat\u00ading systems domain. In Proc. Int l Conf. Automated Software Engineering \n(ASE), pages 73 82. ACM Press, 2010. [12] D. Beuche, H. Papajewski, and W. Schr\u00f6der-Preikschat. Vari\u00adability \nmanagement with feature models. Sci. Comput. Pro\u00adgram., 53(3):333 352, 2004. [13] M. Blume and A. W. \nAppel. Hierarchical modularity. ACM Trans. Program. Lang. Syst. (TOPLAS), 21(4):813 847, 1999. [14] C. \nBrabrand, M. Ribeiro, T. Tol\u00eado, and P. Borba. Intrapro\u00adcedural data.ow analysis for software product \nlines. In Proc. Int l Conf. Aspect-Oriented Software Development (AOSD), 2012. to appear. [15] L. Cardelli. \nProgram fragments, linking, and modularization. In Proc. Symp. Principles of Programming Languages (POPL), \npages 266 277. ACM Press, 1997. [16] W. Chae and M. Blume. Building a family of compilers. In Proc. Int \nl Software Product Line Conference (SPLC), pages 307 316. IEEE CS, 2008. [17] S. Chen, M. Erwig, and \nE. Walkingshaw. Extending type inference to variational programs. Technical report (draft), School of \nEECS, Oregon State University, 2012. [18] A. Classen, P. Heymans, P.-Y. Schobbens, and A. Legay. Symbolic \nmodel checking of software product lines. In Proc. Int l Conf. Software Engineering (ICSE), pages 321 \n330. ACM Press, 2011. [19] K. Czarnecki and U. Eisenecker. Generative Programming: Methods, Tools, and \nApplications. ACM Press/Addison-Wesley, New York, 2000. [20] K. Czarnecki and K. Pietroszek. Verifying \nfeature-based model templates against well-formedness OCL constraints. In Proc. Int l Conf. Generative \nProgramming and Component Engineering (GPCE), pages 211 220. ACM Press, 2006. [21] M. de Jonge. Source \ntree composition. In Proc. Int l Conf. Software Reuse (ICSR), volume 2319 of LNCS, pages 261 282. Springer-Verlag, \n2002. [22] B. Delaware, W. R. Cook, and D. Batory. Fitting the pieces together: A machine-checked model \nof safe composition. In Proc. Foundations of Software Engineering (ESEC/FSE), pages 243 252. ACM Press, \n2009. [23] B. Emir, A. Kennedy, C. Russo, and D. Yu. Variance and generalized constraints for C# generics. \nIn Proc. Europ. Conf. Object-Oriented Programming (ECOOP), volume 4067 of LNCS, pages 279 303. Springer-Verlag, \n2006. [24] E. Ernst, K. Ostermann, and W. Cook. A virtual class calculus. In Proc. Symp. Principles of \nProgramming Languages (POPL), pages 270 282. ACM Press, 2006. [25] M. Ernst, C. Kaplan, and C. Chambers. \nPredicate dispatching: A uni.ed theory of dispatch. In Proc. Europ. Conf. Object-Oriented Programming \n(ECOOP), pages 186 211. Springer-Verlag, 1998. [26] M. Erwig and E. Walkingshaw. The choice calculus: \nA representation for software variation. ACM Trans. Softw. Eng. Methodol. (TOSEM), 21(1):6.1 27, 2011. \n[27] M. Erwig and E. Walkingshaw. Variation programming with the choice calculus. In Generative and Transformational \nTechniques in Software Engineering. Springer-Verlag, 2012. to appear. [28] V. Gasiunas, M. Mezini, and \nK. Ostermann. Dependent classes. In Proc. Int l Conf. Object-Oriented Programming, Systems, Languages \nand Applications (OOPSLA), pages 133 152. ACM Press, 2007. [29] M. Griss. Implementing product-line features \nby composing aspects. In Proc. Int l Software Product Line Conference (SPLC), pages 271 288. Kluwer Academic \nPublishers, 2000. [30] S. S. Huang and Y. Smaragdakis. Expressive and safe static re.ection with MorphJ. \nIn Proc. Conf. Programming Language Design and Implementation (PLDI), pages 79 89. ACM Press, 2008. [31] \nS. S. Huang, D. Zook, and Y. Smaragdakis. cJ: Enhancing Java with safe type conditions. In Proc. Int \nl Conf. Aspect-Oriented Software Development (AOSD), pages 185 198. ACM Press, 2007. [32] C. K\u00e4stner, \nS. Apel, and K. Ostermann. The road to feature modularity? In Proc. SPLC Workshop on Feature-Oriented \nSoftware Development (FOSD). ACM Press, 2011. [33] C. K\u00e4stner, S. Apel, T. Th\u00fcm, and G. Saake. Type checking \nannotation-based product lines. ACM Trans. Softw. Eng. Methodol. (TOSEM), 21(3):14.1 39, 2012. [34] C. \nK\u00e4stner, P. G. Giarrusso, T. Rendel, S. Erdweg, K. Oster\u00admann, and T. Berger. Variability-aware parsing \nin the presence of lexical macros and conditional compilation. In Proc. Int l Conf. Object-Oriented Programming, \nSystems, Languages and Applications (OOPSLA), pages 805 824. ACM Press, 2011. [35] J. Kienzle and R. \nGuerraoui. AOP: Does it make sense? The case of concurrency and failures. In Proc. Europ. Conf. Object-Oriented \nProgramming (ECOOP), volume 2374 of LNCS, pages 37 61. Springer-Verlag, 2002. [36] K. Klose and K. Ostermann. \nModular logic metaprogramming. In Proc. Int l Conf. Object-Oriented Programming, Systems, Languages and \nApplications (OOPSLA), pages 484 503. ACM Press, 2010. [37] C. W. Krueger. New methods in software product \nline develop\u00adment. In Proc. Int l Software Product Line Conference (SPLC), pages 95 102. IEEE CS, 2006. \n[38] H. C. Li, S. Krishnamurthi, and K. Fisler. Interfaces for modular feature veri.cation. In Proc. \nInt l Conf. Automated Software Engineering (ASE), pages 195 204. IEEE CS, 2002. [39] J. Liebig, S. Apel, \nC. Lengauer, C. K\u00e4stner, and M. Schulze. An analysis of the variability in forty preprocessor-based software \n product lines. In Proc. Int l Conf. Software Engineering (ICSE), pages 105 114. ACM Press, 2010. [40] \nB. Liskov, R. Atkinson, T. Bloom, E. Moss, J. C. Schaffert, R. Schei.er, and A. Snyder. CLU Reference \nManual, volume 114 of LNCS. Springer-Verlag, Berlin/Heidelberg, 1981.  [41] J. Liu, D. Batory, and C. \nLengauer. Feature oriented refac\u00adtoring of legacy applications. In Proc. Int l Conf. Software Engineering \n(ICSE), pages 112 121. ACM Press, 2006. [42] M. Mendon\u00e7a, A. W.asowski, and K. Czarnecki. SAT-based analysis \nof feature models is easy. In Proc. Int l Software Product Line Conference (SPLC), pages 231 240. ACM \nPress, 2009. [43] T. Millstein, C. Frost, J. Ryder, and A. Warth. Expressive and modular predicate dispatch \nfor Java. ACM Trans. Program. Lang. Syst. (TOPLAS), 31(2):7.1 54, 2009. [44] T. Millstein, M. Reay, and \nC. Chambers. Relaxed MultiJava: Balancing extensibility and modular typechecking. In Proc. Int l Conf. \nObject-Oriented Programming, Systems, Languages and Applications (OOPSLA), pages 224 240. ACM Press, \n2003. [45] A. C. Myers, J. A. Bank, and B. Liskov. Parameterized types for Java. In Proc. Symp. Principles \nof Programming Languages (POPL), pages 132 145. ACM Press, 1997. [46] J. P\u00e9rez, J. D\u00edaz, C. Costa-Soria, \nand J. Garbajosa. Plastic partial components: A solution to support variability in ar\u00adchitectural components. \nIn Proc. European Conf. Software Architecture (ECSA), pages 221 230. IEEE CS, 2009. [47] C. Prehofer. \nFeature-oriented programming: A fresh look at objects. In Proc. Europ. Conf. Object-Oriented Programming \n(ECOOP), volume 1241 of LNCS, pages 419 443. Springer-Verlag, 1997. [48] R. Prieto-Diaz and J. M. Neighbors. \nModule interconnection languages. Journal of Systems and Software, 6:307 334, November 1986. [49] E. \nReisner, C. Song, K.-K. Ma, J. S. Foster, and A. Porter. Us\u00ading symbolic evaluation to understand behavior \nin con.gurable software systems. In Proc. Int l Conf. Software Engineering (ICSE), pages 445 454. ACM \nPress, 2010. [50] M. Rosenm\u00fcller and N. Siegmund. Automating the con.gura\u00adtion of multi software product \nlines. In Proc. Int l Workshop on Variability Modelling of Software-intensive Systems (VaMoS), pages \n123 130, 2010. [51] I. Schaefer, L. Bettini, and F. Damiani. Compositional type\u00adchecking for delta-oriented \nprogramming. In Proc. Int l Conf. Aspect-Oriented Software Development (AOSD), pages 43 56. ACM Press, \n2011. [52] H. Spencer and G. Collyer. #ifdef considered harmful or portability experience with C news. \nIn Proc. USENIX Conf., pages 185 198. USENIX Association, 1992. [53] P. Tarr, H. Ossher, W. Harrison, \nand S. M. Sutton, Jr. N degrees of separation: Multi-dimensional separation of concerns. In Proc. Int \nl Conf. Software Engineering (ICSE), pages 107 119. IEEE CS, 1999. [54] R. Tartler, D. Lohmann, J. Sincero, \nand W. Schr\u00f6der-Preikschat. Feature consistency in compile-time-con.gurable system soft\u00adware: Facing \nthe Linux 10,000 feature problem. In Proc. Eu\u00ad ropean Conference on Computer Systems (EuroSys), pages \n47 60. ACM Press, 2011. [55] S. Thaker, D. Batory, D. Kitchin, and W. Cook. Safe com\u00adposition of product \nlines. In Proc. Int l Conf. Generative Programming and Component Engineering (GPCE), pages 95 104. ACM \nPress, 2007. [56] T. Th\u00fcm, S. Apel, C. K\u00e4stner, M. Kuhlemann, I. Schaefer, and G. Saake. Analysis strategies \nfor software product lines. Technical Report FIN-004-2012, School of Computer Science, University of \nMagdeburg, 2012. [57] T. van der Storm. Variability and component composition. In Proc. Int l Conf. Software \nReuse (ICSR), volume 3107 of LNCS, pages 157 166. Springer-Verlag, 2004. [58] R. van Ommering. Building \nproduct populations with software components. In Proc. Int l Conf. Software Engineering (ICSE), pages \n255 265. ACM Press, 2002. [59] D. Walker. Substructural type systems. In B. C. Pierce, editor, Advanced \nTopics in Types and Programming Languages, chapter 1, pages 3 43. MIT Press, 2005. A. Proofs A.1 Properties \nof M Lemma 1. Let f be a monotonic relation, (G1, .1) . M, (G2, .2) . M, (G1, .1) OK, (G2, .2) OK, and \ndom(.1) n dom(.2)= \u00d8. Then G1 . G2 \\ (sig(.1) . sig(.2)) f .1 . .2. Proof. G1 . G2 \\ (sig(.1) . sig(.2)) \nf .1 . .2 if and only if .x . dom(.1 . .2). G1 . G2 . sig(.1) . sig(.2) f e : t where (.1 . .2)(x)=(e, \nt). Since dom(.1) n dom(.2)= \u00d8, assume x . dom(.1) with .1(x)=(e, t). Then, from (G1, .1) OK it follows \nthat G1 . sig(.1) f e : t. Thus, by monotonicity, G1 . G2 . sig(.1) . sig(.2) f e : t. Analogous for \nx . dom(.2). Theorem 1 (P4: Composition preserves typing in M). Given a monotonic relation f, module \ncomposition of well-typed, compatible modules preserves typing, that is, .m1, m2 . M. m1 OK . m2 OK . \nm1 \u00f7 m2 . m1 m2 OK. Proof. Let m1 =(G1, .1), m2 =(G2, .2), and m1 m2 = '' (G , . ' ). (G , . ' ) OK \nif and only if (dom(G ' ) n dom(. ' )= '' ' \u00d8) . G f . . We inline the de.nitions of G = G1 . G2 \\ ' \n(sig(.1) . sig(.2)) and . = .1 . .2. The .rst conjunct then follows from the equation dom(sig(.)) = dom(.) \nfor all .. The second conjunct follows by Lemma 1. A.2 Properties of Mv Lemma 2. Let m1 =(v1, G1, .1) \n. M v and m2 = '' (v2, G2, .2) . Mv with m1 OK, m2 OK, and (v , G , . ' )= '' m1 m2. Then v . dom(G \n' ) and v . dom(. ' ). Proof. By m1 OK and m2 OK, we deduce v1 . G1, v1 . .1, '' v2 . G2, and v2 . .2. \nv . dom(G ' ) and v . dom(. ' ) '' then follow from the de.nition of G and . .  Theorem 2 (P4: Composition \npreserves typing in M v). Given a monotonic relation f, module composition of well-typed, compatible \nmodules preserves typing, that is, .m1, m2 . M v . m1 OK . m2 OK . m1 \u00f7 m2 . m1 m2 OK. Proof. Let m1 \n=(v1, G1, .1), m2 =(v2, G2, .2), and m1 '''' '' m2 =(v , G , . ' ). (v , G , . ' ) OK if and only if \nv = \u00d8, v . '' dom(G ' ), v . dom(. ' ), and .c . v . (G ' (c), . ' (c)) OK. The .rst constraint follows \nfrom m1 \u00f7 m2. The second and third constraint follow from Lemma 2. For the .nal con\u00ad straint, note that \n(G ' (c), . ' (c)) = (G1(c) . G2(c) \\ (.1(c) . .2(c)), .1(c) . .2(c)), which equals (G1(c), .1(c)) (G2(c), \n.2(c)). Thus, the .nal constraint follows from the type-preservation Theorem 1 of module system M. Lemma \n3. For the computation of con.icts the following properties hold. (i) con.ictpresence and con.icttype \nare commutative (ii) con.ict(G1, .1, G2, .2)= con.ict(G2, .2, G1, .1) for all G1, G2, .1, .2  ' (iii) \ncon.ictpresence(G , G)= con.ictpresence(G1, G) . con.ictpresence(G2, G), where G ' (c)= G1(c) . G2(c) \n' (iv) con.icttype(G , G)= con.icttype(G1, G) . con.icttype(G2, G), where G ' (c)= G1(c) . G2(c) ' (v) \ncon.icttype(G , G)= con.icttype(G1, G) \\ con.icttype(G2, G), where G ' (c)= G1(c) \\ G2(c) (vi) con.icttype(G1, \nG2) . con.ictpresence(G1, G2)  '' (vii) con.ict(G , . , G, .)= con.ict(G1, .1, G, .) . con.ict(G2, .2, \nG, .), where G ' (c)= G1(c) . G2(c) \\ (Sig(.1(c)) . Sig(.2(c))) and . ' (c)= .1(c) . .2(c). Proof. (i) \n(vi) follow directly from the de.nition of con.ictpresence, con.icttype, and con.ict. (vii) follows from \nthe de.nition of con.ict and properties (i) (vi). Theorem 3 (P6 : Composition preserves compatibility). \nThe partial composition of compatible modules only yields com\u00adpatible modules, that is, \u00f7 m1, m2, . . \n. , mn .\u00f7 m1 m2, . . . , mn . '' Proof. Let mi =(vi, Gi, .i) and m1 m2 =(v , G , . ' ). \u00f7 m1 m2, . \n. . , mn if and only if va \\ vb = \u00d8 where dd ' va = v n ( )= \\ con.ict(G1, .1, G2, .2) x>2 vxr x vx '' \nand vb = y>2 con.ict(G , . , Gy, .y) . b con.ict(Gx, .x, Gyr, . y) . By Lemma 3 (vii),b 2<x<y we can \nsimplify vb to con.ict(Gx, .x, Gy, .y) . x=y Since also con.ict(G1, .1, G2, .2) . vb, we get va \\ vb \n= rdbr b vx \\ con.ict(Gx, .x, Gy, .y) , which is xx=y non-empty due to the assumption \u00f7 m1, m2, . . . \n, mn . Theorem 4 (P5: Commutativity and associativity of mod\u00adule composition). Module composition is \ncommutative (m1 \u00f7 m2 . m1 m2 = m2 m1) and associative (\u00f7 m1, m2, m3 . m1 (m2 m3)=(m1 m2) m3). Proof. \nCommutativity is obvious from the de.nition of mod\u00adule composition. Associativity follows from Lemma \n3 (ii), Lemma 3 (vii), and Theorem 3 by inlining the de.nition of module composition.    A.3 Properties \nof Mvl Lemma 4. For varmodel and varmap, the following proper\u00adties hold. (i) varmodel(v1 n v2) . varmodel(v1) \n. varmodel(v2) (ii) varmodel(v1 \\ v2) . varmodel(v1)  (iii) varmap(v1 n v2, .) . varmap(v1, .) . varmap(v2, \n.) (iv) varmap(v1 \\ v2, .) . varmap(v1, .) (v) varmap(v, . ' ) . varmap(v, .1) . varmap(v, .2) where \n. ' (c)= .1(c) . .2(c) well-de.ned on v (vi) varmap(v, . ' ) . varmap(v, .1) where . ' (c)= .1(c) \\ \n.2(c) well-de.ned on v  Proof. (i) (iv) follow directly from the de.nition of varmodel and varmap. For \n(v), there are four cases in which .1(c\\{f}). .2(c \\{f})= .1(c . {f}) . .2(c . {f}): For i . {1, 2}, \neither dom(.i(c \\{f})) = dom(.i(c . {f})) or for some variable x .i(c \\{f})(x)= .i(c . {f})(x). Either \ncase is subsumed by varmap(v, .i). Similarly for the proof of (vi). Theorem 5 (Composition preserves \nlocality). Module com\u00adposition of well-typed, compatible modules preserves the locality of con.guration \noptions, that is, .m1, m2 . Mvl . m1 OK . m2 OK . m1 \u00f7 m2 . ''' ' m1 m2 =(v , i , j , G , . ' ) ' . \nvarmodel(v ' ) . varmap(v , G ' ). '' varmap(v , . ' ) . i ' . j Proof. By Lemma 4, varmodel(v ' ) . \nvarmodel(v1) . ' varmodel(v2), varmap(v , G ' ) . varmap(v1, G1) . ' varmap(v2, G2), and varmap(v , . \n' ) . varmap(v1, .1) . varmap(v2, .2), which respectively are subsets of ' i ' . j =(i1 . j1) . (i2 . \nj2) by m1 OK and m2 OK. Theorem 6 (P4: Composition preserves typing in M vl). Given a monotonic relation \nf, module composition of well-typed, compatible modules preserves typing, that is, M vl .m1, m2 . . m1 \nOK . m2 OK . m1 \u00f7 m2 . m1 m2 OK. Proof. Follows directly from Theorem 2 and Theorem 5.  \n\t\t\t", "proc_id": "2384616", "abstract": "<p>Module systems enable a divide and conquer strategy to software development. To implement compile-time variability in software product lines, modules can be composed in different combinations. However, this way, variability dictates a dominant decomposition. As an alternative, we introduce a variability-aware module system that supports compile-time variability <i>inside</i> a module and its interface. So, each module can be considered a product line that can be type checked in isolation. Variability can crosscut multiple modules. The module system breaks with the antimodular tradition of a global variability model in product-line development and provides a path toward software ecosystems and product lines of product lines developed in an open fashion. We discuss the design and implementation of such a module system on a core calculus and provide an implementation for C as part of the TypeChef project. Our implementation supports variability inside modules from #ifdef preprocessor directives and variable linking at the composition level. With our implementation, we type check all configurations of all modules of the open source product line Busybox with 811~compile-time options, perform linker check of all configurations, and report found type and linker errors -- without resorting to a brute-force strategy.</p>", "authors": [{"name": "Christian K&#228;stner", "author_profile_id": "81503674924", "affiliation": "Philipps University of Marburg, Marburg, Germany", "person_id": "P3856174", "email_address": "christian.kaestner@uni-marburg.de", "orcid_id": ""}, {"name": "Klaus Ostermann", "author_profile_id": "81100028971", "affiliation": "Philipps University Marburg, Marburg, Germany", "person_id": "P3856175", "email_address": "kos@informatik.uni-marburg.de", "orcid_id": ""}, {"name": "Sebastian Erdweg", "author_profile_id": "81490684973", "affiliation": "Philipps University Marburg, Marburg, Germany", "person_id": "P3856176", "email_address": "seba@informatik.uni-marburg.de", "orcid_id": ""}], "doi_number": "10.1145/2384616.2384673", "year": "2012", "article_id": "2384673", "conference": "OOPSLA", "title": "A variability-aware module system", "url": "http://dl.acm.org/citation.cfm?id=2384673"}