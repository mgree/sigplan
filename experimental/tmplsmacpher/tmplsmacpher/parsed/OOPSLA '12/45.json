{"article_publication_date": "10-19-2012", "fulltext": "\n * Gradual Typing for First-Class Classes AsumuTakikawa T.StephenStrickland ChristosDimoulas SamTobin-Hochstadt \nMatthiasFelleisen PLT,NortheasternUniversity {asumu, sstrickl, chrdimo, samth, matthias}@ccs.neu.edu \nAbstract Dynamic type-checking and object-oriented programming oftengohand-in-hand; scriptinglanguagessuch \nasPython, Ruby, andJavaScript all embrace object-oriented(OO)pro\u00adgramming.When scripts writtenin suchlanguagesgrow \nand evolve into large programs, the lack of a static type disci\u00adpline reduces maintainability.Aprogrammer \nmaythus wish to migrate parts of such scripts to a sister language with a static type system.Unfortunately, \nexistingtype systems nei\u00adthersupportthe .exibleOO compositionmechanismsfound in scripting languages nor \naccommodate sound interopera\u00adtion with untyped code. In this paper, we present the design of a gradual \ntyping system that supports sound interaction between statically\u00adand dynamically-typed units of class-based \ncode. The type system uses rowpolymorphismfor classes andthus supports mixin-basedOO composition.Toprotect \nmigrationof mix\u00adinsfromtypedto untypedcomponents,the system employsa novelformofcontractsthatpartiallyseal \nclasses.Thedesign comes with a theorem that guarantees the soundness of the type system evenin thepresence \nof untyped components. Categories and Subject Descriptors D.3.3[Programming Languages]: Language Constructs \nand Features Classes and objects General Terms Languages,Design Keywords gradual typing, .rst-class classes, \ncontracts, sealing,designby contract, rowpolymorphism,blametheo\u00adrem(prooftechnique) * Supportedinpartby \ntwoNSFgrants,theDARPACRASHprogram, and agrantfrom theMozillaFoundation. Permission to make digital or \nhard copies of all or part of this work for personal or classroomuseisgranted withoutfeeprovided that \ncopiesarenot madeordistributed forpro.tor commercial advantage andthat copiesbearthis notice andthefull \ncitation onthe .rstpage.Tocopy otherwise,torepublish,topostonservers ortoredistribute tolists, requiresprior \nspeci.cpermission and/or afee. OOPSLA 12, October19 26,2012,Tucson,Arizona,USA. Copyright c &#38;#169;2012ACM978-1-4503-1561-6/12/10. \n. .$10.00 1. UntypedObject-OrientedStyle Thepopularity of untypedprogramminglanguagessuch as Python, \nRuby, or JavaScript has stimulated work on com\u00adbining static and dynamic type-checking. The idea is now \npopularly called gradual typing [27]. At this point,gradual typing is available for functional programming \nlanguages such as Racket[33, 34], for object-orientedlanguages such asRuby[12]orThorn[38], andforVisualBasic[23] \nonthe .NET platform. Proposals for gradual typing also exist for JavaScript[19]andPerl[31].Formal modelshave \nvalidated soundness for gradual type systems, allowing seamless in\u00adteroperationbetween sisterlanguages[22,27,32]. \n(de.ne drracket-frame% (size-pref-mixin (searchable-text-mixin (searchable-mixin (status-line-mixin (text-mixin \n(editor-mixin (standard-menus-mixin frame%)))))))) Figure1. Abbreviatedcode with a chain of mixins Unfortunately, \nno existing gradual type system supports the full range of object-oriented styles found in scripting \nlanguages.These untypedlanguagestendto support.exible mechanismsforclass composition,such as mixinsortraits, \nthat allow theprogrammerto abstract overinheritance.Fur\u00adthermore, some untypedlanguages support ageneralization \nof mixins and traits where classes are .rst-class values and thuscaninheritfromotherclasses atruntime.Forexample, \ntheimplementation oftheDrRacketIDE[8] makes exten\u00adsive use oflayeredcombinationsofmixinstoimplementtext \neditingfeatures, as seenin the abbreviated examplegivenin .gure1 thefull code uses17 mixins. In such \nlanguages, class composition requires the pro\u00adgrammerto reason aboutthe specializationinterfaces[20] \nof superclasses.Afaithful type system must enable thepro\u00adgrammer to express this reasoning via types. \nMeanwhile, a gradually typed language should support the exchange of  Figure2. Editor module classes \nbetween typed and untyped components while en\u00adforcing the type system s invariants. This desideratum \nim\u00adpliesprotectingcross-componentinheritance. To address theseissues, wepropose a novelgradualtype system \nthat properly validates a programmer s reasoningin thepresence ofbothdynamic class composition andinheri\u00adtance \nacross untyped-typedboundaries.Ourdesign rests on two technical results. First, we introduce partial \nrun-time sealing as a mechanism to protect inheritance-related in\u00advariants at the boundary between typed \nand untyped com\u00adponents. Second, we utilize row polymorphism to express constraints on class composition \nat component boundaries. We present examples motivating the design in section 2. Our design comes with \na formal model, which we outline in section3.We address soundnessforthe system,including typed-untypedinteraction,in \nsection4. 1 2. Typing&#38;ProtectingFirst-ClassClasses WeuseRacket alanguagewith.rst-classclasses[11] \nto present ourdesign.Our choice oflanguageis motivatedby ourpracticalexperiencewith.rst-classclassesinRacketand \nthe availabilityofTypedRacket[33], agraduallytypedsister language of Racket. While our design is developed \nwith Racketin mind, manyofthelessonslearned should applyto otherlanguages withdynamic class and object \ncomposition, such asRuby,Python, orJavaScript. InTypedRacket, untyped and typed codeinteroperate at the \ngranularity of modules. Interactions between modules are mediatedby higher-orderbehavioral contracts[9].That \nis, when exporting values to untyped modules from typed modules,thelanguageturnstypesinto appropriatecontracts. \nIn atyped module,theprogrammerannotatesimportsfrom untypedmodules withtypes,that are enforcedat runtime \nvia contracts. 1Forthe completede.nitions andproofs, seethetechnical report version of thispaper[30]. \nUnfortunately, Typed Racket does not currently support .rst-class classes and the programming patterns \nthey sup\u00adport, particularly mixins and traits. While these program\u00admingpatterns are widely used,theygreatlycomplicategrad\u00adual \ntyping.Toillustrate theproblems, wepresent a series of examplesusing(mostly)Racketsyntax.The scienti.c \nreader will easily recognize similarproblemsin relatedlanguages. 2.1 ProgrammingwithFirst-ClassClasses \nThe architectures of GUI toolkits showcase the bene.ts of OOprogramming,including the use ofdynamic class \ncom\u00adposition.Ourgoalis,however,to exposethepitfalls of mi\u00adgrating untypedOO codeto atyped world.Tothat \nend,we start with an untyped sample library for text editing wid\u00adgets andthenmigrate somethe codeto an \nevolvingexplicitly typeddialect of thelanguage. Classes in Racket The editor%2 class in .gure 2 extends \nwidget%, abase classprovidedbytheGUIlibrary.The new sub-class uses super-new to callthe constructorofwidget%. \nItde.nesthree newpublic methods:on-key forhandlingkey events, on-paint fordrawing the contents to the \nscreen, and save-.le for savingthe contents of the editor. The .rst position in the class form, which \nspeci.es the superclass, is notably not limited to names of classes. We can supply any expression aslong \nasit evaluates to a class. Thisfeature allows thede.nition ofruntime mixins. Mixins A mixin is simply \na function that take a class as an argument and subclasses it using the class form. With mixins, programmers \nmay parameterize classes over base classes and thus decouple features from speci.c points in classhierarchies.Theright-handcolumnin \n.gure2presents a sample mixin that adds simple modal editing asin vi to an arbitrary editor. 2By convention, \nclass names are suf.xed with % inRacket.  Concretely, modal-mixin adds a mode .eld that controls which \nkeybindings are active, initially set to the command mode.The mixin explicitly overrides the on-key method \nso thatitdispatcheskeyhandlingto the appropriate method.3 We can applythe mixinto create a concrete modaleditor: \n(de.nemodal-editor% (modal-mixin editor%)) Not all applications of modal-mixin tobase classes are suc\u00adcessful.For \nexample,if thebase class alreadyimplements a toggle-mode method orlacks an on-key method,then mixin applicationfails \nwith a runtime error. In other words, public method de.nitions require the absence of the method in the \nsuperclass while override de.nitions require their presence. Our type system must express these restrictions \nin order to accommodate mixins or otherdynamicpatterns of composition. Asde.ned, modal-mixin canbe applied \nto any class that lacks the method toggle-mode and has the method on-key. Thus, modal-mixin sfunctionalityis \nnottied toaparticular classhierarchyandis composable with other editorfeatures. More concretely, we can \ncompose modal-mixin with other mixins from our editor library to produce several combina\u00adtions offunctionality: \n(de.neide-editor% (modal-mixin (line-num-mixin(indent-mixin editor%)))) (de.neword-processing-editor% \n(modal-mixin (spelling-mixin (search-mixin editor%)))) In short, mixins arepolymorphic with regard to \nthe special\u00adization interface [20] that the mixin expects. With this in mind, we need to consider how \nto accommodate the pro\u00adgrammingpatterns wehavejustdiscussedin atypedsetting.  2.2 AFirstDesignforTypedFirst-ClassClasses \nFromourpreviousdiscussion,we canidentify two require\u00admentsfor atyped sisterlanguage:it must supportclasspoly\u00admorphism \nandits types must express constraints on method presence andabsence.Onepossibilityisto use atype system \nwithboundedpolymorphismand subtypingforclasstypes. This choiceisproblematic,however,because runtimeinher\u00aditance \nandsubtyping are at odds. For example, considerthis code snippet: (de.netyped-editor% (class widget% \n(super-new) (de.ne/public (on-key [key:String]):Void (case key [(\"C-x\")(do-cut)]...)) (de.ne/public (on-paint):Void \n. . .) (de.ne/public (save-.le [name :String]):Void . . .) (de.ne/private(do-cut):Void ...) ...)) 3LikeC. \n,Racket requires that override methodsbe explicitly identi.ed. It de.nes a typed variant of the editor% \nclass from .g\u00adure 2. The revised de.nition is like the untyped one but adds type annotationsto methods.Width \nsubtyping on class types allows casting a class to a narrower type, i.e., the type system can forget \nmethods or .elds. If the type sys\u00adtem allowed width subtyping on class types, typed-editor% couldbe downcast \nto T = (Class ([on-paint : (. Void)])). This is .ne for a client that uses the instances of class, as \ntheinstances wouldhavethetype(Object ([on-paint : (. Void)])) and therefore support only calls to the \non-paint method. However, inheritance is now unsound because the type systemhas noknowledge of whether \nmethods are actu\u00adallypresent or absent. Thus, the following de.nition type-checks but raises a runtime \nerrorbecause apublic methodis rede.ned: (de.ne piano% (class (castT typed-editor%);;subsumption (super-new) \n;;alreadyde.nedin superclass (de.ne/public (on-key [key:Note]) :Void (play-soundkey)))) In short, naive \nwidth subtyping for class types is unsound with respect to Racket s inheritance semantics; even for Java, \nthe naive approach wouldfailbecause a subclass may override a method with adifferenttype. Row polymorphism \nAnotherpossibilityisto repurposerow polymorphism [36], studied in the context of type infer\u00adencefor objects[26,36], \nobject calculi[10], and extensible records[13,18].Functions over extensible records also re\u00adquirepolymorphismoverrowmemberswith \nconstraintson thepresence or absence of members.Unlike subtyping, row polymorphismprohibitsforgetting \nclass members.Instead, rowpolymorphismforclasses abstractsoverthefeaturesof a class type both method \nsignatures and types of .elds using constraints on row variables to express absence and row signaturesto \nexpresspresence. With row polymorphic types, the type of modal-mixin from .gure2 couldbewrittenasfollows: \n(.(r/ on-keytoggle-mode)) ((Class([on-key : (String.Void)]|r)) . (Class ([toggle-mode : (.Void)] [on-key \n: (String.Void)]|r))))]) The mixin s type is given as a function type that is poly\u00admorphic in a row \nvariable r, which, in turn, is constrained to lack on-key and toggle-mode members.Theseparticular constraints \nare neededbecause r is aplaceholderforthe rest ofthe methodsor .elds, whichshouldcontainneither on-key \nnor toggle-mode.If r has anon-key method,it con.icts with on-key in the argumentclass that the mixin \noverrides.Since  Transparent Opaque Sealing Figure3. Kinds ofclass contracts modal-mixin adds toggle-mode \ntoitsbase class, whosetype contains r, the row variable r must alsolack toggle-mode. Row variables are \ninstantiated like ordinary type vari\u00adables.Applying a row abstractionto a concrete row type re\u00adquires \nthat the row satis.es the constraints on the variable. Thus, the variable r abovecanbeinstantiated with \nthe con\u00adcrete row([on-paint : (.Void)][insert: (String.Void)]) but not with the row([on-key : (String \n. Void)])ora row that containsthis signature,duetothe constraints on on-key. By using row polymorphism, \nwe make a tradeoff with subtyping.Class abstractionsspecifypolymorphismexplic\u00aditly in their type, rather \nthan allowing the use of the sub\u00adsumption rule. That is, we shift the burden of typing to the implementor \nof a mixin. This does not complicate the ap\u00adplication of mixins because,inpractice, type application \nof rows canbeinferred[35].In contrast, our type system does allow width subtyping on the types of objects, \nsince objects inRacket cannotbe extended after creation. In other words, our approachispay-as-you-go.Program\u00admers \nneedtobe awareofrowpolymorphismonlywhendeal\u00ading with abstractions that are not provided in most typed \nobject-orientedlanguages, such as mixins.Meanwhile,pro\u00adgrammers neednot consider rowpolymorphism whendeal\u00adingwithobjects,andcaninsteadreasonabouttheirprograms \nusingfamiliar subtyping rules.  2.3 ProtectingTypedCodefromUntypedCode Types are only half of the gradual \ntyping story. Runtime monitoring oftype systeminvariantsis the otherhalf, which wehandle withhigher-order \ncontracts[9,29]in the style of Tobin-Hochstadt andFelleisen[32].Every typefor a class becomesarun-timecontract \nattheboundary whereit .ows from a typedmodule to an untyped module or vice versa.A contract for .rst-class \nclasses speci.es clauses that protect methods and .elds of the contracted class. Class contracts are \nspeci.edseparatelyfromthede.nition ofthe class, since classes are values and are notde.nedin a statichierarchy. \nOur contract-basedapproachdoes not scale smoothlybe\u00adcause we wish to formulate types that are polymorphic \nin method and .eld clauses. Figure 3 presents illustrative di\u00adagrams for three different ways of dealing \nwith methods or .elds not included in a class contract. Strickland and Felleisen s contracts [29] are \ntransparent: they allow un\u00admentionedmethodsor .eldstopassthroughwithout any en-forcement.Ourdesign requirestwo \nadditional mechanisms forhandling unmentionedbehaviorin ordertofullyprotect typed code: opaque class \ncontracts and sealing class con\u00adtracts. Opaquecontractsdisallow any unmentionedbehavior byraising a contract \nerror at theboundary. Sealingcontracts allow unmentioned behavior to pass through the boundary butrequire \na matching unsealingto accessit. Opaque contracts Supposeweimportthe editorfunctional\u00adityfromthe untypedmodulein \n.gure2intothe nearbytyped module typed-editor.rkt. Note that we use a double border to distinguish typed \nmodules from untyped ones. Since the editor class is untyped, we must specify an import type for the \nclass sothatTypedRacket cantype checkits uses.The given class type speci.es the signatures of the individual \nmethods.Toprotectthisimport, a naturalchoice wouldbeto translatethetypeintoa class contractthatchecksmatching \npredicates.Unfortunately,the existingclass contractsimple\u00adment transparent behavior, i.e., they require \nthat the meth\u00adods mentioned in the contract have the speci.ed behaviors butmake noguarantees about any \nunspeci.ed methods. Hence, transparent contracts cannot protect typed code properly,eveninthis simple \ncase.Recallthat editor% in .g\u00adure 2 implements a method that is absent from its import type, namely save-.le, \nand thus its corresponding transpar\u00adentimport contractallowsthe methodtopassthrough.Inthe code fragment \nlabeled \"typed-editor.rkt\" (continued), this would resultin a name con.ictin the typed modulebecause \nthe type system does not know that editor% provides save\u00ad.le.Thatis, the code would type-checkbut signal \na runtime error blaming the typed module for an error that the type system seemingly ruled out.  Sealing \ncontracts For everyfeaturein our type system, we need a corresponding feature in the contract system \nto en\u00adforceitsinvariantsat runtime.Thus,weneed someformof parametric contracttoprotectrowpolymorphicfunctions \non classes. Consider what happens when an untyped mixin is imported into the typed module \"typed-modal.rkt\" \nbelow. This moduleimportsmodal-mixin from .gure2with apara\u00admetric type and calls the mixin on the editor% \nclass from \"typed-editor.rkt\".Assuming modal-mixin isde.nedprop\u00aderly, no runtime error canblame the typed \nmodule. Suppose,however,thattheprogrammerwho wrote \"ed\u00aditor.rkt\" adds anotherpublic method to modal-mixin, \nas in the revised version of \"editor.rkt\". Even if the creator of typed-modal.rktdoes notadaptthetypetothe \nnew situation, our system must discover the additional method and signal a violation otherwise the type \nsystem would be unsound. Oneapparentoptionisto mapthetypeto anopaquecontract, whichprohibitsthe .owof \nmodal-mixin across the module boundary. Unfortunately, opaque contracts would also rule out the application \nof the correct version of modal-mixin to abase class with methods other than on-key. Instead, we introduce \nand use sealing contracts, which prevent the addition or use of sealed methods until a cor\u00adresponding \nunsealing contract is applied. Sealing contracts use unforgeablekeysgenerated at run-timetoprevent unau\u00adthorizedaccess.Thisprevents \nmodal-mixin from addingun\u00adspeci.ed methodsbut allows unspeci.ed methodsfromthe baseclassto .owthroughmixinapplication.Inotherwords, \nsealing contracts for mixin types re.ect their key feature, polymorphism overbase types. Metaphorically \nspeaking, sealing contracts establish a private channel through one component to another. We use such \na channel to send a typed class through an untyped mixin, ensuring that the mixin cannot tamper with \nthe pro\u00adtected names of the class en route. A sealing contract at a negative position (e.g., function \nargument) establishes an entrancetothe channel.Dually,a contractin apositivepo\u00adsition(e.g.,functionresult) \nestablishes an exit.The endsof the channel arelocked with unforgeablekeys, allowing only authorized codeto \nsend and receive values on the channel. Our system seals classes because class types are poly-morphic.Classes \nthatpass through sealing contracts are not completelyinaccessible,however.Instead, sealingis applied \nat the granularity of class members such as methods and .elds. Attempts to invoke a sealed method name, \naccess a sealed .eld name, or extend a class using a sealed name all failwith a contracterror.In contrast, \nsealing contractsdo not impose anyaccesslimitations on exposed methods.This es\u00adtablishesthe connectionwithrowpolymorphism:classtypes \nallowthe useof concretemembersatthespeci.ed typebut disallow the use ofabstract membersfrom a row variable. \nLike most OO languages, Racket also contains stateful operations.Ingeneral,the combination ofpolymorphic \ncon\u00adtracts and state requires some care to ensure soundness. In particular, the precise timing for key \ngeneration on seals is crucial. One choice is to generate keys for seals when a contractis applied, e.g., \nwhen an untyped valueis imported into atyped module.For example,considerthe situationin .gure 4a. The \n\"state.rkt\" module exports state-mixin and \"broken-client.rkt\" imports the mixin with a type that sug\u00adgestsitis \ntheidentityfunction on classes.Supposethatkeys for seals are generated once as the mixin is imported. \nThe .rst time that state-mixin is called, editor% is sealed on en\u00ad  (a)Misuseofstate (b)Invalidmethodinvocation \nFigure4. Potentialviolations of soundness via mixins try to the mixin and unsealed on exit. Sending the \non-key messageisthus acceptable, and no contract errorsare raised. The next line is a call to state-mixin, \nperhaps formu\u00adlated under the assumption that it behaves like the identity function a possibility suggested \nby its row-polymorphic type. This time, the mixin is applied to modal-editor%, which is sealed with the \nsame key as editor%. This allows state-mixin to return editor% without triggering a contract error, and \nthat cause the method missing error for toggle\u00admode. In short, even though the code type-checked in our \nimaginarytype system,it caused a run-timetype error. To be sound, our system must generate these seals \nat eachmixin invocation.This ensuresthat editor% and modal\u00adeditor% are sealed with distinct unforgeable \nkeys and that the second call to state-mixin signals a contract error. Object contracts are like class \ncontracts, except that they transparentlyprotectparticularinstances.Since objecttypes offer width subtyping, \ncontracts on objects need not enforce thekind of opacity that class contracts enforce.  2.4 Accessrestrictionsformethodinvocation \nWhile opaque contracts ensures that untyped code cannot access methods unlisted in interfaces, dynamic \nuses of in\u00adheritance(e.g., mixins ortraits) create apotentialholein this protection. Consider the example \nin .gure 4b. An un\u00adtyped mixin imported into the \"search-client.rkt\" module typed  untyped  Figure5. \nAsnapshot of the classhierarchy after unsealing has a methodsearch that assumesthe existence of a save-.le \nmethodinitsbase class.Moreover, search provides afaulty argumentto save-.le.When search isinvokedon aninstance \nof searchable%, an error occursdue to thatfaulty argument. Sincethetypegiveninthe client moduledoes notmention \nsave-.le and the class is unsealed by the time it is instan\u00adtiated, sealing contracts do not catch this \nfaulty method in\u00advocation. That is, a method invocation from untyped code to typed code can be unsafe \nand must be rejected unless a contractprotects the method.  e ::= v | x | (e e) | op(e) | if e e e | \nsend(e, m, e) | iget(f* , e) | iset!(f* , e, e) | new(e) (expressions) | mon l,l l (c, e) | class(e){f \n:= v mpx.e mox.e} op ::= num? | bool? (primitives) v ::= #t | #f | n | cv | o | .x.e (values) cv ::= \nobject% | class/v.(cv){(f,v) mx.e} (class values) o ::= object/v(cv){(f,a)} (objects) f* ::= f | a (.eldterms) \nx . Var (variables) f . Field (.elds) m . Method (methodnames) a . Location (locations) l,j,k . Label \n(contract labels) Figure 6. UntypedExpressions To prevent faulty access via mixins, we require method \ncalls todispatch to either a methodde.ned within the same component or a contracted method.Thatis,if \nuntyped code invokes a method that is not protected by a contract, its de.nition must reside in untyped \ncode as well. The same condition applies to typed code. Figure 5 illustrates this restriction graphically. \nThe dia\u00adgramshowsthe objectinteractionsestablishedbythe codein .gure4b.Therearetwo relevantcomponenttransitionshere: \none between the editor% class and the mixin from the un\u00adtyped component, and one between searchable% \ncreated by the mixin and its use in the typed component. A con\u00adtract protects both boundaries, but the \ninner contract disal\u00adlows the call to save-.le because the contract speci.cation does notincludethatmethod. \nThe problem with cross-boundaries access was discov\u00aderedduring a .rst,failed attempttoestablish thesoundness \nof our type systemdesign.Conversely,thefailure suggested this constraint on protected method calls. Fortunately, \nthis constraintdoesnotreducetheexpressivenessofpurelytyped or untyped code, but it requires that invocations \nthat trans\u00adfercontrolfromtyped to untyped code(and viceversa) are properlymonitoredby the contract system. \n3. FormalizingTypedFirst-ClassClasses Our examples have exposed thorny problems about pro\u00adgramsthatusedynamic \nclass composition acrossthebound\u00adary between typed and untyped components. To communi\u00adcate our solution, \nwe present a formal model of gradually\u00adtypeddynamic class composition.The modelisboth a vehi\u00adclefor a \ncompactpresentation of ourdesign and aplatform for proving its soundness. We consider type soundness \nthe baseline property of any type system, to be preserved even whentyped components arelinked with untyped \ncode. 3.1 Syntax Ourlanguage, calledTFCC, allows the embeddingof typed terms in untyped terms and vice \nversa. The interactions between them are mediated by monitors with contracts. A monitored term can be \nthought of as a server module that exports services toits context,i.e.,its client(s).This section starts \nwith a look at the untyped portion of the language (.gure6)andthenproceedsto the typedportion(.gure7). \nExpressions include values, variables, applications, primi\u00adtive operations, conditionals, method invocation, \nobject in\u00adstantiation, .eld mutation, contract monitors, and classes. The set of values includesbooleans,numbers,class \nvalues, objects, and .-abstractions.Methodinvocationsare written send(e0 , m, e1 ) where e0 is the receiver, \nm the method name, and e1 the argumentto the method. The expression class(e){f := vmpx.ep mox.eo} consists \nof a superclass expression e, .eld names f paired with correspondinginitial values, andde.nitions of \npublic methods mp and override methods mo.Ifthe superclass ex\u00adpression evaluates to a suitable value, \na class reduces to a class value class/v with a unique key . that is used for method dispatch. The term \nobject% represents the root of the classhierarchy.Fielddeclarationsproduce mutablelocal .elds, which \nare only accessiblefrom within methodbodies. We include state so that the calculus can express examples \nthat introduce potential unsoundness in the absence of ap\u00adpropriatedynamic sealing, as explainedin section2. \nState Fields make objects stateful. The iget and iset! expressions,respectively,get and set .eld valueslocally. \nTypes include Int and Bool plus function types. An object or class type consists of rows,describing method \nsignatures.  s ::= t | .(.\\m).t (type schemes) t ::= Int | Bool | Class er | Object r | t . t (types) \nr ::= {(m : t)} (rows) er ::= r | {(m : t)|.} (extendedrows) et ::=(et et) | x | op(et) | if et et et \n| .(.\\m). et | et [r] | send(et, m, et) (typedexpressions) ** l,l | iget(f, et) | iset!(f, et, et) | \nnew(et) | mon (c, e) l | class(et){f : t := vt mp(x : t): tet mo(x : t): tet} vt ::= #t | #f | n | cvt \n| ot | .(x : t)et (typedvalues) . cv ::= object% | class/v(cvt){(f,t,vt) mp(x : t): tet mo(x : t): tet} \n(typedclass values) o ::= object/v(cvt){(f,t,a)} (typedobjects) Figure7. TypedExpressions For example, \n{(on-key : t1 ),(on-paint : t2 )} is a row with labels on-key and on-paint and types t1 and t2 . Rows \nin class types may be extended with a row variable as in {(on-key : t1 ),(on-paint : t2 ) | .}. With \nr1 . r2 , we concatenatetwo rows. Typed expressions require type annotations for all variable declarations.Since \nwe abstractover rows, we alsohave type abstractions .(.\\m). et and type applications et [r]. Untyped-Typed \nInteraction A monitor mon k,l (c, e) sepa\u00ad j rates aprograminto components[5],i.e., e and the context \nof mon, mediatedby the contract c.The superscriptlabels k and l name the server and client components \nrespectively. The label j names the contract c. In our model, monitors playonlyone role.Theymediatebetweentypedanduntyped \ncomponents.Henceit suf.ces to usejust twolabels,instead of uniquelabelsper components: u for untyped,t \nfortyped. Our reduction semantics models exchanges of valuesbe\u00adtween components with substitutions of \nmonitored values, which embeds typed values within untyped code and vice versa. A typed-in-untyped embedding \nis valid if the moni\u00adtor s contractis relatedto thetype of the embeddedterm; an untyped-in-typedembeddingis \nvalidifit type-checksin the typed context with the contractinterpretedas a type.Thebi\u00adjectivefunctionT[],de.nedin \n.gure9,speci.esthenatural correspondencebetween contracts andtypes. Contracts check type-likepropertiesat \nruntime.In contrast to Eiffel, our higher-order contracts describe the behaviors of entire objects,includingtheir \nmethods[9,29]. The model s contractlanguageincludes .at orpredicate contracts, function contracts, class \ncontracts, and contracts forparametricfunctions.Figure8presentsthe syntaxofcon\u00adtracts in two parts: pre-contracts \nare surface syntax, which are elaboratedinto (core)contracts. c ::= flat(op) | c _. c (pre-contracts) \n | .c (.\\m).(c _. c) | class/c([mc _. c]) * | class/c (.,[mc _. c]) | object/c([mc_. c]) e ::= ... | \nblamel (expressions) l c ::= flat(op) | c _. c (core contracts) | .c (.\\m).(c _. c) | class/c([mc _. \nc]) | seal/c([mc _. c],m,.) | unseal/c([mc _. c],.) | object/c([mc _. c]) . ::= . | . (keyterms) . . \nKey (keys) v ::= ... | .Gl,l (.\\m).(c _. c){v} (values) l cv ::= ... | Gl,l {cv,(mc _. c)} (class values) \nl | SGl,l {cv,m,.} l k,l o ::= ... | OG{o,[mc _. c]} (objects) j Figure8. Contracts andguards Class contracts \ncomeintwo varieties: opaque and sealing. The former differs from transparent class contracts[29] in that \nthey enforce the absence of methods not mentioned in a contract. This feature of class/censures that \ntyped modules can safelyimport classesfrom untyped modules. * Sealing contracts class/c have meaning \nonly within a rowpolymorphic contract.They are usedto specify whether agiven contractposition shouldbepolymorphic.For \na nega\u00adtiveposition, an elaborationfrompre-contractsto core con\u00ad * tracts translates class/c to a sealing \ncontract seal/c; it becomes an unseal/c contractin apositiveposition.Both seal/c and unseal/c contain \n., whichis either a variable or a key for unlockingseals.4 4The variable case is required by our choice \nof semantics and occurs only inintermediate reduction steps.  The runtime syntax alsoincludesguards.Guards \nactlike contract monitors but, unlike monitors, are values. Since guardsare values,theycanpassthroughcontractboundaries. \nk,l Theparametricguard.Gj (.\\m).(c _. c){v}behaveslike afunction.When applied,itgenerates afresh sealkeyforits \ncontract.This ensuresthatkeys cannotbeforgedusing state, as explainedin section2.3. Since contract checking \nfor a class is delayed until its k,l methods areinvoked, we use Gj {cv,(mc _. c)}to retain the contracts \nin the class hierarchy. Similarly, the sealing l,k guard SGj {cv,[mc1 _. c2 ],m ',.}wraps a class cv \nin or\u00adder to retain seals untilthey are checked. T[flat(int?)] = Int T[flat(bool?)] = Bool T[c1 _. c2 \n] = T[c1 ] . T[c2 ] T[.c (.\\m).(c1 _. c2 )] = ..\\m.T[c1 _. c2 ] T[class/c([mc1 _. c2 ])] = Class{(m \n: T[c1 _. c2 ])} T[seal/c([mc1 _. c2 ],m,.)] = Class{(m : T[c1 _. c2 ])|.} T[unseal/c([mc1 _. c2 ],.)] \n= Class{(m : T[c1 _. c2 ])|.} T[object/c([mc1 _. c2 ])] = Object{(m : T[c1 _. c2 ])} Figure9. Type-contractcorrespondence \n 3.2 TypeSystem Thetype systemisbasedon atyped .-calculus with subtyp\u00ading,limitedmutable variables, \nobject types, and class types. Theimportanttypingrulesareshownin .gure10.Therules use ajudgement G|S \n. e : t that states that a term e has type t assumingfree variables are typedin Gand storeloca\u00adtions \nin S. Store typings are used to type-check operations ontheprivate .eldsof objects. Row abstractions \nare checked using T-ROWABS. Appli\u00adcations of abstractionsto rows (T-ROWAPP)requirethat the providedrow \nmatchesthe absencelabels onthe abstraction s boundvariable using the G . .\\m judgement. Theinterestingtypingrules \nare thoseinvolving class and object types. A class is well-typed (T-CLASS)if its super\u00adclassis a valid \nclass and allows extension withthe new pub\u00adlic and override methods.These conditionsare ensuredby thejudgementsthat \na rowlacksa member, G . er\\m, and that a row has a member, G . m . er. If the superclass type contains \na row variable,then all methods mustbe com\u00adpatible with the absence labels on the variable. Fields and \nmethods must all be well-typed in the usual sense. Method bodies are checked under the assumption that \nthe receiver hastypeObject R[er], where R[er] denotesthe class s row butwithout the row variableif er \ncontains one. Object instantiation (T-NEW) requires that the instanti\u00adated class has a concrete type, \ni.e., any type variables have beeninstantiated.Methodinvocationis checkedbyT-SEND. Since objects have \nconcrete rows, an object type is a subtype of another if the corresponding rows are subtypes viathe standard \nwidth subtypingrule.5Meanwhile,there are no subtyping rules for classes because row polymorphism replaces \nsubtypingfor classes, asdetailedin section2. We defer rules for interactions between typed and un\u00adtyped \ncode to section 4.3, where we explain the soundness theoremfor mixedtypeprograms.  3.3 OperationalSemantics \nOur operational semantics uses context-sensitive reduction rules[7].Figure12presentsthe evaluationcontextsforour \nlanguage and lists the reduction rules, which in turn rely on the metafunctions de.ned in .gure 13. The \nre.exive\u00adtransitive closure ofthe reductionsdeterminesthe evaluation function. We .rst explainthesemanticsof \nthebaselanguagewith\u00adout contracts and thenincrementallyintroduce the casesfor contract monitoring.The \ntypedlanguagehasthe exact same semantics as the untyped one. For some purposes, we as\u00adsumethatthetypes \nare .rst strippedfromtypedexpressions; in other cases, we assume that the reduction system carries typeinformation \nwithout usingit. The reduction rules in .gure 11 de.ne the conventional behavior of .-expressions,primitives,and \nconditionals; we omit the obviousde.nition of d.The semantics of.rst-class classes is straightforward \nas well. The evaluation contexts ensurethat class expressions reduceonly afterthe superclass expressions \nare reduced to values. A class successfully re\u00adducesto a value(CLASS)whenall ofits override methods arepresentin \nthe superclass andits public methods absent. Method invocation (SEND) triggers only if the given method \nm is present in the class hierarchy of the receiving object.Therulerelies ona metafunctiontolook up thetar\u00adgetmethodin \nthe classhierarchy of the receiver object.The Pull functiontraverses thehierarchytolocate the method. \nThe rulesfor state are conventional.Creating a new ob\u00adject from a class (NEW) chooses unallocated addresses \nin the store and reduces to an object value. Similarly, getting and setting .elds(GET,SET)justinvolveslookingup \nand replacing valuesin the store. Figure 12 introduces contract monitoring. Since reduc\u00adtions may resultin \ncontractviolations,reductionsmaypro\u00adduce the error term blamelj that pinpoints the misbehaving 5Depth \nsubtyping isomittedforsimplicity,but weconjecturethatitsaddi\u00adtionposes noproblems.  G|S . e : t T-ROWABS \nT-ROWAPP G,(.\\m)|S . e : t G|S . e : .(.\\m).t G . r\\m G|S ..(.\\m). e : .(.\\m).t G|S . e [r]:[r/.]t T-SEND \nG|S . e0 : Object r T-NEW T-ROOT (m : t1 . t2 ). r G|S .e1 : t3 t3 <: t1 G|S .e : Class r G|S . object% \n: Class{} G|S . send(e0 , m, e1 ): t2 G|S .new(e): Object r T-OBJECT G|S . cv : Class r .i,S(ai)= ti \nG|S .object/v(cv){(fi,ti,ai)}: Object r T-CLASS p o G|S .es : Class ers G . ers\\mi G .mi . ers pp G,this \n: tobj,x: tp f : tf |S . e: tp i 1i i 2i oo G,this : tobj,xi : to ,f : tf |S . ei : to 1i 2i G . vfi \n: tfi er = ers .{(mp : t1 p . t2 p)} tobj = Object R[er] G .class(es){f : tf := vf mp(xp : tp): tp ep \nmo(xo : to): to eo}: Class er 12 12 Figure10. Selectedtype rules E ::=[] | (E e) | (vE) | op(E) | if \nE ee | send(E, m, e) | send(v, m,E) | iget.(f*,E) l,l * | iset!.(f*, E, e) | iset!.(f, e,E) | new(E) \n| mon (c, E) | class(E){f := v mx.e mx.e} l ),S]\u00b7\u00b7\u00b7 [E(.. ),S]\u00b7\u00b7\u00b7 [E( (.x.e v) \u00b7 [v/x]e BETA op(v) \u00b7 \nd(op,v) DELTA if #t e2 e3 \u00b7 e2 IFTRUE if #f e2 e3 \u00b7 e3 IFFALSE class(cv){f := v mpxp. ep moxo . eo} \n. ifmp nMethods(cv)= \u00d8and mo . Exposed(cv) class/v.(cv){(f,v) mx.e} CLASS and where . is freshand mx.e \n= mpxp. [D/id.]ep .moxo . [D/id.]eo send(o, m, v) . ([this/eo,a/f] e v) SEND ifm . Methods(o) and where \ne = Pull(o,m)and (f,a,.)= ObjectFields(o) (E[new(cv)],S) \u00b7(E[object/v(cv){(f,a,.)}],[v/a]S) NEW where \n(f,v,.)= Fields(cv)with a ndom(S)= \u00d8 (E[iget.(a, o)],S) \u00b7(E[v],S) GET if(f,a,.). ObjectFields(o)and where \nv = S(a) (E[iset!.(a, o, v)],S) \u00b7(E[v],S [a/v]) SET if(f,a,.). ObjectFields(o) Figure11. Reductionsfor \nthebaselanguage component l as violating contract j. Blame is propagated through all evaluation contexts. \nContracts control how monitors behave. Depending on the kind of contract, monitors reduce to additional \nmoni\u00adtors orguards, whichimmediately check the contract orde\u00adlaycheckinginhigher-order cases.Whenimmediate \nchecks fail, contracted values reduce to contract errors, blaming a speci.c component l for violatingsome \n.xed contract j. The reduction rules for monitors deserve special atten\u00adtion. Monitoring an immediate \ncontract reduces to a condi\u00adtional expression(FLATC).If thepredicatefails, a contract erroris signalled.A \nmonitorfor afunction contract reduces to a wrapped function (FUNC), which monitors argument and result \ncontracts with appropriateblame[9]. Monitorswith class or object contracts reducetoguards that wrap the \nappropriate classes or objects for higher\u00adorder contract checking[29].Since our class contracts are opaque, \nthey enforce the additional constraint that the con\u00adtractedmethods arethe actual methods oftheprotectedclass \n(CLASSC).This constraintprotects againsttheinvocation of unspeci.ed methods, which would otherwise violate \nsafety as illustrated with the \"typed-editor.rkt\" example in sec\u00adtion2.3.Similarly, object contracts \nensurethattheprotected object actuallyhas the contracted methods (OBJECTC). When monitors create guards, \nthe latter track the con\u00adtracts that need to be carried along for method invocation. Thus, the Pull metafunction \ndelivers more than a method de.nition.Whenlookingup a method, Pull attaches the ap\u00adpropriate contracts \nto the method as they are discovered in the classhierarchy.If Pull succeeds, the call reduces to the \nwrapped expression appliedto the argument value. Two other details are necessary to understand method \ninvocation. The receiver of a method call (i.e., this) is wrapped in contracts found between the method \nde.nition andthe callerby ProtectThis.Doing so ensuresthatdynam\u00adically dispatched calls areprotected \nwith the expected con\u00adtracts. Furthermore, the semantics also ensures that meth\u00adods canbeinvoked onlyifboththe \ncaller and method arein the same component. This prevents a mixin from invoking a method without protection, \npreventing the faulty invoca\u00adtion from the search-mixin examplein section2.3.In other words, all method \ninvocation must either be dispatched lo\u00adcally or through a contract monitor. The remainingcontractformstracksealing \nand unsealing of methods in order to ensure sound interactions between typed and untyped code in the \npresence of functions that manipulate classes. Such a function must be monitored by aparametric contract, \nwhich reducesto aparametricguard (.C).Theguardbehaveslike afunction,butwith additional monitoring(.G-APP).An \napplication oftheguardresultsin the generation of a seal key .. It is crucial, as we demon\u00adstrated through \nthe broken-mixin in subsection2.3,that ev\u00adery applicationis sealed separatelyin ordertopreventviola\u00adtions \nof rowparametricitydue to state. Thecontractscontainedinaparametriccontractareeither sealingor unsealingcontracts.A \nsealingcontractchecksthat all of the contracted methods are present in the class and reducesto a sealguard.Similarly, \nan unseal contractreduces to an unsealed classprotected with aguard. The semantics of sealing requires \nadditional side condi\u00adtions for the class and method invocation cases. For class expressions, the semantics \nrequires that none of the public or override methods are sealedin the superclass. Let usillustrate the \noperational semantics of sealing with a sample reduction sequence based on the example in .g\u00adure4b.In \nthat example, a typedprograminvokes the search method on an object whose class was constructedbythe ap\u00adplication \nofan untypedbut monitored mixin: c = mon u,t (ctc, mixin)editor % j e = send(new(c),s,\"x\") mixin = .c. \nclass(c){s x.send(this, sf, 0) -}) ctc = .c (.\\-).(seal/c([-],\u00d8,.)) _. unseal/c([s sctc],.) where sctc \n= flat(string?)_. flat(void?) The mon term monitors the module import that embeds the mixinintoits useinthetypedcomponentwitha \ncontract ctc. The modelencodesthe untyped mixinfromthat example as afunctionfrom class c to an extension \nwith method s short for search. The contract ctc corresponds to the type in the example where sctc is \nthe correspondingcontractfor s. The monitored mixin is applied to the editor % class, meaningthe reduction \nstartsfromthis evaluation context: send(new([]editor %),s,\"x\") First the monitor itself reduces to a \nguarded function that installs a sealing contract on application. Next we reduce the application oftheguarded \nmixinto the editor %, sealing editor % asitis substitutedin the mixin sbody. Hereistheresultof these \n.rstfewreductionsteps: u,t mon j (unseal/c([s sctc],.), t,u class/v(SGj {editor %,[-],\u00d8,.}) {sc x.send(this, \nsave-file, 0) -}) The superclass of the class value is a sealed version of the editor % class; the unsealing \ncontract remains. The unsealingyields aguardedclass: u,t u,t Gj {class/v(Gj {editor %,[-]}){ sc x.send(this, \nsf, 0)}, [s sctc]} Finally, this guarded class is instantiated as an object containingthe class.At thispoint, \nthe methodinvocation of s is evaluated, whichsets up thebody of s as the redex.The body, in turn, calls \nthe sf method. This method invocation  (E[blamekj],S)(blamekj,S) (E[\u00b7\u00b7\u00b7 ],S)(E[\u00b7\u00b7\u00b7 ],S) ..  ..  . \n class(cv){f := vmpxp. ep moxo . eo} . class/v(cv){(f,v) mx.e} CLASS ifmp nMethods(cv)= \u00d8, mo . Exposed(cv), \nmp . NotSealed(cv) . [D/id.]ep .. [D/id.]eo and where . isfreshand mx.e = mpxpmoxo class(cv){f := vmpxp. \nep moxo . eo}\u00b7 blamelj CLASSERR p o ifHasBarrier(cv,m), mnMethods(cv)= \u00d8, m. Methods(cv) ii and where \nm = mp .mo and (l,j)= LocateBarrier(cv,m) [] send(o, m, v) . (this/eo,a/fe v) SEND ifm . Methods(o)and \nSameOwner(o,m,.,.) and where e = Pull(|o|l,m), eo = ProtectThis(|o|l,m,|o|l), and (f,a,.)= ObjectFields(o) \n send(o, m, v) . blamekj SENDERR ifm . Methods(o), and not SameOwner(o,m,.,.) and where (k,j)= OwnerLimit(o,m,.,.,.) \nmon k,l j (flat(op), v) mon k,l j (c1 _. c2 , v) \u00b7 \u00b7 if op(v)v blamek j .x.mon k,l j (c2 , (v mon l,k \nj (c1 , x))) FLATC FUNC mon k,l j (class/c ([m c1 _. c2 ]), cv) \u00b7 Gk,l j {cv,[m c1 _. c2 ]} CLASSC ifm \n= Exposed(cv) mon k,l j (class/c ([m c1 _. c2 ]), cv) \u00b7 blamek j CLASSCERR ifm .= Exposed(cv) mon k,l \nj (object/c([m c1 _. c2 ]), o) \u00b7 OGk,l j {o,[m c1 _. c2 ]} OBJECTC ifmi . Exposed(o) mon k,l j (object/c([m \nc1 _. c2 ]), o) \u00b7 blamek j OBJECTCERR ifm .. Exposed(o) mon k,l j (seal/c([m c1 _. c2 ],m ',.), cv) \u00b7 \nSGl,k j {cv,[m c1 _. c2 ],m ',.} SEALC ifmi . Exposed(cv)and m '\\m nExposed(cv)= \u00d8 mon k,l j (seal/c([m \nc1 _. c2 ],m ',.), cv) \u00b7 blamek j SEALCERR ifmi .. Exposed(cv)or m ' \\m . Exposed(cv) mon k,l j (unseal/c([m \nc1 _. c2 ],.).., cv) \u00b7 Gk,l j {Unseal(cv,.),[m c1 _. c2 ]} UNSEALC ifSealed(cv,.)and mi . Exposed(cv) \nmon k,l j (unseal/c([m c1 _. c2 ],.).., cv) \u00b7 blamek j UNSEALCERR ifnot Sealed(cv,.)or mi .. Exposed(cv) \nmon k,l j (.c (.\\m).(c1 _. c2 ), v) \u00b7 .Gk,l j (.\\m).(c1 _. c2 ){v} .C (e v) \u00b7 where e = .Gk,l j (.\\m).(c1 \n_. c2 ){v1 }and . is fresh. (mon k,l j (c1 _. c2 [./.], v1 )v) .G-APP Figure 12. Reductions for monitoredterms \n name domain,range/purpose HasBarrier o or cv, m _. #t or #f checks if some m is inaccessible due to \na guard. LocateBarrier o or cv, m _. (l, l) returns the blame labels for the closest inaccessible m in \nthe objector class hierarchy. SameOwner o or cv, l or ., l or ._. #t or #f checks if m is ownedbythe \ncalling context OwnerLimit o or cv, l or ., l or ., l or ._. (l, l) returns the label ofthe calling context \nof m and ofthe contractboundarywhere ownership of m was lost Pull cv, m _. e returns m simplementation \nas a .-term wrapped with the necessary contracts ProtectThis o, m, o _. o traversesthe .rst object anditshierarchytoapply \nall contractsneededtoprotectthesecond object when itis a receiver ofa call to m Sealed cv, . _. #t or \n#f checksif cv contains a sealguardthatislocked with .. Unseal cv, . _. cv removes sealguardslocked \nwith . in the classhierarchy. Notsealed o or cv _. m returns unsealed methodsin thehierarchy. Exposed \ncv _. m returns all the exposed method namesin thehierarchy Methods o or cv _. m returns method namesin \nthehierarchy. Fields cv _. (f,v,.) returnsthe .elds initial valuesintheclasshierarchy. ObjectFields \no _. (f,a,.) returnstheobject s .eld values Figure13. Metafunctionsarede.nedinductivelyonthestructureof \nthe .rst argument triggers the SameOwner metafunction with the sf method as an argument.This metafunctionfailsbecause \nthe method lacks a contract between the method s invocation on this andtheimplementationinthe editor \n%classinthehierarchy. Thus,the .nalresultis blameuj as expected. 4. TypeSoundnessfor MixedPrograms Type \nsoundness establishes a minimallogicalstandardfor a programming language. In this section, we use the \nformal model to prove that our design meets this criterion. Our proofof soundness requires two steps.First, \nwe mustprove that the type system is sound with respect to the execution of typed programs. Second, we \nmust show that mixing in untyped components does not violate the invariants of the typed components. \nThat is, the interpretation of types as contracts at component boundaries must prevent any type\u00adlike \nruntime error assignableto typedcomponents. Fortheproofofsoundness, we employthe usualprogress andpreservationtechnique[37].For \nthe soundness of types as contracts, we show that the contract systemis a complete monitor [6], meaning \ncomponents do not export their val\u00adues without appropriatecontractprotection.Based onthese two major \nsteps, we .nally show that typed components of mixed-typeprograms cannotbe blamedfor violations of typeinvariants. \n 4.1 Type soundness The reduction relation we usefor typedtermsis the relation for untyped terms in .gure \n12 except that the reductions carry along type annotations.Type applications are reduced analogous to \nfunction application, but types do not affect reductionsin any other way. Inthis setting,typedprogramscannotgo \nwrong,inpar\u00adticular they cannot call unde.ned methods. Lemma 1. (Type Soundness)For all et, if \u00d8|\u00d8 . \net : t, either for all e1 (e1 ,S1 ), there exists an *. . \u00d8) ,te(that such or, )e2,S 2.( . )e2 such \nthat (e1,S 1 ' and Sforsome t:tv.S\u00d8|where ),Stv(*. . \u00d8) ,te( ' \u00d8|S ' . S ' and t<: t.  G;l le Wellformedprograms \n D;k;l.c Wellformedsource contracts K;G;S;l le Wellformedterms Kk,l ;D;k;l.c Wellformedcontracts K l \nS~ S Wellformedstores Figure14. RelationsforWellFormedPrograms Recall from section3 that G|S . S says \nstore S is typable under Gand S.As mentioned,thetheorem requirestwo con\u00adventionallemmas:progress andpreservation.The \nstatement ofboth calls for a typingjudgment applicable to intermedi\u00adate states,i.e., states with non-emptystoresforprivate \n.elds. Other than that, thedetails are straightforwardand omitted.  4.2 Complete monitoring Complete \nmonitoring[6]is aformalcriterionforthe correct design of a contract system. It imposes two conditions \non a correct contract system: complete mediation and correct blame assignment. Complete mediation requires \nthat the contract system does not allow values to pass between components without a contract check possibly \nthe always-true contracts where contract monitors act as component boundaries. Put differ\u00adently,at anypointintime \nevery valueis ownedby one and only one component.Intuitively, owner denotes the compo\u00adnentthatmay affectthe \n.owofthevalue(e.g.,exportthe value to another component).If the owner wishes to share a value with other \ncomponents, it must do so under the aus\u00adpices of a monitororguard.Ownership of termsisformal\u00adized via \nownership labels.Expressions e are annotated with an ownerlabel l, e.g., |e |l.We use lo toindicatetheimplicit \nowner of the wholeprogram. Correct blame assignment requires that upon contract fail\u00adure, the contract \nsystemblames the contractparty responsi\u00adbleforthebreachofthe contract.Apartyis responsiblefor a contractfailureif \na valueit ownsfails animmediate contract check and it is obliged to uphold that particular contract. \nToindicate responsibilityforimmediate contractchecks, we use obligation annotations.Forinstance, flat(op)is \nanno\u00adtated with obligation l as .flat(op).l.If a component l has an immediate contract as an obligation, \nit must ensure that whena valuecrossestheboundaryprotectedbythiscontract, the contractis checked appropriately. \nComplete monitoring assumes that component bound\u00adaries agree with ownership annotations and that obligations \nmatch thelabels on monitors.To checkthis relationship, we de.ne a relation G;l l e that ensures the well-formedness \nof e with respect to a label l and environment G. Accord\u00ading tothe relation sjudgments,ownership can \nchange only viamonitors.Whenthishappens,the ownership annotation on the guarded expression must match \nthe positive label of the monitor while the negative label should coincide with the ownerof the context.Thejudgmentdoesnot \nallow any other ownership annotationsthat may changethe owner of a term.The environment G recordsthe \nowner of eachbinding encounteredby thejudgments. The relationfor well-formedprograms relies on the def\u00adinition \nof an additional judgment D;k;l . c that checks that contracts are well-formed. It picks up the positive \nand negative labels of each monitor and ensures they coincide with the obligation annotations on thepositive \nand negative pieces of the contract of the monitor. After all, the client (negative label)of a guarded \ncomponent is responsible for thevaluesit consumeswhilethe server(positivelabel) is responsibleforthe \nvaluesitproduces. Unfortunately,this strictdistinctionbetween negativeand positivepartiesdoes notholdfor \nclasses and methods.The receiver of a method invocation is an object that, via sub\u00adstitution, traverses \nthe class hierarchy from the call site to the methodimplementation.Depending onthedirection of this migration, \nthe roles of clients and servers on the con\u00adtractboundaries reverse.Thus,for each method contract the \nserver and the client share responsibility for all pieces of the contract.We accountfor this codependenceby \nallowing obligationannotationstohave sets oflabels andby adjusting thejudgments accordingly. Sealing \nand unsealing contracts pose further challenges forprovingthe correctness ofthe contract system.Weguar\u00adanteethat \nsealing contracts show up onlyin negativeposi\u00adtions with respect to the corresponding row variable . \nby marking sealing contracts with the annotation, . = -.Sim\u00adilar annotations, . =+, decorate unsealing \ncontracts. The environment D tracks thebound row variables and theirpo\u00adlarity,+ or -.The well-formedsource \ncontracts relation en\u00adsures that sealing contracts appearin the rightplaces. Thejudgmentsfor well-formedprograms \nand contracts provide the foundation for complete monitoring. Complete monitoring aims to establish that \nif each term in a program has a single owner initially, then each term has a single owner throughoutthe \nevaluation of theprogram.Embedded foreign terms can exist inside a host component, but only if they are \nwrapped with a contract monitor. Accordingly, we change the reduction semantics to propagate ownership \nannotationsas values .owthroughtheprogram.This change is independent of the contract system and does \nnot affect the meaning of the program. Host components assimilate values only when the values are primitive \nand satisfy their contracts.In any other case, values accumulate more owners asthey.owfromonecomponenttoanother. \nIf a contract systemis a complete monitor,then all anno\u00adtationsin a value s stack of ownershiplabelsmustbeiden\u00adtical. \nOtherwise, the contract system would allow values to cross componentboundaries without appropriateprotection. \nWe make redexes that involve values with stacks of non\u00adidentical owners stuck states, which makes violations \nof the single-owner policy manifest. To differentiate between the latter stuck states and stuck states \ndue to type errors we in\u00adtroduce error k,dynamictypeerrors.Thus, a contractsys\u00adtem thatis a complete \nmonitor renders states unreachableif they are stuckdueto a valuehaving multiple owners.  De.nition 1. \n(Complete monitoring) A reduction relation .forTFCC is a complete monitorif \u00d8;l0 l e0 implies: (e0 ,\u00d8).* \n(v,S)or,  (e0 ,\u00d8).* (error k,S)or,  for all e1 such that (e0 ,\u00d8) .* (e1 ,S1 ), there exists e2 such \nthat (e1 ,S1 ).(e2 ,S2 )or,  if (e0 ,\u00d8).* (e1 ,S1 ).* (blamekj,S2 ), there exists  k,l e1 = mon j \n(.flat(op).k,v) and for all such e1 , v = |v1 |k and k . k, k,l e1 = mon j (.class/c([mc1 _. c2 ]).k,v)and \nfor all such e1 , v = |v1 |k and k . k or, k,l e1 = mon j (.object/c([mc1 _. c2 ]).k,v)andfor all such \ne1 , v = |v1 |k and k . k or, .=+ k,l e1 = mon j (.unseal/c([mc1 _. c2 ],.).k,v) and for all such e1 \n, v = |cv|k and k . k or, .=- k,l e1 = mon j (.seal/c(m ' ,[mc1 _. c2 ],.).k,v)and for all such e1 , \nv = |cv|k and k . k or,  e1 = send(o, m, v)where OwnerLimit(o,m,.,.,.)=(k,j)or,   e1 = class(cv){fi \n:= vi mpxp. ep moxo . eo} and where LocateBarrier(cv,m)=(k,j), and m = mp .mo .  In addition to eliminating \nstuck states, the de.nition of complete monitoringrequiresthatthe systemblames a com\u00adponent only when \na violation is due to one of the compo\u00adnent s unmet obligations.Thus, ourde.nitionincludes cases for \nallimmediate checksthatthe contractsystem makes and, furthermore,includes casesthat ensure sealing and \nunseal\u00adingarehandledproperly. employ subject reduction. The proof combines a progress and a preservation \nlemma which establish that reduction preservesthe subjectanddoes notlead to stuck states: Progress. If \nK;G;S;l0 l e0 and K l S~ S0 then k = e1,S 1)ore0 = v ore0 = error ore0.( . )e0,S 0( blamek . j Preservation. \nIf K;\u00d8;S;l0 l e0 , K l S~ S0 and ' , ' K.K S suchthat ,' e1,S 1)thenthereexist K.( . )e0,S 0( '' ' S.S \n, K ' ;\u00d8;S ;l0 l e1 and K ' l S~S1 . Thetwolemmas use a subjectdifferentthanthejudgment for well-formedprograms.Eventhoughthelatterguarantees \nthe absenceof stuck states and correctblame,itis notgen\u00aderalenoughtohandletermsproducedduringevaluation.The \njudgmentfor well-formedterms,K;G;S;l l e,is an exten\u00adsion of the relation for well-formed programs that \ncan ac\u00adcommodateintermediateterms such as objects, class, values andguards. Proposition1. If \u00d8;l0 l e0 \nthen \u00d8;\u00d8;\u00d8;l0 l e0 . The newrelationusestwo additionalenvironments,Sand K.The .rst, store coloring,recordsthe \nownerofthe contents of each storelocation.Itsfunctionis similartothat of store typingin type soundnessproofs.The \nrelation K l S~ S ensuresthat store coloringis synchronizedwith the contents of the store. The second,keycoloring, \nrecordsthe owner of each seal\u00ading/unsealingkey.Components obtainkeys astheygenerate them and each component \nshould only seal and unseal val\u00adues with keys it owns. The environment K guarantees that thekeys storedin \nsealingguardshavethe appropriateowner. In addition,keycoloringcheckswhethercontractsremain well-formed \nafter row variables are replaced by keys. We specify this constraint with an extension of the relation \nfor well-formed contracts, Kk,l;D;k;l . c. It refers to the key coloring whenit checks sealing and unsealing \ncontracts.In these cases, the owner of the seal must match the party that performs the sealing or the \nunsealing. We determine this party by picking up the labels from monitors, decorate key coloring with \nthem, and swapping their position when we go from positive to negative position as we traverse contracts. \nIf a sealing contract is in a positive position, the owner of the key should be the server of the monitor \nsince it is the component that must protect the sealed value from its context. Similar constraints apply \nto the other cases for sealing and unsealing contracts.  4.3 TheBlameTheorem Now that we have established \ncomplete monitoring for TFCC, we canprovetypesoundnessforprogramsthat mix typed and untyped code. Fromtype \nsoundnessfortypedcode, weknowthatpurely typed components are safe from type errors. In mixed pro\u00adgrams, \ntyped and untyped components interact by passing u,t values through contract monitors. A monitor mon \nj (c, e) embeds an untyped value into a typed context because u is the server and t is the client. Similarly, \na monitor t,u mon j (c, et) embeds a typed value into an untyped con\u00adtext.Since theboundariesbetween \nuntyped and typed com\u00adponents are monitoredby the contract system, we need the contract systemtoprotect \nvaluesthat .owacrossthebound\u00adaries as strongly as the type system. For that reason we im\u00adpose contracts \non theinterfacesbetween typed and untyped componentsto simulatethetypesthatthetyped components expect. \nOf course, untyped components may not live up to  isacompletemonitorforTFCC. . . Lemma2. isacompletemonitorforTFCCwe \n. . Toprovethat K |G |S . e : t Well typed mixedterms K |G |S . e Wellformedmixedterms K |G |S.u cv \n~r Well typed mixed class values K |G |S.u o ~r Well typed mixed objects Figure15. RelationsforWellTypedMixedPrograms \nthe expectations that types express, but the contracts catch suchimpedance mismatches. In a sound system, \nsince typed code always respects the type discipline, a typed component should never break any contract \nused to mediate valuesbetween typed and untyped code.Intuitively, soundnessfor mixedprograms means that \nthe contract system neverblames a typed component. The .rststep toformalizesoundnessistoextend theno\u00adtionofwell-typedtermstoincludemixedprograms.The \n.rst two relationsin .gure15jointlyexpressthese roles.The .rst one type-checks typed components using \nthe contracts-to\u00adtypes correspondenceto create atypefor embeddeduntyped components.The second relation \ntraverses untyped compo\u00adnents anddelegates type-checking of embeddedtyped com\u00adponentstothe .rstrelation.Againweusethecontract \nonthe interfacebetweenan untypedandatypedcomponentandthe contractstotypescorrespondencefrom .gure9 toconstruct \na typeto check against the typed code. error (*.. t,S) BlameTheorem.If\u00d8 |\u00d8 |\u00d8. e,then (e,\u00d8) bleparts.We \novercomethis obstacle andprovepreservation even in the presence of sealing using the K environment, which \nmapskeys to row types and we updateit upon mixin application. For uses of untyped mixins from typed code, \nwe map the newly createdkey to the rowprovided with row application. In the reverse case we map the new \nkey to the empty row. Recall that after unsealing a class value that contains a sealed superclass, the \nsealed methods become reachable again. However the contracts in the class hierarchy do not re.ect the \ntypes of the now available methods.Thelast two relationsof .gure15 reconstructthesetypesviaatraversal \nof the class hierarchy that propagates the types of typed methods appropriately. Constructing the types \nof untyped code is not the only dif.culty of proving preservation. In fact, it is even more crucial to \nestablish that typed and untyped code do not in\u00adtermingle in an unprotected manner. Fortunately, complete \nmonitoring solves this problem and guarantees that a mon\u00aditor or a guard always mediates the interaction \nbetween a typed and an untyped component.Thisinsightsigni.cantly reduces the effort ofprovingpreservation \nas wejusthave to ensurethatthe contract we attachto a migratingtyped value corresponds to the value s \ntype.Putdifferently, theproof of theblametheoremis reduced to showing thatmonitorsand guards related \nreductions of well-typed mixed terms result in well-typedmixedterms. 5. RelatedWork Thebodyof related \nwork consists of research on combining typed and untyped languages, polymorphic contracts, and typesfor \nextensible objects or records. Gradual typing Gray etal.[16] presenta multi-language system thatintegratesScheme \nandJava, using contracts and mirrors to mediate interactions between the two languages. Their system \ndoes not handle dynamic class composition because class values cannot .ow from Scheme to Java. In subsequent \nwork,Gray[14]modelsinteroperationbetween Java andScheme with cross-languageinheritance,butdoes not addressdynamic \nclass composition mechanisms such as mixinsor .rst-classclasses.Closertoourwork,Gray[15] also modelsinteroperationbetweenJava \nandJavaScript, al\u00adlowing JavaScript code to use Java classes as prototypes. Whilehermodeldescribesdynamicclass \ncomposition,strin\u00adgent restrictions are placed on inheritance to make com\u00adposition safe. In particular, \nJava classes cannot dispatch to Javascriptextensions. Siek and Taha [28] use an object calculus for the \nfor\u00admulation of their gradual typing system for OO program\u00adming.Their systemhandles subtypingfor objects,but \nsince their language contains neither classes nor extensible ob\u00adjects, there is no treatment of inheritance \nbetween untyped andtyped code. *.. The cornerstone for proving the blame theorem is a preservationlemmafor \nmixedterms.Accordingto complete monitoring the only source of blame for typed components isaviolationofa \n.rst-ordercontract check onatyped value. Duetotypesoundnessfortyped code,however,if all .rst\u00adorder contracts \nthat guard typed values correspond to the type of the values, the checks neverfail.Indeed, thepreser\u00advationlemmafor \nmixedprogramsguaranteesthat reduction always results in well-typed mixed terms. This implies that all \n.rst-ordercheckshavethedesiredproperty. Lemma3. (MixedPreservation)IfK0 |\u00d8|S0 . e0 , \u00d8|S0 . 1suchthat \nS,e1,S 1)thenthereexist K1.( . )S0 and (e0,S 0 K0 .K1 , S0 .S1 , K0 |\u00d8|S1 . e1 and \u00d8|S1 . S1 . Theproofofmixedpreservationdemandsan \nextensionof thetoptwo relations of.gure15tointermediateterms.Seal\u00adingand unsealingcontractsmakethis extensionchallenging. \nAs explained,in section3, sealingis a mechanismforhid\u00ading details of a class provided to a component. \nUnsealing makes thehiddendetails available again to the owner of the class after the component returns \nits result. Thus when we seal a typed class the contracts on the sealing interface do notfully re.ect \nthe type of the sealed classbut onlyits visi\u00ad and (e,\u00d8) (blametj ,S).  Another approach to combining \nuntyped and typed code is applying type reconstruction to an untyped language. DRuby[12] is such a systemfor \na subset ofRuby.While Ruby supports dynamic class composition via a mixin fea\u00adture called modules,DRuby \ns type system is unable to sup\u00adport the runtime composition ofclasses thatRuby allows. Bierman et al. \n[2] formalize the dynamic type that is availableinC.4.0.Thelatter sdynamic types make nopro\u00advisionforhigher-orderdata,however. \nRuntime sealing Morris[24]proposed sealingin1973 as a linguistic mechanism to prevent access to private \npieces of code. More recently, sealing has been used to protect datatype abstraction[25]. Guha et al.[17] \ninvestigateparametricityguaranteesin untypedlanguagesvia a combinationof contractsand seal\u00ading They use \nso-called coffers an opaque datatype for sealing to wrap argumentsto contractedparametricfunc\u00adtions.Matthews \nandAhmed[21]provideaformalvalidation of this approachin a multi-languagesystem combining the untyped \n.-calculus and System F, in which sealing is ap\u00adpliedatlanguageboundariesto ensureparametricity.Ahmed \netal.[1]present a .ner-grained sealing mechanismthatas\u00adsociates seals with type abstractions.Our approach \nextends this line of work by adding partial seals that allow code to see some aspects of classes ratherthanblocking \nout all class features.Notice,however,that ourproof techniquefortype soundnessdifferssigni.cantly.Insteadofthelogicalrelation \nofMatthews andAhmed orthe subtyping-based simulation of Ahmed et al., we base our proof on complete monitor\u00ading. \nThis enables a modular proof structure and the use of standard subject reductionfor establishingtype \nsoundness. Types for dynamic class composition Row polymorphism originated as a mechanismto enabletypeinferencefor \nob\u00adjects.Wand[36]proposes atypeinference algorithmfor a simple object-orientedlanguagebased on recursive \nrecords. Theseideas were also adoptedintotype systemsfor extensi\u00adble records[4,13,18]. Closely relatedisML-ART[26], \nwhichis capable of en\u00adcoding .rst-class classes, but does not provide classes as a primitive concept. \nML-ART does not allow subsumption on objects,thusdisallowingthefamiliarpolymorphismover objects. In the \nsame vein, Fisher [10] presents a calculus with typed extensible objects using rowpolymorphism.Her calculus \nalso enables an encoding of class-based program\u00adming,butdoes not support them asprimitivefeatures.Bono \net al.[3]build onthislineof work,andincludeclasses and mixins as primitives in their calculus. Their \ncalculus cov\u00adersthe use cases of mixins,buttheir classesdonotsupport otherdynamic uses of.rst-class classes.None \nofthese mod\u00adels weredesignedfor agradually-typed setting. 6. StatusandOutlook Thispaperpresentsthe .rstdesignforagradualtypingsys\u00adtem \nthat accommodates class composition across compo\u00adnents with distinct type disciplines. On the typed side, \na novel use of row polymorphism allows for specifying in\u00adterface types for mixins, traits, and other \nmanipulations of .rst-class classes. On the untyped side, the introduction of sealing contracts allows \nthe system to seal off portions of the specialization interface of classes; this sealing ensures the \nsafety of .rst-class classes as they .ow from the typed world to the untyped one and back. Finally, the \npaper also includes a new, easy-to-useprooftechniquefor theproof of blametheoremsin thepresence ofpolymorphism. \nOur workputs usin apositionfromwhere we can explore thepragmatics ofgradualtypingfor .rst-class classes.Inthe \nnearfuture, weintendtoimplementthistype system and use it to equipa signi.cantportion of our codebase \nwith types. Acknowledgments ChristosDimoulas andSamTobin-Ho\u00adchstadt thank Amal Ahmed for several discussions \nabout polymorphic contracts and blame. The authors are also gratefultoStephenChang,VincentSt-Amour,AaronTuron, \nandArjunGuhafor comments on earlydrafts. References [1] AHMED, A., FINDLER, R. B., SIEK, J. G., AND WADLER, \nP. Blamefor all.InSymposium onPrinciples ofProgramming Languages (2011),pp.201 214. [2] BIERMAN, G., \nMEIJER, E., AND TORGERSEN, M. Adding dynamic types to C. . In European Conference on Object-Oriented \nProgramming (2010),pp.76 100. [3] BONO, V., PATEL, A., AND SCHMATIKOV, V. A core calcu\u00adlus ofclasses \nand mixins. In EuropeanConference onObject-Oriented Programming (1999),pp.43 66. [4] CARDELLI, L., AND \nMITCHELL, J. C. Operations on records. Mathematical Structures in Computer Science 1 (1991),3 48. [5] \nDIMOULAS, C., FINDLER, R. B., FLANAGAN, C., AND FELLEISEN,M. Correctblamefor contracts:No more scape\u00adgoating. \nIn Symposium on Principles of Programming Lan\u00adguages (2011),pp.215 226. [6] DIMOULAS, C., TOBIN-HOCHSTADT, \nS., AND FELLEISEN, M. Complete monitoring for behavioral contracts. In Euro\u00adpean Symposium on Programming \n(2012),pp.211 230. [7] FELLEISEN, M., FINDLER, R. B., AND FLATT, M. Seman\u00adticsEngineering withPLTRedex. \nMITPress,2009. [8] FINDLER, R. B., CLEMENTS, J., FLANAGAN, C., FLATT, M., KRISHNAMURTHI,S., STECKLER,P., \nAND FELLEISEN, M. DrScheme: A programming environment for Scheme. Journal ofFunctionalProgramming12,2(2002),159 \n182. [9] FINDLER,R.B., AND FELLEISEN,M. Contractsforhigher\u00adorder functions. In International Conference \non Functional Programming (2002),pp.48 59. [10] FISHER, K. S. Type Systems for Object-Oriented Program\u00admingLanguages. \nPhD thesis,StanfordUniversity,1996.  [11] FLATT,M.,FINDLER,R.B., AND FELLEISEN,M. Scheme with classes, \nmixins, and traits. In Asian Symposium on ProgrammingLanguages andSystems (2006),pp.270 289. [12] FURR, \nM., AN, J.-H. D., FOSTER, J. S., AND HICKS, M. Static type inference for Ruby. In Symposium on Applied \nComputing (2009),pp.1859 1866. [13] GASTER, B. R., AND JONES, M. P. A polymorphic type system for extensible \nrecords and variants. Technical Report NOTTCS-TR-96-3,UniversityofNottingham,1996. [14] GRAY, K. E. Safe \ncross-language inheritance. In European Conference onObject-OrientedProgramming(2008),pp.52 75. [15] \nGRAY, K. E. Interoperability in a scripted world: Putting inheritance&#38;prototypestogether. In Foundations \nof Object-OrientedLanguages (2011). [16] GRAY,K.E.,FINDLER,R.B., AND FLATT,M.Fine-grained interoperability \nthrough contracts and mirrors. In Object-Oriented Programming, Systems, Languages, and Applica\u00adtions \n(2005),pp.231 245. [17] GUHA,A.,MATTHEWS,J., FINDLER,R.B., AND KRISH-NAMURTHI, S. Relationally-parametric \npolymorphic con\u00adtracts. In DynamicLanguages Symposium (2007),pp.29 40. [18] HARPER, R., AND PIERCE, B. \nA records calculus based on symmetric concatenation. In Symposium on Principles of ProgrammingLanguages \n(1991),pp.131 142. [19] HERMAN,D., AND FLANAGAN,C.Statusreport:Specifying JavaScriptwithML. In MLWorkshop \n(2007). [20] LAMPING, J. Typing the specialization interface. In Object-Oriented Programming, Systems, \nLanguages, and Applica\u00adtions (1993),pp.201 214. [21] MATTHEWS,J., AND AHMED,A.Parametricpolymorphism \nthrough run-time sealing, or, theoremsforlow,lowprices! In European Symposium onProgramming (2008),pp.16 \n31. [22] MATTHEWS, J., AND FINDLER, R. B. The meaning of multi-language programs. In Symposium on Principles \nof ProgrammingLanguages (2007),pp.3 10. [23] MEJER, E., AND DRAYTON, P. Static typing where possi\u00adble, \ndynamic typing when needed: The end of the cold war between programming languages. In OOPSLA Workshop \non Revival ofDynamicLanguages (2004). [24] MORRIS, JR., J. H. Types are not sets. In Symposium on Principles \nofProgramming Languages (1973),pp.120 124. [25] PIERCE,B., AND SUMII,E.Abisimulationfordynamicseal\u00ading. \nIn Symposium on Principles ofProgramming Languages (2004),pp.161 172. \u00b4 to ML with abstract and record \ntypes. In Theoretical Aspects ofComputer Software (1994),pp.321 346. [26] REMY,D. Programming objectswithML-ART \nanextension [27] SIEK, J., AND TAHA, W. Gradual typing for functional lan\u00adguages. In Workshop on Scheme \nand Functional Program\u00adming (2006),pp.81 92. [28] SIEK, J., AND TAHA, W. Gradual typing for objects. \nIn Eu\u00adropean Conference on Object-OrientedProgramming (2007), pp.2 27. [29] STRICKLAND, T. S., AND FELLEISEN, \nM. Contracts for .rst-class classes. In DynamicLanguages Symposium (2010), pp.97 111. [30] TAKIKAWA, \nA., STRICKLAND, T. S., DIMOULAS, C., TOBIN-HOCHSTADT, S., AND FELLEISEN,M. Gradual typ\u00ading for .rst-class \nclasses. Technical Report NU-CCIS-12-02, Northeastern University, College of Computer and Informa\u00adtionScience,2012. \n[31] TANG,A. Perl6: reconciling theirreconcilable. Symposium onPrinciples ofProgrammingLanguages,2007. \n[32] TOBIN-HOCHSTADT, S., AND FELLEISEN, M. Interlan\u00adguage migration:fromscriptstoprograms. In Dynamic \nLan\u00adguages Symposium (2006),pp.964 974. [33] TOBIN-HOCHSTADT, S., AND FELLEISEN, M. The design and implementation \nof Typed Scheme. In Symposium on Principles ofProgramming Languages (2008),pp.395 406. [34] TOBIN-HOCHSTADT,S., \nAND FELLEISEN,M.Logicaltypes for untyped languages. In International Conference on Func\u00adtionalProgramming \n(2010),pp.117 128. [35] WAND, M. Complete type inference for simple objects. In Symposium on LogicinComputerScience \n(1987). [36] WAND,M.Typeinferenceforobjectswithinstancevariables and inheritance. In Theoretical Aspects \nof Object-Oriented Programming (1994),pp.97 120. [37] WRIGHT,A.K., AND FELLEISEN,M. Asyntacticapproach \nto type soundness. Information and Control (1994),38 94. [38] WRIGSTAD, T., NARDELLI, F. Z., LEBRESNE, \nS., \u00a8 OSTLUND, J., AND VITEK, J. Integrating typed and untyped code in a scripting language. In Symposium \non Principles ofProgramming Languages (2010),pp.377 388.   \n\t\t\t", "proc_id": "2384616", "abstract": "<p>Dynamic type-checking and object-oriented programming often go hand-in-hand; scripting languages such as Python, Ruby, and JavaScript all embrace object-oriented (OO) programming. When scripts written in such languages grow and evolve into large programs, the lack of a static type discipline reduces maintainability. A programmer may thus wish to migrate parts of such scripts to a sister language with a static type system. Unfortunately, existing type systems neither support the flexible OO composition mechanisms found in scripting languages nor accommodate sound interoperation with untyped code. In this paper, we present the design of a gradual typing system that supports sound interaction between statically- and dynamically-typed units of class-based code. The type system uses row polymorphism for classes and thus supports mixin-based OO composition. To protect migration of mixins from typed to untyped components, the system employs a novel form of contracts that partially seal classes. The design comes with a theorem that guarantees the soundness of the type system even in the presence of untyped components.</p>", "authors": [{"name": "Asumu Takikawa", "author_profile_id": "81549123856", "affiliation": "Northeastern University, Boston, MA, USA", "person_id": "P3856177", "email_address": "asumu@ccs.neu.edu", "orcid_id": ""}, {"name": "T. Stephen Strickland", "author_profile_id": "81418592910", "affiliation": "Northeastern University, Boston, MA, USA", "person_id": "P3856178", "email_address": "sstrickl@ccs.neu.edu", "orcid_id": ""}, {"name": "Christos Dimoulas", "author_profile_id": "81413601733", "affiliation": "Northeastern University, Boston, MA, USA", "person_id": "P3856179", "email_address": "chrdimo@ccs.neu.edu", "orcid_id": ""}, {"name": "Sam Tobin-Hochstadt", "author_profile_id": "81319502825", "affiliation": "Northeastern University, Boston, MA, USA", "person_id": "P3856180", "email_address": "samth@ccs.neu.edu", "orcid_id": ""}, {"name": "Matthias Felleisen", "author_profile_id": "81100323458", "affiliation": "Northeastern University, Boston, MA, USA", "person_id": "P3856181", "email_address": "matthias@ccs.neu.edu", "orcid_id": ""}], "doi_number": "10.1145/2384616.2384674", "year": "2012", "article_id": "2384674", "conference": "OOPSLA", "title": "Gradual typing for first-class classes", "url": "http://dl.acm.org/citation.cfm?id=2384674"}