{"article_publication_date": "10-19-2012", "fulltext": "\n Chaperones and Impersonators: Run-time Support for Reasonable Interposition T. Stephen Strickland Robert \nBruce Findler Matthew Flatt Sam Tobin-Hochstadt Northwestern University University of Utah Northeastern \nUniversity robby@eecs.northwestern.edu m.att@cs.utah.edu {sstrickl,samth}@ccs.neu.edu Abstract Chaperones \nand impersonators provide run-time support for interposing on primitive operations such as function calls, \narray access and update, and structure .eld access and up\u00addate. Unlike most interposition support, chaperones \nand im\u00adpersonators are restricted so that they constrain the behavior of the interposing code to reasonable \ninterposition, which in practice preserves the abstraction mechanisms and reasoning that programmers \nand compiler analyses rely on. Chaperones and impersonators are particularly useful for implementing \ncontracts, and our implementation in Racket allows us to improve both the expressiveness and the perfor\u00admance \nof Racket s contract system. Speci.cally, contracts on mutable data can be enforced without changing \nthe API to that data; contracts on large data structures can be checked lazily on only the accessed parts \nof the structure; contracts on objects and classes can be implemented with lower over\u00adhead; and contract \nwrappers can preserve object equality where appropriate. With this extension, gradual typing sys\u00adtems, \nsuch as Typed Racket, that rely on contracts for inter\u00adoperation with untyped code can now pass mutable \nvalues safely between typed and untyped modules. Categories and Subject Descriptors D.3.3 [Programming \nLanguages]: Language Constructs and Features Keywords Proxies, interposition, intercession, contracts \nPermission to make digital or hard copies of all or part of this work for personal or classroom use is \ngranted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page. To copy otherwise, to republish, \nto post on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. OOPSLA \n12, October 19 26, 2012, Tucson, Arizona, USA. Copyright &#38;#169; 2012 ACM 978-1-4503-1561-6/12/10. \n. . $10.00 1. Extensibility versus Reasoning An extensible programming language like Racket (Flatt and \nPLT 2010) enables the authors of libraries to design and maintain seemingly core aspects of a programming \nlan\u00adguage, such as a class system, a component system, or a type system. At the same time, the desire \nfor more extensi\u00adbility comes at the cost of additional behavior that language primitives may exhibit, \nmaking it harder for programmers to reason about their programs and for the implementors of the class, \ncomponent, or type system to deliver on the promises that such abstractions typically make. The Racket \ncontract system is a prime example of this trade-off in extensibility versus composition. The contract \nsystem can exist in its rich, state-of-the-art form largely be\u00adcause it can be implemented, modi.ed, \nand deployed with\u00adout requiring changes to the core run-time system and com\u00adpiler. At the same time, \nsince the contract system s job is to help enforce invariants on functions and data, language ex\u00adtensions \ncan accidentally subvert the intent of the contract system if the Racket core becomes too extensible \nor offers too much re.ective capability. In this paper, we report on an addition to the Racket core that \nenables language features to be implemented in a library where the features depend on run-time interposition \nor intercession, in the terminology of the CLOS Metaobject Protocol (Kiczales et al. 1991) to change \nthe behavior of core constructs. Contract checking is our most prominent example, where interposition \nis needed to trigger contract checks. For example, if a mutable vector has a contract on its elements, \nevery use or modi.cation of the vector should be guarded by a check. An up-front check does not suf.ce: \nthe vector may be modi.ed concurrently or through a callback. If interposition can change the behavior \nof core con\u00adstructs, however, then it entails the acute possibility of sub\u00adverting core guarantees of \nthe programming language, espe\u00adcially those concerning the composition of components. To balance the \nneeds of extensibility and composition, we have developed a two-layer system of interposition: chaperones \nand impersonators. Chaperones and impersonators are both proxies, where a wrapper object interposes on \noperations in\u00adtended for a target object. Chaperones can only constrain the behaviors of the objects \nthat they wrap; for an interposed op\u00aderation, a chaperone must either raise an exception or return the \nsame value as the original object, possibly wrapped with a chaperone. Impersonators, in contrast, are \nrelatively free to change the behavior of the objects that they wrap but they are not allowed on immutable \nvalues. Overall, impersonators are more expressive than chaperones, but chaperones are al\u00adlowed on more \nkinds of values.  Together, chaperones and impersonators are powerful enough to implement an improved \ncontract system without subverting guarantees that enable composition of language extensions. Thanks \nto chaperones and impersonators, the Racket contract system now supports higher-order contracts on mutable \nobjects and generative structs. This improve\u00adment directly bene.ts Racket programmers, and it bene\u00ad.ts \nlanguage extensions that are further layered on the con\u00adtract system notably Typed Racket (Tobin-Hochstadt \nand Felleisen 2008), whose interoperability with untyped Racket was improved as a result of the addition \nof proxies. Fur\u00adthermore, impersonators can be used to implement tradi\u00adtional proxy patterns, such as \ntransparent access of remotely stored .elds using standard interfaces, while chaperones can be used to \nimplement constructs such as revokable mem\u00adbranes (Miller 2006). Last but not least, building interposition \nsupport into the core compiler and run-time system offers the promise of better performance, both for \ncode that uses libraries such as contracts and code that does not. For example, the ad\u00addition of contract \nsupport for Racket s class system intro\u00adduced a factor of three slowdown for some object-oriented operations, \neven in programs that did not use contracts at all; the support for interposition we present here has \nelimi\u00adnated this overhead. Our current implementation of chaper\u00adones and impersonators compares favorably \nto current im\u00adplementations of Javascript proxies (Van Cutsem and Miller 2010), even though chaperones \nrequire additional run-time checks to enforce their constraints. In short, chaperones and impersonators \nare a new point in the design space for interposition that enable important, higher-level operations \n(e.g., higher-order contracts on mu\u00adtable containers) to be implemented ef.ciently without sub\u00adverting \nany of the existing guarantees of a language that al\u00adready has both threads and state. Section 2 uses \ncontract checking in Racket to explore is\u00adsues of expressiveness and invariants related to interposition. \nSection 3 describes Racket s chaperone and impersonator API and relates it to the implementation of contracts. \nSec\u00adtion 4 reports on additional uses of interposition in Racket: remote objects and membranes. Section \n5 presents a formal model for a subset of Racket with chaperones and imper\u00adsonators. Section 6 reports \nperformance numbers. Section 7 discusses related work. 2. Interposition via Contracts Contract checking \nis easily the most prominent use of in\u00adterposition in Racket, and a look at contract checking by itself \nexposes many of the expressiveness and invariant\u00adpreservation concerns that affect a more general interpo\u00adsition \nmechanism. We therefore start with a careful explo\u00adration of Racket contracts as a way of motivating \nthe design of chaperones and impersonators. Readers familiar with the issues surrounding the interaction \nbetween contracts, mu\u00adtable container types, and parametricity may wish to skip to section 2.5 to understand \nwhat chaperones and imper\u00adsonators enable in the contract system, and readers not inter\u00adested in the \nmotivation behind the design but instead wanting to get right to the details of programming with chaperones \nand impersonators may wish to skip to section 3. 2.1 Predicates and Function Contracts A contract mediates \nthe dynamic .ow of a value across a boundary: In Racket, contracts most often mediate the boundaries \nbetween modules. For example, the left and right bub\u00adbles above match the boundary between the math.rkt \nand circles.rkt modules declared as The circle on the left is the value 3.141592653589793 as bound to \npi in math.rkt. The dividing line in the picture is the contract real?, which checks that the value of \npi is a real number as it crosses to the area on the right. The circle on the right is the successful \nuse of pi s value in circles.rkt, since 3.14... is a real number. Not all contract checks can be performed \nimmediately when a value crosses a boundary. Some contracts require a delayed check (Findler and Felleisen \n2002), which is like a boundary wrapped around a value: Delayed checks are needed for function contracts, \nsuch as when math.rkt exports a sqr function to circles.rkt.  In this case, an immediate check on sqr \ncannot guarantee that the function will only be used on real numbers or that it will always return non-negative \nreal numbers. Instead, when sqr is applied inside circles.rkt, the argument crosses the wrapper boundary \nand is checked to ensure that it is a real number: Similarly, when a call to sqr in circles.rkt returns, \nthe value going out of sqr crosses the wrapper boundary and is checked to ensure that it is a non-negative \nreal number: Other kinds of wrappers can implement contracts that guarantee a kind of parametricity for \nfunctions. Using new\u00ad./c, for example, the left-hand poly.rkt module can promise that its id function \nreturns only values that are pro\u00advided to the function: When the function is called by the right-hand \nmodule, the argument to id is wrapped to make it completely opaque: When id returns, the result value \nis checked to have the opaque wrapper, which is removed as the value crosses back over the function s \nboundary:1 As originally implemented for Racket, simple predicate contracts, function contracts, and \neven new-./c require no 1 Matthews and Ahmed (2008) show that this wrapper protocol implements parametricity. \n particular run-time support; function wrappers are easily implemented with . and opaque wrappers via \nRacket s struct form. Run-time support becomes necessary, how\u00adever, to generalize contracts beyond immediate \npredicates and function wrappers.  2.2 Compound-Data Contracts Lists are as common in Racket as functions, \nand list con\u00adtracts are correspondingly common. In simple cases, the contract on a list can be checked \nimmediately, as in the case of a list of real numbers: The () badge on the circle is meant to suggest \nlist. If the list content is checked completely as it crosses the contract boundary, elements can be \nextracted from the list with no further checks: In the case of a list of functions, the list shape of \nthe value can be checked immediately, but the functions themselves may require wrappers. After such a \nlist crosses the contract boundary, the right-hand module sees a list of wrapped func\u00adtions, and the \nwrappers remain intact when functions are ex\u00adtracted from the list: Wrapping the list instead of its \nelements can be more ef.cient in some situations (Findler et al. 2007), but the  element-wrapping approach \nis effective for checking the 2.3 Structure Contracts contract. Wrapping the elements of a mutable vector \n(array), however, does not work: Since the state vector is mutable, the intent may be that the left-hand \nmath.rkt module can change the values in state at any time, with such changes visible to the right\u00adhand \nmodule. Consequently, values must be checked at the last minute, when they are extracted from the vector \nin the right-hand module: The [] badge on the circle is meant to suggest vector. Similarly, any value \ninstalled by the right-hand module must be checked as it goes into the vector. If the vector contains \nfunctions instead of real numbers, then extracting from the vector may add a wrapper. Finally, installing \na function into the vector may also add a wrapper: In this last case, since both sides of the module \nboundary see the same mutable vector, the newly installed function has a wrapper when accessed from the \nleft-hand math.rkt mod\u00adule. That wrapper allows the left-hand module to assume that any function it calls \nfrom the vector will return a suitable re\u00adsult, or else a contract failure is signalled. Similarly, if \nthe left-hand module abuses the function by calling on an inap\u00adpropriate argument, a contract failure \nprotects any function that was installed by the right-hand module, as guaranteed by the contract on the \nvector. Besides functions and built-in datatypes like lists and vec\u00adtors, Racket allows programmers to \nde.ne new structure types. Reliable structure opacity is crucial in the Racket ecosystem. Not only must \nordinary user libraries have their internal invariants protected, but systems libraries them\u00adselves assume \nstructure opacity because seemingly core forms, such as . or class, are implemented as macros that use \nstructures. Racket s struct form creates a new structure type: (struct widget (parent label callback)) \nThis declaration binds widget to a constructor that takes three arguments to create a widget instance, \nand it binds widget? to a predicate that produces true for values pro\u00adduced by widget and false for any \nother Racket value. The declaration also binds widget-parent to a selector proce\u00addure that extracts the \nparent .eld from a widget, and so on. The following widget.rkt module declares the widget structure type, \nbut it also uses the #:guard option to add a contract-like guard on the widget constructor. It demands \nthat the .rst constructor argument must be either #f or itself a widget, otherwise the construction is \nrejected.2 The guard on widget enforces the invariant that a widget s parent is either #f or itself \na widget. Consequently, the im\u00adplementation of widget-root can safely recur on a non\u00ad#f parent without \ndouble-checking that the parent is itself a widget, because the widget constructor guarantees this property. \nWhile the guard on widget enforces an invariant for all widgets, a structure contract written with struct/c \ncan constrain a speci.c widget instance. For example, the con\u00adtract (struct/c widget widget? any/c any/c) \ndescribes a widget instance whose .rst .eld is a widget (i.e., it cannot be #f), while no new promises \nare offered the sec\u00adond and third .elds. Along the same lines, the following scene.rkt module below promises \nthat plot is an instance 2 The info argument to the guard procedure contains information indicating if \nthe guard is being invoked on a widget instance or a sub-struct of widget.  of the widget structure \nwhose .rst .eld is an OpenGL win\u00addow. The plot contract s promise can be checked through a wrap\u00adper \non plot when the right-hand module accesses the par\u00adent .eld of plot: The left-hand module can similarly \nconstrain any change to the widget s callback function, which may require a wrap\u00adper on the function \nas it is installed into the widget: As in the case of vectors, the wrapper resides on the function even \nwhen it is extracted by the left-hand module, thus ensuring the requirements on the function that the \nleft-hand module imposed through a contract.  2.4 Parametric Contracts and Generativity Don t Mix Consider \nthe case where the left-hand module claims that the widget s parent must be treated parametrically: \nIn this case, extracting the parent from the widget produces an opaque value: This situation, created \nby a contract between the scene.rkt and circles.rkt, is unacceptable to the widget.rkt mod\u00adule that created \nthe widget structure type. If circles.rkt applies widget-root to plot, then widget-root fails with an \ninternal error: it gets a value for plot s parent that is nei\u00adther #f or a widget, despite the widget \n#:guard and the widget? argument contract. Accordingly, allowing (struct/c widget (new-./c) ...) would \nbe a mistake. Furthermore, the problem is not con.ned to an immediate use of new-./c in struct/c. Just \nas scene.rkt must not claim that the parent value of plot is parametric, it must not claim that the value \nin the call\u00adback .eld of plot is a procedure that consumes or produces a parametric value. After all, \nthe guard on widget may have wrapped the procedure to ensure properties of the function. The general \nprinciple is that struct is generative: each time a struct de.nition is evaluated, it creates a unique \nstructure type. If access to a struct-generated constructor is limited (e.g., to a particular module), \nthen properties of .eld values can be ensured by construction. This approach to information hiding breaks \ndown if the contract system allows parametric contracts on immutable structures. The contract system \nmust therefore distinguish contracts that can break invariants and must be disallowed in certain contexts \nfrom contracts that do not break invariants and are safe in all contexts. Instead of imposing constraints \nspeci.c to combinations of new-./c, struct/c, and ->, we seek a more general categorization of contracts \nand contract com\u00adposition.  2.5 The Contract Hierarchy Racket s original contract system (Findler and \nFelleisen 2002) distinguishes two classes of contracts: Flat contracts are checked completely at boundaries, \nre\u00adquiring no additional wrappers.  Higher-order contracts require wrappers to delay checks.  In generalizing \ncontracts to include compound data types and programmer-de.ned structures, we have re.ned the sec\u00adond \nclass to two kinds of higher-order contracts: Chaperone contracts can perform immediate checks and add \nwrappers to delay checks, but immediate or delayed checks can only raise errors. That is, the wrapped \nvalues must behave the same after crossing a contract boundary as before, up to contract failures.  \nImpersonator contracts may replace a value at a contract\u00adboundary crossing with a different or completely \nopaque value (as with parametric contracts).  This categorization is a hierarchy: a .at contract can \nbe used wherever a chaperone contract is allowed, and any kind of contract can be used where an impersonator \ncontract is al\u00adlowed. Contract combinators such as listof and -> cre\u00adate chaperone contracts when given \nchaperone contracts, and they create impersonator contracts when given at least one impersonator contract. \nOnly chaperone contracts can be placed on immutable .elds in structures like widget, be\u00adcause more general \ncontracts could produce a different result for different uses of the value, making it appear mutable. \n To summarize the impact of this change on the Racket contract library, the following table shows the \nstate of con\u00adtract support in Racket before our generalizations: The tildes indicate points where .at \ncontracts were allowed for mutable data and structures. In these cases, the contracts were checked only \npartly, because mutation could subvert the checks later. The asterisks on the objects line indi\u00adcates \nthat contracts were supported for our Java-like object system, but at a high runtime cost to objects \nthat did not use contracts. Many language extensions in Racket are built using macros and programmer-de.ned \nstructure types, and they would likely suffer in the same way the object system did with the addition \nof contracts. The following table shows the current state of Racket support for contracts after our generalizations: \n The unsupported cases in this table are unsupported by de\u00adsign; those points in the spectrum do not \nmake sense, as explained above. Contracts are fully supported and reliably checked in all other points \nof the space. 3. Chaperones and Impersonators The Racket run-time system is oblivious to the contract \nsystem. Instead, the run-time system provides chaperones and impersonators as .rst-class values, with \nwhich it is then possible to implement chaperone and impersonator contracts as well as additional proxy \npatterns. Figure 1 shows part of the Racket chaperone and imper\u00adsonator API.3 The API includes a constructor \nfor each prim\u00aditive datatype that supports interposition on its operations. The chaperone-of? predicate \nchecks whether a value is a chaperone of another value and therefore acceptable, for example, as a replacement \nresult from another chaperone. 3.1 Chaperoning and Impersonating Functions The chaperone-procedure function \ntakes a procedure and creates a chaperone that also acts as a procedure and satis.es the procedure? predicate. \nThe chaperone accepts the same number of arguments as the original function, it returns the 3 The complete \nAPI is about twice as large (Flatt and PLT 2010, \u00a713.5). (chaperone-of? a b) Determines whether a is \nthe same as or a chaperone of b. (chaperone-procedure proc interp-proc) Chaperone a procedure, interposing \non procedure argu\u00adments and results via interp-proc. (chaperone-vector vec interp-ref interp-set) Chaperone \na vector, interposing on the vector-ref and vector-set! operations. (chaperone-struct struct op interp-op \n....) Chaperone a structure instance, interposing on the sup\u00adplied accessor and mutator operations for \nmutable .elds. ... (impersonator-of? a b) Determines whether a is the same as, an impersonator of, or \na chaperone of b. (impersonate-procedure proc interp-proc ....) Impersonate a procedure. (impersonate-vector \nvec interp-ref interp-set ....) Impersonate a mutable vector. (impersonate-struct struct op interp-op \n....) Impersonate a structure instance. ... Figure 1: Partial chaperone and impersonator API same number \nof results, and when it is called, the chaperone calls the original function. At the same time, when \nthe chap\u00aderone is applied, it can check and possibly chaperone the ar\u00adguments to original function or \nthe results from the original function. To chaperone a function, chaperone-procedure needs the function \nto chaperone and a function to .lter arguments and results: (chaperone-procedure orig-proc interpose-proc) \nFor example, to chaperone a function of two arguments, the .ltering interpose-proc would have the form \n(. (a b) .... (values new-a new-b)) where a and b are the arguments originally supplied to the chaperone \ncreated by chaperone-procedure, and new-a and new-b are the replacement arguments that are forwarded \nto the chaperoned orig-proc. An interpose-proc can return an extra value to inter\u00adpose on the result \nof the procedure. The extra value must be a post-interpose-proc function to .lter the result of the chaperoned \nfunction. A post-interpose-proc must ac\u00adcept as many values as the chaperoned function returns, and it \nreturns replacements for the chaperoned function s results. Since the post-interpose-proc is determined \naf\u00adter the arguments are available, the replacement result from post-interpose-proc can depend on the \noriginal argu\u00adments provided to interpose-proc.  For example, to chaperone a function of two arguments \nthat produces a single result, and to adjust the result as well as the arguments, an interpose-proc would \nhave the form (. (a b) .... (values new-a new-b ; post-interpose-proc: (. (result) .... new-result))) \nwhere result is the result of the chaperoned proc, and new-result is the result that is delivered to \nthe caller of the chaperone. When the run-time system applies interpose-proc for a chaperoned function \ncall, it checks that the replacement arguments from interpose-proc are the same as or chaper\u00adones of \nthe original arguments. Similarly, when the run-time system applies a post-interpose-proc to the chaperoned \ncall s result, it checks that the replacement result is the same as or a chaperone of the original. Using \nchaperones to implement contracts is straight\u00adfoward. The contract on a procedure like sqr, (provide/contract \n[sqr (real? . -> . nonnegative-real?)]) is implemented as a chaperone of sqr: (chaperone-procedure sqr \n(. (n) (unless (real? n) (blame client \"real\")) (values n (. (result) (unless (nonnegative-real? result) \n(blame provider \"nonnegative real\")) result)))) Here, the blame function takes an identi.er which names \nthe blamed party and a string that describes the reason that party broke the contract. The parties provider \nand client are the modules that export and import the sqr function, respectively. The -> contract constructor \ncreates a chaperone to imple\u00adment a function contract when the argument and result con\u00adtracts are .at \ncontracts, like real? and nonnegative-real?, or chaperone contracts. If the -> contract constructor en\u00adcounters \nan impersonator contract like a, then it must instead create an impersonator. The impersonate-procedure \nconstructor works the same way as chaperone-procedure. When an imperson\u00adator is applied, the run-time \nsystem skips the check on argu\u00adment and result replacements, since they are not required to be the same \nas or chaperones of the original arguments and results. Naturally, the result of impersonate-procedure \nis not chaperone-of? the original procedure, so it cannot be used in situations that require a chaperone. \n 3.2 Chaperoning and Impersonating Vectors The chaperone-vector function takes a vector and creates \na chaperone that appears to be like any other vector: the vector? predicate returns true when applied \nto the chap\u00aderone, and equal? can be used to compare the chaperone to another vector. To chaperone a \nvector, chaperone-vector needs the vector to chaperone and two functions: one function that interposes \non access of vector elements, and another that interposes on assignments to vector slots: (chaperone-vector \nvec interpose-ref interpose-set) When vector-ref is called on the chaperone with an index i, interpose-ref \nis called with three arguments: vec, i, and the result of (vector-ref vec i), which is the result that \nwould be returned by the original vector. The result of interpose-ref is a replacement for (vector-ref \nvec i), and so it must be the same as this value or a chaperone thereof. The protocol for interpose-set \nis essentially the same. For example, the contract for partial-sums!, (provide/contract [partial-sums! \n((vectorof number?) . -> . any)]) is implemented using chaperone-vector. The installed chaperone ensures \nthe client supplied a vector that contains only numbers and constrains partial-sums! from changing the \nvector to include non-numbers: (chaperone-procedure partial-sums! (. (vec) (unless (vector? vec) (blame \nclient \"vector\")) (chaperone-vector vec ; Check accesses, interpose-ref: (. (vec i val) (unless (number? \nval) (blame client \"number\")) val) ; Check mutations, interpose-set: (. (vec i val) (unless (number? \nval) (blame provider \"number\")) val)))) Note how interpose-ref blames client for a non-number value, \nwhile interpose-set blames provider; if the vector were a result of partial-sums! instead of an argument, \nthe roles would be reversed. This swapping of blame labels is analogous to the swapping that occurs when \nfunctions are used as arguments versus results, and it is supported naturally by the chaperone API. It \nmay seem that an interpose-ref needs only an index, since the interpose-ref provided to chaperone-vector \ncould capture vec in its closure and extract the original value from vec. Passing vec, however, helps \navoid the extra over\u00adhead of allocating a closure when creating a vector chap\u00aderone. More signi.cantly, \na vector chaperone can wrap an\u00adother chaperone, in which case the vector-ref interposi\u00adtion functions \ncompose naturally and with linear complexity when vec, i, and val are all provided. Along similar lines, \ninterpose-set could install its replacement value directly into vec, but to facilitate composition it \ninstead returns a value to be installed.  The impersonate-vector function works the same way as chaperone-vector, \nbut without chaperone checks on re\u00adplacement values. In addition, impersonate-vector is lim\u00adited to mutable \nvectors. If a vector is known to be immutable (via Racket s immutable? predicate), then vector-ref on \na particular slot should always return the same result. Chap\u00aderones enforce a suitable notion of same \nresult, so im\u00admutable vectors can be chaperoned; impersonators could break the intent of an immutable \nvector, so immutable vec\u00adtors cannot be impersonated.  3.3 Chaperoning and Impersonating Structures \nAs noted in section 2.3, Racket s struct form creates a new structure type with a .xed number of .elds, \nand it binds con\u00adstructor, predicate, accessor, and (optionally) mutator func\u00adtions for the new structure \ntype. For example, (struct fish (color [weight #:mutable])) de.nes the constructor fish to create instances, \nthe predi\u00adcate fish? to recognize instances, the accessor fish-color to extract the .rst .eld of an instance, \nand the accessor fish-weight to the extract the second .eld of an instance. Since the second .eld is \nannotated #:mutable, struct also binds set-fish-weight! as a mutator to change an in\u00adstance s second \n.eld. The chaperone-struct function creates a chaperone on an instance of a structure type. Whereas the \nchaperone con\u00adstructors for functions and vectors take a .xed number of interposition functions, chaperone-struct \ndeals with arbi\u00adtrary structure types that can have different numbers of .elds and varying visibility \nof operations. The chaperone-struct function thus takes a structure instance with a sequence of pairs \nof operations and interposition procedures. For exam\u00adple, a contract on a fish instance dory to ensure \nthat dory is blue and between 10 and 12 pounds could be imple\u00admented as (chaperone-struct dory fish-color \n(validate-color provider) fish-weight (validate-weight provider) set-fish-weight! (validate-weight client)) \n where validate-color and validate-weight perform the actual checks. In principle, every value in Racket \nis a structure, and chaperone-vector and chaperone-procedure internally use chaperone-struct to apply \nchaperones through inter\u00adposition of private accessors and mutators.4 By exposing or hiding structure \noperations, a library implementer can choose to either allow clients to use chaperone-struct di\u00adrectly \nor force clients to use some other chaperone-creation function that is exported by the library. The impersonate-struct \nfunction works the same way as chaperone-struct, but without chaperone checks 4 In practice, most (but \nnot all) procedures and vectors have specialized representations that are exploited by the just-in-time \ncompiler. on replacement values. Just like impersonate-vector, impersonate-struct only allows interposition \non mutable .elds of a structure. 4. Interposition beyond contracts Chaperones and impersonators are not \nlimited in use to im\u00adplementing contracts. To demonstrate additional uses, we discuss the implementation \nof remote objects that provide a local view on a remote service with impersonators, and we discuss the \nimplementation of revocable membranes (Miller 2006) with chaperones. 4.1 Remote Objects To illustrate \nremote objects, we use impersonators to imple\u00adment a view on IMAP accounts. The resulting view is ma\u00adnipulated \nby the programmer like normal, local data, but the view retrieves information lazily from the IMAP server \nus\u00ading the interposition capability of impersonators. Since the data we retrieve from the server is not \nthe same as the data stored in the wrapped local data structures, we must use im\u00adpersonators, not chaperones. \nFirst, we require an existing Racket library that provides IMAP functionality: (require net/imp) Building \non this library, an IMAP session is represented as a hash table that maps mailbox names to mailboxes. \nA hash\u00adtable impersonator interposes on the lookup, assign, remove, and key-enumeration operations of \na hash table, where the lookup interposition function .rst .lters the key and returns another procedure \nto adjust the lookup result. To simplify the presentation, the impersonator for the mailbox hash allows \nonly lookup and key-enumeration (replacing or removing mailboxes is not allowed), effectively making \nthe table read\u00adonly. (define (imap-hash server user pass) (define-values (conn c r) (imap-connect server \nuser pass \"INBOX\")) (define mailboxes (map second (imap-list-child-mailboxes conn #f))) (imap-disconnect \nconn) (impersonate-hash (make-hash (map (. (m) (cons m #f)) mailboxes)) (. (h k) (values k (. (h kv) \n(imap-mailbox-vector server user pass k)))) (. (h k v) (error \"assign not allowed\")) (. (h k) (error \n\"remove not allowed\")) (. (h k) k))) To client code, the result of imap-hash looks like a hash ta\u00adble \nht indexed by byte-string mailbox names, so that a client who wants to read messages from the Ultra Mega \nmail\u00adbox would access messages using (hash-ref ht #\"Ultra Mega\"). Instead of returning the placeholder \n#f that is stored in the hash table, the table access triggers a download of the Ultra Mega messages \nvia imap-mailbox-vector.  Ultimately, each message contains four parts: (1) the mes\u00adsage position within \nthe mailbox, (2) the headers of the mes\u00adsage, (3) the body of the message, and (4) the IMAP .ags associated \nwith the message. (struct message (pos [headers #:mutable] [body #:mutable] [flags #:mutable])) Fields \nother than pos in message are marked as mutable so that the impersonator can retrieve them lazily. That \nis, the impersonator for a message connects to the IMAP server when any .eld other than pos is accessed: \n(define (imap-message server user pass mbox pos) (define (fetch-field field) (define-values (conn c r) \n(imap-connect server user pass mbox)) (define val (first (first (imap-get-messages conn (list pos) (list \nfield))))) (imap-disconnect conn) val) (impersonate-struct (message pos #f #f #f) message-headers (. \n(s f) (fetch-field header)) message-body (. (s f) (fetch-field body)) message-flags (. (s f) (fetch-field \nflags))))  4.2 Revocable Membranes Revocable membranes (Donnelley 1976; Miller 2006; Ra\u00adjunas 1989) \nallow one software component to share values that contain behavior or state with another component, but \nto later revoke access to those values when needed. Such membranes are useful for providing untrusted \nparties time\u00adlimited access to sensitive data, and they have been veri.ed to enforce the appropriate \nsecurity properties (Murray 2010). Because the wrapped values should react identically to the original \nvalues except for errors due to the membrane being revoked, chaperones are suf.cient to implement mem\u00adbranes, \ndespite the invariants that Racket enforces. In our implementation, a component provides chaperoned versions \nof values that may contain behavior or state, and the chap\u00aderone checks for revocation before applying \nfunctions and accessing or mutating state. In addition to demonstrating the expressiveness of chaperones, \nprevious membrane de\u00adsigns rely on a universal message-passing interface, whereas chaperones support \nmembranes for data such as vectors and structures. To represent the membrane, we use a structure type \nthat contains one .eld, revoked?, that initially contains #f. We provide two utility functions on membranes: \n check-membrane, which errors if a membrane has been revoked, and  revoke-membrane, which revokes a \nmembrane.  (struct membrane ([revoked? #:mutable #:auto]) #:auto-value #f) (define (check-membrane \nm) (when (membrane-revoked? m) (error \"membrane revoked!\"))) (define (revoke-membrane m) (set-membrane-revoked?! \nm #t)) Van Cutsem and Miller (2010) and Austin et al. (2011) implement revocable membranes via a generic \nproxy mech\u00adanism that is uniform for all types of value. Thus, they need to implement only one proxy \nwrapper that appropriately re\u00adcurs on any values returned from operations. In our sys\u00adtem, however, different \ntypes of values have different chap\u00aderone interfaces, so we have a central dispatching function, membrane-value, \nthat consumes a value and adds a mem\u00adbrane to it. For basic values, like strings or numbers, no wrapping \nis necessary. For values like pairs, the pair need not be wrapped, but the values contained in the pair \nmay require wrapping. For procedures and vectors, we simply use the appropriate type of chaperone. The \ninterposing functions check the membrane, and if it is not yet revoked, allow the operation to proceed. \nAttempting to pass a value through a membrane causes an error if the value cannot be wrapped and may \ncontain behavior or state. (define (membrane-value v m) (cond [(or (null? v) (string? v) (number? v)) \nv] [(pair? v) (cons (membrane-value (car v) m) (membrane-value (cdr v) m))] [(vector? v) (membrane-vector \nv m)] [(procedure? v) (membrane-procedure v m)] [(struct? v) (membrane-struct v m)] [else (error \"Value \ncannot flow through membrane\" v)])) To build a membrane, we simply create a chaperone that calls check-membrane \nbefore allowing any operation. Here s the code to add the chaperone to a vector. (define (membrane-vector \nv m) (chaperone-vector v (. (v i r) (check-membrane m) (membrane-value r m)) (. (v i r) (check-membrane \nm) (membrane-value r m)))) The other operations are similar (although the structure membrane is more \ncomplex, since structures have many op\u00aderations in Racket). The full implementation is given in the technical \nappendicies that accompany this paper.  5. Reasoning about Reasonable Interposition This section presents \na formal model of our chaperones and impersonators. Using the model, we can formally establish limits \non allowed interposition, and we can state a precise theorem that illustrates the desired properties \nof chaperones. To begin, we de.ne VectorRacket, a subset of Racket with both mutable and immutable vectors. \nWe then extend Vec\u00adtorRacket to include chaperones and impersonators for vec\u00adtors and present our theorem \nfor chaperone erasure. 5.1 Constraining Interposition By requiring that a chaperone or impersonator is \nattached to a value before it .ows into otherwise oblivious code, the de\u00adsign of chaperones and impersonators \nimplicitly constrains the interposition to that speci.c value. After a value is chap\u00aderoned, however, \nthe dynamic behavior of the chaperone is hardly constrained; it is certainly not constrained to purely \nfunctional behavior. An interposition function associated with a chaperone can use the full power of \nRacket, which means that it can print output, modify global variables, or even change mutable arguments \nas they .ow through the interposition layer. At .rst glance, a lack of constraints on side effects may \nseem like an open invitation to breaking existing invariants of the programming language. An externally \nvisible side ef\u00adfect that is performed through a chaperone, however, is no different from a side effect \nthat is concurrently performed by another thread. A chaperone may gain access to local values that might \nnot otherwise be exposed to other threads, but in a mostly functional language like Racket, those ar\u00adguments \ntend to be immutable, which means that extra side effects through chaperones are constrained already \nby the immutability of the data. In contrast, impersonators are prohibited from acting on immutable values, \nprecisely to ensure that the invariants of immutability are preserved. For example, extracting the value \nof a .eld from an immutable structure should always return the same result; chaperoned structures still \npreserve this behavior, thanks to the chaperone-of? check that im\u00adpersonators skip. Since chaperones \nand impersonators offer little additional possibilities for side effects compared to threads, and since \nRacket libraries must already account for the possibility of concurrent threads when checking and enforcing \ninvariants, chaperones and impersonators create few new complications on that front. We are therefore \nconcerned with the ability of a chaperone or impersonator to change the result that is produced by an \noperation, and hence our investigation con\u00adcentrates on that problem. To further simplify the model, \nwe restrict attention to procedures and mutable and immutable vectors, since the structure-type generativity \ncan be simu\u00adlated through vectors, procedures, and hidden type tags. Figure 2: VectorRacket Syntax \n 5.2 VectorRacket Figure 2 shows the grammar for VectorRacket. The surface language (the left-hand column) \nincludes  expressions, ap\u00adplication, variables ( ), expressions, expressions, er\u00adrors, booleans ( ), \nnatural numbers ( ), a void result for side effects, and primitives. The primitives include opera\u00adtions \nfor creating and inspecting vectors, as well as two predicates: to compare two values structurally and \nto determine whether a value is an immutable vector. The evaluator for VectorRacket (.gure 3) returns \nthe atomic tag procor vectorto indicate that the result of evalua\u00adtion was some procedure or some vector, \nrespectively. If the result was some other kind of value, the evaluator returns it directly. If evaluation \ngets stuck at a non-value, the evaluator returns error. The evaluator is a partial function, since it \nis unde.ned when evaluation of a program fails to terminate. The evaluator uses the reduction relation \n., which is shown in .gure 4. The relation uses the additional syntactic categories given on the right-hand \ncolumn of .gure 2. The reduction relation operates on programs ( ), which consist of three parts: a store \n( ) to map locations to procedures and vectors ( ), a boolean to track whether evaluation is in the dynamic \nextent of a chaperone s interposition function (which aids with the formulation of our formal results), \nand an expression. The langauge for expressions is nearly the same as the set of surface-level expressions, \nwith the exception that the production is added to stand for a value in the store. Finally, and are \nevaluation contexts for programs and expressions, respectively. The rules are mostly standard, with a \nfew exceptions. To support a notion of equality on procedures, procedures are allocated in the store \nvia the [procedure] rule, so the [\u00dfv] rule extracts the procedure from the store before substitution. \nThe rules for treat non- values as if they were true (as in Racket). The [equal?] rule defers to the \n metafunction (not shown here), which returns when the (potentially in.nite) unfolding of the .rst argument \nis equal to the (potentially in.nite) unfolding of the second. The predicate detects immutable vectors. \nThe remaining rules handle vec\u00ad  . proc if (() #f e) .* (sb (loc x)) and s(x)=(. (x ...) e1) . vector \nif (() #f e) .* (sb (loc x)) . Eval[e] = v if (() #f e) .* (sbv) error: msg if (() #f e) .* (sb (error \nmsg)) error if (() #f e) .* p1 and . . p1 . p11 for any p11 Figure 3: VectorRacket Evaluator (function \nclauses in order) tor allocation, access, and update, where vector allocation records whether it was \nallocated by an interposition (i.e., the program state s boolean).  5.3 VectorRacket with Chaperones \nFigure 5 extends the syntax of VectorRacket with chaperones and impersonators. The extensions include \nthree new prim\u00aditives, value forms for chaperones and impersonators, and and forms to record whether \nevaluation has entered a chaperone s interposition functions. The primitive works as in Racket: its \n.rst argument is a vector to be chaperoned, its second argument is a procedure to interpose on vector \naccess, and its third argument is a procedure to interpose on vector update: If the interposition function \nattempts to return a completely different value, the program aborts, signalling an error that the chaperone \nmisbehaved: The [out-cvec-ref] and [in-cvec-ref] rules of .gure 6 handle for chaperones. The two rules \nare essentially the same, but [out-cvec-ref] applies when evaluation .rst moves into interposition mode, \nwhile [in-cvec-ref] applies when evaluation is already in interposition mode (as indi\u00adcated by the boolean \nin the program state). In either case, the rules expand a application to extract a value from the chaperoned \nvector, apply the interposition function, and check that the interposition function s result is a chap\u00aderone \nof the original value. The [out-cvec-ref] rule also uses and to move into and out of in\u00adterposition \nmode. The [setm] and [clearm] helper rules di\u00adrectly manipulate the boolean in the program state and \nthen reduce to their arguments. Figure 4: VectorRacket Reductions The [out-cvec-ref] and [in-cvec-ref] \nrules of .gure 6 han\u00addle on vector chaperones in a similar man\u00adner. The [ivec-ref] and [ivec-ref] rules \nhandle and  on impersonators, which do not require checks. The [cvec] and [ivec] rules handle chaperone \nand impersonator construction. The  primitive defers to the metafunction of .gure 6. The result of \nis for syntactically identical values. If both arguments are im\u00admutable vectors of the same length, the \nelements are checked point-wise. If the .rst argument is a location in the store that points at a chaperone, \nthe metafunction recurs using the chaperoned value. Otherwise,  returns .  5.4 Chaperone Erasure To \nstate our central theorem on chaperone proxies, we need the notion of chaperone erasure for a subset \nof programs. If a  Figure 5: VectorRacket Chaperone Syntax Extensions Figure 6: VectorRacket Chaperone \nReductions and Meta\u00adfunctions well-behaved program with chaperones evaluates to a value, then the program \nwith all chaperones removed will evaluate to an equivalent value. In our model, a well-behaved pro\u00adgram \nis a program whose chaperone wrappers do not affect mutable vectors used by the main program, that is, \nthe pro\u00adgram with chaperones erased. There are two ways that chap\u00aderones might do this: through mutating \nvectors allocated by the main program, or providing the main program with vec\u00adtors allocated by the chaperone, \nwhich can later be used as a channel of communication. Since chaperone wrappers must return values that \nare chaperones of the appropriate argument, and chaperones must share the same mutable state, providing \nthe main pro\u00adgram with chaperone-allocated vectors is only possible by placing that vector in a vector \nallocated by the main pro\u00adgram. Thus, we need only detect the mutation of main pro\u00adgram state within \na chaperone wrapper to detect ill-behaved programs. We do this by looking for reductions where the left \nhand side is marked as being under the dynamic extent of a chaperone wrapper and the redex is a on a \nvector allocated outside of any chaperone wrappers. Theorem 1. For all if and that evalua\u00adtion contains \nno reductions whose left hand side is of the form where = , then , where is the same as but where any \nuses of are replaced with . Proof sketch To prove this theorem, we look at the trace of reductions for \nboth the unerased and erased programs. First, we set up an approximation relation that relates pro\u00adgram \ntraces in the unerased reduction trace to program states in the erased reduction trace. Erased program \nstates are ap\u00adproximately equal to unerased program states when they contain the same expression, modulo \nthe replacement of with , and the graph of memory allocated by the main program is the same in both, \nmodulo any chaperones allocated by the unerased program. We then show that VectorRacket reduction respects \nthis ap\u00adproximation, and that values from approximated states are equal under our evaluation function. \nThe full proof is given in the technical appendicies. 6. Performance Although our motivation for adding \nchaperones and imper\u00adsonators to Racket is to increase the expressiveness of the contract system, performance \nis a major concern. Our pri\u00admary concern is that support for chaperones, impersonators, and contracts \nis pay as you go as much as possible; that is, programs that do not use the features should not pay for \nthem. A secondary concern is the performance of chaper\u00adones, impersonators, and contracts themselves, \nwhich should not impose excessive overheads on programs that use them.  The Racket implementation uses \na just-in-time (JIT) compiler to convert bytecode into machine code for each function when the function \nis .rst called. When the JIT compiler encounters certain primitive operations, such as vector-ref, it \ngenerates inline code to implement the op\u00aderation s common case. The common case corresponds to a non-chaperone, \nnon-impersonator object. For example, the inlined vector-ref code checks whether its .rst argument has \nthe vector type tag, checks whether its second argument is a .xnum, checks whether the .xnum is in range \nfor the vector, and .nally extracts the .xnum-indexed element from the vector; if any of the checks fail, \nthe generated machine code bails out to a slower path, which is responsible for handling chaperones as \nwell as raising exceptions for bad arguments. The addition of chaperones thus has no effect on the machine \ncode generated by the JIT compiler or its resulting performance when chaperones are not used in dy\u00adnamically \ntyped Racket code. We therefore concentrate our performance analysis on the overhead of using chaperones \nand impersonators, both by comparing this overhead to pro\u00adgrams without interposition as well as comparing \nthe per\u00adformance of chaperones and impersonators to other proxy systems. The source code for all of the \nbenchmarks presented in this section are in the technical appendices. 6.1 Procedure Performance To measure \nthe performance overhead of chaperones and im\u00adpersonators for procedures, we start with microbenchmarks \ncomparing Racket to two variants of Scheme Chicken and Larceny plus two variants of Javascript V8 and \nSpider-Monkey, with J\u00e4gerMonkey and type inference (Hackett and Guo 2012) enabled for the latter. The \n.rst set of benchmarks involve 10 million calls to the identity function in increasingly expensive con.gurations, \nwith results shown in .gure 7: direct Each call is a direct call, which is inlined by the Racket compiler \nand most others.  indirect Each call is through a variable that is as\u00adsigned to the identity function. \nSince Racket is designed for functional programming, its compiler makes no at\u00adtempt to see through the \nassignment, so the assignment disables inlining of the function. For Javascript, the in\u00addirection is \nsimilarly just an assignment, but Javascript implementations tend to see through such assignments; and \nwe make no attempt to obfuscate the program further from Javascript JITs.  wrapped Each call is through \na function that calls the identity function. Like indirect, both the identity func\u00adtion and its wrapper \nare hidden from the Racket com\u00adpiler via assignments to prevent inlining and therefore to simulate at \nthe source level the kind of indirections that a chaperone or impersonator create.  Run times in milliseconds \nRacket Chicken Larceny V8 SM direct 29115 66 42 37 indirect 123 226 63 40\u00b1 46 wrapped 176 218 85\u00b1 36 \n95 wrapped+check 358 446 163 195 139 wrapped+return 562\u00b1 525 197 401 1,211 proxy  1,903\u00b1 1,931 impersonate \n922  chaperone 920  impersonate+return 1,642  chaperone+return 1,676 church 1,258 1,113 706 2,282 \n9,368 church-wrap 4,067 8,014 3,458 8,071 26,785 church-proxy  41,717 79,214 church-chaperone 43,805 \n church-chaperone/a 4,653  church-contract 7,607  293,149 226,135 Average of three runs; \u00b1 inidicates \na standard deviation between 5% and 10% of the average, while all others are within 5% of the average. \nBenchmark machine: MacBook Air, 1.8 GHz Intel Core i7, 4GB running OS X 10.7.4. Implementations: Racket \nv5.3.0.16 (git b0f81b5365) 64-bit, Chicken v4.7.0 64-bit using -O3 -no-trace, Larceny v0.98b1 32-bit \nus\u00ading -r6rs -program, V8 shell v3.12.19 (git cb989e6db8) 64-bit using --harmony, SpiderMonkey v1.8.5+ \n(hg 23a7ba542bb5) 64-bit using -m -n, where uses contracts generated by Contracts.coffee 0.2.0 (Disney \n2012), and the V8 run further uses --noincremental-marking to avoid a problem with weak maps. Figure \n7: Procedure-call microbenchmark results wrapped+check Each call to a function like wrapped is generated \nby a higher-order function that accepts a function to convert to the original function s argument and \nanother to convert the result; the identity conversion is provided. This variant simulates the old implementa\u00adtion \nof contracts in Racket by using lambda as the inter\u00adposition mechanism instead of impersonate-procedure \nor chaperone-procedure.  wrapped+return Like wrapped, but in addition to returning the result of the \nidentity function, the wrapper returns another function (also the identity function) that the caller \nshould apply to the result. This variant simu\u00adlates interposition on both the arguments and results of \na wrapped function as performed by chaperones and im\u00adpersonators, but staying within normal function \ncalls.  proxy For Javascript, calls the identity function through a proxy created by Proxy.createFunction \n(Van Cutsem and Miller 2010), which is roughly analogous to calling a function through an impersonator. \n impersonate and chaperone For Racket, calls the identity function through an impersonator and chaperone, \nrespectively, interposing only on the arguments of the function.   impersonate+return and chaperone+return \n For Racket, calls the identity function through an imperson\u00adator and chaperone, respectively, interposing \non both the arguments and results of the function with the identity conversion. Although it is dif.cult \nto compare performance across lan\u00adguages with different semantics, these results suggest that Racket \ns performance is not out of line with other dynamic\u00adlanguage implementations, both in terms of its baseline \nper\u00adformance and in the performance of chaperones and imper\u00adsonators compared to Javascript proxy implementations. \nIn addition to calling the identity function 10 million times, we also run a .-calculus computation of \nfactorial us\u00ading Church numerals, which stresses higher-order functions. Again, we try several variants \nwith results shown in .gure 7: church Computes the factorial of 9 using Church numerals.  church-wrap \n Like church, but with wrapping func\u00adtions to simulate contract checks. The simulated contracts are higher \norder, involving about 360 wrappers and just short of 10 million applications of wrapped functions. \n church-proxy Like church-wrap, but implementing wrappers with Javascript proxies.  church-chaperone \n Like church-wrap, but imple\u00admenting wrappers with chaperones.  church-chaperone/a Like church-chaperone, \nbut recognizing (any/c . -> . any) contracts to avoid un\u00adnecessary chaperoning in that case, which is \nthe kind of shortcut that Racket s contract system detects.  church-contract Like church-wrap, but \nusing either Racket contracts, which are in turn implemented with chaperones, or Contracts.coffee (Disney \n2012), which compiles to JavaScript proxies.  The initial church variants corroborate the other microbench\u00admark \nresults. The church-contract result shows Racket s performance to be signi.cantly better than the JavaScript \nversions, but this is likely because of optimizations that the Racket contract library performs, and \nnot due to differences at the proxy/chaperone layer. To check the effect of chaperones in realistic applications, \nwe use a few existing Racket programs and tests that make heavy use of functions with contracts: make \nguide Builds a representation of the Racket Guide, which involves many constructors such as section \nand element, as well as the decoding of some string lit\u00aderals into typesetting elements. Most contract \nchecking involves the constructors.  render guide Renders the documentation from make guide to HTML. \nThe relevant contracts are on structure accessors (but not individual structure instances) and on functions \nto resolve cross references.  msecs makes calls make guide 10,792 14,051 90,924 chaperone 10,818 14,049 \n90,922 impersonate 10,606 13,602 89,914 no interpose 10,467 13,602 0 no chaperone proxy overhead: 1% \nadditional chaperone overhead: 0% contract checking overhead: 2% render guide 3,727 2,188 1,846,966 chaperone \n3,741 2,188 1,846,966 impersonate 2,044 172 1,730,158 no interpose 1,889 172 0 no chaperone proxy overhead: \n8% additional chaperone overhead: 0% contract checking overhead: 83% keyboard 7,258 160 1,244,705 chaperone \n7,253 160 1,244,705 impersonate 5,321 0 1,244,545 no interpose 5,182 0 0 no chaperone proxy overhead: \n3% additional chaperone overhead: 0% contract checking overhead: 36% slideshow 5,180 6,467 208,263 chaperone \n5,168 6,467 208,263 impersonate 4,776 4,605 206,401 no interpose 4,663 4,605 0 no chaperone proxy overhead: \n2% additional chaperone overhead: 0% contract checking overhead: 8% plot 2,394 1,755 274,768 chaperone \n2,362 1,755 274,768 impersonate 1,886 1,750 136,923 no interpose 1,854 1,750 0 no chaperone proxy overhead: \n2% additional chaperone overhead: 1% contract checking overhead: 25% typecheck 47,816 1,975,414 7,440,497 \nchaperone 47,302 1,975,414 7,440,497 impersonate 24,144 918,343 3,482,644 no interpose 22,610 918,491 \n0 no chaperone proxy overhead: 7% additional chaperone overhead: 1% contract checking overhead: 96% Figure \n8: Realistic procedure benchmark results Run times in milliseconds  Racket ~Racket Chicken Larceny V8 \nSM bubble 1,317 1,315 4,341 680 463 552 proxy   124,215 97,226 chaperone 6,358 29,171 unsafe 885 3,020\u00b1 \n815 unsafe* 692 ~Racket corresponds to Racket without specialized JIT handling of chap\u00aderoned vectors. \nChicken in unsafe mode corresponds to adding -unsafe. Larceny in unsafe mode corresponds to setting (compiler-switches \nfast-unsafe) before using compile-file. Figure 9: Vector microbenchmark results keyboard A test of \nDrRacket s responsiveness to key\u00adboard events, which simulates a user typing (abc) 400 times. DrRacket \nreacts by adding the characters to an editor buffer, matching parentheses and syntax-coloring through \nan associated coroutine (that is covered in the timing result). Contracts from many different Racket \nli\u00adbraries are involved.  slideshow Construction of a Slideshow talk that in\u00adcludes many animations, \nso that the slide set contains over 1000 frames. The relevant contracts are mainly on the construction \nof pict values that are composed to form the animation frames.  plot Renders a 3-D plot to a PNG .le. \nThe relevant contracts are mainly on the drawing library.  typecheck Runs the Typed Racket compiler \non test input. The Typed Racket compiler uses many higher\u00adorder contracts on its internal modules.  \nFigure 8 shows timing results. For each program, we show the run time, number of created procedure chaperones \n( makes ), and number of calls to chaperoned procedures ( calls ). We then show how the timing changes \nwhen chap\u00aderones are replaced internally with impersonators (skipping the chaperone-of? check), when \napplication of a chaperone procedure redirects internally to the chaperoned procedure (avoiding the overhead \nof the interposition procedures that actually check contracts), and when chaperone-procedure is internally \nshort-circuited to just return the procedure (ef\u00adfectively disabling the contracts in the original code). \nThe results show that the cost of checking contracts is some\u00adtimes quite signi.cant as exposed by the \ntime difference when interposition procedures are skipped while the over\u00adhead of the core chaperone and \nimpersonator mechanism is negligible or small for these programs.  6.2 Vector Performance Our microbenchmark \nfor vector performance is bubble sort on a vector of 10,000 integers in reverse order. Figure 9 msecs \nmakes refs ode-apply 10,632 1,456,221 40,817,268 chaperone 10,236 1,456,221 40,817,268 impersonate 9,265 \n1,456,221 40,817,268 no interpose 7,794 1,456,221 0 no chaperone 5,532 0 0 no procedure vector proxy \noverhead: 19% additional vector chaperone overhead: 4% vector contract checking overhead: 10% procedure \nand vector contract use overhead: 92% Figure 10: Realistic vector benchmark results shows timing results, \nwhere the ~Racket column cor\u00adresponds to Racket with speci.c JIT support for chaper\u00adoned vectors removed; \nwe include the column to demon\u00adstrate how building chaperone and impersonator support into the run-time \nsystem allows the JIT to substantially reduce the overhead of proxies on vectors. The proxy variant for \nJavascript uses makeForwardingHandler from Van Cutsem and Miller (2010), while chaperone uses a Racket \nvector chaperone. Besides the overhead of proxies when used, and in con\u00adtrast to procedure chaperones \nand inspectors, chaperones and inspectors for vectors are not completely pay as you go in Racket. The \ntable in Figure 9 includes an unsafe row to show the performance of bubble sort when vector-ref operations \nare replaced by unsafe-vector-ref. While the unsafe-vector-ref operation assumes that its ar\u00adguments \nare a vector and an in-range index, the vector may be a chaperoned or impersonated vector. The un\u00adsafe* \nrow shows performance using unsafe-vector*-ref, which assumes a non-chaperoned, non-impersonated vec\u00adtor. \nThese unsafe operations are suitable for use in macro expansions or typed contexts where the operations \nare statically known to be safe, and in most such contexts, unsafe-vector-ref must be used. The difference \nin per\u00adformance between unsafe and unsafe* thus re.ects a price imposed on unsafe-vector-ref by the existence \nof chap\u00aderones and impersonators. The cost is small, though not neg\u00adligible for the microbenchmark. We \nuse the williams/science.plt PLaneT package to illustrate the impact on realistic programs with exten\u00adsive \nuse of vector contracts. Many functions from this package expect vectors of real numbers as inputs. We \nad\u00adjusted a test case for ode-evolve-apply so that it per\u00adforms 1,456,221 iterations; the argument vector \nin the test is short, but the vector is accessed frequently, so that 40 mil\u00adlion accesses are chaperoned. \nFigure 10 shows the bench\u00admark results; as for the benchmark suite for procedures, we show how the timing \nchanges when chaperones are re\u00adplaced internally with impersonators, when access of a chap\u00aderoned vector \ndirectly accesses the vector content (skip\u00adping the interposition that checks for a real number), and \nwhen chaperone-vector is internally short-circuited to re\u00adRun times in milliseconds  Racket Chicken \nLarceny V8 SM direct 902 2,324\u00b1 756\u00b1 293 349 proxy  39,345 21,768 chaperone 5,835 unsafe 289 1,250\u00b1 \n800 unsafe* 285 Figure 11: Structure microbenchmark results turn its .rst argument (as if no contracts \nwere present in the original code). Finally, we show the time when both chaperone-vector and chaperone-procedure \nare short\u00adcircuited, which completely removes the contract from ode-evolve-apply. The cost of checking \nthe contract on vector elements is small, while the use of a contract over\u00adall is a substantial cost. \nThe overhead imposed speci.cally by the chaperone and impersonator mechanism is more sub\u00adstantial than \nin the case of procedures, but it is in line with the overall cost of using contracts.  6.3 Structure \nPerformance Our microbenchmark for structure performance is to access the .rst .eld of a two-element \nstructure 100 million times. Figure 11 shows timing results that are analogous to the vec\u00adtor benchmarks. \nAlthough an unsafe structure reference via unsafe-struct-ref must pay for the existence of chaper\u00adones \nand impersonators, the extra test makes little difference in our benchmark, as re.ected in the close \nresults for unsafe and unsafe*; that the difference appears so small is prob\u00adably due to accessing the \nsame structure repeatedly in the microbenchmark, so that the type tag is always in cache. For a more \nrealistic benchmark, we re-use a benchmark from Findler et al. (2007) s work on lazy contracts that con\u00adsists \nof replaying a trace of heap operations from Felzen\u00adszwalb and McAllester (2006) s vision algorithm. \nWe replay the trace in a binomial heap. Contracts on the heap opera\u00adtions ensure that the heap is well-formed, \nbut checking them at every step is prohibitively expensive, so the contracts are checked lazily. These \ncontracts ensure that the structure of the heap is well-formed as far as it is explored, but unex\u00adplored \nparts of the heap are not checked. The original im\u00adplementation of lazy structure contracts required \nthat the program is changed to use a special structure-declaration form, while the new chaperone-based \nversion works with the original structure declaration. The chaperone-based ver\u00adsion is also lazier, in \nthat structure checks are triggered per\u00ad.eld; with the old implementation, an access of any of a structure \ns .elds would trigger checking on all of the .elds. An advantage of the old implementation, however, \nwas that it could drop unchecked .eld values after checking them, msecs makes refs Mbytes lazy 18,616 \n6,026,413 235,002,269 446 chaperone 22,122 0 0 227 original 2,824 0 0 153 no contract structure contract \nchecking overhead: 559% chaperones versus original: 84% Figure 12: Realistic structure benchmark results \nwhile the chaperone-based implementation merely prevents the unchecked variants from being accessed. \nFigure 12 shows the result of running the benchmark on a picture of a koala s face. The .gure shows the \nrunning times, number of created structure chaperones, number of chaperoned structure references, and \npeak memory use of the benchmark in three con.gurations: using the chaperone\u00adbased implementation of \nlazy contracts, using the original implementation of lazy contracts, and using no contracts. The chaperone-based \nimplementation is faster than the orig\u00adinal implementation, mainly due to its .ner granularity of contract \nchecking, but it also uses more memory, since it retains unchecked versions after checked versions are \navail\u00adable. Overall, the benchmark results show that chaperones perform well for lazy structure contracts. \nAside from these benchmarks, structure chaperones in Racket directly improved the performance of Racket \ns class system. Prior to support for chaperones, the class system implemented object-speci.c wrappers \nthat operated like im\u00adpersonators. All object operations required a check on the target object to determine \nwhether it was a wrapped ob\u00adject, and since this test was outside the core run-time sys\u00adtem, the JIT \ncompiler was not able to recognize the imper\u00adsonator pattern and optimize for the common case. In fact, \nthe check interfered with optimizations that the JIT com\u00adpiler could otherwise perform, and the result \nwas a 3x slow\u00addown on .eld-intensive microbenchmarks that did not use contracts (Strickland and Felleisen \n2010). After switching the implementation to use impersonators, this slowdown was completely eliminated. \n 6.4 Discussion Chaperones and impersonators, as implemented in Racket, are expressive and expensive \nconstructs; microbenchmarks indicate a factor of 5 to 10 in run time over normal, unin\u00adlined function \ncall or a vector or structure access (see Fig\u00adure 7). Despite this cost, real applications experience \na much lower slowdown when using them, up to a factor of 2 and usually less (see the contract checking \noverhead results in Figures 8 and 10), although lazy contracts can be expensive (see Figure 12). Considering \nour microbenchmarks and our measurements of larger applications as a whole, we draw the following conclusions: \nRacket s baseline performance and its proxy perfor\u00admance are on par with other production systems offering \nsimilar functionality (see Figure 7). Slower performance from Racket s impersonators compared to JavaScript \ns proxies would have been a cause for concern, since the overall design of Racket generally makes it \neasier to im\u00adplement ef.ciently than JavaScript.  The design of interposition to Racket imposes almost \nno cost on the remainder of the system when it is not used, and the exception for unsafe operations is \nsmall (see the unsafe vs. unsafe* lines in Figures 7, 9, and 11).  The cost of interposition is quite \nreasonable for our pri\u00admary application, contract checking. In real programs, the cost of interposition \nitself is dominated by the cost of actually checking the contracts. (Contrast the proxy overhead lines \nand contract checking overhead lines of Figures 8 and 10; see also the chaperones versus orig\u00adinal line \nof Figure 12.)  Although Racket supports a rich hierarchy of interposi\u00adtion to maintain the language \ninvariants, this additional complexity and the required dynamic checks imposes at most 4% overhead in \nall of our testing (as re.ected by the additional chaperone overhead results in Figures 8 and 10). As \nmentioned in Section 7, JavaScript s proxy design limits its expressiveness by reducing the dynamic checks \nit performs, but our measurements indicate that these checks are inexpensive.  Adding support for interposition \nto the Racket run\u00adtime realizes signi.cant performance bene.ts for exist\u00ading Racket libraries that otherwise \nimplement interposi\u00adtion manually, such as class contracts and lazy structure contracts (see Figure 12 \nand the last paragraph of Sec\u00adtion 6.3).  7. Related Work Related work falls into two main categories: \nimplementa\u00adtions of interposition and implementations of contracts. 7.1 Other Interposition Implementations \nThe most closely related work to ours is the proxy de\u00adsign (Van Cutsem and Miller 2010) proposed for \nJavaScript, which is currently implemented in both Firefox and Chrome\u00adand used in the benchmarks of section \n6. Building on the design of mirages in AmbientTalk (Dedecker et al. 2005; Mostinckx et al. 2009), proxies \nallow interposition of al\u00admost any operation performed on JavaScript objects. Like our design, theirs \ndoes not support interposition on some operations, including instanceof tests, typeof tests, and the \nequality operator ===. Since JavaScript operations such as vector indexing are represented as message \nsends, only one proxy API is needed, in contrast to our separate APIs for separate kinds of Racket values. \nThe JavaScript proxy API is in .ux; in particular, Van Cutsem and Miller have recently proposed a new \ndesign called direct proxies (Van Cutsem and Miller 2012) for the proxy system which differs signi.cantly \nfrom the original design as implemented in current JavaScript engines. We discuss both designs here. \nThe initial JavaScript proxy design differed most signi.\u00adcantly from chaperones by dispensing with the \nobject being wrapped by the proxy. In other words, a proxy was not a proxy for any other object. This \nsimpli.es the implementa\u00adtion of some uses of proxies, but in practice, most uses of proxies have a target, \nas chaperones do. This difference lead to the second major difference be\u00adtween JavaScript proxies and \nour design: how each avoids breaking existing language invariants. JavaScript provides very few invariants \nthat programmers may assume about the behavior of objects, due to pervasive mutability of both objects \nand prototypes even allowing so-called monkey\u00adpatching where the behavior of all objects is affected \nby a single mutation. Further, there is no analogue in JavaScript of the type tests provided by struct \npredicates (see section 2.3 for the importance of these in Racket) and thus JavaScript programmers do \nnot conditionalize code on such tests. Fi\u00adnally, JavaScript provides no reliable structural equality \ncomparison. Since these invariants do not hold for JavaScript programs, proxies need not respect them, \nsimplifying their design considerably. In contrast, the existing design of Racket, as in most languages, \nensures that programmers can reason using a wide variety of invariants based on information hiding, type \nand equality testing, and immutable objects. Programmers rely on these invariants to build applications, \nand compilers and static checkers rely on them to reason about programs. Therefore, our design of an \ninterposition API is constrained to respect them. The current JavaScript language does, however, provide \nre.ective operations which can prevent future mutations to a single .eld, or to an entire object. The \noriginal proxy de\u00adsign handled this awkwardly, by producing an entire new ob\u00adject which was then restricted \nfrom being mutated. This pre\u00advented any further interposition on operations on immutable objects, as \nwell as adding implementation complexity. These problems, along with discussions with the authors of \nthis paper (chaperones and impersonators were origi\u00adnally added to Racket in May 2010), led Van Cutsem \nand Miller to propose a new proxy API, dubbed direct prox\u00adies, which is closely related to our design \nof chaperones and impersonators. In this design, proxies are always prox\u00adies for a particular object. \nFurther, proxies are required to respect the mutability constraints of the proxied object if a .eld is \nimmutable, the result of a proxied access to the .eld is checked to be identical to the underlying .eld. \nSince JavaScript objects and .elds can transition from mutable to immutable during execution, the proxy \ndesign does not dis\u00adtinguish ahead of time between chaperones and imperson\u00adators; instead the new invariants \nare enforced once a .eld has become immutable.  While the direct proxy design is quite similar to ours, \nit is more limited in a fundamental way: proxies for immutable or otherwise restricted .elds must produce \nidentical results, whereas chaperones may produce results with further chap\u00aderone wrapping, as checked \nby the chaperone-of? proce\u00addure. This signi.cantly complicates using JavaScript prox\u00adies to implementing \nhigher-order contracts on immutable data, including any contract on methods of an immutable ob\u00adject. \nThe measurements of section 6 demonstrate that these checks impose little overhead, and therefore the \nJavaScript design could be signi.cantly more expressive with rela\u00adtively little performance cost. These \nwrappings do affect the identity of objects, as compared with JavaScript s === or Racket s eq? comparisons. \nSince JavaScript, much more than Racket, relies on object identity for comparison, this consideration \nled the designers of proxies to impose this restriction.5 Austin et al. (2011) extend the original JavaScript \nproxy design to primitive values such as integers and use the sys\u00adtem to design a contract system (without \nblame) for a core JavaScript calculus, including mutable data. Many other tools that allow unrestricted \nforms of prox\u00adying help to implement contracts but sacri.ce the kind of control over invariants that \ncontracts are intended to pro\u00admote. Notable examples include the MOP (Kiczales et al. 1991), aspect-oriented \nprogramming (Kiczales et al. 1997), and java.lang.reflect.Proxy (Oracle 2000). In this vein, our goals \nwith chaperones and impersonators are related to the ideas of observers and assistants (Clifton and Leavens \n2002), narrowing advice (Rinard et al. 2004), and harmless advice (Dantas and Walker 2006), and other \nsystems like Open Modules (Aldrich 2005) and EffectiveAd\u00advice (Oliveira et al. 2010) enforce harmless \nadvice by con\u00adstraining side effects. Chaperones and impersonators, in contrast, represent a new design \npoint in this space with a different trade-off be\u00adtween enforceable invariants and interposition expressive\u00adness. \nSpeci.cally, Racketeers already program in a world with mutable state and concurrency, so we do not try \nto regain the kinds of reasoning that such a combination al\u00adready invalidates. Instead, since most Racket \nprograms op\u00aderate mostly with immutable values, chaperones and imper\u00adsonators are limited to ensure that \ninvariants relating to the behavior of immutable structures are preserved. Although Balzer et al. (2005) \npoint out that aspects alone do not provide all of the tools necessary to implement con\u00adtracts, aspects \nwould allow us to implement the core func\u00adtionality of contract checking and, in Racket, macros make \nup the difference.  7.2 Other Contract Implementations Eiffel (Meyer 1991), the original embodiment \nof Design by Contract, supports contracts directly in the language run\u00ad 5 Personal communication, Tom \nVan Cutsem, August 2012. time system. Contracts in Eiffel are limited so that they can be compiled directly \ninto pre-and post-condition checks on methods; for example, higher-order contracts on individ\u00adual objects \nare not supported. Eiffel is also less extensible as a programming language. Other notable examples in \nthe Eiffel category include Euclid (Lampson et al. 1977), Ada (via Anna (Luckham and Henke 1985)), D \n(Digital Mars 1999), and others have built contract extensions for exist\u00ading languages including for \nJava, Python, Perl, and Ruby and Ciao (Mera et al. 2009). In all of these cases, contracts are more easily \nimplemented in the core or through pre\u00adpreprocessing since the contracts are more limited, the lan\u00adguage \nis typically less extensible, and the contract system is always less extensible. Disney (2012) uses JavaScript \nproxies to implement con\u00adtracts, producing a system that supports many of the contract system features \ndescribed in section 2, although lacking ex\u00adtensions such as opaque contracts. We take this as validation \nof the strategy presented here: design a robust system for low-level interposition, and build a contract \nsystem (as well as other applications) on top. Our microbenchmark results indicate that the system is \nnot yet performant under heavy use of contracts. Several libraries for Haskell (Chitil 2012; Chitil and \nHuch 2006; Chitil et al. 2003; Hinze et al. 2006) support con\u00adtract and assertion checkers that include \nboth speci.cations for higher-order functions and combinators for building the speci.cations. Their implementations \ncould bene.t from support for impersonators and chaperones. Finally, Findler, Guo, and Rogers s earlier \nwork on lazy contracts (Findler et al. 2007) helped us understand how impersonators and chaperones should \nwork, although their work does not handle contracts on mutable data structures. 8. Conclusion New language \nconstructs provide a way for programmers to express and then rely on complex invariants about program \nbehaviors. Implementing some constructs -such as a full\u00adfeatured contract system requires the ability \nto interpose on the programming language s primitive operations. At the same time, general-purpose interposition \non primitive opera\u00adtions makes reasoning about program behavior too dif.cult, because it forces programmers \nto cope with the possibility of invoking unknown and potentially untrusted code, even when using seemingly \nsimple operations like vector lookup or .eld selection. Worse, Racket programmers routinely ex\u00adploit \ngenerativity to ensure that complex invariants on data structures hold; with unrestricted forms of interposition, \na simple tag check cannot reliably ensure these invariants. To address these two problems, we have designed \nchap\u00aderones and impersonators as a controlled form of interposi\u00adtion. The design enables the implementation \nof a rich con\u00adtract system without giving away the programmer s ability to reason about the behavior \nof programs.  Acknowledgements Thanks to Tom Van Cutsem for valuable discussions about proxies and chaperones \nover several years. Thanks to Daniel Brown, Christos Dimoulas, and Matthias Felleisen for their feedback \non earlier versions of this work. The technical appendicies are available in the ACM Dig\u00ad ital Library \n(together with this paper) and online at http://sstrickl.net/chaperones/ Bibliography Jonathan Aldrich. \nOpen Modules: Modular Reasoning About Ad\u00advice. In Proc. European Conf. Object-Oriented Programming, 2005. \nThomas H. Austin, Tim Disney, and Cormac Flanagan. Virtual Values for Language Extension. In Proc. ACM \nConf. Object-Oriented Programming, Systems, Languages and Applications, 2011. Stephanie Balzer, Patrick \nEugster, and Bertrand Meyer. Can As\u00adpects Implement Contracts? In Proc. Rapid Implemetation of Software \nEngineering Techniques, pp. 145 157, 2005. Olaf Chitil. Practical Typed Lazy Contracts. In Proc. ACM \nIntl. Conf. Functional Programming, 2012. Olaf Chitil and Frank Huch. A pattern logic for prompt lazy \nasser\u00adtions. In Proc. Intl. Sym. Functional and Logic Programming, pp. 126 144, 2006. Olaf Chitil, Dan \nMcNeill, and Colin Runciman. Lazy Assertions. In Proc. Intl. Sym. Functional and Logic Programming, 2003. \nCurtis Clifton and Gary T. Leavens. Observers and assistants: A proposal for modular aspect-oriented \nreasoning. In Proc. Foun\u00addations of Aspect-Oriented Languages, 2002. Daniel S. Dantas and David Walker. \nHarmless Advice. In Proc. ACM Sym. Principles of Programming Languages, 2006. Jessie Dedecker, Tom Van \nCutsem, Stijn Mostinckx, Theo D Hondt, and Wolfgang De Meuter. Ambient-Oriented Pro\u00adgramming. In Proc. \nACM Conf. Object-Oriented Programming, Systems, Languages and Applications, pp. 31 40, 2005. Digital \nMars. D Programming Language. 1999. http://www. digitalmars.com/d/ Tim Disney. Contracts.coffee. 2012. \nhttp://disnetdev.com/ contracts.coffee/ James E. Donnelley. A distributed capability computing system. \nIn Proc. Intl. Conf. on Computer Communication, 1976. Pedro Felzenszwalb and David McAllester. A min-cover \napproach for .nding salient curves. In Proc. IEEE Wksp. Perceptual Or\u00adganization in Computer Vision, \n2006. Robert Bruce Findler and Matthias Felleisen. Contracts for Higher-Order Functions. In Proc. ACM \nIntl. Conf. Functional Program\u00adming, pp. 48 59, 2002. Robert Bruce Findler, Shu-yu Guo, and Anne Rogers. \nLazy Con\u00adtract Checking for Immutable Data Structures. In Proc. Imple\u00admentation and Application of Functional \nLanguages, 2007. Matthew Flatt and PLT. Reference: Racket. PLT Inc., PLT-TR\u00ad2010-1, 2010. http://racket-lang.org/tr1/ \n Brian Hackett and Shu-Yu Guo. Fast and precise type inference for JavaScript. In Proc. Conf. on Programming \nLanguage Design and Implementation, 2012. Ralf Hinze, Johan Jeuring, and Andres L\u00f6h. Typed Contracts \nfor Functional Programming. In Proc. Sym. Functional and Logic Programming, pp. 208 225, 2006. Gregor \nKiczales, John Lamping, Anurag Mendhekar, Chris Maeda, Cristina Lopes, Jean-Marc Loingtier, and John \nIrwin. Aspect-Oriented Programming. In Proc. European Conf. Object-Oriented Programming, pp. 220 242, \n1997. Gregor J. Kiczales, James des Rivieres, and Daniel G. Bobrow. The Art of the Metaobject Protocol. \nMIT Press, 1991. B. W. Lampson, J. J. Horning, R. L. London, J. G. Mitchell, and G. J. Popek. Report \non the programming language Euclid. ACM SIGPLAN Notices 12(2), pp. 1 79, 1977. D. C. Luckham and F. W. \nvon Henke. An overview of Anna, a speci.cation language for Ada. IEEE Software 2(2), pp. 9 22, 1985. \nJacob Matthews and Amal Ahmed. Parametric Polymorphism Through Run-Time Sealing, or, Theorems for Low, \nLow Prices! In Proc. European Sym. on Programming, 2008. E. Mera, P. Lopez-Garcia, and M. Hermenegildo. \nIntegrating Soft\u00adware Testing and Run-Time Checking in an Assertion Veri.\u00adcation Framework. In Proc. \nIntl. Conf. on Logic Programming, LNCS 5649, 2009. Bertrand Meyer. Eiffel : The Language. Prentice Hall \nPTR, 1991. Mark S. Miller. Robust Composition: Towards a Uni.ed Approach to Access Control and Concurrency \nControl. PhD dissertation, John Hopkins University, 2006. Stijn Mostinckx, Tom Van Cutsem, Elisa Gonzalez \nBoix, Stijn Timbermont, \u00c9ric Tanter, and Wolfgang De Meuter. Mirror\u00adbased re.ection in AmbientTalk. Software \nPractice and Ex\u00adperience 39, pp. 661 699, 2009. Toby Murray. Analysing the Security Properties of Object-Capability \nPatterns. PhD dissertation, Hertford College, Oxford University, 2010. Bruno C. d. S. Oliveira, Tom Schrijvers, \nand William R. Cook. EffectiveAdvice: Disciplined Advice with Explicit Effects. In Proc. Aspect-Oriented \nSoftware Development, 2010. Oracle. java.lang.re.ect.Proxy. 2000. http://download.oracle. com/javase/6/docs/api/java/lang/reflect/Proxy.html \n Susan A. Rajunas. The KeyKOS/KeySAFE system design. Key Logic, Inc, SEC009-01, 1989. http://www.cis.upenn.edu/ \n~KeyKOS Martin Rinard, Alexandru Salcianu, and Suhabe Bugrara. A Clas\u00adsi.cation System and Analysis \nfor Aspect-Oriented Programs. In Proc. Intl. Sym. on the Foundations of Software Engineering, 2004. T. \nStephen Strickland and Matthias Felleisen. Contracts for First-Class Classes. In Proc. Dynamic Languages \nSymposium, pp. 97 112, 2010. Sam Tobin-Hochstadt and Matthias Felleisen. The Design and Im\u00adplementation \nof Typed Scheme. In Proc. ACM Sym. Principles of Programming Languages, pp. 395 406, 2008. Tom Van Cutsem \nand Mark Miller. Proxies: Design Principles for Robust Object-oriented Intercession APIs. In Proc. Dynamic \nLanguages Symposium, pp. 59 72, 2010. Tom Van Cutsem and Mark Miller. On the design of the EC-MAScript \nRe.ection API. Vrije Universiteit Brussel, VUB\u00adSOFT-TR-12-03, 2012.     \n\t\t\t", "proc_id": "2384616", "abstract": "<p>Chaperones and impersonators provide run-time support for interposing on primitive operations such as function calls, array access and update, and structure field access and update. Unlike most interposition support, chaperones and impersonators are restricted so that they constrain the behavior of the interposing code to reasonable interposition, which in practice preserves the abstraction mechanisms and reasoning that programmers and compiler analyses rely on.</p> <p>Chaperones and impersonators are particularly useful for implementing contracts, and our implementation in Racket allows us to improve both the expressiveness and the performance of Racket's contract system. Specifically, contracts on mutable data can be enforced without changing the API to that data; contracts on large data structures can be checked lazily on only the accessed parts of the structure; contracts on objects and classes can be implemented with lower overhead; and contract wrappers can preserve object equality where appropriate. With this extension, gradual typing systems, such as Typed Racket, that rely on contracts for interoperation with untyped code can now pass mutable values safely between typed and untyped modules.</p>", "authors": [{"name": "T. Stephen Strickland", "author_profile_id": "81418592910", "affiliation": "Northeastern University, Boston, MA, USA", "person_id": "P3856214", "email_address": "sstrickl@ccs.neu.edu", "orcid_id": ""}, {"name": "Sam Tobin-Hochstadt", "author_profile_id": "81319502825", "affiliation": "Northeastern University, Boston, MA, USA", "person_id": "P3856215", "email_address": "samth@ccs.neu.edu", "orcid_id": ""}, {"name": "Robert Bruce Findler", "author_profile_id": "81100028925", "affiliation": "Northwestern University, Evanston, IL, USA", "person_id": "P3856216", "email_address": "robby@eecs.northwestern.edu", "orcid_id": ""}, {"name": "Matthew Flatt", "author_profile_id": "81100490544", "affiliation": "University of Utah, Salt Lake City, UT, USA", "person_id": "P3856217", "email_address": "mflatt@cs.utah.edu", "orcid_id": ""}], "doi_number": "10.1145/2384616.2384685", "year": "2012", "article_id": "2384685", "conference": "OOPSLA", "title": "Chaperones and impersonators: run-time support for reasonable interposition", "url": "http://dl.acm.org/citation.cfm?id=2384685"}