{"article_publication_date": "10-19-2012", "fulltext": "\n Checking Reachability using Matching Logic * Grigore Ro\u00b8su Andrei \u00b8anescu Stef.University of Illinois \nat Urbana-Champaign University of Illinois at Urbana-Champaign Alexandru Ioan Cuza University, Ia\u00b8si, \nRomania stefane1@illinois.edu grosu@illinois.edu Abstract This paper presents a veri.cation framework \nthat is para\u00admetric in a (trusted) operational semantics of some program\u00adming language. The underlying \nproof system is language\u00adindependent and consists of eight proof rules. The proof sys\u00adtem is proved partially \ncorrect and relatively complete (with respect to the programming language con.guration model). To show \nits practicality, the generic framework is instantiated witha fragmentofCandevaluated with encouraging \nresults. Categories and Subject Descriptors D.2.4[SoftwareVeri\u00ad.cation]:Formal methods; D.2.5[Testing \nand Debugging]: Symb.execution; F.3.1[Specifying andVerifying and Rea\u00adsoning about Programs]: Mechanicalveri.cation; \nF.3.2[Se\u00admantics of Programming Languages]: Operational semantics GeneralTerms Languages,Veri.cation, \nTheory Keywords Reachability, Hoare logic, matching logic 1. Introduction Compared to other programming \nlanguage semantic ap\u00adproaches, operational semantics are easier to understand and de.ne, since we can \nthink of them as formal interpreters for the languages theyde.ne. Moreover and perhaps more impor\u00adtantly, \nthey can be e.ciently executable, and thus testable, the same way we test language implementations: by \nexecuting large test suites of programs (see, e.g.,[1,4, 10]for the case of C). This way, errors are \ndetected and .xed, and con.dence in the semantics is incrementallybuild. It is therefore quite common \nthat operational semantics are considered trusted reference models of the programming languages theyde.ne. \nOn the other hand, existing program reasoning approaches, such as Hoare/separation/dynamic logics, require \nus to * The companion report [30] includes proofs of all the claimed results. Permission to make digital \nor hard copies of all or part of this work for personal or classroom use is granted without fee provided \nthat copies are not made or distributed for pro.t or commercial advantage and that copies bear this notice \nand the full citation on the .rst page.To copy otherwise, to republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. OOPSLA 12, October 19 26, 2012,Tucson, Arizona, \nUSA. Copyright &#38;#169; 2012ACM 978-1-4503-1561-6/12/10. . . $10.00 (re)de.ne the target language semantics \nas a set of proof rules, which are often hard to understand and thus trust.For that reason, the state-of-the-art \nin mechanical veri.cation is to prove such language-speci.c proof systems sound with re\u00adspect to another, \nmore trusted semantics. Since the semantics of real languages can consist of hundreds or even thousands \nof rules, this duplication of work is at best uneconomical. Worse, in order to even be possible to de.ne \na language semantics in these formalisms, non-trivial and specialized extensions of program logics are \ndeveloped (e.g., a sepa\u00adration logic for Javascript , etc.). Since such extensions are likely non-reusable, \nthey are not worth investigating in full depth. Consequently, current programveri.cation approaches and \ntools are not easy to adapt to real languages, and even the most advanced are only shown sound and/or \nrelatively complete for small fragments of their target languages. What we want is a framework which \ntakes a trusted se\u00admantics of some arbitrary programming language, say an o.-the-shelf well-tested operational \nsemantics, and automat\u00adically (with zero e.ort) provides the following: (1) an ex\u00adpressive speci.cation \nformalism for properties of programs in that language; and(2) a sound, complete and practical means for \nproving such language-speci.c program proper\u00adties. Building upon matching logic for (1), we give the \n.rst language-independent, sound and relatively complete proof system for (2). Our proof system consists \nof eight proof rules for reachability. To show its practicality, we have applied the generic frameworktoa \nfragmentoftheC language,by simply passing the operational semantics of the language, unchanged, as axioms \nto the proof system, and by adding a few heuristics for which proof rules to apply and when. Matching \nlogic[31]is designed to state and reason about structural properties of arbitrary program con.gurations. \nSyn\u00adtactically, it introduces a new formula construct, called a pattern, which is a con.guration term \npossibly containing variables. Semantically, its models are concrete/ground con\u00ad.gurations, where a con.guration \nsatis.es a pattern i. it matches it.Fora con.guration signature witha top-level cell .....cfg holding \nother cells with semantic data such as code .....k, environment .....env, heap .....heap, input bu.er \n.....in, outputbu.er .....out, etc., con.gurations have the form ......k .....env .....heap .....in .....out \n....cfg  The cells contents can be various semantic data, such as trees, lists, maps, etc. Here are \ntwo particular con.gurations (in the interest of space, we use ... for the irrelevant parts of them): \n..x=*y; y=x; ....k .x ..7, y ..3, ....env .3 .. 5.heap ....cfg ..x ..3.env .3..5, 2..7.heap .1,2,3,....in \n...., 7, 8, 9.out ....cfg Di.erent languages may have di.erent con.guration struc\u00adtures.Forexample, languages \nwhose semantics are intended to be purely syntactic and based on substitution, e.g., .\u00adcalculi, may contain \nonly one cell, holding the program itself. Other languages may contain dozens of cells in their con.gu\u00adrations; \nforexample, theC semanticsin[10]has more than 70 nested cells. However, no matter how complex a language \nis, its con.gurations can be de.ned as elements in an alge\u00adbra, using conventional algebraic techniques. \nMatching logic takes an arbitrary algebraic de.nition of con.gurations as parameter and allows con.guration \nterms with variables as particular formulae.Forexample, the formula .c:Cells, e:Env, p:Nat, i:Int,s :Heap \n..x .. p, e.env .p .. i,s.heap c.cfg . i > 0 . p . i is satis.ed by all con.gurations where program variable \nx holds a location p holding a di.erent positive integer. The variables e, s, and c are structural frames. \nIf we want to additionally state that p is the only location allocated, then we can just remove s. Matching \nlogic allows us to reason about con.gurations, e.g., to prove: |= .c:Cells, e:Env, p:Nat ..x .. p, e.env \n.p..9.heap c.cfg . p> 10 ..i:Int,s :Heap ..x .. p, e.env .p..i,s.heap c.cfg .i> 0. p. i Since con.guration \nterms with variables are particular pat\u00adterns, typical reduction rules left . right used to de.ne oper\u00adational \nsemantics (several operational semantics approaches based on such rules are discussed in Section 5) are \nparticular matching logic reachability rules[28]of the form . . . ' , where . and . ' are patterns, so \nsuch operational semantics become setsofreachability rules.Forexample, the following reachability rule \ngives the operational semantics of variable assignment in a language over con.gurations like above: ..x \n= i;s.k .x .. j, e.env c.cfg . ..s.k .x ..i, e.env c.cfg Reachability rules as used above only specify \none-step reach\u00adability,butin general they canexpress anynumberof steps. Asshownin[29],they areinfactexpressive \nenoughto spec\u00adify anyprogram properties that can be expressed using Hoare triples. Therefore, despite \nconceptual simplicity, such reacha\u00adbility rules are quite expressive, subsuming the main elements of \nboth operational and axiomatic semantics. These obser\u00advation makes it desirable to have a framework allowing \nto derive sequents A. . .. ' , where A is a set of axioms (i.e, trusted) reachability rules and . . . \n' a reachability rule to be proved. If A is the semantics ofC and . . . ' a reachability propertyof someCprogram, \nforexample, then such a proof system would allow us to prove such a property based entirely on the operational \nsemantics of C. No other semantics forveri.cation purposeswouldbe needed. In this paper we give an eight-rule \nproof system for more general sequents, of the form A .C . . . ' , where C is also a set of reachability \nrules. The intuition for such sequents is that the reachability property . . . ' holds under the hypothesesAand \nC, provided that the .rst step is always one from A whenever Cis non-empty. The rules in Care called \ncircularities. The desired sequents A. . . . ' are recovered when Cis empty. The characteristic rule \nof our proof system, which allows to add circularities, is the following: A .C.{... '} . . . ' Circularity \n: A .C . . . ' The Circularity rule therefore allows to make a new circularity claim at any moment during \na proof derivation. In practice one typically makes such claims for code with repetitive behaviors, such \nas loops, recursive functions, jumps, etc. If one succeeds to prove the circularity claim using itself, \nthen the claim holds. This circular reasoning would obviously be unsound if used unrestricted. What makes \nthe reasoning with circularities well-founded and thus sound is the following modi.edTransitivity rule, \nwhich unleashes the circularities only after at least one trusted step, i.e., one from the set of axioms \nA(i.e., an operational semantics rule), is applied: A .C .1 .+ .2 A.C . .2 . .3 Transitivity : A .C .1 \n. .3 The .+ in the .rst premise implies at least one step cor\u00adresponding to a rule in A has been applied. \nIn concrete in\u00adstances, that operational step is typically a loop unrolling step, or a function invocation \nstep, or a jump, etc. The remain\u00ading six proof rules (Figure 7) and the soundness theorem for the entire \nproof system (Theorem 1), in the sense of partial correctness, are given in Section 6. Our language-independent \neight-rule proof system can therefore be used to derive reachability properties of pro\u00adgrams in anylanguage, \nprovided that an operational seman\u00adtics of that language is provided. But how powerful is it? In Section7 \nwe show that our proof system is infact relatively complete. That means that it can derive anyreachability \nprop\u00aderty of anyprogram in the given programming language. Note that this is a signi.cant improvement \nover the state-of-the-art, as conventional program veri.cation logics, like Hoare logic or dynamic logic, \nneed to be proved relatively complete for each language separately.We prove our relative completeness \nresult for matching logic reachability once and for all, for all languages. The relativity in our completeness \nresult comes from thefact that our setting, including the proof system, are parametricina modelof con.gurations.We \nassumean oracle telling whether the arbitrary but .xed con.guration model satis.es a given .rst-order \nformula or not.  To test the e.ectiveness of our approach, we implemented a programveri.erfora fragmentofC, \ncalledMatchC, which is directly based on the proof system in Figure 7. It uses the operational semantics \nof the fragment of C completely unchanged for programveri.cation.A seriesof non-trivial programs have \nbeen automatically veri.ed using MatchC, some discussed in Sections3and 8. The Matching Logic web page, \nhttp://fsl.cs.uiuc.edu/ml, contains an online interface to run MatchC, where one can try more than 50 \nexisting examples (or type your own). For example, the functional correctness of the Schorr-Waite graph \nmarking algorithm veri.es in less than 2 seconds. Section 8 also discusses how the proof system is being \nmade practical. Contributions This paper makes the following speci.c contributions: 1. Anovel language-independent \nproof system, parametric in an operational semantics of a programming language; 2. A proof of its partial \ncorrectness, saying that anyderived reachability property is semantically valid; 3. A proof of its relative \ncompleteness, saying that any semantically valid reachability property can be derived; 4. An implementation \nof it inMatchC, together with several challengingC programsveri.ed.  We also show that separation logic \ncan be framed as an instance of matching logic for an idealized model of heaps. 2. RelatedWork The idea \nof regarding a program (fragment) as a speci.cation transformer to analyze programs in a forwards-style \ngoes back to Floyd[13]. However, his rules are not concerned with structural con.gurations, are not meant \nto be operational, and introduce quanti.ers. Equational algebraic speci.cations have been used to express \npre-and post-conditions and then verify programs forwards using term rewriting[14]. Evolving speci.cations[24]adapt \nandextend this basic idea to com\u00adpositional systems, re.nement and behavioral speci.cations. What distinguishes \nthe various speci.cation transforming approaches is the formalism they use. What distinguishes matching \nlogic is its apparently low-level formalism, drop\u00adping no detail from the con.guration. The use of variables \nin patterns o.ers a comfortable level of abstraction by mention\u00ading in each rule only the necessary con.guration \ncomponents. The state of the art in mechanized program veri.ca\u00adtion[1, 21]is to de.ne both an operational \nand an axiomatic semantics in a higher-order logic framework, where the two semantics share the de.nition \nof a state , and to prove the axiomatic semantics sound w.r.t. the operational semantics. Then one can \ndeduce theorems about programs using rules from both semantics. While libraries of tactics are developed \nto partially automate the process, it still needs to be done for each language independently. The eight-rule \nproof system proposed in this paper is language-independent and it should be easy to mechanize in a higher-order \nframework. Separation logic[22,25]is anextensionof Hoare logic. There is a major di.erence between separation \nand matching logic: the former enhances Hoare logic to work better with heaps, while the latter provides \nan alternative to Hoare logics in which the con.guration structure is explicit in the speci.cations, \nso heaps are treated uniformly just like any other structures in the con.guration.We study more closely \nthe relationship to separation logic in Section 4.3. Bedrock[5] is a framework which uses computational \nhigher-order separation logic and supports mostly-automated proofs about low-level programs. UnlikeMatchC, \nBedrock requires the user to annotate the source code with hints for lemma applications. Speci.cations \nuse operators de.ned in a pure functional language, similarly to the operators de.ned algebraicallyin \nmatching logic.Tactics employedby Bedrock could likely be adapted for higher-order matching logic. Shape \nanalysis[32]allows toexamine andverify proper\u00adties of heap structures. The ideas of shape analysis have \nalso been combined with those of separation logic[9]to quickly infer invariants for programs operating \non lists. They can likely be also combined with matching logic to infer patterns. Dynamic logic (DL)[15]adds \nmodal operators to FOL to embed program fragments within speci.cations.Forexample, . . [s]. ' means after \nexecuting s in a state satisfying ., a state may be reached which satis.es . ' . In matching logic, programs \nand speci.cations also coexits in the same logic. However, matching logic achieves it by staying within \nFOL and making use of FOL s algebraic signatures and term models. Moreover, DL adds language-speci.c \nproof rules, while our proof system is language-independent. Our own related work. Matching logic was \nintroduced in [31]. However, the proof system there was language-speci.c and not parametric in an operational \nsemantics like the one here.An early implementationofMatchC, based on the proof system in[31], was presented \nin[27]. Our .rst language\u00adindependent proof system is given in[28], and consists of nine rules for deriving \nsequents A. . .. ' , that is, ones without circularities Cwith them. There, the Circularity rule was \nmore complex, mixing ideas from our current Circularity and Transitivity rules, and a now unnecessary \nSubstitution rulewas included.In[29]we were abletoshowthe relative completeness of that proof system \nfor a particular simple language, IMP, by showing how each Hoare logic proof rule of IMP could be mimicked \nwith the proof system in[28]. While all the above are clearly inferior to our new proof system and its \nlanguage-independent proofs of soundness and completeness, they were nevertheless crucial milestones. \n3. Examples usingMatchC Here we discussafewC examples that illustrate theexpres\u00adsiveness and practicality \nof our approach. Figure 1 shows an unde.ned program; Figure 2 a function that reverses a  struct listNode \n{ int val; struct listNode *next; }; int main() { struct listNode *x; x=(struct listNode*) malloc(sizeof(struct \nlistNode)); printf(\"%p\\n\", x->next); } Figure 1. Cprogram exhibiting unde.ned behaviour. singly linked \nlist; Figure3 a function that readsa sequence of integers from the standard input into a singly-linked \nlist; Figure4 a program that respectsa stack inspection property, where some functions can only be called \ndirectly or indirectly by certain other functions, and only under certain conditions; Figure5showsa function \nthat .attensa tree intoa list, travers\u00ading the tree in in.x order and in the process printing the list \nto the standard output in reverse order.MatchCautomatically veri.es all these programs w.r.t. their speci.cations \n(given in the greyboxes) in ~1s in total (Section 8). The unannotated/unspeci.ed program in Figure 1 \nis un\u00adde.ned according to theC standard: it attempts to print the value of the uninitialized list member \nnext. Our operational semantics correctly captures unde.nedness, in that unde.ned programs get stuck \nduring their execution using the semantics. MatchC veri.es programs by executing them according to the \nsemantics. If a fragment of code is given a speci.cation, then that speci.cation is veri.ed and subsequently \nused as a replacement for the corresponding fragment. This is possible in matching logic because both \nthe language semantics and the speci.cations are uniformly given as reachability rules. Since this program \nis unannotated, its veri.cation reduces to executing it according to the semantics, so it gets stuck \nwhen reading x->next.C compilers happily compile this program and the generated code even does what one \n(wrongly) expects it to do, namely prints the residual value of x->next. Some MatchC notations. Each \nuser-supplied rule or in\u00advariant annotation (grayed area in the .gures in this section) corresponds to \na reachability rule, also called a speci.cation, that needs to be derived with the proof system in Figure \n7. For the next speci.cations, we discuss someMatchC nota\u00adtions that help avoid verbosity. (1) While \nall speci.cations are reachability rules . . . ' , often . and . ' share con.gura\u00adtion context; we only \nmention the context once and distribute . through the context where the changes take place. (2)To avoid \nwriting existential quanti.ers, logical variables starting with ? are assumed existentially quanti.ed \nover the cur\u00adrent pattern. (3)Toavoid writing environment cells with only bindings of the form x .. ?x, \nwe automatically assume them when not explicitly mentioned and allow users to write the identi.er x (i.e., \na syntactic constant) instead of the logical variable ?x. (4)MatchC desugars invariants inv . loop into \nrules .[loop...]. .[...].\u00accond(loop), with .[code]the pattern obtained from . setting the contents of \n.....k to code. struct listNode { int val; struct listNode *next; }; struct listNode* reverseList(struct \nlistNode *x) rule .$ . return ?p; \u00b7\u00b7\u00b7.k .\u00b7\u00b7\u00b7 list(x)(A). list(?p)(rev(A)) \u00b7\u00b7\u00b7.heap { struct listNode \n*p; p = NULL; inv .\u00b7\u00b7\u00b7 list(p)(?B), list(x)(?C) \u00b7\u00b7\u00b7.heap . A = rev(?B)@?C while(x != NULL) { struct listNode \n*y; y = x->next; x->next = p; p = x; x = y; } return p; } Figure 2. C function reversing a singly-linked \nlist. Function reverseList in Figure 2 reverses a singly\u00adlinked list. The matching logic rule specifying \nits behavior says that it returns a pointer ?p (here and in the rest of the paper,$ stands for the body \nof the function). The rule also says that, when the function is called, the heap contains a list starting \nat x with contents the sequence A. When the function returns, the initial list is replaced by a list \nstarting at ?p with contents the reversed sequence, rev(A). The \u00b7\u00b7\u00b7 in the heap cell stands for the rest \nof the heap content (the heap frame)which is not touched by the function and thus stays unchanged. Similarly, \nall the parts of the con.guration that are not explicitly mentioned (the con.guration frame)do not change. \nThe loop invariant asserts that the heap contains two lists, one starting at p and containing the part \nof the sequence thatis already reversed, ?B, and one starting atx and containing the part of the sequence \nthat is yet to be reversed, ?C. The initial sequence A equals rev(?B)followed by ?C. Again, the rest \nof the heap and con.guration stay unchanged. Here list, rev, etc., are ordinary operation symbols in \nthe signature and constrained through axioms (Section 4.2). Like in OCaml,@ concatenates sequences.Variables \nwithout ?, like A, are free. Hence, A refers to the same sequence in the function rule and in the loop \ninvariant, while ?B can refer to di.erent sequences in di.erent loop iterations. One might, at this early \nstage, argue that separation logic allows writing more compact speci.cations. Forexample, with the same \nconvention about ? variables, i.e., they are existentially quanti.ed over the entire formula, the invariant \nin Figure2 wouldbe speci.edin separation logic as (list(p, ?B) * list(x, ?C)) . A = rev(?B)@?C, where \nlist(p, ?B)isapredicate capturing the same intuition as our term list(p)(?B). While this separation logic \nformula is indeed slightly more compact than our matching logic pattern, we would like to make two observations: \n struct listNode { int val; struct listNode *next; }; struct listNode *readList(int n) rule .$ . return \n?x; \u00b7\u00b7\u00b7.k .A . \u00b7 \u00b7\u00b7\u00b7.in .\u00b7\u00b7\u00b7 \u00b7. list(?x)(A) \u00b7\u00b7\u00b7.heap if n = len(A) { int i; struct listNode *x, *p; if \n(n == 0) return NULL; x=(struct listNode*) malloc(sizeof(struct listNode)); scanf(\"%d\", &#38;(x->val)); \nx->next = NULL; i = 1; p = x; inv .?C \u00b7\u00b7\u00b7.in .\u00b7\u00b7\u00b7 lseg(x, p)(?B), p .. [?v, NULL] \u00b7\u00b7\u00b7.heap . i = n . \nlen(?C)= n -i . A = ?B@[?v]@?C while (i < n) { p->next = (struct listNode*) malloc(sizeof(struct listNode)); \np = p->next; scanf(\"%d\", &#38;(p->val)); p->next = NULL; i += 1; } return x; } Figure 3. C function reading \na sequence of integers from the standard input into a singly-linked list. First, separation logic is \nheap-centric in its semantics, so * automatically refers to the heap, while matching logic makes no such \nassumptions. If the heap were the only cell in the con.guration, then we could easily adopt the assumption \nthat heap terms are automatically wrapped within the heap cell, in which case our notation would be just \nas compact. However, as seen shortly, we introduce input/outputbu.ers and a call stack to the con.guration. \nThen the uniform notation which explicitly mentions the cells becomes quite natural and useful; separation \nlogic would require syntactic and semantic extensions to deal with such additional components. As shown \nin Section 4.3, anyseparation logic formula can be mechanically trans\u00adlated into an equivalent matching \nlogic pattern.  Second, the compactness of separation logic formulae is also due to an implicit heap \nframing rule in Hoare logics based on separation logic. In matching logic veri.cation we deliberately \navoid adding anyautomatic framing rules, simply because those are not necessary.Forexample, the ... symbols \nin the speci.cations in Figure2 are anony\u00admous (.rst-order) variables that match the corresponding cell \nframes . Removing all the ... from the heap cells would state that reverseList can only be called in \ncon\u00adtexts where the heap contains nothing but a list that x points to. This would be hard to specify \nusing separation logic with implicit heap framing.  Function readList in Figure 3 reads n integers from \nstandard input and stores them in a singly-linked list. The void trusted(int n); void untrusted(int n); \nvoid any(int n); void trusted(int n) rule .$ . return; \u00b7\u00b7\u00b7.k .S.stack if n = 10 . in(hd(ids(S)), [main, \ntrusted]) { untrusted(n); any(n); if (n) trusted(n -1); } void untrusted(int n) rule .$ . return; \u00b7\u00b7\u00b7.k \n.S.stack if in(trusted, ids(S)) { if (n) any(n -1); } void any(int n) { // possible security policy violation \n// (when any is called) if n <= 10 if(n > 10) trusted(n -1); } int main() { trusted(5); any(5); } Figure \n4. C program respecting a stack inspection policy. speci.cation says that the function: (1) returnsa \npointer ?x; (2) reads from the standard input a sequence of integers A of length n (matches A and replaces \nit by the empty sequence \u00b7); (3) allocates a list starting at ?x with contents A (replaces the empty \nheap \u00b7). The rest of the input bu.er, the heap, and the con.guration stay unchanged. The loop invariant \nstates that the sequence ?C is yet to be read, x points to a list segment ending at p with contents ?B, \np points to a nodeList structure with the value .eld?v and the next .eld NULL, the loop index i is not \ngreater than n, the size of ?C is n -i, and the initial sequence A equals the concatenation of ?B,?v, \nand ?C. The list segment lseg(x, p)includes x but excludes p. The notation p .. [?v, NULL]stands for \nthe term (and not formula) p .. ?v, p + 1 .. NULL .  Figure4 showsaC program that respects the following \nsecurity policy: trusted must always be called directly with n s value less than 10 only from main, or \nfrom trusted (suppose that n represents some priority or clearance level), while untrusted must always \nbe called directly or indirectly from trusted (suppose that trusted is the only function whose code is \ncompletely trusted, so in particular it is even allowed to call untrusted functions). The reachability \nrule of trusted matches the call stack, and requires that either the value of n is at least 10, or that \nthe function id of the head of the call stack is one of main or trusted. The rest of the con.guration \nstays unchanged. The rule for untrusted matches the same parts of the con.guration as the rule for trusted, \nbut requires instead that somewhere in the call stack there exists a frame for trusted. In particular, \nboth trusted and untrusted require the heap to stay unchanged. We can prove that, as neither of the three \nfunctions allocates or deallocates heap memory. Function any does not have a rule, so its body is executed \nat each call. If the call to trusted in any were not guarded by the if statement, the line any(5); in \nmain would violate the security policy. Note that just constructing the call graph and performing value \nanalysis is not enough to verify these stack properties.  Function treeToList in Figure 5 .attens a \nbinary tree into a list, by traversing the tree in in.x order, and in the process prints the list to \nthe standard output in reverse order. Each node of the initial tree (structure treeNode)has three .elds: \nthe value, and two pointers, for the left and the right subtrees. Each node of the .nal list (structure \nlistNode) has two .elds: the value and a pointer to the next node of the list. The program makes use \nof an auxiliary structure (stackNode)to representa stackof trees.For demonstration purposes, we prefer \nan iterativeversionof this program.We needa stacktokeep trackof our positioninthe tree. Initially, that \nstack contains the tree passed as argument (as a pointer). The loop repeatedly pops a tree from the stack, \nand it either pushes back the left tree, the root, and the right tree onto the stack, or if the right \ntree is empty it pushes back the left subtree, appends the value in the root node at the beginning of \nthe list of tree elements, and prints the respective value to the standard output. As the loop processes \nthe tree, it frees the tree nodes and it allocates the corresponding list nodes. Because the values are \nprinted when they are popped from the stack, theyappear in the output in reverse in.x order. The treeToList \nrule says that it returns pointer ?l. The rule matches in the heap a tree rooted at t with contents T \nand replacesit witha list startingat ?l with contents tree2list(T) (the in.x traversal sequence of T). \nFinally, it speci.es that the function outputs the traversal sequence in reverse order. The rest of the \nheap, outputbu.er and the con.guration stay unchanged. The invariant says that the heap contains a stack \nof trees (represented as a list of trees) with contents ?TS and a list with contents ?A, the loop has \nprinted so far the sequence rev(?A), and that the in.x traversal sequence of T, tree2list(T), equals \nthe concatenation in reverse order of the in.x traversal sequences of the trees in the stack concatenated \nwith the contents of the list. Nothing else changes. 4. Matching Logic:ALogic of Con.gurations Traditionally, \nprogram logics are deliberately not concerned with low-level details about program con.gurations, those \ndetails being almost entirely deferred to operational seman\u00adtics. This is a lost opportunity, since con.gurations \ncontain very precious information about the structure of the various data in a program s state, such \nas the heap, the stack, the in\u00adput, the output, etc.Without direct access to this information, program \nlogics end up having to either encode it by means of sometimes hard to de.ne predicates, or extend themselves \nstruct treeNode { int val; struct treeNode *left, *right; }; struct listNode { int val; struct listNode \n*next; }; struct stackNode { struct treeNode *val; struct stackNode *next; }; struct listNode *treeToList(struct \ntreeNode *t) rule .$ . return ?l; \u00b7\u00b7\u00b7.k .\u00b7\u00b7\u00b7 tree(x)(T). list(?l)(tree2list(T)) \u00b7\u00b7\u00b7.heap .\u00b7\u00b7\u00b7 \u00b7. rev(tree2list(T)).out \n{ struct listNode *l; struct stackNode *s; if (t == NULL) return NULL; l = NULL; s=(struct stackNode \n*) malloc(sizeof(struct stackNode)); s->val = t; s->next = NULL; inv .\u00b7\u00b7\u00b7 tree(s)(?TS), list(l)(?A) \n\u00b7\u00b7\u00b7.heap .\u00b7\u00b7\u00b7 rev(?A).out . tree2list(T)= treeList2list(rev(?TS))@?A while (s != NULL) { struct treeNode \n*tn; struct listNode *ln; struct stackNode *sn; sn = s; s = s->next; tn = sn->val; free(sn) ; if (tn->left \n!= NULL) { sn = (struct stackNode *) malloc(sizeof(struct stackNode)); sn->val = tn->left; sn->next = \ns; s = sn; } if (tn->right != NULL) { sn = (struct stackNode *) malloc(sizeof(struct stackNode)); sn->val \n= tn; sn->next = s; s = sn; sn = (struct stackNode *) malloc(sizeof(struct stackNode)); sn->val = tn->right; \nsn->next = s; s = sn; tn->left = tn->right = NULL; } else { ln = (struct listNode *) malloc(sizeof(struct \nlistNode)); ln->val = tn->val; ln->next = l; l = ln; printf(\"%d.\", ln->val); free(tn); } } return l; \n } Figure 5. IterativeCprogram .atteningatree intoa listand printing its values in the process.  in \nnon-conventional ways, or sometimes both. In contrast, matching logic [31] takes program con.gurations \nat its core. We next .rst recall general matching logic notions and no\u00adtations (Section 4.1) with emphasis \non its patterns, then give an instance of it for con.gurations corresponding to a frag\u00adment of theC language \n(Section 4.2), and in the end discuss how it relates to separation logic [23, 25] (Section 4.3). 4.1 \nPatterns and General Notions Matching logic[31] is a logic suitable for specifying and reasoning about \nprogram or system con.gurations. Although originally framed asa methodological fragmentof .rst-order \nlogic (FOL), a setting that also su.ces for this paper, match\u00ading logic can be easily extended to second-or \nhigher-order settings. Matching logic is parametric in a syntax and a model for con.gurations. Some con.gurations \ncan be as simple as pairs .code,s. with code a fragment of program and s a state map from program variables \nto integers, e.g. when one wants to reason about simple imperative languages. Other con.gurations can \nbe even simpler, for example just heap singletons holding a map from locations to integers (e.g., when \none wants to exclusively reason about heap structures like in separation logic; see Section 4.3) or even \njust code singletons (e.g., when one wants to reason about programs based purely on their syntax).Yet, \nother con.gurations can be as complex as that of theC language[10], which contains more than 70 semantic \ncomponents. No matter how simple or complex the con.gurations under consideration are, the same machinery \ndescribed below works for all. We assume the reader is familiar with basic concepts of algebraic speci.cation \nand .rst-order logic. Given an algebraic signature S, we let TS denote the initial S-algebra of ground \nterms (i.e., terms without variables) and let TS(Var) denote the free S-algebra of terms with variables \nin Var. TS,s(Var)is the set ofS-terms of sort s. Maps . : Var .T with T a S-algebra extend uniquely to \n(homonymous) S\u00adalgebra morphisms . : TS(Var).T. These notions extend to algebraic speci.cations. Many \nmathematical structures needed for language semantics have been de.ned as initial S\u00adalgebras: boolean \nalgebras, natural/integer/rational numbers, lists, sets, bags (or multisets), maps (e.g., for states, \nheaps), trees, queues, stacks, etc. We refer the reader to the CASL [20] and Maude [6] manuals for examples. \nLet us .x the following: (1) an algebraic signature S, as\u00adsociated to some desired con.guration syntax, \nwith distin\u00adguished sort Cfg, (2) a sort-wise in.nite set of variables Var, and (3) a S-algebra T, the \ncon.guration model, which may but needs not necessarily be the initial or free S-algebra. As usual, TCfg \ndenotes the elements of T of sort Cfg, which we call con.gurations. In Section 7, we prove the relative \ncompletenessof our proof systemw.r.t. such an arbitrarybut .xed con.guration model (with some additional \nconstraints). De.nition 1. [31]A matching logic formula, or a pattern, is a .rst-order logic (FOL) formula \nwhich allows terms in TS,Cfg(Var), called basic patterns, as predicates. We de.ne the satisfaction (., \n.) |= . over con.gurations . .TCfg, valuations . : Var .T and patterns . as follows (among the FOL constructs, \nwe only show .): (., .)|= .X . i. (., . ' )|= . for some . ' : Var .T with . ' (y)= .(y)for ally . Var\\X \n(., .)|= p i. . = .(p) , where p . TS,Cfg(Var) A pattern . is valid, written |= ., when (., .) |= . for \nall . .TCfg and all . : Var .T. Abasic patternp is satis.ed by all the con.gurations . that match it; \nthe . in(., .)|= p can be thought of as the witness of the matching, and can be further constrained in \na pattern. If SUM is the code s:=0; while(n>0)(s:=s+n; n:=n-1) in a simple imperative language with con.gurations \n.code,s. e.g., then the pattern .s (. SUM, (s .. s, n ..n).. n =Int 0) matches the con.gurations with \ncode SUM and state binding program variables s and n to integers s and respectively n =Int 0.We typically \nuse typewriter for program variables and italic for mathematical variables in Var.Pattern reasoning reduces \nto FOL reasoning in the con.guration model T: De.nition 2. Let . be a special fresh Cfg variable, which \nis not in Var, and let Var. be the extended set of variables Var.{.}.For a pattern ., let .. be the FOL \nformula obtained by replacing basic patterns p . TS,Cfg(Var)with equalities . = p. If . .TCfg and . :Var.T, \nthen let .. :Var. .T be the valuation which extends . by mapping . into .: .. (.)= . and .. (x)= .(x)for \nall x . Var. To highlight the semantic indistinguishability between matching logic patterns with variables \nin Varand the corresponding fragment of FOL with variables in Var. , we take the freedom to write (., \n.)|= .. in the FOL fragment, too, instead of .. |= .. .A matching logic (respectively FOL) formula . \nis patternless i. it contains no basic pattern (respectively no . variable), that is, . = .. . The following \nproposition states that the notation in De.\u00adnition2 is consistent: Proposition 1. If . is a matching \nlogic pattern, . .TCfg and . : Var .T, then (., .) |= . (notation in De.nition 1)i. (., .)|= .. (notation \nin De.nition 2). Also |= . i. T|= .. . Therefore, patterns form a methodological fragment of the FOL \ntheory of T, so we can use conventional theorem provers or proof assistants for pattern reasoning. It \nis often technically convenient to eliminate the special . variable from a FOL formula .. corresponding \nto a matching logic pattern .. This can be done by replacing . with a Cfg variable c . Var (possibly \nwhich does not occur free in .): indeed, .. [c/.]is patternless. Lemma 1. If . is a pattern, c . Var \nis a Cfg variable, and . :Var.T a valuation, then (.(c),.)|= .. i. . |= .. [c/.]. Not all patterns are \nequally meaningful.Forexample, the pattern true is matched by all con.gurations, the pattern  Id . C \nidenti.ers Nat . domain of natural numbers (including operations) Int . domain of integer numbers (including \noperations) Type . int | struct Id | Type * Code . the entire remaining syntax of theC fragment Env . \nMapId,Int TEnv . MapId,Type Cell . .MapId,ListType\u00d7Id .struct |.MapId,ListType\u00d7Id \u00d7K.funs |.Code.k |.Env.env \n |.TEnv.tenv |.Id.fname |.ListId\u00d7K\u00d7Env\u00d7TEnv.stack |.MapNat,Int .heap |.ListInt .in |.ListInt .out Cfg \n. .BagCell .cfg Figure 6. Sample con.guration false is matched by no con.gurations, some patterns are \nalways matched by precisely one con.guration . regardless of the valuation ., others are sometimes by \nmatched by some con.gurations for somevaluations, etc.For our subsequent results, we are interested in \nwell-de.nedness of patterns: De.nition 3. A pattern . is weakly well-de.ned i. for any valuation . : \nVar .T there is some con.guration . .TCfg such that (., .)|= ., and it is well-de.ned i. . is unique. \nFor example, all basic patterns p are well-de.ned, while patterns of the form p1 .p2 are weakly well-de.ned.Well\u00adde.ned \npatterns have the following property Lemma 2. If . is well-de.ned and c1, c2 . Var are two Cfg variables, \nthen |= .. [c1/.]... [c2/.]. c1 = c2.  4.2 An Instance Herewe discussa simplebut non-trivial instanceof \nmatching logic for an idealized fragment of theClanguage. The reason we do not choose a trivial language \nis because we want to reiterate that matching logic, as well as all the notions and results presented \nin this paper, are totally agnostic to the language under consideration and to its complexity. To obtain \na matching logic instance, one needs to provide a syntax (as a signature S) and a model (as a S-algebra) \nfor that language s con.gurations.We make use of common algebraic structures like lists, sets, bags, \nand maps over any sorts, including other lists, sets, etc., by simply mentioning their sorts as subscripts.Forexample, \nMapBagNat ,Int\u00d7Int is the sort corresponding to maps taking bags of naturals to pairs of integers.For \nnotational simplicity, we (ambiguously) usea central dot \u00b7 (read nothing ) for the units of all lists, \nsets, bags, maps, etc., a comma , or a whitespace . for their concatenation, and an in.x .. forbuilding \nmap terms. Figure6shows the con.guration syntax of our chosen lan\u00adguage.Weonly consider integer, structure \nand pointer types. The sort Code is a generic sort for code and comprises the entire language syntax; \nthus, terms of sort Code correspond to fragments of program. Environments are terms of sort Env and are \nmaps from identi.ers to integers.Type environments in TEnv map identi.ers to types.A con.gurationisa \nterm .....cfg of sort Cfg containing a bag of cells. In addition to .....k, .....env and .....tenv holding \na program fragment, an en\u00advironment and a type environment, .....cfg also includes the following cells: \n.....struct holds the available structures as a map from data structure names to lists of typed .elds; \n.....funs holds the available functions as a map from function names to their arguments and body; .....fname \nholds the name of the current function; .....stack holds the function stack as a list of frames, each \ncontaining a function name and its execution context (the remaining code, the environment and the type \nenvironment); .....heap holds the heap as a map from natural numbers (pointers) to integers (values); \n.....in holds the input bu.er as a list of integers; and .....out holds the outputbu.er. Let S be the \nalgebraic signature associated to the con.gu\u00adration syntax discussed above (it is well-known that an \nalge\u00adbraic signature can be associated to anycontext-free grammar, by associating one sort to each non-terminal \nand one oper\u00adation symbol to each production).A S-algebra then gives a con.guration model, namely a universe \nof concrete language con.gurations. Let us assume that T is such a con.guration model.We do not bother \nto de.ne T concretely, because its details are irrelevant. Note, however, that T must include submodels \nof natural and integer numbers, of maps, lists, etc. Moreover, to state properties like those in Section \n8, S needs to contain operator symbols corresponding to lists of integer numbers and append and reverse \non them, for membership testing of integers to such lists, etc. Also, to meaningfully reason about programs \nin our language, T needs to satisfy certain expected properties of these operation symbols, e.g.: rev(nil) \n= nil rev([a]) = [a] rev(A1@A2) = rev(A2)@rev(A1) in(a, nil) = false in(a, [b]) = (a = b) in(a, A1@A2) \n= in(a, A1).in(a, A2) .n1 .. i1, n2 .. i2,s.heap . n1 . n2 We next give some examples of patterns for \nour S. Given program variable x (i.e., a constant of sort Id), the pattern .c:BagCell , e:Env ..x .. \n5, e.env c.cfg speci.es those program con.gurations in which x is bound to5in the environment. Similarly, \nthe pattern e:Env, i:Int (..x .. i, e.env c.cfg .i = 0) .c:BagCell , speci.es the con.gurations where \nx is bound to a positive integer. The next says that x is bound to an allocated location e:Env, p:Nat, \ni:Int,s :MapNat,Int .c:BagCell , ..x .. p, e.env .p .. i,s.heap c.cfg  while the pattern e:Env, p:Nat, \ni:Int .c:BagCell , ..x .. p, e.env .p .. i.heap c.cfg says that the location x is bound to is the only \none allocated. Matching logic allows us to write speci.cations referring to data located arbitrarily \ndeep in the con.guration, at the same time allowing us to use existential variables to abstract away \nirrelevant partsof the con.guration.To simplify writing, we adopt the following notational conventions: \nNotation 1. Variables starting with a ? are assumed existentially quanti.ed over the entire pattern and \nthus need not be declared. The sorts of variables are inferred from their use context. Existentially \nquanti.ed variables which appear only once in the pattern are replaced by an underscore (anonymous variable) \n_ or by ... . Cells mentioned only for structural matching can be omitted when their presence is understood; \ne.g., if e is an environment and . a FOL formula, we may write .e.env .. instead of ..e.env ....cfg ... \nWith these notational conventions, the patterns above become: .x .. 5 ....env .x ..?i ....env . ?i = \n0 .x ..?p ....env .?p .. _ ....heap .x ..?p ....env .?p .. _.heap We further illustrate the expressiveness \nof matching logic with a few more pattern examples. The next says that program variables x and y are \naliased and point to an existing location: .x ..?p, y ..?p ....env .?p .. _ ....heap The following patterns \nspecify con.gurations where pro\u00adgram variable x is bound to the last integer that has been output (located \nto the right of the output cell), and con.g\u00adurations in which only one integer has been output and no \nprogram variable is bound to that integer, respectively: .x ..?i ....env .... ?i.out .e.env .?i.out .?i \n. Codom(e) The following pattern says that the current function is f and it has been called directly \nby g (stack s top is to the left): .f.fname .(g, _, _, _) ....stack The following pattern is more complex: \n .x ..?p ....env .f.fname .... (g, _, x ..?p ..., x .. _* ...)....stack It says that the current function \nis f, that it has been called directly or indirectly by g, and that when g was called the program variable \nx had a pointer type and was bound to the same location (? p)it is also bound now inf s environment. \n Assuming that . is a con.guration of T of the form ..x .. 5, y .. 5.env .5 .. 7.heap .3, 5.out ....cfg, \nthen . matches all the following patterns: p1 =.x .. 5 ....env p2 =.x ..?i ....env . ?i = 0 p3 =.x ..?p \n....env .?p .. _ ....heap p4 =.x ..?p ....env .?p .. _.heap p5 =.x ..?p, y ..?p ....env .?p .. _ ....heap \np6 =.x ..?i ....env .... ?i.out Moreover, |= p1 . p2, |= p3 . p2, |= p4 . p3, |= p5 . p3, and, assuming \nthat T correctly de.nes the claimed maps, lists, etc., |= p1 .p5 .p6 ..y .. 5 ....env .5 .. _ ....heap \n.... 5.out. In addition to usual FOL abstractions, matching logic also allows us to introduce and axiomatize \nsituations of interest as operations (insteadof predicates).Forexample, we next show the list heap abstraction \n(part of the MatchC library) which was used, together with other similar abstractions, to verify the \nprograms in Section 8. It abstracts heap subterms into list terms and captures two cases, one in which \nthe list is empty and the other in which it has at least one element. ..list(p)(a),s.heap c.cfg . ..s.heap \nc.cfg . p = 0 . a = nil ..a, q,\u00df (..p..[a, q], list(q)(\u00df),s.heap c.cfg . a = [a]@\u00df) One can now use \nthis axiom to perform reasoning like below: ..1 .. 5, 2 .. 0, 7 .. 9, 8 .. 1,s.heap c.cfg . ..1 .. 5, \n2 .. 0, list(0)([]), 7 .. 9, 8 .. 1,s.heap c.cfg . ..list(1)([5]), 7 .. 9, 8 .. 1,s.heap c.cfg . ..list(7)([9, \n5]),s.heap c.cfg . .q..7 .. 9, 8 .. q, q .. 5, q+1 .. 0,s.heap c.cfg   4.3 Relationship to Separation \nLogic Separation logic [23, 25] is a popular choice for specify\u00ading heap properties. Its main strength \nis the separation con\u00adjunction * , which allows for modular reasoning. Although matching logic is not \nparticularly concerned with specify\u00ading heap properties, the previous section showed manysuch properties \nand thus begs for a formal relationship between separation logic and matching logic. Here we present \nan instance of matching logic, for a particular heap-centric con\u00ad.guration signature and model, together \nwith a mechanical translation of separation logic formulae into semantically equivalent patterns in the \nmatching logic instance. There are many variations of separation logic. Here we consider .rst\u00adorder separation \nlogicover integers, as presentedin[23],but we believe that similar embeddings can be obtained for other \nvariants.Formally, separation logicextends the .rst-order theory of integers with the following constructs: \n emp, the atomic predicate specifying the empty heap.  t1 .. t2, the atomic predicate specifying the \nsingleton heap mapping the natural number (thought of as a mem\u00adory location) represented by t1 into the \ninteger number represented by t2.  P1 * P2, the formula specifying the separation conjunction of two \nformulae, that is, that the heap can be split into two disjoint heaps satisfying P1 and respectively \nP2.  For simplicity, we do not consider the separation implication P1-*P2 here. The satisfaction of \na separation logic formula P is given over a valuation s of the variables in P and a heap h, i.e., a \npartial function from naturals to integers. Speci.cally, as in[23, 25], the satisfaction of spatial formulae \ndepends on both s and h, while that of pure formulae depends only on s (that is, is independent of h). \n To establish the relation between separation logic and matching logic, for the remaining of this subsection \nwe .x the following signature S with .ve sorts and only one cell: Nat . domain of natural numbers (including \noperations) Int . domain of integer numbers (including operations) Bool . domain of Booleans Heap . MapNat,Int \n(domain of heaps represented as .nite mappings from naturals into integers) Cfg . .Heap.heap As in the \nprevious section, we use , for the map concate\u00adnation and . for the map unit.To S we associate a model \nT consisting of a model of natural numbers, a model of the inte\u00adger numbers, a model of heaps, and a \nmodel of con.gurations (whicharejustheaps wrappedintoacell).We assume thereis a special element . in \nT standing for error . All operations with at least one argument .evaluate to .. Equality between .and \nanyother element does not hold.Valuationsdo not take any variables into .. The model of heaps has the \nimportant property that the concatenation of two maps with non-disjoint domains is .. Since separation \nlogic cannot quantify over heap variables, if . : Var .T is a valuation then we let . be the restriction \nof . to natural and integer variables. Let s, s ' , s1, s2, ...be Heap variables in Var which do not \noccur in P. Given a separation logic formula P, we construct an equivalent matching logic formula over \nS S2M(P)=.s(.s.heap ..) where . is a patternless formula. Intuitively, s stands for the heap which . \nconstrains. The construction is based on the syntactic structure of P, and somewhat mimics the de.nition \nof satisfaction for separation logic formulae: S2M(.xP): let S2M(P)be.s(.s.heap ..). Then S2M(.xP)=.s(.s.heap \n..x .)  S2M(P1 . P2): let S2M(P1)be.s1(.s1.heap . .1)and S2M(P2)be.s2(.s2.heap ..2). Then we de.ne \n S2M(P1 . P2) =.s(.s.heap ..s1.s2(s = s1 .s = s2 .(.1 . .2))) Notice that the equalities s = s1 and \ns = s2 ensure that .1 and .2 constrain the same heap. S2M(p(t1,..., tn)), where p is a pure predicate \n(one which is not interpreted over the heap, like = or = ): S2M(p(t1,..., tn)) =.s(.s.heap . p(t1,..., \ntn)) We used the same notation for the pure predicate and the corresponding Boolean algebraic operator. \n S2M(false): we de.ne S2M(false)=.s(.s.heap .false)  S2M(P1 * P2): let S2M(P1) be .s1(.s1.heap . .1) \nand S2M(P2)be.s2(.s2.heap ..2). Then we de.ne  S2M(P1 * P2) =.s(.s.heap ..s1.s2(s = (s1,s2)..1 ..2)) \n Note that the equality s = (s1,s2)holds inT under some valuation . only if(.(s1),.(s2)) is a proper \nheap, that is, only if the domains of .(s1)and.(s2)are disjoint. S2M(x .. y): we de.ne S2M(t1 .. t2)=.s(.s.heap \n.s = (t1 .. t2))  We use the same notation for the separation logic predicate t1 .. t2 and the algebraic \nmap constructor t1 .. t2.  S2M(emp): we de.ne (recall that \u00b7 is the map unit) S2M(emp)=.s(.s.heap .s \n= \u00b7)  To illustrate the transformation, consider the separation logic formula P = x .. a * y .. b.a \n. b. By applying the transformation we have S2M(P)to be .s(.s.heap ..s1.s2(s = s1 .s = s2 .a . b ..s3.s4(s1 \n= (s3,s4).s3 = (x .. a).s4 = (y .. b)))) However, after eliminating the existential quanti.ers via substitution, \nwe obtain the equivalent matching logic formula .x .. a, y .. b.heap .a . b For this reason, in practice \nwe do not encourage the use of the transformation for generating matching logic formulae, but rather \ndirectly writing the matching logic formulae. The following proposition formally captures the relation\u00ad \nship between the version of separation logic considered here and the matching logic over S and T. Proposition \n2. IfPisa separationlogic formula, h .THeap is a heap and . : Var .T is a valuation, then (., h) |= P \n(in separation logic) i. (.h.heap,.)|= S2M(P)(in matching logic). Consequently, |= P (in separation logic)i. \n|= S2M(P) (in matching logic). Although insightful, the result above is not surprising. In\u00addeed, matching \nlogic has the luxury of instantiating itself with anycon.guration signature and anymodel of con.gura\u00adtions, \nin particular with ones that capture the precise syntax and semantics of heaps, while separation logic \nand its vari\u00adations come with .xed such signatures and models. There\u00adfore, the main conceptual di.erence \nbetween separation logic and matching logic is that the former achieves separation by means of special \nlogical connectives and appropriate mathe\u00admatical domains to interpret those, while the latter achieves \nseparation by structural means, at the level of terms instead of modifying the logic,but with the help \nof an appropriately de.ned model of con.gurations. Matching logic thus has the advantage that we do not \nneed to modify the underlying logic with each language extension that requires new seman\u00adtic components \nto be added to the con.guration,but that does not come for free: one still has to carefully construct \none s con.guration model with the desired properties.  5. Reachability Rules In Section 4 we showed \nhow one matching logic pattern . speci.es all the con.gurations . that match it. Here we ex\u00adtend speci.cations \nto pairs of patterns, called reachability rules and written . . . ' , which specify all pairs of con.g\u00adurations \nthat simultaneously match both patterns. The two con.gurations in each such pair can be thought of as \nbeing related by the reachability relation in the transition system corresponding to the (operational \nsemantics of the) language under consideration. Moreover, the transition system itself can be de.ned \nin terms of reachability rules, which are inter\u00adpreted as one-step transitions. Reduction semantics[34]and \nrewriting logic[19]are perhaps the most established logical formalisms whose basic sequents are statements \nof the form ' t . t ' , where t and t are terms with variables specifying one-step transitions or reachability \nin the transition system associated to a reduction or rewrite system. Since matching logic patterns extend \nterms with logical constraints, such pairs of unconstrained terms are therefore special instances of \nreachability rules.We next recall notions related to reacha\u00adbility rulesfrom[28,29],andaddafewnew ones \nneededto state and prove our new soundness and completeness results. De.nition 4. A reachability rule \nis a pair . . . ' , where . and . ' are patterns (which can have free variables).A reach\u00adability system \nis a set of reachability rules. A reachability system S induces a transition system (T, .T)on the con.g- \nS uration model: . .T . ' for ., . '.TCfg i. there is a . . . ' S in Sand a . : Var .T with (., .)|= \n. and (. ' ,.)|= . ' . There is overwhelming evidence that languages and cal\u00adculi can be given operational \nsemantics based on rewrite (or reduction) rules of the form l . r if b , where l and r are con.guration \nterms with variables constrained by boolean condition b. One of the most popular approaches is reduc\u00adtion \nsemantics withevaluation contexts[11,12], with rules c[t]. c[t ' ]if b , where c is an evaluation context, \nt is the redex which reduces to t ' , and b a side condition. Another approach is the chemical abstract \nmachine[3], where l is a chemical solution that reacts into r under condition b. The rewriting logic \nsemantics framework K [26]is yet another approach, based on plain (no evaluation contexts) rewrite rules \nof the form l . r if b . Finally, higher-order logic is also a successful framework for de.ning operational \nse\u00admantics[4, 16], and it is technically the most powerful of all the above. While we currently limit \nourselves to FOL, there is nothing to prevent higher-order extensions of matching logic.Tools, techniques \nand methodologies supporting such operational semantics, like Redex, Maude and the K tool among others, \nas well as large languages de.ned using these (e.g., theC semantics[10]exceeds 1,000 such rules), stand \nas proof that this is not only possible,but also practical. Such rules can all be expressed as matching \nlogic reachability rules l.b . r, allowing to regard operational semantics following these approaches \nas matching logic reachability systems. Generic, language-independent notions of termination and .nite-branching \nare needed for the partial correctness and for the relative completeness results, respectively: De.nition \n5. Con.guration . .TCfg terminates in (T, .T) S i. there is no in.nite .T-sequence starting with .. Con.gu- \nS ration . .TCfg is .nite-branching i. the set {. '|. .T . '} S is .nite. Reachability system S is .nite-branching \ni. so is each con.guration . .TCfg. Finite-branching will be critical for proving the relative completeness \nof our proof system, since it will allow us to encode non-termination as a FOL predicate: a con.guration \n. does not terminatei. for any n there exists of path of length n starting with ..Anexampleof an in.nite-branching \nruleis one de.ning a random expression construct with a reduction rule of the form .random...n.(assume \na trivial language whose con.guration holds only an expression) where n is a variable ranging over an \nidealistic (in.nite) domain of natural numbers. One could devise criteria that guarantee .nite-branching, \nsuch as allowing freshvariablesin the right\u00adhand sides (RHS) of rules (i.e., ones which do not appear \nin the rule s LHS) only if they range over .nite domains, etc., but these are beyond the scope of this \npaper. De.nition 6. A reachability rule . . . ' is weakly well\u00adde.ned, respectively well-de.ned,i. . \n' is weakly well\u00adde.ned,respectively well-de.ned(recall De.nition3). Reach\u00adability system S is (weakly) \nwell-de.ned i. each rule is (weakly) well-de.ned, and is .nite-branching i. so is each con.guration . \n.TCfg. Operational semantics de.ned with rules l . r if b are particular well-de.ned reachability systems \nwith rules of the form l . b . r, because r is a basic pattern and basic patterns are well-de.ned. One \nexample of a properly weakly well-de.ned rule is one of the form . . .1 . .2, where (.1,.)|= .1 and(.2,.)|= \n.2 for two di.erent con.gurations .1 and .2 (however, note that such disjunctive rules can be replaced \nwith two rules). An example of a rule . . . ' which is not weakly well-de.ned is one where . ' is not \nsatis.able, for example . '= false. Such non-well-de.ned rules are unlikely to appear in anymeaningful \noperational semantics, but nevertheless, we do not want to impose any particular style or methodology \nto de.ne operational semantics in this paper and instead prefer to prove our generic soundness and completeness \nresults as generally as possible. Weak well\u00adde.nedness will be required for the soundness of our proof \nsystem and well-de.nedness for our completeness result. Note that there is no relationships between .nite \nbranching and well-de.nedness.Forexample, the rule .random...n. above is well-de.nedbut not .nite branching, \nwhile the rules . . .1 . .2 and . . false are .nite branching but not well-de.ned (the latter is not \neven weakly well de.ned). Reachability rules can specify not only operational se\u00admantics of languages, \nbut also program properties. In fact, each Hoare triple can be regarded as a particular reachability \nrule[29], although the translation needs to be mechanized separately for each language.Forexample, the \npropertyof the SUM program mentioned in Section 4.1 in the context of a simple imperative language with \ncon.gurations of the form .code,s.would be  .s (.SUM, (s .. s, n .. n)..n =Int 0) ..skip, (s .. n * \nInt (n +Int 1)/Int 2, n .. 0). Unlike Hoare triples, which only specify properties about .nal program \nstates, reachability rules can also specify inter\u00admediate state properties. Hoare triples correspond \nto reacha\u00adbility rules whose basic right-hand pattern holds the empty code, like the one above. Semantic \nvalidity in matching logic captures the same intuition of partial correctness as Hoare logic,but in more \ngeneral terms of reachability: De.nition 7. Let S be a reachability system and . . . ' a reachability \nrule. We de.ne S|= . . . ' i. for all . .TCfg such that . terminates in (T, .T)and for all . : Var .T \nS such that (., .) |= ., there exists some . '.TCfg such that .T . . . ' and (. ' ,.)|= . ' . S If . \n' holds the empty code, then so does . ' in the de.nition above, and in that case . ' is unique and thus \nwe recover the Hoare validity as a special case. 6. Language-Independent Proof System Figure 7 shows \nour language-independent matching logic proof system for reachability. It derives sequents of the form \nA .C . . . ' , where A and C are sets of reachability rules. Initially, A contains the operational semantics \nof the target language, given as a set of (one-step) reachability rules, and C is empty. We call the \nrules in C circularities. When C is empty, we write the sequent as A. . . . ' . The intuition for a sequent \nA .C . . . ' is that the reachability rule . . . ' holds under thehypotheses A and C, provided that the \n.rst step is always one from Awhenever C is non-empty. In other words, the existence of a (non-empty) \nCin a sequent A .C . . . ' requires its derivation to start with a trusted step, that is, a step corresponding \nto a trusted rule in A, and then to continue unrestricted using steps from both A and C. The proof rules \nAxiom, Re.exivity, andTransitivity have an operational nature and their role is mainly to (symboli\u00adcally) \nexecute operational semantics. Note how theyproperly capture the intuition of our sequents: Axiom initiates \nthe trusted steps, Re.exivity is only allowed when C is empty, and Transitivity requires at least one \n.rst trusted step with axioms in A, followed by unrestricted use of rules in both A and C as axioms. \nLogic Framing allows the deduction of reachability to take place in context, but only when the context \nis patternless. In other words, it is safe to add more logical constraints onexisting reachability properties,butit \nis unsafe to add more structural constraints.We let it as an exercise to the reader to note whyit would \nbe unsafe to allow structural constraints in frames. Consequence, Case Analy\u00adsis and Abstraction are \nreminiscent to homonymous proof Axiom : . . . ' .A A .C . . . ' Re.exivity : \u00b7 A. . . . Transitivity \n: A .C .1 .+ .2 A.C . .2 . .3 A .C .1 . .3 Logic Framing : A .C . . . ' . is a (patternless) FOL formula \nA .C . .. . . '.. Consequence : |= .1 . . ' A.C . '. . '|= . '. .2 1 122 A .C .1 . .2 Case Analysis : \nA .C .1 . . A .C .2 . . A .C .1 ..2 . . Abstraction : A .C . . . ' X nFreeVars(. ' )= \u00d8 A .C.X . . . \n' Circularity : A .C.{... '} . . . ' A .C . . . ' Figure 7. Matching logic proof system for reachability \n(eight language-independent proof rules). The use of .+ in sequent means that it was derived without \nRe.exivity. rules that appear in Hoare logic proof systems. The latter two can typically be proved in \nHoare logics, by structural induction on the language syntax,but they are necessary in our language-independent \nsystem. The Circularity proof rule has an inductive/coinductive nature and captures the various circular \nbehaviors that appear in languages, due to loops, recursion, etc. Circularity allows us to make a claim \nof circular behavior at anymoment during a proof derivation. The claim holds if we succeed to prove it \n... using itself. What makes such a reasoning well-founded and thus sound is the fact that the circularity \nclaim will only be allowed to be used after at least one trusted step. In concrete instances, that trusted \nstep is typically a loop unrolling, or a function invocation, or a jump, etc., as given by the operational \nsemantics of the language. The proof system in Figure 7 is clearly agnostic to the particular operational \napproach or style used to de.ne the target language. In Section 8 we describe our particular  .\u00b7\u00b7\u00b7 x \n.. ?x, p .. ?p, y .. ?y \u00b7\u00b7\u00b7.env .\u00b7\u00b7\u00b7 list(?p)(?B), list(?x)(?C) \u00b7\u00b7\u00b7.heap .if(x != NULL) { y = x->next; \nx->next = p; p= x; x= y; } \u00b7\u00b7\u00b7.k \u00b7\u00b7\u00b7 .cfg . A = rev(?B)@?C . .\u00b7\u00b7\u00b7 x .. ?x, p .. ?p, y .. ?y \u00b7\u00b7\u00b7.env \n.\u00b7\u00b7\u00b7 list(?p)(?B), list(?x)(?C) \u00b7\u00b7\u00b7.heap .\u00b7\u00b7\u00b7.k \u00b7\u00b7\u00b7 .cfg . A = rev(?B)@?C Figure 8. Matching logic reachability \nrule derivable with the .rst seven rules of the proof system in Figure7 with S the operational semantics \nof the considered fragment of C. The ellipses in each pattern stand for distinct free variables, assumed \nthe same on the corresponding positions in the left-hand-side and the right-hand-side.The ? variables \nare existentially quanti.ed over each pattern. use of the proof system in the MatchC program veri.er, \nusing a K semantics of theC fragment, highlighting both its expressiveness and its potential for automation \nin a non-trivial language instance. Other language instances are certainly needed in order to validate \nthe e.ectiveness of our proof system in other language paradigms. In particular, we are investigating \nits use in the context of a substitution-based reduction semantics de.nition of a functional language; \nthe proof derivations appear to be simpler than for the language considered here. These results will \nbe reported elsewhere. 6.1 Derived Proof Rules In this section we give several derived rules that turned \nout to be useful in practice or in proofs.To save space, we formulate them as lemmas instead of as proof \nrules. The most important one is Lemma4(Substitution). Lemma 3. If A .C . . . ' then A .C .X. ..X. ' \n. Lemma 4. (Substitution) If A .C . .. ' is derivable and . : Var .TS(Var), then A.C.(.)..(. ' )is also \nderivable. Lemma 5. Suppose that A . A ' . If A .C . . . ' then A' .C . . . ' , and if A .C . .+ . ' \nthen A' .C . .+ . ' . Lemma 6. If A .C . .+. ' and C . C ' then A .C' . .+. ' .  6.2 Examples Here we \nshow how the proof system in Figure7allows us to derive program properties expressed as reachability \nrules. First, let us consider the .rst seven proof rules and the Substitution proof rule (which is derived \nfrom the .rst seven). We can use them for symbolic execution/reasoning with the operational semantics \nof the language. However, as seen in Example 1, they are not su.cient to derive circular behaviors. Example \n1. Let us consider the while loop in function reverseList discussed earlier (Figure 2), modi.ed to only \niterate at most once, that is, modi.ed into a conditional, and let us show that it satis.es the claimed \ninvariant. More precisely, let us prove the reachability rule in Figure 8, say .X. ..X. ' , where X = \n{?x, ?p, ?p, ?B, ?C}. Recall that, by convention, the ? variables are existentially quanti.ed over their \ncorresponding patterns. The matching logic rule in Figure8looksdi.erentfromtheinvariantinFigure2because \nof twoMatchC notations: .rst,MatchC desugars invariants inv . loop into matching logic rules .[loop...]. \n.[...]. \u00accond(loop)(see Section 8), where.[code]is the pattern obtained from . by setting the contents \nof .....k to code; second, as explained in Section 3, MatchC allows to refer directly to program variable \nx instead of logical variable ?x, generating automatically the environment cell containing bindings of \nthe form x .. ?x. Since here we want to illustratea formal proof, we completely desugar theMatchC notation \nin Figure 2. We .rst derive . ..X. ' and then thedesired rule followsby Abstraction.It su.ces to derive \n. .?x = 0 ..X. ' and . .?x . 0 ..X. ' , and then use Case analysis and Consequence to derive . ..X. ' \n. For the former, we iteratively use the semantic rules of the considered fragment of C via Axiom, Substitution, \nand Logical Framing, together with FOL reasoning via Conse\u00adquence and with theTransitivity rule, until \nthe condition of if evaluates to0 and then the if statement dissolves (its else branch is empty), thus \nobtaining . .?x = 0 . . '. ?x = 0. The derivation of . .?x = 0 ..X. ' fol\u00adlows via Consequence, since \n|= . '.?x = 0 ..X. ' . Here we are deliberately agnostic to how the semantic rules of the language are \nde.ned, to avoid bias for anyparticular operational semantics approach. In Section8 we discuss ourMatchC \nimplementation, which uses K [26].  For the latter, we also use Axiom, Substitution, Logical Framing, \nConsequence andTransitivity until the condition of if evaluates to ?x . 0, then we apply the semantics \nof if and take the then branch. To continue with the execution of the other statements, we need to apply \nthe list axiom in Section 4.2 from left-to-right; FOL reasoning eliminates the case when the list is \nempty (since ?x . 0). Then Abstraction allows us to assume fresh variables a, q and \u00df like in the axiom \nof lists and thus we can continue the execution. After the block terminates, we get:  .\u00b7\u00b7\u00b7 x .. q, p \n.. ?x, y .. q \u00b7\u00b7\u00b7.env .\u00b7\u00b7\u00b7 list(?p)(?B), ?x .. [a, ?p], list(q)(\u00df) \u00b7\u00b7\u00b7.heap .\u00b7\u00b7\u00b7.k \u00b7\u00b7\u00b7 .cfg . ?C = [a]@\u00df \n. A = rev(?B)@?C  Let . '' denote this pattern. We can now again use FOL reasoning, this time applying \nthe list axiom from right\u00adto-left and using properties of the con.guration model T (like those in Section \n4.2), and derive . '' . .X. ' . If we had not modi.ed the while loop into an if conditional in the . \npattern above, then the second case above would have started by .rst applying the operational semantics \nof the while loop, namely unrolling into an if, and then the proof would have followed similarly until \na pattern like the . '' abovewas reached,but one wherethe .....k cell contains the original while loop. \nNext one can either continue to unroll the loop or one can conclude, similarly to the above, that . '' \n..X.. Unfortunately, none of these would prove the original goal, .X. ..X. ' . Next we show how the last \nrule of the proof system in Figure 7 can be used to deal with circular behaviors. The Circularity proof \nrule allows for a rule to be used in its own derivation, with certain restrictions. Initially, Circularity \nadds the rule to a pending set C.Typically, one or more applications of Circularity areeventually followedbyTransitivity, \nwhich enables the use of the rules in C after at least one step is performed with the already existing \naxioms. Intuitively, Circularity allows a rule to be used in its own derivation only after progress has \nbeen made without it. Example 2. We show how the Circularity rule can be used to verify the while loop \nin function reverseList in Figure 2. In Example 1, we showed how the .rst seven rules of the proofsysteminFigure7 \ncanbeusedtoverifythatthe claimed loop invariant holds after the execution of the code obtained by modifying \nthe while loop into an if conditional. Then we argued that they cannot derive the desired property about \nthe while loop, essentially because of their lack of reasoning support for circular behaviors. Let .X. \n..X. ' be the desired property, that is, the matching logic reachability rule in Figure8with if modi.ed \ninto while and with theextra condition ?x = 0 in the right\u00adhand-side. Since . contains the while loop \nin its .....k cell, we can use the loop unrolling semantics and reduce . into a pattern that resembles \nthe left-hand-side of the rule in Fig\u00adure 8, except that the then branch of the if is followed by the \nwhile loop. Let us call this pattern .if . Using Consequence and Abstraction, we can thus derive S..X. \n.+ .X.if . By Circularity followedbyTransitivity,it su.ces to derive S.{.X. ..X. '} . .X.if ..X. ' . \nUsing a reasoning sequence similar to the one in Example 1, we can .rst derive .if .?x = 0 ..X. ' and \nthen .if .?x . 0 ..X.. We next useTransitivity and Axiom with .X. ..X. ' to derive S.{.X. ..X. '}..if \n.?x . 0 ..X. ' , then Case anal\u00adysis to derive S.{.X. ..X. '} . .if ..X. ' , and then Abstraction to \nderive S.{.X. ..X. '}..X.if ..X. ' .  6.3 Partial Correctness We now state the soundness of our proof \nsystem: Theorem 1. (soundness) Let S be a weakly well-de.ned reachability system and let S. . . . ' be \na sequent derived with the proof system inFigure 7. Then S|= . . . ' . Therefore, once all the circularities \nare discharged, the derived reachability rule is semantically valid, in the sense of partial correctness \n(De.nition 7). Note that this result only requires that the operational semantics of the target language \nis weakly well-de.ned, a property which is satis.ed by all operational semantics that we are aware of. \nTheorem1 thus allows to formally derive correct proper\u00adties of programs based entirely on the operational \nsemantics of the language, and to produce corresponding formal certi.\u00adcates under the form of proof objects, \nwithout anyadditional axiomatic or any other kind of semantics being necessary, and without anytedious, \nlow-level inductive proofs over the transition system associated to the operational semantics. 7. Relative \nCompleteness In this section we show that our proof system for reachability in Figure 6 is relatively \ncomplete. That means that any reachability property of any program in any (operational semantics of any) \nprogramming language can be formally derived with the eight proof rules of our system. The relativity \ncomes from thefact that all our setting, including the proof system, are parametric in a con.guration \nmodel. In particular, the Consequence rule in Figure 6 relies on FOL validity in the con.guration model. \nThus, the completeness of our proof system is relative to an oracle telling whether the con.guration \nmodel satis.es a given FOL formula or not. Before we proceed, let us note that our proof system cannot \nbe complete without some additional constraints on the original reachability system S. First, note that \nalthough S was allowed to be in.nite in the partial correctness result (Theorem 1), we need to restrict \nit to be .nite in order to prove the completeness of our proof system. Consider, for example, a setting \nwhere con.gurations hold natural numbers, that is, .0., .1., .2., ..., and where S contains the in.nite \n(although recursively enumerable) set of rules .1...0., .2...0., and so on. Then it is easy to see that \nS|= .n...0., where n isavariable rangingover natural numbers,but thereis no way to derive S..n...0.. \nThus, Sis restricted to be .nite. This restriction is of little practical concern in our view, since \noperational semantics are expected to be .nite, no matter how complex the target language is. More restrictions \non S are needed. For example, if S consists of the rule true . true than the transition system (T, .T) \ncontains all possible pairs of con.gurations, so S S|= . . . ' for all reachability rules . . . ' . On \nthe other hand, S. . . . ' is derivable only when |= . . . ' . Thus, we need to impose further restrictions \non Sin order for our proof system to be complete. One could argue that the problem with the rule true \n. true is that it does not use any basic patterns, so it is not .nite branching. Consider instead a .nite-branching \nsystem consistingonlyofa rule p . p1 .p2, where p, p1, p2 are distinct and ground basic patterns, and \nwhose model of con.gurations contains precisely these three con.gurations. Then it is easy to see that \nS|= p . p1, since p1 matches the pattern p1 .p2,but thereisnowayto derive S. p . p1. Thus, .nite branching \ndoes not su.ce. However, the rule p . p1 . p2 is not well-de.ned.We are going to require that S is both \n.nite-branching and well-de.ned.We believe that the .nite branching requirement can be avoided, but were \nnot able to prove the completeness result without it.  In order to formulate the FOL questions that \nthe con.g\u00aduration model needs to be asked during the completeness proof, we also need some minimal support \nfrom the signa\u00adture and the model of con.gurations. Speci.cally, in order to G\u00f6delize over sequences \nof con.gurations, we need to express G\u00f6del s \u00df predicate in our FOL, so the con.gura\u00adtion signature S \nneeds to have a distinct sort N with constant symbols 0 and 1 and with binary operation symbols + and \n\u00d7, which are interpreted in the con.guration model T as the domain of natural numbers with corresponding \nconstants and binary operations. We also need to assume that T can enumerate its own con.gurations. The \nweakest condition we were able to .nd in order to achieve that is to assume that S has an operation a \n: Cfg . N which is interpreted in T as an injective (one to one) function. To simplify writing, we deliberately \nmake no distinction between operations in S and their interpretation in T. To summarize all the discussion \nabove, in the remainder of of this section we will work under the following Framework: The reachability \nsystem S is non-empty;  .nite;  well-de.ned; and  .nite branching. The con.guration signature S has \n  a sort N;  constant symbols0 and1of N;  binary operation symbols + and \u00d7 on N;  an operation \nsymbol a : Cfg . N. The con.guration model T interprets  N as the natural numbers; operation symbols \non N as corresponding operations;  a : Cfg . N as an injective function.  Recall that Var is a sort-wise \nin.nite set of (.rst-order) variables, and that . is a special variable of sort Cfg such that . . Var. \nLet VarS. Var be the .nite set of variables appearing free in anyof the rules in S. Notice that since \n. . ' Var, it is also the case that . . VarS. We let c, c , c0,..., cn be distinct variables of sort \nCfg in Var \\VarS (that is, these do not appear free in rules in S).We also let ., . ' ,.0,...,.n range \nover (not necessarily distinct) con.gurations in the model T, that is, over elements in TCfg, and let \n., . ' range over valuations Var .T. Also recall that, by Proposition 1, matching logic formulae are \na methodological fragment of the FOL theory of the model T.For technical convenience, in this section \nwe work with the FOL translations .. instead of the matching logic formulae .. Moreover, since there \nis no possibility for confusion, we drop the . from .. , and we use . to denote the FOL translation. \nWe mention that in all the formulae used in this section, . only occurs in the context . = t, thus we \nstay inside the methodological fragment. 7.1 G\u00f6delization of Con.gurations We use G\u00f6del s\u00df predicateto \nencodefacts about sequencesof con.gurations in FOL (see[33]for an accessible introduction to G\u00f6delization \nand the \u00df predicate). The predicate \u00df relies on the reminder of a when divided by b, namely a mod b.We \nhave that r = a mod b can be de.ned as .d (b\u00d7 d = a .b\u00d7 (d + 1) > a .a = b\u00d7 d + r) \u00df(a, b, i, x)is the \npredicate over natural numbers de.ned as \u00df(a, b, i, x)= x = a mod1 + (1 + i)\u00d7 b Note that our assumptions \nabout the con.guration model T allow us to express G\u00f6del s \u00df predicate. The main role of G\u00f6del s \u00df predicate \nis to encode, using conventional FOL, quanti.cation over .nite sequences of natural numbers. This is \ndue to the following canonical property of \u00df: if u0,..., un is a sequence of natural numbers, then there \nexist natural numbers a and bsuch that for all iwith 0 = i = n and x, we have |= \u00df(a, b, i, x). x = ui;in \nother words, a, b and i uniquely identify ui. This allows us to take sentences .u0,..., un ., where n \nis a given natural number and . a FOL formula, and yield equivalent sentences .a, b ., where . is a FOL \nformula obtained from . by applying some systematic translation. As part of this translation, each atomic \npredicate pof . is translated into .ui1,..., uik (\u00df(a, b, i1, ui1).\u00b7\u00b7\u00b7 .\u00df(a, b, ik, uik). p) where ui1,..., \nuik are all the variables among u0,..., un con\u00adtained by p. The interesting cases are when .u0,..., un \n. occurs in contexts where n itself is existentially or univer\u00adsally quanti.ed; in those cases, only \na .xed (independent of n)subset of the variables u0,..., un can occur in p, which means that the k above \nis .xed and independent of n, which means that . is a correct FOL formula in those contexts. Thus, thanks \nto G\u00f6del s \u00df predicate, statements of the form .u0,..., un ., which are not proper FOL formulae in con\u00adtexts \nwhere n is a quanti.ed variable, can be replaced with equivalent FOL formulae .a, b .. It can be shown, \nalthough the proof is tedious and not necessary here, that the injectivity of a : Cfg . N allows us to \nadapt the result above to sequences of con.gurations in T: sentences of the form .c0,..., cn ., where \nn is a given natural number and . a FOL formula, can be systematically translated into equivalent sentences \nof the form .a, b., where . is a FOL formula replacing each atomic predicate p of . containing variables \nci1,..., cik with  .ci1,..., cik (\u00df(a, b, i1,a(ci1)).\u00b7 \u00b7 \u00b7. \u00df(a, b, ik,a(cik)).p) The injectivity of \na guarantees that di.erent free occurrences of the same variable ci in . are correctly related in .. \nWe only need the particular instance of this general result when . expresses connectedness of c0,..., \ncn in(T, .T), and we S prove that instance separately (Lemma 9).  7.2 EncodingTransition System Operations \nin FOL We introduce the following de.nitions of: (1) the one step transition, (2) the transition sequence \nof length n (n is arbi\u00adtrary but .xed), (3) the in.nite transition sequence, (4) the con.gurations that \nreach ., and (5) the con.gurations that reach . in at least one step. Except for the .rst de.nition of \nthe step predicate below, which is a proper FOL formula because S is .nite, the de.nitions below quantify \nover se\u00adquences of con.gurations c0,..., cn, so theyare not (yet) FOL formulae. Lemma9 shows how to G\u00f6delize \nsuch sequences and thus tells us that we can express all these predicates in FOL.For simplicity, the \n.rst three de.nitions do not allow . as a parameter. Thus, we cannot directly use path(., c ' )and n \nstep(., c '' )in the fourth and .fth de.nitions, respectively. Instead, we introduce an existentially \nquanti.ed variable c which is constrained to be equal to .. ' step(c, c ' ) =.VarS (left[c/.].right[c \n/.]) left.right.S ' path(c, c ' ) =.c0c1 ... .cn (c = c0 .c = cn n . step(ci-1, ci)) 1=i=n ' in.nite(c) \n=.n .c path(c, c ' ) n ' coreach(.) =.n .c .c (c = . ..[c ' /.].path(c, c ' )) n '' coreach+(.) =.c (.c \n(. = c .step(c, c '' )) .coreach(.)[c '' /.]) The following lemmas state that the above de.nitions actually \nhave the semantic properties their names suggest. Recall that ' c, c , c0,..., cn are distinct variables \nof sort Cfg in Var\\VarS. Lemma 7. . |= step(c, c ' )i. .(c).T .(c ' ). S Lemma 8. Let n be a natural \nnumber. Then . |= path(c, c ' ) n .nT i. .(c).(c ' ). S Now, using G\u00f6del s \u00df predicate and the general \nschema described in Section 7.1, we can de.ne a transition sequence of length n (n is arbitrarybut.xed)inFOLusingonlya.xed \nnumber of quanti.ers as shown in Figure 9. Formally, we have the following relationship: Lemma 9. |= \npath(c, c ' ). path(c, c ' ). nn Consequently, we can use path(c, c ' ), the alternative n equivalent \nde.nition of path(c, c ' ), to express in.nite(c), n coreach(.)andcoreach+(.)in FOL. Since our relative \ncom\u00adpleteness proof only uses step(c, c ' ), in.nite(c), coreach(.) and coreach+(.)besides other FOL \nformulae over the sig\u00adnature S, we can conclude that all the formulae used in our proof are FOL formulae.For \nnotational simplicity, we how\u00adever prefer to continue to work with path instead of path. Since S is .nite \nbranching, a con.guration in TCfg does not terminate in(T, .T)if and only if it yields .nite paths of \nS anylength.Formally, we can prove the following: Lemma 10. . |= in.nite(c) i. .(c) does not terminate \nin (T, .T). S Lemma 10 implies the following valid formula (of T): Lemma 11. |= in.nite(c)..c ' (step(c, \nc ' ).in.nite(c ' )). Lemma8 implies the following property of coreach(.): Lemma 12. (., .)|= coreach(.)i. \nthere exists some . ' with .T . ' (. ' ,.)|= . and . . . S The following result formally establishes \nthe expected relationship between ., coreach(.), and coreach+(.): Lemma 13. |= coreach(.). . .coreach+(.). \n 7.3 Encoding SemanticValidity in FOL Here we show that the semantic validity of matching logic reachability \nrules can be framed as FOL validity. Proposition 3. If S|= . . . ' then the FOL validity |= . ..c (. \n= c .in.nite(c)) .coreach(. ' ) holds in T. Note that the proposition above, while reducing semantic \nvalidity of our reachability sequents to FOL validity, does not yet prove the desired relative completeness \nresult. As an analogy, consider the relative completeness of Hoare logic for some simple language. Similarly, \none can reduce the semantic validity of a Hoare triple {.}code {. '}to FOLvalidity,but that does not \ndirectly imply that {.}code {. '} is derivable with the Hoare logic proof system. One still has to construct \na proof derivation for {.}code {. '}using the available proof system, which is the hard part of the relative \ncompleteness result for Hoare logic. Similarly, we still have to construct a derivation for our reachability \nrule . . . ' using the available matching logic proof system in Figure 7.  7.4 Relative Completeness \nWe are now ready to start using the proof system to derive a semanticallyvalid reachability rule.Wedo \nsoby proving several helping lemmas. The next lemma states that if a logical step (in terms of the step \npredicate) is possible from the current con.guration to a next con.guration, then that next con.guration \nis provably reachable without Re.exivity. The result may sound obvious, but, however, it requires the \nwell-de.nedness of S. For  ' path(c, c ' ) =.a.b (.c0(\u00df(a, b, 0,a(c0)) .c = c0)..cn (\u00df(a, b, n,a(cn)) \n.c = ) ncn..i (1 = i.i = n ..ci-1.ci (\u00df(a, b, i-1,a(ci-1)) .\u00df(a, b, i,a(ci)) .step(ci-1, ci)))) Figure \n9. FOL de.nition of a transition sequence example, if S consists of a rule of the form p . p1 . p2 then \nthe rule below cannot be derivable because, if it were, then by the Substitution derived rule (Lemma \n4), it would ' also be derivable when c is substituted with p1;however, in that case the rule becomes \np . p1, which is not derivable (see the discussion in the preamble of Section 7). ' Lemma 14. S..c (. \n= c .step(c, c ' )) .+ . = c. The next lemma states that the reachability rule whose both patterns specify \nnon-termination is derivable without Re.exivity. Intuitively, that is because the step predicate will \nrelate a non-terminating con.guration with at least one next non-terminating con.guration. This lemma \nenables the use of the Circularity rule later (in Lemma 17). Lemma 15. S ..c(. = c.in.nite(c)) .+ .c(. \n= c.in.nite(c)) Lemma 16. If S.A. coreach+(.). ., then S.A. coreach(.). . The following result is critical \nfor the completeness theo\u00adrem: it says that the reachability rule from the pattern speci\u00adfying either \nnon-terminating con.gurations or con.gurations reaching . to . is derivable: Lemma 17. S..c (. = c .in.nite(c)) \n.coreach(.). .. Finally, the relative completeness result now follows from all the above lemmas. Note \nhow the con.guration model is being used, via Proposition 3, as an oracle to answer the semantic reachability \nquestion formulated as a FOL sentence. Theorem 2. If S|= . . . ' then S. . . . ' . Proof. Assume that \nS|= . . . ' . Then, by Proposition 3, we have that |= . ..c (. = c .in.nite(c)) .coreach(. ' ) Further, \nby Lemma 17, we have that S..c (. = c .in.nite(c)) .coreach(.). . Then the theorem follows by Consequence. \n. 8. Implementation and Evaluation Here we discuss our MatchC implementation of the proof system in Figure \n7. While the proof system can be easily implemented in most theorem proving environments, we pre\u00adferred \nan implementation that emphasizes automated reason\u00ading. Our results demonstrate that matching logic reachability \nis practical in a more common sense, that is, that it can be used for relatively e.cient and highly automatedveri.cation \nof expressive properties about challenging programs (like AVL trees and Schorr-Waite).MatchCtakes as \ninputs code fragments writteninaCfragmentand(userprovided) speci.\u00adcations for functions and loops, and \nautomatically checks that the code respect the speci.cations (without user interaction or additional \nannotations, like ghost variables or hints). As discussed in Section 5, general matching logic speci.\u00adcations \nare reachability rules between formulae. As seen in Section 3, our tool handles speci.cations of the \nform: .X(p ..)..X ' (p '.. ' ) where: p and p ' are basic patterns; . and . ' are pattern\u00adless FOL formulae; \nX and X ' are sets of .rst-order vari\u00adables; p contains the cell .code \u00b7\u00b7\u00b7.k and p ' contains the cell \n.code ' \u00b7\u00b7\u00b7.k;andcode is either \u00b7 or the return state\u00adment.For now,MatchC only supports (partial correctness) \nrules summarizing the behavior of functions or loops. An invariant .X(p ..)forwhile(C)S is just syntactic \nsugar for a reachability rule.For clarity, we consider the case when the condition C checks if a program \nvariable x is non-zero (the general case is similar). Then, if the environment of p maps x into vx , \nwe associate with the loop the following rule: .X(p ..)..X(p '.. .vx = 0) where p ' is obtained from \np by replacing .while(x)S \u00b7\u00b7\u00b7.k with .\u00b7 \u00b7\u00b7\u00b7.k, i.e., dropping the loop. The above rule sum\u00admarizes the \nloop. Section 6.2 discusses the reachability rule associated to the loop invariant of reverseList in \nFigure 2. We de.ne the operational semantics of theC fragment in the K framework[26]as a set of reachability \nrules S over the con.guration in Figure 6. Let us discuss in more detail how to use the proof system \ninFigure7and the derived proof rules in Section 6.1 to derive symbolic execution using S as axioms. For \nexample, consider the reachability rule in the Example 1. First, we look at one step of symbolic execution, \nand then we consider formula abstraction. Figure 10 formally derives the execution of the as\u00adsignment \ny = x->next (assuming that x->next evalu\u00adates to some value q). The HEAP macro stands for the cell .list(?p)(?B), \n?x .. [a, q], list(q)(\u00df), H.heap. We give below the reachability rule associated to the K semantics of \nassign\u00adment(inC assignmentisanexpression): ..X = V . K.k .X .. P, E.env C.cfg . ..V . K.k .X .. V, E.env \nC.cfg Like refocussing[7], K .attens computations in a stack-like structure whose tasks are separated \nby . (read followed by ), whose intuition is that its left argument is .rst evaluated and then its value \nis passed to its right argument, which inserts  \u00b7 Axiom S. ..X = V . K.k .X .. P, E.env C.cfg . ..V \n. K.k .X .. V, E.env C.cfg Subst S. ..y= q . K.k .x .. ?x, p .. ?p, y .. ?y, E.env HEAP C.cfg . ..K.k \n.x .. ?x, p .. ?p, y .. q, E.env HEAP C.cfg LF S. ..y= q . K.k .x .. ?x, p .. ?p, y .. ?y, E.env HEAP \nC.cfg .. . ..K.k .x .. ?x, p .. ?p, y .. q, E.env HEAP C.cfg .. Figure 10. Formal derivation of symbolic \nassignment . . . S. ..*( ?x +Int 1) . K.k .list(?p)(?B), ?x .. [a, q], list(q)(\u00df), H.heap ENV C.cfg \n.. '.?x . 0.?C = [a]@\u00df . ... Abs S..a.q (..*( ?x +Int 1) . K.k .list(?p)(?B), ?x .. [a, q], list(q)(\u00df), \nH.heap ENV C.cfg .. '.?x . 0.?C = [a]@\u00df). ... Cons S. ..*( ?x +Int 1) . K.k .list(?p)(?B), list(?x)(?C), \nH.heap ENV C.cfg .. '.?x . 0 . ... Figure 11. Use of Consequence and Abstraction to reduce a more abstract \ncon.guration (bottom) to a more concrete one (up). it in the appropriate place, marked by .. Let . : \nVar . TS(Var)be a substitution mapping the free variables in the rule above as follows: .(X)= y .(V)= \nq .(K)= .;x->next=p;p=x; x=y; .(P)= ?y .(E)= x .. ?x, p .. ?p, E .(C)= .list(?p)(?B), ?x .. [a, q], list(q)(\u00df), \nH.heap C and let . be the patternless .rst-order formula ?C = [a]@\u00df . A = rev(?B)@?C . ?x . 0. Then, \nwe can symbolically execute the assignment by applying the Logic Framing proof rule with the frame ., \nthe Substitution derived proof rule with the substitution . above and the Axiom proof rule with the rule \nabove, as shown in Figure 10. The use of this sequence of Axiom, Substitution and Logic Framing is generic \nand entirely automatic. Further, theTransitivity proof rule allows the chaining of such sequences. The \nCase Analysis proof rule allows for splitting on constructors such as if when their conditions evaluate \nto symbolic values. Next, we consider an issue that arises due to formula abstraction: the con.guration \ncan be too abstract for the se\u00admantic rule to apply via Axiom. In such a case, the Con\u00adsequence and Abstraction \nproof rules can reduce proving a reachability property about a more abstract con.guration, which is not \nmatched by any semantic rules, to a property about a more concrete con.guration. Figure 11 shows such \nan example caused by the symbolic memory read from the location *( ?x +Int 1), which occurs as part of \nthe evalu\u00adation of x->next in the context in Figure 8. The macro ENV stands for .x .. ?x, p .. ?p, y \n.. ?y, E.env, while . ' is A = rev(?B)@?C.We use Consequence with the list abstrac\u00adtion axiom in Section \n4.2 and thefact that ?x . 0 followed by Abstraction with {a, q} and then we can symbolically evaluate \n*( ?x +Int 1) in a con.guration in which ?x +Int 1 is explicitly mentioned in the heap. In general, we \ncan use the .rst seven rules of the proof system (the proof system without Circularity) to derive the \nsymbolic execution of a linear segment of code (code without circular behaviours). Let C be the set of \nreachability rules specifying all the user provided program properties. Ccontains one candidate rule \nfor each function and one candidate rule for each loop. MatchC derives the rules in C by applying the \nproof rules in Figure 7 and the derived proof rules in Section 6.1 ac\u00adcording to certain heuristics. \nIt begins by applying Circu\u00adlarity followed by Transitivity for each rule in C and re\u00adduces the tasks \nto deriving individual sequents of the form A.C ..X(p ..) ..X ' (p '.. ' ). To prove each such rule, \nthe tool symbolically executes the code in the left-hand\u00adside formula using axioms from A.C (like in \nthe example above), and then checks that the formulae obtained after the execution imply the right-hand-side \nformula. Recall that the code of the right-hand-side is either \u00b7 or return, so we know how the symbolic \nexecution should terminate. For each left-hand-side there may be multiple execution paths, generated \nby splits via Case Analysis on constructors like if or on disjunctions existent in the speci.cations \nor introduced by abstraction axioms or domain reasoning. Similarly, when the con.guration is too abstract \nfor anyrule in A.C to apply, the tool uses abstraction axioms to obtain a more concrete con.guration \nif certain triggers are met; in the example above, the memory access on the head of the list triggered \nthe unrolling. As an optimisation, when a formula can be reduced with rules from both S and C, the veri.er \nonly uses the rules from C. In particular, only a loop without a speci.ed invariant is unrolled, and \nonly the body of a function without a rule speci.cation is executed. Another heuristic is that if the \ncurrent formula implies that application of an abstraction axiom would result into a more concrete formula, \nthe veri.er applies the respective axiom (for instance, knowing the head of a list is not null results \nin an automatic list unrolling).MatchCis therefore soundbut incomplete w.r.t. the reachability proof \nsystem. The symbolic execution is also implemented in K, as a set of rules which are added to the original \nset of semantic rules. Checking of matching logic formulae implication (required for Consequence) is \nimplemented in Maude[6]. Proving such an implication consists of two parts: matchingthe structure of \nthe con.guration, and checking the constraints. The structure matching is done modulo both abstraction \naxioms and math\u00adematical domain axioms. If all the structure is successfully matched, and the remaining \nconstraint does not simplify to true, it is passed to CVC3[2]and Z3[8].MatchCcomes with a library of \n~100 mathematical domain operators (like rev, in) and pattern abstractions (like list), together with \ntheir axioms and useful lemmas (see Section 4.2). It currently provides support for reasoning about lists, \ntrees, queues and graphs.  Figure 12 summarises the results of our experiments (# paths column gives \nthe number of symbolic execution paths analysed).Twofactorsguided us: proving functional correctness \n(as opposed to just memory safety) and doing so automatically (the user only provides the speci.cations). \nThe unde.ned behavior is detected by execution based on the semantics. The functional behavior of the \nprograms manipulating lists and trees and performing arithmetic and I/O operations is algebraically de.ned, \nand is similar to thatoftheexamplesin Figures2 ,3and5.Forthe sorting algorithms,MatchC checks that the \nsequence is sorted and has the expected multiset of elements, and for the search trees, it checks that \nthe tree respects the data structure invariant and has the expected multiset of elements. The Schorr-Waite \ngraph marking algorithm computes all the nodes in a graph that are reachable from a set of starting nodes.To \nachieve that, it visits the graph nodes in depth-.rst search order, by reversing pointers on the way \ndown, and then restoring them on the way up. Its main application is ingarbage collection. The Schorr-Waite \nalgorithm presents considerableveri.cation challenges[17,18].We formally veri.ed the algorithm itself, \nand a simpli.ed version in which the graphisa tree.For both cases we proved thata nodeis marked if and \nonly if it is reachable from the set of initial nodes, and that the graph does not change. Most of these \nexamples are proved in milliseconds and do not require SMT support. We mention that the AVL insert and \ndelete programs take approximately3minutes together because some of the auxiliary functions (like balance) \nare not given speci.cations and thus their bodies are being executed, resulting in a larger number of \npaths to analyze. Given the complexity of the speci.cations and the level of automation, the average \ntime per program (below one second) is low and not a matter of concern. The experiments were conducted \non a quad-core, 2.2GHz, 4GB machine running Linux. 9. Conclusion and FutureWork This paper presented \nan eight-rule proof system for reach\u00adability, parametric in an operational semantics of the target programing \nlanguage. The proof system was proved partially correct and relatively complete. At our knowledge, this \nis the .rst language-independent proof system with these proper\u00adties. Previous proof systems, such as \nthose corresponding to Hoare/separation/dynamic logics and extensions of them, are language-speci.c and \nneed to be proved sound with respect to another semantics of the same language. With the help of Stefan \nCiobaca and Brandon Moore, we have started developing in Coq a certi.able program veri.cation framework \nbased on the presented proof system. Program Cells Time (s) #paths SMT? Example programs unde.ned  \n0.01 1 no list reverse heap 0.06 2 no list read in, heap 0.14 7 no stack inspection call stack 0.24 8 \nno tree to list (iterative) heap, out 0.24 11 no Unde.ned programs division by zero  0.01 1 no uninitialized \nvariable  0.01 1 no unallocated location  0.01 1 no Simple programs that need only the environment \ncell average  0.02 1 no min  0.04 2 no max  0.04 2 no mul by add  0.13 3 yes sum (recursive)  0.06 \n2 yes sum (iterative)  0.08 2 yes assoc comm  0.03 1 no Lists list head heap 0.02 2 no list tail heap \n0.02 1 no list add heap 0.02 1 no list swap heap 0.03 3 no list deallocate heap 0.04 2 no list length \n(recursive) heap 0.05 2 no list length (iterative) heap 0.07 2 no list sum (recursive) heap 0.05 2 no \nlist sum (iterative) heap 0.07 2 no list append heap 0.1 3 no list copy heap 0.13 3 no list .lter heap \n0.22 5 no Input and output read write in, out 0.12 4 no list write heap, out 0.06 2 no list read write \nheap, in, out 0.15 5 no Trees tree height heap 0.1 4 no tree size heap 0.07 3 no tree .nd heap 0.12 \n5 no tree mirror heap 0.7 3 no tree in-order heap 0.7 3 no tree pre-order heap 0.7 3 no tree post-order \nheap 0.7 3 no tree deallocate heap 0.14 7 no tree to list (recursive) heap, out 0.1 4 no Call stack \nonly gcalls f call stack 0.04 2 no hin stack when f call stack 0.04 2 no Sorting algorithms insert heap \n0.35 5 no insertion sort heap 0.41 6 no bubble sort heap 0.30 6 no quicksort heap 0.47 8 no merge sort \nheap 1.97 16 yes Search trees BST .nd heap 0.15 5 yes BST insert heap 0.13 4 yes BST delete heap 0.38 \n10 yes AVL .nd heap 0.15 5 yes AVL insert heap 43.5 23 yes AVL delete heap 133.58 36 yes Schorr-Waite \ntree Schorr Waite heap 0.28 6 no graph Schorr Waite heap 1.73 8 no Figure 12. Results of MatchC program \nveri.cation  Our progress can be seen at http://fsl.cs.uiuc.edu/ml. Our objective is to develop language-independent \ntactics that allow for compact and intuitive proofs of program correctness, as well as for generation \nof certi.able proof objects relying only on the operational semantics of the target language and requiring \nno low-level inductive proofs about the transition system associated to the operational semantics, and \nno language-speci.c lemmas.We also intend to generalize our e.cientMatchC prover into a generic one, \nand connect it with the Coq-based framework, to achieve both e.cient and certi.able veri.cation based \non the presented proof system. Acknowledgements: We thank the members of the K team (http://k-framework.org)and \nthe anonymous reviewers for their valuable comments on a previous version of this paper. The work in \nthis paper was supported in part by NSA contract H98230-10-C-0294, by NSF grant CCF-0916893 and by (Romanian) \nSMIS-CSNR 602-12516 contract no. 161/15.06.2010. References [1] A.W. Appel.Veri.ed software toolchain. \nIn ESOP, volume 6602 of LNCS, pages 1 17, 2011. [2] C. Barrett and C. Tinelli. CVC3. In CAV, pages 298 \n302, 2007. [3] G. Berry and G. Boudol. The chemical abstract machine. Th. Comp. Sci., 96(1):217 248, \n1992. [4] S. Blazy and X. Leroy. Mechanized semantics for the Clight subset of theClanguage. J.Autom. \nReasoning, 43(3):263 288, 2009. [5] A. Chlipala. Mostly-automated veri.cationoflow-level pro\u00adgrams in \ncomputational separation logic. In PLDI, pages 234 245, 2011. [6] M. Clavel,F. Dur\u00e1n, S. Eker, J. Meseguer,P. \nLincoln, N. Mart\u00ed-Oliet, and C.Talcott. All About Maude, volume 4350 of LNCS. 2007. [7] O. Danvy and \nL. Nielsen. Refocusing in reduction semantics. Technical Report RS-04-26, BRICS, 2004. [8] L. M. de Moura \nand N. Bj\u00f8rner. Z3: An e.cient SMT solver. In TACAS, volume 4963 of LNCS, pages 337 340, 2008. [9] D. \nDistefano, P. W. O Hearn, and H. Yang. A local shape analysis based on separation logic. In TACAS, volume \n3920 of LNCS, pages 287 302, 2006. [10] C. Ellison andG. Rosu. Anexecutable formal semanticsofC with \napplications. In POPL, pages 533 544, 2012. [11] M. Felleisen and R. Hieb. The revised report on the \nsyntactic theories of sequential control and state. Th. Comp. Sci., 103 (2):235 271, 1992. [12] M. Felleisen, \nR. B. Findler, and M. Flatt. Semantics Engineer\u00ading with PLT Redex. MIT, 2009. [13] R.W. Floyd. Assigning \nmeaning to programs. In Symposium on Applied Mathematics, volume 19, pages 19 32, 1967. [14] J. Goguen \nand G. Malcolm. Algebraic Semantics of Imperative Programs. MIT Press, 1996. [15] D. Harel, D. Kozen, \nand J. Tiuryn. Dynamic logic. In Handbook of Philosophical Logic, pages 497 604, 1984. [16] A. Hobor, \nA.W. Appel, andF. Z. Nardelli. Oracle semantics for concurrent separation logic. In ESOP, volume 4960 \nof LNCS, pages 353 367, 2008. [17] T. Hubert and C. March\u00e9. A case study of C source code veri.cation: \nthe Schorr-Waite algorithm. In SEFM, pages 190 199, 2005. [18] A. Loginov,T.W. Reps, andM. Sagiv. Automatedveri.cation \nof the Deutsch-Schorr-Waite tree-traversal algorithm. In SAS, 2006. [19] J. Meseguer. Conditioned rewriting \nlogic as a united model of concurrency. Theor. Comput. Sci., 96(1):73 155, 1992. [20] P. D. Mosses. CASL \nReference Manual, volume 2960 of LNCS. Springer, 2004. [21] T. Nipkow.Winskelis (almost) right:Towardsa \nmechanized semantics textbook. Formal Aspects of Computing, 10:171 186, 1998. [22] P.W. O HearnandD.J.Pym.Thelogicofbunched \nimplica\u00adtions. Bulletin of Symb. Logic, 5(2):215 244, 1999. [23]P.W. O Hearn,J.C.Reynolds, andH.Yang. \nLocal reasoning about programs that alter data structures. In CSL, pages 1 19, 2001. [24] D.Pavlovic \nand D. R. Smith. Composition and re.nement of behavioral speci.cations. In ASE, pages 157 165, 2001. \n[25] J. C. Reynolds. Separation logic:Alogic for shared mutable data structures. In LICS, pages 55 74, \n2002. [26] G. Rosu andT.-F. Serbanuta. Anoverviewof theK semantic framework. J. Log. Algebr. Program., \n79(6):397 434, 2010. [27] G. Rosu and A. Stefanescu. Matching logic: a new program veri.cation approach \n(NIER track). In ICSE, pages 868 871, 2011. [28] G. Rosu and A. Stefanescu. Towards a uni.ed theory of \noperational and axiomatic semantics. In ICALP (2), volume 7392 of LNCS, pages 351 363, 2012. [29] G. \nRosu and A. Stefanescu. From Hoare logic to matching logic. In FM,To appear, 2012. [30] G. Rosu and A. \nStefanescu. Checking reachability using matching logic.Technical Report http://hdl.handle.net/ 2142/33771, \nUniv. of Illinois, Aug. 2012. [31] G. Rosu, C. Ellison, and W. Schulte. Matching logic: An alternative \nto Hoare/Floyd logic. In AMAST, volume 6486 of LNCS, pages 142 162, 2010. [32] S. Sagiv, T. W. Reps, \nand R. Wilhelm. Parametric shape analysis via 3-valued logic. ACM Trans. Prog. Lang. Syst., 24(3):217 \n298, 2002. [33] G.Winskel. The formal semantics of programming languages -an introduction. Foundation \nof computing series. MIT Press, 1993. [34] A. Wright and M. Felleisen. A syntactic approach to type soundness. \nInf. &#38; Computation, 115(1):38 94, 1994.   \n\t\t\t", "proc_id": "2384616", "abstract": "<p>This paper presents a verification framework that is parametric in a (trusted) operational semantics of some programming language. The underlying proof system is language-independent and consists of eight proof rules. The proof system is proved partially correct and relatively complete (with respect to the programming language configuration model). To show its practicality, the generic framework is instantiated with a fragment of C and evaluated with encouraging results.</p>", "authors": [{"name": "Grigore Rosu", "author_profile_id": "81100069676", "affiliation": "University of Illinois at Urbana-Champaign &#38; Alexandru Ioan Cuza University, Urbana, IL, USA", "person_id": "P3856129", "email_address": "grosu@illinois.edu", "orcid_id": ""}, {"name": "Andrei Stefanescu", "author_profile_id": "81485649989", "affiliation": "University of Illinois at Urbana-Champaign, Urbana, IL, USA", "person_id": "P3856130", "email_address": "stefane1@illinois.edu", "orcid_id": ""}], "doi_number": "10.1145/2384616.2384656", "year": "2012", "article_id": "2384656", "conference": "OOPSLA", "title": "Checking reachability using matching logic", "url": "http://dl.acm.org/citation.cfm?id=2384656"}