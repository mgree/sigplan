{"article_publication_date": "10-19-2012", "fulltext": "\n Predicate Abstraction of Java Programs with Collections Pavel Par\u00b4izek ak Ond.rej Lhot\u00b4David R. Cheriton \nSchool of Computer Science, University of Waterloo {pparizek,olhotak}@uwaterloo.ca Abstract Our goal \nis to develop precise and scalable veri.cation tech\u00adniques for Java programs that use collections and \nproperties that depend on their content. We apply the popular approach of predicate abstraction to Java \nprograms and collections. The main challenge in this context is precise and compact modeling of collections \nthat enables practical veri.cation. We de.ne a predicate language for modeling the observ\u00adable state \nof Java collections at the interface level. Changes of the state by API methods are captured by weakest \npre\u00adconditions. We adapt existing techniques for construction of abstract programs. Most notably, we \ndesigned optimizations based on speci.c features of the predicate language. We evaluated our approach \non Java programs that use col\u00adlections in advanced ways. Our results show that interesting properties, \nsuch as consistency between multiple collections, can be veri.ed using our approach. The properties are \nspec\u00adi.ed using logic formulas that involve predicates introduced by our language. Categories and Subject \nDescriptors D.2.4 [Software Engi\u00adneering]: Software/Program Veri.cation; F.3.1 [Logics and Meanings of \nPrograms]: Specifying and Verifying and Rea\u00adsoning about Programs General Terms Veri.cation Keywords \nJava, collections, predicate abstraction 1. Introduction Our goal is to develop practical veri.cation \ntechniques for Java programs that heavily use the collections provided by the standard library. We call \nthem client programs because they are clients of the collection library. We target properties that depend \non the content of collections in some way for Permission to make digital or hard copies of all or part \nof this work for personal or classroom use is granted without fee provided that copies are not made or \ndistributed for pro.t or commercial advantage and that copies bear this notice and the full citation \non the .rst page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires \nprior speci.c permission and/or a fee. OOPSLA 12, October 19 26, 2012, Tuscon, Arizona, USA. Copyright \nc &#38;#169; 2012 ACM 978-1-4503-1561-6/12/10. . . $10.00 example, (i) assertions over program variables \nthat contain values retrieved from collections, (ii) consistency between multiple collections, and (iii) \nvalidity of method calls on col\u00adlection objects depending on the current state and parameter values. \nFor illustration, consider the Java program in Fig\u00adure 1, which computes a schedule from available information \nabout threads. Two properties of interest are the following: (1) the object variables schTh and actTh \nare not null before the .eld accesses on them, and (2) there is a key-value pair in the map from a thread \nID to a ThreadInfo object for each active thread. The program fails if either of these two proper\u00adties \nis violated during its execution. A veri.cation technique for such Java programs and properties would \nbe practically useful if it is precise (i.e., it does not report spurious er\u00adrors) and scales to large \nprograms with multiple classes and methods. To achieve the necessary precision, the veri.cation technique \nmust be path-sensitive and inter-procedural. Some form of abstraction has to be used for scalability. \nA popular approach to automated software veri.cation is to use predicate abstraction [21] and then run \na model checker to analyze the abstract program, which is much sim\u00adpler than the original program. The \nkey idea behind predicate abstraction is to represent the program state using predicates de.ned in .rst-order \nlogic with speci.c theories (e.g., lin\u00adear arithmetic) over speci.c domains (e.g., integers). Each predicate \ngives some information about the values of pro\u00adgram variables. The effect of individual statements on \npro\u00adgram state can be captured using weakest preconditions. Techniques based on predicate abstraction \nhave been proposed mainly for low-level C programs like device drivers [1, 2, 23]. They are used especially \nfor checking assertions (reachability properties) and temporal properties like validity of event sequences \n(e.g., whether each operation of acquiring a lock is eventually followed by an operation that releases \nthe same lock). We apply predicate abstraction to Java programs and col\u00adlections. The main challenges \nare (1) precise and compact modeling of the collection state with a small number of pred\u00adicates, (2) \nprecise modeling of operations upon collections, (3) support for preserving information between any two \npro\u00adgram code locations, and (4) ef.cient construction of ab\u00adstract programs. Addressing these challenges \nis important  Map<Integer,ThreadInfo> id2thread = new HashMap(); Set<Integer> active = new HashSet(); \n// initialize map with data for several threads id2thread.put(1, new ThreadInfo(1,5)); id2thread.put(2, \nnew ThreadInfo(2,18)); id2thread.put(3, new ThreadInfo(3,10)); // some threads are put into the active \nstate active.add(2); active.add(3); List<Integer> schedule = new LinkedList(); Iterator<Integer> actIt \n= active.iterator(); while (actIt.hasNext()) { int actID = actIt.next(); ThreadInfo actTh = id2thread.get(actID); \nfor (int i =0; i < schedule.size(); i++) { int schID = schedule.get(i); ThreadInfo schTh = id2thread.get(schID); \n if (actTh.priority > schTh.priority) { schedule.add(i, actID); break; }}} Figure 1. Example: thread \nscheduling for scalability to large programs and to enable veri.cation of interesting properties. Many \nprogram veri.cation techniques and frameworks that target collections and data structures have been pro\u00adposed \nin recent years symbolic execution for data struc\u00adtures [25], shape analysis based on predicate abstraction \n[7, 16, 37] or other abstractions [6], logics and decision pro\u00adcedures for heap data structures [7, 29], \ntechniques based on separation logic [18], and various techniques for veri.\u00adcation of linked list implementations \n[9, 10, 28] and general programs that use collections against functional speci.ca\u00adtions [40, 41]. Most \nof these approaches model collections at the representation level. They explicitly consider the inter\u00adnal \ndata structures that implement higher-level collections, heap nodes that represent objects, and pointers \nbetween the heap nodes for example, the nodes and edges of the tree that is used internally to implement \nthe TreeMap class from the Java library. However, it is not necessary to consider the internal representation \nof collections and their implementa\u00adtion details to verify programs that use collections through a well-de.ned \npublic interface (API), since the functional be\u00adhavior of a client program does not depend on the internal \ndata structures and the shape of heap regions used by them. There also exist approaches to modeling program \nbehav\u00adior that can be used for collections, such as the popular contract speci.cation languages JML [30] \nand Spec# [5], and various logics for reasoning about data structures [27, 33, 45]. However, speci.cations \nde.ned in the contract lan\u00adguages (preconditions, postconditions, and invariants) have limited expressive \npower, because they cannot refer to lo\u00adcal variables and they can be associated only with particular \ncode locations (e.g., method boundaries). The corresponding veri.cation techniques [4, 19] are modular \nat the granularity of procedures, which means that they are ef.cient, but they cannot be used for checking \nproperties that span multiple procedures (not in a caller-callee relationship) and for con\u00adsistency properties \nbetween collections owned by unrelated objects. The logics for data structures are either very com\u00adplex \nand not suitable for predicate abstraction, or they are not supported by state-of-the-art decision procedures \nyet. Our approach is to verify client Java programs in a path\u00adsensitive and inter-procedural manner by \nusing predicate ab\u00adstraction and modeling Java collections at the interface level. This approach requires \nfewer predicates about the program state than if collections were modeled at the representation level, \nand it therefore enables more ef.cient and scalable veri.cation. We consider only the state and behavior \nob\u00adservable by client programs as speci.ed by the textual API documentation. We assume that the implementation \nof the collection classes is correct and conforms to the documen\u00adtation. The latter should be true for \nevery implementation of the Java collections API. In this paper, we describe our approach to modeling \nJava collections at the interface level using predicates and its usage for practical veri.cation of Java \nprograms that use collections. We de.ne the following: a translation from the Java collections into \nabstract maps,  a predicate language for modeling the externally observ\u00adable state of collections, and \n weakest preconditions that capture changes of the ob\u00adservable state by API methods.  We adapt existing \ntechniques for constructing abstract programs that were introduced for programs in the C lan\u00adguage [2, \n3]. We describe aspects of the construction that are speci.c to our approach and target domain. In particular, \nwe designed optimizations that exploit speci.c features of the predicate language. Finally, we evaluate \nour approach on Java programs that use collections in advanced ways. Our experiments show that interesting \nproperties of the Java programs can be suc\u00adcessfully veri.ed using our approach. In particular, our pred\u00adicate \nlanguage allows to capture all information about the state of collections that is necessary to verify \nthe properties speci.ed for the benchmark programs.  2. Overview We start with a general overview of \nour approach on the example Java program in Figure 1. In order to verify the properties mentioned in \nthe previous section, it is necessary to have information about the content of the collections pointed \nto by the variables id2thread and active. The variables schTh and actTh refer to data retrieved from \ncollections. The stored data form the observable state of both collections in this case. Changes of their \ncontent by operations like add and put must be captured too. We do not have to consider the internal \nimplementation of collection classes (e.g., HashMap), because the properties are speci.c to the given \nclient program. However, note that the collections cannot be abstracted away completely, be\u00adcause it \nwould not be possible to verify the given properties without any information about the content of the \nmaps. The necessary information about the collections is cap\u00adtured by predicates such as mget(map, id2thread, \n1) ., = mget(map, active, 2) = true, and actTh = null. The pred\u00adicates describe the content of the map \nid2thread and the set active, and the value of the variable actTh. The actual veri.cation of the given \nJava program with our approach consists of three steps: 1. predicates about collections and other program \nvariables that are necessary for the veri.cation of the properties are acquired (provided by the user \nor inferred automatically); 2. an abstract program is generated for the given client Java program, a \nset of properties, and a set of predicates about collections and other program variables; 3. the abstract \nprogram is veri.ed using the Java Path.nder model checker.  The abstract program looks like the one \nin Figure 2 it is a simpli.ed fragment. It contains boolean variables, assign\u00adment statements, and Java \ncontrol-.ow structures. For each assignment statement, the new value of a target boolean vari\u00adable is \ndetermined using the weakest preconditions de.ned later in this paper. Java Path.nder (JPF) [44] performs \nexhaustive traversal of the abstract program. If an assertion violation is detected by JPF, then relevant \ninformation is extracted from the error trace and reported to the user. 3. Preliminaries Predicate abstraction. \nAn abstract program is constructed for a given set of predicates about variables in the input pro\u00adgram. \nThe predicates are supplied by the user or inferred au\u00adtomatically. Either a single set of predicates \ncan be used for the whole input program [2] and associated with every state\u00adment, or each statement s \nin the program can be associated with a (possibly different) set of predicates that covers only the aspects \nof program state relevant for the statement [23]. boolean bv1 = false; // mget(map,id2thread,1) != bot \nboolean bv2 = false; // mget(map,active,2) = true boolean bv3 = true; // actTh = null // more boolean \nvariables for other predicates // statement: id2thread.put(1, new ThreadInfo(1,5)) atomic { bv1 = true; \n... } // statement: active.add(2) atomic { bv2 = true; ... } while (...) { // statement: actTh = id2thread.get(actID) \nif (bv1 &#38;&#38; ...) bv3 = false; // property check if (bv3) assert false : actTh == null ; ... } \nFigure 2. Example: abstract program For each statement s in the original program and each predicate p \nwhose truth value may be changed by the execu\u00adtion of s, the abstraction (abstract program) must capture \nthe change of the truth value of p after the execution of s. The ef\u00adfect of individual statements on \nthe truth values of the pred\u00adicates, i.e. on the program state, is determined by weakest preconditions \nin the following way. For the predicate p . P associated with the statement s, the new truth value of \np after the execution of s is determined using the weakest precon\u00addition WP(s, .(p)) of s with respect \nto .(p), where .(p) is a literal over p (i.e., p or \u00acp). Let the set .(P ) represent the actual truth \nvalues of all predicates from the set P just be\u00adfore execution of the statement s, i.e. for each pi . \nP the set .(P ) contains pi or \u00acpi. The new value of p after the exe\u00ad u cution of s is (a) true if the \nformula .(P ) . WP(s, p) u is valid, (b) false if the formula .(P ) . WP(s, \u00acp) is valid, and (c) a non-deterministic \nboolean value (unknown) otherwise. A decision procedure (e.g., an SMT solver) is used to check the validity \nof the formulas. For example, given the statement v := e and the predicate v< 2, the weakest precondition \ne< 2 determines the new truth value of the predicate after the assignment. Array theory. The array theory \n[34] for .rst-order logic de\u00ad.nes a pair of function symbols that represent array accesses. The symbol \nselect(a, i) returns the element a[i]. The symbol store(a, i, v) returns a new array a' which is equal \nto a ex\u00adcept that a'[i]= v. The meaning of the symbols is de.ned by the read-over-write axiom: select(store(a, \ni, e),i)= e. The elements of a with indices not equal to i are not modi.ed by the store function.  4. \nModeling Java Collections with Predicates Our predicate language enables faithful modeling of Java collections \nwith respect to state and behavior observable from client programs. Speci.cally, it can be used to model \nthe common usage patterns of Java collections in real pro\u00adgrams and the dependence of program behavior \non the col\u00adlection state. We support both associative collections (maps and sets) and position-based \ncollections (lists), and iterators over these collections. We also support nested collections (e.g., \na map from integers to linked lists). First we introduce features of the predicate language on several \nexample pro\u00adgrams, and then we provide formal de.nitions. 4.1 Examples Associative collections. Consider \nagain the program frag\u00adment in Figure 1. The program would crash at the .eld ac\u00adcess actTh.priority if \nthe object variable actTh has the null value. To decide whether the variable actTh can be null, we need \ninformation about all key-value pairs in the map id2thread, all elements of the set active, and the current \nvalue of the variable actID. If the map id2thread contains some mapping for every possible key stored \nin actID and the associated value is not null, then the value of actTh cannot be null. We cap\u00adture the \npresence of a key-value pair (k, v) in the map id2thread by the predicate mget(map, id2thread,k)= v and \nabsence of a mapping for a key k by the predicate mget(map, id2thread,k)= .. The symbols mget, map, and \n. are introduced by our predicate language. The possible values of the variable actID correspond to elements \nof the set active. We model sets as maps from pos\u00adsible elements to boolean values, where the boolean \nvalue for a particular element indicates its presence in the set. For example, the presence of a value \ni in the set active is captured by the predicate mget(map, active,i) = true. The property actTh = null \nholds if there is some map\u00adping in id2thread for every element of the set active, i.e. if the formula \n.i :(mget(map, active,i) = true . mget(map, id2thread,i)= .) holds. To determine the truth value of the \nformula, we need the following predicates: mget(map, id2thread, 1) = ., mget(map, id2thread, 2) = ., \nmget(map, id2thread, 3) = ., mget(map, active, 2) = true, and mget(map, active, 3) = true. Ordered lists. \nThe program in Figure 1 also uses the list schedule. The program accesses list elements at speci.c positions \n(via schedule.get(i)) and adds new elements at a speci.c position (via schedule.add(i, actID)). Such \nmethod calls would fail if the position argument (index) is out of the valid range. We model lists as \nmaps from arbitrary integer values to stored elements. However, the integers do not represent element \npositions (see Section 4.2). The presence of the element e in the list schedule is captured by the predicate \nmget(map, schedule,k)= e for an arbitrary integer k. class Image {public List<Rectangle> rectangles; \npublic int[][] pixels; public static void main(String[] args) { Image img = new Image(); img.load(); \nimg.render(); } public void load() {rectangles = new ArrayList(); pixels = new int[50][50]; rectangles.add(new \nRectangle(5, 10, 20, 20, 3)); rectangles.add(new Rectangle(20, 5, 10, 35, 1)); } public void render() \n{Iterator<Rectangle> recIt = rectangles.iterator(); while (recIt.hasNext()) { Rectangle rec = recIt.next(); \nfor (int i = 0; i < rec.width; i++) for (int j =0;j < rec.height; j++) pixels[rec.left+i][rec.top+j] \n= rec.color; }}} Figure 3. Example: rendering image with several rectangles Reasoning about collection \nsize. To determine whether the index argument of a call to schedule.get(i) is in the valid range, we \nneed information about the current size of the list schedule and the current value of the variable i. \nThe valid range of the index argument i is speci.ed by the for\u00admula i = 0 . i < msize(msz, schedule), \nwhere the ex\u00adpression msize(msz, schedule) represents the size of the list schedule. We need the following \npredicates to capture all of the necessary information: msize(msz, schedule) = 0, msize(msz, schedule) \n= 1, msize(msz, schedule) = 2, i=0, i=1, and i=2, Modeling object .elds and arrays. The program in Fig\u00adure \n3 renders an image containing several rectangles. For each rectangle, it sets the relevant pixels to \na given color. An important correctness property is the consistency between the list of rectangles and \nthe array of pixels if a pixel has some color then there must be some rectangle at its position, and \nvice versa. To verify this property, we need information about (1) the values of the .elds of Rectangle \nobjects stored in the list rectangles and (2) the values of speci.c elements of the array pixels. Moreover, \nthe information about objects stored in the list rectangles must be preserved between the calls of methods \nload and render. We model the values of .elds by expressions of the form fread(f, o), where f is the \n.eld name and o is the object variable, and the values of array elements by expressions of  List<Cyclist> \ncyclists = new ArrayList(); cyclists.add(new Cyclist(2, 3725, 5)); cyclists.add(new Cyclist(56, 3569, \n10)); cyclists.add(new Cyclist(40, 3766, 50)); TreeMap<Integer,Cyclist> results = new TreeMap(); Iterator<Cyclist> \ncycIt = cyclists.iterator(); while (cycIt.hasNext()) {Cyclist cl = cycIt.next(); results.put(cl.time \n-cl.bonus, cl); } Collection<Cyclist> resCyclists = results.values(); Iterator<Cyclist> resIt = resCyclists.iterator(); \n Cyclist bestCL = resIt.next(); int bestTime = bestCL.time -bestCL.bonus; print(bestCL.id + + bestTime); \nwhile (resIt.hasNext()) {Cyclist cl = resIt.next(); int diff = cl.time -cl.bonus -bestTime; print(cl.id \n+ + diff) } Figure 4. Example: processing results of a cycling race the form aread(arr, a, i), where \na is an array variable and i is the index. Arrays with multiple dimensions are modeled by nested aread \nexpressions. The consistency property between the list of rectangles and the array of pixels is expressed \nwith the formula .x, y :(aread(arr, aread(arr, pixels,y),x)=0 . (.q : mget(map, rectangles,q)= r . fread(top,r) \n= y . fread(top,r)+ fread(height,r) = y . fread(left,r) = x . fread(left,r)+ fread(width,r) = x)) where \nthe variable r points to a Rectangle object and q is a logic variable. Global predicates over object \n.elds and constants allow preserving information about collections between method calls (inter-procedurally). \nHere, we use predicates of the form mget(map, rectangles,c)= r, where the symbol c denotes an integer \nconstant their truth values would be set during the execution of the method load and used to determine \nthe property status in the method render. Iteration and sorted collections. The program in Figure 4 takes \nas input the raw (unsorted) results of a cycling race and prints the .nal results in a standard format \n .rst the winner s name and race time, and then differences for all other riders. The .nal results are \nprinted correctly if the .rst element of the map results with respect to the iteration order has the \nsmallest key. The iteration order over a speci.c collection coll is mod\u00adeled with predicates of the form \nmorder(mit, coll,q1,q2), where q1 and q2 are keys in the map that represents coll. The key k is the .rst \none in the iteration order for the map results if the predicate morder(mit, results, .,k) holds we use \nthe symbol . also to capture iteration boundaries. If the predicate morder(mit, results, resIt, .) holds \nfor the iterator variable resIt, then it has reached the end and any additional call of next() would \nfail. Therefore, the property \u00acmorder(mit, results, resIt, .) must hold before every call of next on \nthe iterator to guarantee that an exception is not thrown for an attempt to iterate over the end of the \ncollection. The map results is sorted correctly if for any two keys k1 and k2 such that the predicate \nmorder(mit, results,k1,k2) holds, it is also true that k1 <k2. Sorted collections are implemented using \nthe proper iteration order. Note that the iterator resIt is associated with the collection resCyclists \nthat represents a list view of all values in the map results. We model this association with the predicate \nmvalues(mvs, results, resCyclists). Nested collections. The program in Figure 5 models a sim\u00adple data \n.ow analysis. It involves two collections a map from integers to integer arrays that represents a control-.ow \ngraph (IDs of nodes are mapped to successor nodes), and a map from integers (node IDs) to sets that represent \nfacts associated with nodes. Reasoning about the content of sets of facts that are stored in the map \ncfgnode2facts is possible through formulas like mget(map, mget(map, cfgnode2facts, id),e) = true, where \ne is a particular data .ow fact and id is an ID of a node in the control-.ow graph. Similarly, formulas \nlike aread(arr, mget(map, cfg, 2), 0) = 3 capture the content of arrays stored in the map cfgnode2facts \nand thus enable reasoning about the control-.ow graph. The association between the map cfg and the set \ncfg-Nodes, which provides a view of the map keys, is captured by the predicate mkeys(mks, cfg, cfgNodes). \nSummary. The examples above show that the state of a Java collection observable by a client program consists \nof its content, size, iteration order, and views. These aspects of collection state must be captured \nto allow precise reasoning about the behavior of client programs. In the rest of this section, we provide \na more formal description of our approach to modeling Java collections.  4.2 Abstract Maps We de.ne \nour modeling approach on abstract maps that support speci.c operations and iterators over keys. Each \nabstract map is a set of key-value pairs with a spe\u00adci.c iteration order over the keys. The following \noperations are supported: get, put, putAhead, remove, clear, size, containsKey, containsValue, createIterator, \nkeysView, valuesView, and .ndKey. The operation putAhead(k, v, l) inserts a new key-value pair (k, v) \ninto the map such that  // control .ow graph // a map from node IDs to successor nodes IDs Map<Integer, \nint[]> cfg = ... // initialization // facts associated with cfg nodes Map<Integer, Set<Integer>> cfgnode2facts \n= ... // initialize with empty set of facts for each node Set<Integer> cfgNodes = cfg.keySet(); Iterator<Integer> \ncfgIt = cfgNodes.iterator(); while (cfgIt.hasNext()) { int nodeID = cfgIt.next(); cfgnode2facts.put(nodeID, \nnew HashSet<Integer>()); } List<Integer> queue = new LinkedList<Integer>(); queue.add(1); // start with \nthe entry node while (queue.size() > 0) { int cfgnodeID = queue.remove(0); Set<Integer> oldFacts = cfgnode2facts.get(cfgnodeID); \n Set<Integer> newFacts = new HashSet<Integer>(); newFacts.addAll(oldFacts); ... // facts are updated \nin some way cfgnode2facts.put(cfgnodeID, newFacts); if ( ! oldFacts.equals(newFacts) ) { // update \nthe queue based on CFG int[] succ = cfg.get(cfgnodeID); for (i = 0; i < succ.length; i++) queue.add(succ[i]); \n}} Figure 5. Example: a simple data .ow analysis k precedes l in the iteration order. The operation .ndKey \nreturns a key for the given value. Views over maps are also supported. The operation keysView returns \na set of keys that is associated with the map and the operation valuesView re\u00adturns a list of values. \nIterators are modeled using the iteration order over map keys. The current position of a newly created \niterator is at the beginning of the iteration order (ahead of the .rst key). The following operations \non abstract iterators are sup\u00adported: hasMore, getCurrent, and moveNext. The opera\u00adtion getCurrent returns \na key such that the current iterator s position is behind the key. In the rest of this section, we describe \nhow Java collec\u00adtions are implemented using the abstract maps. Maps. Map classes and interfaces provided \nby the Java col\u00adlection API directly correspond to the abstract map. Methods de.ned by the interface \njava.util.Map are translated to opera\u00adtions supported by the abstract map in a natural way. Iterators. \nThe methods of the interface java.util.Iterator are translated into sequences of operations upon abstract \niter\u00adators and maps. For example, the method remove, which deletes the key-value pair at the current \nposition, is imple\u00admented via the operation getCurrent on the iterator and sub\u00adsequent remove on the \nassociated map. Sets. We model a set of elements of type T as an abstract map with keys of type T and \nboolean values, where the boolean value for a speci.c key indicates the presence of the corresponding \nelement in the set. The methods de.ned by the interface java.util.Set directly correspond to operations \nsupported by the abstract map. Sorted associative collections. In the case of Java classes that provide \nthe functionality of sorted maps and sets (e.g., TreeMap and TreeSet), all methods except addition of \nnew elements are translated directly into operations on the ab\u00adstract maps. The addition of a key-value \npair (k, v) into a map is modeled by a sequence of operations that consists of two parts. The .rst step \nis to .nd the key l that would be the immediate successor of k in the iteration order, and the second \nstep is to insert the new key-value pair using the putAhead operation. Lists. An ordered list of elements \nof type T is modeled by an abstract map where the keys are positive integers and the values have the \ntype T . The keys do not represent the positions of stored elements. Instead, the actual position (index) \nof any element can be deduced from the iteration order over keys. This approach eliminates the need to \nshift many keys in the abstract map upon any modi.cation of the list it is only necessary to update \nthe set of key-value pairs stored in the map and make a local change to the iteration order. The methods \nde.ned by the interface java.util.List are translated into sequences of operations over the abstract \nmap. For methods that take an index argument (e.g., get(i)), the sequence of operations has two parts \n the purpose of the .rst part is to .nd a key whose position is equal to the value of the index argument, \nand the second part implements the actual task using the operations supported by the abstract map. For \naddition methods, the sequence also contains oper\u00adations whose purpose is to .nd the smallest unused \nkey that could be associated with the new element. Internal tempo\u00adrary variables are used in the translation \n(e.g., to store the key corresponding to a given index). Other position-based collections, such as a \nqueue or a stack, are special cases of an ordered list, so they can be modeled using an abstract map \nin the same way.  4.3 Client Programs We de.ne our modeling approach formally on programs with the grammar \nin Figure 6. A program consists of one or more classes, where each class has zero or more .elds and methods. \nThe programs can use abstract maps and iter\u00adators, integer and boolean variables, objects, .eld accesses, \nand arrays. The grammar distinguishes between variables,  v . Variables f . FieldNames m . MethodNames \nProgram ::= Class+ Class ::= T {Field * Method * } Field ::= Tf Method ::= Tm(v, . . . , v){ MethodBody \n} MethodBody ::= Stmt * e . Expr ::= ic | true | false | null | v | e.f | e[e] | unop e | e binop e Stmt \n::= v := e | v := new C | e.f := e | v := new T[] | e[e] := e | assert e | Stmt ; Stmt | v := e.m(e, \n. . . , e) | while e do Stmt | if e then Stmt else Stmt | v := new map | v := e.createIterator() | MapOper \n| IterOper MapOper ::= v := e.get(e) | v := e.findKey(e) | v := e.size() | e.put(e, e) | e.putAhead(e, \ne, e) | e.remove(e) | e.clear() | v := e.containsKey(e) | v := e.containsValue(e) | v := e.keysView() \n| v := e.valuesView() IterOper ::= v := e.hasMore() | v := e.getCurrent() | e.moveNext() Figure 6. Grammar \nof a client program class names (types), .eld names, method names, and expres\u00adsions. The symbol ic represents \nan integer constant. Objects can have .elds of all supported types. Expressions of any supported type \ncan be used as keys and values in maps. In particular, nested collections are supported because a map \ncan be used as a key or value in another map. The grammar requires that the result of each method call \nbe saved into a variable. It does not allow using method calls on maps and iterators directly in composite \nexpressions such as if (m.contains(k)) x = 5 or x = m.get(k) + 5. An example of a valid code fragment \nis b = m.contains(k); if (b) x = 5.  4.4 Predicate Language Information about the program state, including \nthe observ\u00adable state of maps and iterators, is expressed by formulas in .rst-order logic with the theory \nof linear arithmetic and the array theory. The formulas are built from atomic predicates over program \nvariables. The domain of formulas is the set of integer numbers. All other data types are translated \ninto inte\u00adgers. References are modeled using integer values that rep\u00adresent memory addresses. Equality \nbetween reference vari\u00adables models aliasing. We introduce several function symbols and predicate symbols \nfor modeling the observable state of maps mget, mupdate, msize, mresize, morder, mkeys, and mvalues. \nAll of these symbols are aliases for the functions select and store de.ned by the array theory. The purpose \nof the aliases is to explicitly indicate which aspect of the state of a map is captured with the given \npredicate. We use special arrays with the names map, msz, mit, mks, and mvs. The function symbol mget \nis used to denote the presence of a speci.c key-value pair in a given map. The expression mget(map, m, \nk) returns the value associated with the key k in the map m. The expression mupdate(map, m, k, v) re\u00adturns \na new array that is equal to map except that the key k is now associated with the value v in the map \nm. For example, the truth value of the predicate mget(map, m, 1) = 5 says whether the map m contains \nthe key-value pair (1, 5). We use predicates of the form mget(map, m, k)= . with the special symbol . \nto express the fact that the map m contains no value for the key k. Arbitrary nesting of function symbols \nmget and mupdate is possible. The following axiom holds for the symbols: mget(mupdate(map, m, k, v), \nm, k)= v. The full content of some map (i.e., a set of the stored key\u00advalue pairs) can be expressed using \na conjunction of pred\u00adicates with the function mget. Information about a value stored in a nested map \ncan be expressed by a predicate of the form mget(map, mget(map,m1,k1),k2)= v. The function symbols msize \nand mresize are used to model the size of a map. The expression msize(msz,m) returns the current size \nof the map m. The expression mresize(msz, m, sz) returns a new array that is equal to msz except that \nthe element corresponding to the current size of the map m is set to sz . The following axiom holds for \nthe function symbols: msize(mresize(msz, m, sz),m)= sz. We use the predicate symbol morder to model the \niter\u00adation order. The expression morder(mit, m, k1,k2) returns true if the key k1 precedes the key k2 \nin the iteration or\u00adder for the map m. An iterator variable can be used as an argument for the symbol \nmorder to express the current po\u00adsition of a speci.c iterator. The truth value of the predicate morder(mit, \nm, it,k) says whether the iterator s current po\u00adsition is just ahead of the key k. Bounds are represented \nby the . symbol. For example, the value of the expression morder(map, m, ., 2) says whether the key 2 \nis the .rst element in the iteration order for m. The key k is the last element in the iteration order \nof the map m if the predicate morder(mit, m, k, .) holds. The full iteration order for a map can be expressed \nvia a conjunction of predicates with the symbol morder. The predicate symbols mkeys and mvalues are used \nto capture associations between maps and views. The expres\u00adsion mkeys(mks, m, ms) returns true if the \nmap ms repre\u00adsents a set view of all keys in the map m. The expression Table 1. Translation from symbols \nintroduced by our pred\u00adicate language to the array theory functions  Our predicate language Array theory \nmget(map, m, k) select(map, m, k) mupdate(map, m, k, v) store(map, m, k, v) msize(msz, m) select(msz, \nm) mresize(msz, m, sz) store(msz, m, sz) morder(mit, m, d1, d2) select(mit, m, d1, d2) mkeys(mks, m, \nms) select(mks, m, ms) mvalues(mvs, m, ml) select(mvs, m, ml) fread(f, o) select(f, o) fwrite(f, o, e) \nstore(f, o, e) aread(arr, a, i) select(arr, a, i) awrite(arr, a, i, e) store(arr, a, i, e) mvalues(mvs, \nm, ml) returns true if the map ml represents a list view of all values in the map m. The symbol . is \nmodeled by a logic constant of an integer type whose value is different from the values of all other \nexpressions that can appear in a given formula. We model objects, .elds, and arrays using the approach \ndescribed in [13], which is also based on the array theory. For each .eld name, there is a one-dimensional \narray in\u00addexed by objects that have the given .eld. The function ex\u00adpression fread(f, o) returns the \nvalue of the .eld f of the object o and the expression fwrite(f, o, e) encodes update of the .eld f in \no with the new value e. Array accesses are captured by the function symbols aread and awrite. The ex\u00adpression \naread(arr, a, i) returns the element of the array a with the index i. Nested arrays (with multiple dimensions) \nare also possible. The value null of a reference type is mod\u00adeled by a logic constant of an integer type \nwhose value is different from the values of all other expressions that can ap\u00adpear in a given formula \n in particular, it is different from the constant that represents .. The value of a .eld f of an object \nstored in the map m can be expressed by the predicate fread(f, mget(map, m, k)) = v. The symbol fread \ncan be also used as an argument for the function symbol mget. For example, the result of the code fragment \nthis.data.put(5,v) is captured by the predicate mget(map, fread(data, this), 5) = v. Table 1 summarizes \nthe mapping from the function sym\u00adbols introduced by our predicate language to the functions de.ned by \nthe array theory. Locality. We distinguish between predicates and formulas that (1) refer only to constants \nand static .elds, (2) refer also to object .elds, and (3) refer to all kinds of variables including method \nlocal variables. Each formula is associated with a certain scope the whole program, a speci.c class, \nor a speci.c method. Using different sets of predicates for different scopes is important especially \nin cases where local variables of the same name are used in two methods or two classes de.ne .elds with \nthe same name. For each predicate and formula that is associated with a speci.c method, we consider the \nactual scope inside the method body in which it is relevant. A special case are predicates over temporary \nvariables used in the translation from method calls on Java collections to operations on the abstract \nmaps and iterators. The scope of such a predicate is the particular method call. A very important feature \nof our predicate language is the support for preserving information about objects and their .elds between \nmethod calls. However, this requires usage of suitable predicates with respect to the scope of program \nvariables. Let p be a predicate that describes the content of a map pointed to by a speci.c variable \nm. If the variable m is de.ned as a .eld of some object and the information cap\u00adtured by p must be preserved \nbetween method calls (for the whole lifetime of m), then other expressions referenced by p must have \nat least the same scope as m. For example, con\u00adsider the predicates mget(map, fread(data, this), 2) = \n3 and mget(map, fread(data, this), id)=5, where id is a local variable of some method mth. The information \nex\u00adpressed by the .rst predicate is preserved for the whole life\u00adtime of the map pointed to by this.data. \nOn the other hand, the information captured by the second predicate will not be preserved after the exit \nfrom mth because of the local vari\u00adable id.  4.5 Modeling Statements by Weakest Preconditions The execution \nof any statement, including operations on abstract maps and iterators, may change the truth values of \nsome predicates that cover relevant aspects of the program state. We distinguish two categories of supported \noperations on maps and iterators associated with the maps: (1) updating operations that change the observable \nstate of the target map m and possibly some other maps, and (2) query operations that change the current \nvalue of a program variable that is used to store the result of the operation. Maps other than m can \nbe changed by an updating operation because of propagation between views and the underlying map if the \noperation changes the state of the map m, then it also changes the state of maps that represent views \nover m and maps over which m is a view. We specify changes of the truth values of predicates using weakest \npreconditions. They re.ect the following: the semantics of the Java language, including assign\u00adments \nto local variables, .eld accesses, and object con\u00adstruction;  the behavior of the Java collection API \nmethods that is described in the textual documentation;  aliasing between reference variables, including \nmap vari\u00adables, and aliasing between map elements.   Statement s Predicate p W P (s, p) r = m.get(k) \nr = e .qm : qm = m . e = mget(map, qm, k) mget(map, m ' , k ' ) = v ' mget(mupdate(map, m, k, v), m ' \n, k ' ) = v ' m.put(k,v) msize(msz, m ' ) relop u ite( (m = m ' . mget(map, m ' , k) = .) . m = m ' , \nmsize(mresize(msz, m, msize(msz, m) + 1), m ' ) relop u, msize(msz, m ' ) relop u ) it.moveNext() morder(mit, \nm ' , it, .) .qk : (morder(mit, m ' , it, qk) . morder(mit, m ' , qk, .)) Table 2. Weakest preconditions: \nselected examples As an illustration, Table 2 shows the weakest precondi\u00adtions for selected combinations \nof the statements of the lan\u00adguage from Figure 6 and predicates about map content. The symbols qk and \nqm denote logic variables. The construct ite(a, b, c) is de.ned as ite(a, b, c) = (a . b) . (\u00aca . c). \nThe logic variable qm is used in the weakest precondition for the statement r = m.get(k) and the predicate \nr = e to capture aliasing between maps. In the case of the statement m.put(k,v), the weakest preconditions \ncapture aliasing im\u00ad ' plicitly based on whether the symbols m and m have equal values and point to the \nsame element of the underlying array (map or msz). The complete de.nition of the weakest preconditions \nfor all statements and predicates is in Appendix A. 5. Construction of Abstract Programs An abstract \nprogram is constructed from the following in\u00adput: the original Java program, a set PI of predicates over \nprogram variables, and a set of properties. We assume that one set of predicates is de.ned for the whole \ninput program, and this set applies to every state\u00adment. The properties are de.ned as logic formulas \nbuilt from atomic predicates de.ned in our language. Each property is associated with speci.c code locations \nin the input program. For example, there can be a property o = null in front of a .eld access on a speci.c \nobject variable o. Abstract programs are Java programs in which the only primitive data type is boolean. \nThe programs use methods provided by the Java Path.nder API most notably the method getBoolean of the \nVerify class, which returns the non-deterministic boolean value unknown, and the call Ver\u00adify.assertTrue(false) \nthat represents a violated assertion. The process of abstraction preserves all classes de.ned in the \noriginal program (i.e., custom non-library data types). An abstracted method is generated for each method \nin the original program. We adapt existing techniques for the construction of ab\u00adstract programs [2, \n3] that were introduced for the C lan\u00adguage. We summarize the basic approach .rst and then dis\u00adcuss modi.cations \nand aspects speci.c to our approach. Basic approach. Each predicate p in the set PI is repre\u00adsented with \na boolean variable (an object .eld or a method local variable) in the abstract program, which encodes \nthe truth value of p. The control .ow structures in the original Java program are preserved in the abstract \nprogram. Sup\u00adport for exceptions is very limited throwing an exception is modeled as an unconditional \nerror (assert false). Assign\u00adment statements and method calls on collection objects are replaced with \ntheir abstraction in the way described below. Using the terminology of [3], the abstraction algorithm \nthat we use is based on computing the abstract post opera\u00adtor for every statement in every method of \nthe input program. Each statement s in the original program is processed separately. First, a set Ps \n. PI of predicates about the program state whose truth values may be changed due to the execution of \ns is identi.ed. For each predicate p . Ps, the set Ps,p . PI of predicates that may determine the new \ntruth value of p is also identi.ed. The sets Ps and Ps,p are identi.ed based on the semantics of s. For \nexample, when processing the statement x := e, it is necessary to update all predicates over the variable \nx (and possible aliases of x) based on the predicates over the expression e. We present the algorithm \nfor selecting relevant predicates in Section 5.1. The abstraction of the statement s contains code that \nupdates boolean variables that represent predicates in Ps. It has the form of a sequence of if-else statements, \nwhere one such statement is generated for each predicate p . Ps. The if-else statement for p represents \na truth table over the set Ps,p. It contains branches that correspond to cubes over Ps,p. A speci.c cube \nover Ps,p is the set .(Ps,p) that for each pi . Ps,p contains either pi or \u00acpi. Every branch contains \nan assignment statement that sets a new value of the boolean variable bp that represents p. The new value \nof the variable bp (i.e., the new truth value of p) in a particular branch of the if-else statement is \ncomputed based on the weakest precondition WP(s, p) and the cube .(Ps,p) in the way described in Section \n3. One call of the decision procedure (an SMT solver) is made for every cube over Ps,p that must be considered. \nWe de\u00adscribe in Section 5.1 which cubes may be safely pruned. The input for a call of the decision procedure \nis the formula u .(Ps,p).Faux . WP(s, p), where the symbol Faux rep\u00adresents auxiliary formulas (see below). \nFor each property, the code if (!b) Verify.assertTrue(false) is generated at the corresponding location \nin the abstract program, where b is a boolean variable that contains the truth value of the property \nformula. It is derived from the values of the boolean variables that represent atomic predicates in the \nproperty formula.  Auxiliary formulas. We use auxiliary formulas to express general properties and semantics \nof the Java language, in\u00adcluding its type system and heap model, and the semantics of abstract maps. \nThey capture properties and semantics that are not speci.c to any statement s or predicate p, and be\u00adcause \nof that they are not a part of the weakest preconditions. We de.ne auxiliary formulas to capture the \nfollowing semantic constraints: program variables of different types cannot be equal this applies especially \nto pairs of integer variables and map variables, which can both appear as map values (as v in the predicate \nmget(map, m, k)= v), and to pairs of integer variables and iterator variables, which can be used as the \nlast two arguments in morder(mit, m, d1,d2);  the symbols . and null cannot be equal to any program \nvariable or any integer constant explicitly used in the program, and they must differ from each other; \n the predicate mget(map, m, k)= . is true if no predi\u00adcate specifying a value for the key k in the map \nm is true in the current program state;  if some predicate that speci.es a value for the key k in the \nmap m is true in the current program state, then the predicate mget(map, m, k)= . cannot be true;  the \niteration order over a map is an anti-symmetric rela\u00adtion, i.e., if the predicate morder(mit, m, k1,k2) \nis true then morder(mit, m, k2,k1) cannot be true.  The constraints enforce a semantically correct heap \nmodel, where distinct objects have different heap addresses. In addition, we use auxiliary formulas to \nrestrict the val\u00adues of logic variables used in the weakest preconditions. For each logic variable q \nin WP(s, p) and a speci.c cube .(Ps,p), expressions that can instantiate q are identi.ed by syntactic \nmatching between predicates in the cube and pred\u00adicates in WP(s, p). The formulas permit q to get the \nvalue e only if q and e have matching positions in some predicates and the relevant elements of the cube \nevaluate to true. Aliasing. For every statement upon a target variable v of a reference type in the input \nprogram (e.g., a .eld access or a method call), the abstract program contains the code that updates the \ntruth values of relevant predicates over v and predicates over other variables that may be aliased with \nv. The variables possibly aliased with v are taken from equality predicates of the structure v = w, where \nthe symbol w represents some other program variable of a reference type. Our weakest preconditions guarantee \nthat aliasing between variables is re.ected correctly. Views over maps. The abstract program must also \ncorrectly re.ect updates of views for any given map m. Each update of the map m must be propagated to \nall views over m, and each update of some view over the map m must be propagated to m and all other views. \nWe implemented the propagation of changes between views and the underlying map by generating code that \nis driven by truth values of predicates with the symbols mkeys and mvalues. The following code is generated \nfor the op\u00aderation m.put(k,v), where ms1,..., msN and ml1,..., mlN are possible views over m such that \nthe corresponding predi\u00adcates mkeys(mks, m, ms) and mvalues(mvs, m, ml) exist: m.put(k,v) if (mkeys(mks,m,ms1)) \nms1.add(k) ... if (mkeys(mks,m,msN)) msN.add(k) if (mvalues(mvs,m,ml1)) ml1.add(v) ... if (mvalues(mvs,m,mlN)) \nmlN.add(v). Boolean variables representing the predicates over mkeys and mvalues are used in the actual \ncode. The statements m.remove(k) and m.clear() are abstracted in a similar way. Method calls. The process \nof abstraction preserves calls of methods de.ned in the program (i.e., non-library methods). Every abstracted \nmethod has boolean parameters that corre\u00adspond to predicates over parameters of the original method, \nand it may return multiple boolean values that correspond to predicates over the expression returned \nfrom the original method. Abstractions for method calls and returns are gen\u00aderated using a similar approach \nto the one described in [2]. For each method call in the abstract program, the actual parameter values \nin the abstracted caller are derived from the truth values of predicates over the actual parameters in \nthe original caller. The returned values correspond to the truth values of the predicates over the variable \nused to store the result of the method call (result variable) in the original caller, and they are derived \nfrom the predicates over the returned expression in the original callee. Multiple truth values are returned \nin a bit vector that is implemented using a single integer. Output parameters (collections and reference \nvariables that may be updated in the callee) are handled in the same way as returned expressions and \nresult variables. We consider inheritance, method overriding, and inter\u00adfaces with their implementing \nclasses. For every call site, the abstract program contains a non-deterministic choice be\u00adtween all methods \nthat can be invoked. Library methods are conservatively approximated in such a way that all boolean variables \nrepresenting predicates over .elds and the result variable are set to the value unknown. Predicate locality. \nFor every statement s in the method m in the original program, only those predicates over local vari\u00adables \nof m whose scope includes the statement s (i.e., pred\u00adicates live at s) are considered by the abstraction \nalgorithm. The predicate p is live at s only if all local variables referred to by p are live at s. If \nthe variable v is live at s, then every program variable that may be aliased with v is also live at s. \n The scope for every predicate in the set PI is determined using static analysis of the original program \ncode. A few restrictions apply to predicates over collections. A predicate over an iterator variable \nit and a map variable m is live only if the iterator it is associated with m at the given code location. \nThe scope of a map variable (collection) must enclose the scope of iterator variables related to the \nmap. A local variable v used as an argument for the operations put and putAhead on a local map variable \nm is live between the point of the .rst usage of v and the end of m s lifetime. Precision. The generated \nabstract program is an over\u00adapproximation of the original Java program (in general). It captures all \nexecution paths of the original Java program (in particular all errors), and possibly some additional \nexecu\u00adtion paths that are not feasible for the original program. The number of additional infeasible \nexecution paths depends on the input predicates. 5.1 Optimizations The overall performance of the construction \nof an abstract program depends on the number of calls to the decision pro\u00adcedure, which are expensive. \nIn this section, we describe op\u00adtimizations that exploit (i) the structure and semantics of for\u00admulas \nthat capture program state using the predicates de.ned in our language, and (ii) the semantics of operations \nupon ab\u00adstract maps and iterators. The main goal of these optimiza\u00adtions is to reduce the number of calls \nto the decision proce\u00addure by (1) creating small sets Ps and Ps,p, and (2) pruning some cubes over Ps,p. \nA secondary goal, but also important, is the reduced complexity of the generated abstract program and \nthe elimination of some spurious execution paths (that are not feasible in the original program). We \nalso adapt the optimizations proposed in [2] to our predicate language. Selecting relevant predicates. \nFor every operation oper on an abstract map or an abstract iterator, there is a set Poper of predicates \nwhose truth value must be updated to simulate the effects of oper s execution. If the operation oper \nhas a return value, the set Poper contains predicates over the variable r used to store the return value \nand all variables that may be aliased with r. This applies, for example, to the operation v = m.get(k). \nIf the operation oper updates the map content or iterator position, then the set Poper contains predicates \nover the target variable (a method call receiver) and all other variables aliased with it. For the particular \noperation oper and each predicate p . Poper , the set Poper,p of predicates that determine the new truth \nvalue of p is a subset of PI that depends on the weak\u00adest precondition WP(oper,p). More speci.cally, \nthe set Poper,p contains the following predicates: every predicate in PI that matches some atomic predicate \nin the weakest precondition, every predicate in PI that has a common operand with some predicate in \nthe weakest precondition, and  every equality predicate in PI that refers to a variable used as an argument \nfor the function symbol mget or for the predicate morder in the weakest precondition.  We use simple \nsyntactic matching (uni.cation) between predicates. The matching procedure considers also aliasing between \nvariables. A logic variable in the weakest precondi\u00adtion can match any program variable or a constant \nvalue. A program variable can match any constant of the same type. Temporary variables used in the translation \nfrom Java col\u00adlections to abstract maps match integer expressions. Con.icting literals. The .rst optimization \nis to prune cubes over Ps,p that include con.icting literals. It was inspired by the enforce construct \ndescribed in [2]. Two or more literals in the given cube .(Ps,p) are con\u00ad.icting if they cannot be simultaneously \ntrue. For example, the predicates v =3 and v =5 are con.icting because the variable v cannot be equal \nto two different constants at the same time. Similarly, the predicates morder(mit, m, 2, .) and morder(mit, \nm, 3, .) are con.icting because only one key stored in the map m can be at the end of the iteration order \nfor m. We de.ne tuples of con.icting literals that express the following inherent semantic properties \nof abstract maps and iterators: (i) only a single value or . can be associated with a given key k, (ii) \nthere exist unique .rst and last elements in the iteration order, (iii) each element must have a unique \npredecessor and successor in the iteration order, (iv) and only keys stored in the map can appear in \nthe iteration order. In addition, we de.ne a tuple of literals as con.icting when one element of the \ntuple is true only for an empty map and some other element is true only for a non-empty map. This applies, \nfor example, to the literals mget(map, m, k)= . and morder(mit, m, ., .). Con.icting literals are re.ected \nas follows in the abstract program. When generating the abstraction for the operation oper and the updated \npredicate p, cubes over the set Poper,p that contain any con.icting literals are pruned. Code that forces \nJPF to backtrack is generated for the pruned cubes. We eliminate spurious execution paths (and errors) \nin this way too, because it cannot happen during the execution of the original program that two con.icting \nliterals are simulta\u00adneously true in any state of the program. This optimization signi.cantly reduces \nthe number of calls to the decision procedure and the size of the abstract program, because typically \nmany cubes over Ps,p contain pairs of con.icting literals. Irrelevant cubes with respect to aliasing \nrelationship. We exploit aliasing between map variables to prune additional cubes. Suppose that a statement \ns affects a map variable m that may be aliased with another map variable m2, and pi is some predicate \nover m2 in Ps,p. We prune every cube over Ps,p that contains both of the literals \u00ac(m = m2) and pi. It \nis sound to prune such a cube because the predicate pi over m2 is not relevant when m and m2 are not \naliased.  Ambiguous information. We also prune cubes that give ambiguous information about the values \nof the temporary variables used in the translation from Java collections to abstract maps. A cube over \nthe set Ps,p gives ambiguous information about the value of a temporary variable tv if for every predicate \ntv = c in Ps,p, where c is an integer constant, the cube contains the literal \u00ac(tv = c). For example, \nif the cube contains only the literals \u00ac(tv = 1) and \u00ac(tv = 2) for tv, then it does not specify a precise \nvalue for tv. This optimization is sound because temporary variables must have a precise value in any \nreachable state of the abstract program due to the way we designed the translation from Java collections \nto abstract maps. Code that forces JPF to backtrack is generated for every ambiguous cube. 6. Evaluation \nIn this section, we describe the prototype implementation of our approach and present results of experiments \nwith several benchmark programs. 6.1 Implementation We implemented the predicate language and the algorithm \nfor the construction of abstract programs, including all of the optimizations, in our J2BP tool [43]. \nThe tool generates an abstract program in Java for an input client program, a set of properties de.ned \nas logic formulas, and a set of predicates. It uses the WALA library [46] to analyze the input Java program, \nthe ASM library [42] for bytecode generation, and the Yices SMT solver [47] for checking satis.ability \nof logic formulas. Java Path.nder (JPF) [44] is used for veri.cation of the generated abstract programs. \nFormulas representing input properties can include quan\u00adti.ers over logic variables. Our tool eliminates \nquanti.ers in property formulas based on the possible values of the logic variables that are identi.ed \nby syntactic matching over the set of input predicates. Each sub-formula with an existen\u00adtial quanti.er \nover the logic variable q at the root level is replaced with a disjunction where each clause is an instanti\u00adation \nof the original sub-formula with a particular value of q. A conjunction of such clauses is used as a \nreplacement for a universal quanti.er. Our implementation supports classes from the Java col\u00adlection \nlibrary and their methods that can be modeled using abstract maps and operations upon them as described \nin Sec\u00adtion 4.2. The calls of methods like List.containsAll, which are not supported yet, must be replaced \nwith loops that imple\u00adment them before running J2BP. Arti.cial temporary return variables are used for \nprocess\u00ading composite expressions that involve method calls in cases where the result of a method call \nis not stored in an explicitly de.ned variable. This applies, for example, to expressions such as m.values().iterator() \nand m.get(k) + 2. The names of these arti.cial return variables start with the pre.x tmpr and they can \nbe referenced from the predicates. 6.2 Benchmarks We evaluated our approach on two groups of Java programs \nthat use collections in advanced ways: (1) small programs created by Dillig et al. [17] as a testbed \nfor veri.cation tools, and (2) the example programs from Section 4.1. The programs created by Dillig \net al. contain various assertions that concern values stored in the collections. We translated the programs \nfrom C++ into Java and replaced all variables and constants of the string type with integers. The properties \nfor our example programs are de.ned externally, i.e., not as assertions embedded in the source code, \nbut in separate .les. All benchmarks, including our translation of programs created by Dillig et al., \nare available at http: //plg.uwaterloo.ca/ pparizek/oopsla12. Table 3 provides a short description of \nthe properties that we tried to verify for each benchmark program and the size of the programs in terms \nof Java code lines. As an example, Figure 7 shows the code of the program named Relationship between \nkeys and values in the table. The program adds several key-value pairs into the map m three mappings \nwith .xed keys (1-3) and one mapping with the key equal to the parameter s. Assertions check whether \nthe map m contains the right key-value pairs depending on the value of the parameter s. If the value \nof s is 1, then the map should contain the key-value pair (1,56), and otherwise it should contain the \nkey-value pair (1,3).  6.3 Experiments and Results The goal of our experiments was to .nd out (1) whether \nour predicate language has suf.cient expressive power to allow the veri.cation of the properties de.ned \nfor the benchmark programs, and (2) how many predicates are needed to cap\u00adture all of the necessary information \nabout the state of col\u00adlections and other program variables. For the purpose of the experiments, we de.ned \nall of the predicates by hand. We are currently working on an automated procedure for the inference of \npredicates about collections. We bounded the maximal size of collections that is con\u00adsidered by the veri.cation \nprocedure, and de.ned predicates that re.ect this bound. Restricting the size of data structures is a \ncommon approach used by many testing and veri.cation techniques [11, 26, 39]. Note, however, that our \napproach is general and can be used to model collections of any .nite size (provided that the corresponding \npredicates are avail\u00adable). For the purpose of our experiments, we set the bound such that all execution \npaths of the benchmark programs are veri.ed. All of the properties de.ned for the benchmark programs \nwere successfully veri.ed using predicates de.ned in our language. Quantitative results of the experiments \nare shown  Program Property Java LOC Dillig et al. List copy equality between lists 35 Map copy equality \nbetween maps 39 Reverse map correctly reversed input map 40 Set of map keys a set contains exactly all \nmap keys 29 Map of lists correct size and content of nested lists 36 List of sets valid content of nested \nsets after updates 35 Multimap correct size and content of nested sets 29 Map values map contains only \nnon-null values 40 List elements elements are not aliased 43 List of key-value pairs equality between \na list and a map 54 Relationship between keys and values valid content of a map after updates 31 Examples \nfrom Section 4.1 Thread scheduling object variables are not null 54 Rendering image consistency between \na list and an array 61 Processing results of a cycling race correctly sorted map 57 Simple data-.ow analysis \nset of facts exists for every CFG node 63 Table 3. Benchmark programs and veri.ed properties Program \nPredicates J2BP time SMT calls Bytecode JPF time States Dillig et al. List copy 43 146 s 2086 5862 1 \ns 91 Map copy 35 79 s 1114 2721 1 s 315 Reverse map 54 332 s 3854 8239 1 s 595 Set of map keys 33 21 \ns 312 1516 1 s 63 Map of lists 77 14769 s 111331 88414 2 s 283 List of sets 54 958 s 10836 27347 1 s \n25 Multimap 26 180 s 2566 4606 1 s 175 Map values 54 477 s 6224 18955 1 s 9 List elements 52 643 s 8456 \n12488 1 s 29 List of key-value pairs 78 302 s 3324 6328 1 s 945 Relationship between keys and values \n6 9 s 198 695 1 s 29 Examples from Section 4.1 Thread scheduling 30 52 s 782 2844 1 s 67 Rendering image \n65 2612 s 20272 16827 17 s 120871 Processing results of a cycling race 104 6654 s 67390 85178 9 s 51739 \nSimple data-.ow analysis 74 978 s 11344 11761 1 s 177 Table 4. Experimental results in Table 4. For \neach benchmark program, we provide the number of predicates that were used, the running time of the J2BP \ntool (construction of the abstract program), the number of calls to the SMT solver during construction \nof the abstract program, size of the generated abstract program in terms of the number of bytecode instructions, \nthe running time of JPF (exhaustive veri.cation of the abstract program), and the number of states explored \nby JPF. The number of predicates is equal to the number of boolean variables in the generated abstract \nprogram. The number of states explored by JPF in\u00addicates the number of non-deterministic choices in the \nab\u00adstract program. The actual predicates and property formulas used for each benchmark program are available \nat http: //plg.uwaterloo.ca/ pparizek/oopsla12. Returning to the program in Figure 7, the assertions \nin the program code were expressed by the formulas i =3 and i = 56, and the following six predicates \nwere necessary to verify them: s =1, mget(map, m, 1) = 3, mget(map, m, 1) = 56, mget(map, m, 1) = ., \ni =3, and i = 56.  public static void bar(int s) {Map<Integer,Integer> m= new HashMap(); m.put(1,3); \nm.put(2,9); m.put(3,34); m.put(s,56); m.remove(3); int i = m.get(1); if (s != 1) { assert (i == 3) : \nm.get(1) != 3 ; } else { assert (i == 56) : m.get(1) != 56 ; }} public static void main(String[] args) \n{bar(8); bar(2); } Figure 7. Benchmark program: relationship between keys and values The measured running \ntimes indicate that more work re\u00admains to be done to improve the performance and scalability of the construction \nof abstract programs. This is one of our goals for future work. 7. Related Work We describe selected \nexisting approaches to modeling pro\u00adgram behavior and reasoning about it that explicitly consider data \nstructures and collections in some way. For each ap\u00adproach, we discuss the main differences from our \nwork. 7.1 Contract Speci.cation Languages There exist speci.cation and modeling languages for object\u00adoriented \nprograms that allow to de.ne valid functional be\u00adhavior in terms of contracts for individual methods \nand ob\u00adject invariants. We collectively call them contract speci.ca\u00adtion languages. Popular examples \nare JML [30], Spec# [5], and Dafny [31]. A contract for a method consists of a precondition and a postcondition. \nEach class can be equipped with an invariant that must hold for every object of the class before and \nafter the call of any method on the object. Contracts are de.ned as logic formulas that refer to program \nvariables, model vari\u00adables and functions, and abstract data types (e.g., sets and sequences). Method \npostconditions can also involve special constructs for accessing (i) values that were current at the \ntime of a method call and (ii) the return value. The contract languages support basic set operations \non the respective data types, accessing sequence elements by their index, and get\u00adting the current size \nof a given collection. The motivation behind contract speci.cation languages such as JML and Spec# is \nto permit modular veri.cation (i.e., one method at a time). Let the method m1 be equipped with a contract \nand the method m2 be the caller of m1. The implementation of m1 must .rst be veri.ed against its contract. \nLater, in the veri.cation of m2, the contract for m1 can be used as an abstraction of its behavior. Veri.cation \ntools for the contract speci.cation languages have been developed for example, ESC/Java for JML [15, \n19], Boogie for Spec# [4], and the veri.er for Dafny [31]. We focus on the ESC/Java tool as it targets \nJava programs. It detects simple errors like null dereferences and array index bound violations, and \nit also checks whether methods satisfy their contracts de.ned by the user and whether they preserve all \ninvariants. The veri.cation algorithm consists of two big steps: a veri.cation condition is generated \nfrom the method s code, and then an automatic theorem prover is used to check the veri.cation condition. \nModular veri.cation of contracts is very scalable but it reports false errors. The result depends very \nmuch on the precision and the completeness of the user-de.ned contracts (annotations) the user must \nwrite many annotations to capture the necessary information and eliminate spurious warnings. Comparison. \nThe main limitations of method contracts are that they can be associated only with method boundaries, \nand that they cannot refer to local variables. It is not possible to use contracts for expressing the \nvalue of a speci.c variable at an arbitrary program location. Moreover, an invariant de\u00ad.ned for a class \nC can describe the valid states of a single object o of the class and the objects pointed to by the .elds \nof o (i.e., objects owned by o), but it cannot specify the re\u00adlation between the .elds of o and the values \nof completely unrelated variables (e.g., .elds of a different object). In our approach, predicates and \nproperties can capture in\u00adformation about the values of local variables, and they can express the current \nvalue of any variable at any program code location. Properties built using our predicate language can \nspecify a relation between collections from different ob\u00adjects this is an important prerequisite for \nexpressing con\u00adsistency properties between multiple collections. For exam\u00adple, our approach allows de.ning \na consistency property be\u00adtween a collection local to some method m of an object o and a collection pointed \nto by some .eld of o, which should hold at a particular location in m. Regarding veri.cation, our approach \nis not modular un\u00adlike the algorithm used by ESC/Java. We aim at path\u00adsensitive inter-procedural analysis \nof the whole program.  7.2 Logics for Data Structures There exist many logic-based approaches to modeling \ndata structures and collections. Sets and maps (hash tables) are typically modeled using the array theory \n[12]. However, our approach to modeling maps differs from the encoding of hash tables described in [12, \nSection 7.3] in the following aspects: (1) we do not support set operations over keys, (2) we support \npredicates over map size and iteration order, and  (3) we support views of stored keys and values. Some \nap\u00adproaches also support lists and other data structures. For ex\u00adample, the theorem prover Z3 [36] supports \nlists and trees de.ned recursively in a way that resembles modeling col\u00adlections at the representation \nlevel. A .rst-order theory of sequences based on concatenation was proposed in [20]. It supports lists \nde.ned in the recursive style. A decidable ver\u00adsion of this theory does not support indexed access to \nele\u00adments and therefore does not allow updating of individual elements, but it supports membership queries \nand various properties over the whole sequences (e.g., sortedness and partitioning). Kroening et al. \n[45] propose theories for reasoning about .nite sets, maps, and lists in the context of the SMT-Lib stan\u00addard \n[38]. Their work has similar goals to our approach, i.e. modeling externally observable state of various \ncollections. However, we focus on designing a predicate language suit\u00adable for program veri.cation, while \nthe authors of [45] pro\u00adpose general theories. The main difference between their ap\u00adproach and ours is \nthat we use the array theory instead of de.ning new custom theories, and therefore logic formulas built \nusing our predicate language can be checked with ex\u00adisting SMT solvers that support the array theory. \nRegarding speci.c features, the approach of Kroening et al. supports basic set operations like union \nand intersection, but it has no support for iterators. It allows de.ning sets and lists by enumeration \nof elements, but that can be simulated via con\u00adjunctions of atomic predicates in our approach. Powerful \nlogics and complex theories for representing data structures and checking properties about them were \nre\u00adcently proposed [27, 33]. The STRAND logic [33] allows reasoning about heap data structures and the \nvalues stored in them. However, such complex logics are not needed for (1) modeling collections at the \ninterface level and (2) veri.ca\u00adtion of programs that use collections against the properties that we \nare interested in.  7.3 Program Veri.cation In this section, we describe program veri.cation techniques \nthat model collections at the interface level in some way, and techniques that could be used for this \npurpose. Blanc et al. [8] proposed a technique for checking whether a C++ program uses STL containers \ncorrectly with respect to preconditions and postconditions of individual methods. Their approach focuses \non position-based containers and it\u00aderators. It does not support maps, sets, and nested containers. Kapur \net al. [24] proposed a method for verifying pro\u00adgrams that use data structures through interface functions \nassuming a correct implementation of these data structures. The method is based on abstraction re.nement \n(CEGAR), and it uses interpolants with symbolic execution to .nd new predicates. It has the same goals \nas our overall approach, but in [24], the authors focused on computing interpolants for the various theories \nrather than on faithful modeling of col\u00adlection state and behavior. Library methods are abstracted with \nformulas that express transition relations they spec\u00adify, for example, how the return value of a method \ndepends on the parameter values. Strong updates are possible through functions that return a modi.ed \ndata structure, but the ab\u00adstraction does not make it possible to capture side effects. To capture the \nbehavior of Java collections precisely, it is nec\u00adessary to model side effects such as increasing the \ncollection size upon addition of a new element. An optimization of symbolic execution that models col\u00adlections \nat the interface level was proposed in [26]. The nec\u00adessary information about the collection state is \ncaptured in terms of sets of actual elements and the operation contains. It supports only maps and sets, \nand not ordered lists. The static technique proposed by Dillig et al. [17] com\u00adputes information about \nthe possible content of collections during a program run at the level of individual elements, and uses \nthis information for checking memory safety of C++ programs. It uses a uni.ed abstract model of position-based \ncontainers and associative containers. It supports iterators and nested collections. The content of a \nparticular collection can be expressed by a graph, where nodes represent collec\u00adtions (heap structures) \nor atomic values and edges represent the containment relation. Constraints on indexes that are at\u00adtached \nto edges indicate possible associations between keys (indexes) and values for each possible (tracked) \nvalue the constraints de.ne positions at which it may be stored. The main limitations of this technique \ncompared to our approach are the following: (1) each analysis fact can give informa\u00adtion only about the \ncontent of a particular collection and all collections nested in it, and (2) it cannot maintain precise \ninformation about collection size. In our approach, a single formula that uses predicates de.ned in our \nlanguage can de\u00adscribe the content of multiple separate collections (that are not in the nesting relation). \nProgram veri.cation techniques and tools that model col\u00adlections at the representation level were also \npublished. For example, the Jahob veri.cation system proposed by Zee et al. [40, 41] analyzes the whole \nJava program at the pointer\u00adlevel with the goal of proving correctness of individual meth\u00adods with respect \nto some speci.cation of their functional be\u00adhavior. It supports a very powerful language for specifying \nproperties and integrates various reasoning tools (automated SMT solvers and interactive theorem provers). \nThe veri.ca\u00adtion procedure of Jahob is modular such that preconditions and postconditions of already \nchecked methods are used to verify their callers. It involves automated generation of veri\u00ad.cation conditions \n(proof targets), but users may be required to provide hints.  Other techniques aim at verifying programs \nthat manip\u00adulate linked lists and dynamically allocated memory. They model lists at the pointer level \nand impose some restrictions on the programs that they can verify. For example, the ap\u00adproach proposed \nin [9] works only for programs that do not access data stored in the lists at all or that only compare \ndata in some nodes (for sorting purposes). Lahiri and Qadeer pro\u00adposed a logic for specifying properties \nover linked lists and a decision procedure for checking programs in a subset of C against such speci.cations \n[29]. This approach supports only loop-free and call-free programs that use explicit deal\u00adlocation. All \nloops must be unrolled and method calls must be inlined (or replaced with their preconditions and postcon\u00additions). \nIt does not support library calls. The logic allows to specify invariants over the content and structure \nof linked lists (e.g., whether they are sorted) and properties related to memory safety.  7.4 Predicate \nAbstraction for Collections and the Heap Some work has also been done in shape analysis techniques based \non predicate abstraction. These techniques work upon the heap graph, i.e. upon the pointer-level representation \nof data structures. The key idea of [37] is to encode the heap graph by special predicates that express \npointer relations be\u00adtween objects (i.e., edges in the graph). The approach pro\u00adposed by Dams and Namjoshi \n[16] uses predicates that can express the reachability of an address a2 from the address a1, and performs \nshape analysis via model checking of the predicate abstraction of a given program. 8. Conclusion We have \nproposed an approach for modeling the state and behavior of Java collections observable from client pro\u00adgrams, \nwhich is based on predicates and abstract maps with iterators. It captures all of the important features \nof Java col\u00adlections, including the following: iteration order, size, views, aliasing between elements, \nand nested collections. We use the model of Java collections based on maps and the predicate language \nto verify interesting properties of client programs by means of predicate abstraction. The predicate \nlanguage has suf.cient expressive power to cap\u00adture the information necessary for successful veri.cation \nof properties that depend on the collection state, as we illus\u00adtrate in the results of our experiments \nand in the examples in Section 4.1. Note that all of the features of the predicate language are required \nfor this purpose. Future work. Our main priorities for future work are the following: (1) automated inference \nof predicates about col\u00adlections that are needed to verify a given property, and (2) further improving \nthe performance and scalability of con\u00adstructing abstract programs. We aim at inference of predi\u00adcates \nthat would yield a suf.ciently precise abstraction, for which the model checker reports no spurious errors \nand .nds real errors (if any exist in the original input program). We also plan to improve the practical \nusefulness of our tool chain by supporting projection of error traces back to the source code of input \nprograms. Another possible direc\u00adtion is the usage of our tool in existing CEGAR-based ver\u00adi.cation frameworks \n[14] this would require support for automated checking whether an error trace is spurious and identi.cation \nof predicates that can be used to eliminate the given spurious error trace from the abstract program. \nIn the long term, we plan to use the proposed predi\u00adcate language in other program veri.cation and bug \n.nd\u00ading techniques. For example, the weakest preconditions that we de.ned could be used in backward symbolic \nexecution that aims at ef.cient bug .nding [13]. Another option is to use the predicates as elements \nof an abstract domain in static analysis (abstract interpretation). We could extend the technique described \nin [32], which aims to verify the cor\u00adrectness of dereferences using weakest preconditions and backward \ndata .ow analysis, so that it handles collections more precisely. We might also consider interpolation-based \nmodel checking procedures [22, 24, 35] that construct the abstraction on-the-.y during the traversal \nof the program state space. Finally, we would like to extend the predicate language with support for \nset operations over the content of maps, assuming that a map is actually a set of key-value pairs. Acknowledgments \nThis research was supported by the Natural Sciences and Engineering Research Council of Canada and the \nOntario Ministry of Economic Development and Innovation. References [1] T. Ball, E. Bounimova, B. Cook, \nV. Levin, J. Lichtenberg, C. McGarvey, B. Ondrusek, S.K. Rajamani, and A. Ustuner. Thorough Static Analysis \nof Device Drivers. In Proceedings of EuroSys 2006, ACM.  [2] T. Ball, R. Majumdar, T. Millstein, and \nS.K. Rajamani. Auto\u00admatic Predicate Abstraction of C Programs. In Proceedings of PLDI 2001, ACM. [3] \nT. Ball, A. Podelski, and S.K. Rajamani. Boolean and Cartesian Abstraction for Model Checking C Programs. \nIn TACAS 2001, LNCS, vol. 2031. [4] M. Barnett, B.-Y. E. Chang, R. DeLine, B. Jacobs, and R. Leino. Boogie: \nA Modular Reusable Veri.er for Object-Oriented Programs. In FMCO 2005, LNCS, vol. 4111. [5] M. Barnett, \nR. Leino, and W. Schulte. The Spec# Programming System: An Overview. In CASSIS 2004, LNCS, vol. 3362. \n[6] J. Berdine, C. Calcagno, B. Cook, D. Distefano, P. W. O Hearn, T. Wies, and H. Yang. Shape Analysis \nfor Composite Data Struc\u00adtures. In CAV 2007, LNCS, vol. 4590.  [7] J. Bingham and Z. Rakamaric. A Logic \nand Decision Procedure for Predicate Abstraction of Heap-Manipulating Programs. In VMCAI 2006, LNCS, \nvol. 3855.  [8] N. Blanc, A. Groce, and D. Kroening. Verifying C++ with STL Containers via Predicate \nAbstraction. In ASE 2007, ACM. [9] A. Bouajjani, M. Bozga, P. Habermehl, R. Iosif, P. Moro, and T. Vojnar. \nPrograms with Lists Are Counter Automata. In CAV 2006, LNCS, vol. 4144.  [10] A. Bouajjani, C. Dragoi, \nC. Enea, A. Rezine and M. Sighire\u00adanu. Invariant Synthesis for Programs Manipulating Lists with Unbounded \nData. In CAV 2010, LNCS, vol. 6174. [11] C. Boyapati, S. Khurshid, and D. Marinov. Korat: Automated Testing \nBased on Java Predicates, In ISSTA 2002, ACM. [12] A.R. Bradley, Z. Manna, and H.B. Sipma. What s Decidable \nAbout Arrays?. In VMCAI 2006, LNCS, vol. 3855. [13] S. Chandra, S.J. Fink, and M. Sridharan. Snugglebug: \nA Pow\u00aderful Approach to Weakest Preconditions. In PLDI 2009, ACM. [14] E.M. Clarke, O. Grumberg, S. Jha, \nY. Lu, and H. Veith. Counterexample-Guided Abstraction Re.nement, In CAV 2000, LNCS, vol. 1855. [15] \nD. Cok and J. Kiniry. ESC/Java2: Uniting ESC/Java and JML, In CASSIS 2004. [16] D. Dams and K. Namjoshi. \nShape Analysis through Predicate Abstraction and Model Checking. In Proceedings of VMCAI 2003, LNCS, \nvol. 2575. [17] I. Dillig, T. Dillig, and A. Aiken. Precise Reasoning for Pro\u00adgrams Using Containers. \nIn Proceedings of POPL 2011, ACM. [18] D. Distefano and M. Parkinson. jStar: Towards Practical Ver\u00adi.cation \nfor Java. In Proceedings of OOPSLA 2008, ACM. [19] C. Flanagan, R. Leino, M. Lillibridge, G. Nelson, \nJ.B. Saxe, and R. Stata. Extended Static Checking for Java, In Proceedings of PLDI 2002, ACM. [20] C.A. \nFuria. What s Decidable about Sequences?. In ATVA 2010, LNCS, vol. 6252. [21] S. Graf and H. Sa\u00a8idi. \nConstruction of Abstract State Graphs with PVS. In Proceedings of CAV 1997, LNCS, vol. 1254. [22] M. \nHeizmann, J. Hoenicke, and A. Podelski. Nested inter\u00adpolants. In POPL 2010, ACM. [23] T.A. Henzinger, \nR. Jhala, R. Majumdar, and G. Sutre. Lazy Abstraction. In Proceedings of POPL 2002, ACM. [24] D. Kapur, \nR. Majumdar, and C.G. Zarba. Interpolation for Data Structures. In Proceedings of FSE 2006, ACM. [25] \nS. Khurshid, C.S. Pasareanu, and W. Visser. Generalized Sym\u00adbolic Execution for Model Checking and Testing. \nIn TACAS 2003, LNCS, vol. 2619. [26] S. Khurshid and Y.L. Suen. Generalizing Symbolic Execution to Library \nClasses. In Proceedings of PASTE 2005, ACM. [27] V. Kuncak, R. Piskac, P. Suter, and T. Wies. Building \na Calcu\u00adlus of Data Structures. In VMCAI 2010, LNCS, vol. 5944. [28] S.K. Lahiri and S. Qadeer. Verifying \nProperties of Well-Founded Linked Lists. In Proceedings of POPL 2006, ACM. [29] S.K. Lahiri and S. Qadeer. \nBack to the Future: Revisiting Pre\u00adcise Program Veri.cation Using SMT Solvers. In Proceedings of POPL \n2008, ACM. [30] G. Leavens, A. Baker, and C. Ruby. Preliminary Design of JML: A Behavioral Interface \nSpeci.cation Language for Java. ACM SIGSOFT Software Engineering Notes, 31(3), 2006. [31] R. Leino. Dafny: \nAn Automatic Program Veri.er for Func\u00adtional Correctness. In LPAR 2010, LNAI, vol. 6355. [32] R. Madhavan \nand R. Komondoor. Null Dereference Veri.ca\u00adtion via Over-approximated Weakest Pre-conditions Analysis. \nIn OOPSLA 2011, ACM. [33] P. Madhusudan, G. Parlato, and X. Qiu. Decidable Logics Combining Heap Structures \nand Data. In POPL 2011, ACM. [34] J. McCarthy. A Basis for a Mathematical Theory of Compu\u00adtation, Technical \nreport, MIT, Cambridge, MA, USA, 1962. [35] K. McMillan. Lazy Abstraction with Interpolants. In CAV 2006, \nLNCS, vol. 4144. [36] L. de Moura and N. Bjorner. Z3: An Ef.cient SMT Solver. In Proceedings of TACAS \n2008, LNCS, vol. 4963. [37] A. Podelski and T. Wies. Boolean Heaps. In SAS 2005, LNCS, vol. 3672. [38] \nS. Ranise and C. Tinelli. The SMT-LIB standard, version 1.2, August 2006. [39] W. Visser, C.S. Pasareanu, \nand S. Khurshid. Test Input Gener\u00adation with Java PathFinder, In ISSTA 2004, ACM. [40] K. Zee, V. Kuncak, \nand M. Rinard. Full Functional Veri.ca\u00adtion of Linked Data Structures. In PLDI 2008, ACM. [41] K. Zee, \nV. Kuncak, and M. Rinard. An Integrated Proof Lan\u00adguage for Imperative Programs. In PLDI 2009, ACM. [42] \nASM: Java bytecode manipulation and analysis framework. http://asm.ow2.org/. [43] J2BP tool for predicate \nabstraction of Java programs. http: //plg.uwaterloo.ca/ pparizek/j2bp/. [44] Java Path.nder system for \nveri.cation of Java programs. http://babelfish.arc.nasa.gov/trac/jpf/. [45] SMT-LIB Format for Finite \nLists, Sets, and Maps. http: //www.cprover.org/SMT-LIB-LSM/. [46] T.J. Watson Libraries for Analysis \n(WALA). http:// wala.sourceforge.net/. [47] Yices: An SMT solver. http://yices.csl.sri.com/. A. Weakest \nPreconditions For each statement s of the language in Figure 6, we de.ne the weakest preconditions for \npredicates whose truth value may be changed by the execution of s. The weakest precon\u00additions are shown \nin Tables 5-9. We consider only statements whose execution may change the truth value of some predi\u00adcate \n assignment statements, object construction, and sup\u00adported operations on abstract maps and iterators. \nThe weakest precondition WP(s, p) is in many cases de\u00ad.ned in terms of the predicate p and certain syntactic \nsub\u00adstitutions. The symbol Fx denotes any valid atomic predi\u00adcate over the expression x that is not covered \nby other lines of the table for a given statement. The symbols q, qk and qm denote logic variables whose \nnames are different from the names of all program variables. The symbol d represents any expression that \ncan have a speci.c position in the iter\u00adation order of some map (i.e., a key or an iterator variable). \n Statement s Predicate p W P (s, p) w = w Fw p[w ' /w] w = e w relop u e relop u Fw false o.f = e fread(f, \no ' ) relop u fread(fwrite(f, o, e), o ' ) relop u Ffread(f,o) false o = new C o = w false o = null false \nfread(f, o) relop u false Fo false a[i] = e aread(arr, a ' , i ' ) relop u aread(awrite(arr, a, i, e), \na ' , i ' ) relop u Faread(arr,a,i) false m = new map mget(map, m, k) = . true mget(map, m, k) relop \nv false mget(map, m, k1) = mget(map, m, k2) true msize(msz, m) = 0 true msize(msz, m) relop sz false \nmorder(mit, m, d1, d2) false morder(mit, m, ., .) true mkeys(mks, m, ms) false mkeys(mks, m ' , m) false \nmvalues(mvs, m, ml) false mvalues(mvs, m ' , m) false m = m ' false Table 5. Weakest preconditions for \nassignment statements Statement s Predicate p W P (s, p) r = mget(map, m ' , k ' ) (m = m ' . k = k ' \n) . (mget(map, m, k) = mget(map, m ' , k ' )) r = m.get(k) r = null .qm : qm = m . mget(map, qm, k) = \nq . (q = . . q = null) r = e .qm : qm = m . e = mget(map, qm, k) fread(f, r) = e .qm : qm = m . fread(f, \nmget(map, qm, k)) = e Fr .qm .q = . : qm = m . mget(map, qm, k) = q . Fr[q/r] b = m.containsKey(k) b \n= true .qm .q = . : qm = m . mget(map, qm, k) = q b = false .qm : qm = m . mget(map, qm, k) = . b = m.containsValue(v) \nb = true .qm .q : qm = m . mget(map, qm, q) = v b = false \u00ac(.qm .q : qm = m . mget(map, qm, q) = v) r \n= m..ndKey(v) mget(map, m ' , r) = v ' m = m ' . v = v ' Fr .qm .q : qm = m . mget(map, qm, q) = v . \nFr[q/r] sz = m.size() sz relop u .qm : qm = m . msize(msz, qm) relop u Table 6. Weakest preconditions \nfor statements that query map state Table 7. Weakest preconditions for statements that update map state \n Statement s Predicate p W P (s, p) m.put(k,v) mget(map, m ' , k ' ) = v ' mget(mupdate(map, m, k, v), \nm ' , k ' ) = v ' mget(map, m ' , k ' ) = mget(map, m '' , k '' ) (m = m ' . k = k ' . mget(map, m '' \n, k '' ) = v) . (m = m '' . k = k '' . mget(map, m ' , k ' ) = v) . ((m = m ' . k = k ' ) . (m = m '' \n. k = k '' ) . p) msize(msz, m ' ) relop u ite( (m = m ' . mget(map, m ' , k) = .) . m = m ' , p[mresize(msz, \nm, msize(msz, m) + 1)/msz], p ) morder(mit, m ' , ., d) ite( m = m ' , ite( d = k, morder(mit, m ' , \n., .), p ), p ) morder(mit, m ' , d, .) ite( m = m ' , d = k, p ) morder(mit, m ' , ., .) ite( m = m \n' , false, p ) morder(mit, m ' , d1, d2) ite( m = m ' , d1 = k . ((d2 = k . mget(map, m ' , d1) = .) \n. p), p ) m.putAhead(k,v,l) morder(mit, m ' , ., d) ite( m = m ' , ite( d = k, p[./d] . p[l/d], d = l \n. p ), p ) morder(mit, m ' , d, .) ite( m = m ' . d = k, mget(map, m ' , l) = ., p ) morder(mit, m ' \n, ., .) ite( m = m ' , false, p ) morder(mit, m ' , d1, d2) ite( m = m ' , ite( d1 = k, d2 = l, (d2 = \nk . d1 = l . mget(map, m ' , d1) = .) . p ), p ) m.remove(k) mget(map, m ' , k ' ) = v ' mget(mupdate(map, \nm, k, .), m ' , k ' ) = v ' mget(map, m ' , k ' ) = mget(map, m '' , k '' ) (m = m ' . m = m '' . p) \n. (m = m ' . m ' = m '' . k ' = k '' ) . (m = m ' . m = m '' . ite(k = k ' , p, mget(map, m '' , k '' \n) = .)) . (m = m '' . m = m ' . ite(k = k '' , p, mget(map, m ' , k ' ) = .)) msize(msz, m ' ) relop \nu ite( (m = m ' . mget(map, m ' , k) = .) . m = m ' , p[mresize(msz, m, msize(msz, m) - 1)/msz], p ) \nmorder(mit, m ' , ., d) ite( m = m ' , d = k . p[k/d] . p[k/.], p ) morder(mit, m ' , d, .) ite( m = \nm ' , d = k . p[k/.] . p[k/d], p ) morder(mit, m ' , ., .) ite( m = m ' , ite( mget(map, m ' , k) = ., \np, morder(mit, m ' , ., k) . morder(mit, m ' , k, .) ), p ) morder(mit, m ' , d1, d2) ite( m = m ' , \nd1 = k . d2 = k . (p . (p[k/d2] . p[k/d1])), p ) m.clear() mget(map, m ' , k ' ) = v ' ite( m = m ' , \nv ' = ., p ) mget(map, m ' , k ' ) = mget(map, m '' , k '' ) (m = m ' . m = m '' . p) . (m = m ' . m \n' = m '' ) . (m = m ' . m = m '' . mget(map, m '' , k '' ) = .) . (m = m '' . m = m ' . mget(map, m ' \n, k ' ) = .) msize(msz, m ' ) = 0 ite( m = m ' , true, p ) msize(msz, m ' ) relop sz ite( m = m ' , false, \np ) morder(mit, m ' , ., d) ite( m = m ' , false, p ) morder(mit, m ' , d, .) ite( m = m ' , false, p \n) morder(mit, m ' , ., .) ite( m = m ' , true, p ) morder(mit, m ' , d1, d2) ite( m = m ' , false, p \n) The symbol relop denotes a relational operator that is de\u00ad.ned for the type of variables used as operands \n(e.g., only = for booleans). For the operation putAhead, we show in the table only those pairs of a predicate \nand a weakest precon\u00addition where the precondition is different than in the case of the put operation. \nSeveral notes about the behavior (semantics) encoded by the weakest preconditions follow. An execution \nof the as\u00adsignment statement w=e sets to false any predicate in which w is an argument for mget and morder, \nbecause now the variable w may have a different value than when it was used as an argument for the put \noperation. The statement m= new map sets to false all predicates over the variable m ex\u00ad cept the predicates \nsaying that the map is empty. A map cre\u00adated by the operation valuesView (which represents the list of \nall values in m) contains keys in the range from 1 to the size of m. The expression mupdate(map, m, k, \n.) indicates that the key-value pair involving k is being removed from the map m. An execution of the \nstatement o = new C sets the truth value of all aliasing predicates over the reference variable o to \nfalse and assigns the non-deterministic boolean value unknown to all predicates over .elds of the object \npointed to by o. This expresses the absence of any knowl\u00adedge about the values of .elds of the object \nimmediately after its allocation. The predicates mget(map,m ' ,k ' )= mget(map,m '' ,k '' ) and the respective \nweakest precondi\u00adtions are used to express aliasing between map elements.  Statement s Predicate p W \nP (s, p) ms = m.keysView() mget(map, ms, k) = true .q = . : mget(map, m, k) = q msize(msz, ms) relop \nsz p[m/ms] morder(mit, ms, ., d) p[m/ms] morder(mit, ms, d, .) p[m/ms] morder(mit, ms, ., .) p[m/ms] \nmorder(mit, ms, d1, d2) p[m/ms] mkeys(mks, m ' , ms) m = m ' mkeys(mks, ms, ms ' ) false mvalues(mvs, \nm ' , ms) false mvalues(mvs, ms, ml) false ms = ms ' mkeys(mks, m, ms ' ) ml = m.valuesView() mget(map, \nml, k) = v .q : mget(map, m, q) = v msize(msz, ml) relop sz p[m/ml] morder(mit, ml, ., d) d = 1 morder(mit, \nml, d, .) d = msize(msz, m) morder(mit, ml, ., .) msize(msz, m) = 0 morder(mit, ml, d1, d2) d1 < d2 . \n1 = d1 . d2 = msize(msz, m) mkeys(mks, m ' , ml) false mkeys(mks, ml, ms ' ) false mvalues(mvs, m ' , \nml) m = m ' mvalues(mvs, ml, ml ) ' false ml = ml ' mvalues(mvs, m, ml ) ' Table 8. Weakest preconditions \nfor statements that create views over maps Statement s Predicate p W P (s, p) it = it ' false morder(mit, \nm ' , ., it) m = m ' it = m.createIterator() morder(mit, m ' , it, .) m = m ' . p[./it] morder(mit, m \n' , it, d) m = m ' . p[./it] morder(mit, m ' , d, it) false b = it.hasMore() b = true .qm : \u00acmorder(mit, \nqm, it, .) b = false .qm : morder(mit, qm, it, .) r = it.getCurrent() morder(mit, m ' , r, it) true Fr \n.qm .qk : (morder(mit, qm, qk, it) . Fr[qk/r]) morder(mit, m ' , ., it) false it.moveNext() morder(mit, \nm ' , it, .) .qk : (p[qk/.] . p[qk/it]) morder(mit, m ' , it, k ' ) .qk : (p[qk/k ' ] . p[qk/it] . \u00acp[./it]) \nmorder(mit, m ' , k ' , it) morder(mit, m ' , it, k ' ) Table 9. Weakest preconditions for statements \nover iterators   \n\t\t\t", "proc_id": "2384616", "abstract": "<p>Our goal is to develop precise and scalable verification techniques for Java programs that use collections and properties that depend on their content. We apply the popular approach of predicate abstraction to Java programs and collections. The main challenge in this context is precise and compact modeling of collections that enables practical verification. We define a predicate language for modeling the observable state of Java collections at the interface level. Changes of the state by API methods are captured by weakest preconditions. We adapt existing techniques for construction of abstract programs. Most notably, we designed optimizations based on specific features of the predicate language. We evaluated our approach on Java programs that use collections in advanced ways. Our results show that interesting properties, such as consistency between multiple collections, can be verified using our approach. The properties are specified using logic formulas that involve predicates introduced by our language.</p>", "authors": [{"name": "Pavel Par&#237;zek", "author_profile_id": "81501645292", "affiliation": "University of Waterloo, Waterloo, ON, Canada", "person_id": "P3856038", "email_address": "pparizek@uwaterloo.ca", "orcid_id": ""}, {"name": "OndYej Lhot&#225;k", "author_profile_id": "81100503314", "affiliation": "University of Waterloo, Waterloo, ON, Canada", "person_id": "P3856039", "email_address": "olhotak@uwaterloo.ca", "orcid_id": ""}], "doi_number": "10.1145/2384616.2384623", "year": "2012", "article_id": "2384623", "conference": "OOPSLA", "title": "Predicate abstraction of Java programs with collections", "url": "http://dl.acm.org/citation.cfm?id=2384623"}