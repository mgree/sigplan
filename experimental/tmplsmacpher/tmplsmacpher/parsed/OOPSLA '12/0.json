{"article_publication_date": "10-19-2012", "fulltext": "\n Type-Based Safe Resource Deallocation for Shared-Memory Concurrency Kohei Suenaga Ryota Fukuda Atsushi \nIgarashi Kyoto University Kyoto University Kyoto University ksuenaga@kuis.kyoto-u.ac.jp rfukuda@kuis.kyoto-u.ac.jp \nigarashi@kuis.kyoto-u.ac.jp Abstract We propose a type system to guarantee safe resource deal\u00adlocation \nfor shared-memory concurrent programs by extend\u00ading the previous type system based on fractional ownerships. \nHere, safe resource deallocation means that memory cells, locks, or threads are not left allocated when \na program ter\u00adminates. Our framework supports (1) fork/join parallelism, (2) synchronization with locks, \nand (3) dynamically allo\u00adcated memory cells and locks. The type system is proved tobe sound.We also providea \ntype inference algorithm for the type system and a prototype implementation of the algo\u00adrithm. Categories \nand Subject Descriptors D.2.4[Software Engi\u00adneering]: Software/ProgramVeri.cation Formal methods; D.3.2[Programming \nLanguages]: Language Classi.cations Concurrent, distributed, and parallel languages; F.3.1[Log\u00adics and \nMeanings of Programs]: Specifying and Verifying and Reasoning about Programs Mechanical veri.cations; \nF.3.2[Logics and Meanings of Programs]: Semantics of Pro\u00adgramming Languages Program analysis General \nTerms Theory,Veri.cation Keywords fork/join parallelism, fractional ownerships, memory leak, race freedom, \nsafe resource deallocation, shared-memory concurrency, SMT solver, type inference, type systems 1. Introduction \nSafe resource deallocation is a crucial matter in program\u00adming languages with manual resource (e.g., \nmemory and .les) management such as C and C++. Failing to dispose a created resource, or accessing an \nalready disposed resource Permission to make digital or hard copies of all or part of this work for personal \nor classroomuseisgrantedwithout feeprovidedthat copies arenot madeordistributed forpro.torcommercialadvantage \nandthatcopiesbearthisnoticeandthefullcitation onthe .rstpage.To copy otherwise,to republish,topostonserversorto \nredistribute tolists, requirespriorspeci.cpermission and/ora fee. OOPSLA 12, October19 26,2012,Tucson,Arizona,USA. \nCopyright c &#38;#169;2012ACM978-1-4503-1561-6/12/10. . .$10.00 could lead to fatal errors1. For example, \nin the C language, a memory leak occurs if a programmer forgets to deallo\u00adcate a memory cell allocated \nby malloc. In order to ad\u00address this problem, various formal veri.cation methodolo\u00adgies [8, 13, 14, 16, \n18] have been proposed. Most of them are, however, for sequential programs. Our goal is to establish \na technique to statically check safe resource deallocation for concurrent programs written in the C language. \nNot only is it harder to reason about concurrent programs, but also there are more kinds of resources \nto be considered in concurrent programming languages than sequential languages.Forexample, IEEE standards \ndescribe pthread join(), a function for joining a spawned thread, and pthread mutex destroy(), a function \nfor destroying a mutex, as follows [9]: The pthread join() ... should eventually be called for every \nthread that is created [emphasis added] . . . so that storage associated with the thread may be reclaimed. \nThe pthread mutex destroy() function shall destroy the mutex object referenced by mutex; the mutex object \nbecomes, in effect, uninitialized. . . . the results of . . . referencing the object after it has been \ndestroyed are unde.ned [emphasis added]. It shall be safe to destroy an initialized mutex that is unlocked. \nAttempting to destroy a locked mutex results in unde.ned behavior [emphasis added]. As a .rst step towards \nour goal, we will investigate three basic types of resources memory cells, locks, and threads in this \npaper, though there are other kinds of re\u00adsources than threads and locks (e.g., barriers and reader/writer \nlocks). The following example written in a C-like language describes the language features we will deal \nwith. EXAMPLE 1. The main function in Figure 1 allocates two memory cells on heap, sets the pointers \nto the cells to p and 1Some of the modern operating systems automatically reclaim resources that have \nnot been not deallocated appropriately. However, we believe that safe resource deallocation is an important \nissue because not all operating systems have such advanced feature.  main() { loop(p, q, l) { p = malloc(); \nn = 10; q = malloc(); while (n > 0) { l = newlock(); acquire(l); child= *p=0; fork(loop(p,q,l)); release(l); \nloop(p, q, l); printf(\"*q=%d\",*q); wait(child); --n; freelock(l); } free(p); } free(q); } Figure 1. \nAn example of shared-memory concurrent pro\u00adgrams. q, and creates a lock l. Then the program spawns a \nnew thread that executes the body of loop inside. The parent and the child threads both write to *p and \nread from *q repeatedly. In order to avoid race, they use the lock l, which is shared by them. Accesses \nto *q are not guarded because they only read from *q. After the child thread terminates, the parent thread \nreclaims the thread ID (wait(child)), deallocates the lock(freelock(l)), and then the memory cells(free(p) \nand free(q)). This program includes (1) dynamically spawned threads, (2) dynamically allocated locks \nand memory cells, (3) syn\u00adchronization using locks, and (4) deallocation of threads, locks, and memory \ncells. Our approach is to extend the previous .ow-sensitive type system of Suenaga andKobayashi [13] \nto concurrency. The basic idea of their previous type system is to assign a frac\u00adtional ownership to \neach pointer-type constructor. A frac\u00adtional ownership is a rational number that represents capa\u00adbility/obligation \non the usage of the pointers. For example, type int ref 1 is the type for pointers to an integer that \ncan be used for reading/writing and should be used for deallocation before termination.Type int ref 0 \nis for pointers that cannot be used at all and type int ref 0.5 is for read-only pointers that should \nbe used for deallocation. By checking that no ownership is left after the execution of a program, the \ntype system guarantees safe memory deallocation for sequential programs. Our contribution is summarized \nas follows. We propose a type system for safe resource dealloca\u00adtion for a programming language in which \na program\u00admer has to manually deallocate resources (i.e., memory cells, locks, and threads). Our type \nsystem supports (1) dynamic creation of threads, locks, and memory cells and (2) synchronization using \nlocks.  We prove that the type system is sound the execution of a well-typed program indeed leaves no \nresources when it terminates.  We provide a type inference algorithm for the type sys\u00adtem, and an implementation \nof the algorithm. Readers can try the implementation from http://www.fos. kuis.kyoto-u.ac.jp/~rfukuda/freesafety-con/. \nOur type system also guarantees race-freedom and that, for each operation to acquire a lock, there is \nexactly one corresponding release operation before termination. Race\u00adfreedom is naturally achieved by \nthe property inherited from the previous type system that there is at most one pointer that a program \ncan use for writing to each memory cell. Though it is not our main purpose to guarantee these properties, \nthey are interesting on their own because they are important in deadlock-freedom analysis of concurrent \nlanguages with non-block-structured lock primitives [12]. The rest of the paper is organized as follows. \nWe .rst review the previous type system for a sequential language in Section 2 and present an overview \nof our extension in Section 3. Then, Section 4 de.nes the language L, a con\u00adcurrent language with manual \nresource management, and the safety properties we are to guarantee by the type sys\u00adtem. Section 5 introduces \nthe type system and sketches a proof of type soundness, which is followed by a type in\u00adference algorithm \ndescribed in Section 6. After discussing related work in Section 7, Section 8 concludes the paper. Due \nto space limitation, we omit several de.nitions and de\u00adtailed proofs, which are found in a full version \nof the pa\u00adper (found at http://www.fos.kuis.kyoto-u.ac.jp/ ~ksuenaga/papers/leak-full.pdf).  2. Review \nof Fractional Ownerships This section brie.y reviews the type system of Suenaga and Kobayashi [13]. As \nmentioned in Section 1, the basic idea of Suenaga and Kobayashi s type system is to assign a frac\u00adtional \nownership f (represented by a rational number in [0,1]) to each pointer type constructor t ref f. An \nowner\u00adship represents capability about how the pointer is used in a program: f =1means full access capability \ncapability for reading from, writing to, and deallocate the memory cell that the pointer points to; f \n=0 means no access capabilities; and other rational numbers between0and1 mean capability only to read. \nIt also represents obligation: a non-zero owner\u00adship means obligation for deallocation. (A rational number \nless than 1 does not give capability to deallocate, however. So, ownerships held by aliases have to be \nmerged to recover the fullownership1 before deallocation.) EXAMPLE 2. For the following heap structure, \nwhere a ref\u00aderence x points to the .rst cell, x if x has type t ref 0 ref 1, the program can read from/write \nto and has to deallocate the .rst cell through x, while the program cannot access the second cell through \nx. The type system also ensures that an alias of the pointer to the second cell exists and the second \ncell will be deallocated through it.  Atype judgment in this type system is of the formT;G . s . G ' \n, where s is a command, T records types of top\u00adlevel functions, and G and G ' record types of variables. \nThe judgment T;G . s . G ' intuitively means under the assumption that (1) each function has the type \ndescribed in Tand that (2) each variable has the type described in G, the ownerships left after s terminates \nare described as in G ' . We call G the pre type environment and G ' the post type environment of the \njudgment. For example, consider a command let x = *y in skip, which binds x to the value stored in the \nmemory cell that y points to (and does nothing). Then, T;y : int ref 0.5 . let x = *yin skip . y:int \nref 0.5 is a valid type judgment because yis given a non-zero ownership to read through. Un\u00adlike reading, \nhowever, the full ownership is required for writ\u00ading operation into a memory cell. So, T;x:int ref f,y:int \n. *x . y . x : int ref f,y : int (where *x . y is a com\u00admand to store the value of yto the memory cell \nthat x points to) is valid only if f =1. Similarly, deallocation also re\u00adquires the full ownership; moreover, \nthe ownership becomes zero after deallocation, because the pointer becomes dan\u00adgling. So, T;x:int ref \n1 . free(x). x:int ref 0 is valid, whereas neither T;x : int ref 1 . free(x). x : int ref 1 nor T;x : \nint ref 0.5 . free(x). x : int ref 0 is. One interesting feature of the type system is that own\u00aderships \ncan be transferred to aliases of the same pointer. For example, T;x : int ref 1 . let y = x in free(y) \n. x:int ref 0 isavalidtype judgment.Infact,thepretypeen\u00advironment for free(y)is x:int ref 0,y :int ref \n1 due to the transfer of the ownership from x to y at let x = y in. Al\u00adthough this example shows transfer \nof the whole ownership that x holds to y, the typing rule for let y = x in s allows also partial transfer \nthat is, the original ownership of x can be split into two fractions for x and y in s. For example, int \nref 1 can be split into int ref 0.5 and int ref 0.5, which makes the following type judgment valid: let \ny = x in let z = *x in T;x : int ref 1 .. G ' let w = *y in ... Here, the pre type environment for let \nz = *x in ... is x:int ref 0.5,y :int ref 0.5, making it possible to read from 2 both x and y. For a \nprogram, which consists of a set of top-level func\u00adtions and a command (which is considered as the body \nof the main function), the type system requires the main com\u00admand to be typed under the empty pre and \npost type envi\u00adronments. The empty post type environment means that no ownerships are left or, all obligations \nof deallocation are 2In order to deallocate the memory cell pointed to byx, the split ownerships have \nto be merged to recover the full ownership. The type system uses must-alias informationto mergeownerships.See \nSection5for more details. ful.lled after the execution of the main command. This way, safe memory deallocation \nis guaranteed.  3. Extension to Concurrency The discussion in Section 1 and the program in Example 1 \nlead us to the following observations. 1. We need to guarantee safe deallocation not only of mem\u00adory \ncellsbut also of locks and threads. 2. The type system should be able to allow different threads to \naccess shared memory cells when locks are properly usedtoavoid racy accesses.Forexample,inthe program \nin Example 1, two threads use the lock l to control write accesses to *p.  We address the .rst observation \nby ownerships on locks and thread IDs, and the second by ownership transfer via procurable type environments, \nas described below. Ownerships on locks and thread IDs: In order to deal with locks and threads as resources \nthat have to be deallocated, our type system introduces two new types: lock and tid. As we have pointed \nout above, the type system also needs to ensure that they are safely deallocated.To this end, the type \nsystem assigns ownerships to lock types and thread types as well as pointer types. The type system will \nguarantee safe deallocation of these kinds of resources by the same idea as before: by ensuring that \nthere is no ownership left at the end of a program. In order to avoid a lock to be deallocated while \nit is held (see the quotation from [9] in Section 1), we also use own\u00aderships to express obligation to \nrelease locks. Thus, a lock type comes with two ownerships. One is lock ownership, which expresses capability \nto access the lock and obligation to deallocate the lock. The other is release ownership, which expresses \nobligation to release the lock. On the one hand, a lock can be acquired when the ownership of the lock \nis non-zero and the release ownership is 0; after the acquire op\u00aderation, the release ownership becomes \n1, which means the lock has to be released afterwards. On the other hand, a lock can be released when \nthe ownership for the lock is non-zero and the release ownership is 1; after the release operation, the \nrelease ownership becomes 0. The type system will use release ownership also to prevent a thread from \nacquiring (or releasing) a lock twice without releasing (or acquiring, respectively). Ownership transfer \nvia procurable type environments: In order to handle ownership transfer, we further extend lock types \nwith what we call procurable type environment. A procurable type environment describes the ownerships \ngranted to a thread while it holds the lock. As a result, a lock type is written (G,f1) lockf2 , where \nG is a (procur\u00adable) type environment, f1 is release ownership, and f2 is the ownership of the lock itself. \n For example, if a locklis given type((x:int ref 1),0) lock1, then a thread gets the ownership int ref \n1 on x as it acquires l, allowing read from and write to x. After the acquire oper\u00adation, the type of \nlbecomes ((x:int ref 1),1) lock1, where the release ownership is set to 1. When the release owner\u00adship \nis ful.lled by releasing l, the thread will lose the same amount of ownership as it obtained, thus accesses \nto x will be prohibited. After the release of l, the type of l becomes ((x : int ref 1),0) lock1. We \nalso extend thread ID types with procurable type en\u00advironments (written G tidf)to handle reclamation \nof own\u00aderships that have been split for a spawned thread. Con\u00adsider the program in Example 1 again. The \ntwo threads read from q without using locks, so the ownerships on q held by these threads are in (0,1) \n(more precisely, the two ownerships f1 and f2 satisfy f1 > 0,f2 > 0 and f1 + f2 =1). In order to perform \nfree(q), however, the main thread, which has f1 on q, has to reclaim the other owner\u00adship f2 held by \nthe spawned thread. Our type system consid\u00aders this is done by waiting child that is, when child is given \ntype (q : int ref f2 ) tid1 in the pre type envi\u00adronment of wait(child), the typing rule for wait ensures \nq : int ref f1 +f2 in the post type environment. In general, the procurable type environment in a thread \nID type de\u00adscribes the post type environment of the thread, that is, the ownerships left after the thread \nterminates. Having these intuitions in mind, we proceed to the formal de.nitions of our target language \nand type system.  4. Target Language L 4.1 Syntax Let Var be a countably in.nite set of variables. The \nsyntax of L is given in Figure 2. A value, denoted by v, is either a variable or null; the former represent \nmemory addresses, while the latter the null pointer. A thread ID, denoted by t, is a variable or a special \nsymbol ., which is not a member of Var. The former are IDs of dynamically created threads, while the \nlatter is that of the main thread. Commands, ranged over by s, consist of sequential commands, including \ndo-nothing(skip), se\u00adquential composition (s1;s2), local binding (let x = v in s), procedure call(f(x1,...,xn)), \nallocation of a new memory cell(let x = malloc() in s), dealloca\u00adtionofa memory cell(free(x)), dereferencing \na pointer (let x = *y in s), destructive update of a memory cell througha pointer(*x1 . x2), testing \nwhether a value is null (ifnull(x)then s1 else s2),  must-alias annotations(assert(x1 = x2)and assert(x1 \n= *x2)), which programmers can use as hints to the type system,  lock-related primitives, including \ncreation of a lock (let x = newlock() in s), deallocation of a lock  (freelock(x)), acquiringa lock(acq(x)), \nand releasing a lock(rel(x)), and thread management primitives, including let x = fork(s1)in s2 for spawning \na thread that executes s1, binding x to the fresh ID of the new thread and executing s2, and wait(x)for \nwaiting for the thread with ID x to terminate and deallocating the thread ID. A few words about the must-alias \nannotations above: they could be inserted manually or by using static must-alias ana\u00adlyzers. In the current \nimplementation, programmers are re\u00adquired to insert them manually. The type system believes correctness \nof those annotations and uses them for owner\u00adship transfer. If an annotation turns out to be incorrect, \nthe program terminates with an exception see the operational semantics later. A meta-variable d denotes \na function de.nition and D a set of function de.nitions, where the names of functions are pairwise distinct.A \nprogram is a pair of the form (D,s).We write [v/x]s for capture-avoiding substitution of v for x in s. \nThe notion of bound/free variables are de.ned in a standard manner. We assume, without loss of generality, \nthat each boundvariableis different from each other.We also require that the actual arguments yxof function-call \ncommand f(yx) to be pairwise distinct for a technical reason; if one would like to pass one value as \ndifferent arguments, let has to be used beforehand to make aliases . REMARK 3. We do not incorporate \nprimitive values such as integers in the current language because such extension is quite straightforward. \nOne of the non-trivial extensions that are not discussed in this paper is C-like structures. Though extension \nwith structures in the sequential setting has been discussed in the previous work [13], we leave it as \nfuture work to investigate whether the same extension is possible in the concurrent setting. EXAMPLE \n4. The following L command expresses the body of main function in Example 1. We assume that loop is de.ned \nelsewhere. let p= malloc() in let q = malloc() in let l = newlock() in let c = fork(loop(p,q,l))in loop(p,q,l);wait(c);freelock(l);free(p);free(q) \nIn the rest of this section, we assume that Dis .xed if not explicitly speci.ed to make the notations \nless cumbersome.  4.2 Operational semantics The operational semantics is de.ned by small-step reduction \nof con.gurations which represent execution states. DEFINITION 5 (Con.gurations). Acon.guration is a quadru\u00ad \n.n ple (P,H,L,R) where P . (Var .{.}) . Cmd, .n.n .n H . Var . Val, L . Var . {.,.}, R . Var . Val, .n \nwhere X . Y is the set of partial functions from X to Y  x,f,l,h,. . . (Variables) . Var v (Values) \n. Val ::= x | null t (Thread IDs) ::= x | . s (Commands ) . Cmd ::= skip | s1;s2 | let x = v in s | f(x1,. \n. . ,xn) | let x = malloc() in s | free(x)| let x = *y in s | *x1 . x2 | ifnull(x)then s1 else s2 | assert(x1 \n= x2)| assert(x1 = *x2) | let x = newlock() in s | freelock(x)| acq(x)| rel(x) | let x = fork(s1)in s2 \n| wait(x) d(Function de.nitions) . Def ::= f(x1,. . . ,xn)= s E (Evaluation contexts) ::= []| E;s Figure \n2. Syntax of L. whose domain is .nite, and the domains of P, H, L and R are pairwise disjoint. We use \nthe meta-variable Conf for con.gurations.We write P(Conf ),R(Conf ),H(Conf ) and L(Conf ) for P,R,H and \nL in Conf , respectively. P(Conf ) is called thread pool of Conf , H(Conf ) heap and L(Conf )lock environment. \nAthread poolP records the thread IDs and the statements currently being executed. Recall that the symbol \n. stands for a special thread ID for the main thread.Aheap H represents the current state of memory. \nIt is essentially a directed graph whose vertices are memory locations. Lrecords the states of locks: \nL(x)= . means that x is being held by a thread and L(x)= . not being held. R represents a register .le, \nwhich maps a register name to its value. Note that we use variables for thread IDs (other than .), locations, \nlock IDs and register names. Notations. Let X be a map. We write dom(X) for the domain of X. By abuse \nof notation, we write dom(D)for the set of the function names de.ned in D.We write X[x . a]for the map \nde.ned by dom(X[x . a]) = dom(X).{x} and X[x . a](x)= a and X[x . a](y)= X(y)when x \u00b7) to denote a sequence \nand write = y.We use a tilde(xX\\{xx} for the map whose domain is dom(X)\\{xx} and de.ned by (X\\{xx})(z)= \nX(z). DEFINITION 6 (Small-Step Reduction). The relations (s,H,L,R). (s ' ,H ' ,L ' ,R ' )(s,H,L,R). E \n(P,H,L,R). (P ' ,H ' ,L ' ,R ' )(P,H,L,R). E, where E .{NullEx,AssertFail,Error}, are the least relations \nthat satisfy the rulesinFigures3,4 and5.(We use a single symbol . for all the relations by abuse of notation.) \nWe write . * for the re.exive transitive closure of .. The relation (s,H,L,R) . (s ' ,H ' ,L ' ,R ' ) \nrepresents small-step reduction inside a thread. The rules are mostly straightforward. In E-F REE, location \nR(x)is removed from the heap if R(x)is a valid location. If R(x)= null, nothing happens; here, we follow \nthe convention of theC language. E-MALLOC creates a memory cell allocated at a fresh lo\u00adcation h and \nassigns it to a (fresh) register z and extends R with z . h and H with h . v where v is an arbitrary \nvalue3. E-ASSERTEQ and E-ASSERTDEREF represent the cases where the assertions actually hold an assertion \nis no\u00adop when it holds. E-NEWLOCK creates a new lock l and assigns it to a new register z and extends \nLwith l .. and R with z . l. E-FREELOCK removes the lock R(x)from L if the lock is still alive and not \nheld by anythreads. The relation (P,H,L,R) . (P ' ,H ' ,L ' ,R ' ) repre\u00adsents reduction that pertains \nto the thread-related primitives. '' E-FORK generates a fresh thread ID z and assigns it to a ' '' fresh \nregister z ; a thread pool is extended with z . s1. E-WAIT removes R(x) from P if R(x) is a valid thread \nID and P(R(x)) has already .nished its execution. Note that R(x)cannot be .. E-ACQ con.rms that R(x)is \na valid lock and no thread currently holds this lock, and turns its lockstate to .. E-REL is the converse \nof E-ACQ. E-PROC arbitrarily chooses one thread in P and conducts one-step reduction. The relation (P,H,L,R) \n. E where E . {NullEx,AssertFail,Error} represents reduction to an exceptional state. Here, NullEx represents \nnull-pointer ac\u00adcesses, AssertFail assertion errors and Error accesses to dangling resources. As we see \nbelow, we do not treat NullEx nor AssertFail as erroneous states;our type sys\u00adtem does not exclude the \npossibility of null-pointer accesses and assertion errors. It means that safe deallocation is guar\u00adanteed \nonly when assertions, which could be inserted by must-alias analysis, are correct and the program does \nnot perform null-pointer accesses.  4.3 Safety property We formalize the safety property to be satis.ed \nby a well\u00adtyped program below. Informally, a well-typed program does not cause Error or race-condition; \nor does not leak re\u00adsources, either. A program is said to leak resources when itsexecution terminatesbut \nthe heap, the lock environment, or the thread pool at termination is not empty (except for the main thread).We \n.rst de.ne race condition. 3Following the convention of the C language, we assume nothing on the value \ncontained in the newly allocated memory cell.  (s,H,L,R). (s ' ,H ' ,L ' ,R ' ) (*x . y,H[R(x). v],L,R). \n (skip;s,H,L,R). (s,H,L,R) (E-SKIP) (E-ASSIGN) (skip,H[R(x). R(y)],L,R) R(x). dom(H). {null} (free(x),H,L,R). \n(skip,H\\R(x),L,R) (E-FREE) z and hare fresh v . Var . {null} (let x = malloc() in s,H,L,R). ([z/x]s,H[h \n. v],L,R[z . l]) (E-MALLOC) z is fresh (E-LET) z is fresh (let x = *y in s,H[R(y). v],L,R). (E-DEREF) \n (let x = v in s,H,L,R). ([z/x]s,H,L,R[z . v]) ([z/x]s,H[R(y). v],L,R[z . v]) R(x)= null (E-IFNULLTRUE) \n (ifnull(x)then s1 else s2,H,L,R). (s1,H,L,R) (ifnull(x)then s1 else s2,H,L,R[x . y]) . (s2,H,L,R[x . \ny]) (E-IFNULLFALSE) f(x)= s . D R(x1)= R(x2) x(E-APP) (E-ASSERTEQ) (f(y),H,L,R). ([y/x]s,H,L,R)(assert(x1 \n= x2),H,L,R). (skip,H,L,R) xxx (assert(x1 = *x2),H[R(x2). v],L,R[x1 . v]) . (E-ASSERTDEREF) (skip,R[x1 \n. v],H[R(x2). v],L,R[x1 . v]) z and l are fresh (E-NEWLOCK) (freelock(x),H,L[R(x) ..],R). (let x = newlock() \nin s,H,L,R). (E-FREELOCK) (skip,H,L\\R(x),R) ([z/x]s,H,L[l ..],R[z . l]) Figure 3. Semantics ofL (1). \n(P,H,L,R). (P ' ,H ' ,L ' ,R ' ) ' '' z and z are fresh (E-FORK) ''' (P[t . E[let x = fork(s1)in s2]],H,L,R). \n(P[t . E[[z ' /x]s2],z . s1],H,L,R[z . z '' ]) ' (P[t . E[wait(x)],x . skip],H,L,R[x . x ' ]) . (P[t \n. E[skip]]\\{x ' } ,H,L,R[x . x ' ]) (E-WAIT) (P[t . E[acq(x)]],H,L[R(x) ..],R). (P[t . E[skip]],H,L[R(x) \n..],R) (E-ACQ) (P[t . E[rel(x)]],H,L[R(x) ..],R). (P[t . E[skip]],H,L[R(x) ..],R) (E-REL) (s,H,L,R). \n(s ' ,H ' ,L ' ,R ' ) (E-PROC) (P[t . E[s]],H,L,R). (P[t . E[s ' ]],H ' ,L ' ,R ' ) Figure 4. Semantics \nofL (2). DEFINITION 7 (Reading from/Writing to). Thread tin con-to hif P(Conf )(t)is syntactically equal \nto E[*x . v]and .guration Conf such that t . dom(P(Conf )) is said to R(Conf )(x)= hfor some E,v and \nx. be reading from h if P(Conf )(t)is syntactically equal to DEFINITION 8 (Race Condition). A con.guration \nConf is E[let y = *x in s]and R(Conf )(x)= h for some E,x,y in race if there are h . dom(H(Conf )) and \nt1,t2 .and s. Thread t in con.guration Conf is said to be writing dom(P(Conf )) such that t1 = t2 and \neither (1) t1 and t2  (s,H,L,R). E, (P,H,L,R). E ' R(y)= null s is *y . x, or let x = *y in s, or assert(x \n= *y) (s,H,L,R). NullEx R(x1)= R(x2) R(y)./dom(H).{null} (assert(x1 = x2),H,L,R). AssertFail (assert(x \n= *y),H,L,R). AssertFail R(x)= v (assert(x = *y),H[R(y). v],L,R). AssertFail s = *x . y, or let x = *yin \ns, or free(x), or assert(x = *y) s = acq(x), or rel(x), or freelock(x) R(x)./dom(H) R(x)= null R(x)./dom(L) \n(s,H,L,R). Error (s,H,L,R). Error R(x)./dom(P)(s,H,L,R). E (wait(x),H,L,R). Error (P[t . E[s]],H,L,R). \nE Figure 5. Semantics ofL (3). are writing to h or (2) t1 is writing to h and t2 is reading from h. This \nde.nition intuitively means that Conf is in race if there are two or more threads that are accessing \nthe same location, and at least one of them is conducting write oper\u00adation. This de.nition has been widely \nused in race-freedom analysis (e.g.,[1]). Then, we de.ne termination of a con.guration and then the notion \nof program safety, which the type system will guarantee. DEFINITION 9 (Termination). A con.guration Conf \nis in termination if and only if P(Conf )(t)= skip for any t . dom(P(Conf )). We write End(Conf )if Conf \nis in termination. DEFINITION 10 (Safe Con.guration). Acon.gurationConf is safe (written Safe(Conf )) \nif and only if (1) Conf . Error; (2) Conf is not in race; and (3) End(Conf )im\u00adplies Conf =({. . skip} \n,\u00d8,\u00d8,R)for some R. DEFINITION 11 (Program Safety). Aprogram(D,s)is safe * if ({. . s} ,\u00d8,\u00d8,\u00d8) . Conf \nimplies Safe(Conf ). We write Safe(D,s)if (D,s)is safe. REMARK 12. Adeadlocking con.guration is not considered \nin termination.Forexample, .{. . wait(x),t1 . acq(y)} , . End .\u00d8, . .{l . .} , . .. {x . t1,y . l} does \nnot hold, though the con.guration is stuck.  5. Type System 5.1 Types and type environments The set \nof ownerships, ranged over by f, is the subset [0,1] of rational numbers Q. We de.ne types and type environ\u00adments \nas follows: * .(reference types) .{0}. [0,1] t (value types) . VTyp ::= . | (G,f1)lockf2 | Gtidf .n G(type \nenvironments) . Var . VTyp * A reference type . is a map from {0} to the set of owner\u00adships. Here, {0} \n* is the set of .nite sequences, ranged over by p, of the (only) alphabet 0. We assume that every ref\u00aderence \ntype . satis.es .(p) =0 implies .(p0) =0 for any p. (This restriction is needed for soundness [13].) \nA sequence p intuitively represents the memory cell reached by dereferencing a pointer |p| times; if \nx has type . and .(p)= f, it means that a programmer has to respect the ownership f of the value obtained \nby |p|-time dereferenc\u00ading of x following the chain of the pointers, where |p| is the length of p4. For \nexample, the type of x in Example 2 is {o . 1,0 . 0,00 . 0,...}. We write 0 for the reference type that \nis de.ned by 0(p) =0 for any p. Given a reference type ., we write . ref f for the reference type de.ned \nby (. ref f)(o)= f and (.ref f)(0p)= .(p). REMARK 13. In Suenaga and Kobayashi [13], they intro\u00adduce \na recursive type constructor \u00b5a.., interpret a recursive * type as an element in {0}. [0,1] (by in.nite \nexpansion), and de.ne operations on types in terms of in.nite expan\u00adsions. Our choice of directly using \n{0} * . [0,1] simpli.es the presentation of the type system. The type inference algo\u00adrithmin Section6 \nuses therecursive type notation asa .nite representation of reference types. A value type, often called \ntype for short, is either a ref\u00aderence type, a lock type (G,f1)lockf2 , or a thread ID type 4Though using \nthe set of natural numbers in place of{0}* could also work, we adopt the current de.nition for a future \nextension to multi-word cells. For example, when cells consist of two words, we can use {0, 1} as the \nalphabet.  G tidf; we have already explained the syntax and intuition Type environment G1 + G2 is de.ned \nby: of lock and thread ID types in Section 3. We call f1 in (G,f1)lockf2 release ownership and f2 lock \nownership. dom(G1 + G2)= dom(G1). dom(G2) = (G1 +G2)(x)G1(x)+G2(x)(x . dom(G1)n dom(G2)) .. REMARK 14. \nWe currently syntactically separate reference types from value types. However, this separation obviously \nG1(x)(x . dom(G1)\\dom(G2)) . prevents a lock and a thread ID from being stored in heap G2(x)(x . dom(G2)\\dom(G1)) \n. because this requires a type like ((G,0) lock1)ref 1, which does not conform the grammar. Relaxing \nthis restriction is left as future work. Before explaining typing rules, we need several auxiliary de.nitions \nand operations on types and type environments. DEFINITION 15. The sets FV(t)and FV(G) of free vari\u00adables \nof a type t and a type environment G, respectively, are de.ned by: FV(.)= \u00d8 FV((G,f1)lockf2 )= FV(G) \nFV(G tidf)= FV(G) FV(G) = (FV(G(x)) .{x}). x.dom(G) DEFINITION 16. We write G,x : t for the type environment \nG[x . t]if x/. FV(G) and FV(t) . dom(G). We say G is well-formed (written wf (G)) if G can be written \nas Note that the sum t1 + t2 is de.ned only if t1 and t2 are the same kind of types; moreover, when a \nsummand is a lock or thread ID type, their procurable type environments have to be identical. For example \n({x . 0},0) lock1 + ({x . 0},1) lock0 =({x . 0},1) lock1. How\u00adever, none of ({x . 0},0) lock1 +({x . \n1},0) lock1, ({x . 0},0) lock1 +({x . 0,y . 1},0) lock1, or 0 + ({x . 0},0) lock1 is de.ned.  5.2 Typing \nLet T be a function type environment, which is a .nite mapping from variables to function types of the \nform (x1 : '' t1,...,xn : tn) . (t1,...,t ). A function type is de\u00ad n pendent so that a parameter type \ncan mention a preceding parameter in its procurable type environment. Although it returns no value in \nour target language, a function (im\u00ad x1 : t1,...,xn : tn x andt. The condition x ./FV(G) and FV(t) . \ndom(G) xx for some plicitly) returns some ownership held by parameters back to the caller. For example, \na function type (x : . ref 0,y : ((x : .ref 1),0) lock1). (.ref 0,((x : .ref 1),0) lock1) means that, \nin order to add a new type declaration to a describes a function that takes a pointer x and a lock to \nob\u00ad tain ownership to access x;when it returns the same owner\u00adtype environment, the variable has to be \nfresh and, if the newly added type is a lock/tid type, then its procurable ship will be returned to the \ncaller. As explained in Section 2, a type judgment is of the form T;G . s . G ' , whose intuition has \nalready been given. DEFINITION 19 (Typing for Commands). The judgment type environment can mention only \npreceding variables. So, intuitively, well-formedness of a type environment means that bindings can be \nsorted so that the type of a variable mentions only preceding variables. We assume that every type environment \nis well formed in what follows. We next de.ne emptiness of types and type environments. Intuitively, \na value of an empty type can be discarded imme\u00addiately because there is no obligation to deallocate. \nDEFINITION 17 (EmptyTypes/TypeEnvironments). Atype t is empty, written empty(t), if t is either (G,0) \nlock0 for some G, or G tid0 for some G, or a reference type 0. A type environment G is empty, written \nempty(G), if empty(G(x)) for any x . dom(G). We also de.ne summation on types and type environ\u00adments \nto formalize splitting and merging ownerships. DEFINITION 18 (SummationofTypes/TypeEnvironments). Value \ntype t1 + t2 is de.ned by: .1 + .2 = . where .(p)= .1(p)+.2(p)for any p (G,f1)lockf2 + (G,f3)lockf4 = \n(G,f1 + f3)lockf2 +f4 Gtidf1 +G tidf2 =Gtidf1 +f2 T;G . s . G ' is the least relation that is closed \nunder the rules inFigures6 and 7. Typing rules for sequential commands. The typing rules in Figure 6 \nare rules for values and sequential commands. Rule T-NULL means that a null pointer can be given any \nreference type. Rules T-NULL and T-VAR require G to be empty since variables in it are not used here. \nRules T-SKIP and T-SEQ are straightforward. In T-LET, the type of x in the post type environment has \nto be empty since ownerships on x should not be left after the scope of x ends here. Similar emptiness \nconditions are found in typing rules for commands involving variable binding. Rule T-APP expresses standard \ndependent function application. In rule T-MALLOC, x is given type 0 ref 1 in the pre type environment \nof the body s. Recall the intuition of ownership 1 explained in Section 3 that, when a new cell is allocated, \n(1) exclusive access through x is granted and (2) obligation to deallocate the cell through x in future \nis imposed. Since the content of the newly-created cell should not be used until initialization has been \ndone, the type of a value pointed to by x is 0. Rule T-FREE is basically the converse of T-MALLOC.  \nG . v : t empty(G) G . null : . (T-NULL) empty(G) G,x : t . x : t (T-VAR) T;G . s . G ' T;G . skip \n. G (T-SKIP) T;G1 . s1 . G3 T;G3 . s2 . G2 (T-SEQ) T;G1 . s1;s2 . G2 ' G1 . v : t1 T;G2,x : t1 . s . \nG3,x : t empty(t ' ) x/. FV(G1) (T-LET) T;G1 +G2 . let x = v in s . G3 dom(G) = dom(G ' )= {y1,...,yn} \n' G(yi)=[y1,...,yi-1/x1,...,xi-1]ti for each i G ' (yi)=[y1,...,yi-1/x1,...,xi-1]t for each i i (T-APP) \n T;f :(x : t). (tx' );G+G '' . f(y). G ' +G '' xxx T;G1,x : 0 ref 1 . s . G2,x : 0 T;G,x : 0 ref 1 . \nfree(x). G,x : 0 (T-FREE) (T-MALLOC) T;G1 . let x = malloc() in s . G2 T;G1,y : .1 ref f,x : .2 . s \n. G2,x : 0 f> 0 (T-DEREF) T;G1,y :(.1 + .2)ref f . let x = *y in s . G2 T;G,y : 0 ref 1,x : .1 + .2 \n.*y . x . G,y : .1 ref 1,x : .2 (T-ASSIGN) G1(x)= .ref f T;G1[x . .1]. s1 . G2 T;G1 . s2 . G2 (T-IFNULL) \n T;G1 . ifnull(x)then s1 else s2 . G2 '' t1 + t2 = t 1 + t2 (T-ASSERTEQ) '' T;G,x1 : t1,x2 : t2 . assert(x1 \n= x2). G,x1 : t1,x2 : t 2 .1 + .2 = .1 ' + . ' f> 0 2 (T-ASSERTEQDEREF) T;G,x1 : .1,x2 : .2 ref f . \nassert(x1 = *x2). G,x1 : . ' 1,x2 : .2 ' ref f Figure 6. Typing rules for sequential commands. The type \nof x becomes 0 in the post type environment to prevent accesses to the deallocated cell. Rules T-DEREF \nand T-ASSIGN check if there is enough ownership on the type . ref f of y in the pre type en\u00advironment \nof the conclusion, in order to perform reading (f> 0)and writing(f =1), respectively. When a pointer \nis derefeneced, the content of the memory cell pointed to by y is copied to x, and so the original ownership \nof the pointer stored in the memory cell is (partially) transferred to x. The type .1 + .2 expresses \nthe original ownership and it is split for x. Conversely, in assignment, the assigned value x is copied \nto the memory cell that y points to, so the own\u00adership on x is split. Moreover, the pointer that y points \nto should have the empty (pointer) type, because no obligation should be left for the old content before \nassignment. Owner\u00adship splittings at these rules arekept non-deterministic. The implementation in Section \n6.4 chooses one of the possible splittings with an SMT solver. Rule T-IFNULL ensures that the post type \nenvironment of the two clauses are the same. The rule also allows the then clause to use x as any type \nbecause x is null in this clause (c.f. T-NULL). Rules T-ASSERTEQ and T-ASSERTEQDEREF describe how the \ntype system exploits must-alias annotations. For '' example, in T-ASSERTEQ, the condition t1 + t2 = t \n1 + t2 makes it possible to shuf.e ownerships between x1 and x2, and thus enables the type system to \ntransfer a part of ownership from one to the other. The following command (written in slightly changed \nsyntax to save space) shows how this rule works: let x = malloc() in let y = x in f(*y);f(*x);assert(x \n= y);free(x).  T;G . s . G ' (cont d.) T;G1,x : (G2,0) lock1 . s . G3,x : t empty(t) T;G1 + G2 . let \nx = newlock() in s . G3 (T-NEWLOCK) T;G1,x : (G2,0) lock1 . freelock(x). (G1,x : (G2,0) lock0)+ G2 (T-FREELOCK) \nf > 0 T;G1,x : (G2,0) lockf . acq(x). (G1,x . (G2,1) lockf)+ G2 (T-ACQ) f > 0 T;(G1,x : (G2,1) lockf)+ \nG2 . rel(x). G1,x : (G2,0) lockf (T-REL) T;G1 . s1 . G ' 1 T;G2,x : G ' 1 tid1 . s2 . G ' 2,x : t empty(t) \nT;G1 + G2 . let x = fork(s1)in s2 . G ' 2 x /. FV(G1) (T-FORK) T;G1,x : G2 tid1 . wait(x). (G1,x : G2 \ntid0)+ G2 (T-WAIT) s . D Figure 8. Typing rules for programs. Figure 7. Typing rules for concurrency-related \ncommands. '' T;x1 : t1,...,xn : tn . s . x1 : t1,...,xn : t n (T-FUNDEF) '' T . f( x) s :T(f)for each \nf( x s :(x1 : t1,...,xn : tn ). (t 1,...,t ) n = x x)x) x Without the assertion, this example would \nnot typecheck, because both x and y have a positive ownership and thus the ownership of x is not 1, required \nto free. However, thanks to assert(x = y), which lets the type system transfer the ownership of y to \nx, the type of x before free(x) is 0 ref 1, which allows free. Note that it is not a responsibility of \nthis type system to ensure the correctness of must-alias assertions. If an incorrect assertion is inserted, \na program may reduce to AssertFail and the type system guarantees nothing. Typing rules for concurrency-related \ncommands. Fig\u00adure 7 shows the typing rules for concurrency-related com\u00admands. The .rst four rules concern \nlock manipulation. Rule T-NEWLOCK splits the ownerships of the current thread into two (G1 and G2), and \ndeposit one of them (G2) in the newly-created lock type as its procurable type environ\u00ad T . f(= = . \nD:T . D:T T;\u00d8. s .\u00d8 dom(T) = dom(D) (T-FUNENV) (T-PROG) . (D,s)ok ment(x : (G2,0) lock1). The release \nownership part of the lock type is 0 because the lock is initially in the state .. The lock ownership \npart is 1, which means that only this thread is currently allowed to access this lock and the lock has \nto be deallocated in future. Rule T-FREELOCK is sim\u00adilar to T-FREE; it also requires the release ownership \nof x to be 0 because, after executing freelock(x), the pro\u00adgram cannot release the lock. As its post \ntype environment shows, the current thread acquires the procurable type en\u00advironment that has been deposited \nto the type of x. Rules T-ACQ and T-REL are straightforward once the meaning of procurable type environments \nand release ownership is un\u00adderstood. Acquiring a lock borrows ownerships deposited in the lock; the \nprocurable type environment G2 added to the post type environment expresses this. Releasing a lock re\u00adturns \nthe borrowed ownership back to the lock. To express this, the procurable type environment G2 at the pre \ntype envi\u00adronment is removed at the post type environment. Note also thatthe releaseownershipsat these \nrulesareset accordingto the intuition explained in Section 3: The release ownership of x is 1 at the \npost type environment of T-ACQ, while it is 0at T-REL.  The next two rules concern thread manipulation. \nRule T-FORK means that the ownerships the current thread holds are split into two(G1 and G2)and oneof \nthem(G1)is given to the spawned thread (as its pre type environment). The type of x in the pre type environment \nof s2 is G ' 1 tid1, where G ' 1 is the post type environment of s1. It expresses that the ID of the \nchild thread has to be passed to wait afterwards, and that the thread that waits the spawned thread will \nbe granted G ' 1 the ownerships left after the execution of the spawned thread s1 as expressed by rule \nT-WAIT. Note that we do not force a spawned thread to use up or preserve the ownerships initially given. \nExample. We show a typing example using the command continuation (that is, let c = fork(loop(p,q,l))in \n\u00b7\u00b7\u00b7): G _ _ T; p: 0 ref 0 ,q : 0 ref 1,l : (( p: 0 ref 1 ),0) lock1 . let c = fork(loop(p,q,l))in \u00b7\u00b7\u00b7 \n. p: 0,q : 0,l : ((p: 0 ref 1),0) lock0 T;p: 0 ref 1 ,q : 0 ref 1 . T-NEWLOCK let l = newlock() in let \nc = fork(loop(p,q,l))in \u00b7\u00b7 \u00b7 . p: 0,q : 0 Let Gl = p: 0 ref 1 in what follows. The next rule is T-FORK. \nHere, the pre type environment G is split into two: one for the continuation of the main thread and one \nfor the spawned thread. In both threads, q is used for reading (without using locks) and lis used for \nlock\u00ading, so the ownerships of q and l in both type enviroments must be greater than 0. In the following \nderivation step we in Example 4. First, let use G .rst two steps (counted from the root) are as follows: \n= p:0,q:0 ref 0.5,l:(Gl,0) lock0.5, which satis.es 1 2 G =G+G 1 : 1 T= loop:(p: 0,q : 0 ref 0.5,l : ((p: \n0 ref 1),0) lock0.5) . (0,0 ref 0.5,((p: 0 ref 1),0) lock0.5). 2 2 tid1 . loop(p,q,l); \u00b7\u00b7\u00b7 T;G 1 ,c \n:G 1 2 2 The type of loop means that the function loop takes two . p: 0,q : 0,l : (Gl,0) lock0,c :G \n1 2 tid0 references p, which cannot be accessed at .rst, and q, which . loop(p,q,l). GT;G 11 22 is read-only, \nand one lock l. This lock type means that (1) the lock is not acquired yet; and (2) it gives a full ownership \non p, once the lock is acquired. At the end of loop, the ownership of these resources are returned unchanged. \nThe command (we call it s)is typed under the empty pre and post type environments: T;\u00d8. s .\u00d8. Now, let \ns take a look at main parts of its derivation tree. The T;G . let c = fork(loop(p,q,l))in \u00b7\u00b7\u00b7 T-FORK \n. p: 0,q : 0,l : (Gl,0) lock0 Also it is important to notice that the post type environment for the new \nthread body and the procurable type environment for the thread ID c agree, as shaded boxes show. Figure \n9 shows the pre type environment for each sub\u00adcommand as comments.We can observe that 1. after wait(c), \nthe procurable type environment G 1 2 inc s type is merged and so q sownershipis1in the post type environment; \nT;p: 0 ref 1,q : 0 ref 1 . let l = newlock() in \u00b7\u00b7 \u00b7 . p: 0,q : 0 2. similarly, after freelock(l), the \nprocurable type environ- T-MALLOC T;p: 0 ref 1 . let q = malloc() in \u00b7\u00b7 \u00b7 . p: 0 ref 0 T-MALLOC T;\u00d8. \nlet p= malloc() in let q = malloc() in let l = newlock() in \u00b7\u00b7\u00b7 . \u00d8 In the pre type environment for \nlet l = newlock() in \u00b7\u00b7\u00b7, full ownership (i.e., 1) is assigned to p and q, while no ownership is assigned \nin the post. The next rule is T-NEWLOCK. Here l is supposed to guard any access to p, the procurable \ntype environment in the type of lshould include p:0 ref 1 whereas no ownership is left for p in the pre \ntype environment (called G) for the ment Gl in l s type is merged and so p sownership is1in the post \ntype environment. (Note that when two commands s1 and s2 are combined with ; , the pre type environment \nfor s2 is the post for s1.) Typing rules for programs. A type judgment for a pro\u00adgram is of the form \n. (D,s) ok, which means that, if a program starts its execution from the main command s, the program \nrespects types and ownerships in anyscheduling. It is de.ned via typing for functions. DEFINITION 20 \n(Typing for Programs). . (D,s)ok is the leastrelation that satis.es the rulesinFigure8. Rule T-FUNDEF \nis straightforward. The condition that a parameter can depend on preceding parameters is guaranteed by \nthe formation of type environments (recall that G,x : t is de.ned only when x . FV(G) . FV(t)). Rule \nT-FUNENV  /*\u00d8* / let p= malloc() in /* p: 0 ref 1 * / let q = malloc()) in /* p: 0 ref 1,q : 0 ref 1 \n* / let l = newlock() in /* p: 0,q : 0 ref 1,l : (Gl,0) lock1 * / let c = fork(loop(p,q,l))in / * p: \n0,q : 0 ref 0.5,l : (Gl,0) lock0.5,c :G tid1 * / loop(p,q,l); 1 21 2 / * p: 0,q : 0 ref 0.5,l : (Gl,0) \nlock0.5,c :G tid1 * / wait(c); /* p: 0,q : 0 ref 1,l : (Gl,0) lock1 ,c :G 1 2 tid0 * / freelock(l); \n/ * p: 0 ref 1 ,q : 0 ref 1,l: (Gl,0) lock0 ,c :Gtid0 * / free(p); 1 2 1 2 1 2 / * p: 0 ,q : 0 ref \n1,l : (Gl,0) lock0,c :G tid0 * / free(q) / * p: 0,q : 0 ,l : (Gl,0) lock0,c :G tid0 * / Figure 9. Typing \nexample. is essentially a standard typing rule for mutually recursive functions. Rule T-PROG checks that \n(1) the functions de.ned in D are well-typed and the types of those functions are described by some T, \nand (2) the main command s is well-typed under Tand the empty pre and post type environments.  5.3 Soundness \nof the type system The type soundness theorem is stated as expected: THEOREM 21 (Type Soundness). If \n. (D,s) ok, then Safe(D,s). This theorem is proved in the standard manner: subject reduction and lack \nof immediate errors. For subject reduc\u00adtion, we de.ne typing for con.gurations by using an auxil\u00adiary \nde.nition. DEFINITION 22. The function PTE takes a process type and returns its PTE part; it is de.ned \nby PTE(G tidf)=G. DEFINITION 23 (Typing for Con.gurations). The typing re\u00adlation for con.gurations T;G \n.D Conf ok is de.ned by the rule inFigure 10. Rule T-CONFIG basically imposes that each thread re\u00adspects \nthe function type environment T and its pre type en\u00advironment. The highlights of the rule are as follows. \n The post type environment of the main thread . has to be empty, which is crucial for resource-leak-freedom. \n The condition ConOwn(Conf ,G), which essentially means that, for each thread ID, lock, and pointer, \nthe sum of ownerships held by the threads is exactly 1, so that ev\u00adery resource is eventually deallocated \nbefore termination.  The condition acyclic(xt, Gx',R) imposes that there is no circular dependency among \nthe threads in Conf . We need this condition to ensure that the thread pool becomes {. . skip} leaving \nno other threads when the program terminates.  The last conditions means that, for each binding of the \nform x :G ' tidf in G, where the value of x is theIDof i-th thread, G ' is equal to the post type environment \nG ' of i si modulo empty types. This condition is necessary for a thread not to die without returning \nall the non-empty ownerships. The precise de.nitions of ConOwn and acyclic are given in the full version. \nTheorem 21 is proved by showing (1) the initial con.gu\u00adration is well-typed (Lemma 24), (2) well-typedness \nis pre\u00adserved by reduction (Lemma 25) and (3) a well-typed con\u00ad.guration is safe (Lemma 26). Then, the \ntheorem is easily proved. LEMMA 24 (Initial Con.gurationisWellTyped). If . D : Tand T;\u00d8. s .\u00d8, then T;\u00d8.D \n({. . s} ,\u00d8,\u00d8,\u00d8)ok. LEMMA 25 (Subject Reduction for Con.gurations). If ' T;G .D Conf ok and Conf . Conf \n, then there exists G ' ' such that T;G ' .D Conf ok. LEMMA 26 (Immediate Safety). If T;G .D Conf ok, \nthen Safe(Conf ).  6. Type inference We present a constraint-based type inference algorithm for the \ntype system. The algorithm takes a simply typed pro\u00adgram, generates a set of constraints for the program \nto be well-typed, and then tries to solve it. The idea of the type inference algorithm is basically the \nsame as the previous one presented in [13]; reducing con\u00adstraints on types into a system of linear inequalities. \nHow\u00adever, in the current type system, a challenge consists in how to infer an appropriate PTE for each \nlock and thread ID type. To this end, we designatetype environment variables, which represent unknowns \non PTEs, and use them forbuilding con\u00adstraints on (procurable) type environments. In the rest of this \nsection, we assume that input to the type inference algorithm is a simply typed program, and  each bound \nvariable and assert command is annotated with . D:T P(Conf )= {t1 . s1,...,tn . sn} T;Gi . si . G ' \nfor each i .{1,...,n} i ti = . implies empty(G ' ) G=G1 + \u00b7\u00b7\u00b7 +Gn ConOwn(Conf ,G) acyclic(xt, Gx' ,R) \ni For anyx . dom(R(Conf )) such that R(Conf )(x)= ti, G ' i = PTE(G(x))+G '' and empty(G '' )for some \nG '' (T-CONFIG) T;G .D Conf ok Figure 10. Typing rule for con.gurations. s ::= . . . | let x : a = y \nin s | let x = null in s | asserta(x = y) d ::= f( x : a)= s a (Simple types) ::= ref | lock | tid Figure \n11. Revised syntax for type inference. (Only ex\u00adtended or overridden parts are presented.) q ::= + q2 \nf | . | q1 +t ::= (\u00b5a.aref q2 )ref q1 | (GG,q1)lockq2 | G tidq G ::= x : t G x| x. | [\u00ad G ::= y/x]. c \n::= empty(xt)x| empty(G +dom(.)) .. \\ .| == >q2 .1 +.2 | q1 +q2 | q1 +| = .{x} G1 +G2 +dom(.)+ + . | \n.x |{dom(.) xx}.+. | dom(.)+dom(. ' ) .. . | dom(.)-+[y/.dom(. ' ) .Txxx]; T ::= f :(x : t). (tx') xxx \n. . OVar . . EVar Figure 12. Syntax of constraint language. its simple type; Figure 11 shows the syntax \nof commands, function de.nitions and simple types with those annotations. Those simple types can be inferred \nby straightforwardly adapting standard techniques [11] to our language. We also assume that bound variables \nare different from each other. We write stype(x)for the simple type assigned to x. 6.1 Syntax and semantics \nof constraints Figure 12 shows the syntax of constraint language. In or\u00adder to distinguish the constructors \nof expressions in the con\u00adstraint language from the predicates and the operators in\u00adtroduced in the previous \nsection, we put +\u00b7 on the constraint language constructors. qranges over ownership expressions. .represents \nan un\u00adknown for an ownership, which is a member of a countably in.nite set OVar. q1 + + q2 represents \nsummation of owner\u00adships. t is the meta-variable for type expressions and represents a value type that \nmay contain unknowns for ownerships or type environments. Expressions (GG,q1)lockq2 , G tidq and (\u00b5a.a \nref q2 ) ref q1 represent lock types, thread ID types and reference types respectively. Here, G is a \ntype environ\u00adment expression (see below). In order to simplify the type inference algorithm, we .x the \nshape of reference types; we deal with only reference types that can be expressed by recursive type expression \n(\u00b5a.a ref q2 ) ref q1 . More con\u00adcretely, the type expression (\u00b5a.a ref q2 )ref q1 represents a recursive \ntype . that satis.es .(o)= q1 and .(p)= q2 for p .{0}+. We can enhance the power of the type in\u00adference \nalgorithm by using more expressive type expression such as (\u00b5a.a ref q1 )ref q2 ... ref qn for a .xed \nn, and the type inference algorithm can be easily adapted for those ex\u00adpressions. The meta-variable G \nranges over the set of type environ\u00adment expressions. . ranges over the countably in.nite set EVar of \ntype environment variables and denotes an un\u00adknown (procurable) type environment. [\u00ad y/x]. represents \nre\u00ad xx naming of (procurable) type environment denoted by ..We require that both x and y are pairwise \ndistinct sequences. xx The meta-variable c represents a constraint. The con\u00adstraint syntax is designed \ncarefully so that it is suf.cient for a reasonably simple type inference. empty(t) expresses . emptiness \nof t. .1 +.2 expresses equality of .1 and .2. = q1 +>q2 are on ownerships. Note = q2 and q1 +constraints \nthat the ownership constraints expressible in the constraint language consist of only linear inequalities \non ownership variables. The constraint G1 +G2 + =+ . represents equality between the type environment \ndenoted by G1 and the sum of G2 and .. .dom(.)) expresses that the type envi\u00ad empty(G+\\ .ronment denoted \nby G+\\ .dom(.) +x}, dom(.)is empty. ..{ .x dom(.).+.dom(.) +y/x]dom.(. ' ) dom(. ' )and .. [-are set\u00ad \nxx inclusion constraints among the domains of type environ\u00adments.We usea meta-variable C for sets of \nconstraints. .n.n .,a valuation, ranges over (OVar . Q=0). (EVar . TEnv). Here, TEnv is the set of type \nenvironments. Denotational semantics of ownership expressions, type expressions and type environment \nexpressions are de.ned in Figure 13. We write |= C if there is a valuation . such that . |= C.  6.2 \nConstraint generation The .rst step of the type inference algorithm is constraint generation. Given a \nprogram, this phase generates a set of  [ f] . = f [ .] . = .(.)[ q1 ++q2] . =[ q1] . +[ q2] . [ q1 \n-+q2] . =[ q1] . - [ q2] . [[(GG,q1)lockq2 ] = ([[GG]].,[ q1] )lock[ q2 ] [[GGtidq] =[ GG]]tid[ q] .... \n.. [[(\u00b5a.aref q2 )ref q1 ] = . where .(e)=[ q1] and .(0p)=[ q2] for anyp . .. - [[(x : t)]]=(x : [[ \nt] ) [ .] = .(.) [ [y/x].] =[y/x][[.] ... .. xxxxxxx [[(x : t). (tx' )]]=(x :[ t] ). ([[tx'] ) . .. \nxxxx [[T] = {f . [[T(f)]]} . .f.dom(T) . |= empty(t)iff. empty([[t] ) . |= .{x} iff. dom([[.] ).{x} dom(.) \n+ .. xx . |= empty(G +\\ dom(.)) iff. empty([[G]]\\dom([[.] )) . |= {. dom(.)iff. {x}. dom([[.] ) ..x} \n+. [[G1] . =[[G2] . +[ .] . and . |= dom(.) x.+dom(. ' )iff. domx([[.] ). dom([[. ' ] ) . |= =+ . iff. \n.. G1 +G2 +dom([[G1] )= dom([[G2] ) ..-\u00ad . |= dom(.).+[y/x]dom(. ' )iff. dom([[.] ). dom([[[y/x]. ' \n] ) .. . |== .2 iff. [ .1] =[ .2] xxxx .1 + .. . |= C iff. . |= c for every c . C . |== q2 iff. [ q1] \n=[ q2] q1 + .. . |= = q2 iff. [ q1] > [ q2] q1 +.. Figure 13. Denotation of constraint language expressions. \n. '' ((\u00b5a.aref q2 )ref q1 =(\u00b5a.aref q ' )ref q ' )= {q1 = +q1,q2 = +q2} G ' 21 .. ' '' ' ((GG,q1)lockq2 \n= (G,q1)lockq ) = (GG =G ' ).{q1 = +q1,q2 = +q2} .. (GGtidq =G ' tidq 2 ' ) = (GG =G ' ).{q = q ' } + \n.. ' ((xx: tx)=(xx. : tx')) = i(ti = ti) (.1 = .2)= {.1 = +.2,dom(.1).+dom(.2),dom(.2).+dom(.1)} . ----} \n(.1 =[y/x].2)= {.1 = +[y/x].2,dom(.1).+[y/x]dom(.2),dom(.2).+[x/y]dom(.1) xxxxxxxx .. - ([y/x].1 =GG) \n=(.1 = (x/y)GG) xx.. xx - (G =[y/x].) =(. = (x/y)G) . xx. xx (. =G) =(G = .)= C1 . C2 . C3 where G ' \n,C1 = rename ovars(G) {} C2 = empty(G ' (x)) | x . dom(G ' ) C3 = {G =G ' + .,dom(.).+dom(G),dom(G) .+dom(.)} \n. + . G1 =G2 +G3 = C1 . C2 where G ' ,C1 =G2 +G3 and C2 = (G1 =G ' ) .. . Figure 14. De.nitions of t1 \n= t2 and G 1 =G 2 and G1 =G2 +G3. constraints that make the program well-typed. Before elabo\u00adrating this \nphase, we introduce several auxiliary de.nitions. DEFINITION 27. rename ovars is a function that takes \n' an exprssion X and returns a pair X ' ,C, where X is an expression that is obtained by replacing every \nown\u00adership in X with a fresh ownership variable and C is{.i =+. ' | (\u00b5a.aref . ' )ref .i appears in X \n'}. i i The constraint set that rename ovars returns guarantees the restriction on reference types that \n.(p) =0 implies .(p0) =0mentioned in Section 5.1. DEFINITION 29. The operator (y/x) is de.ned as follows. \nxx (y/x)(\u00b5a.aref q2 )ref q1 =(\u00b5a.aref q2 )ref q1 xx (y/x)(G,q1)lockq2 = (((y/x)G),q1)lockq2 xxxx (y/x)Gtidq \n=((y/x)G) tidq xxxx (y/x)(x1 : t1,...,xn : tn)= xx (x1 : (y/x)t1,...,xn : (y/x)tn) xxxx DEFINITION 28. \n(x:t)|{jy}is de.ned to be xi1 :ti1 ,...,xin : xx tin where {xi1 ,...,xin } = {x}n{y}. xx  C(T,s,Gpost \n)=(Gpre ,C) C(T,skip,Gpost )=(Gpost ,\u00d8) C(T,s1;s2,Gpost )=(Gpre ,C1 . C2)where G ' ,C1 = C(T,s2,Gpost \n) Gpre ,C2 = C(T,s1,G ' ) C(T,let x : a = y in s,Gpost )=(Gpre ,C1 . C2 . C3)where t = template(a) t \n' ,C2 = (G ' (x)+G ' (y)) x G ' ,C1 = C(T,s,(Gpost ,x : t)) = {} C3 empty(t) Gpre = (G ' \\{x,y} ,y : \nt ' ) C(T,let x = null in s,Gpost )=(Gpre ,C)where G ' ,C = C(T,s,(Gpost ,x :(\u00b5a.aref 0)ref 0)) Gpre \n=G ' \\{x} C(T,f(y),Gpost )=(Gpre ,C1 . C2 . C3 . C4)where ' (x : tx). (tx' )=T(f) C3 = (Gpost = . (y/x)tx+G \n' ) xx. xx G ' ,C1 = rename ovars(Gpost ) C4 = (Gpre = (y/x)t +G ' ) xxx Gpre ,C2 = rename ovars(Gpost \n) C(T,let x = malloc() in s,Gpost )=(Gpre ,C1 . C2)where G ' ,C1 = C(T,s,(Gpost ,x :(\u00b5a.aref 0)ref 0)) \n. C2 = (G ' (x)=(\u00b5a.aref 0)ref 1) Gpre =G ' \\{x} C(T,free(x),Gpost )=(Gpre ,C)where Gpre =Gpost [x . \n(\u00b5a.aref 0)ref 1] . C = (Gpost (x)=(\u00b5a.aref 0)ref 0) C(T,let x = *y in s,Gpost )=(Gpre ,C1 . C2)where \n.,.1,.2 are fresh G ' ,C1 = C(T,s,(Gpost ,x :(\u00b5a.aref 0)ref 0)) .. } C2 = (G ' (x)=(\u00b5a.aref .)ref .). \n(G ' (y)=(\u00b5a.aref .2 )ref .1 ). {.1 >+0,.1 =+.2 Gpre = (G ' \\{x})[y . (\u00b5a.aref +.2 )ref .1 ] .: C(T,*y \n. x,Gpost )=(Gpre ,C)where .1,.2,.3 are fresh .. } C = (Gpost (x)=(\u00b5a.aref .3 )ref .2 ). (Gpost (y)=(\u00b5a.aref \n.1 )ref 1). {.2 =+.3 Gpre =Gpost [y . (\u00b5a.aref 0)ref 1][x . (\u00b5a.aref .1 +:.3 )ref .1 :] +.2 C(T,ifnull(x)then \ns1 else s2,Gpost )=(G2,C1 . C2 . C3)where .1 and .2 are fresh G1,C1 = C(T,s1,Gpost ) G2,C2 = C(T,s2,Gpost \n) .. } C3 = (Gpost (x)=(\u00b5a.aref .2 )ref .1 ). (G1\\{x} =G2\\{x}). {.1 =+.2 C(T,asserta(x = y),Gpost )=(Gpre \n,C1 . C2 . C3 . C4 . C5)where '' t1,t 2 =Gpost (x),Gpost (y) t,C4 = t1 + t2 . '' t ' ,C1 = t1 + t2 \nC5 =(t = t ' ) ' t1,C2 = rename ovars(t1)Gpre = G[x . t1,y . t2] ' t2,C3 = rename ovars(t2) C(T,assert(x \n= *y),Gpost )=(Gpre ,C1 . C2)where .1,.2,.,. ' 2,. ' are fresh .. C1 == =(\u00b5a.aref .2 )ref .1 ). {.1 >+0,.1 \n+} (Gpost (x)(\u00b5a.aref .)ref .). (Gpost (y) >.2Gpre = G[x . (\u00b5a.aref .' )ref .' ,y . (\u00b5a.aref . ' )ref \n.1 ] 2 C2 = {.++.2 = +. ' + . ' 2} + Figure 15. Constraint generation algorithm (cases for sequential \ncommands). C(T,s,Gpost )=(Gpre ,C) C(T,let x = newlock() in s,Gpost )=(Gpre ,C1 . C2 . C3)where G ' \n,C1 = C(T,s,(Gpost ,x :(.x,0) lock0)) Gpre ,C2 = rename ovars(Gpost ) . C3 = {Gpre = (G ' \\{x})++.x,dom(.x).+dom(Gpost \n)}. (G ' (x)=(.x,0) lock1) + C(T,freelock(x),Gpost )=(Gpre ,C1 . C2 . C3)where Gpre ,C1 = rename ovars(Gpost \n) . C2 = (Gpre (x)=(.x,0) lock1) C3 = {Gpost =Gpre [x . (.x,0) lock0]++.x} + C(T,acq(x),Gpost )=(Gpre \n,C1 . C2 . C3)where Gpre ,C1 = rename ovars(Gpost ) .is fresh . C2 = (Gpre (x)=(.x,0) lock.) C3 = {Gpost \n=Gpre [x . (.x,1) lock.]++.x,. >+0} + C(T,rel(x),Gpost )=(Gpre ,C1 . C2 . C3)where Gpre ,C1 = rename \novars(Gpost ) .is fresh . C2 = (Gpost (x)=(.x,0) lock.) C3 = {Gpre =Gpost [x . (.x,1) lock.]++.x,. >+0} \n+ C(T,let x = fork(s1)in s2,Gpost )=(Gpre ,C1 .\u00b7\u00b7\u00b7. C5)where G ' ,C1 = rename ovars(Gpost |FV(s1 )) \npost G1,C2 = C(T,s1,G ' ) post G2,C3 = C(T,s2,(Gpost ,x : .x tid0)) Gpre ,C4 = (G1 +G2\\{x}) } C5 = {FV(s1).+dom(.x),dom(.x. \ndom(Gpost ),empty(G ' \\ dom(.x)) ) +post +C(T,wait(x),Gpost )=(Gpre ,C1 . C2 . C3)where Gpre ,C1 = rename \novars(Gpost ) . C2 = (Gpre (x)= .x tid1) C3 = {Gpost = (Gpre \\{x} ,x : .x tid0)++.x} + C(D)=(T,C) C({fi(xi1 \n: ai1,...,ximi : aimi)= si})=(T, Ci)where ii tij = templatexij (aij)for each iand for each j.{1,...,mi} \n' t = template(aij)for each iand for each j.{1,...,mi} ij xij ' T =(fi :(xi : ti). (tx))i i xx Ci = \nC(T,fi(xi : ai)= si). wfarg (T(fi)) for each i x C(T,f(x)= s)= C C(D,s)= C x C(T,f(x)= s)= C where \nC(D,s)= C1 . C2 where (x : tx). (tx')=T(f)T,C1 = C(D) .xx. x '' \u00d8,C2 = C(T,s,\u00d8) tC = C(T,s, t') , xx \n: x '' ' C= i(t = ti) i ' C = Ci . C i Figure 16. Constraint generation algorithm (cases for concurrency-related \ncommands). (y/x)(t1,...,tn)= x.xy1 : t1, . y2 : (y1/x1)t2, .. .y3 : (y1,y2/x1,x2)t3, . . ..., . .. \nyn : (y1,...,yn-1/x1,...,xn-1)tn - (y/x). =[y/x]. xxxx - (y/x) [yx'/xx']. =([y/x]. [yx' /xx']).. xxxx \n- Here, [y/x]. [yx'/xx' ] represents the renaming constructor xx that corresponds to the composition \nof [y/x]and [yx' /xx']. xx - The operator (y/x) pushes the constructor [y/x]as inward xxxx as possible. \nIt also serves for creating pre/post type envi\u00adronments of a function call from a sequence of the types \nof function arguments; observe the correspondence between the de.nition of (y/x)(t1,...,tn)above and \nthe second and xx the third premises of T-APP in Figure 6. .. t1 = t2 (and G 1 =G 2), a set of constraints \nthat make t1 equal to t2 (and G 1 equal to G 2, respectively) are de.ned in Figure 14. The constraints \nalso include those on domains . of type environment expressions. G1 =G2 +G3 isa setof constraints that \nmake G1 equal to G2 +G3, which is de.ned below. .. Note that, in the cases of .1 =[y/x].2, [y/x].1 =G \n . xxxx - and G =[y/x]., creating (x/y) is legitimate because x xxxxx and y are both pairwise distinct \nsequences. Note also that x.. the de.nition of . =G and G= . are a little compli\u00adcated so that the generated \nconforms the syntax of the con\u00adstraint language; we generate a type environment G ' from G, generate \nconstraints that guarantee empty(G ' )and gen\u00aderate G =G ' + . that effectively expresses G= . given \n+ empty(G ' ). t1 + t2 (N.B., no \u00b7 on +)is a pair (t,C)where t is the + sum of t1 and t2, and C is constraints \nfor the sum to be well-de.ned. G1 +G2 is also de.ned accordingly. DEFINITION 30. t1+t2 and G1+G2 are \nde.ned as follows. ' (\u00b5a.aref q2 )ref q1 +(\u00b5a.aref q )ref q ' = 21 DEFINITION 31. De.ne template(a)as \nfollows: x template(ref )=(\u00b5a.aref .2 )ref .1 x where .1 and .2 are fresh. template(lock)=(.x,.1)lock.2 \nx where .1 and .2 are fresh. templatex(tid)= .x tid. where .is fresh. In the de.nition above, .x is the \ntype environment variable designated for the variable x. (See Remark 35 below.) domtyp(t)returns the \nexpression that corresponds to the domain of PTE inside t if exists. DEFINITION 32. domtyp(t)is de.ned \nas follows. domtyp((\u00b5a.aref q2 )ref q1 )= \u00d8 domtyp((GG,q1)lockq2 )= domtyp(GG) domtyp(GGtidq)= domtyp(GG) \ndomtyp((x : t)) = {x} xxx domtyp(.)= dom(.) domtyp([y/x].)=[y/x]dom(.) xxxx Constraint set wfarg(x1:t1,...,xn \n:tn)is used for well\u00adformedness of function argument types. DEFINITION 33. Let wfarg(x1 :t1,...,xn :tn)be \nthe con\u00adstraint set .domtyp(t1) +. .\u00d8, domtyp(t2) + .{x1} , . . .. domtyp(t3) + .{x1,x2} , ..., . . \n .domtyp(tn.{x1,...,xn-1} . ) +. We writewfarg ((x:t). (tx')) for wfarg(x:t).wfarg(x:tx ') xxxxx and \nwfarg(T)for f.dom(T)wfarg (T(f)). The constraint generation algorithm C is de.ned in Fig\u00adures 15 and \n16. The core of the algorithm takes a function type environment T, a command s and a post type environ\u00adment \nGpost as input, and returns a pre type environment Gpre and a set of constraints C. The way of deriving \nC from the typing rulesin Section5is standard.Weaddexplanationto ,\u00d8)((\u00b5a.aref )ref several non-trivial \ncases. ' ' : +q2 1)lockq : 1 +q2 G '' + (G,q q q1 (GG,q1)lockq2 ' = 2 Case s = let x : a = y in s0: The \nalgorithm creates a fresh . ' G ' ))((G,q1 ++q1)lock ,(GG = : +q ' G tidq +G ' tidq = extends Gpost \nwith x : t and recursively passes it to . ' type expression t from the simple type annotation a, q2 2 \nG ' )) (G tid ,(GG = C with the subcommand. From the returned pre type : +q environment G ' , the algorithm \nproduces the type of y, t(1)t(3)t(4))G ' (x)+G ' (y), in the pre type environment of the whole (x : \n[,yt(2))+(y,z : [= : [: [ xxxx t(1)' t(3)), xinput Gpre . Note that, from the syntax of the constraint \n((x : [,y: tx,z : [C)where xxxlanguage, G ' in G ' (x),G ' (y)and G ' \\{x,y} is neither . x n y = yn \nz = z n x = \u00d8 - xxxxxxnor [y/x].. ' t(2) t(3) C = . tx, x[+ [xx Case s = f(y): The algorithm creates \ntwo type environ\u00ad x templatex(a)is a value type whose ownership and PTE ments G ' and Gpre from Gpost \nby rename ovars. Opera\u00adpart are left unknown. tor (x/y) is used to generate the constraints on pre/post \nxx type environments from the types of function arguments. ' q1 1  Case s = let x = *y in s0: The idea \nis the same as the pre\u00advious case; create a fresh type expression, extend Gpost , pass it to the recursive \ncall and calculate the type of x in Gpre from the output of the recursive call. However, in the cases \nin which reference types are involved, we have to be aware that the type of x in the returned G ' is \nof the shape (\u00b5a.a ref .)ref . due to our assumption on the shape of reference types. Case s = let x \n= newlock() in s0: We need to express the conditions on type environments in T-NEWLOCK in this case. \nTo do that, we generate the constraint Gpre = (G ' \\{x})++.x. .x is the type environment vari\u00ad + able \ndesignated for the variable x. Case s = let x = fork(s1)in s2: The algorithm restricts the domain of \nGpost with FV(s1), renames its owner\u00adship part and passes it to the recursive call for s1. The passed \ntype environment G ' subjects to empty(G ' \\ post + dom(.x));with this constraint and the following lemma, \nit is guaranteed that the conditions in T-FORK are met. LEMMA 34. If T;G1 . s . G2, then dom(G1)= dom(G2). \nIf T;G1 . s . G2 and empty(t)and x/. FV(T). FV(G1). FV(s). FV(G2), then T;G1,x:t . s . G2,x : t. Proof \nSketch Both follow from induction on the deriva\u00adtion of T;G1 . s . G2. .. REMARK 35. The type inference \nalgorithm makes use of the property of the type system that, under the assumption that a bound variable \nis different from each other, the PTE assigned to each lock/pid-typed variable is globally unique (i.e., \nno .ow-sensitivity on PTE). Thanks to this property, the de.nition of template(lock)and template(tid)can \nxx assign the unique type environment variable for eachx. This design decision simpli.es the type inference \nalgorithm. The following lemma guarantees soundness of this step; it says that if a constraint set C \ngenerated by the algorithm C satis.es |= C, then the input program is indeed well-typed. LEMMA 36 (Soundness \nof C). If C(T,Gpost ,s)=(Gpre ,C) and . |= C, then [ T] ;[ Gpre ] . s . [ Gpost ] .. ..  6.3 Constraint \nreduction The next step of the type inference is to .nd a valuation . such that . |= C holds for the \nconstraint set C returned by C. This constraint reduction phase .rst determines the domain of each type \nenvironment variable and decomposes the constraints into ones on ownership variables. Then, the resulting \nconstraints are solved by a linear inequality solver. Step 1: Deciding the domain of type environment \nvari\u00adables The constraint reduction phase .rst reduces those set-inclusion constraints(dom(.) +x}, {. \ndom(.), .{x} + xx - dom(.).+dom(. ' )and dom(.).+[y/x]dom(. ' ))by cal\u00ad xx culating the domain of each \ntype environment variable and instantiating it with a type environment template with fresh ownership \nvariables. In calculating the domain, we calculate particularly the greatest domain allowed to each type \nenvi\u00adronment variable. This is justi.ed by the observation that, intuitively, taking the larger domain \nfor a type environment variable is safe estimation; even if the domain turns out to be larger than necessary, \nthe types of the redundant variables can be made empty in the following phases. It is in fact possible \nto calculate the greatest domain by a standard .xed-point iteration because each dom(.) is either bound \nfrom above by a monotone expression, or, from below by a set of program variables. Concretely, such an \nalgorithm starts from the assignment {dom(.i). V}, i where V is the (.nite) set of all the variable names \nthat appear in the input program, and update the assignment according to the constraints of the form \ndom(.) +x}, .{ x - dom(.) .+dom(. ' )and dom(.).+[y/x]dom(. ' )until it xx reaches the .xed-point. Then, \nthe algorithm checks whether the obtained assignment satis.es {x}.+dom(.)and returns x the assignment. \nFigure 17 presents the de.nition of the algorithm R. In the de.nition, solve dom(C)returns the map {dom(.i).{xi}} \nxi that gives the greatest solution of the set-inclusion con\u00adstraints C as mentioned above. In addition \nto applying sub\u00adstitution, .C simpli.esthe constraintsif possible.Forexam\u00adple, if {empty((.x,q1)lockq2 \n), } C = (x :(.x,q3)lockq4 )=(x :(.x,q5)lockq6 + .y )+ + {.x . (y:(\u00b5a.aref q8 )ref q7 ), } . = , .y . \n(x :(.x,q9)lockq10 ) then .C = {=0,q2 = +0,q3 = +q5 ++q9,q4 = +q6 ++q10 }. q1 + Lemma 37 guarantees soundness \nof this phase: the algo\u00adrithm R does not turn an unsatis.able constraint set into a satis.able one. Completenessis \nleft as futurework. LEMMA 37. If |= R(C), then |= C. Step 2: Solving linear inequalities After completion \nof Step 1, . does not appear in the constraint set. Moreover, constraints of the form empty(\u00b7) have been \nsimpli.ed to ownership constraints. Thus, the residual constraints consist of ones of the form q1 = + \n>q2. From the syntax q2 or q1 +of the constraint language, these constraints form a system of linear \ninequalities over rational numbers. Thus, we can decide whether the constraints are satis.able or not. \nNote that, thanks to the use of rational numbers as ownerships, this step is done in polynomial time \non the number of ownership variables and inequalities.  ' R(C)= C where {} C1 = c . C | c is of the \nform dom(.).+X {} C2 = c . C | c is of the form {x}.+dom(.) x F = solve dom(C1 . C2) . = makeval (F) \n' C = iter (.,C\\(C1 . C2)) makeval ({dom(.i) .{ xi}})= xi {.i . (xi : template j(stype(xi)))} xi i x' \nx iter (.,C)= C where ' If .C = C then C = C ' else C = iter (.,.C) Figure 17. De.nition ofR.  6.4 Implementation \nWe have implemented an automated veri.er based on the al\u00adgorithm described in this section. The frontend \nof the veri.er that is in charge of C and R is implemented with OCaml. As a linear-inequality solver, \nwe use SMT solver Z3 [5]. The Web interface is available at http://www.fos.kuis. kyoto-u.ac.jp/~rfukuda/freesafety-con/. \n 7. Related Work Terauchi [15] has proposed a type-based race-freedom anal\u00adysis based on fractional \ncapabilities. His type system assigns a fractional permission to each abstract location. Fractional permissions \ndescribe read/write permission to each abstract location. In order to deal with lock-based synchronization \nand fork/join concurrency, his type system associates what we could call procurable capabilities with \nlock types and thread ID types; each lock type comes with capabilities granted by acquiring/releasing \nthe locks and each thread ID type comes with ones granted by waiting the threads. He also reported the \nresult of experiment. Our idea of procurable type environments is inspired by his type system. An important \ndifference, however, is that our ownerships also represent obligation to be ful.lled (e.g., every lock \nto be deallocated exactly once before termina\u00adtion), not only capability. This leads to the difference \nin the typing rules for deallocation of resources; his type system does not exclude programs that deallocate \nlocks twice or more. Besides Terauchi s work [15], the idea of using rational numbers for representing \nownerships has been used in the area of program analysis [3, 8, 13, 17]. Among them, the workby Suenaga \nandKobayashi [13] and thatby Heine and Lam [8] deal with safe memory deallocation. However, they only \ndeal with sequential programs. Extension of the previ\u00adous techniques, especially one proposed in [13], \nto concur\u00adrency is not trivial: it requires, for example, the acyclicity condition in T-CONFIG, which \nis not necessary in the se\u00adquential setting. Type inference, as we have shown, is non\u00adtrivial either \ndue to the presence of procurable type environ\u00adments. Gotsman et al. [6] have proposed an extension of \nthe con\u00adcurrent separation logic [10] with dynamic creation/disposal of locks and threads. Though their \nwork does not deal with safe resource deallocation, it seems that it is not dif.cult to adapt their framework \nto do so. They can treat programs that store locks and thread IDs to heap, which is currently not al\u00adlowed \nin our framework. Theyalso support structures which, for example, enable a program to create a pair of \na memory cell anda lock guarding the cell.Wewould need to incorpo\u00adrate dependent pairs to the type system \nin order to deal with such structures. As far as we know, they have not proposed an automated veri.cation \nbased on their framework yet. It seems that their framework requires for spawned threads to terminate \nwith empty ownerships to locks, while ours allow threads to leave release/lock ownerships. Calcagno et \nal. [4] have proposed an automated veri\u00ad.cation technique for concurrent programs. They use bi\u00adabduction \nto infer resource invariant, a separation logic for\u00admula that describes which part of memory is protected \nby conditional variables. Our procurable type environments correspond to their resource invariant. The \nexpressiveness of concurrent separation logic allows resource invariant to express more properties than \nours (e.g., a pointer not be\u00ading null). Their work has not been extended with dynamic creation of threads \nnor conditional variables. Haack et al. [7] have designed a variant of the concur\u00adrent separation logic \nfor multithreaded Java programs. Their framework supports fork/join parallelism and re-entrant monitors. \nThey use fractional permissions to express shar\u00ading of a location among several threads. However, it \nis not clear whether their logic can be easily adapted also for safe resource deallocation because it \nis based on the intuitionistic version of separation logic. Because intuitionistic separa\u00adtion logic \nadmits weakening, their logic would allow facts about the existence of an allocated memory cell to be \nfreely discarded. Bornat et al. [2] have extended separation logic to concur\u00adrency. They use fractional \npermissions in their assertion lan\u00adguage to express sharing of locations among threads. They also support \nsynchronization with conditional variables by which the logic grants access right to critical regions. \nThis feature is comparable to our procurable type environments in the sense that a resource for synchronization \n(conditional variables, in their case) is associated with some (.xed) per\u00admissions to access guarded \nresources. However, they do not support dynamic creation of threads.  8. Conclusion We have proposed \na type system based on fractional own\u00aderships to guarantee safe resource deallocation and race\u00adfreedom \nin a low-level concurrent language. The type sys\u00adtem is a non-trivial extension of the previous type \nsystem by SuenagaandKobayashi[13].Thekeyideasoftheextension are (1) to assign ownerships not only to \nreference types but also to lock and thread ID types, and (2) to assign procur\u00adable type environments \nto lock types and thread ID types to describe the amount of ownerships granted by or required for operating \nvalues of those types. We have also proposed a type inference algorithm for the type system. The algo\u00adrithm \nreduces a type inference problem into satis.ability of a system of linear inequalities, which is checked \nby the SMT solver Z3.  Incorporating more real-world features to our frame\u00adworkis another important \nfuture direction.Forexample, we need to add C-like structures to our framework so that pro\u00adgrammers can \nuse data structures. This extension could be done as that in the .rst author s previous work [13]. Ex\u00adtension \nwith pointers to locks is also necessary for deal\u00ading with real-world programs. After completing these \nexten\u00adsions, we plan to extend FreeSafeTy, the prototype veri.er implemented in the previous work [13], \nand conduct feasi\u00adbility study by experiment to observe the scalability of our technique and how much \nmanual insertion of must-alias an\u00adnotations is needed in reality. The following program, which is considered \nto be safe in our semantics and also typechecks in our type system, suggests another direction to be \npursued: let x = newlock() in acq(x);let y = fork(rel(x))in wait(y);freelock(x). This program is de.ned \nto be erroneous in many thread libraries including pthreads because the thread that acquires a lock is \ndifferent from one that releases the lock. Extending our framework to exclude more of such bad behaviors \nthat consist in real-world software is an important task. In the current paper, the type system excludes \nall the racy programs. However, in reality, it is sometimes convenient to allow some memory cells to \nbe accessed in a racy manner. Allowing such partially racy programs would be another interesting future \nwork. Acknowledgments We are grateful for valuable comments by the anonymous reviewers. Suenaga is partially \nsup\u00adported by KAKENHI 23\u00b7571 and Hakubi Project at Ky\u00adoto University. Igarashi is partially supported \nby KAKENHI 23220001.  References [1] M. Abadi, C. Flanagan, and S. N. Freund. Types for safe locking: \nStatic race detection for Java. ACM Trans. Prog. Lang. Syst., 28(2):207 255, Mar. 2006. [2]R. Bornat, \nC. Calcagno,P.W. O Hearn, and M. J.Parkinson. Permission accounting in separation logic. In Proc. of \nPOPL, pages 259 270.ACMPress, Jan. 2005. [3] J. Boyland. Checking interference with fractional permis\u00adsions. \nIn Proceedings of SAS 2003, volume 2694 of LNCS, pages 55 72. Springer-Verlag, 2003. [4] C. Calcagno, \nD. Distefano, and V. Vafeiadis. Bi-abductive resource invariant synthesis. In Proceedings of APLAS 2009, \npages 259 274, 2009. [5] L. De Moura and N. Bj\u00f8rner. Z3: an ef.cient SMT solver. In Proceedings of the \nTheory and practice of software, 14th international conference on Tools and algorithms for the construction \nand analysis of systems, TACAS 08/ETAPS 08, pages 337 340. Springer-Verlag, 2008. [6] A. Gotsman, J. \nBerdine,B. Cook, N. Rinetzky, and M. Sagiv. Local reasoning for storable locks and threads. Technical \nReport MSR-TR-2007-39, Microsoft Research, 2007. [7] C. Haack, M. Huisman, and C. Hurlinc. Permission\u00adbased \nseparation logic for multithreaded Java programs. http://fmt.cs.utwente.nl/files/projects/ VerCors.p1.pdf. \n[8] D. L. Heine and M. S. Lam. A practical .ow-sensitive and context-sensitive C and C++ memory leak \ndetector. In Proc. of PLDI, pages 168 181, 2003. [9] IEEE. The Open Group Base Speci.cations Issue 6, \nIEEE Std 1003.1, 2004 Edition, 2004. http: //pubs.opengroup.org/onlinepubs/000095399/ basedefs/pthread.h.html. \n[10] P. W. O Hearn. Resources, concurrency, and local reasoning. Theor. Comput. Sci., 375(1-3):271 307, \n2007. [11]B.C. Pierce. Types and Programming Languages. MIT Press, 2002. [12] K. Suenaga. Type-based \ndeadlock-freedom veri.cation for non-block-structured lock primitives and mutable references. In G. Ramalingam, \neditor, Programming Languages and Sys\u00adtems, 6th Asian Symposium, APLAS 2008, Bangalore, India, volume \n5536 of LNCS, pages 155 170. Springer, Dec. 2008. [13] K. Suenaga and N. Kobayashi. Fractional ownerships \nfor safe memory deallocation. In Z. Hu, editor, Programming Languages and Systems, 7th Asian Symposium, \nAPLAS 2009, volume 5904 of Lecture Notes in Computer Science, pages 128 143. Springer-Verlag, Dec. 2009. \n[14] N. Swamy, M. W. Hicks, G. Morrisett, D. Grossman, and T. Jim. Safe manual memory management in Cyclone. \nSci. Comput. Program., 62(2):122 144, 2006. [15] T. Terauchi. Checking race freedom via linear programming. \nIn Proc. of PLDI, pages 1 10, 2008. [16] M. Tofte and J.-P. Talpin. Region-based memory manage\u00adment. \nInfo.Comput., 132(2):109 176, 1997. [17] K. Ueda. Resource-passing concurrent programs. In Proceed\u00adings \nof 4th International Symposium on Theoretical Aspects of Computer Science (TACS2001), volume 2215 of \nLNCS, pages 95 126. Springer-Verlag, 2001. [18] D. Walker, K. Crary, and J. G. Morrisett. Typed memory \nmanagement via static capabilities. ACM Trans. Prog. Lang. Syst., 22(4):701 771, 2000.  \n\t\t\t", "proc_id": "2384616", "abstract": "<p>We propose a type system to guarantee safe resource deallocation for shared-memory concurrent programs by extending the previous type system based on fractional ownerships. Here, safe resource deallocation means that memory cells, locks, or threads are not left allocated when a program terminates. Our framework supports (1) fork/join parallelism, (2) synchronization with locks, and (3) dynamically allocated memory cells and locks. The type system is proved to be sound. We also provide a type inference algorithm for the type system and a prototype implementation of the algorithm.</p>", "authors": [{"name": "Kohei Suenaga", "author_profile_id": "81363593440", "affiliation": "Kyoto University, Kyoto, Japan", "person_id": "P3856026", "email_address": "ksuenaga@kuis.kyoto-u.ac.jp", "orcid_id": ""}, {"name": "Ryota Fukuda", "author_profile_id": "81548392056", "affiliation": "Kyoto University, Kyoto, Japan", "person_id": "P3856027", "email_address": "rfukuda@kuis.kyoto-u.ac.jp", "orcid_id": ""}, {"name": "Atsushi Igarashi", "author_profile_id": "81309510908", "affiliation": "Kyoto University, Kyoto, Japan", "person_id": "P3856028", "email_address": "igarashi@kuis.kyoto-u.ac.jp", "orcid_id": ""}], "doi_number": "10.1145/2384616.2384618", "year": "2012", "article_id": "2384618", "conference": "OOPSLA", "title": "Type-based safe resource deallocation for shared-memory concurrency", "url": "http://dl.acm.org/citation.cfm?id=2384618"}