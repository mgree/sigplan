{"article_publication_date": "10-19-2012", "fulltext": "\n Taming MATLAB Anton Dubrau and Laurie Hendren McGill University anton.dubrau@mail.mcgill.ca, hendren@cs.mcgill.ca \nAbstract MATLAB is a dynamic scienti.c language used by scientists, engineers and students worldwide. \nAlthough MATLAB is very suitable for rapid prototyping and development, MAT-LAB users often want to convert \ntheir .nal MATLAB pro\u00adgrams to a static language such as FORTRAN. This paper presents an extensible object-oriented \ntoolkit for support\u00ading the generation of static programs from dynamic MAT-LAB programs. Our open source \ntoolkit, called the MATLAB Tamer, identi.es a large tame subset of MATLAB, supports the generation of \na specialized Tame IR for that subset, pro\u00advides a principled approach to handling the large number of \nbuiltin MATLAB functions, and supports an extensible inter\u00adprocedural value analysis for estimating MATLAB \ntypes and call graphs. Categories and Subject Descriptors D.3.4 [Processors]: Compilers General Terms \nExperimentation, Languages Keywords MATLAB, Static Compilation, Interprocedural Value Analysis, Analysis \nFramework 1. Introduction MATLAB is a popular numeric programming language, used by millions of scientists, \nengineers as well as stu\u00addents worldwide[16]. MATLAB programmers appreciate the high-level matrix operators, \nthe fact that variables and types do not need to be declared, the large number of library and builtin \nfunctions available, and the interactive style of program development available through the IDE and the \ninterpreter-style read-eval-print loop. However, even though MATLAB programmers appreciate all of the \nfeatures that en\u00adable rapid prototyping, they often have other ultimate goals. Frequently they wish to \nconvert their MATLAB code to a more static language such as FORTRAN or C. Permission to make digital \nor hard copies of all or part of this work for personal or classroom use is granted without fee provided \nthat copies are not made or distributed for pro.t or commercial advantage and that copies bear this notice \nand the full citation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. OOPSLA 12, October 19 26, 2012, Tucson, Arizona, \nUSA. Copyright &#38;#169; 2012 ACM 978-1-4503-1561-6/12/10. . . $10.00 There are several reasons why \nusers would like to have static code. First, users may want source code, which can be compiled into a \nself-contained executable with standard and freely available compilers. This allows them to easily dis\u00adtribute \nboth the source and executable. Second, users may want to generate code that can be integrated into existing \nsystems. As just one example, one of our users wanted to generate FORTRAN code that can be plugged into \na weather simulation environment. Finally, users may wish to generate code that can take advantage of \nhigh-performance optimiz\u00ading or parallelizing compilers (such as FORTRAN), or novel parallel systems \n(such as X10).1 This paper addresses the problem of how to provide the bridge between the dynamic realities \nof MATLAB and the ul\u00adtimate goal of wanting ef.cient and static programs. It is not realistic to support \nall the MATLAB features, but our goal is to de.ne and provide support for a very large subset of MATLAB, \nwhich includes dynamic typing, variable numbers of input and output arguments, support for a variety \nof MAT-LAB data types including arrays, cell arrays and structs, and support for function handles and \nlambda expressions. Providing this bridge presents two main challenges. The .rst is that MATLAB is actually \nquite a complex language. It evolved over many years and has non-standard type rules and function lookup \nsemantics. The second major challenge is properly dealing with the large number of builtin and library \nfunctions, which have also been developed over time and which sometimes have unexpected or irregular \nbehaviour. Our solution is an open-source, extensible, objected\u00adoriented framework, implemented in Java, \nas presented in Figure 1. The overall goal of the system is to take MATLAB programs as input and produce \noutput which is suitable for static compilation, a process that we call Taming MATLAB. Given a .m.le \nas input, which is the entry point, the MAT-LAB Tamer produces as output: (1) a Tame IR for all func\u00adtions \n(both user and library) which are reachable from the 1 We should note that another way to achieve performance \nis to use more dynamic techniques with a virtual machine and an optimizing/parallelizing JIT. For a dynamic \nlanguage like MATLAB, this seems to be a good .t, and in fact our research group is developing dynamic \ntechniques with the McVM project [4] in parallel with our work for static compilers. Somewhat to our \nsurprise there has been much more user interest in the static compi\u00adlation project, for the reasons we \nhave given. Thus, we think that pursuing both the static and dynamic approaches are worthwhile.  Figure \n1. Overview of our MATLAB Tamer. The shaded boxes indicate the components presented in this paper. The \nother solid border boxes correspond to existing McLAB tools we use, and the dashed boxes boxes correspond \nto on\u00adgoing projects which are using the results of this paper. entry point, (2) a complete call graph, \nand (3) an estimation of classes/types for all variables. There are some features in MATLAB that are \nsimply too wild to handle, and so our system will reject programs using those features. The user will \nneed to refactor their program to eliminate the use of those wild features. Thus, another important goal \nin our work is to de.ne a subset of MATLAB which is a large as possible and which can be tamed without \nuser intervention. The main contributions of this paper are as follows. We present an overall design \nand implementation for the MATLAB Tamer, an extensible object-oriented frame\u00adwork which provides the \nbridge between the dynamic MATLAB language and static back-end compilers.  We describe the key features \nof MATLAB necessary for compiler developers and for tool writers to understand MATLAB and the analyses \nin this paper. We hope that by carefully explaining these ideas, we can enable other researchers to also \nwork on static tools for MATLAB. Our discussion of MATLAB features also motivates our choice of the subset \nof MATLAB that we aim to tame.  We provide a principled approach to understanding, grouping, and analyzing \nthe large number of MATLAB  builtin functions. This is a non-trivial effort that is really needed in \norder to be able to properly analyze MAT-LAB programs which typically make heavy use of library functions. \n We provide extensions to the McSAF [5, 7] framework to support a lower-level and more specialized Tame \nIR, suitable for back-end static code generation.  We present an interprocedural .ow analysis framework \nthat computes both abstract values and the complete call graph. This .ow analysis provides an object-oriented \nap\u00adproach which allows for extension and re.nement of the abstract value representations.  The remainder \nof the paper is structured as follows. Sec. 2 introduces the key MATLAB features, Sec. 3 describes our \napproach to MATLAB builtins, Sec. 4 describes the Tame IR and transformations, Sec. 5 explains our extensible \nand interprocedural value analysis and call graph construction, Sec. 6 summarizes how our framework can \nbe used, Sec. 7 provides an overview of related work and Sec. 8 concludes. 2. MATLAB -a dynamic language \nIn this section we describe key MATLAB semantics and fea\u00adtures to provide necessary background for compiler \nwrit\u00aders and tool developers to understand MATLAB and its challenges, and to motivate our approach of \nconstructing a tame intermediate representation and MATLAB callgraph. In each subsection we give a description \nfollowed by anno\u00adtated examples using the MATLAB read-eval-print loop. In the examples, >> indicates \na line of user input, and the following line(s) give the printed output. 2.1 Basics MATLAB was originally \ndesigned in the 1970s to give ac\u00adcess to features of FORTRAN (like LINPACK, EISPACK) without having to \nlearn FORTRAN[17]. As the name MAT\u00adLAB(MATrix LABoratory) suggests, MATLAB is centered around numerical \ncomputation. Floating point matrices are the core of the language. However, the language has evolved \nbeyond just simple matrices and now has a type system in\u00adcluding matrices of different types, compound \ntypes includ\u00ading cell arrays and structs, as well as function references. Given its origins, MATLAB is \na language that is built around matrices. Every value is a Matrix with some number of dimensions, so \nevery value has an associated array shape. Even scalar values are 1 \u00d7 1 matrices. Vectors are either \n1 \u00d7 n or n \u00d7 1 matrices and strings are just vectors of characters. Most operations are de.ned for matrices, \nfor example a*bspeci.es matrix multiplication if both aand b are matrices. Operators are overloaded and \nsometimes refer to scalar operations, for example a*bspeci.es an element\u00adwise multiplication if a is \na matrix and b is a scalar. >> size(3) % the scalar 3 is a 1x1 matrix 1 1 >> size([1 2 3]) % a 1x3 vector \n 13 >> size([5; 6; 7; 8; 9])% a 5x1 vector 5 1 >> size('hello world') % a string, which is a 1x11 vector \n1 11 >> ['a' 'b'; 'e' 'f'] % a 2-dimensional matrix of chars ab ef 2.2 MATLAB Type System MATLAB is \ndynamically typed -variables need not be de\u00adclared, they will take on any value that is assigned to them. \nEvery MATLAB value has an associated MATLAB class (henceforth we will use the name mclass when referring \nto a MATLAB class, in order to avoid confusion with the usual notion of a class). The mclass generally \ndenotes the type of the elements of a value. For example, the mclass of an array of doubles is double. \nThe default numeric mclass is double. While MATLAB also includes integer types, all numeric literals \nare doubles. >> n=1 % input literal and output look like an int 1 >> class(n) % however, mclass is really \ndouble, the default double >> class(1:100) % mclass of vector [1, 2, ..., 100] is double double MATLAB \nhas a set of builtin mclasses, which can be summarized as follows: double, single: .oating point values \n uint8, uint16, uint32, uint64, int8, int16, in32, int64: integer values  logical: boolean values \n char: character values (strings)  cell: heterogeneous arrays  struct: structures  function handle: \nreferences to functions  Given that by default any numerical value in MATLAB is a double, all values \nthat are intended to be of a dif\u00adferent numeric type have to be speci.cally converted. This also means \nthat when combining a value of some non-double mclass with a value that is a double, the result will \nbe of the non-double mclass. This leads to the surprising seman\u00adtics that adding an integer and a double \nresults in an integer, because that is the more specialized type. >> x = 3; % x is implicitly a double \n>> y = int8(5); % y is explictly an integer >> class(x) % the class of x is double double >> class(y) \n% the class of y is int8 int8 >> class(x+y) % the result of x+y is int8 , not double int8 2.3 MATLAB \nFunctions and Specialization A MATLAB function is de.ned in a .m-.le which has the same name as the function.2 \nSo, for example, a function named foo would be de.ned in a .le named foo.m, and that .le needs to be \nplaced either in the current directory, or in a directory on the MATLAB path. A .m-.le can also de.ne \nsubfunctions following the main (primary) function de.nition in a .le, but those subfunctions are only \nvisible to the functions within the .le. Functions may also be de.ned in a private/ directory, in which \ncase they are visible only to functions de.ned in the parent directory. MATLAB allows overriding or specializing \noperations and functions to operate on speci.c mclasses. This is accom\u00adplished by de.ning the function \nin a .le inside a specially named directory which starts with the character @ followed by the name of \nthe mclass. For example, one could create a specialized function firstWord de.ned for Strings, by creating \na .le @char/firstWord.m somewhere on the MATLAB path. Functions that are specialized in such a way have \nprecedence over non-specialized functions, but they do not have precedence over inner functions, subfunctions \n(de\u00ad.ned in the same .le) or private functions (de.ned in the /private directory). So, in our example, \nif there existed two de.nitions of firstWord.m, one general implemen\u00adtation somewhere on the MATLAB path, \nand one specialized implementation in a directory @charon the MATLAB path, then a call to firstWordwith \na charargument will result in acall to @char/firstWord.m, whereas a call with an argument with any other \nmclass, will result in a call to the general firstWord.mde.nition. When calling a function that has mclass-specialized \nver\u00adsions with multiple arguments of different mclasses, MAT-LAB has to resolve which version of the \nfunction to call. There doesn t exist a standard inheritance relationship be\u00adtween the builtin mclasses. \nRather, MATLAB has the notion of a superior or inferior class. We were unable to .nd a succinct summary \nof these relationships, so we generated a MATLAB program which exercised all cases and which produced \na .dot .le describing all relationships, with all transitive relationships removed. Figure 2 shows the \nrela\u00adtionships between different builtin mclasses, showing supe\u00adrior classes above inferior classes. \nNote that some mclasses have no de.ned relationship, for example, there are no de\u00ad.ned inferior/superior \nrelationships between the different in\u00adteger mclasses. Further, note that double, being the default mclass, \nis inferior to integer mclasses. Also, the compound mclasses (struct and cell), are superior to all matrix \nmclasses. When resolving a call with multiple arguments, MATLAB .nds the most superior argument, and \nuses its mclass to re\u00adsolve the call. If multiple arguments have no de.ned superi\u00ad or/inferior relationships, \nMATLAB uses the leftmost superior argument. For example, if a function is called with three ar\u00ad 2 In \nthe case where the name of the .le and the function do not match, the name of the .le takes precedence. \n Figure 2. Superior/inferior class relationships for MATLAB guments with the mclasses (double, int8, \nuint32), in that order, MATLAB attempts to .nd a specialized version for mclass int8. If none is found, \nMATLAB attempts to .nd a non-specialized version. The class specialization semantics for MATLAB means \nthat if one intends to build a complete callgraph, i.e. resolve all possible call edges, one has to .nd \nall possible MAT-LAB classes for all arguments, and one must safely approx\u00adimate the lookup semantics \nof functions, including the cor\u00adrect lookup of specialized functions using the mclass and the superior/inferior \nmclass relationships from Figure 2. 2.4 MATLAB Classes It is important to note that the mclass of a value \ndoes not completely de.ne its type. For example, numeric MATLAB values may be real or complex, and matrices \nhave an array shape. Both of these properties are de.ned orthogonally to the notion of its mclass. Although \na computation can ask whether a value is complex or real, and can ask for the shape of an array, the \nlookup semantics solely depend on the mclass, which is effectively just a name. Within the MATLAB language, \nthere is no dedicated class of values to represent mclasses. Usually, strings (char vectors) are used \nto denote mclasses. For example, ones(3,2,'single'), will call the builtin function ones and create a \n3\u00d72 array of unit values of mclass single.  2.5 Function Handles MATLAB values with mclass function \nhandle store a reference to a function. This allows passing functions as arguments to other functions. \nFunction handles can either be created to refer to an existing function, or can be a lambda expression. \nLambda expressions may also encapsulate state from the current workspace via free variables in the lambda \nexpression. >> f = @sin % a function handle to a named function f = @sin >> g = @(x) exp(a*x) % a lambda \nwith a free variable a g = @(x)exp(a*x) Function handles, and especially lambdas, are useful in numerical \ncomputing, for example when calling numerical solvers, as illustrated below. f = @(t,y) D*t + c;% set \nup derivative function span = [0 1]; % set interval y0 = [0:0.1:10]'; % set initial value result = ode23s(f,span,y0); \n% use matlab library function to solve When building a callgraph of a program that includes function \nhandles, one needs to propagate function handles through the program interprocedurally in order to .nd \nout which variables may refer to function handles, and to .nd associated call edges. 2.6 Function Parameters \nand Arguments MATLAB uses call-by-value semantics, so that each parame\u00adter denotes a fresh copy of a \nvariable.3 This simpli.es inter\u00adprocedural analyses for static compilation as calling a func\u00adtion cannot \ndirectly modify local variables in the caller. In MATLAB, function arguments are optional. That is, when \ncalling a function one may provide fewer arguments than the function is declared with. However, MATLAB \ndoes not have a declarative way of specifying default values, nor does it automatically provide default \nvalues. That is, a pa\u00adrameter corresponding to an argument that was not provided will simply be unassigned \nand a runtime error will be thrown if an unassigned variable is read. MATLAB does provide the function \nnargin to query how many arguments have been provided to the currently executing function. This allows \nthe programmer to use the value of nargin to explicitly assign values to the missing parameters, as illustrated \nbelow. function [result1, result2] = myFunction(arg1,arg2) if (nargin < 1) arg1 = 0; end if (nargin \n< 2) arg2 = 1; end; ... end As shown above, MATLAB also supports assigning multi\u00adple return variables. \nA function call may request any number of return values simply by assigning the call into a vector of \nlvalues. Just like the function arguments, the return values don t all need to be assigned, and a runtime \nerror is thrown if a requested return value is not assigned. MATLAB provides the nargoutfunction to query \nhow many results need to be returned. Clearly a static compiler for MATLAB must deal with optional arguments \nin a sound fashion. 3 Actual MATLAB implementations only make copies where actually nec\u00adessary, using \neither lazy copying when writing to an array with reference count greater than 1, or by using static \nanalyses to determine where to in\u00adsert copies[13].  2.7 Wild Dynamic Features Whereas features like \ndynamic typing, function handles, and variable numbers of input arguments are both widely used and possible \nto tame, there are other truly wild dynamic fea\u00adtures in MATLAB that are not as heavily used, are sometimes \nabused, and are not amenable for static compilation. These features include the use of scripts (instead \nof func\u00adtions), arbitrary dynamic evaluation (eval), dynamic calls to functions using feval, deletion \nof workspace variables (clear), assigning variables at runtime in the caller scope of a function (assignin), \nchanging the function lookup di\u00adrectories during runtime (cd) and certain introspective fea\u00adtures. Some \nof these can destroy all available static informa\u00adtion, even information associated with other function \nscopes than where these features occur. Our approach to these features is to detect them and help\u00ading \nprogrammers to remove them via refactorings. Some refactorings can be automated. For example, McLAB al\u00adready \nsupports refactorings to convert scripts to functions and some calls to feval to direct function calls[19]. \nOther refactorings may need to be done by the programmer. For ex\u00adample, the programmer may use cd to \nchange directory to access some data .le, not being aware that this also changes the function lookup \norder. The solution in this case is to use a path to access the data .le, and not to perform a dynamic \ncall to cd. We have also observed many cases where dynamic evalor fevalcalls are used because the programmer \nwas not aware of the correct direct syntax or programming fea\u00adture to use.4 For example, feval is often \nused to evaluate a function name passed as a String, where a more correct programming idiom would be \nto use a function handle.  2.8 Illustrative Example The example in Figure 3 exempli.es some of the ideas \npre\u00adsented in the previous section. It is a complete, valid MAT-LAB program, performing some numerical \ncomputation5, using common features and functionality. It is a program using multiple user-de.ned functions, \nas well as MATLAB builtin functions, and one MATLAB library function (the call to toeplitzin function \nDxx). Note the use of single values. These single values are created only in the .rst function (main). \nBut they are supe\u00adrior to doublevalues used in the other functions, and all the values in the actual \ncomputation are a result of operating on the incoming singlevalues, so the overall computation is done \nusing single values. Essentially functions perform\u00ading the actual computations are agnostic to the mclasses \nof 4 This is at least partly due to the fact that older versions of MATLAB did not support all of the \nmodern features. 5 While the presented example is a complete, valid MATLAB program, and uses features \nand the kind of functions one would commonly see used in MATLAB, it does not represent a meaningful way \nto solve the contained numerical problem, because it is highly unstable. We created this example for \nthe purposes of illustrating different MATLAB language ides, and for brevity. function result = main(N) \n % set up sytem conditions/variables rod.L = single(10); rod.Ta = single(3); rod.Tb = single(4); a = \n.2; A = 0.05; Tspan = [0 20]; % solve system result = solveSystem(rod,a,A,N,Tspan);  end % solves \nthe heat equation for some rod of length rod.L, % initially at temperature rod.Ta, rod.Tb, using N subdivisions. \n% uses default values for Tspan, Tsteps if they are unde.ned function out=solveSystem(rod,a,A,N,Tspan,Tsteps) \nswitch nargin case 4 Tspan = [0, 10]; Tsteps = 100; case 5 Tsteps = 100; end h = rod.L/(N+1); % step \nsize in x X = [h:h:rod.L-h].'; % create x axis with subidivisions U0 = X; % allocate u0 mid = round(length(X)/2); \nU0(1:mid) = rod.Ta; % set left to Ta U0(mid:end) = rod.Tb; % set right to Tb [D,c] = Dxx(N,rod.Ta,rod.Tb,h); \n% set up derivative matrix f = @(t,u) a*(D*u + c) + A; % right hand side of ODE [T,out] = RungeKutta2(f,Tspan,U0,Tsteps); \n% solve ODE end % creates a centered-in-space .nite difference differentiation % matrix for the second \nspatial derivative. function [D,c]=Dxx(N,a,b,h) D= toeplitz([-2;1;zeros(N-2,1)],... [-2,1,zeros(1,N-2)])./h \n2; c = [a/h 2; zeros(N-2,1); b/h 2]; end % Runge-Kutta 2 implementation solving the system % y'=f(t,y), \ny(a)=y0 % over tspan=[a,b], using function f , and N integration steps function [X,Y]=RungeKutta2(f,tspan,y0,N) \na=tspan(1); % initial time b=tspan(2); % .nal time h=(b-a)/N; % step size Y = [y0 zeros(length(y0),N)]; \n% result matrix, with y0 X = (a:h:b)'; % set times for j=1:N % integration steps k1 = h*f(X(j), Y(:,j)); \nk2 = h*f(X(j)+ h, Y(:,j) + k1); Y(:,j+1)=Y(:,j) + 1/2*(k1 + k2);  end end Figure 3. MATLAB numerical \nexample the arguments (including the MATLAB function toeplitz itself). Note also the use of the following \nMATLAB features presented in the previous discussion: use of a structure (in main)  use of a lambda \nexpression encapsulating local variables to construct a function reference (in solveSystem)  use of \noptional input arguments (in solveSystem), where optional parameters are assigned using a switch statement \non nargin.  use of multiple return values (in Dxx).  In the following sections we will illustrate the \nrelevant points using this example. The complete result of running the Tamer on the example in Figure \n3 is shown in Appendix A.  2.9 Summary In this section we have outlined key MATLAB features and semantics, \nespecially concentrating on the de.nition of mclass and function lookup. Our approach is to tame as much \nof MATLAB as possible, including support for func\u00adtion pointers and lambda de.nitions. Capturing as much \nas possible of the evolved language is not just useful to allow access to a wider set of MATLAB features \nfor user code. Also, a signi.cant portion of MATLAB s extensive libraries are written in MATLAB itself, \nand make extensive use of some of the features discussed above. Since we implement the MATLAB lookup \nsemantics, and allow the inclusion of the MATLAB path, our callgraph will automatically include available \nMATLAB library functions. Thus, implementing more features will also bene.t users who do not make direct \nuse of advanced features.  3. Framework for Builtins One of the strengths of MATLAB is in its large \nlibrary, which doesn t only provide access to a large number of matrix com\u00adputation functions, but packages \nfor other scienti.c .elds. Even relatively simple programs tend to use a fair number of library functions. \nMany library functions are actually im\u00adplemented in MATLAB code. To provide their functionality, the \ncallgraph construction needs to include any MATLAB function on the MATLAB path, if it is available. Thus \nwe can provide access to a large number of library functions as long as we can support the language features \nthey use. However, hundreds of MATLAB functions are actually implemented in native code. We call these \nfunctions builtins or builtin functions. Every MATLAB operator (such as +, *) is actu\u00adally a builtin \nfunction; the operations are merely syntactic sugar for calling the functions that represent the operations \n(like plus , mtimes ). Thus, for an accurate static analysis of MATLAB programs, one requires an accurate \nmodel of the builtins, and a way to deal with them. Consider that the example presented in Figure 3 at \n.rst sight only seems to use some basic matrix arithmetic and some comparison op\u00aderators; however, the \nfull program, including the embedded MATLAB library function call, refers to a total of twenty-six builtins.6 \nIn this section we describe how we have modeled the builtins and how we integrate the analysis into the \nstatic interprocedural analysis framework. 3.1 Learning about Builtins As a .rst step to build a framework \nof builtin functions, we need to identify builtins, and need to .nd out about their behaviour, especially \nwith respect to mclasses. 3.1.1 Identifying Builtins: To make the task of building a framework for builtins \nman\u00adageable, we wanted to identify the most commonly used builtin functions and organize those into a \nframework. Other builtins can be added incrementally, but this initial set was useful to .nd a good structure. \nTo identify commonly used builtins we used the McBENCH framework[19] to .nd all references to functions \nthat occur in a large corpus of over 3000 MATLAB programs.7 We recorded the frequency of use for every \nfunction and then using the MATLAB function exist, which returns whether a name is a variable, user-de.ned \nfunction or builtin, we identi.ed which one of these functions is a builtin func\u00adtion. This provided \nus with a list of builtin functions used in real MATLAB programs, with their associated frequency of \nuse. We selected approximately three hundred of the most frequent functions, excluding very dynamic functions \nlike evalas our initial set of builtin functions.8 3.1.2 Finding Builtin Behaviours: In order to build \na call graph it is very important to be able to approximate the behaviour of builtins. More precisely, \ngiven the mclass of the input arguments, one needs to know a safe approximation of the mclass of the \noutput arguments. This behaviour is actually quite complex, and since the imple\u00admentation of MATLAB 7 \nis the defacto speci.cation of the behaviour we decided to take a programmatic approach to exploring \nand determining the behaviours.9 We developed a set of scripts that generated random MATLAB values of \nall combinations of builtin mclasses, and called selected builtins using these arguments. If different \nrandom values of the same mclass result in consistent result\u00ading mclasses over many trials, the scripts \nrecord the associ\u00ad 6 mtimes, vertcat, single, transpose, conj, round, colon, lt, isequal, mrdivide, length, \nhorzcat, mpower, end, plus, minus, nargin, class, ones, message, uminus, zeros, ne, rdivide, ctranspose, \nwarning 7 This is the same set of projects that are used in [6]. The benchmarks come from a wide variety \nof application areas including Computational Physics, Statistics, Computational Biology, Geometry, Linear \nAlgebra, Signal Pro\u00adcessing and Image Processing. 8 The complete list can be found at www.sable.mcgill.ca/mclab/ \ntamer.html 9 We also used the MATLAB 7 documentation, which unfortunately includes fairly little type \ninformation, and ad-hoc trials to determine the behaviour of builtins. ated mclass propagation for builtins \nin a table, and collect functions with the same mclass propagation tables together. Examples of three \nsuch tables are given in Figure 4.10 As compared with type rules in other languages, these results may \nseem a bit strange. For example, the - entry for plus(int16,int32) in Figure 4(a) shows that it is an \nerror to add an int16 to and int32. However adding an int64 to a double is allowed and it results in \nan int64. Also, note that although the three tables in Figure 4 are similar, they are not identical. \nFor example, in Figure 4(a), multiplying a logical with a logical results in a double, but using the \npower operator with two logicals is an error. Finally, note that the tables are not always symmetrical. \nIn particular, the f64column and row in Figure 4(b) are not the same. The reader may have noticed how \nthe superior/inferior mclass relationships as shown in .gure Figure 2 seem to resemble the implicit type \nconversion rules for MATLAB builtin functions. For example, when adding an integer and a double, the \nresult will be double. However, it is not suf.cient to model the implicit MATLAB class conversion semantics \nby just using class-specialized functions and their relation\u00adships. Many MATLAB builtins perform explicit \nchecks on the actual runtime types and shapes of the arguments and perform different computations or \nraise errors based on those checks. Through the collection of a large number of tables we found that \nmany builtins have similar high-level behaviour. We found that some functions work on any matrix, some \nwork on numeric data, some only work on .oats, and some work on arbitrary builtin values, including cell \narrays or function handles.  3.2 Specifying Builtins To capture the regularities in the builtin behaviour \nwe ar\u00adranged all of the builtins in a hierarchy -a part of the hi\u00aderarchy is given in Figure 5. Leaves \nof the hierarchy corre\u00adspond to actual builtins and upper levels correspond to ab\u00adstract groups which \nshare some sort of similar behaviour. The motivation is that some .ow analyses need only spec\u00adify the \nabstract behaviour of a group, and the .ow analysis framework will automatically apply the correct (most \nspe\u00adcialized) behaviour for a speci.c builtin. To specify builtins and their relationships, we developed \na simple domain-speci.c language. One just needs to specify the name of a builtin. If the builtin is \nabstract (i.e. it refers to a group of builtins), the parent group has to be speci.ed. If no parent is \nspeci.ed, the speci.ed name is an actual builtin, belonging to the group of the most recently speci.ed \nabstract builtin. This leads to a very compact representation, allowing builtins to be speci.ed on one \nline each, as illustrated by the following snippet of the builtin speci.cation: 10 To save space we have \nnot included the whole table, we have left out the columns and rows for unsigned integer mclasses and \nfor handles. All re\u00adsult tables can be found at www.sable.mcgill.ca/mclab/tamer. html floatFunction; \nmatrixFunction properFloatFunction; floatFunction unaryFloatFunction; properFloatFunction elementalUnaryFloatFunction; \nunaryFloatFunction sqrt realsqrt erf ... improperFloatFunction; floatFunction ... The builtin framework \ntakes a builtin speci.cation and generates a set of Java classes whose inheritance relationship re.ects \nthe speci.ed tree. It also generates a visitor class, which allows annotating methods to Builtins using \nthe visi\u00adtor pattern -a pattern that is already extensively used in the McSAF framework[5, 7] upon which \nthe Tamer is built. We categorize the MATLAB builtin functions according to many properties, such as \nmclass, arity, shape, semantics. This means that different analyses or attributes can be spec\u00adify at \nexactly the required category. It also means that when adding builtins that do .t in already existing \ncategories, one does not need to add all required attributes or .ow equations. 3.3 Specifying Builtin \nattributes It is not suf.cient to just specify the existence of builtins; their behaviour needs to be \nspeci.ed as well. In particular, we need .ow equations for the propagation of mclasses. Thus the builtin \nspeci.cation language allows the addition of properties. A property is just a name, with a set of arguments \nthat follow it. A speci.c property can be de.ned for any builtin, and it will trigger the addition of \nmore methods in the generated Java code as well as the inclusion of interfaces. In this way, any property \nde.ned for an abstract builtin group is de.ned for any builtin inside that group as well, unless it gets \noverridden. 3.3.1 The Class attribute The .rst property we de.ned was the property Class. When speci.ed \nfor a builtin, it forces the inclusion of the Java interface ClassPropagationDefinedin the gen\u00aderated \nJava code, and will add a method that returns an mclass .ow equation. The mclass .ow equation itself \nis speci.ed as an argument to the Class attribute using a small domain speci.c language that allows matching \nar\u00adgument mclasses, and returns result mclasses based on matches. An example snippet is given below which \nshows the speci.cation of mclass .ow equations for unary func\u00adtions taking numeric arguments. Functions \nin that group ac\u00adcept any numeric argument and return a result of the same mclass (numeric->0), a char \nor logical argument will re\u00adsult in a double. unaryNumericFunction; properNumericFunction; -Class(numeric->0, \n\\ char|logical->double)  elementalUnaryNumericFunction; unaryNumericFunction; -abstract  i8 i16 i32 \ni64 f32 f64 c b i8 i16 i32 i64 f32 f64 c b i8 i8 - - - - i8 i8 - i8 i8 - - - - - i8 - i16 - i16 - - - \ni16 i16 - i16 - i16 - - - - i16 - i32 - - i32 - - i32 i32 - i32 - - i32 - - - i32 - i64 - - - i64 - i64 \ni64 - i64 - - - i64 - - i64 - f32 - - - - f32 f32 f32 f32 f32 - - - - f32 - f32 f32 f64 i8 i16 i32 i64 \nf32 f64 f64 f64 f64 i8 i16 i32 i64 f32 f64 f64 f64 c i8 i16 i32 i64 f32 f64 f64 f64 c i8 i16 i32 i64 \nf32 f64 f64 f64 b - - - - f32 f64 f64 f64 b - - - - f32 f64 f64 - (a) plus, minus, mtimes, times, kron \n(b) mpower, power i8 i16 i32 i64 f32 f64 c b i8 i8 - - - - i8 i8 - i16 - i16 - - - i16 i16 - i32 - - \ni32 - - i32 i32 - i64 - - - i64 - i64 i64 - f32 - - - - f32 f32 f32 f32 f64 i8 i16 i32 i64 f32 f64 f64 \nf64 c i8 i16 i32 i64 f32 f64 f64 f64 b - - - - f32 f64 f64 - (c) mldivide, mrdivide, ldivide, rdivide, \nmod, rem, mod Figure 4. Example mclass results for groups of Built-in binary operators. Rows correspond \nto the mclass of the left operand, columns correspond to the mclass of the right operand, and the table \nentries give the mclass of the result. The labels i8 to i64 represent the classes int8 through int64, \nf32 is single, f64 is double, c is char, and b is logical. Entries of the form - indicate that this combination \nis not allowed and will result in a runtime error. real imag abs conj;; MatlabClass(logical->error, natlab) \nsign;; MatlabClass(logical->error, natlab) We have noticed some irregularities in the pure MATLAB semantics, \nand our speci.cation sometimes removes those. In order to keep a record of the differences we use the \nMatlabClass speci.cation which allows us to specify the exact MATLAB semantics -and thus provides an \nexact de.nition and documentation of MATLAB class semantics. In the example above, we specify that the \nfunctions conj and signhave different MATLAB semantics: they disallow logicalarguments, which will result \nin an error.  3.3.2 Other Attributes It is possible to add new kinds of attributes to the builtin speci.cation \nlanguage. One merely has to add a function to the builtin generator with a speci.c function interface \nand the same name as the new attribute. This function has to return Java code that will be inserted in \nthe generated Builtin class. The function may also force the generated Builtin class to implement a certain \ninterface (i.e. to signify that certain methods were added to it). We will use this facility to add more \ninformation about builtins or .ow equations for  3.4 Summary We have performed an extensive analysis \nof the behaviour of MATLAB builtin functions. Based on that we developed a framework that allows to specify \nMATLAB builtin functions, their relationships and properties such as .ow equations in a compact way. \nThis framework is extensible both by allowing the quick addition of more builtin functions; and by allowing \nto specify information and behaviour for builtin functions. This can be done either adding new properties \nto the framework itself; or by implementing visitor classes. 11  4. Tame IR As indicated in Figure 1, \nwe build upon the McSAF [5, 7] framework by adding taming transformations and by pro\u00adducing a more specialized \nTame IR. The McSAF framework provides both a high-level AST and a lower-level AST called McLAST in which \nmany sim\u00adpli.cations have been performed, including simplifying the left-hand and right-hand sides of \nassignment statements, transforming the implicit control-.ow of short-circuit opera\u00adtors to explicit \ncontrol .ow, resolving the precise meaning of the end operator, and simplifying the if and for control \nconstructs. To produce an easily analyzable Tame IR we have made three important additions: (1) generating \nmore specialized AST nodes, (2) translating switch statements to equiva\u00adlent conditional statements, \nand (3) transforming lambda ex\u00ad the operations they represent. It will conversely allow us to 11 The \ncomplete speci.cation of builtins, documentation of quickly provide information about builtins that we \nadd to the the speci.cation and diagrams of all builtins is available at framework. www.sable.mcgill.ca/mclab/tamer.html \n Figure 5. Subtree of builtin tree, showing all de.ned .oating point builtins of MATLAB pressions to \nanalyzable equivalents. One might wonder why these transformations are not already part of McSAF, the \nframework upon which the Tamer is built. The important point is that McSAF must handle all of MATLAB, \nwhereas for our Tame IR we can make restrictions that are reason\u00adable for the purposes of static compilation. \nThis allows us to make the Tame IR more specialized and enables more sim\u00adplifying transformations. 4.1 \nSpecialized AST nodes One goal for our Taming framework was to produce an IR that is very simple to analyze, \nand has operations that are low-level enough to map fairly naturally to static languages like FORTRAN. \nAs one example, in McSAF there is only one kind of assignment statement, assigning from an ex\u00adpression \nto an lvalue expression. The Tame IR has many more specialized cases as illustrated in Figure 6. We also \nextended McSAF s analysis framework to recognize these new IR nodes, so .ow equations can be speci.ed \nfor them. Note how the Tame IR has a different statement for a func\u00adtion call or an array indexing operation. \nIn MATLAB these use the same syntax, a parameterized expression. We use the kind analysis[6] to resolve \nnames to being a function or vari\u00adable, but there are rare cases when this is not possible. Tame MATLAB \nwill reject these cases.  Figure 6. Specializations of the assignment statement 4.2 Lambda Simpli.cation \nMATLAB supports lambda expressions. In order to be com\u00adpatible with the Tame IR, their bodies need to \nbe converted to a three address form in some way. MATLAB lambda expres\u00adsions are just a single expression \n(rather than, say, statement lists), so we extract the body of the lambda expression into an external \nfunction. The lambda expression still remains, but will encapsulate only a single call, all whose arguments \nare variables. For example, the lambda simpli.cation will transform the expression in Figure 7(a) to \nthe code in Fig\u00ad ure 7(b). function outer function outer ... ... f = @(t,y) D*t + c f = @(t,y) lambda1(D,c,t,y) \n... ... end end function r = lambda1(D,c,t,y) r = D*t + c end (a) lambda (b) transformed lambda Figure \n7. Transforming lambdaexpressions The new lambda expression encapsulates a call to the new function lambda1. \nNote that the .rst two arguments are variables from the workspace, the remaining ones are the pa\u00adrameters \nof the lambda expression. In the analyses, we can thus model the lambda expression using partial evaluation \nof the function lambda1. To make this transformation work, the generated function must return exactly \none value, and thus Tame MATLAB makes the restriction that lambda ex\u00adpressions return a single value \n(of course that value may be an array, struct or cell array).  4.3 Switch simpli.cation As illustrated \nin Figure 8(a), MATLAB has support for very .exible switch statements. Unlike in other languages, all \ncase blocks have implicit breaks at the end. In order to spec\u00adify multiple case comparisons for the same \ncase block, MAT-LAB allows using cell arrays of case expressions, for exam\u00adple {2, 3}in Figure 8(a). \nIndeed, MATLAB allows arbi\u00adtrary case expressions, such as c in the example. If c refers to a cell array, \nthen the case will match if any element of the cell array matches. Without knowing the static type and \nsize of the case expressions, a simpli.cation transformation is not possible. Thus, to enable the static \nsimpli.cation shown in Figure 8(b) we add the constraint for the Tame MATLAB that case-expressions are \nonly allowed to be syntactic cell arrays. switch n t = n case 1 if (isequal(t,1)) ... ... case {2, 3} \nelseif (isequal(t,2) || ... isequal(t,3)) case c ... ... elseif (isequal(t,c)) otherwise ... ... else \nend ... end (a) switch (b) transformed switch Figure 8. Transforming switchstatements  4.4 Example \nThe solveSystem function from the example in Fig\u00adure 3 gets transformed into the code shown in Figure \n9. The code has been transformed into a three-address version, with many temporaries, and all expressions \nhave been turned into calls to the equivalent builtin functions. Note in partic\u00adular how the switch on \nnargin() gets transformed into a series of if-statements (lines 5-20), and how the lambda expression \nis turned into a function. The original lambda expression is represented as a single call (on line 60) \nto a newly introduced function (lines 65-73) that holds the body of the lambda expression. Comments in \nthe origi\u00adnal code are preserved in empty statements that hold the comments (TIRCommentStmt). This means \nthat no other statement contains any comments, and every statement can 1 function [out] = solveSystem(rod,a,A,N,Tspan,Tsteps) \n38 2 % solves the heat equation for some rod of length rod.L, 39 3 % initially at temperature rod.Ta, \nrod.Tb, using N subdivisions. 40 4 % uses default values for Tspan, Tsteps if they are unde.ned 41 5 \n[mc_t10] = nargin(); 42 6 mc_t34 = 4; 43 7 [mc_t12] = isequal(mc_t10, mc_t34); 44 8 if mc_t12 45 9 mc_t36 \n= 0; 46 10 mc_t37 = 10; 47 11 [Tspan] = horzcat(mc_t36, mc_t37); 48 12 Tsteps = 100; 49 13 else 50 14 \nmc_t38 = 5; 51 15 [mc_t11] = isequal(mc_t10, mc_t38); 52 16 if mc_t11 53 17 Tsteps = 100; 54 18 else \n55 19 end 56 20 end 57 21 [mc_t17] = rod.L; 58 22 mc_t39 = 1; 59 23 [mc_t18] = plus(N, mc_t39); 60 24 \n[h] = mrdivide(mc_t17, mc_t18); 61 25 % step size in x 62 26 mc_t21 = h; 63 27 mc_t22 = h; 64 28 [mc_t24] \n= rod.L; 65 29 mc_t25 = h; 66 30 [mc_t23] = minus(mc_t24, mc_t25); 67 31 [mc_t20] = colon(mc_t21, mc_t22, \nmc_t23); 68 32 [mc_t19] = vertcat(mc_t20); 69 33 [X] = ctranspose(mc_t19); 70 34 % create x axis with \nsubidivisions 71 35 U0 = X; 72 36 % allocate u0 73 37 [mc_t27] = length(X); mc_t40 = 2; [mc_t26] = mrdivide(mc_t27, \nmc_t40); [mid] = round(mc_t26); [mc_t13] = rod.Ta; mc_t41 = 1; [mc_t15] = colon(mc_t41, mid); U0(mc_t15) \n= mc_t13; % set left to Ta [mc_t14] = rod.Tb; mc_t28 = mid; mc_t42 = 1; mc_t43 = 1; [mc_t29] = end(U0, \nmc_t42, mc_t43); [mc_t16] = colon(mc_t28, mc_t29); U0(mc_t16) = mc_t14; % set right to Tb mc_t30 = N; \nmc_t31 = rod.Ta; mc_t32 = rod.Tb; mc_t33 = h; [D, c] = Dxx(mc_t30, mc_t31, mc_t32, mc_t33); % set up \nderivative matrix f = (@(t, u) lambda_1(a, D, c, A, t, u)); % right hand side of ODE [T, out] = RungeKutta2(f, \nTspan, U0, Tsteps);  end function [mc_t0] = lambda_1(a, D, c, A, t, u) mc_t148 = a; [mc_t150] = mtimes(D, \nu); mc_t151 = c; [mc_t149] = plus(mc_t150, mc_t151); [mc_t146] = mtimes(mc_t148, mc_t149); mc_t147 = \nA; [mc_t0] = plus(mc_t146, mc_t147); end Figure 9. Tame IR version of the function solveSystemfrom \nthe example in Figure 3 get transformed without having to worry about preserving comments.  5. Interprocedural \nValue Analysis and Call Graph Construction The core of the MATLAB Tamer is the value analysis. It s an \nextensible monolithic context-sensitive inter-procedural forward propagation of abstract MATLAB values. \nFor every program point, it estimates what possible values every vari\u00adable can take on. Most notably \nit .nds the possible set of mclasses. It also propagates function handle values. This al\u00adlows resolution \nof all possible call edges, and the construc\u00adtion of a complete call graph of a tame MATLAB program. \nThe value analysis is part of an extensible interprocedural analysis framework. It contains a set of \nmodules, one build\u00ading on top of the other. All of them can be used by users of the framework to build \nanalyses. The interprocedural analysis framework (section 5.1) builds on top of the Tame IR and the McSAF \nintrapro\u00adcedural analysis framework. It allows the construction of interprocedural analyses by extending \nan intraprocedural analysis built using the McSAF framework. This frame\u00adwork works together with a callgraph \nobject implement\u00ading the correct MATLAB look up semantics. An analy\u00adsis can be run on an existing callgraph \nobject, or it can be used to build new callgraph objects, discovering new functions as the analysis runs. \n The abstract value analysis (section 5.2), built using the interprocedural analysis framework, is a \ngeneric analy\u00adsis of abstract MATLAB values. The implementation is agnostic to the actual representation \nof abstract values, but is aware of MATLAB mclasses. It can thus build a call graph using the correct \nfunction lookup semantics includ\u00ading function specialization.  We provide an implementation of composite \nvalues like cell arrays, structures and function handles, which is generic in the implementation of abstract \nmatrix val\u00adues (section 5.4). This makes composite values com\u00adpletely transparent, allowing users to \nimplement very .ne-grained abstract value analyses by only providing   an abstraction for MATLAB values \nwhich are matrices, thus simp.ifying developing new analyses. Building on top of all the above modules \nand putting ev\u00aderything together, we provide an abstraction for all MAT-LAB values, which we call simple \nvalues (section 5.5). Since it includes the function handle abstractions, this can be used by users to \nbuild a complete tame MATLAB callgraph. This is the concrete value analysis, whose re\u00adsults are presented \nin section 5.7. 5.1 The Interprocedural Analysis Framework The interprocedural Analysis framework is \nan extension of the intraprocedural .ow analyses provided by the McSAF framework. It is context-sensitive \nto aid code generation targeting static languages like FORTRAN. FORTRAN s poly\u00admorphism features are \nquite limited; every generated vari\u00adable needs to have one speci.c type. The backend may thus require \nthat every MATLAB variable has a speci.c known mclass at every program point. Functions may need to be \nspecialized for different kinds of arguments, which a context-sensitive analysis provides at the analysis \nlevel. In the Tamer framework an interprocedural analysis is a collection of interprocedural analysis \nnodes, which repre\u00adsent a speci.c intraprocedural analysis for some function and some context. The context \nis usually a .ow represen\u00adtation of the passed arguments. Every such interprocedural analysis node produces \na result set using the contained in\u00adtraprocedural analysis. Every interprocedural analysis has an associated \ncall\u00adgraph object, which may initially contain only one function acting as the entry point for the program. \nThe interprocedu\u00adral analysis requires a context or argument set for the entry point function. The analysis \nstarts by creating an interprocedural analysis node for the entry point function and the associated context, \nwhich triggers the associated intraprocedural .ow analysis. As the intraprocedural .ow analysis encounters \ncalls to other functions, it has to create context objects for those calls, and ask the interprocedural \nanalysis to analyze the called functions using the given context. The call also gets added to the set \nof call edges associated with the interprocedural analysis node. As the interprocedural analysis has \nto analyze newly en\u00adcountered calls, the associated functions are resolved, and loaded into the callgraph \nif necessary. The result is a com\u00adplete callgraph, and an interprocedural analysis. The interprocedural \nanalysis framework supports simple and mutual recursion by performing a .xed point iteration within the \n.rst recursive interprocedural analysis node.  5.2 Introducing the Value Analysis The abstract value \nanalysis is a forward propagation of generic abstract MATLAB values. The mclass of any abstract value \nis always known. A speci.c instance of a value analysis may use different representations for values \nof different mclasses. For exam\u00adple, function handle values may be represented in a different way than \nnumeric values. This in turn means that values of different Matlab classes can not be merged (joined). \n5.2.1 Mclasses, Values and Value Sets: To de.ne the value analysis independently of a speci.c rep\u00adresentation \nof values, We .rst de.ne the set of all mclasses: C = {double, single, logical, cell,...} For each mclass, \nwe need some lattice of values that repre\u00adsent estimations of MATLAB values of that class: Vmclass ={v \n: v approximates a value with mclass mclass}, mclass . C We require that merge operations are de.ned, \nso .v1,v2 . Vmclass,v1 .v2 . Vmclass. We can not join values of different mclasses, because their actual \nrepresentation may be incompatible. So VC is not a lattice. In order to allow union values for variables, \ni.e. to allow variables to have more than one possible mclass, we estimate the value of a MATLAB variable \nas a set of pairs of abstract values and their mclasses, where the mclasses are disjoint. We call this \na value set. More formally, we de.ne a value set as: V alueSet = {(mclass1,v1),..., (mclassn,vn): classi \nclassj , classi . C, vi . Vclassi = } Or the set of all possible value sets given a set V of lattices \nfor every mclass. SV = {{(mclassk,vk): mclassi mclassj ,vi . ,k . 0..n}: = Vmclassi 0 = n =|C|} This \nis a lattice, with the join operation which is the simple set union of all the pairs, but for any two \npairs with matching mclasses, their values get joined, resulting in only one pair in the result set. \nWhile the notion of a value set allows the analysis to deal with ambiguous variables, still building \na complete callgraph and giving a valid estimation of types, having ambiguous variables is not conducive \nto code generation for a language like FORTRAN. So if (..) t = 4; else t = 'hi'; end  results in \nt having the abstract value {(double, 4), (char, hi )}. This example is not tame MATLAB.  5.2.2 Flow \nSets: We de.ne a .ow set as a set of pairs of variables and value sets, i.e. f low = {(var1,s1), (var2,s2), \n..., (varn,sn): si . SV , vari = varj } and we de.ne an associated look-up operation f low(var)= s if \n(var, s) . f low This is a lattice whose merge operation resembles that of the value sets. Flow sets \nmay be nonviable, representing non-reachable code (for statements after errors, or non-viable branches). \nJoining any non-bottom .ow set with the nonviable set results in the viable .ow set. joining bottom and \nnonviable results in nonviable.  5.2.3 Argument and Return sets: The context or argument set for the \ninterprocedural analysis is a vector of values representing argument values. Argu\u00adments are not value \nsets, but simple values v . Vc with a single known mclass c. When encountering a call, the anal\u00adysis \nhas to construct all combinations of possible argument sets, construct a context from that and analyze \nthe call for all such contexts. For example, if we reach a call r = foo(a,b) with a .ow set {(a, {(double,v1 \n), (char,v2 )}), (b, {(logical,v3 )})}, the value analysis constructs two contexts, from (v1,v3) and \n(v2,v3), and analyzes function foowith each context. Note how the dominant argument for the .rst context \nis double, whereas it is char for the second. If there exist mclass specialized versions for foo, then \nthis results in call edges to, and analysis of, two different functions. More formally, for a call f \nunc(a1, a2, \u00b7\u00b7\u00b7 , an) at pro\u00adgram point p, with the input .ow set fp, we have the set of all possible \ncontexts I allargs =fp(a1) \u00d7 fp(a2) \u00d7 \u00b7\u00b7\u00b7 \u00d7 fp(an)= fp(ai). 1=i=n The interprocedural analysis needs \nto analyze f unc with all these contexts and merge the result, 1 R = analyze(f unc, arg). arg.allargs \nTo construct a context, the value analysis may simplify (push up) values to a more general representation. \nFor exam\u00adple, if the value abstraction includes constants, the push up operation may turn constants into \ntop. Otherwise, the num\u00adber of contexts for any given function may grow unnecessar\u00adily large. The result \nof analyzing a function with an argument set is a vector of value sets, where every component represents \na returned variable. They are joined by component-wise joining of the value sets. In the value analysis \nwe require that for a particular call, the number of returned variables is the same for all possible \ncontexts. 5.2.4 Builtin Propagators: Every implementation of the value abstractions needs to provide \na builtin propagator, which provides .ow equations for builtins. If B is the set of all de.ned builtin \nfunctions {plus, minus, sin,...}, then the builtin propagator PV for some representation of values VC \nis a function mapping a builtin and argument set to a result set.  PV : B \u00d7 (VC )n . (SV )n n.N n.N \n The builtin framework provides tools to help implement builtin propagators by providing builtin visitor \nclasses. The framework also provides attributes for builtin functions, for example the class propagation \ninformation attributes.  5.3 Flow Equations In the following subsection we will show a sample of .ow \nequations to illustrate the .ow analysis. We assume a state\u00adment to be at program point p, with incoming \n.ow set fp. The .ow equation for program point p results in the new .ow set f; p vart = vars: f ; = \\{(vart,fp(vart))}.{(var, \nfp(vars))} p fp var = l, where l is a literal with mclass cl and value representation vl: f;= fp \\{(var, \nfp(var))}.{(var, {(cl,vl)})} p [t1,t2,...,tm]= f unc(a1,a2,...,an), a function call to some function \nf unc: with . . PV (b, args) . . -if f unc with args refers to a builtin b callf unc,arg = . analyze(f, \nargs) . . -if f unc(args) refers to a function f we set 1 R = callfunc,args args.fp (a1 )\u00d7fp (a2 )\u00d7\u00b7\u00b7\u00b7\u00d7fp \n(an ) then mm  f ; = fp \\{(ti,fp(ti))}. {(ti,Ri)} p i=1 i=1 Note that when analyzing a call to a function \nin an m-.le, the argument values will be pushed up. For calls to builtins, the actual argument values \nwill be used, effectively in-lining the behaviour of builtin functions.  5.4 Structures, Cell Arrays \nand Function Handles We implemented a value abstraction for structs, cell arrays and function handles \n(which we call AggrValue inter\u00adnally). This abstraction is again modular, this one with re\u00adspect to the \nrepresentation of matrix values (i.e. values with mclass double, single, char, logical or integer). Structures, \ncell arrays and function handles act as contain\u00aders for other values, making them effectively transparent. \nA user may provide a .ne-grained abstraction for just matrix values and combine it with abstraction of \ncomposite values to implement a concrete value analysis. 5.4.1 struct, cell: For structures and cell \narrays, there are two possible abstrac\u00adtions: tuple: The exact index set of the struct/cellis known \nand every indexing operation can be completely resolved statically. Then the value is represented as \na set of pairs {(i1,s1), (i2,s2), .., (in,sn): ik . I, sn . SV }, where I is an index set -integer vectors \nfor cell arrays, and .eldnames for structs.  collection: Not all indexing operations can be statically \nresolved, or the set of indices is unknown. In this case, all value sets contained in the struct or cell \nare merged together, and the representation is a single value set s . SV .  The usual representation \nfor a structure is a tuple, because usually all accesses (dot-expressions) are explicit in the code and \nknown. Cell arrays are usually a collection, because the index expressions are usually not constant. \nBut cell arrays tend to have homogeneous mclass values, so there is some expectation that any access \nof a structor cellresults in some unambiguous mclass and thus allows static compila\u00adtion.  5.4.2 function \nhandle: As explained in section 2.5, function handles can be created either by referring to an existing \nfunction, or by using a lambda expression to generate an anonymous function using a lambda expression. \nThe lambda simpli.cation (presented in section 4.2) reduces lambda expressions to single calls. We model \nall function handles as sets of function han\u00addle pairs. A function handle pair consists of a reference \nto a function and a vector of partial argument value sets. A func\u00adtion handle value may thus refer to \nmultiple possible func\u00adtion/partial argument pairs. Given some .ow set fp de.ned at the program point \np, g = @sin results in f p . =fp \\ (g, fp (g)). {(g, {(function handle, {(sin, ())})})} g = @(t,y) lambda1(D,c,t,y) \nresults in f . p =fp \\ (g, fp (g)). {(g, {(function handle, {(lambda1, (fp (D),fp (c)))})})} Note that \nfunction handles get invoked at array get state\u00adments, rather than calls. That is because the tame IR \nis con\u00adstructed without mclass information, and will correctly in\u00adterpret a function handle as a variable. \nWhen the target of an array get statement is a function handle, the analysis inserts one or more call \nedges at that program point, referring to the functions contained in the function handle.  5.5 The Simple \nMatrix Abstraction Using the value abstraction for structures, cell arrays and function, we implemented \na concrete value abstraction by adding an abstraction for matrix values, which we call sim\u00adple matrix \nvalues. On top of the required mclass, this ab\u00adstraction merely adds constant propagation for scalar \ndou\u00adbles, strings (char vectors), and scalar logicals. This allows the analysis of MATLAB code utilizing \nop\u00adtional function arguments using the builtin function nargin, and some limited dynamic features utilizing \nstrings. For ex\u00adample, a call like ones(n,m, int8 )can be considered tame. This implementation represents \nthe concrete value analy\u00adsis that is used to construct complete callgraphs. 5.6 Example The concrete \nvalue analysis using simple matrix values is able to build a complete callgraph for our example intro\u00adduced \nin Sec. 2.8, and .nd a unique mclass for every variable at every program point. It includes and analyzes \nthe MAT-LAB library function toeplitz. This includes resolution of structures as well as function handles \ncreated by a lambda expression. The analysis .nds the following function calls, with their associated \narguments and return values: main: double -> single solveSystem: struct{Ta=single, Tb=single, L=single}, \n double, double, double, double -> single  Dxx: double, single, single, single -> single, single toeplitz: \ndouble, double -> double RungeKutta2: (handle, @lambda_1(double, single, single, double,..), double, \nsingle, double -> double, single  lambda_1: double, single, single, double, double, single -> single \n Note the structure and the function handle, and the mix of singleand doublevalues. We have included \nthe complete program, which is the result of the tamer, in appendix A. It is shown in the Tame IR form, \nwith the result of the value analysis annotated to every assignment statement. The complete resolution \nof every value is only possible because we include constant propagation. For example, it allows the value \nanalysis to know which case for the switch statement in solveSystem is valid. Also, the included function \ntoeplitzincludes the lines [xclass] = class(x); % xclass=(char,double) [mc_t90] = zeros(xclass); % mc \nt90=(double) Without knowing that the variable xclassholds the string double , the following call to \nzeros wouldn t be known to return a double, and the value analysis would have to assume the result could \nbe any numerical value (double, single, or any integer).  5.7 Applying the Value Analysis In order to \nexercise the framework, we applied it to the set of benchmarks we have previously used for evaluating \nMcVM/McJIT[13], a dynamic system. The benchmarks and results are given in Table 1. About half of the \nbenchmarks come from the FALCON project[20] and are purely array\u00adbased computations. The other half of \nthe benchmarks were collected by the McLAB team and cover a broader set of ap\u00adplications and use more \nlanguage features such as lambda expressions, cell arrays and recursion. The columns labeled #Fn correspond \nto the number of user functions, and the column labeled #BFn corresponds to the number of builtin functions \nused by the benchmark. Note the high number of builtins. The column labeled Wild indicates if our sys\u00adtem \nrejected the program as too wild. Only the sdku bench\u00admark was rejected because it used the load library \nfunc\u00adtion which loads arbitrary variables from a stored .le. It is likely that we should provide a tamer \nversion of load. The column labeled Mclass indicates unique if the interpro\u00adcedural value propagation \nfound a unique mclass for every variable in the program. Only three benchmarks had one or more variables \nwith multiple different mclasses. We veri.ed that it was really the case that a variable had two different \npossible classes in those three cases. Although the main point of this experiment was just to exercise \nthe framework, we were very encouraged by the number of benchmarks that were not wild and the overall \naccuracy of the basic interprocedural value analysis. We expect many other analyses to be built using \nthe framework, with different abstractions. By implementing them all in a common framework we will be \nbe able to compare the different approaches.  6. Building on the Tamer The Tamer framework, as presented \nin this paper, is intended both to support further analyses and to provide the building blocks for a \nvariety of back-ends. 6.1 Using the Tamer for further analyses There are several ways in which the Tamer \nsupports exten\u00adsions or further analyses. 6.1.1 Implementing new Value Abstractions As discussed in Sec. \n5.5, we have built a concrete value anal\u00adysis that is used to build the callgraph, which is built on \ntop of the composite value abstraction for structures, cell arrays and function handles. The most common \ncase to extend the value analysis is to provide a different implementation for matrix values, while reusing \nthe abstraction for the compos\u00adite values. Many .ow analyses that attempt to estimate some aspect of \nMATLAB values are only concerned with MATLAB values that are matrices. They are basically independent \nof the be\u00adhaviour of composite values, except that these may contain matrices. This can be exactly addressed \nby providing a new matrix abstraction: the user only has to provide the abstrac\u00adtion for matrix values, \na factory class that can produce these matrix values, and a class that de.nes the .ow equations for builtins \nfor that matrix abstraction. The whole machinery of the value analysis can be reused, as well as composite \nval\u00adues -they simply contain whatever matrix value abstraction is being used, as needed. For example, \nan analysis writer may want to implement an analysis that tracks whether matrices are sparse or not (i.e. \ncontain mostly zeros). Sparse matrices can be represented with special data types that can leverage performance \nsparse\u00adness. This property is only relevant to matrices, so the anal\u00adysis can reuse the implemented composite \nvalues and only provide an abstraction for matrices. The user can combine their information about matrices \nwith other components that we have already implemented (like constants) to get a richer or more detailed \nabstraction. Users could also implement a complete new abstraction for values, but still reuse the analysis \nitself. 6.1.2 Implementing other Interprocedural Analyses The interprocedural analysis framework provides \na conve\u00adnient framework for developing new .ow analyses, forward or backward, that must be interprocedural, \nwhich are not necessarily based on .owing abstract representations of MATLAB values forward. For example, \na user may imple\u00adment an interprocedural side-effect analysis, computed on a callgraph that was produced \nby the value analysis. All interprocedural analysis use McSAF-based intrapro\u00adcedural analysis operating \non the Tamer IR. Name Description Source #Fn #BFn Features Wild Mclass adpt Adaptive quadrature Numerical \nMethods 1 17 no unique beul Backward Eurler McLAB 11 30 lambda no unique capr Capacitance Chalmers EEK \n170 4 12 no unique clos Transitive Closure Otter 1 10 no unique crni Tridiagonal Solver Numerical Methods \n2 14 no unique dich Dirichlet Solver Numerical Methods 1 14 no unique diff Light Diffraction Appelbaum \n(MUC) 1 13 no unique edit Edit Distance Castro (MUC) 1 6 no unique fdtd Finite Distance Time Domain Chalmers \nEEK 170 1 8 no unique fft Fast Fourier Transform Numerical Recipes 1 13 no multi .ff Finite Difference \nNumerical Methods 1 8 no unique mbrt Mandelbrot Set McLAB 2 12 no unique mils Mixed Integer Least Squares \nChang and Zhou 6 35 no unique nb1d 1-D Nbody Otter 2 9 no unique nb3d 3-D Nbody Otter 2 12 no unique \nnfrc Newton Fractal McLAB 4 16 no unique nne Neural Net McLAB 3 16 cell no unique play Minimax Search \nMcLAB 5 26 recursive, cell no multi rayt Raytracer Aalborg (Jensen) 2 28 no unique sch2 Sparse Schroed. \nEqn Solver McLAB 8 32 cell, lambda no unique schr Schroedinger Eqn Solver McLAB 8 31 cell, lambda no \nunique sdku Sodoku Puzzle Solver McLAB 8 load yes sga Vectorized Genetic Algorithm Burjorjee 4 30 no \nmulti svd SVD Factorization McLAB 11 26 no unique Table 1. Results of Running Value Analysis  6.2 Using \nthe Tamer for back-ends The tamer provides a convenient IR, a complete call graph, and the mclass information \nfor each variable. This provides a good starting point for developing back-ends. In the McLAB group we \nare developing two such back-ends, one for gener\u00adating FORTRAN and another for generating X10 code. Other \nresearch groups are also starting to use the Tamer frame\u00adwork, including a project for a back-end for \nModelica. We would like to encourage other compiler writers inter\u00adested in MATLAB to consider using the \nTamer, so that they can focus on issues in their backend. For example, a recent MATLAB compiler system \ncalled MEGHA ( MATLAB Ex\u00adecution on GPU based Heterogeneous Architectures )[18] focuses on translating \nprograms for parallel execution on GPU and CPU. They use a relatively small subset of MAT-LAB that does \nnot even include user functions; the whole program is assumed to be one script. Using the Tamer they \ncould support a wider set of features, even if the Tamer were just used to pre-process programs into \na single inlined func\u00adtion (which is one possible output).  7. Related Work There are several categories \nof related work. First, we have the immediate work upon which we are building. The McLAB project already \nprovided the front-end and the McSAF [5, 7] analysis framework, which provided an impor\u00adtant basis for \nthe Tamer. We also learned a lot from McLAB s previous McFOR project[14] which was a .rst prototype MATLAB \nto FORTRAN95 compiler. McFOR supported a smaller subset of the language, did not have a comprehen\u00adsive \napproach to the builtin functions, and had a much more ad hoc approach to the analyses. However, it really \nshowed that conversion of MATLAB to FORTRAN95 was possible, and that FORTRAN95 is an excellent target \nlanguage. In this paper we have gone back to the basics and de.ned a much larger subset of MATLAB, taken \na more structured and ex\u00adtensible approach to building a general toolkit, tackled the problem of a principled \napproach to the builtins, and de.ned the interprocedural analyses in a more rigorous and extensi\u00adble \nfashion. The next generation of McFOR, as well as other backends, can now be built upon these new foundations. \n Although we were not able to .nd publicly available ver\u00adsions, there have been several excellent previous \nresearch projects on static compilation of MATLAB which focused particularly on the array-based subset \nof MATLAB and de\u00adveloped advanced static analyses for determining shapes and sizes of arrays. For example, \nFALCON [20] is a MATLAB to FORTRAN90 translator with sophisticated type inference al\u00adgorithms. Our Tamer \nis targeting a larger and more modern set of MATLAB that includes other types of data structures such \nas cell arrays and structs, function handles and lambda expressions, and which obeys the modern semantics \nof MAT-LAB 7. We should note that FALCON handled interproce\u00addural issues by fully inlining all of the \nthe code. MaJIC[2], a MATLAB Just-In-Time compiler, is patterned after FAL\u00adCON. It uses similar type \ninference techniques to FALCON, but they are simpler to .t the JIT context. MAGICA [11, 12] is a type \ninference engine developed by Joisha and Banerjee of Northwestern University, which is written in Mathematica \nand is designed as an add-on module used by MAT2C com\u00adpiler [10]. We hope to learn from the advanced \ntype infer\u00adence approaches in these projects and to implement similar approximations using our interprocedural \nvalue analysis. The previously mentioned MEGHA project[18] provides an interesting approach to map MATLAB \narray operations to CPUs and GPUs, but only supports a very small subset of MATLAB. There are also commercial \ncompilers, which are not pub\u00adlicly available, and for which there are no research articles. One such \nproduct is the MATLAB Coder recently released by MathWorks[15]. This product produces C code for a subset \nof MATLAB. According to our preliminary tests, this product does not appear to support cell arrays except \nin very speci.c circumstances, nor does it support a general form of lambda expressions, and was therefore \nunable to handle quite a few of our benchmarks. However, the key differences with our work is that we \nare designing and providing an extensible and open source toolkit for compiler and tool researchers. \nThis is clearly not the main goal of proprietary compilers. There are other projects providing open source \nimple\u00admentations of MATLAB-like languages, such as Octave[1] and Scilab[9]. Although these add valuable \ncontributions to the open source community, their focus is on providing in\u00adterpreters and open library \nsupport and they have not tackled the problems of static compilation. Thus, we believe that our contributions \nare complementary. Other dynamic languages have had very successful ef\u00adforts in de.ning compilable subsets \nand statically analyzing whole programs. For example RPython[3] uses a similar ap\u00adproach to ours, de.ning \na reduced set of python that can be statically compiled, requiring that all variables have a unique possible \ntype, while providing an analysis and compiler to compile that subset. RPython does not produce multiple \nver\u00adsions of a function if it is called with different arguments; so every function can only be used \nwith one set of argument types. DiamondbackRuby (DRuby) is a static type inference toolkit for Ruby [8], \nmostly with the goal to gain the ad\u00advantage of static languages to report potential errors ahead of time. \nRuby, like MATLAB, is a dynamic, interpreted lan\u00adguage, with many library functions in native code -which \nmay also have different behaviours depending on the incom\u00ading argument types. Thus DRuby has to provide \ntype infor\u00admation for builtin functions. In order to that, DRuby includes a type annotation language, \nwhich can also be used to spec\u00adify types for functions with dif.cult behaviour. DRuby con\u00adstrains the \nset of supported language features to enable the static analysis, but allows some of them by inserting \nruntime checks to still be able to support them. These are included in such a way as to help users identify \nwhere exactly the error occurred.  8. Conclusions This paper has introduced the MATLAB Tamer, an extensi\u00adble \nobject-oriented framework for supporting the translation from dynamic MATLAB programs to a Tame IR, call \ngraph and class/type information suitable for generating static code. We provided an introduction to \nthe features of MAT-LAB in a form that we believe helps expose the semantics of mclasses and function \nlookup for compiler and tool writers. We tackled the somewhat daunting problem of handling the large \nnumber of builtin functions in MATLAB by de.ning an extensible hierarchy of builtins and a small domain-speci.c \nlanguage to de.ne their behaviour. We de.ned a Tame IR and added functionality to McSAF to produce the \nIR and to extend the analysis framework to handle the new IR nodes introduced. Finally, we developed \nan extensible interpro\u00adcedural analysis framework and an extensible value analy\u00adsis that can be used \nto build a complete callgraph, which estimates the mclass of every variable. We provide these frameworks, \nfor users to implement further interprocedural analyses, or as an entry point for static MATLAB compilers. \nOur initial experiments with the framework are very en\u00adcouraging and we are now working on using the \nframework to implement back-ends, and we hope that others will also use the framework for a variety of \nstatic MATLAB tools.12 We also plan to continue developing the value analysis to add richer abstractions \nfor shape and other data structure proper\u00adties. Finally, as a part of a larger project on benchmarking \nMATLAB, we hope to expand our set of benchmarks and to further examine which features might be tamed, \nand to ex\u00adtend our set of automated refactorings. References [1] GNU Octave. http://www.gnu.org/software/ \noctave/index.html. [2] G. Alm\u00b4asi and D. Padua. MaJIC: compiling MATLAB for speed and responsiveness. \nIn PLDI 02: Proceedings of the ACM SIGPLAN 2002 Conference on Programming Language Design and Implementation, \npages 294 303, New York, NY, USA, 2002. ACM. [3] D. Ancona, M. Ancona, A. Cuni, and N. D. Matsakis. Rpython: \na step towards reconciling dynamically and stati\u00adcally typed oo languages. In DLS 07: Proceedings of \nthe 2007 symposium on Dynamic languages, pages 53 64, New York, NY, USA, 2007. ACM. [4] M. Chevalier-Boisvert, \nL. Hendren, and C. Verbrugge. Opti\u00admizing MATLAB through Just-In-Time Specialization. In In\u00adternational \nConference on Compiler Construction, pages 46 65, March 2010. 12 The Tamer and McLAB release is available \nat http://www.sable. mcgill.ca/mclab/software/software_releases_mclab. html. [5] J. Doherty. McSAF: \nAn Extensible Static Analysis Frame\u00adwork for the MATLAB Language. Master s thesis, McGill University, \nDecember 2011. [6] J. Doherty, L. Hendren, and S. Radpour. Kind analysis for MATLAB. In In Proceedings \nof OOPSLA 2011, pages 99 118, 2011. [7] J. Doherty and L. J. Hendren. McSAF: A static analysis framework \nfor MATLAB. In Proceedings of the 26th Euro\u00adpean Conference on Object-Oriented Programming, volume 7313, \npages 132 155, 2012. [8] M. Furr, J.-h. D. An, J. S. Foster, and M. Hicks. Static type inference for \nRuby. In Proceedings of the 2009 ACM symposium on Applied Computing, SAC 09, pages 1859 1866, New York, \nNY, USA, 2009. ACM. [9] INRIA. Scilab, 2009. http://www.scilab.org/ platform/. [10] P. G. Joisha. a MATLAB-to-C \ntranslator, 2003. http://www.ece.northwestern.edu/cpdc/ pjoisha/MAT2C/. [11] P. G. Joisha and P. Banerjee. \nStatic array storage optimization in MATLAB. In PLDI 03: Proceedings of the ACM SIG-PLAN 2003 conference \non Programming Language Design and Implementation, pages 258 268, New York, NY, USA, 2003. ACM. [12] \nP. G. Joisha and P. Banerjee. An algebraic array shape in\u00adference system for MATLAB\u00ae. ACM Trans. Program. \nLang. Syst., 28(5):848 907, 2006. [13] N. Lameed and L. J. Hendren. Staged static techniques to ef.ciently \nimplement array copy semantics in a MATLAB JIT compiler. In Proceedings of the International Compiler \nConference (CC11), pages 22 41, 2011. [14] J. Li. McFor: A MATLAB to FORTRAN 95 Compiler. Mas\u00adter s thesis, \nMcGill University, August 2009. [15] MathWorks. MATLAB Coder. http://www. mathworks.com/products/matlab-coder/. \n[16] C. Moler. The Growth of MATLAB and The Math-Works over Two Decades. http://www.mathworks. com/company/newsletters/news_notes/ \nclevescorner/jan06.pdf. [17] C. Moler. The Origins of MATLAB. http: //www.mathworks.com/company/newsletters/ \nnews_notes/clevescorner/dec04.html. [18] A. Prasad, J. Anantpur, and R. Govindarajan. Automatic com\u00adpilation \nof MATLAB programs for synergistic execution on heterogeneous processors. In Proceedings of the 32nd \nACM SIGPLAN conference on Programming Language Design and Implementation, PLDI 11, pages 152 163, New \nYork, NY, USA, 2011. ACM. [19] S. Radpour. Understanding and Refactoring MATLAB. Mas\u00adter s thesis, McGill \nUniversity, January 2012. [20] L. D. Rose and D. Padua. Techniques for the translation of MATLAB programs \ninto Fortran 90. ACM Trans. Program. Lang. Syst., 21(2):286 323, 1999.  A. Example Result The following \ncode is what the Tamer produces for the example introduced in section Sec. 2.8. Since MATLAB is a proprietary \nsystem, we opted to omit the body of the library function that was included in the callgraph. % args: \n{N=(double)} function [result] = main(N) mc_t4 = 10; % mc t4=(double,10.0) [mc_t1] = single(mc_t4); % \nmc t1=(single) rod.L = mc_t1; % rod=struct{L=(single)} mc_t5 = 3; % mc t5=(double,3.0) [mc_t2] = single(mc_t5); \n% mc t2=(single) rod.Ta = mc_t2; % rod=struct{Ta=(single), L=(single)} mc_t6 = 4; % mc t6=(double,4.0) \n[mc_t3] = single(mc_t6); % mc t3=(single) rod.Tb = mc_t3; % rod=struct{Ta=(single), Tb=(single), L=(single)} \na = .2; % a=(double,0.2) A = 0.05; % A=(double,0.05) mc_t8 = 0; % mc t8=(double,0.0) mc_t9 = 20; % mc \nt9=(double,20.0) [Tspan] = horzcat(mc_t8, mc_t9); % Tspan=(double) [result] = solveSystem(rod, a, A, \nN, Tspan); % result=(single) end % results: [( single )] % args: {rod=struct{Ta=(single), Tb=(single), \nL=(single)}, % a=(double), A=(double), N=(double), Tspan=(double)} function [out]=solveSystem(rod,a,A,N,Tspan,Tsteps) \n[mc_t10] = nargin(); % mc t10=(double,5.0) mc_t34 = 4; % mc t34=(double,4.0) [mc_t16] = isequal(mc_t10,mc_t34);% \nmc t16=(logical,false) if mc_t16 mc_t36 = 0; % non-viable mc_t37 = 10; % non-viable [Tspan] = horzcat(mc_t36, \nmc_t37);% non-viable Tsteps = 100; % non-viable else mc_t38 = 5; % mc t38=(double,5.0) [mc_t15] = isequal(mc_t10,mc_t38);% \nmc t15=(logical,true) if mc_t15 Tsteps = 100; % Tsteps=(double,100.0) else end end [mc_t17] = rod.L; \n% mc t17=(single) mc_t39 = 1; % mc t39=(double,1.0) [mc_t18] = plus(N, mc_t39); % mc t18=(double) [h] \n= mrdivide(mc_t17, mc_t18);% h=(single) mc_t21 = h; % mc t21=(single) mc_t22 = h; % mc t22=(single) [mc_t24] \n= rod.L; % mc t24=(single) mc_t25 = h; % mc t25=(single) [mc_t23] = minus(mc_t24, mc_t25);% mc t23=(single) \n[mc_t20] = colon(mc_t21, mc_t22, mc_t23); % mc t20=(single) [mc_t19] = vertcat(mc_t20);% mc t19=(single) \n [X] = ctranspose(mc_t19); % X=(single) U0 = X; % U0=(single) [mc_t27] = length(X); % mc t27=(double) \nmc_t40 = 2; % mc t40=(double,2.0) [mc_t26] = mrdivide(mc_t27, mc_t40);% mc t26=(double) [mid] = round(mc_t26); \n% mid=(double) [mc_t11] = rod.Ta; % mc t11=(single) mc_t41 = 1; % mc t41=(double,1.0) [mc_t13] = colon(mc_t41, \nmid); % mc t13=(double) U0(mc_t13) = mc_t11; % U0=(single)  [mc_t12] = rod.Tb; % mc t12=(single) mc_t28 \n= mid; % mc t28=(double) mc_t42 = 1; % mc t42=(double,1.0) mc_t43 = 1; % mc t43=(double,1.0) [mc_t29] \n= end(U0, mc_t42, mc_t43);% mc t29=(double) [mc_t14] = colon(mc_t28, mc_t29);% mc t14=(double) U0(mc_t14) \n= mc_t12; % U0=(single) mc_t30 = N; % mc t30=(double) mc_t31 = rod.Ta; % mc t31=(single) mc_t32 = rod.Tb; \n% mc t32=(single) mc_t33 = h; % mc t33=(single) [D, c] = Dxx(mc_t30, mc_t31, mc_t32, mc_t33); % D=(single), \nc=(single) f = (@(t, u) lambda_1(a, D, c, A, t, u)); % f=(handle,@lambda 1((double), (single), (single), \n(double),.. )) [T, out] = RungeKutta2(f, Tspan, U0, Tsteps); % T=(double), out=(single) end % results: \n[( single )] % args: {N=(double), a=(single), b=(single), h=(single)} function [D, c] = Dxx(N, a, b, \nh) mc_t62 = 2; % mc t62=(double,2.0) [mc_t51] = uminus(mc_t62); % mc t51=(double) mc_t63 = 2; % mc t63=(double,2.0) \n[mc_t53] = minus(N, mc_t63); % mc t53=(double) mc_t64 = 1; % mc t64=(double,1.0) [mc_t52] = zeros(mc_t53, \nmc_t64); % mc t52=(double) mc_t65 = 1; % mc t65=(double,1.0) [mc_t46] = vertcat(mc_t51, mc_t65, mc_t52); \n% mc t46=(double) mc_t66 = 2; % mc t66=(double,2.0) [mc_t48] = uminus(mc_t66); % mc t48=(double) mc_t67 \n= 2; % mc t67=(double,2.0) [mc_t50] = minus(N, mc_t67); % mc t50=(double) mc_t68 = 1; % mc t68=(double,1.0) \n[mc_t49] = zeros(mc_t68, mc_t50); % mc t49=(double) mc_t70 = 1; % mc t70=(double,1.0) [mc_t47] = horzcat(mc_t48, \nmc_t70, mc_t49); % mc t47=(double) [mc_t44] = toeplitz(mc_t46, mc_t47); % mc t44=(double) mc_t71 = 2; \n% mc t71=(double,2.0) [mc_t45] = mpower(h, mc_t71); % mc t45=(single) [D] = rdivide(mc_t44, mc_t45); \n% D=(single) mc_t60 = a; % mc t60=(single) mc_t72 = 2; % mc t72=(double,2.0) [mc_t61] = mpower(h, mc_t72); \n% mc t61=(single) [mc_t54] = mrdivide(mc_t60, mc_t61); % mc t54=(single) mc_t73 = 2; % mc t73=(double,2.0) \n[mc_t59] = minus(N, mc_t73); % mc t59=(double) mc_t74 = 1; % mc t74=(double,1.0) [mc_t55] = zeros(mc_t59, \nmc_t74); % mc t55=(double) mc_t57 = b; % mc t57=(single) mc_t75 = 2; % mc t75=(double,2.0) [mc_t58] = \nmpower(h, mc_t75); % mc t58=(single) [mc_t56] = mrdivide(mc_t57, mc_t58); % mc t56=(single) [c] = vertcat(mc_t54, \nmc_t55, mc_t56); % c=(single) end % results: [(single), (single)] % args: {c=(double), r=(double)} \nfunction [t] = toeplitz(c, r) [mc_t80] = nargin(); % mc t80=(double,2.0) ... Code Omitted t(:) = mc_t77; \n% t=(double) end % results: [( double)] % args: {f=(handle,@lambda 1((double),(single),(single),(double), \n.. )), % tspan=(double), y0=(single), N=(double)} function [X, Y] = RungeKutta2(f, tspan, y0, N) mc_t139 \n= 1; % mc t139=(double,1.0) [a] = tspan(mc_t139); % a=(double) mc_t140 = 2; % mc t140=(double,2.0) [b] \n= tspan(mc_t140); % b=(double) [mc_t116] = minus(b, a); % mc t116=(double) mc_t117 = N; % mc t117=(double) \n [h] = mrdivide(mc_t116, mc_t117);% h=(double) mc_t118 = y0; % mc t118=(single) [mc_t120] = length(y0); \n% mc t120=(double) mc_t121 = N; % mc t121=(double) [mc_t119] = zeros(mc_t120, mc_t121);% mc t119=(double) \n [Y] = horzcat(mc_t118, mc_t119);% Y=(single) [mc_t122] = colon(a, h, b); % mc t122=(double) [X] = transpose(mc_t122); \n% X=(double) mc_t145 = 1; % mc t145=(double,1.0) for j = (mc_t145 : N); mc_t123 = h; % mc t123=(double) \n[mc_t125] = X(j); % mc t125=(double) [mc_t126] = Y(:, j); % mc t126=(single) [mc_t124] = f(mc_t125, mc_t126);% \nmc t124=(single) [k1] = mtimes(mc_t123, mc_t124);% k1=(single) mc_t127 = h; % mc t127=(double) [mc_t133] \n= X(j); % mc t133=(double) mc_t134 = h; % mc t134=(double) [mc_t129] = plus(mc_t133, mc_t134); % mc t129=(double) \n[mc_t131] = Y(:, j); % mc t131=(single) mc_t132 = k1; % mc t132=(single) [mc_t130] = plus(mc_t131, mc_t132);% \nmc t130=(single) [mc_t128] = f(mc_t129, mc_t130);% mc t128=(single) [k2] = mtimes(mc_t127, mc_t128);% \nk2=(single) [mc_t135] = Y(:, j); % mc t135=(single) mc_t142 = 1; % mc t142=(double,1.0) mc_t143 = 2; \n% mc t143=(double,2.0) [mc_t137] = mrdivide(mc_t142, mc_t143); % mc t137=(double) [mc_t138] = plus(k1, \nk2); % mc t138=(single) [mc_t136] = mtimes(mc_t137, mc_t138); % mc t136=(single) [mc_t114] = plus(mc_t135, \nmc_t136);% mc t114=(single) mc_t144 = 1; % mc t144=(double,1.0) [mc_t115] = plus(j, mc_t144);% mc t115=(double) \nY(:, mc_t115) = mc_t114; % Y=(single) end end % results: [(double), (single)] % args: {a=(double), \nD=(single), c=(single ), A=(double), % t=(double), u=(single)} function [mc_t0] = lambda_1(a, D, c, A, \nt, u) mc_t148 = a; % mc t148=(double) [mc_t150] = mtimes(D, u); % mc t150=(single) mc_t151 = c; % mc \nt151=(single) [mc_t149] = plus(mc_t150, mc_t151);% mc t149=(single) [mc_t146] = mtimes(mc_t148, mc_t149);% \nmc t146=(single) mc_t147 = A; % mc t147=(double) [mc_t0] = plus(mc_t146, mc_t147);% mc t0=(single) end \n % results: [( single )] B. TIR Grammar In this appendix we present the abstract syntax tree structure \ncorresponding to the grammar for the tame IR. node extends contains TIRAbstractAssignStmt AssignStmt \n- TIRAbstractAssignFromVarStmt TIRAbstractAssignStmt Name rhs TIRArraySetStmt TIRAbstractAssignFromVarStmt \nName arrayVar, TIRCommaSeparatedList indices, Name rhs TIRCellArraySetStmt TIRAbstractAssignFromVarStmt \nName arrayVar, TIRCommaSeparatedList indices, Name rhs TIRDotSetStmt TIRAbstractAssignFromVarStmt Name \ndotVar, Name .eld, Name rhs TIRAbstractAssignToListStmt TIRAbstractAssignStmt IRCommaSeparatedList targets \nTIRArrayGetStmt TIRAbstractAssignToListStmt Name lhs, Name rhs, TIRCommaSeparatedList indices TIRCellArrayGetStmt \nTIRAbstractAssignToListStmt Name cellVar, TIRCommaSeparatedList targets, TIRCommaSeparatedList indices \nTIRDotGetStmt TIRAbstractAssignToListStmt TIRCommaSeparatedList lhs, Name dotVar, Name .eld TIRCallStmt \nTIRAbstractAssignToListStmt Name function, TIRCommaSeparatedList targets, TIRCommaSeparatedList args \n TIRAbstractAssignToVarStmt TIRAbstractAssignStmt Name lhs TIRAssignLiteralStmt TIRAbstractAssignToVarStmt \nName lhs, LiteralExpr rhs TIRCopyStmt TIRAbstractAssignToVarStmt Name lhs, Name rhs TIRAbstractCreateFunctionHandleStmt \nTIRAbstractAssignToVarStmt Name lhs, Name function TIRCreateFunctionReferenceStmt TIRAbstractCreateFunctionHandleStmt \nName lhs, Name function TIRCreateLambdaStmt TIRAbstractCreateFunctionHandleStmt Name lhs, Name function \nList<Name>lambdaParameters, List<Name>enclosedVariables Figure 10. Assignment Statments  We have listed \nall tame IR nodes, together with the par\u00adent class and the nodes they contain. All tame IR nodes ei\u00adther \nextend McSAF s AST nodes, or other Tame IR Nodes. This means that any Tame IR node is also a a valid \nMcSAF AST node. Tame IR nodes may contain other AST nodes, because they are effectively little AST subtrees. \nUsers of the Tame IR should not modify IR Nodes, except the TIRStatementList. They should also only use \nthe ac\u00adcessor methods provided by the Tame IR interfaces. By fol\u00adlowing these conventions users will \nalways create correct Tame IR because the constructors of the Tame IR nodes en\u00adforce the constraints \nof the Tame IR. Figure 10 shows all IR statement nodes that are derived from assignments (Figure 6 in \nSec. 4.1 shows their hierarchy as a tree), Figure 11 shows all remaining statement nodes, Figure 12 shows \nall Tame IR nodes that may contain statements, Figure 13 shows all remaining tame IR nodes.  List<Name>outputParams, \nString name, TIRFunction Function List<Name>inputParams, List<HelpComment>helpComments, TIRStmtList stmts, \nList<TIRFunction>nestedFunctions TIRStmtList List<Stmt> List<TIRStmt>statements  TIRIfStmt IfStmt Name \nConditionVar, TIRStmtList IfStmts, TIRStmtList ElseStmts TIRWhileStmt WhileStmt Name condition, TIRStmtList \nbody TIRForStmt ForStmt Name var, Name lower, (Name inc), Name upper, TIRStmtList stmts Figure 12. Compound \nStructures  Figure 13. Other Tame IR Nodes   \n\t\t\t", "proc_id": "2384616", "abstract": "<p>MATLAB is a dynamic scientific language used by scientists, engineers and students worldwide. Although MATLAB is very suitable for rapid prototyping and development, MATLAB users often want to convert their final MATLAB programs to a static language such as FORTRAN. This paper presents an extensible object-oriented toolkit for supporting the generation of static programs from dynamic MATLAB programs. Our open source toolkit, called the MATLAB Tamer, identifies a large tame subset of MATLAB, supports the generation of a specialized Tame IR for that subset, provides a principled approach to handling the large number of builtin MATLAB functions, and supports an extensible interprocedural value analysis for estimating MATLAB types and call graphs.</p>", "authors": [{"name": "Anton Willy Dubrau", "author_profile_id": "81458658153", "affiliation": "McGill University, Montreal, PQ, Canada", "person_id": "P3856123", "email_address": "anton.dubrau@mail.mcgill.ca", "orcid_id": ""}, {"name": "Laurie Jane Hendren", "author_profile_id": "81100646110", "affiliation": "McGill University, Montreal, PQ, Canada", "person_id": "P3856124", "email_address": "hendren@cs.mcgill.ca", "orcid_id": ""}], "doi_number": "10.1145/2384616.2384653", "year": "2012", "article_id": "2384653", "conference": "OOPSLA", "title": "Taming MATLAB", "url": "http://dl.acm.org/citation.cfm?id=2384653"}