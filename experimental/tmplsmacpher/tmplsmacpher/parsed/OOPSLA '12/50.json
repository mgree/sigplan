{"article_publication_date": "10-19-2012", "fulltext": "\n ReIm &#38; ReImInfer: Checking and Inference of Reference Immutability and Method Purity Wei Huang \nAna Milanova Rensselaer Polytechnic Institute Troy, NY, USA {huangw5, milanova}@cs.rpi.edu Abstract \nReference immutability ensures that a reference is not used to modify the referenced object, and enables \nthe safe sharing of object structures. A pure method does not cause side-effects on the objects that \nexisted in the pre-state of the method execution. Checking and inference of reference immutability and \nmethod purity enables a variety of program analyses and optimizations. We present ReIm, a type system \nfor reference immutabil\u00adity, and ReImInfer, a corresponding type inference analysis. The type system \nis concise and context-sensitive. The type inference analysis is precise and scalable, and requires no \nmanual annotations. In addition, we present a novel applica\u00adtion of the reference immutability type system: \nmethod purity inference. To support our theoretical results, we implemented the type system and the type \ninference analysis for Java. We in\u00adclude a type checker to verify the correctness of the inference result. \nEmpirical results on Java applications and libraries of up to 348kLOC show that our approach achieves \nboth scalability and precision. Categories and Subject Descriptors D.3.3 [Programming Languages]: Language \nConstructs and Features; D.1.5 [Pro\u00adgramming Techniques]: Object-oriented Programming General Terms Experimentation, \nLanguages, Theory 1. Introduction An immutable, or readonly, reference cannot modify the state of an \nobject, including the transitively reachable state. For instance, in the following code, the Date object \ncannot be modi.ed by using the immutable reference rd, but the same Permission to make digital or hard \ncopies of all or part of this work for personal or classroom use is granted without fee provided that \ncopies are not made or distributed for pro.t or commercial advantage and that copies bear this notice \nand the full citation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. OOPSLA 12, October 19 26, 2012, Tucson, Arizona, \nUSA. Copyright c &#38;#169; 2012 ACM 978-1-4503-1561-6/12/10. . . $10.00 Werner Dietl Michael D. Ernst \nUniversity of Washington Seattle, WA, USA {wmdietl, mernst}@cs.washington.edu Date object can be modi.ed \nthrough the mutable reference md: Date md = new Date(); // mutable by default readonly Date rd = md; \n// an immutable reference md.setHours(1); // OK, md is mutable rd.setHours(2); // compile-time error, \nrd is immutable The type quali.er readonly denotes that rd is an immutable reference. By contrast to \nreference immutability, object im\u00admutability enforces a stronger guarantee that no reference in the system \ncan modify a particular object. Each variety of immutability is preferable in certain situations; neither \ndominates the other. This paper only deals with reference immutability. As a motivating example, consider \na simpli.cation of the Class.getSigners method which returns elements that have signed a particular class. \nIn JDK 1.1, it is implemented approximately as follows: class Class { private Object[] signers; public \nObject[] getSigners() { return signers; } } This implementation is not safe because a malicious client \ncan obtain a reference to the signers array by invoking the getSigners method and can then side-effect \nthe array to add an arbitrary trusted signer. Even though the .eld is declared private, the referenced \nobject is still modi.able from the outside. There is no language support for preventing outside modi.cations, \nand the programmer must manually ensure that the code only returns clones of internal data. A solution \nis to use reference immutability and annotate the return value of getSigners as readonly. (A readonly \narray of mutable objects is expressed, following Java 8 syntax [13], as Object readonly [].) As a result, \nmutations of the array through the returned reference will be disallowed: Object readonly [] getSigners() \n{ return signers; }  ... Object readonly [] signers = getSigners(); signers[0] = maliciousClass; // \ncompile-time error A type system enforcing reference immutability has a number of bene.ts. It improves \nthe expressiveness of inter\u00adface design by specifying the mutability of parameters and return values; \nit helps prevent and detect errors caused by unwanted object mutations; and it facilitates reasoning \nabout and proving other properties such as object immutability and method purity. This paper presents \na context-sensitive type system for reference immutability, ReIm, and an ef.cient inference analysis, \nReImInfer. We implemented our inference system for Java and performed case studies of applications and \nlibraries of up to 348kLOC. ReIm is related to Javari [33], the state-of-the-art in reference immutability, \nbut also differs in important points of design and implementation. ReIm s design was motivated by a particular \napplication: method purity inference. As a result, ReIm is simpler than Javari, if less expressive in \nsome respects that are irrelevant to purity inference. ReIm treats every structure as a whole and assigns \na single mutability to the structure. By contrast, Javari contains multiple features for excluding certain \n.elds or generic type arguments from the immutability guarantee, in order to support code patterns such \nas caches and lazily-initialized .elds. Another difference is that ReIm encodes context sensitivity using \nthe concept of viewpoint adaptation from Universe Types [9, 10], while Javari uses templatizing. These \ndesign decisions result in a more compact type system, particularly suitable for reasoning about method \npurity. Our inference system allows programmers to annotate only references they care about (programmers \nmay choose to annotate no references at all). The inference analysis .lls in the remaining types, and \nthe system performs type checking. The inference is precise in the sense that it infers the maximal number \nof immutable references. It has O(n2) worst-case complexity and scales linearly in practice. Our inference \nsystem, ReImInfer, has two advantages over Javari.er [26], the state of the art reference immutability \ninference tool. First, as with ReIm, it models context sensitivity using the concept of viewpoint adaptation \nfrom Universe Types. Javari.er handles context sensitivity by replicating methods. Viewpoint adaptation \ncontributes to the better scalability of ReImInfer compared to Javari.er. Second, ReImInfer relies entirely \non the Checker Framework [11, 23], which provides better integration of programmer-provided annotations, \ntype inference, and type checking. In addition, we present method purity inference built as an application \nof reference immutability. Purity information facilitates compiler optimization [6, 19, 37], model check\u00ad \ning [32], Universe Type inference [12, 18], and memoiza\u00ad tion of procedure calls [17]. Purity inference \n(also known as side-effect analysis) has a long history. Most existing pu\u00adrity or side effect analyses \nare whole-program analyses that are based on points-to analysis and/or escape analysis and therefore \nscale poorly. We know of no purity inference tool that scales to large Java codes and analyzes both whole \npro\u00adgrams and libraries. In fact, the work presented here was motivated by our need for purity information \nfor Universe Type inference [12, 18]. We spent considerable time trying to use existing tools. Unfortunately, \nexisting tools were impre\u00adcise, fragile, whole-program, and/or unscalable, as we detail in Section 4. \nOur solution was to build ReIm and ReImInfer and the purity extension. ReImInfer outperformed existing \ntools, and is fully integrated with the Checker Framework. Our reference immutability inference and purity \ninference are modular and compositional. They are modular in the sense that they can analyze any given \nset of classes L. Unknown callees in L are handled using appropriate defaults. Callers of L can be analyzed \nseparately and composed with L without re-analysis of L. In summary, we make the following contributions: \n ReIm, a context-sensitive type system for reference im\u00admutability. A key novelty in ReIm is the use \nof viewpoint adaptation to encode context sensitivity.  ReImInfer, a type inference algorithm for reference \nim\u00admutability.  A novel application of reference immutability: method purity inference.  An implementation \nfor Java.  An empirical evaluation of reference immutability infer\u00adence and purity inference on programs \nof up to 348kLOC, including widely used Java applications and libraries, com\u00adprising 766kLOC in total. \n The rest of this paper is organized as follows. Section 2 describes the type system and the inference \nanalysis. Sec\u00adtion 3 presents purity inference, and Section 4 describes our experiments. Section 5 discusses \nrelated work, and Section 6 concludes. 2. ReIm Reference Immutability Types This section describes the \nimmutability quali.ers (Sec\u00adtion 2.1) and explains context sensitivity (Section 2.2). It proceeds to \nde.ne the type system for reference immutability (Section 2.3) and the inference analysis (Section 2.4). \n 2.1 Immutability Quali.ers The ReIm type system has three immutability quali.ers: mutable, readonly, \nand polyread. These quali.ers were in\u00adtroduced by Javari [33] (except that polyread was romaybe in Javari \nbut became polyread in Javari.er [26]). They have essentially the same meaning in Javari and ReIm, except \nthat readonly in Javari allows certain .elds and generic type arguments to be excluded from the immutability \nguarantee, while readonly in ReIm guarantees immutability of the entire structure. We detail the differences \nin Section 5.1.  mutable:A mutable reference can be used to mutate the referenced object. This is the \nimplicit and only option in standard object-oriented languages.  readonly:A readonly reference x cannot \nbe used to mutate the referenced object nor anything it references. For example, all of the following \nare forbidden:  x.f = z x.setField(z) where setField sets a .eld of its receiver y = id(x); y.f = z \nwhere id is a function that returns its argument x.f.g = z y = x.f; y.g = z polyread: This quali.er expresses \npolymorphism over immutability. Essentially, polyread denotes a reference is immutable in the current \ncontext, but it may or may not be mutable in other contexts. The interpretation of polyread depends on \nthe context and will be explained in Section 2.2. The subtyping relation between the quali.ers is mutable \n<: polyread <: readonly where q1 <: q2 denotes q1 is a subtype of q2. For example, it is allowed to assign \na mutable reference to a polyread or readonly one, but it is not allowed to assign a readonly reference \nto a polyread or mutable one.  2.2 Context Sensitivity ReIm expresses context sensitivity using a variant \nof view\u00adpoint adaptation [9]. Consider the following code. For read\u00ad ability, code throughout this section \nmakes the formal param\u00adeter this explicit. 1 2 class DateCell {Date date; 3 4 5 Date getDate(DateCell \nthis) { return this.date; }void cellSetHours(DateCell this) {Date md = this.getDate(); 6 md.setHours(1); \n// md is mutated 7 8 9 }int cellGetHours(DateCell this) {Date rd = this.getDate(); 10 int hour = rd.getHours(); \n// rd is readonly 11 return hour; 12 13 }} In the above code, this of cellGetHours may be annotated \nas readonly, which is the top of the type hierarchy. Doing so is advantageous because then cellGetHours \ncan be called on any argument. The return value of method DateCell.getDate is used in a mutable context \nin cellSetHours and is used in a readonly context in cellGetHours. A context-insensitive type system \nwould give the return type of getDate one speci.c type, which would have to be mutable. This would cause \nrd to be mutable, and then this of cellGetHours would have to be mutable as well (if this.date is of \ntype mutable, this means that the current object was modi.ed using this, which forces this to become \nmutable). This violates our goal that this of cellGetHours is readonly. A context-sensitive type is required \nfor the return type of DateCell.getDate. The effective return type will depend on the calling context. \nAn example of calling context is the type of the left-hand side of an assignment statement, when the \ncall is the right-hand side. Another example is the type of a formal parameter, when the call is used \nas an actual argument. The polymorphic quali.er polyread expresses context sensitivity. We annotate this, \nthe return type of getDate, and .eld date as polyread: polyread Date date; polyread Date getDate(polyread \nDateCell this) { return this.date; } Intuitively, viewpoint adaptation instantiates polyread to mutable \nin the context of cellSetHours, and to readonly in the context of cellGetHours. The call this.getDate \non line 5 returns a mutable Date, and the call this.getDate on line 9 re\u00adturns a readonly Date. As a \nresult, the mutability of md prop\u00adagates only to this of cellSetHours; it does not propagate to this \nof cellGetHours which remains readonly. ReIm handles polyread via viewpoint adaptation, and Javari/Javari.er \nhan\u00addle polyread via templatizing methods. The two approaches appear to be semantically equivalent. Viewpoint \nadaptation however, is a more compact and scalable way of handling polymorphism than templatizing. Conceptually, \na method must type-check with each in\u00adstance of polyread replaced by (adapted to) mutable, and with each \ninstance of polyread replaced by readonly. Thus, a polyread reference x cannot be used to mutate the \nreferenced object. A method may return x to the caller, in which case the caller might be able to mutate \nthe object. Programmers should use polyread when the reference is readonly in the scope of the enclosing \nmethod, but may be modi.ed in some caller contexts after the method s return. The type of a polyread \n.eld f is adapted to the viewpoint of the receiver that accesses the .eld. If the receiver x is mutable, \nthen x.f is mutable. If the receiver x is readonly, then x.f is readonly. If the receiver x is polyread, \nthen x.f is polyread and cannot be used to modify the referenced object, as the access might be further \ninstantiated with a readonly receiver. For example, x.f = 0, where x is polyread, is not allowed, but \n z = id(y); z.f = 0, where id is  polyread X id(polyread X x) { return x; } , is allowed when y and \nz are mutable.  We forbid mutable as a quali.er for .elds. ReIm gives a strong reference immutability \nguarantee, including the whole transitive state. A mutable .eld would not depend on the type of the receiver \nand would therefore violate this guarantee. Viewpoint adaptation is a concept from Universe Types [7, \n9, 10], which can be adapted to Ownership Types [5] and ownership-like type systems such as AJ [35]. \nViewpoint adaptation of a type q\" from the point of view of another type q, results in the adapted type \nq\"\". This is written as \" q [ q= q\"\". Traditional viewpoint adaptation from Universe Types de.nes one \nviewpoint adaptation operation [; it uses [ to adapt .elds, formal parameters, and method returns from \nthe point of view of the receiver at the .eld access or method call. Below, we explain viewpoint adaptation \nfor reference immutability. In ReIm, [ adapts .eld accesses from the point of view of the receiver, but \nadapts method calls from the point of view of the variable at the left-hand-side of the call assignment. \nThis concept is also known as the calling context or call-site context. We de.ne [ as: [ mutable = mutable \n[ readonly = readonly q [ polyread = q The underscore denotes a don t care value. Quali.ers mutable and \nreadonly do not depend on the viewpoint. Qual\u00adi.er polyread depends on the viewpoint and is substituted \nby that viewpoint. For a .eld access, viewpoint adaptation q [ qf adapts the declared .eld quali.er qf \nfrom the point of view of receiver quali.er q. In .eld access y.f where the .eld f is readonly, the type \nof y.f is readonly. In .eld access y.g where the .eld g is polyread, y.g takes the type of y. If y is \nreadonly, then y.g must be readonly as well, in order to disallow modi.cations of y s object through \ny.g. If y is polyread then y.g is polyread as well, propagating the context-dependency. For a method \ncall x = y.m(z), viewpoint adaptation qx [q adapts q, the declared quali.er of a formal parameter/return \nof m, from the point of view of qx, the quali.er at the left-hand\u00adside x of the call assignment. If a \nformal parameter/return is readonly or mutable, its adapted type remains the same regardless of qx. However, \nif q is polyread, the adapted type depends on qx it becomes qx (i.e., the polyread type is the polymorphic \ntype, and it is instantiated to qx). This is a generalization of traditional viewpoint adaptation in \nthat ReIm allows for adaptation from other points of view, not only the point of view of the receiver \nas in traditional viewpoint adaptation. We use viewpoint adaptation to encode context sensitivity. Thus, \nit can be interpreted as encoding context sensitivity at .eld-transmitted dependences differently from \ncontext sensitivity at call-transmitted dependences. And it can be viewed as allowing different abstractions \nof context. For example, adaptation from the point of view of the receiver cd ::= class C extends D {fd \nmd} class fd ::= t f .eld md ::= t m(t this,t x) { t ys; return y } method s ::= s; s | x = new t() | \nx = y statement | x = y.f | x.f = y | x = y.m(z) t ::= q C quali.ed type q ::= readonly | polyread | \nmutable quali.er Figure 1. Syntax. C and D are class names, f is a .eld name, m is a method name, and \nx, y, and z are names of local variables, formal parameters, or parameter this. As in the code examples, \nthis is explicit. For simplicity, we assume all names are unique. amounts to object sensitivity [22]. \nAdaptation from the point of view of the left-hand-side of a call amounts to call-site context sensitivity. \nWe note that the purpose of this paper is to develop reference immutability and method purity. The precise \nrelation between context sensitivity in data.ow analysis, CFL-reachability [27], and viewpoint adaptation \nis left for future work.  2.3 Typing Rules For brevity, we restrict our formal attention to a core calculus \nin the style of Vaziri et al. [35] whose syntax appears in Figure 1. The language models Java with a \nsyntax in a named form , where the results of .eld accesses, method calls, and instantiations are immediately \nstored in a variable. Without loss of generality, we assume that methods have parameter this, and exactly \none other formal parameter. Features not strictly necessary are omitted from the formalism, but they \nare handled correctly in the implementation. We write t y for a sequence of local variable declarations. \nIn contrast to a formalization of standard Java, a type t has two orthogonal components: type quali.er \nq (which expresses reference immutability) and Java class type C. The immutability type system is orthogonal \nto (i.e., independent of) the Java type system, which allows us to specify typing rules over type quali.ers \nq alone. The type system is presented in Figure 2. Rules (TNEW) and (TASSIGN) are straightforward. They \nrequire that the left\u00adhand-side is a supertype of the right-hand-side. The system does not enforce object \nimmutability and, for simplicity, only mutable objects are created. Rule (TWRITE) requires G(x) to be \nmutable because x s .eld is updated in the statement. The adaptation rules for .eld access are used in \nboth (TWRITE) and (TREAD). Rule (TCALL) demands a detailed explanation. Function typeof retrieves the \ntype of m. qthis is the type of parameter this, qp is the type of the formal parameter, and qret is the \ntype of the return. Rule (TCALL) requires qx [ qret <: qx. This constraint disallows the return value \nof m from being readonly when there is a call to m, x = y.m(z), where left-hand-side x  (TNEW) G f x \n= new mutable C (TASSIGN) G(x)= qx G(y)= qy qy <: qx G f x = y (TWRITE) G(x)= qx qx = mutable G(y)= qy \ntypeof (f)= qf qy <: qx [ qf G f x.f = y (TREAD) G(x)= qx G(y)= qy typeof (f)= qf qy [ qf <: qx G f \nx = y.f (TCALL) G(x)= qx G(y)= qy G(z)= qz typeof (m)= qthis,qp . qret qy <: qx [ qthis qz <: qx [ qp \nqx [ qret <: qx G f x = y.m(z) Figure 2. Typing rules. Function typeof retrieves the de\u00adclared immutability \nquali.ers of .elds and methods. G is a type environment that maps variables to their immutability quali.ers. \nis mutable. Only if the left-hand-sides of all call assignments to m are readonly, can the return type \nof m be readonly; otherwise, it is polyread. A programmer can annotate the return type of m as mutable. \nHowever, this typing is pointless, because it unnecessarily forces local variables and parameters in \nm to become mutable when they can be polyread. In addition, the rule requires qy <: qx [ qthis. When \nqthis is readonly or mutable, its adapted value is the same. Thus, when qthis is mutable (e.g., due to \nthis.f = 0 in m), qy <: qx [ qthis becomes qy <: mutable which disallows qy from being anything but mutable, \nas expected. The most interesting case arises when qthis is polyread. Recall that a polyread parameter \nthis is readonly within the enclosing method, but there could be a dependence between this and ret such \nas Xm() { z = this.f; w = z.g; return w; } which allows the this object to be modi.ed in caller context, \nafter m s return. Well-formedness guarantees that whenever there is dependence between this and ret, \nas in the above example, the following constraint holds: qthis <: qret Recall that when there exists \na context where the left-hand\u00adside variable x is mutated, qret must be polyread. Therefore, constraint \nqthis <: qret forces qthis to be polyread (let us assume that this is not mutated in the context of its \nenclosing method). The role of viewpoint adaptation is to transfer the depen\u00addence between this and ret \nin m, into a dependence between actual receiver y and left-hand-side x in the call assignment. In the \nabove example, there is a dependence between this and the return ret. Thus, we also have a dependence \nbetween y and x in the call x = y.m() that is, a mutation of x makes y mutable as well. Function [ does \nexactly that. Rule (TCALL) requires qy <: qx [ qthis When there is a dependence between this and ret, \nqthis is polyread, and the above constraint becomes qy <: qx This is exactly the constraint we need. \nIf x is mutated, y becomes mutable as well. In contrast, if x is readonly, y remains unconstrained. Note \nthat adapting from the viewpoint of the receiver, as is customary in ownership type systems, will result \nin qy <: qy which does not impose any constraints on y when qthis is polyread. Our inference tool, ReImInfer, \ntypes the DateCell class from Section 2.2 as follows: class DateCell { polyread Date date; polyread Date \ngetDate(polyread DateCell this) { return this.date; } void cellSetHours(mutable DateCell this) { mutable \nDate md = this.getDate(); md.setHours(1); } void cellGetHours(readonly DateCell this) { readonly Date \nrd = this.getDate(); int hour = rd.getHours(); } } Field date is polyread because it is mutated indirectly \nin method cellSetHours. Because the type of this of getDate is polyread, it is instantiated to mutable \nin cellSetHours as follows: qmd [ qthis = mutable [ polyread = mutable It is instantiated to readonly \nin cellGetHours: qrd [ qthis = readonly [ polyread = readonly  Thus, this of cellGetHours can be typed \nreadonly. Method overriding is handled by the standard constraints \" for function subtyping. If m overrides \nm we require typeof (m \" ) <: typeof (m) and thus, (qthis ,qp . qret ) <:(qthism ,qpm . qretm ) mmm This \nentails qthism <: qthism ,qpm <: qpm, and qretm<: qretm .  2.4 Type Inference The type inference algorithm \noperates on mappings from keys to values S. The keys in the mapping are (1) local variables and parameters, \nincluding parameters this, (2) .eld names, and (3) method returns. The values in the mapping are sets \nof type quali.ers. For instance, S(x)= {polyread, mutable}means the type of reference x can be polyread \nor mutable. For the rest of the paper we use reference and variable to refer to all kinds of keys: local \nvariables, .elds, and method returns. S is initialized as follows. Programmer-annotated refer\u00adences, \nif any, are initialized to the singleton set that contains the programmer-provided type. Method returns \nare initialized S(ret)= {readonly, polyread} for each method m. Fields are initialized S(f)= {readonly, \npolyread}. All other ref\u00aderences are initialized to the maximal set of quali.ers, i.e., S(x)= {readonly, \npolyread, mutable}. We denote the initial mapping by S0. There is a function fs for each statement s. \nEach fs takes as input the current mapping S and outputs an updated map\u00adping S \" . fs re.nes the set \nof each reference that participates in s as follows. Let x, y, z be the references in s. For each reference, \nfs removes all inconsistent quali.er from the refer\u00adence s set. Consider reference x. fs removes each \nqx . S(x) from S(x), if there does not exist a pair qy . S(y), qz . S(z) such that qx,qy,qz type check \nunder the type rule for s from Figure 2. The same repeats for y, and then z. Note that the order in which \nreferences are examined does not affect the .nal result one can see that fs always removes the same \nset of quali.ers from, say, S(x), regardless of whether x is examined .rst, second or last. This algorithm \nis similar to the one used by Tip et al. [14, 31]. For example, consider statement x = y.f and correspond\u00ading \nrule (TREAD). Suppose that S(x)= {polyread}, S(y)= {readonly, polyread, mutable} and S(f)= {readonly, \npolyread}before the application of the function. The function re\u00admoves readonly from S(y) because there \ndoes not exist qf . S(f) and qx . S(x) that satis.es readonly [ qf <: qx. Similarly, the function removes \nreadonly from S(f) be\u00adcause there does not exist qy . S(y) and qx . S(x) that satis.es qy [ readonly \n<: qx. After the application of the function, S \" is as follows: S \" (x)= {polyread}, S \" (y)= {polyread, \nmutable}, and S \" (f)= {polyread}. class A { X f; X get(A this, Y y) { ... = y.h; X x = this.getF(); \nreturn x; } X getF(A this) { X x = this.f; return x; } } void setG() { A a = ... Y y = ... X x = a.get(y); \nx.g = null; S(asetG) = {mutable} S(ysetG) = {readonly, polyread, mutable} S(xsetG) = {mutable} } void \ngetG() { A a = ... Y y = ... X x = a.get(y); S(agetG) = {readonly, polyread, mutable} S(ygetG) = {readonly, \npolyread, mutable} S(xgetG) = {readonly, polyread, mutable} ... = x.g; } Figure 3. Polymorphic methods. \nA.get(Y) has different mutabilities in the contexts of setG and getG. Also, A.getF(), which is called \nfrom A.get(Y), has different mutabilities in different calling contexts. The box beside each statement \nshows the set-based solution; the underlined quali.ers are the .nal quali.ers picked by ReImInfer. The \ninference analysis iterates over the statements in the program and re.nes the sets until either (1) a \nreference is assigned the empty set in which case the analysis terminates with an error, or (2) the iteration \nreaches a .xpoint. Note that the result of .xpoint iteration is a mapping from references to sets. The \nactual mapping from references to quali.ers is derived as follows: for each reference x we pick the greatest \nelement of S(x) according to the subtyping relation, which we also call the preference ranking when we \nuse it for this purpose. This ranking maximizes the number of readonly references. Note that leaving \nall references as mutable is also a valid typing but a useless one, as it expresses nothing about immutability. \nConsider the example in Figure 3. We use xget to denote the reference x in method get. Initially, all \nreferences are initialized to the sets as described above. The analysis iter\u00adates over all statements \nin class A and in methods setG and getG. In the .rst iteration, the analysis changes nothing un\u00adtil it \nprocesses x.g = null in setG. S(xsetG) is updated to {mutable}. In the second iteration, when the analysis \npro\u00adcesses x = a.get(y) in setG, S(retget) becomes {polyread}. In the third iteration, S(xget) becomes \n{polyread, mutable}because xget has to be a subtype of S(retget). This in turn forces S(retgetF) and \nsubsequently S(thisgetF) to become {polyread, mutable}. The iteration continues until it reaches the \n.xpoint as shown in the boxes in Figure 3. For brevity, some references are not shown in the boxes. The \nunderlined quali.ers are the greatest element in the preference ranking.  The .xpoint will be reached \nin O(n2) time where n is the size of the program. In each iteration, at least one of the O(n) references \nis updated to point to a smaller set. Hence, there are at most O(3n) iterations (recall that each set \nhas at most 3 quali.ers), resulting in the O(n2) time complexity. The inferred solution is correct, precise, \nand maximal. The following propositions formalize its properties. Proposition 2.1. The type assignment \ntype checks under the rules from Figure 2. Proof. (Sketch) The proof is a case-by-case analysis which \nshows that after the application of each function, the rule type checks with the maximal assignment. \nLet max(S(x)) return the maximal element of S(x) according to the preference ranking (which is the same \nas the type hierarchy). We show (TCALL) x = y.m(z). The rest of the cases are straightforward. Let max(S(x)) \nbe readonly. If max(S(this)) is readonly or polyread, qy <: qx [qthis holds for any value of max(S(y)). \nIf max(S(this)) is mutable, the only possible max for y would be mutable (the others would have been \nremoved by the function for (TCALL)). We do not discuss qz <: qx [ qp because it is analogous to qy <: \nqx [ qthis qx [ qret <: qx holds for any value of max(S(ret)).  Let max(S(x)) be mutable. If max(S(this)) \nis readonly, qy <: qx [ qthis holds for any value of max(S(y)). If max(S(this)) is polyread, the only \npossible value for max(S(y)) would be mutable. If max(S(this)) is mutable, the only possible max for \ny would be mutable as well (the others would have been removed by the function for (TCALL)). If max(S(ret)) \nis polyread, clearly qx [qret <: qx holds. max(S(ret)) cannot be readonly, readonly would have been removed \nby the function.  Let max(S(x)) be polyread. If max(S(this)) is readonly, qy <: qx [ qthis holds for \nany value of max(S(y)). If max(S(qthis)) is polyread, the only possible values for max(S(y)) would be \npolyread or mutable. If max(S(qthis)) is mutable, the only possible max for y would be mutable.  If \nmax(S(ret)) is polyread, clearly qx [qret <: qx holds. max(S(ret)) cannot be readonly, readonly would \nhave been removed by the function. The next two propositions establish the precision of our inference \nalgorithm. ReIm, like Ownership type systems [5, 9] allows many different typings for a given program. \nAs mentioned earlier, the trivial typing for ReIm applies mutable to every reference; this clearly type \nchecks, but is useless as we would like to prove as many references as readonly as possible. The main \nchallenges for type inference is to de.ne which typing is best (or most desirable/precise) and then infer \nthat typing. In previous work [18], we formalized the notion of best typing for ownership type systems, \nspeci.cally Ownership types [5] and Universe Types [9], by using a heuristic ranking over typings. This \nformalization applies to ReIm as well as to other ownership-like type systems such as AJ [35] and EnerJ \n[29]. We say that T is a valid typing if T type checks with ReIm. We proceed to de.ne an objective function \no which ranks valid typings. o takes a valid typing T and returns a tuple of numbers. For ReIm, the objective \nfunction is the following: -1-1-1 oReIm (T )=(|T (readonly)|, |T (polyread)|, |T (mutable)|) The tuples \nare ordered lexicographically. We have T1 >T2 iff T1 has more readonly references than T2, or T1 and \nT2 have the same number of readonly references, but T1 has more polyread references than T2. The preference \nranking over typings is based on the preference ranking over quali.ers: we prefer readonly over polyread \nand mutable, and polyread over mutable. This is a natural ranking for ReIm. The following two propositions \nestablish that the maximal typing, i.e., the typing that maps each x to max(S(x)), maximizes the above \nobjective function. In other words, the maximal typing computed by our inference procedure is the best \ntyping. Note that Proposition 2.1 establishes that the maximal typing is valid. Recall that S0 denotes \nthe initial mapping. T . S0 denotes that T (v) . S0(v) for every variable v. Proposition 2.2. Let S be \nthe set-based solution. Let v be any variable in the program and let q be any quali.er in ReIm. If q/. \nS(v) then there does not exist a valid typing T . S0, such that T (v)= q. Proof. (Sketch) We say that \nq is a valid quali.er for v if there exists a valid typing T , where T (v)= q. Let v be the .rst variable \nthat has a valid quali.er q removed from its set S(v) and let fs be the function that performs the removal. \nSince q is a valid quali.er there exist valid quali.ers q1, ..., qk that make s type check. If q1 . S(v1) \nand q2 . S(v2), ... , and qk . S(vk), then by de.nition, fs would not have had q removed from S(v). Thus, \none of v1,...,vk must have had a valid quali.er removed from its set before the application of fs. This \ncontradicts the assumption that v is the .rst variable that has a valid quali.er removed.  The second \nproposition states that if we map every variable v to max(S(v)) and the typing is valid, then this typing \nmaximizes the objective function. Proposition 2.3. Let oReIm be the objective function over valid typings, \nand S be the set-based solution. The maximal typing T is the following: T (v)= max(S(v)) for every variable \nv. If T is a valid typing, then T is the unique maximal typing of the program under oReIm . Proof. (Sketch) \nWe show that T is a maximal typing. Suppose \"\" that there exists a different valid typing T = T . Let \nq be the most-preferred quali.er such that T \"-1(q \" ). Since \" )= T -1(q \"\" T = T , there must exist \na variable v such that T \" (v)= q , \" but T (v)= q<q \". In other words, T types v with q \", but T types \nv differently and lesser in the preference ranking. \" Since T (v)= max(S(v)), it follows that q ./S(v). \nBy \" Proposition 2.2, if q ./S(v) there does not exist a valid typing which maps v to q \", which contradicts \nthe assumption \" that T is a valid typing. Additionally, the propositions are validated empirically as \ndetailed in Section 4. To validate Proposition 2.1, we build an independent type checker in the Checker \nFramework and type check the inferred types. To validate Propositions 2.2 and 2.3, which state the precision \nargument, we perform detailed comparison with Javari.er, the state-of-the-art tool for inference of reference \nimmutability. 3. Method Purity A method is pure (or side-effect free) when it has no vis\u00adible side effects. \nKnowing which methods are pure has a number of practical applications. It can facilitate compiler optimization \n[6, 19, 37], model checking [32], Universe Type inference [12, 18], memoization of function calls [17], \nand so on. We adopt the de.nition of purity given by S. alcianu and Rinard [30]: a method is pure if \nit does not mutate any object that exists in prestates. Thus, a method is pure if (1) it does not mutate \nprestates reachable through parameters, and (2) it does not mutate prestates reachable through static \n.elds. The de.nition allows a pure method to create and mutate local objects, as well as to return a \nnewly constructed object as a result. This is the semantics of the @Pure annotation in JML. For a method \nthat does not access static .elds, the prestates it can reach are the objects reachable from the actual \nargu\u00adments and the method receiver. Therefore, if any of the for\u00admal parameters of m or implicit parameter \nthis is inferred as mutable by reference immutability inference, m is im\u00adpure. Otherwise, i.e., if none \nof the parameters is inferred as mutable, m is pure. Consider the implementation of List in the left \ncolumn of Figure 4. For method add, reference im\u00admutability inference infers that both n and this are \nmutable, class Main { class List { static List sLst; Node head; void m1() { int len; List lst = ... void \nadd(Node n) { Node node = ... n.next = this.head; lst.add(node); this.head = n; Main.sLst = lst; this.len++; \n} } void m2() { void reset() { int len = sLst.size(); this.head = null; PrintStream o = System.out; this.size \n= 0; o.print(len); } } int size() { void m3() { return this.len; m2(); } } } } Figure 4. A simple linked \nlist and example usage. i.e., the objects referred by them may be mutated in add. When there is a method \ninvocation lst.add(node), we know that the prestates referred to by the actual argument node and the \nreceiver lst may be mutated. As a result, we can infer that method add is impure. We can also infer that \nmethod reset is impure because implicit parameter this is inferred as mutable by reference immutability \ninference. Method size is inferred as pure because its implicit parameter this is inferred as readonly \nand it has no formal parameters. However, the prestates can also come from static .elds. A method is \nimpure if it mutates (directly, or indirectly through callees), a static .eld, or objects reachable from \na static .eld. We introduce a static immutability type qm for each method m. Roughly, qm is mutable when \nm accesses static state through some static .eld and then mutates this static state; qm is polyread if \nm accesses static state but does not mutate this state directly, however, m may return this static state \nto the caller and the caller may mutate it; qm is readonly otherwise. Static immutability types are computed \nusing reference immutability. We introduce a function statictypeof that retrieves the static immutability \ntype of m: statictypeof (m)= qm We extend the program syntax with two additional statements (TSWRITE) \nsf = x for static .eld write, and (TSREAD) x =sf for static .eld read. Here x denotes a local variable \nand sf denotes a static .eld. In contrast to instance .elds, static .elds are declared as either readonly \nor mutable. There is no receiver for static .eld accesses and therefore no substitution for polyread \nwould occur. Figure 5 extends the typing rules from Figure 2 with constraints on static immutability \ntypes. If method m contains a static .eld write sf = x, then its static immutability type is mutable \n(see rule (TSWRITE)). If m contains a static .eld read  (TSWRITE) methodof (sf = x)= m statictypeof \n(m)= qm qm = mutable G f sf = x (TSREAD) methodof (x = sf)= m statictypeof (m)= qm G(x)= qx qm <: qx \nG f x = sf (TCALL) G(x)= qx G(y)= qy G(z)= qz typeof (m)= qthis,qp . qret qy <: qx [ qthis qz <: qx [ \nqp qx [ qret <: qx ' methodof (x = y.m(z)) = mstatictypeof (m)= qm ' statictypeof (m)= qm qm <: qx [ \nqm G f x = y.m(z) Figure 5. Extended typing rules for static .elds (see Figure 2 for the base type system). \nFunction methodof (s) returns the enclosing method of statement s. Function statictypeof (m) returns \nthe static immutability type of m. Static immutability types can be readonly, polyread, or mutable . \nRule (TCALL) includes the antecedents from the base type system and the new antecedents that handle the \nstatic immutability type of m, underlined. x = sf where x is inferred as mutable, qm becomes mutable \nas well (see rule (TSREAD)). While the handling of (TSWRITE) is expected, the handling of (TSREAD) may \nbe unexpected. If sf is read in m, using x = sf, then m or one of its callees can access and mutate the \n.elds of sf through x. If m or one of its callees writes a .eld of sf through x, then x will be mutable. \nIf m does not write x, but returns x to a caller and the caller subsequently writes a .eld of the returned \nobject, then x will be polyread. x being readonly guarantees that x is immutable in the scope of m and \nafter m s return, and sf is not mutated through x. Note that aliasing is handled by the type system which \ndisallows assignment from readonly to mutable or polyread. Consider the code: void m() { ... x = sf; \n// a static .eld read y = x.f; z = id(y); z.g = 0; ... } Here static .eld sf has its .eld f aliased \nto local z, which is mutated. The type system propagates the mutation of z to x; thus, the constraints \nin Figure 5 set the static immutability type of m to mutable. Rule (TCALL) in Figure 5 captures two cases: \n1. If the callee m mutates static .elds, i.e. statictypeof (m) = mutable, the statictypeof (m \" ) of \nenclosing method \" m has to be mutable as well, because [ mutable = mutable. 2. If the callee m returns \na static .eld which is mutated later, statictypeof (m) would be polyread. If the enclos\u00ad \" ing method \nm mutated the return value x, i.e. qx = mutable, statictypeof (m \" ) would be mutable because mutable \n[ polyread = mutable. Otherwise, if x is polyread, statictypeof (m \" ) is constrained to polyread or \nmutable. Finally, if x is readonly, statictypeof (m \" ) is \" readonly, indicating that m does not mutate \nstatic .elds. Method overriding is handled by an additional constraint. \" If m overrides m we must have \nqm <: qm In other words, if m \" mutates static state, qm must be mutable, even if m itself does not mutate \nstatic state. This constraint \" ensures that m is a behavioral subtype of m and is essential for modularity. \nStatic immutability types are inferred in the same fashion as reference immutability types. The analysis \ninitializes every S(m) to {readonly, polyread, mutable} and iterates over the statements in Figure 5 \nand the overriding constraints, until it reaches the .xpoint. If readonly remains in S(m) at the end, \nthe static immutability type of m is readonly; otherwise, it is polyread or mutable. Consider the right \ncolumn of Figure 4. qm1 becomes mutable because m1 assigns lst to the static .eld sLst. qm2 is mutable \nas well, because it mutates the PrintStream object referred by System.out by invoking the print method \non it, and local variable o is mutable. qm3 becomes mutable as well, because it invokes method m2 and \nqm2 is mutable. The observant reader has likely noticed that qm = mutable does not account for all mutations \nof static state in m. In particular, static state may be aliased to parameters and be accessed and mutated \nin m through parameters: void m(X p) { p.g = 0; } ... void n() { X x = sf; // a static .eld read (TSREAD) \nm(x); } In the above example, qm is readonly, even though m mutates static state. Note however that method \nm is impure, because there is a write to its parameter. Interestingly, this is not un\u00adsound. Parameter \nand static mutability types capture precisely the information needed to infer purity as we shall see \nshortly.  We infer that a method m is pure if all of its parameters, jdbf-0.0.1 is an object-relational \nmapping system. including implicit parameter this, are not mutable (i.e., they commons-pool-1.2 is a \ngeneric object-pooling library. are readonly or polyread), and its static immutability type is jtds-1.0 \nis a JDBC driver for Microsoft SQL Server andnot mutable (i.e., it is readonly or polyread). More formally, \nSybase. let typeof (m)= qthis,qp . qret and statictypeof (m)= qm. We have: java.lang is the package \nfrom JDK 1.6 pure(m)= . . . false if qthis = mutable or qp = mutable or java.util is the package from \nJDK 1.6. xalan-2.7.1 is a library for transforming XML documents . . true qm = mutable otherwise to \nHTML from the DaCapo 9.12 benchmark suite. Benchmarks JOlden, tinySQL, htmlparser, and ejc are As discussed \nearlier, a method m can be impure because: (1) prestates are mutated through parameters, or (2) prestates \nare mutated through static .elds. If prestates are mutated through parameters, then this will be captured \nby the mutability of this and p. Now, suppose that prestates are not mutated through parameters, but \nare mutated after access through a static .eld. In this case, there must be an access in m to a static \n.eld sf through (TSREAD) or (TSWRITE), and the mutation is captured by the static immutability type qm. \n4. Experiments The inference of reference immutability, and the type checker that veri.es the inferred \ntypes are implemented as compiler plug-ins in the Checker Framework (CF) [11, 23]. The pu\u00adrity inference \nis implemented on top of the CF as well. The implementation relies on the CF to generate type constraints \nfor Java programs. Because it handles context sensitivity by using viewpoint adaptation, it generates \nless type con\u00adstraints compared to Javari.er, and the constraints can be solved faster. The tool, called \nReImInfer, is publicly avail\u00adable at http://code.google.com/p/type-inference/, including source. 4.1 \nBenchmarks The implementation is evaluated on 13 large Java benchmarks, including 4 whole-program applications \nand 9 Java libraries. Whole programs: Java Olden (JOlden) is a benchmark suite of 10 small programs. \n ejc-3.2.0 is the Java Compiler for the Eclipse IDE.  javad is a Java class .le disassembler.  SPECjbb \n2005 is SPEC s benchmark for evaluating server side Java.  Libraries: tinySQL-1.1 is a database engine.1 \n htmlparser-1.4 is a library for parsing HTML.  jdbm-1.0 is a lightweight transactional persistence \nen\u00adgine.  1 We added 392 empty methods in tinySQL in order to compile it with Java 1.6. The modi.ed \nversion is available online. precisely the benchmarks used by Javari.er [33]. Javari.er s distribution \nincludes regression tests, which greatly facilitates the comparison between Javari.er and ReImInfer. \njava.lang and java.util are included because they are representative libraries. The rest of the benchmarks \ncome from our previous experimental work [18, 21]. We run our inference tool, called ReImInfer, on the \nabove benchmarks on a server with Intel R&#38;#169; CPU X3460 &#38;#169; Xeon R@2.80GHz and 8 GB RAM \n(the maximal heap size is set to 2 GB). The software environment consists of Sun JDK 1.6 and the Checker \nFramework 1.3.0 on GNU/Linux 3.2.0. The goal of our experiments is to demonstrate the scala\u00adbility, precision, \nand robustness of ReImInfer.  4.2 Reference Immutability Inference In this section, we present our results \non reference immutabil\u00adity inference. We treat the this parameters of java.lang.Object s hashCode, equal, \nand toString as readonly, even though these methods may mutate internal .elds (these .elds are used only \nfor caching and can be excluded from the object state). This handling is consistent with the notion of \nobservational purity discussed in [3] as well as other related analyses such as JPPA [30]; these methods \nare intended to be observationally pure. Our analysis does not detect bugs due to unintended mutation \nin these methods. ReImInfer treats private .elds f that are read and/or written through this in exactly \none instance method m, as if they were local variables. Precisely, this means that for these .elds we \nallow quali.er mutable, and treat .eld reads x = this.f and writes this.f = x as if they were assignments \nx = f and f = x. One such .eld and method are current and nextElement() in class Enumerate shown in Figure \n7. We preserve the dependence between this and f, by using an additional constraint: qthis <: qf . Thus, \nwhen f is mutated in m, f and this are inferred as mutable. When f is readonly in the scope of m, but \ndepends on the context of the caller, f is polyread and this is polyread or mutable. If f is readonly, \nno constraints are imposed on this. As an example, .eld current and this of nextElement() in Figure 7 \nare both inferred polyread. The motivation behind this optimization is precisely the Enumeration class \nin Figure 7. The goal is to transfer the dependence from the element stored in the container, to the \ncontainer itself, which is important for purity inference.  If current were treated as a .eld, it would \nbe polyread, and therefore, this of elements would be mutable, which entails that every container that \ncreates an enumeration is mutable, even if its elements were not mutated. If current was excluded from \nabstract state, then this of nextElement would have been readonly and mutation from elements would not \nhave been transferred to the container. Our optimization allows this of nextElement and elements to be \npolyread, which is important for purity inference, as we discuss shortly. The optimization affected 8 \nnextElement and elements methods and 12 other methods that call nextElement and elements throughout all \nof our benchmarks. Recall that reference immutability inference is modular. Thus, it is able to analyze \nany given set of classes L. If there are unknown callees in L, the analysis assumes default typing mutable, \nmutable . polyread. The mutable parameters assume worst-case behavior of the unknown callee the unknown \ncallee mutates its arguments. Clearly, readonly is the most general return type. However, this will require \nthat every use of the return in the client is readonly, and many clients violate this restriction. mutable, \nmutable . polyread is safe because we can always assign the polyread return value to a readonly variable. \nAnd it also imposes a constraint on the callee: e.g., suppose the code for X id(X p) { return p; } was \nunavailable and we assumed typing mutable . polyread for id. When it becomes available, p will be polyread. \nUser code U, which uses previously analyzed library L, is analyzed separately using the result of the \nanalysis of L. In our case, when analyzing user code U, we use the annotated JDK available with Javari.er \nfrom the CF; the similarities between Javari and ReIm justify this use. Correctness of the composition \nis ensured by the check that the function \" subtyping constraints hold: for every m in U that overrides \nan m from L, typeof (m \" ) <: typeof (m) must hold. For example, suppose that L contains code x.m() where \nthism, is inferred as readonly. The typing is correct even in the \" presence of callbacks. If x.m() results \nin a callback to m \" in U (m overrides m), constraint typeof (m \" ) <: typeof (m) (Section 2.3) which \nentails thism <: thism , ensures that thism is readonly as well. Of course, it is possible that U violates \nthe subtyping ex\u00adpected by L. Interestingly however, in our experiments the only violations were on special-cased \nmethods of Object: equals, hashCode and toString. Furthermore, the vast ma\u00adjority of violations occurred \nin the java.util library. As with other analyses (JPPA), we report these violations as warnings. Below, \nwe present our results on inference of reference immutability. Sections 4.2.1 4.2.3 evaluate our tool \nin terms of scalability and precision. 4.2.1 Inference output Table 1 presents the result of running \nour inference tool ReImInfer on all benchmarks. Figure 6. Runtime performance comparison. Note that \nthe running time for type checking is excluded for both ReImInfer and Javari.er. In all benchmarks, about \n41% to 69% of references are reported as readonly, less than 16% are reported as polyread and 24% to \n50% are reported as mutable. To summarize our .ndings, ReImInfer is more scalable than Javari.er (Section \n4.2.2). Furthermore, ReImInfer pro\u00ad duces equally precise results (Section 4.2.3). 4.2.2 Timing results \nFigure 6 compares the running times of ReImInfer and Javari.er on the .rst 5 benchmarks in Table 1. ReImInfer \nand Javari.er analyze exactly the same set of classes (given at the command-line), and use stubs for \nthe JDK. That is, both ReImInfer and Javari.er generate and solve constraints for the exact same set \nof classes, and neither analyzes the JDK. The timings are the medians of three runs. ReImInfer scales \nbetter than Javari.er. ReImInfer appears to scale approximately linearly. As the applications grow larger, \nthe difference between ReImInfer and Javari.er be\u00adcomes more signi.cant. These results are consistent \nwith the results reported by Quinonez et al. [26] where Javari.er posts signi.cant nonlinear growth in \nrunning time, when program size goes from 62kLOC to 110kLOC.  4.2.3 Correctness and precision evaluation \nTo evaluate the correctness and precision of our analysis, we compared our result with Javari.er on the \n.rst four benchmarks from Table 1. We do not compare the numbers directly because we use a different \nnotion of annotatable reference from Javari.er (e.g., Javari.er counts List<Date> twice while we only \ncount it once). In our comparison, we examine only .elds, return values, formal parameters, and this \nparameters; we call these references identi.able references. We exclude local variables because Javari.er \ndoes Table 1. Inference results for reference immutability. #Line shows the number of lines of the benchmarks, \nincluding blank lines and comments. #Meth gives the number of methods of the benchmarks. #Pure is the \nnumber of pure methods inferred by our purity analysis. Annotatable References include all references, \nincluding .elds, local variables, return values, formal parameters, and implicit parameters this. It \ndoes not include variables of primitive type. #Ref is the total number of annotatable references, #Readonly, \n#Polyread, and #Mutable are the number of references inferred as readonly, polyread, and mutable, respectively. \nWe also include the running time for the benchmarks. Infer is the running time of ReImInfer for inferring \nreference immutability, and method purity. Check is the running time for type checking. The last column \nTotal shows the total running time, including reference immutability inference, purity inference and \ntype checking.  Benchmark Code size #Line #Meth #Pure #Ref Annotatable References #Readonly #Polyread \n#Mutable Time (in seconds) Infer Check Total JOlden 6223 326 175 (54%) 949 453 (48%) 149 (16%) 347 (37%) \n4.0 1.6 5.7 tinySQL 31980 1597 965 (60%) 4247 2644 (62%) 418 (10%) 1185 (28%) 11.3 3.7 15.1 htmlparser \n62627 1698 647 (38%) 4853 2711 (56%) 421 ( 9%) 1721 (35%) 11.4 5.3 16.9 ejc 110822 4734 1740 (37%) 15434 \n6161 (40%) 1803 (12%) 7470 (48%) 43.3 22.7 66.2 xalan 348229 10386 4019 (39%) 41186 25181 (61%) 3254 \n( 8%) 12751 (31%) 57.4 23.3 81.1 javad 4207 140 60 (43%) 363 249 (69%) 19 ( 5%) 95 (26%) 2.2 0.9 3.2 \nSPECjbb 28333 529 200 (38%) 1537 830 (54%) 246 (16%) 461 (30%) 6.9 2.2 9.3 commons-pool 4755 275 94 (34%) \n602 266 (44%) 37 ( 6%) 299 (50%) 2.7 1.0 3.8 jdbm 11610 446 139 (31%) 1161 470 (40%) 161 (14%) 530 (46%) \n4.0 1.8 5.9 jdbf 15961 707 336 (48%) 2510 1669 (66%) 240 (10%) 601 (24%) 7.1 2.4 9.6 jtds 38064 1882 \n672 (36%) 5048 2805 (56%) 299 ( 6%) 1944 (39%) 12.1 5.0 17.2 java.lang 43282 1642 1128 (69%) 2970 2028 \n(68%) 187 ( 6%) 755 (25%) 8.6 3.0 12.1 java.util 59960 2724 1093 (40%) 6920 2852 (41%) 1005 (15%) 3063 \n(44%) 16.7 7.6 24.5 public class Body { Body next; public .nal Enumeration elements() { class Enumerate \nimplements Enumeration { private Body current; public Enumerate() { current = Body.this; } public Object \nnextElement() { Object retval = current; current = current.next; return retval; } } return new Enumerate(); \n} } Figure 7. The elements() method in JOlden/BH not give identi.able names for local variables (it \nonly shows local 0, local 1, and so on). In addition, polyread .elds in Javari.er are called this-mutable. \nIn the comparison, we view all such .elds as polyread. JOlden We examined all programs in the Java Olden \n(JOlden) benchmark suite. We found 34 differences between our result and Javari.er s, out of 758 identi.able \nreferences. We exclude the following difference from the count: the this parameters of constructors are \nreported as readonly by Javar\u00adi.er, while they are reported as mutable if this is mutated, by ReImInfer. \nDifferences due to the annotated JDK are also excluded because Javari.er treated variables from library \nmethods as mutable even though we have speci.ed the anno\u00adtated JDK. 8 out of the 34 differences are the \nnextElement() method that implements the Enumeration interface (Figure 7). Javari.er infers the return \nvalue as readonly. This is correct with respect to the semantics of Javari and Javari.er, which separates \na structure from the elements stored in it; thus, a mutation on an element, should not necessarily affect \nthe data structure itself. The semantics of ReIm and ReImInfer demands that the return of nextElement \nshould be polyread, because there are cases when the retrieved element is mutated. ReImInfer re\u00adports \nthat nextElement() s return is polyread. Also Javari.er infers the this parameter of nextElement() as \nmutable while ReImInfer reports that it is polyread. This is possible because ReImInfer treats .eld current \nin Figure 7 as a local variable as discussed earlier. There are 4 nextElement() methods in the JOlden \nbenchmark suite, causing 8 differences in total. These 8 differences directly or indirectly lead to the \nre\u00admaining 26 differences. First, these 8 differences directly lead to 8 differences in the current .eld \nand the elements() method in the Enumerate class, which is shown in Figure 7. Our analysis infers retval \nas polyread because the return value of nextElement() is polyread as discussed earlier. This causes .eld \ncurrent to be inferred as polyread in statement Object retval=current since current is a .eld but treated \nas a local variable. As a result, the this parameter of elements() becomes polyread due to the assignment \ncurrent=Body.this. Because Javari.er infers the return value of nextElement() as readonly, it reports \nboth the current .eld and the this of elements() are readonly, which leads to 8 differences in total. \nThe treatment of Javari.er re.ects the expected semantics of Javari the container that calls elements \nshould not be affected by the data stored in it. ReIm and ReImInfer s seman\u00adtics demands that a mutation \non the element is propagated to the container.  Second, these 8 differences on current and elements() \npropagate to the other 18 differences. The following code shows an example: Body bodyTab = ...; for(Enumeration \ne = bodyTab.elements(); e.hasMoreElements();){ Body b = (Body)e.nextElement(); ... b.setProcNext(prev); \n} Here b is mutable since the this parameter of setProc-Next(Body) is mutable. Because bodyTab is indirectly \nas\u00adsigned to b through the Enumeration instance referred by e, bodyTab should be mutable as well. Javari.er \nreports bodyTab is readonly because the this parameter of ele\u00adments() is inferred as readonly. ReImInfer \nreports bodyTab as mutable. This is important for purity e.g., if bodyTab is a parameter, its mutability \nentails that the enclosing method is impure. Other benchmarks For the remaining three benchmarks, tinySQL, \nhtmlparser and ejc, we examined 4 randomly se\u00adlected classes from each (a total of 12 classes). We found \n2 differences out of 868 identi.able references. The 2 differ\u00adences are caused by the fact that Javari.er \ninfers a parameter of String type as polyread, which causes an actual argument to become polyread or \nmutable; ReImInfer infers this param\u00adeter as readonly. Overall, the differences are very minor. Most \nare at\u00adtributable to the different semantics of ReIm and Javari, and the few others are due to an apparent \nbug in a corner case of Javari.er s handling of the annotated JDK.  4.3 Purity Inference This section \npresents our results on purity inference. We treat methods equals, hashCode, toString in java.lang.Object, \nas well as java.util.Comparable.compareTo, as observationally pure. This is analogous to previous work \n[30]. Our purity inference is modular. Reference immutability assumptions for unknown callees are exactly \nas before. Static immutability types, which we discussed in Section 3, are not available in Javari s \nannotated JDK. We ran ReImInfer on java.lang and java.util packages, and we assumed that other library \nmethods have not mutated static .elds. JPPA, a Java Pointer and Purity Analysis tool by S. alcianu and \nRinard [30], makes the same assumption for unknown library methods, and our decision to use qm = readonly \nas default, is motivated by this, in order to facilitate comparison with JPPA. When composing previously \nanalyzed libraries L with user code U for purity inference, we need one additional Program #Meth JPPA \nJPure ReImInfer BH 69 20 (29%) N/A 33 (48%) BiSort 13 4 (31%) 3 (23%) 5 (38%) Em3d 19 4 (21%) 1 ( 5%) \n8 (42%) Health 26 6 (23%) 2 ( 8%) 11 (42%) MST 33 15 (45%) 12 (36%) 16 (48%) Perimeter 42 27 (64%) 31 \n(74%) 38 (90%) Power 29 4 (14%) 2 ( 7%) 10 (34%) TSP 14 4 (29%) 0 ( 0%) 1 ( 7%) TreeAdd 10 1 (10%) 1 \n(10%) 6 (60%) Voronoi 71 40 (56%) 30 (42%) 47 (66%) Table 2. Pure methods in Java Olden benchmarks \" \ncheck: for every m in U that overrides m in L, we must have qm <: qm . In particular, if qm is inferred \nas readonly, then qm must be readonly as well. As with reference immutability, it is possible that user \ncode violates this constraint. In the .rst 11 benchmarks in Table 1, we found 205 out of 22,720 user \nmethods that violate the inferred statictypeof on java.lang and java.util packages, and the vast majority \nof the violations are on the special-cased methods, equals, hashCode, and toString. These violations \nare reported as warnings. The results of purity inference by ReImInfer are shown in Table 1, column #Pure. \nTo evaluate analysis precision, we compared with JPPA by S. alcianu and Rinard [30] and JPure by Pearce \n[24]. We ran JPPA and JPure on the JOlden benchmark suite and directly compared its output with ours. \nTable 2 presents the comparison result. To summarize our results, ReImInfer scales well to large programs \nand shows good precision compared to JPPA and JPure. Furthermore, ReImInfer, which is based on the stable \nand well-maintained CF, appears to be more robust than JPPA and JPure, both of which are based on custom \ncompilers. These results suggest that ReImInfer can be useful in practice. 4.3.1 Comparison with JPPA \nJOlden There are 59 differences out of 326 user methods between ReImInfer s result and JPPA s. Of these \ndifferences, (a) 4 are due to differences in de.nitions/assumptions, (b) 51 are due to limitations/bugs \nin JPPA and (c) 4 are due to limitations in ReImInfer. 4 differences are due to JPPA s assumption about \nun\u00adknown library methods. For example, JPPA reports as pure the method median in Jolden/TSP, which invokes \nnew java.lang.Random(). The constructor Random should not be pure because it mutates a static .eld seedUniqui.er. \nReIm-Infer precomputes static immutability types qm on the JDK library and thus reports method median \nas impure. 51 differences are due to limitations/bugs of JPPA. 38 differences are the constructors, which \nReImInfer reports as pure but JPPA does not. According to [30], JPPA follows the JML convention and constructors \nthat mutate only .elds of the this object are pure. Thus, JPPA should have inferred them as pure. ReImInfer \nfollows the same de.nition and reports these constructors as pure. There are 3 differences on methods \nthat are inferred as pure by ReImInfer but impure by JPPA. These 3 methods that return newly-constructed \nobjects, which are mutated later. According to the de.nition in [30], JPPA should have inferred them \nas pure. There is 1 difference on method loadTree in Jolden/BH. It is likely a bug in JPPA because the \nthis parameter is passed to another object s .eld which is mutated later, but JPPA reports loadTree as \npure. ReImInfer detects the this parameter is mutated and reports the method as impure. There are 9 methods \nreported as pure by ReImInfer but not covered by JPPA. This is because JPPA is a whole-program analysis \nand these methods are not reachable, resulting in 9 differences in the comparison.  The remaining 4 \ndifferences are the nextElement method discussed in Section 4.2.3. Because ReImInfer considers the current \n.eld as a local variable, it infers these 4 methods as pure while JPPA considers they are impure. Other \nbenchmarks We attempted to run JPPA and compare on benchmarks tinySQL, htmlparser, and ejc as we did \nwith Javari.er. tinySQL is a library and there is no main method. htmlparser, which is a library as well, \ncomes with a main, which exercises a portion of its functionality; JPPA threw an exception on htmlparser \nwhich we were unable to correct. JPPA completed on ejc. Due to the fact that it is a whole\u00adprogram analysis, \nit analyzed 3790 reachable user methods; ReImInfer covered all 4734 user methods. We examined 4 randomly \nselected classes from ejc and found 17 differences out of 163 methods in total. 9 methods are not reachable \naccording to JPPA. Of the remaining 8 differences, (a) 2 are due to limitations/bugs in JPPA and (b) \n6 are due to limitations/bugs in ReImInfer. 1 constructor that should have been pure according to the \nJML convention was reported as impure by JPPA. In addition, 1 method which we believe is pure because \nit does not mutate any prestate, was reported as impure by JPPA. The remaining 6 methods are reported \nas pure by JPPA but impure by ReImInfer; this is imprecision in ReImInfer. These methods are inferred \nas impure by ReImInfer because they are overridden by impure methods. This is an insurmountable imprecision \nfor ReImInfer.  4.3.2 Comparison with JPure JOlden There are 60 differences out of 257 user methods \nbetween ReImInfer s result and JPure s, excluding the BH program (JPure could not compile BH). Of these, \n(a) 29 differences are caused by different de.nitions/assumptions, (b) 2 are caused by limitations/bugs \nin ReImInfer, and (c) 29 differences are caused by limitations/bugs in JPure. 29 differences are caused \nby different de.nitions of pure constructors. We follow the JML convention that a construc\u00adtor is pure \nif it only mutates its own .elds. JPure has different de.nition of a pure constructor and that leads \nto these dif\u00adferences. 2 differences are the nextElement method where ReImInfer considers the current \n.eld as a local variable as discussed above. There are 8 differences in toString meth\u00adods, which are \ninferred as impure by JPure. Our examination shows that those methods are pure; it appears that they \nshould be pure, but are inferred as impure due to imprecision in JPure, according to [24]. 16 differences \nare caused by meth\u00ad ods that return fresh local references. JPure should have been able to identify them \nas @Fresh, but it did not. The remaining 5 differences are due to the static methods in java.lang.Math. \nJPure infers all methods that invoke the static methods in java.lang.Math as impure, while ReImInfer \nidenti.es that these methods satisfy qm is readonly by using the inference result from the java.lang \npackage. Other benchmarks We attempted to run JPure on the li\u00adbraries from JDK 1.6, but that caused problem \nwith the un\u00adderlying compiler in JPure. We attempted to run JPure on tinySQL, htmlparser and ejc. In \nall three cases, the tool issued an error. We were unable to perform direct comparison on larger benchmarks. \n5. Related Work We begin by comparison with Javari [33] and its inference tool Javari.er [26], which \nrepresent the state-of-the-art in reference immutability. Although the type systems have sim\u00adilarities, \nthey also differ in important points of design and implementation. The corresponding inference tools \nimple\u00adment substantially different inference algorithms. Section 5.1 compares ReIm with Javari, and Section \n5.2 compares our inference approach, ReImInfer, with Javari.er. Section 5.3 discusses related work on \npurity inference, and Section 5.4 discusses other related work. 5.1 Comparison with Javari There are \ntwo essential differences between ReIm and Javari [33]. First, Javari allows programmers to exclude .elds \nfrom the abstract state by designating .elds as assignable or mutable. Such a .eld may be assigned or \nmutated even through a readonly reference. An example is a .eld used for caching (e.g., hashCode) modifying \nit should not be con\u00adsidered mutation from the client s point of view. As expected however, this expressive \npower complicates Javari: to prevent converting an immutable reference to a mutable reference, Javari \nrequires the access to an assignable .eld through a readonly reference, to have different mutabilities \ndepending on whether it is an l-value or an r-value of an assignment expression. ReIm does not allow \nassignable or mutable .elds and therefore it is less expressive but simpler. This decision is motivated \nby our intended application: purity inference. Including assignable and assignable for .elds in the type \nsystem would have complicated purity inference. Second, Javari treats generics and arrays differently. \nJavari permits annotating the type arguments when instantiating a parametric class: a programmer can \nexpress designs such as readonly list of readonly elements , readonly list of mutable elements , mutable \nlist of readonly elements , and mutable list of mutable elements . ReIm does not support annotations \non the type arguments when instantiating a parametric class, and can express only readonly list of readonly \nelements and mutable list of mutable elements (which it uses to approximate the two inexpressible designs). \nThe difference between the two approaches is illustrated by the following example:  void m(List<Date> \nlst2) { lst2.get(0).setHours(1); } Here Javari s inference tool (Javari.er) infers that reference lst2 \nis of type readonly List<mutable Date>. ReImInfer annotates lst2 as mutable List<Date>. (Javari.er does \nnot have an option to make it prefer the solution mutable List<mutable Date> over readonly List<mutable \nDate>.) Again, the primary motivation for the decision about ReIm s simpler design is the application \nwe had in mind: purity inference. Purity is a single bit that summarizes whether any reachable datum \nmay be modi.ed, and .ner-grained information is not of use when computing whether a method is pure. Arrays \nare treated similarly to generics in Javari and its inference tool. In the following code b would be \nannotated as mutable Date readonly []. void m(Date[] b) { b[0].setHours(2); } Again, Javari and Javari.er \npermit a programmer to give the array and its elements either the same or different mutability annotations. \nReIm and ReImInfer enforce that the array and its elements have the same mutability annotation, so the \narray reference b would be inferred as mutable Date mutable [] due to the mutation of element 0. One \nmight imagine inferring method purity from Javari\u00ad.er s output, as follows: a method is pure if all the \nmutabilites of its formal parameters and static variables, and their type arguments and array elements, \nare readonly. This approach is sound but can be unnecessarily conservative, in certain cir\u00adcumstances. \nA concrete example is when the type argument is not part of the state of the object but is mutated. Consider \nthe following example: class A<T> { T id(T p) { return p; } } void m(A<Date> x) { Date d = x.id(new Date()); \nd.setHours(0); } Here Javari.er infers that x is of type readonly A<mutable Date>. Using the proposed \napproach, method m would be conservatively marked as non-pure. By contrast, ReImInfer annotates x as \nreadonly, so m is inferred to be pure. Another important (but non-essential for our purpose) difference \nbetween Javari and ReIm is the type quali.er hierarchy.  5.2 Comparison with Javari.er Our inference \napproach is comparable to Javari.er, the in\u00adference tool of Javari. Both tools use .ow-insensitive and \ncontext-sensitive analysis and solve constraints generated during type-based analysis. There are three \nsubstantial differ\u00adences between the tools. The most signi.cant difference is in the context-sensitive \nhandling of methods. The main idea of Javari.er is to create two context copies for each method that \nreturns a reference, one copy for the case when the left-hand-side of the call as\u00adsignment is mutable, \nand another copy for the case when the left-hand-side is readonly. As a result, Javari.er doubles the \ntotal number of method-local references, including local variables, return values, formal parameters \nand implicit pa\u00adrameters this. It also doubles the number of constraints. In contrast, our inference \nuses polyread and viewpoint adapta\u00adtion, which ef.ciently captures and propagates dependences from parameters \nto return values in the callee, to the caller. For example, in m() { x = this.f; y = x.g; return y; }, \nthe polyread of the return value is propagated to implicit param\u00adeter this; the dependence is transferred \nto the callers when viewpoint adaptation is applied at the call sites of m. Second, Javari.er and ReImInfer \nhave different constraint resolution approaches. Javari.er computes graph reachability over the constraint \ngraph. Its duplication of nodes in its constraint graph correctly handles context sensitivity. In contrast, \nReImInfer uses .xpoint iteration on the set-based solution and outputs the .nal typing based on the preference \nranking over the quali.ers. Third, Javari.er is based on Soot [34] while ReImInfer is based on the Checker \nFramework (CF), which did not yet exist when Javari.er was developed. Javari s type-checker is completely \nseparate code from Javari.er, and Javari.er also requires an additional utility to map the inference \nresult back to the source code in order to do type checking. In total, Javari and Javari.er depend on \nthree tools: Soot, the annotation utility, and the Checker Framework. In contrast, ReImInfer and the \ntype checker require only the Checker Framework and the annotation utility. These differences contribute \nto the usability of ReImInfer. We conjecture that viewpoint adaptation, the constraint resolution approach, \nand the better infrastructure in the CF, contribute to the better scalability of ReImInfer compared to \nJavari.er.  5.3 Purity S. alcianu and Rinard present a Java Pointer and Purity Anal\u00adysis tool (JPPA) \nfor reference immutability inference and purity inference. Their analysis is built on top of a combined \npointer and escape analysis. Their analysis not only infers the immutability, but also the safety for \nparameters, which means the abstract state referred by a safe parameter will not be exposed to externally \nvisible heap inside the method. However, the pointer and escape analysis is more expensive. It relies \non whole program analysis, which requires main, and analyzes only methods reachable from main. ReImInfer \ndoes not require the whole program and thus it can be applied to libraries. Plus, we also include a type \nchecker for verifying the inference result, which is not available in JPPA.  JPure [24] is a modular \npurity system for Java. The way JPure infers method purity is not based on reference immutability inference, \nas our purity inference and JPPA did. Instead, it exploits two properties, freshness and locality, for \npurity analysis. Its modular analysis enables inferring method purity on libraries and gains ef.cient \nruntime performance. Rountev s analysis is designed to work on incomplete programs using fragment analysis \nby creating arti.cial main routine [28]. However, its de.nition of pure method is more restricted in \nthat it disallows a pure method to create and use a temporary object. Clausen develops Cream, an optimizer \nfor Java bytecode using an inter-procedural side-effect analysis [6]. It infers an instruction or a collection \nof instructions as pure, read-only, write-only or read/write, based on which it can infer purity for \nmethods, loops and instructions. It is a whole-program analysis which requires a main method and also, \nunused methods are not covered. Other researchers also explore the dynamic notion of pu\u00adrity. Dallmeier \net al. develop a tool, also called JPURE, to dynamically infer pure methods for Java [8]. Their analysis \ncalculates the set of modi.ed objects for each method invo\u00adcation and determines impure methods by checking \nif they write non-local visible objects. Xu et al. use both static and dynamic approaches to analyze \nmethod purity in Java pro\u00adgrams [36]. Their implementation supports different purity de.nitions that \nrange from strong to weak. These dynamic ap\u00adproach depends on the runtime behavior of programs, which \nis totally different from our purity analysis.  5.4 Other Related Work Artzi et al. present Pidasa for \nclassifying parameter reference immutability [1, 2]. They combine dynamic analysis and static analysis \nin different stages, each of which re.nes the re\u00adsult from the previous stage. The resulting analysis \nis scalable and produces precise result. They also incorporate optional unsound heuristics for improving \nprecision. In contrast, our analysis is entirely static and it also infers immutability types for .elds \nand method return values. It is unclear how their analysis handles polymorphism of methods. The IGJ [38] \nand OIGJ [39] type systems support both reference immutability (a la Javari and ReIm) and also object \nimmutability. Concurrent work by Haack et al. [16] also supports object immutability. JQual [15] is a \nframework for inference of type quali.ers. JQual s immutability inference in .eld-sensitive and context\u00adsensitive \nmode is similar to Javari s inference. However, it is not scalable in this mode according to the authors. \nAnd Artzi et al. s evaluation con.rms this [2]. In .eld-insensitive mode, JQual suffers from the problem \nthat the method receiver has to be mutable when the method reads a mutable .eld, even if the method itself \ndoes not mutate any program state. Our analysis is scalable and may even have better scalability than \nJavari.er. Also, by introducing the polyread annotation and viewpoint adaptation, our analysis is able \nto correctly infer that a method receiver is readonly or polyread, even if a .eld is returned from the \nmethod, and the returned value is mutated later. Porat et al. [25] present an analysis that detects immutable \nstatic .elds and also addresses sealing/encapsulation. Their analysis is context-insensitive and libraries \nare not analyzed. Liu and Milanova [20] describe .eld immutability in the context of UML. Their work \nincorporates limited context sen\u00adsitivity, analyzes large libraries and focuses on instance .elds. This \nwork is an improvement over [20]. Immutability infer\u00ad ence not only includes instance .elds, but also \nlocal variables, return values, formal parameters, and this parameters. Also, this work provides a type \nchecker to verify the correctness of the inference result. Chin et al. [4] propose CLARITY for the inference \nof user-de.ned quali.ers for C programs based on user-de.ned rules, which can also be inferred given \nuser-de.ned invari\u00adants. It infers several type quali.ers, including pos and neg for integers, nonnull \nfor pointers, and tainted and untainted for strings. These type quali.ers are not context-sensitive. \nIn contrast, our tool focuses on the type system for reference im\u00admutability and it is context-sensitive, \nas viewpoint adaptation is used in the type system to express context sensitivity. ReIm uses and adapts \nthe concept of viewpoint adaptation from Universe Types [7, 9, 10], which is a lightweight ownership \ntype system that optionally enforces the owner\u00adas-modi.er encapsulation discipline. The readonly quali.er \nin ReIm is similar to the any quali.er in Universe Types (in earlier work on Universe Types, quali.er \nany is actually called readonly). Both readonly references and any references disallow mutations on their \nreferents. However, the ownership structure in Universe Types can be used to give a more concrete interpretation \nof casts from a readonly type to a mutable type. In addition, the purity results from this work can be \nused in the inference of Universe Types, as shown by our previous work [12, 18]. The type inference algorithm \npresented in this paper, .ts in the framework from [18]. One difference is that viewpoint adaptation \nin [18] is the traditional viewpoint adaptation from Universe Types: it uses the same operation at .eld \naccesses and at method calls, and adapts only from the point of view of the receiver. In this paper, \nwe use a more general notion of viewpoint adaptation. The precise relation between [18] and this work, \nwill be formalized in future work.  The inference algorithm (Section 2.4) of ReImInfer is similar to \nthe algorithm used by Tip et al. [14, 31]. Both algorithms start with sets containing all possible answers \nand iteratively remove elements that are inconsistent with the typing rules. Then, they use a ranking \nover valid typings to select from the multiple options that remain. 6. Conclusion We have presented ReIm \nand ReImInfer, a type system and a type inference analysis for reference immutability. In addition, we \nhave applied reference immutability to method purity inference. We have shown that our approach is scalable \nand precise by implementing a prototype, evaluating it on 13 large Java programs and Java libraries, \nand comparing the results to the leading reference immutability inference tool, Javari.er, and to purity \ninference tools, JPPA and JPure. We envision several potential applications of ReIm and ReImInfer. We \nhave already used ReImInfer to infer method purity which is needed, for example, for Universe Type inference \n[12, 18]. Other applications are .ow-sensitive type inference, error detection in concurrent programs, \nand optimization of concurrent programs. In future work, we plan to develop a framework for inference \nand checking of pluggable types, which will include ReIm, ownership types, Universe Types, as well as \nother type systems such as AJ [35], EnerJ [29], etc. In addition, we intend to study the interesting \nrelationship between context sensitivity and CFL-reachability from data-.ow analysis and viewpoint adaptation \nfrom ownership types. Acknowledgments This research was supported in part by NSF grants CCF\u00ad0642911 and \nCNS-0855252 and by DARPA contracts FA8750-12-2-0107 and FA8750-12-C-0174. References [1] S. Artzi, A. \nKie. zun, D. Glasser, and M. D. Ernst. Combined static and dynamic mutability analysis. In ASE, pages \n104 113, 2007. [2] S. Artzi, A. Kie. zun, J. Quinonez, and M. D. Ernst. Parameter reference immutability: \nformal de.nition, inference tool, and comparison. Automated Software Engineering, 16(1):145 192, Dec. \n2009. [3] M. Barnett, D. A. Naumann, W. Schulte, and Q. Sun. 99.44% pure: Useful abstractions in speci.cations. \nIn FTfJP, pages 11 19, 2004. [4] B. Chin, S. Markstrum, T. Millstein, and J. Palsberg. Inference of user-de.ned \ntype quali.ers and quali.er rules. In ESOP, pages 264 278, 2006. [5] D. Clarke, J. M. Potter, and J. \nNoble. Ownership types for .exible alias protection. In OOPSLA, pages 48 64, 1998. [6] L. R. Clausen. \nA Java bytecode optimizer using side-effect analysis. Concurrency: Practice and Experience, 9:1031 1045, \n1997. [7] D. Cunningham, W. Dietl, S. Drossopoulou, A. Francalanza, P. M\u00a8 uller, and A. J. Summers. Universe \nTypes for topology and encapsulation. In FMCO, 2008. [8] V. Dallmeier, C. Lindig, and A. Zeller. Dynamic \npurity analysis for java programs. http://www.st.cs.uni-saarland.de/ models/jpure/, 2007. [9] W. Dietl \nand P. M\u00a8 uller. Universes: Lightweight ownership for JML. Journal of Object Technology, 4:5 32, 2005. \n[10] W. Dietl, S. Drossopoulou, and P. M\u00a8uller. Generic Universe Types. In ECOOP, pages 28 53, 2007. \n[11] W. Dietl, S. Dietzel, M. D. Ernst, K. Mus\u00b8lu, and T. W. Schiller. Building and using pluggable type-checkers. \nIn ICSE, pages 681 690, 2011. [12] W. Dietl, M. D. Ernst, and P. M\u00a8uller. Tunable static inference for \nGeneric Universe Types. In ECOOP, pages 333 357, 2011. [13] M. D. Ernst. Type Annotations speci.cation \n(JSR 308). http: //types.cs.washington.edu/jsr308/, July 3, 2012. [14] R. Fuhrer, F. Tip, A. Kie.zun, \nJ. Dolby, and M. Keller. Ef.\u00adciently refactoring Java applications to use generic libraries. In ECOOP, \npages 71 96, July 2005. [15] D. Green.eldboyce and J. S. J. Foster. Type quali.er inference for Java. \nIn OOPSLA, pages 321 336, 2007. [16] C. Haack, E. Poll, J. Sch\u00a8Immutableafer, and A. Schubert. objects \nfor a Java-like language. In ESOP, pages 347 362, Mar. 2007. [17] A. Heydon, R. Levin, and Y. Yu. Caching \nfunction calls using precise dependencies. In PLDI, pages 311 320, 2000. [18] W. Huang, W. Dietl, A. \nMilanova, and M. D. Ernst. Inference and checking of object ownership. In ECOOP, pages 181 206, 2012. \n[19] A. Le, O. Lhot\u00b4ak, and L. Hendren. Using inter-procedural side-effect information in JIT optimizations. \nIn CC, pages 287 304, 2005. [20] Y. Liu and A. Milanova. Ownership and immutability inference for UML-based \nobject access control. In ICSE, pages 323 332, 2007. [21] A. Milanova and W. Huang. Static object race \ndetection. In APLAS, pages 255 271, 2011. [22] A. Milanova, A. Rountev, and B. G. Ryder. Parameterized \nobject sensitivity for points-to analysis for Java. ACM Transac\u00adtions on Software Engineering and Methodology, \n14(1):1 41, Jan. 2005. [23] M. M. Papi, M. Ali, T. L. Correa, Jr., J. H. Perkins, and M. D. Ernst. Practical \npluggable types for Java. In ISSTA, pages 201 212, 2008. [24] D. Pearce. JPure: A modular purity system \nfor Java. In CC, pages 104 123, 2011. [25] S. Porat, M. Biberstein, L. Koved, and B. Mendelson. Au\u00adtomatic \ndetection of immutable .elds in Java. In CASCON, pages 10 24, 2000. [26] J. Quinonez, M. S. Tschantz, \nand M. D. Ernst. Inference of reference immutability. In ECOOP, pages 616 641, 2008.  [27] T. Reps. \nUndecidability of context-sensitive data-independence analysis. ACM Transactions on Programming Languages \nand Systems, 22:162 186, 2000. [28] A. Rountev. Precise identi.cation of side-effect-free methods in \nJava. In ICSM, pages 82 91, 2004. [29] A. Sampson, W. Dietl, E. Fortuna, D. Gnanapragasam, L. Ceze, and \nD. Grossman. EnerJ: Approximate data types for safe and general low-power computation. In PLDI, pages \n164 174, 2011. [30] A. S.alcianu and M. Rinard. Purity and side effect analysis for Java programs. In \nVMCAI, pages 199 215, 2005. [31] F. Tip, R. M. Fuhrer, A. Kie.zun, M. D. Ernst, I. Balaban, and B. D. \nSutter. Refactoring using type constraints. ACM Transactions on Programming Languages and Systems, 33(3): \n9:1 9:47, May 2011. [32] O. Tkachuk and M. B. Dwyer. Adapting side effects analysis for modular program \nmodel checking. In ESEC/FSE, pages 188 197, 2003. [33] M. S. Tschantz and M. D. Ernst. Javari: Adding \nreference immutability to Java. In OOPSLA, pages 211 230, 2005. [34] R. Vall\u00b4ee-Rai, P. Co, E. Gagnon, \nL. Hendren, P. Lam, and V. Sundaresan. Soot -a Java bytecode optimization framework. In CASCON, pages \n13 , 1999. [35] M. Vaziri, F. Tip, J. Dolby, C. Hammer, and J. Vitek. A type system for data-centric \nsynchronization. In ECOOP, pages 304 328, 2010. [36] H. Xu, C. J. F. Pickett, and C. Verbrugge. Dynamic \npurity analysis for Java programs. In PASTE, pages 75 82, 2007. [37] J. Zhao, I. Rogers, and C. Kirkham. \nPure method analysis within Jikes RVM. In ICOOOLPS, 2008. [38] Y. Zibin, A. Potanin, M. Ali, S. Artzi, \nA. Kie.zun, and M. D. Ernst. Object and reference immutability using Java generics. In ESEC/FSE, pages \n75 84, Sept. 2007. [39] Y. Zibin, A. Potanin, P. Li, M. Ali, and M. D. Ernst. Ownership and immutability \nin generic Java. In OOPSLA, pages 598 617, Oct. 2010.    \n\t\t\t", "proc_id": "2384616", "abstract": "<p>Reference immutability ensures that a reference is not used to modify the referenced object, and enables the safe sharing of object structures. A pure method does not cause side-effects on the objects that existed in the pre-state of the method execution. Checking and inference of reference immutability and method purity enables a variety of program analyses and optimizations. We present ReIm, a type system for reference immutability, and ReImInfer, a corresponding type inference analysis. The type system is concise and context-sensitive. The type inference analysis is precise and scalable, and requires no manual annotations. In addition, we present a novel application of the reference immutability type system: method purity inference.</p> <p>To support our theoretical results, we implemented the type system and the type inference analysis for Java. We include a type checker to verify the correctness of the inference result. Empirical results on Java applications and libraries of up to 348kLOC show that our approach achieves both scalability and precision.</p>", "authors": [{"name": "Wei Huang", "author_profile_id": "81548007977", "affiliation": "Rensselaer Polytechnic Institute, Troy, NY, USA", "person_id": "P3856200", "email_address": "huangw5@cs.rpi.edu", "orcid_id": ""}, {"name": "Ana Milanova", "author_profile_id": "81100481541", "affiliation": "Rensselaer Polytechnic Institute, Troy, NY, USA", "person_id": "P3856201", "email_address": "milanova@cs.rpi.edu", "orcid_id": ""}, {"name": "Werner Dietl", "author_profile_id": "81100178705", "affiliation": "University of Washington, Seattle, WA, USA", "person_id": "P3856202", "email_address": "wmdietl@cs.washington.edu", "orcid_id": ""}, {"name": "Michael D. Ernst", "author_profile_id": "81100204056", "affiliation": "University of Washington, Seattle, WA, USA", "person_id": "P3856203", "email_address": "mernst@cs.washington.edu", "orcid_id": ""}], "doi_number": "10.1145/2384616.2384680", "year": "2012", "article_id": "2384680", "conference": "OOPSLA", "title": "Reim &#38; ReImInfer: checking and inference of reference immutability and method purity", "url": "http://dl.acm.org/citation.cfm?id=2384680"}