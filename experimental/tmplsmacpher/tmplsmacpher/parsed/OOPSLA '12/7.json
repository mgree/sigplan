{"article_publication_date": "10-19-2012", "fulltext": "\n Modular and Veri.ed Automatic Program Repair Francesco Logozzo Thomas Ball Microsoft Research, Redmond \n { logozzo, tball} @microsoft.com Abstract We study the problem of suggesting code repairs at design \ntime, based on the warnings issued by modular program ver\u00adi.ers. We introduce the concept of a veri.ed \nrepair, a change to a program s source that removes bad execution traces while increasing the number \nof good traces, where the bad/\u00adgood traces form a partition of all the traces of a program. Repairs are \nproperty-speci.c. We demonstrate our frame\u00adwork in the context of warnings produced by the modular cccheck \n(a.k.a. Clousot) abstract interpreter, and generate repairs for missing contracts, incorrect locals and \nobjects ini\u00adtialization, wrong conditionals, buffer overruns, arithmetic over.ow and incorrect .oating \npoint comparisons. We re\u00adport our experience with automatically generating repairs for the .NET framework \nlibraries, generating veri.ed repairs for over 80% of the warnings generated by cccheck. Categories and \nSubject Descriptors D. Software [D.1 Programming Techniques]: D.1.0 General, D.2.1 Require\u00adments/Speci.cations, \nD.2.2 Design Tools and Technique, D.2.4 Software/Program Veri.cation D.2.5 Testing and De\u00adbugging D.2.6 \nProgramming Environments General Terms Design, Documentation, Experimentation, Human Factors, Languages, \nReliability, Veri.cation. Keywords Abstract interpretation, Design by contract, Pro\u00adgram repair, Program \ntransformation, Refactoring, Static analysis. 1. Introduction Programs have bugs. Sound static analyzers, \nsuch as auto\u00admatic program veri.ers, can catch bugs but usually leave the problem of repairing the program \nto the developer. During active development, reports of possible bugs may be of lit\u00adtle interest to programmers. \nOn the other hand, if a program Permission to make digital or hard copies of all or part of this work \nfor personal or classroom use is granted without fee provided that copies are not made or distributed \nfor pro.t or commercial advantage and that copies bear this notice and the full citation on the .rst \npage. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior \nspeci.c permission and/or a fee. OOPSLA 12, October 19 26, 2012, Tucson, Arizona, USA. Copyright c &#38;#169; \n2012 ACM 978-1-4503-1561-6/12/10. . . $10.00 veri.er can suggest code repairs, it can potentially help \nthe programmer write correct code. We focus on the problem of suggesting code repairs start\u00ading from \nthe warning issued by a modular program veri.er. A modular veri.er uses contracts (i.e., preconditions, \npost\u00adconditions, and object invariants) to decompose the veri.ca\u00adtion problem from the level of a whole \nprogram to the level of individual methods. Developer-supplied contracts are es\u00adsential not only for \nscalability but also for documenting in\u00adtent as well as localizing the cause of failures [25]. The .rst \nstep in addressing the problem is to focus atten\u00adtion on the bugs that matter to developers. In our case, \nwe consider contract violations and runtime errors. A tool like cccheck [12], the CodeContracts static \nchecker, can spot those errors at design time. Ideally, cccheck should not only report the warnings, \nbut also provide a (set of) possible .xes, that are then presented to the programmer to choose among \nor reject. The second step in addressing the problem is to de.ne what a code repair is. Previous work \non automatic program repair by Perkins et al. [27] de.nes a repair to be a code transformation such that \nthe repaired program passes a given set of test cases (including the one exposing the bug). This de.nition \nis not well-suited to the context of veri.cation and active program development as it requires running \nthe repaired program, which may not always be possible, and it is only as good as the given regression \ntest suite. Because of these limitations and our desire to statically reason about program defects and \nrepairs, we propose a different de.nition for repair. A veri.ed repair reduces the number of bad executions \nin the program, while preserving, or increasing, the number of good runs. A bad run is one that violates \na given speci.cation (assertion, precondition, run-time guard, etc.). A good run is one that meets all \nspec\u00adi.cations of the original program. These two sets of traces form a partition of all the traces of \na program. Using abstract interpretation, we design a general frame\u00adwork in which code repairs can be \nexpressed. We de.ne several abstractions of trace semantics in order to permit a wide variety of program \nrepairs. One abstraction restricts what is observable about program state to the program points containing \nassertions, which is necessary since we expect program repairs to change the control .ow of programs. \nA  void P(int[] a) { for (var i = 0; i < a.Length; i++) a[i-1]= 110; } void P (int[] a) { Contract.Requires(a \n!= null); for (var i = 1; i < a.Length; i++) a[i-1]= 110; } Figure 1. Cccheck detects the possible null-dereference \nof a and a de.nite buffer under.ow in P. It suggests the precondition a != null and initializing i to \n1. The resulting correct program is P . Boolean abstraction further restricts the observations to the \nBoolean values of assert expressions, which permits changes to program variables appearing in the program \nand the as\u00adsertion expression itself. Based on this semantic foundation, one can design different algorithms \nfor code repairs. In gen\u00aderal there is no unique recipe for designing veri.ed code re\u00adpairs, in the same \nway as in abstract interpretation there is no unique way of designing abstract domains. We relate the \nproblem of designing code repairs to pro\u00adgram veri.cation/analysis as follows. There are three com\u00adponents \nin program analysis: the program, the semantic knowledge about program behavior, and the property to \nbe veri.ed. In program analysis, the problem is to re.ne the semantic knowledge so to derive that the \nproperties hold for the program (veri.cation) or do not hold (bug .nding). In code repairs, the problem \nis to re.ne the program using the semantic knowledge so that it satis.es the properties of in\u00adterest. \nIn cccheck, or similar tools, the semantic knowledge is given by the abstract state, belonging to some \nabstract do\u00admain, which was computed by the analysis. The next natural step is to exploit the abstract \nstate to derive the semantic code .x. Therefore, code repairs are domain-dependent. We envision code \nrepairs to be standard part of the design of static analyses, abstract domains and veri.cation systems \nin general. Main contributions We de.ne the notions of veri.ed repairs in terms of abstractions of trace \nsemantics. We present sound algorithms for suggesting program repairs to: contracts (preconditions, postconditions, \nassumptions, pure methods), initialization (wrong constants, buffer size, object .elds), guards (negation, \nstrengthening, weakening), buffer over.ows, .oating point comparisons, and over.ow\u00ading expressions. While \nwe use cccheck as our veri.er, the proposed repairs can be easily adapted and implemented in most any \nstatic analyzer. It is worth noting that our formalization of veri.ed repairs is with respect to the \nspeci.cations of the original program. As we will see, some repairs are veri.ed by construction. For \nothers, we need to apply the repair and check the repaired program to ensure it does not violate other \nassertions, i.e., we want to avoid the situation where repairing an assertion causes the failure of another \nassertion downstream. The fact that all repairs are local to a method means that verifying a repair only \nrequires local analysis and can be applied to incomplete programs. In general, for a given warning, several \ndistinct repairs are possible. Repairs can be ranked according to some metric of interest, e.g., complexity, \nsize of the change, etc. We show that the local analysis is very fast in the order of 150ms per method \n and that the repair inference is just a tiny portion of that time. We can infer thousands of repairs \nin large C# libraries and we can propose a repair for more than 80% of the warnings issued by the analyzer. \nWe are con.ndent that our code repairs can be used in an interactive IDE. Plan The remainder of the paper \nis organized as follows. Section 2 illustrates the kind of repairs we are able to pro\u00adduce automatically. \nSection 3 presents a trace-based seman\u00adtics of programs. Section 4 de.nes abstractions over traces and \nformalizes two kinds of veri.ed repairs. Section 5 ex\u00adtends those abstractions when a static analyzer \nis used. Sec\u00adtion 6 describes the cccheck veri.er, the types of errors it can .nd, and the speci.c repairs \nenabled by cccheck. Sec\u00adtion 7 discusses our experience with automatically repairing very large C# programs, \nSection 8 reviews related work and Section 9 concludes the paper. 2. Examples of Program Repairs Repair \nby Contract Introduction. It is often the case that the code of a method is correct only when executed \nunder certain conditions. In the example of Fig. 1, when the param\u00adeter a is null, there will de.nitely \nbe a failure due to a null dereference of the parameter. In this case, the Cccheck tool suggests the \nprecondition a != null using a Requires contract [6]. In the example of Fig. 2, when length is negative, \nthe ar\u00adray allocation will always fail. In this case, there are two pos\u00adsible repairs: (i) add an explicit \nassumption 0 <= length; or (ii) add the postcondition to GetALength stating it will al\u00adways return a \nnon-negative value. Cccheck suggests both to the programmer and lets her choose which one to apply. The \n.rst repair is useful when GetALength is a third-party or ex\u00adternal code, as it makes the programmer \nassumption explicit and prevents Cccheck from generating a warning. The sec\u00adond repair documents the \nbehavior of GetALength, clearly stating the contract clients of the method can rely upon.  int[] ContractRepairs(int \nindex) { var length = GetALength(); // (1) var arr = new int[length]; arr[index] = 9876; return arr; \n} Figure 2. Cccheck spots several possible errors in the code (allocation of an array of negative size, \nbuffer overruns). See the paper text for a description the proposed repairs. string GetString(string \nkey) { var str = GetString(key, null); if (str == null) { var args = new object[1]; args[1] = key; // \n(*) throw new ApplicationException(args); } return str; } Figure 3. A (simpli.ed) code snippet from CustomMarshalers.dll. \nCccheck detects the buffer overrun at (*), and suggests the allocation of a larger buffer at the line \nabove or changing the index to 0. In this example, both a buffer under.ow and over.ow are possible. In \nthese cases, Cccheck proposes the pre\u00adcondition 0 <= index and the assumption Assume(index < length), \nmaking explicit the relationship between the return value of GetALength and the parameter index. Repair \nof Initialization and Off-By-One Errors. Another class of errors arises from the improper initialization \nof vari\u00adables (especially loop induction variables) or use of con\u00adstants just outside a safe zone. In \nthe for loop of Fig. 1, Cccheck detects a buffer under.ow and localizes the cause to be in the initialization \nof i. Cccheck infers that: (i) the constraint 0 < i should hold on loop entry; and (ii) any pos\u00aditive \ninitial value for i removes the buffer unde.ow. The ini\u00adtialization i =1 is the one that enables most \ngood runs, and it is therefore the one suggested to the user. In the example of Fig. 3, Cccheck detects \na buffer under.ow and suggests two potential repairs: allocate a buffer of length at least 2; use 0 to \nindex the array (to avoid the buffer over.ow, with\u00adout introducing an under.ow). Repairing Guards of \nConditional Statements. Let us con\u00adsider the code snippet in Fig. 4, taken from one of the .NET framework \nlibraries. At program point (*): (i) c != null should hold, otherwise the program will crash with a null\u00adpointer \nexception; (ii) cccheck determines that c is null for all the executions reaching that point (a de.nite \nerror). void ValidateOwnerDrawRegions( ComboBox c, Rectangle updateRegionBox) { if (c == null) { var \nr = new Rectangle(0, 0, c.Width); // (*) // use r and c } } Figure 4. A (simpli.ed) snippet from a bug \nfound in System.Windows.Forms.dll. cccheck proposes the re\u00adpair c != null as a precondition or as a replacement \nfor the guard of the if-then statement. IMethodCallMessage ReadArray( object[] callA, object handlerObject) \n{ if (callA == null) return null; varnum= 0; if (NonDet())) num++; if (callA.Length < num) throw new \nSerializationException(); // here callA.Length >= num this.args = (object[])callA[num++]; // ... } Figure \n5. A (simpli.ed) snippet from a bug found mscorlib.dll. Cccheck proposes to change the guard to callA.Length \n<= num Cccheck suggests three repairs: the necessary precondition c != null; .ipping the guard from c \n== null to c != null; removing the branch altogether. Note that neither re\u00adpair removes any good trace \npresent in the original program, but does remove bad traces. Also, there is no best repair. We do not \nrank repairs: we simply report them at the program point where they should be applied. In Fig. 5, cccheck \nsuggests to strengthen the if-guard to the condition callA.Length <= num, as a buffer over.ow may happen \notherwise (a Serialization exception is not considered an error). Repairing Erroneous Floating Point \nComparisons. Float\u00ading point comparisons may produce unexpected results [23]. The .NET semantics enforces \nthe runtime to use: (i) for stack values, the most precise .oating point representation available from \nthe hardware; (ii) for heap values, the rep\u00adresentation exactly matching the nominal type. In the code \nof Fig. 6, the parameter d0 may be a very small, non-zero double represented by 80 bits on x86. The test \nsucceeds, but the next assignment causes the truncation of the value of d0 to a 64-bit quantity, that \nmay be zero, violating the object  class FloatingPoint { double d; [ContractInvariantMethod] void ObjectInvariant() \n{ Contract.Invariant(this.d != 0.0); } public void Set(double d0) { // here d0 may have extended double \nprecision if (d0 != 0.0) this.d = d0; // d0 can be truncated to 0.0 } } Figure 6. A (simpli.ed) snippet \nfrom a bug found mscorlib.dll. The store .eld causes the truncation of d0 which may break the invariant, \ndespite the guard. Cccheck proposes repairing the guard by adding the truncation to d0. int BinarySearch(int[] \narray, int value) { Contract.Requires(array != null); int inf = 0, sup = array.Length -1; while (inf \n<= sup) { var index = (inf + sup) /2 ; // (*) var mid = array[index]; if (value == mid) return index; \nif (mid < value) inf = index + 1; else sup = index -1; } return -1; } Figure 7. Cccheck detects and \nautomatically proposes a re\u00adpair for over.ow in the computation of the variable mid, us\u00ading the loop \ninvariants automatically inferred by the abstract interpreter. invariant. Cccheck identi.es the problem \nand suggests re\u00adpairing the guard to (double)d0 != 0.0, i.e., forcing the comparison of the 64-bit truncation \nof d0 to zero. Repairing Over.owing Expressions. Veri.ed repairs are very helpful for dealing with unintended \narithmetic over\u00ad.ows. Consider the classical binary search example of Fig. 7: The expression at (*) may \nover.ow, setting index to a negative value, causing a buffer under.ow in the next line. Cccheck suggests \nrepairing the expression to inf + (sup -inf) / 2, which: (i) allows more good runs (inputs that previously \ncaused the over.ow now are ok); (ii) is based void ThreadSafeCopy(char* sourcePtr, char[] dest, int destIndex, \nint count) { if (count > 0) if ((destIndex > dest.Length) || ((count + destIndex) > dest.Length)) throw \nnew ArgumentOutOfRangeException(); { // ... } } Figure 8. A code snippet from a bug in mscorlib.dll. \nCccheckdetects that count + destIndex may over.ow and suggests repairing the expression to the non-over.owing \ncount > dest.Length -destIndex. on the loop invariant automatically discovered by cccheck: 0 = inf = \nsup < array.Length. In the example of Fig. 8, count can be a very large positive value, causing count \n+ destIndex to over.ow. Cccheck suggests repairing the expression to count > dest.Length -destIndex. \n3. Trace Semantics We formalize the notion of a veri.ed program repair via a trace semantics. As we are \nonly interested in repairs of violations of safety properties, we only consider .nite traces. Let P be \na program. P(pc) denotes the statement at pro\u00adgram point pc, and P[pc . S] denotes the program that is \nthe same as P everywhere except pc, where it contains the statement S. If S is a compound statement, \na remapping of S s program points may be needed. We keep the remapping implicit to simplify the notation. \nWe let E denote the set of pure Boolean expressions. Let S be a set of states, and tP . P(S \u00d7 S) be a \nnon\u00addeterministic transition relation. For a state s . S, s(C) denotes the basic command associated with \nthe state, e.g., an assignment, an assumption, or an assertion. The set of blocking states, i.e., states \nwith no successors, is B = {s . 1 S |.s. \u00actP (s, s1)}. The set of erroneous state, i.e., states violating \nsome assertion e, is E = {s . S | s(C)= assert e . s |= e}. B. Traces are sequences of states. Concatenation \nis denoted by juxtaposition and extended to sets of traces. Ssn is the set of non-empty .nite traces \nss = ss0 ... ssn-1 of length |ss| = n = 0 including the empty trace s' of length |s'| \u00a3 0. Ss+ \u00a3 Ssn \nS* is the set of non-empty .nite traces and s= n:1 Ss+ .{s'}. The set of .nite bad traces, i.e., traces \ncontaining an error is sE = {ss . Ss+ |.i . [0, |ss|).si . E}. The bad (resp. good) traces of T . Ss* \nare B(T ) \u00a3 T n Es(resp. C(T ) \u00a3 T n (Ss* \\ Es)). The function \u00b5 . P(S*) . P(S*) .lters the maximal traces \nout of a set of traces. Given a set of traces T , \u00b5(T ) is the largest set satisfying the properties: \n\u00b5(T ) . T and .t . \u00b5(T ). .t 1 . T..t 11.t 11 = s'. t1 = tt11.  The maximal execution traces or runs \nare pre.x traces generated by applying the transition relation from the initial states until a .xpoint \nis reached (partial execution traces) followed by a projection on the maximal traces: t+ s0 ...sn . T \n. t (sn,sn+1)}). sP (S)= \u00b5(lfp.T. S .{s0 ...snsn+1 | (1) The bad (resp. good) .nite complete runs, or \nsimply bad (resp. good) runs of P are BP \u00a3 B(st +) (resp. GP \u00a3 G(st +)). PP The de.nitions above (and \nin the following) can be ex\u00adtended as in [3] to take into account in.nite runs, but we In general, a \nrepair may introduce new assertions (that may or may not hold). As the goal of a repair is to address \nfailing assertions of the original program, we remove from the assertion semantics of P all the new assertions \nand the new variables before comparing the behaviors of P and P . Let dP,P denote a repair that transforms \nprogram P to program P and let A(dP,P ) be all the new assertions intro\u00adduced by the repair in P . Let \npdP,P . S . S denote the state projection over all the common variables of P and P . The function a1 \n. Ss* . Ss* removes all the new asser\u00ad dP,P tions and new variables from a trace: a1 dP,P (s )= . .. \n.. avoid doing it here to keep the presentation as simple as pos\u00ad sible. 4. Veri.ed Repairs s' s = s' \npdP,P (s)a1 (ss1) s = sss1 . s(C) . A(dP,P ) dP,P a1 (ss1) s = sss1 . s(C) . A(dP,P ) dP,P Hereafter, \nwe assume that P is the program containing a bug and P the repaired version. Intuitively, P should have \nmore and its lifting to sets adP,P a1 (s ), is a complete .-morphism, dP,P . P(Ss*) . P(Ss*), de.ned \n good runs and fewer bad runs than P. Because a repair may as adP,P (T )= ss.T change the program s control \n.ow, introducing new states, and possibly new assertions, the concrete traces of P and P may appear very \ndifferent. Thus, the simple inclusions GP .GP and BP .BP may be too strict and hold only for trivial \nrepairs. Instead, we compare the semantics of P and P at a higher level of abstraction. First, we remove \nall states but those con\u00adtaining assertion statements (the assertion trace semantics). Then, we remove \nall new assertions introduced in P . Ab\u00adstract interpretation [4] provides the right framework to for\u00admalize \nthis. Basic Elements of Abstract Interpretation. We .rst recall some basic facts and notations about \nabstract interpretation. . .-- A Galois connection (L, .) --.(L, .) consists of posets a (L, .), (L, \n.) and maps a . L . L, . . L . L such that .x . L, y . L : a(x) . y .. x . .(y). In a Galois connection, \nthe abstraction a preserves existing least upper bounds (lubs) hence is monotonically increasing so, \nby duality, the concretization . preserves existing greatest lower bounds (glbs) and is monotonically \nincreasing. The composition of Galois connections is a Galois connection. Assertion Trace Semantics. \nThe assertion abstraction aA removes all states but those referring to assertions. The ab\u00adstraction a1 \n. Ss* . Ss* on a single trace: A so that it exists a concretization function .dP,P such that .dP,P .----- \n(P(Ss*), .) -----. (P(Ss*), .). adP,P Veri.ed Repairs. We are now ready to formally de.ne the concepts \nof a veri.ed repair and a repaired program improving another program. DEFINITION 1 (Veri.ed repair, improvement). \nIf aA(GP) . adP,P . aA(GP ) and aA(BP) . adP,P . aA(BP ), then we say that dP,P is a veri.ed repair for \nP and that P is an improvement of P. The above de.nition denies the identity (i.e., program P itself) \nas a trivial improvement, since the number of bad traces should strictly decrease. It allows the removal \nof an always failing assertion as a repair. If an assertion fails in some executions and passes in others, \nthen its removal is disallowed (as the subset inclusion on good runs will fail). For a given program \nP, there may be several distinct improvements P 1, P 2 ... (e.g., Fig. 2 or Fig. 4). One can de.ne an \nadditional scoring function to rank P 1, P 2 ... . The de.nition of veri.ed repair naturally induces \na partial order on programs (and hence on improvements): a program Q improves R, written R . Q if dR,Q \nis a veri.ed repair for R. We only compare the same assertions over two versions of .. . the program, \nso P may introduce new bugs, which requires s' s = s' a new code .x, etc. The code .xing process can \nbe iterated to a1(s )= sa1 AA (ss1) s = sss1 . s(C)= assert e a .xpoint. In general, the least .xpoint \nmay not exist (more a1(ss1) s = sss1 . s(C)= assert e A hypotheses are needed). The de.nition above requires \nnot only all the assertions P(Ss*) . P(Ss*): . to be the same, but also that the variables have the same \n can be lifted to a set of traces aA a1(s ). The function aA , is a complete .- A aA (T )= concrete \nvalues. We can relax this by introducing a further abstraction a1 . Ss. P(Sa), Sa \u00a3 '.{true, false}\u00d7E, \nt which abstracts from a state everything but the assertion and ss.T morphism. Thus, it exists a unique \nconcretization .A such .A --- that (P(Ss*), .)---(P(Ss*), .) [4]. The assertion trace .. aA semantics \nof P is aA (st +). its truth value. Furthermore a1 forgets the execution order P t it only focuses on \nthe truth value of the assertions: int NotDecidable(int x) . . . { \u00d8 s = s' string s = null; (ss1) s \n= sss1 . s(C)= assert e 1 t {(b, e)} . a if(P(x)) a t (s )= . b = s |= e s = ss . . s = \"Hellouworld\"; \n1 (ss 1) s1 . s(C)= assert e return s.Length; a t } . P(Ss*) . P(Sa), de.ned The lifting to sets of \ntraces at (s ), is a complete .-morphism, so Figure 9. An example showing the undecidability of code \n1 as at(T )= s .T at repairs. The predicate P is true for each x, but it cannot be decided. that it exists \na concretization function .t such that (P(Ss*), .t --- .)-. .(P(Sa), .). -- at DEFINITION 2 (Veri.ed \nassertion repair, assertion improvement). Our goal is to exploit the information gathered by a If at \n. aA(GP) . at . adP,P . aA(GP ) and at . aA (BP) . . aA(BP ), then we say that dP,P is a veri.ed as\u00ad \nat . adP,P sertion repair for P and that P is an assertion improvement for P. Thus, an assertion improvement \nP focuses on the as\u00adsertion behavior, guaranteeing that: (i) the repair decreases the number of assertions \nviolated; (ii) no regression is intro\u00adduced. A veri.ed assertion repair is a weaker concept than veri.ed \nrepair, as it allows the addition of new traces that change the behavior of the program while not breaking \nthe old assertions. We say that a program Q a-improves R, writ\u00adten R a Q if dR,Q is veri.ed assertion \nrepair for R. Here we are interested in repairing failing assertions. However, one can think of modifying \nthe De.nition 2 to focus on other behaviors to .x, e.g., memory allocation, resources usage, or performance. \n5. Program Repairs from a Static Analyzer When the state space S is .nite, the .xpoint equation (1) can \nbe exactly computed and the abstractions and the de.nitions in Section 4 can be applied as they are. \nThe state space can be made .nite either by requiring the programmer to provide loop invariants (as in \ndeductive veri.cation [15]) or by .xing ahead of time a .nite set of predicates to be used (as in predicate \nabstraction [2]). In practice, state space .niteness is too strong a require\u00adment. We want to avoid it, \nunlike [14, 30]. For instance, un\u00adder the .niteness hypotheses we cannot automatically pro\u00advide a repair \nfor the over.owing expression in Fig. 7. The repair is based on the knowledge of the loop invariant 0 \n= inf = sup < array.Length (to prove that sup -inf does not under.ow). In general to infer such an invariant \nthe ab\u00adstract domain should at least include the abstract domain of intervals [4], which is of in.nite \nwidth and height. An abstract interpretation-based static analyzer, like cccheck, does not make the \n.nite states hypothesis. It computes an over-approximation of the trace semantics of P 1: + cccheck-like \ntool to automatically suggest veri.ed repairs for incomplete programs. We let BP \u00a3 B(.(cccheck(P))) (resp. \nGP \u00a3 G(.(cccheck(P)))) denote the inferred bad runs (resp. good runs) of P. De.nition 1 and De.nition \n2 can immediately be extended to use BP and GP instead of BP and GP . Because of over-approximation, \nit may be the case that more bad traces are inferred than the ones in the program s concrete semantics. \nIn practice, this means that sometimes cccheck cannot detect that an assertion is always satis.ed in \nthe concrete, and it suggests a repair for it, to shut off the warning. Nevertheless, this is not a problem \nfor us, for three main reasons. First, veri.ed code repairs are supposed to be used as design-time suggestions \nin the IDE: the programmer has the last word on whether or not to apply a code repair. Second, the code \nrepair generated from a false warning helps the programmer understanding the nature of the alarm. Third, \nby construction, veri.ed repairs improve the program in the sense of De.nition 1 or De.nition 2. If the \nrepair is such that PP1, then it introduces in P only checks that at worst are redundant with those that \nwere already present in P. Otherwise, if the repair satis.es P a P1, the repair is guaranteed to not \nviolate assertions that were (proven) de.nitely valid in P. EXAMPLE 1. Let us consider the example in \nFig. 9. The predicate P is such that .x.P(x)= true, but it cannot be decided. Such a predicate exists \nbecause of G\u00a8odel s incom\u00adpleteness theorems. Therefore, the s dereference cannot be proven, and two \ncode .xes can be suggested, satisfying re\u00adspectively De.nition 1 and De.nition 2: (i) the (trivial) addition \nof the assumption s != null just before the re\u00adturn statement, adding a redundant check at runtime; (ii) \nthe initialization s = \"\". Both repairs will stop cccheck from reporting the warning. 6. Program Repairs \nin Practice stP . .(cccheck(P)). (2) Actual veri.ed repairs are property-speci.c. They exploit the inferred \nsemantic information and the speci.cation (in 1 The concretization function . maps cccheck abstract \ndomains into con\u00adcrete execution traces. In general there is no best abstraction a. the form of contracts \nor runtime errors) to automatically pro\u00ad duce a program repair. We infer program repairs by leverag\u00ading: \n(i) a backwards must analysis to propose new contracts, initializations, and guards; (ii) a forward may \nanalysis to pro\u00adpose off-by-one, .oating point comparisons, and arithmetic over.ows code repairs. 6.1 \nClousot We extended cccheck, an abstract interpretation-based static analyzer for .NET [12], to generate \nveri.ed repairs. Cccheck has four main phases: (i) assertion gathering; (ii) fact inference; (iii) proving; \n(iv) report warnings and sug\u00adgest repairs. In the .rst phase, Cccheck gathers the program assertions, \neither provided by the programmer, e.g., as con\u00adtracts, or by language semantics, e.g., division by zero, \nnull pointer, etc. Then, it uses abstract interpretation to infer facts about the program. Cccheck includes \nabstract domains for heap abstrac\u00adtion [10], nullness checking [11], scalable numerical analy\u00adsis [18, \n22], universally and existentially quanti.ed proper\u00adties [5], and .oating point comparisons. [23] Cccheck \nuses the inferred facts to discharge the gathered assertions. Cccheck s decision procedure has four possible \nout\u00adcomes: (i) true, the assertion holds for all executions reach\u00ading it, if any; (ii) false, every execution \nreaching the asser\u00adtion, if any, will cause it to fail (e.g., Fig. 4); (iii) bottom, no execution will \never reach the assertion; (iv) top, we do not know, as the assertion may be violated sometimes or the \nanalysis was too imprecise. If the outcome is top or false, Cccheck tries to .nd a veri.ed repair before \nreporting the warning/error to the user. If a veri.ed repair is found (in gen\u00aderal there may be more \nthan one repair for a warning) then: (i) it is reported to the user via a graphical interface; and (ii) \nit is used by the warning scoring algorithm to produce a ranking of warning (e.g., a warning with a veri.ed \nrepair gets a higher score than a warning without a veri.ed repair).  The above outcomes give an easy \nalgorithm to check whether P a P : check (for the matching asserts) if cccheck reports fewer top and \nfalse for P than P with\u00adout reducing the number of the true results. Correctness follows by the analyzer \nsoundness property (2). In practice re-analysis is not a big problem: on average a method is analyzed \nin 156ms.  6.2 Repairs Inferred by Backwards Analysis The precondition inference of [6] is a goal-directed \nback\u00adward analysis Bpc (e), starting from a failing assertion e. For each program point pc, if Bpc (e) \ndoes not hold at pc, then e will necessarily fail later in the program. The expression Bpc (e) is a necessary \ncondition for e at pc. We omit here the details of B, leaving it as a parameter. Different choices are \npossible, enabling a .ne tuning of the precision/cost ratio. In general, Bis an under-approximation of \nthe semantics, com\u00adputing .xpoints when loops are encountered 2. The advan\u00adtage of using a necessary \ncondition is that we are guaranteed not to remove any good trace. We use the analysis Bto sug\u00adgest repairs, \nby matching Bpc (e) and the statement P(pc) as follows. Repair by Contract. Contracts (preconditions, \npostcondi\u00adtions, object invariants, assertions and assumptions) are used for code documentation and by \nthe static checker to perform the assume/guarantee reasoning. The backward analysis can be used to suggest \ncontracts. De.nition 1 generalizes the precondition inference prob\u00adlem of [6]. As a consequence, the \ninference of necessary preconditions is a form of veri.ed repair. A candidate neces\u00adsary precondition \nis Bentry (e). If Bentry (e) meets the visibil\u00adity and inheritance constraints of the enclosing method \n[20], then it can be suggested as precondition. Otherwise it is sug\u00adgested as an assumption or a candidate \nobject invariant. In both cases P Bentry (e); P follows from the fact that Bonly produces necessary conditions \n(hence cutting bad runs). It may be the case that the backwards analysis stops at pc = entry, i.e., before \nreaching the entry point of the method. For instance, this happens when variable in the goal expression \nis the return value from a method. We can still suggest a repair, either in the form of an Assume or \nas a candidate postcondition for the callee. No good trace is removed: PP[pc . (P(pc); Assume(Bpc (e)))]. \nEXAMPLE 2. For the array store in Fig. 2, Cccheck collects the two assertions 0 = index and index < arr.Length. \nThe inferred facts are not suf.cient to prove that the as\u00adsertions will not fail, so Cccheck propagates \nthe assertions backwards. For the .rst assertion, Bentry (0 = index)= 0 = index is suggested as precondition \n(index is a param\u00adeter). The precondition is necessary, because if index < 0 then a buffer under.ow de.nitely \nwill occur. The precondi\u00adtion is not suf.cient, as it does not guarantee that the array indexing is in \nbounds. For the second assertion, Bentry (index < arr.Length)= true, but B(1) (index < arr.Length)= index \n< length must hold between the return value of GetALength and the method parameter, otherwise the program \nwill nec\u00adessarily fail. Therefore, Cccheck suggests to make the assumption explicit using the repair \nContract.Assume (index < length). For the array creation, the safety con\u00addition 0 = length cannot be \nproven either, and the cause is traced back to the value returned by GetALength. Two repairs are possible: \neither an assumption (to document it) or a postcondition for GetALength. Initialization. The necessary \ncondition analysis B(e) can be used to infer repairs for initialization and guards. Let k be a compile-time \nconstant and i=k the statement at the pro\u00ad 2 Please note that Bis not Dijkstra s wp predicate transformer. \nThe weakest precondition requires the program to be correct on all the possible paths, no matter which \nnon-deterministic choice is made.  gram point pc. If Bpc (e)= i=k1, with k1 = k, then we have detected \nan erroneous initialization. We can suggest the re\u00adpair i=k1: P \u00a3 P[pc . (i= k1)]. More generally, if \nthe necessary condition is i<k1, with < a relational operator, then i should be initialized to a value \nsatisfying i < k13. However, the initialization repair may: (i) change the behavior of the program; (ii) \ncause assertions not in dP,P to fail in P . There\u00adfore, to verify the repair before suggesting it to \nthe user, we analyze P in background to check that no additional asser\u00adtion failure is introduced by \nthe repair, so that P a P . In 1 general there are many k satisfying i < k1 and P a P . We leverage the \nconstraint solver in (the numerical abstract domains of) cccheck to provide a satis.able assignment. \nIn 1 most of the cases we get the most general k . EXAMPLE 3. In Fig. 1, Cccheck infers the necessary \ncon\u00addition 1 = i, .nds the initialization i=0, and suggests repairing it with i=1. Similarly, in Fig. \n3, Cccheck prop\u00adagates the constraint 1 < args.Length, .nds the array cre\u00adation setting args.Length =1, \nand suggests the repair of a larger allocation new object[2]. Repairing Guards. We can use B(e) to check \nwhether a guard is too weak or even contradictory. If at a program point pc, P(pc)= Assume g, i.e., g \nis the guard at program point pc 4, and Bpc (e)= !g, then we can suggest to use !g instead of g, after \nchecking that no new assertion failure is introduced. Similarly, if g \u00a3 a<= b and Bpc (e)= a<b, we can \nsuggest a guard strengthening (after an additional run of cccheck). Therefore P a P[pc . Assume(Bpc (e))]. \nEXAMPLE 4. In the example of Fig. 4, the safety condi\u00adtion c != null contradicts the if-statement guard \nc == null. Hence it is proposed as a veri.ed repair: all the as\u00adsertions after (*) are unreached in P, \nand the else branch is empty. A new run of Cccheck is therefore not necessary. Please note that false \nmay also be proposed as a guard, i.e. the branch of the conditional can be removed altogether. In the \nexample of Fig. 5, the assertion num < callA.Length is stronger than the (implicit else-)condition callA.Length \n>= num, and hence proposed as a repair 5. Ensuring correct object initialization. When e is an asser\u00adtion \nin a public method m and Bentry (e) involves only private .elds of this object, then Bentry (e) is a \nnecessary invariant on the object .elds. In particular, if Bentry (e) contains only readonly .elds 6 \nthen it should hold after the invocation of any of the constructors. Otherwise, suppose the constructor \nc does not establish Bentry (e). Then the sequence of calls c, 3 Note that k does not satisfy i <k', \notherwise cccheck should have proven it before. 4 As common, we assume that conditional and loop guards \nare represented by Assume statements, and control .ow modelled by gotos. 5 In an early stage of Cccheck \npipeline, all such assumptions are made explicit. 6 A readonly .eld can only be assigned inside constructors. \n public class MyClass { private readonly SomeObj s; public MyClass(SomeObj s) { Contract.Requires(s \n!= null); this.s = s; } public MyClass() { } public int Foo() { return this.s.f; } // ... } Figure \n10. An example of object initialization repair. The repair can either initialize this.s to a non-null \nvalue in MyClass() or add an object invariant to avoid the null dereference of s in Foo. m will cause \nthe assertion e to fail. We can repair it in two ways. The .rst way is to repair the constructor c so \nto es\u00adtablish Bentry (e). This alternative corresponds to assuming Bentry (e) to be (part of) the object \ninvariant, and repairing the constructor to meet the invariant. We should check that the repair does \nnot violate some other assertion (to ensure that P a P ). The second way is to deny the invocation of \nm when the object is created via c. This corresponds to the object invariant bc ||Bentry (e). The Boolean \n.ag bc captures whether the class was initialized via the constructor c. The object invariant removes \nonly bad runs so that: P P . EXAMPLE 5. Let us consider the class in Fig. 10, abstracting a common pattern \nin system code. When Foo is invoked this.s != null should hold necessarily. Otherwise the client code: \nx = new MyClass(); x.Foo(); causes a null dereference exception. To rule out bad execu\u00adtions we can \neither modify the implementation of MyClass or we can add a contract to specify the correct usage pattern. \nThe .eld this.s is private, so it cannot be made a pre\u00adcondition of Foo: it is a condition on the object \n.elds that should be established on object creation. The .rst construc\u00adtor, MyClass(SomeObj), satis.es \nit. The second construc\u00adtor, MyClass(), does not. Adding the assignment this.s = new SomeObj() to MyClass() \nremoves the problem. An alternative is to add the object invariant  Contract.Invariant(this.b || this.s \n!= null); where the readonly private Boolean .eld is assigned this.b = true in MyClass(). Method purity. \nSuppose that the necessary condition Bpc (e) mentions an object on the heap o, e.g., o.f != null. If \nthe instruction at pc is a method call and no information is provided on m then Cccheck assumes the worst \nfor o, and the object gets havoced. As a consequence, the propagation of B(e) stops at pc. A repair is \nto mark the method m as [Pure], i.e., its execution as no visible side-effects. The pu\u00adrity marker has \nno effect on the concrete semantics, but it largely improves the precision of static analyzers: P P . \n 6.3 Repairs Inferred From the Abstract Domains Off-by one. The semantic facts inferred at a given program \npoint can be used to suggest repairs. In particular, one can use the information inferred by the numerical \nabstract do\u00admain(s) to suggest repairs for off-by-one errors. If cccheck cannot prove an assertion a<b \nat program point pc but it can prove a <= b, then it can suggest using a-1 instead of a, provided it \ndoes not introduce any new warning. In this case, P a P[pc . P(pc)[a . a-1]]. EXAMPLE 6. In the example \nof Fig. 3, cccheck trivially .nds that 1 <= args.Length = 1, and as 0<1, it sug\u00adgests 0 as new array \nindex. In the example of Fig. 5, it can prove that num <= callA.Length. However, it does not suggest \nreplacing num with num-1 as this may introduce a new bug in the program (a buffer under.ow at the same \nline). Floating point comparison. The .NET type system allows two kinds of .oating point numbers Float32 \n(32 bits) and Float64 (64 bits). The .NET speci.cation requires that .oats in locals (stack locations, \nparameters, return values) should be implemented by the underlying virtual machine with the highest precision \navailable from the hardware (e.g., 80 bits registers in x86 architectures). On the other hand, heap locations \n(.elds, array elements, statics) should always match the precision of their nominal type. As a consequence, \nwhen a local .oat is stored into a heap location its value is truncated. The comparison of values of \ndifferent bit sizes may lead to very unexpected results. For an expression a <b at pc, with < relational \noperator, if cccheck deduces that one of the operands has an extended precision, while the other has \nnominal precision, it suggests the repair t, containing the truncation of the extended preci\u00adsion value \nto its nominal type. Therefore, PP[pc . t]. EXAMPLE 7. In Fig. 6, cccheck infers the parameter d0 (of \nextended precision) is compared against a constant (of 64 bits), and it suggests adding the cast (double)d0 \nto force the truncation and guarantee that the comparison operator checks .oating point values of the \nsame bit size. In P the object invariant is hence satis.ed. Arithmetic Over.ows. We introduce a new algorithm \nto re\u00adpair arithmetic over.ows that leverages the decision proce\u00addure and the numerical facts inferred \nby Cccheck abstract domains. We consider expressions in the language: e ::= a | a < a a ::= k | v | a+a \n| a-a | a/k < ::= < | <= | > | >= | == | != k ::= -2p-1 | ... - 1 | 0 | 1 | ...2p-1 - 1 The rewriting \nrules are in Fig. 11. They immediately induce a non-deterministic memoization-based algorithm. The al\u00adgorithm \nstarts with an expression a which may cause an over.ow for some input, and rewrites it to an expression \na which is provably non-over.owing. The algorithm an\u00adnotates each subexpression with a tag: ? means that \nwe do not know if the expression may over.ow; ! means that the expression is provably not-over.owing \n(for the values in the concretization of the current abstract state). If it suc\u00adceeds, the algorithm \nguarantees that a : (i) evaluates to the same value as a when they are both interpreted over Z; and, \n(ii) no over.ow happens when evaluated on Zp, where p .{8, 16, 32, 64 ... } is the given integer precision. \nThe algorithm is incomplete by design, for performance reasons. It is an abstract interpretation of the \ntrivial algo\u00adrithm which enumerates all the equivalent expressions and then checks for non-over.owing. \nNext we detail the rules. A constant, a variable, and the comparison of non-over.owing expressions do \nnot over.ow. We can remove the uncertainty on an binary arithmetic expression if the underlying ab\u00adstract \nstate guarantees that the operation does not over.ow. Moving the right operand of a subtraction to the \nright of a comparison operator removes a possible over.ow. In the case of an addition, one should pay \nattention that -a does not over.ow (i.e., a may be MinInt). Division by a con\u00adstant over.ows if k =0 \nor if MinInt is divided by -1. Half-sum can be written in two ways (note that the rule (a+b)/2 . a/2+ \nb/2 is incorrect when a, b are odd quan\u00adtities). We can trade an addition for a subtraction, or a sub\u00adtraction \nfor an addition if we are guaranteed that the new expression does not over.ow. Finally, we allow shuf.ing \nex\u00adpressions by moving them on the same side of a relational operator, and we introduce strict inequalities \nto remove over\u00ad.ows (the dual rule for >= is not shown in the .gure). Let P be such that all the over.owing \nexpressions are replaced by the result of the algorithm above. Then P a P . EXAMPLE 8. In the binary \nsearch example (Fig. 7), Cccheck proves that all but one arithmetic expressions are not\u00adover.owing. It \ninfers the loop invariant 0 = inf = sup < array.Length. As a consequence, at (*), it can apply the rule \nfor the half-sum (the difference of two non-negative values can never over.ow), and it suggest the correct \nex\u00adpression. Similarly, in Fig. 8, cccheck captures the possible over.ow in the addition, and it suggests \nusing a subtraction instead.  k? . k! v? . v! ok(a1opa2) op . {+, -}(a! 1opa! 2)? . (a! 1opa! 2)! ok(-a2) \n((a! 1 + a! 2)? < 0)? . (a! 1 < -a! 2)! (a! 1 < a! 2)? . (a! 1 < a! 2)! ((a! 1 - a! 2)? < 0)? . (a! 1 \n< a! 2)! k = 0 . (a = MinInt . k = -1) (a!/k!)? . (a!/k!)! ((a! + b!)?/2!)? . ((a! + ((b! - a!)?/2!)!)!)! \n((a! + b!)?/2!)? . ((b! + ((a! - b!)?/2!)!)!)! ok(c - b) ((a! + b!)? < c!)? . (a! < (c! - b!)!)! ok(c \n- a) ((a! + b!)? < c!)? . (b! < (c! - a!)!)! ok(a-c) ((a! + b!)? - c!)? . ((a! - c!)! + b!)? ok(b-c) \n((a! + b!)? - c!)? . (a! + (b! - c!)!)? ok(a+b) ((a! - c!)! + b!)? . ((a! + b!)! - c!)? ok(a+b) (a! + \n(b! - c!)?)? . ((a! + b!)! - c!)? ((a! + b!)? < c?)? . (((a! + b!)? - c?)? < 0)? ((a! + 1!)?<=b!)? . \n(a!<b!)! Figure 11. The rules used by the over.owing expression repair algorithm. The function ok(a) \nuses the inferred facts to check whether the expression a (or one of its subcomponents) does not over.ow. \n Library Methods Overall Time Asserts Validated Warnings Repairs Time Asserts with Repairs % system.Windows.forms \nmscorlib system system.data.entity system.core custommarshaler 23,338 22,304 15,187 13,884 5,953 215 \n62:00 38:24 26:55 51:31 32:02 0:11 154,863 113,982 99,907 95,092 34,156 474 137,513 103,596 90,824 81,223 \n30,456 433 17,350 10,386 9,083 13,869 3,700 41 25,501 16,291 15,618 28,648 9,591 31 1:27 0:59 0:47 1:21 \n0:27 0:00 14,617 7,180 6,477 12,906 2,862 35 84.2 69.1 71.3 93.0 77.3 85.3 Total 80,881 3:31:03 498,474 \n444,045 54,429 95,680 4:51 44,077 80.9 Figure 12. The experimental results of veri.ed repairs on the \ncore .NET libraries. We report the number of methods, the overall analysis time, the number of assertions, \nvalidated assertions, warnings, the number of repairs, the time it took to infer them, the number of \nassertions with at least one repair and the percentage of warnings with at least one repair. Time is \nin  minutes. 7. Experience Shipped Libraries We generated veri.ed repairs for the shipped core libraries \nof the .NET framework (they are not yet annotated with contracts). We run Cccheck with the de\u00adfault checks \n(nonnull, bounds, arithmetic) and the precondi\u00adtion, postcondition and object invariant inference on. \nInfer\u00adence propagates preconditions and object invariants to the caller, where they become new assertions. \nThe more re.ned the inference algorithm, the more complex the inferred pre\u00adconditions [6]. The empirical \nresults are in Fig. 12. For each assem\u00adbly, we report the total number of analyzed methods and the overall \nanalysis time. We also report the number of as\u00adsertions, validated assertions (true, bottom), and warnings \n(false, top). The total number of repairs is obtained after simpli.cation and includes all of the repairs \nenumerated in Sec. 6. We use a simple simpli.cation procedure to elim\u00adinate redundant repairs. In general, \nthe simpli.cation proce\u00addure takes as input a set of repairs R and returns a set of repairs R1 such that: \n(i) the repairs in R and R1 are equiv\u00adalent; and (ii) #R< #R1. For instance, if x>0 and x> 1 are inferred \nas repairs, we retain only the latter. The time includes the time to infer the repairs and simplify them. \nWe also report the number of warnings for which we discovered at least one repair (in general several \nrepairs are possible for the same warning) and the percentage over the total number of warnings. Our \n.rst observation is that we can infer thousands of repairs in large libraries in a short time the time \nto generate code repairs is only a tiny fraction of the overall run of Cccheck. We can propose a repair \nfor a warning in almost 81% of the cases (overall). If the programmer decides to apply one of the repairs, \nthe precision of the analyzer (the percentage of all asserts that cccheck validates) rises by almost \n10% (from 89% to almost 99%). We cannot apply repairs automatically, as in general there is more than \none repair possible for a given warning.  Automatic application of repairs is out-of-the scope of our \nwork: we want to provide the programmer with vari\u00adous semantically justi.ed choices and let her decide \nhow to repair the code. Repairs provide a witness for the warn\u00adings, and we use them to rank the warnings. \nWe manually inspected some of the repairs generated by Cccheck and dis\u00adcovered new bugs in shipped and \nvery well-tested libraries. Some of those bugs are illustrated by the examples in Sec. 2. IDE integration \nThe goal of veri.ed repairs is to use them interactively. We integrated Cccheck in Visual Studio, via \nthe Microsoft Roslyn CTP [26]. An example of the user ex\u00adperience is in Fig. 13. Roslyn exposes the C# \n(and VB) com\u00adpiler(s) as a service. Plugins register to Roslyn as code is\u00adsues and code action providers. \nCccheck runs in background while the programmer is writing the program. Cccheck re\u00adports the assertion \nviolations as code issues. For those asser\u00adtions it can infer a code repair, Cccheck, reports it as a \ncode action. The code action is shown in a preview window. The user choses to apply the code action or \nnot. Veri.ed code repairs are realistic only if we can prove that the running time of the analysis + \nthe generation of the .xes is small enough to be used in a real time programming environment. On average \nCccheck analyzes 6+ methods per second and it infers 7.5 repairs per second (Fig. 12). The benchmarks \nabove were run without any form of caching. However, to further improve the performances, Cccheck has \na built-in cache mechanism which let the analysis run only on the methods that have been modi.ed since \nthe last analysis. In the past, we measured the effects of the cache mechanism to at least a 10\u00d7 speed-up. \nOverall, we are very positive that the approach can be applied during active development: code repairs \n+ Cccheck with cache are ef.cient enough to be used in the IDE. 8. Related Work Automatic program repair \nis an active research subject in the testing community [28]. Starting from a program P ex\u00adposing a bug, \nthe goal is to derive P such that the bug is repaired and no regression is introduced. The repair is \nob\u00adtained by pseudo-invariant inference [27], by genetic algo\u00adrithms [19, 35], by a smart exploration \nof the space of re\u00adpairs [1], or by instantiating some templates [34]. Our ap\u00adproach is different in \nthat we do not use a known failing test to infer the repair (we start from a warning issued by the analyzer), \nwe do not need to run the program to apply our technique, the repair is inferred from the semantics of \nthe program and it is veri.ed. In particular, the repairs we gen\u00aderate are property-speci.c, so our technique \nis not subject to the randomness in the proposed repairs of the afore\u00admentioned techniques. Pex [32] \nuses symbolic execution to remove inputs that inevitably lead to an error. Our .xes are more general \n(e.g., we can .x over.owing expressions) and they soundly cope with loops symbolic execution engines \ndo not infer loop invariants. Starc [9] mixes dynamic and static analysis to repair data structures. \nWe do tackle the problem of repairing data structures, but an interesting future research direction is \nto extend the de.nitions of Section 4 in that sense. Samini et al. [31] also combines dynamic and static \nanalysis, but to repair PHP programs. Eclipse [13] has a .x-it feature for repairing syntactically wrong \nprograms. Whalen et al. [36] have a vision of an in\u00adtegrated test environment. Our vision is instead \nthat of a se\u00admantic integrated environment [21], where a static analyzer runs in background, reports \nthe errors, proposes the semanti\u00adcally justi.ed repairs, and helps common programming tasks such as refactoring \n[7], searching, code reviewing etc.. In the static analysis and veri.cation community, recent work focused \non the repairing of Boolean programs [14, 16, 30]. We are not constrained to Boolean programs (we handle \narbitrary C# programs), we handle in.nite state spaces, and we have a very precise yet universal notion \nof what a code repair is. We were able to generate repairs for the running examples of the above papers, \nwith the exception of the con\u00adcurrent examples of [16] Cccheck does not analyze paral\u00adlel programs. \nSurprisingly enough, for the running example of [14] we inferred a different repair (the initialization \nx= 1). Other authors focused on repairing programs for speci.c properties. Martel [24] tackles the problem \nof repairing .oat\u00ading point arithmetic expressions. The goal of [24] is to infer (a good-enough approximation \nof) the most precise expres\u00adsion over machine .oats equivalent to a given one. His work is a code repair \nas according to our De.nition 2. The main differences with the algorithm in Fig. 11 is that we focus \non ints, so we are only interested in a non-over.owing expres\u00adsion (there may be many in general), we \nperform online local rewriting instead of estimating the cost for the whole expres\u00adsion, we use all the \nnumerical information inferred by the numerical abstract domains, not only the numerical ranges. Vechev \net al [33] present algorithms to introduce syn\u00adchronization to remove bad interleavings. In spirit, their \nap\u00adproach is very similar to ours, as they use abstract inter\u00adpretation to verify a program, and when \nthey fail they gave themselves the freedom to modify the program also when it cannot be proven in the \nabstract that it is wrong (it may be correct in the concrete). Apart from the handling of concur\u00adrency, \nthe main difference is that we do not aim at applying the .xes automatically, we give some semantic guarantees \non the repairs (they should not remove good runs and should increase the number of validated assertions), \nand we do not aim for minimality.  A related research .eld is the localization and the ex\u00adplanation \nof bugs and warnings. Jose and Majumdar [17] present an algorithm to .nd the cause of a failing test. \nTheir approach is different from ours in many ways. First, their algorithm requires the knowledge of \na complete (failing) program execution we use static analysis instead. Sec\u00adond, their error localization \nalgorithm is based on .nite tech\u00adniques (bounded model checking, SAT, loops are handled by unrolling) \nso it is unlikely to cope with in.nite state spaces as we do. Third, their scope is to .nd the origin \nof the bug, whereas we aim at proposing a repair for a possible error in the program. Rival [29] proposes \na set of techniques to .nd the origin of alarms in an industrial strength static an\u00adalyzer. Our veri.ed \nrepairs can be also used to explain the origin of the warnings of the static analyzer. Dillig, Dil\u00adlig \nand Aiken [8] use abduction to infer the information a static analyzer is missing to carry on the correctness \nproof (or to prove the program is incorrect). The information is presented to the user who should validate \nor refuse it. We do not use abduction and we interact with the user by suggest\u00ading code changes, instead \nof logical formulas. To see how our technique compares to abduction, we converted the C benchmarks of \n[8] into C#. We skipped those relying on C\u00adspeci.c patterns, e.g., string and pointer manipulation. We \napplied cccheck on the converted benchmarks. For most of them, cccheck not even shows a suggestion, as \nit was able to prove the correctness without additional help. For all the oth\u00aders, e.g., the one with \nreal errors, cccheck suggested mean\u00adingfull assumptions and repairs. Overall, we did not experi\u00adence \nany advantage of the abduction technique of [8] over ours. 9. Conclusions We envision a future in which \nIDEs not only report seman\u00adtic errors at design time but also suggest code repairs for them [21]. This \npaper is a .rst step in that direction. We in\u00adtroduced a new analysis for automatic, modular and veri.\u00adable \nprogram repair. We used abstract interpretation to for\u00admalize the concepts of a veri.ed repair (which \nremoves bad runs while possibly increasing good runs), and the weaker notion of veri.ed assertion repair. \nWe presented a set of ver\u00adi.ed repairs, implemented in our static analyzer for .NET. The repairs are \nextracted from the semantic information computed by the abstract interpreter. Experience shows that the \nrepairs: (i) are generated fast enough that they could be computed during active devel\u00adopment; (ii) cover \nalmost 4/5 of the warnings raised; and (iii) are precise enough to .nd new bugs for very well tested \nshipped libraries. Acknowledgments We thank Andrew Bagel, Patrick and Radhia Cousot, Manuel F\u00a8andrich, \nMatthieu Martel, Nikolai Tillman for the discus\u00adsions. We are also gratefull to Mike Barnett who made \nthe Roslyn integration possible. References [1] S. Chandra, E. Torlak, S. Barman, and R. Bod\u00b4ik. Angelic \ndebugging. In ICSE, 2011. [2] E. M. Clarke, O. Grumberg, S. Jha, Y. Lu, and H. Veith. Counterexample-guided \nabstraction re.nement. In CAV, 2000. [3] P. Cousot. Constructive design of a hierarchy of semantics of \na transition system by abstract interpretation. Theor. Comput. Sci., 277(1-2), 2002. [4] P. Cousot and \nR. Cousot. Abstract interpretation: a uni.ed lattice model for static analysis of programs by construction \nor approximation of .xpoints. In ACM POPL, 1977. [5] P. Cousot, R. Cousot, and F. Logozzo. A parametric \nsegmen\u00adtation functor for fully automatic and scalable array content analysis. In POPL, 2011. [6] P. \nCousot, R. Cousot, and F. Logozzo. Precondition inference from intermittent assertions and application \nto contracts on collections. In VMCAI, 2011. [7] P. Cousot, R. Cousot, F. Logozzo, and M. Barnett. An \nabstract interpretation framework for refactoring with application to extract methods with contracts. \nIn OOPSLA, 2012. [8] I. Dillig, T. Dillig, and A. Aiken. Automated error diagnosis using abductive inference. \nIn PLDI, 2012. [9] B. Elkarablieh, S. Khurshid, D. Vu, and K. S. McKinley. Starc: static analysis for \nef.cient repair of complex data. In OOPSLA, 2007. [10] M. F\u00a8ahndrich. Static veri.cation for Code Contracts. \nIn SAS, 2010. [11] M. F\u00a8 Declaring and checking ahndrich and K. R. M. Leino. non-null types in an object-oriented \nlanguage. In ACM OOP-SLA, 2003. [12] M. F\u00a8 ahndrich and F. Logozzo. Static contract checking with abstract \ninterpretation. In FoVeOOS, 2010. [13] Eclipse Foundation. Eclipse. http://eclipse.org, 2011. [14] A. \nGriesmayer, R. Bloem, and B. Cook. Repair of boolean programs with an application to c. In CAV, 2006. \n[15] C. A. R. Hoare. An axiomatic basis for computer program\u00adming. Commun. ACM, 12(10), 1969. [16] B. \nJobstmann, A. Griesmayer, and R. Bloem. Program repair as a game. In CAV, 2005. [17] M. Jose and R. Majumdar. \nCause clue clauses: error localiza\u00adtion using maximum satis.ability. In PLDI, 2011. [18] V. Laviron and \nF. Logozzo. Subpolyhedra: A (more) scalable approach to infer linear inequalities. In VMCAI, 2009. [19] \nC. Le Goues, M. Dewey-Vogt, S. Forrest, and W. Weimer. A systematic study of automated program repair: \nFixing 55 out of 105 bugs for $8 each. In ICSE, 2012.  [20] B. Liskov and J. M. Wing. A behavioral notion \nof subtyping. ACM Trans. Program. Lang. Syst., 16(6), 1994. [21] F. Logozzo, M. Barnett, P. Cousot, R. \nCousot, and M. F\u00a8ahndrich. A semantic integrated development environment. In OOPSLA Companion, 2012. \n[22] F. Logozzo and M. F\u00a8ahndrich. Pentagons: a weakly relational abstract domain for the ef.cient validation \nof array accesses. In SAC, 2008. [23] F. Logozzo and M. F\u00a8ahndrich. Checking compatibility of bit sizes \nin .oating point comparison operations. In 3rd work\u00adshop on Numerical and Symbolic Abstract Domains, \nENTCS, 2011. [24] M. Martel. Program transformation for numerical precision. In PEPM, 2009. [25] B. Meyer. \nApplying Design by Contract . IEEE Computer, 25(10):40 51, 1992. [26] Microsoft. Roslyn CTP. http://msdn.microsoft.com/en-us/roslyn, \n2011. [27] J. H. Perkins, S. Kim, S. Larsen, S. P. Amarasinghe, J. Bachrach, M. Carbin, C. Pacheco, F. \nSherwood, S. Sidiroglou, G. Sullivan, W.-F. Wong, Y. Zibin, M. D. Ernst, and M. Ri\u00adnard. Automatically \npatching errors in deployed software. In ACM SOSP, 2009. [28] M. Pezz`e, M. C. Rinard, W. Weimer, and \nA. Zeller. Self\u00adrepairing programs (Dagstuhl seminar 11062). Dagstuhl Re\u00adports, 1(2):16 29, 2011. [29] \nX. Rival. Understanding the origin of alarms in astr\u00b4ee. In SAS, 2005. [30] R. Samanta, J. V. Deshmukh, \nand E. A. Emerson. Automatic generation of local repairs for boolean programs. In FMCAD, 2008. [31] H. \nSamimi, M. Sch\u00a8afer, S. Artzi, T. D. Millstein, F. Tip, and L. J. Hendren. Automated repair of html generation \nerrors in php applications using string constraint solving. In ICSE, 2012. [32] N. Tillmann and J. de \nHalleux. Pex-white box test generation for .net. In TAP, 2008. [33] M. T. Vechev, E. Yahav, and G. Yorsh. \nAbstraction-guided synthesis of synchronization. In POPL, 2010. [34] Y. Wei, Y. Pei, C. A. Furia, L. \nS. Silva, S. Buchholz, B. Meyer, and A. Zeller. Automated .xing of programs with contracts. In ISSTA, \npages 61 72, 2010. [35] W. Weimer, T. Nguyen, C. Le Goues, and S. Forrest. Au\u00adtomatically .nding patches \nusing genetic programming. In ICSE, 2009. [36] M. W. Whalen, P. Godefroid, L. Mariani, A. Polini, N. \nTill\u00admann, and W. Visser. Fite: future integrated testing environ\u00adment. In FoSER, 2010.  \n\t\t\t", "proc_id": "2384616", "abstract": "<p>We study the problem of suggesting code repairs at design time, based on the warnings issued by modular program verifiers. We introduce the concept of a verified repair, a change to a program's source that removes bad execution traces while increasing the number of good traces, where the bad/good traces form a partition of all the traces of a program. Repairs are property-specific. We demonstrate our framework in the context of warnings produced by the modular cccheck (a.k.a. Clousot) abstract interpreter, and generate repairs for missing contracts, incorrect locals and objects initialization, wrong conditionals, buffer overruns, arithmetic overflow and incorrect floating point comparisons. We report our experience with automatically generating repairs for the .NET framework libraries, generating verified repairs for over 80% of the warnings generated by cccheck.</p>", "authors": [{"name": "Francesco Logozzo", "author_profile_id": "81100572523", "affiliation": "Microsoft Research, Redmond, WA, USA", "person_id": "P3856047", "email_address": "logozzo@microsoft.com", "orcid_id": ""}, {"name": "Thomas Ball", "author_profile_id": "81548021880", "affiliation": "Microsoft Research, Redmond, WA, USA", "person_id": "P3856048", "email_address": "tball@microsoft.com", "orcid_id": ""}], "doi_number": "10.1145/2384616.2384626", "year": "2012", "article_id": "2384626", "conference": "OOPSLA", "title": "Modular and verified automatic program repair", "url": "http://dl.acm.org/citation.cfm?id=2384626"}