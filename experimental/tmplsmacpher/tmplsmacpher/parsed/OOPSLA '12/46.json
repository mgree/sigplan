{"article_publication_date": "10-19-2012", "fulltext": "\n Constrained Kinds Olivier Tardieu Nathaniel Nystrom Igor Peshansky Vijay Saraswat IBM Research University \nof Lugano Google IBM Research tardieu@us.ibm.com nate.nystrom@usi.ch igorp@acm.org vsaraswa@us.ibm.com \n Abstract Modern object-oriented languages such as X10 require a rich framework for types capable of \nexpressing both value-dependency and genericity, and supporting pluggable, domain-speci.c extensions. \nIn earlier work, we presented a framework for con\u00adstrained types in object-oriented languages, parametrized \nby an underlying constraint system. Types are viewed as for\u00admulas C{c} where C is the name of a class \nor an interface and c is a constraint on the immutable instance state (the properties) of C. Constraint \nsystems are a very expressive framework for partial information. Many (value-)dependent type systems \nfor object-oriented languages can be viewed as constrained types. This paper extends the constrained \ntypes approach to handle type-dependency ( genericity ). The key idea is to introduce constrained kinds: \nin the same way that constraints on values can be used to de.ne constrained types, constraints on types \ncan de.ne constrained kinds. We develop a core programming language with con\u00adstrained kinds. Generic \ntypes are supported by introducing type variables literally, variables with type Type and permitting \nprograms to impose subtyping and equality con\u00adstraints on such variables. We formalize the type-checking \nrules and establish soundness. While the language now intertwines constraints on types and values, its \ntype system remains parametric in the choice of the value constraint system (language and solver). We \ndemonstrate that constrained kinds are expressive and prac\u00adtical and sketch possible extensions with \na discussion of the design and implementation of X10. Categories and Subject Descriptors D.3.1 [Programming \nLanguages]: Formal De.nitions and Theory; D.3.2 [Pro\u00adgramming Languages]: Language Classi.cations object- \nPermission to make digital or hard copies of all or part of this work for personal or classroom use is \ngranted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page. To copy otherwise, to republish, \nto post on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. OOPSLA \n12, October 19 26, 2012, Tucson, Arizona, USA. Copyright c &#38;#169; 2012 ACM 978-1-4503-1561-6/12/10. \n. . $10.00 oriented languages; D.3.3 [Programming Languages]: Lan\u00adguage Constructs and Features classes \nand objects, con\u00adstraints; F.3.3 [Logics and Meaning of Programs]: Stud\u00adies of Program Constructs object-oriented \nconstructs, type structure General Terms Design, Languages, Theory Keywords types; generics; constraints; \nX10 1. Introduction Dependent types [9, 31, 49] offer opportunities for detecting programming errors \nstatically and for eliminating costly ar\u00adray bounds, null dereference, or other run-time checks. The \nX10 programming language takes advantages of constrained types [37] a form of dependent types to provide \nan open\u00adended, user-extensible framework in which to specify and enforce desirable properties of data \nstructures statically. Generic types, types such as List<T> in Java that are parametrized by other types, \nare widely established [5, 12, 18, 25, 35, 36, 44], and are vital for implementing type-safe, reusable \nlibraries, especially collections classes. X10, like Java, initially had no support for genericity. The \nsubtle issues encountered when designing and implementing a generic type system for X10 exposed the need \nfor a for\u00admal framework in which to explore the design space and to reason about fundamental issues of \nsoundness and expres\u00adsivity. As a result, this paper develops the framework of con\u00adstrained kinds, unifying \nconstrained types and generic types. 1.1 Constrained Types In X10, a normal class type C is enriched \nto permit a constrained type C{c} where c is a constraint on the im\u00admutable .elds, or properties, of \nthe class C as well as any .nal variables and constants in scope. Constraints are drawn from a constraint \nlanguage that, syntactically, is a subset of the boolean expressions of X10. For in\u00adstance, Point{self.rank==n} \nis a type satis.ed by any n-dimensional point, that is, any instance of Point whose rank property is \nn. Here, n is a .nal variable whose value may be unknown statically. In a constraint, self refers to \na value of the base type being constrained, in this case Point. Constraints may be used to specify class \ninvariants and conditions on the accessibility of methods. For instance, the euclidian distance method \nof the Point class requires that the ranks of the points be the same:  class Point(rank:Int) { def distance(p:Point){this.rank==p.rank} \n... } Therefore the X10 compiler is able to .ag and reject pro\u00adgrams trying to compute the distance between \na 2-d point and a 3-d point. Reciprocally, if two points are known stat\u00adically to have the same rank, \neven if the actual rank itself is not known statically, the compiler is able to type check the distance \nmethod invocation. The key idea behind X10 s approach is that the type\u00adchecking rules can be decoupled \nfrom the machinery of constraints. By varying the constraint language and solver, one can tune the X10 \ntype system to the speci.c needs of a particular application domain, with con.dence that the result is \nsound.  1.2 Generic Types Generic types are essential for implementing type-safe, ex\u00adtensible collections \nlibraries. In Java, for example, generic types let programmers distinguish different types of lists such \nas lists of integers List<Integer> or lists of lists of strings List<List<String>>. In general, Java \ntypes can be parametrized with other types. The compiler keeps track of the type parameters and guards \nagainst mismatches. In other languages, including X10, genericity bene.ts extend beyond static safety. \nFor instance, X10 permits the declaration of struct types reminiscent of C structs. The run\u00adtime representation \nof an X10 array is customized to the content of the array: structs are inlined into arrays whereas arrays \nof objects are implemented as arrays of pointers. 1.3 Constrained Kinds This paper lays out a framework \nto extend constrained types to handle type genericity. The general outline of the ap\u00adproach is to introduce \ntype variables and a vocabulary of constraints over types. These constraints on types are used to specify \nconstrained kinds in the same way that constraints over values are used to specify constrained types. \nIn different programming languages, type variables are introduced as type parameters (cf. Java [18]) \nor as type members (cf. BETA [27]). In the framework described in this paper, a type variable can be \ndeclared as a property of a class or as a method parameter with type Type. For example, one can declare \nan Array class with a type property X as well as an integer property rank: class Array(X:Type,rank:Int) \n{ ... } Within the scope of its declaration, a type variable can be used wherever a type can (e.g., to \nspecify the type of a value property or method parameter, or as the target of a cast). Like value properties, \ntype properties can be used in con\u00adstrained types through the variable self. With the above 1 public \nclass Array[T](rank:Int) { 2 private val raw:Block[T]; // raw memory 3 private val size:Int; 4 ... 5 \n6 /* rank 1 constructors */ 7 public def this(size:Int,init:T) { 8 ... 9 raw = Block.allocateUninitialized[T](size); \n10 for (i in 0..(size-1)) raw(i) = init; 11 } 12 13 public def this(size:Int){T haszero} { 14 ... 15 \nraw = Block.allocateZeroed[T](size); 16 } 17 18 /* getter */ 19 public def get(p:Point){rank==p.rank}:T \n{ 20 return raw(offset(p)); 21 } 22 23 /* rank 1 getter */ 24 public def get(i:Int){rank==1}:T { 25 return \nraw(i); 26 } 27 28 public def sum(){T<:Arithmetic[T]}:T { 29 var acc:T = raw(0); 30 for (i in 1..(size-1)) \nacc += raw(i); 31 return acc; 32 } 33 } Figure 1. X10 array class. Array declaration, the type of an \narray of integers, say, can be written as Array{self.X==Int}. To make constrained kinds expressive, a \nsuitable vocab\u00adulary of constraints over types must be chosen. In the con\u00adtext of nominal object-oriented \nlanguages such as Java and X10, types are equipped with a partial order (the subtyp\u00ading relation) generated \nfrom the user program through the extends and implements relationships. This structure motivates a constraint \nsystem in which, for a type variable X one can assert the constraint X<:T. A valuation (a mapping from \nvariables to types) realizes this constraint if it maps X to a type that is a subtype of T. Constrained \nkinds can therefore express bounds on type variables similar to those in Java: X:Type{self<:Number} declares \na type variable X which can only be bound to those types S that satisfy S<:Number.  1.4 Example Figure \n1 shows a fragment of an Array class in the X10 syntax. This class introduces a type parameter T in square \nbrackets (see Section 5).  The fragment shows two constructors. The .rst construc\u00adtor (lines 7 11) takes \nan array size and an initial value for the array elements; the second (lines 13 16) takes only a size. \nThe second constructor constrains T with a haszero constraint, which holds when a type contains a zero \nvalue, that is, a value whose representation is a pattern of zero bits. This constraint allows fast allocation \nof arrays con\u00adtaining the zero value, but safely ensures a zero-backed ar\u00adray cannot be created when \nT is bound to a type such as Object{self!=null} with no zero value . Thus, to allocate an Array[Object{self!=null}], \nthe programmer must use the .rst constructor, passing in an explicit initial value. The example also \nshows two getter methods: the .rst (lines 19 21) requires a point of matching rank, while the second \n(lines 24 26) allows a single integer to index into the array, but only if the array is of rank 1. Finally, \na sum method (lines 28 32) is de.ned, which uses a subtyping constraint to require that the method only \nbe invoked on arrays of arithmetic types; that is, types pro\u00adviding the usual arithmetic operators. The \nsubtyping, haszero, and rank constraints all provide partial information about the types (both requirements \nand guarantees). The framework in this paper presents a uni.ed formalism for constraints on both types \nand values such as the above. It permits programmers to provide more static information to the compiler \nto enable safer, more ef.cient libraries and to allow the compiler to generate faster code with fewer \nrun-time checks.  1.5 Contributions This paper develops the framework of constrained kinds, unifying \nconstrained types and generic types. We present a formalization of these ideas through an extension of \nthe development in our prior work on constrained types [37]. We summarize our contributions: We present \na core featherweight calculus for con\u00adstrained kinds, FXG, parametrized on an underlying value constraint \nsystem. The calculus can express X<:T con\u00adstraints on type variables and offers the programmer a uni.ed \nview of value and type dependency.  We formalize its type system and prove type soundness. The type-checking \nrules cleanly disentangle type con\u00adstraints from value constraints, directly solving type con\u00adstraints \nwhile funneling value constraints to the constraint system.  We show how the framework can be extended \nin a sim\u00adple, methodical fashion to handle additional constraints such as arithmetic constraints or structural \nsubtyping constraints.  While our focus here is on a formal framework for con\u00adstrained kinds, we address \nissues of practicality in the context of X10. A version of the framework forms the core of the X10 type \nsystem. To realize the framework,  several design choices were made that restrict the expres\u00adsiveness \nin favor of ef.ciency, ease of use, and imple\u00admentation. We discuss how design alternatives such as the \nchoice of type parameters versus type members, use\u00adsite versus de.nition-site variance, and nominal versus \nstructural subtyping constraints can be expressed in the framework. The high-level design goal of FXG \nis to keep its type\u00adchecking rules as simple as possible while delegating the bulk of the hard work to \nthe constraint system. From an op\u00aderational perspective, the FXG type checker asks a constraint solver \nwhether a given context entails a given constraint and accepts or rejects programs based on the answers. \nAs shown in [37], this modular approach helps at many levels including soundness, expressivity, and performance. \nFirst, soundness is easier to ensure as it results in large part from the soundness of the constraint \nsystem itself. Second, the requirements on the constraint system are minimal, mak\u00ading it easy to explore \nthe design space and vary the static guarantees, annotation overhead, compile-time and run-time costs, \netc. Finally, the type checker performance will bene.t from highly optimized constraint solvers. Outline. \nThe rest of the paper is organized as follows. Section 2 introduces FXG with its formal semantics and \ntype-checking rules. We prove type soundness in Section 3 and discuss formal extensions of FXG in Section \n4. Section 5 follows with a discussion of design choices and of how the framework is realized concretely \nin X10. While this section builds on the formalism introduced in the previous sections, much of this \ndiscussion should be understandable after a quick read of Section 2. Related work is discussed in Section \n6. Section 7 concludes the paper. 2. The FXG Language In this section, we introduce a core formal programming \nlan\u00adguage, FXG, unifying constrained types and generic types. We describe its syntax, operational semantics, \nand type sys\u00adtem. Our language models many but not all of the relevant fea\u00adtures of X10. Following FJ \n[20], it does not account for mu\u00adtable state. Objects once constructed are immutable. All vari\u00adables \nare .nal. We model classes but not interfaces, method overriding but not method overloading, default \nconstructors but not user-de.ned constructors. None of these restrictions impacts the formalism, its \nsoundness, or expressivity in an essential way. We will revisit these decisions when we dis\u00adcuss X10 \nin Section 5. 2.1 Syntax The grammar for FXG is shown in Figure 2. The syntax is essentially that of \nX10. We use x to denote a possibly empty list x1,...,xn and to denote the empty list. A program P is \na .nite set of class declarations L.  (Class declaration) L ::= class C(f : T){c} extends C { M }(Method \ndeclaration) M ::= def m(x :T){c}:T = e; (Path) p ::= x | p.f (Kind) K ::= Type{c} (Type) R, S, T ::= \nK | T0 where T0 ::= C{c}| p (Expression) e ::= x | new C(e) | e.f | e.m(e) | e as T0 | C{c} (Constraint \nterm) t ::= x | new C(t) | t.f | C{c} (Value constraint) c0 ::= true | false | t == t | c0 ,c0 (Constraint) \nc ::= T0 <: T0 | c0 | c,c (Value) v, w ::= new C(v) | C{c} where c contains no variable other than possibly \nself C, D range over class names, f, g over .eld names, m over method names, x, y, z over variable names. \n.elds(C)= f : T (R-FIELD) new C(v).fi . vi 1 e . e (RC-FIELD) 1 e.f . e.f 1 e . e (RC-INVK-RECV) e.m(e) \n. e1 .m(e) 1 e . e (RC-CAST) e as T . e1 as T Figure 2. FXG productions. 1 ei . e i (RC-NEW-ARG) 1 \nnew C(v1,..., vi-1,ei,...,en) . new C(v1,...,vi-1,ei,...,en) method(C,m)= m(x :T){c}:R = e (R-INVK) \nnew C(v).m(w) . e[new C(v), w/this,x] 1 ei . e i (RC-INVK-ARG) 1 v.m(w1,...,wi-1,ei,...,en) . v.m(w1,...,wi-1, \nei,...,en) f new C(v):S,S <: T (R-CAST) new C(v) as T . new C(v) Figure 3. Operational semantics. .elds(Object) \n= class C(f :T){c} extends C1 { M } .elds(C1) = f1: T1 .elds(C) = f1, f :T1,T class C(f :T){c} extends \nC1 { M } def m(x :T1){c1}:R = e . M method(C, m) = m(x : T1){c1}:R = e class C(f :T){c} extends C1 { \nM } method(C1,m) = m(x :T1){c1}:R = e method(C, m) = m(x : T1){c1}:R = e Figure 4. Fields and methods. \nm . M (L-FIELD-B) (L-FIELD-I) (L-METHOD-B) (L-METHOD-I)  1. Classes. A class has a name C, .nal .elds \nf with types T, a superclass C, methods M, and a class invariant c a constraint on the .elds valid for \nall instances of the class. Like any other constraint, the class invariant may be omitted. An omitted \nconstraint simply stands for the true constraint. Class names C range over the declared classes in P \nand Object. As usual, we assume the classes of a program have distinct names, which are also distinct \nfrom Object and Type. The class Object is implicitly declared, has no .elds or methods, and does not \nextend any other class. We de.ne the inheritance relation C inherits from C1 as the transitive closure \nof the extends relation. We assume that the inheritance graph has no cycles or self loops; hence, it \nis a tree with class Object as its root. 2. Fields and constructors. The .elds of a class C are the union \nof the .elds of the superclasses and the .elds declared in C. class C(x:Object) extends Object {} class \nD(y:Type) extends C {} class E(z:y) extends D {} In this example, C has one .eld named x, D has two \nnamed x and y in this order, and E has three. The .elds are ordered by their declaration with the .elds \nof the superclass coming before the .elds of the declared class. We assume the names of the .elds of \na class to be distinct from one another. A .eld may be a type variable (e.g., the y .eld of D). The type \nof a .eld may involve .elds already declared. Here, .eld z is declared with type y. Each class has an \nimplicit default constructor that takes one argument for each .eld of the class, in order, and initial\u00adizes \nthe .elds with these arguments. The Object class has a 0-ary constructor. 3. Methods. Methods are introduced \nwith the def key\u00adword. A method has formals x with types T and return type T. The method guard c is to \nbe thought of as an additional con\u00addition that must be satis.ed by the receiver and the argu\u00adments of \nthe method call. The body of a method is an ex\u00adpression e. We assume that the formals of a method have \ndistinct names, none of which are this. We do not consider method overloading: we assume each class declares \nat most one method with a given name. The type of a formal may involve a formal declared to its left \nas well as the .elds of the enclosing class. For instance, the distance method of the Point class of \nSection 1 could also be declared: def distance(p:Point{this.rank==self.rank}) ... Here, this.rank denotes \nthe rank of method receiver and self.rank denotes the rank of p. Ultimately this constraint on the type \nof p or the method guard as de.ned in Section 1 impose the same restrictions on the method s applicability. \n4. Variables and paths. The variables in scope in the body of a method are the method formals x and the \nimplicit receiver this. Paths, e.g, x.f.g, are chains of .eld selections starting with a variable. 5. \nTypes, kinds, and type variables. Types in FXG are .rstly nominal types: each class name C de.nes a type \nC. Informally, a value is of type C if it is an instance of the  1 class C. Types include constrained \nclass types C{c} and con\u00adstrained kinds Type{c}. If value v is of type T{c} then it satis.es the constraint \nc[v/self]. Formals and .elds de\u00adclared with type Type{c} are said to be type variables. Finally, there \nare path types p. We assume that paths used in type positions are type variables, hence the name path \ntypes. We write T0 for a type that is not a kind, that is, a con\u00adstrained class type or a path type. \nA path type is never a kind. If a formal or .eld is declared with path type p then it cannot be a type \nvariable. In other words, its value cannot be a type. As a result, while type variables are not segregated \nfrom standard variables in FXG using the bracket notation of Java or X10, it is always possi\u00adble to partition \n.elds and formals as either type variables or standard variables by just looking at their declared types. \nWhile a method s return type may be a kind, an invoca\u00adtion of such a method cannot appear in type position \n(i.e., as the type of a formal or a .eld, or as the target of a cast). 6. Values, expressions, and constraint \nterms. There are two sorts of values: object instances and constrained class types C{c} where the only \nvariable permitted in c is self. Formally, C{c} binds variable self in c; a value C{c}may not have free \nvariables. Following FJ, we denote ob\u00adject instances by means of nested constructor calls, e.g., new \nBox(C,new C()). Expressions are built from variables in scope, .eld ac\u00adcesses, constructor calls, method \ninvocations, casts (writ\u00adten e as T0 ), and constrained class types. Casts for values of type Type such \nas C as Type{self==C} are unsup\u00adported due to a lack of compelling use cases. In FXG as in X10 or Java, \nC in constructor invocation new C(e) must be a class name, not a type or type variable. The set of constraint \nterms is a subset of the set of expres\u00adsions and a superset of the set of values. It includes variables \nand constrained class types and is closed under .eld selec\u00adtion and object construction. 7. Constraints. \nConstraints are built from the conjunc\u00adtion of the constraints true and false, equality constraints t \n== t, and subtyping constraints T0 <: T0 . We write c0 for value constraints, that is, in this core lan\u00adguage, \nequality constraints. Value constraints include equal\u00adity constraints on types such as x == C{c} (see \nSection 2.3). 1 Formally, the type of an instance of class C is .x : T. C{c} for some types T and constraint \nc, therefore a subtype of C.  A class invariant may only refer to the variable this. Moreover, it may \nonly refer to this in .eld selection ex\u00adpressions. A method guard may refer to the receiver this and \nthe formals x of the method. In general, a constraint c in a constrained type T{c} may refer to the variable \nself in addition to the variables in scope where self refers to any value of the type T being constrained. \nIn particular, a return type may refer to the receiver and the formals of the method as well as to the \nreturn value itself (i.e., self). Constraints may be nested, for example: Type{self<:Nat{self==new Zero()}} \nHere the outer self corresponds to the type being con\u00adstrained, the inner self to a value of that type. \n 2.2 Operational Semantics The operational semantics, shown in Figure 3, is described as a reduction \nrelation on expressions e . e1. It enforces a strict left-to-right call-by-value evaluation order. It \nuses two helper predicates de.ned in Figure 4. The .elds predicate computes the list of .elds of a given \nclass. The method predicate returns the declaration of method m available in class C, if it exists. It \nis recursively de.ned as either the method m declared in class C, if any, or else as the method m available \nin the superclass of C, if any. In rule R-INVK, we use [x/y] to denote the substitution of the y s by \nthe x s. This implicitly requires the two lists to have the same length, hence R-INVK ensures that the \nmethod call has the correct number of arguments. Unsurprisingly, the dynamic semantics only depends on \nthe type system via the rule R-CAST. In short, the rule speci.es that new C(v) can be cast to type T \niff new C(v) can be shown to have type S where S is a subtype of T. It is worth noting that, in theory, \ncasts require run-time invocations of the static type system, which may involve constraint solving (see \nSection 5.4). Except for casts, constraints are irrelevant to the dynamic semantics. We will establish \nthat there is no need for run\u00adtime checking of method guards or class invariants for a well-typed program. \nIn essence, every variable with a con\u00adstrained type T{c} is guaranteed to be bound to a value that satis.es \nc at run time. 2.3 Constraint System The FXG de.nition is parametrized by a value constraint system \nX . This constraint system is required to have the predicates and terms of our constraint language with \nan adequate interpretation. It may have other predicates and terms whose interpretation is left unconstrained. \nFormally, X is required to have terms t of the form C(f = t) , t.f , C{c} , and an equality predicate \n== on such terms. We map FXG constraint terms new C(t) to X terms C(f = t) so as to capture .eld names \nin the term itself (see the de.nition of constraint projections below). The entailment relation for X \nmust respect the interpreta\u00adtion of (a) C(f = t) as a .nite tree with root labeled with C, ith branch \nlabeled with fi and leading to ti, and (b) t.f as 2 selection of the child labeled f for the tree t. \nEquality is re.exive, symmetric, transitive, and a congru\u00adence w.r.t. .eld selection: if x == y then \nx.f == y.f. More\u00ad 1 1 over C(f = t) == C1(f = t) iff the class names and .eld names are identical and \nt == t1. Using object-oriented ter\u00adminology, equality is structural. Terms of the form C{c} are just \nthat, terms, with no semantics or structure as far as X is concerned. Intuitively, we want X to solve \nterm equivalence constraints irrespective of the sort of the terms, but subtyping constraints will be \nhandled outside of X . 1. Inconsistent constraints. A type T of may be incon\u00adsistent due to inconsistent \nconstraints, that is, there exists no value of type T. This may be due to value constraints as in the \ntype C{self==new C(),self==new D()} or type constraints as in the kind Type{self<:C,self<:D}. While it \nmakes sense to report inconsistent types, class invariants, or guards to the programmer (see Section \n5.6), inconsistent constraints are not a .rst-order concern of FXG. Indeed, as long as methods with inconsistent \nguards cannot be invoked, objects with inconsistent invariants cannot be constructed, or casts to inconsistent \ntypes cannot succeed, type soundness can be established. Inconsistent subtyping constraints however complicate \nthings because they essentially bring back multiple in\u00adheritance to FXG despite the initial single-inheritance \nas\u00adsumption. For instance, if x has type T and T has type Type{self<:C,self<:D} then both the methods \nof C and D are available on x, which lead to ambiguities. There\u00adfore, we adopt a mixed approach in FXG \nwhere we disallow inconsistent subtyping constraints, but consider inconsistent value constraints harmless. \nWe formalize this shortly.  2.4 Type System Type checking FXG programs involves judgments about constraint \nentailment, subtyping, member lookup, and typ\u00ading per se. Below, i stands for the name of a .eld of method \nand I,I1 for .eld or method signatures: I,I1 ::= C.f :T | C.m(x : T){c}: R Formally, we consider: 1. \nConstraint entailment: G f c0 environment G entails value constraint c0 2. Subtyping: G f S <: T the \ntype S is a subtype of type T in G G f x :: T the type of x is a subtype of type T in G 3. Member lookup: \nG f T.i -. IT.i resolves to .eld or method I in G  2 A complete axiomatization of the algebra of .nite \ntrees is provided in [29].  G f T.i =. IT.i ambiguously resolves to I in G I \u00ab I1 I overrides I1 4. \nTyping: G f e :T expression e has type T in G f def m(x :T){c}:R = e OK in C method m in class C is well \ntyped f class C(f :T){c} extends C1{ M } OK class C is well typed A program P is well typed iff all its \nclasses are well typed. In the de.nition of these judgments, the program source is an axiom of the deduction \nsystem. Therefore, judgments implicitly depend on the program P under consideration. The environment \nG is a .nite, possibly empty sequence of variable declarations x : T and constraints c. In the type system \nspeci.cation, we often need to partially specify the environment. In particular, we write G,x : T, . \nfor an envi\u00adronment that declares x with type T and is otherwise uncon\u00adstrained. Before we specify each \nof these judgments in turn, we discuss well-formedness, existential types, and class invari\u00adants. 1. \nWell-formedness. A constraint, type, or expression is well formed in environment G iff its free variables \nare de\u00adclared in G. Given the scoping rules we sketched earlier in this section, the rules of well-formedness \nare straightfor\u00adward. We omit them. An environment G is well formed iff each constraint and type in G \nis well formed w.r.t. to the sequence of variable declarations to its left. This includes the current \nvariable declaration. For example, x : Object{self == x} is a well-formed environment. It is worth keeping \nin mind that for G,x : y,. to be well\u00adformed it must be that y is declared as a type variable in G with \ntype Type{c} for some c. Moreover, x is not a type variable. We assume well-formedness through the rest \nof the paper. 2. Existential types. The family of types E we consider in the type system is richer than \nsource types T as de.ned in Figure 2. E ::= T | E{c}|.x :E. E First, we permit constraints on path types, \nfor example: x : Type,y : x f y : x{self == y} Second, types are closed under existential quanti.cation. \nInformally, a value v is of type .x : S. T if there exists some value w of type S such that v is of type \nT[w/x]. We use existential types to conveniently accumulate con\u00adstraints in chains of existentials. For \ninstance, if class C has a .eld f with type Object, we can establish x : C f x.f : .y :C{self == x}. \nObject{self == y.f} While, as part of the type-checking rules, we could attempt to simplify this to x \n: C f x.f : Object{self == x.f}, The constraint projections s and p are de\u00ad.ned similarly. To save space, \nwe introduce . to abstract over them. . .{s,p} .(x)= x .(new C(t)) = C(f = .(t)) if .elds(C)= f : T .(t.f)= \n.(t).f .(C{c})= C{c} .(true)= true .(false)= false .(c,c 1)= .(c), .(c 1) .(c,G)= .(c), .(G) .(x :Type,G)= \n.(G) .(x :C,G)= .(G) .(x :y,G)= .(G) .(x :T{c},G)= .(x : T,c[x/self],G) .(x :.y : T. S,G)= .(z : T,x \n: S[z/y],G) s(t == t1)= s(t) == s(t1) p(t == t1)= true s(S0 <: T0 )= true p(S0 <: T0 )= S0 <: T0 Figure \n5. Constraint projections. s(G) f c0 in X (X-PROJ) G f c0 Figure 6. Constraint entailment. we choose \nnot to do so in the type system and rely on the constraint solver to coalesce the equality constraints. \nIn our implementation however, we adopt an eager approach no existentials for performance reasons. For \nsimplicity, we keep using symbols R, S, and T to refer to types of the extended family. 3. Class invariants. \nA class invariant is intended to hold for any instance of that class. Therefore, in all judgments, if \nG declares a variable x of type C then the invariant for class C with x substituted for this is implicitly \nadded to G. 4. Constraint entailment. In general, a typing environ\u00adment is expressed in terms that are \noutside of the domain of the constraint system, such as existential types, subtyping  3 In contrast, \nwe do not recursively add invariants for the .elds of x. It is the responsibility of the FXG programmer \nto include selected fragments of these invariants into the class invariant itself. See [37] for a discussion \nof the alternative.  x fresh G,x :S f x :: T (S-SUB) G f S <: T G,x :S,c[x/self],. f x :: T (S-CONST-L) \nG,x :S{c},. f x :: T S <: T . p(G,x : S,.) (S-HYP) G,x : S,. f x :: T G f c[x/self],x :: T (S-CONST-R) \nG f x :: T{c} class C(f :T){c} extends C1{ M } (S-CLASS) G,x :C,. f x :: C1 G,y :R,x :S,. f x :: T (S-EXISTS-L) \nG,x : .y : R. S,. f x :: T G,x :S,. f S == T (S-REFL) G,x : S,. f x :: T G f t :R,y :: T[t/x] (S-EXISTS-R) \nG f y :: .x : R. T G f x :: Sy fresh G,y :S f y :: T (S-TRANS) G f x :: T Figure 7. Subtyping rules. \nconstraints, etc. It is therefore necessary to extract from the typing environment a context for the \nvalue constraint solver to reason about. In Figure 5, we de.ne the constraint projection s(G) that, in \nessence, strips out all type information from G, material\u00adizes .eld names and existentials, and drops \nsubtyping con\u00adstraints. In the last rule, we assume that alpha-equivalence is used to choose a variable \nz that does not occur in the con\u00adtext under construction. The dual projection p also de.ned in Figure \n5 is discussed later. If c0 is a value constraint, we specify that G f c0 if s(G) entails s(c0 ) in X \nwith rule X-PROJ in Figure 6. 5. Subtyping. We say that S is a subtype of T in G and write G f S <: T \nif, informally, an expression of type S may be used when an expression of type T is required. The type\u00adchecking \nrules for method and constructor invocations for example make use of the subtyping relation. Because \nof dependent types, both S and T may constrain self. Intuitively, self in S and self in T are to be thought \nas the same variable when evaluating the validity of the judgment G f S <: T . It is therefore necessary \nto instan\u00adtiate self equate self in both types with a fresh variable name to reason about the subtyping \nrelation. When formal\u00adizing subtyping and making proofs about it, we came to real\u00adize that this is cumbersome \nand error prone. This motivates the introduction of an alternate notation for subtyping judg\u00adments, which \nwe now describe. We adopt G f x :: T as our primary form of subtyping judgment. If variable x is declared \nwith type S in G, then this stands for G f S{self == x}<: T{self == x} . In other words, if x is fresh, \nthe following equivalence holds: G,x : S f x :: T . G f S <: T We use this equivalence to prove subtyping \nconstraints in guards and class invariants (see rule S-SUB in Figure 7) but, as much as possible, we \nstick to the :: form. In essence, it lets us introduce a variable name x to reason about once, which \ncan be then used across an entire deduction tree. The intent of FXG subtyping is to combine nominal sub\u00adtyping \nand constraint entailment: type C{c} is a subtype of C1{c1} if C inherits from C1 and c entails c1. For \nexam\u00adple, the type RectArray{self.t==Int} is a subtype of Array{self.t<:Number} if Int is a subtype of \nNumber and RectArray a subtype of Array. The subtyping relation is speci.ed in Figure 7. It relies of \nthe constraint projection p of Figure 5 to extract subtyping constraints from the environment. There \nare three sources of subtypes: (i) the extends re\u00adlation of the source program (rule S-CLASS), (ii) subtyp\u00ading \nconstraints in the source program (rule S-HYP), and (iii) term equivalence (rule S-REFL). This last rule \nlets us for instance derive that x : Type{self == Int}f x :: Int. Subtyping is re.exive thanks to rule \nS-REFL and transitive by rule S-TRANS. Rules S-CONST-L, S-CONST-R, S-EXISTS-L, and S-EXISTS-R handle \nconstrained and existential types. In rule S-EXISTS-L, well-formedness ensures that variable y is not \nfree in . or T. Rules S-CONST-L and S-CONST-R let us rearrange con\u00adstraints in types, e.g., x :T{c,c1} \nf x :: T{c}{c1}. 6. Inconsistent subtyping constraints. We say that an environment G is inconsistent \niff G f T <: C,T <: D for some type T and distinct class types C and D such that C does not inherit from \nD or vice versa. In the remainder of the type system, that is, in member lookup and type-checking rules, \nwe assume all environments  class C(f :T){c} extends C1{ M } (H-FIELD) G f C.fi =. C.fi :Ti class C(f \n:T){c} extends C1{ M } def m(x :T1){c1}:R = e . M (H-METHOD) G f C.m =. C.m(x :T1){c1}:R G f S <: T \nG f T.i =. I (H-SUB) G f S.i =. I G f T.i =. I .I1 . G f T.i =. I1. I \u00ab I1 (H-AMB) G f T.i -. I C.i \n: I \u00ab C.i :I (O-REFL) f C <: C1 this : C,x :T,c1f c this :C,x :T,c f R <: R1 (O-METHOD) C.m(x :T){c}:R \n\u00ab C1 .m(x : T){c1}: R1 Figure 8. Member lookup. i ranges over member names, I over member signatures. \nG,x :T,. f x :T{self == x} (T-VAR) G f e :S,S.f -. C.f :T .elds(C)= f : Tx fresh (T-FIELD) G f e.f :.x \n:S. T[x.f/f]{self == x.f} G f e :S .elds(C)= f : Tx fresh G,x :S f x :: T[x/f],inv(C)[x/this.f] (T-NEW) \n G f new C(e):.x :S. C{self == new C(x)} G f e :S, e :T, S.m -. C.m(x :T1){c}:Ry,z fresh . =[y,z/this,x] \nG, y : S, z : T f c.,z :: T1. (T-INVK) G f e.m(e):.y :S,z :T. R. G f e :S (T-CAST) G f e as T0 :T0 \nG f C{c}:Type{self == C{c}} (T-CLASS) this :C,x :T,c f e :Sy fresh this :C,x :T,c, y : S f y :: R 1 \nmethod(super(C),m)= m(x1 :T1){c1}:R1 = eimplies C.m(x :T){c}:R \u00ab super(C).m(x1 :T1){c1}:R1 (OK-METHOD) \n f def m(x : T){c}:R = e OK in C this :C f inv(C1) .elds(C1)= f1 :T1 f n f1 = 0/ M OK in C (OK-CLASS) \n f class C(f :T){c} extends C1{ M } OK Figure 9. Typing rules. x : Type f x : Type{self == x} T-VAR \n x : Type f new C(x) : S where S is .z : Type{self == x}. C{self == new C(z)} T-NEW x : Type f new C(x).f \n: T where T is .z : S. Type{self == z.f} T-FIELD  x : Type,y : T f y :: Type S-CONST-L and S-EXISTS-L \n x : Type,y : T f y == x X-PROJ  Figure 10. Example judgments for program class C(f:Type) extends Object \n{}. are not inconsistent. In other words, inference rules cannot be instantiated with inconsistent environments. \nThis consistency check is key to the soundness proof. It ensures that if a method invocation is typed \nusing the signature of method m in class C then, at run time, this invocation will be dispatched to m \nin either C or a subclass of C (as opposed to a class possibly unrelated to C). While this criterion \nis adequate for FXG with its single\u00adinheritance hierarchy, in the X10 type checker, we imple\u00adment a re.ned \nconsistency test which accounts for interfaces in addition to class inheritance. 7. Member lookup. Figure \n8 speci.es the .eld and method signatures available on each type. A .eld signature is of the form C.f \n: T with the name C of the class declaring the .eld, the .eld name f and the declared type for the .eld \nT (possibly a path type). Simi\u00adlarly, a method signature is written m(x : T){c}:R with the class name \nC, method name m, formal names x and types T, guard c, and return type R. Lookup is a function of the \nreceiver s type T and the desired member name i. In particular for methods it does not involve the formal \ntypes, argument types, or method guards we do not consider overloading. The types and method guard will \nbe checked later (see rule T-INVK in Figure 9). We .rst de.ne ambiguous lookup: member i of type T ambiguously \nresolves to signature I in context G, written G f T.i =. I . Ambiguous lookup collects candidate sig\u00adnatures \nby looking at all the class types that are super types of T, which involves not only the inheritance \ntree but also the subtyping constraints in the input program. Then, rule H-AMB, T.i (unambiguously) resolves \nto I, written G f T.i -. I , iff T.i resolves to I ambiguously and I overrides any other signature T.i \nresolves to. The overriding relation \u00ab is re.exive. Fields cannot be overridden in subclasses. A method \nof class C overrides a method of class C1 it inherits from iff it has the same formal names and types, \nthe guard of the method in C1 entails the guard of the method in C and the return type in C is a subtype \nof the return type in C1 . Of course, for the non-generic fragment of FXG, it would make sense to look \nfor .elds and methods by walking the class hierarchy bottom up, stopping at the .rst match, thus avoiding \nthe need for ambiguous lookup altogether. But once there are type variables and bounds, it gets complicated. \nMoreover, there is not much point specifying an ef.cient traversal for a formal language like FXG without \ninterfaces, so we stick to the inef.cient but sound procedure of ambigu\u00adous lookup followed by ambiguity \nresolution. 8. Typing. The typing rules are speci.ed in Figure 9. We write inv(C) for the invariant of \nclass C and super(C) for the superclass of C. T-VAR asserts the constraint self == x, which records that \nany value of this type is known statically to be equal to x. Thanks to this constraint, we can for instance \ntype check the invocation x.distance(x) on a variable x of type Point even if the rank of x in statically \nunknown. T-FIELD resolves the .eld name on the expression type. Like T-VAR it records more than just \nthe resolved .eld type T. It asserts that there exists an x of the receiver s type such that any value \nof this type is known statically to be equal to x.f. Because T may be a dependent type, we need to substitute \npossible occurrences of .eld names in T with the corresponding .elds of x. T-NEW has a similar structure \nto T-FIELD. It checks that the static types of the constructor arguments are subtypes of the declared \n.eld types and also imply the class invariant. Fi\u00adnally, it records that the types of the .elds of the \nconstructed object are the types of the constructor call arguments, which are typically more precise \nthan (as in strict subtypes of) the declared .eld types of the class. Combining these three rules with \nconstraint entailment, we can for example in Figure 10 establish statically for program class C(f:Type) \nextends Object {} that if x is a type variable then new C(x).f has not only a type T that is a subtype \nof Type but in addition that any variable of type T is equal to x. T-INVK similarly enforces that the \nargument types are subtypes of the types of the formals and checks that the method guard is entailed \nby the argument types. T-CAST only requires e to be of some type S. At run time, the reduced value for \ne is checked to see if it is actually of type T (see R-CAST in Figure 3). T-CLASS like T-VAR records \nthat any value of this type is statically known to be C{c}. OK-METHOD and OK-CLASS enforce overriding \nrules for .elds and methods. The class invariant of a class must entail the class invariant of its superclass. \nOK-METHOD makes sure the body of a method has a type that is a subtype of the declared type (assuming \nthe class invariant and the method guard).  3. Soundness The following results hold for FXG irrespective \nof the choice of the value constraint system X . Lemma 3.1 (Principal types). G f e : S and G f e : T \nthen S are T are identical. Lemma 3.2 (Progress). If f e : T then one of the following conditions holds: \n1. e is a value, 2. e contains a stuck cast sub-expression, that is, an expres\u00adsion of the form v as \nT0 , 3. there exists e1 such that e . e1 .  Lemma 3.3 (Subject Reduction). If P is well typed and e \n. e1, and G f e : T then there exists a type S such that G f e1 :S. Moreover, G f S <: T. Theorem 3.4 \n(Type soundness). If P is well typed and f e :T and e reduces to a normal form e1 then either e1 contains \na stuck cast sub-expression of the form v as T0 or e1 is a value v and there exists S such that f v \n:S. Moreover, in that case, f S <: T. Constructors calls in a well-typed program do not violate class \ninvariants at run time. Theorem 3.5 (Class invariants). If P is well typed and G f new C(e): T and e \n.* v then G f inv(c)[v/this.f]. Method invocations in a well-typed program do not vio\u00adlate method guards \nat run time. Theorem 3.6 (Method guards). If P is well typed and G f e.m(e):S and e .* new C(v) and e \n.* w and method(C,m)= m(x :T){c}:R = e1 then G f c[new C(v),w/this,x]. The proofs of these results are \nsketched in Appendix A. 4. Extensions We now discuss possible extensions of FXG, .rst for the case of \nvalue constraints, then for type constraints. Primitive types. Since the FXG design is parametric in \nthe value constraint language we can easily extend it to support, say, arithmetic constraints or constraints \non primitive types. First, we assume we are given a constraint system X with a vocabulary of primitive \ntypes R, functions h, predicates q, and literals l of these primitive types. Second, we extend the productions, \noperational semantics, and type system of FXG with the productions and inference rules of Figure 11. \nFormally, we should also extend the constraint projections, but the extensions are straightforward and \nomitted. We denote Rng(l) the primitive type of the literal l. We assume each function h is a total mapping \nfrom Dom(h) to Rng(h), that is, if f v : Dom(h) then there exists a unique literal l equal to h(v) and \nmoreover Rng(l) is Rng(h). For instance, if X de.nes the type Int, integer literals, the addition operator, \nand the greater-or-equal predicate, we could declare: class Count(n:Int) extends Object { def inc():Count{self.n>=this.n} \n= new Count(this.n+1); } In rule T-FUN, we assume we are given an abstraction h of every function h. \nFormally, h(x) is a formula of the constraint language relating the variables x and possibly self. For \ninstance, the absolute value function abs could be typed as: G f e : T,T <: Int G f abs(e):.x :T. Int{self \n>= 0} Informally, FXG+primitives is sound iff function abstrac\u00adtions are sound. Formally, we not only \nextended the con\u00adstraint language but also the expression language, opera\u00adtional semantics, and type \nchecking rules. Therefore, the soundness results of the previous section are not imme\u00addiately applicable \nto FXG+primitives. But they are easily generalized because the proof structures are unchanged and need \nonly be extended to the new rules. Principal types and progress hold unconditionally. Subject reduction \ndepends on the function abstractions, which must be such that: h(e) . h(e 1) . G f e : S,e 1 : T . G,x \n: S,y : T,h(y) f h(x) h(v) evaluates to l . self == l f h(v) Intuitively, abstractions must be such that \nthey retain or increase precision with each execution step. Structural subtyping constraints. We add \nthe constraint T0 hasm(x : T){c} : R which states that type T0 has a method available with the given \nsignature. We extend the type checking rules in Figure 12. Ambiguous lookup di\u00adrectly accounts for structural \nsubtyping constraints by rule H-STRUCT. A class type C with method signature C.m(x : T){c}: R satis.es \nthe constraint C has m(x : T){c}: R by rule X-STRUCT. By attaching the method signatures to Object, we \nensure actual method declarations have precedence over ones known to exist by means of structural constraints. \nA side-effect of our formalization is that by combining rules H-STRUCT and X-STRUCT every method signature \nof the program also ends up being attached to Object. But this is .ne since this virtual method is only \nvisible for types below the class of declaration of the method so that the vir\u00adtual method is always \ngoing to be overridden by the actual method declaration. We can prove that soundness is preserved with \nthis ex\u00adtension by simply updating the proof that run-time dispatch always returns a method compatible \nwith the method signa\u00adture selected during type checking. The rest of the soundness proof is unchanged. \nMethodology. With these two extensions, one can get a feel for how to extend FXG with more constraints. \nOn the one hand, richer value-dependency is obtained with the ad\u00addition of matching type-checking rules \nand run-time steps.  (Type) T0 ::= R f l :Rng(l){self == l} (T-LIT) (Expression) e ::= h(e) | l (Constraint \nterm) t ::= l G f e :T,T <: Dom(h) (Value constraint) c0 ::= q(t) (T-FUN) (Value) v ::= l G f h(e):.x \n: T. Rng(h){h(x)} ei . e1 h(v) evaluates to l i (RC-FUN)(R-FUN) 1 h(v1,...,vi-1, ei,..., en) . h(v1,...,vi-1,ei,...,en) \nh(v) . l Figure 11. FXG+primitive types. G f T0 hasm(x :T){c}:R (H-STRUCT) G f T0 .m =. Object.m(x \n:T){c}:R class C(f : T){c} extends C1{ M } def m(x : T1){c1}: R = e . M G f T0 <:C (X-STRUCT) G f T0 \nhasm(x :T1){c1}:R Figure 12. FXG+structural subtyping constraints. Because these are tightly coupled, \nsubject reduction and progress proofs just need to be extended with new cases, with the bulk of the proof \nunchanged. On the other hand, richer type-dependency is obtained with the addition of sub\u00adtyping rules \nand lookup rules. There, we must ensure that run-time dispatch is faithful to compile-time lookup of \n.eld and method signatures. 5. Towards a Practical Language In this section, we discuss how the FXG formal \nsystem can be realized in a practical programming language. The choice of type variables and constraint \nsystem and other design fac\u00adtors affect the ease of use and ease of implementation of the resulting language. \nWe outline the design and implementa\u00adtion choices made by X10, focusing on how FXG forms the core semantics \nof the language. 5.1 Type Variables The .rst version of X10 did not support generic types. In extending \nthe language, the .rst question to consider is the choice of type variables. Most object-oriented languages \nprovide genericity by introducing type parameters on classes and methods. The development of a nominal \nOO type sys\u00adtem with type parameters is now standard (cf. FGJ [20]). An alternative approach is to use \ntype members, type-valued attributes of classes or objects. Virtual types in BETA [27] are an example \nof this approach, as are FXG s type-valued .elds. Type members may be either statically bound to con\u00adcrete \ntypes or dynamically bound at object creation time. Scala [38] supports both type parameters and type \nmembers. Type parameters. Type parameters can be encoded as im\u00admutable type-valued .elds in FXG. Unlike \npositional param\u00adeters, type .elds can be referred to outside their class body in constraints and in \nsubclasses, for instance. Consequently, the encoding should rename type parameters to avoid name shadowing \nand ambiguity problems. In the following, we simply assume type .elds are named to avoid con.icts. An \nan example, the Java class class List<T> { void add(T x) { ... } void addAll(List<T> xs) { ... } T get(int \ni) { ... } } can be encoded as the following FXG class: class List(T: Type) extends Object { def add(x: \nT) ... def addAll(xs: List{self.T==this.T}) ... def get(i: Int): T = ... } Instantiation of parameters \nis encoded as an equality con\u00adstraint. A use of the type List<C> is encoded as the FXG type List{T==C}. \nParameter bounds can be encoded as subtyping con\u00adstraints in either constrained kinds or in the class \ninvariant. For example, the Java class class Folder<T extends Foldable> { ... } can be encoded as either \nof the following FXG classes: class Folder(T: Type{self <: Foldable}) { ... } class Folder(T: Type) {T \n<: Foldable} { ... } A key issue with parametrized types affecting the expres\u00adsiveness and usability \nof the language is variance: that is, what is the subtyping relationship between C<S> and C<T>? At present, \ntype parameters in X10 are invariant that is, C<S> and C<T> are subtypes only if S and T are equal. Out\u00adlined \nbelow are several options for supporting variance in X10, building on the FXG formalism.  It is often \nexpected that, for example, List<Int> is a subtype of List<Number> when Int is a subtype of Number. This \ncovariance, however, is unsound if List<T> has methods that take T as an argument. As an example, if \nthe T parameter of the List class above were covariant, then the following code would compile. List<Number> \nnums = new List<Number>(); nums.add(new Float(2.718f)); // safe List<Number> ints = new List<Int>(); \nints.add(new Float(1.414f)); // unsafe ints.addAll(nums); // unsafe Calling nums.add with a Float is \nsafe since Float is a subtype of Number; however, calling ints.add with a Float is unsafe and can lead \nto a dynamic type error. Adding all elements of nums to ints will similarly fail. A sound type system \nshould reject the above code. Speci.cation of variance can be done either at the use site or at the de.nition \nsite. Java pioneered use-site variance through the use of wildcard types [46]. Scala and Cq support de.nition-site \nvariance annotations. In use-site variance, the user of the generic type de\u00adcides the variance of the \ntype s parameters. In Java, vari\u00adance is speci.ed using bounded wildcard types. The type List<? extends \nNumber> represents a list of some .xed, but statically unknown, element type that must be a sub\u00adtype \nof Number. Both List<Int> and List<Number> are subtypes of this type. In contrast, there is no subtyping \nrelationship between the invariant types List<Int> and List<Number>. FXG can support use-site variance \nthrough subtyping constraints. The encoding of type parameters described above can be extended to handle \nwildcard types. For the above List class, the following correspondences hold: Java FXG List<?> List{true} \nList<? extends C> List{T<:C} List<? super C> List{T:>C} Covariance relies on the result that if B is \na subtype of A, then List{T<:B} is a subtype of List{T<:A}. However, like wildcard types [26], this encoding \nof covariance can hurt usability. Because programmers must make variance decisions for each use of a \ngeneric type, they must anticipate how that object will be used. In particular, if a type has a covariant \nconstraint on a type variable, then methods that take that type variable as an argument cannot normally \nbe called. For instance in the code below, the call to add is illegal: val nums: List{T<:Number} = ... \nnums.add(new Int(1)); // illegal The problem is that nums.T is statically unknown. The com\u00adpiler cannot \ndetermine if Int is a subtype of nums.T. Pre\u00adventing the call ensures a dynamic type error does not occur. \nSince calls to methods like add that accept covariantly con\u00adstrained parameters are illegal, objects \nwith covariant type constraints can be rendered effectively read-only. The other common approach to variance, \nde.nition-site variance, is used in Scala and Cq. In a class declaration, a pa\u00adrameter may be declared \nin-, co-, or contravariant. Following Kennedy and Pierce [23], variant parameters can be encoded in FXG \nusing subtyping constraints at their use. All uses of Cons[A] are translated to Cons{T<:A}. If B is a \nsubtype of A, then this encoding ensures the translation of Cons[B] is a subtype of the translation of \nCons[A] that is, Cons{T<:B} is a subtype of Cons{T<:A}. If T were an invariant param\u00adeter, the encoding \nof Cons[A] would be Cons{T==A}. For example, consider the following Scala declaration of a Cons cell \nwith covariant parameter T. class Cons[+T] { def head: T = ... def tail: Cons[T] = ... } This can be \nencoded in FXG as the class: class Cons(T: Type) extends Object { def head: this.T = ... def tail: Cons{self.T<:this.T} \n= ... } To ensure type soundness in languages with de.nition\u00adsite variance, the use of variant parameter \ntypes in methods and .elds must be restricted in the body of their class. The compiler checks that covariant \ntype parameters do not occur in negative positions that is, as method arguments and that contravariant \ntype parameters do not occur in positive positions as method return types. These structural checks are \nneeded to guarantee soundness, avoiding the dynamic type errors described above. In supporting de.nition-site \nvariance, Scala does not permit, for example, an equivalent of the Java List<T> class above to be covariant \nin T. If T were covariant, then methods like add, which take a T as an argument would be prohibited. \nIn the FXG encoding of de.nition-site variance as use-site constraints, these checks need not be performed, \nas long as the output of the encoding type-checks. The resulting FXG would not be able to invoke methods \nlike add that lead to dynamic type errors. Type members Rather than supporting genericity through type \nparameters, genericity could instead be provided with type members. Thorup [44] proposed using virtual \ntypes [14, 27, 28] to add genericity to Java. For example, a generic List class can be written as follows: \nabstract class List { abstract typedef T; T get(int i) { ... } }  The virtual type T is unbound in List, \nbut can be re.ned by binding T in a subclass: class IntList extends List { final typedef T as Int; } \nClasses like List where the virtual type is not .nal bound to a concrete type must be abstract. Virtual \ntypes, too, can be encoded as type-valued .elds in FXG, similarly to how wildcards are encoded. In FXG, \nthe analogous de.nition of the List class above is: class List(T: Type) extends Object { def get(i: int): \nT { ... } } Bounds on virtual types can be encoded in the class invari\u00adant. For example, the subclass \nIntLit can constrain T to be equal to Int as follows: class IntLit(){T==Int} extends List { } However, \nunlike with virtual types. the FXG version of List need not be abstract; rather, T must be bound to a \ncon\u00adcrete type when an instance of List is created. Since im\u00admutable .elds can be constrained where their \nclass type is used (e.g., List{T<:Number} and List{T==Int}) a sub\u00adclass of List need not be declared \nat all. Since .elds are inherited, the language design needs to account for ambiguities introduced when \nthe same name is used for different .elds declared in or inherited into a class. In FXG, a subclass cannot \ndeclare a .eld with the same name as one in a superclass; in a practical programming language, shadowing \nof .eld names could be allowed. Name con.icts can be disambiguated by casting the target to the desired \nsupertype, e.g., (e as C).X speci.es the .eld X inherited from C. Because of these name ambiguity issues \nand because type parameters are more familiar to OO programmers, X10 chose to support type parameters \nrather than type members. Currently, type parameters in X10 are invariant. It is planned to extend the \nlanguage with support for de.nition-site vari\u00adance, basing the design on the FXG formalism, as outlined \nabove.  5.2 Constraint System The second design question is the choice of constraint sys\u00adtem. Natural \ncandidates are constraint systems that incor\u00adporate subtyping constraints or structural constraints on \nob\u00adjects. Subtyping constraints. The subtyping constraints in FXG can be incorporated into a full-.edged \nprogramming lan\u00adguage like X10. For a type variable X one asserts the con\u00adstraint X<:T. This constraint \nis realized by any valuation that maps X to a subtype of T. Constraints on types can specify either subtype \n(<:), supertype (:>), or equality bounds (==). As described in the previous section, subtyping con\u00adstraints \nin the class invariant provide a means to bound the type variables introduced by the class declaration. \nCon\u00adstraints in constrained types C{c} can bound immutable type .elds of the base type C. Subtyping constraints \nin method guards can bound type parameters of the method or bound type .elds of the method s class. This \nfeature is similar to optional methods in CLU [25] and to generalized type con\u00adstraints in Cq [13]. For \ninstance, given a list of T, one could de.ne a method print with a guard that requires that T be a subtype \nof Printable: def print(){T <: Printable} { head.print(); tail.print(); } This constraint ensures that \nthe head .eld of type T has a print() method. Structural constraints. Rather than imposing nominal bounds \non type variables, one can instead require that a type have a particular member a .eld with a given name \nand type, or a method with a given name and signature. We in\u00adtroduce the constraints T has f:T and T \nhas m(x :S):T to express this. These constraints allow one to de.ne an alter\u00adnative version of the guarded \nprint method above: def print(){T has print(): Void} { head.print(); tail.print(); } With structural \nconstraints, any list whose element type has a print method may be used, not just lists whose elements \nimplement Printable. Structural constraints on types are found in many lan\u00adguages. For instance, Haskell \nsupports type classes [19, 22]. In Modula-3, type equivalence is structural rather than nom\u00adinal as in \nobject-oriented languages of the C family (e.g., C++, Java, and X10). Unity [30] is a Java-like language \nwith both nominal and structural subtyping. Scala provides struc\u00adtural types as well. In the class invariant, \na structural constraint can bound the class s type variables, similar to the language PolyJ [35], which \nallows type parameters to be bounded using structural where clauses [10]. Because structural types are \nnot supported directly on the Java virtual machine, implementing them on languages that target the JVM \nis non-trivial and can result in a performance penalty [11]. Structural constraints are not currently \nsup\u00adported in X10, but are under consideration. Default values. In languages like Java with primitive \ntypes, every type has a default value null for reference types, false or 0 for primitive types. With \nconstrained types, some types do not have an obvious default value. For example, the type C{self!=null} \ndoes not contain the value null.  Thus, a useful extension to the type system is to add constraints \nof the form T haszero. This constraint holds if the type T has a default value. Variables where the constraint \ndoes not hold must be explicitly initialized. X10 supports default-value constraints in method guards. \nThey are used primarily to enable construction of arrays of primitives or structs without providing an \ninitial value for each array element. The default values are all represented by a 0 bit pattern, and \narray construction is implemented by requesting a zeroed out memory buffer.  5.3 Overloading and Dispatch \nThe next question to address is the overloading semantics for methods with constraints on formal parameters \nand with method guards. One option is to ignore constraints when checking for overloading. Thus, these \nthree methods: def m(List{T==Int,length==0}) = ... def m(List{T==Int,length==n}) = ... def m(List{T==Float,length==n}) \n= ... are considered to have the same signature. It is a static error if more than one of these methods \nappears in the same class. Alternatively, the overloading could be allowed, with methods resolved at \ncompile-time using the constraint solver. It is an error if a call could resolve to more than one method. \nOne question is whether to rule out overlapping methods (e.g., m(Int{self>=0}) and m(Int{self==1})), \nor to permit them and have the caller resolve any ambiguities. Going further, one could support a form \nof predicate dispatch [33], selecting the method to invoke by dynamically evaluating the constraints \nin the method signature and the method guard. With type constraints, multimethod dispatch could then \nbe implemented as an extension of predicate dispatch. X10 takes a conservative approach and does not \nallow overloading based on constraints or method guards. 5.4 Run-time Casts While constraints are normally \nsolved at compile time, con\u00adstraints can be evaluated at run time by using casts. The ex\u00adpression xs \nas List{length==n} checks not only that xs is an instance of the List class, but also that xs.length \nequals n. An exception is thrown if the check fails. The information needed to perform checked casts \nmust be available at run time. Java s approach to generics implemen\u00adtation is to erase type parameters \nand to allow these casts with a static warning, but no dynamic check. Erasure admits more dynamic errors \nbecause it permits, for instance, a C<A> to be cast to C<B>. Retrieving a .eld of static type B could \ncause a run-time type error when an A is returned instead. Unlike Java, X10 does not erase type parameters \nat run time. Instead, each instance of a generic type contains a description of the types that its parameters \nare instantiated upon. This extra run-time type information enables checked casts to generic types. In \nthe above example, the test of the constraint does not require run-time constraint solving; the constraint \ncan be checked by simply evaluating the length .eld of xs and comparing against n. However, the situation \nis more complicated when casting to a generic type. Similarly, the cast xs as List{T<:C{c}} checks that \nthe element type of xs is a subtype of C{c}. This test requires a run-time constraint entailment test. \nSuppose xs were de\u00adclared to be a List{T==C{d}}. Checking the above cast re\u00adquires testing that C{d} \nis a subtype of C{c}. This check, in turn, requires checking that d entails c. One approach is to restrict \nthe language to rule out casts to type parameters and to generic types with subtyping con\u00adstraints, ensuring \nthat entailment checks are not needed at run time. Alternatively, the constraint solver could be em\u00adbedded \ninto the runtime system. However, this solution can result in inef.cient run-time casts if entailment \nchecking for the given constraint system is expensive. The X10 implementation makes a compromise. Run-time \ntype information is preserved, but constraints are not. 5.5 Static vs. Dynamic Checking Checking constraints \nstatically rather than at run time en\u00adables early error detection and allows the compiler to gener\u00adate \nbetter code. However, during development, ensuring con\u00adstraints hold at each compile can slow progress. \nThese trade\u00adoffs are similar to the tradeoffs between static and dynamic typing. The X10 compiler supports \ntwo modes. In one mode, the compiler will reject programs when a constraint entail\u00adment cannot be proved; \nin another mode, similar to Flana\u00adgan s hybrid typing [15], the compiler emits dynamic checks for these \nentailments. Dynamic checks need to be performed to check class invariants when new objects are created, \nto check method guards, and to check assignments from sub\u00adtypes to supertypes if the solver cannot determine \nthat the assignment is allowed. Emitting dynamic checks can also permit a more expressive constraint \nlanguage, allowing pro\u00adgrammers to write constraints that cannot (yet) be handled by the embedded solver. \n 5.6 Inconsistent Constraints The soundness of the type system ensures that constraints cannot be violated \nat run time. If a class invariant or a con\u00adstraint on a type is inconsistent, then no values of that \ntype can exist at run time. Similarly, if a method guard is incon\u00adsistent, that method cannot be called. \nAny code dependent on an inconsistent guard is unreachable. For subject reduction to hold, the formal \nsystem assumes that subtyping constraints are not inconsistent; however, other constraints may be. The \ncompiler can therefore al\u00adlow inconsistent constraints. For developers, it is useful for the compiler \nto report whether a constraint is inconsistent. However, this requires the constraint system to be complete. \nHence, the X10 compiler is more strict about type constraints than about value constraints. The compiler \nenforces consis\u00adtency of constraints on types, but not constraints on values. In practice, this means \nthe X10 compiler accepts the follow\u00ading method, even though it can never be invoked:  def m(x: Int){x==0, \nx==1} ... But it rejects the analogous method with type parameters rather than value parameters: def \np(X: Type){X==C, X==D} ... where C and D are classes.  5.7 Mutable State Objects in FXG contain only \nimmutable value and type .elds. X10, additionally, supports mutable and immutable instance .elds. Constraints \ncontinue to be invariants on only the immutable state of objects (including types). Allowing constraints \non mutable data would not be sound since a con\u00adstraint that holds at one point in the program might not \nhold at another. One subtlety is ensuring that class invariants are estab\u00adlished correctly. When a constructor \nexecutes, .elds of the receiver are initialized one-by-one, which can potentially al\u00adlow the object being \nconstructed to be accessed before the class invariant is established for the object. To address this, \nX10 distinguishes between .elds and properties. Properties are immutable (.nal) .elds of the object. \nUnlike normal .elds, X10 requires that all properties of the object be initial\u00adized instantaneously. \nThis provides a single program point a property statement at which the compiler can check if the class \ninvariant holds. Before this point, the properties of the object cannot be accessed; after this point, \nthe class in\u00advariant is established. Unlike properties, .nal .elds need not be initialized all at once. \nAs in Java, .nal .elds can be initialized at any point during constructor execution. However, .elds cannot \nbe used in constraints. 6. Related Work Constraint-based type systems, dependent types, and generic types \nhave been well studied in the literature. Further discus\u00adsion of related work for constrained types can \nbe found in our earlier work [37]. Constraint-based type systems. The use of type con\u00adstraints for type \ninference and subtyping was .rst pro\u00adposed by Mitchell [34] and Reynolds [39]. HM(X) [41] is a constraint-based \nframework for Hindley Milner-style type systems. The framework is parametrized on the speci.c constraint \nsystem X; instantiating X yields extensions of the HM type system. Constraints in HM(X) are over types, \nnot values. The HM(X) approach is an important precursor to our constrained types approach. The principal \ndifference is that HM(X) applies to functional languages and does not integrate dependent types. We consider \nobject-oriented lan\u00adguages with constraint-based type systems when we discuss generic types, below. Dependent \ntypes. Dependent type systems [3, 32, 49] parametrize types on values. Our work is closely related to \nDependent ML (DML [49]), which is also built paramet\u00adrically on a constraint solver. The main distinction \nbetween DML and constrained types lies in the target domain: DML is a functional programming language; \nconstrained types are designed for imperative, concurrent object-oriented lan\u00adguages. Types in DML are \nre.nement types [16]: they do not affect the operational semantics, and erasing the constraints yields \na legal DML program. This differs from generic con\u00adstrained types, where erasure of subtyping constraints \ncan prevent the program from type-checking. DML does not permit any run-time checking of constraints \n(dynamic casts). Another distinction between DML and constrained types is that constraints in DML are \nde.ned over a set of index variables; in X10, constraints are de.ned over program vari\u00adables and types. \nLiquid types [40], permit types in a base Hindley Milner\u00adstyle type system to be re.ned with conjunctions \nof logical quali.ers. The subtyping relation is similar to X10 s; that is, two liquid types are in the \nsubtyping relation if their base types are in the relation and if one type s quali.er implies the other \ns. Liquid types support type inference and the type system is path sensitive; neither is the case in \nX10. Liquid types do not provide subtyping constraints. Bierman et al. [4] propose a functional language \nwith re.nement types. Rather than use the constraint solver as a subroutine for subtyping checks, type-checking \nis performed by an SMT solver by translating types into logical formulas. The language supports a richer \nset of predicates on values than X10, but this is in large part orthogonal to the rest of the language \ndesign. Their language does not include constraints on types. K\u00a8oksal et al. [24] takes another approach \nto integrating constraints with the type system. Logical variables are added to Scala, and an SMT solver \nis used to solve constraints. Like Bierman et al. [4], any pure function can be used in a constraint. \nGenericity. Genericity in object-oriented languages is usu\u00adally supported through type parametrization. \nA number of proposals for adding genericity to Java quickly followed the initial release of the language \n[1, 5, 35, 44]. GJ [5] implements invariant type parameters via type erasure. Java 5 [18] adopted the \nsame implementation approach, incorporating wildcards and raw types [46]. Other proposals [8, 35, 47, \n48] support run-time representation of type parameters. PolyJ [35] permits instantiation of param\u00adeters \non primitive types and structural parameter bounds. MixGen [1] supported mixins through type parametrization. \nVariance in Java is handled at the use-site using wild\u00adcards [7, 46]. Scala [38] and Cq [12], by contrast, \nsupport de.nition-site variance annotations, which address many of the usability concerns of wildcards \n[26], but can often re\u00adsult in complicated or duplicated code to create invariant, covariant, and contravariant \nversions of a library class. Alti\u00addor et al. [2] propose a framework for combining de.nition\u00adand use-site \nvariance in a Java-like language. Encoding this framework in FXG is an interesting area for future work. \n Summers and Cameron et al. [6, 43] characterized wild\u00adcards in terms of existential types. Our encoding \nof wild\u00adcards in FXG similarly uses existentials, over constraint terms rather than types, however. Summers \net al. [42, 43] ob\u00adserve that care must be taken to model assignment to avoid an unsoundness. We leave \nthis extension for future work. Virtual classes and virtual types [14, 27, 28] are another mechanism \nfor supporting genericity, using nested types rather than parametrization. As discussed in Section 5.1, \nThorup [44] proposed using virtual types to provide gener\u00adicity in Java. Much of the development of Java \ns gener\u00adics followed from virtual classes: use-site variance based on structural virtual types was proposed \nby Thorup and Torgersen [45] and extended for parametrized type systems by Igarashi and Viroli [21]; \nthe latter type system lead to the development of wildcards in Java [7, 46]. Dependent classes [17] generalize \nvirtual classes to express similar semantics via parametrization rather than nesting. With type properties, \nclasses are not parametrized on their val\u00adues; rather properties are members and types are constructed \nby constraining these properties. Parametrization can be en\u00adcoded with type properties using equality \nconstraints. 7. Conclusions We have presented a constraint-based framework FXG for type-and value-dependent \ntypes in an object-oriented lan\u00adguage. The use of constraints on type properties provides a framework \nfor capturing many features of generics in object\u00adoriented languages and then extending these features \nwith more expressive power. We have proved the type system sound. The type system of FXG formalizes the \nsemantics of the X10 programming language. The design admits an ef.cient implementation for generics \nand dependent types in X10, available at x10-lang.org. To improve the expressiveness of X10, we plan \nto implement a type inference algorithm that infers constraints over types and values, and to support \nuser-de.ned constraints. Acknowledgments This material is based upon work supported in part by the Defense \nAdvanced Research Projects Agency under its Agreement No. HR0011-07-9-0002. References [1] Eric Allen, \nJonathan Bannet, and Robert Cartwright. A .rst\u00adclass approach to genericity. In Proc. OOPSLA 03, pages \n96 114, October 2003. [2] John Altidor, Shan Shan Huang, and Yannis Smaragdakis. Taming the wildcards: \nCombining de.nition-and use-site variance. In Proc. 2011 ACM SIGPLAN Conf. on Program\u00adming Language Design \nand Implementation (PLDI), June 2011. [3] Lennart Augustsson. Cayenne: a language with dependent types. \nIn ACM SIGPLAN International Conf. on Functional Programming (ICFP 98), pages 239 250, 1998. [4] Gavin \nM. Bierman, Andrew D. Gordon, C.at.alin Hrit\u00b8cu, and David Langworthy. Semantic subtyping with an SMT \nsolver. The Journal of Functional Programming, 22(1):31 105, March 2012. [5] Gilad Bracha, Martin Odersky, \nDavid Stoutamire, and Philip Wadler. Making the future safe for the past: Adding Generic\u00adity to the Java \nPrograming Language. In Proc. OOPSLA 98, 1998. [6] Nicholas Cameron and Sophia Drossopoulou. On subtyping, \nwildcards, and existential types. In Formal Techniques for Java-Like Programs (FTfJP), July 2009. [7] \nNicholas Cameron, Sophia Drossopoulou, and Erik Ernst. A model for Java with wildcards. In Proc. ECOOP \n08, number 5142 in Lecture Notes in Computer Science, pages 2 26, July 2008. [8] Robert Cartwright and \nGuy L. Steele. Compatible genericity with run-time types for the Java programming language. In Proc. \nOOPSLA 98, Vancouver, Canada, October 1998. [9] Thierry Coquand and Gerard Huet. The Calculus of Construc\u00adtions. \nInformation and Computation, 76, 1988. [10] Mark Day, Robert Gruber, Barbara Liskov, and Andrew C. Myers. \nSubtypes vs. Where Clauses: Constraining Parametric Polymorphism. In Proc. OOPSLA 95, pages 156 168, \nAustin TX, October 1995. ACM SIGPLAN Notices 30(10). [11] Gilles Dubochet and Martin Odersky. Compiling \nstructural types on the JVM: a comparison of re.ective and generative techniques from Scala s perspective. \nIn ICOOOLPS 09, pages 34 41, 2009. [12] ECMA. ECMA-334: C# language speci.cation, June 2006. http://www.ecma-international.org/publications/.les/ecma\u00adst/ECMA-334.pdf. \n[13] Burak Emir, Andrew Kennedy, Claudio Russo, and Dachuan Yu. Variance and generalized constraints \nfor Cq generics. In Proc. ECOOP 06, 2006. [14] Erik Ernst, Klaus Ostermann, and William R. Cook. A virtual \nclass calculus. In 33th ACM Symp. on Principles of Program\u00adming Languages (POPL), pages 270 282, Charleston, \nSouth Carolina, January 2006. [15] Cormac Flanagan. Hybrid type checking. In 33rd An\u00adnual Symposium on \nPrinciples of Programming Languages (POPL 06), pages 245 256, 2006. [16] Tim Freeman and Frank Pfenning. \nRe.nement types for ML. In Proc. 1991 ACM SIGPLAN Conf. on Programming Language Design and Implementation \n(PLDI), pages 268 277, June 1991. [17] Vaidas Gasiunas, Mira Mezini, and Klaus Ostermann. Depen\u00addent \nclasses. In Proc. OOPSLA 07, pages 133 152, 2007. [18] J. Gosling, W. Joy, G. Steele, and G. Bracha. \nThe Java Lan\u00adguage Speci.cation, Third Edition. Addison Wesley, 2006.  [19] Cordelia V. Hall, Kevin \nHammond, Simon L. Peyton Jones, and Philip L. Wadler. Type classes in Haskell. ACM Trans\u00adactions on Programming \nLanguages and Systems (TOPLAS), 18(2):109 138, 1996. [20] Atsushi Igarashi, Benjamin Pierce, and Philip \nWadler. Feath\u00aderweight Java: A minimal core calculus for Java and GJ. ACM Transactions on Programming \nLanguages and Systems (TOPLAS), 23(3):396 450, 2001. [21] Atsushi Igarashi and Mirko Viroli. Variant \nparametric types: A .exible subtyping scheme for generics. ACM Transac\u00adtions on Programming Languages \nand Systems (TOPLAS), 28(5):795 847, 2006. [22] Haskell 98: A non-strict, purely functional language. \nhttp://www.haskell.org/onlinereport/, February 1999. [23] Andrew Kennedy and Benjamin Pierce. On decidability \nof nominal subtyping with variance. In Foundations of Object-Oriented Languages (FOOL), 2007. [24] Ali \nSinan K\u00a8Con\u00adoksal, Viktor Kuncak, and Philippe Suter. straints as control. In 39th ACM Symp. on Principles \nof Pro\u00adgramming Languages (POPL), pages 151 164, January 2012. [25] Barbara Liskov et al. CLU Reference \nManual. Springer-Verlag, 1984. [26] Howard Lovatt. Simply.ng Java generics by eliminating wildcards, \nJanuary 2008. Retrieved March 22, 2009. [27] O. Lehrmann Madsen, B. M\u00f8ller-Pedersen, and K. Nygaard. \nObject Oriented Programming in the BETA Programming Language. Addison-Wesley, June 1993. [28] Ole Lehrmann \nMadsen and Birger M\u00f8ller-Pedersen. Virtual classes: A powerful mechanism for object-oriented program\u00adming. \nIn Proc. OOPSLA 89, pages 397 406, October 1989. [29] Michael J. Maher. Complete axiomatizations of the \nalgebras of .nite, rational and in.nite trees. In Third Annual Sympo\u00adsium on Logic in Computer Science, \n1988. [30] Donna Malayeri and Jonathan Aldrich. Integrating nominal and structural subtyping. In Proc. \nECOOP 08, number 5142 in Lecture Notes in Computer Science, July 2008. [31] Per Martin-L\u00a8of. A Theory \nof Types. 1971. [32] Conor McBride and James McKinna. The view from the left. Journal of Functional Programming, \n14(1):69 111, 2004. [33] Todd Millstein. Practical predicate dispatch. In Proc. OOP-SLA 04, October 2004. \n[34] John C. Mitchell. Coercion and type inference. In 11th Annual ACM Symposium on Principles of Programming \nLanguages (POPL 84), pages 174 185, 1984. [35] Andrew C. Myers, Joseph A. Bank, and Barbara Liskov. Pa\u00adrameterized \ntypes for Java. In 24th ACM Symp. on Principles of Programming Languages (POPL), pages 132 145, Paris, \nFrance, January 1997. [36] Karl A. Nyberg, editor. The annotated Ada reference manual. Grebyn Corporation, \nVienna, VA, USA, 1989. [37] Nathaniel Nystrom, Vijay Saraswat, Jens Palsberg, and Chris\u00adtian Grothoff. \nConstrained types for object-oriented lan\u00adguages. In Proc. OOPSLA 08, October 2008. [38] Martin Odersky. \nReport on the programming language Scala. Technical report, EPFL, 2006. [39] John C. Reynolds. Three \napproaches to type structure. In TAP-SOFT/CAAP 1985, volume 185 of Lecture Notes in Computer Science, \npages 97 138. Springer-Verlag, 1985. [40] Patrick Rondon, Ming Kawaguchi, and Ranjit Jhala. Liquid types. \nIn Proc. 2008 ACM SIGPLAN Conf. on Programming Language Design and Implementation (PLDI), June 2008. \n[41] Martin Sulzmann, Martin Odersky, and Martin Wehr. Type inference with constrained types. In Fourth \nInternational Workshop on Foundations of Object-Oriented Programming (FOOL 4), 1997. [42] Alexander J. \nSummers. Modelling Java requires state. In For\u00admal Techniques for Java-Like Programs (FTfJP), July 2009. \n[43] Alexander J. Summers, Nicholas Cameron, Mariangiola Dezani-Ciancaglini, and Sophia Drossopoulou. \nTowards a se\u00admantic model for java wildcards. In Formal Techniques for Java-Like Programs (FTfJP), June \n2010. [44] Kresten Krab Thorup. Genericity in Java with virtual types. In Proc. ECOOP 97, number 1241 \nin Lecture Notes in Com\u00adputer Science, pages 444 471, 1997. [45] Kresten Krab Thorup and Mads Torgersen. \nUnifying gener\u00adicity: Combining virtual types and parameterized classes. In Proc. ECOOP 98, 1998. [46] \nMads Torgersen, Christian Plesner Hansen, Erik Ernst, Peter von der Ah\u00b4e, Gilad Bracha, and Neal Gafter. \nAdding wild\u00adcards to the Java programming language. In SAC, March 2004. [47] Mirko Viroli. A type-passing \napproach for the implementa\u00adtion of parametric methods in Java. The Computer Journal, 46(3):263 294, \n2003. [48] Mirko Viroli and Antonio Natali. Parametric polymorphism in Java: an approach to translation \nbased on re.ective features. In Proc. OOPSLA 00, pages 146 165, 2000. [49] Hongwei Xi and Frank Pfenning. \nDependent types in practical programming. In 26th Annual ACM Symposium on Principles of Programming Languages \n(POPL 99), pages 214 227, San Antonio, TX, January 1999. A. Proof Sketch We assume well-formedness and \nnon-inconsistent environ\u00adments. Lemma A.1. If G f T.i -. I and G f T.i -. I1 then I = I1 . Proof. By \nH-AMB I \u00ab I1 and I1\u00ab I. If I is a .eld signature then by O-REFL I = I1. If I is a method signature then \nI1 must be a method signature. Let C be the class of I and C1 be the class of I1. Suppose C is not C1 \nthen by O-METHOD C <: C1 and C1 <: C. Contradiction. C has at most one method named m, therefore I = \nI1 in all cases. Theorem A.2 (Principal Types). If G f e : S and G f e : T then S = T.  Proof. By induction \non the structure of e. There is exactly one typing rule for each kind of expression. Moreover, by Lemma \nA.1, each .eld name or method name may resolve to at most one signature on a given type. Therefore, there \nis only one way the T-FIELD and T-INVK rules can be used to type a .eld selection or a method invocation. \nTheorem A.3 (Progress). If f e : T then one of the following conditions holds: 1. e is a value, 2. e \nhas a stuck cast sub-expression of the form v as T0, 3. there exists e1 such that e . e1 .  Proof. \nBy induction on the structure of the expression. As\u00adsume e contains no stuck cast sub-expression of the \nform v as T0 and is not a value. If e is a.f. If a is a value then e can make a step by rule R-FIELD. \n1 Otherwise, by the induction hypothesis, a . athen e can make a step by rule RC-FIELD. If e is a.m(b). \nIf a,b are values then e can make a step by rule R-INVK. Otherwise, if a is not a value then by the induction \nhypothesis a . a1 and e can make a step by rule RC-INVK-RECV. Otherwise, if bi is not a value then by \nthe induction hypothesis bi . b1 i and e can make a step by rule RC-INVK-ARG.  If e is new C(a) Since \nai is not a value for some i then e can make a step by rule RC-NEW-ARG.  If e is a as T0. If a is not \na value then a is well typed by T-CAST, hence can make a step by the induction hypothesis, thus e can \nmake a step by rule RC-CAST. Otherwise, if a is a value then e can make a step by rule R-CAST since e \ncontains no stuck cast sub-expression.  T.i -. I then there exists I1 such that G f S.i -. I1 and I1\u00ab \nI. Proof. Let C be the class of I. By H-SUB, G f S.i =. I. By de.nition of ambiguous lookup, G f T <: \nC. By S-TRANS, G f S <: C. Let I1 be such that G f S.i =. I1 and C1 the class of I1. By de.nition of \nambiguous lookup, G f S <: C1. Because G is consistent, all such C1 are related via inheritance. Let \nC11 be the maximum of this set of classes and I11 the corresponding signature. By OK-METHOD, I11 \u00ab I1 \nfor all I1 including I11 \u00ab I. By H-AMB, G f S.i -. I11 . Lemma A.5. If method(C,m)= m(f : F){c} : M = \ne then G f C.m -. C1 .m(f : F){c} : M for C1 a superclass of C or C. Proof. Since G is consistent the \nonly class types that C is a subtype of are C and the superclasses of C. Let C1 be C if C declares m \nor its lowest superclass that declared m. By rule OK-METHOD C1 .m overrides all the methods m de.ned \nin these classes. Therefore, G f C.m -. C1 .m(f : F){c} : M. The following lemmas permit replacing one \ntype by a subtype in various contexts. Lemma A.6. If G,x : X f e : T and G f e1 : Y and G, x : Y f x \n:: X then there exists S such that G f e[e1/x] : S and G,y : S f y :: .x : Y.T. Lemma A.7. If G,x : T \nf c and G, x : S f x :: T then G,x : S f c. Lemma A.8. If G,y : S f y :: T then G, x : .y : S.U f x :: \n.y : T.U. Lemma A.9. If G,y : U,x : S f x :: T then G,x : .y : U.S f x :: .y : U.T. Proof. Straightforward \ninductions. Theorem A.10 (Subject Reduction). If P is well typed and G f e : T and e . e1 then there \nexists S such that G f e1 : S. Moreover G,x : S f x :: T. Proof. By induction on the proof of e . e1. \nAssume G f e : T. For simplicity, we omit substitutions from the proof. In other words, we do as if .eld \nlookup, method lookup, and the .elds, method, and inv predicates return artefacts that are already matching \nour choice of fresh variables. 1 e.f . e.f by rule RC-FIELD  e.m(a) . e.m(a) by rule RC-INVK-RECV \n Lemma A.4. If P is well typed and G f S <: T and G f T-FIELD G f e : R G f R.f -. C.f : F G f e.f \n: T where Ind. hyp. T is .r : R.F{self == r.f}G f e1 : R1 and G,x : R1 f x :: R Lemma A.4 G f R1 .f -. \nC.f : F T-FIELD G f e1 .f : S where Lemma A.8 S is .r : R1 .F{self == r.f}G,x : S f x :: T 1 T-INVK \nG f e : R,a : A G f R.m -. C.m(x : X){c} : M G,r : R,x : A f c,x :: X G f e.m(a) : T where T is .r : \nR..x : A.M Ind. hyp. G f e1 : R1 and G,x : R1f x :: R Lemma A.4 G f R1 .m -. C1 .m(x : X){c1} : M1 1 \nG,r : R1 ,x : X,c,y : M1f y :: M 1 G,r : R1 ,x : X,c f c 1 Lemma A.7 G,r : R1 ,x : A f cG,r : R1 ,x : \nA,y : M1f y :: M 1 T-INVK G f e.m(a) : S where S is .r : R1 ..x : A.M1 Lemma A.9 G,y : S f y :: .r : \nR1 ..x : A.M Lemma A.8 G,y : .r : R1 ..x : A.M f y :: T S-TRANS G,y : S f y :: T  v.m(a) . v.m(a1) by \nrule RC-INVK-ARG T-INVK G f v : R,a : A G f R.m -. C.m(x : X){c} : M G,r : R, x : A f c,x :: X G f e.m(a) \n: T where T is .r : R..x : A.M Ind. hyp. G f a1 : A1 and G, x : A1 f x :: A S-TRANS G,x : A1 f x :: X \nLemma A.7 G,r : R, x : A1 f c T-INVK G f v.m(a1) : S where S is .r : R..x : A1 .M Lemma A.8 G,y : S f \ny :: T new C(a) . new C(a 1) by rule RC-NEW-ARG T-NEW G f e : R .elds(C)= f : F G,x : R f x :: F,inv(C) \nG f new C(e) : T where T is .x : R.C{self == new C(x)}Ind. hyp. G f e1 : R1 and G, x : R1f x :: R S-TRANS \nG,x : R1f x :: F Lemma A.7 G,x : R1f inv(C) T-NEW new C(e1) : S where S is .x : R1 .C{self == new C(x)}Lemma \nA.8 G,y : S f y :: T e as T . e1 as T by rule RC-CAST T-CAST G f e as T : T G f e : S Ind. hyp. G f e1 \n: S1 T-CAST G f e1 as T : T S-REFL G,x : T f x :: T new C(v) as T . new C(v) by rule R-CAST T-CAST f \nnew C(v) : S T-NEW f v : R where S is .x : R.C{self == new C(x)}R-CAST x : S f x :: T  new C(v).fi . \ne1 by rule R-FIELD  T-NEW G f v : V .elds(C)= f : F G,x : V f x :: F G f new C(v) : R where R is .x \n: V.C{self == new C(x)} R-FIELD e1 is vi T-FIELD G f new C(v).fi : T where T is .r : R.Fi{self == r.fi} \nT-VAR G,y : Vi f y : Vi{self == y} let t be new C(v[y/vi]) T-NEW G,y : Vi f t : R1 where R1 is .x : V[Vi{self \n== y}/Vi]. C{self == new C(x)} s(G) f y == t.fi in X X-PROJ G,y : Vi f y == t.fi S-CONST-R G,y : Vi \nf y :: Fi{self == t.fi}S-EXISTS-R G,y : Vi f y :: .r : R1 .Fi{self == r.fi}Lemma A.8 G,y : Vi f y :: \nT new C(v).m(w) . e1 by rule R-INVK R-INVK method(C,m) = m(f : F){c} : M = e e1 is e[new C(v)/this,w/f] \nOK-METHOD r : C,f : F,c f e : E r : C,f : F,c, x : E f x :: M T-NEW G f v : V G f new C(v) : R where \nLemma A.5 T-INVK R is .x : V.C{self == new C(x)}G f C.m -. C1 .m(f : F){c} : M G f new C(v).m(w) : T \nG f w : W G,r : C,f : W f c,f :: F where T is .r : R..f : W.M Lemma A.6 G f e1 : S G,x : S f x :: .r \n: R..f : W.E G,r : R,f : W,x : E f x :: M Lemma A.9 G,x : .r : R..f : W.E f x :: T S-TRANS G,x : S f \nx :: T Theorem A.11 (Type Soundness). If P is well typed f e : T and e reduces to a normal form e1 then \neither e1 contains a stuck cast sub-expression of the form v as T0 or e1 is a value v and there exists \nS such that f v : S. Moreover, in that case,  x : S f x :: T. Proof. Straightforward by Theorems A.3 \nand A.10. Theorem A.12 (Method guards). If P is well typed and G f e.m(a) : T and e .* new C(v) and a \n.* w and method(C, m)= m(f : F){c} : M = e then G f c[new C(v),w/this,f]. Proof. Using subject reduction \nand overriding rules. T-INVK G f e : E,a : A G f E.m -. C.m(f : G){d} : N G,x : E,f : A f d,f :: G Th. \nA.10 G f new C(v) : R,w : W G,x : R f x :: E G,f : W f f :: A T-NEW R is .y : W.C{k}Lemma A.5 G f R.m \n-. C.m(f : F){c} : M Lemma A.4 G f m(f : F){c} : M \u00ab m(f : G){d} : N OK-METHOD G,x : R,f : G,d f c Lemma \nA.7 G,x : R,f : W f c G f c[new C(v),w/this,f] Theorem A.13 (Class invariants). If P is well typed and \nG f new C(e):T and e .* v then G f inv(c)[v/this.f]. Proof. Similar to the proof of Theorem A.12.  \n  \n\t\t\t", "proc_id": "2384616", "abstract": "<p>Modern object-oriented languages such as X10 require a rich framework for types capable of expressing both value-dependency and genericity, and supporting pluggable, domain-specific extensions. In earlier work, we presented a framework for constrained types in object-oriented languages, parametrized by an underlying constraint system. Types are viewed as formulas C{c} where C is the name of a class or an interface and c is a constraint on the immutable instance state (the properties) of C. Constraint systems are a very expressive framework for partial information. Many (value-)dependent type systems for object-oriented languages can be viewed as constrained types.</p> <p>This paper extends the constrained types approach to handle type-dependency (\"genericity\"). The key idea is to introduce constrained kinds: in the same way that constraints on values can be used to define constrained types, constraints on types can define constrained kinds.</p> <p>We develop a core programming language with constrained kinds. Generic types are supported by introducing type variables---literally, variables with \"type\" Type---and permitting programs to impose subtyping and equality constraints on such variables. We formalize the type-checking rules and establish soundness.</p> <p>While the language now intertwines constraints on types and values, its type system remains parametric in the choice of the value constraint system (language and solver). We demonstrate that constrained kinds are expressive and practical and sketch possible extensions with a discussion of the design and implementation of X10.</p>", "authors": [{"name": "Olivier Tardieu", "author_profile_id": "81100366768", "affiliation": "IBM Research, Yorktown Heights, NY, USA", "person_id": "P3856182", "email_address": "tardieu@us.ibm.com", "orcid_id": ""}, {"name": "Nathaniel Nystrom", "author_profile_id": "81100144238", "affiliation": "University of Lugano, Lugano, Switzerland", "person_id": "P3856183", "email_address": "nate.nystrom@usi.ch", "orcid_id": ""}, {"name": "Igor Peshansky", "author_profile_id": "81100145497", "affiliation": "Google, New York, NY, USA", "person_id": "P3856184", "email_address": "igorp@acm.org", "orcid_id": ""}, {"name": "Vijay Saraswat", "author_profile_id": "81548007297", "affiliation": "IBM Research, Yorktown Heights, NY, USA", "person_id": "P3856185", "email_address": "vsaraswa@us.ibm.com", "orcid_id": ""}], "doi_number": "10.1145/2384616.2384675", "year": "2012", "article_id": "2384675", "conference": "OOPSLA", "title": "Constrained kinds", "url": "http://dl.acm.org/citation.cfm?id=2384675"}