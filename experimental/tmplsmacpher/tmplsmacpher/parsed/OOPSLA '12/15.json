{"article_publication_date": "10-19-2012", "fulltext": "\n Automating Object Transformations for Dynamic Software Updating Stephen Magill * Michael Hicks Suriya \nSubramanian IDA Center for Computing Sciences University of Maryland, College Park Intel Corporation \nsbmagil@super.org mwh@cs.umd.edu suriya@alumni.cs.utexas.edu Kathryn S. McKinley Microsoft Research \n&#38; The University of Texas at Austin mckinley@cs.utexas.edu Abstract Dynamic software updating (DSU) \nsystems eliminate costly downtime by dynamically .xing bugs and adding features to executing programs. \nGiven a static code patch, most DSU systems construct runtime code changes automati\u00adcally. However, a \ndynamic update must also specify how to change the running program s execution state, e.g., the stack \nand heap, to make it compatible with the new code. Constructing such state transformations correctly \nand auto\u00admatically remains an open problem. This paper presents a solution called Targeted Object Synthesis \n(TOS). TOS .rst executes the same tests on the old and new program ver\u00adsions separately, observing the \nprogram heap state at a few corresponding points. Given two corresponding heap states, TOS matches objects \nin the two versions using key .elds that uniquely identify objects and correlate old and new-version \nobjects. Given example object pairs, TOS then synthesizes the simplest-possible function that transforms \nan old-version object to its new-version counterpart. We show that TOS is effective on updates to four \nopen-source server programs for which it generates non-trivial transformation functions that use conditionals, \noperate on collections, and .x memory leaks. These transformations help programmers understand their \nchanges and apply dynamic software updates. * Most of the work was completed while this author was at \nthe University of Maryland, College Park. Permission to make digital or hard copies of all or part of \nthis work for personal or classroom use is granted without fee provided that copies are not made or distributed \nfor pro.t or commercial advantage and that copies bear this notice and the full citation on the .rst \npage. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior \nspeci.c permission and/or a fee. OOPSLA 12, October 19 26, 2012, Tucson, Arizona, USA. Copyright c &#38;#169; \n2012 ACM 978-1-4503-1561-6/12/10. . . $10.00 Categories and Subject Descriptors D.1.2 [Programming Techniques]: \nAutomatic Programming; I.2.2 [Arti.cial In\u00adtelligence]: Program Synthesis General Terms Algorithms, Languages, \nTheory Keywords Dynamic Software Update, DSU, Hot-Swapping, Program Synthesis, State Transformation, \nObject Correla\u00adtion, Object Matching 1. Introduction Suppose you are running an on-line service and a \nmemory leak in your server software causes it to regularly run out of memory and crash. Eventually you \ndiscover the one-line .x: the Connection class s close method should unlink some metadata when a connection \ncloses. To apply this .x in a standard deployment, you stop your server and restart the patched version, \nbut this disrupts active users. With dynamic software updating (DSU) support in an extended Virtual Ma\u00adchine \nsuch as LiveRebel [16] you can do better. You apply a dynamic patch to the Connection class of your running \nsys\u00adtem to prevent further leaks without disrupting current users. In some DSU-enhanced VMs, such as \nJvolve [14], you can do better still. You include state transformation code in the dynamic patch that \ntraverses the heap and unlinks the useless metadata left reachable by the bug. An important goal toward \nfurthering the adoption of DSU systems is to make them easy to use, i.e., to minimize the effort required \nto produce a correct dynamic patch from two versions of a system. As a step in this direction, many DSU \nsystems employ simple syntactic, type-based tool support for constructing a dynamic patch from the old \nand new program versions [1, 8, 13, 14]. For example, if the bytecode for method m of class C changes, \nJvolve will include C.m in the dynamic patch. If C s .eld de.nitions change, in type or number, Jvolve \ncreates a default object transformation function that it applies to all C objects when it applies the \npatch. This function retains the values of unchanged .elds and initializes the rest with a default value, \ne.g., null.  While tool support for identifying changed code is highly effective, existing support for \nconstructing state transforma\u00adtion code is rarely suf.cient, and the programmer must there\u00adfore modify \nthe generated code. For example, in Jvolve the programmer must add code that unlinks the leaked meta\u00addata \nin our example. Unfortunately, the cases that require manual intervention are often challenging to get \nright. For the above example, the Connection transformer cannot sim\u00adply unlink all connection metadata \nunconditionally. Instead, it must use appropriate context by examining the running program s heap and \nstack to identify and unlink only the metadata that is logically dead. Transformations that move objects \nbetween collections or partition single objects into several objects examples we observe in practice \nrequire similar care in their construction. Thus, writing state trans\u00adformation code for DSU systems \nis a programming task unique to DSU, and it can be a time-consuming, error-prone process. To ease this \nburden on programmers, we have developed a general-purpose approach for synthesizing object transform\u00aders \nthat we call Targeted Object Synthesis (TOS). Our devel\u00adopment is in the context of a DSU system for \nJava, called Jvolve, but our techniques are readily adaptable to other DSU systems. Furthermore, the \ntechniques that we design for .nding heap object correlations between different pro\u00adgram versions may \nbe useful for other program understand\u00ading tasks, such as bug detection and testing. TOS works in two \nphases, matching and synthesis the matching phase creates examples by pairing objects in two snapshots \ntaken at equivalent points during the execution of the old and new programs, respectively, while the \nsynthesis phase generates a function that transforms the old object of a matched example pair to the \nnew object. The matching phase begins by running both the old and new versions of the program on the \nsame inputs and tak\u00ading heap snapshots at corresponding program points. Given a class C whose .elds changed \nbetween versions, we .rst reduce the heap snapshots such that they only include C objects and objects \nto which they refer, directly or transi\u00adtively. TOS matching seeks to correlate objects in the old and \nnew versions. TOS identi.es key .elds in the objects that (1) uniquely identify the object in a given \nheap (i.e., each object of class C differs on the values of its key .elds) and (2) there exist objects \nin both heaps with the same values for these .elds. We use a greedy algorithm which, in our experience, \nusually succeeds in .nding a set of key .elds. In the case that no key .elds exist, matching uses the \nmost distinguishing set of .elds it can .nd to pair up most objects, and then applies a lightweight form \nof synthesis to .nd a function that pairs up the remaining objects. With example pairs of corresponding \nold o and new o' objects (o, o') in hand, the synthesis phase searches for func\u00adtions that are consistent \nwith the examples, i.e., functions d for which d(o)= o' for all matched pairs. Functions d assign an \nexpression to each new-version object .eld one at a time, where the expressions may reference any of \nthe old object s .elds (or .elds reachable from them). These ex\u00adpressions may contain constants, simple \nfunctions (e.g., the concatenation or partitioning of string expressions), and con\u00additionals (e.g., if \nthe value to assign to a .eld depends on the current value of another .eld). While these expression forms \nare suf.cient for our examples, additional expression forms can be readily supported, expanding expressiveness \nat the cost of increasing the search space. For collections, we recursively invoke synthesis to generate \ntransformations between objects that make up each collection, mapping the resulting function over the \nold collection objects to produce the new one. When many functions are possible for a given set of examples, \nsynthesis chooses the simplest. We care\u00adfully designed the transformation language to make impor\u00adtant \noperations ef.cient, such as intersecting a set of candi\u00addate functions. As far as we are aware, the \nTOS matching algorithm is new. No prior work attempts to map heap objects from un\u00adstructured heap snapshots \nof different program-version exe\u00adcutions. The TOS synthesis algorithm is inspired by recent work on synthesizing \nstring and Excel table data transforma\u00adtion functions from input and output examples [5, 6]. TOS matching \ncreates examples automatically, whereas this prior work requires users to provide examples. TOS functions \nare a superset of string transformations. Whereas Excel table functions focus on .lters and numerics, \nTOS data transfor\u00admations focus on a more general problem, the transformation of heap objects. We demonstrate \nour approach by synthesizing trans\u00adformation functions for updates to several open-source Java servers, \nincluding JavaEmailServer (a POP and SMTP server), CrossFTP (an FTP server), Azureus (a Bittorrent client), \nand JEdit (a graphical text editor). In one case, changed objects do not have the key .elds that matching \nrequires. In all the others, we show that TOS produces cor\u00adrect transformation functions. These functions \ninclude object .eld additions, string partitioning, partitioning a collection based on a predicate, and \ndeleting objects due to memory leaks. In fact, to our knowledge no prior DSU system has considered the \nneed to correct the residual effects of bugs, such as a memory leak, and our synthesized functions are \nthe .rst demonstration of this capability. TOS represents a sub\u00adstantial step toward realizing the promise \nof DSU technology by reliably automating the most programmer-intensive step. 2. Overview This section \npresents an overview of synthesizing state trans\u00adformation functions for dynamic software updates using \nTOS. We begin with some background on DSU, present an example dynamic update taken from an actual program \n  Figure 1. Program trace at update point after a2. change, and show how TOS synthesizes this dynamic \nupdate automatically. 2.1 Dynamic software updating Suppose an old version of a program is actively \nrunning, and a new version becomes available that .xes some bugs or adds some new features. In many cases, \nwe would like to update the running program without shutting it down since stopping it would degrade \nthe user experience or the program contains useful program state that is costly to recreate. For example, \nusers may have active connections or the program may cache state, such as recent queries and network \nstate. To use a typical DSU system, we must construct a dy\u00adnamic patch [8] that speci.es the changed \ncode and a state transformation function, which modi.es heap objects and other program state, as necessary, \nto work with the new code. For example, if the old program version maintains a list of Connection objects \nand the new version adds some .elds to the Connection class, the state transformation function must initialize \nthe values of the new .elds for the existing objects. In some systems, the state transformer may also \nupdate the control state of the program, e.g., examining and modifying the existing stack and program \ncounter as necessary [10, 14]. We implement TOS for Jvolve [14], which performs DSU in a Java Virtual \nMachine (Jikes RVM), but the TOS design generalizes to other DSU systems. Figure 1 depicts a dynamically \nupdated program s exe\u00adcution. The circles represent the program s state, the labels a1, a2,a3,a4 represent \nactions, e.g., messages sent to and from client applications. Each gray circle represents a state in \nwhich a dynamic update is permitted not every program state may be amenable to certain dynamic updates, \nas dis\u00adcussed below. In this trace, the program starts executing at version 1, and after executing actions \na1 and a2, it applies a dynamic patch. As a result, the code of the program is up\u00addated to version 2, \nand the state transformation function d is applied to transform the current state. A patch could have \nbeen applied in the initial state or the one after a3, if a patch were available at those times. Most \nDSU systems work in three steps. First, when a patch becomes available and the program reaches an ac\u00adceptable \nstate, the DSU system dynamically loads the new and changed code. Second, it redirects existing references \nto the new de.nitions. Finally, it executes the state transforma\u00adtion function to update the existing \nstate. Jvolve implements these steps within a modi.ed virtual machine. It uses stan\u00ad public class v131 \nUser {private .nal String username, domain, password; private String [] forwardAddresses; }public class \nJvolveTransformers { ... public static void jvolveObject(User n, v131 User o) { n.username = o.username; \nn.domain = o.domain; n.password = o.password; int len = o.forwardAddresses.length; n.forwardAddresses \n= new EmailAddress[len]; for ( int i =0; i < len; i++) {  String[] parts =o.forwardAddresses[i].split( \n@ ); n.forwardAddresses[i] = new EmailAddress(parts[0], parts[1]); }}} Figure 2. User object transformer, \nJES 1.3.1 1.3.2 update dard classloading to load new versions of classes. For classes whose only change \nis to the code of methods, Jvolve sim\u00adply modi.es the metadata for that class to point to the new method \nde.nitions (which the JIT may subsequently opti\u00admize). For each class whose objects state requires modi.\u00adcation \n(e.g., because the new version adds .elds), the patch must include an object transformation method. At \nupdate time, the garbage collector .nds all objects that require transformation. It executes the object \ntransformation method on each old object, creating and initializing a corresponding object that conforms \nto the new class s type speci.cation. When a dynamic patch becomes available, the system may choose not \nto apply it immediately. A policy adopted by many DSU systems is to delay updates while changed code \nis actually executing or referenced by the call stack. While this delay makes sense, it is not suf.cient \nto avoid trouble. Hayden et al. [7] studied several years worth of changes to three server programs and \nfound that dynamic updates de\u00adrived from actual releases sometimes fail even while adher\u00ading to this \nactiveness restriction. Other work [8] suggests that simply asking programmers to specify a few program \npoints (dubbed update points) at which updates are permit\u00adted makes the system easier to reason about. \nHayden et al. s study .nds this approach to be effective: updates were ap\u00adplied promptly (e.g., roughly \nevery 10 ms) and never failed. Jvolve and several other systems [8, 10, 13] support this ap\u00adproach. TOS \nuses update points to create correlated pairs of heap snapshots, as explained in Section 2.4.  2.2 JavaEmailServer \nexample We now present an example Jvolve dynamic update and sub\u00adsequently show how TOS synthesizes it. \nFigure 3 illustrates code from versions 1.3.1 and 1.3.2. of JavaEmailServer (JES), a simple SMTP and \nPOP e-mail server, that we obtained from the JES open-source repository. In the old  public class User \n{private .nal String username, domain, password; private String [] forwardAddresses; public User (...) \n{...}public String [] getForwardedAddresses() {...}public void setForwardedAddresses(String[] f) {...} \n}public class Con.gurationManager {private User loadUser(...) { ... User user = new User(...); String \n[] f = ...; user.setForwardedAddresses(f); return user; }} (a) Version 1.3.1 public class User {private \n.nal String username, domain, password; private EmailAddress[] forwardAddresses; public User (...) {...}public \nEmailAddress[] getForwardedAddresses() {...}public void setForwardedAddresses(EmailAddress[] f) {...}}public \nclass Con.gurationManager { private User loadUser(...) { ... User user = new User(...); EmailAddress[] \nf = ...; user.setForwardedAddresses(f); return user; }}public class EmailAddress { public EmailAddress(String \nusername, String domain) {isEmpty = false; username = username; domain = domain; } ... private String \nusername = ; private String domain = ; private boolean isEmpty = true; } (b) Version 1.3.2 Figure \n3. An update to JavaEmailServer (JES) User and Con.gurationManager classes version of the User class, \nforwardedAddresses is an array of strings. In the new version, forwardedAddresses is an array of EmailAddress \nobjects. This difference requires a correspond\u00ading change to the types of other methods in the User class, \nand to the loadUser method code of the Con.gurationManager class, which sets the .eld by calling setForwardedAddresses. \nA Jvolve dynamic patch for this update contains the new versions of the User and Con.gurationManager \nclasses. No object transformer is needed for the Con.gurationManager class because only its methods have \nchanged, not its .elds. Figure 2 illustrates the object transformer method for User objects. The transformer \nis a static method jvolveObject in the class JvolveTransformers. The method takes the old-version object \nand an allocated uninitialized new-version object as arguments. Both have the same class name. To distinguish \nthem, Jvolve renames the old object s class to v131 User. The transformation method copies the .rst three \n.elds from the old to the new version.1 The object transformer allocates and populates an array of EmailAddress \nobjects to replace the existing array of String objects. 1 Jvolve relaxes the Java language restrictions \non private .eld accesses during an update. Given two program versions, Jvolve and other DSU systems automatically \nconstruct the code portion of a dy\u00adnamic patch by syntactically comparing the old and new class .les. \nHowever, generating the object transformer in Figure 2 is well beyond the reach of current techniques. \nJvolve produces the .rst three lines, but then inserts the line n.forwardedAddresses = null. Ginseng \n[13], POLUS [4], and DLpop [8] do slightly better: they generate the loop, but the loop body simply assigns \neach element to null. TOS gener\u00adates the correct object transformer for JES in its entirety.  2.3 Snapshot \nCollection TOS infers object transformers based on example pairs of (old-version, new-version) objects \nand uses the test cases al\u00adready present in a programs test suite to produce these ex\u00adamples. It does \nthis by executing each test case twice once with the old version and once with the new version of the \ncode. At every update point encountered during execution, it records a heap snapshot, which records types \nand .eld val\u00adues for all live objects. Figure 4 depicts this process. The shaded circles are the update \npoints at which we take heap snapshots. Thus each version in the .gure will produce three snapshots and \nthese will later be compared to .nd example pairs for synthesis.  Figure 4. Comparing old and new heaps \nat update points. Snapshot collection is generally straightforward once the programmer marks the update \npoints (which is already re\u00adquired for dynamic updating). Even far-reaching, complex changes to code \ncan be accommodated since update points tend to be close to the root of the control-.ow graph, in code \nthat is quite stable. For example, our JavaEmailServer code has an update point at the end of the main \nprocessing loop for the thread that handles sending outgoing messages. If a test case involves sending \nspeci.c messages at speci.c inter\u00advals, then the same number of snapshots will be created dur\u00ading each \nrun. Futhermore, these snapshots will correspond in the sense that the lists of sent and pending messages \nwill be the same. Changes to the send routine, or the details of the protocol used to send messages, \ndo not affect this cor\u00adrespondence. Only updates that alter the high-level message processing semantics \nare problematic for example, if the server switched from sending all pending messages at once to a model \nwhere message sends are spaced out (perhaps to implement a rate-limited send). Such changes require great \ncare because an existing invariant that there are no pend\u00ading messages when the update point is reached \nno longer holds in new program versions. These updates are best left to the programmer, so we do not \nview the failure of TOS to cope with them as a signi.cant shortcoming.  2.4 Matching TOS works in two \nsteps, matching and synthesis. Matching takes as input the snapshots produced by the test runs and the \nclass C for which we want to generate an object trans\u00adformer. It then produces pairs of (old-version, \nnew-version) objects that serve as examples to guide synthesis. Early in the matching process we also \nprune each snapshot to include only C objects and objects to which they refer, directly or transitively. \nThis linear pass through the heap signi.cantly reduces the input size to TOS matching. In general, TOS \nrequires that (1) the test input generate the same number of snapshots when run using each program version; \nand (2) the ith snapshot for a given input will al\u00adways contain the same set of objects of class C; and \n(3) the corresponding snapshots have the same number of C objects (though the number of instances of \nother classes may differ). Intuitively, the program must behave deterministically with respect to the \nobjects in C, and the role of those objects in the two versions must be the same. The JES example illustrates \nthis point. The email server itself is non-deterministic. Net\u00adwork events and the order in which requests \nare processed vary from one run to the next. However the set of forwarded addresses behaves deterministically \nsince it is read from the same con.guration .le in both versions and does not vary across runs. For all \nour real-world applications and test in\u00adputs, these requirements were met. The goal of the matching phase \nis to produce a uniform one-to-one mapping between objects in each pair of corre\u00adsponding snapshots. \nIt does this primarily by identifying a class s key .elds. De.nition The .elds ]f of a class C are key \n.elds if objects of class C have two properties. 1. No pair of C objects in the same snapshot have the \nsame values for all the .elds ]f . 2. For each object in snapshot sold , there is exactly one object \nin the corresponding snapshot snew that has the same values for .elds ]f .  As an example, Figure 5 \nillustrates a snapshot pair from JES with three objects of class User in the old (top) and new (bottom) \nsnapshots. In this case, TOS generates the mapping {(user[0]old , user[0]new), (user[1]old , user[1]new), \n(user[2]old , user[2]new)} using key .eld username. This .eld is key be\u00adcause the values john, alice, \nand pat uniquely identify each object in both sold and snew and there exists only one old and new object \nwith the same value. Neither domain nor password are key .elds because multiple objects in the same snapshot \nhave the same value. If user[2].username was john instead of pat, then there is no single key .eld, since \nnone of the primitive .elds username, domain, or password have unique values. In this case, matching \nsearches for a set of .elds that all together satisfy the given criteria. Given the modi.ed user[2] snap\u00adshots, \nmatching would .nd that together the .elds username and domain impose a one-to-one mapping on all the \nobjects. If no set of key .elds exists, our matching algorithm em\u00adploys two re.nements, described in \nSection 3. First, it at\u00adtempts to use referent object .eld values as potential key .elds. If this attempt \nfails, it uses the set of key .elds/paths that is most discriminatory (i.e., it comes the closest to \npro\u00adducing a one-to-one matching), and then re.nes any objects not yet matched by using a lightweight \nform of synthesis.  2.5 Synthesis The matching phase ultimately produces a list of example pairs of \nobjects of a class C. Synthesis then proceeds in roughly two steps. (1) For each example pair, the algorithm \nsynthesizes a set of candidate functions. (2) It intersects the set of candidate functions to produce \na function consistent with all examples. In our implementation, the algorithm proceeds by synthesizing \nan initializer for each .eld, one at a time. The description given here, for simplicity, presents the \nprocess as working for the entire transformer method at once.  Old Version Heap Objects JES Heap user[0] \nuser[1] user[2] john alice pat yahoo.com yahoo.com intel .com poorpassword poorpassword poorpassword \n[ john@cs.umd.edu , john-alice@yahoo.com ] [ john-alice@yahoo.com ] NULL New Version Heap Objects JES \nHeap user[0] user[1] user[2] john alice pat yahoo.com yahoo.com intel .com poorpassword poorpassword \npoorpassword forwardedAddresses[0] = forwardedAddresses[0] = NULL [ username = john , domain = cs.umd.edu \n] [ username = john-alice , forwardedAddresses[1] = domain = yahoo.com ] [ username = john-alice , domain \n= yahoo.com ] Figure 5. JES heap example for User Class with .elds, in order, username, domain, password, \nand forwardedAddresses. The .rst step proceeds as follows. For each example pair, synthesis seeks a set \nof functions . such that each d . . is consistent with the example, i.e., o ' = d(o) for the example \n(o,o '). Each di . . assigns each new-version .eld one at a time. For example, consider the two User \nobjects in Figure 5 that correspond to user[0]. For this example, synthesis will .rst infer d0 that assigns \nthe constants john, yahoo.com, and poorpassword to each of the new object s .elds username, domain, and \npassword, respectively. It also infers d1 that copies the corresponding .elds from the input object, \ni.e., n.username := o.username,n.domain := o.domain, etc. For .elds of type String, it also considers \nassigning the concatenation of other strings, e.g., those that are substrings of old-version .elds. For \n.elds that are collections, we invoke synthesis re\u00adcursively. The algorithm matches two collections and \nthen matches the set of objects in the two collections. It then generates a transformation function between \nthe collection pairs from a transformation function for the object pairs. For forwardedAddresses, each \nString has the form x@y and is mapped to an EmailAddress object whose username, domain, and isEmpty .elds \nare x , y , and false, respectively, where the .rst two .elds are substrings of the input string. Once \nthe algorithm establishes an element-wise function, it simply it\u00aderates over the old collection and maps \neach element to one in the new collection. Once synthesis generates . for each pair of objects of class \nC, it intersects them to produce a . that is consistent with all the examples. During this step, synthesis \ndiscards overly-speci.c functions, e.g., it discovers that d1 described above is consistent with all \nthree of the matched pairs but d0 is not, and discards it. If |. | = 1, then synthesis chooses d . . \nfor the object transformer. If |. | > 1, it picks the d . . that is intuitively the simplest and most \ngeneral function. For example, we mark functions that contain assignments from old .elds to new .elds \nas more general than functions that assign constants. If |. | = 0 then no one function works for all \nexamples. In this case, synthesis picks the function that works for the most examples and then iteratively \nseeks a function that works for the remaining examples along with a conditional expression that distinguishes \nbetween the two cases.  2.6 Discussion A key difference between TOS and prior work on learning from \nexamples is that in prior work, the user identi.es partic\u00adular example pairs, whereas in our work, the \nuser must pro\u00adduce matching executions created by running the old and new program versions on the same \ninputs from which TOS automatically identi.es examples. While automatic match\u00ading is simpler than identifying \nexample object pairs directly, there is a risk that it will not pair up truly corresponding ob\u00adjects, \nin which case the synthesized transformation function will be incorrect. To reduce the likelihood of \nthis case, we place strong restrictions on the inputs to matching, as de\u00adscribed in the third paragraph \nof Section 2.4: snapshots in both versions must be taken at the same update points in both versions, \nthere must be an equal number of snapshots, and when synthesizing a transformer for class C, there must \nbe an equal number of C objects in corresponding snapshots. These restrictions ensure that C objects \nare playing the same role in the old and new execution, so if we update the old program at one of these \nupdate points, executing the synthe\u00adsized transformer would bring the program to an equivalent state. \nNote that while corresponding snapshots must contain the same number of C objects, where C is the changed \nclass, the number of other objects can vary. For example, a buggy implementation of C may fail to null \nits .eld f of class D, inducing a memory leak. Thus in the old and new snapshots, the number of C objects \nwill be the same, but the number of D objects may differ. As we show in our experiments, inferring the \ntransformer method for such a leaky class C can end up correcting the memory leak by nulling the dead \nobjects.  Because TOS generates a solution speci.c to the ex\u00adamples it is given, the developer must \nsnapshot executions that produce a suf.cient number of objects. For conditional transformers, the input \nmust produce objects that cover the range of possible variations; i.e., if there are N conditions, TOS \nneeds at least an example pair for each of the N con\u00additions. These examples could come from a single \nsnapshot with N instances of the object in both the old and new ver\u00adsion or from multiple snapshots which \neach contain one or two instances but together provide N examples. If there are too few examples, then \nsynthesis may infer a function that is overly speci.c. In our experience (described in Section 5), it \nwas easy to provide enough examples for synthesis, and most experi\u00adments required just one (well-chosen) \ntest. TOS fails in two of our test cases. In one case we could not reproduce a mem\u00adory leak we were aiming \nto .x, leading to a failure during the snapshot collection phase. In the other case, the changed objects \ndid not have key .elds and so the matching phase failed. Despite these limitations, our approach adds \nvalue: the developer needs to run tests anyway, and if these tests are suf.ciently deterministic and \ncover the relevant behaviors of a changed class, TOS can be used to infer object transform\u00aders for that \nclass. 3. Matching Now we present the TOS matching algorithm in detail; the next section describes the \nsynthesis algorithm. The goal of matching is to produce example pairs (o,o ') of correspond\u00ading old and \nnew objects taken from heap snapshot pairs. The synthesis phase takes these pairs as input and searches \nfor a function d such that d(o)= o ' for all the example pairs. The functions are class based, thus all \nold objects o must have the same class C and all new objects must have the same class C'. We .rst assume \nC = C', and then consider C = C', when matching recursively during synthesis. We describe our algorithm \nusing the following notation. A snapshot s is just a set of objects; we use the two terms interchangeably. \nWe write ]X to denote a list of Xs; ]X :: X to denote concatenating the element X to the end of the list \n]X; and ]X(i) to denote the ith element of the list ]X. We sometimes refer to a list as a tuple (e.g., \nwhen its length is known to be .xed). We write o.]f to denote the tuple ]v where o. fi = vi for 0 < i \n= n. We write values]f (s) for the set of value tuples assigned to .elds ]f by objects in s, i.e., ] \nvalues]f (s)= {]v | o . s .o.f =]v}. Finally, we write ]sl]f =]v for {o | o . s . o.]f =]v}. Figure 6 \ngives the pseudocode for the matching algorithm in the function called match. The input to match is a \npair of lists of object sets (]sold , ]snew). The object set ]sold (i) contains objects collected from \nthe ith snapshot taken while running the old program, while s' = ]snew(i) contains objects collected \nfrom the corresponding snapshot of a run of the new program. As mentioned earlier, we .rst prune the \nsnapshots to in\u00adclude only objects of classes C that changed between the old and new version and objects \nto which these objects di\u00adrectly or transitively refer. We assume that this pruning has happened prior \nto the call to match. We also assume that there are the same number of snapshots for the old and new \nprogram executions (|]sold | = |]snew|), and that each corre\u00adsponding pruned snapshot has the same number \nof objects (|]sold (i)| = |]snew(i)|). If these conditions do not hold then matching fails for the class \nin question. The match function returns a list of object pairs (o,o '), the .rst from an old snap\u00adshot \nand the second from a new snapshot, which serves as input for synthesis. 3.1 Key .elds The match function \n.rst calls get key.elds (line 2) to search for key .elds that partition the objects in corresponding \npruned snapshots. Given a list of .elds kfs, and the old and new snapshots, match calls the function \nsplit on key.elds , which returns a pair of object set lists whose ith elements correspond. In particular, \neach object o . ]sold (i) and o '. ]snew(i) have the same values for .elds in kfs. Ideally, the size \nof ]sold (i) and ]snew(i) returned by split on key.elds will be 1 for all i. In this case (as checked \non line 4), each object is uniquely identi.ed by the .elds kfs in every snapshot and there is a corresponding \nobject in the old (respectively, new) snapshot with the same .eld values. The size of a set will be greater \nthan 1 if there are multiple objects in a single snapshot that contain the same values for .elds in kfs. \nIf sets are non-singleton, match uses lightweight synthesis to complete the partition. The function get \nkey.elds iteratively adds new .elds to the list kfs. When it reaches a .xed point, it returns the list. \nThe .rst nested loop (line 12) considers each possible relevant .eld f for objects of class t. The function \nassigns each .eld a score based on how well f , when added to the current .elds in kfs , distinguishes \nthe objects. The inner loop (line 15) considers each pair of snapshots and computes the set V, which \ncontains the distinct tuples of kfs .elds values in old-version objects. Line 17 then considers each \nof the tuples ]v in set V. It must be the case that we have the same number of old and new objects with \nvalues ]v in .elds kfs . This requirement preserves the ability to discover a bijection between the objects. \nThe larger |V | is, the .ner the partition induced by splitting on kfs . Synthesis prefers .ner partitions, \nwhich indicate more effective key .elds. Thus match adds |V | to score and then chooses the .eld that \nmaximizes score. If a .eld f leads to the condition on line 17 being violated, then match assigns f a \nscore of 0 and proceeds to the next .eld.  1 match(]sold , ]snew)= 2 kfs := get key.elds (]sold , ]snew) \n '' 3 (]ss) = split on key.elds(kfs,] old , ]newsold ,]snew) ' 4 if .i. |]sold (i)| > 1 then '' '' \n5 (]ss) := synthesis match(]ss) old ,]newold , ]new '' ' 6 return {(o,o ') |.i.0 < i = length(]snew) \n. o . ]sold (i) . o '. ]snew 7 get key.elds (]sold , ]snew)= 8 kfs := [] 9 currscore := 0 10 11 repeat \n{prevkfs := kfs ; 12 for each .eld 13 kfs ' := kfs :: 14 score( f ) = 0 f . kfs {f 15 for each i . \n1..length(]snew) {16 V := valueskfs ' (]sold (i)) 17 if .]v .V. |sold (i)lkfs ' =v| = |snew(i)lkfs ' \n= ] ]v| then 18 19 20 score( f ) := score( f ) + |V|else {score( f ) = 0 21 break 22 23 24 } } }let g \nbe the f that maximizes score( f ) 25 26 if score(g) > currscore {kfs := kfs :: g 27 currscore := score(g) \n28 29 30 }} until (prevkfs = kfs) return kfs 31 } 32 split on key.elds (kfs,]sold ,]snew)= 33 if kfs \n= [] then return (]sold ,]snew) ' 34 ]sold := [] ' 35 ]s:= [] new 36 for each i . 1..length(]snew) {37 \nfor each ]v . valueskfs(]sold (i) .]snew(i)) { '' 38 ]ss (i)} old := ]old :: sold (i)lkfs=]v '' 39 ]snew \n:= ]snew :: snew(i)lkfs=]v 40 } 41 } 42 return (]sold ,]snew) 43 synthesis match(]sold ,]snew)= ' 44 \n]sold := [] ' 45 ]s:= [] new 46 for each k . 1..length(]sold ) { 47 s := ]sold (k) ' 48 s:= ]snew(k) \n49 if |s| = 1 .|s'| = 1 then 50 while s' = 0/{ 51 choose o from s 52 let . = ' synth non branching(o,oi) \n oi.s 53 letfun score(d )= |s'n d (s)| 54 let d be the element of . that maximizes score ' 55 let U \n= {(o,o ') | (o,o ') . s \u00d7 s'. o 56 for each (o, o ') . U { '' 57 ]sold := ]sold :: {o}'' 58 ]s:= ]s:: \n{o '} 59 s := s -{o}' new new 60 s:= s'-{o '} 61 } 62 } 63 } '' 64 return (]ss) old ,]new = d (o)} \nFigure 6. Pseudocode for the match function. Once it scores all the .elds, match picks the .eld g that \nmaximizes the score. If the best score does better at distin\u00adguishing objects than it previously did \nwhen using just .elds in kfs, it adds g to kfs and continues iterating. If get .elds cannot .nd a bijection \nusing one or more primitive .elds, we extend it by changing the .rst nested loop (line 12) to consider \n.eld paths. A .eld path ]f is a list of .elds, e.g. f1. f2. The value given by o.]f is the value as\u00adsigned \nto .eld f2 in the object referenced by o. f1. Beyond the replacement of f with ]f , the algorithm in \nFigure 6 is un\u00adchanged. If matching with .eld paths still does not produce a bijection, we apply synthesis-based \nmatching, described in Section 3.3.  3.2 The Old-Version Consistency Check Note that the description \nof matching thus far has not made use of the fact that the objects in the two snapshot lists are the \nresult of executing different program versions. We have described the inputs to match as a list of old-version \nsnapshots and a list of new-version snapshots, but these could equally well be two lists of old-version \nsnapshots produced by separate runs of the old version over a single test case. Performing such an old-old \nmatch is useful as a preprocessing step prior to old-new matching. Recall that get key.elds assigns to \neach .eld f a score, given by score( f ). This score is non-zero if and only if par\u00adtitioning each snapshot \non .eld f produces sets with equal cardinalities. We use this property in old-new matching as a heuristic \nto .nd .elds that are unchanged by the update and that help pair up corresponding objects. We would also \nex\u00adpect these .elds to have non-zero score in an old-old match\u00ading, and we use this additional check \nto ensure that we are in fact .nding unchanged .elds. In our implementation, we .rst perform an old-old \nmatching and consider only those .elds f with score( f ) > 0 as potential key .elds for the old\u00adnew matching. \n Old-old matching also helps focus synthesis. If a .eld f has score 0 in the old-old case, then this \n.eld behaves non-deterministically. As an example, both time-stamps and nonces would have this property. \nWe do not infer transfor\u00admations for these .elds because even if we match objects correctly, the difference \nbetween the old and new values for these .elds will not solely be the result of the code change. Finally, \nif we fail to produce an old-old matching, then we can say with certainty that this is not an object \nfor which we should perform TOS. We can also provide the programmer with feedback indicating that the \nfailure to synthesize is not due to the code change s effect on the object, but rather due to inherent \nproblems with the role of the object in the given test case.  3.3 Synthesis-based matching If key .elds \ndo not induce singleton sets, we further decom\u00ad '' pose the non-singletons, since whenever ]sold (i) \nand ]s(i) new contain more than one element each, it is unclear which '' pair (o1,o2) with o1 . ]sold \n(i) and o2 . ]snew(i) to use as an input-output example for synthesis. In this case, match calls synthesis \nmatch with the two current lists of corresponding sets to re.ne the non-singleton sets in the lists. \nSynthesis-based matching tries to .nd a matching that is witnessed by a transformation function d that \nmaps objects in the old set to objects in the new set. We introduce addi\u00adtional terminology to explain \nthe algorithm. We say that d is consistent with the object pair (o,o ') iff o ' = d(o). We call a set \nof pairs U a matching iff for all pairs (o1,o ' 1) and (o2,o ' 2) '' in U, we have o1 = o2 . o1 = o2. \nThat is, no old-version ob\u00adject is paired with multiple new-version objects, nor is any new-version object \npaired with multiple old-version objects. The synthesis match function iterates over each pair of ob\u00adject \nsets, searching for a one-to-one matching between the ' old and new objects of each when the sets s and \nsare not singletons. Consider the non-singleton pair s and s'. The al\u00adgorithm .rst chooses an old-version \nobject o (line 51). It may choose any object since it must eventually .nd transforma\u00adtion functions for \nall objects in ]sold . It then considers each pair (o,oi), where oi is a new-version object, with the \naim of synthesizing .i,a set of transformation functions consistent with the example (o,oi). The algorithm \ncombines all these sets of functions into a single set of transformation functions . (line 52). The synthesis \nprocedure used here is restricted to non-branching transformation functions. These are func\u00adtions that \ndo not perform case analysis on the old-version object. (Figure 9 gives pseudocode for this function, \nwhich is explained in the next section.) Without this restriction, the inferred functions can always \ncreate a conditional function speci.c only to this one pair, but these functions are not gen\u00aderal and \ndo not help create sets of examples for synthesis of general functions. Line 53 de.nes a function score \nthat scores possible transformation functions d in .. The algorithm chooses the highest-scoring function \nd (line 54). The score of a trans\u00adformation d is determined by how well it maps objects in s to those \nin s' in the .gure we write d(s) to mean {o '| o . s . o ' = d(o)}. Thus a high-scoring function will \nmap the input set to many objects that match (intersect with) the output set. The mapping induced by \nd is given in U . Fi\u00adnally, the loop on line 56 adds the singleton sets comprising '' this mapping to \n]sold and ]snew (which will be the ultimate output of this function) and then removes the mapped ele\u00adments \nfrom the current snapshots s and s'. The algorithm greedily continues, iteratively choosing transformation \nfunc\u00adtions that maximize the number of example pairs they cover. Once s becomes empty, which is sure \nto happen because ultimately objects can be matched arbitrarily using constant functions, the while loop \nexits and synthesis moves on to the next snapshot, continuing until it considers all pruned snapshots. \n4. Synthesis The synthesis phase takes the example pairs produced by matching and synthesizes a function \nd from them such that for the pair (o,o '), d(o)= o ' . 4.1 Transformation functions d A transformation \nfunction d is de.ned according to the grammar in Figure 7. Transformation functions take an old\u00adversion \nobject in o, allocate a new-version object in n, assign values to each of the .elds of n, and then return \nn. Field as\u00adsignments g are of the form n. f := c where c is a conditional and f is a .eld path that \nis, it is a (possibly empty) list of .eld labels l. For n, this path is almost always a single .eld. \n(Section 4.5 discusses the multiple .elds case.) Each condi\u00adtional c speci.es one or more cases distinguished \nby boolean expressions ei over old-version state (i.e., they can only refer to objects via o, never n). \nEach case has an initializer expres\u00adsion d which is either a constant, a reference to an old .eld, a \nstring produced by concatenating one or more (sub)strings, or a collection produced by map. Here, map(d,o. \nf ) takes the collection at o. f , and transforms these elements using d . The string expression substr(o. \nf , i) splits the string o. f at positions where a delimiter delim appears and then selects the ith substring. \nFor example, substr( foo@bar.com ,2) re\u00adturns bar.com since @ is a delimiter that splits the string into \ntwo substrings and bar.com is the second substring. Our language of string updates supports a concatenation \nof substrings and is suf.cient for the examples we considered. If a more robust string transformation \nlanguage were needed, the approach taken by Gulwani [5, 6] or any other example\u00adbased string synthesis \ntechnique would work easily. We have simpli.ed the form of d to keep the algorithm tractable. The most \nobvious restriction is that d transforms a single object, rather than multiple objects at once. This \nre\u00ad striction derives from the nature of the underlying DSU sys\u00adtem we use, Jvolve. Note that different \nobjects of the same  Updates d ::= . o. new n; g1; ...; gn; ret n 1 2 Field Updates g ::= n. f := c \n3 Field Path f ::= e | f .l Conditional c ::= case e1 . d1,...,en . dn end 4 5 Initializer d ::= k | \no. f | concat(se1,...,sen) | map(d ,o. f ) Integer Constant i, j . Z 6 7 8 9 Constant k ::= i | null \n| delim Delimiter delim ::= \\ | / | # | @ | : String Expression se ::= delim | substr(o. f ,i) Boolean \nExpression e ::= a | e1 . e2 | e1 . e2 Atomic Expression a ::= o. f1 o o. f2 | o. f o k Operator o ::= \n= | = | ... 10 11 12 13 14 15 16 17 Figure 7. The language over which we perform synthesis. 18 19 class \nwill not necessarily be transformed in the same way 20 conditionals c may evaluate to different branches \nfor differ\u00ad 21 ent objects and thereby trigger different initializers. Another 22 restriction is that \neach .eld of the new object is initialized in\u00ad 23 dependently, albeit with access to the full contents \n(i.e., mul\u00ad 24 tiple .elds) of the old-version object o. Transformers that are 25 ruled out by this setup \ninclude those that initialize .eld f ac\u00ad cording to the updated value for .eld f ' as well as those that \npass values across the object graph, e.g., setting n. f2:= Foo. f1 when o is not an instance of Foo. \n4.2 Synthesis algorithm Figure 8 gives pseudo-code for the synthesis algorithm. The main function is \nsynthesize. It takes a set of input-output examples U (pairs of old-version, new-version objects) and \nproduces a transformation function that is consistent with those examples. Synthesis proceeds one .eld \nat a time. For each .eld, it synthesizes a conditional update (c in the grammar in Figure 7) that is \ncapable of producing all the values for that .eld seen in the example pairs in U. It .rst generates the \ninitializers d and then searches for conditions that indicate which d to apply. To .nd the initializers \nd, the synthesis algorithm main\u00ad tains a set update fns of initializers it has discovered thus far, as \nwell as a set not covered that contains all example pairs that cannot be produced by an initializer in \nupdate fns. During each iteration through the loop on line 5, it chooses an element from not covered \nand calls synth .eld, which re\u00ad turns the set D of all initializers d that are consistent with that .eld \ns values in the provided example pair. Of these, we choose d , which covers the largest number of pairs \nin not covered, and add it to update fns, while removing the pairs that d covers from not covered. The \nloop on line 16 .nds the conditions that indicate which d to apply to a given old-version object. For \neach synthesize(U)= for each new-version .eld fi {not covered := U update fns := [] while not covered \n= 0/{choose (o,o ') . not covered let D = synth .eld( fi,o,o ' ) letfun score(d)= ' |{(o,o ') | (o, o \n') . not covered . o . fi = d(o)}| let d be the element of D that maximizes score ' let U = {(o,o ') \n| (o,o ') . not covered . o . fi = d (o)} update fns := update fns :: (d ,U ) not covered := not covered \n- U } cond := [] for i . 1..length(update fns) { let (d ,U )= update fns(i) ' let sin = {o |.o . (o,o \n') . U . (o,o ') . U }' let sout = {o |.o . (o, o ') . U . (o,o ') . U } cond := cond :: (synth cond(sin,sout)) \n} c fi := (case c 1 . d 1,..., c n . d n end ) where c j = cond(j) and (d j,U j)= update fns(j) } return \n(. o. new n; n. f1:= cf1; ...;n. fn := cfn ; ret n) Figure 8. Main synthesis algorithm. transformation \nfunction d , the loop builds sin, containing the old-version objects from the example pairs consistent \nwith d , and sout, containing the remaining example pairs. It then calls synth cond to .nd a condition \nthat separates these two sets based on values of old-version .elds, and adds it to the list cond. Finally, \nthe algorithm constructs c fi , the conditional up\u00addate containing all the logic it just synthesized \nfor .eld fi. The update for the class is then the sequence of all these .eld updates. We write synthesized \ncode in angle brackets to distinguish it from the code of the synthesis algorithm. 4.3 Field synthesis \nFigure 9 gives the pseudo-code for synth .eld, which pro\u00adduces the initializers for a new-version .eld \naccording to a given example pair. The .gure also shows the code for synth non branching, which is the \nfunction used to perform synthesis-based matching (Section 3.3). It uses synth .eld as a subroutine. \nThe synth .eld function takes a .eld, an old-version ob\u00adject o, and a new-version object o ', and returns \na set of initial\u00adizers (from production d in the grammar in Figure 7), where each initializer can produce \nthe value in o ' . f given the object o. The set is constructed by .rst checking whether the value in \no ' . f is also present in a .eld in o and if its value can be copied over. Next, it checks whether o \n' . f is one of the con\u00adstants in the synthesis language. If so, it adds this production Figure 9. Non-branching \nand per-.eld synth. subroutines.  1 synth non branching(o,o ' ) = 2 g := empty .eld update 3 4 for each \nf in o ' {let c set = synth .eld ( f ,o,o ' ) 5 6 7 8 for each c . c set do { g := g + ( ; n. f := c \n) }}return . o. new n; (g);ret n 9 synth .eld ( f ,o,o ' ) = 10 ret set := /0 11 if o ' . f = o.g for \nsome .eld g 12 13 ret set := if o ' . f = k ret set . {(o.g)} 14 15 ret set := ret set . {(k)} if typeof(o \n' . f ) = String 16 ret set := ret set . string synth(o. f ,o ' . f ) 17 if o ' . f is a collection 18 \nlet s' = multiset of objects in collection o ' . f 19 20 for each collection-valued .eld o. f2 {let s \n= multiset of objects in collection o. f2 21 let d = collection synth(s,s') 22 23 24 ret set := }return \nret set ret set . {(map(d ,o. f2))} 25 26 collection synth (s,s' ) = 27 let examples = match([s],[s' \n]) 28 return synthesize(examples) method to the returned set. Finally, we have two class-based synthesis \nchecks. If o ' . f is a string, we invoke string synthe\u00adsis to produce a set that describes all possible \nmethods for construction the string from substrings present in o. We do not give code for this function \nsince it closely follows Gul\u00adwani [5]. If o ' . f is a collection, then we recursively invoke synthesis \nin order to transform the elements of the collection.  4.4 Condition synthesis Condition synthesis produces \na condition that distinguishes two sets of examples following the basic approach of Gul\u00adwani [5]. Figure \n10 gives the pseudocode. It uses nota\u00adtion [e] to denote a function from objects to truth values where \n[e]o = true if and only if condition e is true when o (an actual object) is substituted for o (the variable) \nin e. If [e]o = true, we will say that e includes o and otherwise we say that e excludes o. Given a set \nof objects sin and sout, the goal of condition synthesis is to return an expression e such that .o . \nsin [e]o = true and .o . sout [e]o = false. If this is the case, we say that e separates sin and sout. \nThe construction of e proceeds in a greedy fashion. The loop at line 4 calls synth conj to synthesize \na conjunction a1 . ... . an, where each ai is an atomic expression. This expression will exclude all \nthe elements in sout while in\u00adcluding as many elements of sin as possible. The synth conj function builds \nup this conjunction iteratively using the loop at line 15. Given e = a1 . ... . aj, we .rst check to \nsee if e already separates sin and sout. If so, we are done the code '' detects this case when s= 0. \nIf not, let/ s= {o | o . out in ' sin .[e]o = true} and let sout = {o | o . sout .[e]o = true}. '' Thus \nsin and sout are the subsets of sin and sout that satisfy e. We then choose aj+1 to be the atomic expression \nthat max\u00ad '' imizes rank(aj+1,sout). We de.ne the rank of a condi\u00ad in,s tion e as follows. De.nition \n1. Let rank(e,sin,sout)= m \u00d7 n where m = |{o | o . sin . [e]o = true}| and n = |{o | o . sout . [e]o \n= false}|. Thus, rank(e,sin, sout) is the product of the number of objects from sin that are included \nby e and the number of objects in sout that are excluded. The atomic expressions we consider are those \ninvolving equality or inequality between pairs of .elds (of which there are a .nite number) and equality \nor inequality with a con\u00adstant appearing in the object (of which there are a .nite number). Since there \nare a .nite number of possible atomic expressions, we can simply iterate over them, although our implementation \nis able to avoid considering many expres\u00adsions that are guaranteed to not satisfy the conditions re\u00ad \n'' quired. Provided rank(a,sout) is non-zero, we know that in,s ' conjoining a to e will cause some elements \nof sto be out excluded, while still including some elements of sin. If no atomic expression produces \na rank greater than zero, then this indicates a failure to .nd the necessary condition and we abort the \nsynthesis process for this .eld. In this case our expression language is either insuf.cient to distinguish \nthe different examples, or we have simply not considered the discriminating data (e.g., if it were a \nglobal variable). Oth\u00aderwise we continue adding atomic expressions until we have excluded all elements \nof sout and constructed conjunct e. Returning to the code of synth cond, we know that the conjunct returned \nfrom synth conj excludes all elements of sout. We add e ' to the current list of disjuncts e, and then \nadd ' to sin the set {o | o . sin . [e '] o = true}, which are all ob\u00adjects e now includes. If any elements \nremain, we iterate again to produce another conjunct that will include them, until the expression includes \nall elements of sin (and excludes all el\u00adements of sout).  4.5 Discussion Our synthesis algorithm is \nengineered to favor simpler, more general transformations d over more specialized ones. For example, \nsuppose class Foo contains an integer-valued .eld f and in all our snapshots s . ]sold we have two Foo \nobjects o1 and o2 such that o1. f = 1 and o2. f = 2. Likewise, all snapshots s'. ]snew have two Foo objects \no ' 1 and o2 ' such that o ' 1. f = 1 and o ' 2. f = 2. In this case, synthesize will produce the function \n. o.new n; case true . n. f := o. f end;ret n  1 synth cond(sin,sout) = ' 2 s0 in := / 3e := (false) \n' 4 while s in = sin { '' 5 let e = synth conj(sin - sin,sout) 6e := e + (.e ') '' 7 sin := sin .{o \n| o . sin . [e ']o = true} 8 } 9 return e 10 11 synth conj(sin,sout) = ' 12 sin := sin ' 13 sout := sout \n14 e := (true) ' 15 while sout = 0/{ '' 16 let a be the condition that maximizes rank(a,sin, sout) '' \n17 if rank(a,s)= 0 then abort in, sout18 e := e + (.a)'' 19 sin := {o | o . sin . [e]o = true}'' 20 sout \n:= {o | o . sout . [e]o = true} 21 } 22 return e Figure 10. Synthesizing conditions. and not the function \n. o.new n;case (o. f = 1) . n. f := 1, case (o. f = 2) . n. f := 2 end; ret n Line 10 of synthesize (Figure \n8) favors initializers that apply to the most possible objects. Line 16 of synth conj (Figure 10) similarly \naims for simpler, more general conditions. The algorithm as described assumes that synthesis takes place \non a per-object basis, one .eld at a time. In fact, it can also synthesize the contents of a new object \ns children, e.g., assigning not just n. f := d but n. f1. f2:= d as well. Likewise it can read children \nof old objects in initializers d. To support this extension, we simply consider .eld paths rather than \n.elds, up to a speci.ed depth, e.g., on line 2 in Figure 8 and on line 11 in Figure 9. Matching can be \nsimilarly extended, e.g., using paths on line 12 in Figure 6. Finally, we extend the synthesis language \nin Figure 7 to allow object allocation, so we can allocate and initialize child objects if needed. (Note \nthat allocation happens implicitly with map when producing the new collection.) We have found this .exibility \nuseful in practice, as we discuss in the Azureus example in the next section. 5. Evaluation We implemented \nTOS and used it to synthesize object trans\u00adformers for several program updates we gathered from the wild. \nWe choose challenging examples that other systems cannot handle, and .nd that TOS handles most. TOS does \nfail when the changed objects do not store data that makes it possible to match them between heaps, but \nthis case is less common. This section provides a few more details about our implementation, describes \neach test program update, and our experiences with TOS in each case.   5.1 Implementation We use the \nOracle HotSpot JVM to collect heap snapshots using the agentlib:hprof command line option.2 This op\u00adtion \ninvokes the heap pro.ler, which sends the current snap\u00adshot over a network socket. We wrote a small server \nthat coordinates snapshots with the application. It initiates snap\u00adshots at update points and saves them \nto disk. In particular, when the application reaches an update point, it calls into a helper class to \ntrigger a snapshot. TOS is implemented in Java and comprises roughly 4200 lines of code. About 1300 lines \nimplement matching, 1600 implement synthesis, and the rest is common code.  5.2 Results In our experiments, \nwe consider two updates to Azureus (a bittorrent client); three updates to jEdit (a text editor); one \nupdate to JavaEmailServer (a.k.a., JES, an SMTP and POP mail server); and one update to CrossFTP (an \nFTP server). These applications range from 2.3k to 250k source lines of code. These are actively developed \nand maintained programs not built with dynamic software updating in mind. We chose these applications \nand updates for the following reasons. First, dynamic updates for these programs would be useful. For \nAzureus, JES, and CrossFTP, dynamic updates would avoid disruption due to shutdown/restart, e.g., they \nwould preserve active connections involving e-mail send\u00ading or .le transfer, and they would preserve \nimportant in\u00admemory state, such as .le/metadata caches. Dynamic up\u00addates to JEdit are less important \n(you could save in-progress work and restart), but would be convenient, e.g., to preserve the content \nand layout of onscreen windows. Second, the up\u00addates to JES and CrossFTP were also considered in the \norig\u00adinal Jvolve work [14]. We wanted to see if we could use TOS to generate transformers we previously \nwrote by hand. Finally, we found updates to these programs that are rela\u00adtively interesting, such as \nupdates that do not affect all ob\u00adjects uniformly (thus requiring conditional transformers) or updates \nthat .x memory leaks. We focus on the challeng\u00ading updates that prior DSU systems cannot handle automat\u00adically. \nWe also tested TOS on many simple updates, and in\u00adclude two of these the copy transformers for CrossFTP \nv1.06 as exemplars. Table 1 summarizes information about the updates and the inferred transformers. We \nlist the version for which we synthesize an update and the number of snapshots generated by our test \ncase. In all but one example, TOS needs only a single test case. Version 1.08 of CrossFTP required three \ntest cases. We list the number of classes used by the pro\u00ad 2 We use HotSpot only for snapshotting Jvolve, \nthe VM that TOS targets, is based on Jikes RVM and does not support snapshotting.  Application SLOC \nVersion # Snaps Classes Heap Obj. Target Obj. Match Synthesis Inferred Type Azureus 250K r2514 11 1616 \n1315420 97 0.842 s 0.120 s yes conditional r120 22 1634 1117463 275 0.002 s 0.000 s no JEdit 154K r14027 \n5 3044 703360 30 0.041 s 0.008 s yes constant 150K r13413 5 3221 747849 0 0.000 s 0.000 s no JES 2.3K \n1.3.2 1 911 51802 1 0.020 s 0.022 s yes collection 2.4k 1.3.3 1 902 52210 1 0.001 s 0.007 s yes constant \nCrossFTP 13.9K 13.9K 1.06 1.06 1 1 953 953 38907 38907 1 1 0.001 s 0.002 s 0.009 s 0.007 s yes yes copy1 \ncopy1 13.9K 1.06 1 953 38907 1 0.002 s 0.009 s yes constant 14K 1.07 1 2417 152531 1 0.044 s 0.013 s \nyes constant 18.1K 1.08 3 954 116833 1 0.002 s 0.011 s yes conditional Table 1. Summary of updates and \ninferred transformers. Each example is the result of a single test case. 1Transformer that would also \nhave been produced automatically by Jvolve. gram, the number of object instances present (total across \nall snapshots), and the total number of instances of the tar\u00adget object (target objects changed or transitively \nreferred to by changed objects). Finally, we list execution times in sec\u00adonds for matching and synthesis, \nand indicate if synthesis succeeded. Matching and synthesis times are negligible for all exam\u00adples. Matching \ntimes and effectiveness bene.t from focusing on a single class at a time, since it signi.cantly reduces \nthe number of objects that TOS considers. TOS restricts itself to changed objects and objects reachable \nfrom changed ob\u00adjects by a bounded number of .eld dereferences. This bound is the same one mentioned \nin Section 4.5, which discusses bounding the depth of .eld paths. Synthesis bene.ts from the fact that \nour language of state transformers is designed to be small and succinct. The synthesized functions involve \nconstant updates, con\u00additional updates, string transformations, and collection up\u00addates. For JES and \nCrossFTP, we used the generated update functions in Jvolve [14] and veri.ed that the system contin\u00adued \nrunning correctly following the update. We were unable to get Azureus and jEdit to run reliably using \nthe Jvolve VM, but this was not due to Jvolve: the Jikes RVM, on which Jvolve is based, does not run \nthem properly either. Since we could not run the Azureus and jEdit updates, we per\u00adformed a manual code \nreview of the transformers produced by our synthesis algorithm to check that they matched what we would \nhave written by hand. TOS fails in two cases to synthesize update functions because we could not generate \nsnapshots that captured the changed behavior; we discuss these situations, and all of the updates, in \ndetail below. Azureus update SVN r2514 Azureus is a widely used Bit-Torrent server/client. Version r2514 \ncontains about 250k lines of code. This update changes two classes and meth\u00adods. Figure 11 shows a portion \nof the update. The added call to clearServerAdapter nulls the adapter .eld of the server object when \na peer server is stopped; doing so ensures the adapter is garbage collected. When we apply this update \nat run-time, we would like it to retroactively null adapter .elds that the buggy version neglected to. \nTOS facilities doing so by synthesizing a transformer for PEPeerControlImpl objects. To generate the \nsnapshots, we ran both program versions in a controlled setting and had them download the same set of \n.les. TOS performs matching on PEPeerControlImpl objects. The program contains one such object for each \n.le it downloads. Matching chooses key .eld nbPieces, which is a value proportional to the .le size that \nis highly likely to be unique across different .les. Synthesis then observes that for these matching \nob\u00adjects the new versions server.adapter .eld is null when server.bContinue is false, but the two versions \nmatch on the server.adapter .eld otherwise. It then infers the following conditional transformer, which \nhas the effect of freeing the leaked objects: if ( bContinue == false) server.adapter = null; else server.adapter \n= server old.adapter; Note that to generate this transformation function requires using .eld paths instead \nof single .elds (cf. Section 4.5). Azureus update SVN r120 Figure 12 shows update r120 to Azureus. This \nupdate modi.es the condition under which Azureus releases the read buffer between a client and its peer. \nThere are two issues with using TOS to infer this update. The .rst is that the read buffer does not contain \na natural key .eld. Each buffer is identical and does not have a pointer back to the object using it. \nThis problem manifests as a failure in the matching process. In such a case, one might consider adding \na ghost .eld that records the allocation order and using this as a key .eld to match objects. Matching \nsucceeds with this addition. However, the assignment of  class PEPeerControlImpl {PESharedPortServerImpl \nserver; boolean bContinue; ... void stopAll () { ... // 3. Stop the server server.stopServer(); + server.clearServerAdapter(); \n} ... } class PESharedPortServerImpl { void clearServerAdapter() {adapter = null; }} Figure 11. Azureus \nr2514 update public class PeerSocket ... { ... // 4. release the read Buffer - if (readBuffer != null \n&#38;&#38; !readingLength) + if (readBuffer != null) ByteBufferPool.getInstance().freeBuffer(readBuffer); \n... } Figure 12. Azureus update r120 buffers to clients varies across runs (and is unrelated to allocation \norder), which causes synthesis to fail, since the ith buffer is not associated with the same client in \neach run. This transformation is thus not inferable from the objects themselves, which is a limitation \nof our approach. However, it is not surprising that, on occasion, suf.cient information for transformation \nis not available from the heap. jEdit JEdit is a text editor for programmers that provides common and \nadvanced features, such as syntax highlight\u00ading, folding, automatic indentation, a built-in macro lan\u00adguage, \nmacro recording, and plugin support. Here we con\u00adsider two similar memory leaks .xed in jEdit versions \nr5178 and r14027. Figure 13 shows the source patch for the leak .xed in r14027. jEdit calls the function \nmarkTokens when it needs to split a string into tokens based on the type of the .le being edited. Each \n.le type (C, Java, Verilog, etc.) has special logic to split text in a line and embed it in an object \nof type TokenHandler. The leaky jEdit version fails to set the .eld TokenMarker.tokenHandler to null. \nThe inferred object transformer is simple. It sets the leaky .eld to null. It is safe to execute the \ntransformer as long as the markTokens function is not active on stack. Figure 14 shows a change to jEdit \nin SVN revision r13413. The leak is in function HistoryText.showPopupMenu(). jEdit calls showPopupMenu() \nwhen the user performs certain actions, such as right clicking a text .eld with history. In the old version, \nsome instances of HistoryText have the boolean .eld popup.visible set to true and others set it to false. \nIn the new version, the .eld popup is not null only when an ob\u00adject also has its popup.visible .eld set \nto true. TOS can infer class TokenMarker {public LineContext markTokens(...) { ... tokenHandler.setLineContext(context); \n/* for GC. */ + this.tokenHandler = null; this. line = null; return context; } } Figure 13. Update r14027 \nto jEdit  class HistoryText {showPopupMenu() {if (popup != null &#38;&#38; popup.isVisible()) { popup.setVisible(false \n); + popup = null; return; } - popup = new JPopupMenu(); + popup = new JPopupMenu() { + @Override + \npublic void setVisible(boolean b) { + if (! b) { + popup = null; + } + super.setVisible(b); + } \n + }; JMenuItem caption = new JMenuItem(jEdit.getProperty(  history.caption )); caption.addActionListener(new \nActionListener() }} Figure 14. Update to jEdit: SVN revision r13413 class DataConnectionCon.g { ... \n+ boolean enableBonjour = true; + String listEncoding = utf-8 ;  } Figure 15. Update to CrossFTP in \nversion 1.07 this property and generate a transformer that nulls the popup .eld of instances that have \npopup.visible set to false. How\u00adever, while creating snapshots we were unable to create a situation where \npopup.isVisible () was true during a snapshot, which would execute instructions controlled by the condi\u00adtion \nand exercise the leak. This update is an example that TOS is capable of handling, but for which we fail \ndue to test coverage problems. JavaEmailServer (JES) The collection update is the one discussed in Section \n2 and presented in Figure 3. We automatically generate a correct update function for it.  The constant \nupdate involves the addition of a new .eld deliveryAttemptThreshold. This value controls how many times \nJES should try to deliver a message before discarding the message. We automatically generate an initializer \nthat sets this to the default value. This default value is not present in the code, but rather in a con.guration \n.le that is read dur\u00ading JES start-up. Thus it would not have been discovered by other approaches to \ntransformer generation. CrossFTP In this Java-based FTP server, the DataConnec\u00adtionCon.g class maintains \ncon.guration information about the connection between the client and the server. Its .elds control what \nresponse the server sends to various commands a client issues. Version 1.07 of CrossFTP adds two new \n.elds to this class. The boolean .eld enableBonjour con\u00adtrols whether the server should support the Bonjour \nprotocol and the String .eld listEncoding speci.es what encoding the server should use when responding \nto the LIST command. There is always only one instance of this object in the heap. From the heap snapshots, \nTOS identi.es the value of these .elds in the new version and generates the transformation function that \nsets these .elds accordingly. For version 1.06, we consider three .eld updates, two of which involve \ncopying the old version to the new and one of which involves a constant initializer. The copy cases involve \n.elds whose access modi.ers have changed. In such cases, simply copying the old value to the new is a \ngood heuristic and this transformer would be generated automatically by Jvolve. Our system also generates \nthe transformer but pro\u00advides the added assurance that this update is consistent with the states observed \nwhen running the old and new versions. In version 1.08, the default port used by a SocketFactory object \nis changed. We provide TOS with three snapshots at each version two in which non-default ports are con.gured \nand one that has no port con.gured and thus falls back on the default port. TOS is able to synthesize \nthe conditional transformer that changes the port to the new default value if it was set to the old default \nvalue and leaves it unchanged otherwise. Discussion These .rst experiments with TOS show that good results \ncan be obtained when matching and synthe\u00adsis work in harmony. If either step fails then TOS fails for \nthe targeted class. But if matching identi.es key .elds then synthesis-based matching can be avoided \nor reduced and low TOS run times are observed. For the examples we consid\u00adered, most objects do have \nkey .elds that matching identi.es and uses to produce good examples for synthesis. Although it seems \nintuitive that most programs will encode suf.cient state in changed classes to make matching practical, \nfuture work should explore this question more thoroughly. Our syn\u00adthesis language is relatively simple, \nwhich eases synthesis, yet it includes common string and data functions. Future work should explore if \nthe current synthesis language has suf.cient coverage on a wider range of programs. 6. Related work This \npaper contributes novel matching and synthesis algo\u00adrithms. The matching algorithm analyzes unstructured \nheap snapshots from different program version executions. While some recent prior work analyzes a single \nheap to discover leaked objects and other inef.ciencies [2, 3, 9, 11, 12, 15], none aligns heap objects \nfrom different program versions or considers how to .x the effects of leaks on the .y. A lot of related \nwork considers synthesizing code from speci.cations, but only recently have researchers consid\u00adered the \nproblem of synthesizing data transformation func\u00adtions. The closest related work is by Gulwani and others \non synthesizing string and Excel spreadsheet data transfor\u00admations. These approaches require users to \ndirectly specify the input/output examples whereas TOS requires users to run the same test on both program \nversions from which ex\u00adamples are inferred by matching. Gulwani s algorithm [5] synthesizes string functions \nthat include concatenation, sub\u00adsequence, and .nding special symbols. TOS uses this algo\u00adrithm as a subroutine \nas part of synthesizing transformations between objects (cf. Section 4.3). Harris and Gulwani [6] generate \ntransformations between spreadsheets; their nu\u00admeric transformations and .lters are similar to ours. \nThey also search structured spreadsheet data to .nd correlation be\u00adtween the input and output rows and \ncolumns. Our matching phase serves a similar purpose, but once objects are paired up, synthesis follows \nthe structure of the new-version ob\u00adject, assigning its .elds one at a time. A unique feature of TOS \nis that it iterates synthesis and matching to produce transformers for collections of objects. Many prior \ndynamic updating systems, including Gin\u00adseng [13], DLpop [8], POLUS [4], and Jvolve [14], provide primitive \nsupport for generating state transformation code. For changes that extend classes or structs with new \n.elds, these systems simply copy the old .elds and initialize the new ones with default values, e.g., \nnull for object references, or 0 for ints. Systems that provide no direct support for state transformation, \ne.g., LiveRebel [16], effectively take this approach. In all of these cases, synthesis is based en\u00adtirely \non comparing the de.nitions of changed types/classes. None of them consider program semantics by analyzing \nthe code or the heap. By contrast, TOS obtains semantic infor\u00admation from program execution to derive \ndata transforma\u00adtions. In short, while prior systems remove some of the te\u00addium of writing transformation \nfunctions, they fail to handle any interesting program changes, which are exactly the cases which are \nharder for programmers to write correctly. 7. Conclusions This paper has presented Targeted Object Synthesis \n(TOS), a novel technique that synthesizes object transformer meth\u00adods. Object transformers convert old \nversion objects to new ones during a dynamic software update. TOS is distin\u00adguished by its generality: \nwhereas prior techniques for syn\u00adthesizing object transformers follow simple syntactic rules, TOS produces \nfunctions based on observations of actual pro\u00adgram executions of the old and new program versions. In \npar\u00adticular, TOS takes periodic heap snapshots at corresponding points during executions of the old and \nnew program when executing the same inputs. It then matches corresponding objects between these snapshots, \nand uses these as examples to synthesize object transformation functions. We show TOS is ef.cacious in \nsynthesizing transformation functions for actual changes to classes in various Java server applications. \nEven when it fails to generate a correct transformer, the partial results may be useful to developers. \nThis function\u00adality eases, but does not eliminate, the programmer burden of understanding program changes \nand performing dynamic software updating. TOS may also be useful for other version and program understanding \nscenarios, such as bug detection and testing.  Acknowledgments We thank the anonymous reviewers for \nhelpful comments on drafts of this paper. This work is sup\u00adported by NSF grants CCF-0910530, CCF-1018271 \nand SHF-0910818 and the partnership between UMIACS and the Laboratory for Telecommunication Sciences. \nAny opin\u00adions, .ndings and conclusions expressed herein are the au\u00adthors and do not necessarily re.ect \nthose of the sponsors. References [1] J. Arnold and F. Kaashoek. Ksplice: Automatic rebootless kernel \nupdates. In EuroSys, 2009. [2] M. D. Bond and K. S. McKinley. Bell: Bit-Encoding Online Memory Leak Detection. \nIn ASPLOS, 2006. [3] M. D. Bond and K. S. McKinley. Leak pruning. In ASPLOS, 2009. [4] H. Chen, J. Yu, \nR. Chen, B. Zang, and P.-C. Yew. POLUS: A POwerful Live Updating System. In ICSE, 2007. [5] S. Gulwani. \nAutomating string processing in spreadsheets using input-output examples. In POPL, 2011. [6] W. R. Harris \nand S. Gulwani. Spreadsheet table transforma\u00adtions from examples. In PLDI, 2011. [7] C. M. Hayden, E. \nK. Smith, E. A. Hardisty, M. Hicks, and J. S. Foster. Evaluating dynamic software update safety using \nef.cient systematic testing. IEEE Transactions on Software Engineering, 99(PrePrints), Sept. 2011. [8] \nM. Hicks and S. M. Nettles. Dynamic Software Updating. Transactions on Programming Languages and Systems, \n27(6): 1049 1096, November 2005. [9] M. Jump and K. S. McKinley. Cork: Dynamic Memory Leak Detection \nfor Java. In POPL, 2007. [10] K. Makris and R. Bazzi. Immediate Multi-Threaded Dynamic Software Updates \nUsing Stack Reconstruction. In USENIX ATC, 2009. [11] N. Mitchell and G. Sevitsky. The causes of bloat, \nthe limits of health. In OOPSLA, 2007. [12] N. Mitchell and G. Sevitzky. LeakBot: An Automated and Lightweight \nTool for Diagnosing Memory Leaks in Large Java Applications. In ECOOP, 2003. [13] I. Neamtiu, M. Hicks, \nG. Stoyle, and M. Oriol. Practical Dynamic Software Updating for C. In PLDI, 2006. [14] S. Subramanian, \nM. Hicks, and K. S. McKinley. Dynamic Software Updates: A VM-centric Approach. In PLDI, 2009. [15] G. \nXu and A. Rountev. Detecting inef.ciently-used containers to avoid bloat. In PLDI, 2010. [16] ZeroTurnaround. \nLiveRebel. http://www. zeroturnaround.com/liverebel.   \n\t\t\t", "proc_id": "2384616", "abstract": "<p>Dynamic software updating (DSU) systems eliminate costly downtime by dynamically fixing bugs and adding features to executing programs. Given a static code patch, most DSU systems construct runtime code changes automatically. However, a dynamic update must also specify how to change the running program's execution state, e.g., the stack and heap, to make it compatible with the new code. Constructing such state transformations correctly and automatically remains an open problem. This paper presents a solution called Targeted Object Synthesis (TOS). TOS first executes the same tests on the old and new program versions separately, observing the program heap state at a few corresponding points. Given two corresponding heap states, TOS matches objects in the two versions using key fields that uniquely identify objects and correlate old and new-version objects. Given example object pairs, TOS then synthesizes the simplest-possible function that transforms an old-version object to its new-version counterpart. We show that TOS is effective on updates to four open-source server programs for which it generates non-trivial transformation functions that use conditionals, operate on collections, and fix memory leaks. These transformations help programmers understand their changes and apply dynamic software updates.</p>", "authors": [{"name": "Stephen Magill", "author_profile_id": "81384619914", "affiliation": "IDA Center for Computing Sciences, Bowie, MD, USA", "person_id": "P3856080", "email_address": "sbmagil@super.org", "orcid_id": ""}, {"name": "Michael Hicks", "author_profile_id": "81100060959", "affiliation": "University of Maryland, College Park, College Park, MD, USA", "person_id": "P3856081", "email_address": "mwh@cs.umd.edu", "orcid_id": ""}, {"name": "Suriya Subramanian", "author_profile_id": "81435597339", "affiliation": "Intel Corporation, Santa Clara, CA, USA", "person_id": "P3856082", "email_address": "suriya@alumni.cs.utexas.edu", "orcid_id": ""}, {"name": "Kathryn S. McKinley", "author_profile_id": "81100402805", "affiliation": "Microsoft Research &#38; The University of Texas at Austin, Redmond, WA, USA", "person_id": "P3856083", "email_address": "mckinley@cs.utexas.edu", "orcid_id": ""}], "doi_number": "10.1145/2384616.2384636", "year": "2012", "article_id": "2384636", "conference": "OOPSLA", "title": "Automating object transformations for dynamic software updating", "url": "http://dl.acm.org/citation.cfm?id=2384636"}