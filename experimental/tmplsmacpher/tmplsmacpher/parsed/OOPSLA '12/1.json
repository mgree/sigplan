{"article_publication_date": "10-19-2012", "fulltext": "\n Uniqueness and Reference Immutability for Safe Parallelism Colin S. Gordon , Matthew J. Parkinson , \nJared Parsons0, Aleks Brom.eld0, Joe Duffy0 University of Washington, Microsoft Research Cambridge, 0Microsoft \nCorporation csgordon@cs.washington.edu, {mattpark,jaredpar,albrom.,joedu}@microsoft.com Abstract A key \nchallenge for concurrent programming is that side\u00adeffects (memory operations) in one thread can affect \nthe be\u00adhavior of another thread. In this paper, we present a type sys\u00adtem to restrict the updates to \nmemory to prevent these unin\u00adtended side-effects. We provide a novel combination of im\u00admutable and unique \n(isolated) types that ensures safe paral\u00adlelism (race freedom and deterministic execution). The type \nsystem includes support for polymorphism over type quali\u00ad.ers, and can easily create cycles of immutable \nobjects. Key to the system s .exibility is the ability to recover immutable or externally unique references \nafter violating uniqueness without any explicit alias tracking. Our type system models a prototype extension \nto C# that is in active use by a Mi\u00adcrosoft team. We describe their experiences building large systems \nwith this extension. We prove the soundness of the type system by an embedding into a program logic. \nCategories and Subject Descriptors D.3.3 [Language Constructs and Features]: Concurrent programming struc\u00adtures; \nF.3.2 [Semantics of Programming Languages]: Pro\u00adgram Analysis General Terms Languages, Veri.cation Keywords \nreference immutability, type systems, concur\u00adrency, views 1. Introduction In concurrent programs, side-effects \nin one thread can affect the behavior of another thread. This makes programs hard to understand as programmers \nmust consider the context in which their thread executes. In a relaxed memory setting even understanding \nthe possible interactions is non-trivial. We wish to restrict, or tame, side-effects to make pro\u00adgrams \neasier to maintain and understand. To do so, we build Permission to make digital or hard copies of all \nor part of this work for personal or classroom use is granted without fee provided that copies are not \nmade or distributed for pro.t or commercial advantage and that copies bear this notice and the full citation \non the .rst page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires \nprior speci.c permission and/or a fee. OOPSLA 12, October 19 26, 2012, Tucson, Arizona, USA. Copyright \nc &#38;#169; 2012 ACM 978-1-4503-1561-6/12/10. . . $10.00 on reference immutability [37, 39, 40], which \nuses permis\u00ad sion type quali.ers to control object mutation. Typically there are notions of writable \nreferences (normal access), read-only references (objects may not be mutated via a read\u00adonly reference, \nand .eld reads from read-only references produce read-only references), and immutable references (whose \nreferents may never be changed through any alias). There are many applications of this approach to controlling \nside effects, ranging from improving code understanding to test generation to compiler optimization. \nWe add to reference immutability a notion of isolation in the form of an extension to external uniqueness \n[23]. We support the natural use of isolation for object immutabil\u00adity (making objects permanently immutable \nthrough all ref\u00aderences). But we also show a new use: to recover isola\u00adtion or strengthen immutability \nassumptions without any alias tracking. To achieve this we give two novel typing rules, which allow recovering \nisolated or immutable refer\u00adences from arbitrary code checked in environments contain\u00ading only isolated \nor immutable inputs. We provide two forms of parallelism: Symmetric Assuming that at most one thread \nmay hold writable references to an object at a given point in time, then while all writable references \nin a context are tem\u00adporarily forgotten (framed away, in the separation logic sense [29, 33]), it becomes \nsafe to share all read-only or immutable references among multiple threads, in ad\u00addition to partitioning \nexternally-unique clusters between threads. Asymmetric If all data accessible to a new thread is im\u00admutable \nor from externally-unique clusters which are made inaccessible to the spawning thread, then the new and \nold threads may run in parallel without interference. We provide an extended version of the type system \nwith polymorphism over reference immutability quali.ers. This maintains precision for instantiated uses \neven through rich patterns like iterators, which was not possible in previous work [39]. There are several \naspects of this work which we are the .rst to do. We are the .rst to give a denotational meaning to reference \nimmutability quali.ers. We are the .rst to formal\u00adize the use of reference immutability for safe parallelism. \nWe Figure 1. External uniqueness with immutable out\u00adreferences.  are the .rst to describe industry \nexperience with a reference immutability type system. 2. Reference Immutability, Uniqueness, and Parallelism \nReference immutability is based on a set of permission\u00adquali.ed types. Our system has four quali.ers: \nwritable: An ordinary object reference, which allows mu\u00adtation of its referent. readable: A read-only \nreference, which allows no mu\u00adtation of its referent. Furthermore, no heap traversal through a read-only \nreference produces a writable ref\u00aderence (writable references to the same objects may exist and be reachable \nelsewhere, just not through a readable reference). A readable reference may also refer to an im\u00admutable \nobject. immutable: A read-only reference which additionally notes that its referent can never be mutated \nthrough any refer\u00adence. Immutable references may be aliased by read-only or immutable references, but \nno other kind of reference. All objects reachable from an immutable reference are also immutable. isolated: \nAn external reference to an externally-unique object cluster. External uniqueness naturally captures \nthread locality of data. An externally-unique aggregate is a cluster of objects that freely reference \neach other, but for which only one external reference into the ag\u00adgregate exists. We de.ne isolation \nslightly differently from most work on external uniqueness because we also have immutable objects: all \npaths to non-immutable ob\u00adjects reachable from the isolated reference pass through the isolated reference. \nWe allow references out of the externally-unique aggregate to immutable data because it adds .exibility \nwithout compromising our uses for iso\u00adlation: converting clusters to immutable, and support\u00ading non-interference \namong threads (see Figure 1). This change in de.nition does limit some traditional uses of externally-unique \nreferences that are not our focus, such as resource management tasks. The most obvious use for reference \nimmutability is to con\u00adtrol where heap modi.cation may occur in a program, simi\u00ad readable /\" writable \nimmutable \"/ isolated Figure 2. Quali.er conversion/subtyping lattice. lar to the owner-as-modi.er discipline \nin ownership and uni\u00adverse type systems [14]. For example, a developer can be sure that a library call \nto a static method with the type signa\u00adture int countElements(readable ElementList lst); will not modify \nthe list or its elements (through the lst reference). Accessing any .eld of the argument lst through \nthe readable reference passed will produce other readable (or immutable) results. For example, a developer \ncould not implement countElements like so: int countElements(readable ElementList lst) { lst.head = null; \nreturn 0; } because the compiler would issue a type error. In fact, any attempt within countElements() \nto modify the list would result in a type error, because lst is deeply (transitively) read-only, and \nwrites through read-only references are pro\u00adhibited. 2.1 Conversion from Isolated The isolated quali.er \nis atypical in reference immutability work, and is not truly a permission for (im)mutability in the purest \nsense. In fact, we require that isolated references be converted through subtyping to another permission \nbefore use, according to the type quali.er hierarchy in Figure 2. isolated references are particularly \nimportant in our system for two reasons. First, they naturally support safe parallelism by partitioning \nmutable data amongst threads. The threads1 in the following example cannot interfere with each other, \nbecause the object graphs they operate on and can mutate are disjoint: isolated IntList l1 = ...; isolated \nIntList l2 = ...; { l1.map(new Incrementor()); } || { l2.map(new Incrementor()); } Second, the control \nof aliasing allows conversion of whole externally-unique object clusters. If there are no external ref\u00aderences \nbesides the isolated reference, then the whole ob\u00adject graph (up to immutable objects) can be converted \nat once. An isolated reference (and object graph) can triv\u00adially be converted to writable, by essentially \nsurrendering the aliasing information: 1 We use I for structured parallelism, and the formal system does \nnot have dynamic thread creation.  isolated IntList l = ...; // implicitly update l s permission to \nwritable l.head = ...; Or an isolated graph can be converted to immutable; as with any form of strong \nupdate, the decision to treat the whole object graph as immutable is localized: isolated IntList l = \n...; // implicitly update l s permission to immutable immutable IntList l2 = l; l.head = ...; // Type \nError! The type system is .ow sensitive, so although l was initially isolated after the assignment to \nl2 it has been coerced to immutable and thus cannot be written to.  2.2 Recovering Isolation A key insight \nof our approach is that converting an isolated reference to writable does not require permanently sur\u00adrendering \nthe aliasing information. In particular, if the input type context for an expression contains only isolated \nand im\u00admutable objects, then if the output context contains a single writable reference, we can convert \nthat reference back to isolated. Consider the following method: isolated IntBox increment(isolated IntBox \nb) { // implicitly convert b to writable b.value++; // convert b *back* to isolated return b; } The .rst \nconversion from isolated to writable occurs naturally by losing aliasing information. The second conver\u00adsion \nis safe because if one writable reference is left when the initial context contained only isolated and \nimmutable references, that reference must either refer to an object that was not referenced from elsewhere \non entry, or was freshly allocated (our core language and prototype do not allow mu\u00adtable global variables). \nThis .exibility is especially useful for algorithms that re\u00adpeatedly map destructive operations over \ndata in parallel. By keeping data elements as isolated, the map operations nat\u00adurally parallelize, but \neach task thread can internally violate uniqueness, apply the updates, and recover an isolated reference \nfor the spawning context for later parallelization (Section 2.5). Recovering isolation is reminiscent \nof borrowing al\u00adlowing temporary aliases of a unique reference, often in a scope-delimited region of \nprogram text. The main advantage of recovery is that unlike all borrowing designs we are aware of, recovery \nrequires no tracking or invalidation of speci.c references or capabilities as in other work [10, 23]. \nOf course this is a result of adding reference immutability, so recovery is not a stand-alone replacement \nfor traditional borrowing; it is an additional bene.t of reference immutability. We also see two slight \nadvantages to our recovery ap\u00adproach. First, a single use of recovery may subsume multiple uses of a \nscoped approach to borrowing [30], where exter\u00ad nal uniqueness is preserved by permitting access to only \nthe interior of a particular aggregate within a lexically scoped region of code. Of course, scopeless \napproaches to borrow\u00ading exist with more complex tracking [10, 23]. Second, no special source construct \nis necessary beyond the reference immutability quali.ers already present for parallelism.  2.3 Recovering \nImmutability, and Cycles of Immutable Objects Another advantage of using isolated references is that \nthe decision to make data immutable can be deferred (arbitrar\u00adily). This makes constructing cycles of \nimmutable objects easy and natural to support. The mechanism for converting an isolated reference to \nimmutable is similar to recover\u00ading isolation, with the natural direct conversion being a spe\u00adcial case. \nIf the input context when checking an expression contains only isolated and immutable references, and \nthe output context contains one readable reference (or in gen\u00aderal, multiple readable references), then \nthe readable refer\u00adent must be either an already-immutable object or an object not aliased elsewhere \nthat it is safe to now call immutable. The simplest case of this (equivalent to direct conversion) is \nto frame away all references but one, convert to readable, and then recover immutability: immutable IntBox \nfreeze(isolated IntBox b) { // implicitly convert b to readable // implicitly recover immutability; // \nthe input context was all isolated return b; } Creating cycles of immutable objects is then simply a \nmatter of restricting the input to a conversion to only isolated and immutable data, then recovering. \nThis can even include recovering immutability from regular code: // The default permission is writable \nCircularListNode make2NodeList() { CircularListNode n1 = new CircularListNode(); CircularListNode n2 \n= new CircularListNode(); n1.next = n2; n1.prev = n2; n2.next = n1; n2.prev = n1; return n1; } ... immutable \nl = make2NodeList(); Here the method has no inputs and it returns a writable value, so at the call site \nanything it returns can be consid\u00adered readable, then recovered to immutable (or directly recovered to \nisolated). Prior reference immutability systems [39] required build\u00ad ing immutable cyclic data structures \nin the constructor of one object, using extensions to pass a partially-initialized object during construction \nas (effectively) immutable to the con\u00adstructor of another object. Our use of isolated with recov\u00adery \nmeans we do not need to explicitly model the initializa\u00adtion period of immutable structures.  While \nwe have been using closed static method de.ni\u00adtions to illustrate the recovery rules, our system includes \na frame rule [29, 33], so these conversions may occur in local\u00ad ized sections of code in a larger context. \n 2.4 Safe Symmetric Parallelism Fork-join concurrency is deterministic when neither forked thread interferes \nwith the other by writing to shared memory. Intuitively, proving its safe use requires separating read \nand write effects, as in Deterministic Parallel Java (DPJ) [4]. With reference immutability, a simpler \napproach is available that does not require explicit region management, allowing much of the same expressiveness \nwith simpler annotation (see Section 7). If neither forked thread requires any writable reference inputs \nto type check, then it is safe to parallelize, even if the threads share a readable reference to an object \nthat may be mutated later, and even if threads receive isolated references. x = new Integer(); x.val \n= 3; y = x; z = x; // y and z are readable aliases of x a = new Integer(); b = new Integer(); // a and \nb are isolated // frame away writable references (x) a.val = y.val; || b.val = z.val; // get back writable \nreferences (x) x.val = 4; After joining, x may be unframed and the code regains writable access to it. \nSafety for this style of parallelism is a natural result of reference immutability, but proving it sound \n(race free) requires careful handling of coexisting writable references to the temporarily-shared objects. \nWe require that each thread in the parallel composition re\u00adceives disjoint portions of the stack, though \nricher treatments of variable sharing across threads exist [31, 32].  2.5 Safe Asymmetric Parallelism \nC# has an async construct that may execute a block of code asynchronously via an interleaving state machine \nor on a new thread [3], and returns a handle for the block s result in the style of promises or futures. \nA common use case is asynchronously computing on separated state while the main computation continues. \nOur formal system models the asymmetric data sharing of this style of use on top of structured parallelism. \nThe formal system (Section 3) does not model the .rst-class join; in future work we intend to extend \nthis rule to properly isolate async expressions. A natural use for this style of parallelism is to have \nthe asynchronous block process a limited data set in parallel with a main thread s execution. One de.nition \nof limited is to restrict the worker thread to isolated and immutable data, allowing the main thread \nto proceed in parallel while retaining writable references it may have. writable Integer x = ...; // \nconstruct isolated list of isolated integers y = new IsolatedIntegerList(); ... // populate list f = \nnew SortFunc(); // Sort in parallel with other work y.map(f); || x.val = 3; This code also demonstrates \nthe .exibility of combining the rules for recovering isolated or immutable references with parallelism. \nIn the left thread, f and y are both isolated on entry, and the rule for recovering an isolated reference \ncan be applied to y at that thread s .nish. Thus, when the threads join, y is again isolated, and suitable \nfor further parallelization or full or partial conversion to immutable. 3. Types for Reference Immutability \nand Parallelism We describe a simple core imperative, object-oriented lan\u00adguage in Figure 3. Commands \n(statements) include standard .eld and variable assignments and reads, sequencing, loops, non-deterministic \nchoice (to model conditional statements) and fork-join style parallelism. Our language also includes \na destructive read, x = consume(y.f), which reads the .eld, y.f, stores its value in x, and then updates \nthe .eld to null. Our types include primitive types and permission-quali.ed class types. We include the \nfour permissions from Section 2: readable, writable, isolated, and immutable. This section focuses on \nthe language without methods, which are added in Section 3.3. Polymorphism, over both class types and \npermissions, is described in Section 5. One of our primary goals for this core system is to under\u00adstand \nthe design space for source languages with reference immutability and concurrency in terms of an intermediate\u00adlevel \ntarget language. This approach permits understanding source-level proposals for typing higher level language \nfea\u00adtures (such as closures) in terms of translation to a well\u00adtyped intermediate form (such as the function \nobjects C# closures compile into), rather than independently reasoning about their source level behavior. \nThe heart of reference immutability is that a reference s permission applies transitively. Any new references \nacquired through a reference with a given permission cannot allow modi.cations that the root reference \ndisallows. We model this through a permission combining relation [, borrowing intuition and notation \nfrom universe types viewpoint adap\u00adtation [14]. We de.ne [ and lift it to combining with types in Figure \n3. Generally speaking, this relation propagates the weak\u00adest, or least permissive, permission. Notice \nthat there are no permission-combining rules for isolated receivers and non-immutable .elds; this re.ects \nthe requirement that ac\u00adcessing an isolated object graph generally requires upcast\u00ading variables .rst \nand accessing isolated .elds requires destructive reads. Also notice that any combination involv\u00ad  Metavariables \nSyntax a atoms a ::= C command (statement) | x = y w, x, y, z variables | x.f = y t, u types | x = y.f \nT, U class type | x = consume(y.f) T D class type declaration | x = y.m(z1, ..., zn) cn class name | \nx = new t() p permission | return x fld .eld declaration meth method declaration f, g .eld names m method \nnames n, i, j nat (indices) ::= a | skip | C; C | C + C | CIC | C * p ::= readable | writable | immutable \n| isolated T ::= cn TD ::= class cn [<: T 2] {field * meth*} fld ::= t fn meth ::= tm(t1 x1, ..., tn \nxn)p{ C; return x; }t ::= int | bool | pT G ::= E | G,x : t [ : Permission . Permission . Permission \nimmutable [ = immutable [ immutable = immutable readable [ writable = readable readable [ readable = \nreadable writable [ readable = readable writable [ writable = writable p [ int = int p [ bool = bool \n'' p [ (pT )=(p [ p) T Figure 3. Core language syntax. ing immutable permissions produces an immutable \npermis\u00adsion; any object reachable from an immutable object is also immutable, regardless of a .eld s \ndeclared permission. We use type environments G, and de.ne subtyping on en\u00advironments (f G -G) in terms \nof subtyping for permissions (f p -p), class types (f T -T ), and permission-quali.ed types (f t -t) \nin Figure 4. Figure 5 gives the core typing rules. These are mostly standard aside from the treatment \nof unique references. A destructive .eld read (T-FIELDCONSUME) is fairly stan\u00addard, and corresponds dynamically \nto a basic destructive read: as the command assigns null to the .eld, it is sound to return an isolated \nreference. Writes to isolated .elds (T-FIELDWRITE) and method calls with unique arguments (T-CALL) treat \nthe isolated input references as af.ne re\u00adsources, consumed by the operation. We use a metafunction RemIso() \nto drop used isolated references: f p -p f p -readable f isolated -p class c<: d {fld meth }. P S-DECL \nf c -d f p -p' f T -T ' S-PERM S-TYPE f pT -p' T f pT -pT ' f t1 -t2 f t2 -t3 f t1 -t2 S-REFLEXIVE S-TRANS \nf t -t f t1 -t3 f G -G' f t -t' S-EMPTY ' S-CONS f G -G' E -E f G,x : t -G',x : tf G -G' S-DROP f G,x \n: t -G' Figure 4. Subtyping rules RemIso() : G . G RemIso(G) = .lter (.x. x )G = isolated This is a \nslight inconvenience in the core language, but the implementation supports consume as a .rst class effect\u00adful \nexpression. The method rule is otherwise straightforward aside from calls on isolated receivers (Section \n3.3). We also provide structural rules to allow these rules to be used in more general contexts (last \ntwo rows of Figure 5). The def\u00ad inition of well-formed programs is mostly standard (shown in our technical \nreport [20]), aside from requiring covariant method permissions for method overrides (Figure 6). 3.1 \nRecovery Rules Figure 7 gives the two promotion rules from Sections 2.2 and 2.3 that are key to our system \ns .exibility: the rules for recovering isolated or immutable references, used for both precision and \nconversion. These rules restrict their in\u00adput contexts to primitives, externally unique references, and \nimmutable references. The T-RECOVISO, checks the vari\u00adable in the premise x must either be null, or point \ninto a freshly-allocated or previously present (in G) object aggre\u00adgate with no other references, and \nthus it is valid to consider it isolated. Similarly T-RECOVIMM checks suf.cient prop\u00aderties to establish \nthat it is safe to consider it immutable. In practice, using these relies on the frame rule (Figure 5). \nWithout reference immutability, such simple rules for re\u00adcovery (sometimes called borrowing) would not \nbe possi\u00adble. In some sense, the information about permissions in the rules input contexts gives us permissions \nfor free. We may essentially ignore particular permissions (isolation) for a block of commands, because \nknowledge of the input context ensures the writable or readable output in each premise is suf.ciently \nseparated to convert if necessary (tak\u00ading advantage of our slight weakening of external unique\u00adness \nto admit references to shared immutable objects). Sec\u00adtion 4.2 elaborates on the details of why we can \nprove this f p -p' f T -T '  t = isolated T-ASSIGNVAR T-NEW x : ,y : t f x = y y : t, x : t f x = new \nT () x : isolated T G1 f C G2 ' '' tf . Tp = immutable t . p = immutable = isolated . t = isolated T-FIELDREAD \n x : ,y : pT f x = y.f y : p T,x : p [ t ' tf . T T-FIELDWRITE y : writable T,x : t f y.f = x y : writable \nT, RemIso(x : t) isolated Tf f . T T-FIELDCONSUME y : writable T f x = consume(y.f) y : writable T,x \n: isolated Tf T-INT T-BOOL T-NULL x : f x = n x : int x : f x = b x : bool x : f x = null x : pT '' ' \ntm(u ' z ' ) p . T f p -p f u -u ' p = isolated =t= readable . t . IsoOrImm(z : t) . p '= immutable . \n= writable T-CALL y : p T, z : u f x = y.m(z) y : p T, RemIso(z : t),x : t ' -G ' G1 ' f C G ' G ' \nG11 22 -G2 G1 f C G2 G f C G T-SUBENV T-FRAME T-LOOP G1 f C G2 G, G1 f C G, G2 G f C* G ' f C G '' G1 \nf C1 G2 G2 f C2 G3 G1 f C1 G2 G1 f C2 G2 G,y : t ,x : t, G ' T-SEQ T-BRANCH T-SHUFFLE ' f C G '' G1 \nf C1; C2 G3 G1 f C1 + C2 G2 G,x : t, y : t, G ' Figure 5. Core typing rules. '' '' TD = class cn [<: \nT 2] {fld meth } tm(t ' x ') p . T 2 P f t -tP f p -pP f t ' -t p .i . [1 ...n].P f ti P f t this : p \ncn, tx f C; return x result : t = isolated T-METHOD2 P ; TD f tm(tx) p { C; return x; } Figure 6. Method \noverride de.nition typing IsoOrImm(G) IsoOrImm(G ' ) G f C G ' , x : writable T G f C G ' , x : isolated \nT T-RECOVISO IsoOrImm(G) IsoOrImm(G ' ) G f C G ' , x : readable T G f C G ' , x : immutable T T-RECOVIMM \ndef where IsoOrImm(G) = .(x : pT ) . G. f p -immutable Figure 7. Recovery rules is sound. Additionally, \nthe permission quali.cations spec\u00adify which references may safely interact with an externally\u00adunique \naggregate, and which must be prevented from inter\u00adacting via the frame rule (readable and writable refer\u00adences). \nThis distinction normally requires precise reasoning about aliases.  3.2 Safe Parallelism Figure 8 gives \nthe rules for safe parallelism. They ensure data race freedom, and therefore (for the concurrency prim\u00aditives \nwe provide) deterministic execution. T-PAR corre\u00adsponds to safe symmetric parallelism, when all writable \nreferences are framed out. The second rule T-ASYNC cor\u00ad NoWrit(G1) NoWrit(G2)G1 f C1 G ' 1 G2 f C2 G \n' 2 T-PAR G1, G2 f C1||C2 G ' 1, G ' 2 IsoOrImm(G1)G1 f C1 G ' G2 f C2 G ' 12 T-ASYNC G1, G2 f C1||C2 \nG ' 1, G ' 2 def where NoWrit(G) = .(x : pT ) . G.p= writable Figure 8. Type rules for safe parallelism. \nIsoOrImm is de\u00ad.ned in Figure 7 responds to the safety criteria for asymmetric parallelism (named for \nC# s async block). This rule obviously produces structured parallelism, not the unstructured task-based \ncon\u00adcurrency present in C#. But it models the state separation required for safe task parallelism: all \ninput to a task must be isolated or immutable. The implementation provides safe task parallelism of this \nform, as described in Section 6.1, as well as structured parallelism.  3.3 Methods The type rule for \na method call (T-CALL) is shown in Fig\u00adure 5. It is mostly standard (the method exists in the receiver \ntype, actual arguments are subtypes of formal arguments), with a couple of complications. First, isolated \nactual ar\u00adguments are forgotten by the typing context, in lieu of ex\u00adtending the method syntax for destructive \nreads.  Second, methods have required calling permissions, which restrict the side effects a method \nmay have on the receiver. The permission on the receiver at the call site must be at least as permissive \nas the required permission (e.g., a program cannot call a writable method on a readable receiver). This \nis standard for reference immutability [37, 39, 40]. Finally, additional restrictions apply when the \nreceiver is isolated. Intuitively, no isolated method may return an alias to an object inside its isolation \nbubble; alternatively, the re\u00adstrictions ensure that an inlined method body is suitable for upcasting \nthe isolated receiver s permission, executing, and .nally applying T-RecovIso. Because no method is type \nchecked with this : isolated T (by T-METHOD* in Figure 6 and our technical report [20], no method may \nrequire an isolated receiver permission), no method may leverage recovery rules (Figure 7) to recover \nan isolated or immutable reference to its receiver. Thus any meth\u00adods returning primitives (int and bool) \nor isolated or immutable references is returning a value that does not vi\u00adolate external uniqueness for \nthe receiver s bubble.  3.4 Examples For brevity, because the type environment is .ow sensitive, we \nwrite typing derivations in the same style as a proof in a program logic, with pre-and post-conditions \nof a statement in braces before and afterwards. Unmarked adjacent asser\u00adtions represent use of the rule \nof implication (subtyping). Uses of other transformation rules are labeled. In Section 4, it will become \nclear how this style directly models the cor\u00adresponding proof of type checking in the program logic. \n3.4.1 Assigning an Isolated Variable Assigning an isolated variable consists of framing away outer context, \nupcasting the isolated reference to writable, assigning normally, weakening to drop the source variable, \nand an application of T-RECOVISO to recover the isolation property on the destination variable. It is \npossible to add an admissible rule for the direct consumption. It is also possible to preserve access \nto the source variable by also overwriting  3.4.2 Temporarily Violating Isolation Figure 9 shows the \ntype derivation for a simple use of the T-RECOVISO rule, adding a node to an isolated list. The inner \nportion of the derivation is not notable, simply natural use of sequencing, allocation, and .eld write \nrules. But that inner portion is wrapped by a use of subtyping, followed by recovering an isolated reference. \nUsing T-RECOVIMM to recover an immutable reference would be similar, using a readable reference to the \nlist after the updates. 4. Type Soundness To prove soundness, we must de.ne the dynamic language semantics \nand relate the typing rules. The dynamic seman\u00adtics for commands C are standard small step operational \nse\u00admantics over the states we de.ne below, so we omit them here. The operational rule for reducing an \natom a appeals to a denotational semantics of atoms, which is de.ned in an entirely standard way and \ntherefore also omitted (method calls have some subtlety, but conform to standard intuition of evaluating \nmethod calls by inlining method bodies, fully de\u00adtailed in our technical report [20]). We relate the \ntype rules to the semantics by de.ning a denotation of type environments in terms of an extended machine \nstate. We de.ne abstract machine states as: def S = Stack \u00d7 Heap \u00d7 TypeMap def def where Stack = Var \n-Val and is ranged over by s, Heap = def OID\u00d7Field -Val and is ranged over by h, and TypeMap= OID -Class \nand is ranged over by t. We only consider well-typed states. To de.ne well-typed states, we assume a \nfunction that gives the type and permis\u00adsion for each .eld of each class, re.ects inheritance of .elds, \nand in Section 5 handles instantiating .eld types of polymor\u00ad phic types: FType : Class \u00d7 Field . Type \nWe can describe a state (s, h, t) as well-typed iff WellTyped(s, h, t)= .o, f. (.v. h(o, f)= v) .. (.ft. \nFType(t(o),f)= ft) it with a primitive value such as null, which is equivalent to an encoding of a traditional \ndestructive read on a variable. . ..ft. FType(t(o),f)= ft ft = pc ' . h(o, f)= null =.f t(h(o, f)) -c \n' . ft = bool =..b. h(o, f)= b . ft = int =..n. h(o, f )= n =. . . . . ............ . - {G,x : bool,y \n: isolated T } {x : bool,y : isolated T } The .rst conjunct requires that the type map contains a type \n . ..... - T-SUBENV T-RECOVISO T-FRAME  ......... - for every object in the heap, and vice-versa; it \nlimits the type map to the heap contents. The second conjunct simply enforces that each .eld holds well-typed \ncontents. {x : bool,y : isolated T } {x : bool,y : writable T } x = y {x : writable T,y : writable T \n} {x : writable T } Reasoning about which objects are immutable and the permissions of various references \nis somewhat dif.cult for {x : isolated T }{G,x : isolated T } such a basic state space, so we de.ne an \ninstrumented state with additional metadata: a partitioning of objects among  . - . .......................... \n. .................................. . .............................. -- {x : isolated Node,y : int,z \n: bool} {x : isolated Node,y : int,z : bool}  {x : writable Node,y : int,z : bool} {x : writable Node,y \n: int,z : bool} y=new Node(); T-ALLOC - {x : writable Node,y : writable Node,z : bool} z=x.next; . T-SEQ \n* across T-FIELDREAD and T-FIELDWRITE {x : writable Node,y : writable Node,z : writable Node} y.next=z; \nT-RECOVISO T-SUBENV {x : writable Node,y : writable Node,z : writable Node} z.prev=y;  {x : writable \nNode,y : writable Node,z : writable Node} y.prev=x;  {x : writable Node,y : writable Node,z : writable \nNode} x.next=y;  {x : writable Node,y : writable Node,z : writable Node}  {x : writable Node,y : writable \nNode,z : writable Node} {x : writable Node} {x : isolated Node}  Figure 9. Typing derivation for adding \na node to an isolated doubly-linked list. regions, and permission to each region (important for safe \nparallelism). We map each object to a region r : RegionMap = OID -Region We have three forms of region: \n Root(.) is a root region with abstract root .  Field(o, f) means the region is only accessible through \nthe isolated .eld f of object o.  Immutable means immutable We associate two permissions with each root \nregion:  p : RegionPerm = Root -Update[0, 1] \u00d7 Reference(0, 1] where Update: Is used to indicate if \nobjects in the region can be modi.ed. Full (1) means this is the case. An update permission will be split \nfor the period of a parallel com\u00adposition, as a fractional permission [9].  Reference: Is used to indicate \nwhether there is a framed\u00adout reference to this region (< 1). This prevents the con\u00adversion of a region \nto isolated or immutable when there are framed-out readable or writable references to it. Note that 0 \nreference permission is not allowed; states with no permission at all to a region do not have that per\u00admission \nin their permission map.  For both permissions, the total permission available to the program for any \ngiven region is 1. These two permission types capture two interference concepts. You can interfere with \nyourself; and you cannot interfere with other threads. Interference with other threads is prevented by \nthe update permission, only one thread can ever have an update permis\u00adsion to a region. These states \nalso satisfy a well-formedness predicates. We require instrumented states to be well-regioned: e.g. an \nimmutable reference points to an object in region Im\u00admutable, no readable or writable reference outside \na given externally unique aggregate points to an object in an isolated region, etc. We de.ne well-regioned \ngiven in Fig\u00adure 10. The .rst conjunct ensures full region information for the heap s objects. The second, \nlargest conjunct enforces re\u00adstrictions on references between regions. Intra-region point\u00aders must be \neither within the Immutable region, or following readable or writable .elds. Cross-region pointers must \nnot be pointing out of Immutable (which is closed under .eld dereference), and must either pointing into \nImmutable from .elds with appropriate permissions, an isolated .eld pointing into an appropriate Field \nregion, or a readable reference between root regions. The next conjunct requires permissions on any root \nregion, and the .nal conjunct lim\u00adits the region map s Fields to those whose entry points are present \nin the heap. We can thus de.ne an instrumented state as: m .S\u00d7 RegionMap \u00d7 RegionPerm M = | WellRegioned(m) \n. WellTyped(lmJ) where we de.ne an erasure l\u00b7J : M.S that projects in\u00adstrumented states to the common \ncomponents with S. We use m.s, m.h, m.t, m.r, and m.p to access the stack, heap, type map, region map \nand region permission map, respec\u00adtively. We view type environments denotationally, in terms of the set \nof instrumented states permitted by a given envi\u00ad  WellRegioned(s, h, t, r, p)= . . . CompleteRegionInfo(s, \nh, t, r, p). .o, f, v, p. h(o, f)= v . v . OID . FType(t(o),f)= p . [x : isolated T ] = m .M m.p(m.r(m.s(x))) \n= (1, 1) .m.t(m.s(x)) = T ' .f T ' . . . . -T ..... ..... ... = .. .RootClosed(m.r(m.s(x)),m) ... . =. \n.m.s(x)= null (r(o)= r(v) . . r(o)= Immutable . p .{readable, writable}) . (r(o)= r(v)=. ValidXRegionRef(r, \no, f, p, v)) .. [x : immutable T ] = m .M m.r(m.s(x)) = Immutable .. . (... Root . . Img(r)=. p(.)(=,>)(0, \n0)) .m.t(m.s(x)) = T ' .f T ' -T .. . (.o, f. Field(o, f) . Img(r)=. (o, f) . dom(h)) .m.s(x)= null = \n. where [x : readable T ]p m .M m.s(x)= null. ((... Up(p(.)) > 0 . Up(m.p(.)) > 0 . . .. . .. ValidXRegionRef(r, \no, f, p, v)= (r(o)= Immutable) . . . . . ... . m.r(m.s(x)) = Root .) . . . .m.r(m.s(x)) = Immutable) \n.m.t(m.s(x)) = T ' .f T ' -T ... . (r(v)= Immutable =. p .{immutable, readable}) =. p = isolated) . (r(v)= \nField(o, f) = . . . . (r(v)= Root() =. p = readable . r(o)= Root( )) [x : writable T ]p m .M m.s(x)= \nnull. . . ...(..p(.)=(1) m.p(.)=(1),, CompleteRegionInfo(s, h, t, r, p)= .o, f. h(o, f) de.ned =. . . \n. . .m.r(m.s(x)) = Root .) .m.t(m.s(x)) = T ' .f T ' -T . . . . t(o) de.ned . r(o) de.ned . [G,x : isolated \nT ]p = [x : isolated T ] * [G]p (... r(o)= Root(.)=. p(.) de.ned) . .. . . .(.o, r(o) de.ned =..f, h(o, \nf) de.ned) [G,x : immutable T ]p = [x : immutable T ] * [G]p [G,x : readable T ]p = [x : readable T ]p \nn [G]p Figure 10. De.nition of Well-Regioned [G,x : writable T ]p = [x : writable T ]p n [G]p [E]p = \nm .M m.p = p . .. . . ronment. Figure 11 de.nes the type environment denota\u00ad . (.. . dom(p). Up(p(.)) \n> 0) tion [G]p. Isolated and immutable denotations are mostly straightforward, though they rely on a \nnotion of partial sep\u00adarating conjunction * of instrumented states. To de.ne this ..o, f, o ' ' . . . \nm.r(o) . dom(p) . m.h(o, f)= o ' m.r(o ) . dom(p) . ' .. . . .. . . .. m.r(o )= Immutable . =. m.r(o \n' )= Field(o, f ) separation, we must .rst de.ne composition of instrumented states : def . where RootClosed(., \nm) .o, f, o ' . m.r(o)= Root(.) . m.h(o, f)= o ' =. = =( , ., ., ., p) . where def s . (s1 s2)= dom(s1) \nn dom(s2)= \u00d8. s = s1 . s2 def x . (x1 . x2)= x = x1 . x2 def p . (p1 p p2)= ... p(.)= p1(.)(+, +)p2(.) \n. (m.r(o ' )= m.r(o) . m.r(o ' )= Immutable . .. m.r(o ' )= Field(o, f)) Figure 11. Denoting types and \ntype environments. Partial separating conjunction then simply requires the exis\u00adtence of two states that \ncompose: def \"\"\"\"\" . Q . m . m\"\" m . P * Q = .m. .m.m\" . P . m\" m This partial separation makes denotation \nof immutable or isolated references mostly independent of other state. For ex\u00adample, an isolated reference \nin the environment must be the only reference to some root region, and it must be pos\u00adsible to split \nthat full permission away from the state de\u00adscribed by the rest of the environment without invaliding \nother parts of the context. We cannot de.ne the meaning of readable and writable individually, because \nwe need an externally visible bound on the regions involved in denot\u00ading a readable or writable reference \nwhen proving con\u00adversions (T-RECOVISO and T-RECOVIMM) sound. We give the meaning of a typing context \nwith respect to some local permission map p, which the denotations of readable and writable references \nrefer to, in addition to checking per\u00admissions in the concrete state. Because this p bounds the set of \nregions supporting an environment, when p contains only full permissions we can prove that certain region-changing \noperations will not interfere with other threads. It also en\u00adables proving parallel composition is race \nfree, as our proof of safe composition gives full update permission on a shared region to neither thread, \nmeaning neither thread may denote a writable reference to a shared object (as in T-PAR). Section 4.1 \nbrie.y describes speci.cs of how we inter\u00adact with an existing program logic [15] to prove sound\u00adness. \nEven without reading Section 4.1, the actual sound\u00adness proof in Section 4.2 should be understandable \nenough to build an intuition for soundness with only intuition for *. The proofs are based around a relation \n., which can be viewed as saying what changes to the p and r components of instrumented states are allowed, \nsuch that other threads can  def ' '' preserve their view of the typing of the state. (s, h, t, r, \np)R0(s ,h ' ,t ,r ,p ' )= s = s ' . p = p ' 4.1 Views Framework . .(.o, f. h(o, f)= h ' (o, f)=. p(r(o)) \n= (0, )) let O = dom(t) in . ............. Our soundness proof builds upon a version of the Views Framework \n[15], which is in some sense a generalization of the ideas behind separation logic and rely-guarantee \nrea\u00ad let O ' = dom(t ' ) in (.o. o . O n O ' =. (r(o)= r ' (o)=. ............. soning. The de.nitions \nwe gave in the previous section, S, ' . p(r(o)) = (0, ) . p(r (o)) = (0, ))) M and , happen to coincide \nwith de.nitions required by this framework. Given a few operations and relations over M, the framework \ngives a natural structure to the soundness . t(o)= t ' (o) . (.o. o . O \\ O ' =. r(o)= Field( , )) . \n(.o. o . O ' \\ O . r ' (o) . dom(p ' ) proof as an embedding of type derivations into the view s program \nlogic. To do this we must de.ne: An operation : M.M.M that is commutative and associative.  A preorder \ninterference relation R . M\u00d7M that de.nes permissible interference on an instrumented state. The relation \nmust distribute over composition:  .m1,m2, m. (m1 m2)Rm =. \"\"\" \"\"\" .m1,m 2.m1Rm1 . m2Rm2 . m . m1 \nm 2 A (left and right) unit to that is closed wrt to R (in our case, an instrumented state where all \nthe components are empty maps).  A denotation of static assertions (in our case, types) in terms of \ninstrumented states: [G]p as in Figure 11.  Soundness follows from proving that the denotation of a \ntyping derivation ([G f C -G]) respects some lifting of the operational semantics to instrumented states, \nby embedding the typing derivations into a program logic. The advantage of choosing this approach over \na more traditional technique like syntactic type soundness is that after proving a few lemmas about how \ntype environment denotations behave with respect to composition and interference, a number of typically \ndistinct concepts (including forking and joining threads, frame rules, and safety of environment reordering) \nbecome straightforward applications of simpler lemmas. We de.ne the interference permitted by a single \naction of another thread (heap modi.cations) R0 in Figure 4.1. The interference relation for individual \nactions allows relatively little to change. The stack and region permissions must re\u00admain constant. The \ntypes and region map must remain con\u00adstant, aside from objects initially in Field regions disappear\u00ading \n(as in another view performing a destructive read), new objects appearing in any region the current view \nhas no up\u00addate permission for, and moving objects between root re\u00adgions with no update permission (intuitively, \nanother view merging two root region contents). The heap has similar re\u00adstrictions, though it additionally \npermits .eld changes in root regions with 0 update permissions. Note that WellTyped and WellRegioned \nconstrain the domains of the region and type maps, and the object-only projection of the heap domain, \nto =. p ' (r ' (o)) = (0, )) Figure 12. The thread interference relation R0. all be equal. So if an object \nappears in the region map, it ap\u00adpears in the type map and heap as well, and so on. We de.ne the .nal \ninterference relation R as the re.exive transitive closure of R0. Given the speci.c de.nitions of composition \nand inter\u00adference, the Views Framework de.nes a number of useful concepts to help structure and simplify \nthe soundness proof. First, it de.nes a view as the subset of instrumented states that are stable under \ninterference: def View = {M .P(M) |R(M) . M} The program logic is proven sound with respect to views \n[15], and our denotation of type environments is a valid view (sta\u00adble with respect to R). The framework \nalso describes a use\u00adful concept called the view shift operator , that describes a way to reinterpret \na set of instrumented states as a new set of instrumented states with the same erasures to S, accounting \nfor any requirement of other views. It requires that: def pq .. .m .M. lp *{m}J . lq *R({m})J This speci.es \nhow the region information can be changed soundly. That is, we can only change the region information \nsuch that all other possible threads can maintain compatible views. This corresponds to precisely what \nsubtyping must satisfy in a concurrent setting and underlies the majority of encoding the complex typing \nrules into the Views Frame\u00adwork.  4.2 Soundness Proof As mentioned earlier, soundness of a type system \nin the Views Framework proceeds by embedding the types deno\u00adtation into a sound program logic [15]. The \nlogic itself con\u00ad tains judgments of the form {p}C{q} for views p and q and commands C, and the logic \ns soundness criteria, subject to our de.nitions of composition, interference, etc. satisfying the required \nproperties, is  Theorem 1 (Views Logic Soundness [15]). If {p}C{q} is derived in the logic, then for \nall s .lpJ, and s .S, if \" (C, s) -.* (skip,s \" ) then s .lqJ. Thus because our de.nitions of S, M, \nand R satisfy the required properties, if every type derivation denotes a valid derivation in the Views \nFramework s logic, then the type system is sound. We can de.ne the denotation of a typing judgment as: \ndef [G1 f C -G2] = .p. (... p(.) = (1, )) .{[G1]p}C{[G2]p} We map each judgement onto a collection of \njudgements in the Views Framework. This allows us to encode the rules for recovery, as the logic does \nnot directly support them. Specif\u00adically, closing over p allows us to prove that permissions are preserved. \nThus, if a block of code is encoded with a set of initially full permissions, it will .nish with full \npermissions, allowing conversion back to isolated if necessary. We always require there to be at least \none local region that is writable: (... p(.) = (1, )). This is required to prove soundness for the subtyping \nrule, to allow us to cast isolated to writable. Here we describe the major lemmas supporting the soundness \nproof, and omit natural but uninteresting lemmas, such as proving that the denotation of a type environment \nis stable under interference. We also omit methods here. When not otherwise discussed, lemmas are typically \nproven by in\u00adduction on a type environment G. More details are available in our extended technical report \n[20]. To prove soundness for method calls, we extended the Views Framework with support for method calls. \nThe semantics are mostly intuitive (reducing a call statement to an inlined method body with freshly \nbound locals), and both the semantics and proof ex\u00adtensions are described in detail in our technical \nreport [20]. The most important lemmas are those for recovering iso\u00adlated or immutable references, which \nprove the soundness of the type rules T-RECOVISO and T-RECOVIMM: Lemma 1 (Recovering Isolation). IsoOrImm(G) \n=. FullPermsOnly(p)=. [G,x : writable]p [G,x : isolated]\u00d8 Lemma 2 (Recovering Immutability). IsoOrImm(G) \n=. FullPermsOnly(p)=. [G,x : readable]p [G,x : immutable]\u00d8 Both Lemmas 1 and 2 rely on the fact that \nreadable and writable references into root regions refer only to regions in p. Without that restriction, \nand the fact that the denotation of type environments separates isolated and immutable references from \nregions in p, recovering isolation or im\u00admutability would not be possible. Another important factor for \nthese lemmas is our slight weakening of external unique\u00adness, to allow references out of an aggregate \ninto immutable data; without this, recovering isolation would not be possible with immutable references \nin G. Environment subtyping is given by the following lemma. Lemma 3 (Subtyping Denotation). (... p(.) \n= (1, )) .f G1 -G2 = . [G1]p [G2]p The lemmas for framing (and unframing) parts of the type environment \nrequire de.ning a weakened type deno\u00ad . tation [G], described in detail in our expanded technical p report \n[20]. This denotation is mostly the same as the reg\u00ad ular denotation but requires only a non-zero update \nper\u00admission in p, with 0 update permission in the state, but checking reference permission against a \np matching the un\u00adframed state. This makes the environment unusable for ex\u00adecuting commands but retaining \nenough information to re\u00adstore the environment later. We also use a transformation function on p to frame \nout a reference permission, prevent\u00ading the recovery rules from being applied in cases where a readable \nor writable reference to some region is framed out: frame out perm (u, r) := (u, r/2). Lemma 4 (Type \nFraming). . [G, G \" ]p [G](map frame out perm p) *[G \" ](map frame out perm p) Lemma 5 (Type Unframing). \n. [G](map frame out perm p) *[G \" ](map frame out perm p) [G, G \" ]p Lemma 6 (Symmetric Decomposition). \nNoWrit(G) =. [G, G \" ]p [G](map halve perm p) * [G \" ](map halve perm p) Lemma 7 (Join). [G]p * [G \" \n]p1 [G, G \" ]p p1 Lemma 8 (Asymmetric Decomposition). IsoOrImm(G) =. [G, G \" ]p [G]\u00d8 * [G \" ]p Theorem \n2 (Type Soundness). G1 f C -G2 =. [G1 f C -G2] Proof. By induction on the derivation G1 f C -G2. 5. Polymorphism \nAny practical application of this sort of system naturally re\u00adquires support for polymorphism over type \nquali.ers. Oth\u00aderwise code must be duplicated, for example, for each pos\u00adsible permission of a collection \nand each possible permis\u00adsion for the objects contained within a collection. Of course, polymorphism \nover unique and non-unique references with mutable state still lacks a clean solution due to the presence \nof destructive reads (using a destructively-reading collection for non-unique elements would signi.cantly \nalter semantics, though in the pure setting some clever techniques exist [26]).  To that end we also \ndevelop a variant of the system with both type and method polymorphism, over class types and permissions. \nAs in C#, we allow a sort of dependent kind\u00ading for type parameters, allowing type and permission pa\u00adrameters \nto bound each other (without creating a cycle of bounding). We separate permission parameters from class \nparameters for simplicity and expressivity. A source level variant may wish to take a single sort of \nparameter that quan\u00adti.es over a permission-quali.ed type as in IGJ [39]. There is a straightforward \nembedding from those constraints to the more primitive constraints we use, and our separation makes our \nlanguage suitable as an intermediate language that can be targeted by variants of a source language that \nmay change over time. Figure 13 gives the grammar extensions for the polymor\u00ad phic system. Our language \npermits bounding a polymorphic permission by any other permission, including other permis\u00adsion parameters, \nand by concrete permissions that produce parameters with only a single valid instantiation (such as class \ncn(X)(P ) where ... {field t f field method}. P t[P/p, X/T ] f . cn(T )(p) class cn(X)(P ) where ... \n{field method}. Pm . method m = t ' m(Y)(Q)(u ' z ') p ' where Y<: V, Q <: q... m[P/p, X/T ] . cn(T \n)(p) def IsoOrImm.(G) = .(x : pT ) . G. . f p -immutable [. : Permission . Permission . Permission immutable \n[. = immutable [. immutable = immutable readable [. writable = readable readable [. readable = readable \nwritable [. readable = readable writable [. writable = writable readable [. Q = readable P [. readable \n= readable writable [. Q = Q P [. writable = . .. .. P immutable). This allows for future extensions, \nfor example Q . f P -Q P . f Q -P P . Q otherwise distinguishing multiple immutable data sources. We \nadd a P [. Q = context . containing type bounds to the typing and subtyp\u00ad ing judgements. We extend the \nprevious typing and subtyp\u00ading rules in the obvious way. . is invariant for the duration of checking \na piece of code, and the main soundness the- Figure 14. Auxiliary judgements and metafunctions for the \npolymorphic system. orem, restated below, relies on an executing program hav\u00ading an empty . (a program \ninstantiates all type and permis\u00adsion parameters to concrete classes and permissions). Con\u00ad cretely, \ntype judgements and subtyping judgements now take the forms: this is too imprecise for uses such as container \nclasses. There is always a more precise answer to give, but it cannot be known until all parameters are \ninstantiated. To this end, we . | G f C -G. f t -t Figure 14 gives auxiliary judgements and metafunctions \nused in the polymorphic system. Most of the extensions are straightforward, leveraging bounds in . to \ntype check inter\u00adactions with generic permissions and class types. We discuss a couple of the most interesting \nrules here, presenting the full type system in our technical report [20]. One of the most interesting \nrules is the .eld read: t ' f . Tp = isolated . t ' = immutable t ' = isolated . p = immutable . | x \n: ,y : pT f x = y.f y : p T,x : p [. t ' It uses a variant of permission combining parameterized by ., \ngiven in Figure 14, and lifted to types as before. When reading the de.nition of [., bear in mind that \nno permis\u00adsion variable may ever be instantiated to isolated. The .\u00adnal case of [. produces a deferred \npermission combination (p \" p). The two cases previous to it that combine uninstan\u00adtiated permission \nparameters leverage the bounding relation in . to give a sound answer that might produce writable or \nimmutable results that can be used locally (though in the case that P is instantiated to immutable, this \ncan lose some precision compared to instantiated uses). In the unre\u00adlated case, there is always an answer \nto give: readable. But also change the type and permission substitution to reduce p \" q to p [. q if \np and q are both concrete permissions after substitution. Note that these deferred permissions are effectively \nequivalent to readable in terms of what actions generic code using them may perform. This deferred combi\u00adnation \nplays a pivotal role in supporting highly polymorphic collection classes, as Section 6.3 describes. We \nalso support covariant subtyping on readable and immutable references, as in IGJ [39]. i-1 m-ii-1 m-i \n. f pc(T ,Ti,T )(p) . f pc(T ,T i ' ,T )(p) p = readable . p = immutable . f Ti -Ti ' i-1 m-ii-1 m-i \n. f pc(T ,Ti,T )(p)-pc(T ,T i ' ,T )(p) There is another rule for safe covariant permission subtyping \nas well. Soundness for Generics At a high level, the soundness proof for the polymorphic system is similar \nto the monomor\u00adphic system, because we only need to embed fully-instantiated programs (the top level \nprogram expression is type checked with an empty type bound context). The de.nition for type maps in \nthe concrete machine states and views are rede.ned to have a range of only fully-instantiated types, \nmaking type environment denotations de.ned only over fully-instantiated types.  TD ::= class cn(X)(P \n) [<: T 2] where X<: T, P <: p {field meth } W, X, Y, Z type variables meth ::= tm(X)(P )(t1 x1, ..., \ntn xn) p where X<: T, P <: p { C; return x; } P, Q, R permission variables p, q ::= ... | P | pp T, \nU, V ::= cn(T )(p)| X . ::= E | .,X <: T | .,P <: p  Figure 13. Grammar extensions for the polymorphic \nsystem. Several auxiliary lemmas are required such as that sub\u00adstituting any valid permission or type \ninstantiations into a generic derivation yields a consistent derivation. Addition\u00adally, the denotation \nof writable and isolated references must use a strengthened subtyping bound on their referents, to ensure \nthey are viewed at a type that does not change any .eld types (thus preventing the classic reference \nsub\u00adtyping problem while allowing covariant subtyping of read\u00adonly references). More details are given \nin our technical re\u00adport [20]. 6. Evaluation A source-level variant of this system, as an extension to \nC#, is in use by a large project at Microsoft, as their pri\u00admary programming language. The group has \nwritten sev\u00aderal million lines of code, including: core libraries (includ\u00ading collections with polymorphism \nover element permis\u00adsions and data-parallel operations when safe), a webserver, a high level optimizing \ncompiler, and an MPEG decoder. These and other applications written in the source language are performance-competitive \nwith established implementa\u00adtions on standard benchmarks; we mention this not because our language design \nis focused on performance, but merely to point out that heavy use of reference immutability, includ\u00ading \nremoving mutable static/global state, has not come at the cost of performance in the experience of the \nMicrosoft team. In fact, the prototype compiler exploits reference immutabil\u00adity information for a number \nof otherwise-unavailable com\u00adpiler optimizations. 6.1 Differences from Formal System The implementation \ndiffers from the formal system de\u00adscribed earlier in a number of ways, mostly small. The most important \ndifference is that the implementation supports proper task parallelism, with a .rst-class (unstructured) \njoin. Task parallelism is supported via library calls that accept isolated delegates (closures, which \nmust therefore capture only isolated or immutable state, in correspondence with T-ASYNC) and return isolated \npromises, thus interacting nicely with recovery and framing, since the asynchronous task s mutable memory \nis disjoint from the main compu\u00adplexing async block tasks on a single CLR thread2, which already reduces \nconcurrency errors from its use, so the team has not yet decided to undertake the maintenance task of \nturning on such checking. This permits some unchecked concurrency, but single-threaded (avoiding at least \nmemory model issues) and with only explicit points of interference (an await expression basically acts \nas a yield statement; es\u00adsentially cooperative concurrency). The team plans to even\u00adtually enable checking \nof async blocks as well. T-PAR is not used for asynchronous tasks because it is unsound: recovery (T-RECOVISO \nand T-RECOVIMM) is not valid if a shared readable reference to mutable data can live arbitrarily long \nafter the recovery block in an asynchronous task. Thus T-PAR is used only for applicable static constructs \nsuch as parallel for loops. There are also a few source-level conveniences added as compared to the system \nhere. The most notable is immutable classes. Immutable classes are simply classes whose con\u00adstructors \nare required to have a .nal type environment with this : immutable rather than isolated. This allows \nthe constructor to internally treat the self pointer as writable or isolated, before the type system \nconceptually uses T-RECOVIMM. Thus, writable and readable constructor arguments are permitted, they simply \ncannot be stored di\u00adrectly into the object. The disadvantage of this is that it is not possible, without \nunsafe casts, to create a cycle of ob\u00adjects of immutable classes (cycles of immutable objects in general \nremain possible as in Section 2.3). The source variation also includes an unstrict block, where permission \nchecking is disabled. The eventual goal is for this to be used only in trusted code (whose .NET as\u00adsemblies \nare marked as such), for optimizations like lazy ini\u00adtialization of immutable data when an accessor is \ncalled; the core libraries offer a set of standard abstractions to encap\u00adsulate these unsafe actions \n(Section 6.6). Finally, the source language uses only a single type parameter list, where each argument \nmay be instantiated with a single permission or full permission-quali.ed type. C# also permits compound \nexpressions, and expres\u00adsions with side-effects, which our core language disallows. consume is an expression \nin the source language, which performs a destructive read on its l-value argument and re\u00adturns the result. \nThis makes using isolated method arguments tation s. async blocks are not currently checked according \n2 In C# s implementation, async blocks may run on other threads [3], but to T-ASYNC, mostly because we \nrestrict async block task the team decided prior to adding reference immutability that such behavior \nexecution to single-threaded cooperative behavior, multi-was too error prone. more convenient than in \nour core language, which allows statement consumption of .elds, but treats isolated variables as af.ne \nresources when passed to methods. A common focus for safe data-parallelism systems is han\u00addling of arrays. \nThe implementation currently does not sup\u00adport arrays directly, but via trusted library abstractions \nfor safe data parallelism. We are currently designing a notion of a sub-array, using a combination of \nisolation and immutabil\u00adity to allow safe array partitioning for in-place updates, as well as functional \ndata-parallelism. This part of the design is still evolving.  6.2 Differences from C# Beyond adding \nthe obvious immutability-related extensions and restricting async block task execution to a single\u00adthreaded \nmodel (augmented with a true task parallelism li\u00adbrary) as already discussed, the only additional difference \nfrom C# is that all static (global) state must be immutable. This is necessary for safe parallelism and \nfor the recovery rules to avoid capturing shared mutable state. This restric\u00adtion does lead to some different \ncoding patterns, and required introducing several internally-unsafe but externally-safe li\u00adbrary abstractions \nfor things like global caches, which we will discuss shortly.  6.3 Source Level Examples Generic Collections \nCollection libraries are a standard benchmark for any form of generics. The source variant of our system \nincludes a full collections library, including sup\u00adport for polymorphism over permissions of the collection \nitself and elements of the collection. An illustrative exam\u00adple is the following simpli.ed collections \ninterface (using a lifting of our notation to a source language with interfaces, retaining our separation \nof permission and class parameters): public interface ICollection<Elem><PElem> { public void add(PElem \nElem e) writable; public writable Enumerator<Elem><P,PElem> getEnumerator() P; } public interface IEnumerator<Elem><PColl,PElem> \n{ public bool hasNext() readable; public PColl.PElem Elem getNext() writable; } This collection interface \nis parameterized over a class type for elements and a permission for the elements (which may never be \ninstantiated to isolated). The add() method is natural, but the interesting case is getEnumerator(). \nThis method returns a writable enumerator, but the enumera\u00adtor manages two permissions: the permission \nwith which getEnumerator() is called (which governs the permission the enumerator will hold on the collection) \nand the permis\u00adsion the collection has for the elements. These separate permissions come into play in \nthe type of the enumerator s getNext() method, which uses de\u00adferred permission composition (pp, Section \n5) to return elements with as precise a permission as possible. Simply specifying a single permission \nfor the elements returned requires either specifying a different enumerator variant public class LinkedList<Elem><PElem> \nimplements ICollection<Elem><PElem> { protected writable Node<Elem><PElem> head; protected class Node<Elem><PElem> \n{ public PElem Elem item; public writable Node<Elem><PElem> next; } protected class LLEnum<E><PColl,PE> \n implements IEnumerator<E><PColl,PE> { private PColl Node<Elem><PE> next; public LLEnum(PColl LinkedList<E><PE> \ncoll) { next = coll.head; } public bool hasNext() readable { return next == null; } public PColl.PElem \nE getNext() writable { if (next != null) { PColl.PElem E nextElem = next.item; next = next.next; return \nnextElem; } return null; } } public LinkedList() { head = null; } public void add(PElem Elem e) writable \n{ writable Node<Elem><PElem> n = new Node<Elem><PElem>(); n.item = e; n.next = head; head = n; } public \nwritable Enumerator<Elem><P,PElem> getEnumerator() P { return new LLEnum<Elem><P,PElem>(this); } } Figure \n15. A simpli.ed collection with a polymorphic enu\u00admerator. for every possible permission on the collection, \nor los\u00ading precision. For example, given a writable collection of immutable elements, it is reasonable \nto expect an it\u00aderator to return elements with an immutable permission. This is straightforward with \na getEnumerator() variant speci.c to writable collections, but dif.cult using poly\u00admorphism for code \nreuse. Returning (using the enumera\u00adtor de.nition s parameters) PElem elements is in general not possible \nwith a generic PColl permission on the col\u00adlection because we cannot predict at the method de.ni\u00adtion \nsite the result of combining the two permissions when the enumerator accesses the collection; it would \nbe sound for a writable collection of immutable objects, but not for an immutable collection of writable \nobjects since immutable [. writable = immutable, not writable. It also preserves precision, as any element \nfrom enumerating an immutable collection of readable references should ideally return immutable elements \nrather than the sound but less precise readable. Consider a linked list as in Figure 15. The heart of \nthe it\u00ad erator s .exibility is in the type checking of the .rst assign\u00adment in LLEnum.getNext(). There \nthe code has a PColl permissioned reference next to a linked list node that con\u00adtains a PElem permissioned \nreference .eld item to an ele\u00adment. Thus the result type of next.item is PColl PElem PE by T-FIELDREAD \nand [.. When the linked list type is instantiated, and getEnumerator() is called with a certain permission, \nthe enumerator type becomes fully instantiated and the deferred combination is reduced to a concrete \nper\u00admission. For example:  writable LinkedList<IntBox><writable> ll = new LinkedList<IntBox><writable>(); \nwritable IEnumerator<IntBox><writable,writable> e = ll.getEnumerator(); // P instantiated as writable \nwritable IntBox b = e.getNext(); writable LinkedList<IntBox><readable> llr = new LinkedList<IntBox><readable>(); \nwritable IEnumerator<IntBox><writable,readable> e = llr.getEnumerator(); // P instantiated as readable \nwritable IntBox b = e.getNext(); // Type Error! // e.getNext() returns readable, since w r=r readable \nIntBox b = e.getNext(); // OK A slightly richer variant of this enumerator design underlies the prototype \ns foreach construct, and is used widely in the Microsoft team s code. Data Parallelism Reference immutability \ngives our lan\u00adguage the ability to offer uni.ed specializations of data structures for safe concurrency \npatterns. Other systems, such as the collections libraries for C# or Scala separate concurrency-safe \n(immutable) collections from mutable col\u00adlections by separate (but related) trees in the class hierarchy.3 \nA fully polymorphic version of a map() method for a col\u00adlection can coexist with a parallelized version \npmap() spe\u00adcialized for immutable or readable collections. Consider the types and extension methods [34] \n(intuitively similar to mixins on .NET/CLR, though the differences are non-trivial) in Figure 16, adding \nparallel map to a LinkedList class for a singly-linked list (assuming the list object itself acts as \na list node for this example). Each maps a function4 across the list, but if the function requires only \nreadable permission to its arguments, pmap may be used to do so in parallel. Note that the parallelized \nversion can still be used with writable collections through subtyping and framing as long as the mapped \noperation is pure; no duplication or creation of an additional collection just for concurrency is needed. \nWith the eventual addition of static method overloading by per\u00admissions (as in Javari [37]), these methods \ncould share the same name, and the compiler could automatically select the parallelized version whenever \npossible.  6.4 Optimizations Reference immutability enables some new optimizations in the compiler and \nruntime system. For example, the concur\u00adrent GC can use weaker read barriers for immutable data. The \ncompiler can perform more code motion and caching, and an MSIL-to-native pass can freeze immutable data \ninto the binary. 3 C# and Scala have practical reasons for this beyond simply being unable to check safety \nof parallelism: they lack the temporary immutability of our system due to the presence of unstructured \nparallelism. 4 Func1 is the intermediate-language encoding of a higher-order procedure. C# has proper \ntypes for these, called delegate types [34], each compiled to an abstract class with an invoke method \nwith the appropriate arity and types. We restrict our examples to the underlying object representation \nfor clarity. public abstract class Func1<In,Out><Pin,Pout,Prun> { public abstract Pout Out invoke(Pin \nIn in) Prun; } public static class LinkedListExtensions { // A parallel map public static readable LinkedList<readable><X> \npmap<X>( this readable LinkedList<readable><X>, immutable Func1<X,X><readable,readable,readable> fun) \nreadable { readable LinkedList<readable><X> rest = null; isolated LinkedList<readable><X> head = null; \n head = if (list.next != null) new LinkedList<readable><X>; rest = head.elem = fun(list.elem); list.next.map<X>(fun); \nhead.next = rest; return head; } // A polymorphic map public static writable LinkedList<PL PE><X> map<X><PE>( \nthis PL LinkedList<PE><X> list, immutable Func1<X,X><PL PE,PL PE,readable> fun) PL { writable LinkedList<PL \nPE><X> result = new LinkedList<PL PE><X>; result.elem = fun(list.elem); writable LinkedList<PL PE><X> \nnewCurr = result; PL LinkedList<PE><X> oldCurr = list; while (oldCurr.next != null) { newCurr.next = \nnew LinkedList<PL PE><X>; newCurr = newCurr.next; oldCurr = oldCurr.next; newCurr.elem = fun(oldCurr.elem); \n } return result; } } Figure 16. Extension methods to add regular and parallel map to a linked list. \nA common concern with destructive reads is the addi\u00adtional memory writes a na\u00a8ive implementation (such \nas ours) might incur. These have not been an issue for us: many null writes are overwritten before .ushing \nfrom the cache; the compiler s MSIL is later processed by one of two optimizing compilers (.NET JIT or \nan ahead-of-time MSIL-to-native compiler) that often optimize away shadowed null writes; and in many \ncases the manual treatment of uniqueness would still require storing null.  6.5 Evolving a Type System \nThis type system grew naturally from a series of efforts at safe parallelism. The initial plans included \nno new lan\u00adguage features, only compiler plugins, and language exten\u00adsions were added over time for better \nsupport. The earli\u00adest version was simply copying Spec# s [Pure] method attribute [1], along with a set \nof carefully designed task\u00ad and data-parallelism libraries. To handle rough edges with this approach \nand ease checking, readable and immutable were added, followed by library abstractions for isolated and \nimmutable. After some time using unstrict blocks to implement those abstractions, we gradually saw a \nway to integrate them into the type system. With all four permis\u00adsions, the team was much more eager \nto use reference im\u00admutability. After seeing some bene.t, users eagerly added readable and immutable \npermissions.  Generics were the most dif.cult part of the design, but many iterations on the design \nof generic collections pro\u00adduced the design shown here. The one aspect we still strug\u00adgle with is the \noccasional need for shallow permissions, such as for a collection with immutable membership, but mutable \nelements. This is the source of some unstrict blocks. The entire design process was guided by user feedback \nabout what was dif.cult. Picking the right defaults had a large impact on the users happiness and willingness \nto use the language: writable is the default annotation, so any single-threaded C# that does not access \nglobal state also compiles with the prototype. This also made converting ex\u00adisting code much easier. \nThe system remains a work in progress. We initially feared the loss of traditional threads could be a \ngreat weak\u00adness, but the team placed slightly higher value on correct concurrency than easy concurrency, \nleading to the design point illustrated here. To recover some .exibility, we are currently adding actor \nconcurrency, using isolated and immutable permissions for safe message passing [22, 24]. We continue \nto work on driving the number of unstrict blocks as low as possible without over-complicating the type \nsystem s use or implementation. Part of this includes codify\u00ading additional patterns that currently require \nunstrict use. We understand how to implement some of these (such as per\u00admission conversion for stateless \nobjects like empty arrays) safely within the type system, but the engineering trade-offs have not yet \nbeen judged worth the effort to implement.  6.6 User Experience Overall, the Microsoft team has been \nsatis.ed with the addi\u00adtional safety they gain from not only the general software en\u00adgineering advantages \nof reference immutability [37, 39, 40] but particularly the safe parallelism. Anecdotally, they claim \nthat the further they push refer\u00adence immutability through their code base, the more bugs they .nd from \nspurious mutations. The main classes of bugs found are cases where a developer provided an object in\u00adtended \nfor read-only access, but a callee incorrectly mu\u00adtated it; accidental mutations of structures that should \nbe immutable; and data races where data should have been im\u00admutable or thread local (i.e. isolated, and \none thread kept and used a stale reference). Annotation burden has been low. There is roughly 1 annotation \n(permission or consume) per 63 lines of code. These are roughly 55% readable, 16.8% consume, 16.5% immutable, \n4.7% writable, 4.1% isolated, and 2.8% generic permissions. This is partly due to the writable default, \nas well as C# s local type inference (e.g. var x = ...;). Thus most annotations appear in method signa\u00adtures. \nNote that because users added additional quali.ers for stricter behavior checking, this is not the minimal \nannotation burden to type check, but re.ects heavy use of the system. The type system does make some \ncommon tasks dif.\u00adcult. We were initially concerned that immutable-only global state would be too restrictive, \nbut has been mitigated by fea\u00adtures of the platform the Microsoft team develops on top of. The platform \nincludes pervasive support for capability-based resource access for resources such as .les. Global caches \nare treated as capabilities, which must be passed explicity through the source (essentially writable \nreferences). This re\u00adquires some careful design, but has not been onerous. Mak\u00ading the caches global \nper process adds some plumbing effort, but allows better uni.ed resource management. Another point of \ninitial concern was whether isolation would be too restrictive. In practice it also adds some design \nwork, but our borrowing / recovery features avoid viral lin\u00adearity annotations, so it has not been troublesome. \nIt has also revealed subtle aliasing and concurrency bugs, and it enables many af.ne reference design \npatterns, such as checking lin\u00adear hand-off in pipeline designs. The standard library also provides trusted \ninternally\u00adunstrict abstractions for common idioms that would other\u00adwise require wider use of unstrict \nblocks. Examples include lazy initialization and general memoization for otherwise immutable data structures, \ncaches, and diagnostic logging. There are relatively few unstrict blocks, of varying sizes (a count does \nnot give an accurate estimate of unchecked code). Most of these are in safe (trusted) standard library \nabstractions and interactions with the runtime system (GC, allocator, etc., which are already not memory-safe). \nOver the course of development, unstrict blocks have also been useful for the Microsoft team to make \nforward progress even while relying on effectively nightly builds of the compiler. They have been used \nto temporarily work around unimplemented features or compiler bugs, with such blocks being marked, and \nremoved once the compiler is updated. The Microsoft team was surprisingly receptive to using explicit \ndestructive reads, as opposed to richer .ow-sensitive analyses [8, 28] (which also have non-trivial interaction \nwith exceptions). They value the simplicity and predictability of destructive reads, and like that it \nmakes the transfer of unique references explicit and easy to .nd. In general, the team pre\u00adferred explicit \nsource representation for type system interac\u00adtions (e.g. consume, permission conversion). The team has \nalso naturally developed their own de\u00adsign patterns for working in this environment. One of the most \npopular is informally called the builder pattern (as in building a collection) to create frozen collections: \nisolated List<Foo> list = new List<Foo>(); foreach (var cur in someOtherCollection) { isolated Foo f \n= new Foo(); f.Name = cur.Name; // etc ... list.Add(consume f); } immutable List<Foo> immList = consume \nlist;  This pattern can be further abstracted for elements with a deep clone method returning an isolated \nreference. Nearly all (non-async) concurrency in the system is checked. The unchecked concurrency is \nmostly due to de\u00advelopment priorities (e.g. feature development has been pri\u00adoritized over converting \nthe remaining code); removing all unchecked concurrency from the system remains an explicit goal for \nthe team. Nonetheless, the safe concurrency fea\u00adtures described here have handled most of the team s \nneeds. Natural partitioning of tasks, such as in the H.264 and JPEG decoders (both veri.ed for safe concurrency) \nis surprisingly common, and well-supported by these abstractions. Some\u00adtimes breaking an algorithm into \nMap-Reduce-style phases helps .t problems into these abstractions. The main dif.cul\u00adties using the model \ncome in two forms. The .rst form is where partitioning is dynamic rather than structural. This is dif.cult \nto express ef.ciently; we are working on a frame\u00adwork to compute a partitioning blueprint dynamically. \nSec\u00adond, sometimes communication among tasks is not required for correctness, but offers substantial \nperformance bene.ts: for example, in a parallelized search algorithm, broadcast\u00ading the best-known result \nthus far can help all threads prune the search space. Currently unstrict code is used for a few instances \nof this, which motivates current work to add actors to the language [22, 24]. 7. Related Work Reference \nimmutability [37, 39, 40] is a family of work char\u00ad acterized by the ability to make an object graph \neffectively immutable to a region of code by passing read-only refer\u00adences to objects that may be mutated \nlater, where the read\u00adonly effect of a reference applies transitively to all references obtained through \na read-only reference. Common extensions include support for class immutability (classes where all in\u00adstances \nare permanently immutable after allocation) and ob\u00adject immutability (making an individual instance of \na class permanently immutable). Surprisingly, despite safe paral\u00adlelism being cited as a natural application \nof reference im\u00admutability, we are the .rst to formalize such a use. Immutability Generic Java (IGJ) \n[39] is the most simi\u00ad lar reference immutability work to ours, though it does not address concurrency. \nIGJ uses Java generics support to em\u00adbed reference immutability into Java syntax (it still requires a \ncustom compiler to handle permission subtyping). Thus reference permissions are speci.ed by special classes \nas the .rst type parameter of a generic type. IGJ s support of ob\u00adject immutability is also based on \nthe permission passed to a constructor, rather than conversion, so object immutabil\u00adity is enforced at \nallocation, and may not be deferred as our T-RECOVIMM rule allows. This means that creating a cy\u00adcle \nof immutable objects requires a self-passing constructor idiom, where a constructor for cyclic immutable \ndata struc\u00adtures must pass its this pointer into another constructor call as Immutable. Haack and Poll \nrelax this restriction by lexi\u00adcally scoping the modi.cation lifetime of an immutable in\u00adstance [21]. \nOwnership [6, 7, 11, 13] and Universe [14] types describe a notion of some objects owning others as a \nmethod of structuring heap references and mutation. The owner-as\u00admodi.er interpretation of ownership \nresembles reference immutability: any modi.cation to an object o must be done through a reference to \no s owner. These systems still per\u00admit references across ownership domain, but such refer\u00adences (any \nreferences in Universe types) are deeply read\u00adonly. Universe types specify a viewpoint adaptation re\u00adlation \nused for adapting type declarations to their use in a given context, which directly inspired our permission \nadap\u00adtation relation. Leino, M\u00a8 uller, and Wallenburg [25] boost the owner-as-modi.er restriction to \nobject immutability by adding a freeze operation that transfers ownership of an ob\u00adject to a hidden owner \nunavailable to the program source. Since the owner cannot be mentioned, no modi.cations may be made to \nfrozen objects. In general, ownership transfer, (as in Leino et al. s system or UTT [27]) relies on uniqueness \nand treats ownership domains as regions to merge. The most similar treatment of polymorphism over muta\u00adbility-related \nquali.ers to our work is Generic Universe Types (GUT). GUT provides polymorphism over permis\u00adsion-quali.ed \ntypes as in our prototype source language, rather than separating quali.ers and class types as our core \nlanguage does. GUT s viewpoint adaptation (roughly equiv\u00adalent to our permission combining relation [.) \ndeals im\u00admediately with concrete quali.er combinations, and pre\u00adserves some precision when combining \na concrete own\u00adership modi.er with a generic one. But when combining two generic ownership modi.ers, \nthe result is always any, roughly equivalent to readable in our system. In prac\u00adtice, this is suf.cient \nprecision for GUT, because passing a generic type across ownership domains typically converts to any \nanyways. Our use cases require additional precision, which we retain by using deferred permission combination \n(pp) to postpone the combination until all type parame\u00adters are instantiated. Without this, the generic \nenumerator in Section 6.3 could only return readable elements, even for a writable collection of immutable \nelements. IGJ [39] does not discuss this type of permission combining, but ap\u00adpears to have a similar \nloss of precision: i.e. accessing a .eld with generic permission through a reference with generic permission \nalways yields a readable reference. OIGJ [40] can express generic iterators, but mostly because reference \nimmutability in OIGJ is not transitive: a read-only iterator over a mutable list is permitted to mutate \nthe list, and an it\u00aderator over an immutable list of mutable elements can return mutable references to \nthose elements. Ownership type systems have been used to achieve data race freedom [6, 7, 13], essentially \nby using the owner\u00ad ship hierarchy to associate data with locks and beyond that enforcing data race freedom \nin the standard way [17 19].  Clarke et al. [12] use ownership to preserve thread locality, but allow \nimmutable instances and safe references (which permit access only to immutable, e.g. Java-style final, \npor\u00adtions of the referent) to be shared freely across threads, and add transfer of externally unique \nreferences. \u00a8 Ostlund et al. [30] present an ownership type and effect system for a language Joe3 with \nthe explicit aim of sup\u00adporting reference immutability idioms by embedding into an ownership type system. \nOwner polymorphic methods de\u00adclare the effects they may have on each ownership domain, treating ownership \ndomains as regions [35, 36]. Joe3 uses a similar technique to ours for delayed initialization of im\u00admutable \ninstances, as it has (externally) unique references, and writing a unique reference to an immutable variable \nor .eld converts the externally unique cluster into a cluster of immutable objects. While Joe3 has blocks \nfor borrow\u00ading unique references, our T-RECOVIMM rule is more gen\u00aderal, combining borrowing and conversion. \nTheir borrowing mechanism also creates local owners to preserve encapsula\u00adtion, requiring explicit ownership \ntransfer to merge aggre\u00adgates. Our type system also permits invoking some meth\u00adods directly on unique \nreferences (as opposed to the re\u00adquired source-level borrowing in Joe3) because our frame rule makes \nit easy to prove the invocation preserves unique\u00adness with the additional argument restrictions (Figure \n5). Our T-RECOVISO rule is in some ways a simpli.cation of existing techniques for borrowing unique references, \ngiven the presence of reference immutability quali.ers. The clos\u00adest work on borrowing to ours in terms \nof simplicity and expressiveness is Haller and Odersky s work [23] using ca\u00ad pabilities that guard access \nto regions containing externally\u00adunique clusters. Regions of code that return an input capabil\u00adity have \nonly borrowed from a region, and have not violated its external uniqueness. Local variable types . [ \nt are ref\u00aderences to an object of type t in region .. When a reference to some object in an externally \nunique aggregate is written to a heap location, that aggregate s capability is consumed in a .ow-sensitive \nfashion, and all local variables guarded by that capability become inaccessible. Our recovery rule requires \nno invalidation, though its use may require environ\u00adment weakening. We believe the expressiveness of \nthe two approaches to be equal for code without method calls. For method calls, Haller and Odersky track \nborrowing of indi\u00advidual arguments by what permissions are returned. Our sys\u00adtem would require returning \nmultiple isolated references through the heap, though our recovery rules would allow in\u00adferring some \nmethod returns as isolated in the proper con\u00adtexts, without cooperation of the method called. We also \nadd some .exibility by allowing arbitrary paths to immutable state reachable from an externally-unique \naggregate. Another interesting variant of borrowing is adoption [10, 16], where one piece of state is \nlogically embedded into an\u00ad other piece, which provides a way to manage unique refer\u00adences without destructive \nreads. Boyland proposed fractional permissions [9] to reason statically about interference among threads \nin a language with fork-join concurrency. We use a twist on fractional per\u00admissions in the denotation \nof our types, including to denote uniqueness, though the fractions do not appear in the source program \nor type system. The Plaid language uses fractional permissions to manage aliasing and updates to objects \nwhen checking typestate [2]. Recent work by Naden et al. to sim\u00ad plify Plaid [28], like our system, does \nnot require any frac\u00ad tions or explicit permission terms to appear in source code, though unlike us an \nimplementation of their type system must reason about fractional permissions (our fractional per\u00admissions \nappear only in our meta-proofs). Like us they use type quali.ers to specify access permissions to each \nobject, though their permissions do not apply transitively (a distinc\u00adtion driven largely by our differing \nmotivations). Naden s language supports externally-unique and immutable refer\u00adences, and more .ne-grained \ncontrol than our system over how permissions for each argument to a method are changed (e.g. preserving \nuniqueness as an indication of borrowing), though his language does not address concurrency. Deterministic \nParallel Java (DPJ) [4] uses effect typing and nested regions [35, 36] to enable data parallelism and \ndeterministic execution of parallel programs. An expression may have a read or write effect on each of \nsome number of regions, and expressions with non-con.icting effects (one thread with write effect and \nnone with read effects, or multi\u00adple threads with read effects and no write effects, on each region) \nmay safely be parallelized. This ensures not only the absence of data races, but determinism as well \n(later re\u00advisions add controlled nondeterminism [5]). Our system is similar in spirit, but requires no \nmention of regions in the source, only mention of the permissions required for each object a method accesses, \nnot where they reside. This means, for example, that region polymorphism is implicit in our sys\u00adtem; \nmethods need not bind to a speci.c number of regions, while DPJ requires methods and classes to declare \n.xed numbers of regions over which they operate (it is possible to instantiate multiple region arguments \nwith the same region). The upside to the explicit treatment of regions in DPJ is that non-interfering \nwrites may be parallelized without requiring any sort of reference uniqueness (the type system must still \nbe able to prove two regions are distinct). DPJ also treats data parallelism over arrays, whereas we \ndo not. Westbrook et al. [38] describe Habanero Java with Per\u00ad missions (HJp), a language with parallelism \nstructure be\u00adtween our formal and source languages: async(e) begins an asynchronous task and returns \nunit; .nish(e) waits for all tasks spawned within e, rather than allowing joins with indi\u00advidual tasks. \nThey use quali.ers to distinguish thread-local read, thread-local write, and thread-shared read access \nto ob\u00adjects (the latter is mutually exclusive with the .rst two). They must distinguish between thread \nlocal and shared read-only access because they cannot guarantee the inaccessibility of writable references \nto objects for the duration of an async; doing so would require a .ow-sensitive set of variables in\u00adaccessible \nuntil the enclosing .nish() because the end of an async is not statically scoped, and async blocks may \ncapture any shareable state, not only unique or immutable state. Their treatment of storing (totally) \nunique references in unique .elds and embedding the referent s permissions is more .exible for concurrency \nthan our isolated .elds. Their embedding allows natural read-only access to unique .eld referents if \nthe containing object is shared read-only, while isolated .elds of shared readable objects are in\u00adaccessible \nuntil recovery or conversion. Reads from non\u00adunique .elds in HJp have no static permissions; dereferenc\u00ading \nsuch .elds requires dynamically acquiring permissions. We treat permission polymorphism, while they do \nnot.  8. Conclusions We have used reference immutability to ensure safe (inter\u00adference-free) parallelism, \nin part by combining reference im\u00admutability with external uniqueness. Applying our approach to an intermediate-level \nlanguage led us to derive recovery rules for recovering isolation or immutability in certain con\u00adtexts, \nwhich offers a natural approach to borrowing for lan\u00adguages with reference immutability. Our type system \nmodels a reference immutability system in active use in industry, and we have described their experiences \nwith it. Acknowledgments Thanks to Dan Grossman, Brian Burg, and the anonymous reviewers for helpful \ncomments, and to Michael Ernst for helpful conversations about related work. The .rst author s design \nwork occurred during a Mi\u00adcrosoft internship; proof work was supported by NSF grants CCF-1016701 and \nCNS-0855252. References [1] M. Barnett, M. F\u00a8K. R. M. uller, ahndrich, Leino, P. M\u00a8 W. Schulte, and H. \nVenter. Speci.cation and Veri.cation: The Spec# Experience. Commun. ACM, 54(6):81 91, June 2011. [2] \nK. Bierhoff and J. Aldrich. Modular Typestate Checking of Aliased Objects. In OOPSLA, 2007. [3] G. Bierman, \nC. Russo, G. Mainland, E. Meijer, and M. Torg\u00adersen. Pause n Play: Formalizing Asynchronous C.. In ECOOP, \n2012. [4] R. L. Bocchino, Jr., V. S. Adve, D. Dig, S. V. Adve, S. Heumann, R. Komuravelli, J. Overbey, \nP. Simmons, H. Sung, and M. Vakilian. A Type and Effect System for De\u00adterministic Parallel Java. In OOPSLA, \n2009. [5] R. L. Bocchino, Jr., S. Heumann, N. Honarmand, S. V. Adve, V. S. Adve, A. Welc, and T. Shpeisman. \nSafe Nondeterminism in a Deterministic-by-default Parallel Language. In POPL, 2011. [6] C. Boyapati and \nM. Rinard. A Parameterized Type System for Race-Free Java Programs. In OOPSLA, 2001. [7] C. Boyapati, \nR. Lee, and M. Rinard. Ownership Types for Safe Programming: Preventing Data Races and Deadlocks. In \nOOPSLA, 2002. [8] J. Boyland. Alias Burying: Unique Variables without Destruc\u00adtive Reads. Software Practice \n&#38; Experience, 31(6), 2001. [9] J. Boyland. Checking Interference with Fractional Permis\u00adsions. In \nSAS, 2003. [10] J. T. Boyland and W. Retert. Connecting Effects and Unique\u00adness with Adoption. In POPL, \n2005. [11] D. Clarke, S. Drossopoulou, and J. Noble. Aliasing, Con.ne\u00adment, and Ownership in Object-Oriented \nProgramming. In ECOOP 2003 Workshop Reader, 2004. \u00a8 Ownership for Active Objects. In APLAS, 2008. [12] \nD. Clarke, T. Wrigstad, J. Ostlund, and E. Johnsen. Minimal [13] D. Cunningham, S. Drossopoulou, and \nS. Eisenbach. Universe Types for Race Safety. In VAMP, 2007. [14] W. Dietl, S. Drossopoulou, and P. M\u00a8uller. \nGeneric Universe Types. In ECOOP, 2007. [15] T. Dinsdale-Young, L. Birkedal, P. Gardner, M. Parkinson, \nand H. Yang. Views: Compositional Reasoning for Concurrent Programs. Technical report, 2012. URL https://sites. \ngoogle.com/site/viewsmodel/. [16] M. Fahndrich and R. DeLine. Adoption and Focus: Practical Linear Types \nfor Imperative Programming. In PLDI, 2002. [17] C. Flanagan and M. Abadi. Object Types against Races. \nIn CONCUR, 1999. [18] C. Flanagan and M. Abadi. Types for Safe Locking. In ESOP, 1999. [19] C. Flanagan \nand S. N. Freund. Type-Based Race Detection for Java. In PLDI, 2000. [20] C. S. Gordon, M. J. Parkinson, \nJ. Parsons, A. Brom.eld, and J. Duffy. Uniqueness and Reference Immutability for Safe Parallelism (Extended \nVersion). Technical Report MSR-TR\u00ad2012-79, 2012. [21] C. Haack and E. Poll. Type-Based Object Immutability \nwith Flexible Initialization. In ECOOP, 2009. [22] P. Haller. Isolated Actors for Race-Free Concurrent \nProgram\u00adming. PhD thesis, EPFL, Lausanne, Switzerland, 2010. [23] P. Haller and M. Odersky. Capabilities \nfor Uniqueness and Borrowing. In ECOOP, 2010. [24] C. Hewitt, P. Bishop, I. Greif, B. Smith, T. Matson, \nand R. Steiger. Actor Induction and Meta-Evaluation. In POPL, 1973. [25] K. Leino, P. M\u00a8uller, and A. \nWallenburg. Flexible Immutability with Frozen Objects. In VSTTE, 2008. [26] K. Mazurak, J. Zhao, and \nS. Zdancewic. Lightweight Linear Types in System F.. In TLDI, 2010. [27] P. M\u00a8uller and A. Rudich. Ownership \nTransfer in Universe Types. In OOPSLA, 2007. [28] K. Naden, R. Bocchino, J. Aldrich, and K. Bierhoff. \nA Type System for Borrowing Permissions. In POPL, 2012. [29] P. O Hearn, J. Reynolds, and H. Yang. Local \nReasoning about Programs that Alter Data Structures. In Computer Science Logic, 2001.  \u00a8 [30] J. Ostlund, \nT. Wrigstad, D. Clarke, and B. \u00b0Akerblom. Owner\u00adship, Uniqueness, and Immutability. In Objects, Components, \nModels and Patterns, 2008. [31] M. Parkinson, R. Bornat, and C. Calcagno. Variables as Resource in Hoare \nLogics. In LICS, 2006. [32] U. S. Reddy and J. C. Reynolds. Syntactic Control of Inter\u00adference for Separation \nLogic. In POPL, 2012. [33] J. Reynolds. Separation Logic: A Logic for Shared Mutable Data Structures. \nIn LICS, 2002. [34] J. Richter. CLR Via Cq, Second Edition. Microsoft Press, 2006. ISBN 0735621632. [35] \nJ.-P. Talpin and P. Jouvelot. Polymorphic Type, Region, and Effect Inference. JFP, 2(2), 1992. [36] M. \nTofte and J.-P. Talpin. Implementation of the Typed Call\u00adby-Value .-calculus Using a Stack of Regions. \nIn POPL, 1994. [37] M. S. Tschantz and M. D. Ernst. Javari: Adding Reference Immutability to Java. In \nOOPSLA, 2005. [38] E. Westbrook, J. Zhao, Z. Budimli, and V. Sarkar. Practical Permissions for Race-Free \nParallelism. In ECOOP, 2012. [39] Y. Zibin, A. Potanin, M. Ali, S. Artzi, A. Kiezun, and M. D. Ernst. \nObject and Reference Immutability Using Java Gener\u00adics. In ESEC-FSE, 2007. [40] Y. Zibin, A. Potanin, \nP. Li, M. Ali, and M. D. Ernst. Owner\u00adship and Immutability in Generic Java. In OOPSLA, 2010.    \n\t\t\t", "proc_id": "2384616", "abstract": "<p>A key challenge for concurrent programming is that side-effects (memory operations) in one thread can affect the behavior of another thread. In this paper, we present a type system to restrict the updates to memory to prevent these unintended side-effects. We provide a novel combination of immutable and unique (isolated) types that ensures safe parallelism (race freedom and deterministic execution). The type system includes support for polymorphism over type qualifiers, and can easily create cycles of immutable objects. Key to the system's flexibility is the ability to recover immutable or externally unique references after violating uniqueness without any explicit alias tracking. Our type system models a prototype extension to C# that is in active use by a Microsoft team. We describe their experiences building large systems with this extension. We prove the soundness of the type system by an embedding into a program logic.</p>", "authors": [{"name": "Colin S. Gordon", "author_profile_id": "81496660244", "affiliation": "University of Washington, Seattle, WA, USA", "person_id": "P3856029", "email_address": "csgordon@cs.washington.edu", "orcid_id": ""}, {"name": "Matthew J. Parkinson", "author_profile_id": "81406598777", "affiliation": "Microsoft Research Cambridge, Cambridge, England UK", "person_id": "P3856030", "email_address": "mattpark@microsoft.com", "orcid_id": ""}, {"name": "Jared Parsons", "author_profile_id": "81548330756", "affiliation": "Microsoft, Redmond, WA, USA", "person_id": "P3856031", "email_address": "jaredpar@microsoft.com", "orcid_id": ""}, {"name": "Aleks Bromfield", "author_profile_id": "81444595878", "affiliation": "Microsoft, Redmond, WA, USA", "person_id": "P3856032", "email_address": "albromfi@microsoft.com", "orcid_id": ""}, {"name": "Joe Duffy", "author_profile_id": "81330490217", "affiliation": "Microsoft, Redmond, WA, USA", "person_id": "P3856033", "email_address": "joedu@microsoft.com", "orcid_id": ""}], "doi_number": "10.1145/2384616.2384619", "year": "2012", "article_id": "2384619", "conference": "OOPSLA", "title": "Uniqueness and reference immutability for safe parallelism", "url": "http://dl.acm.org/citation.cfm?id=2384619"}