{"article_publication_date": "10-19-2012", "fulltext": "\n Higher-Order Symbolic Execution via Contracts Sam Tobin-Hochstadt David Van Horn Northeastern University \n {samth,dvanhorn}@ccs.neu.edu Abstract We present a new approach to automated reasoning about higher-order \nprograms by extending symbolic execution to use behavioral contracts as symbolic values, thus enabling \nsymbolic approximation of higher-order behavior. Our approach is based on the idea of an abstract reduc\u00adtion \nsemantics that gives an operational semantics to pro\u00adgrams with both concrete and symbolic components. \nSym\u00adbolic components are approximated by their contract and our semantics gives an operational interpretation \nof contracts-as\u00advalues. The result is an executable semantics that soundly predicts program behavior, \nincluding contract failures, for all possible instantiations of symbolic components. We show that our \napproach scales to an expressive language of con\u00adtracts including arbitrary programs embedded as predicates, \ndependent function contracts, and recursive contracts. Sup\u00adporting this rich language of speci.cations \nleads to powerful symbolic reasoning using existing program constructs. We then apply our approach to \nproduce a veri.er for con\u00adtract correctness of components, including a sound and com\u00adputable approximation \nto our semantics that facilitates fully automated contract veri.cation. Our implementation is ca\u00adpable \nof verifying contracts expressed in existing programs, and of justifying contract-elimination optimizations. \nCategories and Subject Descriptors D.2.4 [Software Engi\u00adneering]: Software/Program Veri.cation; D.3.1 \n[Program\u00adming Languages]: Formal De.nitions and Theory General Terms Languages, Theory, Veri.cation Keywords \nHigher-order contracts, symbolic execution, re\u00adduction semantics Permission to make digital or hard copies \nof all or part of this work for personal or classroom use is granted without fee provided that copies \nare not made or distributed for pro.t or commercial advantage and that copies bear this notice and the \nfull citation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. OOPSLA 12, October 19 26, 2012, Tucson, Arizona, \nUSA. Copyright c &#38;#169; 2012 ACM 978-1-4503-1561-6/12/10. . . $10.00 1. Behavioral contracts as symbolic \nvalues Whether in the context of dynamically loaded JavaScript programs, low-level native C code, widely-distributed \nli\u00adbraries, or simply intractably large code bases, automated reasoning tools must cope with access to \nonly part of the program. To handle missing components, the omitted por\u00adtions are often assumed to have \narbitrary behavior, greatly limiting the precision and effectiveness of the tool. Of course, programmers \nusing external components do not make such conservative assumptions. Instead, they at\u00adtach speci.cations \nto these components, often with dynamic enforcement. These speci.cations increase their ability to reason \nabout programs that are only partially known. But reasoning solely at the level of speci.cation can also \nmake veri.cation and analysis challenging as well as requiring substantial effort to write suf.cient \nspeci.cations. The problem of program analysis and veri.cation in the presence of missing data has been \nwidely studied, producing many effective tools that apply symbolic execution to non\u00addeterministically \nconsider many or all possible inputs. These tools typically determine constraints on the missing data, \nand reason using these constraints. Since the central lesson of higher-order programming is that computation \nis data, we propose symbolic execution of higher-order programs for reasoning about systems with omitted \ncomponents, taking speci.cations to be our constraints. Our approach to higher-order symbolic execution \nthere\u00adfore combines speci.cation-based symbolic reasoning about opaque components with semantics-based \nconcrete reason\u00ading about available components; we characterize this tech\u00adnique as speci.cations as values. \nAs speci.cations, we adopt higher-order behavioral software contracts [17]. Contracts have two crucial \nadvantages for our strategy. First, they pro\u00advide bene.t to programmers outside of veri.cation, since \nthey automatically and dynamically enforce their described invariants. Because of this, modern languages \nsuch as C#, Haskell, and Racket come with rich contract libraries that programmers already use [15, 17, \n22]. Rather than requir\u00ad ing programmers to annotate code with assertions, we lever\u00adage the large body \nof code that already attaches contracts at code boundaries. For example, the Racket standard library \nfeatures more than 4000 uses of contracts [21]. Second, the meaning of contracts as speci.cations is \nneatly captured by  (define-contract list/c (rec/c X (or/c empty? (cons/c nat? X)))) (module opaque \n(provide [insert (nat? (and/c list/c sorted?) -> (and/c list/c sorted?))] [nums list/c]))) (module insertion-sort \n(require opaque) (define (foldl f l b) (if (empty? l) b (foldl f (cdr l) (f (car l) b)))) (define (sort \nl) (foldl insert l empty)) (provide [sort (list/c -> (and/c list/c sorted?))])) > (sort nums) ( (and/c \nlist/c sorted?)) Figure 1. Veri.cation of insertion sort their dynamic semantics. As we shall see, we \nare able to turn the semantics of contract systems into tools for veri.\u00adcation of programs with contracts. \nVerifying contracts holds promise both for ensuring correctness and improving perfor\u00admance: in existing \nRacket code, contract checks take more than half of the running time for large computations such as rendering \ndocumentation and type checking large pro\u00adgrams [39]. Our plan is as follows: we begin with a review \nof con\u00adtracts in the setting of Contract PCF [12](\u00a72). Next, we ex\u00adtend Contract PCF with abstract values \ndescribed by spec\u00adi.cations, producing a core model of symbolic execution for our language of higher-order \ncontracts, which we dub Symbolic PCF with Contracts (\u00a73). This allows us to give non-deterministic behavior \nto programs in which any num\u00adber of modules are omitted, represented only by their spec\u00adi.cations; here \ngiven as contracts. We accomplish this by treating contracts as abstract values, with the behavior of \nany of their possible concrete instantiations. Contracts as abstract values provides a rich domain of \nsymbols, including precise speci.cations for abstract higher\u00adorder values. These values present new complications \nto soundness, addressed with a demonic context, a universal context for discovering blame for behavioral \nvalues (\u00a73.5). We then extend this core calculus to a model of pro\u00adgrams with modules including opaque \nmodules whose im\u00adplementation is not available and a much richer contract language (\u00a74), modeling the \nfunctional core of Racket [19]. We show that our symbolic execution strategy soundly scales up from Symbolic \nPCF to this more complex language while preserving its advantages in higher-order reasoning. More\u00adover, \nthe technique of describing symbolic values with con\u00adtracts becomes even more valuable in an untyped \nsetting. As the modular semantics is uncomputable, this veri.ca\u00adtion strategy is necessarily incomplete. \nTo address this, we apply the technique of abstracting abstract machines [42] to derive .rst an abstract \nmachine and then a computable approximation to our semantics from our reduction system (\u00a75). We then \nturn our semantics into a tool for program ver\u00adi.cation which is integrated into the Racket toolchain \nand IDE (\u00a76). Users can click a button and explore the behav\u00adior of their program in the presence of \nopaque modules, ei\u00adther with a potentially non-terminating semantics, or with a computable approximation. \nFinally, we discuss prior work in symbolic execution, veri.cation of speci.cations, and anal\u00adysis of \nhigher-order programs (\u00a77) and conclude. Our semantics allows us to use contracts for veri.cation in \ntwo senses: to verify that programs do not violate their contracts, and to verify rich properties of \nprograms by ex\u00adpressing them as contracts. In fact, the semantics alone is, in itself, a program veri.er. \nThe execution of a modular pro\u00adgram which runs without contract errors on any path is a ver\u00adi.cation \nthat the concrete portions of the program never vi\u00adolate their contracts, no matter the instantiation \nof the omit\u00adted portions. This technique is surprisingly effective, partic\u00adularly in systems with many \nlayers, each of which use con\u00adtracts at their boundaries. For example, the implementation of insertion \nsort in .gure 1 is veri.ed to live up to its con\u00ad tract, which states that it always produces a sorted \nlist. This veri.cation works despite the omitted insert function, used in higher-order fashion as an \nargument to foldl. Contributions We make the following contributions: 1. We propose abstract reduction \nsemantics as a technique for higher-order symbolic execution. This is a variant of operational semantics \nthat treats speci.cations as values, to enable modular reasoning about partially unknown programs. 2. \nWe give an abstract semantics for a core typed functional language with contracts that equips symbolic \nvalues, rep\u00adresented as sets of contracts, with an operational inter\u00adpretation. This semantics allows \nsound reasoning about opaque program components with rich speci.cations by soundly predicting program \nbehavior for all possible in\u00adstantiations of those opaque components. We then scale this semantics up \nto model a more realistic untyped lan\u00adguage with modules and an expressive set of contract combinators. \n 3. We derive a sound and computable program analysis based on our semantics that can serve as the basis \nfor automated program veri.cation, optimization, and static debugging. 4. We provide a prototype implementation \nof an interactive veri.cation environment based on our models that suc\u00adcessfully veri.es existing programs \nwith contracts.   2. Contracts and Contract PCF The basic building block of our speci.cation system \nis behavioral software contracts. Originally introduced by Meyer [31], contracts are executable speci.cations \nthat sit at the boundary between software components. In a .rst-order setting, properly assessing which \ncomponent violated a con\u00adtract at run-time is straightforward. Matters are complicated when higher-order \nvalues such as functions or objects are in\u00adcluded in the language. Findler and Felleisen [17] introduced \nthe notion of blame and established a semantic framework for properly assessing blame at run-time in \na higher-order language, providing the theoretical basis for contract sys\u00adtems such as Racket s. (module \ndouble (provide [dbl ((even? -> even?) -> (even? -> even?))]) (define dbl (. (f) (. (x) (f (f x)))))) \n> (dbl (. (x) 7)) top-level broke the contract on dbl; expected <even?>, given: 7 To illustrate, consider \nthe program above, which consists of a module and top-level expression. Module double pro\u00advides a dbl \nfunction that implements twice-iterated applica\u00adtion, operating on functions on even numbers. The top-level \nexpression makes use of the dbl function, but incorrectly dbl is applied to a function that produces \n7. Contract checking and blame assignment in a higher\u00adorder program is complicated by the fact that it \nis not de\u00adcidable in general whether the argument of dbl is a function from and to even numbers. Thus, \nhigher-order contracts are pushed down into delayed lower-order checks, but care must be taken to get \nblame right. In our example, the top-level is blamed, and rightly so, even though even? witnesses the \nviolation when f is applied to x while executing dbl. 2.1 Contract PCF Dimoulas et al. [12, 13] introduce \nContract PCF as a core calculus for the investigation of contracts, which we take as the starting point \nfor our model. CPCF extends PCF [33] with contracts for base values and .rst-class functions. We provide \na brief recap of the syntax and semantics of CPCF. Contracts for .at values, .at(E), employ predicates \nthat may use the full expressive power of CPCF. Function con\u00adtracts, C1 . C2, consist of a pre-condition \ncontract C1 for the argument to the function and a post-condition contract C2 for the function s result. \nDependent function contracts, C1 . .X.C2, bind X to the argument of the function in the post-condition \ncontract C2, and thus express a dependency between a function s input and result. In the remainder of \nthe paper, we treat the non-dependent function contract C1 .C2 as shorthand for C1 ..X.C2 where X is \nfresh. PCF with Contracts Types T ::= B | T . T | con(T ) Base types B ::= N | B Terms E ::= A | X | \nEE | \u00b5X :T.E | if EEE f,f | O1(E) | O2(E, E) | mon(C, E) f Operations O1 ::= zero? | false? | ... O2 \n::= + |-|.|.| ... Contracts C ::= .at(E) | C .C | C ..X :T.C Answers A ::= V |E[blamef ] f Values V ::= \n.X :T.E | 0 | 1 |- 1 | ... | tt | . Evaluation E ::= [ ] |E E | V E| O2(E,E) | O2(V, E) f,g contexts \n| O1(E) | if E EE | mon(C, E) h Semantics for PCF with Contracts E -. E' if tt E1 E2 -. E1 if. E1 E2 \n-. E2 (.X : T.E) V -. [V/X]E \u00b5X : T.E -. [\u00b5X :T .E/X]E O((V ) -. A if d(O, V()= A f,g mon(C1 ..X :T.C2,V \n) -. h f,g g,f .X :T.mon(C2, (V mon(C1,X))) hh monf,g(.at(E),V ) -. if (EV ) V blamef hh A contract C \nis attached to an expression with the monitor construct monf,g(C, E), which carries three labels: f, \ng, and h h, denoting the names of components which may be blamed for contract failure. (An implementation \nwould synthesize these names from the source code.) The monitor checks any interaction between the expression \nand its context is in accordance with the contract. Component labels play an important role in case a \ncon\u00adtract failure is detected during contract checking. In such a case, blame is assigned with the blamef \nconstruct, which g states that the component named f broke its contract with g. CPCF is equipped with \na standard type system for PCF plus the addition of a contract type con(T ), which denotes the set of \ncontracts for values of type T [12, 13]. The type system is straightforward, so for the sake of space, \nwe defer the details to an appendix (\u00a7A.1). The semantics of CPCF are given as a call-by-value re\u00adduction \nrelation on programs. One-step reduction E -. E' is de.ned above, contextually closed over evaluation \ncon\u00adtexts E; its re.exive transitive closure is written E -. E'. The .rst .ve cases of the reduction \nrelation are stan\u00addard for PCF. The remaining two cases implement con\u00adtract checking for function contracts \nand .at contracts, re\u00adspectively. The monitor of a function contract on a func\u00adtion reduces to a function \nthat monitors its input with re\u00adversed blame labels and monitors its output with the origi\u00adnal blame \nlabels.1 The monitor of a .at contract reduces to an if-expression which tests whether the predicate \nholds. If it does, the value is returned. Otherwise, a contract error is signaled with appropriate blame. \n 3. Symbolic PCF with Contracts We now present an extension to Contract PCF and its seman\u00adtics that \nenriches the language with symbolic values, drawn from the language of contracts. The key idea of SCPCF \nis to take the values of CPCF as pre -values U and add a no\u00adtion of an unknown values (of type T ), written \n T . Purely unknown values have arbitrary behavior, but we re.ne un\u00adknowns by attaching a set of contracts \nthat specify an agree\u00adment between the program and the missing component. Such re.nements can guide an \noperational characterization of a program. Pre-values are re.ned by a set of contracts to form a value, \nU/C, where C ranges over sets of contracts. The high-level goal of the following semantics is to en\u00adable \nthe running of programs with unknown components. The main requirement is that the results of running \nsuch computations should soundly and precisely approximate the result of running that same program after \nreplacing an un\u00adknown with any allowable value. More precisely, if a pro\u00adgram involving some value V \nproduces an answer A, then abstracting away that value to an unknown should produce an approximation \nof A: if E[V ] -. A and f V : T , then E[ T ] -. A ' , where A ' approximates A. Notation: Abstract (or \nsynonymously: symbolic) values VVrange over values of the form T /C. Whenever the re.ne\u00adment of a value \nis irrelevant, we omit the C set. We write V \u00b7 C for U/C.{C} where V = U/C. The semantics given below \nreplace that of section 2, equipping the operational semantics with an interpretation of symbolic values. \n(The semantics of contract checking is deferred for the moment.) To do so requires two changes: 1. the \nd relation must be extended to interpret operations when applied to symbolic values, and 2. the one-step \nreduction relation must be extended to the cases of (1) branching on a (potentially) symbolic value, \nand (2) applying a symbolic function.  3.1 Operations on symbolic values Typically, the interpretation \nof operations is de.ned by a function d that maps an operation and argument values to 1 For simplicity, \nwe present the so-called lax dependent contract rule; our implementation uses indy [13], obtained by \nreplacing the contractum with: f,g f,h g,f .X :T.mon([mon(C1,X)/X]C2,V mon(C1,X)). hh h Symbolic PCF \nwith Contracts Prevalues U ::= T | .X :T.E | 0 | 1 |- 1 | ... | tt | . Values V ::= U/{C, . . . } Semantics \nfor Symbolic PCF with Contracts E -. E ' if VE1 E2 -. E1 if d(false?,V ) . if VE1 E2 -. E2 if d(false?,V \n) tt (.X : T.E) V -. [V/X]E \u00b5X : T.E -. [\u00b5X : T .E/X]E O(V() -. A if d(O, V() A ( T .T !/C) V -. T ! \n/{[V/X]C2 | C1 ..X :T.C2 . C} ( T .T !/C) V -. havocT V an answer, e.g. d(add1, 0) = 1. The result of \napplying a primitive may either be a value in case the operation is de.ned on its given arguments, or \nblame in case it is not. The extension of d to interpret symbolic values is largely straightforward. \nIt starts by generalizing d from a function from an operation and values to an answer, to a relation \nbetween operations, values, and answers (or equivalently, to a function from an operation and values \nto sets of answers). This enables multiple results when a symbolic value does not convey enough information \nto uniquely determine a single result. For example, d(zero?, 0) = {tt}, but d(zero?, N)= {tt, .}. From \nhere, all that remains is adding appropriate clauses to the de.nition of d for handling symbolic values. \nAs an example, the de.nition includes: d(+,V1,V2) N, if V1 or V2 = N/C. The remaining cases are similarly \nstraightforward. The revised reduction relation reduces an operation, non\u00addeterministically, to any answer \nin the d relation.  3.2 Branching on symbolic values The shift from the semantics of section 2 to section \n3 also in\u00advolves what appears to be a cosmetic change in the reduction of conditionals, e.g., from if \ntt E1 E2 -. E1 to if VE1 E2 -. E1 if d(false?,V ) .. In the absence of symbolic values, the two relations \nare equivalent, but once symbolic values are introduced, the latter handles branching on potentially \nsymbolic values by deferring to d to determine if V is possibly true. Conse\u00adquently branching on B results \nin both E1 and E2 since d(false?, B)= {tt, .}. Without this slight refactoring for conditionals, additional \ncases for the reduction relation are required, and these cases would largely mimic the existing if reductions. \nBy reformulating in terms of d, we enable the uniform reduction of abstract and concrete values.  3.3 \nApplying symbolic functions When applying a symbolic function V , the reduction relation must take two \ndistinct possibilities into account. The .rst is that although the argument to the symbolic function \nescapes, no failure occurs in the unknown context, so the function returns an abstract value re.ned by \nthe range contracts of the function. The second is that the use of V in a unknown context results in \nthe blame of V . To discover if blaming V is possible we rely upon a havoc function, which iteratively \nexplores the behavior of V for possible blame. Its only purpose is to uncover blame, thus it never produces \na value; it either diverges or blames V . In this simpli.ed model, the only behavioral values are functions, \nso we represent all possible uses of the escaped value by iteratively applying it to unknown values. \nThis construction represents a universal demonic context to discover a way to blame V if possible, and \nwe have named the function havoc to emphasize the analogy to Boogie s havoc function [14], which serves \nthe same purpose, but in a .rst-order setting. The havoc function is indexed by the type of its argu\u00adment. \nAt base type, values do not have behavior, so havoc simply produces a diverging computation. At function \ntype, havoc produces a function that applies its argument to an ap\u00adpropriately typed unknown input value \nand then recursively applies havoc at the result type to the output: havocB = \u00b5x.x ' havocT .T ! = .x \n:T . T.havocT ! (x T ) This means that havocT V either diverges or produces blame, and thus never introduces \nspurious results, and fur\u00adther that applications of havocT can be given whatever type is required for \nthe context. To see how havoc .nds all possible errors in a term, consider the following function guarded \nby a contract (the mon function wraps a value with a contract): mon(.f :N . N.sqrt (f 0), (any .any).any) \nwhere any is the trivial contract .at(.x.tt) and sqrt has the type N . N and contract .at(positive?) \n. .at(positive?). If we then apply havoc to this term at the appropriate type, it will supply the input \nN.N for f. When this abstract value is applied to 0, it reduces both to havocN 0, a diverging term that \nproduces no blame, and the symbolic number N . Finally, sqrt is applied to N, which both passes and fails \nthe contract check on sqrt, since N represents both positive and non-positive numbers; the latter demonstrates \nthe original function could be blamed. In contrast, if the original term was wrapped in the con\u00adtract \n(any . .at(positive?)) . any, then the abstract value N.N would have been wrapped in the contract any \n. .at(positive?). When the wrapped abstract function is ap\u00adplied to 0, it then produces the more precise \nabstract value N \u00b7 .at(positive?) as the input to sqrt and fails to blame the original function. The \nability of havoc to .nd blame if possible is key to our soundness result.  3.4 Contract checking symbolic \nvalues We now turn to the revised semantics for contract checking reductions in the presence of symbolic \nvalues. The key ideas are that we 1. avoid checking any contracts which a value provably satis.es, and \n 2. add .at contracts to a value s re.nement set whenever a contract check against that value succeeds. \n To implement the .rst idea, we add a reduction relation that sidesteps a contract check and just produces \nthe checked value whenever the value proves it satis.es the contract. To implement the second idea, we \nrevise the .at contract checking reduction relation to produce not just the value, but the value re.ned \nby the contract in the success branch of a .at contract check. Contract checking, revisited monf,g (C, \nV ) -. V if f V : C . h f,g mon(.at(E),V ) -. h if (EV )(V \u00b7 .at(E)) blamef if f V : .at(E) . g f,g mon(C1 \n..X :T.C2,V ) -. h f,g g,f .X :T.mon(C2,V mon(C1,X)) hh if f V : C1 ..X :T.C2 . The judgment f V : C \n. denotes that V provably satis\u00ad.es the contract C, which we read as V proves C. Our system is parametric \nwith respect to this provability relation and the precision of the symbolic semantics improves as the \npower of the proof system increases. For concreteness, we begin by considering the following simple, \nyet useful proof system which asserts a symbolic value proves any contract it is re.ned by: C .C f V/C \n: C . As we will see subsequently, this relation can easily be extended to handle more sophisticated \nreasoning. Taken together, the revised contract checking relation and proves relation allow values to \nremember contracts once they are checked and to avoid rechecking in subsequent computations. Consider \nthe following program with abstract pieces: let keygen = mon(unit..at(prime?), ) rsa = mon(.at(prime?) \n.(any .any), ) in rsa (keygen ()) Plaintext  When invoking keygen, the result is an abstract value since \nkeygen s source is not available to be veri.ed. However, this abstract value remembers the prime? contract, \nmeaning that our semantics correctly predicts that the top level applica\u00adtion does not break rsa s contract \nby providing a composite number. This veri.es that regardless of the implementation of keygen and rsa, \nwhich may themselves be buggy, their composition is veri.ed to uphold its obligations.  3.5 Soundness \nSoundness relies on the de.nition of approximation between terms. We write E E ' to mean E ' approximates \nE, or conversely E re.nes E '. The basic intuition for approxima\u00adtion is an abstract value, which can \nbe thought of as stand\u00ading for a set of acceptable concrete values, approximates a concrete value if \nthat value is in the set the abstract value denotes. Since the T value stands for any value of type T \n, we have the following axiom: f V : T V T (In subsequent judgments, we assume both sides of the ap\u00adproximation \nrelation are typable at the same type and thus omit type annotations and judgments.) A monitored expres\u00adsion \nis approximated by its contract: mon(C, E) \u00b7 C To handle the approximation of wrapped functions, we em\u00adploy \nthe following rule, which matches the right-hand side of the reduction relation for the monitor of a \nfunction: (.X.mon(D, (V mon(C, X)))) \u00b7 C ..X.D Arbitrary additional contract re.nements may be introduced \non the approximated value as follows: V \u00b7 C V A contract may be eliminated when a value proves it: f \nV : C . V V \u00b7 C If an expression approximates a monitored expression, it s OK to monitor the approximating \nexpression too: mon(C, E) E ' mon(C, E) mon(C, E ' ) Finally, is re.exively, transitively, and compatibly \nclosed. Theorem 1 (Soundness of Symbolic PCF with Contracts). If E E ' and E -. A, then there exists \nsome A ' such that E ' -. A ' where A A ' . Proof. (Sketch) The proof follows from (1) a completeness \nresult for havoc, which states that if E[V ] -. E ' [blame\u00a3] where \u00a3 is not in E, then havoc V -. E '' \n[blame\u00a3], and (2) the following main lemma: if E1 -. E1 ' = E[blamefg ], and E1 E2, then E2 -. E ' and \nE1' E ' , which is in turn 22 proved reasoning by cases on E1 -. E ' and appealing to 1 auxiliary lemmas \nthat show approximation is preserved by substitution and primitive operations. The full proof for the \nenriched system of section 4 is given in section 4.5. The soundness result achieves the high-level goal \nstated at the beginning of this section: we have constructed an ab\u00adstract reduction semantics for the \nsound symbolic execu\u00adtion of programs such that their symbolic execution approx\u00adimates the behavior of \nprograms for all possible instantia\u00adtions of the opaque components. In particular, we can verify pieces \nof programs by running them with missing compo\u00adnents, re.ned by contracts. If the abstract program does \nnot blame the known components, no context can cause those components to be blamed. 4. Symbolic Core \nRacket Having developed the core ideas of our symbolic executor for programs with contracts, we extend \nour language to an untyped core calculus of modular programs with data struc\u00adtures and rich contracts. \nThis forms a core model of a re\u00adalistic programming language, Racket [19]. In addition to closely modeling \nour target language, omitting types places a greater burden on the contract system and symbolic execu\u00adtor. \nAs we see in this section, ours is up to the job. To SCPCF we add pairs, the empty list, and related \noper\u00adations; contracts on pairs; recursive contracts; and conjunc\u00adtive and disjunctive contracts. Predicates, \nas before, are ex\u00adpressed as arbitrary programs within the language itself. Pro\u00adgrams are organized as \na set of module de.nitions, which as\u00adsociate a module name with a value and a contract. Contracts are \nestablished at module boundaries and here express an agreement between a module and the external context. \nThe contract checking portion of the reduction semantics moni\u00adtors these agreements, maintaining suf.cient \ninformation to blame the appropriate party in case a contract is broken. 4.1 Syntax The syntax of our \nlanguage is given in .gure 2. We write E(for a possibly-empty sequence of E, and treat these se\u00adquences \nas sets where convenient. Portions highlighted in gray are the key extensions over SCPCF, as presented \nin ear\u00adlier sections. A program P consists of a sequence of modules fol\u00adlowed by a main expression. Modules \nare second-class en\u00adtities that name a single value along with a contract to be applied to that value; \nmodule names are in scope through\u00adout the program. Opaque modules are modules whose body is . Expressions \nnow include module references, labeled by  ( P, Q ::= ME M, N ::= (module fCV ) E, E ' ::= f\u00a3 | X | \nA | EE\u00a3 | if EEE | O E(\u00a3 | \u00b5X.E \u00a3,\u00a3 | mon (C, E) \u00a3 U ::= n | tt | . | (.X.E) | | (V, V ) | empty V ::= \nU/C C, D ::= X | C ..X.C | .at(E) |(C,C)| C . C | C . C | \u00b5X.C O ::= add1 | car | cdr | cons | + | = \n| o? | ... o? ::= nat? | bool? | empty? | cons? | proc? | false? A ::= V |E[blame\u00a3\u00a3] Figure 2. Syntax \nof Symbolic Core Racket the module they appear in; this label is used as the nega\u00adtive party for the \nmodule s contract. Applications are also labeled; this label is used if the application fails. Pair val\u00adues \nand the empty list constant are standard, along with their operations. Since the language is untyped, \nwe add standard type predicates such as nat?. The new contract forms include pair contracts, (C,D), conjunction, \nC .D, and disjunction, C .D, of contracts, and explicit recursive contracts with contract variables, \n\u00b5X.C. Contract checks monf,g (C, E), which will now be in\u00ad h serted automatically by the operational \nsemantics, take all of their labels from the names of modules, with the third label h representing the \nmodule in which the contract orig\u00adinally appeared. As before, f represents the positive party to the \ncontract, blamed if the expression does not meet the contract, and g is the negative party, blamed if \nthe context does not satisfy its obligations. Whenever these annotations can be inferred from context, \nwe omit them; in particular, in the de.nition of relations, it is assumed all checks of the form mon(C, \nE) have identical annotations. We omit labels on applications whenever they provably cannot be blamed, \ne.g. when the operand is known to be a function. A blame expression, blame\u00a3\u00a3! , now indicates that the \nmod\u00adule (or the top-level expression) named by \u00a3 broke its con\u00adtract with \u00a3 ', which may be the name \nof a module f, the top-level expression , or the language, indicated by ., in the case of primitive errors. \nSyntactic requirements: We make the following assump\u00adtions of initial programs P : programs are closed, \nevery mod\u00adule reference and application is labeled with the enclosing module name, or for the top-level \nexpression, operations are applied with the correct arity, abstract values only appear in opaque module \nde.nitions, and no monitors or blame ex\u00adpressions appear in source programs. We also require that recursive \ncontracts be productive, meaning either a function or pair contract constructor must occur between binding \nand reference. We also require that contracts in the source program are closed, both with respect to \n.-bound and contract variables. Following standard prac\u00adtice, we will say that a contract is higher-order \nif it syntac\u00adtically contains a function contract; otherwise, the contract is .at. Flat contracts can \nbe checked immediately, whereas higher-order contracts potentially require delayed checks. All predicate \ncontracts are necessarily .at. Disjunction of contracts: For disjunctions, we require that at most one \ndisjunct is higher-order and without loss of gen\u00aderality, we assume it is the right disjunct. The reason \nfor this restriction is that we must choose at the time of the initial check of the contract which disjunct \nto use we cannot just try both because higher-order checks must be delayed. In Racket, disjunction is \nthus restricted to contracts that are dis\u00adtinguishable in a .rst-order way, which we simplify to the \nrestriction that only one can be higher-order.  4.2 Reductions Evaluation is modeled with one-step reduction \non programs, P -. Q. Since the module context consists solely of syn\u00adtactic values, all computation occurs \nby reduction of the top\u00adlevel expression. Thus program steps are de.ned in terms of top-level expression \nsteps, carried out in the context of several module de.nitions. We model this with a reduction relation \non expressions in a module context, which we write ( M f E -. E '. We omit the the module context where \nit is not used and write E -. E ' instead. Our reduction sys\u00adtem is given with evaluation contexts, which \nare identical to those of SCPCF in section 3. We present the de.nition of this relation in several parts. \n 4.2.1 Applications, operations, and conditionals First, the de.nition of procedure applications, conditionals, \nand primitive operations is as usual for a call-by-value lan\u00adguage. Primitive operations are interpreted \nby a d relation (rather than a function), just as in section 3. The reduction relation for these terms \nis de.ned as follows: Basic reductions E -. E ' ((.X.E) V )\u00a3 -. [V/X]E (VV ' )\u00a3 -. blame\u00a3 . if d(proc?,V \n) . (O (V )\u00a3 -. A if d(O\u00a3 , (V ) A if VE E ' -. E if d(false?,V ) . if VE E ' -. E ' if d(false?,V ) \ntt Again, we rely on d not only to interpret operations, but also to determine if a value is a procedure \nor .; this allows uniform handling of abstract values, which may (depending on their remembered contracts) \nbe treated as both true and false. We add a reduction to blame\u00a3 when applications are . misused; the \nprogram has here broken the contract with the language, which is no longer checked statically by the \ntype system as it was in SCPCF. Additionally, our rules for if follow the Lisp tradition, which Racket \nadopts, in treating all non-. values as true.  Primitive operations (concrete values) d(O\u00a3 , V() A misused, \nas in the last case, and are omitted where irrelevant. When primitive operations are misused, the violated \ncontract d(add1,n) n +1 is on ., standing for the programming language itself, just d(+,n, m) n + m as \nin the rule for application of non-functions. d(car, (V, V ' )) V d(cdr, (V, V ' )) V '  4.2.3 Module \nreferences Primitive operations (abstract values) f V : o? . =. d(o?,V ) tt f V : o? . =. d(o?,V ) . \nf V : o? ? =. d(o?,V ) /{.at(bool?)} f V : nat? . =. d(add1,V ) /{.at(nat?)} f V : nat? . =. d(add1\u00a3,V \n) blame\u00a3 add1 f V : nat? ? =. d(add1,V ) /.at(nat?) . d(add1\u00a3,V ) blame\u00a3 add1 f V : cons? . =. d(car,V \n) p1(V ) f V : cons? . =. d(car\u00a3,V ) blame\u00a3 car f V : cons? ? =. d(car,V ) p1(V ) . d(car\u00a3,V ) blame\u00a3 \ncar otherwise d(O\u00a3 , V() blame\u00a3 . Figure 3. Basic operations 4.2.2 Basic operations Basic operations, \nas with procedures and conditionals, fol\u00adlow SCPCF closely. Operations on concrete values are stan\u00addard, \nand we present only a few selected cases. Operations on abstract values are more interesting. A few selected \ncases are given in .gure 3 as examples. Otherwise, the de.nition of d for concrete values is standard \nand we relegate the re\u00admainder to the auxiliary materials (\u00a7A.2). When applying base operations to abstract \nvalues, the re\u00adsults are potentially complex. For example, add1 might produce any natural number, or \nit might go wrong, depend\u00ading on what value represents. We represent this in d with a combination of \nnon-determinism, where d relates an oper\u00adation and its inputs to multiple answers, as well as abstract \nvalues as results, to handle the arbitrary natural numbers or booleans that might be produced. A representative \nselection of the d de.nition for abstract values is presented in .gure 3. The de.nition of d relies \non a proof system relating predicates and values, just as with contract checking. Here, f V : o? . means \nthat V is known to satisfy o?, f V : o? . means that V is known not to satisfy o?, and f V : o? ? means \nneither is known. For example, f 7: nat? ., f tt : cons? ., and f : o? ? for any o?. (Again, our system \nis parametric with respect to this proof system, although we present a useful instance in section 4.3.) \nFinally, if no case matches, then an appropriate error is produced. Labels on operations come from the \napplication site of the operation in the program, e.g., (add1 5)\u00a3, so that the appro\u00adpriate module can \nbe blamed when primitive operations are To handle references to module-bound variables, we de.ne a module \nenvironment that describes the module context M(. Using the module reference annotation, the environment \ndis\u00adtinguishes between self references and external references. When an external module is referenced \n(f = g), its value is wrapped in a contract check; a self-reference is resolved to its (unchecked) value. \nThis distinction implements the no\u00adtion of contracts as boundaries [17], in other words, con\u00ad tracts \nare an agreement between the module and its context, and the module can behave internally as it likes. \n( Module references M f fg -. E M(f ff -. V if (module fCV ) . M(M(f fg -. monf,g (C, V ) if (module \nfCV ) . M( f (f,g M f fg -. mon(C, \u00b7 C) if (module fC ) . M( f  4.2.4 Contract checking With the basic \nrules handled, we now turn to the heart of the system, contract checking. As in section 3, as computation \nis carried out, we can discover properties of values that may be useful in subsequently avoiding spurious \ncontract errors. Our primary mechanism for remembering such discoveries is to add properties, encoded \nas contracts, to values as soon as the computational process proves them. If a value passes a .at contract \ncheck, we add the checked contract to the value s remembered set. Subsequent checks of the same contract \nare thus avoided. We divide contract checking reductions into two categories, those for .at contracts \nand those for higher\u00adorder contracts, and consider each in turn. Flat contracts: First, checking .at \ncontracts is handled by three rules, presented in .gure 4, depending on whether the value has already \npassed the relevant contract. The .rst two rules consider the case where the value de.nitely does pass \nthe contract, written f V : C . ( V proves C ), or does not pass, written f V : C . ( V refutes C ). \nIf neither of these is the case, written f V : C ?, the third rule implements a contract check by compiling \nit to an if-expression. The test is an application of the function generated by FC(C) to V . If the test \nsucceeds, V \u00b7 C is produced. Otherwise, the positive party, here f, is blamed for breaking the contract \non h. The three judgments checking the relation between values and contracts are a simple proof system; \nby parameterizing over these relations, we enable our system to make use of sophisticated existing decision \nprocedures. For the moment,  Flat contract reduction mon(C, V ) -. E ' monf,g h (C, V ) -. V \u00b7 C if \nC is .at and f V : C . monf,g h (C, V ) -. blamef h if C is .at and f V : C . f,g mon(C, V ) -. if (FC(C) \nV )(V \u00b7 C) blamef hh if C is .at and f V : C ? Flat contract checking FC(C)= E FC(\u00b5X.C)= \u00b5X.FC(C) FC(X)= \nX FC(.at(E)) = E FC(C1 . C2)= .y.if (FC(C1) y)(FC(C2) y) . FC(C1 . C2)= .y.if (FC(C1) y) tt (FC(C2) \ny) FC((C1,C2))= .y.(and (cons? y)(FC(C1)(car y)) (FC(C2)(cdr y))) Figure 4. Flat contracts the key property \nis that f V \u00b7 C : C . holds, just as in sec\u00adtion 3.4, and further details are discussed in section 4.3. \n Compiling .at checks to predicates: The FC metafunc\u00adtion, also in .gure 4, takes a .at contract and \nproduces the source code of a function, which when applied to a value produces true or false indicating \nwhether the value passes the contract. The additional complexity over the similar rules of sections 2 \nand 3 handles the addition of .at contracts con\u00ad taining recursive contracts, disjunctive and conjunctive \ncon\u00adtracts, and pair contracts. In particular, to check disjunctive contracts, we must test if the left \ndisjunct passes the contract, and branch on the result, whereas our earlier reduction rules for .at contracts \nsimply fail for contracts that don t pass. As an example, the expression monf,g (.at(nat?),V ) re\u00ad h \nduces to if (nat? V ) V blamef , but using this reduction to h check the left disjunct of mon(.at(nat?) \n. .at(bool?), tt) would cause a blame error, which is obviously not the in\u00adtended result. Instead, the \nrules for FC generate the check if ((nat? tt) . (bool? tt)) tt blame, which then succeeds. Higher-order \ncontracts: The next set of reduction rules, presented in .gure 5, de.nes the behavior of higher-order \ncontract checks; we assume here that the contract is not .at. In the .rst rule, we again use the .-expansion \ntechnique pioneered by Findler and Felleisen [17] to decompose a higher-order contract into subcomponents. \nThis rule only ap\u00adplies if the contracted value V is indeed a function, as indi\u00adcated by proc? (In SCPCF, \nthis side-condition is unneces\u00adsary thanks to the type system). Otherwise, the second rule blames the \npositive party of a function contract when the supplied value is not a function. The remaining rules \nhandle higher-order contracts that are not immediately function contracts, such as pairs of func\u00adtion \ncontracts. The .rst two are for pair contracts. If the value is determined to be a pair by cons?, then \nthe components are Function contract reduction mon(C, V ) -. E ' f,g mon(C ..X.D, V ) -. h f,g g,f (.X.mon(D, \n(V mon(C, X)))) hh if d(proc?,V ) tt monf,g (C ..X.D, V ) -. blamef if d(proc?,V ) . hh Other higher-order \ncontract reductions mon((C,D),V ) -. (cons mon(C, car V ' ) mon(D, cdr V ' )) if d(cons?,V ) tt and V \n' = V \u00b7 .at(cons?) f,g mon((C,D),V ) -. blamef if d(cons?,V ) . hh mon(\u00b5X.C, V ) -. mon([\u00b5X.C/X]C, V \n) mon(C . D, V ) -. mon(D, mon(C, V )) mon(C . D, V ) -. if (FC(C) V )(V \u00b7 C) mon(D, V ) if f V : C ? \nmon(C . D, V ) -. V if f V : C . mon(C . D, V ) -. mon(D, V ) if f V : C . Figure 5. Higher-order contract \nreduction extracted using car and cdr and checked against the rele\u00advant portions of the contract. Otherwise, \nthen the program reduces to blame, analogous to function contracts. The last set of rules decompose combinations \nof higher\u00adorder contracts. Recursive contracts are unrolled. (Produc\u00adtivity ensures that contracts do \nnot unroll forever.) Conjunc\u00adtions are split into their components, with the left checked before the \nright. For higher-order disjunctions, we rely on the invariant that only the right disjunct is higher-order \nand use FC for the check of the left. When possible, we omit this check by using the proof system (see \nthe .nal two rules).  4.2.5 Applying abstract values Again, application of abstract values poses a challenge, \njust as it did in section 3. In contrast, the system must now explore more possible behaviors of abstract \noperators and it can no longer be guided by the type. Fortunately, abstract values provide the tools \nto express the needed computation. Applying abstract values E -. E ' where VV= /C VV ' -. V /X]D | (C \n..X.D) . C} V/{[ V if d(proc?,VV) tt VV ' -. havoc V ' if d(proc?,VV) tt V havoc = \u00b5y.(.x.AMB({y (x ), \ny (car x), y (cdr x)})) AMB({E})= E AMB({E, E1,... })= if E AMB({E1,... })  The behavior of abstract \nvalues, which are created by references to opaque modules, is handled in much the same way as in SCPCF. \nWhen an abstract function is applied, there are again two possible scenarios: (1) the abstract function \nreturns an abstract value or (2) the argument escapes into an unknown context that causes the value to \nbe blamed. We again make use of a havoc function for discovering if the possibility of blame exists. \nIn contrast to the typed setting of SCPCF, we need only one such value. The demonic context is a universal \ncontext that will produce blame if it there exists a context that produces blame originating from the \nvalue. If the universal demonic context cannot produce blame, only the range value is produced. The havoc \nfunction is implemented as a recursive func\u00adtion that makes a non-deterministic choice as to how to treat \nits argument it either applies the argument to the least\u00adspeci.c value, , or selects one component of \nit, and then recurs on the result of its choice. This subjects the input value to all possible behavior \nthat a context might have. Note that the demonic context might itself be blamed; we implic\u00aditly label \nthe expressions in the demonic context with a dis\u00adtinguished label and disregard these spurious errors \nin the proof of soundness. We use the AMB metafunction to imple\u00adment the non-determinism of havoc; AMB \nuses an if test of an opaque value, which reduces to both branches.  4.3 Proof system Compared to the \nvery simple proof system of section 3.4, the system for proving or refuting whether a given value satis.es \na contract in Core Racket is more sophisticated, although the general principles remain the same. In \nparticular, we rely on three different kinds of judg\u00adments that relate values and contracts: proves, \nrefutes, and neither. The .rst, f V : C . includes the original judgment that a value proves a contract \nif it remembers that contract. Additionally, we add judgements for reasoning about type predicates in \nthe language. For example if a value is known to satisfy a particular base predicate, written f V : o? \n., then the value satis.es the contract .at(o?). This relies on the relation between values and predicates \nused above in the de.nition of d, which is de.ned in a straightforward way. The refutes relation is more \ninteresting and relies on addi\u00adtional semantic knowledge, such as the disjointness of data types. For \ninstance, a value that remembers it is a proce\u00addure, refutes all pair contracts and the pair? predicate \ncon\u00adtract. Other refutes judgments are straightforward based on structural decomposition of contracts \nand values. The complete de.nition of these relations is given in the auxiliary materials (\u00a7A.3). Our \nimplementation, described in section 6, incorporates a richer set of rules for improved reasoning. The \nimplementation is naive but effective for basic semantic reasoning, however it essentially does no sophisticated \nreasoning about base type domains such as numbers, strings, or lists. The tool could immediately bene.t \nfrom leveraging an external solver to decide properties of concrete values. 4.4 Improving precision \nvia non-determinism Since our reduction rules, and in particular the d relation, make use of the remembered \ncontracts on values, making these contracts as speci.c as possible improves precision of the results. \nImproving precision via non-determinism V -. V ' VV /C.\u00b7{C1 . C2} -. /C.{Ci} i .{1, 2}  /C.\u00b7{\u00b5X.C} \n-. /C.{[\u00b5X.C/X]C}  The two rules above increase the speci.city of abstract values. The .rst rule splits \nabstract values known to sat\u00adisfy a disjunctive contract. For example, /{.at(nat?) . .at(bool?)} -. /.at(nat?) \nand /.at(bool?). This con\u00adverts the imprecision of the value into non-determinism in the reduction relation, \nand makes subsequent uses of d more precise on the two resulting values. Similarly, we unfold recursive \ncontracts in abstract values; this exposes further disjunctions to split, as with a contract for lists. \nAs an example of the effectiveness of this simple ap\u00adproach, consider the list length function: (module \nlength (provide [len (list/c -> nat?)]) (define (len l) (if (empty? l) 0 (+ 1 (len (cdr l)))))) When \napplied to the symbolic value \u00b7 \u00b5x.(.at(empty?) .(.at(nat?),x)) which is the de.nition of list/c, we \nimmediately unroll and split the abstract value, meaning that we evaluate the body of len in exactly \nthe two cases it is designed to handle, with a precise result for each. Without this splitting, the test \nwould return both tt and ., and the semantics would attempt to take the cdr of the empty list, even though \nthe function will never fail on concrete inputs. This provides some of the bene.ts of occurrence typing \n[41] simply by exploiting the non-determinism inherent in the reduction semantics.  4.5 Evaluation and \nSoundness We now de.ne evaluation of entire modular programs, and prove soundness for our abstract reduction \nsemantics. One complication remains. In any program with opaque mod\u00adules, any module might be referenced, \nand then treated ar\u00adbitrarily, by one of the opaque modules. While this does not affect the value that \nthe main expression might reduce to, it does create the possibility of blame that has not been pre\u00adviously \npredicted. We therefore place each concrete mod\u00adule into the previously-de.ned demonic context and non\u00addeterministically \nchoose one of these expressions to run prior to running the main module of the program.  The evaluation \nfunction is de.ned as: eval( (M f E ' ; E -. E ' }, ME)= {E ' | ( where E ' = AMB({tt, havoc f}), (module \nfCV ) . M(. Soundness, as in section 3.5, relies on the de.nition of approximation between terms, and \nits straightforward exten\u00adsion to modules and programs. The approximation relation on expressions, modules, \nand programs is formalized below. We show only the impor\u00adtant cases and omit the straightforward structurally \nrecursive cases. We parametrize by the module context of the ab\u00adstract program to determine the opaque \nmodules; we omit this context where it can be inferred. Approximates PQ, M MN, and E ME ' MM V mon(C, \nE) \u00b7 C (.X.mon(D, (V mon(C, X)))) \u00b7 C ..X.D VV ' f V : C . V \u00b7 CV V \u00b7 CV ' \u00b7 C VV \u00b7 C N(M(E ' E mon(C, \nE) E ' (( NE ' ME mon(C, E) mon(C, E ' ) (module fC ) . M(or f = blamef E gM M (module fC ) . M((module \nfCV )(module fC ) M The relation is lifted to evaluation contexts E by struc\u00adtural extension; to contracts \nby structural extension on con\u00adtracts and on embedded values; to vectors by point-wise extension; and \nto sets of expressions by point-wise, subset extension. With the approximation relation in place, we \nnow state and prove our main soundness theorem. Theorem 2 (Soundness of Symbolic Core Racket). ( If PQ \nwhere Q = ME and A . eval(P ), then there exists some A ' . eval(Q) where AA ' . M This soundness result, \nproved below, implies that if a pro\u00adgram with opaque modules does not produce blame, then the known modules \ncannot be blamed, regardless of the choice of implementation for the opaque modules. Corollary 1. If \nf is the name of a concrete module in P , and P -. E [blamef ], then no instantiation of the opaque g \nmodules in P can cause f to be blamed. To prove soundness, we .rst establish some auxiliary lemmas. Lemma \n1. If V(U(, then d(O, V() d(O, U(). M M Proof. By inspection of d and cases on O and V(. Lemma 2. If \nEE ' and VU, then [V/X]E M M M [U/X]E ' . Proof. By induction on the structure of E and cases on the \nderivation of E M E ' . Lemma 3. If CD, then FC(C) FC(D). M M Proof. By induction on the structure of \nC and cases on the derivation of E M E ' and the de.ntion of FC. Lemma 4. Let E = FC(C), then 1. if f \nV : C . and VU, then EU -. A ; tt , M 2. if f V : C . and VU, then EU -. A ; . . M Proof. By induction \non the structure of C and cases on the derivation of U M V and the de.ntion of FC. '' ( Lemma 5. If P \n-. P , P = M blamef and PQ, g ' then Q -. Q ' and PQ ' . Proof. We split into two cases. Case (1): P \n= M(E[E] -. M(E[E ' ] (' [E '' ] Q = N E ' [E ' ] -. N(E where E ME '. We reason by cases on the step \nfrom E to N E ' . Case: E = fg and (module fCE ' ) . M(If f is transparent in N(, then (module fCE ' \n) . N(and we are done by simple application of the reduction rules for module references. Otherwise, \nf = g and thus f,g E '' f,g E ' = mon(C, V )= mon(C, /{C}), f f but now E ' NME '', since E ' M /{C}. \nN Case: mon(C ..X.D, V ) -. (.X.mon(D, (U mon(C, X)))) where d(proc?,V ) tt and U = V/{C ..X.D}. Since \nE ' is a redex, by we have E ' = mon(C ' . .y.D ' ,V ' ), where V MV '. Then d(proc?,V ' ) tt N ' by \nlemma 1,. So E '' =(.y.mon(D ' , (U mon(C ' ,y)))) ' where U = V ' /{C ' ..y.C ' } MV/{C ..X.D} N E '' \nand thus E ' M. N Case: V1 V \u00a3 -. blame\u00a3 , where d(proc?,V1) .. 2. By ,wehave E ' = U1 U2 \u00a3 and UiMVi. \nBy lemma 1, N d(proc?,U1) ., hence U1 U\u00a3 -. blame\u00a3 2..  Case: V1 V \u00a3 -. E ', where d(proc?,V1) tt. 2 \nBy ,wehave E ' = U1 U\u00a3 and UiMVi. By lemma 1, 2 N d(proc?,U1) tt. Either V1 and U1 are structurally similar, \nin which case the result follows by possibly relying on lemma 2, or V1 =(.X.E0)/C and U1 = /C '. There \nare two pos\u00adsibilities for the origin of V1: either it was blessed or it was not. If V1 was not blessed, \nthen C contains no function contracts, implying C ' contains no function con\u00adtracts, hence E '' = , and \nthe result holds. Alterna\u00adtively, V1 was blessed and C contains a function con\u00adtract C . .X.D. But by \nthe blessed application rule, we have E = E1[mon([V2 ' /X]D, [])], thus by assumption '' ' E = E1[mon([U2/X]D \n' , [])], implying [V2 ' /X]D ' [U2/X]D ', .nally giving us the needed conclusion: '' E1[mon([V2 ' /X]D, \nE ' )] ME1[mon([U2/X]D ' ,E '' )], N where E '' = /{[U2/X]D ' | C ' ..X.D ' .C ' }. Case: mon(C, V ) \n-. E ' where C is .at. If f V : C ?, then the case holds by use of lemma 3. If f V : C ., then the case \nholds by lemma 4(1). If f V : C , then the case holds by lemma 4(2).  The remaining cases are straightforward. \nCase (2):  P = M(E1[E2[E]] -. M(E1[E2[E ' ]] ('' Q = N E1[E2[E ' ]] ' where E1 is the largest context \nsuch that E1 NME1 but ' E2 ME2. N ' In this case, we have E2[E] ME2[E ' ], but since E2 M NN ' E , this \nmust follow by one of the non-structural rules for , 2 all of which are either oblivious to the contents \nof E and E ' , or do not relate redexes to anything. Lemma 6. If there exists a context E such that M((module \nfCV ) E[f] -. blamef , g then M((module fCV )(havoc f) -. blamef . g Proof. If there exists such an E, \nthen without loss of gener\u00adality, it is of some minimal form D in D =[] | (D V ) | (car D) | (cdr D), \nbut then there exists a D ' equal to D with all values replaced with such that M(D ' [V ] -. blamef \n. This is because g at every reduction step, replacing some component of the redex with causes at least \nthat reduction to .re, possibly in addition to others. Further, by inspection of havoc, if M(D ' [V ] \n-. blamef , then M((havoc V ) -. blamef . gg Proof of Theorem 2. By the de.nition of eval, we have P \n-. A. Let the number of steps in P -. A be n. There are two cases: either A = V , or A = blame\u00a3\u00a3 ! . \nIf A = V , then we proceed by induction on n and apply lemma 5 at each step. If A = blame\u00a3\u00a3! then there \nare two possibilities. If \u00a3 is the name of an opaque module in M(or if \u00a3 = , then A MA ' M immediately. \nIf \u00a3 = f is the name of a concrete module in M(, then havoc f -. A by lemma 6, and therefore A . eval(Q) \nby the de.nition of eval. 5. Convergence and decidability At this point, we have constructed an abstract \nreduction se\u00admantics that gives meaning to programs with opaque com\u00adponents. The semantics is a sound \nabstraction of all possible instantiations of the omitted components, thus it can be used to verify that \nmodular programs satisfy their speci.cations. However, in order to automatically verify programs, the \nse\u00admantics must converge for the program being analyzed. We now describe how to refactor the semantics \nin such a way that we can accelerate and if desired guarantee convergence by introducing further orthogonal \napproxima\u00adtion into the semantics. This is accomplished in a number of ways: operations may widen when \napplied to concrete values, environment structure may be bounded, and  control structure may be bounded. \n In order to guarantee convergence for all possible pro\u00adgrams, all three of these forms of approximation \nmust be em\u00adployed and are suf.cient to guarantee decidability of the se\u00admantics. However, our experience \nsuggests that such strong convergence guarantees may be unnecessary in practice. For example, we have \nfound that a simple widening of concrete recursive function applications to their contract when ap\u00adplied \nto abstract values works well for ensuring convergence of tail-recursive programs broken into small modules. \nBy adding a limited form of control structure approximation, we are able to automatically verify non-tail-recursive \nfunc\u00adtions. Taken together, these forms of approximation do not guarantee convergence in general, yet \nthey do induce con\u00advergence for all of the examples we have considered (see \u00a76.2) and with fewer spurious \nresults compared to more tra\u00additional forms of abstraction such as 0CFA and pushdown .ow analysis. But \nrather than advocate a particular approxi\u00admation strategy, we now describe how to refactor the seman\u00adtics \nso that all these choices may be expressed. Our imple\u00admentation (\u00a76) then makes it easy to explore any \nof them. 5.1 Widening values Widening the results of basic operations, i.e., those inter\u00adpreted by d, \ncan cut down the set of base values, and if nec\u00adessary can ensure .niteness of base values. Thus, we \nreplace d with d ' : d ' (O, V() widen(V ) .. d(O, V() V  where widen represents an arbitrary choice \nof a metafunc\u00adtion for mapping a value to its approximation. To avoid ap\u00adproximation, it can be interpreted \nas the identity function. To ensure .nite base values, it must map to a .nite range; a simple example \nis widen(V )= for all V . An example of a more re.ned interpretation is widen(n)= .at(nat?), widen(cons \nVU)= .at(cons?), etc. For soundness, we re\u00adquire that widen(V )= V ' implies VV ' .  5.2 Bounding environment \nstructure The lexical environment of a program represents a source of unbounded structure. To enable \napproximation of the lexical environment, we .rst refactor the semantics as calculus of explicit substitutions \n[11] with a global store. Substitutions are modeled by .nite maps from variables to addresses and the \nstore maps addresses to sets of values, which are now represented as closures: .,. ::= \u00d8| .[X . a] s,. \n::= \u00d8| s[a .{ V, . . . }] Reductions that bind variables, such as function application, must allocate \nand extend the environment. For example, (.X.E) V \u00a3 -. [V/X]E becomes an analogous reduction relation \non closures and stores: ((.X.E),.) V \u00a3 ,s -. (E,.[X . a]),s [a . V ] where a = alloc(s, X) and the interpretation \nof s [a . V ] is s ' s.t. s ' (b)= s(b) if a = b and s ' (a)= s(a) .{V }. Since reduction operates over \nclosures, there is an addi\u00adtional case needed to handle variable references: (X,. ),s -. V,s if V . s(.(X)) \nThe alloc metafunction provides a point of control which regulates the approximation of environment structure. \nTo ensure .nite environment approximation, the metafunction must map to a .nite set of addresses (for \na .xed program). A simple .nite abstraction is alloc(s, X)=0 for all s and X. This abstraction maps all \nbindings to a single location, thus con.ating all bindings in a program. Although highly imprecise, this \nis a sound approximation, and in fact any in\u00adstantiation of alloc is sound [42]. A more re.ned abstrac\u00ad \ntion is alloc(s, X)= X, which provides a .nite abstraction of environment structure similar to 0CFA in \nwhich multi\u00adple bindings of the same variable are con.ated. To avoid ap\u00adproximation, alloc(s, X) should \nchose a fresh address not in s. Consequently, the store maps all addresses to singleton sets of values \nand the environment-based reduction seman\u00adtics corresponds precisely with the original.  5.3 Bounding \ncontrol structure The remaining source of unbounded structure stems from the control component of a program. \nBounding the environment structure was achieved by (1) making substitutions explicit as environments \nand (2) threading environments through a store which could be bounded. An analogous approach is taken \nfor control: (1) evaluation contexts are explicated as continuations and (2) continuations are threaded \nthrough the store. The resulting semantics is an abstract machine that oper\u00adates over a triple comprised \nof a closure, a store, and a con\u00adtinuation. Transitions take three forms: decomposition steps, which \nsearch for the next redex and push continuations if needed; plug steps which return a value to a context \nand pop continuations if needed; and contraction steps, which imple\u00adment the s notion of reduction. We \nwrite continuations . as single evaluation context frames with embedded addresses representing (a pointer \nto) the surrounding context. So for example Ea represents E E where a points to a continuation representing \nE. A simple decompose case is: ((EE ' ,.), s, .) -. ((E,.),s [a . .],a (E ' ,.))where a = alloc(s,. ) \nNotice that this transition searches for the next redex in the left side of an application and allocates \na pointer to the given context in order to push on the argument to be evaluated later. Similar to variable \nbinding, continuations are allocated using alloc and joined in the store, allowing for multiple continuations \nto reside in a single location. The corresponding plug rule pops the current continuation frame and non-deterministically \nchooses a continuation: (V, s, a (E ' ,.)) -. (V (E ' ,.), s, .) where .s(a) The contraction rule simply \napplies the reduction relation on explicit substitutions: ((E,. ),s,.) -. ((E ' ,.),.,.)if ((E,. ),s) \n-. ((E ' ,.),.) To ensure a .nite approximation of control, alloc must map to a .nite set of addresses. \nA simple .nite abstraction is alloc(.,s )=0. A more re.ned .nite abstraction of control is to use a frame \nabstraction: alloc(Ea, s)= E [] and like\u00adwise for other continuation forms. To avoid approximation, alloc(.,s \n) should produce an address not in s. We have now restructured our semantics as a machine model with \nthree distinct points of control over approxima\u00adtion: basic operations, environments, and control. The \nfull de.nition of the machine is derived following the outline of Van Horn and Might [42]; the complete \ndetails are in\u00ad cluded in the Redex model accompanying the implementa\u00adtion.  We now establish the correspondence \nbetween the previ\u00adous reduction semantics and the machine model when no ap\u00adproximation occurs. Let -.CESK \ndenote the machine tran\u00adsition relation under the exact interpretations of widen and alloc. Let U be \nthe straightforward recursive unload func\u00adtion that maps a closure and store to the closed term it repre\u00adsents. \nLemma 7 (Correspondence). If P -. Q, then there exists . such that (P, \u00d8, \u00d8) -. CESK . and U(.)= Q. We \nnow relate any approximating variant of the machine to its exact counterpart. Let -.Cdenote the machine \nCESK transition under any sound interpretation of widen. We de\u00ad.ne an abstraction map as a structural \nabstraction of the state-space of the exact machine to its approximate coun\u00adterpart. The key case is \non stores: a(s)= . {a(s(a))} a. a(a)= a The relation is lifted to machine states as the point-wise, element-wise, \ncomponent-wise, and member-wise lifting. ' . ' Theorem 3 (Soundness). If . -.CESK . and a(.) , ' then \nthere exists . ' such that . -.C. ' and a(. ' ) . . CESK We have now established any instantiation of \nthe machine is a sound approximation to the exact machine, which in turn correspond to the original reduction \nsemantics. Furthermore, we can prove decidability of the semantics for .nite instan\u00adtiations of widen \nand alloc: Theorem 4 (Decidability). If widen and alloc have .nite range for a program P , then (P, \u00d8, \n\u00d8) -. C. is CESK decidable for any .. The proofs of these theorems closely follow those given by Van \nHorn and Might [42]. 6. Implementation To validate our approach, we have implemented a prototype interactive \nprogram veri.cation environment, as seen in .g\u00adure 6. We can take the example from section 2, de.ne the \nrel\u00adevant modules, and explore the behavior of different choices for the main expression. Programs are \nwritten with the #lang var <options> header, where <options> range over a visualization mode: trace, \nstep, or eval; a model mode: term or machine; and an approximation mode: approx or exact. Following the \nheader, programs are written in a subset of Racket, con\u00adsisting of a series of module de.nitions and \na top-level ex\u00adpression. The visualization mode controls how the state space is ex\u00adplored. The choices \nare simply running the program to com\u00adpletion with a read-eval-print loop, visualizing a directed graph \nof the state space labeled by transitions, or with an in\u00adteractive step-by-step exploration. The model \nmode selects  Figure 6. Interactive program veri.cation environment whether to use the term or the machine \nas the underlying model of computation. Finally, the approximation mode selects what, if any, ap\u00adproximation \nshould be used. The exact mode uses no ap\u00adproximation; allocation always returns fresh addresses and \nno widening is used for base values. The approx mode uses a default mode of approximation that has proved \nuseful in verifying programs (discussed below). 6.1 Implementation extensions Our prototype includes \nsigni.cant extensions to the system as described above. First, we make numerous extensions in order to \nverify existing Racket programs. For example, modules are ex\u00adtended to include multiple de.nitions and \nfunctions may accept zero or more arguments. The latter complicates the reduction relation as new possibilities \narise for errors due to arity mismatches. Second, we add additional base val\u00adues and operations to the \nmodel to support more realis\u00adtic programs. Third, we make the implementation of con\u00adtract checking and \nreduction more sophisticated, improving running time and simplifying visualization. Fourth, we im\u00adplement \nseveral techniques to reduce the size of the state space explored in practice, including abstract garbage \ncol\u00adlection [32]. Abstract GC enables naive allocation strate\u00adgies to perform with high precision. Additionally, \nwe widen contracted recursive functions to their contracts on recur\u00adsive calls; this implements a form \nof induction that is highly effective at increasing convergence. Fifth, we add simpler rules to model \nnon-recursive functions and non-dependent contracts. This brings the model closer to programmers ex\u00adpectation \nof the semantics of the language, and simpli.es visualizations. Sixth, we include several more contract \ncom\u00adbinators, such as and/c for contract conjunction; atom/c for expressing equality with atomic values; \none-of/c for .nite enumerations; struct/c for structures; and listof and non-empty-listof for lists of \nvalues..  Finally, we provide richer blame information, as can be seen in the screen shot of .gure 6. \nOur system reports the full complement of information available in Racket s production contract library, \nwhich reports the failure of dbl as: > ((dbl (. (x) 7)) 4) top-level broke (even? . even?) . (even? . \neven?) on dbl; expected <even?>, given: 7 Our prototype is available at github.com/samth/var .  6.2 \nVeri.ed examples We have veri.ed a number of example programs, which fall into three categories: small \nprograms with rich contracts such as the example of insertion-sort from the introduction, where veri\u00adfying \ncontract correctness is close to full functional veri\u00ad.cation;  tricky-to-verify programs with simple \ncontracts such as Wright and Cartwright s tautology checker, where our tool proves not only that the \nfunction satis.es its boolean? -> boolean? contract, but also that it has no internal run-time type errors; \nand  several larger graphical, interactive video games devel\u00adoped according to the program-by-design \n[16] approach that stresses data-and contract-driven program design.  In the third category, we were \nable to automatically ver\u00adify contract correctness for non-trivial existing programs, including two, \nSnake and Tetris, developed for our under\u00adgraduate programming course. The programs make use of higher-order \nfunctions such as folds and maps and construct anonymous (upward) functions. Their contracts include \n.\u00adnite enumerations, structures, and recursive (ad-hoc) unions. Here is the key contract de.nition for \nthe Snake game: (define-contract snake/c (struct/c snake (one-of/c up down left right) (non-empty-listof \n(struct/c posn nat? nat?)))) We are able to automatically verify these stated invariants, such as that \nsnakes have at least one segment and that it moves in one of four possible directions. For these examples, \nwe found that simply widening the results of recursive calls with abstract arguments is suf.cient to \nensure convergence in the semantics given an appropriate .ne-grained module decomposition. All of our \nveri.ed ex\u00adamples are available with our implementation. 7. Related work The analysis and veri.cation \nof programs and speci.cations has been a research topic for half a century; we survey only closely related \nwork here. Symbolic execution Symbolic execution [24] is the idea of running a program, but with abstract \ninputs. The technique can be used either for testing, to avoid the need to specify certain test data, \nor for veri.cation and analysis. Over the past 35 years, it has been used for numerous testing and veri.cation \ntasks. There has been a particular upsurge in interest in the last ten years [8, 9], as high-performance \nSAT and SMT solvers have made it possible to eliminate infeasible paths by checking large sets of constraints. \nMost approaches to symbolic execution focus on abstract\u00ading .rst order data such as numbers, typically \nwith con\u00adstraints such as inequalities on the values. In this paper, we present an approach to symbolic \nexecution based on con\u00adtracts as symbols, which scales straightforwardly to higher\u00adorder values. Despite \nthis focus on higher-order values, the remembered contracts maintained by our system let us con\u00adstrain \nsymbolic execution to feasible evaluations; using an external solver to decide relationships such as \nf V : C . is an important area of future work. Recently, under the heading of concolic execution [20, \n36], symbolic execution has been paired with test generation to analyze software more effectively. We \nbelieve that we could effectively use our system as the framework for such a system, by nondeterminstically \nreducing abstract values to concrete instances. The only work on higher-order symbolic execution that \nwe are aware of is by Thiemann [40] on eliminating redun\u00ad dant pattern matches. Thiemann considers only \na very re\u00ad stricted form of symbols: named functions partially applied to arguments, constructors, and \na top value. This approxi\u00admation is only sound for a purely functional language, and thus while we could \nincorporate it into our current sym\u00adbolic model of Racket, further extensions to handle mutable state \nrule out the technique. It is unclear whether redundancy elimination would bene.t from contracts as symbol. \nVeri.cation of .rst-order contracts Over the past ten years, there has been enormous success verifying \nmodu\u00adlar .rst-order programs, as demonstrated by tools such as the SLAM and Spec# projects [3, 6, 14]. \nThese tools typ\u00ad ically operate by abstracting .rst-order programs in lan\u00adguages such as C to simpler \nsystems such as automata or boolean programs, then model-checking the results for vio\u00adlations of speci.ed \ncontracts. However, these approaches do not attempt to handle the higher-order features of languages \nsuch as Racket, Python, Scala, and Haskell. For instance, the boolean program ab\u00adstraction employed by \nSLAM [2] is inherently .rst-order: variables can take only boolean values. Our system, in con\u00adtrast, \nscales to higher-order language features.  Despite the fundamental difference, there are important similarities \nbetween this work and ours. The systems all em\u00adploy nondeterminism extensively to reason about unknown \nbehavior, and abstract the environment by allowing it to take arbitrary actions; as in the havoc statement \nin Boo\u00adgie [14] which we generalize to the havoc function for plac\u00ading higher-order functions in an arbitrary \ncontext. Additionally, we believe that the techniques used in these existing .rst-order tools could improve \nprecision for .rst\u00adorder predicate checks in our system; exploring this is an important avenue for future \nwork. Veri.cation of higher-order contracts The most closely related work to ours is the modular set-based \nanalysis based on contracts of Meunier et al. [29, 30] and the static contract checking of Xu et al. \n[43, 44]. Meunier et al. take a program analysis approach, gen\u00aderating set constraints describing the \n.ow of values through the program text. When solved, the analysis maps source la\u00adbels to sets of abstract \nvalues to which that expression may evaluate. Meunier s system is more limited than ours in sev\u00aderal \nsigni.cant ways. First, the set-based analysis is de.ned as a separate se\u00admantics, which must be manually \nproved to correspond to the concrete semantics. This proof requires substantial sup\u00adport from the reduction \nsemantics, making it signi.cantly and arti.cially more complex by carrying additional infor\u00admation used \nonly in the proof. Despite this, the system is unsound, since it lacks an analogue of havoc. This unsound\u00adness \nhas been veri.ed in Meunier s prototype. Second, while our semantics allows the programmer to choose \nhow much to make opaque and how much to make concrete, Meunier s system always treats the entire rest \nof the program opaquely from the perspective of each module. Third, our language of contracts is much \nmore expres\u00adsive: we consider disjunction and conjunction of contracts, dependent function contracts, \nand data structure contracts. Our ability to statically reason about contract checks is sig\u00adni.cantly \ngreater Meunier s system includes only the sim\u00adplest of our rules for f V : C .. Finally, Meunier approximates \nconditionals by the union of its branches approximation; the test is ignored. This seemingly minor point \nbecomes signi.cant when consider\u00ading predicate contracts. Since predicate contracts reduce to conditionals, \nthis effectively approximates all predicates as both holding and not holding, and thus all predicate \ncon\u00adtracts may both fail and succeed. Xu et al. [44] describe a static contract veri.cation sys\u00adtem for \nHaskell. Their approach is to compile contract checks into the program, using a transformation modeled \non Findler and Felleisen [17], simplify the program using the GHC optimizer, and examine the result to \nsee if any con\u00adtract checks are left in the residual program. In subsequent work, Xu [43] applies this \napproach to OCaml, providing a formal account of the simpli.er employed, and extend\u00ading simpli.cation \nby using an SMT solver as an oracle for some simpli.cation steps. In both systems, if not all contract \nchecks are eliminated by simpli.cation, the system reports them as potentially failing. Our approach \nextends that of Xu et al. in three crucial ways. First, our symbolic execution-based approach allows \nus to consider full executions of programs, rather than just a simpli.cation step. Second, Xu et al. \nconsiders a signif\u00ad icantly restricted contract language, omitting conjunction, disjunction, and recursive \ncontracts, as well as contracts that may not terminate, may fail, or include calls to unknown functions. \nAs we saw in section 4, these extensions add sig\u00ad ni.cant complexity and expressiveness to the system. \nThird, as with Meunier et al. s work, the user has no control over what is precisely analyzed; indeed, \nXu et al. inline all non\u00adcontracted functions. Blume and McAllester [7] provide a semantic model of contracts \nwhich includes a de.nition of when a term is Safe, which is when it can never be caused to produce blame. \nWe use a related technique to verify that modules cannot be blamed, by constructing the havoc context. \nHowever, we do not attempt to construct a semantic model of contracts; instead we merely approximate \nthe run-time behaviors of programs with contracts. Abstract interpretation Abstract interpretation provides \na general theory of semantic approximation [10] that relates concrete semantics to an abstract semantics \nthat interprets programs over a domain of abstract values. Our approach is very much an instance of abstract \ninterpretation. The reach\u00adable state semantics of CPCF is our concrete semantics, with the semantics \nof SCPCF as an abstract interpretation de.ned over the union of concrete values and abstract values repre\u00adsented \nas sets of contracts. In a .rst-order setting, contracts have been used as abstract values [14]. Our \nwork applies this idea to behavioral contracts and higher-order programs. Combining expressions with \nspeci.cations Giving se\u00admantics to programs combined with speci.cations has a long history in the setting \nof program re.nements [23]. Our key innovations are (a) treating speci.cations as abstract values, rather \nthan as programs in a more abstract language, (b) ap\u00adplying abstract reduction to modular program analysis, \nas opposed to program derivation or by-hand veri.cation, and (c) the use of higher-order contracts as \nspeci.cations. Type inference and checking can be recast as a reduc\u00adtion semantics [27], and doing so \nbears a conceptual resem\u00ad blance to our contracts-as-values reduction. The principal difference is that \nKuan et al. are concerned with producing a type, and so all expressions are reduced to types before be\u00ading \ncombined with other types. Instead, we are concerned with values, and thus contracts are maintained as \nspeci.ca\u00adtion values, but concrete values are not abstracted away. Also related to our speci.cation-as-values \nnotion of re\u00adduction is Reppy s [34] variant of 0CFA that uses a more re.ned representation of approximate \nvalues , namely types.  The analysis is modular in the sense that all module imports are approximated \nby their type, whereas our approach allows more re.ned analysis whenever components are not opaque. Reppy \ns analysis can be considered as an instance of our framework by applying the techniques of section 5 \nand thus could be derived from the semantics of the language rather than requiring custom design. Modular \nprogram analysis Shivers [38], Serrano [37], and Ashley and Dybvig [1] address modularity (in the sense \nof open-world assumptions of missing program components) by incorporating a notion of an external or \nunde.ned value, which is analogous to always using the abstract value for unknown modules, and therefore \nallowing more descriptive contracts can be seen as a re.nement of the abstraction on missing program \ncomponents. Another sense of the words modular and compositional is that program components can be analyzed \nin isolation and whole programs can be analyzed by combining these component-wise analysis results. Flanagan \n[18] presents a set-based analysis in this style for analyzing untyped pro\u00adgrams, with many similar goals \nto ours, but without con\u00adsidering speci.cations and requiring the whole program be\u00adfore the .nal analysis \nis available. Banerjee and Jensen [4, 5] and Lee et al. [28] take similar approaches to type-based and \n0CFA-style analyses, respectively. Other approaches to higher-order veri.cation Kobayashi et al. [25, \n26] have recently proposed approaches to ver\u00ad i.cation of temporal properties of higher-order programs \nbased on model checking. This work differs from ours in four important respects. First, it addresses \ntemporal prop\u00aderties while we focus on behavioral properties. Second, it uses externally-provided speci.cations, \nwhereas we use contracts, which programmers already add to their pro\u00adgrams. Third, and most importantly, \nour system handles opaque components, while model-checking approaches are whole-program. Fourth, it operates \non higher-order recur\u00adsion schemes, a computational model with less power than CPCF, the basis of our \ndevelopment. Rondon et al. [35] present Liquid Types, an extension to the type system of OCaml which \nincorporates dependent re\u00ad.nement types, and automatically discharges the obligations using a solver. \nThis naturally supports the encoding of some uses of contracts, but restricts the language of re.nements \nto make proof obligations decidable. We believe that a com\u00adbination of our semantics with an extension \nto use such a solver to decide the f V : C . relation would increase the precision and effectiveness \nof our system. 8. Conclusion We have presented a technique for verifying modular higher\u00adorder programs \nwith behavioral software contracts. Con\u00adtracts are a powerful speci.cation mechanism that are al\u00adready \nused in existing languages. We have shown that by us\u00ading contracts as abstract values that approximate \nthe behav\u00adior of omitted components, a reduction semantics for con\u00adtracts becomes a veri.cation system. \nFurther, we can scale this system both to a rich contract language, allowing expres\u00adsive speci.cations, \nas well as to a computable approximation for automatic veri.cation derived directly from our seman\u00adtics. \nOur central lesson is that abstract reduction semantics can turn the semantics of a higher-order programming \nlan\u00adguage with executable speci.cations into a symbolic execu\u00adtor and modular veri.er for those speci.cations. \nAcknowledgments: We are grateful to Phillipe Meunier for discussions of his prior work and providing \ncode for the prototype implementation of his system; to Casey Klein for help with Redex; and to Christos \nDimoulas for discussions and advice. We thank our anonymous reviewers for their detailed comments on \nthe submitted paper. This material is based on research sponsored by DARPA under the programs Auto\u00admated \nProgram Analysis for Cybersecurity (FA8750-12-2\u00ad0106) and Clean-Slate Resilient Adaptive Hosts (CRASH). \nThe U.S. Government is authorized to reproduce and dis\u00adtribute reprints for Governmental purposes notwithstanding \nany copyright notation thereon. References [1] J. Michael Ashley and R. Kent Dybvig. A practical and \n.exible .ow analysis for higher-order languages. ACM Trans. on Program. Lang. Syst., 20(4):845 868, 1998. \n[2] Thomas Ball, Rupak Majumdar, Todd Millstein, and Sri\u00adram K. Rajamani. Automatic predicate abstraction \nof C pro\u00adgrams. In Proceedings of the Conference on Programming Language Design and Implementation, pages \n203 213, 2001. [3] Thomas Ball, Vladimir Levin, and Sriram K. Rajamani. A decade of software model checking \nwith SLAM. Commun. ACM, 54(7):68 76, 2011. [4] Anindya Banerjee. A modular, polyvariant and type-based \nclosure analysis. In Proceedings of the International Confer\u00adence on Functional Programming, pages 1 \n10, 1997. [5] Anindya Banerjee and Thomas Jensen. Modular control\u00ad.ow analysis with rank 2 intersection \ntypes. Mathematical. Structures in Comp. Sci., 13(1):87 124, 2003. [6] M. Barnett, M. ahndrich, R. P. \nM\u00a8F\u00a8K. M. Leino, uller, W. Schulte, and H. Venter. Speci.cation and veri.cation: The Spec# experience. \nCommun. ACM, 54(6):81 91, 2010. [7] Matthias Blume and David McAllester. Sound and complete models of \ncontracts. J. Funct. Program., 16(4 5):375 414, 2006. [8] Cristian Cadar, Vijay Ganesh, Peter M. Pawlowski, \nDavid L. Dill, and Dawson R. Engler. EXE: automatically generating inputs of death. In Proceedings of \nthe Conference on Com\u00adputer and Communications Security, pages 322 335, 2006. [9] Cristian Cadar, Daniel \nDunbar, and Dawson Engler. KLEE: unassisted and automatic generation of high-coverage tests for complex \nsystems programs. In Proceedings of the Confer\u00adence on Operating Systems Design and Implementation, pages \n209 224, 2008.  [10] Patrick Cousot and Radhia Cousot. Abstract interpretation: a uni.ed lattice model \nfor static analysis of programs by construction or approximation of .xpoints. In Proceedings of the Symposium \non Principles of Programming Languages, pages 238 252, 1977. [11] P. L. Curien. An abstract framework \nfor environment ma\u00adchines. Theoretical Computer Science, 82(2):389 402, 1991. [12] Christos Dimoulas \nand Matthias Felleisen. On contract sat\u00adisfaction in a higher-order world. ACM Trans. on Program. Lang. \nSyst., 33, 2011. [13] Christos Dimoulas, Robert B. Findler, Cormac Flanagan, and Matthias Felleisen. \nCorrect blame for contracts: no more scapegoating. In Proceedings of the Symposium on Principles of Programming \nLanguages, pages 215 226, 2011. [14] Manuel F\u00a8Static contract ahndrich and Francesco Logozzo. checking \nwith abstract interpretation. In Proceedings of the 2010 International Conference on Formal Veri.cation \nof Object-Oriented Software, pages 10 30, 2011. [15] Manuel F\u00a8ahndrich, Michael Barnett, and Francesco \nLogozzo. Embedded contract languages. In Proceedings of the Sympo\u00adsium on Applied Computing, pages 2103 \n2110, 2010. [16] Matthias Felleisen, Robert B. Findler, Matthew Flatt, and Shriram Krishnamurthi. How \nto design programs: an intro\u00adduction to programming and computing. MIT Press, 2001. [17] Robert B. Findler \nand Matthias Felleisen. Contracts for higher-order functions. In ICFP 02: Proceedings of the sev\u00adenth \nACM SIGPLAN International Conference on Functional Programming, pages 48 59, 2002. [18] Cormac Flanagan. \nEffective Static Debugging via Componen\u00adtial Set-Based Analysis. PhD thesis, Rice University, 1997. [19] \nMatthew Flatt and PLT. Reference: Racket. Technical Report PLT-TR-2010-1, PLT Inc., 2010. [20] Patrice \nGodefroid, Nils Klarlund, and Koushik Sen. DART: directed automated random testing. In Proceedings of \nthe 2005 ACM SIGPLAN Conference on Programming Language Design and Implementation, pages 213 223. ACM, \n2005. [21] M. Greenberg. personal communication. [22] Ralf Hinze, Johan Jeuring, and Andres L\u00a8oh. Typed \ncontracts for functional programming. In Functional and Logic Pro\u00adgramming, volume 3945 of LNCS, chapter \n15, pages 208 225. 2006. [23] Ralph Johan, Abo Akademi, and J. Von Wright. Re.nement Calculus: A Systematic \nIntroduction. Springer-Verlag New York, Inc., 1998. [24] James C. King. Symbolic execution and program \ntesting. Commun. ACM, 19(7):385 394, 1976. [25] Naoki Kobayashi. Types and higher-order recursion schemes \nfor veri.cation of higher-order programs. In Proceedings of the Symposium on Principles of Programming \nLanguages, pages 416 428, 2009. [26] Naoki Kobayashi, Ryosuke Sato, and Hiroshi Unno. Predicate abstraction \nand CEGAR for higher-order model checking. In Proceedings of the Conference on Programming Language Design \nand Implementation, pages 222 233, 2011. [27] George Kuan, David MacQueen, and Robert B. Findler. A rewriting \nsemantics for type inference. In Proceedings of the European Symposium on Programming, volume 4421, 2007. \n[28] Oukseh Lee, Kwangkeun Yi, and Yunheung Paek. A proof method for the correctness of modularized 0CFA. \nInfo. Proc. Letters, 81:179 185, 2002. [29] Philippe Meunier. Modular Set-Based Analysis from Con\u00adtracts. \nPhD thesis, Northeastern University, 2006. [30] Philippe Meunier, Robert B. Findler, and Matthias Felleisen. \nModular set-based analysis from contracts. In POPL 06: Conference record of the 33rd ACM SIGPLAN-SIGACT \nSym\u00adposium on Principles of Programming Languages, pages 218 231, 2006. [31] Bertrand Meyer. Eiffel : \nThe Language. Prentice Hall, 1991. [32] Matthew Might and Olin Shivers. Improving .ow analyses via GCFA: \nAbstract garbage collection and counting. In Pro\u00adceedings of the International Conference on Functional \nPro\u00adgramming, pages 13 25, 2006. [33] G. Plotkin. LCF considered as a programming language. Theoretical \nComputer Science, 5(3):223 255, 1977. [34] John Reppy. Type-sensitive control-.ow analysis. In ML 06: \nProceedings of the 2006 Workshop on ML, pages 74 83, 2006. [35] Patrick M. Rondon, Ming Kawaguci, and \nRanjit Jhala. Liquid types. In Programming Languages Design and Implementa\u00adtion, PLDI 08, pages 159 169. \nACM, 2008. [36] Koushik Sen, Darko Marinov, and Gul Agha. CUTE: a con\u00adcolic unit testing engine for C. \nSIGSOFT Softw. Eng. Notes, 30(5):263 272, 2005. [37] Manuel Serrano. Control .ow analysis: a functional \nlanguages compilation paradigm. In Proceedings of the Symposium on Applied Computing, pages 118 122, \n1995. [38] Olin Shivers. Control-.ow analysis of higher-order lan\u00adguages. PhD thesis, Carnegie Mellon \nUniversity, 1991. [39] T. Stephen Strickland, Sam Tobin-Hochstadt, Robert Bruce Findler, and Matthew \nFlatt. Chaperones and impersonators: Runtime support for reasonable interposition. In OOPSLA 12: Object-Oriented \nProgramming, Systems, Languages, and Applications, 2012. [40] Peter Thiemann. Higher-Order redundancy \nelimination. In Proceedings of the Workshop on Partial Evaluation and Pro\u00adgram Manipulation, pages 73 \n84, 1994. [41] Sam Tobin-Hochstadt and Matthias Felleisen. Logical types for untyped languages. In Proceedings \nof the International Conference on Functional Programming, pages 117 128, 2010. [42] David Van Horn and \nMatthew Might. Abstracting abstract machines. In Proceedings of the International Conference on Functional \nProgramming, pages 51 62, 2010. [43] Dana N. Xu. Hybrid contract checking via symbolic simpli.\u00adcation. \nIn Proceedings of the Workshop on Partial Evaluation and Program Manipulation, pages 107 116, 2012. [44] \nDana N. Xu, Simon Peyton Jones, and Simon Claessen. Static contract checking for Haskell. In POPL 09: \nProceedings of the 36th annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, pages \n41 52, 2009.    \n\t\t\t", "proc_id": "2384616", "abstract": "<p>We present a new approach to automated reasoning about higher-order programs by extending symbolic execution to use behavioral contracts as symbolic values, thus enabling symbolic approximation of higher-order behavior.</p> <p>Our approach is based on the idea of an abstract reduction semantics that gives an operational semantics to programs with both concrete and symbolic components. Symbolic components are approximated by their contract and our semantics gives an operational interpretation of contracts-as-values. The result is an executable semantics that soundly predicts program behavior, including contract failures, for all possible instantiations of symbolic components. We show that our approach scales to an expressive language of contracts including arbitrary programs embedded as predicates, dependent function contracts, and recursive contracts. Supporting this rich language of specifications leads to powerful symbolic reasoning using existing program constructs.</p> <p>We then apply our approach to produce a verifier for contract correctness of components, including a sound and computable approximation to our semantics that facilitates fully automated contract verification. Our implementation is capable of verifying contracts expressed in existing programs, and of justifying contract-elimination optimizations.</p>", "authors": [{"name": "Sam Tobin-Hochstadt", "author_profile_id": "81319502825", "affiliation": "Northeastern University, Boston, MA, USA", "person_id": "P3856127", "email_address": "samth@ccs.neu.edu", "orcid_id": ""}, {"name": "David Van Horn", "author_profile_id": "81337494657", "affiliation": "Northeastern University, Boston, MA, USA", "person_id": "P3856128", "email_address": "dvanhorn@ccs.neu.edu", "orcid_id": ""}], "doi_number": "10.1145/2384616.2384655", "year": "2012", "article_id": "2384655", "conference": "OOPSLA", "title": "Higher-order symbolic execution via contracts", "url": "http://dl.acm.org/citation.cfm?id=2384655"}