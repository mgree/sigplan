{"article_publication_date": "10-19-2012", "fulltext": "\n Refactoring Android Java Code for On-Demand Computation Of.oading Ying Zhang1,2 Gang Huang1,2 * Xuanzhe \nLiu1,2 Wei Zhang1,2 Hong Mei1,2 Shunxiang Yang1,2 1Key Laboratory of High Con.dence Software Technologies \n(Peking University), Ministry of Education 2Institute of Software, School of Electronics Engineering \nand Computer Science Peking University, Beijing, 100871, China zhangying06@sei.pku.edu.cn; hg@pku.edu.cn; \nliuxzh@sei.pku.edu.cn; zhangwei11@sei.pku.edu.cn meih@pku.edu.cn; yangsx07@sei.pku.edu.cn Abstract Computation \nof.oading is a promising way to improve the performance as well as reducing the battery power consump\u00adtion \nof a smartphone application by executing some parts of the application on a remote server. Supporting \nsuch capabil\u00adity is not easy for smartphone application developers due to (1) correctness: some code, \ne.g., that for GPS, gravity, and other sensors, can run only on the smartphone so that devel\u00adopers have \nto identify which parts of the application cannot be of.oaded; (2) effectiveness: the reduced execution \ntime must be greater than the network delay caused by compu\u00adtation of.oading so that developers need \nto calculate which parts are worth of.oading; (3) adaptability: smartphone ap\u00adplications often face changes \nof user requirements and run\u00adtime environments so that developers need to implement the adaptation on \nof.oading. More importantly, considering the large number of today s smartphone applications, solutions \napplicable for legacy applications will be much more valu\u00adable. In this paper, we present a tool, named \nDPartner, that automatically refactors Android applications to be the ones with computation of.oading \ncapability. For a given Android application, DPartner .rst analyzes its bytecode for discov\u00adering the \nparts worth of.oading, then rewrites the bytecode to implement a special program structure supporting \non\u00addemand of.oading, and .nally generates two artifacts to be deployed onto an Android phone and the \nserver, respectively. We evaluated DPartner on three real-world Android appli\u00ad * Corresponding author \nPermission to make digital or hard copies of all or part of this work for personal or classroom use is \ngranted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page. To copy otherwise, to republish, \nto post on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. OOPSLA \n12, October 19 26, 2012, Tucson, Arizona, USA. Copyright c . 2012 ACM 978-1-4503-1561-6/12/10. . . $10.00 \n cations, demonstrating the reduction of execution time by 46%-97% and battery power consumption by 27%-83%. \nCategories and Subject Descriptors D.2.3 [Software En\u00adgineering]: Coding Tools and Techniques Object-oriented \nprogramming; D.2.7 [Software Engineering]: Distribution, Maintenance, and Enhancement Enhancement; C.2.4 \n[Computer-Communication Networks]: Distributed Systems Client/server, Distributed applications General \nTerms Experimentation, Languages, Performance Keywords computation of.oading; bytecode refactoring; energy; \nAndroid 1. Introduction Android [1] is an open source mobile platform for smart\u00adphones, and it has gained \nmore than 59% of smartphone market share in the .rst quarter of 2012 [2]. Hundreds of thousands of developers \nhave produced more than 490 thou\u00adsands Android apps (a special kind of Java applications, app is short \nfor application) since the platform was .rst released by Google in 2008 [3] [4]. Following the fast improvement \nof smartphone hardware and increased user experience, An\u00addroid apps try to provide more and more functionality \nand then they inevitably become so complex as to make the two most critical limits of smartphones worse. \nThe .rst limit is the battery power. Complex Android apps usually have intensive computations and consume \na great deal of energy. For instance, the top 10 downloaded Android apps such as Fruit Ninja and Angry \nBirds on the Google Play [3] (formerly known as the Android Market) are all the complex ones that can \ndrain the battery power in about 30 minutes if running on HTC G13 [5]. Although the battery capacity \nkeeps growing continuously, it still cannot keep pace with the growing requirements of Android apps [6]. \nThe second limit is the diversity of hardware con.gura\u00adtions, which gives smartphone users very different \nexperi\u00adences even running the same app. For example, among the best-selling HTC smartphones in 2011, \nG13 has a 600 MHz CPU, G11 and G12 have a 1GHz CPU, and G14 has a 1.2 GHz CPU. The same Fruit Ninja app \nruns very slowly on G13, faster on G11 and G12, and the fastest on G14. Gener\u00adally speaking, the lower \nhardware con.guration of a phone implies the lower performance of the apps running on the phone. Users \nusually stop using the slow apps even if the root cause of the poor user experience is due to the low \nhardware con.guration of the phone. Such factor can lead to a big loss of the app market for developers \nand vendors. Computation of.oading is a popular technique to help im\u00adprove the performance of an Android-like \nsmartphone app and meanwhile reduce its power consumption. Of.oading, also referred to as remote execution, \nis to have some compu\u00adtation intensive code of an app executed on a nearby server (the so-called surrogate, \ne.g., a PC), so that the app can take advantage of the powerful hardware and the suf.cient power supply \nof the server for increasing its responsiveness and de\u00adcreasing its battery power consumption. Computation \nof.oading is usually implemented by a spe\u00adcial program structure, or a design pattern, that enables a \npiece of code to execute locally or remotely and handles the interactions between the local and the remote \ncode without impact on the correctness of the functionality. With respect to features of smartphones, \nthree advanced issues have to be dealt with: Correctness: some code, e.g., that for GPS, gravity, and \nother sensors, can run only on the smartphone. Therefore developers have to identify which parts of the \napp cannot be of.oaded;  Effectiveness: the reduced execution time must be greater than the network \ndelay caused by computation of.oad\u00ading. Therefore, developers have to calculate which parts are worth \nof.oading;  Adaptability: one of the most important natures of mobile computing is the diverse, frequent, \nand rapid changes of user requirements and runtime environments, which may lead to changes of computation \nof.oading. For example, if the remote server becomes unavailable due to unstable network connection, \nthe computation executed on the server should come back to the smartphone or go to another available \nserver on the .y. Developers have to consider such changes in computation of.oading.  The preceding \nissues are not easy to deal with and, more importantly in practice, a solution should be applied to legacy \napps in a cost effective way considering the huge number of today s Android apps. In this paper, we present \nan automatic approach to real\u00adizing computation of.oading of an Android app. Our paper makes three major \ncontributions: A well-designed pattern to enable an Android app to be computation of.oaded on-demand. \nAll Java classes of the app are able to interact with each other locally or remotely. The computations \nof a class can be of.oaded dynamically and only the interactions between the smart\u00adphone and the server \ngo through the network stack.  A refactoring tool, named DPartner, to automatically transform the bytecode \nof an Android app to implement the proposed design pattern. DPartner .rst analyzes the bytecode for discovering \nthe parts of an app that are worth of.oading, then rewrites the bytecode to imple\u00adment the design pattern, \nand .nally generates two arti\u00adfacts to be deployed onto the Android smartphone and the server, respectively. \nRefactoring is transparent to app developers and supports legacy apps without source code.  A thorough \nevaluation on three real-world Android apps. The evaluation results show that our approach is effec\u00adtive. \nThe of.oaded apps execute much faster (reducing execution time by 46%-97%) and consume much less battery \nenergy (reducing power consumption by 27%\u00ad83%) than the original ones.  We organize the rest of this \npaper as follows. Section 2 presents the design pattern for computation of.oading. Sec\u00adtion 3 gives the \nimplementation of DPartner. Section 4 re\u00adports the evaluation on Android apps. Section 5 discusses related \nwork and we conclude the paper in Section 6. 2. Design Pattern for Computation Of.oading An Android app \nis a Java program, whose building blocks are classes. Any meaningful computation is implemented as a \nmethod of a class, which uses the data and methods in\u00adternal of the same class or invokes some methods \nof other classes. As a result, of.oading computations can be imple\u00admented as remotely deploying and invoking \na single class or a set of classes performing the computation. The goal of our approach is to automatically \nrefactor Android apps into the ones implementing the design pattern for such deployment and invocation. \nThe principle of refactoring is to restructure the given code without altering the external functionality \n[9]. Gen\u00aderally speaking, refactoring is characterized by three as\u00adpects [9]: (1) the structure of the \noriginal code, i.e., source structure; (2) the structure of the target code, i.e., target structure; \n(3) a sequence of code refactoring steps that trans\u00adform the original code to the functionally equivalent \ntarget code, so that the target code are .nally able to take on the desired program structure. Thus, \nwe introduce these aspects one by one in detail as follows. 2.1 The Source Structure and the Target Structure \nIn Java, the object reference determines whether two classes interact with each other locally or remotely. \nThe source structure of the given code in any standalone Android app all take on the local reference \nprogram structure, i.e., the so-called in-VM reference program structure as shown in Figure 1. Local \ninvocation (source structure) Figure 2. Remote invocation (source structure) Figure 3. On-Demand remote \ninvocation (target structure) Figure 1. Class X .rst gets the in-VM reference of class N and then invokes \nthe methods of N. Such a structure does not support of.oading any computation in class N because if N \nis of.oaded to a remote server, N s in-VM reference held by X becomes invalid, i.e., it cannot help the \nVM pass the method invocations to N, and X will fail to obtain the new in-VM reference of N. Figure 2 \npresents the typical code structure that enables class X to invoke the methods of a remote class N. That \nis, X gets a remote reference to N from a remote commu\u00adnication service, then uses the reference to interact \nwith N remotely. The remote communication service is responsible to associate N s reference with N across \nthe network. Take Android AIDL [39] as an example, its ServiceConnection can be seen as the main part \nof the remote communication service. X gets a reference to N in the onServiceConnected method of ServiceConnection, \nthen uses the reference to in\u00advoke the methods of N. Such a structure can have the compu\u00adtations in N \nof.oaded to a remote server, but suffer serious performance penalty if N and X are both in the same VM. \nAs mentioned above, whether N is of.oaded or not is de\u00adtermined dynamically and may change time to time. \nIf N is not of.oaded, all the interactions between X and N in such a structure will still go through \nthe time-consuming network stack, which is contrary to the goal of computation of.oad\u00ading, i.e., improving \nperformance and save energy. We have done an experiment on the standard Android SDK sample: net.learn2develop.Services \n[40]. X (MainActivity) uses the ServiceConnection to get the reference to N (MyService). After that it \nuses the reference to call N s methods. Com\u00adpared with local interactions, such remote interactions in \nthe same VM increase execution time by 680% and battery power consumption by 287%. Figure 3 presents \nthe target structure we propose for on\u00addemand computation of.oading, i.e., allowing X to effec\u00adtively \ninvoke N no matter the two are running in the same VM or in different VMs across the network. The core \nof the structure is composed of two elements: proxy and endpoint. A proxy, NProxy in Figure 3, acts the \nsame as the proxied class N except that it does not do any computation itself, but forwards the method \ninvocations to the latter. If the location of the proxied class N is changed from local to remote, or \nfrom one remote server to another, NProxy keeps unchanged so that the caller, class X, will not get noticed. \nThe endpoint is responsible for determining the current location of N and for the truly crossing network \ncommuni\u00adcation from X to N. When N is running in a remote VM, the endpoint will take advantage of a given \nremote communica\u00adtion service to get a reference to N and pass it back to X, then X can use the reference \nto invoke N remotely. When X and N both run in the same VM, the endpoint will directly obtain the in-VM \nreference of N, so that X can invoke N without going through the network stack. The endpoint de\u00adcouples \nthe caller and the remote communication service. A smartphone can dynamically change its network connection \nwith the same server among multiple protocols, e.g., Wi-Fi, and 3G. The endpoint automatically adapts \nto such changes so that the interacted app classes are unaware of them. 2.2 Refactoring Steps Overview \nA sequence of refactoring steps will be performed on the Java bytecode of a given standalone Android \napp, so that the source structure of the code shown in Figures 1 and 2 can be transformed to the target \nstructure shown in Figure 3. We implement a tool, called DPartner [8], to automatically execute the refactoring \nsteps, as shown in Figure 4. Step 1: detect which classes are movable. For a given app, DPartner automatically \nclassi.es the Java classes (i.e., byte\u00adcode .les) into two categories: Anchored and Movable. The anchored \nclasses must stay on the smartphone because they directly use some special resources available only on \nthe phone, e.g., the GUI (Graphic User Interface) displaying, the gravity sensor, the acceleration sensor, \nand other sensors. If being of.oaded to the server, these anchored classes cannot work because the required \nresources become unavailable. Besides those anchored classes, all other classes are mov\u00adable, i.e., can \nexecute either on the phone or on the server. Step 2: make movable classes be able to of.oad. When a \nclass is of.oaded, the local invocation structure between this class and its interacted classes should \nbe transformed to the on-demand remote invocation structure, e.g., generating the proxy of the callee \nclass and rewriting the caller class to  Figure 4. Refactoring steps Figure 5. The runtime architecture \nof an of.oaded Android app equip the proxy. Note that, if an anchored class is invoked by an of.oaded \nclass, the latter needs the former s proxy. Since which movable classes are of.oaded is determined at \nrun\u00adtime, we have to generate the proxies for all callee classes and rewrite the corresponding caller \nclasses except that the caller and callee are both anchored. In our approach, a proxy class will be made \nto act exactly like its proxied app class. That is to say, these two classes will extend the same inher\u00aditance \nchain, implement the same interfaces, have the same method signatures, etc. In this way, class X will \nfeel no dif\u00adference when using the proxy of class N instead of N itself. The speci.c features of Java \nhave to be considered when generating the proxies, which include the static methods, .\u00adnal methods/classes, \npublic .elds, inner classes, arrays, etc. The details of proxy generation and class transformation will \nbe presented in Section 3. Step 3: detect which classes should be of.oaded as a whole. There are numerous \nrules and algorithms to deter\u00admine which movable classes should be of.oaded [7]. As mentioned before, \nsuch a decision has to be made and changed at runtime due to the mobility of smartphones. Meanwhile, \nmaking decision at runtime inevitably consumes resources and therefore it is valuable to have done some \npre-processing to simplify runtime decision. DPartner em\u00adploys a well-known rationale for pre-processing \nbased on class clustering [24], i.e., the frequently interacted classes should be of.oaded as a whole. \nIn this way, it cannot only avoid the time-consuming network communication between these classes, but \nalso help accelerate runtime decision. For instance, if class X and class N interact with each other \nfre\u00adquently, the endpoint only needs to pro.le the execution trace of X to determine of.oading at runtime. \nWhen X is about to of.oad, N will then be pro.led to decide whether it should be of.oaded together. It \nis unnecessary to continuous pro.le N for reducing runtime overhead. Step 4: package deployable .les. \nThe input of DPartner is the Java bytecode .les of an Android app as well as the referenced resource \n.les, e.g., images, xml .les, and jar libs. After going through the above three steps, DPartner will \npackage the .les and then generate two artifacts. The .rst is the refactored Android app, i.e., an .apk \n.le, which is ready to be installed on a phone. The second is an executable jar .le, which contains the \nmovable Java bytecode .les cloned from the refactored app. Both artifacts include the code of the endpoint \nand the communication service. 2.3 An Illustrative Example Figure 5 shows an example of the runtime \narchitecture of an of.oaded Android app. This app is composed of six classes, with their names from a \nto i, respectively. In Step 1, DPartner .nds that class b and g are both anchored classes, so that they \nshould always run on the phone. All the other classes are movable. In Step 2, each app class is transformed \nand gotten its corresponding proxy class. In Step 3, DPartner .nds that class a, c, d, e, and f are closely \nrelated to each other, and then clusters them for of.oading as a whole. In Step 4, DPartner packages \nall the movable classes, the proxies, and the endpoint classes in to a jar .le that will be deployed \nand executed on the server, and packages all the app classes, the proxies, and the endpoint classes as \nan Android apk .le that will be deployed and executed on the phone. At runtime, the endpoint predicts \nthat of.oading class d can improve the whole app performance, and then deacti\u00advates the d running on \nthe phone and activates the d deployed on the server. The d s proxy on the phone will forward the incoming \nmethod invocations to the d on the server. Since class d is clustered with class a, c, e, and f in Step \n3, these classes will also be of.oaded to the server when necessary by going through the deactivating, \nstate synchronizing and activating procedures as class d. Any invocations to these app classes will be \nforwarded to the server by the endpoint. When the of.oading-related conditions become unfavorable, e.g., \nthe phone gets far away from the server which leads to a high network latency, the computations of a, \nc, d, e, and f can get back to the phone by automatically deactivating them on the server and reactivating \nthem on the phone. All invocations to these classes will be redirected to the phone by the endpoint. \n 3. Implementation of DPartner 3.1 Detect Movable Classes DPartner classi.es a Java class into anchored \nor movable via bytecode analysis. In an Android app, an anchored class must have one of the following \nfeatures: (1) there are the native keyword existing in the class methods; (2) the class extends/implements/uses \nthe Android system classes that are already regarded to be anchored by DPartner. For instance, the android.view.View \nclass is used as the parent class for drawing the GUI of an Android app, so that it is clas\u00adsi.ed to \nbe the anchored class by DPartner. If a class is found to extend this class, it will also be anchored \nby DPart\u00adner. For another instance, the android.hardware.* classes are responsible for handling the camera \nand sensors of an Android smartphone. Therefore, they and the classes using them will be automatically \nanchored by DPartner. The rest of the classes will be classi.ed as movable classes. The above classi.cation \nprocedure may cause false posi\u00adtives and false negatives. A false positive means that a class is classi.ed \nas a movable one, but the developer is unwill\u00ading to do this. For instance, the developer does not want \nthe cn.edu.pku.password class be of.oaded due to pri\u00advacy concerns, although this class is classi.ed \nas a mov\u00adable one. A false negative means that a class is classi.ed as an anchored one although it can \nactually be of.oaded. For instance, as there are native keywords in its meth\u00adods, the cn.edu.pku.nativeCall \nclass will be classi.ed as anchored automatically. However, such methods may never be invoked, so that \nthis class can be of.oaded. By analyzing the bytecode of an app, DPartner is able to tell whether an \nanchored class is invoked by the other classes of the same app. However, it cannot tell whether the class \n(acting as an Android service [38]) will be used by other apps, which may lead to false negatives of \nclassi.cation. Therefore, we can see that DPartner takes a conservative approach to detecting movable \nclasses, which can at least guarantee that a refactored app work correctly no matter be\u00ading of.oaded \nor not. To re.ne the classi.cation results of anchored classes, DPartner provides a con.guration .le \nin which the naming patterns of anchored classes such as an\u00addroid.hardware.usb.* can be listed. In fact, \nthe automatic classi.cation procedure is carried out based on a prede.ned naming pattern list that takes \neffect just like the con.gura\u00adtion .le. At present, we have prede.ned 63 and 72 nam\u00ading patterns for \nAndroid 2.1 and 2.2, respectively. Compared with Android 2.1, Android 2.2 has 96% naming patterns un\u00adchanged, \n1% deleted, 1% revised, and 2% added. Developers can edit the con.guration .le to make the classi.cation \nstep adapt to the speci.c structures of each unique Android app and the platform. Of course, DPartner \ncan force a movable class to be anchored by indicating it in the con.guration .le. For instance, developers \ncan write cn.edu.pku.password in the .le so that DPartner will automatically classify this class to be \nan anchored one.  3.2 Generate Proxies One of the biggest challenge when generating proxies is to make \na proxy act exactly like its proxied class. For instance, the app class X invokes the methods of another \napp class N. In the original code of X, a casting operation is done on N to N s parent NParent. If we \njust change N to NProxy in X s code, but not let NProxy extend class NParent, the cast\u00ading operation \nwill fail. Therefore, the proxy generated by DPartner will have the same program structure as the prox\u00adied \nclass. Especially, the proxies themselves will maintain the same hierarchical structure as the proxied \nclasses. For in\u00adstance, N extends NParent, NProxy should also extend NPar\u00adent s proxy, so that any invocations \nto the inherited methods and constructors in N from NParent, can be forwarded .rst from NProxy to NParent \ns proxy, and .nally to NParent. Java interface is used to separate the external represen\u00adtation and the \ninternal implementation of a class. From the view of an interface, the proxy class and the proxied class \nare the same if they implement the same interface. There\u00adfore, DPartner will automatically extract the \ninterfaces to represent an app class and its proxy. For instance, there is an app class N, DPartner will \n(1) extract all the method sig\u00adnatures of N to form an NIntf interface; (2) make NIntf ex\u00adtend the NParentIntf \ninterface of N s parent NParent, so as to maintain the inheritance hierarchy; (3) make N imple\u00adment NIntf \n; and (4) make NProxy also implement NIntf. Af\u00adter that, DPartner will rewrite all the other classes \n(e.g., the class X) from using N to NIntf. However, to the static meth\u00adods of N, as they are not allowed \nin Java interfaces, DPartner will directly use the corresponding static methods of NProxy to forward \nthe method invocations. 3.3 Transform App Classes The app classes should also be rewritten to adapt \nto the of.oading requirements. Given an app class, DPartner will automatically transform it using the \nfollowing transformers: 1. Field2Method transformer: The non-private .elds of a class, i.e., with the \npublic, protected, or null modi.er, can be used by other classes outside of its class scope. However, \nif the class is of.oaded, its callers can never get the reference to these .elds. To solve this problem, \nthe transformer will au\u00ad  Figure 6. The treatment to (Integer) array type tomatically generate the \npublic getter/setter methods for the non-private .elds of a given class X, and then change their modi.er \nto private. After that, the transformer will change all the classes that get/set the .elds of X to use \nthe corre\u00adsponding getter/setter methods. In addition, to help state syn\u00adchronization, the transformer \nalso generates the getter/setter methods for the private .elds. In this way, the inner states of a class \ninstance can be collected and injected to enable state synchronization when the computations of a class \ninstance are of.oaded on-demand. 2. Array transformer: Given a class N that has an array type .eld being \nused by another class X, if X changes the el\u00adement value of the array, N will see the changed value. \nThat is because, in Java, an array is passed by reference. However, if X and N are running in different \nVMs, the array has to be passed by value between X and N, so that it can be trans\u00adferred over the network. \nUnder such a circumstance, X and N each have a copy of the array. If X changes the value of its copied \narray, but does not pass the array back, N will still use the old array, which makes the array value \ninconsistent. Therefore, the pass-by-reference feature of arrays should be kept. The array transformer \nwraps an array by using a func\u00adtional equivalent class shown in Figure 6, which encapsu\u00adlates the get/set \noperations of an array. For example, class N has a .eld intArray with the Integer array type. Class X \nchanges the value of intArray as the following code: n.intArray[5]=3; Then the above code will be replaced \nby the following code: Integer Array Dimension1 Intf arrayIntf = n.getInteger Array Dimension1(); arrayIntf.aastore(5, \nnew Integer(3)); //where n is an NProxy object represented by NIntf. //arrayIntf is an Integer Array \nDimension1 Proxy object represented by Integer Array Dimension1 Intf. In this way, the get/set operations \nin X on the intArray will be intercepted by the corresponding proxy class, and .nally be forwarded to \nN. Otherwise, these operations will be done directly by using the aastore/aaload bytecode in\u00adstructions \nthat cannot be intercepted, which will lead to the value inconsistency of intArray in X and N. Transforming \nmulti dimensional array is similar to single dimensional Figure 7. The classes relationships in a call \ngraph array. For example, Integer[][] will be wrapped as an In\u00adteger Array Dimension2 object. The type \nof the array .eld will be changed to Integer Array Dimension1. The get/set operations on the one-dimensional \nelements will also be changed to the aaload/aastore methods of the In\u00adteger Array Dimension1. 3. ServerObject \ntransformer: To make sure an invocation received by a proxy is correctly forwarded to the correspond\u00ading \nproxied class instance, this transformer will make an app class implement a speci.c ServerObject interface, \nwhich has two methods: getID and getProxyForSerializing. The getID method will return an Integer value \nto identify the app class instance, which is used to correlate this object with its proxy. The getProxyForSerializing \nmethod is used to handle the ob\u00adject serialization issue in the callback style method invoca\u00adtion described \nin Section 3.6. 4. Other transformers: They handle the speci.c features of classes, including the anonymous \nconstructor, inner class, abstract keyword, .nal keyword, etc. Their details are published on the website \nof DPartner [8].  3.4 Cluster App Classes To improve the performance of runtime decision about which \nmovable classes to of.oad, DPartner will cluster the frequently interacted classes and to of.oad them \nas a whole. It treats each app class as a node in the call-graph [26] of an Android app. The edge between \ntwo nodes means that the classes have one of the three relationships: extend, im\u00adplement, and use. As \nshown in Figure 7, class A extends P, implements I, and uses class B, C, and D. The call-value, i.e., \nedge weight, from A to B is ten, which means that by static bytecode analysis, it is found that A calls \nthe methods of B ten times in its code. The call-value from A to C is six, which is less than that of \nA to B. It denotes that A depends on B more than on C. Class P is the parent of A, however, by code analysis, \nthe method call from A to P may be less than that of A to B. In order to highlight the importance of \nP, DPartner will calculate the maximum call-value from A to other nodes, then assign this value to the \nedge from A to P. Thus in the following clustering procedure, A and its parent P will more likely be \nclustered together. DPartner will do the same thing on the edge of A to I. DPartner treats the above \ncall graph as G=(V, E), where V is the set of nodes in the graph, and E is the set of edges. A cluster \nis de.ned as a sub-graph G =(V , E ), where t3 Table 1. Class Clustering -1. c = inputApplicationClasses() \n2. g = buildCallGraph(c) 3. callValue = computeCallValue(g) 4. semSim = computeSemSim(c) 5. callValue \n= updateCallValue(callValue, semSim) 6. bset = computeBetweenness(g, callValue) 7. while (clustersnumber \n< threshold)  8. bmaxSet = maxSet(bset) 9. eremovedSet = removeEdges(bmaxSet)  10. g = g -eremovedSet \n 11. bset = computeBetweenness(g, callValue) 12. clusters = disconnectedSubgraphs()  In the above equation, \nNij represents the total number of terms contained in both Ti and Tj . For instance, the term pattern \nappears in both name1 and name2, so it will be counted in N12. The term-containing check will be performed \nat the etyma level. That is to say, if patterns appears in Ti, and patterned appears in Tj , these two \nwill be considered as the same one. Ni represents the total number of terms contained in Ti but not in \nTj. Nj represents the total number of terms contained in Tj but not in Ti. DPartner will add such a SemSim \nvalue to the call-value of each corresponding edge in an app s call-graph as below, so as to use the \nG-N algorithm to reveal the class clusters. The new call-value is calculated as follows: The whole clustering \nprocedure is shown in Table 1. The ranges of the threshold are [1, Nclass number], where Nclass number \nis the number of classes in a given Android app. Therefore, the extreme cases of clustering are: (1) \nall the classes belong to a single cluster; (2) every single class belongs to its single class cluster. \nDPartner will iterate the values in [1, Nclass number] to get the clustering hierarchy graph of a given \nAndroid app as shown in Figure 8. For example, when threshold is 2, the given app classes are clustered \ninto two clusters. One cluster is composed of class a, c, d, e and f. The other is composed of b, g, \nh and i. As the second cluster contains anchored classes, i.e., b and g, thus this cluster is considered \nas an anchored class cluster, which means that the classes in such a cluster should never be of.oaded \ntogether to execute on the server. DPartner will store the above clustering information into the refactored \nAndroid app. Such information will be lever\u00adaged by the endpoint to decide which classes should be of\u00ad.oaded \nas a whole at runtime. To reduce the overhead of runtime decision, the endpoint leverages a selective \nmoni\u00adtoring strategy, i.e., it monitors only the execution trace of some of the most computation-intensive \nmovable classes. If one monitored classes is predicted to be suitable for of.oad\u00ading, the other classes \nthat are closely related to it will also be  Figure 8. The clustering hierarchy graph of.oaded when \nnecessary. For example, the most computa\u00adtion intensive class of an Android app is a. If the endpoint \npredicts that a should be of.oaded, then it will search the clustering hierarchy graph from the top down \nto .nd the .rst movable cluster that contains a and meanwhile with all its classes being suitable for \nof.oading. At .rst, the endpoint examines Level-1 in Figure 8, and .nds that the cluster at Level-1 is \nanchored. Therefore, the endpoint goes on to ex\u00adamine Level-2. The movable cluster at Level-2, i.e., \nthe clus\u00adter {a, c, d, e, f }, happens to contain a. At this time, the end\u00adpoint will use the prediction \nalgorithm presented in the next section to check whether the classes in the cluster are all suitable \nfor of.oading. Otherwise, it will go on to search the next level to .nd a cluster that can be of.oaded \nas a whole. The extreme case of the end of searching is at Level-9, where the endpoint will surely .nd \na cluster being suitable for of\u00ad.oading, i.e., the single class cluster with only class a.  3.5 Determine \nthe Computations to be Of.oaded As shown in [27], a class that has more bytecode instructions is usually \nthe one that costs more computing resources to run, e.g., CPU and memory. Therefore, DPartner calculates \nthe instruction numbers of each movable app class to .nd the top n (e.g., n=3) computation intensive \nclasses. Then it will store these information into the refactored app. The endpoint will monitor only \nthese top n classes to decide whether of.oading is necessary by executing the following prediction algorithms \nat regular intervals (e.g., 1 second). The monitoring of the other classes is carried out as required, \nwhich helps reduce the runtime overhead on the smartphone. A class instance must satisfy both the following \ntwo for\u00admulas when it is predicted to be suitable for of.oading: (a) .method m of class c, tm phone/tm \noffload = tm phone /(dm input/r + tm phone/i + dm output/r) = a, where a = 1.5. tm phone is the execution \ntime when m is running on the phone, while tm offload is the total execution time when Figure 9. The \nmethod forwarding chain from a proxy to the endpoint m is executed on the server; dm input is the method \ns input parameters in bytes; dm output is the method s return values in bytes; r is the data transmission \nrate over the network; i = cpuserver/cpuphone is the CPU cycle ratio between the server and the phone. \n(b) (Ecpu offload + Ewifi or 3G) = Ecpu local. E is the Android app s power consumption per time unit, \ne.g., 1 second. The inequality means that if class instance c is of.oaded, the app s power consumption \nshould never be greater than that when c is running on the phone. Ewifi or 3G can be calculated by monitoring \nthe Wi-Fi/3G con.g .les of the phone [29] [30]. Ecpu offload and Ecpu local can be cal\u00ad culated by using \nthe mapping algorithm between the byte\u00adcode instructions and energy consumption proposed in [27]. 3.6 \nOf.oad Computations at Runtime As shown in Figure 5, its up to the endpoint to handle the ac\u00adtual crossing \nnetwork communication between app classes. A method invocation from class X to class N is passed .rst \nfrom X to NProxy (which is represented as NIntf ), then to the endpoint, and .nally to N. An example \nof such method forwarding chain is shown in Figure 9. In a method body of NProxy, the invokeMethod method \nof the endpoint is used to forward the method invocation to the may-be-of.oaded class N. The parameters \nof invokeMethod are: (1) the class N s full quali.ed class name; (2) the instance ID of class N. Each \nNProxy holds an ID of a class instance N. The ID is initialized when this proxy is created for the correspond\u00ading \napp class instance. Therefore, the endpoint can use the class name and ID to locate the N instance uniquely; \n(3) the bytecode-level method signature. Java bytecode uses inter\u00adnal name [41] to represent a class \ntype as shown in Figure 9. By using such internal names, DPartner can easily locate the method being \ninvoked on N; (4) the parameters required for the methodM of N being actually executed. With the endpoint, \nthe communication between two classes can be easily optimized. For instance, when class A and B are located \nin different VMs, the endpoint has to pass method invocations through the network stack (e.g., TCP/IP). \nWhen A and B are both located in the same VM, Figure 10. Handling callback-style remote invocation the \nendpoint will use the in-VM local object reference to forward method invocations from A to B. In this \nway, the time-consuming network message transmission is avoided. When invoking methods through the network \nstack, the method parameters have to be serialized. We should pay at\u00adtention to the de/serialization \nmechanism of the caller object in the callback-style method invocation. For instance, the class instances \nof X run on the phone, and the class instance of N run on the server. An X instance calls the handle\u00adCaller(XIntf) \nmethod of NIntf (which represents an NProxy instance when the method is called) by passing itself as \nthe method parameter. The invocation will cause the X instance be serialized on the phone side and then \nbe deserialized on the server side. What should be noted is that after deserial\u00adization, there will be \ntwo X instances, one is the original X instance on the phone, and the other is the copied X instance \non the server. If N processes the copied X on the server, the operations cannot be forwarded back to \nthe X on the phone, which will make these two X inconsistent. Additionally, if X is anchored, it cannot \nrun on the server natively. To solve the above problems, the serialization of X should make an XProxy \ninstance being serialized instead of the X instance itself. Any invocations on the XProxy instance will \nbe called back to the X instance on the phone. The serialization of the caller X to XProxy should not \nim\u00adpact the normal serialization operation of X. For instance, when X is normally serialized, it may \nbe designed to store its .elds into the .le system. To differentiate these two kinds of serialization \noperations, DPartner (1) .rst makes X imple\u00adment a unique interface: ServerObject as described in Sec\u00adtion \n3.3; (2) then creates a unique method getProxyForSe\u00adrializing in X through bytecode rewriting. In this \nmethod, an XProxy will be created and associated with the X object through instance ID. This proxy object \nwill be used as the re\u00adturn value of the method; (3) the endpoint uses a speci.c Ob\u00adjectStream for object \nserialization. If an object is an instance of ServerObject, the getProxyForSerializing method of the \nobject will be invoked. The returned proxy object will .nally be serialized and sent to the server. The \nprocedure of such callback-style method invocation is shown in Figure 10. In addition to forwarding \nmethod invocations, the end\u00adpoint is also responsible for the context synchronization of class instances \nbeing of.oaded. As described in Sec\u00adtion 2.3, the general of.oading procedure is to activate an object \non the server/phone, deactivate its counterpart on the phone/server, and synchronize the object state \nfrom one side (e.g., phone) to another (e.g., server). The getter/setter meth\u00adods of the of.oaded object \nare used to collect and inject its states as described in Section 3.3. Dpartner collects class relationships \nusing proxies, and tracks newly created ob\u00adjects using the re.ection mechanism [42] together with a hashtable-like \ndata structure. Additionally, the speci.c SmartObjectInput/SmartOutputStream are used to check whether \na referred object of the of.oaded one is serializable. If not, these streams will un/wrap the object \nusing NotSeri\u00adalizableObjWrapper , which tries to de/serialize the object s .elds recursively, and send \nthe serialized data to the other side to keep context synchronized. Other communication related code, \ne.g., call-try, dead\u00adlock remover [21], and distributed garbage collection [31] are also implemented \nin the endpoint to form an interception chain for method invocation, which can greatly help improve the \nquality of the crossing network communication. The de\u00adtails can be found at the project website [8]. \n4. Evaluation The goals of the evaluation are to (1) validate whether DPart\u00adner is applicable to of.oad \nreal-world apps with reasonable costs; (2) compare the performance of of.oaded apps with the original \nones; (3) compare the battery power consump\u00adtion of of.oaded apps with the original ones; (4) test whether \non-demand of.oading can really bene.t the phone users. 4.1 Experiment Setup Currently, Wi-Fi is widespread \nin China for regions like schools, hospitals, malls, etc. For instance, The China Tele-Com corp. has \nsetup thousands of free Wi-Fi hotspots across the city of Beijing [34]. Therefore, we evaluate DPartner \nmainly with Wi-Fi connectivity. The tested smartphone is an HTC tattoo [28] with 528MHz CPU, 256MB RAM \nand Android 2.1. The server is a PC running Ubuntu 8.04 with 2.1GHz dual-core CPU and 1GB RAM. The phone \nand the server are connected by Wi-Fi with 50ms RTT (Round Trip Time). The server uses NDIS intermediate \ndriver [32] to add a controlled amount of queuing delay to the network path, which helps simulate different \nRTTs between the phone and the server for evaluating the of.oading effects under differ\u00adent network conditions. \nWe measure the battery power con\u00adsumption of the phone by the PowerTutor Android app [29], which gives \nthe details of the power consumption for each targeted Android app. We evaluate DPartner on three real-world \nAndroid apps shown in Table 2. As described in [7] and [10], the apps worth of.oading are usually the \ncomputation intensive ones  Table 2. The Android apps for evaluation Table 3. The refactoring performance \nof DPartner Features Linpack Chess Game 3D Car Game UI GUI GUI GUI Interactive No Yes Yes Computation-Intensive \nHigh High High Data-Intensive Low Medium High Multi-Thread No Yes Yes such as the image/audio/text processing \napps and games, which fall into the following Android Market categories: entertainment and games, media \nand video, music and au\u00addio, books and texts, and photography. More than 50% of 487,601 apps on Android \nMarket in July 2012 [33] belong to these categories, and we selected three typical ones for evaluation. \nEvaluations on other apps are available on the project website [8]. Table 2 shows the features of the \nthree apps that are im\u00adportant to of.oading. The .rst app is the Linpack bench\u00admark [35] that carries \nout numerical linear algebra compu\u00adtations. The second is a chess game called Andgoid [36], an interactive \napp that allows a human player to place chess pieces by using the touch screen of the phone. The human \nand AI player each runs in a separate thread. It is more data\u00adintensive than the Linpack app because \nwhen it is the turn of the AI player, all the chess piece positions on the chess board will be transferred \nto the AI class to compute the po\u00adsition of the next piece. The third is a 3D car game called XRace [37], \na more interactive Android app. The car s di\u00adrection and speed are controlled by the gravity sensor of \nthe phone. It is also a multi-thread program. Comparing with the other two apps, the car game is the \nmost data-intensive be\u00adcause it reads many data to form the 3D racing scenario, and its collision detection \nlogic has to take in many car position data to check whether the car is running out of the road or colliding \nwith the boundary fence. All the above three apps are computation-intensive, which means that they are \nmuch more suitable to be of.oaded to take advantage of the pow\u00aderful processing capability of the server. \n 4.2 Performance of Refactoring Table 3 shows the refactoring performance of DPartner on the three Android \napps. The size of the app after refactoring will be increased because DPartner rewrites each app class \nand generates proxies and interfaces for them. The endpoint code are also linked into the app. Since \nthe size of smart\u00adphone s memory keeps growing and Android supports the memory to SD card app-installation \nfeature, the increase of app size is acceptable. The refactoring time increases with the total number \nof bytecode instructions (just like the lines of code) of the Android app, which is also acceptable in \nprac\u00adtice because refactoring is performed before runtime. To some extent, the percentage of movable \nclasses im\u00adplies the possibility and .exibility of computation of.oad\u00ading. In our experiment, the Linpack \napp has only 1 movable class, i.e., the Linpack.class, which performs algebra compu\u00adtations. The chess \ngame has 31 movable classes, which are all used for different AI algorithms. The anchored classes of \nthe above two apps all deal with UI interactions. The car game has 39 movable classes while its anchored \nclasses control the gravity sensor and draw images with Android OpenGL ES library [46].  In the movable \nclasses, the most computation intensive one is com.greenecomputing.linpack.Linpack in Linpack, insa.android.andgoid.strategy.MonteCarloAI \nin the chess game, and com.sa.xrace.collision.Line2f in the car game. These three classes will be monitored \nby the endpoint at runtime as described in the last paragraph of Section 3.4. Ta\u00adble 4 shows the movable \nclusters containing the monitored classes. For each app, the movable clusters are arranged in the hierarchical \nstructure just like Figure 8. We manually checked the clustering results and found that all these classes \nwere indeed closely related, which shows the correctness of clustering. Take the 3D car game as a example, \nthe classes such as Line2f, AABBbox, and MathUtil are all used together for collision detection. 4.3 \nComparison of App Performance We compared the performance of the above three apps by running them in \neight different scenarios. In the .rst sce\u00adnario, the original apps run entirely on the phone. In the \nnext scenario, the refactored apps run entirely on the phone. In the following four scenarios, the clustered \nclasses in Table 4 are of.oaded to always execute on the server. The phone and the server are connected \nusing Wi-Fi with different RTT val\u00adues (50ms, 100ms, 150ms, and 200ms). The exact clusters to be of.oaded \nare at Level-i, Level-j, and Level-k for the three  Figure 12. The power consumption comparison of \nthe Android apps running in different scenarios Table 4. The movable cluster containing the monitored \nclass App Cluster Level The Classes in the Movable Cluster Linpack Linpack Level-i (i=1) {Linpack}Level-j \n(j=1) {MonteCarloAI, UCTNode} Chess AI Level-(j+1) {MonteCarloAI}Level-k (k=1) {Line2f, AABBbox, Rectangle, \nMathUtil, Matrix4f, Point2f, Point3f, Plane3D, Colli- Car Collision sionHandler}Level-(k+1) {Line2f, \nRectangle, MathUtil, Matrix4f, Point2f, Point3f, Plane3D}Level-(k+2) {Line2f, Rectangle, MathUtil, Point2f}Level-(k+3) \n{Line2f} apps, respectively. In the seventh scenario, we force apps to of.oad only the monitored class, \ni.e., Linpack, MonteCar\u00adloAI, and Line2f executed on the server during the test with 50ms RTT, so that \nwe can test whether clustering can really help avoid the high overhead of the crossing network com\u00admunication. \nThe .nal scenario is for adapting the of.oading and will be discussed in Section 4.5. The performance \ncomparison results are shown in Fig\u00adure 11. We can see that, running the refactored app entirely on the \nphone will increase the execution duration slightly compared with the original app. For instance, in \nthe Linpack test, one run of the original Linpack costs 3.734s, while the refactored Linpack costs 3.792s, \ni.e., with an overhead of 0.058s. For another instance, the time cost for drawing 100 frames of the refactored \n3D car game running entirely on the phone is 0.367s slower than the original app. The slight in\u00adcrease \nof execution time is due to that method invocations between local classes will be forwarded by the proxies \nand the endpoint. However, of.oading can really help improve the app per\u00adformance. For instance, when \nof.oading the Linpack cluster to the server, the execution time of the same test with 50ms RTT is just \n0.078s or reduced by 98%. The time for the AI to calculate the chess piece position in the original chess \ngame is 13.63s on average, while the time for the refactored chess game with the AI cluster being of.oaded \nis just 1.681s or re\u00adduced by 88%. The execution time for drawing 100 frames in the car game is reduced \nby 70%. The reason for the great performance improvement is that the computation intensive code is executed \non a more powerful processor of the server other than the phone s own processor. The quality of the network \nimpacts the of.oading effect signi.cantly. If the RTT value becomes larger, the perfor\u00admance of the of.oaded \napp will get decreased due to the fact that more time will be spent on network communication. For instance, \nwhen RTT is 50ms, drawing 100 graph-frames in the 3D car game will cost 3.925s. However, when RTT is \n200ms, this value is just 6.881s or is increased by 75%. Of.oading only the most computation intensive \nclass but not the class cluster it belonged to will often put a negative impact on the app s performance, \nand even make of.oading unworthy. For instance, in the Of.oad* test of the chess game, the time cost \nfor the AI player to calculate the chess piece position is 8.211s; while of.oading the AI cluster (i.e., \nthe cluster containing the MonteCarloAI and the UCTNode classes) can cost only 1.681s to .nish such a \ncomputation. For another instance, in the Of.oad* test of the 3D car game, drawing 100 frames will cost \n15.679s, which is even longer than that of the original app running on the phone. The total time can \nbe divided into three parts: (1) phone, the time spent on the phone; (2) network, the time spent on the \nnetwork; (3) server, the time spent on the server. The time spent on the network increases sharply in \nOf.oad* (accounting for 63% of the total execution time of this test, as shown in Figure 11). Thus we \ncan see that of.oading in the cluster unit can greatly improve the performance of an of.oaded app, because \nit reduces the unnecessary network communication between the parts on the phone and the parts on the \nserver.  4.4 Comparison of App Power Consumption The power consumption results are shown in Figure \n12. When running the refactored app entirely on the phone, its power consumption will increase slightly \ncompared with the original app, because the proxies and the endpoint in the refactored app cost energy \nto run. We can also see that, as of.oading makes some computation intensive code be exe\u00adcuted on the \nserver, the energy consumption of an of.oaded Android app is often reduced. For instance, in the Linpack \ntest, running the benchmark one time will cost 3.28 Joules, while the result of the of.oaded Linpack \nwith 50ms RTT is just 0.54 Joules or reduced by 83%. What should be noted is that, the power of the Wi-Fi \non the HTC smartphone we used is about 0.78 watt [28], which may make the of.oaded app s power consumption \nbe greater than that of the original app. However, we get very small energy consumption (e.g., 0.54J) \nin the of.oaded tests because: (1) when the Wi-Fi de\u00advice is not working, it will enter a sleep phase \nfor saving en\u00adergy. The power consumption in such a phase is about 30mJ on the tested smartphone [28]; \n(2) In the Linpack app, one execution of the benchmark will run the Linpack class in\u00adstance 3 times to \nget the average test results. The number of runs (i.e., 3) will be sent as a parameter to the Linpack \nclass. Therefore, in the of.oaded app, the Wi-Fi channel will de\u00adliver the method request for linpack-calculation \njust once, and the server will execute the Linpack class instance three times before returning the average \nresults. Thus the power consumption of the Wi-Fi is further reduced; (3) the time for sending one method \nrequest is very short, e.g., usually less than 10ms. Therefore, the total power consumed by Wi-Fi will \nnot be much when the number of the crossing network communication is relatively small. However, as shown \nby the Of.oad* test in Figure 12, if the network communica\u00adtion becomes too frequent, the power consumption \nof Wi-Fi will increase. Thus the whole power consumption of the of\u00ad.oaded app will also increase. For \ninstance, when of.oad\u00ading only the Line2f class of the 3D car game, the app will consume 30.86 more Joules \nthan of.oading the whole Col\u00adlision class cluster. A lot of energy is wasted on the crossing Table 5. \nThe on-demand of.oaded computations in detail  Time (s) RTT (ms) Of.oaded Computations Description Linpack \nChess Car 0 200 Level-i Level-j Level-k of.oaded execution, performance decreases with the increase of \nRTT 15 250 Level-i Level-j Level-k 30 300 Level-i Level-j Level-k 45 350 Level-i Level-j Level-k network \npacket loss, invocation retry, from of.oading only the suitable computations to of.oading none 60 400 \nLevel-i Level-(j+1) Level-(k+1) 75 450 Level-i Level-(j+1) Level-(k+2) 90 500 Level-i Level-(j+1) Level-(k+3) \n105 550 None None None 120 600 None None None local execution network communication between the closely-related \nbut not\u00adtogether-of.oaded classes. 4.5 The Effect of On-Demand Of.oading The last scenario in Figures \n11 and 12 shows the perfor\u00admance and power consumption of the three apps when of\u00ad.oading is adapted during \nthe RTT value changing from 200ms to 600ms gradually in 120 seconds. The correspond\u00ading details are presented \nin Figure 13 and Table 5. We can see that the performance plot of the apps can be divided into 3 regions. \nRegion-1 is 0~30s when RTT increases from 200 to 300ms gradually. During this period, the of.oaded computations \nare the Level-i cluster of Linpack, the Level\u00adj cluster of chess, and the Level-k cluster of car game \n(see Table 4). The app performance decreases with the increase of RTT. Region-2 is 30~105s when RTT increases \nfrom 300 to 550ms. The app performances during this period fall sharply. Network packet loss has happened \nin this period, which causes the endpoint to retry method invocation several times. When found that the \nof.oaded computations fail to satisfy the of.oading requirements described in Section 3.5, the endpoint \nwill draw these computations back to execute on the phone. For example, the endpoint of the car game \nwill .rst draw back the computations of the classes in cluster (Level-k) -cluster (Level-(k+1)), that \nis, the class instances belonging to cluster (Level-k) but not to cluster (Level-(k+1) will be drawn \nback to execute on the phone (see Table 4 and 5). At this point, the of.oaded computations are just the \nclass instances of the cluster Level-(k+1). As RTT increases continuously, the endpoint will change the \ncontents of the of.oaded computations to maintain the performance as de\u00adscribed in Section 3.4. For example, \nthe of.oaded compu\u00adtations of the car game changes from Level-(k+1) to Level\u00ad(k+2), then to Level-(k+3), \nand .nally to none. In the 105th seconds, all the computations of the tested apps have come back to execute \non the phone till the end of the test as shown in Region-3 of the plot.  4.6 Experiments on 3G Network \nAs 3G has become a widely accepted way to connect a smartphone and the servers in Cloud, we continue \nto test the refactored apps with 3G connectivity. We use a server in our Cloud platform [47], which can \nbe publicly accessed using 3G. The server is a Ubuntu 8.04 Xen VM [48] with 2.0GHz four-core CPU and \n1GB RAM running on IBM blade HS22. We use the Chess app in the experiment with the experiment setup remained \nthe same as previously, except that the of.oaded cluster is accessed using 3G. The remained parts of \nthe app on the phone use HTTP instead of TCP connections to interact with the of.oaded parts of the app \nrunning on the server. The RTT value of the 3G test is about 360 ms, the upload speed is 23.4kb/s, and \nthe download speed is 28.9kb/s. Figures 14 and 15 present the performance and power consumption results, \nrespectively. We have three observa\u00adtions from the results. First, of.oading can really help im\u00adprove \nthe app performance a lot even if we connect the phone with the server using a relatively slower network \nconnection of 3G instead of Wi-Fi. The average execution time of one round of Chess AI is 2.426s or reduced \nby 82.2% in 3G test compared with that of the original app running entirely on the phone. Second, The \nperformance of the server greatly affects the of.oading effects. The Cloud server we used in the experiment \nis much more powerful than the PC we used in the prior tests. Therefore, the time delay brought by the \nslow network connection of 3G can be partly offset by the high computing capability of the Cloud server, \nand the .\u00adnally obtained of.oading effects are still very good. Third, 3G costs more energy than Wi-Fi. \nThe power consumption of one round of Chess AI with Wi-Fi is 1.01 Joules on average. The consumed energy \nincreases to 2.56 Joules in the 3G test. The above results indicate that of.oading can save energy and \nimprove performance for smartphone apps. However, this usually depends on the server s performance and \nthe amounts of data exchanged through the network. Therefore, computation of.oading is more suitable \nto of\u00ad.oad computation-intensive apps with only a small amount of data exchanged between the server and \nthe client [7], es\u00adpecially on 3G network.  Figure 15. The chess s power consumption in 3G test 5. Related \nWork The idea of using a strong server to enhance the process\u00ading capabilities of a weak device (e.g., \nmobile phone) is not new [7]. Many early research projects have tried to automat\u00adically partition a standalone \ndesktop app to have some parts of it executed remotely on the server. The research on mobile computing \nthen leverage such an idea to realize computation of.oading on a smartphone. Coign [12] is an early work \non computation of.oading. It takes the binary code of a Windows .COM application, then by using code \ninterception and rewriting, it turns the app into a DCOM application with some COM components running \non a common PC (i.e., a weak device) and the rest running on a powerful server (i.e., a strong surrogate). \nIn this way, the performance of the original application can be improved. J-Orchestra [13] and JavaParty \n[14] are the early work on of.oading standalone desktop Java applications. J-Orchestra works on the Java \nbytecode level, while JavaParty works on the source code level. They both require develop\u00aders to manually \ntell the of.oading tool about which class can be of.oaded. For instance, J-Orchestra provides a GUI to \nask developers to select the can-be-of.oaded classes. Java-Party asks developers to annotate the source \ncode with the Remote keyword. Then the compiler provided by these tools will compile these selected classes \nto generate the RMI stubs/skeletons for them [45], so that the app is turned to be a client/server one \nby using RMI as the communication channel. The work of J-Orchestra and JavaParty cannot be directly used \nfor of.oading Android apps. One reason is that Android does not support RMI. The research on mobile \ncomputing follows the above early work to of.oad computations running on the phone to run on the server. \nAIDE [15][16] can partition a mobile Java application at runtime through JVM instrumentation. It leverages \na fuzzy control model to decide which class should be transferred to the server. The code on the phone \nand the code on the server can cooperate to work with the support of the modi.ed JVM. Similarly, CloneCloud \n[17] augments the performance of Smartphone apps through clone cloud execution. It modi.es the Android \nDalvik VM to provide an application partitioner and an execution runtime to help apps running on the \nVM of.oad tasks to execute on a cloned VM hosted by a Cloud server. MAUI [11] requires developers to \nannotate the can-be-of.oaded methods of a .Net mobile application by using the Remoteable annotation. \nThen the MAUI analyzer will decide which method should really be of.oaded through runtime pro.ling. Cuckoo \n[10] is an of\u00ad.oading framework for Android apps. It requires developers to follow a speci.c programming \nmodel to make some parts of the app be of.oaded. JDOP [18] mainly focuses on the algorithm of how to \ndistribute objects among the phone and the server to achieve high app performance, and provides the request \nresolver and dispatcher facilities to make objects be able to of.oad. Spectra [19] requires developers \nto specify movable classes and modify the application. It then performs of.oading at the granularity \nof methods. Puppeteer [20] tar\u00adgets at data adaptation via of.oading when facing with lim\u00adited bandwidth, \nand it is applicable for only COM/DCOM\u00adlike component-based applications. Our of.oading approach and \nthe DPartner tool are differ\u00adent from the above work mainly in the aspects below. First, our approach \nis transparent to developers. We neither re\u00adquire them to annotate the code of an Android app to decide \nwhich class should be of.oaded, nor require them to follow a speci.c programming model to redesign the \nwhole app. Second, of.oading at the granularity of class/object makes our approach be more suitable for \nobject-oriented programs. Third, our approach can enable the on-demand of.oading of an given Android \napp, while few of the above existing work can support such a feature. What should be noted is that, al\u00adthough \nthe research projects such as AIDE, CloneCloud, and MAUI have tried to make of.oading be on-demand. They \nall have some obvious drawbacks that can make them be im\u00adpractical. For instance, AIDE and CloneCloud \nrequire using a modi.ed JVM, and MAUI requires developers to anno\u00adtate source code methods. DPartner \ndoes not impose such requirements. It can refactor any Android app into the one supporting on-demand \nof.oading, no matter the app is newly designed or is already installed on a phone. 6. Conclusion and \nFuture Work In this paper, we presented DPartner for automatically refac\u00adtoring an Android app into one \nimplementing the on-demand computation of.oading design pattern, which can transfer some computation-intensive \ntasks from a smartphone to a server so that the task execution time and battery power consumption of \nthe app can be reduced signi.cantly. DPart\u00adner will be improved and further validated as follows. First, \nmore experiments with real-world Android apps will be done, especially on 3G network. Second, to support \nrefac\u00adtoring and of.oading obfuscated apps. DPartner leverages Dexmaker [43] and ASM [44] for bytecode \nrefactoring. These libraries do not fully support obfuscated bytecode currently. Third, better measuring \ntools will be used. For example, we will use an external current meter to measure the power consumption \nof a phone much more accurately, and use routers to measure the amount of network packets transmitted. \nFourth, more rules and algorithms will be ex\u00adplored and evaluated for deciding which class should be \nof\u00ad.oaded. We will put further results on the website of DPart\u00adner: https://code.google.com/p/dpartner/. \nAcknowledgments We thank Professor Lu Zhang of Peking University, Professor Tao Xie of North Carolina \nState University, Professor Zhendong Su of the University of California -Davis, and the anonymous review\u00aders \nfor their valuable feedback on an earlier version of this pa\u00adper. This work is supported by the National \nBasic Research Pro\u00adgram of China (973) under Grant No. 2009CB320703; the National Natural Science Foundation \nof China under Grant No. 61121063, 60933003, 61003010; the European Commission Seventh Frame\u00adwork Programme \nunder grant no. 231167; the IBM-University Joint Study and the NCET. References [1] Android, http://www.android.com/ \n[2] Smartphone Market Share, http://www.idc.com/getdoc.jsp? containerId=prUS23503312 [3] Google Play, \nhttps://play.google.com/store [4] The applications number of the Google Play, http://en.wikipedia. org/wiki/Google \nPlay [5] Apps drain battery power, www.droidforums.net/forum/droid\u00adrazr-support/216454-battery-drain.html \n[6] Android Application Requirements, www.netmite.com/ android/mydroid/development/pdk/docs/system requirements \n[7] Karthik Kumar, Jibang Liu, Yung-Hsiang Lu, Bharat Bhar\u00adgava. A Survey of Computation Of.oading for \nMobile Sys\u00adtems . In the Journal of Mobile Networks and Applications, Springer, April, 2012. [8] Dpartner: \nhttp://code.google.com/p/dpartner/ [9] Martin Fowler, Kent Beck, John Brant, William Opdyke, Don Roberts. \nRefactoring: Improving the Design of Existing Code . Publisher:Addison-Wesley, First edition, 1999. \n[10] Roelof Kemp, Nicholas Palmer. Cuckoo: a Computation Offoading Framework for Smartphones . In Proceedings \nof the International Conference on Mobile Computing, Applica\u00adtions, and Services (MobiCase), pp. 1-20, \n2010. [11] Eduardo Cuervoy, Aruna Balasubramanianz, Stefan Saroiux, Ranveer Chandrax, Paramvir Bahlx. \nMAUI: Making Smart\u00adphones Last Longer with Code Of.oad . In Proceedings of the International Conference \non Mobile Systems, Applications, and Services (MobiSys), pp. 49 -62, 2010. [12] Galen C. Hunt and Michael \nL. Scott. The Coign Auto\u00admatic Distributed Partitioning System . In Proceedings of the USENIX Symposium \non Operating Systems Design and Imple\u00admentation (OSDI), pp. 187-200, 1999. [13] Eli Tilevich and Yannis \nSmaragdakis. J-Orchestra: En\u00adhancing Java Programs with Distribution Capabilities . In ACM Transactions \non Software Engineering and Methodol\u00adogy (TOSEM), Vol. 19, No. 1, Article 1, pp. 1-41, 2009. [14] Michael \nPhilippsen and Matthias Zenger. JavaParty: Trans\u00adparent Remote Objects in Java . In Concurrency: Practice \nand Experience 9(11):1225-1242, John Wiley &#38; Sons, Ltd., 1997. [15] Alan Messer, Ira Greenberg, Philippe \nBernadat, DeJan Milo\u00adjieie, Deqing Chen, T.J. Giuli, Xiaohui Gu. Towards a dis\u00adtributed platform for \nresource-constrained devices . In Pro\u00adceedings of the International Conference on Distributed Com\u00adputing \nSystems (ICDCS), pp. 43-51, 2002. [16] Xiaohui Gu, Klara Nahrstedt, Alan Messer, Ira Greenberg, and Dejan \nMilojicic. Adaptive Of.oading for Pervasive Computing . In IEEE Pervasive Computing, pp. 66-73, 2004. \n[17] Byung-Gon Chun, Sunghwan Ihm, Petros Maniatis, et al. CloneCloud: Elastic Execution between Mobile \nDevice and Cloud . In Proceedings of the European Conference on Com\u00adputer Systems (EuroSys), pp. 301-314, \n2011. [18] Lei Wang and Michael Franz. Automatic Partitioning of Object-Oriented Programs for Resource-Constrained \nMobile Devices with Multiple Distribution Objectives . In Proceed\u00adings of the International Conference \non Parallel and Dis\u00adtributed Systems (ICPADS), pp. 369-376, 2008. [19] J. Flinn, S. Park, and M. Satyanarayanan. \nBalancing Perfor\u00admance, Energy, and Quality in Pervasive Computing . In Pro\u00adceedings of the IEEE International \nConference on Distributed Computing Systems (ICDCS), pp. 1-10, 2002. [20] E. Lara, D. S. Wallach, and \nW. Zwaenepoel. Puppeteer: Component-based Adaptation for Mobile Computing . In Proceedings of the USENIX \nSymposium on Internet Technolo\u00adgies and Systems (USITS), pp. 159-170, 2001. [21] Eli Tilevich and Yannis \nSmaragdakis. Portable and Ef\u00ad.cient Distributed Threads for Java . In Proceedings of the ACM/IFIP/USENIX \nInternational Middleware Confer\u00adence (Middleware), pp. 478-492, 2004. [22] Girvan, M. and NewMan, M.E.. \nCommunity structure in so\u00adcial and biological networks . In Proceedings of the National Academy of Sciences \nof the United States of America (PNAS), Vol. 99, pp. 7821-7826, 2002. [23] J. Han and M. Kamber. Data \nMining: Concepts and Tech\u00adniques . Morgan Kaufmann Publishers, 2001. [24] Lu Zhang, Jing Luo, He Li, \nJiasu Sun, and Hong Mei. A Biting-Down Approach to Hierarchical Decomposition of Object-Oriented Systems \nBased on Structure Analysis . In the Journal of Software Maintenance and Evolution: Research and Practice, \nVol. 22, No. 8, pp. 567-596, 2010. [25] Jonathan I. Maletic and Andrian Marcus. Supporting Pro\u00adgram Comprehension \nUsing Semantic and Structural Infor\u00admation . In Proceedings of the International Conference on Software \nEngineering (ICSE), pp. 103-112, 2001. [26] Call Graph, http://en.wikipedia.org/wiki/Call graph [27] \nWalter Binder, et al. Using Bytecode Instruction Counting as Portable CPU Consumption Metric . In Electronic \nNotes in Theoretical Computer Science, Elsevier, pp. 57-77, 2006. [28] HTC Tattoo, www.htc.com/europe/product/tattoo/overview.html \n[29] PowerTutor, http://powertutor.org/ [30] L. Zhang, B. Tiwana, Z. Qian, Z. Wang, et al. Accurate online \npower estimation and automatic battery behavior based power model generation for smartphones . In Proceedings \nof the In\u00adternational Conference on Hardware/Software Codesign and System Synthesis (CODES+ISSS), pp. \n105-114, 2010. [31] Saleh E., Abdullahi, et al. Garbage Collecting the Internet: A Survey of Distributed \nGarbage Collection . In ACM Comput\u00ading Surveys, Vol. 30, No. 3, pp. 330-373, 1998. [32] Network Driver \nInterface Speci.cation (NDIS), http://wikipedia.org/wiki/Network Driver Interface Spec [33] The Android \napplication categories, http://www. appbrain.com/stats/android-market-app-categories [34] Wi-Fi Hotspots \nin Beijing, http://www.theregister.co.uk/2011/11/03/china free wi./ [35] Linpack, https://market.android.com/details?id= \ncom.greenecomputing.linpack [36] Chess Game, http://code.google.com/p/andgoid/ [37] Car Game, http://code.google.com/p/xrace-sa/ \n[38] Android Service, http://developer.android.com/reference/ android/app/Service.html [39] Android Interface \nDe.nition Language (AIDL), http://developer.android.com/guide/developing/tools/aidl.html [40] Android \nApi Demo, http://developer.android.com/resources/samples/ApiDemos/ [41] The JavaTM Virtual Machine Speci.cation, \nsecond edition, http://docs.oracle.com/javase/specs/jvms/se7/html/index.html [42] Java Re.ection, http://java.sun.com/developer/technicalArticles/ALT/Re.ection/ \n[43] Dexmaker: Programmatic code generation for Android, http://code.google.com/p/dexmaker/ [44] ASM: \nA Java bytecode engineering library, http://download.forge.objectweb.org/asm/asm4-guide.pdf [45] Remote \nMethod Invocation (RMI), http://docs.oracle.com/javase/tutorial/rmi/overview.html [46] Android OpenGL \nES, http://developer.android.com/guide/topics/graphics/opengl.html [47] Internetware Testbed, http://icloud.internetware.org/ \n[48] Xen, http://www.xen.org/   \n\t\t\t", "proc_id": "2384616", "abstract": "<p>Computation offloading is a promising way to improve the performance as well as reducing the battery power consumption of a smartphone application by executing some parts of the application on a remote server. Supporting such capability is not easy for smartphone application developers due to (1) correctness: some code, e.g., that for GPS, gravity, and other sensors, can run only on the smartphone so that developers have to identify which parts of the application cannot be offloaded; (2) effectiveness: the reduced execution time must be greater than the network delay caused by computation offloading so that developers need to calculate which parts are worth offloading; (3) adaptability: smartphone applications often face changes of user requirements and runtime environments so that developers need to implement the adaptation on offloading. More importantly, considering the large number of today's smartphone applications, solutions applicable for legacy applications will be much more valuable. In this paper, we present a tool, named DPartner, that automatically refactors Android applications to be the ones with computation offloading capability. For a given Android application, DPartner first analyzes its bytecode for discovering the parts worth offloading, then rewrites the bytecode to implement a special program structure supporting on-demand offloading, and finally generates two artifacts to be deployed onto an Android phone and the server, respectively. We evaluated DPartner on three real-world Android applications, demonstrating the reduction of execution time by 46%-97% and battery power consumption by 27%-83%.</p>", "authors": [{"name": "Ying Zhang", "author_profile_id": "81548688356", "affiliation": "Institute of Software, School of Electronics Engineering and Computer Science, Peking University, Beijing, China", "person_id": "P3856069", "email_address": "zhangying06@sei.pku.edu.cn", "orcid_id": ""}, {"name": "Gang Huang", "author_profile_id": "81350600064", "affiliation": "Institute of Software, School of Electronics Engineering and Computer Science, Peking University, Beijing, China", "person_id": "P3856070", "email_address": "hg@pku.edu.cn", "orcid_id": ""}, {"name": "Xuanzhe Liu", "author_profile_id": "81323493291", "affiliation": "Institute of Software, School of Electronics Engineering and Computer Science, Peking University, Beijing, China", "person_id": "P3856071", "email_address": "liuxzh@sei.pku.edu.cn", "orcid_id": ""}, {"name": "Wei Zhang", "author_profile_id": "81540024756", "affiliation": "Institute of Software, School of Electronics Engineering and Computer Science, Peking University, Beijing, China", "person_id": "P3856072", "email_address": "zhangwei11@sei.pku.edu.cn", "orcid_id": ""}, {"name": "Hong Mei", "author_profile_id": "81100215033", "affiliation": "Institute of Software, School of Electronics Engineering and Computer Science, Peking University, Beijing, China", "person_id": "P3856073", "email_address": "meih@pku.edu.cn", "orcid_id": ""}, {"name": "Shunxiang Yang", "author_profile_id": "81548301856", "affiliation": "Institute of Software, School of Electronics Engineering and Computer Science, Peking University, Beijing, China", "person_id": "P3856074", "email_address": "yangsx07@sei.pku.edu.cn", "orcid_id": ""}], "doi_number": "10.1145/2384616.2384634", "year": "2012", "article_id": "2384634", "conference": "OOPSLA", "title": "Refactoring android Java code for on-demand computation offloading", "url": "http://dl.acm.org/citation.cfm?id=2384634"}