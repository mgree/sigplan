{"article_publication_date": "10-19-2012", "fulltext": "\n The HipHop Compiler for PHP Haiping Zhao Iain Proctor MinghuiYang XinQi MarkWilliams Qi Gao Guilherme \nOttoni * AndrewParoski Scott MacVicar Jason Evans StephenTu Facebook, Inc. Abstract Scripting languages \nare widely used to quickly accomplish a variety of tasks because of the high productivity they en\u00adable. \nAmong other reasons, this increased productivity re\u00adsults from a combination of extensive libraries, \nfast devel\u00adopment cycle, dynamic typing, and polymorphism. The dy\u00adnamic features of scripting languages \nare traditionally asso\u00adciated with interpreters, which is the approach used to imple\u00adment most scripting \nlanguages. Although easy to implement, interpreters are generally slow, which makes scripting lan\u00adguages \nprohibitive for implementing large, CPU-intensive applications. This ef.ciency problem is particularly \nimpor\u00adtant for PHP given that it is the most commonly used lan\u00adguage for server-side web development. \nThis paper presents the design, implementation, and an evaluation of the HipHop compiler for PHP. HipHop \ngoes against the standard practice and implements a very dy\u00adnamic language through static compilation. \nAfter describ\u00ading the most challenging PHP features to support through static compilation, this paper \npresents HipHop s design and techniques that support almost all PHP features. We then present a thorough \nevaluation of HipHop running both stan\u00addard benchmarks and the Facebook web site. Overall, our experiments \ndemonstrate that HipHop is about 5.5\u00d7 faster than standard, interpreted PHP engines. As a result, HipHop \nhas reduced the number of servers needed to run Facebook and other web sitesbyafactor between4 and6, \nthus drasti\u00adcally cutting operating costs. Categories and Subject Descriptors D.3.4[Programming Languages]: \nProcessors compilers, optimization, code generation General Terms Languages, Design, Performance Keywords \nPHP, dynamic languages, compilation, C++ * Contact author. E-mail address: ottoni@fb.com Currently af.liated \nwith MIT. Permission to make digital or hard copies of all or part of this work for personal or classroom \nuse is granted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page.To copy otherwise, to republish, \nto post on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. OOPSLA \n12, October 19 26, 2012,Tucson, Arizona, USA. Copyright c &#38;#169; 2012ACM 978-1-4503-1561-6/12/10... \n$10.00 1. Introduction General-purpose scripting languages like Perl, Python, PHP, Ruby, and Lua have \nbeen widely used to quickly accom\u00adplish a broad variety of tasks. Although there are several reasons \nfor the widespread adoption of these languages, the key common factor across all of them is the high \nprogram\u00admers productivity that they enable [14]. This high produc\u00adtivity is the result of a number of \nfactors. First, these lan\u00adguages typically provide a rich set of libraries, which re\u00adduce the amount \nof code that programmers need to write, test, and debug. Second, the dynamically-typed nature of scripting \nlanguages provides .exibility and high degrees of dynamic polymorphism. Last, and most important, dynamic \nlanguages are in general purely interpreted, thus providing a fast cycle to modify and test source changes. \nBy purely interpreted we mean that there is no compilation step nec\u00adessary to run a program after writing \nor modifying it. This advantageisparticularly relevantinthedevelopmentofvery large systems, which typically \ntake substantial time to stati\u00adcally compile and link. On the down side, the major issue with scripting \nlan\u00adguages in general is performance. Because of their dynamic features, these languages are typically \nimplemented via in\u00adterpreters. Experiments have shown that programs tend to take an order of magnitude \nmore CPU time to run when im\u00adplemented in interpreted languages compared to correspond\u00ading implementations \nin compiled languages [22]. Although performance is often not important for small scripts written to \naccomplish simple tasks, it does become a major problem when developing large CPU-intensive appli\u00adcations. \nThis has spurred a number of efforts to try to im\u00adprove the performance of scripting languages [3, 8, \n10, 19, 21, 24]. Among all general-purpose scripting languages, this problem is probably most pronounced \nfor PHP, since it is the most commonly used language for server-side web develop\u00adment [23]. Given the \nscale of users and data that Internet companies have, improving server ef.ciency is a key factor to reduce \ntheir operating costs incurred by running huge data centers.  This paper describes the approach that \nwe took at Face\u00adbook to address the performance problem of PHP. Our main insight to improve performance \nwas to implement PHP via a static compiler, called HipHop. Although static compila\u00adtion requires all \nthe code to be known in advance, this is a minor imposition for server-side applications, which are the \ncore usage of PHP. Going against the standard practice of implementing PHP via interpreters, HipHop has \nproved to be a high risk, high reward project. As this paper describes, there are a number of challenges \nto enable static compila\u00adtion of a dynamic language like PHP. Despite these chal\u00adlenges, HipHop supports \na very large subset of PHP, and it only lacks a few, less useful language features. HipHop is a source-to-source \ncompiler, and it transforms PHP programs into semantically equivalent C++ programs. This design en\u00adables \nleveraging high-quality optimizing C++ compilers to produce machine code, and we currently use GCC [9]. \nTo obtain high performance, in addition to leveraging GCC op\u00adtimizations, HipHop also implements a number \nof optimiza\u00adtions. As our experiments show, this approach has enabled HipHop to run both benchmark and \nreal-world applications 5.5\u00d7 faster on average than the standard PHP implementa\u00adtion [25]. Finally, although \nHipHop only supports PHP, we believe that many of its techniques can be used to improve the performance \nof other scripting languages as well. HipHop has been releasedbyFacebook as an open-source project [6], \nand it is currently deployed not only within Facebook but also in other companies. In all these cases, \nHipHop has reduced the number of servers needed to run web sitesbyafactor between4and6, thus drastically \ncutting operating costs. This paper describes our experience in the design and implementation of the \nHipHop compiler. More speci.cally, this paper makes the following main contributions: 1. It describes \nthe set of techniques that enabled implement\u00ading a general-purpose, dynamic scripting language with a \nstatic compiler. 2. It describes the set of compilation techniques that enable HipHop to achieve outstanding \nperformance for PHP. 3. It presents a thorough experimental evaluation of HipHop running both benchmarks \nand real-world applications from Facebook. This evaluation includes comparisons with other PHP execution \nengines.  The rest of this paper is organized as follows. Section 2 gives a brief introduction to PHP, \nits key dynamic features, and its standard implementation. Section3then presents the design of the HipHop \ncompiler and its main techniques.Fol\u00adlowing that, Section4 presentsa detailedexperimentaleval\u00aduation \nof HipHop and compares it to other PHP execution engines. Finally, Section 5 discusses related work and \nSec\u00adtion6 concludes the paper. 01) <?php 02) 03) define(\"confName\", \"OOPSLA\"); 04) define(\"firstYear\", \n1986); 05) 06) function year($edition) { 07) return firstYear -1 + $edition; 08) } 09) 10) echo \"Hello \n\" . confName . \" \" . year(27); Figure 1. PHP code example 2. PHP Background PHP is an imperative scripting \nlanguage, originally con\u00adceived in 1995 for creating dynamic web pages. After its ini\u00adtial de.nition, \nPHP has evolved signi.cantly. Since version 3, PHPis an object-oriented programming language and to\u00adday, \nat version 5.4, it is a general-purpose language used be\u00adyond web development. Like Java, PHP combines \ninterfaces and single inheritance. However, since version 5.4, PHP also supports traits [5]. In the absence \nof a formal speci.cation, the language is de.ned by its standard implementation [25]. Although PHP syntactically \nresembles C++, PHP is in\u00adherently much more dynamic. Figure 1 illustrates a simple PHP example, which \nprints Hello OOPSLA 2012 . The definesin lines3 and4 are calls toabuilt-in function that declares a constant \nnamed after its .rst argument and with value given by its second argument. In line 10, echo prints to \nthe output and . is string concatenation. Syntactically, some key differences from C++ are: (1) names \nof variables start with $ , and (2) variables are not declared. Given that C++ well represents the class \nof static, high\u00adperforming languages, while PHP is representative of the much worse performing scripting \nlanguages1, it is worth pointing out the main differences between the two lan\u00adguages. After describing \nthese differences in Section 2.1, Section 2.2 brie.y introduces the approach used in PHP s standard implementation. \nThis brief overview provides key insights into the performancegap between PHP and C++. 2.1 Comparison \nbetween PHP and C++ Table1 summarizes thekeylanguage features that are more general in PHP than in C++. \nIn general, these PHP features incur signi.cant runtime costs, and their more restricted forms in C++ \nenable more ef.cient execution. Below, we brie.y discuss and illustrate each of these features. This \ndiscussion not only gives insights into the performancegap between the two languages, but it also demonstrates \nthe biggest challenges that HipHopfaces to translate PHP code into C++. 1The performance gap is 36.8\u00d7 \nfor measured benchmarks using Zend PHP [22].  Feature PHP C++ types function and class name binding \ndynamic name resolution dynamic symbol inspection re.ection dynamic code evaluation (eval) dynamic dynamic \nyes yes yes yes static static no no no no Table 1. Key language features that are richer in PHP than \nin C++ 2.1.1 DynamicTyping Being dynamically typed, PHP allows variables to hold val\u00adues from different \ntypes during the execution.For example, $x takes both string and integer values in the following code: \nfunction foo($x) { echo \"foo: \" . $x . \"\\n\"; } foo(\"Hello\"); // prints: \"foo: Hello\" foo(10); // \nprints: \"foo: 10\" This is fundamentally different from statically typed lan\u00adguages like C++, where the \nprogrammer has to declare the types of variables, which the compiler can then rely on. 2.1.2 Dynamic \nName Binding In PHP, the names of functions and classes are only bound to concrete implementations during \nruntime. For example, consider the following PHP code: if ($cond) { function foo($x) { return $x + 1; \n} } else { function foo($x) { return $x -1; } } $y = foo($x); If $cond is true, function foo is \nde.ned per the .rst declara\u00adtion and $y gets the value of $x + 1. Otherwise, the second de.nition of \nfoo is used and $y gets the value of $x -1. Note that, however, PHP does not allow functions and classes \nto be redeclared during execution. 2.1.3 Dynamic Name Resolution In PHP, the names of variables, properties, \nfunctions, and classes may reside in variables and may be dynamically created. Consider the following \nexample: $a = f ; $b = c ; $c = oo ; $func = $a . $$b; $func(); $obj = new $c; This code invokes function \nfoo in the .fth line. Notice the $$ in front of b: $b .rst evaluates to c, and then $c evaluates to oo. \nIn the last statement, this example creates an object of class oo. The following example illustrates \ndynamic properties: class C { public $declProp = 1; } $obj = new C; $obj->dynProp = 2; echo $obj->declProp \n. \"\\n\"; echo $obj->dynProp . \"\\n\"; Although property dynProp is not declared in class C, this program \nis valid and prints out 1 and 2. 2.1.4 Dynamic Symbol Inspection In PHP, programs can make runtime queries \nto check whether or not functions or classes have been declared.For instance, code like the following \nis valid: if (function_exists( foo )) { ... } if (class_exists($c)) { ... } The ability to make \nsuch queries is intrinsic to dynamic languages, while static languages typically assume all the program \nis seen before it is executed. 2.1.5 Re.ection PHP has native support for re.ection, which enables query\u00ading \nvarious properties about classes, methods, functions, and more. However, C++ does not have native support \nfor re.ec\u00adtion. Notice that the lack of re.ection is speci.c to C++ and not a general limitation of static \nlanguages.  2.1.6 Dynamic Code Evaluation Like other scripting languages, PHP supports evaluating arbitrary \nstrings as PHP code. In PHP, this is supported through calls to the eval built-in function. While dynamic \ncode evaluation is simple to support in purely interpreted languages, its support in static languages \nwould be much more complex and thus is not normally provided. 2.2 Standard PHP Implementation In order \nto support PHP s dynamic features such as those de\u00adscribed in the previous section, PHP s standard implementa\u00adtion \n(Zend) is an interpreter [25]. The choice of an interpreter is not particular to PHP, as it is also the \nmost common ap\u00adproach used to implement other dynamic languages like Perl, Python, and Ruby. In this \nsection, we give a brief overview of how the Zend interpreter works, which provides some in\u00adsights into \nits main sources of inef.ciency. Zend is a bytecode interpreter, meaning that it uses a lower-level program \nrepresentation the Zend bytecode.  This is in contrast to AST (abstract syntax tree) walker inter\u00adpreters, \nwhich interpret a program while traversing its AST. The .rst time a .le is invoked, Zend parses it and \ntranslates it into bytecode. Zend then interprets bytecode instructions one at a time. In its highest \nperforming setup, Zend uses a bytecode cache (e.g. APC [1]), which avoids repeatedly parsing the program \nand translating it to bytecode. As with other dynamic languages, Zend discovers and loads various program \ncomponents during execution as source .les are included. This feature is known as dynamic loading. The \nprogram components, including classes, func\u00adtions,variables,and constants,arekeptinvariouslookupta\u00adbles. \nDynamic loading is particularly expensive for classes, which require composing class methods, properties, \nand constants along with those from parent classes and traits. While composing classes, Zend also needs \nto perform a number of semantic checks. For instance, it needs to check if method overrides are valid, \nand if all interface and abstract base-class methods are implemented by concrete classes. During execution, \neach time the interpreter needs to ac\u00adcess a given symbol, it uses the symbol s name to consult the lookup \ntables. This incurs runtime costs referred to as dynamic lookups. For example, consider the code in Fig\u00adure \n1. The execution of the echo statement incurs one con\u00adstant lookup(confName)and one function lookup(year), \nin addition to one constant lookup(firstYear)and one vari\u00adable lookup($edition)in function year. Although \nsome of these dynamic lookups can be eliminated through byte\u00adcode optimizations, in practice these optimizations \nhave re\u00adsulted in very small speedups (1-2%) [12]. In addition to the costs of dynamic loading and lookups, \nanother major overhead in Zend comes from dynamic typ\u00ading. Since variables can contain values of different \ntypes during execution, they are kept in generic, boxed values called z-values. The Zend bytecode instructions \nare mostly untyped and, while interpreting each bytecode instruction, Zend checks the types of operands \nin order to perform the appropriate actions. For example, the ADD bytecode .rst checks if the operands \nare numbers and, if not, attempts to convert them according to a set of type-speci.c rules. The mere \ntype check itself amounts to a very signi.cant over\u00adhead for the common case of adding two integers. \n3. The HipHopApproach Historically, there has been a rough separation between static and dynamic languages. \nThis categorization is based mostly on whether the languages are statically or dy\u00adnamically typed, but \nit also encompasses other languages features such as those listed inTable 1. While dynamic lan\u00adguages \nprovide higher levels of abstraction and thus tend to increase productivity, static languages are commonly \nused when performance is important. In fact, the categorization between static and dynamic languages \nis usually aligned with how the language is implemented. Static languages are usually statically compiled, \nwhich signi.cantly helps achieving high performance. In contrast, dynamic languages are generally interpreted, \nwhich helps supporting their dy\u00adnamic featuresbut signi.cantly affects performance. HipHop breaks this \nstandard practice and implements PHP via static compilation. With this approach, HipHop brings high performance \nto a typical scripting language. In Section 3.1, we give an overview of HipHop s ap\u00adproach and discuss \nhow it addresses the main PHP inef.cien\u00adcies. After that, Section 3.2 presents the high-level design \nof HipHop. Finally, Section 3.3 describes the techniques that HipHop uses to address the challenges imposed \nby PHP s dynamic nature. 3.1 Overview Being a static compiler, HipHop is fundamentally different from \nPHP s standard implementation. This key difference has several implications. First, it requires all the \nsource code to be known a priori. For server-side applications, where PHP is mostly used, we believe \nthis is a small imposition. Also, knowing all the source code in advance enables whole\u00adprogram analyses \nthat can signi.cantly boost performance. Second, most but not all PHP features are supported by HipHop. \nMost notably, HipHop does not support dynamic code evaluation (eval). Support for eval is theoretically \npossible in HipHop by invoking an interpreter. However, we opted not to implement that because the use \nof eval exposes serious security problems and is therefore discouraged [15, 18]. For this same reason, \nHipHop does not support PHP s create function() and preg replace() with /e . Be\u00adsides eval, HipHop does \nnot support automatic promotion from integer to .oating-point numbers in case of over.ow. The decision \nnot to support this PHP feature was made in the interest of performance. Third, HipHop effectively an\u00adalyzes, \ncompiles, and loads all symbols before execution starts. Although this differs from original PHP semantics, \nwhich only hoists (i.e. pre-loads) symbol de.nition under certain ill-de.ned rules, we have found that \nHipHop s se\u00admantics is easier to reason about and more often matches the programmer s intent. Finally, \nstatic compilation incurs a signi.cant cost to rebuild large systems even after small code changes, which \ncan dramatically reduce programmer productivity. To address that, one can combine the use of HipHop for \nbuilding production code with the use of inter\u00adpreters for code development. This is the setup we have \nbeen successfully using atFacebook. Although HipHop s approach faces a number of chal\u00adlenges to support \ndynamic language features (discussed in Section 3.3), it directly addresses the three main PHP inef\u00ad.ciencies \ndiscussed in Section 2.2. Below, we explain how static compilation addresses each of these overheads. \nDynamic Loading. By compiling the entire program in ad\u00advance, HipHop can reduce most of the overhead \nof dynami\u00adcally loading classes, functions, and variables. This not only  Compiler Phase Role 1. Parsing \ngenerates AST 2. Program analysis collects symbols and their dependencies 3. Pre-optimizer performs type-independent \noptimizations 4. Type inference infers primitive types of expressions 5. Post-optimizer performs type-dependent \noptimizations 6. Code generation outputs C++ code Table 2. HipHop compiler phases enables classes to \nbe composed statically,but it also enables creating various lookup tables for functions, classes, and \nvariables during compilation instead of execution time. For the cases where PHP s dynamic-loading semantics \nmatter, we have designed a set of techniques to provide that seman\u00adtics (see Section 3.3),but which incur \nruntime costs.Overall, this combination of techniques allows HipHop to eliminate overheads in the common \ncase while still supporting PHP semantics. Dynamic Lookups. Static compilation also eliminates most of \nthe overhead associated with dynamic lookups. In the common case, the compiler can statically resolve \nsymbol names and emit code that directly accesses program com\u00adponents (e.g. variables, functions). This \nenables the genera\u00adtion of ef.cient binary code where the addresses of compo\u00adnents are used, thus saving \nexpensive dynamic table lookups. For the rare cases that the compiler cannot statically resolve symbol \nnames, HipHop employs less ef.cient techniques based on lookup tables (see Section 3.3). DynamicTyping. \nAs a static compiler, HipHop can perform more extensive program analyses than is practical at runtime. \nThis enables HipHop to do aggressive type inference. For variables and expressions that HipHop is able \nto infer primi\u00adtive types, this information is used to produce ef.cient code that bypasses dynamic type \nchecking.  3.2 High-level Compiler Design HipHop is a source-to-source compiler, and it uses an AST \nas the primary program representation throughout its phases. HipHop has six main compilation phases, \nlisted in Table 2. Below, we brie.y describe HipHop s steps at each of these phases, and illustrate its \noperationin Figure3 for theexam\u00adple from Figure 1. Phase1 Parsing The parser reads in the PHP source \n.les and creates corre\u00adsponding ASTs, which are then used by subsequent phases. Figure 3(c) illustrates \nthe AST constructed for the PHP code in Figure 3(a). Phase2 Program Analysis This phase traverses the \nASTs and collects information about all symbols, including classes, functions, variables, constants and \nmore. With this information, HipHop can determine how many symbols are declared with the same Figure \n2. HipHop type hierarchy name, which then enables it to generate more ef.cient code for uniquely de.ned \nsymbols. The information collected for program-de.ned constants is shown at the lower left cor\u00adner of \nFigure 3(c). Besides collecting this information, this phase also creates a dependence graph between \nprogram symbols. This dependence graph is used by later phases for various purposes and also enables \ntheir parallelization. Phase3 Pre-optimizer This phase performs a number of optimizations that do not \nrequire type information. These optimizations include: constant inlining and folding; logical-expression \nsimpli.\u00adcation; dead-code elimination; copy propagation; inlining of small user-de.ned functions, and \nalso built-in functions like class exists() and defined() that can be stati\u00adcally determined; string \nconcatenation optimizations. Given that PHP scripts generally manipulate a lot of strings, string concatenation \nis very common and worth special attention. PHP s double-quoted strings may contain variables that need \nto be replaced. The pre-optimizer breaks these strings into cascaded calls to concat. In addition, na\u00a8ive \npairwise concate\u00adnation is inef.cient because it requires memory allocation and data copying at each \nstep. To mitigate that, the pre\u00adoptimizer replaces cascaded pairwise concatenations with a call to an \ninternal concat() function that performs a series of concatenations at once. Figure 3(d) shows the AST \nafter it is processed by the pre-optimizer. In function year, the value of constant firstYear is replaced \nand the result of the subtraction is folded. In the echo statement, the call to function year is inlined, \nwhich allows the addition 1985 + 27 to be folded. Finally, all the operands in the resulting chain of \nstring con\u00adcatenations become known constants, so the resulting string is concatenated at this phase. \nPhase4 Type Inference This phase attempts to determine the types of various sym\u00adbols, and it plays a \ncentral role in HipHop. The more types HipHop can statically infer, the fewer checks need to be per\u00adformed \nat runtime. HipHop uses an adaptation of the tradi\u00adtional Damas-Milner constraint-based algorithm [4] \nto infer the types of constants, variables, function parameters and return values, and other expressions. \nThe HipHop built-in types are illustrated in the type hierarchy in Figure 2. Vari\u00adant is the most general \ntype, to which all symbols belong before type inference. For symbols whose types can be in\u00ad  01) <?php \n02) 03) define(\"confName\", \"OOPSLA\"); 04) define(\"firstYear\", 1986); 05) 06) function year($edition) \n{ 07) return firstYear -1 + $edition; 08) } 09) 10) echo \"Hello \" . confName . \" \" . year(27); (a) PHP \nCode (hello-oopsla.php) 01) const StaticString k_confName(\"OOPSLA\"); 02) const int64 k_firstYear = 1986LL; \n03) 04) /* SRC: hello-oopsla.php line 6 */ 05) Numeric f_year(const Variant&#38; v_edition) { 06) return \n(1985LL + v_edition); 07) } 08) Variant pm_php$hello_oopsla_php(bool incOnce, 09) LVariableTable* variables, \n10) Globals *globals) { 11) echo(\"Hello OOPSLA 2012\"); 12) return true; 13) } (b) C++ Code  (c) Initial \nAST generated by the parser and constants collected by the analysis phase S Figure 3. Example of HipHop \ncompilation phases. (a) input PHP code; (b) sketch of the generated C++ code; (c) initial AST; (d) AST \nafter pre-optimizer and type-inference phases. ferred, HipHop uses the speci.c inferred types, for which \nthe Phase5 Post-optimizer runtime system containsfast, specialized implementations. After typeinference, \nHipHop performsa coupleof optimiza- In Figure 3(d), the AST nodes are annotated with the tions that bene.t \nfrom type information, including algebraic types inferred by HipHop. For example, in function year, and \nlogical simpli.cations. In addition, another round of although one of the operands of the addition has \ntype Vari-some pre-optimizer s optimizations (e.g. string concatena\u00adant, the compiler infers that the \nresult of the addition must be tion, dead-code elimination) is performed to handle oppor\u00adof Numeric type, \nand so does the return value of the function. tunities exposed by type-speci.c optimizations. In the \nexam\u00adple from Figure 3(d), the code has been fully optimized by the pre-optimizer, so there are no further \nopportunities left for the post-optimizer. Phase6 Code Generation The last step of HipHop is totraverse \nthe AST and emit C++ code. The choice of C++ was made due to a few factors. First, C++ is known as one \nof the fastest languages and it has highly optimized compilers. HipHop has been using GCC [9] to compile \nthe generated code, thus leveraging the substantial amount of optimizations that GCC implements. Second, \nC++ is a very .exible language, which makes it a good target for auto-generated code. Finally, C++ shares \nmany similarities with PHP, including object orientation, whichfacilitate the translation process. HipHop \ngenerates four groups of C++ .les: 1. Class Header Files: Each PHP class has one C++ header .le, which \nis included by other .les that use that particu\u00adlar PHP class. 2. PHP-File Header Files: Each PHP .le \nhas one corre\u00adsponding C++ header .le with the prototype of functions that it de.nes. A PHP include statement \nis translated into a C++ include for the corresponding C++ header .le. This effectively makes the functions \nde.ned in that .le visible to the other .les that include it. 3. Implementation Files: These .les have \nimplementation of converted PHP functions, class methods, and top\u00adlevel statements (i.e. statements outside \nany function or method). Each of these C++ .les is generated from one or more PHP .les. 4. System Files: \nThese .les do not have corresponding PHP .les and they are generated to store system-level func\u00adtions \nand global lookup tables (discussed in Section 3.3).  Given the similarities between C++ and PHP, most \ncon\u00adstructs can be easily translated into C++ from the AST. Some notable exceptions include: 1. Some \nstatements need to have a declaration added to header .les as discussed above. These statements include \nfunctions, methods, classes, interfaces, traits, class vari\u00adables and constants. 2. Top-level statements \nare wrapped into what we call a pseudo-main function. A PHP include statement in\u00adcluding a .le with top-level \nstatements will also result in a C++ call to its pseudo-main function to execute these statements. 3. \nSome expressions have dynamic evaluations that do not have a C++ counterpart. These include dynamic variable, \nfunction, and class names as illustrated in Section 2.1.3. How HipHop supports these features is discussed \nin Sec\u00adtion 3.3 below.  Figure 3(b) presents a sketch of the C++ .le gener\u00adated for the PHP script from \nFigure 3(a). The top-level echo statement is wrapped into the pseudo-main function pm php$hello oopsla \nphp. The echo function is pro\u00advided by the HipHop runtime system.  3.3 Supporting PHP Semantics In this \nsection, we describe how HipHop handles some of the most dynamic and challenging PHP features discussed \nin Section 2.1. 3.3.1 DynamicTyping Support for dynamic typing is implemented with a combina\u00adtion of \ntype inference (see Section 3.2) and a runtime system that implements the PHP operators for the variant \ntype (at minimum) and other common types (for performance). 3.3.2 Dynamic SymbolTables In order to support \ndynamic name binding (Section 2.1.2) and resolution (Section 2.1.3), HipHopkeeps track of global state \nduring runtime in a global symbol table (GST). This table includes entries for: Global variables;  \nDynamically declared constants;  Static variables inside functions, methods, and classes;  Whether \na .le has been included or not;  Redeclared functions and classes.  For functions and classes that \nare de.ned multiple times in the PHP code, called redeclared, HipHop generates all theirversions (with \nunique names) and the GSTkeeps track of which version is dynamically included. In scopes with symbol \nnames that cannot be resolved statically (e.g. those in Section 2.1.3), HipHop also generates a local \nsymbol table (LST). All variable accesses within such scopes then need to go through a helper that looks \nup the symbol in LST and GST. The LST is also used in the presence of PHP extract and compact functions.2 \nFinally, to support dynamic properties (see Section 2.1.3), HipHop keeps inside the objects a property \nsymbol ta\u00adble (PST) that maps property names to values. The PST is used when accessing dynamic properties. \nWith this approach based on dynamic symbol tables, HipHop supports dynamic name binding and resolution \nin PHP (at a performance cost) while still leveraging static binding to generate ef.cient code for the \nmost common cases.  3.3.3 InvocationTables HipHop uses a few invocation tables for invoking functions, \ninstantiating objects, or including source .les whose names cannot be resolved statically. In these situations, \nHipHop produces code that does a runtime lookup into the appro\u00adpriate table, which is very similar to \nhow Zend processes 2PHP s extract function imports the variables from a given array into the current \nlocal symbol table, while compact does the opposite.  function calls. HipHop s invocation tables map \nnames of functions, classes, or .les to the corresponding implementa\u00adtion. These invocation tables, which \ncontain all known func\u00adtions, classes, and .les, is completely generated at compila\u00adtion time, which \nis possible due to HipHop s whole-program analysis.  3.3.4 Volatile Symbols In HipHop, we call the PHP \nsymbols whose presence af\u00adfect the execution volatile symbols. Section 2.1.4 illustrates how a program \ncan check for the presence of functions and classes. In PHP s interpreter-based reference implementa\u00adtion, \nthe symbols are only present after they are dynami\u00adcally loaded, which occurs when the .les containing \ntheir de.nitions are included.With HipHop, all symbols are nat\u00adurally loaded statically, before the program \nstarts execution. In the cases where the dynamic-loading semantics is rele\u00advant, HipHop provides that \nillusion in the following way. For each symbol that requires this behavior, HipHop keeps a .ag that tells \nwhether the symbols has been loaded or not. This .ag is initially unset, and HipHop emits code to set \nit at the program point where the symbol is de\u00adclared. The real dif.culty with this approach is to deter\u00admine \nwhich symbols are volatile, and thus need to be tracked by this mechanism. To address this problem, HipHop \nuses a few heuristics (e.g., foo is marked volatile if it appears in class exists( foo )). However, precisely \ndetermin\u00ading whether a symbol is volatile may ultimately depend on program inputs and dynamic execution \n.ow, and thus it is an undecidable problem. Therefore, besides its heuristics, HipHop also leverages \na user-provided list of symbols that need to be treated as volatile.  3.3.5 Re.ection Contrary to PHP, \nC++ does not have any support for re.ec\u00adtion. To support PHP s re.ection APIs, HipHop statically generates \na set of tables containing the necessary data, in\u00adcluding: class information, function prototypes, and \nsource location information. The source location information for functions also enables generating a \nPHP-level stack trace from the C++ frames on the stack. 4. Evaluation This section evaluates HipHop and \ncompares it with other PHP execution engines. The evaluation was performed on 64-bit Linux servers based \non Intel R &#38;#169; Xeon processors. We used the latest release of HipHop at the time of this writing, \nand Zend PHP version 5.3.10, which was released in Febru\u00adary 2012. We present experiments running both \nstandard bench\u00admarks and the Facebook web site. The benchmarks include the widely used bench.php provided \nby Zend, and also the set of PHP applications from the computer language bench\u00admarks [22]. 4.1 Standard \nBenchmarks Figure 4 presents the performance comparison for our set of benchmarks. The .rst portion of \nthese programs (up to strcat)is part of Zend sbench.php, while the remaining ones are from the computer \nlanguage benchmarks [22]. The bars in Figure 4 are the execution times relative to Zend. HipHop is faster \nthan Zend in all benchmarks. The maxi\u00admum speedup is on simpleudcall, for which HipHop is 260\u00d7 faster \nthan Zend. This program simply has a loop call\u00ading an empty function, which HipHop inlines to eliminate \nthe call overhead. The geometric mean shows that HipHop is 5.6\u00d7 faster than Zend for this set of benchmarks. \nIn addition to Zend and HipHop, Figure 4 also presents results for the HHVM interpreter (HHVMi) [7]. \nHHVMi is a PHP bytecode interpreter recently developed atFacebook. In principle, HHVMi is similar to \nZend (also a bytecode interpreter),butit uses the HipHopextensions, runtime, and web server. Figure4shows \nthat HHVMiis onaverage 17.9% slower than Zend and 6.3\u00d7 slower than HipHop. Notice that none of these \nbenchmarks use the PHP fea\u00adtures unsupported by HipHop (described in Section 3.1). Thisfact con.rms the \nassumption made in HipHop that such features are uncommon (and sometimes even insecure).  4.2 FacebookWorkloads \nIn this section, we present experimental results of running the Facebook web site with production traf.c, \ni.e. serving real user requests. Facebook currently uses HipHop to compile all its PHP code base. Most \nof HipHop s compilation phases have been parallelized, which enables HipHop to compile Facebook s huge \ncode base from PHP into C++ in 3.5 minutes using a single 12-core server. The generated C++ code, which \nis about 5\u00d7 bigger than the original PHP as measured in lines of code, is then compiled in parallel using \nGCC and distcc ona clusterof servers. This step takes8 minutes. The .nal binary is linked using Google \ns Gold linker, and it is distributed to allFacebook web servers using bittorrent. Unfortunately, due \nto new language extensions in HipHop that are widely used in the Facebook code base (e.g. richer type \nhints and yield generators), Zend PHP has been unable to run theFacebook web site since August 2010. \nGiven this limitation, we present two sets of experiments to give an idea of HipHop s current bene.ts \nover Zend running Face\u00adbook production traf.c. The .rst set of experiments is based on historical improvements \nmade to HipHop since August 2010, and the second one uses HHVMi. 4.2.1 Tracking HipHop s Historical \nImprovements In these experiments, we measured the initial performance improvement of HipHop over Zend \nwhen Zend was last able to run the Facebook web site. From that point, we kept track of performance improvements \nmade to HipHop over itself. For that, a baseline HipHop branch was created Figure 4. Performance comparison \nof Zend, HHVMi, and HipHop using standard PHP and computer language benchmarks  and updated with the \nminimal changes necessary to keep it running the site. These updates included support for new 2.5 languageextensions,but \nno performance enhancements. In August 2010, we last compared the performance of HipHop and Zend running \nFacebook production traf.c. At that time, theversionof Zend usedwas 5.1.3.For this com\u00adparison, two clusters \nof servers were used, one with HipHop and another with Zend, and load balancers ensured that the Relative \nThroughput 2 1.5 1 two sets received equal traf.c. The average CPU time serv-0.5 ing requests in each \ncluster was computed across a large pe\u00ad riod of time. On average, HipHop completed web requests 0 2.5\u00d7 \nfaster than Zend. Since HipHop was much faster, the servers in its cluster were underutilized. We also \ncompared the throughput of the clusters when the servers were fully Figure 5. HipHop throughput over \ntime, running Face\u00adloaded. To do so, we con.gured the load balancers to pro\u00adbook production traf.c. The \nbaseline is the throughput of vide enough traf.c to keep the CPUs in both clusters 100% HipHop s version \nfrom August 2010, which is when Zend utilized. The results of this experiment, measured in number last \nranFacebook. of requests-per-second (RPS), demonstrated that the HipHop cluster achieve throughput 2.5\u00d7 \nhigher than Zend. On the left side of Figure 5, this throughput data is plotted relative another 2.3\u00d7. \nAlthough we cannot directly compare with to HipHop. Zend running the currentFacebook web site, these \ndata sug-Figure5also plots the throughput improvements made to gest that HipHop s throughput is now 5.8 \n(2.5 \u00d7 2.3) times HipHop after August 2010. This comparison was performed higher than what Zend 5.1.3 \nwould achieve. These improve\u00adusing the same methodology described above, except that ments resulted from \nadditional tuning, static analyses, and the Zend cluster was changed to use the baseline HipHop optimizations \ndescribed in Section3 that were added in this branch instead. The load balancers were again set to keep \nperiod. the servers in each cluster fully utilized, so that we could Given the nature of theFacebook \napplication, which pro\u00admeasure the maximum throughput achieved by each server. cesses huge data sets, \none could expect Facebook s web Overall, HipHop s throughput over this period improved by servers to \nbe I/O bound. However, given the great amount ofwork done on data fetching and caching,Facebook s web \nservers are actually CPU bound. This is the reason why HipHop greatly impacts the performance ofFacebook \ns web servers,ina similarfashiontohowit alsoimprovedtheper\u00adformance of benchmark applications.  4.2.2 \nHipHop vs. HHVMi As another experiment, we compared the performance of HipHop against HHVMi [7], which \nis a PHP bytecode in\u00adterpreter akin to Zend. Although HHVMi s performance is slightly lower than Zend \non the benchmarks evaluated in Section 4.1, a comparison between HipHop and HHVMi ef\u00adfectively isolates \nthe core differences between the two dif\u00adferent PHP execution engines. This is because HHVMi uses the \nsame HipHop extensions, runtime, and web server. Following the same methodology described in the previ\u00adous \nsection, we ran HHVMi and HipHop in production, serv\u00ading normalFacebook web requests. Thisexperiment \ndemon\u00adstrated that, on average, HipHop served web requests 5.5\u00d7 faster than HHVMi. Overall, our evaluation \ndemonstrates that HipHop is more than 5\u00d7 faster than other PHP implementations. This has been con.rmed \nthrough extensive experiments both using standard PHP benchmarks and running the Facebook web site in \nproduction. Our .ndings are also aligned with what has been reported by another company that converted \nfrom Zend to HipHop and published an experimental evalua\u00adtion [11]. 5. RelatedWork The continuous expansion \nof the Internet and adoption of PHP for server-side development has motivated a number of efforts to \nimprove PHP performance.We brie.y describe various of these efforts in this section. One approach to \nimprove the performance of PHP has been to leverage Java Virtual Machines (JVM) by translat\u00ading PHP into \nJava bytecode [16, 17, 21].Tatsubori et al. [21] have pursued this approach by retro.tting PHP into IBM \ns P9 JVM. Compared to Zend, their evaluation shows a 20\u00ad30% improvement on SPECweb2005, and 2.5\u00d7-9.5\u00d7 \nim\u00adprovement on micro-benchmarks. A similar approach has been followed by Quercus [17] and Project Zero \n[16]. Quer\u00adcus s reported performance is similar to Zend with bytecode caching (APC) [1, 17]. For Project \nZero, performance has not been reported and the emphasis is on the interoperability between PHP and Java. \nAnalogous to the JVM-based efforts above, Phalanger [2] compiles PHP to Microsoft CIL bytecode. Here \nagain, Pha\u00adlanger s emphasis has been more on interoperability than performance. Phalanger s recently \nreported performance is on par with Zend PHP using bytecode caching [13]. Another JIT-based project for \nPHP is the HappyJIT [10], which is based on PyPy [19]. On bench.php and the com\u00adputer language benchmarks, \nHappyJIT s performance com\u00adpared to Zendvaries from4\u00d7 slower to8\u00d7 faster. Most closely to HipHop s approach, \na couple of other projects have compiled PHP to C, including phc [3] and Roadsend [20]. Unlike HipHop, \nphc makes extensive calls to the Zend runtime and does not exploit manyof the oppor\u00adtunitiesavailable \nthrough static compilation.Forexample,it does not leverage static binding and, instead, generates code \nthat performs extensive dynamic lookups. Furthermore, phc does not perform static analysis and optimizations, \nand its bene.ts over Zend come mostly from avoiding the dispatch overheads in the interpreter loop. Its \nreported speedup over Zend on bench.php is 1.53\u00d7 [3]. Roadsend followed a sim\u00adilar approach,but it is \nmore simplistic and does not support various PHP extensions. Recent evaluations show that Road\u00adsend is \nnot able to run all bench.php and that its perfor\u00admance is similar to Zend [10]. Lemos [12] presents \na performance comparison among HipHop, phc, and Zend running bench.php. Although this evaluation did \nnot use the latest HipHop release, it still found HipHoptobethefastest enginebyfar,being3\u00d7 faster than \nthe second one(phc). 6. Conclusion Although scripting languages have considerably increased in popularity \nover the past decades, their performance is still a main blocker for building large, CPU-intensive systems. \nThis paper described how the HipHop compiler addresses the performance problem of a typical and widely \nused script\u00ading language, PHP. The key for achieving performance in HipHop is the use of static compilation, \nto generate very ef.cient code whenever possible, combined with a set of techniques to support various \ninherently dynamic PHP fea\u00adtures. Overall, our thorough experimental evaluation demon\u00adstrated that HipHop \nis on average 5.5\u00d7 more ef.cient than traditional PHP execution engines based on interpreters. The drasticef.ciencygainsprovidedby \nHipHophave resultedin its adoption not only inside Facebook but also in a number of other Internet companies. \nFinally, we believe that the ap\u00adproach and techniques used to make HipHop a success can also be applied \nto other scripting languages. As such, we expect HipHop to have great impact in improving the per\u00adformance \nof scripting languages in general, and thus help expand their uses. Acknowledgments For their support, \nfeedback on the HipHop compiler project, and/or feedback on earlier drafts of this paper, we thank: Ali-Reza \nAdl-Tabatabai, Aditya Agarwal, Albert Bergman, Er\u00advan Darnell, Jordan DeLong, Steven Grimm, Andrei Home\u00adscu, \nHarry Li, Scott MacFiggen, David Mortenson, Mike Paleczny, JayParikh, GirishPatangay, Daniel Pepper, \nDavid Reiss, Sonya Rikhtverchik, JeffRothschild,Paul Saab, Mike Schroepfer, and the rest of the HipHop \nteam at Facebook.  We also thank the anonymous reviewers for their valuable feedback. References [1] \nAPC: Alternative PHP Cache. Web site: http://php.net/manual/en/book.apc.php. [2] J. Benda, T. Matousek, \nand L. Prosek. Phalanger: Compiling and running PHP applications on the Microsoft .NET plat\u00adform. In \nProceedings on the 4th International Conference on .NET Technologies, pages 11 20, 2006. [3] P. Biggar, \nE. de Vries, and D. Gregg. A practical solution for scripting language compilers. In Proceedings of the \nACM Symposium on Applied Computing, pages 1916 1923, 2009. [4] L. Damas and R. Milner. Principal type-schemes \nfor func\u00adtional programs. In Proceedings of the ACM SIGPLAN-SIGACT Symposium on Principles of Programming \nLan\u00adguages, pages 207 212, 1982. [5] S. Ducasse, O. Nierstrasz, N. Sch\u00a8 arli, R. Wuyts, and A. P. Black. \nTraits: A mechanism for .ne-grained reuse. ACM Trans. Program. Lang. Syst., 28:331 388, March 2006. [6] \nFacebook, Inc. The HipHop compiler for PHP. Available at: https://github.com/facebook/hiphop-php/wiki/. \n[7] Facebook, Inc. The HipHop Virtual Machine. Web site: https://www.facebook.com/note.php? note id=10150415177928920, \nDecember 2011. [8] A. Gal, B. Eich, M. Shaver, D. Anderson, D. Mandelin, M. R. Haghighat, B. Kaplan, \nG. Hoare, B. Zbarsky, J. Oren\u00addorff, J. Ruderman, E. W. Smith, R. Reitmaier, M. Bebenita, M. Chang, and \nM. Franz. Trace-based just-in-time type spe\u00adcialization for dynamic languages. In Proceedings of the \nACM SIGPLAN Conference on Programming Language Design and Implementation, pages 465 478, 2009. [9] GCC. \nGnu Compiler Collection. Web site: http://gcc.gnu.org. [10]A. HomescuandA.S\u00b8uhan. HappyJIT:a tracingJIT \ncompiler for PHP. In Proceedings of the 7th Symposium on Dynamic Languages, pages 25 36, 2011. [11] Hyves, \nInc. HipHop for PHP at Hyves. Web site: http://hyvesblogonproductdevelopment.blogspot.com/ 2011/10/hiphop-for-php-at-hyves.html, \nOctober 2011. [12] M. Lemos. PHP compiler performance. Available at: http://www.phpclasses.org/blog/post/117-PHP-compiler\u00adperformance.html, \nFebruary 2010. [13] J. Misek. Improved wordpress performance with phalanger. Web site: http://www.php-compiler.net/blog/2011/phalanger\u00adwordpress-performance, \n2011. [14] J. K.Ousterhout.Scripting: Higher-level programming for the 21st century. Computer, 31:23 \n30, March 1998. [15] PHP eval. Web site: http://php.net/manual/en/function.eval.php. [16] Project Zero. \nWeb site: https://www.projectzero.org/php/. [17] Quercus: PHP in Java. Web site: http://www.caucho.com/resin-3.0/quercus/. \n[18] G. Richards,C. Hammer,B. Burg, andJ.Vitek. Theeval that men do: A large-scale study of the use of \neval in JavaScript applications. In Proceedings of the 25th European Conference on Object-oriented Programming, \npages 52 78, 2011. [19] A. Rigo and S. Pedroni. PyPy s approach to virtual ma\u00adchine construction. In \nProceedings of the 21st ACM SIGPLAN Symposium on Object-oriented Programming Systems, Lan\u00adguages, and \nApplications, pages 944 953, 2006. [20] Roadsend compiler. Web site: http://www.roadsend.com. [21] M. \nTatsubori, A. Tozawa, T. Suzumura, S. Trent, and T. On\u00adodera. Evaluation of a just-in-time compiler retro.tted \nfor PHP. In Proceedings of the 6th ACM SIGPLAN/SIGOPS In\u00adternational Conference on Virtual Execution \nEnvironments, pages 121 132, 2010. [22] The Computer Language Benchmarks Game. Web site: http://shootout.alioth.debian.org/. \n[23] S. Warner and J. Worley. SPECweb2005 in the real world: Using IIS and PHP. In Proceedings of SPEC \nBenchmark Workshop, 2008. [24] K.Williams,J. McCandless, andD. Gregg. Dynamic interpre\u00adtation for dynamic \nscripting languages. In Proceedings of the 8th IEEE/ACM International Symposium on Code Generation and \nOptimization, pages 278 287, 2010. [25] Zend PHP. Web site: http://php.net.     \n\t\t\t", "proc_id": "2384616", "abstract": "<p>Scripting languages are widely used to quickly accomplish a variety of tasks because of the high productivity they enable. Among other reasons, this increased productivity results from a combination of extensive libraries, fast development cycle, dynamic typing, and polymorphism. The dynamic features of scripting languages are traditionally associated with interpreters, which is the approach used to implement most scripting languages. Although easy to implement, interpreters are generally slow, which makes scripting languages prohibitive for implementing large, CPU-intensive applications. This efficiency problem is particularly important for PHP given that it is the most commonly used language for server-side web development. This paper presents the design, implementation, and an evaluation of the HipHop compiler for PHP. HipHop goes against the standard practice and implements a very dynamic language through static compilation. After describing the most challenging PHP features to support through static compilation, this paper presents HipHop's design and techniques that support almost all PHP features. We then present a thorough evaluation of HipHop running both standard benchmarks and the Facebook web site. Overall, our experiments demonstrate that HipHop is about 5.5x faster than standard, interpreted PHP engines. As a result, HipHop has reduced the number of servers needed to run Facebook and other web sites by a factor between 4 and 6, thus drastically cutting operating costs.</p>", "authors": [{"name": "Haiping Zhao", "author_profile_id": "81548578656", "affiliation": "Facebook, Menlo Park, CA, USA", "person_id": "P3856131", "email_address": "hzhao@fb.com", "orcid_id": ""}, {"name": "Iain Proctor", "author_profile_id": "81549050056", "affiliation": "Facebook, Menlo Park, CA, USA", "person_id": "P3856134", "email_address": "iproctor@fb.com", "orcid_id": ""}, {"name": "Minghui Yang", "author_profile_id": "81549364056", "affiliation": "Facebook, Menlo Park, CA, USA", "person_id": "P3856135", "email_address": "myang@fb.com", "orcid_id": ""}, {"name": "Xin Qi", "author_profile_id": "81549069956", "affiliation": "Facebook, Menlo Park, CA, USA", "person_id": "P3856136", "email_address": "qixin@fb.com", "orcid_id": ""}, {"name": "Mark Williams", "author_profile_id": "81548719556", "affiliation": "Facebook, Menlo Park, CA, USA", "person_id": "P3856137", "email_address": "mwilliams@fb.com", "orcid_id": ""}, {"name": "Qi Gao", "author_profile_id": "81548927156", "affiliation": "Facebook, Menlo Park, CA, USA", "person_id": "P3856138", "email_address": "qigao@fb.com", "orcid_id": ""}, {"name": "Guilherme Ottoni", "author_profile_id": "81339520988", "affiliation": "Facebook, Menlo Park, CA, USA", "person_id": "P3856139", "email_address": "ottoni@fb.com", "orcid_id": ""}, {"name": "Andrew Paroski", "author_profile_id": "81549395256", "affiliation": "Facebook, Menlo Park, CA, USA", "person_id": "P3856140", "email_address": "andrewparoski@fb.com", "orcid_id": ""}, {"name": "Scott MacVicar", "author_profile_id": "81549557756", "affiliation": "Facebook, Menlo Park, CA, USA", "person_id": "P3856141", "email_address": "macvicar@fb.com", "orcid_id": ""}, {"name": "Jason Evans", "author_profile_id": "81549349556", "affiliation": "Facebook, Menlo Park, CA, USA", "person_id": "P3856132", "email_address": "je@fb.com", "orcid_id": ""}, {"name": "Stephen Tu", "author_profile_id": "81549248256", "affiliation": "MIT, Cambridge, MA, USA", "person_id": "P3856133", "email_address": "stephentu@csail.mit.edu", "orcid_id": ""}], "doi_number": "10.1145/2384616.2384658", "year": "2012", "article_id": "2384658", "conference": "OOPSLA", "title": "The HipHop compiler for PHP", "url": "http://dl.acm.org/citation.cfm?id=2384658"}