{"article_publication_date": "10-19-2012", "fulltext": "\n Bolt: On-Demand In.nite Loop Escape in Unmodi.ed Binaries Michael Kling Sasa Misailovic Michael Carbin \nMartin Rinard MIT CSAIL {mkling,misailo,mcarbin,rinard}@csail.mit.edu Abstract We present Bolt, a novel \nsystem for escaping from in.nite and long-running loops. Directed by a user, Bolt can attach to a running \nprocess and determine if the program is execut\u00ading an in.nite loop. If so, Bolt can deploy multiple strategies \nto escape the loop, restore the responsiveness of the program, and enable the program to deliver useful \noutput. Bolt operates on stripped x86 and x64 binaries, dynam\u00adically attaches and detaches to and from \nthe program as needed, and dynamically detects loops and creates program state checkpoints to enable \nexploration of di.erent escape strategies. Bolt can detect and escape from loops in o.-the\u00adshelf software, \nwithout available source code, and with no overhead in standard production use. Categories and Subject \nDescriptors D.2.5 [Testing and Debugging]: Error handling and recovery; D.2.7 [Distribu\u00adtion, Maintenance, \nand Enhancement]: Corrections Keywords Bolt, In.nite Loop, Error Recovery, Unrespon\u00adsive Program 1. Introduction \nIn.nite and long-running loops can cause applications to become unresponsive, thus preventing the application \nfrom producing useful output and causing users to lose data. 1.1 Bolt We present Bolt, a new system for \ndetecting and escaping from in.nite and long-running loops. Bolt supports an on\u00addemand usage model a \nuser can attach Bolt to a running application at any point (typically when the application be\u00adcomes unresponsive). \nBolt will then examine the execution of the application to determine if it is in an in.nite loop. Permission \nto make digital or hard copies of all or part of this work for personal or classroom use is granted without \nfee provided that copies are not made or distributed for pro.t or commercial advantage and that copies \nbear this notice and the full citation on the .rst page. To copy otherwise, to republish, to post on \nservers or to redistribute to lists, requires prior speci.c permission and/or a fee. OOPSLA 12, October \n19 26, 2012, Tucson, Arizona, USA. Copyright &#38;#169;c2012 ACM 978-1-4503-1561-6/12/10. . . $10.00 \nOnce it detects a loop, Bolt (directed by the user) tries multiple loop exit strategies to .nd a strategy \nthat enables the application to escape the loop and continue to execute suc\u00adcessfully. If one strategy \nfails to deliver acceptable continued execution, Bolt uses checkpoints to restore the application state \nand try another loop exit strategy. After the application has successfully escaped from the loop, Bolt \ndetaches from the application. To support the on-demand usage model, Bolt operates on unmodi.ed, stripped \nx86 or x64 binaries. This makes it possible for Bolt to detect and escape loops in o.-the-shelf software \nwithout available source code. To use Bolt, the user does not the need to recompile the application to \ninsert instrumentation and Bolt does not incur any overhead in standard production use. Bolt can be installed \nand deployed even after the application has entered a loop. Escaping the loop enables the application \nto continue executing and produce a result. This result may contain a part of or even all of the result \nthat a (hypothetical) correct application (without the in.nite loop) would have produced. The user can \nevaluate the e.ects of escaping the loop and can also, at his or her discretion, try several alternative \nstrategies to recover the application execution from the loop, at the end selecting the result that best \ncorresponds to his or her goals.  1.2 Bolt Work.ow Bolt consists of three components: a detector module, \nan escape module, and a checkpoint module. The Bolt detector module .rst runs a dynamic analysis to .nd \n1) the sequence of instructions that comprise one iteration of a loop and 2) the stack frame of the function \nthat contains the loop. The detector module then monitors the execution of the application to determine \nif the loop is in.nite: each time the application starts a new iteration of the loop, the detector takes \na snapshot of the current application state and compares that snapshot to the last N-1 snapshots it has \ntaken. If one of the previous snapshots matches, Bolt has detected an in.nite loop. After the detector \nmodule .nds a loop (in.nite or other\u00adwise) a user may decide to invoke the escape module to con\u00adtinue \nthe execution outside of the loop. A user may escape from any loop that he or she perceives to be unresponsive \n(regardless of whether or not the detector module recognized the loop as in.nite).  The Bolt escape \nmodule obtains (from the detector mod\u00adule) the set of top-level instructions the set of instructions \nthat are both in the loop and also in the function that contains the loop. The escape module can then \nexplore alternatives from the following two escape strategies: Jump Beyond Loop (Break): The escape \nmodule sets the program counter to point to the instruction immedi\u00adately following the top-level instruction \nwith the highest address. This instruction is outside the set of instructions that comprise the loop \nconceptually, it is the next in\u00adstruction following the loop.  Return From Enclosing Procedures (Unwind): \nThe escape module exits either the function that contains the loop or any ancestor of this function that \nis on the current call stack. Each function on the call stack gives Bolt a distinct escape alternative. \n Each escape strategy must also choose an escape instruc\u00adtion an instruction inside the loop from which \nto escape the loop. Because the state may be di.erent at di.erent es\u00adcape instructions, di.erent escape \ninstructions may produce di.erent results. Bolt is currently con.gured to escape from the jump instruction \nat the end of the loop i.e., the jump instruction with the highest address among all of the jump instructions \nin the top-level instructions. The Bolt imple\u00admentation also has the capability to escape from any other \ntop-level instruction. There is, of course, no guarantee that any speci.c escape strategy will enable \nthe application to continue to execute successfully. Bolt therefore o.ers the user the capability to \nexplore multiple di.erent escape alternatives. To provide this exploration, Bolt o.ers the option to \ncheckpoint the application s state and then automatically apply each escape strategy in turn if the user \ndoes not like how the application responds to one strategy, Bolt can roll back to the checkpoint and \ntry another strategy.  1.3 Technical Challenges Our previous work on Jolt [24] was the .rst to demonstrate \na tool capable of detecting and escaping in.nite loops at run\u00adtime. Jolt s mixed static and dynamic analysis \napproach lim\u00adited its applicability in that it forced developers to recompile their applications with \nJolt to enable loop detection and es\u00adcape. This had two negative consequences: 1) users could not apply \nthe technique on-demand (Jolt was available only for binaries precompiled to use Jolt) and 2) Jolt s \ninserted instrumentation imposed a 2%-10% overhead on the appli\u00adcation even when Jolt was not running. \nJolt also worked only for single-threaded applications. Bolt, in contrast, operates on unmodi.ed binaries, \nincurs no overhead during normal program execution, and works on both single-threaded and multithreaded \napplications. To realize Bolt s fully dynamic approach to in.nite loop detec\u00adtion and escape on stripped \nbinaries, we had to deal with the following key technical challenges: Dynamic Loop Structure Detection: \nThe .rst step in detecting an in.nite loop in a running application is to de\u00adtermine if the application \nis executing within a loop. Bolt implements a novel dynamic analysis to automatically re\u00adconstruct the \nloop structure in unmodi.ed binaries. When Bolt attaches to an application, it records the cur\u00adrent \ninstruction. Bolt designates this instruction as the pivot instruction. Bolt identi.es the loop by monitoring \nall executed instructions and tracking the sequence of function calls (via corresponding stack frames) \nbetween two subsequent executions of the pivot instruction. Note that the instructions in the loop may \nbelong to multiple functions or even dynamically loaded libraries. Bolt de\u00adtects the loop when the execution \nhits the pivot instruc\u00adtion in the same stack frame as when it .rst encountered the pivot instruction. \nThe instructions executed in be\u00adtween these two executions of the pivot instruction com\u00adprise one iteration \nof the loop.  Exploration of Multiple Escape Alternatives: In gen\u00aderal, di.erent escape strategies may \nproduce di.erent re\u00adsults for di.erent applications. Bolt therefore enables the user to explore multiple \nescape strategies which continue the execution at di.erent locations in the application. Bolt uses a \ncheckpoint to restore the application to the state before any attempted escape, after which the other \nescape strategies can be applied to .x the execution.  Multithreaded Applications: Many interactive \napplica\u00adtions are multithreaded for example, applications often run the user interface and the core computation \nin sepa\u00adrate threads. Bolt detects in.nite loops in multithreaded programs on a per-thread basis. Bolt \ntracks memory accesses for loop iterations in every thread separately, but to better understand the synchronization \nbehavior of threads, Bolt also tracks other actions, such as writes to shared memory and atomic instructions. \n  1.4 Experimental Results We applied Bolt to thirteen in.nite loops and two long\u00adrunning (but .nite) \nloops in thirteen applications to evaluate how well Bolt s detector module detects in.nite loops and \nhow well Bolt s escape module enables an application to continue its execution and produce useful results. \nDetection. Bolt correctly classi.es eleven of the thirteen in.nite loops as in.nite.1 Bolt also correctly \ndetects that the two long-running loops change state at every iteration and therefore reports that the \nloops may not be in.nite. 1We note that Jolt can detect seven of these eleven in.nite loops. The remaining \nin.nite loops are out of the scope of Jolt.  Escape. For fourteen of the .fteen total loops (both in.nite \nand long-running), Bolt can identify an escape strategy that enables the application to terminate and \nproduce an output. These results include the two in.nite loops that the detector module could not identify \nas in.nite; we treated these two loops as additional long-running loops for this experiment. For seven \nout of these fourteen loops, Bolt enables the ap\u00adplication to provide the same correct output as a subsequent \nversion of the application with the in.nite loop error elimi\u00adnated via a developer .x. For the remaining \nseven loops, Bolt enables the application to provide more output than simply terminating the application \nwould produce, but not all of the correct output (see Section 4 for details).  1.5 In.nite Loop Patterns \nAn examination of the in.nite loops in our set of bench\u00admark applications indicates that they fall into \none of two pat\u00adterns: missing transition in.nite loops (the application enters a state from which it \ncannot consume and process the re\u00admaining input) and missing exit condition in.nite loops (the application \nhas processed its input but is missing the exit condition that enables it to terminate after processing \nthat particular input). These patterns help to explain why Bolt can enable appli\u00adcations to produce useful \nor even correct results. For missing transition loops, using Bolt to escape the in.nite loop typi\u00adcally \nenables the application to produce a partial result (in some cases escaping the loop restores the ability \nof the ap\u00adplication to successfully process subsequent inputs so that the application produces the correct \nresult). For missing exit condition loops, using Bolt to escape the in.nite loop typi\u00adcally enables the \napplication to produce the correct result.  1.6 Contributions This paper makes the following contributions: \n Bolt: We present Bolt, which detects and escapes in.nite loops in (potentially stripped) single and \nmultithreaded x86 and x64 binaries. Bolt uses application checkpoint\u00ading to explore multiple escape strategies. \nThe goal is to enable the program to continue its execution to provide useful results to its users even \nin the face of in.nite loops.  Implementation: We present the details of the Bolt im\u00adplementation, including \nthe mechanisms Bolt uses to 1) detect loops in executing binaries, 2) determine if the loop is actually \nan in.nite loop, 3) escape the loop if di\u00adrected to do so by the user, and 4) roll back to the check\u00adpointed \nstate to try di.erent alternatives if the last alter\u00adnative did not deliver a successful execution. \n Evaluation: We present an evaluation of how well Bolt works for thirteen in.nite loops and two long-running \nloops in thirteen applications. Bolt s in.nite loop detec\u00adtion is successful for eleven out of the thirteen \nin.nite loops. Escaping the loops enables the applications to suc\u00adcessfully continue their executions \nfor fourteen out of the  .fteen total loops. For seven of these loops Bolt pro\u00adduces the same correct \nresult as subsequent versions of the applications with the in.nite loops eliminated via a developer .xes. \nFor the remaining seven loops, Bolt provides more useful output than simply terminating the applications. \n Case Studies: We present .ve case studies that illustrate, in detail, the e.ect of using Bolt to escape \nin.nite loops.  In.nite Loop Patterns: We discuss two in.nite loop pat\u00adterns found in our set of benchmark \napplications: missing transition in.nite loops and missing exit condition in.\u00adnite loops. These patterns \nhelp to explain Bolt s success in enabling applications to successfully execute once they escape in.nite \nloops.  We also note that Bolt currently implements the core sys\u00adtem building blocks required to address \na much larger range of anomalies and errors. Speci.cally, Bolt s monitoring, checkpointing, and search \ncapabilities can be extended to respond to a variety of detected errors, enabling a user to try di.erent \nrecovery strategies until one allows the application to continue successfully. 2. Using Bolt The PHP \nscript in Figure 1 performs a computation, adds a small constant numerical value to the computed result \n($result), and then outputs the result. A user might nat\u00adurally expect the script to print its results \nand terminate normally. However, with PHP version 5.3.4, the PHP inter\u00adpreter enters an in.nite loop \nwhile processing the next to last line (which adds a double-precision .oating point literal to $result).2 \nThe script hangs and never prints the result. Bolt. If the user observes that PHP has become unrespon\u00adsive, \nhe or she can install and apply Bolt on-demand. To ap\u00adply Bolt, the user would open the Bolt User Interface \n(pre\u00adsented in Figure 2) and perform the following steps: Detect: First, the user selects the php process \nfrom the central box that lists running processes, sorted by CPU usage; in this case the php process \nconsumes almost 100% of the CPU time. The user next presses the De\u00adtect button, after which Bolt runs \nits in.nite loop detec\u00adtion analysis and then reports in the status box below the list of processes that \nit has detected an in.nite loop; Fig\u00adure 3 provides a more detailed presentation of this box. Note that \na user does not need to anticipate the existence of the in.nite loop in advance it is possible to install \nand apply Bolt even after the PHP interpreter becomes unresponsive. 2PHP 5.3.4 has a known in.nite loop \nbug when parsing source code containing certain small .oating point numbers or when string literals that \nrepresent these numbers are passed as an argument to a string-to-.oat conversion function such as floatval(). \nWe discuss the technical aspects of this bug in Section 5.1.  <?php $result = 0 // ... $result = $result \n+ 2.2250738585072011e-308; printf( \"Final result: %.17e \\n\", $result); ?> Figure 1: Example PHP Program \n Figure 2: Bolt GUI Main Window  Checkpoint: After Bolt detects the in.nite loop, the user has an option \nto immediately try one of the escape strate\u00adgies or to take an application checkpoint by pressing the \nCheckpoint button. A checkpoint e.ciently stores the entire state of the program and allows a user to \ntry mul\u00adtiple escape strategies if the .rst strategy does not give acceptable results, Bolt can use the \ncheckpoint to restore the state and try some other escape strategy.  Escape: The user chooses an escape \nstrategy from the drop down menu above the Escape button and hits the Escape button. In our example, \nthe user .rst selects the Unwind strategy (which exits from the function that contains the in.nite loop). \nThis strategy does not produce a desired result the execution of PHP continues, but the program returns \na non-zero status code and prints an error message reporting a parsing error on the line before the last \n(on which the small .oating point value is added to the $result variable).  Restore: If an escape strategy \ndoes not produce an ac\u00adceptable result, then the user can press the Restore but\u00adton to restore the application \ns original state from the  checkpoint and execute a di.erent strategy. In our exam\u00adple, the user restores \nthe application and then attempts the Break strategy (which jumps to an instruction in the same function \noutside of the observed in.nite loop). In this case the strategy is successful and the user can ob\u00adtain \nthe output of the script. Automated Bolt. Instead of manually selecting an escape strategy, the user \ncan press the Search button, which auto\u00admates the process of executing escape strategies and restor\u00ading \nfrom checkpoints. After trying one escape strategy, Bolt checks if the application terminated gracefully \n(without er\u00adror), and if so, presents the results to the user. If the program terminated unexpectedly, \ndid not terminate until a timeout, or the user is not satis.ed with the result, Bolt restores the program \nfrom a checkpoint and tries the next escape strat\u00adegy. It repeats these steps until it .nds a successful \nescape strategy or explores all of the di.erent strategies. When encountering a non-responsive program \nfor the .rst time, we anticipate that users will typically elect to invoke an automated search for the \nbest escape strategy. On the other hand, if a user encounters a loop in a program for which Bolt previously \nfound a successful escape strategy, a user may select that strategy directly from the drop down menu. \n3. Bolt Implementation Bolt contains a detection module, an escape module, and a checkpoint module. These \nmodules are tied together with the Bolt User Interface, but can also be used separately. Each of the \nBolt modules is implemented using the following tools: Bolt Detector: The Detector attaches to the target \nap\u00adplication using the Pin dynamic instrumentation frame\u00adwork [34]. The Bolt Detector uses Pin to monitor \nmem\u00ad ory accesses and function calls.  Bolt Escape Tool: The Escape tool uses ptrace system calls to \nattach to the target application, set breakpoints, and execute escape strategies.  Checkpoint Module: \nThe checkpoint module is imple\u00admented using Berkeley Lab Checkpoint/Restart (BLCR), a Linux kernel module \nfor application checkpointing [2].  In addition to providing these modules, Bolt is also a completely \nmodular framework, enabling it to be extended with additional error detectors and escape strategies. \n 3.1 Bolt Detector The Bolt Detector performs two primary tasks: loop struc\u00adture detection and in.nite \nloop detection. 3.1.1 Loop Structure Detection When the Bolt Detector attaches to the running application \nusing Pin, it must .rst detect if the application is inside a loop. A loop is de.ned as a sequence of \nexecuted instruc\u00adtions that starts from a given stack frame and instruction and then returns to the same \nstack frame and instruction. This de.nition includes loops that may cross function boundaries through \nfunction calls, but excludes recursion.  When the Bolt Detector attaches to the running appli\u00adcation, \nit saves the value of the instruction pointer at the moment it attaches; we call this instruction the \npivot instruc\u00adtion. The Bolt Detector then tests if the application s execu\u00adtion is within a loop that \ncontains the pivot instruction speci.cally, if the application executes a contiguous se\u00adquence of instructions \nbeginning from the current stack frame and the pivot instruction and returning to the same stack frame \nand the pivot instruction. To determine if the stack frame of a subsequently ex\u00adecuted instruction is \nthe same as the pivot instruction, the Bolt Detector compares the calling context of the instruction \nto that of the pivot instruction.3 A calling context is the se\u00adquence of executed call sites that create \na given stack frame. The Bolt Detector dynamically reconstructs the calling context of both the pivot \ninstruction and the instructions in the loop by monitoring the execution of the application. Calling \nContext Reconstruction. The Bolt Detector s calling context reconstruction algorithm exploits the obser\u00advation \nthat it is possible to construct the calling context of the pivot instruction by observing the subsequent \nexecution of the application. To make this more precise, we .rst abstract the execu\u00adtion trace of the \napplication after Bolt attaches as a sequence of only function calls and returns. The function call instruc\u00adtion \ni : call f is an instruction at address i that pushes the address i + 1 onto the application s stack \nand then transfers control to the address of the function f. The function return instruction ret is an \ninstruction that pops the return destina\u00adtion address o. the top of the application s stack and then \ntransfers control to the return destination. We classify a trace of the execution of the application \nas matched if the trace is an element of the language of balanced parentheses with grammar M: M := E \n| ( M ) M In this grammar, left parentheses ( denote call instruc\u00adtions and right parentheses ) denote \nret instructions. This grammar therefore represents executions where each func\u00adtion call instruction \nis appropriately matched by a function return instruction. The calling context of a pivot instruction \nin an execution trace is the given by the sequence of unmatched return in\u00adstructions in the su.x of the \ntrace beginning at the pivot instruction. The su.x of a matched trace can be unmatched in that it may \ncontain return instructions ) with no corre\u00adsponding call instruction ( . If a return instruction is \nun\u00admatched in this su.x, then the corresponding call instruc\u00ad 3The option to compile an application without \na stack frame pointer is available in many widely used compilers. Therefore, the stack frame pointer \ncannot be reliably used to identify stack frames. tion must have occurred before the pivot instruction \nand is therefore part of the calling context. Algorithm 1 presents the pseudocode for the calling con\u00adtext \nreconstruction algorithm. The algorithm updates the calling context information for the pivot instruction \nafter each subsequent instruction step as follows. It takes as input the current instruction address \nic, the current stack pointer sp, the current call stack Sc, and the portion of the pivot in\u00adstruction \ns calling context that has been constructed thus far Cp. In this presentation, Sc is a standard stack \ndata structure whereas Cp is a standard list. Algorithm 1 Calling Context Reconstruction 1: function \nupdate context (ic, sp, Sc, Cp) 2: if is call ( ic) then 3: push ( Sc, ic + 1) 4: else if is ret( ic) \nthen 5: if empty ( Sc) then 6: insert ( Cp, *sp ) 7: else 8: pop( Sc) 9: end function The algorithm need \nonly consider three cases: Call Instruction: If the current instruction is a call in\u00adstruction, then \nthe algorithm pushes the instruction ad\u00address plus one onto the current call stack of the applica\u00adtion \nSc (Line 3).  Unmatched Return Instruction: If the current instruc\u00adtion is a return instruction, and \nthe current call stack is empty, then the return is unmatched and therefore part of the calling context. \nThe algorithm adds the return desti\u00adnation address to the calling context (which resides at the top of \nthe stack and is pointed to by sp) by inserting it into the calling context Cp (Line 6).  Matched Return \nInstruction: If the current instruction is a return instruction and the current call stack is non\u00adempty, \nthen the return is matched and not part of the calling context. The algorithm therefore pops the top \nelement o. of the current call stack (Line 8).  Each time the Bolt Detector reaches the pivot instruction \nit compares Cp with Sc. If these two structures contain the same sequence of addresses, then both the \ncalling context of the pivot instruction and the current call stack are the same and the Bolt Detector \nhas identi.ed a loop in the execution of the program. Applicability. The loop structure detection algorithm \nidenti.es loops implemented using standard control .ow constructs (both structured and unstructured) \nsuch as for and while loops, conditionals, goto statements, and function call/return. It is not designed \nto recognize loops generated using a mix of setjmp/longjmp and/or recursive function calls. Note that \nthe application must re-execute the pivot instruction for the algorithm to detect the loop.  3.1.2 \nIn.nite Loop Detection At the end of each iteration of the loop, the Bolt Detector takes a snapshot of \nthe application s register and memory state. These snapshots enables it to determine if the loop is in.nite. \nSpeci.cally, for any sequence of loop iterations and corresponding snapshots, if execution returns to \nthe same state (as recorded in the snapshots), then the loop is in.nite. The Bolt Detector records any \nmemory locations modi.ed or read in any previous loop iteration. When comparing snap\u00adshots, the Bolt \nDetector .rst compares the set of memory locations and registers contained in the snapshots. If these \nsets are equal, it then compares the contents of these mem\u00adory locations and registers. The Bolt Detector \nalso has the capability to detect certain semantic in.nite loops in cases where changes to portions of \napplication s state are independent of the termination of the loop. For example, an in.nite loop may \nproduce outputs to a console or .le during each iteration through calls to the application s runtime \nlibrary (e.g., fputs or fprintf in the C standard runtime library). On each of these calls, the standard \nlibrary keeps track of the number of bytes written or the current cursor position in the .le in its internal \nstate, which is stored within the application s address space. While this state will change on each iteration \nof the loop, if this state is never used within an iteration of the loop, then it can be ignored (its \nvalue is independent of the termination of the loop). To implement this functionality, the Bolt Detector \nuses Jolt s library routine abstraction technique [24]. In some programs that contain in.nite loops, \nit may take many iterations before the program returns to an earlier state. The Bolt Detector provides \na user-settable timeout, or a minimum number of instructions to execute, after which it will detach if \nit has not yet detected an in.nite loop. Multithreaded Loop Detection. When the Bolt Detector attaches \nto a multithreaded application, it begins tracking the memory accesses of each thread separately. When \na given thread completes one iteration of a loop, snapshots of mem\u00adory accessed only by that thread are \ncompared to determine if there may be an in.nite loop in that thread. In addition to memory snapshots, \nthe Bolt Detector tracks other actions taken by each thread before reporting that there is an in.nite \nloop (it is possible for another thread to eventually take some action to in.uence the execution of a \nthread suspected to be in an in.nite loop). Speci.cally, the Bolt Detector monitors each thread for the \nfollowing types of operations, which in\u00addicate that threads may be communicating with each other: Synchronization/Atomic \nOperations: The Bolt De\u00adtector inspects the set of instructions executed by each thread to identify synchronization \nand atomic operations.  Volatile/Shared Memory Writes: The Bolt Detector compares the read and write \nsets of each thread in the application to .nd intersections between the read set of a potentially looping \nthread and the write set of another thread.  If the Bolt Detector observes any potential inter-thread \ncommunication, then it reports to the user that the thread may not be in an in.nite loop (however, it \nstill provides the user with the capability to escape the loop).4 3.1.3 Analysis Result The Bolt Detector \ns produces 1) the set of top-level instruc\u00adtions (the set of instructions that are both in the loop and \nalso in the function that contains the loop) along with the stack pointer observed at each instruction, \n2) a determination of whether the loop is potentially in.nite, and 3) a report of any patterns that may \nindicate inter-thread communication. Before exiting, the Bolt Detector writes these results to a .le \nand then detaches all dynamic instrumentation. For loops that do not read inputs from the outside world \nand are within an application without asynchronous control .ow (such as signal handlers) or multithreading, \nthe Bolt Detector s in.nite loop detection strategy is sound if it reports that there is an in.nite loop \nthen the application is in an in.nite loop. If any of these quali.cations are violated, then the detection \nstrategy takes a best-e.ort approach by looking at additional information (such as the application s \nsynchronization behavior). In these cases, the Bolt Detector reports that the application may not be \nin an in.nite loop, but still o.ers the user the option to escape the loop.  3.2 Bolt Escape Tool The \nBolt Escape tool implements two in.nite loop escape strategies: Break (which forces the execution to \ncontinue at an instruction that is outside the set of instructions executed by the loop) and Unwind (which \nforces the execution to return from the function containing the loop). The Escape tool takes as input \nthe results of the Bolt Detector s in.nite loop detection analysis and the escape con.guration parameters \nprovided by the user via the Bolt GUI. If the user has elected to use the Unwind strategy, then the Escape \ntool also takes as input the value to return from the target function when unwinding the stack. Given \nthe analysis results and GUI parameters, the tool proceeds as follows: 1. The escape tool .rst attaches \nto the application and places a breakpoint at the escape instruction the instruction from which escape \nwill be performed. The Escape tool currently selects the top-level instruction with the maxi\u00admum address \nas the escape instruction. 2. When the application hits the breakpoint, the escape tool compares the \ncurrent stack pointer of the application with that provided as input with the top-level instructions. \nThis ensures that the breakpoint has been hit in the top\u00adlevel stack frame. If not, execution continues \nuntil the application hits the breakpoint in the correct stack frame.  4Bolt s analysis is inspired \nby the C++0x standard s de.nition for empty loops that can be removed by an optimizing compiler [18]. \n 3. When the application reaches the breakpoint in the cor\u00adrect stack frame, the escape tool applies \none of the two escape strategies and then remains attached to the appli\u00adcation for a speci.ed timeout. \nIf the application termi\u00adnates within this timeout, then the Escape tool reports the termination to the \nuser. Otherwise, the Escape tool de\u00adtaches from the application once the timeout expires, al\u00adlowing the \napplication to continue its execution with no instrumentation and no Bolt overhead. The search function \nin the Bolt GUI provides an auto\u00admated method to explore multiple escape strategies on a tar\u00adget program. \nTo use the search function, a user must attach Bolt to the program and take a checkpoint. The search \nfunc\u00adtion will then try each escape strategy in turn. For each strat\u00adegy, if the target program does \nnot terminate after a time\u00adout, the user can attempt to determine if the escape strategy was successful \nby observing the continued execution. If the strategy did not succeed, Bolt will terminate the program \n(if necessary), then restore execution from the checkpoint. Implementation. The Escape tool attaches \nto the applica\u00adtion with ptrace, which is a lightweight alternative to attach\u00ading to the application \nwith Pin in cases in which one does not need to perform heavyweight dynamic instrumentation. The Escape \ntool implements the Break escape strategy by using ptrace to modify the instruction pointer register \nof the application to point to an escape destination instruc\u00adtion. This action forces the application \nto immediately jump to the escape destination instruction. The Escape tool selects the address of the \nescape instruction plus one as the escape destination instruction. Because we set the escape instruc\u00adtion \nto be the top-level instruction with the maximum ad\u00address, the escape destination is therefore not in \nthe set of top-level instructions and must be on a di.erent control .ow path. For example, if the escape \ninstruction is a conditional jump, then the escape destination is the fall-through of the jump. Bolt \nalso supports setting the escape instruction to be any top-level jump instruction. The Escape tool uses \nthe libunwind library [6] to imple\u00ad ment the Unwind escape strategy, which unwinds one or more frames \nof the stack, e.ectively forcing the program to return from the current function and continue execution \naf\u00adter the function call-site. The Bolt GUI also enables a user to explore di.erent return values for \nthe function call when executing the Unwind strategy. The Escape tool implements this by modifying the \nreturn value registers immediately be\u00adfore unwinding the application from the function. The libunwind \nlibrary uses a combination of excep\u00adtion handling information and stack walking to perform call stack \nreconstruction. In particular, libunwind looks at certain sections in ELF binaries, including the .eh \nframe, and .debug frame sections. Depending on how the applica\u00adtion was compiled, these sections may \nnot contain enough information to reconstruct a call stack. In these cases, li\u00adbunwind uses a simple \nstack walking algorithm that looks at the base pointer. In general, libunwind s analyses are in\u00adcomplete. \nTherefore, in cases where libunwind is unable to identify an unwind destination, Bolt reports to the \nuser that is is unable to apply the Unwind strategy.  3.3 Checkpoint Module Bolt uses the BLCR (Berkeley \nLab Checkpoint/Restart sys\u00adtem [2]), which is implemented as a kernel module. This checkpoint saves memory \nand register state, .le system state, and works for single and multithreaded applications. Some resources, \nincluding sockets and other resources, can\u00adnot be checkpointed by BLCR. One limitation of BLCR is that \nit requires an application to have loaded the BLCR runtime library into its address space before creating \na checkpoint. To enable Bolt s on\u00addemand usage scenario where the user downloads Bolt on the .y, we therefore \nautomatically force-load BLCR s run\u00adtime library into the application s address space when the user elects \nto take a checkpoint. Speci.cally, we use Pin to inject calls to dlopen() into the application s instruction \nstream. This approach is similar to what others have done in previous work on Process Hijacking [52]. \n 3.4 Platform Compatibility and Extensions Bolt s current implementation best supports detecting and \nescaping loops in x86 and x64 binaries on Linux. In prin\u00adciple, it would be possible to extend Bolt for \nuse on other platforms in the following ways: Bolt Detector: The Bolt Detector uses Pin for its dy\u00adnamic \nanalysis. Pin can analyze binaries built for the x86, x64, and IA-64 architectures on Linux, Windows, \nand Mac OS. To support an alternative architecture or operating system, one would need a di.erent dynamic \ninstrumentation framework (e.g., DynInst [29] or Dy\u00ad namoRIO [21]) that supported the desired platform. \n Escape Module: The escape module is x86/x64 Linux speci.c. To extend the escape module to an alternative \narchitecture, one would need to provide Bolt with access to the application s stack pointer register. \nTo extend the escape module to an alternative operating system, the operating system would need to provide \nfunctionality similar to that of ptrace. So, for example, while Mac OS X provides an implementation of \nptrace, Windows does not. Therefore, an implementation of the escape module for Windows would need to \nobtain ptrace s capabilities on that platform.  Checkpoint Module: The checkpoint module is a Linux \nkernel module and is compatible with all versions of Linux up to and including version 2.6.38. The module \nfully supports x86 and x64 architectures, and has experi\u00admental support for ARM and PPC. To provide checkpointing \non other architectures in Linux, one would need to re-implement the small architecture speci.c components \nof BLCR [3]. To provide check\u00ad   pointing on other operating systems, one would need to use an alternative \napplication checkpointing framework that supported the operating system of interest. 4. Empirical Evaluation \nWe next present and discuss the benchmarks we use to eval\u00aduate Bolt, our experimental methodology, and \nthe results of our experiments. 4.1 Benchmark Summary To evaluate Bolt, we collected a number of applications \nwith known in.nite loops. We obtained eight in.nite loops in ctags, grep, ping, look, and indent that \nwe used in our pre\u00advious evaluation of Jolt [24]. In addition to these in.nite loops, we searched open-source \nproject repositories and the Common Vulnerabilities and Exposures database [4] for ad\u00ad ditional bug reports \nthat involve non-terminating program behavior. We used several general guidelines while searching for \nadditional bug reports to investigate. First, we only inves\u00adtigated bug reports that speci.ed the steps \nrequired to re\u00adproduce the in.nite loop and provided an input that elicited the in.nite loop. Second, \nwe attempted to collect in.nite loops from di.erent application domains. Finally, we con\u00adsidered the \nperceived importance and popularity of applica\u00adtions when determining which bug reports to investigate. \nWe investigated nine additional bug reports: .ve of these bugs are due to in.nite loops, two are due \nto long-running loops, and one is due to an in.nite recursion. We were unable to reproduce the remaining \nloop. Benchmarks. Table 1 presents the benchmarks on which we evaluated Bolt. Column 1 (Benchmark) presents \nthe name of the benchmark. Column 2 (Version With Bug) presents the version number of the benchmark that \ncontained the in.nite or long-running loop. Column 3 (Version With Fix) presents the version number of \na later version with the bug eliminated via a developer .x. Column 3 (Loop Type) indicates if the benchmark \nloop is an in.nite loop or a long\u00adrunning loop. We evaluate Bolt on .fteen benchmarks. Thirteen bench\u00admarks \ncontain in.nite loops and two benchmarks contain long-running (but .nite) loops. The applications range \nfrom common utilities to large, multithreaded GUI applications: php: PHP is a general purpose scripting \nlanguage, com\u00admonly used for web development and in server side appli\u00adcations [8]. The in.nite loop occurs \nwhen the PHP inter\u00ad preter parses certain .oating point values from a string. It occurs only in 32-bit \nbuilds of PHP, but presents a denial of service (DoS) risk to server applications if they receive these \n.oating point value as input or parse a script that contains these values [17].  wireshark: Wireshark \nis a network protocol analyzer which allows a user to capture and analyze tra.c on a  Benchmark Version \nWith Bug Version With Fix Loop Type php 5.3.4 5.3.5 In.nite wireshark 1.4.0 1.4.1 In.nite gawk 3.1.1 \n3.1.2 Long apache 2.2.18 2.2.19 In.nite pam 1.1.2 1.1.3 In.nite poppler 0.11.3 0.12.0 Long ctags-fortran \n5.5 5.5.1 In.nite ctags-python 5.7b (646) 5.7b (668) In.nite grep-color 2.5 2.5.3 In.nite grep-color-case \n2.5 2.5.3 In.nite grep-match 2.5 2.5.3 In.nite ping 20100214 20101006 In.nite look 1.1 (svr 4) - In.nite \nindent 1.9.1 2.2.10 In.nite java-vm 6.0 - In.nite Table 1: Benchmark Loops computer network [10]. The \nin.nite loop occurs when parsing certain network packets that contain malformed attributes. The in.nite \nloop can be triggered by opening a previously recorded packet log .le or by a remote user sending corrupt \nnetwork packets [14]. gawk: Gawk is the GNU implementation of the AWK pattern scanning and text processing \nlanguage [5]. The long-running loop occurs when attempting to parse an input containing nested single \nand double quotes. This loop occurs in the implementation of the regular expres\u00adsion engine in gawk [11]. \n apache: Apache is an extensible web server [1]. The in.\u00ad nite loop occurs in the Apache Runtime Library \nin a func\u00adtion used for matching URL regular expressions [15].  pam: Pluggable Authentication Modules \n(PAM) are used to provide authentication mechanisms for Linux pro\u00adgrams [7]. The in.nite loop is within \nthe PAM module that is responsible for parsing .les that contain environ\u00adment variables. It can be triggered \nwhen parsing a .le that has values that exceed the maximum internal bu.er size [16].  poppler: poppler \nis a rendering engine for the PDF doc\u00adument format [9]. It contains a long-running loop that oc\u00ad curs \nwhen rendering PDF documents that contain JPEG images with corrupt dimensions [13].  ctags: We investigated \ntwo in.nite loops in ctags: ctags-fortran: The fortran module in version 5.5 has  an in.nite loop when \nparsing certain declarations sep\u00adarated by semicolons.  ctags-python: The python module in version 5.7 \nhas an in.nite loop that occurs when parsing certain multi-line strings. grep: We investigated three \nin.nite loops in grep version 2.5. These loops occur as a result of a zero length match: grep-color: \nOccurs when grep is con.gured to dis\u00adplay the matching part of each line in color. grep-color-case: Occurs \nwhen grep is con.gured with case insensitive matching and to display match\u00ad ing parts of each line in \ncolor. grep-match: Occurs when when grep is con.gured to print only the matching part of each line. \n ping: ping client is a network utility that checks for the reachability of a remote host on a network. \nAn in.nite loop occurs when parsing certain reply message .elds.  look: look is a dictionary lookup \nprogram. An in.nite loop occurs as a result of a dictionary entry not termi\u00adnated by a newline character. \n indent: indent is a source code pretty-printer. An in.nite loop occurs parsing a .nal line containing \na comment and no newline character.  java-vm: Java virtual machine has an in.nite loop that occurs when \nconverting certain strings to .oating point numbers [12].  Additional In.nite Loop Reports. In addition \nto the benchmark in.nite loops discussed above, we also inves\u00adtigated the following in.nite loop bug \nreports: .ndutils: The bug reported in GNU .ndutils (GNU bug tracker 13381) is an in.nite recursion, \nnot an in.nite loop. It is therefore outside the scope of Bolt (although one can envision extending Bolt \nto handle in.nite re\u00adcursions as well as in.nite loops). The in.nite recursion is caused by symbolic \nreferences in the .le system that form cyclic paths in scanned subdirectories.  gstreamer: The bug reported \nin the gstreamer audio li\u00adbrary (Gnome bug tracker 120292) is an in.nite loop in the vorbis plugin. We \nwere unable to compile the version of the plugin package that contains the in.nite loop.   4.2 Methodology \nFor each benchmark, we performed the following steps: Detection: We ran the application and allowed \nit to enter the in.nite or long-running loop. We then started Bolt and evaluated if Bolt was able to \nidentify the in.nite loop.  Checkpointing: We evaluated whether Bolt (using the BLCR library) was able \nto take a checkpoint of the appli\u00adcation and restore from a previous checkpoint. We eval\u00aduated the e.ciency \nof checkpointing by measuring the time to take the checkpoint and size of the checkpoint.  Escape: \nWe used Bolt to force the application to escape from the loop. We then observed whether the application \nbecame responsive as a consequence of the escape. We determined whether the resulting output was well \nformed and used manual inspection or Valgrind to determine if the continued execution incurred any invalid \nmemory accesses or leaks.  Comparison with Termination: We compared the out\u00adput obtained from terminating \nthe application with the output obtained by applying each of the Bolt escape strategies.  Comparison \nwith Manual Fix: We compared the out\u00adput produced by applying di.erent Bolt escape strategies with the \noutput of a later version of the application with the in.nite loop manually corrected via a developer \n.x.  Comparison between Strategies: We considered two possible loop escape strategies: Unwind and Break. \nWe compared the e.ectiveness of each of these strategies by comparing the output produced after using \neach of these strategies.  Reasons for In.nite Loops: We manually analyzed the source code of the application \nto discover the underlying reasons for the in.nite loop and classify these reasons into common patterns. \n We performed our experiments on a 3.2 GHz Quad-Core Intel Xeon with 6 GB of RAM running Ubuntu Linux. \nWe also used the Linux strip command to remove all symbols from executables and relevant libraries before \nrunning Bolt. We set two timeouts for how long to run the Bolt De\u00adtector: 10 seconds of execution time \nor 105 analyzed in\u00adstructions; detection stops when one of the conditions is hit. We did not constrain \nthe Bolt Detector to maintain a .xed number of snapshots therefore, the number of snapshots that we compare \nvaries from application to application. The Break escape strategy jumps out of the loop from the jump \ninstruction at the maximum address inside the loop. For the Unwind escape strategy we used four possible \nreturn values: -1, 0, 1, and the value previously stored in the CPU s return register (e.g., the eax \nregister on x86). We applied both de\u00adtection and escape for up to three consecutive times for each unresponsive \nloop to account for possible in.nite loops in the continued execution.  4.3 Detection Results Bolt detected \n11 out of 13 in.nite loops. Bolt was not able to detect the in.nite loops in indent and java-vm. For \nthese two benchmarks the state of the application changes after every iteration of the in.nite loop that \nBolt tracked. For 9 out of these 11 loops Bolt was able to identify a repeating state after a single \niteration of the loop. Two loops, php and pam, change the state of the application after a single iteration, \nbut the executions eventually return to one of the previously observed states after multiple iterations. \n For the two long-running (.nite) loops in gawk and pop\u00adpler Bolt identi.es that the state after every \niteration changes and thus does not report them as in.nite loops. In comparison to Bolt s results, Jolt \ncan successfully de\u00adtect seven of these in.nite loops (ctags-fortran, ctags-python, grep-match, grep-color, \ngrep-color-case, ping, and look). The remaining benchmarks are out of the scope of Jolt, ei\u00adther because \nthe benchmark is multithreaded (wireshark), because the loops execute several iterations before repeating \nthe same state (php and pam) or because the loops occur in library code (apache, pam, and poppler). 4.4 \nNumerical Results Timing Results. Table 2 presents the time statistics for in.nite loop detection and \nescape. Column 2 presents the amount of time that Bolt takes to detect an in.nite loop, starting from \nwhen the Bolt Detector has attached to the application. Column 3 presents the amount of time required \nto escape from the in.nite loop and continue execution, starting from when the Bolt escape module has \nattached to the application. These times represent the median of .ve repeated executions in which we \nused Bolt to escape each in.nite loop. The escape time for each benchmark is equal to the maximum of \nthe times for the two escape strategies. For all benchmarks, median detection time was below 6 seconds \nand the median escape time was below 0.03 sec\u00ad onds. Entries marked as  indicate that the Bolt Detector \ndid not detect an in.nite loop until the timeout. Loop Size Results. Table 3 presents the length of the \nin\u00ad.nite loop and the size of the snapshot of the program state after each iteration for each benchmark \nfor which Bolt de\u00adtected the in.nite loop. Column 2 presents the size of a regis\u00adter .le in bytes (note \nthat because php is a 32-bit application its register snapshot size is smaller than the remaining 64\u00adbit \napplications). Column 3 presents the size in bytes of all memory locations modi.ed during the execution \nof the loop. Column 4 presents the length of each detected in.nite loop measured in the number of instructions \nthat the loop exe\u00adcutes. It is possible for di.erent iterations of in.nite loops in our benchmark applications \nto have di.erent sized snapshots or lengths, depending on the location in the loop to which Bolt attaches. \nIn such cases we reported the maximum sizes and lengths over all iterations of the loop. We identi.ed \na positive correlation between the lengths of each loop and the time to detect the loop (R-squared co\u00ade.cient \n0.78). This positive correlation suggests that loops with more instructions will typically take longer \nto detect. The short detection time for the smallest loop in Wireshark, which is one instruction long \n(see Section 5.2), indicates that the overhead of the initial setup of Bolt Detector is minimal. Checkpointing \nResults Table 4 summarizes the check\u00adpointing results. Column 2 presents whether the checkpoint\u00ading and \nsubsequent restoring of the state was successful. Column 3 presents the median time to create a checkpoint. \nBenchmark Detection Time (s) Escape Time (s) php 1.346 0.008 wireshark 0.0003 0.006 gawk  0.004 apache \n0.168 0.005 pam 5.856 0.011 poppler  0.002 ctags-fortran 0.122 0.004 ctags-python 0.141 0.002 grep-match \n2.458 0.013 grep-color 2.145 0.011 grep-color-case 1.348 0.006 ping 0.026 0.003 look 0.164 0.003 indent \n 0.024 java-vm  0.030 Table 2: Loop Time Statistics Benchmark Reg. Size (b) Mem. Size (b) Length php \n128 688 7784 wireshark 192 0 1 gawk apache 192 8 106 pam 192 0 74606 poppler ctags-python 192 24 78 ctags-fortran \n192 0 239 grep-match 192 1001 1575 grep-color 192 1001 1577 grep-color-case 192 1093 1740 ping 192 0 \n21 look 192 108 153 indent java-vm Table 3: In.nite Loop Memory and Length Statistics Benchmark Success \nTime (s) Size (kb) php Yes 0.221 2192 wireshark No gawk Yes 0.139 484 apache No pam Yes 0.269 943 poppler \nYes 1.663 94548 ctags-fortran Yes 0.166 360 ctags-python Yes 0.136 448 grep Yes 0.147 408 ping Yes 0.177 \n360 look Yes 0.181 212 indent Yes 0.736 228 java-vm Yes 0.258 7116  Table 4: Results of BLCR Checkpointing \nTable 5: Summary of Escape Results Benchmark Errors After: Unwind Break vs. Termination Unwind Break \nvs. Manual Fix Unwind Break Best Strategy php Parse None Same Better None Same Break wireshark None \nParse Better Better Same Same* Same gawk None Memory Better Same Partial None Unwind apache None None \nBetter Worse Same Worse Unwind pam None Unresponsive Better N/A Same N/A Unwind poppler None Unresponsive \nBetter N/A Partial N/A Unwind ctags-fortran None Memory Better Same Partial None Unwind ctags-python \nNone None Better Better Partial Partial Same grep-match None Unresponsive Better N/A Partial* N/A Unwind \ngrep-color None None Better Better Partial Partial Break grep-color-case None None Better Better Partial \nPartial Break ping None None Better Better Same Partial* Unwind look None None Same Same Same Same Same \nindent None None Better Better Partial Same* Break java-vm Unresponsive Unresponsive N/A N/A N/A N/A \nN/A Column 4 presents the median size of the checkpoint. The results contain only a single entry for \ngrep as all three in.\u00adnite loops occur in the same version of the program. For 10 out of the 13 applications, \nrestoring from the checkpoint was successful. Restoring the state for Wireshark and Apache was not successful \nbecause the BLCR check\u00adpointing system was unable to checkpoint open sockets and certain open system \n.les (such as /dev/urandom). The time to take the checkpoint for all benchmarks was less than two seconds \nand the maximum size of the check\u00adpoint .les was 95 MB for poppler. For all applications except indent \nthe variance between checkpoint times was minimal. Since the indent in.nite loop continuously allocates \nmem\u00adory, taking a checkpoint later in the execution of this pro\u00adgram records more program state, which \nrequires more time and produces a larger checkpoint .le.  4.5 Escape Results Table 5 presents the summary \nof the results of the continued execution of benchmarks after using each escape strategy. In addition \nto this summary, we present detailed descriptions of escaping the loops in php, wireshark, gawk, apache, \nand pam in Section 5. We previously presented detailed descriptions of escaping the in.nite loops in \nctags, grep, ping, look, and indent in the evaluation of Jolt [24]. Continued Execution Errors. Columns \n2 and 3 of Ta\u00adble 5 present errors in continued execution after applying each of the two escape strategies. \nThe errors include unex\u00adpected application terminations, latent memory errors, and unresponsiveness. \nEntries marked as None did not exhibit any error as a consequence of in.nite loop escape. For 14 out \nof the 15 benchmarks at least one escape strategy enabled the application to execute without error in \nthe continued execution. Instructing Bolt to escape the loop in java-vm with both the Unwind and Break \nescape strategies kept the application in an unresponsive state. Seven benchmarks had an error after \napplying one of the escape strategies. Two benchmarks (php and wireshark) reported errors in parsing \nparts of their inputs after exiting the in.nite loops. Two applications (gawk and ctags-fortran) experience \nsegmentation faults after escaping the in.nite loop with the Break strategy. Applying the Break strategy \non pam, poppler, and grep-match leaves the applications unresponsive even after repeated escape attempts. \nA dagger ( ) on an error entry indicates that the error triggered the application s existing error handling \ncode, which allowed the application to terminate gracefully. Termination Comparison. Columns 4 and 5 \nof Table 5 present the results of comparing the outputs obtained after terminating the application with \nthe outputs produced by applying Bolt to escape the loop. For entries marked Better Bolt helped the application \nproduce more output or handle more requests compared to termination. For entries marked Same both Bolt \nand termination produced the same output. If the escape strategy left the application in an unresponsive \nstate, we mark the e.ect of escape as N/A . We marked the entry for apache and the Break escape strategy \nas Worse because for some con.gurations of the server the continued execution may grant unauthorized \naccess to protected data (see Section 5.4). For 13 loops at least one of Bolt s escape strategies pro\u00advided \nbetter output than terminating the application. For the remaining loop (look) termination and Bolt both \nproduce the same output because the in.nite loop occurs at the very end of the computation (this output \nis also the same as the output of the correct program). Manual Fix Comparison. Columns 6 and 7 of Table \n5 present the results of comparing the outputs produced by ap\u00adplying Bolt to the outputs produced by \na later version of the application in which developers .xed the in.nite loop. En\u00adtries marked Same indicate \nthat the outputs from applying Bolt are identical to the outputs from the .xed application. Entries marked \nPartial produced some (but not all) of the correct output. Entries marked None produced none of the output \nthat the manually .xed application produced. For en\u00adtries marked with an asterisk (*), the output after \nescaping from the loop contained the complete or partial expected output from the .xed version, but also \nincluded additional output from code that is not executed in the .xed version.  For all loops except \nthe java-vm, at least one escape strategy enabled the application to produce a partial output. For 7 \nloops, one of the escape strategies provided output identical to that of the manually .xed application. \nFor the remaining 7 loops Bolt helped the application produce a partial result. Four benchmarks that \nproduced additional outputs after applying Bolt are wireshark, grep-match, ping, and indent. In the case \nof the Break strategy for wireshark, the appli\u00adcation prints an additional warning message. In the case \nof the Unwind strategy for grep-match, the application outputs additional end-of-line characters. In \nthe case of the Break strategy for ping, the extra output results in displaying the time stamp information \nof an input packet; the .xed version of the program ignores this part of the packet. In the case of the \nBreak strategy for indent, the output (a C source .le) is semantically identical it di.ers by only a \nsingle additional whitespace character at the end of the .le. Comparison of Two Escape Strategies. Column \n8 of Ta\u00adble 5 presents which one of the two escape strategies, Break or Unwind, was more e.ective for \neach in.nite loop. We evaluated the relative e.ectiveness of the strategies by com\u00adparing the output \nproduced after applying each strategy to the output produced by the manually .xed application. The entries \nfor which both escape strategies produced identical outputs are marked as Same . For 4 loops, the Break \nstrategy gave the best output, and for 7 loops, the Unwind strategy gave the best output. In the remaining \n3 cases both the Break and the Unwind produced the same output. Both escape strategies were unsuccessful \nfor the java-vm loop.  4.6 In.nite Loop Patterns Out of the thirteen in.nite loops, eight loops perform \nstring pattern matching (look, apache, indent, and all ctags and grep loops), two loops traverse complex \ndata structures (wireshark and ping), two loops perform numerical com\u00adputation (php and java-vm), and \none loop performs string substitution (pam). Within this diversity of computations, we identi.ed two \nmain reasons for the in.nite loops in our benchmark applications: Missing Transition: While processing \nits input, the com\u00adputation inside a loop enters a state from which it can\u00adnot proceed and consume the \nremaining input. Exam\u00adples include unhandled zero-length string matches (the three grep loops), unhandled \nnested character patterns in a string (ctags-python), unmatched keywords in the in\u00adput source code .le \n(ctags-fortran), unsupported optional parts of the input message (ping), or undetected round\u00ado. errors \nin arithmetic operations involving subnormal .oating-point numbers (php and java-vm). Missing Exit Condition: \nThese loops have completed processing their inputs, but the exit condition is not sat\u00adis.ed. Examples \ninclude missing end-of-line character checks (indent and look), missing return statements in error-handling \ncode (wireshark and pam), or missing string length check (apache). Each of these patterns also correlates \nwith how well es\u00adcaping the in.nite loop emulates the developers manual .x (Table 5, Columns 6 and 7). \nFor loops with missing transi\u00ad tions, escaping the loop produces a partial result in 5 out of 8 cases \nthe remaining two loops (php and ping) produce the same result as the manual .x and java-vm does not \nproduce any result. The intuition behind this result is that the applica\u00adtion enters an in.nitely looping \nstate before processing the entire input and, therefore, escaping such a loop curtails the execution \nof the loop without processing the remainder of the input. For all loops with a missing exit condition \nat least one of Bolt s escape strategies produces the same result as the manual .x proposed by the developers. \nThis is again intu\u00aditive because the application will have already .nished pro\u00adcessing the input by the \ntime it enters a repeating sequence of states. 5. Detailed Case Studies We next provide a detailed analysis \nof Bolt for .ve bench\u00admark applications. These applications include both client ap\u00adplications and libraries \n(Wireshark, Gawk, and the PAM li\u00adbraries) and server-side applications (Apache and PHP). 5.1 PHP We \ncontinue with the example in.nite loop from Section 2. PHP version 5.3.4 for 32-bit x86 processors when \ncompiled with the gcc compiler (which is the default compiler for the binary distribution of PHP) contains \nan in.nite loop when converting certain strings into .oating point values [17]. The error occurs in the \nzend strtod function in the .le zend strtod.c. The loop begins on line 2313. This function takes as input \na pointer to a string literal (which can be a constant or an input that a user interactively provides \nas the script executes) and returns 1) the .oating-point value of the largest convertible pre.x of the \nstring and 2) a pointer to the end of the pre.x. We presented an input that triggers this in.nite loop \nin Figure 1 in Section 2. The in.nite loop occurs when the loop continuously tries to adjust the accuracy \nof the .oating point result as it reads additional characters from the string. The computation does not \nmake progress due to the interplay between the gcc com\u00adpiler and the CPU s .oating point unit the computation \nof intermediate results inside the FPU is performed in 80-bit extended precision registers, but the .nal \nresult is converted to the regular 64-bit IEEE double precision .oating point value. When the computation \ntries to add the adjustment to the current result, due to rounding it leaves the value of the result \nunchanged so that it misses the loop s exit condition.  In.nite Loop Detection. Each iteration of the \nloop ac\u00adcesses over 20 local variables and executes several levels of nested function calls. A closer \nexamination of the compu\u00adtation reveals that 1) in each iteration of the loop the com\u00adputation allocates \nand frees temporary heap data structures that represent unbounded integers and 2) the only state in the \nloop that changes between iterations is the pointers to these data structures, which are independent \nof the loop s exit con\u00addition. Because PHP uses a custom bounded-size allocator for these data structures, \nthe allocator eventually reuses the same (previously allocated and freed) memory locations af\u00adter four \nloop iterations. This loop therefore repeats the same execution pattern every four iterations. E.ects \nof Escaping In.nite Loop. When using the Un\u00adwind escape strategy, PHP terminates and prints an error \npointing to the user s source code: Parse error: syntax error, unexpected $undefined in test.php on line \n2. Line 2 in the .le test.php contains the .oating-point string literal. The error handling code is triggered \nby intermediate values that are present in the registers at the time of applying the Unwind escape strategy. \nWhen using the Break escape strategy, PHP continues its execution from an instruction still inside the \nloop that is in a branch not taken by the original computation, but which changes the values of the adjustment \nvariables. This branch does not change any of the digits of the resulting .oating-point value, but allows \nthe computation to exit the loop during the next iteration, at the same location and with the same result \nas the manually .xed version of the program. As a result, the user s script is properly parsed and executed, \nprinting out a double value, without any visible errors. For the Break escape strategy, we used Valgrind \nto check for latent memory errors. Valgrind does not report any mem\u00adory errors and a manual inspection \nof the application s code shows that the branch at which Bolt forces the application to continue its \nexecution ensures that the currently allocated memory is properly freed. Comparison with Termination. \nIf the .oating-point value is passed as a constant (as in the example), then the in.nite loop occurs \nduring PHP s compilation phase and termina\u00adtion results in no PHP code being executed (PHP parses the \nentire .le before executing the code). Although applying the Unwind escape strategy also causes the code \nto not be executed, it still provides a parse error that points to the line where the value appears in \nthe user s code. The Break strategy, on the other hand, enables the program to terminate and fully execute \nevery instruction of the code, including the instruction with the string literal. The in.nite loop can \nalso be triggered when reading the string literal from an input source, such as a .le or an HTTP request. \nIn this case, termination prevents any code past this point from being executed. The Unwind escape strategy \nwill terminate the script (but will log the location of the error). And the Break strategy will allow \nthe script to continue its execution past this point. We note that while PHP has the facility to detect \nand ter\u00adminate long-running scripts (speci.cally by setting a limit on the maximum execution time), PHP \ncannot recognize and terminate a script that contains this in.nite loop because PHP checks to see if \nthe limit has been exceeded only after executing (interpreting) complete PHP instructions. How\u00adever, \nthis in.nite loop occurs in the middle of interpreting a single PHP instruction, so PHP is unable to \ndetect that the script has exceeded its maximum time limit. Comparison with Manual Fix. The developers \nmanually .xed the application by marking local variables as volatile, which forces the compiler to store \nthe intermediate values of the computation in memory (thus implicitly converting these values from 80-bit \nto 64-bit values). This avoids the undesired rounding of these variables. We compared the result of applying \nthe Break escape strategy to the faulty version of PHP with the result of the manually corrected version \nof PHP (version 5.3.5). The results of both executions had all digits identical.  5.2 Wireshark Wireshark \nis commonly used for network tra.c monitoring, recording, and analysis. It provides a graphical interface \nthat enables a user to analyze network tra.c in real time. Version 1.4.1 of Wireshark contains an in.nite \nloop in the ZigBee wireless protocol module [14]. The in.nite loop can be triggered by reading a malformed \npacket log .le or by a remote user maliciously sending corrupt packets. Figure 4 presents a simpli.ed \nversion of the loop. The variable tree is a pointer. If tree is NULL, then no code inside the loop is \never executed and the loop termination condition will never be satis.ed. This loop is located in the \nfunction dissect zcl discover attr resp(). The loop begins on line 1192 of the .le packet-zbee-zcl.c. \nwhile ( *offset < tvb_len &#38;&#38; i < ZBEE_ZCL_NUM_ATTR_ETT ) { if(tree) { // ... i++; // ... } } \nFigure 4: Wireshark Loop in packet-zbee-zcl.c  In.nite Loop Detection. When gcc compiles the applica\u00adtion \nwith optimizations turned on (with optimization level -O2), the compiler executes a loop unswitching \noptimization, which splits the original loop into two loops representing individual branches of the if \ncondition, and moves the if (tree) condition outside to control which loop to execute. If the tree pointer \nis not NULL, then the program executes the loop that processes tree and increments the induction vari\u00adable \ni. If the pointer tree is NULL, then execution continues in the one-instruction long in.nite loop in \nFigure 5. 0x7f66ccc51136: jmp 0x7f66ccc51136 Figure 5: Disassembly of the Wireshark In.nite Loop While \nthis in.nite loop is the simplest of all loops in our benchmarks, it deserves attention because Wireshark \nis a multithreaded application (see Section 3.1.2). In this case, the in.nite loop does not make any \nmemory accesses and, therefore, Bolt can be certain that a computation in another thread will never cause \nthis loop to exit. E.ects of Escaping In.nite Loop. With both the Unwind and Break strategies, Wireshark \nbecomes responsive after Bolt escapes the in.nite loop: it presents the network tra.c that caused the \nin.nite loop and all subsequent tra.c. The function that contains the in.nite loop does not contain any \ncode after the loop, so applying the Unwind strategy does not skip any computation. The Break strategy \ntransfers the execution of the program to the code within the if branch in Figure 4 (since the compiler \nplaces this code below the in.nite loop in the program s binary); this forces Wireshark to attempt to \nparse a corrupted packet. However, every operation within the body of this if branch has a redundant \ncheck to ensure that tree is not NULL. Therefore, if tree is NULL (as in the this case), execution simply \nexits the loop. As a result, the computation returns a status message noting that the packet is malformed. \nComparison with Termination. Terminating the program results in lost log data as the in.nite loop prevents \nthe user from saving the log data before termination. In contrast, both of Bolt s escape strategies enable \nthe application to become responsive again and continue analyzing tra.c, including the packet that caused \nthe in.nite loop. Comparison with Manual Fix. The manual .x by the de\u00advelopers simply moved the check \nfor NULL tree pointer val\u00adues outside the loop, so no code inside the loop is ever ex\u00adecuted. Since the \nfunction has no code after the loop, the result of the manual .x is equivalent to the Unwind escape strategy \nand the output of the manual .x is identical to that of the Unwind escape strategy. When using the Break \nes\u00adcape strategy, the program presents all results that the man\u00adually .xed program produced, but also \noutputs an additional [Malformed Packet] status message. loop.awk: {sub(/ (.?[ ]+)* /, \"<em>&#38;</em>\"); \nprint} input: Italics with an apostrophe embedded  No nested apostrophes Figure 6: Script and Input \nthat Cause the Long-Running Loop in Gawk  5.3 Gawk Gawk is the GNU implementation of the awk language. \nAwk is a text processing language commonly used for manipulat\u00ading .les and data. Version 3.1.1 of gawk \ncontained a long\u00adrunning loop in its regular expression library [11]. Figure 6 shows the awk program \nand the input .le (de\u00adrived from the bug report) that cause gawk to become un\u00adresponsive. The awk program \ncontains a regular expression designed to match pairs of double quotes (written as two sin\u00adgle quote \ncharacters) and surround them with <em> (empha\u00adsis) tags. The result of the substitution on each line \nis then printed out. In this case, the loop is triggered when gawk encounters a string with nested double \nquotes. Long-Running Loop Detection. The long-running loop is located in the .le regex.c, beginning on \nline 5615. This loop exits when a complete match is found or if a match fails. In total this loop contains \n1996 lines of code. The developer s response to this bug report was [11]: This is a bug who-knows-where \nin the guts of the regex.[ch] library. Unfortunately, I treat that as a black box, and have no idea how \nto fix it. Bolt identi.es that the state after each loop iteration changes and does not recognize this \nloop as in.nite. Testing gawk with smaller examples that we constructed by remov\u00ading the letters from \nthe beginning of the input from Figure 6 reveals that the loop is not in.nite, but its execution time \ndoubles with any character added before the nested quote symbol. The execution of gawk for the input \nfrom Figure 6 terminates after about one hour of execution. Further examination of the loop shows that \ngawk attempts matching the part of the string up to and including the nested quote symbols. However, \nbecause the substring does not fully match the pattern (i.e., there are additional characters after the \nquote symbols), gawk backtracks the search and tries to match all possible pre.xes, often repeating some \nof them multiple times. The number of pre.xes gawk tries is exponential in the size of the number of \ncharacters before the quote symbols. E.ects of Escaping Long-Running Loop. If Unwind sets the return \nvalue to 0 or uses the value residing in the return register from the function that contains the loop, \nthe pro\u00adgram terminates with a memory error. Gawk contains a sig\u00adnal handler that captures this type \nof error and prints the er\u00ad  ror message gawk: loop.awk:1: (FILENAME=input FNR=1) fatal err: internal \nerror. If Unwind instead returns -1 from the function that con\u00adtains the loop, the program will continue \nto execute and will produce the following output for the example input .le: Italics with an apostrophe<em> \n embedded </em> <em> No nested apostrophes </em> We can see that a match is found on the .rst line, and \na replacement made, though it is not the .rst match on the line. The match on the next line is then processed \nwithout any problem. Valgrind detected no memory leaks when using this escape strategy. A manual inspection \nof the loop shows that the computation uses the value -1 as an error code representing that no match \nwas found. After escaping from the loop with the Break strategy, gawk terminates and prints the same \nerror message as in the case when Bolt applies the Unwind strategy with return value 0. Comparison with \nTermination. Terminating the program prevents gawk from processing any lines in input .les after the \nline that elicits the long-running loop. The Unwind strat\u00adegy allows gawk to process the remainder of \ninput, while only a.ecting the result on the lines that caused the long ex\u00adecution of the loop. Comparison \nwith Manual Fix. The developers .xed this long-running loop as a part of a complete rewrite of awk s \npattern matching engine for version 3.1.2 (in the bug report response that we cited, the developer announced \nthe new version of the pattern matching library, which at the time was in development). We used this \nversion of gawk to process this input .le and it instantaneously produced the following result : <em> \nItalics with an apostrophe</em> embedded <em> No nested apostrophes </em> In general, regular expressions \nmatch from left to right and, therefore, the manually .xed pattern matcher inserts tags around the .rst \nmatched quotes. The Unwind strategy in\u00adstead .nds the second match on this line. However, it pro\u00adduces \nlegal HTML tag pairs, which do not a.ect rendering of the remainder of the output .le. The lines without \nnested quotes in the output are identical in both cases.  5.4 Apache Apache HTTP server version 2.2.18 \ncontains an in.nite loop in string matching code in the Apache Portable Runtime Library, version 1.4.4 \n[15]. The error occurs in the loop starting on line 199 in the function apr fnmatch, in the .le apr fnmatch.c. \nThis function takes as inputs a string, a pattern to match, and a set of .ags that controls properties \nof the matching. It returns 0 if a match was found and 1 if no match was found. Access Policy: Request: \n<Location \"/*/WEB-INF\"> GET /test HTTP/1.1 deny from all Host: 127.0.0.1 </Location> Figure 7: Access \nPolicy and HTTP Request that Cause the In.nite Loop in Apache Apache uses the apr fnmatch function as \na part of com\u00adputation that, given a set of access policies, determines whether to allow or deny requests \nthat the server receives. Figure 7 presents a sample access policy and HTTP request that causes the in.nite \nloop. This access policy is intended to prevent clients from accessing directories matching the regular \nexpression \"/*/WEB-INF\". Apache treats slash char\u00adacters ( / ) is a special way in this expression: a \nstring that matches this pattern must have exactly two slash charac\u00adters. The HTTP request contains the \npath /test, which does not match the pattern of the policy. The in.nite loop oc\u00adcurs when the non-matching \nrequested path has less slash characters than the pattern. Apache calls the function apr fnmatch with \nthree argu\u00adments: the requested path (\"/test\"), the access policy pat\u00adtern (\"/*/WEB-INF\"), and a .ag \nto ensure the number of slash characters in both the path and the pattern are the same. Af\u00adter the .rst \niteration, the in.nite loop consumes the entire re\u00adquested path, but only partially consumes the access \npolicy pattern (the corresponding pointer is incremented to point to the second slash-character). The \nfollowing iterations of the loop, however, do not recognize that the requested path is consumed and try \n(unsuccessfully) to match the remainder of the access policy pattern with the empty string. In.nite Loop \nDetection. The loop does not change the state of the application between iterations and the loop only \nmakes calls to the string library routines. This in.nite loop occurs in the Apache Runtime Library code, \nwhich is dy\u00adnamically loaded at runtime (Bolt readily supports analyzing code inside shared libraries). \nE.ects of Escaping In.nite Loop. Apache interprets the e.ect of the Unwind strategy with a return value \nother than 0 as returning a no-match the requested path does not match the access control policy pattern \nand the server should not apply the policy. When Apache continues execu\u00adtion after the loop, it makes \nrecursive calls to the function ap process request internal and, for the same request, the function apr \nfnmatch and the in.nite loop will execute again, in a di.erent stack frame. We can again apply the Un\u00adwind \nstrategy using a non-zero return value and Apache will continue the execution and send a response to \nthe client. Using the Break strategy or the Unwind strategy with a zero return value allows the server \nto continue execution with a return value 0 of the function, indicating that the path matches the pattern. \nThis return value indicates that Apache should apply the access control policy. The response of the server \ndepends on the policy s rule. In the previous example, the deny all policy instructs the server to deny \naccess to the path and instead send a 403 Forbidden response.  A manual inspection of the in.nite loop \nindicates that no memory is allocated or freed during the loop execution the loop memory accesses include \nonly pointer arithmetic and comparisons of local variables. Comparison with Termination. While the server \nis in the in.nite loop, a client will keep waiting for the response until a timeout on the client side \nor until the server process is terminated. Termination of the server process also terminates the connection \nand as a consequence the client will not receive any reply data. The Unwind strategy with non-zero return \nvalue instructs Apache not to apply the access control policy. This is a correct behavior, as the pattern \nand the path does not match the policy. The server eventually sends the correct response to the client \ns request. The Break strategy and the Unwind strategy with zero return value instruct the server to apply \nthe access control policy. As a result, depending on the body of the policy, the server can send the \ncorrect response, send the permission error instead of requested content (as for the input from Fig\u00adure \n7), or allow this policy to override the previously applied policies (which may potentially lead to security \nissues by al\u00adlowing unauthorized access to protected paths on the server). Comparison with Manual Fix. \nThe developer s .x, in APR version 1.4.5 (Apache 2.2.19) added two checks to this computation. The .rst \ncheck at the start of the loop body ensures that the computation exits the loop if the input string has \nbeen completely consumed. The second check after the loop body ensures that the function apr fnmatch \nreturns 0 (match found) only when both the requested path and the policy pattern have been completely \nconsumed. Otherwise the function returns a non-zero value (no match found). For the inputs from Figure \n7, the .xed application will exit the loop once the requested path is consumed and then return a non-zero \nvalue (no match). This .x produces the same result as our Unwind escape strategy with non-zero return \nvalue.  5.5 Pluggable Authentication Modules (PAM) Pluggable Authentication Modules (PAM) is a shared \nlibrary that implements authentication mechanisms. Many Linux programs and utilities, for example login, \nsu, and sshd, use PAM for authentication. PAM version 1.1.2 contains an in\u00ad.nite loop that can be triggered \nby a long environment vari\u00adable expansion [16]. The function that performs this expan\u00ad sion is expand \narg in the pam env module. The loop begins on line 553 of the .le pam env.c. Because PAM modules are \nnot standalone, we discuss the loop in the context of the the su tool and the command su \u00ad$USER , which \nallows the current user to login with another EF_255 DEFAULT=BBBBBBBB... [repeated 255 times] EF_256 \nDEFAULT=${EF_255}B EF_1024 DEFAULT=${EF_256}${EF_256}\\ ${EF_256}${EF_256} EF_8191 DEFAULT=${EF_1024}${EF_1024}\\ \n${EF_1024}${EF_1024}\\ ${EF_1024}${EF_1024}\\ ${EF_1024}${EF_256}\\ ${EF_256}${EF_256}\\ ${EF_255} EVIL_OVERFLOW_DOS \nDEFAULT=${EF_8191}AAAA Figure 8: Entries in .pam environment File that Cause the In.nite Loop in PAM \nwhile(*orig) { /* while there is still some input to deal with */ // ... if((strlen(tmp) + 1) < MAX_ENV) \n{ tmp[strlen(tmp)] = *orig++; } else { /* is it really a good idea to try to log this? */ D((\"Variable \nbuffer overflow: <%s> + <%s>\", tmp, tmpptr)); pam_syslog(pamh, LOG_ERR, \"Variable buffer overflow: \\ \n<%s> + <%s>\", tmp, tmpptr); } // ... } Figure 9: PAM In.nite Loop Code in pam env.c user name $USER. \nThe tool .rst prompts the user for the pass\u00adword, which will be authenticated using PAM. After authen\u00adtication, \nPAM creates an execution shell and sets up the en\u00advironment variables de.ned in the ~/.pam environment \n.le. The pam env module reads this .le and calls the expand arg function. This function contains a loop \nthat scans the input string for variables to expand. Figure 8 presents an input .le for the .pam environment \n.le that triggers the in.nite loop. Each entry is a single environment variable, followed by the keyword \nDEFAULT and the default value. The value of the environment vari\u00adable EVIL OVERFLOW DOS is constructed \nby concatenating the values of the previously de.ned environment variables. Its length exceeds 8192 characters. \nFigure 9 presents the simpli.ed version of the loop that expands and assigns values to environment variables. \nPAM limits the length of the value of each environment variable to 8192 characters (this is the size \nof an internal bu.er used to store the values). During every expansion, the current length of the value \nis compared to the maximum size of the inter\u00adnal bu.er. If this length is greater than the maximum size \n(as in the case of the EVIL OVERFLOW DOS variable), the computa\u00adtion uses the pam syslog function to \nlog this event. However, the computation does not exit the loop and, instead, keeps logging the same \nevent in every subsequent iteration. In.nite Loop Detection. This loop iterates through a large number \nof states before repeating. The reason for the mul\u00adtiple states is the allocation and deallocation of \ntemporary bu.ers that PAM s logging module creates every time it prints data to the output .le in the \nfunction pam syslog.  E.ects of Escaping In.nite Loop. The Break strategy does not escape this in.nite \nloop. It instead continues the execution inside the same loop along a di.erent path, previ\u00adously unseen \nby the Bolt Detector. The computation in this execution path interprets one character A from the input \nas an unrecognized escape character. On subsequent loop itera\u00adtions, execution returns to the original \npath and the execution remains in the in.nite loop. The Unwind strategy with non-zero values allows the \nex\u00adecution to escape the loop. The Unwind return value is com\u00adpared with zero (which represents success) \nand the caller function returns an error code up the call stack. This error code is handled by the clients \nof the PAM module. PAM then continues the computation and invokes additional mod\u00adules that again enter \nthe same in.nite loop. Escaping the loop for the second time returns the error code to the client. Each \nclient may use a di.erent strategy to handle this er\u00adror code: su prints an error message su: Critical \nerror -immediate abort and terminates. Other clients, such as a graphical login screen, may refuse to \nlog in the current user, but still enable logging in for other users. The Unwind strategy with a value \nof zero (applied two times, as in the previous case) also escapes the in.nite loop and allows the program \nto continue executing. A return value of zero indicates the call to the function has been successful \nand all variables expanded correctly, allowing su to create and start a new shell process. However, after \nescaping the loop with Bolt, the new shell remains in the background and becomes unresponsive (the shell \nexpects to run in the foreground and have a direct access to the terminal). While the current Bolt implementation \nleaves the new shell in an unusable state, using gdb to manually simulate this escape strategy does allow \nthe shell to execute in the foreground and a user to interact with it. The environment in this shell \ncontains all the variables declared in the .pam environment .le, including EVIL OVERFLOW DOS, which has \nthe same value as \"${EF 8191}\". We note that this in.nite loop does not cause privilege escalation. The \nPAM module that performs authentication part has already granted permissions to the user by the time \nthe application reaches the module with the in.nite loop. Manual inspection shows that no memory is allocated \nin this function until the very end, but the program never executes this code after applying the Unwind \nstrategy. Comparison with Termination. Terminating the process when using su has the same e.ective result \nas using the Un\u00adwind escape strategy with non-zero return value. We note that other clients that use \nthe PAM libraries may handle an internal PAM error in di.erent ways. Some clients may ter\u00adminate as a \nresult of the error code returned by the authen\u00adtication module (as in the case of su), but in other \ncases, the client may print an error message and continue interacting with a user on other tasks. Comparison \nwith Manual Fix. We compared the Bolt execution with the manually .xed PAM libraries version 1.1.3. The \nresult of invoking the su command with the .xed version was identical to the Unwind strategy with the \nnon\u00adzero return value: su prints an error message to the screen and terminates the execution. A manual \ninspection of the code reveals that the function expand arg is private to the PAM module, and all calls \nto this function are wrapped by the internal error handler that returns to the clients of the module \none of the de.ned error codes. Applying the Unwind strategy and running the manually .xed version of \nPAM return the same error code to clients. Using the Unwind escape strategy with value 0 presents an \nalternative .x for this computation the environment variable that causes the in.nite loop can be truncated \nor discarded, and PAM can log a warning message and still start the new shell. 6. Related Work In.nite \nLoop Detection. Researchers have developed several techniques that use symbolic program execution to \ndetect in.nite loops [22, 28]. Unlike Bolt, these techniques require the source code of an application \nand do not pro\u00advide the user with the option to escape an in.nite loop and continue the application s \nexecution. Researchers have also developed techniques for program debugging and veri.ca\u00ad tion that ensure \nthat a program does not contain any in.nite loops [19, 20, 25, 26, 49]. Jolt. Our previous work on Jolt \n[24] was the .rst to show that a simple, lightweight technique for dynamically detect\u00ading and exiting \nin.nite loops at runtime could enable ap\u00adplications with in.nite loops to produce acceptable outputs. \nJolt used a compiler to insert instrumentation into the pro\u00adgram. It therefore required access to source \ncode, a build environment, and ahead of time planning for in.nite loop detection and escape before executing \nthe application. The inserted Jolt instrumentation also imposed a 2%-10% over\u00adhead in standard production \nuse. Bolt, in contrast, is fully dynamic and operates directly on stripped binaries with no need for \nrecompilation, no access to source, an on-demand usage model, and no overhead in production use. Bolt \nalso handles multithreaded applications and can detect in.nite loops in which the loop state repeats \nonly after multiple iter\u00adations of the loop. Because Bolt operates on binaries, it can detect and escape \nin.nite loops that appear in any part of the application, including loops that appear in external libraries, \nwhich may not be available for recompilation. Program Repair. Nguyen and Rinard have previously de\u00adployed \nan in.nite loop escape algorithm that is designed to eliminate in.nite loops in programs that use cyclic \nmem\u00adory allocation to eliminate memory leaks [38]. The proposed technique bounds the number of iterations \nof all loops in a program. The bounds are determined empirically by observ\u00ading the execution of the program \non representative inputs. In comparison to Bolt, Nguyen and Rinard s technique is com\u00adpletely automated, \nbut may also escape loops that would oth\u00aderwise terminate.  Like Bolt, ClearView [39] is designed to \nrepair errors in potentially stripped binaries. ClearView, however, targets a di.erent class of errors \nspeci.cally, errors that violate learned invariants. ClearView is also designed to operate without user \ninteraction it relies on a set of pluggable error detectors to determine when the application is executing \nincorrectly. Bolt, in contrast, relies on the user to determine when the application has become unresponsive \n(although it would be straightforward to extend Bolt to trigger its loop detection and escape mechanisms \nbased on a timeout). Finally, ClearView uses a community approach it learns from past experience to favor \nrepairs that have succeeded in the past. Failure-Oblivious Computing [43] enables applications to dynamically \nidentify and recover from out-of-bounds mem\u00adory reads and writes. If the application detects that it \nis about to read or write an out-bounds-memory location, then it will synthesize a value for the read \nor expand the bounds of the allocated array to encompass the write. Unlike Bolt, the cur\u00adrently implemented \nversion of Failure-Oblivious Computing uses a compiler to insert checks and therefore requires ac\u00adcess \nto the source code of the application. Like Bolt, Failure-Oblivious computation enables applications \nto survive other\u00adwise fatal errors. The two techniques are potentially syner\u00adgistic in that they may, \ntogether, enable applications to sur\u00advive combinations of errors that either technique would be unable \nto handle separately. The Rx system [40] takes periodic checkpoints of the pro\u00ad gram state. When a failure \noccurs, it 1) reverts the appli\u00adcation to the checkpoint, 2) makes semantically equivalent changes to \nthe application s execution environment (e.g., adding padding to allocated bu.ers), and 3) restarts the \nex\u00adecution. Not that Rx does not attempt to change the appli\u00adcation s semantics it instead attempts to \nsearch the set of existing executions to .nd one that does not have an error. Like Rx, Bolt combines \ncheckpoints with recovery actions. But one critical di.erence between the two systems is that escaping \nin.nite loops changes (purposefully) the semantics of the original application to eliminate a bug. Such \nan ap\u00adproach is inherently required to eliminate in.nite loops (or, for that matter, many other software \nerrors). Researchers have also proposed a number of techniques that automatically repair applications \nby statically manipu\u00adlating their code (or scheduler in the case of deadlocks) [27, 30, 31, 33, 39, 46, \n47, 50, 51]. These systems operate in an o.-line fashion: they .rst observe the program failure, and \nonly after do they generate repairs for future executions. Therefore, these systems cannot be used to \nrecover an out\u00adput from a failed application. Bolt di.ers in that it focuses exclusively on in.nite loops \nand allows applications to re\u00adcover even the .rst time they encounter the error. Loop Perforation and \nTask Skipping. In.nite and long\u00adrunning loop escape can be viewed as a form of loop per\u00adforation [36, \n37, 48, 53], which reduces the execution time or energy consumption of an application by skipping itera\u00adtions \nof time-consuming loops. Task skipping obtains sim\u00adilar bene.ts by skipping tasks in time-consuming computa\u00adtions \n[44, 45]. Like loop perforation and task skipping, the goal of loop escape is to enable the application \nto produce an acceptable result in an acceptable time frame (although the reduction in execution time \nis larger for in.nite loop es\u00adcape than for loop perforation). Both loop perforation and in.nite loop \nescape are forms of acceptability-oriented com\u00adputing [23, 42] in that they are both mechanisms that \nenable applications to deliver acceptable results within an accept\u00adable time frame. Unsynchronized Parallel \nComputing. Unsynchronized updates to shared data can often be coded so that the net result of any resulting \ndata races is simply dropping one or more updates (which ensures that the updated data structures still \nsatisfy key data structure consistency properties) [41]. It is possible to apply this principle to obtain \nparallelizing com\u00adpilers that produce parallel programs with data races [35]. Despite the presence of \nthese data races, the automatically generated parallel code produces accurate enough results of\u00adten enough \nto be acceptable. Like in.nite loop termination, these techniques may improve a program by eliminating \ncomputation. 7. Conclusion Bolt enables users to escape in.nite and long-running loops in unresponsive \napplications so that the application can pro\u00adduce useful output or continue on to successfully process \nadditional inputs. Bolt operates directly on stripped x86 and x64 binaries. It requires no access to \nsource code, no recom\u00adpilation, imposes no overhead in standard production use, works with multithreaded \napplications, implements multiple loop escape strategies, and supports an on demand usage model in which \nit attaches and detaches to and from running applications. Our experimental results show that Bolt can \ne.ectively enable applications to escape in.nite and long\u00adrunning loops, produce useful output (in many \ncases the same output as subsequent versions with the in.nite loops eliminated through developer .xes), \nand continue on to pro\u00adcess additional inputs and serve the needs of its users. Acknowledgements We would \nlike the thank Deokhwan Kim, Stelios Sidiroglou, and the anonymous reviewers for their useful feedback \nand comments. We note our previous work on this topic [32]. This research was supported in part by the \nNational Science Foundation (Grants CCF-0811397, CCF-0905244, CCF\u00ad1036241, and IIS-0835652), DARPA (Grants \nFA8650-11\u00adC-7192 and FA8750-12-2-0110), and the United States De\u00adpartment of Energy (Grant DE-SC0005288). \n References [1] Apache HTTP server project. http://httpd.apache.org. [2] Berkeley lab checkpoint/restart. \nhttps://ftg.lbl.gov/projects/CheckpointRestart/. [3] BLCR frequently asked questions. https://upc-bugs.lbl.gov/blcr/doc/html/FAQ.html# \nporting. [4] Common Vulnerabilities and Exposures (CVE). http://cve.mitre.org/. [5] GNU awk. http://www.gnu.org/s/gawk/. \n[6] The libunwind project. http://www.nongnu.org/libunwind/. [7] Linux PAM Modules. https://fedorahosted.org/linux-pam/. \n[8] PHP. http://www.php.net/. [9] Poppler. http://poppler.freedesktop.org/. [10] Wireshark. http://www.wireshark.org/. \n[11] Gawk: In.nite loop in sub/gsub. http://lists.gnu.org/ archive/html/bug-gnu-utils/2002-10/msg00051.html, \n2002. [12] Java VM: Fix bug 4421494 in.nite loop while parsing double literal. http://bugs.openjdk.java.net/show \nbug.cgi?id=100119, 2009. [13] Poppler: Problem decoding JBIG2Stream stream. https://bugs.freedesktop.org/show \nbug.cgi?id=23025, 2009. [14] Wireshark: Bug 5303 -In.nite Loop in ZCL Discover Attributes dissection. \nhttp://bugs.wireshark.org/bugzilla/ show bug.cgi?id=5303, 2010. [15] Apache: apr fnmatch in.nite loop \non pattern /*/WEB-INF . http://issues.apache.org/bugzilla/show bug.cgi?id=51219, 2011. [16] PAM: 100% \nCPU utilization in pam env parsing. http://bugs.launchpad.net/ubuntu/+source/pam/+bug/874565, 2011. [17] \nPHP: Bug 53632 PHP hangs on numeric value 2.2250738585072011e-308. http://bugs.php.net/bug.php?id=53632, \n2011. [18] Working Draft, Standard for Programming Language C++. www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf, \n2011. [19] E. Albert, P. Arenas, M. Codish, S. Genaim, G. Puebla, and D. Zanardini. Termination analysis \nof Java bytecode. In FMOODS, 2008. [20] A. Bradley, Z. Manna, and H. Sipma. Termination of polyno\u00admial \nprograms. In VMCAI, 2005. [21] D. L. Bruening. E.cient, transparent, and comprehensive runtime code manipulation. \nPhD thesis, 2004. [22] J. Burnim, N. Jalbert, C. Stergiou, and K. Sen. Looper: Lightweight detection \nof in.nite loops at runtime. In ASE, 2009. [23] M. Carbin, D. Kim, S. Misailovic, and M. Rinard. Proving \nacceptability properties of relaxed nondeterministic approxi\u00admate programs. In PLDI, 2012. [24] M. Carbin, \nS. Misailovic, M. Kling, and M. Rinard. Detecting and escaping in.nite loops with Jolt. In ECOOP, 2011. \n[25] M. Col\u00b4on and H. Sipma. Practical methods for proving pro\u00adgram termination. In CAV, 2002. [26] B. \nCook, A. Podelski, and A. Rybalchenko. Terminator: beyond safety. In CAV, 2006. [27] V. Dallmeier, A. \nZeller, and B. Meyer. Generating .xes from object behavior anomalies. In ASE, 2009. [28] A. Gupta, T. \nHenzinger, R. Majumdar, A. Rybalchenko, and R. Xu. Proving non-termination. In POPL, 2008. [29] J. Hollingsworth, \nB. Miller, and J. Cargille. Dynamic program instrumentation for scalable performance tools. In SHPCC, \n1994. [30] H. Jula, P. Tozun, and G. Candea. Communix: A framework for collaborative deadlock immunity. \nIn DSN, 2011. [31] H. Jula, D. Tralamazza, C. Zam.r, and G. Candea. Deadlock immunity: enabling systems \nto defend against deadlocks. In OSDI, 2008. [32] M. Kling. Escaping in.nite loops using Bolt. MEng. Thesis, \nMIT CSAIL, January 2012. [33] C. Le Goues, M. Dewey-Vogt, S. Forrest, and W. Weimer. A systematic study \nof automated program repair: Fixing 55 out of 105 bugs for $8 each. In ICSE, 2012. [34] C.-K. Luk, R. \nCohn, R. Muth, H. Patil, A. Klauser, G. Lowney, S. Wallace, V. Reddi, and K. Hazelwood. Pin: Building \ncus\u00adtomized program analysis tools with dynamic instrumenta\u00adtion. In PLDI, 2005. [35] S. Misailovic, \nD. Kim, and M. Rinard. Parallelizing sequential programs with statistical accuracy tests. Transactions \non Embedded Computing Systems (to appear), 2012. [36] S. Misailovic, D. M. Roy, and M. C. Rinard. Probabilistically \naccurate program transformations. In SAS, 2011. [37] S. Misailovic, S. Sidiroglou, H. Ho.mann, and M. \nC. Rinard. Quality of service pro.ling. In ICSE, 2010. [38] H. Nguyen and M. Rinard. Detecting and eliminating \nmemory leaks using cyclic memory allocation. In ISMM, 2007. [39] J. H. Perkins, S. Kim, S. Larsen, S. \nAmarasinghe, J. Bachrach, M. Carbin, C. Pacheco, F. Sherwood, S. Sidiroglou, G. Sul\u00adlivan, W.-F. Wong, \nY. Zibin, M. D. Ernst, and M. Rinard. Automatically patching errors in deployed software. In SOSP, 2009. \n[40] F. Qin, J. Tucek, J. Sundaresan, and Y. Zhou. Rx: treating bugs as allergies a safe method to survive \nsoftware failures. In SOSP, 2005. [41] M. Rinard. A lossy, synchronization-free, race-full, but still \nacceptably accurate parallel space-subdivision tree construc\u00adtion algorithm. Technical Report MIT-CSAIL-TR-2012-005, \nMIT, Feb. 20012. [42] M. Rinard. Acceptability-oriented computing. In OOPSLA Onwards, 2003. [43] M. Rinard, \nC. Cadar, D. Dumitran, D. Roy, T. Leu, and W. Beebee Jr. Enhancing server availability and security through \nfailure-oblivious computing. In OSDI, 2004. [44] M. C. Rinard. Probabilistic accuracy bounds for fault-tolerant \ncomputations that discard tasks. In ICS, 2006.  [45] M. C. Rinard. Using early phase termination to \neliminate load imbalances at barrier synchronization points. In OOPSLA, 2007. [46] S. Sidiroglou, O. \nLaadan, C. Perez, N. Viennot, J. Nieh, and A. Keromytis. Assure: automatic software self-healing using \nrescue points. In ASPLOS, 2009. [47] S. Sidiroglou, M. E. Locasto, S. W. Boyd, and A. D. Keromytis. Building \na reactive immune system for software services. In USENIX Technical, 2005. [48] S. Sidiroglou, S. Misailovic, \nH. Ho.mann, and M. C. Rinard. Managing performance vs. accuracy trade-o.s with loop per\u00adforation. In \nFSE, 2011. [49] F. Spoto, F. Mesnard, and E. Payet. A termination analyzer for Java bytecode based on \npath-length. Transactions on Programming Languages and Systems, 32:1 70, March 2010. [50] W. Weimer, \nT. Nguyen, C. Le Goues, and S. Forrest. Au\u00adtomatically .nding patches using genetic programming. In ICSE, \n2009. [51] J. Wu, H. Cui, and J. Yang. Bypassing races in live applica\u00adtions with execution .lters. In \nOSDI, 2010. [52] V. C. Zandy, B. P. Miller, and M. Livny. Process Hijacking. In HPDC, 1999. [53] Z. A. \nZhu, S. Misailovic, J. A. Kelner, and M. C. Rinard. Randomized accuracy-aware program transformations \nfor ef\u00ad.cient approximate computations. In POPL, 2012.    \n\t\t\t", "proc_id": "2384616", "abstract": "<p>We present Bolt, a novel system for escaping from infinite and long-running loops. Directed by a user, Bolt can attach to a running process and determine if the program is executing an infinite loop. If so, Bolt can deploy multiple strategies to escape the loop, restore the responsiveness of the program, and enable the program to deliver useful output.</p> <p>Bolt operates on stripped x86 and x64 binaries, dynamically attaches and detaches to and from the program as needed, and dynamically detects loops and creates program state checkpoints to enable exploration of different escape strategies. Bolt can detect and escape from loops in off-the-shelf software, without available source code, and with no overhead in standard production use.</p>", "authors": [{"name": "Michael Kling", "author_profile_id": "81488658185", "affiliation": "MIT CSAIL, Cambridge, USA", "person_id": "P3856108", "email_address": "mkling@csail.mit.edu", "orcid_id": ""}, {"name": "Sasa Misailovic", "author_profile_id": "81330495396", "affiliation": "MIT CSAIL, Cambridge, USA", "person_id": "P3856109", "email_address": "misailo@csail.mit.edu", "orcid_id": ""}, {"name": "Michael Carbin", "author_profile_id": "81319489479", "affiliation": "MIT CSAIL, Cambridge, USA", "person_id": "P3856110", "email_address": "mcarbin@csail.mit.edu", "orcid_id": ""}, {"name": "Martin Rinard", "author_profile_id": "81100087275", "affiliation": "MIT CSAIL, Cambridge, USA", "person_id": "P3856111", "email_address": "rinard@csail.mit.edu", "orcid_id": ""}], "doi_number": "10.1145/2384616.2384648", "year": "2012", "article_id": "2384648", "conference": "OOPSLA", "title": "Bolt: on-demand infinite loop escape in unmodified binaries", "url": "http://dl.acm.org/citation.cfm?id=2384648"}