{"article_publication_date": "10-19-2012", "fulltext": "\n Dependent Types for JavaScript Ravi Chugh David Herman Ranjit Jhala University of California, San Diego \nMozilla Research University of California, San Diego rchugh@cs.ucsd.edu dherman@mozilla.com jhala@cs.ucsd.edu \n Abstract We present Dependent JavaScript (DJS), a statically typed dialect of the imperative, object-oriented, \ndynamic language. DJS supports the particularly challenging features such as run-time type-tests, higher-order \nfunctions, extensible ob\u00adjects, prototype inheritance, and arrays through a combina\u00adtion of nested re.nement \ntypes, strong updates to the heap, and heap unrolling to precisely track prototype hierarchies. With \nour implementation of DJS, we demonstrate that the type system is expressive enough to reason about a \nvariety of tricky idioms found in small examples drawn from several sources, including the popular book \nJavaScript: The Good Parts and the SunSpider benchmark suite. Categories and Subject Descriptors D.3.3 \n[Programming Languages]: Language Constructs and Features Inheri\u00adtance, Polymorphism; F.3.1 [Logics \nand Meanings of Pro\u00adgrams]: Specifying and Verifying and Reasoning about Pro\u00adgrams Logics of Programs \nKeywords Re.nement Types, JavaScript, Strong Updates, Prototype Inheritance, Arrays 1. Introduction Dynamic \nlanguages like JavaScript, Python, and Ruby are widely popular for building both client and server applica\u00adtions, \nin large part because they provide powerful sets of features run-time type tests, mutable variables, \nextensi\u00adble objects, and higher-order functions. But as applications grow, the lack of static typing \nmakes it dif.cult to achieve reliability, security, maintainability, and performance. In re\u00adsponse, several \nauthors have proposed type systems which provide static checking for various subsets of dynamic lan\u00adguages \n[5, 16, 22, 23, 30, 36]. Recently, we developed System D [9], a core calculus for dynamic languages that \nsupports the above dynamic id- Permission to make digital or hard copies of all or part of this work \nfor personal or classroom use is granted without fee provided that copies are not made or distributed \nfor pro.t or commercial advantage and that copies bear this notice and the full citation on the .rst \npage. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior \nspeci.c permission and/or a fee. OOPSLA 12, October 19 26, 2012, Tucson, Arizona, USA. Copyright &#38;#169; \n2012 ACM 978-1-4503-1561-6/12/10. . . $10.00 ioms but in a purely functional setting. The main insight \nin System D is to dependently type all values with formulas drawn from an SMT-decidable re.nement logic. \nWe use an SMT solver to reason about the properties it tracks well, namely, control-.ow invariants and \ndictionaries with dy\u00adnamic keys that bind scalar values. But to describe dynamic keys that bind rich \nvalues like functions, System D encodes function types as logical terms and nests the typing relation \nas an uninterpreted predicate within the logic. By dividing work between syntactic subtyping and SMT-based \nvalidity checking, the calculus supports fully automatic checking of dynamic features like run-time type \ntests, value-indexed dic\u00adtionaries, higher-order functions, and polymorphism. In this paper, we scale \nup the System D calculus to Dependent JavaScript (abbreviated to DJS), an explicitly typed dialect of \na real-world, imperative, object-oriented, dynamic language. We bridge the vast gap between System D \nand JavaScript in three steps. Step 1: Imperative Updates. The types of variables in JavaScript are routinely \nchanged either by assignment or by incrementally adding or removing .elds to objects bound to variables. \nThe presence of mutation makes it challenging to assign precise types to variables, and the standard \nmethod of assigning a single invariant reference type that overap\u00adproximates all values held by the variable \nis useless in the JavaScript setting. We overcome this challenge by extending our calculus with .ow-sensitive \nheap types (in the style of [2, 12, 15, 31, 32]) which allow the system to precisely track the heap location \neach variable refers to as well as alias\u00ading relationships, thereby enabling strong updates through mutable \nvariables. Our formulation of .ow-sensitive heaps combined with higher-order functions and re.nement \ntypes is novel, and allows DJS to express precise pre-and post\u00adconditions of heaps, as in separation \nlogic [17]. Step 2: Prototype Inheritance. Each JavaScript object maintains an implicit link to the prototype \nobject from which it derives. To resolve a key lookup from an object at run-time, JavaScript transitively \nfollows its prototype links until either the key is found or the root is reached without success. Thus, \nunlike in class-based languages, inheritance relationships are computed at run-time rather than provided \nas declarative speci.cations. The semantics of prototypes is challenging for static typing, because to \ntrack the type of a key binding, the system must statically reason about a po\u00adtentially unbounded number \nof prototype links! In DJS, we solve this problem with a novel decomposition of the heap into a shallow \npart, for which we precisely track a .nite number of prototype links, and a deep part, for which we do \nnot have precise information, represented abstractly via a logical heap variable. We unroll prototype \nhierarchies in shallow heaps to precisely model the semantics of object op\u00aderations, and we use uninterpreted \nheap predicates to reason abstractly about deep parts. In this way, we reduce the rea\u00adsoning about unbounded, \nimperative, prototype hierarchies to the underlying decidable, .rst-order, re.nement logic. Step 3: \nArrays. JavaScript arrays are simply objects whose keys are string representations of integers. Arrays \nare com\u00admonly used both as heterogeneous tuples (that have a .xed number of elements of different types) \nas well as homoge\u00adneous collections (that have an unbounded number of ele\u00adments of the same type). The \noverloaded use of arrays, to\u00adgether with the fact that arrays are otherwise syntactically indistinguishable \nand have the same prototype-based seman\u00adtics as non-array objects, makes it hard to statically reason \nabout the very different ways in which they are used. In DJS, we use nested re.nements to address the \nproblem neatly by uniformly encoding tuples and collections with re.nement predicates, and by using intersection \ntypes that simultane\u00adous encode the semantics of tuples, collections, and objects. Expressiveness. We \nhave implemented DJS (available at ravichugh.com/djs) and demonstrated its expressiveness by checking \na variety of properties found in small but sub\u00adtle examples drawn from a variety of sources, including \nthe popular book JavaScript: The Good Parts [10] and the Sun-Spider benchmark suite [34]. Our experiments \nshow that several examples simultaneously require the gamut of fea\u00adtures in DJS, but that many examples \nconform to recurring patterns that rely on particular aspects of the type system. We identify several \nways in which future work can handle these patterns more speci.cally in order to reduce the an\u00adnotation \nburden and performance for common cases, while falling back to the full expressiveness of DJS in general. \nThus, we believe that DJS provides a signi.cant step towards truly retro.tting JavaScript with a practical \ntype system. 2. Overview Let us begin with an informal overview of the semantics of JavaScript. We will \nemphasize the aspects that are the most distinctive and challenging from the perspective of type system \ndesign, and describe the key insights in our work that overcome these challenges. JavaScript Semantics \nby Desugaring. Many corner cases of JavaScript are clari.ed by .JS [21], a syntax-directed translation, \nor desugaring, of JavaScript programs to a mostly-standard lambda-calculus with explicit references. \n Figure 1. Architecture of DJS As .JS is a core language with well-understood semantics and proof techniques, \nthe translation paves a path to a typed dialect of JavaScript: de.ne a type system for the core lan\u00adguage \nand then type check desugared JavaScript programs. We take this path by developing System !D (pronounced \nD-ref ), a new calculus based on .JS. Although the oper\u00adational semantics of System !D is straightforward, \nthe dy\u00adnamic features of the language ensure that building a type system expressive enough to support \ndesugared JavaScript idioms is not. We solve this problem by scaling the purely functional technique \nof nested re.nement types up to the im\u00adperative, object-oriented, setting of real-world JavaScript. Figure \n1 depicts the architecture of our approach: we desugar a Dependent JavaScript (DJS) .le program.js to \nthe System !D .le program.dref, which is analyzed by the type checker along with a standard prelude comprising \nthree .les (basics.dref, objects.dref, and prelude.dref) that model JavaScript semantics. Terminology. \nJavaScript has a long history and an evolv\u00ading speci.cation. In this paper, we say JavaScript to roughly \nmean ECMAScript Edition 3, the standard version of the language for more than a decade [24]. We say ES5 \nto refer to Edition 5 of the language, recently released by the JavaScript standards committee [13]; \nEdition 4 was never standardized. We say ES6 to refer to features proposed for the next version of the \nlanguage, scheduled to be .nalized within the next one or two years. DJS includes a large set of core \nfeatures common to all editions. 2.1 Base Types, Operators, and Control Flow Consider the following function \nadapted from [9] and anno\u00ad tated in DJS. A function type annotation is written just above the de.nition \ninside a JavaScript comment demarcated by an additional : character. We typeset annotations in math mode \nfor clarity, but the ASCII versions parsed by our type checker are quite similar. /*: x:Top .{. iite \nNum(x) Num(.) Bool(.)} */ function negate(x) { if (typeof x == \"number\") { return 0 -x; } else { return \n!x; } } The typeof operator is a facility used pervasively to direct control .ow based on the run-time \ntag of a value. If the input to negate is a number, so is the return value. If not, the function uses \nan interesting feature of JavaScript, namely, val typeof :: (* x:Top .{. = tag(x)} *) val !:: (* x:Top \n.{. i. falsy(x)} *) val (||) :: (* x:Top . y :Top .{ite falsy(x)(. = y)(. = x)} *) val (&#38;&#38;) :: \n(* x:Top . y :Top .{ite truthy(x)(. = y)(. = x)} *) val (===) :: (* x:Top . y :{tag(.)= tag(x)}. {. i. \n(x = y .x . NaN)} *) val (==) :: (* x:Top . y :Top .{Bool(.).(tag(x)= tag(y).. i. (x = y .x . NaN))} \n*) val (+) :: (* x:Str . y :Str . Str *) val (+) :: (* x:Num . y :Num .{Num(.).((Int(x).Int(y)).(Int(.).. \n= x +y))} *) val fix :: (* .A. (A . A). A *) Figure 2. Excerpt from basics.dref {p}= {. ip} Num(x)Bool(x) \n.. .... = tag(x) = tag(x) = tag(x) ite pq1 q2 = that all values have a boolean interpretation. The values \n= number = boolean false, null, undefined, the empty string , 0, and the Top(x)= true .= .{()}()= T.Strx \nnot-a-number value NaN are considered falsy, and evaluate = T string to false when used in a boolean \ncontext; all other values are truthy. The operator ! inverts truthiness, so the else branch (p .q1).(\u00acp \n.q2) true)(x = false) (==i.itexppx . .. if p then q1 else q2 = x .{false .null .undefined .=\u00acfalsy(x) \nreturns a boolean no matter what the type of x is. The ability falsy(x) .0 .NaN} to treat arbitrary values \nas booleans is commonly used, for truthy(x) example, to guard against null values. The negate function \ndemonstrates that even simple Figure 3. Abbreviations for common types JavaScript programs depend heavily \non sophisticated control\u00ad.ow based reasoning. Syntactic type systems are capable of tracking control \n.ow to a limited degree [22, 36], but none de.ned in the .le basics.dref (Figure 2). Notice that typeof \nreturns the tag of its input. Some examples beyond ones we have already seen include tag(null)= can handle \ncomplex invariants like the relationship between object the input and output of negate. To have any chance \nof cap\u00ad and tag(undefined)= undefined . turing such invariants, types must be able to depend on other \n negation operator ! inverts truthiness. The types of the op\u00ad program values. Powerful dependent type \nsystems like Coq erators &#38;&#38; and || are interesting, because as in JavaScript, The type of the \ncan express extremely rich invariants, but are too heavy\u00adthey do not necessarily return booleans. The \nguard opera\u00adweight for our goals since they require the programmer to tor &#38;&#38; returns its second \noperand if the .rst is truthy, which discharge type checking obligations interactively. Re.nement Types. \nWe adopt a more lightweight mecha\u00ad nism called re.nement types that has been previously ap\u00ad enables \nthe idiom if(x &#38;&#38; x.f) { ...} that checks whether the object x and its f .eld are non-null. Dually, \nthe default operator || returns its second operand if the .rst is falsy, which enables the idiom x = \nx || defaultplied to purely functional dynamic languages [5, 9]. We to specify a default value. The + \noperator is speci.ed as an demonstrate that re.nement types afford us the expressive\u00adintersection of \nfunction types and captures the fact that it ness needed to precisely track control-.ow invariants in \nthe performs both string concatenation and numerical addition, but does not type check expressions like \n3 + JavaScript setting and, unlike more powerful dependent sys\u00ad hi that rely tems, without sacri.cing \ndecidable type checking. In partic\u00adon the implicit coercion in JavaScript. We choose types for ular, \nonce the programmer has written type annotations for System !D primitives that prohibit implicit coercions \nsince function de.nitions, type checking is carried out automat\u00adthey often lead to subtle programming \nerrors. Equality. JavaScript provides two equality operators: == ically via a combination of syntactic \nsubtyping and SMT\u00adbased [11] logical validity checking. In System !D, every value is described by a re.nement \ntype of the form {. .p}, read implicitly coerces the second operand if its tag differs from . such that \np , where p the .rst, and strict equality === does not perform any coer\u00ad is a formula that can mention \n.. For example, 3 can be number } and true the type cion. To avoid reasoning about implicit coercions, \nwe give a given the type {. .tag(.){. .tag(.)= boolean }, where tag is an uninterpreted function symbol \nin the re.nement logic, not a function in the = relatively weaker type to ==, where the boolean result \nrelates its operands only if they have the same tag. programming language. We de.ne abbreviations in \nFigure 3 to make the re.nement binder implicit and the types concise. Primitives. We use re.nements to \nassign precise, and sometimes exact, types to System !D primitive functions, Integers. JavaScript provides \na single number type that has no minimum or maximum value. However, programmers and optimizing JIT compilers \n[38] often distinguish integers from arbitrary numbers. In System !D, we describe integers with the abbreviation \nInt(x)=.Num(x).integer(x). We introduce the uninterpreted predicate integer(x) in the types function \nalso_negate(x) { 1 let also_negate = fun x -> (* G1 =\u00d8;S1 =\u00d8 *) 2 let _x=ref xin (* G2 = x:Top;S2 =(ex \n.x) *) if (typeof x == \"number\") 3 if typeof (deref _x) == \"number\" then (* G3 = G2,x:Ref ex;S3 = S2 \n*) x=0-x; 4 _x := 0 -(deref _x) (* G4 = G3, Num(x);S4 =.x4 :Num. (ex .x4) *) else 5 else x = !x; 6 \n_x := !(deref _x) (* G6 = G3, \u00acNum(x);S6 =.x6 :{. i. falsy(x)}. (ex .x6) *) 7 ; (* G7 = G3;S7 =.x ' \n:{ite Num(x)Num(.)Bool(.)}. (ex .x ') *) return x; 8 deref _x in (* G8 = G3;S8 = S7 *) } 9 let _also_negate \n= ref {\"__code__\": also_negate} Figure 4. DJS function also negate; Desugared to System !D; Verifying \nx:Top .{ite Num(x) Num(.) Bool(.)} of integer literals, and functions like + propagate integer\u00adness where \npossible. Furthermore, numeric functions use the (decidable) theory of linear arithmetic to precisely \nreason about integers, which is important for dealing with arrays. Tracking Control Flow. System !D tracks \ncontrol .ow precisely by recording that the guard of an if-expression is truthy (resp. falsy) along the \nthen-branch (resp. else-branch), enabling System !D to verify the annotation for negate as follows. Because \nof the call to typeof, System !D tracks that Num(x) holds along the then-branch, so x can be safely passed \nto the subtraction operator which produces a number as required. For the else-branch, System !D records \nthat \u00acNum(x). The negation operator, which can be applied to any value, produces a value of type {. i. \n\u00acfalsy(x)}which is a subtype of Bool. Thus, both branches satisfy the speci.cation provided by the programmer. \n 2.2 Imperative Updates JavaScript is an imperative language where variables can be reassigned arbitrary \nvalues. Consider the DJS function also_negate in Figure 4 that is like negate but .rst as\u00adsigns the eventual \nresult in the variable x, and its translation to System !D on the right (ignore the comments for now). \nSeveral aspects of the translation warrant attention. First, since the formal parameter x, like all JavaScript \nvariables, is mutable, the translation of the function body begins with an explicit reference cell _x \ninitialized with x, and each read of x is desugared to a dereference of _x. Presentations of imperative \nlanguages often model assignable variables di\u00adrectly rather than with explicit references. Both approaches \nare equivalent; we choose the latter to make the presenta\u00adtion more similar to .JS [21] and System D \n[9]. Second, notice that scalar constants like 0 and true and operators like typeof and == are translated \ndirectly to corresponding ones in System !D. Third, notice that each assignment to the variable x translates \nto a set reference (i.e., assignment) op\u00aderation to update the contents of the heap cell. Finally, since \nevery JavaScript function is actually an object, the transla\u00adtion stores the function value in a distinguished \n code .eld, which we assume is inaccessible to source programs. Instead of this assumption, we could \ntreat each function as a pair of a function value and an associated object, but we follow the .JS encoding \nfor simplicity. For System !D to verify that also_negate satis.es the speci.cation, it must precisely \nreason about heap updates in addition to control\u00ad.ow as before. Reference Types. The traditional way \nto handle references in the .-calculus [28] is to (a) assign a reference cell some type Ref T , (b) require \nthat only values of type T be stored in it, and then (c) conclude that dereferences produce values of \ntype T . This approach supports so-called weak updates, be\u00adcause even if a stored value satis.es a stronger \ntype S than T (i.e., if S is a subtype of T ), subsequent dereferences pro\u00adduce values of the original, \nweaker type T . Put another way, this approach requires that the type assigned to a reference cell be \na supertype of all the values written to the cell. Un\u00adfortunately, weak updates would preclude System \n!D from verifying also_negate. The initialization of _x on line 2 stores the parameter x which has type \nTop, so _x would be assigned type Ref Top. The assignments on lines 4 and 6 type check because the updated \nvalues satisfy the trivial type Top, but the dereference on line 8 produces a value with type Top, which \ndoes not satisfy the speci.ed return type. Thus, we need a way to reason more precisely about heap updates. \nStrong Updates. Allowing assignment to change the type of a reference is called strong update, which \nis sound only when a reference is guaranteed to point to a single heap cell and when there are no accesses \nthrough other aliases that re\u00adfer to the same cell. The Alias Types approach [32] provides a means of \nmanaging these concerns. Rather than Ref T ,a reference type is written Ref \u00a3, where \u00a3 is the (compile-time) \nname of a location in the heap, and a separate (compile\u00adtime) heap maps locations to types, for example, \n(\u00a3 .T ). Strong updates are realized by allowing heaps to change .ow-sensitively, and the aliasing problem \nis mitigated by maintaining the invariant that distinct location names \u00a3 and \u00a3 ' do not alias. System \n!D employs this approach by using a type environment G that grows and shrinks as usual during type checking \nbut remains .ow-insensitive, and a heap envi\u00adronment S that can be strongly updated per program point. \nFigure 4 shows how System !D checks the desugared version of also_negate. The .gure shows, at each line \ni, the type environment Gi used to check the expression on the line, and the heap environment Si that \nexists after checking the expression. After starting with the empty heap S1 =\u00d8, the allocation on line \n2 creates a fresh location \u00a3x in the new . heap S2 = S1 .(\u00a3x .x) and adds x :Ref \u00a3x to the type environment. \nWe use the symbol . to construct unordered sets of heap bindings. To exploit the precision of dependent \ntypes, we map locations to values rather than types (i.e., (\u00a3 .x) rather than (\u00a3 .Top)). When checking \nthe if-expression guard on line 3, the deference retrieves the initial value x from the heap S2, so as \na result of the tag-test, System !D adds Num(x) to the type environment G4 along the true-branch and \n\u00acNum(x) to G6 along the false-branch. In the true-branch, the subtraction on line 4 is well-typed because \nNum(x), and produces a number x4 that is stored in the heap S4 at location \u00a3x. In the false-branch, x \nis negated on line 6, producing a boolean x6 that is stored in the heap S6 at location \u00a3x. System !D \ncombines the branches by joining the heaps S4 and S6, producing S7 that describes the heap no matter \nwhich branch is taken. The dereference on line 8 retrieves x ' , a value of type {ite Num(x) Num(.) Bool(.)}, \nas required by the return type annotation. In this way, System !D syntactically tracks strong updates \nto the heap, while reducing subtyping obligations to impli\u00adcation queries in an ordinary, pure re.nement \nlogic [9] that does not model imperative updates.  2.3 Simple Objects JavaScript s objects exhibit several \ninteresting semantic properties. Consider the following object initialized with a single key (also known \nas .eld or property). We assume that assert is a pre-de.ned function that aborts when its ar\u00adgument is \nfalsy; JavaScript does not provide such a function as built-in, but it is trivial to de.ne. var x = {\"f\": \n1}; assert (x.f == 1 &#38;&#38; x.g == undefined); x.g = 2; delete x.f; assert (x.g == 2 &#38;&#38; \nx.f == undefined); x.f.g; // raises exception var k = \"h\"; x[k] = 3; assert (x[k] == 3); Notice that \nwhen retrieving the non-existent g key from x, JavaScript returns undefined as opposed to raising an \nexception. Attempting to retrieve a key from undefined, or null, however, does raise an exception. Keys \ncan be added or removed to objects, and can even be arbitrary dynamically-computed values, not just string \nliterals, that are converted to strings if necessary. Dynamic keys are pervasive objects are commonly \nused as hash tables with unknown sets of keys but they are quite challenging to track inside a static \ntype system. Nested Re.nements. To support dynamic keys, we adopt the System D primitives [9] for (functional) \ndictionary oper\u00ad ations, shown in the .rst four lines of the .le objects.dref (Figure 5). The primitive \nfunction application get dk re\u00adtrieves the key k from dictionary d, where sel(d, k) de\u00adscribes the exact \nbinding as a value in the re.nement logic; set dky produces a new dictionary that extends d with a binding \nfor k, shadowing previous bindings, if any, where upd(d, k, y) describes the new dictionary; del dk pro\u00adduces \na new dictionary with a binding removed, using the logical symbol bot (distinct from all source-level \nvalues) to denote its absence; and mem dk indicates the presence or absence of a binding, where we write \nthe abbreviation has(d, k)=.sel(d, k).bot. The key innovation of nested re.nements in System D allows \nsyntactic type terms U (like function types) to be written within re.nement formulas using an uninterpreted \nhas-type predicate x :: U, while staying within the de\u00adcidable McCarthy theory of arrays [27]. The has-type \npred\u00ad icate allows System D to describe dictionaries that map dynamic keys to arbitrary values. For example, \nwe write {Dict(.).sel(., k) :: Bool .Bool} to describe a dictio\u00adnary d with key k that binds a boolean-to-boolean \nfunction, and {. = upd(d, g , 4)} to describe a dictionary d ' that is just like d but with an additional \nbinding. Prior approaches such as [5] were limited to dynamic keys that store .rst-order (non-function) \nvalues. We refer the reader to [9] for the tech\u00ad nical development of nested re.nements. Mutability and \nDynamic Keys. The combination of nested re.nements and strong updates allows us to precisely track objects \nwith dynamic keys despite the presence of impera\u00adtive updates. Consider the desugaring of our example \nabove; we omit the assertions for clarity. 1 let _x = ref (ref {\"f\": 1}) in 2 _x := set (deref (deref \n_x)) \"g\" 2; 3 _x := del (deref (deref _x)) \"f\"; 4 let_k =\"h\"in 5 _x := set (deref (deref _x)) 6 (coerceToStr \n(deref _k)) 3; The allocation on line 1 adds three bindings to the type environment d:{. = upd(empty, \nf , 1)}, ptr :Ref \u00a3, '' and obj :Ref \u00a3 , where \u00a3 and \u00a3 are fresh locations . ' and produces the heap \nS1 =(\u00a3 .ptr).(\u00a3 .d). No\u00adtice that the dictionary is stored via an additional level of indirection to \nfacilitate the encoding of side-effecting JavaScript object operations. The object extension on line \n' 2 adds d :{. =upd(d, g , 2)} to the type environment and .' strongly updates the heap to S2 =(\u00a3 .ptr).(\u00a3 \n.d '). The deletion on line 3 and the extension on line 5 (through a dynamic key) have similar effects \non the static heap, thereby statically verifying the assertions. 2.4 Function Types In order to fully \nunderstand the challenges of JavaScript objects, we must pause to take a closer look at function types. \nThe function types we have seen so far for negate and the primitives in basics.dref have not mentioned \n val set :: (* d:Dict . k :Str . y :Top .{. = upd(d, k, y)} *) val del :: (* d:Dict . k :Str .{. = upd(d, \nk, bot)} *) val has :: (* d:Dict . k :Str .{. i. has(d, k)} *) val get :: (* d:Dict . k :Str .{ite has(d, \nk)(. = sel(d, k)) (. = undefined)} *) val setPropObj :: (* (x:Ref ,k :Str,y :Top)/(x ..d:Dict,x..). \n{. = y}/(x ..d ' :{. = upd(d, k, y)},x..) *) val delPropObj :: (* (x:Ref ,k :Str)/(x ..d:Dict,x..) . \nBool /(x ..d ' :{. = upd(d, k, bot)},x..) *) val hasPropObj :: (* (x:Ref ,k :Str)/(x ..d:Dict,x..). {. \ni. ObjHas(d, k, cur,x.)}/same *) val getPropObj :: (* (x:Ref ,k :Str)/(x ..d:Dict,x..) .{ite ObjHas(d, \nk, cur,x.)(. = ObjSel(d, k, cur,x.)) (. = undefined)}/same *) val getIdxArr :: (* .A. (x:Ref ,i:Int)/(x \n..a:Arr(A),x..) .{ite \u00acpacked(a)(. ::A .Undef (.)) (ite (0 = i < len(a)) (. ::A)(Undef (.)))}/same *) \nval getLenArr :: (* .A. (x:Ref ,k :{. = length })/(x ..a:Arr(A),x..) .{ite packed(a)(. = len(a)) Int(.)}/same \n*) val getPropArr :: (* .A. (x:Ref ,k :{Str(.).. . length })/(x ..a:Arr(A),x..) .{ite HeapHas(H, x, k.)(. \n= HeapSel(H, .undefined)}/same x, k)) (. = *) val getElem :: (and (type getPropObj) (type getIdxArr) \n(type getLenArr) (type getPropArr)) val setIdxArr :: (* .A. (x:Ref ,i:Int,y :A)/(x ..a:Arr(A),x..) .{. \n= y}/(x ..a ' :{. ::Arr(A).arrSet(., a, i)},x..) *) Figure 5. Excerpt from objects.dref heaps, because \ntheir inputs and outputs are scalar values. However, JavaScript objects are reference values, and are \npassed to and returned from functions through the heap. Thus, to account for heaps and side-effects, \na System !D function type has the following form. .[A; L; H] x1 :T1 /S 1 .x2 :T2 /S 2 This type describes \na function that, given an argument x1 of type T1 in a calling context that satis.es the input heap type \n S1, produces an output value x2 of type T2 and a modi.ed heap type S 2. A function type can be parameterized \nby se\u00adquences of type variables A, location variables L, and heap variables H. A heap type S is like \na heap environment S but maps locations to binder-type pairs rather than values (e.g., (\u00a3 .y :T ) rather \nthan (\u00a3 .v)); the binders name the values stored in the heap before and after a function call. The binder \nx1 and all of the binders in the input heap S 1 are in scope in the output world x2 :T2 /S 2. Intuitively, \na world describes a tuple where every component except the .rst resides in a heap. We often omit binders \nwhen they are not referred to. To match the structure of function types, function applications must instantiate \ntype, location, and heap variables. However, our implementation infers instantiations in almost all cases \nusing standard local type inference techniques (\u00a7 6). When we write DJS examples in the sequel, we omit \ninstantiations at applications wherever our current implementation infers them. We sweeten function type \nsyntax with some sugar: When used as an output heap, the token same refers to the sequence of locations \nin the corresponding input heap, where each binding records that the .nal value is exactly equal to the \ninitial value. In an input world, a reference binding x:Ref without a location introduces a location \nvariable L that is quanti.ed by the type, and x (a value of type Ref L) can be used as a location in \nheaps to refer to this variable L. Further, the dotted variable x.introduces a location parameter, corresponding \nto the prototype of x.  A heap variable H is implicitly added to a function type when it contains none, \nand H is added to both the in\u00adput and output heaps; this variable corresponds to the frame from separation \nlogic [17]. In this case, the to\u00ad ken cur refers to H.  For example, compare the type for hasPropObj \n(Figure 5) followed by its expansion. (x:Ref ,k :Str)/(x ..d:Dict,x..) .{. i. ObjHas(d, k, cur,x.)}/same \n.L, L ' , H. (x:Ref L, k :Str)/H .(L ..d:Dict,L '.) .{. i. ObjHas(d, k, H, L ')}/H .(L ..d ' :{. = d},L \n'.)  2.5 Prototype-Based Objects JavaScript sports a special form of inheritance, where each base object \nis equipped with a link to its prototype object. This link is set when the base object is created and \ncannot be changed or accessed by the program. When trying to retrieve a key k not stored in an object \nx itself, JavaScript transitively searches the prototype chain of x until it either .nds k or it reaches \nthe root of the object hierarchy without .nding k. The prototype chain does not play a role in the semantics \nof key update, addition, or deletion.1 For example, consider the initially empty object child created \nby the function beget (described in the sequel) with prototype object parent. The prototype of object \nliterals, like parent, is the object stored in Object.prototype (note that the prototype key of Object \nis not the same as its prototype object). Thus, all keys in parent and Object.prototype are transitively \naccessible via child. var parent = {\"last\": \" Doe\"}; var child = beget(parent); child.first = \"John\"; \nassert (child.first + child.last == \"John Doe\"); assert (\"last\" in child == true); assert (child.hasOwnProperty(\"last\") \n== false); The JavaScript operator k in x tests for the presence of k anywhere along the prototype chain \nof x, whereas the native function Object.prototype.hasOwnProperty tests only the own object itself. Keys \nroutinely resolve through pro\u00adtotypes, so a static type system must precisely track them. Unfortunately, \nwe cannot encode prototypes directly within the framework of re.nement types and strong update, as the \nsemantics of transitively traversing mutable and unbounded prototype hierarchies is beyond the reach \nof decidable, .rst\u00adorder reasoning. Shallow and Deep Heaps. We solve this problem by syn\u00adtactically reducing \nreasoning about prototype-based objects to the re.nement logic. Our key insight is to decompose the heap \ninto a shallow part, the bounded portion of the heap for which we have explicit locations, and a deep \npart, which is the potentially unbounded portion which we can represent by uninterpreted heap variables \nH. We explicitly track prototype links in the shallow heap by using bind\u00adings of the form (\u00a3 ..d, \u00a3 '.), \nwhere the prototype of the object at \u00a3 is stored at \u00a3 ' . We cannot track prototype links explicitly \nin the deep heap, so instead we summarize in\u00adformation about deep prototype chains by using the abstract \n(uninterpreted) heap predicate HeapHas(H, \u00a3, k) to encode the proposition that the object stored at location \n\u00a3 in H tran\u00adsitively has the key k, and the abstract (uninterpreted) heap function HeapSel(H, \u00a3, k) to \nrepresent the corresponding value retrieved by lookup. As an example, recall the child object and its \nprototype parent. Suppose that the prototype of parent is an un\u00adknown object grandpa, rather than Object.prototype \nas written. If child, parent, and grandpa are stored at locations \u00a31, \u00a32, and \u00a33 with underlying own \ndic\u00adtionary values d1, d2, and d3, then we write the heap {\u00a31 ..d1,\u00a32.,\u00a32 ..d2,\u00a33.,\u00a33 ..d3,\u00a34.,H} we \nuse set notation to abbreviate the concatenation of heap bindings 1 Many implementations expose the prototype \nof an object x with a non\u00adstandard x. proto property, and prototypes do affect key update in ES5. We \ndiscuss these issues further in \u00a77. with .. Despite not knowing what value is the prototype of grandpa, \nwe name its location \u00a34 that is somewhere in the deep part of the heap H. Key Membership and Lookup. \nWhen describing simple objects, we used the original System D primitives (mem and get) to desugar key \nmembership and lookup operations. But in fact, to account for the transitive semantics of key mem\u00adbership \nand lookup facilitated by prototype links, System !D uses new primitives hasPropObj and getPropObj de.ned \nin objects.dref (Figure 5). These primitives differ from their purely functional System D counterparts \nin two ways: each operation goes through a reference to a dictionary on the heap, and the abstract predicates \nObjHas and ObjSel are used in place of has and sel. These abstract predicates are de.ned over the disjoint \nunion of the shallow and deep heaps as follows and, intuitively, summarize whether an ob\u00adject transitively \nhas a key and, if so, the value it binds. ObjHas(d, k, H, x.)=.x, k) has(d, k).HeapHas(H, . . = ObjSel(d, \nk, H, x.)=.if has(d, k) then . = sel(d, k) else . = HeapSel(H, . x, k) Transitive Semantics via Unrolling. \nLet us return to the example of the child, parent and grandpa prototype chain to understand how unrolling \ncaptures the semantics of transitive lookup. The DJS key membership test on the left desugars to System \n!D on the right as follows. k in child hasPropObj (deref _child, deref _k) The result of the function \ncall has the following type. {. i. ObjHas(d1, k, {(e2 ..d2,e3.), (e3 ..d3,e4.),H},e2)} We expand this \ntype by unrolling ObjHas to the following. {. i. has(d1, k).has(d2, k).has(d3, k).HeapHas(H, e4, k)} \nThe .rst three disjuncts correspond to looking for k in the shallow heap, and the last is the uninterpreted \npredicate that summarizes whether k exists in the deep heap. Similarly, key lookup in DJS on the left \nis desugared as follows. child[k] getPropObj (deref _child, deref _k) We unroll the type of the System \n!D expression as follows. {if has(d1, k) then . = sel(d1, k) else if has(d2, k) then . = sel(d2, k) else \nif has(d3, k) then . = sel(d3, k) else ite HeapHas(H, e4, k)(. = HeapSel(H, e4, k)) Undef (.)}  Thus, \nour technique of decomposing the heap into shallow and deep parts, followed by heap unrolling, captures \nthe ex\u00adact semantics of prototype-based object operations modulo the unknown portion of the heap. Thus, \nSystem !D precisely tracks objects in the presence of mutation and prototypes. var __hasOwn = . /*: \n(this :Ref ,k :Str)/(this ..d:Dict, this.). {. i. has(d, k)}/same . ..A. (this :Ref ,i:Int)/(this ..a:Arr(A), \nthis.). {ite packed(a)(. i. 0 = i < len(a)) Bool(.)}/same . ..A. (this :Ref ,k :Str)/(this ..a:Arr(A), \nthis.). {. i. k = length }/same */ \"#extern\"; function Object() { ... }; Object.prototype = {\"hasOwnProperty\": \n__hasOwn, \"constructor\": Object, ... }; . var __push = /*: .A. (this :Ref ,x:A)/(this ..a:Arr(A), this.) \n' . . Int /(this ..a :{. ::Arr(A).arrSize(., a, 1)}, this.) */ \"#extern\"; . var __pop = /*: .A. (this \n:Ref ,x:A)/(this ..a:Arr(A), this.) .{ite packed(a)(. ::A)(. ::A .Undef (.))} ' . /(this ..a :{. ::Arr(A).arrSize(., \na, -1)}, this.) */ \"#extern\"; function Array() { ... }; Array.prototype = {\"push\": __push, \"pop\": __pop, \n\"constructor\": Array, ... }; Figure 6. Excerpt from prelude.js, which desugars to the prelude.dref .le \nin the standard prelude Additional Primitives. The new update and deletion prim\u00aditives setPropObj and \ndelPropObj (Figure 5) affect only the own object, since the prototype chain does not partici\u00adpate in \nthe semantics. We model native JavaScript functions like Object.prototype.hasOwnProperty with type an\u00adnotations \nin the .le prelude.js (Figure 6). Notice that the function type for objects (the .rst in the intersection) \nchecks only the own object for the given key. Constructors. JavaScript provides the expression form new \nFoo(args) as a second way of constructing objects, in addition to object literals whose prototypes are \nset to Object.prototype. The semantics are straightforward, but quite different than the traditional \nnew syntax suggests. Here, if Foo is any function (object), then a fresh, empty ob\u00adject is created with \nprototype object Foo.prototype, and Foo is called with the new object bound to this (along with the remaining \narguments) to .nish its initialization. We desugar constructors and new with standard objects and functions \n(following .JS [21]) without adding any special System !D constructs or primitive functions. Inheritance. \nSeveral inheritance relationships, including ones that simulate traditional classes, can be encoded with \nthe construction mechanism, as shown in the popular book JavaScript: The Good Parts [10]. Here, we examine \nthe pro\u00adtotypal pattern, a minimal abstraction which wraps construc\u00adtion to avoid the unusual syntax \nand semantics that leads to common errors; we discuss the rest in \u00a7 6. The function beget (the basis \nfor Object.create in ES5) returns a fresh empty object with prototype o. 1 /*: .L. o:Ref /(o ..d:Dict,o..) \n 2 . Ref L/(L ..{. = empty},o.).(o .same) */ 3 function beget(o) { 4 /*: #ctor this :Ref .{. = this} \n*/ 5 function F() { return this; }; 6 F.prototype = o; 7 return new /*:L*/ F(); } The #ctor on line \n4 instructs desugaring to: initialize the function object with a prototype key that stores an empty object \nliteral (since it will be called as a constructor); and expand the type annotation as follows to require \nthat this initially be empty, as is common for all constructors. . this :Ref /(this ..{. = empty}, this.).{. \n= this}/same The assignment on line 6 strongly updates Foo.prototype (overwriting its initial empty \nobject) with the argument o. Thus, the object constructed (at location L) on line 7 has prototype o, \nso beget has the ascribed type. In most cases, new can be used without a location annotation and a fresh \none is chosen. In this case, we annotate line 7 with L (from the type of beget), which our implementation \ndoes not infer because there is no input corresponding to L. 2.6 Arrays The other workhorse data structure \nof JavaScript is the ar\u00adray, which is really just an object with integer indices con\u00adverted to ordinary \nstring keys. However, arrays pose several tricky challenges as they are commonly used both as .nite tuples \nas well as unbounded collections. var arr = [17, \"hi\", true]; arr[3] = 3; arr.push(4); assert (arr.length \n== 5 &#38;&#38; arr[5] == undefined);  As for any object, retrieving a non-existent key returns undefined \nrather than raising an out-of-bounds excep\u00adtion. Like other objects, arrays are extensible simply by \nwriting past the end. Array literal objects have proto\u00adtype Array.prototype, which includes a push (resp. \npop) function for adding an element to (resp. removing an ele\u00adment from) the end of an array. Loops are \nused to iterate over arrays of unknown size. But since lookups may return undefined, it is important \nto track when an access is in-bounds. JavaScript bestows upon arrays an unusual length property, rather \nthan a method, to help. Reading it returns the largest integer key of the array, which is not necessarily \nits size because it may contain holes or even non-integer keys. Furthermore, assigning a number n to \nthe length of an array either truncates it if n is less than its current length, or extends it (by padding \nwith holes) if it is greater. Despite the unusual semantics, programmers commonly use arrays as if they \nare traditional packed arrays with integer indices zero to size minus one. The type system must reconcile \nthis discrepancy. Array Types. We introduce a new syntactic type term Arr(T ) and maintain the following \nfour properties for ev\u00adery value a that satis.es the has-type predicate a ::Arr(T ). We refer to strings \nthat do not coerce to integers as safe, and we use an uninterpreted predicate safe to describe such strings \n(e.g., safe( foo ) whereas \u00acsafe( 17 )). (A1) a contains the special length key. (A2) All other own \nkeys of a are (strings that coerce to) integers. (A3) For all integers i, either a maps the key i to \na value of type T , or it has no binding for i. (A4) All inherited keys of a are safe (i.e., non-integer) \nstrings. An array can have arbitrary objects in its prototype chain, so to ensure (A4), we require that \nall non-array objects bind only safe strings. This sharp distinction between between ar\u00adray objects (that \nbind integer keys) and non-array objects (that bind safe string keys) allows System !D to avoid rea\u00adsoning \nabout string coercions, and does not signi.cantly limit expressiveness because, in our experience, programs \ntypically conform to this division anyway. To enforce this restriction, the type for keys manipulated \nby primitives in objects.dref and prelude.js is actually SafeStr, rather . than Str as shown in Figure \n5 and Figure 6, where SafeStr = {Str(.).safe(.)}. We discuss an alternative approach in \u00a77 that allows \nnon-array objects to bind unsafe strings. Packed Arrays. Arrays a that additionally satisfy the unin\u00adterpreted \npredicate packed(a) enjoy the following property, where len(a) is an uninterpreted function symbol. \n(A5) For all integers i, if i is between zero and len(a) minus one, then a maps i to a value of type \nT . Otherwise, a has no binding for i. Tuple Arrays. Using additional predicates, System !D gives precise \ntypes to array literals, which are often used as .nite tuples in idiomatic code. For example, we can \nde\u00adscribe pairs as follows: (Int, Int)=.{. ::Arr(Int).packed(.).len(.)= 2} (Bool, Str)=.{. ::Arr(Top).packed(.).len(.)= \n2 .Str(sel(., 0)).Bool(sel(., 1))} Thus, the technique of nested re.nements allows us to smoothly reason \nabout arrays both as packed homogeneous collections as well as heterogeneous tuples. Array Primitives. \nWe de.ne several array-manipulating primitives in objects.dref (some of which we show in Figure 5) that \nmaintain and use the array invariants above. For key lookup on arrays, we de.ne three primi\u00adtives: getIdxArr \nlooks for the integer key i on the own object a and ignores the prototype chain of a because (A4) guarantees \nthat a will not inherit i, and returns a value sub\u00adject to the properties (A3) and (A5) that govern its \ninteger key bindings; getLenArr handles the special case when the string key k is length , which (A1) \nguarantees is bound by a, and returns the the true length of the array only if it is packed; and getPropArr \ndeals with all other (safe) string keys k by reading from the prototype chain of the array (re-using \nthe heap unrolling mechanism) ignoring its own bindings because of (A2). For array updates, we de.ne \nsetIdxArr that uses the fol\u00adlowing macros to preserve packedness (A5) when possible. arrSet(a ' , a, \ni)=.if 0 = i < len(a)then arrSize(a ' , a, 0)else if i = len(a)then arrSize(a ' , a, 1)else true arrSize(a \n' , a, n)=.packed(a). (packed(a ').len(a ')= len(a)+n) In particular, the updated array a ' is packed \nif: (1) the orig\u00adinal array a is packed; and (2) the updated index i is either ' within the bounds of \na (in which case, the length of a is the same as a) or just past the end (so the length of a ' is one \ngreater than a). In similar fashion, we specify the remaining primitives for update and deletion to maintain \nthe array in\u00advariants, and the ones for key membership to use them, but we do not show them in Figure \n5. In prelude.js (Figure 6), we use precise types to model the native push and pop methods of Array.prototype \n(which maintain packedness, as above), as well as the be\u00adhavior of Object.prototype.hasOwnProperty on \narrays (the last two cases of the intersection type). Thus, the pre\u00adcise dependent types we ascribe to \narray-manipulating oper\u00adations maintain invariants (A1) through (A5) and allow DJS to precisely track \narray operations. Desugaring. It may seem that we need to use separate primitive functions for array \nand non-array object opera\u00adtions, even though they are syntactically indistinguishable in JavaScript. \nNevertheless, we are able to desugar DJS based purely on expression syntax (and not type information) \nby unifying key lookup within a single primitive getElem and giving it a type that is the intersection \nof the (three) array lookup primitives and the (one) non-array lookup primitive getPropObj. We de.ne \ngetElem in Figure 5, where we specify the intersection type using and and type as syntac\u00adtic sugar to \nrefer to the previous type annotations. We de\u00ad.ne similar uni.ed primitives for setElem, hasElem, and \ndelElem (not shown in Figure 5). Desugaring uniformly translates object operations to these uni.ed general \nprimi\u00adtives, and type checking of function calls ensures that the appropriate cases of the intersection \ntype apply.  2.7 Collections As discussed in \u00a72.2, strong updates are sound only for ref\u00ad erences that \npoint to exactly one object, which is far too re\u00adstrictive as real programs manipulate collections of \nobjects. In this section, we describe weak references in DJS to refer to multiple objects, a facility \nthat enables programming with arrays of mutable objects as well as recursive types. Weak References. \nIn the following example, we iterate over an array of passenger objects and compute the sum of their \nweights; we use a default value max_weight when a passenger does not list his weight (ignore the unfamiliar \nannotations for now). 1 /*: (e pass .frzn). same */ 2 for (i=0; i < passengers.length; i++) { 3 var \np = passengers[i]; 4 /*: #thaw p */ 5 if (p.weight) { sum += p.weight; } 6 else { sum += max_weight; \n} 7 /*: #freeze p */ 8 } We could describe the array passengers with the type Ref \u00a3 for a location \n\u00a3. However, this type is not very useful as it denotes an array of references to a single object. Weak \nLocations. To refer to an arbitrary number (zero or more) objects of the same type, we adopt the Alias \nTypes [32] solution, which categorizes some locations as weak to describe an arbitrary number of locations \nthat satisfy the same type, and syntactically ensures that weak locations are weakly updated. We introduce \na new kind of heap binding (\u00a3 ..T,\u00a3 '.), where \u00a3 is a weak location, all objects that might reside there \n' satisfy T , and \u00a3 is the strong location of the prototype of all objects that reside at location \u00a3 \n. There is no heap binder for weak locations since there is not a single value to describe. In our example, \nwe can use (\u00a3 pass ..Tpass ,\u00a3op.)to describe passenger objects, where \u00a3op is the location of Object.prototype \nand Tpass is the dictionary type {Dict(.).has(., weight ).Num(sel(., weight ))}. If we assign the type \n{. ::Arr(Ref \u00a3 pass ).packed(.)}, to passengers, then p has type Ref \u00a3 pass , and thus each (desugared) \nuse of p is a dictionary of type Tpass. This type is quite unsatisfying, however, because the conditional \nestablishes that along the then-branch, p does possess the key and therefore should be assigned the more \nprecise type {Num(sel(d, weight ))}. Thaw and Freeze. To solve this problem, we adopt a mechanism found \nin derivatives of Alias Types (e.g., [2, 12, 15, 31]) that allows a weak location to be temporarily treated \nas strong. A weak location \u00a3 is said to be frozen if all references Ref \u00a3 use the location only at its \nweak (invari\u00adant) type. The type system can thaw a location, producing a strong reference Ref \u00a3k (with \na fresh name) that can be used to strongly update the type of the cell. While a location is thawed, the \ntype system prohibits the use of weak references to the location, and does not allow further thaw operations. \nWhen the thawed (strong) reference is no longer needed, the type system checks that the original type \nhas been restored, re-freezes the location, and discards the thawed location. Soundness of the approach \ndepends on the invariant that each weak location has at most one corresponding thawed location at a time. \n In our example, we do not need to temporarily violate the type of p, but the thaw/freeze mechanism does \nhelp us relate the two accesses to p. The thaw state annotation above the loop declares that before each \niteration of the loop (including the .rst one), the location \u00a3 pass must be frozen. The thaw annotation \non line 4 changes the type of p to a strong reference to a fresh thawed location \u00a31, which stores a particular \ndictionary on the heap (named with a binder) that is retrieved by both subsequent uses of p. Thus, we \ncan relate the key membership test to the lookup, and track that p.weight produces a number. The freeze \nannotation on line 7 restores the invariant required before the next iteration. We describe this technique \nfurther in \u00a74. Recursive Types. We reuse the weak location mecha\u00adnism to describe recursive data structures. \nConsider the following adapted from the SunSpider [34] benchmark access-binary-trees.js, annotated in \nDJS. 1 /*: #define Ttn { i :Num, l , r :Ref e tn} */ 2 /*: #weak (e tn ..Ttn,etnp.) */ 3 /*: #ctor \n(this :Ref , left, right :Ref e tn, item :Num) 4 /(e tn .frzn). Ref e tn /same */ 5 function TreeNode(left, \nright, item) { 6 this.l = left; this.r = right; this.i = item; 7 /*: #freeze this */ 8 return this; \n 9 } 10 /*: this :Ref e tn . Num */ 11 TreeNode.prototype.itemCheck = function f() { 12 // thaw/freeze \nannotations inferred 13 if (this.l == null) return this.item; 14 else { return this.i 15 + f.apply(this.l) \n 16 -f.apply(this.r); } 17 } The source-level macro on line 1 introduces Ttn to abbre\u00adviate the type \nof TreeNodes, using traditional record type syntax instead of the underlying McCarthy operators. Line \n2 de.nes the weak location for TreeNodes, using the pre\u00addictable location \u00a3tnp created by desugaring \nfor the object TreeNode.prototype. The constructor annotation itself declares that the return type is \na reference to one of these recursive objects, which System !D veri.es by checking that on line 6 the \nappropriate .elds are added to the strong, initially-empty object this before it is frozen and returned. \n Recursive Traversal. There are two differences in the itemCheck function above compared to the original \nver\u00adsion, which cannot be type checked in DJS. First, we name the function being de.ned (notice the f \non line 11), a JavaScript facility for recursive de.nitions. Second, we write f.apply(this.r) instead \nof this.r.itemCheck() as in the original, where the native JavaScript function apply al\u00adlows a caller \nto explicitly supply a receiver argument. The trouble with the original call is that it goes through \nthe heap (in particular, the prototype chain of this) to resolve the re\u00adcursive function being de.ned. \nThis function will be stored in a strong object, and we have no facility (e.g., mu-types) for strong \nobjects with recursive types; our only mechanism is for weak objects. If we write f.apply(this.r), how\u00adever, \nthe recursive function f is syntactically manifest, and we can translate the de.nition with a call to \nthe standard fix primitive (Figure 2). In \u00a75, we describe how we handle a limited form of apply that \nis suf.cient for our idiomatic recursive de.nitions in DJS. We expect that we can add a more powerful \nmechanism for recursive types that supports the original code as written, but we leave this to future \nwork.  2.8 Rest of the Paper We have now completed our tour of Dependent JavaScript. Next, we formally \nde.ne the syntax of System !D in \u00a73 and the type system in \u00a7 4. In, \u00a7 5, we present the syntax of DJS \nand its desugaring to System !D. We discuss our implementation and results in \u00a76, directions for future \nwork in \u00a7 7, and related work in \u00a7 8. Additional details may be found in an accompanying technical report \n[7]. 3. Syntax and Semantics of System !D We now introduce the formal syntax of values, expressions, \nand types of System !D, de.ned in Figure 7. Values. Values v include variables x, constants c, lamb\u00addas \n.x. e, (functional) dictionaries v1 ++ v2 . v3, and run-time heap locations r. The set of constants c \nincludes base values (numbers, booleans, strings, the empty dictio\u00adnary {}, null, undefined, NaN, etc.) \nand the primitive functions from basics.dref and objects.dref (typeof, get, getElem, etc.). We use tuple \nsyntax (v0, ..., vn) as sugar for the dictionary with .elds 0 through n bound to the component values. \nLogical values w are all values and applications of primitive function symbols F , such as addi\u00adtion \n+and dictionary selection sel, to logical values. Expressions. We use an A-normal expression syntax so \nthat we need only de.ne substitution of values (not arbi\u00adtrary expressions) into types. We use a more \ngeneral syntax for examples throughout this paper, and our implementation desugars expressions into A-normal \nform. Expressions e in\u00adclude values, function application, if-expressions, and let\u00adbindings. The ascription \nform e as T allows source-level type annotations. Since function types will be parameterized by type, \nlocation, and heap variables, the syntax of function application requires that these be instantiated. \nReference op\u00aderations include reference allocation, dereference, and up\u00addate, and the run-time semantics \nmaintains a separate heap ' that maps locations to values. The expression newobj \u00a3vv stores the value \nv at a fresh location r where the name \u00a3 is a compile-time abstraction of a set of run-time loca\u00adtion \nnames that includes r with its prototype link set to v ' , which should be a location. The thaw \u00a3v operation \ncon\u00adverts a weak reference to a strong strong one; freeze \u00a3.v converts a strong reference to a weak one, \nwhere thaw state . is used by the type system for bookkeeping. The operational semantics is standard, \nbased on .JS with minor differences. For example, we make prototype links manifest in the syntax of heaps \n(to facilitate heap unrolling in the type system), whereas .JS stores them inside objects in a distinguished \n proto .eld. We refer the reader to [21] for the full details. Types and Formulas. Values in System \n!D are described by re.nement types of the form {x .p} where x may appear free in the formula p and existential \ntypes .x:T. S where x may appear free in S. Rather than introduce additional syn\u00adtactic categories, we \nassume, by convention, that existential types do not appear in source programs; they are created only \nduring type checking in a controlled fashion that does not preclude algorithmic type checking [25]. When \nthe choice of re.nement binder does not matter, we write {p} as short\u00adhand for {. .p}. The language of \nre.nement formulas includes predicates P , such as equality and the dictionary predicate has, and the \nusual logical connectives. Similar to the syntax for expres\u00adsion tuples, we use (T1, ..., Tn) as sugar \nfor the dictio\u00adnary type with .elds 0 through n with the correspond\u00ading types. As in System D, we use \nan uninterpreted has\u00adtype predicate w :: U in formulas to describe values that have complex types, represented \nby type terms U, which in\u00adcludes function types, type variables, null, reference, and ar\u00adray types. A \nreference type names a strong or weak location in the heap, where a strong location \u00a3 is either a constant \na or a variable L and a weak location \u00a3 is a constant a . We discussed function types in \u00a72.4; now we \nuse the metavari\u00ad able W to range over worlds. A world x:T /S describes the binders and types of a tuple \nof values, where every compo\u00adnent except the .rst (x of type T ) resides in the heap S . Heap Types. \nA heap type S is an unordered set of heap variables H and heap bindings h concatenated with the . operator. \nTo simplify the presentation, we syntactically require that each heap has exactly one heap variable, \nso we write a heap type as the pair (H, h ), where H is the deep part for which we have no information \nand h is the shallow part for which have precise location information. The heap binding (\u00a3 . x:T ) represents \nthe fact that the value at location \u00a3 has type T ; the binder x refers to this value in the types of \nother heap bindings. The binding (\u00a3 ..x:T,\u00a3 '.) Values v ::= x i c i v1 ++ v2 .v3 i .x. e i r Expressions \ne ::= v i[T ; e; S ] v1 v2 i if v then e1 else e2 i let x = e1 in e2 i e as T i ref ev i deref v i v1 \n:=i newobj evv ' i e.v i thaw ev v2 freeze Types S, T ::= {x ip} i.x:T.S Formulas p, q ::= P (w)i w ::U \ni HeapHas(H, e, w)i p .q i p .q i\u00acp Logical Values w ::= v i F (w)i HeapSel(H, e, w) Syntactic Type Terms \nU ::= .[A; L; H] W1 .W2 i A i Null i Ref e i Ref e i Arr(T )  Heap Bindings h ::= (e .x:T )i(e ..x:T,e \n'.) i (e ..)i h1 .h 2 i\u00d8 Thaw States . ::= frzn i thwd e Worlds W ::= x:T /S x, y, z . Identi.ers A, \nB . TypeVariables  Heaps S ::= (H, h ) a . LocationConstants H . HeapVariables Strong Locations e ::= \na i Lr . DynamicHeapLocations L . LocationVariables  Weak Locations e ::= a F . LogicalFunctionSymbols \nP . LogicalPredicateSymbols c . ValueConstants .{ true, false, null, undefined, 1, 2, hanna , (==), !, \ntypeof, get, getElem, fix } Figure 7. Syntax of System !D additionally records a prototype link \u00a3 ' . \nThe binding (\u00a3 ..)records the current thaw state of weak location \u00a3 , to help maintain the invariant \nthat it has at most one thawed location at a time. We abuse the notation (H, h 1). h2 to mean (H, h 1 \n.h 2). Uninterpreted Heap Symbols. To describe invariants about the deep part of a heap, System !D introduces \ntwo unin\u00adterpreted heap symbols. The predicate HeapHas(H, \u00a3, k)represents the fact that the chain of \nobjects in H start\u00ading with \u00a3 has the key k. Similarly, the function symbol HeapSel(H, \u00a3, k) refers to \nthe value retrieved when looking up key k in the heap H starting with \u00a3. 4. Type Checking In this section, \nwe discuss the well-formedness, typing, and subtyping relations of System !D. The type system reuses \nthe System D [9] subtyping algorithm to factor subtyping obli\u00ad gations between a .rst-order SMT solver \nand syntactic sub\u00adtyping rules. The novel technical developments here are: the formulation of .ow-sensitive \nheap types in a dependent set\u00adting; the use of uninterpreted heap symbols to regain preci\u00adsion in the \npresence of imperative, prototype-based objects; the encoding of array primitives to support idiomatic \nuse of JavaScript arrays; and the use of re.nement types to assign precise types to JavaScript operators. \nEnvironments. The type checking relations make use of type environments G and heap environments S. G \n::= \u00d8i G,x:T i G,p i G,A i G,L i G,H i G, (e ..T,e.) S ::= (H, h) h ::= \u00d8i h1 .h2 i(e .v)i(e ..v, e '.) \ni (e ..)  A type environment binding records either: the derived type for a variable; a formula p to \ntrack control .ow along a conditional branch; a polymorphic variable introduced by a function type; or \nthe description of a weak location (which does not change .ow-sensitively), namely, that every object \nstored at \u00a3 satis.es type T and has prototype link \u00a3. A heap environment is just like a heap type, except \na strong location \u00a3 binds the value v it stores (as opposed to the type of v). 4.1 Well-Formedness As \nusual in a re.nement type system, we de.ne well\u00adformedness relations (see [7]) that govern how values \nmay be used inside formulas. The key intuition is that formulas are boolean propositions and mention \nonly variables that are currently in scope. Locations in a heap type S must either be location constants \nor location variables bound by the type environment, and may not be bound multiple times. All heap binders \nmay refer to each other. Thus, the values in a heap can be regarded as a dependent tuple. For the input \nworld x1 :T1 /S 1 of a function type, the binder x1 and the binders in S 1 may appear in the output world \nW2. 4.2 Subtyping Several relations (see Figure 8 and [7]) comprise subtyping. Subtyping and Implication. \nAs in System D, subtyping on re.nement types reduces to implication of re.nement formu\u00adlas, which is \ndischarged by a combination of uninterpreted, .rst-order reasoning and syntactic subtyping. Our treatment \nof existential types follows the algorithmic (decidable) ap\u00adproach in [25]. In particular, when on the \nleft side of an obligation, the S-EXISTS rule adds the existential binding to the environment; there \nis no support for existentials on Subtyping G . T1 . T2 [S-REFINE] y fresh G . G{x i, p} . {x i p[y/x] \n.q[y/x] q} [S-EXISTS] G, x:T .G ..x:T S1 . S2 . S1 . S2 Syntactic Sub typ ing (selected rules) G .U1 \n<:U2 [U-ARRAY] [U-VAR] [U-STRONGREF] G .Arr(T )<:Arr(T ) G .A <:A G .Ref e <:Ref e [U-NULL] [U-WEAKREF] \nG .Null <:Ref e G .Ref e <:Ref e Figure 8. Subtyping for System !D Value Typing (selected rules) G; S \n.v :: T G(x)= S [T-CONST] x} [T-VAR] G; S .c :: ty(c) G; S .x :: {y iy = [T-FUN] U =.[A; L; H] x:T1 /S \n1 .W2 G .U HeapEnv(S 1)=(z :S, S1) G1 = G, A, L, H, x:T1,z :S G1;S1 .e :: T2 /S2 G1 .T2 /S2 . W2 G; S \n..x. e :: {y iy ::U} Figure 9. Value type checking for System !D the right. The way in which type checking \nintroduces exis\u00adtentials guarantees that they always appear on the left. References and Arrays. As in \nAlias Types [32], we en\u00ad force the invariant that distinct strong locations do not alias, so references \nto them are never related by subtyping. In con\u00adtrast, weak locations describe zero or more locations, \nand it is safe to treat null as a subtype of any weak location (U-NULL). That is, weak references are \nnullable but strong ones are not. Arrays are invariant in their type parameter (U-ARRAY), as usual, but \ncan be related with additional predi\u00adcates. For example, {. ::Arr(Int).len(.)=2} is a subtype of {. ::Arr(Int)}. \nHeaps. The heap subtyping judgement (de.ned in [7]) re\u00ad  lates two heap types (H1,h1) and (H2,h2) if: \n(1) the heaps agree on the deep part, that is, if H1 = H2; (2) the structure of the shallow parts h 1 \nand h 2 match modulo permutation; and (3) the heap bindings in h 1 and h 2, which can be thought of as \ndependent tuples, are related by subtyping.  4.3 Value Typing The value typing judgement G; S . v :: \nT (de.ned in Figure 9 and [7]) veri.es that the value v has type T in the given environments. Since values \ndo not produce any effects, this judgement does not produce an output heap environment. Each primitive \nconstant c has a type, denoted by ty(c), that is used by T-CONST. In our implementation, ty(c) is de.ned \nin the standard prelude .les (basics.dref, objects.dref, and prelude.dref). The standard T-VAR rule assigns \nsingleton types to variables. The rule T-FUN uses the procedure HeapEnv that takes a snapshot of the \ninput heap type S 1 by collecting all of its binders z :S to add to the type environment and producing \na heap environment S1 for type checking the body. Dually, the world satisfaction judgement G1 .T2 /S2 \n. W2 (de.ned in [7]) checks that the resulting type and heap environment T2 /S2 satis.es W2, modulo permutation \nof heap bindings.  4.4 Expression Typing The expression typing judgement G; S . e :: T /S ' (in Figure \n10 and [7]) veri.es that the evaluation of expression e ' produces a value of type T and a new heap \nenvironment S . ' We write U as shorthand for the type {. :: U}, and S = S for heap equality modulo \npermutation of bindings. Prenex Quanti.ed Types. The T-LET rule uses an existen\u00adtial to describe the \ntype T1 of the variable x that goes out of scope after the body expression is checked. Alternatively, \nthe more traditional approach (e.g., [9]) requires that the variable be eliminated (e.g., via subsumption), \nbut we use existentials because it simpli.es several other typing rules. So that existentials appear \nonly on the left side of subtyp\u00ading obligations, we ensure that the typing rules derive prenex quanti.ed \ntypes of the form .x:T. S, where all the types T and S are re.nement types, not existential types. In \nparticu\u00adlar, to combine the worlds of two branches, the Join opera\u00adtor (de.ned in [7]), rearranges existentials \nto ensure that the resulting world is in prenex form. For example, for a condi\u00adtional with guard b, the \njoin of (.x1 :T1. Top /(\u00a3 .x1)) and (.x2 :T2. Top /(\u00a3 .x2)) is (.y :T12. Top /(\u00a3 .y)) where . T12 ={if \nb then T1(.) else T2(.)}. Imperative Operations. We use two kinds of reference cells in System !D: simple \nreferences that store base val\u00adues and functions without prototype links, and object ref\u00aderences that \nstore dictionaries paired with prototype links. We require that all imperative operations go through \nstrong locations. We do not need weak, simple locations since they cannot appear in DJS programs and \nthey are not needed for desugaring; and we do not need weak, object locations be\u00adcause we can use our \nthawing mechanism instead. Three rules manipulate simple references. To check the reference allocation \nref \u00a3v, the rule T-REF ensures that \u00a3 is not already bound in the heap, and then adds a binding that \nrecords exactly the value being stored. The rule T-DEREF checks that the given value is a reference to \na simple loca\u00adtion, and then retrieves the stored value; this is the imperative analog to the sel.fying \nT-VAR rule. The rule T-SETREF strongly updates a simple location. The rule T-NEWOBJ stores the dictionary \nv1 in the heap at location \u00a31 along with a prototype link to the location \u00a32 that v2 refers to. Although \nno typing rules manipulate object locations, several primitives (getElem, setElem, etc.) do. Expression \nTyping (selected rules) G; S .e :: T /S ' G; S .v :: T G; S .e1 :: T1 /S1 G,x:T1;S1 .e2 :: T2 /S2 [T-VAL] \n[T-LET] G; S .v :: T /S G;S .let x = e1 in e2 :: .x:T1.T2 /S2 G; S .v :: S G, truthy(v);S .e1 :: T1 /S1 \nG, falsy(v);S .e2 :: T2 /S2 T /S ' = Join(v, T1 /S1,T2 /S2) [T-IF] G; S .if v then e1 else e2 :: T /S \n' e . dom(S) G; S .v :: T S ' = S .(e .v) G; S .v :: Ref e S = S0 .(e .v ') [T-REF] [T-DEREF] G; S .ref \nev :: Ref e/S ' G; S . deref v :: {y iy = v '}/S G; S .(v1,v2):: (Ref e, T ) e1 . dom(S) G; S .(v1,v2):: \n(Dict, Ref e2) ' '' S = S0 .(e .v) S = S0 .(e .v2) S = S0 .(e2 ..v ,e3.) S = S .(e1 ..v1,e2.) [T-SETREF] \n[T-NEWOBJ] G; S .v1 := v2 :: {x ix = v2}/S ' G; S .newobj e1 v1 v2 :: Ref e1 /S ' G; S .v1 :: .[A; L; \nH] W1 .W2 G; S .v2 :: T2 G .[T /A] G .[m/M] G .[S /H] ' ''' ' W2 = Freshen(W2)(W1,W2 )= Unroll(HInst(LInst(TInst((W1,W2), \nA, T ), L, e),H, S )) ' ' ' '''' G .T2 /S . W1; pW1 = x:T11 /S 11 p = p[v2/x] pW2 = x :T12 /S 12 HeapEnv(S \n12)=(y :S, S12) [T-APP] G; S .[T ; e; S ] v1 v2 :: .x ' :T12. .y :S. {z iz = x '}/S12 Figure 10. Expression \ntype checking for System !D Unroll(HeapHas((H, h ), e, k)) UnrollHas(H, = h, e, k) UnrollHas(H, =h, e, \nk) .' has(d, k).UnrollHas(H, . .HeapHas(H, e, k) h, e . .false Unroll(.(HeapSel((H, h ), e, k))) UnrollSel(., \nH, =h, e, k) ,k) if (e ..d:T,e '.). h else if e .. else (i.e., e =.) = UnrollSel(., H, h, e, k) . ' ite \nhas(d, k) .(sel(d, k)) (UnrollSel(., H, ,k)) h, e. if (e ..d:T,e '.). h . .(HeapSel(H, e, k)) else if \ne .. . ..(undefined) else (i.e., e =.) Figure 11. Heap unrolling Function Application. To type check \n[T ; m; S ] v1 v2, the T-APP rule must perform some heavy lifting. Three well\u00adformedness checks ensure \nthat the number of type, location, and heap parameters must match the number of type, loca\u00adtion, and \nheap variables of the function type, and that the sequence of locations \u00a3 contains no duplicates to ensure \nthe soundness of strong updates [32]. The procedure Freshen generates fresh binders for the output world \nso that bindings at different call sites do not collide. The substitution of parameters for polymorphic \nvariables proceeds in three steps. First, the type variables A inside has\u00adtype predicates are instantiated \nwith the type parameters T using the procedure TInst. Second, the location variables L are replaced with \nthe parameters \u00a3 by ordinary substitution. Third, the heap variables H are instantiated with heap pa\u00adrameters \nusing a procedure HInst that substitutes heap bind\u00adings for heap variables. As a result, HeapHas and \nHeapSel may refer to arbitrary heaps rather than just heap variables, as required. These pre-types (and \npre-formulas, pre-heaps, etc.) are expanded using the procedure Unroll, de.ned in Figure 11, that transitively \nfollows prototype links in heap bindings, precisely matching the semantics of object key membership and \nlookup. We write the location .for the root of the prototype hierarchy. We use the notation .(p) to refer \nto a formula context ., a formula with a hole, .lled with p. At this point, the polymorphic variables \nhave been fully instantiated. Next, the argument type T2 and current heap S are checked to satisfy the \ninput world x:T11 /S 11. If so, the substitution p maps binders from the input heap S 11 to the corresponding \nones in the current heap S. The substitution is extended with a binding from x to the argument v2 and \napplied to the output world. Then, like in the T-FUN rule, we use HeapEnv to collect the bindings y :S \nin S 12 and convert it to a heap environment S12. Finally, the derived type uses existentials to describe \nthe values in the output world. Thaw and Freeze. To safely allow a weak, object location \u00a3 to be treated \ntemporarily as strong, System !D ensures that \u00a3 has at most one corresponding thawed location \u00a3 at a \ntime (if there is none, we say \u00a3 is frozen) by recording its thaw state either thwd \u00a3 or frzn. One interesting \naspect of our formulation is that, to facilitate idiomatic programming, we choose to allow the use of \npossibly-null references. Instead, to require that all references be provably non-null before use, we \ncan simply update the type signatures for object primitives. We omit the typing rules for thawing and \nfreezing from Figure 10; we refer the reader to [7] for more details. Location Polymorphism. To simplify \nthe presentation of System !D in this paper, we have limited location polymor\u00adphism in two ways. First, \nwe allow location variables L to refer only to strong locations. In [7], we describe how to add weak \nlocation polymorphism to function types and up\u00addate the typing rules appropriately. Second, we offer \nonly a single mechanism namely, universal quanti.cation to abstract over both simple locations as well \nas object lo\u00adcations. As a result, functions must be quanti.ed over all simple locations inserted by \ndesugaring (to model impera\u00adtive JavaScript variables), which clutters function types and, worse, requires \nexplicit declaration and instantiation of lo\u00adcations that are internal to the desugaring translation \nand not accessible in the original DJS program. Instead, in [7], we show how to use existential quanti.cation \nin the output types of functions to describe simple locations, and use uni\u00adversal quanti.cation in the \ninput types of functions only to describe object locations, which are visible in DJS.  4.5 Type Soundness \nMany standard stuck states are not stuck in JavaScript: a function can be applied with any number of \narguments; an operator can be used with any values because of implicit coercion; and, all property lookups \nsucceed (possibly pro\u00adducing undefined). Nonetheless, several (non-exceptional) stuck states remain: \napplying a non-function value; and re\u00adtrieving a property for a non-object value. System !D is de\u00adsigned \nto ensure that well-typed programs do not get stuck and can only fail with exceptions due to retrieving \na property from undefined or null. We can also provide the stronger guarantees that only bound keys are \nretrieved and only non\u00adnull objects are accessed (thus ruling out the possibility of null dereference \nexceptions) simply by changing the types of object primitives appropriately. We expect that System !D \nsatis.es progress and preser\u00advation theorems, but we have not yet proven them. The pro\u00adcess will likely \nbe tedious but not require new proof tech\u00adniques. Unlike System D, which introduced the problem\u00adatic \nnesting of syntactic types inside uninterpreted formulas, System !D does not introduce any new mechanisms \nin the re.nement logic. Furthermore, several variations of Alias Types [23, 32, 37], even in a dependent \nsetting [31], have been proven sound, and we expect to re-use their techniques to prove the soundness \nof System !D. 5. Desugaring DJS to System !D In Figure 12, we present a selection of the explicitly typed \nabstract syntax of DJS along with desugaring rules . e .= e that translate DJS expressions e to System \n!D expressions e. Most of the desugaring rules follow .JS [21] closely, so we limit our discussion to \nthe aspects most relevant to DJS; we refer the reader to [7] and their work for more details. We use \n. the metavariable I =[T ; m; S ] to range over instantiation parameters for function application. Instantiation \nparameters are usually inferred by the type checker (\u00a76). Desugaring (selected rules) . e .= e . c \n.= c [DS-CONST] . x .= deref x [DS-DEREF] . e1 = e2 .=.e1 .:= .e2 . [DS-SETREF] . var x = e; e ' .= let \nx = ref ax .e. in .e '. [DS-REF] . /*:I */ e1 [e2 ]. = [DS-GETELEM] /*:I */ getElem (.e1 ., .e2 .) . \n/*:I */ e1 [e2 ]= e3 .= [DS-SETELEM]/*:I */ setElem (.e1 ., .e2 ., .e3 .) . /*:I */ delete e1 [e2 ]. \n= [DS-DELELEM]/*:I */ delElem (.e1 ., .e2 .) . /*:I */ e2 in e1 .= [DS-HASELEM]/*:I */ hasElem (.e1 ., \n.e2 .) . /*:e */{ ek :ev }. = [DS-OBJLIT] newobj e {.ek0 ...ev0 . ++ .}(pro(Object)) . /*:e */[ e ]. \n= [DS-ARRLIT] newobj e { 0 ..e0 . ++ .}(pro(Array)) . /*:I */ e(e1 , ..., en ). = [DS-FUNCCALL]/*:I */ \n:.e.: (window, (.e1 ., ..., .en .)) . /*:I */ e[e '](e1 , ..., en ). = [DS-METHCALL] let obj =.e. in \nlet m = getElem (obj , .e '.) in /*:I */ :m: (obj , (.e1 ., ..., .en .)) . new /*:enew I */ e(e1 , ..., \nen ). = [DS-NEW] let foo =.e. in let obj = newobj enew {} (foo prototype ) in /*:I */ :foo:(obj , (.e1 \n., ..., .en .)) . /*:I */ e.apply(e1 , ..., en ). = [DS-APPLY]/*:I */ :.e.: (.e1 ., (.e2 ., ..., .en \n.)) Figure 12. Desugaring DJS to System !D The DS-CONST rule for constants, the three DS-*REF rules \nfor mutable variables, and the four DS-*ELEM rules for object and array operations are straightforward. \nObject Literals. In the rules DS-OBJLIT and DS-ARRLIT, we write pro(e)=.getProp (.e., prototype ) to \nset the prototypes of fresh object and array literals, translated to newobj which creates values with \nprototype links. Our implementation inserts a fresh location if none is provided. Function Application. \nThe last four rules in Figure 12 handle different kinds function calls in JavaScript. The rules DS-FUNCCALL \nand DS-METHCALL desugar direct calls and method calls , where :e:=.getElem (e, code ). Notice that non-receiver \narguments are packed into a single arguments tuple. In DS-FUNCCALL, we write window for the global object \nsupplied as the receiver for direct calls. The DS-NEW rule handles object construction by creating a \nfresh object with newobj whose prototype is set to the object in the constructor object s prototype .eld, \nand calls the function in the code .eld to .nish the initialization. JavaScript provides two native \nfunctions apply and call in Function.prototype that allow the caller to explicitly supply the receiver \nargument. We do not provide general support apply and call in DJS, because they require mech\u00adanisms beyond \nthe scope of our (already-large) type sys\u00adtem; for example, the latter accepts an arbitrary number of \narguments. The primary bene.t of (non-constructor) func\u00adtions as objects in JavaScript is that they inherit \napply and call from Function.prototype, but since we do not sup\u00adport them, we sacri.ce little expressiveness \nif the type sys\u00adtem treats every non-constructor function as a scalar func\u00adtion value, rather than an \nobject with the function stored in code . Furthermore, we can then support the lim\u00adited use of apply \nrequired for our recursive function idioms in \u00a7 2.7 using the rule DS-APPLY that syntactically looks \nfor apply and explicitly sets the receiver. Because the type systems prohibits (non-constructor) functions \nfrom be\u00ading used as objects, there is no danger that the apply be hijacked by overwriting the apply property. \nControl Operators. Throughout the paper, we wrote only JavaScript functions that have either a single \nreturn state\u00adment or a return statement along every control .ow path. In general, however, return statements \n as well as loop\u00ading constructs and other control operators can appear in arbitrary positions. In System \n!D, we handle the general case using break and label expressions, following .JS [21]. We omitted the \nformulation from our presentation for ease of exposition; see [7] for details. 6. Evaluation In this \nsection, we describe our implementation, the bench\u00admarks we have annotated and type checked so far that \ndemonstrate the expressiveness of DJS, and identify several ways for future work to improve the tool. \n 6.1 Implementation We have implemented a type checker for DJS, available at ravichugh.com/djs, that \nis currently approximately 6,600 (non-whitespace, non-comment) lines of OCaml code. We borrow the .JS \n[21] JavaScript parser, use their desugar\u00ad ing as a starting point for our own, and use the Z3 SMT solver \n[11] to discharge logical validity queries. We specify the System !D primitive functions in the .les \nbasics.dref and objects.dref, and JavaScript built-in functions like Object.prototype.hasOwnProperty \nin prelude.js (desugared to prelude.dref). These three .les comprise a standard prelude included with \nevery desugared DJS pro\u00adgram for type checking. Local Inference. Function de.nitions require explicit \ntype annotations, and we employ bidirectional type checking [29] techniques to infer types for local \nexpressions. At a function application, we infer missing type and location parameters by greedily matching \nthe types of arguments against any Adapted Benchmark Un Ann Queries Time JS: The Good Parts prototypal \n1836 731 2 pseudoclassical 1523 706 2 functional 1943 862 8 parts 1120 605 3 SunSpider string-fasta 1018 \n263 1 access-binary-trees 34 50 2389 23 access-nbody 129 201 4225 39 V8 splay 1736 571 1 Google Closure \nLibrary typeOf 15 31 1975 52 Other negate 99 2961 passengers 9 19 310 3 counter 1624 272 1 dispatch 48 \n2191 Totals 306 518 13424 137 Figure 13. Benchmarks (Un: LOC without annotations; Ann: LOC with annotations; \nQueries: Number of Z3 queries; Time: Running time in seconds) Arr(T ) and Ref L type terms in the the \ndeclared input type and input heap. Because these type terms are invariant in their parameters (recall \nthe U-ARRAY and U-STRONGREF rules from Figure 8), the greedy choice is always the right one. For a function \ntype with exactly one heap variable H (like all the ones we have encountered) and input heap type(H, \nh ), we infer the corresponding heap argument by simply collecting all locations in the current heap \nenvironment that do not match the explicit location bindings in h . In our benchmarks, we are able to \nomit most type and location arguments and all heap arguments. 6.2 Benchmarks To demonstrate the expressiveness \nof DJS, we have anno\u00adtated and checked several small examples inspired by JavaScript: The Good Parts \n[10], the Google Closure Li\u00ad brary [19], and the SunSpider [34] and V8 [20] benchmarks that exercise \na variety of invariants, besides those demon\u00adstrated by previous examples (e.g., negate, passengers, \netc.). We also ported the counter and dispatch examples from System D [9] to DJS to demonstrate the nesting \nof function types inside objects with dynamic keys. Figure 13 summarizes our results, where for each \nexample: Un is the number of (non-whitespace, non-comment) lines of code in the unannotated benchmark; \nAnn is the lines of code in the annotated DJS version (including comments because they contain annotations); \nTime is the running time rounded to the nearest second, tested on a 2.66GHz machine with 4GB of RAM running \nUbuntu; and Queries is the number of validity queries issued to Z3 during type checking. Expressiveness. \nWe highlight some of the features of DJS that our benchmarks leverage. Besides the prototypal pattern \ndiscussed in \u00a7 2.5, Crockford [10] presents three additional inheritance patterns using JavaScript s \nconstruction mecha\u00adnism. Each of these examples relies on the support for im\u00adperative, prototype-based \nobjects in DJS. The behavior of the typeOf function is like the typeof operator except that it returns \nthe more informative result null for null and array for arrays; the operator re\u00adturns object in both \ncases. The type speci.cation for typeOf depends on the ability to express intersections of function types \nin DJS, and verifying it requires control-.ow tracking in the presence of mutation as well as a precise \nspeci.cation for the native (ES5) function Array.isArray, which we model in prelude.js. The makeCumulative \nfunction in string-fasta.js it\u00aderates over an object with an unknown number of keys that all store integers, \nand sums them in place within the object. While iterating over the keys of the object, the function uses \na variable to store the key from the previous iteration, a sub\u00adtle invariant that DJS is able to express \nby describing the heap before and after each iteration. Compared to the orig\u00adinal version, we allow the \nbindings to store arbitrary values and use a tag-test to sum only the integer bindings. To spec\u00adify the \noriginal version requires universally quanti.ed for\u00admulas, which DJS avoids to retain decidable type \nchecking. The splay benchmark de.nes the following interesting tree node constructor. Rather than initializing \neach own object with null left and right subtrees, the constructor s prototype object stores the defaults. \nfunction Node(k,v) { this.k = k; this.v = v; } Node.prototype.left = null; Node.prototype.right = null; \nAfter construction, however, Nodes are often extended with explicit subtrees. Using the .exibility of \nre.nements, we as\u00adsign each Node a type with the predicate has(., left ). sel(., left ) :: Ref \u00a3 , where \n\u00a3 is the weak location that describes Nodes, to ensure that retrieving the left key produces another \nNode regardless of whether it is stored on the object or not (and similarly for right ). Our largest \nexample is access-nbody, which de.nes a constructor function NBodySystem that creates a container object \nto store an array of Body objects. The prototypes of both constructors are augmented with methods, and \nthe thaw/freeze mechanism is heavily used while iterating over the array of Body objects to read and \nwrite their .elds.  6.3 Annotation Burden As Figure 13 shows, our annotated benchmarks are approx\u00ad imately \n1.7 times as large (70% overhead) as their unanno\u00adtated versions on average. In our experience, a signi.cant \nmajority of the annotation burden is boilerplate unrelated to the interesting typing invariants that \nfall into the fol\u00adlowing .ve patterns. Our implementation includes prelim\u00adinary support for automatically \ninserting several common patterns of annotations by tracking a limited amount of type information during \ndesugaring (that require no changes to type checking). This effort has already signi.cantly reduced the \nannotation overhead, but there is plenty of room for fur\u00adther improvements in future work. Closures. \nIf a function refers to a variable from an outer scope, its heap type must explicitly list its location \nand type. In the following example, the desugarer uses the predictable locations api and ae when desugaring \npi and e, and the function type must contain the binding for api . var pi = 3.14, e = 2.718; /*: Top \n/(api .n:Num). Num /same */ function getPi() { return pi; } To ease this burden, we collect the free \nvariables in each function de.nition and automatically add the corresponding heap bindings that are missing. \nIn situations where we can\u00adnot insert a suitably precise type for a location, we allow the programmer \nto annotate a variable declaration vari = /*: T */ e and we propagate T to functions that refer to i. \nLoops. Because loops desugar to functions, they require a heap type annotation (like for arbitrary closures) \nto describe invariants that hold before and after every iteration. We infer heap types for basic patterns \nlike the following. /*: (ai .{Int(.). i = 0}).(asum .Num).(ans .Ref e).(e ..{. ::Arr(Num).packed(.)},e \n'.) */ for (i=0; i < ns.length; i++) { sum += ns[i]; } Thaw and Freeze. Every weak reference must .rst \nbe thawed before access, which quickly becomes burdensome. As a simple aid, we surround an access to \na weak refer\u00adence with thaw and freeze operations, which is suf.cient for simple cases involving reads \nand weak updates. For more complex invariants, like the relationship between accesses to a weak reference \n(as in the passengers example from \u00a72.7), a single thaw and freeze pair must surround both ac\u00adcesses. \nIn the future, we plan to insert these operations at basic block and function boundaries in the style \nof [31] so that objects are tracked with strong references as long as possible. Untampered Natives. Functions \nthat use JavaScript prim\u00aditive functions like Object.prototype.hasOwnProperty and Array.prototype.push \nand expect them not to be overwritten, must explicitly constrain their input heaps as such. In most cases, \nprogrammers expect natives to remain untampered, so desugaring could augment all function types with \nthese constraints. Constructor Prototypes. The purpose of a constructor C is to allow its instances to \ninherit properties of C.prototype (stored at location aCpro), but functions like useC that use such an \ninstance must then explicitly list the type of C.prototype. /*: #define TC {Dict(.).. } */ /*: #ctor \nthis :Ref /(this ..Emp,aCpro .) .{. = this}/(this ..TC ,aCpro.) */ function C() { ...; return this; } \nC.prototype.f = /*: Tf */ ...; C.prototype.g = /*: Tg */ ...; /*: x:Ref /(x ..TC ,aCpro.). (aCpro ..Tf \n(sel(., f )).Tg(sel(., g )),eop .) . Top /same */ function useC(x) { ... x.f ... } This is a predictable \npattern that should be easy to incorpo\u00adrate into desugaring, though we have not yet done so.  6.4 Performance \nThe running time of our type checker is acceptable for small examples, but less so as the number of queries \nto the SMT solver increases. We have not yet spent much effort to im\u00adprove performance, but we have implemented \na few opti\u00admizations that have already reduced the number of SMT queries. First, even though desugaring \nworks perfectly well without any type information, we use DJS type annotations to translate object and \narray operations to speci.c primi\u00adtives, where possible, rather than the more general ones (e.g., getPropObj \nand getIdxArr rather than getElem) so that type checking has fewer cases to try, and we insert type and \nlocation parameters so that they need not be inferred. Sec\u00adond, we modify the T-VAR rule, which normally \nassigns the sel..ed type {. = x} to variable x that is already bound in G. Although this precision is \ncrucial, the variable x often has a simple syntactic type (e.g., Ref \u00a3) that is hidden be\u00adhind the equality. \nInstead, if G(x) is of the form {. ::U .p}, we assign {. :: U .p .. = x} so that subsequent typing rules \ncan syntactically look for U rather than going through additional SMT queries as in the general case \n[9]. We expect that syntactically handling more common cases will further improve performance. For example, \neven though the dynamic keys are crucial in certain situations, many examples use objects with .nite \nand .xed key names, which we should be able to handle with far fewer queries to the SMT solver than in \nthe current implementation. 7. Conclusion and Future Work In this paper, we have shown how to scale up \nprior work on System D a type system for dynamic languages in a functional setting to the real-world \nJavaScript setting with imperative updates, prototype-based objects, and arrays through a combination \nof strong updates and prototype chain unrolling. We have demonstrated that our new system, System !D, \nis expressive enough to support the invariants from a series of small but varied examples drawn from \nex\u00adisting JavaScript benchmarks. We have found that the full range of features in DJS are indeed required, \nbut that many examples fall into patterns that do not simultaneous exercise all features. Therefore, \nwe believe that future work on desug\u00adaring and on type checking can treat common cases specially in order \nto reduce the annotation burden and running time, and fall back to the full expressiveness of the system \nwhen necessary. We believe that Dependent JavaScript is the most promising approach, to date, for supporting \nreal-world dy\u00adnamic languages like JavaScript. Features for Future Work. DJS already supports a large \nsubset of JavaScript that can be used for projects where all the code is controlled (e.g., server-side \napplications), and future work on integrating with run-time environments could allow DJS code to run \nalongside full untyped JavaScript. Next, we describe several features that we currently do not support, \nin addition to general use of apply and call as discussed in \u00a75. To allow mutation of prototype links \nvia the non-standard proto property, we could add a setproto expression to the language and detect \ncycles during heap unrolling. The eval statement allows a string to be parsed and executed, which is \nuseful but dangerous if misused. Since DJS is .ow-sensitive, we can constraint eval with heap invariants \nbefore and after the statement, and then perform staged type checking in the style of [8] at run-time. \nES5 introduces optional per-object and per-property at\u00adtributes (for example, to prevent modi.cations \nor deletions) that can likely be incorporated into our encoding of dictio\u00adnaries. One bene.t of such \nan extension is that the type sys\u00adtem could reason more precisely about which objects are in a prototype \nchain. For example, we could then allow non-array objects to bind unsafe strings as long as we prevent \nthem from appearing in the prototype chain of arrays, thus weak\u00adening the distinction we impose between \narray and non-array objects (\u00a72.6). A second bene.t is that native objects could be marked as unmodi.able, \nstatically enforcing the pattern they are usually untampered as discussed in \u00a76. ES5 getters and setters \ninterpose on object reads and writes. Since this is a deep change to the semantics of ob\u00adject operations \n(invoking arbitrary functions), adding general support for these will likely be heavyweight. Interestingly, \none can think of our treatment of the special array length property (\u00a72.6) as a built-in getter/setter. \nEach function has an implicit arguments array that binds all parameters supplied by the caller, regardless \nof how many formals the function de.nes. Current ES6 proposals include a modi.ed version, where an explicit \nparameter can bind a variable number of arguments beyond those named by formals, similar in style to \nPython. The x instanceof Foo operator checks whether or not Foo.prototype is somewhere along the prototype \nchain of x. We could add a primitive to match these semantics. Scalar values can be explicitly coerced \nby wrapper func\u00adtions, such as Boolean, in addition to the implicit coercion we have discussed. Undesirable \nFeatures. The last three features we dis\u00adcuss regularly compete for the title of worst among several \nwarts in the language (e.g., [10]) that lead to confusing code and hard-to-detect bugs. Incidentally, \nthe .JS transla\u00adtions of all three are straightforward and can be supported in DJS, but we see no reason \nto given their demerits. The with statement adds the .elds of an object to the current scope of a block, \nallowing them to be accessed with\u00adout quali.cation. There is hardly a good reason to use this feature, \nand it is banned in ES5 strict mode. All var declarations are implicitly lifted to the top of the enclosing \nfunction, resulting in function scope rather than lexical scope. Although simple to detect when var\u00adlifting \nkicks in, we opt for the latter. ES6 will likely add an explicit let binding form that is not subject \nto lifting. In DJS, var is essentially the new let form, but we stick with the traditional syntax for \nfamiliarity. For a method call x.f(y), the receiver x is supplied for the this argument to the function, \nbut for a direct call x(y), JavaScript implicitly supplies the global object for this, masking common \nerrors. We choose to statically reject direct calls to functions that require a this parameter. 8. Related \nWork In this section, we discuss topics related to types for imper\u00adative dynamic languages, and hence \nstrong updates and in\u00adheritance. The reader may refer to [9] for background on the challenging idioms \nof even functional dynamic languages and the solution that nested re.nements provide. Location Sensitive \nTypes. The way we handle reference types draws from the approach of Alias Types [32], in which strong \nupdates are enabled by describing reference types with abstract location names and by factoring reasoning \ninto a .ow-insensitive tying environment and a .ow-sensitive heap. Low-level liquid types [31] employs \ntheir approach in the setting of a .rst-order language with dependent types. In contrast, our setting \nincludes higher-order functions, and our formulation of heap types gives variable names to unknown heaps \nto reason about prototypes and gives names to all heap values, which enables the speci.cation of precise \nrelation\u00adships between values of different heaps; the heap binders of [31] allow only relationships between \nvalues in a single heap to be described. The original Alias Types work also includes support for weak \nreferences that point to zero or more values, for which strong updates are not sound. Several subsequent \npropos\u00adals [2, 3, 14, 15, 31, 33] allow strong updates to weak ref\u00ad erences under certain circumstances \nto support temporary invariant violations. We adapt the thaw/freeze mechanism from [2] and [31] with \nmostly cosmetic changes. Prototype Inheritance. Unlike early class-based languages, such as Smalltalk \nand C++, the (untyped) language Self al\u00adlows objects to be extended after creation and feature pro\u00adtotype, \nor delegation, inheritance. Static typing disciplines for class-based languages (e.g., [1]) explicitly \npreclude ob\u00ad ject extension to retain soundness in the presence of width subtyping, the ability to forget \n.elds of an object. To mit\u00adigate the tension between object extension and subtyping, several proposals \n[6, 18] feature quite a different .avor: the .elds of an object are split into a reservation part, which \nmay be added to an object but cannot be forgotten, and a sealed part that can be manipulated with ordinary \nsub\u00adtyping. Our approach provides additional precision in two important respects. First, we precisely \ntrack prototype hi\u00aderarchies, whereas the above approaches .atten them into a single collection of .elds. \nSecond, we avoid the separation of reservation and sealed .elds but still allow subtyping, since width \nsubtyping in System !D is simply logical implica\u00adtion over re.nement formulas; forgetting a .eld discard\u00ading \na has(d, k) predicate does not imply that \u00achas(d, k), which guards the traversal of the prototype chain. \n Typed Subsets of JavaScript. Several (syntactic) type sys\u00adtems for various JavaScript subsets have been \nproposed. Among the earliest is [35], which identi.es silent errors that result from implicit type coercion \nand the fact that JavaScript returns undefined when trying to look up a non-existent key from an object. \nThe approach in [4] distinguishes be\u00ad tween potential and de.nite keys, similar to the reservation and \nsealed discussed above; this general approach has been extended with .ow-sensitivity and polymorphism \n[39]. The notion of recency types, similar to Alias Types, was applied to JavaScript in [23], in which \ntyping environments, in ad\u00ad dition to heap types, are .ow-sensitive. Prototype support in [23] is limited \nto the .nite number of prototype links tracked by the type system, whereas the heap symbols in System \n!D enable reasoning about entire prototype hierar\u00adchies. Unlike System !D, all of the above systems provide \nglobal type inference; our system does not have principal types, so we can only provide local type inference \n[29]. AD\u00ad safety [30] is a type system for ADsafe, a JavaScript sand\u00ad box, that restricts access to some \n.elds. Although expressive enough to check ADsafe, which heavily uses large object literals, they do \nnot support strong update and so cannot rea\u00adson about object extension. Unlike System !D, none of the \nabove systems include dependent types, which are required to express truly dynamic object keys and precise \ncontrol\u00ad.ow based invariants. Recent work on JavaScript veri.cation uses separation logic [17] to track \nprecise .ow-sensitive invariants. They support only .rst-order programs, and the expressiveness of their \nlogic takes them beyond automatic veri.cation, thus requiring properties to be manually proved. JavaScript \nSemantics. We chose the JavaScript semantics\u00adby-translation of .JS [21] since it targets a conventional \ncore language that has been convenient for our study. An alternate semantics [26] inherits unconventional \naspects of the language speci.cation [24] (e.g., scope objects ), which complicates the formulation of \nstatic reasoning. Acknowledgments This work was supported by NSF Grants CCF-0644361, CNS-0964702, and \ngifts from Microsoft Research. Part of this work was done while the .rst author was at Mozilla. References \n[1] M. Abadi and L. Cardelli. A Theory of Objects. Springer-Verlag, 1996. [2] A. Ahmed, M. Fluet, and \nG. Morrisett. L3: A Linear Language with Locations. Fundamenta Informaticae, 77(4), June 2007. [3] A. \nAiken, J. Kodumal, J. S. Foster, and T. Terauchi. Checking and Inferring Local Non-Aliasing. In PLDI, \n2003. [4] C. Anderson, S. Drossopoulou, and P. Giannini. Towards Type Inference for JavaScript. In ECOOP, \n2005. [5] G. M. Bierman, A. D. Gordon, C. Hritcu, and D. E. Langwor\u00adthy. Semantic Subtyping with an SMT \nSolver. In ICFP, 2010. [6] V. Bono and K. Fisher. An Imperative, First-Order Calculus with Object Extension. \nIn ECOOP, 1998. [7] R. Chugh, D. Herman, and R. Jhala. Dependent Types for JavaScript Appendix. arxiv.org/abs/1112.4106. \n[8] R. Chugh, J. A. Meister, R. Jhala, and S. Lerner. Staged Information Flow for JavaScript. In PLDI, \n2009. [9] R. Chugh, P. M. Rondon, and R. Jhala. Nested Re.nements: A Logic for Duck Typing. In POPL, \n2012. [10] D. Crockford. JavaScript: The Good Parts. Yahoo! Press, 2008. [11] L. de Moura and N. Bj\u00f8rner. \nZ3: An Ef.cient SMT solver. In TACAS, 2008. [12] R. DeLine and M. F\u00a8 ahndrich. Enforcing High-level Protocols \nin Low-level Software. In PLDI, 2001. [13] ECMA. TC-39 Committee. www.ecmascript.org/ community.php. \n[14] M. Fahndrich and R. DeLine. Adoption and Focus: Practical Linear Types for Imperative Programming. \nIn PLDI, 2002. [15] J. Foster, T. Terauchi, and A. Aiken. Flow-sensitive Type Quali.ers. In PLDI, 2002. \n[16] M. Furr, J. hoon (David) An, J. S. Foster, and M. W. Hicks. Static type inference for ruby. In SAC, \n2009. [17] P. Gardner, S. Maffeis, and G. D. Smith. Towards a Program Logic for JavaScript. In POPL, \n2012. [18] P. D. Gianantonio, F. Honsell, and L. Liquori. A Lambda Cal\u00adculus of Objects with Self-In.icted \nExtension. In OOPSLA, 1998. [19] Google. Closure library. https://developers.google. com/closure/library. \n[20] Google. V8 benchmark. http://v8.googlecode.com/ svn/data/benchmarks/. [21] A. Guha, C. Saftoiu, \nand S. Krishnamurthi. The Essence of JavaScript. In ECOOP, 2010. [22] A. Guha, C. Softoiu, and S. Krishnamurthi. \nTyping Local Control and State Using Flow Analysis. In ESOP, 2011. [23] P. Heidegger and P. Thiemann. \nRecency Types for Analyzing Scripting Languages. In ECOOP, 2010. [24] E. International. ECMAScript Language \nSpeci.cation, ECMA-262, 3rd ed. 1999. [25] K. W. Knowles and C. Flanagan. Compositional Reasoning and \nDecidable Checking for Dependent Contract Types. In PLPV, 2009. [26] S. Maffeis, J. Mitchell, and A. \nTaly. An operational semantics for JavaScript. In APLAS, 2008. [27] J. McCarthy. Towards a Mathematical \nScience of Computa\u00adtion. In IFIP, 1962. [28] B. C. Pierce. Types and Programming Languages. 2002. [29] \nB. C. Pierce and D. N. Turner. Local Type Inference. In POPL, 1998. [30] J. G. Politz, S. A. Eliopoulos, \nA. Guha, and S. Krishnamurthi. Adsafety: Type-based Veri.cation of JavaScript Sandboxing. In USENIX Security, \n2011. [31] P. Rondon, M. Kawaguchi, and R. Jhala. Low-Level Liquid Types. In POPL, 2010. [32] F. Smith, \nD. Walker, and G. Morrisett. Alias Types. In ESOP, 2000. [33] J. Sunshine, K. Naden, S. Stork, J. Aldrich, \nand E. Tanter. First-class State Change in Plaid. In OOPSLA, 2011. [34] SunSpider. Javascript benchmark. \nhttp://www.webkit. org/perf/sunspider/sunspider.html. [35] P. Thiemann. Towards a Type System for Analyzing \nJavaScript Programs. In ESOP, 2005. [36] S. Tobin-Hochstadt and M. Felleisen. Logical Types for Untyped \nLanguages. In ICFP, 2010. [37] D. Walker and G. Morrisett. Alias Types for Recursive Data Structures. \nIn TIC. 2000. [38] S. yu Guo and B. Hackett. Fast and Precise Hybrid Type Inference for JavaScript. In \nPLDI, 2012. [39] T. Zhao. Polymorphic Type Inference for Scripting Lan\u00adguages with Object Extensions. \nIn DLS, 2011.   \n\t\t\t", "proc_id": "2384616", "abstract": "<p>We present Dependent JavaScript (DJS), a statically typed dialect of the imperative, object-oriented, dynamic language. DJS supports the particularly challenging features such as run-time type-tests, higher-order functions, extensible objects, prototype inheritance, and arrays through a combination of nested refinement types, strong updates to the heap, and heap unrolling to precisely track prototype hierarchies. With our implementation of DJS, we demonstrate that the type system is expressive enough to reason about a variety of tricky idioms found in small examples drawn from several sources, including the popular book JavaScript: The Good Parts and the SunSpider benchmark suite.</p>", "authors": [{"name": "Ravi Chugh", "author_profile_id": "81435596644", "affiliation": "University of California, San Diego, La Jolla, CA, USA", "person_id": "P3856142", "email_address": "rchugh@cs.ucsd.edu", "orcid_id": ""}, {"name": "David Herman", "author_profile_id": "81337490109", "affiliation": "Mozilla Research, Mountain View, CA, USA", "person_id": "P3856143", "email_address": "dherman@mozilla.com", "orcid_id": ""}, {"name": "Ranjit Jhala", "author_profile_id": "81100198278", "affiliation": "University of California, San Diego, La Jolla, CA, USA", "person_id": "P3856144", "email_address": "jhala@cs.ucsd.edu", "orcid_id": ""}], "doi_number": "10.1145/2384616.2384659", "year": "2012", "article_id": "2384659", "conference": "OOPSLA", "title": "Dependent types for JavaScript", "url": "http://dl.acm.org/citation.cfm?id=2384659"}