{"article_publication_date": "08-01-1997", "fulltext": "\n Synthesis of functions by transformations and constraints Crist6bal Pareja-Flores J. Angel Veliizquez-Iturbide \ncpareja@eucmax .sim. ucm. es and avelazquez~fi .upm.es Univ. Complutense de Madrid Univ. Polit6cnica \nde Madrid The unfold/fold system [BD77] is a simple to use and yet general program transformation system. \nWe are trying to extend it to make synthesis of functions. ln this way, we would have a simple and useful \ntool to design naive algorithms, which could later be transformed into efficient ones. Several extensions \nof the Unfoldifold system have been proposed. For irtetance, Chin [ChiW] used constraints to be able \nto transform programs while taking into account addi\u00adtional properties such as preconditions or invariants. \nFollowing Chin [Cbi90], we specify relations (i.e. con\u00adstraints) with a clause such that (written st \n) [Chi90]. Such constraints are not executable, but are only used for an\u00adnotation and transformation \nmumrees. However. we make a .. more general use of them as pre-and post-con~tions. We integrate them \nin Haskell, although the choice of the base functional language is largely irrelevant for our synthesis. \nFor instance, a function can be typically specified in the following way: f xst P[xl = y st REx, y] where \nP [xJ is a precondition to be satisfied by input x and R [x, y] is a relation to be hold by input x and \noutput y. We use the term }unction synthesis in the restricted sense of a process where general equalities \nwith constraints are transformed into functional equations after constraint re\u00admoval. We have extended \nthe unfold/fold transformation rules to be able to operate over general equalities instead of equations. \nBesides, we have introduced several transforma\u00adtion rules to handle constraints. err. the conversion \nbetween , constraints and local definitions or guards. The case of synthesis we have worked the most \nis in\u00adversion of functions: given the definition of a function f as fx= y, we want to derive another \nfunction f 1 defined as f-l ~ = x. Partially applied functions can also be inverted: (fk)-*y=xstfkx=y \nThe function (f k) -1, inverse off k, depends in general on k, so it is again parametrized by k. invertible \nfunctions are implicitly used in specifications baaed on patterns: they represent the application of \nan in\u00advertible function to decompose the function parameter into several data. For instance, the equation \nf (x: XS) = E[x, XS] contains a pattern that represents the list resulting from aPPIY@ the constructor \n(: ) to x and XS. The use of the Permission to make digital/hard copv of part or all this work for personal \nor classroom use is granted without fee provided that copies are not made or distributed for profit or \ncommercial advan\u00ad tage, the copyright notice, the title of the publication and its date appear, and notice \nis given that copying is by permission of ACM, Inc. To copy otherwise, to republish. to post on servers, \nor to redistribute to lists, requires prior specific permission and/or a fee ICFP 97 Amsterdam, ND @ \n1997 ACM 0-89791 -918 -1/97 /0006 . ..$3.50 pattern extracts the original arguments of the application \nof (:) that formed such a list. We can say this aa follows: f list = E[x, xs] where (X, XS) = (: )-1 \nlist s (head list ,tail list) This situation holds for any constructor. The same idea can be fmther generalized \nif we allow patterna to be formed by any functional expression that can be inverted. These generalized \npatterns provide us with another way of specify\u00ading functions. For instance, let the following definition \nbe: f (listl++[O]++list2) = E[listl ,list2] where f is applied to a list of integem with exactly one \noccur\u00adrence of number zero. The expression 1 ist 1++ [0] ++1 ist 2 is not a pattern, but it can be understood \nas an inversion process: f list = E[listl ,list2] where listl++[O]+tliet2 = list ~ E[listl ,list2] rrhsre \n(listl ,list2) = Pat-l list provided Pat (listl ,list2) = list l++[O]*list2. No\u00ad tice that tils way of \nspecifying functions leads to a partic\u00ad ular case of synthesis: that of the inverse of a eneralized --F \npattern. In this example, the synthesis of Pat derives a fumction equivalent to span (/=0). We have applied \nthe extended language and transform\u00ad ation system to the syntiesis of a variety of algorithms, in\u00ad cluding \nsome non-trivial arithmetic functions, and the known problem of building a tree from its preorder and \ninorder tra\u00ad versals. We are synthesizing other demanding problems, such as sorting lists, computing \na aearcb tree given its preorder traversal, string-matching, HufTman s algorithm, etc. There is a number \nof points not completely studied: to define precisely the syntax and semantics of our constraints; to \nfix our set of transformation rules; to systematize the syn\u00adthesis process, ideally with tactice; and \nto study more deeply the nondeterminism inherent in constraints and inverses.  References [BD77] R. \nM. Buratall and J. Darlington. A transformation system for developing recursive programs. Journal of \nthe ACM, 24(l), 1977. [Chi90] W. N. Chin. Automatic Methods jor Program Trana\u00ad}ormation. PhD thesis, \nImperial College of Science, Technology and Medicine, London, 1990. [PV97] C. Pareja-Flores and J. ~. \nVelAzquez-Iturbide. Syn\u00adthesis oj junctions by transformations and con\u00adstraints: rules, applications \nand examples. Technical report, Depto. Inform&#38;tica y Aut om~tica, U. Com\u00adplutense de Madrid, April \n1997. 317  \n\t\t\t", "proc_id": "258948", "abstract": "", "authors": [{"name": "Crist&#243;bal Pareja-Flores", "author_profile_id": "81100425409", "affiliation": "Univ. Complutense de Madrid", "person_id": "P50552", "email_address": "", "orcid_id": ""}, {"name": "J. &#193;ngel Vel&#225;zquez-Iturbide", "author_profile_id": "81100245077", "affiliation": "Univ. Polit&#233;cnica de Madrid", "person_id": "PP17013352", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/258948.258986", "year": "1997", "article_id": "258986", "conference": "ICFP", "title": "Synthesis of functions by transformations and constraints (poster)", "url": "http://dl.acm.org/citation.cfm?id=258986"}