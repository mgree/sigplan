{"article_publication_date": "08-01-1997", "fulltext": "\n Strongly Typed Flow-Directed (Extended Allyn Dimock Robert Muller Harvard University Boston College \nTopic Areas compilation, lambda typed flow analysis, Abstract We present a new framework for transforming \ndata repre\u00adsentations in a strongly typed interrnedlate language. Our method allows both value producers \n(sources) and value con\u00adsumem (sinks) to support multiple representations, aut~ maticaily inserting any \nrequired code. Specialized represen\u00adtations can be easily chosen for particular Source/sink pairs. The \nframework is based on these techniques: 1. F1OVIannotated types encode the flows-from (source) and flows-to \n(sink) information of a flow graph. 2. Intersection and union types support (a) encoding pr~ cise flow \ninformation, (b) separating flow information so that transformations can be well typed, (c) automat\u00adically \nreorganizing flow paths to enable multiple repre\u00adsentations.  As au instance of our framework, we provide \na function rep resentation transformation that encompasses both closure conversion and inlining. Our \nframework is adaptable to data other than functions. Introduction Typed intermediate languages [19, 18, \n25, 32] support type\u00addirected transformations while simultaneously increasing confidence in the correctness \nof such transformations. In th~ paper, we focus on representation transformations, i.e., those that arise \nin data type implementations. We consider representation transformations that transform all sources at \nwhich values are produced and all sinks at whk.h they are consumed in a consistent manner. In functional \npro\u00adgramming languages, a particularly important representa\u00adtion transformation is C1OSUWwntrersion, \nwhich implements a function value as a cio.sure, packaging the function code with the values of its free \nvariables [16, 3, 25, 30, 17]. This author swork was done at Boston University and was par\u00adtially supported \nby NSFgrantsCCR 9113196and CCR-9417382and EPSRCgrantGR/L 36963. Permission to make digital/hard copv \nof part or all this work for personal or clsssroom use is granted without fee provided that copies are \nnot made or distributed for profit or commercial advan\u00ad tage. the copyright notice, the title of the \npublication and ita date appear, and notice is given that copying is by permission of ACM, Inc. To copy \notherwise, to republish, to post on servers, or to redistribute to lists, requires prior specific permission \nand/or a fee, ICFP 97 Amsterdam, ND @ 1997 ACM 0-89791 -918 -1/97 /0006 . ..$3.50  Representation Transformations \nAbstract) Franklyn Turbak J. B. Wells* Wellesley College Glasgow University calculus, intersection and \nunion types, closure conversion, Mning By using multiple representations for a single data type, a compiler \ncan choose more efficient representations by con\u00adsidering their uses. For example, selective closure \nconver\u00adsion uses two function representation [30]: it can repre sent open functions (i.e., functions \nwith free Variablm) as code/environment pairs, but in some cases cars represent closed functions simply \nas code. The latter can be more ef\u00adficient because it avoids packing the code into and unpacking it from \na pair with a useless empty environment. Although beneficial in an optimizing compiler, imple\u00admenting \nmultiple representations is challenging: 1. Global flow information is required to match up the sources \nand sinks that share a representation. Because there is growing recognition that such flow analyses are \nnecessary for optimizing higher-order languages [26, 21, 12], this requirement is not too burdensome. \n 2. To distinguish between multiple representations, it is necessary to separate data flow paths. The \nplumbing of the program must be transformed in such a way that the meaning of the program is preserved. \n In this paper, we address the plumbing problem while using existing flow analysis techniques [5]. We \npresent a framework for representation transformation that supports multiple representations within a \nstrongly typed language. The framework is both type-dirwcted and jlow-directed in the sense that it uses \nthe types of terms and global flow infor\u00admation encoded in those types to determine how the terms are \ntransformed. We illustrate our framework by demon\u00adstrating how multiple function representations can \nbe used in the same program in a strongly typed manner. Contributions of this Paper We show how flows-from \nand flows-to annotations on types can be used to pair up sources and sinks. We then use this information \nto make pairwise representation decisions. Flows-from annotations on types have been used in previous \nwork [10, 5], but we are the first to use them in combination with flows-to annotations.  We solve the \nplumbing problem for multiple represen\u00adtations using intersection and union types. We intro\u00adduce virtual \ntuples (values of intersection type) into programs to refine flows-to information, and virtual variants \n(values of union type) to refine flows-from in\u00adformation. A later stage transforms some virtual tuples \nand variants to real tuples and variants to provide sep\u00adarate data flow paths for incompatible representations. \n We present a novel function representation transforma\u00adtion that subsumes both closure conversion and \ninlining m special cases. We are the first to perform function transforma\u00adtions using multiple representations \nwith multiple interfaces in a strongly typed language. Earlier approaches to typed closure conversion \n[9, 17, 18] have required all function representations to use the same application protocol. The only \nflow\u00adbased closure conversion work known to us that supports multiple application protocols is ex\u00adpressed \nin an untyped language [30]. Our transformation can inline functions along ar\u00adbitrary flow paths, even \nopen functions. 1 ThM paper is organized as follows. Section 2 gives au overview of our framework. Section \n3 presents the stagee of our framework in more detail. Section 4 discusses related research. Section \n5 dkcumes future work. Our intermediate lanWage is defined in the Appendix. Overview Our representation \ntransformation framework is depicted by the diagram in figure 1. The framework is a composition of well-typedness-preserving \ntrmsformations on typings of terms in our intermediate language ACIL,2 The Flow Sepa\u00adration and Splitting/Tagging \nstages preserve normal forms for closed terms at base type. Meaning preservation has not yet been proved \nof the Representation Transformat ion stage. The modularity of our framework makes it possible to ex\u00adperiment \nwith different approaches to representation trans\u00adformations via mix-and-match parts. Our approach can \nwork with many flow analysis algorithms and also allows great flexibility in making representation decisions. \nGiven a flow analysis and a set of representation decisions consistent with the flow analysis, our algorithm \nperforms the program transformations that implement the decisions. Our language ACILk an explicitly typed \nlambda calculus with product, sum, union, intersection and function typea. Function (arrow) types, abstractions, \nand applications, are annotated with flow labels approximating the flow of func\u00adtions horn abstractions \nto applications. The Appendix formally defines ACIL but we will informally introduce its features in \nthe main t ext ~ needed. We introduce the stages of our framework with the fol\u00ad 1Because we have not \nyet explored how to support lightweight closure conversion (where free variables whose values are available \nat the sink do not need to be included in closures) in our framework, the irdining we support is complementary \nto rather than a replacement for classical inlining. ~CIL, 21n c stands for the Church Project (http//wvnv.cs. \nbu.edu/groups/church/) and IL stands for intermediate language . The purpose of the Church Project, named \nin honor of Alonzo Church, is to investigate the applications of intersection and union ty es in the \ncompilation of stron Iy typed &#38;L of Acl!. higher-order languages. .ADLOand ~~~~ are subsets defined \nin Section 3. lowing example:3 j int+int = ~zint.z * ~ let in let g t_ int = Ayint.y + ai in x (f @I5, \n(if bb then ~ else g) Cl 7) In this term there zme two free variablex u and b. The closed function \n(,kzi t. x * 2) flows to two application sites, the second ,of which is also a sink for the open function \n(Ayin .y + a ). It is important that the flow properties of this simple term are merely examples of \nmore complex flow patterns that arise in real programs. In order to stress that our framework can handle \narbitrarily complex flow pat\u00adterns, we will illustrate subsequent examples diagrammatically with the \nabstractions and applications detached from most of their surrounding text. The Flow Analysis stage computes \nan approximation to the flow of values between sources and sinks in the input term and encodes this via \nflow labels in the output typing. Figure 2 shows a possible result of flow analysis for the sam\u00adple term. \nIn the diagram, each abstraction site (~j.-.M) is anno\u00adtated with a source label 1 and a set of sink \nlabels @ ap\u00adproximating the set of application sites that can consume Al. Source and sink labels are \nalso used to annotate finc\u00adtion types. If M has type r in the above term, the type of the abstraction \nis u+.. Each application site (M @ N) is annotated with a sink label k and a set of source labels q$ap\u00adproximating \nthe set of abstractions that can be consumed at @k. If N has type o, then such an abstraction is well-typed \nonly if M has a type of the form a-&#38;r.4 The Representation Choices stage chooses representa\u00adtions \nfor the values that flow along each flow path from source to sink and supplies information about these \nchoices to later stages. In the case of function values, there are a wide variety of representations \nto choose from. For simplic\u00adity, we consider only the following represent ations. An open function can \nbe represented either as (1) a closure consisting of a code/environment pair, or (2) an environment, \nwhere the code has been irdined at the application sites that the function flows to. A closed function \ncan use one of the open function representations (with a dummy environment), but it can also be represented \nas just a code pointer. In many cases, the representations for each flow path can be chosen independently.s \nHowever, it is necessiwy to mod\u00adify the flow graph with plumbing coercions that appropri\u00adately handle \nthe flow of multiple representations. Multiple representations produced at a source must be packaged \ninto a tuple at the source and later projected out. If multiple representations reach a sink, they must \nbe injected into a variant earlier so that the sink can perform a case analysis on the variant tag. The \nexamples will illustrate thk. The Representation Choices stage does not perform any plumbing coercions \nor make any representation changes, but Variables are explicitly annotated with types, applications are \nmarked by @ , and (real) tuples are marked by x . For readability, we omit types on bound variable occurrences \nwhen the binding is visible. We have omitted the flow labels AC*L requires; assume they are all O. Also, \nwe use baae types (like int and bool) and constants and familiar operators for these types, even though \nthey are not in the formal presentation. Explicit type coercions are required by ACIL when the flow labels \non function types do not match. We omit these coercions from our example diagrams for readability, In \ncertain closure representations, such as those with linked envi\u00adronments, the representation of one abstraction \ncan depend on that for its enclosing abstractions. We have not yet dealt with the issue of multiple representations \nin combination with linked closures. Representation Choices = ~ ~ -_-_-_-_-_-_---_-\\-\\ ---------- (RC) \nrI:T 1? PO Flow PI Flow P2 Splitting/ P3 Representation P4 Analysis * Separation Tagging llansformation \n~cIL (FA) Ag:Lo (FS) Ag;r (ST) Ag~$ (RT) AC L . Figure 1: Program transformation framework, Figure 2: \nFlow Analysis result. it provides the required partitioning information to subse\u00adquent stages that implement \nthe changes. The first such stage is Flow Separation, which introduces potential plumbing coercions wherever \na function type will need to be transformed into multiple representation types. Flow Separation is guided \nby II&#38;, a partitioning of flow paths according to the transformed representation type cho\u00adsen for \nthem. Figure 3 shows the result of Flow Separation on our example in the case where all three flow paths \nwill be given different representation types.6 The abstraction occ~rence A\\3,4} is transformed into a \nvirtual tuple (a value of intersection type) containing two abstraction occurrences ~~s} md ~~d}. htuitively, \na virtual tuple is a compile-time vafue of intersection type containing virtuaf copies of a term that \ndiffer only in their types. All of the values inside a vir\u00adtual tuple share the same run-time representation, \nand no space needs to be allocated for the virtuaf tuple at run-time. Similarly, the application occurrence \n@$l 2} is transformed into a virtual cnse expression that dispatches on the tag of a virtual variant \n(a value of union type) to one of two ap\u00ad {1} {2} plication occurrences @4 or @q . The Splitting/Tagging \nstage reifies some of the virtual plumblng coercions into real plumbing coercions by chang\u00ading some intersections \n(A) to products (x) and some unions (V) to sums (+). It is guided by II&#38;, a partitioning of flow \npaths according to the run-time code which will implement the transformed representation types. Consider \nfigure 3 and suppose that the {~} partition is represented by a code pointer and {~, ~} is represented \nby a closure. Then Split\u00adting/Tagging would transform A(~}~, .in ...z, ~~q}&#38; .=.2) into x (A~~)Zimt.m*2, \nAj,}zimt. ~.2) because different code will be executed at run-time to create the two values. The sa\u00adsociated \nn: terms would also be transformed to T,x. Even though the run-time code constructing the environments \nfor the two closures would differ, the run-time code invoking them would the same, so the caaev would \nnot be trans\u00adformed to case+. Choosing the same representation method (e.g., flat closures) for different \nfunctions of the same type can result in different representa\u00adtion types. The closure representation \nand environment representa\u00adtion expose the types of the function s free variables, thus leading tn different \ntransformed types even when the pre-transformation types are the same. These types are only superficially \ndifferent, because the closures are invoked in the came way. We combine such superficially different \ntypes using union types. For some function representations (but not all), existential types can serve \na similar purpose [17], As another example of Splitting/Tagging, suppose that {3, ~} are represented \nby code pointers and {~} is repr~ sented by a closure. Then Splitting/Tagging would trans\u00adform the instance \nof case and irf to case+ and in; be\u00adcause a run-time discrimination will be required to choose between \n63$1} and @~} which must be implemented by dif\u00adferent run-time code. (In this case, Flow Separation would \nnot have needed to introduce a virtuaf tuple at J~3,4}.) Together, Flow Separation and Splitting/Tagging \ninstall the correct plumbing for the final Representation Thms\u00adformation stage. This stage is controlled \nby a represen\u00adtation map 7? supplied by Representation Choices. The map 7? specifies consistent transformations \non types, source subterms producing values, and sink subterms consuming these values. Figures 44 show \nthe output of Representa\u00adtion Transformation on our sample term for these three sets of representation \nchoices: Figures 4, 5, and 6 illustrate, respectively, the splitting of a vafue at a source, discrimination \non a tagged value at a sink, and inlining an open function. 7 The input abstrac\u00adtion (~~~)~ t.~+ai t) \nhas been transformed to an environ\u00adment containing its free variable, while its code has been inlined \nat the application site tlq 2}. Because a code pointer representation can reach site @4{l} , the two \nincompatible values are injected into a variant. 3 Transformation Fkamework 3.1 Preliminary Definitions \nWe w our typed intermediate language AcrL, which is d\u00adfined in the Appendm. For this paper, we will add \nthe fol\u00ad 7Figures 4, 5, and 6 have been simplified by standard lo\u00adcal optimization. The subterm ( wx \nh 1 ) Oio} x ((*1 h), ) in the first branch of the case in figure 4 is actually it =~1 G h in (-~ s) \n0$0} x((m~ e),7) . A similar simplification has been made for the second case branch in figures 4 and \n5. See footnote 8 for an explanation of the flow label O. In figure 6, the subterm 7+(~~ h) in the second \ncase branch is actually w x [x ~.tl Ii+ m x(h,7) 1 (m; M)+(-; n: II) . ~)V[i #i ii +$@ t] case v if \nbb o ( p[i ++ di-l +i ] else (in] ~ (7r( ) @$ } 5 )  Al ~I bind has int~ int * h @ ~l} 7, int# int \n* h Q: } 7 H [ Figure 3: Flow Separation result. Figure 4: Representation Thnsforrnation result illustrating \nsplitting. = lx(( ~o x[x[int] t](m )+(m + [int # int, 02] case+ (if bbo then (in~ ) / ~~ \\ else (l; \ni!lj~ntwin l ) bind h-(i ++ ) = ~Q$} 7 U2+ (n: h) @$} X ((m: h) ,7) Figure 5: Representation Transformation \nresult illustrating tagging. x (aint) / ~ Qjl} ~ bind has (int #+int) + h @$ } 7 x [int] -7 + (7r~ h) \n Figure 6: Representation Transformation result illustrating inlining. lowing definitions and requirements. \nWe require that every flow label only appears on an arrow at one type. As an example of a type violating \nthis condition, in the type (int~int) ~ (bod~bml) the la\u00ad bel 1 corresponds to the two distinct types \n(int-J+int) and (jnt~int)~(bo~l~bool) and the label 2 corresponds to the twO dk.tinCt typeS (int~int) \nand (b..l+bool). Definition 3.1 (Type/Label Consistent ). Given some syntactic entity X, define these \nsets: xi = {u* Tluq%TEx} Xi = {U*71U*7EX } Then X is type/label consistent (TLC) if and only if Ixi \nI+ lXil <1 for all i. Since our hnework will use flow labels for transforming subterms, the labels embedded \nwithin a term must be suffi\u00adciently distinctly chosen. A term M has a label (at the top level) if and \nonly if A4 is an abstraction or an application. An abstraction (~$= .AZ)has label i (the top, or source \nlabel) and an application (M O? IV) has label j (the bottom, or sink label). Given a set of terms M = \n{1141,... , Af~} where the label of each Mi is l , the set M is distinctly labekzi if and only if li= \nlj implies i = j. Given a term M, the subterms ofM are the members of the set { N IN ~ M }. Given a term \nA4, the subtenn occurrences of M are the members of the set ( N(PI I N d M at position p) where N{pl \npairs the subter~ N with the position p (an un~pecified notion) at which it occurs in M, so the set has \none copy of the subterm for each position at which it occurs. Definition 3.2 (Distinctly Labelled). 1. \nA term M is distinctly labelled by occuwence (DLO) if and only if the set of subterm occurrences of M \nis distinctly Iabelled. 2. A term M is distinctly labelled by subterrn (DLS) if and only if the set \nof subterms of M is distinctly labelled.  Definition 3.3 (A~~Loand ~~~~). A judgement Ai-M : P is derivable \nin the language subset A~\\Lo(respectively ~~~~) if and only if A l_~~lL M :r via D and the term M is \nDLO (respectively DLS) and the typing D is TLC. 3.2 Algorithm The overaI1 algorithm Y implementing our \nrepresentation transformation thrnework proceeds aa follows (see also fig\u00adure 1): F(Po) = let PI = FA(Po) \nin let (7?, lI&#38;, ll&#38;.) = RC (PI) in let Pz = FS (PI, I&#38;) in let P3 = ST (P2, I&#38;) in let \nPq = RT (P3, R) in P4 The algorithm 3 uses sub-algorithms FA, RC, FS, ST, and RT, which are described \nin sections 3.3,3.4,3.5,3.6, and 3.7, respectively. 3.3 Flow Analysis (FA) In the literature, a jlow \nanalysis (sometimes called a clo\u00adsure analysis) is any of a class of analyses that either relate abstraction \noccurrences (function definitions) to application occurrences (function call sitea), or relate abstractions \nwhich may be called to the abstractions from whose bodies they are called [1, 5, 10, 11, 26]. In our \nintermediate language ACIL, as in the work of Heintze [10] and Banerjee [5], flow information is encoded \naa annotations on arrow types. The Flow Analysis (FA) stage takes the input program Po, performs a flow \nanalysis on PO and encodes the results of this analysis in type annotatations on its output P1. Rather \nthan providing an algorithm to implement this stage, we merely specify minimum requirements that an algorithm \nmust satisfy to work with our framework. Definition 3.4 (Label Erasure). The label erasure of any syntactic \nentity X, denoted (X), is obtained by replac\u00ading all labels on types, abstractions, or applications in \nX by the label O. Definition 3.5 (Flow Analysis Requirements). A to typed terms in function FA from typed \nterms in AclL ~~~o is a. flow analysis suitable for use in our framework if and only If the following \ncondkions hold. If A ~ACILM : r via D and M = FA(M), then there exist A , r , and D such that 1. A .@JLOM \n:r via D . 2. IM I s IMI (meaning preservation). 3. (A ) = (A) and (~ ) = (r).  There is a flow analysis \nfor ACILthat is as accurate w the OCFA of Shivers [26]. Due to our deliberately restricted sub\u00adtyping \nrelation, such a flow analysis must introduce virtual tuples and variants to achieve sufficient accuracy. \n3.4 Representation Choices (RC) The Representation Choices (RC) stage takes aa input a typed rogram P1 \nand computes a representation map ~ = &#38;.&#38;l, ~v., , R_ ) and partitioning functions ll~s and \n@T, i.e., The map components are used by the Representation Thns\u00adformation stage to perform transformations \non the pro\u00adgram s syntax tree. The component 7?~ outputs code im\u00adplementing each occurrence of an abstraction \nin the source term, R@ outputs code implementing each occurrence of an application in the source term, \n7? outputs a function from variables to code implementing variable lookup, and 73+ maps function types \nto the types of the corresponding function implementations. The partitioning functions 11~~and lT&#38; \nare used in the Flow Separation and Splitting/Tagging stages to prepare for the Representation Transformation \nstage. The Flow Sepa\u00adration transformation is guided by ll&#38; in separating types, abstractions, and \napplications which either (1) need differ\u00adent types or (2) actually need different code. The Split\u00adting/Tagging \ntransformation is guided by lI&#38;. in changing virtual tuples and variants into real tuples and variants \nto allow possibility (2). In the following we use these textual abbreviations (i.e., free variables in \nthe expansions are captured): =n-( (w) ty e(bvww i =q((fvf~)) y e(f (W) n=#fv@) T = [T]R,N p =E+ :,N \np = x[p, T ] The function [. ].,. is defined in figure 9. The representationmap R will be what this \nfigure is defining. The parameter PI is the entire program se input to the RC stage. Representation Choice \nConstraints Any total predicate RC de?and R ? may be chosen as long se: v~. ((#fv (j, P1) =O) or R d \n (~) or R= ?(j)) Vi. (not irdinedin? (~, ~, PI)) Representation Implementation The functions ( l?~, \nRa, 7?- , 7?.+) depend on the value of (R de ($) , R ? ($)) as follows: 7?+ $,ul, uz, N R~ $,E,M, N \n@ ~,M1,M2,M3,N Ev-r $,E,N Cv.r $, N (true, true) C+ $,ul, uz, N CA $, E,M, N C (MI , Mz) ~min~zr M (true,false) \nMl ~~in ~ MZ E Z I+ X f 1 + 2 d (false,true) E+($, N) E~ $,E, N @ $, M1, M2, M3, N f = $N (false,false) \nX[] x(] let z = MZ in M3 XT* XT The M3 parameter of R. will be a function body to inline. The N parameter \nof each function will be the entire program P3 as input to the RT stage. Clomre Implementation C+&#38; \nWZ,N) = x (x[w+3w2) ,,] ($-w =x [ O!O}ZP M)E ($EN)) C (M~, A4Z) = ey =; n (w $ ((-)4 hem isfmb =&#38;v8r \n$,N C- :,N () Environment Implementation $,N E+ ()= x [~&#38;,N,..-, [+,N] =x( E(z~),. ... E(z~)) +w$ \n) [ .@ :, MfI,M2,M3,N = let zx[u T l = x(M1, M2) in Ms () E- :,N = z + 7r;z+ U z1 i*7r,x r~zp ll<i<n \n() { }{ } Flow Partitioning Functions Each partitioning function maps a flow path to a string identifyhg \na partition. Strings are concatenated via : . KY (j) : 7Z. 0d (j) :1 if #fv (j, PI) ~ 1 or not R de \n(~), ~&#38; (L) = ~..v? (J : true otherwise. { rI;T where @+A (j) = Re v7 (~) : R,C de? (~) =(@ -) ST \n~ ST R (L) : false: 1 if not 7? 0 (~), ~~+ (L) = {~.w? (J : true otherwiee. Figure 7: Example representation \nmap with corresponding flow partitions. The algorithm implementing the RC stage will generally need to \nto inspect the entire input program in generating the representation map 7? and the partitioning functions \nII~s and H~T. In addition, the components (~~, R@, R= , ~+ ) of the representation map itself will need \naccess to global program information. For this reason, each component will have an extra parameter which \nwill be supplied with the en\u00adtire program as an argument in the Representation Trans\u00adformation stage. \nDefinition 3.6 (Flow Paths and Bundles). Given 1,kE Label, the pair ~ is a flow path. Given ~, ~ C Label, \nthe pair ~ is a flow bundle. We write ~E$ to denote that i G~ and t E~. The presence of a flow path j \nin a program indicates that the Flow Analysis stage has guessed that the source Iabelled 1might be able \nto flow to the sink labelled k. A flow bundle $, can be seen es the collection of the flow paths {j I \n~ c $,}. Definition 3.7. For any term N in DLS (distinctly labelled by subterm) form, if Ms (A&#38; .M \n) S IV,kE~, and Zlr , .,. , Znr are the free variables of M in order of first occurrence horn left to \nright, then the following functions are defined: bv(~, iV) =z #fv(~, IV) = n fVi(~,iV) Xi ifl<i<rz body \n(~, N) = M name (v ) = y type (y ) = u Convention 3.8. Any total function f on flow paths ~ is automatically \nextended to a partial function on flow path bundles $ as follows: In figure 7 we give an example implementation \nof the RC algorithm. The algorithm specified in figure 7 can pro\u00adduce a representation map that can perform \nboth closure conversion and Wining. To choose function representa\u00adtions, this representation map uses \npredicates % de and %T V*,which may be arbitrarily chosen total predicates on flow paths, except that \nan abstraction with free variables must be given some way to carry the values of those free variables \nand that inlining loops must be avoided. The concrete representations of closures and environments for \nthis example me abstracted in C = (CA,Co, C , C+)s and f = {&#38;~, &#38;~, &#38;- , &#38;+)9. The representation \nmap 77, and partitioning functions Il~s and ~~T given in figure 7 are specifically d~igned to work together; \nif 7? were altered then ll~s and 11~~might need to change in a corresponding way. Due to our deliberatelyrestrictedsubtyping \nrule, this example usesOfor flow labels in closures, thus losing flow information in the output. Thisproblemcanbesolvedbyaddingflowlabelsto \nalldata types. This definitionissimplifiedfromwhatwillactuallywork. In order for a closure referencing \na ~-bound variableto be a value in ACIL, the code storing the p-bound variable value in the closure must \nbe thunkified and the correspond ng variablwwcess code in the function body must force the thunk. This \nproblem seems to represent a flaw in the form ]atio of ACIL. using a A-graph-breed calculusmightavoid \nthis problem. The problem does not occur if p-bindings are restricted to the form UZr. V and closure-paasing \nstyle is used. 3.5 Flow Separation (FS) The Flow Separation (FS) stage takes as input a typed program \nPl and a flow path partitioning function ~~~ (sup\u00adplied by Representation Choices to determine which \nflow paths can coexist in the same flow path bundles) and re\u00adturns a transformed typed program Pz. We \nimplement this stage with the FS algorithm, which applies the transforma\u00adtion in figure 8 to the in ut \nP1 using ll~s for 11in the figure to obtain the result PZ.E More precisely, if we let ~ be an abbreviation \nfor FS(M, II~s), then Definition 3.9. If II is a function on flow paths (source/sink flow label pairs), \nthen a typing D respects II if II ($) is defined for every flow bundle $ (source/sink flow label set \npairs) occurring in D (see convention 3.8). The type transformation T preserves the structure of all \ntypes except arrow types, which it transforms to unions of intersections of arrows in a way that respects \nlI~s. The term transformation Z preserves structure except at ab\u00adstractions, applications, and coercions. \nAn abstraction oc\u00adcurrence is transformed into a virtual variant containing a virtuaf tuple whose slots \ncent ain different type annotations of the same abstraction which are suitable for the different call \nsites to which the original abstraction flowed. An appli\u00adcation occurrence is transformed into a virtual \ncase expres\u00adsion which d~patches on the virtual tags of the abstractions that could reach the application \ns function (left) slot. Each alternative in the case expression is a virtual copy of the original application. \nThe transformation of a coerce ex\u00adpression results in a term that converts a virtual variant of virtual \ntuples into another virtual variant of virtual tuples. The type erasure of an abstraction remains the \nsame, while the type erasure of an application is ~-expanded from (M@ N) to ((Af.f @ N) @ M), since the \ntype erasure of a virtual case expression is a /3-redex. The transformation could take advantage of pre-existing \n~-redexes at the cost of a more complex specification. The type erasure of a coerce expression is @expanded \nfrom M to ((Af. f)@M), again a result of our formulation of virtual case expressions and potentially \nsimplifyable in the same way M for applications. The Flow Separation transformation in figure 8 intro\u00adduces \nunneeded singleton virtual variants and virtual tuples, which could be avoided by a more complex specification. \nIn the worst case, Flow Separation may be provided with a par\u00adtitioning function that assigns every flow \npath to a distinct partition and this would cause an at-least-quadratic expan\u00adsion in size of the program \nrepresentation. We expect that typicaf partitionings will be coarser-grained functions that avoid this \nworst-case expansion. Theorem 3.10 (Flow Separation Correctness). If 1. A1-Ag:Lo M : T. 2. t-nf(M). \n3. R-FS(M, II).  then them etisti a D such that loFigure 8 is simplified to avoid a subtlety Of Our \nPZraf!el term formulation. For correctness, for every coerce, we must pretend there is a (possibly useless) \ncoerce in each corresponding parallel position so that the type erasure of parallel subterms is changed \ncompatibly. UOWSeparation for Types (non-trivial case only) The function II mentioned below is a parameter \nto the algorithm. U+T = V4,, ~,,,,,$n[A!Ji,j in+i,l..+i,mi [&#38;* T]] where @l, . . . , ~~ partitions \n@so that II ~~1 isdefined fork~~andl~i <n, () +1,1!..,Vi,m(i) partitions@ sothat ~($~m(.)) isdefinedfor1c@iand1~ \nj<m(i), (mind~) < (minrj~+~) for 1 ~ i <n, (mh@i,j) < (min@i,j+l) for1< zs nand1< j <m(i), and each partitioning \nchooses the largest possible partitions. Flow Separation for Terms (non-trivial cases only) ( A\\Z~.M7)P \ns (iny A~=l(A\\jZ=~)) p where P = v[A~.1 [~~~1] MP@)@u ~ )( casev~bindj in..., Pi+-(Tff~i)@~i F,... () \nwhere~ isfresh,Is zs n,P= V~=l (pi], andpi = A[~ -&#38;+ F] (coerce (p,~) M) = casev ~ bind j in (  \n... ,Pi* (in:(i) A~~f(i))(coerce(~i,q(i,j),pL[i),j)~$(i,j)fpi))7 ) wherej isfresh,1< i < n, = v~=l [~i]j \nPi = Aj=ld,)[ .] ~ ~1,~ J Pi,j = ~+~, 7= v~;l [A]!P;= A~~~)[~l,j>p~,j= F*T> 1 and +, c d~(i) and @i,q(i,j) \na ~~(i),j forl<i< n andl~j~m (i) 01 other cases are purely structural, e.g., rr~M = m? fi and ~ = ZF. \nFigure 8: Flow Separation transformation. 2. D rs9pects l-I. Definition 3.12. If II is a function from \nflow paths to par\u00adtition identifiers, then for some term M, 3. IfT=o,Misclosed,M% N, and~ % N , 1. The \nparallel abstractions of M are legal with respect then N=N (meaning preservation). to If if whenever \n(~$1.1 al .Ni)Il(-i~2m2@Z .%) in M then 3.6 Splitting/Tagging (ST) 11(~1) =l-If;, )(. The undefined result \nis not equal to itself.) The Representation Choices stage can (1) specify for an in\u00addividual function \nthat it haa multiple closure creation (and 2. The parallel applications of A4 are legal with respectvariable \naccess) methods for different call sites to which it to ~ if whenever (NI afl N{) II (N2 o~ N;) in M \nthen can flow, and (2) specify for an individual call site that it l-I(:l)=rI (p). must handle multiple \nfunction calling conventions for dtier\u00adent functions which can flow to it. When this has happened, Definition \n3.13 (Joins). A subterm occurrence J ~ M the Flow Separation stage will have used the features of joins \ndistinct subterm occurrences N, N Q J when J is our intermediate language ACILin creating multiple parallel \neither a virtual tuple A(N1,. . . , N~) or a virtual case ex\u00adversions of the original function or call \nsite which are con-pression nected by a virtual tuple A(~I,. . . , IVm) or a virtual case (casev Mbindzinul \n%. Nl,... ,u~ ~N~) expression (case M bind z in al + N1,...,crm+-Nm). In these terms, the pardei subterms \nlV1, . . . . IVmrepresent ~dN~Niand N ~Nj where i#j. different type annotations of the same program phrase. \nIf the type erasures of Ni and Nj for i# j are changed in-The Splitting/Tagging (ST) stage takes aa input \na pro\u00ad compatibly, the result will be ill typed. We make it possible gram PZ and a pair of flow path \npartitionings 11:= = IIR,A for this to happen by (1) spiitting some function definitions supplied by \nRepresentation Choices to de\u00ad sT ,@ie )( ( and having the ditferen.t versions go to different call sites \ntermine which functions and call sites will have compatible and (2) tagging (injecting into sum type) \nsome function def\u00adtransformations) and returns as output the appropriatelyinitions and having call sites \ndiscriminate on the tags. The transformed typed program P3. We provide the following Splitting/Tagging \n(ST) stage does this by changing some ST algorithm to implement this stage. The ST algorithmoccurrences \nof A and V into x and + , respectively. inspects the derivation D which types Ps, transforms D into \nDefinition 3.11 (Parallel). Distinct subterm occurrences D as specified below, and returns as output \nthe transformed Ni,Nj u M are pamllel, written Ni IINj in M , if and only typed program P3 typed via \nD , i.e., ifMs Cp[Nl,.. . , N~ ] for some parallel context Cp and i,jc {l,... ,m}andi+j. P3 = ST (P2, \n(I@, II;~ )) In the algorithm below, (11~, I_I@)are the parameters which will be instantiated to 11~~~,II~~o \n. ()  1. For every pair of parallel abstraction occurrences Ml II MZ in PZ that are not legal with respect \nto 11~, find the subterm occurrence J ~ Pz that joins MI and Mz. Mark J s type constructor symbol as \neither A or V. Do similarly for every pair of parallel application occur\u00ad rences It4{ IIM; in PZ which \nare not legal with respect to l-IQ. 2. Propagate the markings on A and V. When a marked h or V is matched \nagainst an unmarked A or V in D by the typing rules, add marks to the unmarked symbols. 3. When there \nis a subterm M SI P2 which is a marked A, V-introduction or elimination term and there is a distinct \nsubterm M such that M IIM in P2, tind the subterm J ~ Pz which joins M and M and mark J. 4. Repeat steps \n2 and 3 until they do nothing. 5. Change every marked A into x and every marked V into +.  This algorithm \ncan sometimes split excessively, but common-subexpreesion elimination can compensate. Theorem 3.14 (Splitting/lhgging \nCorrectness). It 1. A l-~~cwjM :r via D. 2. t-nf(M). 3. The typing D respects IIA and II . 4. M -ST(M, \n(IIA,IIa)).  then there ezist A , T , and D such that 1. A l-~g~; M : r via D . 2. The amllel abstmctions \nof M are legal with respect to II ? and the parallel applications of M are legal with respect to II . \n 3. For any II , if D rvspects II then D rwspects II .  If r does not mention A or V, then T = T . \n4. 5. Ifr = o, M is closed, M J%, N, and M ~, N , then N = N (meaning preservation). 3.7 Representation \nTransformation (RT) The Representation Transformation (RT) stage takes as input a typed program Ps and \na representation map 7? and then traverses the syntax tree of Ps transforming abstrac\u00adtions, applications, \nvariable occurrences and function types as specitkd by 7? to produce the resulting typed program P~. \nWe implement this stage with the RT algorithm defined in figure 9. More precisely, where E~ta,t is the \nfunction such that ESts,t (XT) = x CTIR,P3, Note that thk implementation of the RT algorithm worka with \nthe example implementation of the RC algorithm in figure 7. A substantially dflerent implementation of \nRC might require corresponding changes to RT. The transformation on types proceeds structurally ex\u00adcept \nfor function types. Because the types of free variables of an abstraction are exposed in the transformed \ntype of the transformed abstraction, some transformed types can be infinite. These types will always \nhave a tinite represen\u00adtation. An implementation of the RT algorithm is required to detect when this \nhappens and tie off the recursion by in\u00adserting a p-binding. The transformation on terms is defined on \nthe structure of terms. In the application case, [. ]n,.,. provides to 7?0 not only the transformations \nof the appli\u00adcation s syntactic components, but sometimes also provides the transformation of a function \nbody to inline in place of the operator. To avoid non-termination, the output of the RC algorithm must \navoid specifying inlining loops. Theorem 3.15 (Well-Deflnedness of RC and RT). Ij 1. A ~~g~% M :r 2. \n( R, II~s, IT&#38;.) = RC (M) (using RC from figure 7). 3. A l-~gcm~M : # where M s ST (FS (M, lI&#38;), \nI I&#38;.).  then [A ]n,~, EACIL [M ] R, E,,ar, ,M, : [T l~,W. We have not yet proved that applying \nthe RT algorithm preserves the meaning of the program 4 Related Work General research into the use of \nintersection typa which has influenced us includes the work of Van Bakel [4] and Jim [13, 14]. Relevant \nresearch on both intersection and union types includes the work by Pierce [20], Aiken, Wim\u00admers, and \nLakshman [1], lkifonov, Smith, and E*ig [29, 8], and Barbanera, Dezani-Ciancaglini, and de Liguoro [6]. \nOf the above, only Pierce considers intersection and union types in an explicitly typed language. Even \nthat is somewhat dis\u00adtant from our work because Pierce includes a general sub\u00adtyping relation on intersection \nand union types which we deliberately avoid. Flow-types were first named by Heintze in [10], and are \nalso used by Banerjee in [5]. We diifer from the above by including sink labels as well as source labels. \nOur closure conversion is most closely related to Wand and Steckler s work on selective and lightweight \nclosure con\u00adversion [30]. They give a OCFA-based algorithm in the untyped setting and prove its correctness. \nTheir algorithm can avoid closure creation when all the functions flowing to a particular call site are \nclosed. In addition, the lightweight optimization uses an escape analysis to determine when the value \nof a free variable is available at the call site. Their algorithm restricts a function to a single representation \nand requires all functions flowing to a particular application site to observe the same application protocol. \nHannan [9] describes the annotations on types to perform the optimizations of [30] in a typed system. \nHe specifies a conversion, but does not supply an algorithm. He does not handle multiple representations \nfor a single function or mixed calling convent ions at a single call site. Minamide, Morrisett and Harper \npresent an algorithm for typed closure conversion [17, 18]. They use purely lo\u00adcal transformations to \nperform closure conversion. Their framework supports multiple closure representations but it is restricted \nin that all representations share the same inter\u00adface. There are many studies of closure conversion which \nfo\u00adcus on the data structures used for variable lookup and the representation Transformation for Types \n(non-trivial caae only) R-+ (wo [uIR,~>[TIR,N! N) [[+llR,N = UIother caeeeare purely structural, e.g., \n[QIT1,..., T? b]]R,N= Q[[Tdjz,NxY [7n]R,N] . representation Ikansformation [z ]R,E,~ [[W4?L,E,N Ml@~M2 \n~EN [1 ,, ~xr.M]R,E,N for Terms (non-trivial cases only) e -E(Z ) ( = RA $), E,[M] ??,q$w)!wq =~e~k})[MI]R,E,N, \n[M2]R,E,NjM3)~) where M3 = ~ ~bk,N .[~] { POdyC~~,N)l~,~v~,(~b,,E,~],~ co %E [x -+zl l~,N] ,N not  \nt) ot herwiee. > let z [rlR.N = [M~]R,E,N in [ 2]~ E[Z.X.17]R!N],N [let z = A41in M2]R,~,N \u00ad[[cases \nMbindzin... ,T1+Mi, . ..] R.E,N z cases [M]R,E,~ bind z in . . . ![~l]~,N + [Mi]R,Ei,N, . . where Ei \n= .?3 Zr~ # Z[ri]~IN [1 111other case are rmrel~structural. Figure 9: Representation Transformation. \ntradeoffs between sharing and time to lookup the value of a variable [16, 27, 2, 25]. Our framework abstracts \nout data structure representation imues. Jagannathan and Wright discuss flow-directed inlining in an \nuntyped system [12]. Their paper examines heuris\u00adtics for selecting application sites for inlining. They \ndo not discuss irdining open terms. Plevyak and Chien have ex\u00adperimented with flow directed inlining \nin an object oriented language [21]. Future Work Although th~ paper focuses on the transformation of \nfunc\u00adtion representations, our framework can be extended to transformations on other data types. These \nextensions in\u00advolve adding flow labels to all value producing and consum\u00ading forma. We expect to handle \nspecialized tuple, variant, and inductive datatype representations. We are implementing our framework \nand will experiment with various flow analysis algorithms and representation de\u00adcision heuristics. We \nwill refine the example representation transforma\u00adtion to include analysis enabling lightweight closure \nconver\u00adsion [30]. This allows variables available at the call site to be omitted from the environment \nof the closure. This will aleo improve inlining. In this paper we have presented a simple algorithm for \nthe Splitting/Tagging tranaformation. We plan to develop and implement a more efficient algorithm. An \nimportant practical issue in compiling with types is controlling the size of the intermediate representations. \nOur current language, following the style of [15], duplicates terms when it duplicates types. Our language \nis convenient for speci~ing our framework, but for implementation a consid\u00aderable size savings can be \nobtained by using a typed calculus with intersection and union types in the style of [31]. Finally, we \nplan to study the interaction of our current approach with separate compilation. 6 Acknowledgements \nWe would like to thank Mitch Wand, Will Clinger, Paul Steckler and several anonymous reviewers for their \nhelpful comments and suggestions. We would also like to thank our fellow Church Project members for their \nsupport and en\u00adcouragement, especially Asaaf Kfoury and Glenn Holloway. References [1] Alexander S. \nAiken, Edward L. Wlmmers, and T. K. Lakshman. Soft typing with conditional types. In POPL 94 [22], pages \n163\u00ad 173. [2] Andrew W. Appel. Compiling with Continuations. Cambridge University Prees, 1992. [3] Andrew \nW. Appel and Trevor Jim. Continuation-passing, closure-passing style. In Conf. Rec. 16th Ann. AC 14 Sprnp. \nPrinciples of Programming Languogee, pageg 293 302, 1989. [4] Steffen van Bakel. Intersection me Dimiplinee \nin Lambda Calcuiua and Applicative Term Rewriting S@errw. PhD the\u00adsis, University of Nijmegen, 1993. \n[5] Anindya Banerjee. A modular, polyvariarrt, and type-based clo\u00adsure analysis. In Proc. 1997 ACM SIGPLAN \nInt 1 Conf. Prmc\u00adtionid Pr-ugmmming, 1997. [6] Franco Barbarrera, Mariangiola Dezani-Chncaglini, and \nUgo de Llguoro. Intersection and union types: Syntax and aeman\u00adtics. Information and Computation, 119:202 \n230, 1995. [7] Hendrik Pieter Barendregt. Lambda calculi with types. In Sam\u00adson Abrsmsky, Dov M. GabbW, \nand Thomas S. E, Maibaum, editore, Handbook of Logic in Computer Science, volume 2, chapter 2, pages \n117 309. Oxford University Press, 1992. [8] Jonathan Eifrig, Scott Smith, and Valery lMfonov, Type in\u00adference \nfor recursively constrained types and its application to 00P. In Proc. 1995 Mathematical Foundations \nof Program\u00adming Semantics Conf. Elsevier, 1995. [9] John Hannan. TvDe svstems for closure conversion. \nIn kVork\u00ad~hop on ~ea ~or ~rogram Anatuaia, pages 48-62, 1995. DAIMI PB-493. [10] NevinHeintze.Control-flowanalysisandtypesystems.In \nPro.. 2nd Jnt 1 Stattc Analysis S~mp., pages 189-206, 1995. [11] Suresh Jagannathan and Stephen Weeks. \nA unified treat\u00adment of ffow analysis in higher-order languages. In Conf. Rec. 22nd Ann. ACM SUmp. Principles \nof Programming Lan\u00adguages, pages 393-407, 1995. [12] Suresh Jagannathan and Andrew Wright. Flow-directed \ninlin\u00ading. In Proc. ACM SIGPLAN 96 Conf. Pr og. Language De\u00adsign /3 Implementation, pages 193-205, 1996. \n[13] Trevor Jim. Rarrk-2 type systems and recursive definitions. Technical Report MIT/LCS/TM-531, Massachusetts \nInstitute of Technology, November 1995. [14] Trevor Jim. What are principal typings and what are they \ngood for? In POPL 96 [23]. [15] A. J. Kfoury and J. B. Wells. New notions of reduction and non\u00adsemantic \nproofs of @-strong normalization in typed A-calculi. In Proc, 10th Ann, IEEE Symp. Logic in Computer \nSci., pages 311-321, 1995. [16] David Kranz, Richard Kelsey, Jonathan A. Rees, Paul Hudak, James Philbln, \nand Norman I. Adams. Orbit: An optimizing compiler for Scheme. In Proc. SIGPIIA N 86 S~mp. Compiler Construction, \npages 216-233, 1986. [17] Yasuhiko Minamide, Greg Morrisett, and Robert Harper. Typed closure conversion. \nIn POPL 96 [23]. [18] Greg Mnrrisett. Compiling with ~pea. PhD thesis, Carnegie Mellon University, 1995. \n[19] Simon L. Peyton Jones, Cordy Hall, Kevin Hammond, Will Par\u00adtain, and Phil Wadler. The Glaegow Haekell \ncompiler: a tech\u00adnical overview. In Proc. UK Joint Pmmework &#38; Information Technology (JFIT) Technical \nConf., 1993. [20] Benjamin C. Pierce. Programming with intersection types, union types, and polymorphkm. \nTechnical Report CMU-CS\u00ad91-106, Carnegie Mellon University, February 1991. [21] John PIevyak and Andrew \nA. Chien. Iterative flow analysis. Submitted, July 1995. [22] Conf. Rec. 21st Ann. ACM S~p. Principles \nof Pr-ogrornrning Languagee, 1994. [23] Conf. Rec. POPL 96: 23rd ACM Sgmp. Principles of Prog. Languages, \n1996. [24] John C. Reynolds. Design of the programming language Forsythe. In P. O Hearn and R. D. Tennent, \neditors, Algol-like Languageu. Birkhauser, 1996. [25] Zhong Shao. Compiling Standard ML for Eficient \nErecution on Modern Machines. PhD thesis, Princeton University, 1994. [26] Olin Shivers. Control Flow \nAnolVsis of Higher Order Lan\u00adguages. PhD thesis, Carnegie Mellon University, 1991. [27] Guy Steele. Rabbit: \nA compiler for Scheme. Technical Report MIT/AI-TR-474, Maesacbusetts Institute of Technology, 1978. {28] \nAndrew Tolmach. Combining closure conversion with closure analysis using algebraic types. Presented at \nACM SIGPLAN Types in Compilation Workshop, June 8, Amsterdam, January 1997. [29] Valery Trifonov and \nScott Smith. Subtyping constrained types. In Proc. W-d Int 1 Static Analgsie Sgmp., pages 349-365, 1996. \n[30] Mitchell Wand and Paul Steckler. Selective and lightweight clo\u00adsure conversion. In POPL 94 [22], \npages 435 445. [31] J. B. Wells. Intersection types revisited in the Church style. Manuscript, June 1996. \n[32] J. B. Wells, Allyn Dimock, Robert Muller, and Franklyn Tnr\u00adbak. A typed intermediate language for \nflow-directed compila\u00adtion. In Proc. 7th Int 1 .foirtt Conf. Theory &#38; Practice of Soft\u00adware Development, \nLine, France, April 1997. Springer-Verlag. Appendix: ACIL This appendix resents the essential definitions \nfor and the\u00adorems about A$ . For a more thorough explanation and a discussion of design decisions, see \n[32], an extended version of which is available from http: //www.cs.bu.edu/group6/ church/reports/. The \nstatement X a Y means that the syntactic entity X occurs properly within the syntactic entity Y; X ~ \nY has the same meaning except X and Y may be the same. A simple notion of reduction (n.o.r.) R is a pair \n(+R, CR) of a redex/contractum relation -~ and a set of reduction contexts CR. The statement M +R N means \nM is an R-redez and N isthe R-contmctum of M. For a simple n.o.r., M4 RN means M is transformed into \nN by contracting R-redexes in positions in M specified by an R-reduction context, i.e., there are a context \nC E CR with k holes ad terms M; and Ni for i G {1, ... ,k} such thatM E CIM1,... ,Mk] and N -CINl,...,Nk] \nand &#38;fi -R Ni fori E {l,... , k}. A wmposite n.o.r. R is a rule composing reduction steps of simple \nn.o.r. s; in this case M -+ RN means M and N are related by the rule. Writing ~R denotes the transitive \nand reflexive closure of +Jl . A term M is in normal form with respect to R, written R-nf (M), when there \nis no term N such that M ~R N. The statement M%R N means M-R N and R-nf (N). Figure 10 shows the syntax \nand semantics of the untyped language A~IL. Theorem A.1 (Confluence of Untyped Reduction). If M -e N1 \nand M ~~ N2., then there ezists M such that fil -t &#38; and N2 ~~ k . Figure 11 shows the syntax of \nour explicitly typed lan\u00adguage .4C1L. Convention A.2 (Bound Variable Names). For con\u00advenience, we zwwumeby \na-conversion that parallel (cf. defi\u00adnition 3.11) variable bindings use the same variable name. Our definition \nof type equality on recursive types is stan\u00addard [7]. We do not distinguish between equal recursive typea \nin any context, so we have no rules for folding or un\u00adfolding recursive types. We assume free type variables \ndo not occur (i.e., every type variable will be bound by p) in typing derivations and terms. Figure 12 \ngives the typing rules of ~CIL. If A is a type enm ronment, then A, z:r denotes A extended to map x to \ntype ~. The domain of definition of A is DomDef (A). A triple A 1-M :Tis a judgement. A derivation D \nis a se\u00adquence of judgments, each obtained from the previous ones by one of the typing rules. We write \nA l_ACILM :r via D to mean V is valid in AC L and Dendawith A1-M:r. In this case, D is a typing for M \nand M is well typed. The statement A l_ACILM :~ means there exists some D such that A kACILM : r via \nD. For any subset A~lL of AC[L, the statement A I-A21LM :r means At-M :r is derivable in that subset. \nThe notation M asserts that M is well typed and has type r. Theorem A.3 (Uniqueness of Typings). ForM \nE Term, there is at most one type environment A and type T such that DomDef (A) = FV (M) and A *~CIL \nM :~. The call-by-value reduction rules for our typed language ACIL are in figure 13. We assume terms \nare always kept in t-normal form. Untyped Syntax x,y, zE Var c E Constant d E UntCOntext ::= [ lalclzl \n#z.cl Az.cle1@b2 Ix cl,... ,en) I ?f e ( I ini C I case+ dbindzindl,... ,Cn V, N 6 UntTerm = {Cl[ ]@e} \nV UntValue ::= c I Az.111 ] X(il, . . ..on ) I in~~ Untyped Reduction AZ.M Q o -1~ if X:=V ()J1 7r,?x \nVl,....vn-..+~vi ifl<i<n ( ) .. .. case+ in~V bmd x m Ml, ... , ifl<i<n () in z ( w v .LKZ.M - i[z \n=o zfi)l Reduction contexts: Ct = { C Id 6 UntContext and ~ has exactly one hole} Figure 10: Untyped \nlanguage AS*L. Theorem A.4 (Subject Reduction). IfM +, N and A kACILM :r, then A kACILN : r. Theorem \nA.5 (Typed/Untyped Reduction Corre\u00adspondence). Ij A ~CIL M : r, then 1. ZjM +, N, then IMI -+C INI. \n2. Ij IMl +~ N, then there etists a term N where M +, N and IN[= N.   Theorem A.6 (Confluence of Typed \nReduction). Ij M-r N1andM~, N2, then there exist M{ and M; such that lM~l e lMjl and N1 -B~ M: and N2 \n+. M!. iyntax Shared between Types and Terms Q::=PIS S::=vl+ P::= A/x l,k~Label=N B # ~,+ c Label ~pes \na ~ TyVar p,o, r ::= o I UI+7J2 I Q[uI, . . ..un] I /.m.T v ::=alr 17ypeEquality o = 7 iff U(u) and U(T), \nthe infiniteunfoldings of a and T, are identical I?ype-Annotated Contexts CEContext ::= [ ] Ic Iz IW \n.c IA\\z7.c Ic1 @fc2 { Jqcl,... ,Cn) I n: C I coerce (u,T)C I let 2 = Cl in Cz I (in~C) I cases Cbindzin~l \n+Cl,...,r~+C* l ype Erasure (a partial function) ICI Ixrl ~~ Ipxr.cl A$x .c = h.[c[ c1 q C2 Ix(cl,... \n,Cn)l = X(lcll,.. . ,Icnl) Icoerce (u, T ir ? c = ir,xIcl 17r:c1 z in~lCl l(in~ C)rl 1[ II =[1  (Jc)Tl \n Ilet Zr = Cl in C21Z (A3.ICII) @ IC21 lcase+Cbindzin~~ +Cl,... ,7~+C~l ~-e+, lClbind zinlCll, . . ..lC~l \n(XZ.ICII) @ ICI if ICll = . . . ~ lCnl, lcaaev Cbindzinrl +Cl,...,7~*C~l = undefined otherwise. [C,l \nif[Clla...=lCnl,  IA(C1,... ,Cn)l . undefined otherwise. I ype-Annotated ~rms, Values, Parallel Contexts \nM,N E l&#38;m = {C [ the type erssure ICI 6 UntTerm } V6 Value ={C I the type erasure ICI E UntValue \n} Cp E ParContext = {CIthetypeerasureICIhssexactlyonehole} Syntactic Sugar for Examples bool = +[X[ ], \nX[ ]] true= (iny x ()) 00 f~~ (inj x ()) 00 (if Ml then Mz else Ms) = case+ Ml bind x in x{]+ M2, X[ \n]+ M3 where z is fresh Figure 11: Synt= of explicitly typed language AC*L. (const) (var) At-c:o A,z:rtx \n:r A,x:uk M:T (-+ elim) (+ intro) AkA&#38; .M:o~T AkM:u&#38;ir; AkN:u AFMQ~N:T V~=l. At-Mi :Ti AFM:u; \nu<T (x intro) (coerce)A+x(MI,. ... M~):x[TI, T~],T~] A !-coerce (u, T) M :T ~=l. At-Mi ,Ti; lA411~..~lMnl \n(A intro) A1-A(M1,..., Mn):AIT1, Tn],Tn] AEA4:P[T1 ,.. .,7n]; l<i<n (x ,A elim) AF~~A4:Ti AFM:Ti;l<i<n \nA,z:uk N: T; AFM:u (+,V intro) (let) A 1-(inf M)s[71  7n1:s[Tl,...,7n] Atletx =Min N:T AI-M:+[T1 ,.. \n., Tin]; V~=l. A, Z:T1 1-Mi :7 (+ elim) A1-case+ Mbindxinrl+ Ml,. ... Tna Mn:T AI-M: VIT1 ,... ,Tn]; \n~=l.A,~:~il-Mi:~; lM1lE...SIMnl (V elim) A1-caaev Mbindxinrl~ Ml, ,,, ,Tn~Mn:T Figure 12: Typing rules \nof explicitly typed language ACIL, Main Notion of Reduction for Type-Annotated lkrms M+. N M 3M , N \n. M+ M +CN &#38;t N () Computation Reduction letz =Vin M -c M [z:=V] c Vi ifl<i<n bind xinrl+M1,... ,r-+ \nM~ -.+Clet xTi = V in Mi ifl<i<n ~~? ri~?) Fz .M --+. M [Z:= (/kTr .M)] Reduction contexts: Cc = ParContext \nType-Annotation-Simpli fication Reduction *tletzr=Min N   (X-9 ~M x; A(M1, *t Mi ifl<i<n v . i ? ). \n. . . ..rn+Mn-tletzri =Nin Mi ifl<i<n ~O~r~~u,~~[~~~:.~fi~~NM1 --+tletxp=Nin M coerce (u1, T) coerce \n(p, q) M --v coerce (p, T) M Reduction contexts: Ct = { C IC E Context and C hsa exactly one hole} Figure \n13: Reduction rules of explicitly typed language JC*L.  \n\t\t\t", "proc_id": "258948", "abstract": "We present a new framework for transforming data representations in a strongly typed intermediate language. Our method allows both value producers (sources) and value consumers (sinks) to support multiple representations, automatically inserting any required code. Specialized representations can be easily chosen for particular source/sink pairs.The framework is based on these techniques:1. <i>Flow annotated types</i> encode the \"flows-from\" (source) and \"flows-to\" (sink) information of a flow graph.2. <i>Intersection and union types</i> support (a) encoding precise flow information, (b) separating flow information so that transformations can be well typed, (c) automatically reorganizing flow paths to enable multiple representations.As an instance of our framework, we provide a function representation transformation that encompasses both closure conversion and inlining. Our framework is adaptable to data other than functions.", "authors": [{"name": "Allyn Dimock", "author_profile_id": "81100363224", "affiliation": "Harvard University", "person_id": "P15557", "email_address": "", "orcid_id": ""}, {"name": "Robert Muller", "author_profile_id": "81407593283", "affiliation": "Boston College", "person_id": "PP39076288", "email_address": "", "orcid_id": ""}, {"name": "Franklyn Turbak", "author_profile_id": "81339533353", "affiliation": "Wellesley College", "person_id": "PP39080358", "email_address": "", "orcid_id": ""}, {"name": "J. B. Wells", "author_profile_id": "81341498152", "affiliation": "Glasgow University", "person_id": "PP39080916", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/258948.258952", "year": "1997", "article_id": "258952", "conference": "ICFP", "title": "Strongly typed flow-directed representation transformations (extended abstract)", "url": "http://dl.acm.org/citation.cfm?id=258952"}