{"article_publication_date": "08-01-1997", "fulltext": "\n Structuring Graphical Paradigms in TkGofer Keen Claessen Ton Vullinghs Erik Meijer OGI and Utrecht University \nUniversitat Ulm OGI and Utrecht University koen~cse. ogi. edu ton~inf ormat ik .uni-ulm. de erik~cse \n.ogi .edu Abstract In this paper we describe the implementation of several graphical programming paradigms \n(Model View Controller, Fudgets, and Fimctional Animations) uaing the GUI library TkGofer. This library \nrelies on a combination of monads and multiple-parameter type classes to provide an abstract, type safe \ninterface to Tcl/Tk. We show how choosing the right abstractions makes the given implementations surpris\u00adingly \nconcise and easy to understand. Introduction In his article Why Functional Programming Matters [7], John \nHughes explains that an important feature of a pr~ gramming language is the way in which a language provides \nglue for combining building blocks to form larger stmctures. The better the glue, the more modular programs \ncan be made. He argues that functional languages offer very pow\u00aderful kinds of glue like higher order \nfunctions and lazy eval\u00aduation. Further research evolved a new kind of glue: type and constructor classes \n[9]. Unfortunately, there used to be a separation between the imperative world, which had very useful \nbricks, but no glue, and the functional world, which had powerful glue, but no bricks. Recently however, \nthings changed when monads were introduced into functional programming [13, 18]. When using monads it \nbecomes possible to seamlessly introduce imperative features into a purely functional language. This \ntechnique is used in Z kGofer, a library in Gofer [8] that interacts with the imperative graphical toolkit \nTk [12]. On top of a few new primitive functions, a system is built that offers the programmer structural \naccess to the widgets of Tk. But, unlike Tk, widgets in TkGofer are typed and type classes are used to \ngroup different kinds of properties for widgets. This provides the functional programmer with a powerful \ntool for performing GUI programming. A criticism of the use of monads is that they lead to an im\u00adperative \nstyle of programming. A more functional way of Permission to make digital/hard copy of part or all this \nwork for personal or classroom use is granted without fee provided that copies are not made or distributed \nfor profit or commercial cidvan\u00ad tage, The copyright notice, the tide of the publication and its date \nappear, and notice is given that copying is by permission of ACM, Inc. To copy otherwise, to republish, \nto post on servers, or to redistribute to lists, requires prior specific permission and/or a fee ICFP \n97 Amsterdam, ND @ 1997 ACM 0-89791 -918 -1/97 /0006 . ..$3.50 coding GUIS without monads is, for example, \nFudgets [1]. We think, however, that monads are more generaf and offer more structure. This is shown \nby giving an elegant imple\u00admentation of Fudgets and ActiveX Animation [3]. Further\u00admore, we show that \nTkGofer is capable of expressing other well known graphical paradigms, such as the Model View Controller \n[10]. There are also other systems that try to integrate graphi\u00adcal user interaction in functional languages. \nExamples are Fudgets [1], Haggis [5] and sml.tk [11]. We believe that they do not capture the essence \nof what makes functional GUI programming concise, elegant, and powerfid. They lack using monads for imperative \nactions, combined with type classes for structure. As we shall see, constructor classes and multiple-parameter \ntype classes play a critical role in our system. The remainder of this paper is organized as follows. \nThe next section of this paper introduces TkGofer. The third section describes the integration of the \nModel View Con\u00adtroller paradigm in TkGofer. The fourth section shows an implementation of Fudgets. The \nimplementation of a func\u00adtional animation toolkit is discussed in section five. The last section compares \nTkGofer to a few other graphical func\u00adtional systems and discusses our results. 2 TkGofer In this section \nwe give a short introduction to TkGofer. For a more detailed description of TkGofer we refer to other \npapers [16, 17]. 2.1 Creating a GUI How do we write GUIS in TkGofer? To explain this we present a smalf \nexample. Figure 1 illustrates a picture of a decimal counter and the code that implements it. The user \ninterface shows five widgets: a window, a label, an integer display field, and two command buttons. The \nfunctions window, entry, and button create widgets each with a specific list of configuration options. \nThe effect of performing these actions is that Tcl/Tk creates a han\u00addle for the new widget. Via this \nhandfe we may modify the widget or specify its layout. The layout of the GUI is con\u00adstructed using layout \ncombinators. For example, the com\u00adbinator (<<) combines two widgets horizontally. The com\u00ad 251 counter \n: : GUI () counter = do w <-window [title Counter ] 1 c-label [text Value: , background green ] e f-entry \n[initValue O, background yellow ] p <-button [text - , command-(updValue pred s f-button [text 1+! , \ncommand (updValue succ pack (1 --(p<< e<<s)) Figure 1: A binator (---) combines two widgets vertically \nand aligns them. The function pack actually displays the combined widgetson the screen. When the user \npresses the + button, the function updValueis invoked. This function replaces the value oftheentry field \nby the incremented value (see also the next section). Likewise, if the user presses the - button, the \nvalue is decremented . The functions button and entry have the following signa\u00ad tures: button :: [conf \nButton] -> Uindow -> GUI Button entry :: GUIValue a => [Conf (Entrya)l -> Uindow -> GUI (Entry a) The \nsignatures reveal some interesting characteristics of Tk-Gofer. First, to provide widget objects with \na unique iden\u00adtity, they are created within the GUI monad. This monad is an extension of the standard \nIO monad. For the remainder of the paper it is sufficient, to assume that values of type GUI a represent \nactions that may have some side effect on the user interface (e.g. close awindow) andreturna value of \ntype a (e.g. the contents of a text-edkor). Second, widgets that handle user input are typed over their \ncontents. This type has tobean instance of the ch.ssGUIValue that defines parse andunparse methods. Third, \nunlike many other GUI libraries where information is just coded into strings, Tk-Gofer widgets have typed \nconfiguration options. Configura\u00adtion options specify theextermal appearance and behaviom of a widget. \nAlthough many differences between widgets ex\u00adist, slot ofoptions are shared, e.g., the function background \napplies to both theentry and the button widget. In Sect. 2.2 we explain how we use type classes to express \nthe common characteristics between different widgets. Another aspect, which is not obvious from the above \nsig\u00adnatures, is that we distinguish several kinds of widgets. A widget is either a window item, a menu \nitem, a canvas item ora toplevel item. This means that a widget may appear on a window, in a menu, in \na canvas or may act aa a container forother widgets. Type classes may beusedto express this property. \nThe signatures for window items are generalized by the following type synonym: type Uid w = [Conf WI \n-> Vindow -> GUI w The signature of button and entry may now be written as Uid Button and GUIValue a \n=> Wid (Entry a), respec\u00adtively. w w e)] w e)] w decimal counter 2.2 The TkGofer Widget Hierarchy \nTo constrain functions to a specific class of widgets we in\u00adtroduce a hierarchy oftype classes (Fig. \n2) . - The root class, Uidget, contains methods that apply to every widget, e.g., the function cset to \nupdate a configuration of a widget. class Uidget w where cset ::w-> conf w-> GUI () ... All other cl~ses \nin the widget hierarchy are subclasses of Uidget. The class HasCommand, for example, includes all widgets \nthat may be configured with a callback function. class Uidget w => HasCommand w where command :: GUI \n() -> Conf W As we saw in Fig. 1, buttons are the prototypical instance of this class. instance HasCommandButton \nwhere . . . To set the command of a button b to the function cmd, we can write cset b (command cmd) because \nevery instance of HasCommand also has the cset method. Another example of a type class is Has Input. \nIn this multiple\u00adparameter type class we group widgets that can handle user input. 1ts methods are overloaded \non both the widget type (like HasCommand) as well as on the input type. class Uidget (w v) => Has Input \nw v where getValue :: WV-> GUIV setValue :: w v -> v -> GUI () updValue :: (v -> v) -> w v -> GUI () \n An example instance of this class are entry fields. instance GUIValue v => HasInput Entry v where ... \n The values that can be displayed in an entry field are re\u00adstricted to instances of the class GUIValue \n(e.g. String and Int). 252 ~ ; Ha,l d,cater HasHe>ghC Xa,Pad I I HasAnchor HasText HasWidth HasScroll \nI HasFillCCJ1.ar HasForegr.un Ha.B.rd.r HaaPo. it ion I I H.sc.. rds Hascalua d HasE!ackground / H.*Input \nI zWidg.t Tkw,*.t Figure Z: The TkGofer widget hierarchy  2.3 Extending TkGofer Using the TkGofer primitives, \nit is possible to present the whole functionality offered by Tcl/Tk to the Gofer program\u00admer. But we \ncan go further; using higher order functions and aIgebraic datatypes we can easily roll our own custom \nwid\u00adgets. Making such abstractions is hard to do in Tcl/Tk and in most other GUI Libraries. As a concrete \nexample of a composed widget, we build a spin button [6]. A spin button is often used to control a value \nthat can be incremented and decremented. The spin button widget actually consists of two other widgets: \na spin-up button and a spin-down button (see Fig. 3). a ~ Figure 3: The spinbutton widget How do we \nimplement this new widget? First, we define a type for the new widget. 1 type SpinBut t on = WItem (Button, \nButton) We use the redefined .. constructor WIt em. to indicate . tvDe that this is a widget that can \nbe placed in a window. A SpinButton now also contains some information about its graphical properties. \nWe can access the two buttons by using the function wit em. data WItem u = ... witem :: WItem u -> w \n*In Gofer, a type declaration will only create a new type if it is a datatype or a restricted type. To \nmake the presentation clearer we will use type synonyms as if they worked ss restricted types, so that \nthey can be made instance of constructor classes. The exact layout of the widget is specified in the \nconstruc\u00adtion function spinButt on. spinButt on :: Uid SpinButton spinButton cs w = do bl ~-button [bitmap \nup. bmp ~ u b2 ~-button [bitmap dn. bmp ] w composeWidget (bl ,b2) (bl b2) cs The function composeW \nidget takes care of the extra admin\u00adistrateive information for the WIt en structure. We have to make \nsure that the configuration options are cor\u00adrectly distributed over the components of the composed wid\u00adget. \nTherefore, we overwrite the default method for cset. instance Widget SpinButton where cset wc = do cset \n(fst (uitem v)) (const (c v)) cset (snd (uitem w) ) (const (c v) )  Finally, we make SpinButton an instance \nof the classes Has-Background, and HasForeground and we define the widget specific configuration options. \nspinUp, spinDn :: GUI () -> Conf SpinButton spinUp c u = option (cset (fst (witem u)) (command c)) spinDn \nc v = option (cset (snd (uitem w)) (command c))  inexactly thesame way, the combination ofa spin button, \nan entry field, and a label can be hidden in a new widget. We will call this widget the Spinner widget. \ntype Spinner v = WItem (Sntry v, Label, SpinButton) spinner :: PredSucc v => Hid (Spinner v) spinner \ncs v = do e<-entry [] w 1 <-label [] w  253 s <-spinButton mode: [ spinUp (updValue succ e) Tree II \nspinDn (updValue pred e) iw r composeWidget (e,l,s) ((e --l)<< S)CS  Thelabel is used to display some \ntext string. The spinner widget only controls values which areaninstance of the class PredSucc. Thk. \nclass defies thefunctions predandsuccto calculate predecessor and successor values for some type a. WemakeSpinner \naninstanceofthe ckissesWidget,HasText, HasCommand,and HasInput and we overwrite the methods getValue \nand setValue. instance PredSucc v => HasInput Spinner v where getValue = getValue . fst3 . witem setValue \n= setValue . fst3 . witern  If we use the spinner widget instead of the two command buttons, we can \nreimplement the example of Fig. 1. The new implementation and a picture (see Fig. 4) are given below. \n counter2 :: GUI () counter2 = do w <-window [1 s <-spinner [text value , initValue O] w pack s Figure \n4 A spinner: a counter with a spin button Composing widgets is afle.xible way to construct reusable building \nblocks. Composeci widgets can be integrated in the widget hierarchy, thus inheriting the properties oftheir \ncomponents. 3 The MVC Paradigm The basic widget layer of TkGofer, and the ability to ex\u00adtend this layer, \nallows us to write further abstractions. One of these is the Model View Controller paradigm (MVC). The \nMVC paradigm is one of the oldest object-oriented design paradigms [10]. It provides a modular way to \nrep\u00adresent information (Model), to display information (View) and to control the interactions with the \ninformation (Con\u00adtrol). The main idea is to support several views of the same data. Changes in one view \nshould be reflected in all the other views. As an example, consider a debugger that offers functions \nto display a syntax tree. The tree represents the model. Possible views are a textual and a graphical \nrepre\u00adsentation of the tree. The controller keeps the two views consistent (see Fig. 5). Control * *.. \n. (w. b ,!.1, ,!.2,, ,Ned.c (L3),  Q$ltl VW 2 Figure5: Theh4VCpamdigm 3.1 The Controller A controller \nhas to know which model (value)it hastoob\u00adserve. If a certain view changes, the view will send the con\u00adtroller \na message containing the new value. Subsequently, the controller will send a message to all dependent \nviews to tell them they have to change as well. Thus, the controller also has to know which viewsit has \nto control. We represent the ability to send a message by a function with the following type: type Send \na=a-> GUI() when we apply this function to a message of type a, it returns an action of type GUI (), \nwhich will, when executed, send the message. This concept is sometimes called aselj addremecienuelope. \nThe controller gets an envelope (of type Send a) from the view, that isusedto return messages (of type \na) to the view. Wedefine thecontroller as an abstract widget, i.e. a widget without a graphical representation. \ntype Control v = (State v, state [Sendvl) The fist component of Control is am updatable state con\u00adtaining \nthe value of the model. The second state keeps a list of dependent update methods for the model. States \nare also abstract widgets. Anew state iscreated using the func\u00adtion state. Using getValue andsetValue \nwecanaccesstbe state. The function control creates a new controller object. control :: [Conf(Control \nv)] -> GUI(Control v) control cs = do v C-state [] m <-state [ initValue [1 1 composeAbeUidget (v,m) \ncs The function addHethodaddsa new update method tothe method list of the controller: addlfethod :: \nSend v -> Control v -> GUI () addHethod send (v, m) = updValue (send :) m WemakeControl instance oftheclasses \nMidget andHasInput: instance Vidget (Control v) where . . . instance HasInput Control v where 254 getValue \n= getValue . fst setValue (v, III) x = do setValue v x fs <-getValue n seqs[fxlf<-fs] In this declaration, \ngetValue will read the actual value of the model. The fun~tion setvalue updates the model and the dependent \nviews. The standard function seqs :: [GUI () I -> GUI () executes a list of actions in that order.  \n3.2 Adding Views Different views are represented by different widgets. For each view we have to implement \ntwo functions. The function updat eV iev specifies the way the controller has to send a message to update \nthe view. The function invokeV iew is to tell the view how to send the controller a message when someone \nchanges the view. The functions are methods in the class View. This class takes two parameters. The first \none corresponds to the view and the second one to the model we want to control. class Vieu w v where \nupdateView :: w -> Send v invokeView :: w -> Send v -> GUI () Based on these two functions we introduce \na new configura\u00adtion option. Configuring a widget w with the option mvc c means that w will be controlled \nby controller c. mlc :: Vieu w v => Control v -> Conf u mvccu= opt ion (do v <-getValue c updateVieu \nw v invokeView w (setValue c) addHethod (updateView u) c) If a widget w is created and controlled by \ncontroller c, it will first read the value of c and set its own value to this value. Furthermore, w will \ninstall its own invoke method, so that w will send its displayed value to c as soon as it is changed. \nFinally, the update method for u is added to the method list of c. As an example, we make Spinner an \ninstance of the class View instance Vieu (Spirmer v) v where updateView = set Value invokeVieu v f = \ncset w (command (do v <-getValue w fv)) When the user presses one of the spin controls, the spinner wiU \nread its value and send it to the controller. The spinner updates its value by performing a setlfalue \nwith the new controller value. 3.3 Example In the following example we use the MVC paradigm to con\u00adtrol \nan integer value bya spinner widget and a scale widget. A scale widget is a widget that displays an integer \nvalue and allows users to edit this value by dragging a slider, The Vieu instance for Scale is written \nin a similar way as the in\u00adstance for Spinner. Both widgets are on the same window. On every window there \nis a copy button. When the user presses this button, a copy of the window is made and two new views are \ncreated. Figure 6: The MVC ezample vievs : GUI () vieus = do C <--control [ initValue 8 J copy c where \ncopy c= do w <-iiindou [ title WC ] v <-vscale [ text View 1 , mvc Clv i <-spinner [ text Vieu 2 , nvc \nClu b <-button [ text Copy View command (COPY C) i w pack ((v << i) --b) The function v ieus creates \nan initial controller. and calls the function copy to open the first window. Each time the button is \npressed, this function is called again, thus creating a copy of the window and adding the scaler and \nthe spinner widget to the controller. This example only shows the basic principles of the MVC paradigm. \nIts benefits are of course better expressed in larger applications. The MVC paradigm tries to abstract \nfrom low level event programming and hides the commu\u00adnication between widgets in a few primitive functions. \nIn the next section we will see Fudgets, which are another ap\u00adproach to make the communication between \nwidgets more implicit.  4 Implementing Fudgets In this section we will explain what Fudgets are [1], \nand discuss how to implement them in TkGofer. 4.1 The GUI Framework The main abstraction used in the \nFudgets system is called a Fudget (Functional Widget). A Fudget is an object consist\u00ad 255 ing of two \nparts. One is the graphical representation of a Fudget, the other is its functionality. For example, \na button Fudget is, for the user, a visible object in a window, that can be clicked. The programmer can \nspecify the properties of such a button, i.e. what to do when the button is clicked. A Fudget can send \nand receive messages of particular types: the button Fudget sends out a Click whenever the user presses \nit and the programmer can send a Bool to the button to change its activity status. A Fudget that receives \nmes\u00adsages of type a and sends messages of type b has the type F a b. Only the types of the messages determine \nthe type of a Fudget. A button Fudget has the type F Bool Click, but inpnnciple anyotherl%dget can have \nthat same type. The Fudgets system offers the programmer atomic Fudgets, such as buttons and entry fields. \nThey can be combined, using combinatore, to build larger Fudgets. Different combi\u00ad nators provide different \nways of plumbing message streams. We will discuss twocomblnators: serial and cross composi\u00ad tion. (>==<) \n:: Fbc->Fab->Fac * ... .-. . ---\u00ad   - ra- c Figure 7: Serial composition Serial composition (Fig. \n7) just plugs the output stream of its right argument into the input stream ofits left argument. it has \na similar type as functional composition. (>*<) :: Fab->Fab->Fab ..... ...... ... ,.,. ...,.. Fa b .... \n,: a: lb ;: Fab .; ..,, ,.,. .... ,.. ..... ..- + ?ab Figure 8: Cross composition Cross composition (Fig. \n8) puts its two parameters in paraf-Iell, thus forming a new Fudget. Input messages are sent to both \nFudgets, the output messages of the internal Fudgets are combined to a single stream. 4.2 Fudgets in \nTkGofer We will implement some of the atomic Fbdgets and combi\u00adnatore in TkGofer. The first question \nis how to represent the type Fab. The main task of a Fhdget is to send and receive messages. We implement \na FMget as a function. The user of the func\u00adtion (another Fudget ) tells it how to send out a message. \nThe Fudget then returns a function that describes how to send in a message. (This part is also called \nthe receive func\u00adtion of the Fudget). We will reuse the type Send, as de\u00adscribed in Sect. 3.1. Since \nwe also also want to do graphical IO, we wrap this function in a monad. We call this monad the Fudget \nMonad (FM) and will define it later. For now, just consider FM as a bare GUI monad. type Fab=Send b-> \nFM(Send a) The next step is to define the combinators. Serial compo\u00adsition passes the function for sending \nmessages to the left Fudget, which results in a function for receiving messages. This function is passed \nto the right Fudget as the function for sending messages, which results in the receive function for the \nresulting Fudget. (Actually, this is just the flipped monadic composition 00). (>==<) :: Fbc->Fa b-> \nFac fudL >==< fudR = \\sendC -> do sendB <-fudL sendC sendA <-fudR sendB result sendA Cross composition \nis defined in a similar way. The sending function is passed to both Fhdgets. The final receive func\u00adtion \nis the combination of the receive fi.mctions of the two combined Fudgets, (>*<) :: Fab->Fab->Fab fudL \n>*< fudR = \\sendB -> do lsendA <-fudL sendB rsendA <-fudR sendB result (\\a -> do {lsendA a; rsendA a}) \nNotice that we do not worry about graphical IO yet, the FMmonad will take care of that. The only thing \nwe are concerned with here is the functionality of the Fudgets.  4.3 Atomic Fudgets To define atomic \nFudgets, such as buttons, we slightly ex\u00adpand the structure of the monadic type FR A button needs to \nknow in which window it is supposed to appear. There\u00adfore, we let FH be a reader monad in the type Uindou. \ntype FM a = Uindou -> GUI a instance Monad FM where . . . We make FM an instance of the monad type class. \nThis is done in the standard way [18]. The type of a button l%dget is F Bool Click; it sends Clicks and \nreceives Bools. The send function (the parame\u00adter of the Fudget) is set as a command of the button. The \nreceive function (the result of the Fudget ) modifies the activ\u00adity status of the button. Other atomic \nFudgets are defined in a similar way. 256 buttonF :: String -> F Bool Click buttonF s = \\send win -> \ndo b <-button [ text s , command (send Click) ] riin pack b result (cset b . active) Since weadded the \nextra itindowparameter, weneedafunc\u00adtion that puts aFudget in a window. For this, the Fudgets library \nprovides the function shellF. We implement this function by creating a window, and passing it as a parameter \nto the given Fudget. shellF :: String -> Fab->Fab shellF s fud = \\send win -> do win <-window [ title \ns ] fud send win 4.4 Placers Since we pack a widget as soon as we create it, an atomic Fudget is just \nput in an arbitrary place in its window. Of course, we want to manipulate the layout of the graphi\u00adcal \nobjects in a Fudget. The Fudgets system haa different ways of doing this. One of them is to provide layout \nmodi\u00adfiers, called placers, such as horizontslP and matrixP. The function placerF takes such a placer \nand a Fudget, and rear\u00adranges the layout of the intemaf Fudgets within that Fudget, according to the \nplacer. To implement this, we need to know which atomic widgets are contained in a Fudget, Therefore \nthe FM type is extended to be a writer rnonadof a list of Frames. In TkGofer, a Frame is a widget with \nonly graphical properties. Since they form the superclass of all window items, every widget can be transformed \ninto such a Frame. Hence, our final type for FM becomes: type FM a = Uindow -> GUI (a, [Frame]) It is \nagain standard to define the monadic functions for this type. Instead of packing a Fudget as soon as \nwe create it, we need to add it to the list of frames. When creating an atomic Fudget, we do not pack \nthe widget, but, after some necessary lifting, use the following function instead: rrriteFrame : : Widget \nw => w -> FM () uriteFrsme wid = \\win -> do fr <-frame [] wid result ((), [frl) A placer is basically \na list-of-frames transformer. The func\u00adtion placerF applies this transformer to the internal list of \nframes, thus obtaining a new Fudget. type Placer = [Frame] -> [Frame] placerF :: Placer -> Fab->Fab placerF \nplacer fud = \\sendS win -> do (sendA, frames) <-fud sendf3 win result (sendA, placer frames) There are \nalready placer-like functions defined in the Tk- Gofer prelude. W;e reuse them to obtain the following \nplac\u00ad ers. horizontal frs = [horizontal frs] vertical P frs = [vertical frsl matrixP n frs = [matrixn \nfrsl   4.5 Stream Processors Plugging the message streams of one Fudget directly into another is often \nnot what we want. Sometimes, messages are not compatible, or some intermediate computation is needed. \nTherefore, the Fudgets system introduces stream processors. SP s are just like Fudgets, but they only \nhavea functional behavior on messages, and do not have a graph\u00adical representation. For this reason, \nthey are also called abstract l%lgets. SP S are solely used to act on a message stream. SP S are also \ntyped by their messages. An SP of type SP a b receives messages of type a and sends messages of type \nb. SP S are defined in a continuation passing style. There are three primitives for constructing SP S. \nputsP ::[b]->SPab->SPab getSP ::(a->SPab)->SPab nullSP :: SP a b The function putsp sends the messages \nin its first argument and then continues with its second argument. The SP get.W waits for a message, \nand then applies that message to its first argument, which defines how to continue. Finally, nullsp terminates \nthe reception and sending of messages. How do we implement stream processors in TkGofer? First of all, \nwe cannot use the same type as Fudgets have. Because of the way get SP defies the reception of messages, \nan SP can redefine its behavior for incoming messages. Therefore we do not want the outside world to \nact the same every time a message is sent to an SP (like we did with the type F). An SP can change its \nown behavior. Another observation is that SP S can be described as a purely functional structure; we \ndo not need any of the extras the GUI monad offers. Therefore, we represent SP S by the fol\u00adlowing recursive \ndatatype. data SPab=SP [b] (a -> SPab) An SP can send out some messages but then has to wait for an incoming \nmessage. The definitions of putSP, get SP and nullSP are now straightforward. putSP rnesgs (SP mesgs \nfsp) = SP (mesgs ++ mesgs ) f sp getSP fsp = SP [1 fsp null SP = getSP (\\_ -> nullSP) To use this structure, \nwe need to turn an SP into a Fudget. The Fudgets library has a function absF to do this. Because SP S \ncan be used to create Fudgets that act like if they have state, our implementation of absF creates a \nstate for each SP in TkGofer as well. In that state it keeps the SP 257 that k wait.ing foramessag( \n(having thet~pea -> SP a b). Sending a message to an SP means: apply the waiting SP to the incoming message, \noliaining some outgoing messages to be sent and a new waiting SP. We put the new waiting SP back in the \nstate, and send off all the messages. 4.6 Looping Sometimes we want the output messages a Fudget produces \nto be fed back into the same Fudget. Using the combinators defined so far. we cannot do this. Therefore. \nsome exdicit combinat ors are introduced tying this cyclic knot. For ex\u00adample, the function loopF (Fig. \n9) copies alf its output messages and feeds them back as input messages. loopF :: Faa->F aa aa ?aa ml- \n Figure 9: Looping To define this function, we need a fixpoint operator on the FIJI monad. We use the \nlifted version of the generalized fixpoint operator for the GUI monad. fixGUI :: (GUI a -> GUI a) -> \nGUI a fixGUI f = do s c-state [] a <-f (getValue s) setValue s a result a fixFH :: (GUI a -> FFla) -> \nFMa This function first makes an empty State, from which the result of the function f is going to be \nread. After the result is computed, it is put in the State. We have to be carefuf not to read the result \nbefore it is produced. The reason why the traditional fixpoint on monads f ixfl, with type (a -> !4 a) \n-> N a, does not work here is that its parameter wants the computed value a, rather then the computation \nof that value !! a. In this case, this is too strict, and will resuft in unexpected behavior. loopF fud \n= \\send -> fixFFl (\\mself -> fud (\\a -> do self <-mself self a send a ))  To connect the output off \nud with its own input, we have to change its send function. Now, whenever sending a message out, it should \nalso send a message to itself. This is done by the function self, which is the result of the computation \nmself, provided by the fixpoint combinator.  4.7 An Example We will use the implemented combinators \nto build the spin\u00adner example from Sect. 2.3. First, we define the Fudget that displays the two spin \nbut\u00adtens. ignoring every input message, it can send out the functions succ and pred, that is, functions \nof type Int -> Int. The buttons are placed on top of each other. spinbutF :: F a (Int -> Int) spinbutF \n= placerF vert icalP ( (\\ Click -> SUCC) >=< buttonF + >*< (\\ Click -> pred) >=< buttonF - ) >=< nullF \n--ignore input  Further, we will need a processing core, which holds the state, and applies the functions \nsent by the buttons. This is a stream processor, that takes an extra argument, which is the initiaf value \nof the state. coreSP :: Int -> SP (Int -> Int) Int coreSPn=getSP (\\f -> let n =f n in putSP [n ] (coreSP \nn ) )  The main Fudget links an integer entry Fudget, the proces\u00adsor, and the together. Further, we \nadd a loop to provide a connection between the output of the entry and the core we want the user to \nbe able to update the state as well. aEl ttcar spinF :: F Int Int spinF = placerF horizontal ( 100PF \n( intF >=< coreSP O >=< (mapF const >*< spinbutF) )) Anextra feature we implemented (that isnotin the \noriginal Fudgets library) is the combinator (>=<). Using Gofer s type classes, it generalizes the three \nnotions of Fudget, SP, and function in a Fudget composition. As a result we do not explicitly have to \nturn a function or an SP into a Fudget. It is interesting to look at the differences between delining \na new Fudget and a new widget. First, alf Fudgets are in\u00adstances of the type F a b, where a new widget, \nbecause of type safety, is always a new type. Second, the state for the spinbutton is in Fudgets stored \nin a separate stream pro\u00adcessor, where in TkGofer the widget knows its own state. Third, because every \nFudget has exactly one input and out\u00adput stream, we sometimes end up explicitly blocking or com\u00adbining \nstreams. 4.8 Executing Fudgets The last step is a function that executes a Fudget. We call this function \nf udgeGUI, since it translates a Fudget into the GUI type. 258 fudgeGUI :: F a b -> GUI () fudgeGUI \nfud = do (-, frs) <-fud noSend noUindow seqs [pack f If <-frs ] uhere noSend = \\_ -> result () noblindou \n= error window? It gives the Fudgeta dummy window (since it is supposed to be wrapped ina windowby shellF)and \nadummy send function, and packs all the frames. 4.9 Remarks In this section we gave an implementation \nof Fudgets. We believe that our implementation is very concise, and can, for example, easily be used \ntoexpenment with adding non\u00adstandard features to Fudgets. Our full implementation [2] implements many \nother of the basic Fudget functions and runs all the examples from the Fudgets tutorial unchanged. During \nthe writing of this paper we became aware of an un\u00adpublished technical report [15], in which an approach \nsimilar to ours was used to implement Fudgets [14]. However, they had difficulties with defining SP S \nand loops. 5 Functional Animations In this section we will discuss a way of expressing and ex\u00adecuting \nanimations. This will be done in the context of a functional animation system that is heavily inspired \nby Conal Elliot s Reactive Behavior Modelling in Haskel/ [4]. RBMH is an implementation in Hugs of Actioe~ \nAnimation [3]. 5.1 Behaviors The system s main abstraction is the notion of behavior. A value of type \nBeh a represents a dynamic value of type a that can change during the animation. For example, if Image \nis the abstract type of static images, than a value of type Beh Image is an animation. But all other \ntypes can also be used in combination with the behavior type. We can view a value of type Beh a as a \ndependent value. On what is that value dependent? Certainly on time,since an animation changes in time. \nA behavior also has a reactive component. This means that an action of the user, such as clicking or \nmoving the mouse, can influence a behavior too. Therefore, a behavior is also dependent on events, We \nrepresent time and events by the following types. We will not discuss here how we can use events to change \nbehaviors. type Time = Float data Event = LeftH I RightH I HoveH (Int, Int)  Another observation we \ncan make is that time flows forward. We will never jump back to earlier points in time. Since a behavior \nsometimes restructures itself according to time or certain events, we want to be able to throw away old \ninformation and create a fresh behavior. That is why we adapt the following definition for the type Beh. \nSince it is recursive, we use a datatype. data Beh a = Beh (Time -> [Event] > (a, Beh a)) A behavior \nof a is a function that takes a time and some events, and will return a value of type a plus a new behavior, \nto be used next time. One of the basic functions over this type is the funtion time, which is a behavior \nover Time. We can use time inside an animation, for example when we want to animate a clock. time :: \nBeh Time time = Beh (\\t --> (t, time)) Further, there exist several lifting functions. These trans\u00adform \nfunctions that act on normal values into functions that act on behaviors. We gave the definition of one \nlifting func\u00adtion. The others are defied in a similar way. lift :: a-> Beha lift a = Beh (\\. --> (a, \nlift a)) liftl :: (a -> b) -> (Beh a-> Behb) lift2 :: (a->b-> c) -> (Beh a-> Behb-> Behc)  The property \nof RBMH that we will focus on here is that an\u00adimations can be specified in a functional way. Using atomic \nbuilding blocks, animation modifiers and combinators we can build very complex animations in a charming, \nintuitive and concise way.  5.2 Images We will use the type Image for static images. Images are drawn \non a canvas, a TkGofer drawing area that can be used to display graphical objects. Another parameter \nim\u00adages take is their place on the canvas, expressed as a coordi\u00adnate. Having taken these parameters, \nan image will return a GUI action that will draw the image. type Image = (Int, Int) -> Canvas -> GUI \n() Of course, we can add an arbitrary number of extra param\u00adeters, such as color, size, etc. To keep \nthings simple, we will not do that here. Using the TkGofer functions ctext and cbitmp, which draw text \nand bitmaps on a canvas, we can define some primitive image behaviors. bitmapIm :: String -> Beh Image \nbitmapIm file = lift ( cbitmap [bitmap file] ) text Im :: String -> Beh Image text Im string = lift ( \nctext [text string] ) Because these behaviors are just lifted static images, they are constant animations. \nCombmatore that act on behav\u00adiors can change this. One of them is move, which moves 259 an image according \nto a behavior that specifies its coordi\u00adnate. Another combinator for images is over, which takes two \nimages and combines them into a single one. move :: Beh (Int,Int) -> Beh Image -> Beh Image move = lift2 \n(\\dxy img -> \\xy can-> img (xy+dxy) can) over :: Beh Image -> Beh Image -> Beh Image over = lift2 (\\imgl \nimg2 -> \\xy can-> do {imgl XY can; img2 XY can}) The implementation of these combinators is done with \nlift\u00ading. The last function we discuss forimages is the onethatac\u00adtually draws a(static) image on a given \ncanvas. drauIrn :: Canvas -> Image -> GUI () drauIrn can img = img (maxX/2,maxY/2) can It provides the \nimages with its parameters, using a default coordinate, which is the middle of the canvas. 5.3 Time The \nstructure we chose for behaviors admits another inter\u00adesting feature. Because a behavior gets the time \nas a pa\u00adrameter, rather than some global variable, we can introduce local times. We can give a behavior \na different time than the actual time. This principle is called time transformation. We present an example. \nThe function later puts a behavior further in time. This means that its time changes, and its events \nshift accordingly. All events for the behavior are delayed, in order to let them arrive at the right \ntime. To do this, we have a function SP1itstore that takes a time and a store containing timed events. \nThe function splits the store up in events that should occur now and events that will occur later. type \nStore = [(Time, [Event]) 1 splitStore :: Time -> Store -> ([Event] ,Store) splitStore t ((t ,es) :st) \nI t >= t = (es, st) splitStore t St = ([1, St) The function is a simple function that we will only use \nfor the function later. It considers the store to be a queue of delayed messages. Now, we can define \nthe function later. later :: Time -> Beh a -> Beh a later dt = delay [1 uhere delay store (Beh beh) = \nBeh (\\t evs -> let t =t+dt store = store ++ [(t, evs)l (nou, later) = split Store t store (a, beh ) = \nbeh t 9 now in (a, delay later beh )) The local function delay keeps the store of the delayed events. \n[t computes the new time and extracts the right events from the store. Then it gives the time and the \nac\u00adcording events to the behavior that is being delayed. 5.4 Animation Though we defined a function \ndrauIm for drawing static im\u00ad ages on a canvas, we still do not have a function that will execute dynamic \nimages, that is animations. Recall that animations have the type Beh Image. To define the function drawAnim, \nlet us first look at anima\u00adtions not dependent of user actions. In this case we can completely ignore \nthe events part of behaviors. drauAnim :: Canvas -> Beh Image -> GUI () drawAnim can beh = loop 0.0 beh \nwhere loop t (Beh beh) = do let (img, beh ) = beh t drauIm can img loop (SUCC t) beh Wecreate asimple \nloop that starts with time O, It extracts the image from the behavior, then it draws the image, and calls \nitself with the new behavior for the next point in time. Unimportant remark should be made here. Since \nbehaviors are infinite, this loop goes on forever. We have to be careful that the program is still able \nto react on user actions. The solution we chose for this, is to make a concurrent version of TkGofer. \nWe changed the definition of the GUI monad a little bit, so that all callback actions in the system are \nautomatically interleaved with existing actions. So, during this loop, thesystem will still notice user \nactions, and will concurrently execute the resulting callback func\u00adtions. Since adding concurrency adds \na lot of additional, but standard problems, this version of TkGofer is still in an experimental phase. \nThus, to allow user interaction in the animation, we can still use a loop. Additionally, we have to collect \nevents that hap\u00adpened during the animation. Mouse clicks and movements are stored in a state. We now \nnot only pass the time as a parameter to a behavior, but we get the right events from out of the state \nas well. drawAnim :: Canvas -> Beh Image -> GUI () drauAnim can beh = do stE <-state [ initValue [1 1 \ncsets can [ on (click 1) (updValue (LeftPl :) stE) , on (click 2) (updValue (RightPl :) stE) , onxy mouse \n( \\xy -> updValue (FloveH xy :) stE) 1 loop stE 0.0 beh ... The function drawAnim first creates a state, \nin which the events aregoing to recollected. Thenit sets some properties of the canvas, that will, in \nresponse to user actions, put the right events in the state. ... where loop stE t (Beh beh) = do evs \n<-getValue stE setValue stE [] let (img, beh~) = beh t evs drawIm can img loop stE (SUCC t) beh 260 \nThe loop function is a little bit extenclecl, It now also reacls and empties the event statr every time \na new image is drawn.  5.5 Example We present a small example that makes use of the functions we defined. \nThe example is made for RBMH by Sigbjom Finne, and is cafled Time flows like a river . It shows these \nfive words following the mouse pointer, every word placed in time a little bit later. In this way, the \nwords form a string that shows the history of the mousepointer (Fig. 10). Eku. flew Figure 10: Tame \njlows like a river river : : Beh Itnage river = compose (delay (follow imgs)) uhere compose = foldrl \nover delay = zipUith later [0.0, 2.0 ..] follow = map (move mouseXY) imgs = [ textIm s I s <-words Time \nflows like a river 1 A list of images following the mouse is created. Subse\u00adquently, every element in \nthe list is delayed. The last step is to overlay afl these images. Discussion In the last two sections, \nwe have seen ways of defining graph\u00adicaf structures, using atomic building blocks, modifiers and combinators. \nThe graphical and reactive parts alf relied on an imperative monad, the GUI monad. Imperative monads \nare often accused of mimicking impera\u00adtive code. But we showed that, by choosing the right types and \ncombinators, we can neatly hide this, and exploit the expressiveness offunctional programming. Andthis \nshowsthe realpowerofmonads. Wecantreatthem as first class values, allowing us to postpone, modify and \ncombine computations. We can even extend the monadic structure, giving us the same power as adding extra \nfeatures directly to the language. Thus, monads appear to be the ideal and most general func\u00adtional object \nto capture imperative actions. An intuition suggested by John Launchbury is that monads give us, in contrast \nto normal combiuators. the ability not only to com\u00adpose objects, but to name the intermediate result \nas well. This is what makes monads so general and powerful, Over the last few years, the integration \nof graphical 1/0 and func\u00adtional languages has become a popular research topic, 6.1 Related Work Haggis \n[5], like TkGofer, also uses monads to handle GUIS. One of its properties is the use of concurrent processes \nto manage callbacks, e.g., instead of specifying what a button must do when clicked, a new process is \ncreated that waits until the user clicks the button. A confusing drawback is however that Haggis uses \ntwo different handlers for every widget; one for the graphical layout and one for the func\u00adtionality \nof the widget. As we saw earlier, the Fudgets system takes a completely different approach. Though this \nseems very natural and refreshing at first sight, it appears to be rather awkward after some time. Everything \nwe want to send to a widget has to be coded into one datatype, since the Fudget type is restricted to \nreceive messages of only one type. Furthermore, the use of the combinators restricts us to the creation \nof planar graphs. Often the structure of information pasing in a GUI is much more complicated than that. \nWe end up with ad hoc methods for solving these kinds of problems. A system that also uses Tk as its \nGUI basis is smLtk [11]. Though provided with a nice toplevel partition in the con\u00adcepts application, \ngraphical object and window, the system lacks in certain points the elegance of TkGofer. Implemen\u00adtation \ndetails, like the creation of unique identifiers for wid\u00adgets, are not hidden for the programmer, and \nthe system is not type safe. 6.2 Conclusions Compared to the other systems, TkGofer does have some disadvantages \ntoo. Since Gofer is interpreted, and the im\u00adplementation uses character strings to communicate between \nGofer and Tk, programs tend to run slower. However, in most interactive applications, this is not noticable. \nMore often then not, the user is slower than the system. Further, many TkGofer programmers see it as \nbig advantage to be able to use an interpreted system. Furthermore, TkGofer does not support real concurrency. \nWe experimented with changing the definition of the GUI monad to deal with coarse concurrency, at the \nlevel of prim\u00aditive 10 actions. We also added forking and communication. Though we experienced some of \nthe standard concurrency problems, in most application this works fine, as we could see in Sect. 5. However, \nthe systems mentioned here lack one great feature that makes TkGofer fairly unique: structure. There \nis no hierarchy of widgets in any of these systems. For all the widgets we can specify the same properties. \nEither they are encoded in monomorphic fimctions or data constructors (Fudgets and sml-tk), or in strings \n(Haggis). We think this approach is unacceptable. Strong typing should be used to catch errors we make \nat compile time, instead of generating a run time error or unexpected behaviour. 261 The structure in \nTkGofer ]s primarily due to the heavy use of multiple-parameter type classes. This resulted in an ex\u00adpendable \nhierarchy of widgets, based on the functionality of the widgets. Similar structured GUI libraries where \nprevi\u00adously only available for object oriented languages (e.g., the Java AWT package). However, widget \nhierarchies for object oriented languages are in essence based on widget types, and therefore less intricate. \nMultiple-parameter classes enabled us to relate datat ypes and components of datat ypes. This gave us \nthe extra glue we needed to build this tool. The general architecture of TkGofer is not tightly coupled \nto Tcl/Tk, but can be reused to provide a type safe interface on top of any weakfy typed library such \nas ActiveX or other shell scripting languages.  Acknowledgements We wish to thank Byron Cook, Sigbjom \nFinne, Jay Hollings\u00adworth, Daan Leijen, and Wolfram Schulte for their helpful suggestions. We also thank \nThomas Nordin for joining us in implementing the animation library. References [1] M. Carlsson and Th. \nHallgren. Fudgets -a graphical user interface in a lazy functional language. In Confer\u00adence on Functional \nProgmmming and Computer Archi\u00adtecture. ACM Press, 1993. [2] K. Claessen. Fudgets Implementation. URL \nhttp:// www.cse.ogi,edul-kcclaesslFudgets, 1996. [3] C. Elliot. A brief introduction to ActiveVRML. Tech\u00adnical \nReport MSR-TR-96-05, Microsoft Research, July 1996. [4] C. Elliot and P. Hudak. Functional Reactive Anima\u00adtion. \nIn International Conference on Functional Pro\u00adgramming. ACM Press, June 1997. [5] S. Finne and S. Peyton \nJones. Composing Haggis. In Proceeding of the Fiflh Eurographics Workshop on Pro\u00adgramming Paradigms for \nComputer Graphics. Springer-Verlag, September 1995. [6] M. Halverton. Microsoft Visual Basic 5 Step by \nStep. Microsoft Press, 1997. [7] J. Hughes. Why Functional Programming Matters. The Computer Journal, \n2(2), 1989. [8] M.P. Jones. An introduction to Gofer, 1993. Included as part of the standard Gofer distribution. \n[9] M.P. Jones. Functional Programming with Overload\u00ading and Higher-Order Polymorphism. In J. Jeuring \nand E. Meijer, editors, Advanced Functional Program\u00adming, volume 925 of Lecture Notes in Computer Sci\u00adence, \npages 97 136. Springer-Verlag, 1995. [10] G. Kramer and S. Pope. A Cookbook for using the Model-View-Controller \nUser Interface Paradigm in Smalltalk-80. Journal of Object-Oriented Programming, 1(3):26-49, 1988. [11] \nC. Luth, S. Westmeier, and B. WOW, sml-tk Functional Programming for Graphical User Interfaces. Technical \nReport 8/96, Universitat Bremen, 1996. [12] J.K. Ousterhout. Tcl and the Tk toolkit. Addison Wes\u00adley, \n1994. [13] S.L. Peyton Jones and Ph. Wadler. Imperative Func\u00adtional Programming. In Proc. 20th ACM Symposium \non Principles of Programming Languages, Charlotte, North Carolina, January 1993. [14] A. Reid and S. \nSingh. Implementing Fudgets with stan\u00ad dard Widget Sets. In Glasgow Functional Programming Workshop, \npages 222-235, 1993. [15] C. J. Taylor. Embracing Windows. Technical Report TR-96-1, University of Nottingham, \nOctober 1996. [16] T. Vullinghs, W. Schulte, and T. Schwirm. An Intro\u00adduction to TkGofer. Technical Report \n96-o3, University of Ulm, June 1996. [17] T. Vullinghs, W. Schuke, and T. Schwinn. The De\u00adsign of a Functional \nGUI Library Using Constructor Classes. In D. Bjorner, M. Broy, and I. Pottosin, edi\u00adtors, Perspectives \nof System Informatics, volume 1181 of Lecture Notes in Computer Science, Novosibirsk, De\u00adcember 1996. \nSpringer-Verlag. [18] Ph. Wadler. The essence of functional programming. In ACM Principles of Programming \nLanguages, 1992. 262  \n\t\t\t", "proc_id": "258948", "abstract": "In this paper we describe the implementation of several graphical programming paradigms (Model View Controller, Fudgets, and Functional Animations) using the GUI library TkGofer. This library relies on a combination of monads and multiple-parameter type classes to provide an abstract, type safe interface to Tcl/Tk. We show how choosing the right abstractions makes the given implementations surprisingly concise and easy to understand.", "authors": [{"name": "Koen Claessen", "author_profile_id": "81100206977", "affiliation": "OGI and Utrecht University", "person_id": "P162548", "email_address": "", "orcid_id": ""}, {"name": "Ton Vullinghs", "author_profile_id": "81100154931", "affiliation": "Universit&#228;t Ulm", "person_id": "P284145", "email_address": "", "orcid_id": ""}, {"name": "Erik Meijer", "author_profile_id": "81100295095", "affiliation": "OGI and Utrecht University", "person_id": "P78826", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/258948.258972", "year": "1997", "article_id": "258972", "conference": "ICFP", "title": "Structuring graphical paradigms in TkGofer", "url": "http://dl.acm.org/citation.cfm?id=258972"}