{"article_publication_date": "08-01-1997", "fulltext": "\n Functional Reactive Animation Conal Elliott Paul Hudak Microsoft Research Yale University Graphics Group \nDept. of Computer Science conaltiicrosoft. com paul. hudak@yale. edu Abstract Run (Functional Reactive \nAnimation) is a collection of data types and functions for composing richly interactive, multi\u00admedia \nanimations. The key ide~ in Fran are its notions of behauiors and events. Behaviors are time-varying, \nreactive values, while events are sets of arbitrarily complex condi\u00adtions, carrying possibly rich information. \nMost traditional values can be trested as behaviors, and when images are thus treated, they become animations. \nAlthough these n~ tions are captured as data types rather than a programming language, we provide them \nwith a denotational semantics, including a proper treatment of real time, to guide reaacm\u00ading and implementation. \nA method to effectively and ef\u00adficiently perform event detection using interval analysis is also described, \nwhich relies on the partial information struc\u00adture on the domain of event times. Fran has been imph+ \nmented in Hugs, yielding surprisingly good performance for an interpreter-based system. Several examples \nare given, in\u00adcluding the ability to describe physical phenomena involving gravity, springa, velocity, \nacceleration, etc. using ordinary differential equations. Introduction The construction of richly interactive \nmultimedia anima\u00adtions (involving audio, pictures, video, 2D and 3D graph\u00adics) has long been a complex \nand tedous job. Much of the difficulty, we believe, sterna from the lack of sufficiently high-level abstractions, \nand in particular from the failure to clearly distinguish between modeling and presentation, or in other \nwords, between what an animation is and how it should be presented. Consequently, the resulting programs \nmust explicitly manage common implementation chores that have nothing to do with the content of an animation, \nbut rather its preaentation through low-level display libraries running on a sequential digital computer. \nThese implemen\u00adtation chores include: . stepping forward discretely in time for simulation and for frame \ngeneration, even though animation is con\u00adcept ually cent inuous; Permission to make digital/hard copy \nof part or all this work for personal or classroom use is granted without fee provided that copies are \nnot made or distributed for profit or commercial advan\u00ad tage, the copyright notice, the title of the \npublication and ita date  aPPear, and notice is 9iven that c0pyin9 is by permission of ACM, Inc. To \ncopy otherwise, to republish, to post on servers, or to redistribute to lists, requires prior specific \npermission and/or a fee, ICFP 97 Amsterdam, ND  @ 1997 ACM 0-89791 -918 -1/97 /0006 ...$3.50 capturing \nand handling sequences of motion input events, even though motion input is conceptually continuous; time \nslicing to update each timevarying animation Da\u00adrameter, e~en ~hough these parm ete~s conceptu~ly vary \nin parallel; and By allowing programmers to express the what of an interactive animation, one can hope \nto then automate the how of its presentation. With this point of view, it ehould not be surprising that \na set of richly expressive recursive data types, combined with a declarative programming lan\u00adguage, serves \ncomfortably for modeling animations, in con\u00adtrast with the common practice of using imperative lan\u00adguages \nto program in the conventional hybrid modeling/\u00adpresentation style. Moreover, we have found that non-etrict \nsemantics, higher-order functions, strong polymorphic typ\u00ading, and systematic overloading are valuable \nlanguage prop erties for supporting modeled animations. For these reasons, Fran provides these data types \nin the programming language Haakell [9]. Advantages of Modeling over Presentation The benefits of a modeling \napproach to animation are similar to those in favor of a functional (or other declarative) pr~ gramming \nparadigm, and include clarity, ease of construc\u00adtion, composability, and clean semantics. But in addition \nthere are application-specific advantages that are in some ways more compelling, painting the picture \nfrom a software engineering and end-user perspective. These advantages in\u00adclude the following: . Authoring. \nContent creation systems naturally con\u00adstruct models, because the end users of such systems think in \nterms of models and typically have neither the expertise nor interest in programming presentation de\u00adtails. \n . Optimizabiltty Model-baaed systems contain a presen\u00adtation sub-system able to render any model that \ncan be  constructed within the system. Because higher-level information is available to the presentation \nsub-system than with presentation programs, there are many more opportunities for optimization. . Regulation. \nThe presentation sub-system can also more easily determine level-of-detail management, as well as sampling \nrates required for interactive animations, baaed on scene complexity, machine speed and load, etc. . \nMobility and safety. The platform independence of the modeling approach facilitates the construction \nof mobile applications that are provably safe in World Wide Web applications. The Essence of Modeling \nOur goal in this paper is to convey the essence of a modeling approach to reac\u00adtive animations as captured \nin Fran, as summarized in the following four concepts: 1. Temporal modeling. Values, called behaviors, \nthat vary over continuous time are the chief values of inter\u00adest. Behaviors are first-class values, and \nare built up compositionally; concurrency (parallel composition) is expressed naturally and implicitly. \nAs an example, the following expression evaluates to an animation (i.e., an image behavior) containing \na circle over a square. At time t, the circle has size sin t, and the square has size Cost. bigger (sin \ntime) circle over bigger (COS time) square  2. Event modeling. Like behaviors, events are first\u00adclass \nvalues. Events may refer to happenings in the real world (e.g. mouse button presses), but also to predicates \nbaaed on animation parameters (e.g. prox\u00adimity or collision). Moreover, such events may be com\u00adbined \nwith others, to an arbitrary degree of complexity, thus factoring complex animation logic into semanti\u00adcally \nrich, modular building blocks. For example, the event describing the first left-button press after time \ntO is simply lbp tO; cme describing time squared being equaf to 5 is just:  predicate (time-2 == 5) \ntO and their logical disjunction is just:  lbp tO . I . predicate (time-2 == 5) tO 3. Declarativereactivity. \nMany behaviors are natu\u00adrally expressed in terms of reactions to events. But even these reactive behaviors \nhave declarative W+ mantics in terms of temporal composition, rather than an imperative semantics in \nterms of the state changes often employed in event-based formalisms. For ex\u00adample, a color-valued behavior \nthat changes cyclically from red to green with each button press can be de\u00adscribed by the following simple \nrecurrence: colorCycle tO = red untilB lbp tO *=> \\tl -> green untilB lbp t 1 *=> \\t2 -> colorCycle \nt2 (In Haakell, identifiers are made into infix operators by backquotes, as in b unt ilB e. Ahw, infix \nopera\u00adtors can be made into identifiers by enclosing them in parentheses, as in (+) x y. Lambda abstractions \nare written as \\ vars -> ezp .) 4, Polymorphic media. The variety of time-varying media (images, video, \nsound, 3D geometry) and pa\u00adrameters of those typea (spatial transformations, col\u00adors, points, vectors, \nnumbers) have their own type\u00adspecific operationa (e.g. image rotation, sound mixing, and numericaf addition), \nbut fit into a common frame\u00adwork of behaviors and reactivity. For instance, the unt ilB operation used \nabove is polymorphic, apply\u00ading to all types of time-varying values. Our Contributions We have captured \nthe four fea\u00adtures above as a collection of recursive data types, functions, and primitive graphics routines \nin a system that we call Pran, for Functional Reactive Animation. Although these data types and functions \ndo not form a programming lan\u00adguage in the usual sense, we provide them with a formal denotational semantics, \nincluding a proper treatment of real time, to allow precise, implementation-independent reaaon\u00ading. This \nsemantics includes a CPO of real time, whose ap\u00adproximate elements allow us to reason about events before \nthey occur. As would be true of a new programming lan\u00adguage, the denotational semantics has been extremely \nuseful in designing Fran. All of our design decisions begin with an understanding of the formaf semantics, \nfollowed by reflect\u00ading the semantics in the implemental ion. (The semantics is given in Section 2.) \nPerhaps the most novel aspect of Fran is its imp~icit treai!\u00adment of time. This provides a great deal \nof expressiveness to the multimedia programmer, but also presents interesting challenges with respect \nto both formal semantics and imple\u00admentation. In particular, events may be specified in terms of boolean \nfunctions of continuous time. These functions may become true for arbitrarily brief periods of time, \neven instantaneously, and so it is challenging for an implemen\u00adtation to detect these events. We solve \nthis problem with a robust and efficient method for event detection baaed on interval anal@s. (Implementation \nissues are discussed in Section 4.) Specifically, the nature of an event can be exploited to eliminate \nsearch over intervals of time in which the event provably do~ not occur, and focus intead on time inter\u00advals \nin which the event may occur. In some csses, such as a collection of bouncing balls, exact event times \nmay be deter\u00admined analytically. In general and quite frequently, however, analytic techniques fail to \napply. We describe intead an al\u00adgorithm for event detection based on interval analVsis and relate it \nto the partial information structure on the CPO of event times. 2 The Formal Semantics of I%an The two \nmost fundamental notions in Fran are behaviors and everuk We treat them as a pair of mutually recursive \npolymorphic data types, and specify operations on them via a denotational semantics (The media types \nwe often use with events and behaviors will be treated formally in a later paper; but see also [7].) \n 2.1 Semantic Domains The abstract domain of time is called Time. The abstract domains of polymorphic \nbehaviors (a-behaviors) and poly\u00admorphic events (a-events) are denoted 13ehavior~ and .Event=, respectively. \n Most of our domains (integers, booleans, etc. ) are stan\u00addard, and require no explanation. The Time \ndomain, how\u00adever, requires special treatment, since we wish values of time to include partial elements. \nIn particular, we would like to know that a time is at least some value, even if we don t yet know exactly \nwhat the final value will be. To make this notion precise, we define a domain (pointed CPO) of time as \nfollows: Denote the set of real numbers as R, and include in that set the elements co and m. This set \ncomes equipped with the standard arithmetic ordering ~, including the fact that Oo~z~oo forallz E!R. \nNow define Time = Y?+ R, where elements in the sec\u00adond copy of 3? are distinguished by prefixing them \nwith ~, asin ~ 42, which should be read: at least 42. Then define J-Time = ~ ( co), and the domain (i.e. \ninformation) ordering on Time by: It is easy to see that L Time is indeed the bottom element. Also note \nthat a limit point y is just the LUB of the set of partial elements ( pretimes ) that approximate it: \nSince the ordering on the domain Time is chain-like, and every such chain h= a LUB (recall that R has \na top element m), the domain Time is a pointed CPO. This fact is neces\u00adsary to ensure that recursive \ndefinitions are well defined. Elements of Time are most useful for approximating the time at which an \nevent occurs. That is, an event whose time is approximately ~t is one whose actual time of occurrence \nis greater than t. Note that the time of an event that never occurs is just co, the LUB of R. Finally, \nwe extend the definition of arithmetic s to all of Time by defining its behavior across the subdomains \nas follows: z<~yifx<y This can be read: The time z is less than or equal to a time thatk atleastY,ifz \nSu. (ZZ S vand~Z s ~yare undefined.) We can easily show that this extended function of type Time ~ Time \n~ Bool is continuous with respect to c. It is used in various places in the semantics that follows. Semantic \nl?unctions We define an interpretation of a-behaviors as a function from time to a-values, producing \nthe value of a behavior bat a time t. Next, we define an interpretation on cr-events as simply non\u00adstrict \nTime xa pairs, describing the time and information associated with an occurrence of the event. Occ : \nEvenk ~ Time x cr Now that we know the semantic domains we are working with, we present the varioua \nbehavior and event combinators with their formal interpretations. 2.2 Semantics of Behaviors Behaviors \nare built up from other behaviors, static (non\u00adtime-varying) values, and events, via a collection of \ncon\u00adstructors (combinators). Time. semantics The simplest is given by: primitive behavior is time, whose \ntime : BehaviorTime at[tirne]t = t Thus at[time] is just the identity function on Time. Lifting. We \nwould like to have a general way of lifting functions defined on static values to analogous functions \nde\u00adfined on behaviors. This lifting is accomplished by a (con\u00adceptually infinite) family of operators, \none for each arity of functions. hjtn:(al+ . ..-+ fl)+l)+ Behavior.l -...-Behavioral ~ Behauior@ at[lift~ \nj bl ...b~]t = f (at[bl]t) . . . (at[b~]t) Note that constant value lifting is just li~. Notational aide: \nIn practice, lifting is needed quite fre\u00adquently, so it would be inconvenient to make lifting explicit \neverywhere. It is more desirable to use familiar names like sin , cos , + , * , and even Iiterals like \n3 and blue , to refer to lifted versions of their standard interpretations. For instance, a literal such \nas 42 should behave as the con\u00adstant behavior li~ 42, and a summation on behaviors such as bl + bz should \nbehave as li~ (+) bl bz , where (+) is curried addition. In our implementation of Fran in Haakell, type \nclasses help considerably here, since the Num class providea a convenient implicit mechanism for lifting \nnumerical values. In particular, with a suitable instance declaration, we achieve exactly the interpretations \nabove, even for literal constants. Time transformation. A time transform allows the user to transform \nlocaf tim~frames. It thus supports what we call tempod modularity for behaviors of all types. (Sim\u00adilarly, \n2D and 3D transforms support spatial modulatit~ in image and geometry behaviors.) time lkan.sjorm : Behaviora \n~ Behavior Tame -Behavior. at [time I%msform b tb~ = at [b] oat [tb] Thus note that time is an identity \nfor time tinsform  time!fkansform b time= b As examples of the use of time transformation in Fran, the \nexpression: time !hnsforrn b (time/2) slows down the animation b by a factor of 2, whereas:  time Tkansjorm \nb (time 2) delays it by 2 seconds, Integration. Integration applies to real-valued as weli as 2D and \n3D vector-valued behaviors, or more generally, to vector-spaces (with limits). Borrowing from Haskell \ns type class notation to classify vector-space types: integml: VectorSpace o + Behauiora ~ Time ~ Behaviora \n at[integralb to]t = f: at [b] Integration allows the specification of velocity behaviors, and, if used \ntwice, acceleration behaviors. For example, if the velocity of a moving ball is given by behavior b (perhaps \na constant velocity, perhaps not), then its position relative to starting time toisgiven by tn.tegml \nb to. This provides a natural means to express physics-baaed animations, exam\u00adples of which are given \nin Section 3. Reactivity. The key interplay in Fran is that between behaviors and events, and is what \nmakes behaviors reactive. Specifically, the behavior b untilB e exhibita b s behavior until e occurs, \nand then switches to the behavior associated with e. More formally: untilB: Behaviora ~ EventBeha~ora \n~ Behaviora   at[b untdll e]t = if t< t,thenat[b]telseat[b ]t where (t., b ) = occ[e] Note that the \ninequality used here, tS t.,isthe one defined in Section 2.1. In the next section examples of reactivit \ny are given for each of the various kinds of events. 2.3 Semantics of Events Event handling. In order \nto give examples using spe\u00adcific kinds of events, we first describe the notion of event handlers, which \nare applied to the time and data associated with an event using the following operator: (-) : Even&#38; \n+ (Time ~ CY~ 9) + EventP occ[e -t+ f] = (t=, f t= x) where (t,, x) = occ[e] For convenience, we will \nalso make use of the following derived operations, whkh igmore the time or the data or both: (s) : Even&#38; \n+ (a+ /3) ~ Eventd (*+) : Even&#38; + ( Timed ~) ~ Event. (+) : Eueni&#38; ~ P -Eventfl ev-g = ev*Atx. \ngx ev *-h = ev-l+Atz. ht ev+z = m* Atz. z These different operator symbols are somewhat neumonic: (++) \nreceives afl of the parameters, ( *) receives none of the parameters, (*+) receives only the time, and \n(=) receives only the data. Constant events. The simplest kind of event ia one specified directly by \nits time and value. wnstEv: Time -a ~ Evenk occ[con3tEv t. z] = (t=, z) Thus, for example, the behavior: \nbl unti.lB (constEv 10 z)+ b2 exhibits behavior bl until time 10, at which point it begins exhibiting \nbehavior b2 (x is ignored in this example, but of course needn t be). External events. For this paper \nwe only consider one kind of external event mouse button presses-which can be from either the left or \nright button. The value associated with a button press event is the corresponding button release event, \nwhich in turn yielda a unit value (() is the unit type):  lbp, rbp: Time -EventEvento The meaning of \nan event /bp to, for example, is the pair (t., e), such that t.is the time of the fust left button press \nafter to,and e is the event corresponding to the first left button release after te.Thus the behavior: \nbl untilB (lbp to) = Ae. b2 untilB e+ bs exhibits behavior bl until the left button is pressed, at which \npoint it becomes bz until the left button is released, at which point it becomes bs. Predicates. It is \nnatural to want to specify certain events m the first time that a boolean behavior becomes true after \na given time. predicate : BehaviorBool h Time h Event. occ[predicate b to] = (inf {t > to [ at[b]t}, \n()) That is, the time of a predicate event is the infimum of the set of times greater than tOat which \nthe behavior ia true. Note that this time could be equal to to. The behavior: bl untilB (predicate (sin \ntime= 0.5) to)-+ bz thus exhibits bl until the first time tafter tothat sin tis 0.5, after which it exhibits \nbz. If the boolean behavior argument to ptiicate were an ar\u00adbitrarily complex computable function, then \npredicate would not be computable. To cope with this problem, we re\u00adstrict behaviors somewhat, to make \npredicate not only com\u00adputable, but alao efficient. We will return to this issue in Section 4.2. Choice. \nWe can choose the earlier of two events with the .1. operatcm (.1.) : Even&#38; -Even&#38; ~ Even~ occ[e \n.1. e ] = (t=, z), if t=< t: = (t~z ~cc~jherwiae where (t=, z) 1 (tj, d) = occ[e ] For example, this \nbehavior: bl untillil (fbp to .1. predicate (time> 5) to)+ bz waits for either a left button press or \na timeout of 5 seconds before switching from behavior bl to behavior ~. As an alternative, the following \nexample switches to a different behavior, b3, upon timeout.  bl untiE3 (lbp to -+ ~ .1. predicate (time> \n5) to+ b3) Snapshot. At the moment an event occurs it is often convenient to take a snapshot of a behavior \ns value at that point in time. snapshot : Even&#38; * Behauiord + EvenL xo occ~e snapshot b] = (t,, (z, \nat[b]t. ) ) where (t., z) = occ[e] For example, the behavior: bl untdB (Ibp tOsnapshot (sin time)) =+-A(e, \ny). bz ~abs the sine of the time at which the left button is preaaed, binds it to y, and continues with \nbehavior bz which pre\u00ad sumably depends on y. Although this example could also be achieved by grabbing \nthe time of the left button press event and computing its sine, in general the behavior be\u00ad ing snapshot \ncan be arbitrarily complex, and may in fact be dependent on external events. Event sequencing. lt ia \nsometimes useful to use one event to generate another. The event joinEv e is the event that occurs when \ne occurs, where e is the value part of e. joinEv: EVentEvent= + Event. occ~oinEv e] = occ[srtd (occ[e])] \n (This tinction is so named because it is the join operator for the Event monad [221.) For example, the \nevent  joinEv (lbp tO*+ prediwte (b= O)) occurs the first time that the behavior b has the value zero \nWer the first left button press after time tO.  3 Some Larger Examples The previous section presented \nthe primitive combinators for behaviors and events, along with their formaf semantics. The following \nexamples illustrate the use of some of these combhatora. The examples are given as Haskell code, whose \ncorrespondence to the formal semantics should be obvious. (All values in these examples are behaviora, \nthough we do not explicitly say sO.) To begin, let s define a couple of simple utility behaviors. The \nfirst varies smoothly and cyclically between -1 and +1. wiggle = sin (pi * time) Using Wiggle we can \ndefine a function that smoothly varies between its two argument valuea. vigglaliange 10 hi = 10 + (hi-lo) \n. (viggle+i) /2  Now let s create a very simple animation: a red, pulsat\u00ading ball. pBall = uithColor \nred (bigger (Wigglelkmge 0.5 1) circle)  The function bigger scales its second argument by the amount \nspecified by ik tirat argument; since the firat argument is a behavior, the result is also a behavior, \nin this case a ball whose size variea from full size to half its full size. A key attribute of Fkan ia \nthat behaviors are wmposable. For example, pBall. can be further manipulated, as in: rBall = move (vectorPolar \n2.0 time) (bigger 0.1 pBall) which yields a ball moving in a circular motion with radius 2.0 at a rate \nproportional to time. The ball itself is the same as pBall (red and pulsating), but 1/10 the original \nsize. Certain external phenomena can be treated as behaviora, too. For example, the position of the mouse \ncan naturally be thought of as a vector behavior. Thus to cause an image to track exactly the position \nof a mouse, all we need to do is: follovHouse im tO = move (mouse tO) im (The function move shifts an \nimage by an offeet vector.) Another natural way to define an animation is in terms of mtes. For example, \nwe can expand on the mous~follower idea by having the image follow the mow at a rate that is dependent \non how far the image is from the current mouse position. follovHouseRate im tO = move offset im inhere \noffset = integral rate tO rate = mouse tO .-. pos pos = origin2 . +-offset Note the mutually recursive \nspecification of of f set, rate, and pos: The offset starts out as the zero vector, and grows at a rate \ncalled rate. The rate is defined to be the dif\u00adference between the mouse s location (mouse is a primitive \nbehavior that represents mouse position) and our anima\u00adtion s position pea. pos, in turn, is defined \nin terms of the offset relative to the origin. As a result, the given image al\u00adways pursues the mouse, \nbut moves faster when the d~tance is greater. (The operation .+-adda a point and a vector, yielding a \npoint, and .-. subtracts two points, yielding a vector.) As a variation, we can virtually attach the \nimage to the mouse cursor using a spring. The definition is very similar, with position defined by a \nstarting point and a growing off\u00adset. This time, however, the rate is itself changing at a rate we call \naccel. This acceleration is defined in part by the difference between the mouse position and the image \ns posi\u00adtion, but we also add some drag that tends to slow down the image by adding an acceleration in \nthe direction opposite to its movement. (Increasing or decreasing the drag factor of 0.5 below creates \nmore or less drag. ) f olloui40useSpring im tO = move offset im vhere offset = integral rate tO rate \n= integral accel tO accel = (mouse tO .-. pos) -0.5 *-rate pos = origin2 .+-offset (The operator *-multiplies \na real number by a vector, yield\u00ading a vector.) As an example of event handling, the foUowing behavior \ndescribes a color that changes between red and blue each time the left button is pressed. We accomplish \nthis change with the help of a function cycle that takes two colors, c 1 and c2, and gives an animated \ncolor that starts out aa cl. When the button is pressed, it swaps cl and C2 and repeats (using recursion). \nanim12 tO = withColor (cycle red blue tO) circle where cycle cl C2 tO = cl untilB lbp tO *=> cycle C2 \ncl bounce minVal maxVal yO VO g tO = path Where path = start tO (yO,vO) start to (yo,vo) = y untilB< \ndoBounce +=> start where y = liftO yO + integral v tO v = liftO VO + integral g tO reciprocity = 0.8 \n doBounce :: Event (RealVal, RealVal) --returns new y and v doBounce = (collide snapshot pairB y v) \n==> snd ==> \\ (yHit,vHit) -> (yHit, -reciprocity * vHit) collide = predicate (y <=* liftO minVal &#38;&#38;* \nv<=*O II* y >=* liftO maxVal &#38;&#38;* v>=*O) tO Figurel: One-Dimensional Bounce Note that the Time \nargument in the recursive call to cycle is supplied automatically by *=>. The next example is a number-valued \nbehavior that starts out as zero, and becomes -1 while the left button is pressed or 1 while the right \nbutton is pressed. bSign tO = O untilB lbp tO ==> nonZero (-1) .1. rbp tO ==> nonZero 1 where nonZero \nr stop = r untilB stop *=> bSign  We can use the function bSign above to control the rate of growth \nof an image. Pressing the left (or right) button causes the image to shrink (or grow) until released. \nPut another way, the rate of growth is O, -1, or 1, according to bSign. grow im tO = bigger size im where \nsize = 1 + integral rate tO rate = bSign tO  A very simple modification to the grow function above causes \nthe image to grow or shrink at the rate of its own size (i.e. exponentially). grow) im tO = bigger size \nim where size = 1 + integral rate tO rate = bSign tO * size  Here s an example that demonstrates that \neven colors can be animated. Using the function rgb, a color behavior is created by tixing the blue component, \nbut allowing the red and green components to vary with time. uithColor (rgb (abs (COS time)) (abs (sin \n(2*time))) 0.5) circle As a finaf example, let s develop a modular program to describe bouncingballs. \nFiretnotethat thephysicalequ&#38; tions describing the position y and velocity v at time t of an object \nbeing accelerated by gravity g are: Y = yo+&#38;dt v . VO+~tO g dt  whereyoandvo aretheinitial position \nand velocity, respec\u00adtively of the object at time to. In Fkan these equationa are simply: y = liftO yO \n+ integral v tO v= liftO VO + integral g tO Next we define a function bounce that, in addition to computing \nthe position of an object based on the above equations, also determine when the ball h= hit either the \nfloor or the ceiling, and if so revereee the direction of the ball while reducing its velocity by a certain \nreczprocit~, to account for loss of energy during the collision. The code for bounce is shown in Figure \n1. Note that collision is defined as the moment when either the pcsition has exceeded the minVal and \nthe velocity is negative, or the position haa ex\u00adceeded themaxVal and the velocity ia positive. When \nsuch a collision is detected, the current position and velocity are snapshot, and the cycle repeats with \nthe velocity negated and scaled by the reciprocityy fact or. (The various opera\u00adtors with * after them \nare lifted versions of the underlying operators.) Now that bounce is defined, we can also use it to de\u00adscribe \nhorizontal movement, using O for acceleration. Thus to simulate a bouncing ball in a box, we can simply \nwrite: moveXY x y (withColor green circle) where x = bounce xMin xMax XO VXO O tO y s bounce yHin yMax \nyO vyO g tO where xMin, flax, yMin, and yMaxare the dimensions of the box. 4 Implementation Theformaleemantics \ngiveninSection 2couldalrnost serve aa an implementation, but not quite. In this section, we de scribe \nthe non-obvious implementation techniques ueed in Fran. One relatively minor item is integration. While \nsym\u00adbolic integration could certainly be used for simple behav\u00adiors, we have instead adapted standard \ntextbook numerical techniques. (We chiefly w fourth order Runge Kutta [17].) 4.1 Representing Behaviors \nAn early implementation impliwi in the formal sem of Fran antics: represented behaviors as data Behavior \na = Behavior (Time -> a) This representation, however, leads to a serious inefficiency. To see why, \nconsider a simple sequentially recursive reactive behavior like the following. b= toggle True O where \ntoggle val tO = lif tO val untilB lbp tO *=> toggle (not val) This behavior toggles between true and \nfalse whenever the left button is pressed. Suppose b is sampled at a time tl after the first button press, \nand we then need to sample b at a time tz> tl.Then b needs to notice that tz is after the first button \npress, and then see whether it is also beyond the second button press. After n such events, sampling \nmust verify that their given times are indeed past n events, so the running time and the (lazily expanded) \nrepresentation would be O(n). One could try to eliminate this space time leak by switching to a stateful \nimplementation, but doing so would interfere with a behavior s ability to support multiple simultaneously \ntime-transformed versions of itself. We solve this problem by having behavior sampling gen\u00aderate not \nonly a value, but also a new, possibly simpler, behavior. data Behavior a = Behavior (Time -> (a, Behavior \na)) (In fact, we use a slightly more complex representation, as expkained in Section 4.2 below.) Once \nan event is detected to be (t,, b ), the new behavior is sampled and the resulting value and possibly \nan even further simplified version are r~ turned. In most cases (ones not involving time transform), \nthe original untilB behavior is then no longer accessible, and so gets garbage collected. Note that this \noptimization im\u00adplies some loss of generality: sampling must be done with monotonically non-decreasing \ntimes. These same efficiency issues apply as well to integration, eliminating the need to re-start integration \nfor each samp\u00adling. (In fact, our formulation of numerical integration is as sequentially recursive reactive \nbehaviors.) 4.2 Implementing Events There are really two key challenges with event detection: (a) how \nto avoid trying too soon to catch events, and (b) how to catch events efficiently and robustly when we \nneed to. We use a form of laziness for the former challenge, and a technique called interval analysis \nfor the latter.  Representing events lazily. Recallthe semantics of reactivity: untilB : Behavior. \n~ EventBeha~or * Behaviora at[b untilB e]t = if t< t=thenat[b~telseat[b ]t where(t.,b ) = occ[e] Note \nthat values of an untilll-baaed behavior at t s t= do not depend on the precise value of t,,just the \npartial information about t.that it is at least t.This observation is crucial, because it may be quite \nexpensive or, in the case of user input, even impossible to know the value oft. before the time t, arrives. \nInstead, we represent the time t.by a chain of lower-bound time values increasing monotonically with \nrespect to the information ordering defined in Section 2.1. Because these chains are evaluated ~a.zdy,detection \nis done progressively on demand. Detecting predicate events. The second imple\u00adment ation challenge raised \nby events is how to determine when predicate events occur. For instance, consider the = 10: event that \noccurs when t e4t predicate (time * exp (4 * time) ==* 10) O Any technique based solely on sampling of \nbehaviors must fail to detect events like this whose boolean behaviors are true only instantaneously. \nAn alternative technique is sym\u00adbolic equation solving. Unfortunately, except for very simple examples, \nequations cannot be solved symbolically. The technique we use to detect predicate events is in\u00adterval \nanal~sis (IA) [20]. It uses more information from a behavior than can be extracted purely through sampling, \nbut it does not require symbolic equation solving. Instead, every behavior is able not only to tell how \na sample time maps to a sample value, but also to produce a conservative interval bound on the values \ntaken on by a behavior over a given interval 1. More precisely, the operation during, mapping time intervals \nto a intervals, has the property that at [b]tE during [b]1 for any a-valued behavior b, timein\u00adterval \n1, and time tE 1. An interval is represented simply as a pair of values: data Ivl a = a Upto a For instance, \n3 Upto 10 represents the interval {3,101, i.e., the set of x such that 3 s z s 10. The implement tion \nof a behavior then contains both the tirm+sarnpling and interval-sampling functions: data Behavior a \n= Behavior (Time -> (a, Behavior a)) (Ivl Time -> (Ivl a, Behavior a)) As an example, the behavior time \nmaps times and time intervale to themselves, and returns an unchanged behavior. time :: Behavior Time \ntime = Behavior (\\ t -> (t, time)) (\\ iv -> (iv, time)) Lifting of functions to the level of behaviors \nworks sim\u00adilarly to the description in Section 2, but additionally maps domain intervals to range intervals, \nand r~applies the lifted functions to possibly altered behavior arguments. For in\u00adstance, li~ is implemented \nas follows. lift2 f fi bl b2 = Behavior sample isample where sample t = (f xl x2, lift2 f fi bl b2 ) \nwhere (xl, bl)) = bl at C t (x2, b2 ) = b2 at t iasmple iv = (fi xil xi2, lift2 f fi bl~ b2 ) where (xii, \nbl ) = bi during iv (xi2, b2 ) = b2 during iv The restriction on behaviors referred to in Section 2.3 \nthat makes event detection possible, is that behaviors are composed of functions f for which a corresponding \nf i is known in the lijtn functions. (These f i are called inclusion 5 Related Work functions. ) Defining \nfunctions behaviors over intervals is well-under-Henderson s functional geomet~ [12] was one of the first \nstood [20], and we omit the details here, other than to point purely declarative approaches to graphics, \nalthough it does out that Haakell s type classes once again provide a conve not deal with animation or \nreactivity. Several other re\u00adnient notation for interval versiona of the standard arith-searchers have \natso found declarative languages well-suited metic operators. For example, evaluating for modeling pictures. \nExamples include [15, 23,3, 10]. Arya used a lazy functional language to model 2D an\u00ad (2 Upto 4) + (10 \nWpto 30) imation as lazy lists of pictures [1, 2], constructed using list combinators. While this work \nwas quite elegant, the yielda the interval /12,34). Also, a useful IA technique is to use of lists implies \na discrete model of time, which is some exploit intervals of monotonicit y. For instance, the exp func\u00adwhat \nunnatural. Problems with a discrete model include the tion is monotonically increasing, while sin and \ncos functions fact that time-waling becomes difficult, requiring throwing change between monotonically \nincreasing and monotonically away frames or interpolation between frames, and rendering decreasing on \nintervals of width n. an animation reouires that the frame rate match the dis-We can also apply IA to \nboolean behaviors, if we consider crete representat~on; if the frames cannot be generated fast booleans \nto be ordered with False t True. There are three enough, the perceived animation will slow down. Our \ncon\u00ad nonempty boolean intervats, corresponding to the behavior tinuous model avoids these problems, \nand has the pleasant being true never, sometimes, or always. For example, the property that animations \nrun at precisely the same speed, intervat form of equality checks whether its two interval ar\u00ad regardless \nof how fast the underlying hardware is (slower guments overlap. If not, the answer is uniformly false. \nIf hardware will generate lees smooth animations, but they both intervals are the same singleton interval, \nthen the an\u00ad will still run at the same rate). swer is uniformly true. Otherwise, IA only knows that \nthe The TBA G system modeled 3D animations aa functions answer may be true or false throughout the interval. \nSpecif\u00adover continuous time, using a behavior type family [8, 19]. ically: These behaviors are built \nup via combinations that are auto matically invoked during solution of high level constraints. (101 Upto \nhil) =4 (102 Upto hi2) = Because it used continuous time, TBAG was able to support I hil < 102 II hi2 \n< 101 derivatives and integrals. It also used the idea of elevating False Upto False functions on static \nvalues into functions on behaviors, whichI lol==hii M lo2==hi2 M 101==102 = we adopted. Unlike our approach, \nhowever, reactivity wasTrue Upto True = handled imperatively, through constraint assertion and re-I \notherwise traction, performed by an application program. False Upto True CML (Concurrent ML) formalized \nsynchronous opera-Similarly, it is straightforward to define interval versions of tions as first-class, \npurely functional, values called events theinequality operators and logical operators (conjunction, [18]. \nOur event combinators . I . and ==> correspond disjunction, and negation). to CML S choose and wrap functions. \nThere are substantial With this background, detection of predicate events throug ;h differences, however, \nbetween the meaning given to events IA ia straightforward. Given a start time tl,choose a time in these \ntwo approaches. In CML, events are ultimately used tz> tl,and evaluate the boolean behavior over [tyield-to \nperform an action, 1,tz],such aa reading input from or writing ing one of the three boolean intervals \nlisted above. If the output to a file or another process. In contrast, our events result is uniformly \nfalse, then tzis guaranteed to be a lower are used purely for the vatues they generate. These values \nbound for the event time. If uniformly true, then the event often turn out to be behaviors, although \nthey can also be time is t 1 (which is the infimum of times after tl ). Oth-new events, tuples, functions, \netc. erwise, the interval is split in half, and the two halves are C oncuwent Haskell [14] extends the \npure lazy functional considered, starting wit h the earlier half (because we are programming language \nHaskelt with a small set of primitives looking for the first time the boolean behavior is true), At for \nexplicit concurrency, designed around Haakell s monadic some point in this recursive search, the interval \nbeing di-support for 1/0. While this system is purely functional in vided becomes smaller than the desired \ndegree of temporal the technical sense, its semantics has a strongly imperative accuracy, at which point \nevent detection claims a success. feel. That is, expressions are evaluated without side-effects This \nevent detection algorithm is captured in the def-to yield concurrent, imperative computations, which \nare ex\u00adinition of predicate given in Appendix A. This function ecuted to perform the implied sideeffects. \nIn contrast, mod\u00aduses the above divide-and-conquer strategy in narrowing eling entire behaviors as implicitly \nconcurrent functions of down the interval, but atso, a double-and-conquer strategy continuous time yielda \nwhat we consider a more declarative in searching the right-unbounded time interval. The idea fed. that \nif the event was not found in the next w seconds, then Haskore [13] is a purely functional approach to \nconstruct\u00adperhaps we should look a bit further into the future-2w ing, analyzing, and performing computer \nmusic, which haa seconds-the next time around. much in common with Henderson s functional geometry, even \nIt is atao possible to apply IA to positional user input. though it is for a completely different medium. \nThe Haskore The idea is to place bounds on the rate or acceleration of work also points out useful algebraic \nproperties that such the positional input, and then make a worst-case analysis declarative systems possess. \nOther computer music lan\u00adbaaed on these bounds. We have not yet implemented this guages worth mentioning \ninclude Canon [5], Fbgue [6], and a idea. language being developed at GRAME [16], only the latter of \nwhich is purely declarative. Fugue also highlights the util\u00adity of lazy evaluation in certain contexts, \nbut extra effort is needed to make this work in its Lispbaaed context, whereas in a non-strict language \nsuch as Haskell it essentially comes for free. DtrectX Animation is a library developed at Microsoft \nto support interactive animation. Fran and Direct X Animation both grew out of the ideas in an earlier \ndesign called Ac\u00adtive VRA4L [7]. DirectX Animation is used from more main\u00adstream imperative languages, \nand so mixes the functional and imperative approaches. There are also several languages designed around \na syn\u00ad chronous data-jiow notion of computation. The general\u00adpurpose functional language Lucid [21] is \nan example of this style of language, but more importantly are the languages Signal [11] and Lustre [4], \nwhich were specifically designed for control of real-time systems. In Signal, the most fundamental idea \nis that of a signal, a timeordered sequence of values. Unlike Nan, however, time is not a value, but \nrather is implicit in the ordering of vafues in a signal. By its very nature time is thus discrete rather \nthan continuous, with emphasis on the relative ordering of values in a data-flow-like framework. The \ndesigners of Signal have also developed a clock calculus with which one can reason about Signal programs. \nLustre is a language similar to Signal, rooted again in the notion of a sequence, and owing much of its \nnature to Lucid. Conclusions Writing rich, reactive animations is a potentially tedious and error-prone \ntask using conventional programming method\u00adologies, primarily because of the attention needed for issues \nof presentation. We have described a system called Fran that remedies this problem by concentrating on \nissues of model\u00ading, leaving presentation details to the underlying implemen\u00adtation. We have given a \nformal semantics and described an implementation in Haskell, which runs acceptably fast using the Hugs \ninterpreter. Future work lies in improving perfor\u00admance through the use of standard compilation methods \nas well as domain-specific optimization techniques; extending the ideas to 3D graphics and sound; and \ninvestigating other applications of this modeling approach to software develop ment. Our implementation \nof Fran currently runs under the Windows 95/NT version of Hugs, a Haskell implementation being developed \ncollaboratively by Yale, Nottingham, and Glasgow Universities. It ISconvenient for developing animw tion \nprograms, because of quick turn-around from modifica\u00adtion to execution, and it runs with acceptable performance, \nfor a bytecode interpreter. We expect marked performance improvement once Fran is running under GHC (the \nGlasgow Haskell Compiler). Even better, when these two Haskell im\u00adplementations are integrated, man programs \nwill be conve\u00adnient to develop and run fast. The Hugs implementation, which includes the entire Fran \nsystem, may be retrieved from http: //ww. haskell. erg/hugs. Although this paper will give the reader \nan understanding of the technical ideas un\u00adderpinning Fran, its power as an animation engine (and how \nmuch fun it is to play with!) can only be appreciated by us\u00ading it. Acknowledgements We wish to thank \nJim Kajiya for early discussions that stimulated our ideaa for modeling reactivity; Todd Knoblock who \nhelped explore these ideas as well as many other variations; John Peterson and Alastair Reid for experimental \nimplementations; Philip Wadler for thoughtful comments that resulted in simpli~ing the seman\u00adtic model; \nand Sigbjorn Finne for helping with the imple\u00ad mentation of Fran. We also wish to acknowledge funding \nof this project from Microsoft Research, DARPA/AFOSR un\u00ad der grant number F30602-96-2-0232, and NSF under \ngrant number CCR-9633390.  References [14] Simon Peyton Jones, Andrew Gordon, and Sigbjorn [1] Kavi \nArya. A functional approach to animation. Com\u00adputer Graphics Forum, 5(4) :297 31 1, December 1986. [2] \nKavi Arya. A functional animation starter-kit. Journal of Functional Progmmmang, 4(1):1 18, January 1994. \n[3] Joel F. Bartlett. Don t fidget with widgets, draw! Tech\u00adnical Report 6, DEC Western Digital Laboratory, \n250 University Avenue, Palo Alto, California 94301, US, May 1991. [4] P. Caspi, N. Halbwachs, D. Pilaud, \nand J.A. Plaice. Lustre: A declarative language for programming syn\u00adchronous systems. In Id th ACM Symp. \non Principles of Programming Languages, January 1987. [5] R.B. Dannenberg. The Canon score language. \nCom\u00ad  puter Music Journal, 13(1):47-56, 1989. [6] R.B. Dannenberg, C.L. Fraley, and P. Velikonja. A \nfunctional language for sound synthesis with behavioral abstraction and lazy evaluation. In Denis Baggi, \neditor, Computer Genemted Music. IEEE Computer Society Press, 1992. [7] Conal Elliott. A brief introduction \nto ActiveVRML. Technical Report MSR-TR-96-05, Microsoft Re\u00adsearch, 1996. f tp: Ilf t.p. research. rnicroeof \nt. ccnnl pub/tech-reportslWinter95-961tr-96-05. ps. [8] Conal Elliott, Greg Schechter, Ricky Yeung, and \nSalim Abi-Ezzi. TBAG: A high level framework for interac\u00adtive, animated 3D graphics applications. In \nAndrew Glaeaner, editor, Proceedings of SIGGRAPH 94 (Or\u00adlando, Florida), pages 421-434. ACM Press, July \n1994. [9] John Peterson et. al. Ha.s.kell 1.3: A non\u00adstrict, purely fictional language. Technical Report \nYALEU/DCS/RR-1106, Department of Computer Sci\u00adence, Yale University, May 1996. WWW version at http: //haskell. \ncs. yale. edulhaskell-report. [10] Sigbjorn Finne and Simon Peyton Jones. Pictures: A simple structured \ngraphics model. In Glasgow Func\u00adtional Progmmming Workshop, Ullapool, July 1995. [11] Thierry Gautier, \nPaul Le Guernic, and Loic Besnard. Signal: A declarative language for synchronous pro\u00adgramming of real-time \nsystems. In Gilles Kahn, edi\u00adtor, Iimctional Progmmming Languages and Computer Architecture, volume 274 \nof Lect Notes in Computer Science, edited by G . Goos and J. Hartmani-s, pages 257-277. Springer-Verlag, \n1987. [12] Peter Henderson. Functional geometry. In ACM Sym\u00adposium on LISP and Functional Progmmming, \npages 179-187, 1982. [13] Paul Hudak, Tom Makucevich, Syam Gadde, and Bo Whong. Haskore music notation \n-an algebra of music, September 1994. To appear in the Journal of Functional Programming; preliminary \nversion avail\u00adable via ftp: //nebula. aysternsz. cs. yale. edulpubl yale-f p/papers/haskore/hmn-lhs. \nps. Finne. Concurrent Haskell. In ACM Symposium on the Principles of Programming Languages, St. Petersburg \nBeach, Florida, January 1996. [15] Peter Lucas and Stephen N. Zilles. Graphics in an ap\u00adplicative context. \nTechnical report, IBM Almaden R.e search Center, 650 Harry Road, San Jose, CA 95120\u00ad6099, July 81987. \n[16] 0. Orlarey, D. Fober, S. Letz, and M. Bilton. Lambda calculus and music calculi. In Prowedings of \nInter\u00adnational Computer Music Conference. Int 1Computer Music Association, 1994. [17] William H. Press, \nSaul A. Teukolaky, William T. Vet\u00adterling, and Brian P. Flannery. Numerical Recipes in C: The Art of \nScientific Computing (2nd cd.). Cambridge University Press, Cambridge, 1992. ISBN 0-521-43108\u00ad 5. [18] \nJohn H. Reppy. CML: A higher-order concurrent lan\u00adguage. Proceedings of the ACM SIGPLAN 91 Confer\u00adence \non Programming Language Design and Implemen\u00adtation, pages 293 305, 1991. [19] Greg Schechter, Conal Elliott, \nRicky Yeung, and Salim Abi-Ezzi. Functional 3D graphics in C++ -with an object-oriented, multiple dispatching \nimplement tion. In Proceedings of the 1994 Eurogmphics Object-Oriented Gmphics Workshop. Eurographics, \nSpringer Verlag, 1994. [20] John M. Snyder. Interval analysis for computer graph\u00adics. In Edwin E. Catmull, \neditor, Computer Gmphics (SIGGRAPH 92 Proceedings), volume 26, pages 121\u00ad130, July 1992. [21] W.W. Wadge \nand E.A. Ashcroft. Lucid, the Dataflow Progmmming Language. Academic Press U.K., 1985. [22] Philip Wadler. \nComprehending monads. In Proceedings of Symposium on Lisp and Fhctional Programming, pages 61 78, Nice, \nFrance, June 1990. ACM. [23] S.N. Zilles, P. Lucas, T.M. Linden, J.B. Lotspiech, and A.R. Harbury. The \nEscher document imaging model. In Proceedings of the ACM Conference on Document Pro\u00adcessing Systems (Santa \nFe, New Mezico), pages 159\u00ad168, December 5 9 1988.  Appendix A: Haskell Code for Predicate Event Detection \ntype BooIB = Behavior Bool type TimeI = Ivl Time predicate :: BooIB -> Time -> Event () predicate cond \ntO = predAfter cond tO 1 where predAfter cond tO width = predIn cond (tO Upto tO+width) ( \\ cond -> \npredAfter cond (tO+width) (2*width) ) predIn :: BooIB -> TimeI -> (BooIB -> Event ()) -> Event () predIn \ncond iv tryNext = case valI of False Upto False -> --no occurrence --Note lower bound and try the next \ncondition. timeIsAtLeast hi (tryNext cond ) False Upto True -> --found at least one if hi-mid f= eventEpsilon \nthen constEv mid () else predIn cond (lo Upto mid) ( \\ midCond -> predIn midCond (mid Upto hi) tryNext \n) True Upto True -> constEv 10 () --found exactly one where 10 Upto hi = iv mid = (hi+lo)/2 ivLeftTrimmed \n= 10 + leftSkipWidth Upto hi (valI,cond ) = cond during ivLeftTrimmed --Interval size limit for temporal \nsubdivision eventEpsilon = 0.001 :: Time --Simulate left-open-ness via a small increment leftSkipWidth \n= 0.0001 :: Time \n\t\t\t", "proc_id": "258948", "abstract": "<i>Fran</i> (Functional Reactive Animation) is a collection of data types and functions for composing richly interactive, multimedia animations. The key ideas in Fran are its notions of <i>behaviors</i> and <i>events</i>. Behaviors are time-varying, reactive values, while events are sets of arbitrarily complex conditions, carrying possibly rich information. Most traditional values can be treated as behaviors, and when images are thus treated, they become animations. Although these notions are captured as data types rather than a programming language, we provide them with a denotational semantics, including a proper treatment of real time, to guide reasoning and implementation. A method to effectively and efficiently perform <i>event detection</i> using <i>interval analysis</i> is also described, which relies on the partial information structure on the domain of event times. Fran has been implemented in Hugs, yielding surprisingly good performance for an interpreter-based system. Several examples are given, including the ability to describe physical phenomena involving gravity, springs, velocity, acceleration, etc. using ordinary differential equations.", "authors": [{"name": "Conal Elliott", "author_profile_id": "81339498305", "affiliation": "Microsoft Research, Graphics Group", "person_id": "PP39071398", "email_address": "", "orcid_id": ""}, {"name": "Paul Hudak", "author_profile_id": "81100539650", "affiliation": "Yale University, Dept. of Computer Science", "person_id": "PP40028396", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/258948.258973", "year": "1997", "article_id": "258973", "conference": "ICFP", "title": "Functional reactive animation", "url": "http://dl.acm.org/citation.cfm?id=258973"}