{"article_publication_date": "08-01-1997", "fulltext": "\n Graphs in Compilation Keen Claessen OGI and Utrecht University koen@cse. ogi. edu 1 Background and \nMotivation Traditionally, inside compilers, expression trees are used as an internal representation of \nfunctional programs. A big disadvantage of trees is the w of explicit variable names in expressions. \nWhen expression trees are transformed to optimize a program [5], we end up doing a lot of adminis\u00adtration \non the variables. Aleo, substitution of variables is a costly and awkward operation. Variable names create \nan extra indirection we do not want, but still have to deal with. Alternatively, programs can be represented \nby expression graphs. This is the approach we took in the compiler of Mondrian [3], a new lazy functional \nlanguage that we are currently designing and implementing. Expression construc\u00adtors (such as application \nand lambda abstraction) are rep\u00adresented aa nodes in the graphs, whereas their arguments (other expressions \nor variables) are pointers to other pieces of the graph. Using graphs, we can avoid all of the explicit \nvariable names in the representation of a program. Variables introduced by a let each create a graph \nfor their definition. References to such variables will point to this definition graph. By allowing this, \nwe are able to introduce sharing and cycles. A variable bound by a lambda becomes an empty node in the \ngraph, to which the body can point. We overwrite the node as soon aa we do beta reduction on the lambda. \nExpression graphs are sometimes used in the evaluation of functional programs. Evaluation however, is \nsignificantly different from transformation, because evaluation might not terminate. We have to be careful \nwith termination, because of the possible cyclic structures we are now dealing with. 2 Advantages and \nDisadvantages We investigate the pros and cons of using graphs as an in\u00adtermediate representation. + \nRemoving the let construct from programs allows us to postpone the very difficult issue of let transformations \n[4] to a later stage of the compiler. Programs that are the Permission to make digital/hard copy of part \nor all this work for personal or classroom uae is granted without fee provided that copies are not made \nor distributed for profit or commercial advan\u00adtage, the copyright notice, the title of the publication \nand its date appear, and nolice is given that copying is by permission of ACM, Inc. To copy otherwise, \nto republish, to post on servers, or to redistribute to lists, requires prior specific permission and/or \na fee. ICFP 97 Amsterdam, ND @ 7997 ACM 0-89791 -918 -1/97 /0006,.. $3.50 same, but look different, because \nthey have lets in different places, are now mapped onto the same graph. Definitions are automatically \ninlined , because the reference to the vari\u00ad able becomes a pointer to ita definition. This automatically \nopens the way for many transformations that could not have been done without the irdining. + In case \nexpressions, we use a similar trick to avoid ad\u00administration of variables matching certain patterns. \nInstead of looking up the variable in an environment, the refer\u00adence to the variable haa become a pointer \nto the pattern it is matching. Some transformations become automatically available in this way. However, \nthis representation also dis\u00adallowa other, less frequent transformations. + Several analyais algorithms \nover programs are concisely expressed over graphs. We have defined general operators over expression \ngraphs, comparable to catamorph isms over trees. Our implementations of type checking [2] and stric\u00adtnessanalysis \nseem to fit perfectly in this framework.  -A well known problem of graphs is that, because of the possible \nsharing of a lambda, we have to copy a lambda term before beta reduction. Fortunately, we do not beta \nreduce often inside a compiler. -Functional languages provide much less support for graphs than for trees. \nHowever, using datat ypes, MutVars and mon\u00adads, we were able to create usable graph abstractions. Mon\u00adads \nare also euitable for expressing the transformations them\u00adselves, so that the graph representation and \nthe transforma\u00adtions can be fused seamlessly. A more detailed discussion of these issues will be found \nin my graduation thesis [1].  References [1] K. Claessen. Graphs in Compilation. Master s thesis, (in \nprogress), 1997. [2] J. van Dijk. Monadic Type Inference and Experimental Type Systems. URL http: /iwww.cs.ruu,nl/-joostd, \n1996. [3] E. Meijer and K. Claessen. The Design and Implementation of Mondrian. to appear in the Haakell \nworkshop at the ICFP, 1997. [4] S Peyton Jones and W. Partain. Let-floating: Moving bind\u00ad ings togive \nfaster programs. In International/ Conference on Functional Programming, 1996. [5] Andr6 Luis de Medeiros \nSantoa. Compilation by Transforma\u00adtion in Non-Strict Functional Languages. PhD thesis, July 1995. 309 \n \n\t\t\t", "proc_id": "258948", "abstract": "", "authors": [{"name": "Koen Claessen", "author_profile_id": "81100206977", "affiliation": "OGI and Utrecht University", "person_id": "P162548", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/258948.258978", "year": "1997", "article_id": "258978", "conference": "ICFP", "title": "Graphs in compilation (poster)", "url": "http://dl.acm.org/citation.cfm?id=258978"}