{"article_publication_date": "08-01-1997", "fulltext": "\n Multi-Stage Programming Walid Taha&#38; Tim Sheard Oregon Graduate Institute of Science &#38; Technology \n{walidt,sheard} @cse.ogi.edu * 1 Introduction The concept of a multi-stage computation has recently been \nthe focus of a number of studies [2, 1]. A com\u00adputational stage roughly corresponds to the running of \na program on some input. Practical interest in mod\u00adels of mult i-st age computations stems from their \nsig\u00adnificant potential for enabling meamng-preservmg opti\u00admization whenever the inputs to a program are \navail\u00adable at different times .  2 Examples of Multi-Stage Computation Despite the numerous examples \nthat can be seen in al\u00admost every kind of application, the multi-stage nature of a computation can be \nobscured by the fact that a stage often coincides with a translation from one language to another. Consider \ncompilation: First, the source pro\u00adgram is compiled or tmnslated to machine code, and then later, the \nmachine code is executed. With respect to the source program, the translation step is really the first \nstage in executing this program, and executing the machine code is the second stage. However, the trans\u00adlation \nfrom one language to another is not fundamental to the first stage. Evidence of this is that we can imag\u00adine \nthe object language being the same as the source language, and the compiler would still be doing use\u00adful \nwork, including performing any of a number of op\u00adtimization on the input program. The last stage of any \nmulti-stage computation usually does not generate a program, but rather, a value that the end-user can \nunderstand. Another example is using yacc for parser-generation. There are three distinct stages: 1) \ncompiling the gram\u00admar and generatin a C program, 2) compiling the the 7 C program, and 3 executing the \nobject code. Here, again, in a language such as SML/NJ, the grammar and all the contents of the yacc \ninput file can be repre\u00adsented in the same language as the generated language, The research reported \nin this paper was supported by the USAF Air Materiel Command, contract # F1962S-93-C-0069, and NSF Grant \nIRI-9625462. Permission to make digital/hard copy of part or all this work for personal or classroom \nuse is granted without fee provided that copies are not made or distributed for profit or commercial \nadvan\u00ad tage, the copyright notice, the title of the publication and its date aPPear. and notice is given \nthat copying is by permission of ACM, Inc. To copy otherwise, to republish, to post on servers, or to \nredistribute to lists, requires prior specific permission and/or a fee ICFP 97 Amsterdam, ND @ 1997 ACM \n0-89791 -918 -1/97 /0006 . ..$3.50 in which case, again, the input and the output of the first stage \nare in the same language. And still, there is useful work being done. The second and thmd stages are \nexact Iy the same as in classic compilation. Finally, one of the most interesting applications of the \nidea of multi-stage computation can be seen in par\u00adtial evaluation. In particular, an ofline partial \nevalua\u00adtion takes a single-stage program and generates a two\u00adstage program. The two-stage program is \nthen run on the inputs that are known at partial-evaluation time . The resulting program is a specialized, \nmore efficient version of the original program that has just been par\u00adtially evaluated. Recently, offline \npartial evaluation has been generalized to general multi-stage programs [2]. 3 MetaML Until recently, \nmulti-stage computations were developed using ad hoc methods, such as generating text-strings representing \nprograms. Systems developed this way are prone to error. MetaML is a statically-typed multi\u00adstage language \nbased on an SML-like core. The lan\u00adguage was developed to allow multi-stage programming with ezplicit \nannotations [3]. References [1] Rowan Davies and Frank Pfenning. A modal anal\u00adysis of staged computation. \nIn 23rd Annual ACM Symposium on Principles of Pmgmmming Lan\u00adguages (POPL 96), St. Petersburg Beach, Florida, \nJanuary 1996. [2] Robert Gliick and Jesper Jorgensen. Fast binding\u00adtime analysis for multi-level specialization. \nIn PSI\u00ad 96: Andrei Ershov Second International Memorial Conference, Perspectives of System Informatics, \nvol\u00adume 1181 of Lecture Notes in Computer Science. Springer-Verlag, 1996. [3] Walid Taha and Tim Sheard. \nMulti-stage pro\u00adgramming with explicit annotations. In Proceed\u00adings of the Symposium on Partial Evaluation \nand Semantics-Based Program Manipulation, Amster\u00addam, June 1997. 321 \n\t\t\t", "proc_id": "258948", "abstract": "", "authors": [{"name": "Walid Taha", "author_profile_id": "81100239752", "affiliation": "Oregon Graduate Institute of Science & Technology", "person_id": "PP39034018", "email_address": "", "orcid_id": ""}, {"name": "Tim Sheard", "author_profile_id": "81331504269", "affiliation": "Oregon Graduate Institute of Science & Technology", "person_id": "PP39078835", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/258948.258990", "year": "1997", "article_id": "258990", "conference": "ICFP", "title": "Multi-stage programming (poster)", "url": "http://dl.acm.org/citation.cfm?id=258990"}