{"article_publication_date": "08-01-1997", "fulltext": "\n The development of Erlang Joe Armstrong Computer Science Laboratory Ericsson Telecom AB joeQcslab.ericsson.se \nAbstract This paper describes the development of the programming language Erlang during the period 1985-1997. \nErlang is a concurrent programming language designed for programming large-scale distributed soft real-time \ncon\u00ad trol applications. The design of Erlang was heavily influenced by ideas from the logic and functional \nprogramming communities. Other sources of inspiration came from languages such as Chill and Ada which \nare used in industry for programming control systems. Introduction This paper describes the development \nof the Erlang pro\u00adgramming language. Erlang is a language which draws heav\u00adily from various traditions \nin the logic, functional and real\u00adtime control programming communities. Our goal was to make a language \nwhich could be used for building large soft real-time control systems. By large I mean systems with possibly \nmillions of lines of code. By a soft real-time system I mean a system which does not faif catastrophically \nif a real-time deadline is missed. Erlang was developed by the author and his colleagues at the Ericsson \nComputer Science Laboratory. Ericsson is currently the world s largest supplier of telecoms systems and \nthe world s leading manufacturer of mobile phones. Ericsson s flagship product is a telephone exchange \ncalled the AXE lO which is programmed in a proprietary language called PLEX. A typicaf AXEl O system \nhas over 5 million Iines of PLEX. The AXEIO is specified to have a down time of less than 3 minutes per \nyear -such requirements are common in the telecoms industry. The programming languages which are used \nfor building such systems have to deal with a range of problems not usu\u00adally encountered in traditional \nbatch or interactive computer systems. For example, one requirement is that the system should be in continuous \noperation -this means we must do software upgrades without stopping the system. It also implies the use \nof fault-tolerant processors and a software architecture which protects the integrity of the system from \nvarious classes of programmer error, Erlang grew out of a series of experiments which we per\u00adformed to \nsee if we could find better ways of programming telecoms systems. Our criterion for success was that \nwe could program telecoms systems with less effort and fewer errors than could be done using conventional \ntechnology. Permission to make digital/hard copy of part or all this work for personal or classroom use \nis granted without fee provided that copies are not made or distributed for profit or commercial advan\u00adtage, \nthe copyright notice, the title of the publication and its date appear, and notice is given that copying \nis by permission of ACM, Inc. To copy otherwise, to republish, to post on servers, or to redistribute \nto lists, requires prior specific permission and/or a fee This paper starts with a brief discussion of \nthe various milestones which the language went through. This is fol\u00ad lowed by sections describhrg the \nlanguage, finally future di\u00ad rections of research are mentioned. 2 Milestones . Early experiments Being \na telecoms laboratory we were in the fortunate position of always having hardware to play with. The lab \nhad a Ericsson MD110 (which is a smafl telephone exchange) which had been modified so it could be controlled \nby a conventional Unix machine. We pro\u00adgrammed POTS1 in as many programming languages as we could lay \nour hands on. The main conclusion [5] was that declarative language programs for POTS were a lot shorter \nand easier to understand than imperative language programs. Un\u00adfortunately the declarative languages \nlacked features for concurrency control and had poor error handling facilities. We concluded that we \nwould like something like Pro log with added facilities for concurrency and improved error handling. \nNo such language existed at the time. s 1986 -1989 The Prolog interpreter Having decided that we liked \nProlog for programming POTS we started a series of experiments call LOTS (Lots of POTS) to program not \nonly POTS but aleo an extremely large number of different telephony fea\u00adtures in Prolog. Before long \nI had programmed a large subset of PABX features in Prolog. To do so I wrote a Prolog meta-interpretor \nwhich added the notion of a process to Prolog and which added facilities for ad\u00advanced error detection \nand recovery. This work is de\u00adscribed in [1]. b The Bollmora group Using the results of the work with \nthe Prolog interpre\u00adter we were able to attract the curiosity and interest of a group of engineers who \nwere responsible for a future soft ware architecture of the Ericsson MD 110. POTS stands for Plain Old \nTelephony Service, that is, subscriber A calls subscriber B and they chat for a while Who worked in Bollmora, \nStockholm. ICFP 97 Amsterdam, ND 0 1997 ACM 0-89791 -918 -1/97 /0006 .,.$3.50 196 This group thought \nthat they could US( our results as a vehicle for investigate ing their own software architec\u00adtures. This \nbegan a period of collaboration which led to the development of Erlang as a fully fledged lan\u00adguage and \nto a new range of Ericsson products. During the period 1986-1988 members of the computer science lab \nworked closely with the Bollmora group, meeting once or twice a week. During this time the Prolog interpretor \n(and the language which it defined) changed rapidly, The language grew and evolved and somewhere along \nthe line acquired a name, Erlang, named in honor of the Danish mathematician Agner Krarup Erlang (1878-1929) \nwhose name is associated with the telecoms industry. . The jam machine By about 1988 is was clear that \nErlang as it was now called wss a good language for prototyping telephone exchanges [10]. It was a strange \nmixture, with declar\u00adative features (inherited from Prolog), multi-tasking and concurrency (inherited \nfrom EriPascaJ and Ada) and an original combination of error handling mecha\u00adnisms. Erlang was, however, \ntar too slow to be used for prod\u00aduct development, The Bolhnora group did some mea\u00adsurements and decideil \nt}lat for product development they needed a system that was 40 times faster than the Prolog interpreter \nThis requirement lead to the development of a number of different abstract lnachines and compilation \ntech\u00adniques used for implementing Erlang. A cross compiler from Erlang to Strand [7] was developed. After \na num\u00adber of experiments tht JAM [4] machine was invented. This was based on the Warren Abstract Machine \nwith added primitives for concurrency and exception han\u00ad dling. By this time the Erlang effort had grown \nto three peo\u00adple. Mike Wifliams wrote a byte code emulator for JAM code, I wrote the compiler and Robert \nVirding wrote the support libraries. While we only ever distributed one version of the sys\u00ad tem to externaf \nuser:., internally there were severaf competing Erlang engines where we experimented with different implementation \ntechniques. The resulting JAM implementation was delivered to the Bollmora group in 1989. Fortunately \nit was 70 times faster than the original Prolog interpretor -un\u00adfortunately they had now revised their \noriginal esti\u00admates and wanted a machine that was 280 times faster than the original. . Adding distribution \nDuring the period 1989-1994 the Erlang group ex\u00adpanded (there has ne~,er been a formal group). Claes \nVikstrom joined the group in 1990 and added distribu\u00adtion to the language. The original language had \nbeen designed with hooks for adding distribution -but this was Iiever actually done until Claes implemented \nit. The Bollmora group had now decided to go ahead and build a new PABX in Erlang. Erlang wasn t fast \n 9 enough but it was generally thought that the perfor\u00admance problems could be solved. In 1992 they started \ndevelopment of a product called the Mobility Server , In 199.5 this was launched and became part of the \nConsono product range. At the time of writing the Mobility Server is marketed in 12 countries. Among \nother things it is used to control the DECT mobile phone in the European Parliament in Strasbourg. Fight \nfor acceptance During the period 1992-1996 it was by no means clear that Erlang was suitable for programming \nlarge-scale industrial products. While we were very successful in a number of smalf projects, Erlang \nprogramming and programmers stilf represented a very small percentage of the programming effort at Ericsson. \nThe Mobility server project continued and we attracted several new smalf projects. During this time we \nwere involved in maasive guerilla marketing activities. I don t think there was a single person in Ericsson \nwho ever came out of Bjarne s3 office without a copy of the Erlang manual under their arm! The beam Performance \nhas always been a major problem. In 1992 Bogumil Hausman started work on the BEAM.4 The BEAM compiles \nErlang to C which can then be compiled with a conventional C compiler. The BEAM can afso compife to threaded \ncode which can be freely intermixed with compiled code. Compiled code is faster but takes up more space \nthan threaded code. In a large embedded system with mil\u00adlions of lines of code, the volume of object \ncode can be a major problem, Infrequently used and non-performance critical parts of the system can be \ncompiled to threaded code while performance critical parts of the system can be com\u00adpiled to native code. \nThere are performance tools which we can use to analyse the system and find out which parts of the system \nneed to be native code com\u00adpiled. The BEAM is described in [6]. In many applications the BEAM is comparable \nwith C in performance terms. The BEAM replaced the JAM as the principle system for new product development \nin 1997. Erlang Systems Up to 1995 most users were enthusiasts and Erlang spread internally within Ericsson \nby word of mouth . We didn t find new users, they found us. As the language spread we needed to produce \ntraining material and hold courses to train new users. Initially, all courses were held at the Computer \nScience Lab by members of the Erlang group . Whife holding such courses was great fun, demand soon far \noutstripped supply. In April 1993 a new company Erlang Systems was formed to handle sales, marketing, \neducation and con\u00adsulting of Erlang. We had been in the fortunate posi\u00adtion of having supervised a number \nof Master degree 3Boss of the computer science lab. 4 Bogdans s Erlang Abstract machine. 197 students \nin conlputer science at the [Jlliversity 0[ tlp\u00adpsala. Having conlpleted i]. Masters degree many of \n these students were employed by Erlang Systems. Mike Williams moved from the Computer Science Lab\u00adoratory \nto manage Erlang Systems and had soon built up a strong team of consultants and impressive train\u00ading \nfacilities. In 1996 over 500 Ericsson programmers attended courses at Erlang Systems. Erlang consulting \nis one of the most important factors that have led to the spread of Erlang within Ericsson. In the first \nErlang projects there ww very close contact between the developers and the users. We knew every user \nand could provide individual help and tuition \u00adthis doesn t scale. Now, when we start a new project, \nwe aJways try to get at least two Erlang Systems consultants working on the project. They provide a vital \nlink between the users and developers of Erlang. This is a significant factor in the success of new projects. \nIt is also interesting to note that the skll level required for an entry-level industrial programmer \nhas increased in recent years. A good degree in computer science is now a pre-condition for working with \nstate of the art software technology. The days of the amateur hacker are fast disappearing. . The tools \nThe current Erlang system comes with an extensive toolkit. As well as the obvious software tools (yacc, \nlex look-a-likes etc. ) there is a wide range of tools which are useful for building telecoms applications. \nThese include things like cross-compilers for interfac\u00ading Erlang to foreign language applications, an \nASN. 1 interface compiler, an SNMP tool-kit, a HTTP-server etc. Many of the new users of Erlang are not \ninitially at\u00adtracted by the language but rather by the set of tools which comes with the language. For \nexample, it is extremely easy to Imihi an SNMP application using the Erlang SNMP toolkit. The SNMP toolkit, \nfor ex\u00adample, contains a MIB compiler, and set of default methods which allows a non-expert user to build \nan SNMP agent in a matter of hours. Doing this in a conventional language is much more difficult. Many \nof the first versions of the tools were written by students = part of their Maater thesis work. . Mnesia \nMany real-time applications need access to data over long periods of time. For example, in a telephone \nexchange subscriber data must be stored for many years and must be accessible within a few millisec\u00adonds, \nCharging data (telephone bills) must be kept and never lost. Mnesia [9] is a real-time distributed database \ndesigned for programming telecoms applications in Erlang. Am\u00adnesia is written entirely in Erlang. . OTP \nOn 1 January 1996 a new Ericsson division was created to support applications written in Erlang. Our \nusers want a lot more than just a programming language. For example, some users want not only the language \nbut also the operating systems and the hardware plat\u00adform to be delivered in one package. The OTP (Open \nTelecom Platform) division can pro\u00advide Ericsson users with anything from a simple Erlang system which \nruns on a PC to an embedded system complete with hardware. The division has the goal of providing prospective \nusers with a turn-key system which they can turn on and start programming from day one of a project. \nStandard OTP software comes with extensive libraries which solve common applica\u00adtion problems. Another \ngoal of the OTP division w= to transfer r~ sponsibility for the maintenance and support of the Erlang \nsystem from the Computer Science Laboratory to a mainstream Ericsson division. 3 Erlang in 14 Examples \nThe previous sections described the development of Erlang. The following sections describe Erlang through \na number of small examples. 3.1 Sequential Erlang Example 1-Factorial All functions are defined in modules, \nfor example, factorial can be written: -module (math) . -export ([f ac/11 ) . fat(N) when N > 0 -> N \n* fac(N-1) ; fat(O) -> 1.  The annotation -export ([f ac/ 11 ) means the function f ac with one argument \nis from the module. Only exported functions can be called from outside the module. Once a module has \nbeen loaded into the system the query evaluator can be used for function evacuation: > math: fac(25) \n. 15511210043330985984000000  Example 2-Binary Tree lookup (Key, {Key, Val, -, _}) -> {ok, Vail; lookup \n(Key, {Keyl ,Val ,S ,B}) when Key<Keyl -> lookup (Key, S) ; lookup (Key, {Keyl ,Val, S, B}) -> lookup \n(Key, B) ; lookup (Key, nil) -> not-f ound.  Here the tuple {Key, Val, S ,B} represents a node of a \nbinary tree. Tuples store fixed numbers of arguments. Example 3-Append append ([HIT], L) -> [Hlappend(T, \nL)]; append ([] , L) -> L.  198 The notation [HI T] when occurring in ii function head denotes a pattern \nmatching operation on a list. H is the first element of the list, T is the remainder of the list. When \noccurring on the right hand side of a production it denotes a list constructor. Example 4-Sort sort ( \n[pivot ITI ) -> sort([Xll X <-T, X < Pivot]) ++ [Pivot] ++ sort([Xll X <-T, X >= Pivot]); sort([l) -> \n[1.  The notation [Expr II . ..1 introduces a list compre\u00adhension and ++is the infix append operator. \nExamples-Adder Lambda expressions are introduced with the syntax: fun{. . . ) -> end As an example we \ncan write: > Adder = fun(N) -> fun(X) -> X + N end end. SFr.m > G = Adder (lO). #Fun > G(5). 15 3.2 \nConcurrent Erlang Example 6-An area Server Starto -> spam(funo -> loop(O) end). loop(Tot) -> receive \n  {Pid, {square, Xl} -> Pid ! X*X, loop(Tot + X*X); {Pid, {rectangle, [X,yI}}-> Pid ! X*Y, loop(Tot \n+ X*Y); {Pid, areas} -> Pid ! Tot, loop(Tot) end. This creates an area server -you can ask the server \n what the area of a square or rectangle is, or, you can ask it to return the total of all areas that \nit has been requested to compute. In the above, spawn(Fun) creates a parallel process which evaluates \nthe lambda expression Fun. Spawn returns a pro\u00adcess identifier (Pid) which can be used to communicate \nwith the process. Here Pid ! M sends the message M to the process Pid. receive . . . endis a pattern \nmatching operation which re\u00adceives a message, Send is an asynchronous non-blocking operation. Example \n7-An area client Client code which uses the above server can be written: Pid ! {selfo, {square, 10}}, \nreceive Area -> ... end Example 8-Global Server In the above examples, the process identifier of the \nserver hadtomade known tothe client. Toprovide a global service we can associate a process identifier \nwith a global name se follows: ... Pid -spavn(Fun), register(area-server, Pid), ... area-server ! . \n. .  This associates the global name area-server with Pid. Thereafter any process evaluating in the \nnode where this name was registered can send a message to the process with the syntax area-server ! ?lsg \n3.3 Distribution Example 9- Spawning ona remote node Spawn can be used tocreate aprocess ofa different \nErlang node. ... Pid = sparm(Fun@Node) ... alive (Node) ... not-al ive(llode)  The primitives alive \nand not-alive signify a node s willingness to participate in distributed computations. If they have not \nevaluated alive they remain anonymous and cannot take part in distributed computations. 3.4 Error detection \nErlang is designed for programming robust systems, so there are a number of primitives for trapping errors. \nError recovery is not automatic. The programmer must design a fault-tolerant architecture which can be \nimplemented using the error detection mechanisms. Example 10-Catch > x = 1/0. ** exited: {badarith, divide_by_zero} \n** > X = (catch 1/0). { EXIT , {badmith, divide-by-zero}] > bo. X = { EXIT ,{badarith, divide-by_zero}} \n catch (Expr) converts any error occurring within Expr into a term describing the error. 199 Example \n11-Catch and throw case catch f(X) of {exception, Why} -> Actions; NormalReturn -> Actions; end, f(x) \n-> ... Nomal.retumt-value; f(x) -> ... throw({exceptionl, . ..}).  Non-local returns can be performed \nwith throv(Expr). Expr is evaluated and becomes the value of the enclosing catch, Example 12-Links and \ntrapping exits Processes can be linked together. If a process dies an error message is sent to all processes \nto which it is linked. process-flag(trap-exits, true), P = spavn-link(Node, Fun), receive { EXITJ, P, \nwhy} -> Actions; ... end  spaun.link(Fw) creates a parallel process which evalu\u00adates Fun and creates \na link between the process which per\u00adforms the spawn (the parent) and thenewly created process (the child). \nIf an exception is raised in the child process then an error message is sent to all processes which the \nchild process is linked to. In our example an error in the child process will cause an error message \nto be sent to the parent process. The parent process can receive the error message and take appropriate \naction. Example 13-Undefined processes Ifwecallllod:Func (Argl,. .Argn) and this function cannot be located \nin the system, then Hod: Func behaves as if it had been defined as follows: Hod:Func(Argl, . . . . Argn) \n-> error_handler:undefined-functlon(Hod, Func, [Argl, . . Argnl) The function undefined_function can \nbe definedby the user or the system default can be used. It is usually defined something like: undefined-function(Hod, \nFunc, Args) -> case code: ensure_loaded(Hod) of {module, Hodl -> case is-exported(Hod, Func, length(Args)) \nof true -> apply(Hod, Func, Args); false -> exit({undef, {Hod,Func,Args}}) end; {module, Other} -> exit({undef, \n{Hod,Func,Args}} ); {interpret, Hod} -> int:eval(Hod, Func, Args); Other -> exit({undef,{Hod,Func ,Args}}) \nend. 3.5 Hot code replacement Example 14-Code replacement Erlang is designed for non-stop systems. We \nneed to be able to replace code and data without stopping the system. This example shows how we can change \ncodein a server, without stopping the server. loop(Data, F) -> receive  {request, Pid, (?1 -> {Reply, \nDatal} = F(Q, Data), Pid ! Reply, loop(Datal, F); {cha.nge_code, Fl} -> loop(Data, Fl) end The above \ncode represents a server. Data represent the local state of the server. F is a lambda expression which \ndetermines the behaviour of the server. Tochange the code in the server we send it the message {change_code, \nFl} The garbage collector willremove the old function. 4 Higher Order Processes Most large Erlang systems \nare programmed by re-using code from a number of programming patterns which we call be\u00adhaviors. This \nis a processes whose behaviour will be deter\u00admined by a lambda expression at run-time. As an example \nof a behaviour we show how a simple client-server model can be programmed. Firstly the code for the generic \npart of the client-server: Generic Client Server -rnodule(cs). -export([start/3, rpc/2, loop/21). start(?iae, \nData, Fun) -> register(Name, spavn(funo -> loop(Data, Fun) end) ). rpc(llime, q) -> Tag = refo, IJame \n! {query, selfo, Tag, u}* receive {Tag, Reply] -> Reply end. loop(Data, Fun) -> 200 receive {query, \nPid, Tag, Q} -> {Reply, Datal} = Fun(Q, Data), Pid ! {Tag, Reply}, loop(Datal, Fun) end. The above code \nprovides skeleton code for a client-server. We can parameterise it by instantiating the variable Fun \nwith a lambda expression which gives the server its desired behaviour. Forexarnple, aKey-Value dictionary \nserver can be made as follows: A key-Value Server -rnodule(kv) . starto -> cs:start(keydb, [], fun handler/2). \nadd(Key, Val) -> cs:rpc(keydb, {add,Key,Val}). lookup(Key) -> cs:rpc(keydb, {lookup,Key}). handler({add, \nKey, Val}, Data) -> {ok, add(Key,Val,Data)]; handler({lookup, Key}, Data) -> {find(Key, Data), L)ata}. \nadd(Key,Val, [{Key,_}lT]) -> [{Key,Val}lT]; add(Key,Val, [HIT]) -> [Hladd(Key,Val,T}I ; add(Key,Val, \nKl) -> [{Key,Val}]. find(Key, [{Key,Val}l_]l -> {found, Vail; find(Key, [HIT]) -> find(Key, T); find(Key,D) \n-> error. Insequential programnring a small number of higher or\u00adder functions (map, fold, zip etc.) provide \na library of func\u00adtions which the programmer can re-use in a number of dif\u00adferent contexts. Note thereis \nalirnit edsetofsu chfunctions. Toomany ortoo abstract functions would not help. In concurrent programming \nwe have found that most concurrent programs can be built from a small number of higher order processes \n(such as the client-server) example. In a given application between 5 and 10 such higher-order processes \nseems to capture 95 %oof the concurrency mecha\u00adnisms. Interestingly the generic part of the higher-order \nprocess is often not well-typed, but the functions which parameterise the process are. 5 Enter The Type \nSystem Erlang has a dynamic type system which was inherited from Prolog, All types are checked at run-time. \nNonsense ex\u00adpressions (for example I + true) are not type-checked at compile time but result in run-time \nexceptions. In 1995 Phil Wadler decided that Erlang needed atype system, and promptly informed us that \nhe was makkrg one. After he hads tarted work on the project he realised that he needed some money and \nsome help. He got his money, and we got a type system, At the time of writing a Haskell prototype of \nthe type checker [8] is being evaluated and the type checker itself is being re-writtenin Erlang. We \nareevahrating the type systemby type checking all the libraries in the standard Erlang distribution. \nThis work is not complete, but we can make certain observations about the type system. The first point \nto note is that the type checker is totafly free-standing from the Erlang system itself. Nochanges have \nbeen made to Erlang to accommodate the type system. A consequence of this is that theuser is free to \ncompile and run programs which the type checker says are not well\u00adtyped. This is in contrast to say Haskell, \nor ML where a type-incorrect program cannot be compiled or run. Many programs behave correctly despite \nthe fact they are not well-typed. This is especially true of systems soft\u00adware -for example, theprograrnsin \nthekernel of the Erlang run-time which are responsible for IO and distribution per\u00adform highly complex \ngeneric operations on arbitrary data structures. In the Erlang type system ausercan declare a type. For \nexample: -type fac(into) -> into. fat(N) vhenN > 0 -> N * fac(ll-l); fat(O) -> 1. Ifa typeis supplied \nit is checked by the type checker. Types can be annotated unchecked. This means that the type checker \naccepts the supplied type without analyzing the function tosee ifit hasthetype the programmer intended. \nIn practise this turns out to be very useful for forcing bizarre code through the type checker. An example \nis the code for the Erlang pretty printer The pretty printer con\u00adtains code like: -unchecked([pp/1] ). \n-type pp(l) -> deepstringo. pp(X) then tuple(X) -> pp_list(tuple_to_list(T) ); pp(X) when list(X) -> \n... pp(X) when float(X) -> ... ppis a function which turns any arbitrary data structure into a deep list \nof characters. We tell the system that pp is of type l->deepstringo where 1 is the universal type. This \nis a correct statement about the program but one which cannot be inferred by the type checker. In type \nchecking the standard libraries we have found the following: . The type system has uncovered no errors. \nThe kernel libraries were written by Erlang experts -it seems that good programmers don t make type errors. \nIt will be interesting to see if this remains true when we start type checking code written by less experienced \nprogrammers. 201 . Certain libraries (ordsets, diet etc. ) passed the type checker at the first attempt. \nThe derived types corre\u00adsponded in most c~ses to our intuition of what the derived types shouhl be. Adding \ntype declarations (mostly for documel,tatioll purpose) was a trivial op\u00aderation. Interestingly we could \noften remove a number of com\u00adments and replace them by more precise type declara\u00adtions. Thus in diet.erl \nwe replaced comments like:  ~~ fetch(Key, Diet) -> Value XX find(Key, llict) -> {Olr,valuel I error \n~~ store(Key, Value, Diet) -> Diet With type declaration: -deftype dict(Key, Val) = [{Key, Val}]. -type \nfetch(Key, dlct(Key, Val)) -> Val. -type find(Key, dlct(Key, Val)) -> ok{Val} I error. -type store(Key, \nVal, dict(Key, Val)) -> dict(Key, Val). Which says the same thing only more precisely. . Many modules \ndid not type check at the first attempt. We had to re-write some functions or add unchecked annotation \nto force the code through the type checker. In complexmorlules about 10% ofthefunctions needed small \nchanges. In t}le vast majority of cases a small change to the function corrected the type error. In a \nminority ofcases we had to resort to adding unchecked annotations. Even iu the kernel system modules \nwe were able to provide readable types for the majority of functions and not resort to the unchecked \nannotation. uncheckedordy had to be used when the Erlang func\u00adtions contained primitives such as apply \netc. which could not be analysed by the type checker. s Debugging (i.e. fincling the source) of the type \nerror was i;-sorne cases extr&#38;lely difficult. This proved to be very frustrating. Well-tested programs \nwhich we believed to be correct were rejected by the type checker -finding exactly what was wrong was \nsometimes very difficult.  6 The future Where is the research leading us? . Very large systems How can \nwe build very large systems? The prob\u00adlems associated wit h building very large systems seem to have \nmore to do with software architectures than choice of programming language. We have found that the use \nof program patterns (or higher order processes) greatly helps users structure large software systems. \nIt has often been speculated that the advantages of a strong type system will be seen in very large software \nsystems. We intend to test this hypothesis. . Evolving systems As systems evolve and as we learn more \nwe discover better ways of programming things. Early design de\u00adcisions turn out to be wrong. We often \nwish to change some of tbe major system interfaces which turned out to be wrong, Project managers worry \nabout backwards compati\u00adbility and are very reluctant to accept changes to the standard system software. \nAny change to the basic system invalidates their test procedures and can delay introduction of a new \nproduct. While in the short\u00ad term is is desirable to keep the system as stable se possible, in the long-term \nwe must allow systems to evolve and phase out old code and design decisions. We are interested in techniques \n(for example, partial evahration) that can simplify (orin the best case auto\u00admate) the transition from \nan older to a newer version of the system. . Performance Certain applications cannot be efficiently programmed \nin Erlang. We are considering adding imperative fea\u00adtures to the language to solve these problems, 7 \nReflections Erlanghas spread successfully from the laboratory toanum\u00ad ber of commercial products. We \ncan speculate se to the reasons why this has occurred. Some of the more important factors seem to be: \n. real problems We work on real problems. We tend to make progress when we cannot solve a particular \nproblem with the existing technology. Progress has often come when a user came with a problem which \ncould not be solved in Erlang. . working within the organisation We work within the Ericsson organisation. \nIt is far easier to sell an idea internally than to come to the organisation from outside. . organisational \nsupport There is a gap between the best that a laboratory with limited resources can produce and what \nis minimally acceptable for a commercial product. Ericsson has pro\u00advided financial support and created \nnew jobs as neces\u00adsary to help fill this gap. . we can provide good support Good documentation, courses, \ne-mail, hot-line tele\u00adphone support etc. are essential in psasing from the enthusiast to the main-stream \nphase of develop\u00adment. . lots of tools  Project managers are not interested in programming languages. \nThey arenotinterested informal anything and don t give a hoot about types or calculi. They are however, \ninterested in short time to mar\u00adket and in writing bug-free software. The provision 202 of large numbers \nof software tools can greatly reduce software development times and improve the quality of the software. \nThese tools are specific to our problem domain. Thus we have tools for making SNMP MIBs, for nlanipulat\u00ad \ning ASN. 1 data ty])es, for building fault-tolerant du\u00ad plicated data-bases with hot-standby etc. . \nForeign language interfaces Typicaf systems are written in severaf different lan\u00ad guages. Erlang is not \ngood at everything. Large parts of a system might use purchased software packages written in C. Efficient \nintegration with C is essential References [1] .J. L. Armstrong, S. R. Virding and M. C. Williams. Use \nof Prolog for developing a new programming language. The Practical Application of Prolog London l-3 Aprif \n1992 [2] J. L. Armstrong, M. C. Williams, C. Wikstromand S. R. Virding. Concurrent Programming in Erlang, \n2nd ed. Prentice Hall (1995)  [3] J. L. Armstrong. Erlang-Asurvey of thelanguage and its industrial \napplications. In Proceedings of tire sym\u00adposium on industrial app./ications of Prolog (HVAP96). 16 18 \nOctober 1996. Hino, Tokyo Japan. [4] J. L. Armstrong, B. Dicker, S. R. Virding, and M. C. Williams, \nImplementing a functional language for highly paralfe] reaJ timeapplications. 8th Int Conf. on Software \nEngineering for Telecommunication Switching Systems, Florence 30 March-1 April 1992.  [s] B. Dicker, \nN. Elahiewy, P. Hedeland, C. W. Welin C. W. and M. C. Williams. Experiments with Program\u00adming Languages \nand Techniques for Telecommunica\u00adtion Applications. SixtJ~ International Conference on Software Engineering \nfor Telecommunication Switching Systems. Eindhoven, 1986.  [6] B. Hausman. Turbo Erlang: Approaching \nthespeedof C.In Implementations of Logic Programming Systems, pp. 119-135, ed. Evan Tick and Giancarlo \nSucci, Kluwer Academic Publishers (1994). [7] I. Foster and S. Taylor. STRAND: New Conceptsin ParaUel \nProcessing. Prentice Hall, 1989. [8] S. Marlow, and P. Wadler. Apractical snbtyping sys\u00adtem for Erlang. \nIn ACM International Conference on Functional Programming, 1997. [9] C. Wikstrom and H. Nilsson. Mnesia \n-An Industrial DBMS with Transactions, Distribution and a Logicaf Query Language. International Symposium \non Coop erative Databme S,ystems for Advanced Applications. Kyoto Japan 1996 [10] K. Odling. New technology \nfor prototyping new ser\u00advices. In Ericsson Review No. 21993. \n\t\t\t", "proc_id": "258948", "abstract": "This paper describes the development of the programming language Erlang during the period 1985--1997.Erlang is a concurrent programming language designed for programming large-scale distributed soft real-time control applications.The design of Erlang was heavily influenced by ideas from the logic and functional programming communities. Other sources of inspiration came from languages such as Chill and Ada which are used in industry for programming control systems.", "authors": [{"name": "Joe Armstrong", "author_profile_id": "81100467022", "affiliation": "Computer Science Laboratory, Ericsson Telecom AB", "person_id": "PP39044093", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/258948.258967", "year": "1997", "article_id": "258967", "conference": "ICFP", "title": "The development of Erlang", "url": "http://dl.acm.org/citation.cfm?id=258967"}