{"article_publication_date": "08-01-1997", "fulltext": "\n On global dynamics of optimal graph reduction Julia L. LawalJ* Harry G. Mairsont IRISA Computer Science \nDepartment Campus Universitaire de Beaulieu Brandeis University 35042 Rennes Cedex Waltham, Massachusetts \n02254 France Abstract Optimal graph reduction technology for the A-calculus, as developed by Lamping, \nwith modifications by Asperti, Gonthier, Abadl, and Lr5vy,has a well-understood local dy\u00ad namics based \non a standard menagerie of reduction rules, m welI as a global contezt semantics baaed on Girwd s geom\u00adetry \nof interaction. However, the global dynamics of graph reduction has not been subject to czueful investigation. \nIn particular, graphs lose their structural resemblance to X terms after only a few graph reduction steps, \nand little is known about graph reduction strategies that maintain effi\u00adciency or structure. While the \ncontext semantics provides global information about the computation, its use as part of a reduction strategy \nseems computationally infeasible. We propose a tractable graph reduction strategy that preserves computationally \nrelevant global structure, and allows us to efficiently bound the computational resources needed to im\u00adplement \noptimal reduction. A simple canonical representation for graphs is intro\u00adduced that we call fan-normal \n~orm. This normal form al\u00adlows us to reduce graphs baaed on efficient identification of /?-redexes, rather \nthan being guided by lower-level search for interacting nodes. In addition and perhaps more impor\u00adtant, \nthe fan-normal form facilitates a complexity analysis of graph reductions, showing that the number of \nfan interac\u00adtions is essentially bounded by a polynomial in the number of unique L6vy labels generated \nduring a labelled reduc\u00adtion. This global analysis of the finitary dynamics of opti\u00admal reduction is \nthe fist demonstration that a reasonable implementation-independent cost model for the A-calculus is \nin fact realized by Lamping s abstract algorithm. It re\u00admains to be seen whether similar claims can be \nmade about so-called bookkeeping for fan interactions. Work performed at Brandeis University, supported \nby ONR Grant NOOO14-93-1-1015 and NSF Grant CDA-95042SS, and at IRIS A, supported by a NSF International \nPost-Doctoral Research Fel\u00adlowship. E-mail: jU@irisa.fr. Phone: (33) 299847536. tsupported by ONR Grmt \nNoOO14-93-1-1O15, NSF Grant CCR\u00ad 9216185, and the Tyson Foundation. Permission to make digital/hard \ncopy of part or all this work for personal or classroom use is granted without fee provided that copies \nare not made or distributed for profit or commercial advan\u00ad tage, the copyright notice, the title of \nthe publication and its date appear, and notice ia given that copying is by permission of ACM, Inc. To \ncopy otherwise, to republish, to post on servers, or to redistribute to lists, requires prior specific \npermission and/or a fee. ICFP 97 Amsterdam, ND @ 1997 ACM 0-89791 -918 -1/97 /0006 .,.$3.50 1 Introduction \nA fundamental distinction between the varieties of func\u00adtional programming languages can be made by considering \nrespective evaluation stmtegies. In what order are subex\u00adpressions evaluated? All such languages are \nfounded on the A-calculus [Chu41, Bar84]. But this calculus, like every\u00adday algebraic calculation, is \nindeterminate choosing what subexpression to simplify next is not specified, though the Church-Rosser \ntheorem provides assurance that we always get the same anewer, if there is one. The designer of a func\u00adtional \nprogramming language must complete this ihrnework by choosing a deterministic strategy, while balancing \nissues of efficiency and of semantic clarity, In searching for efficient evaluation strategies for the \nX calculus, a natural goal was to minimize the number of @\u00adreductions, which implement the application \nof functions to arguments. However, there are many examples of A-terms where the minimal reduction sequence \ndepends on specific term structure, and seems inaccessible to any fixed, univer\u00adsal reduction strategy. \nInstead, attention was drawn to aug\u00admenting the syntactic world of the A-calculus with a sharing mechanism, \nintroducing basic data structures allowing du\u00adplicated terms-the bane of efficient evaluation-to be rep\u00adresented \nuniquely and reduced without redundancy. A well\u00adknown evaluation technique of this sort is due to Wadsworth \n[Wad71]. While these techniques succeed in the efficient sharing of arguments, they suffer from redundancies \ncaused by the necessary copying of shared functions. In foundational research some two decades ago, Jean-Jacques \nL4vy attempted to formally characterize what an optimally efficient strategy would look like, even if \nthe technology for its implementation was at the time lacking. Lr5vy s dual goals were correctness, so \nthat such a reduc\u00adtion strategy does not diverge when another could produce a normal form, and optirnahty, \nso that redexes are not du\u00adplicated by a reduction, causing a redundancy in later calcu\u00adlation [L6vY78, \nL6vy80]. The relevant functional program\u00adming analogies are that call-by-name evaluation is a cor\u00adrect \nbut not optimal strategy, while call-by-value evaluation is an approximation of an incorrect but optimaJ \nstrategy. Lr4vyintroduced a variant of A-calculus where all subterms of an expression are annotated with \nlabels that code the his\u00adtory of a computation. He proposed the notion of a redex famil~redexes in a \nterm with identical labels in the Yunc\u00adtion position to identify similar redexes whose reduction should \nsomehow be evaluated at once (via a so-called parallel ~-reduction) by any efficient scheme. Recent \nresearch by Lamping, and independently Kathail, has shown that there indeed exist A-calculus evaluators \nsatis\u00adfying L6vy s specification [Lam90, Kat90]. Lamping s work, in particular, was followed by variants \nand simplifications proposed by Asperti, and Gonthier, Abadi, and L6vy, among others [AsP94, GAL92]. \nThe basic framework was to begin with a straightforward graph reduction scheme made up of application \n(Q) and abstraction (J) nodes, and augment it with sharing nodes that lazily duplicate pieces of the \ngraph. lladitional sharing nodes, found in implementations of lazy evaluation, allow the sharing of a \nsingle value between two different evaluation contezts. Lamping s key insight was to introduce a dual \nform of sharing, where a single evaluation contezt is shared by two different values. These two forms \nof sharing nodes allow a single, shared representation of a redex family, and thus provide a means to \nimplement L6vy s notion of parallel reduction. The varied implementations of this fundamental framework \ndiffer in the underlying bookkeep\u00ading technology used to control interactions between sharing nodes. \nFor a gentle introduction to and summary of these issues, see [LM96]. A dktinguishing characteristic \nof optimal reduction schemes founded upon graph reduction is their description solely in terms of local \nreduction rules. This approach sim\u00adplifies the underlying atomic operations, and facilitates im\u00adplementation. \nReducing the graph representation of a X term, however, quickly yields intermediate graphs (i.e., rep\u00adresenting \nintermediate terms in the reduction) whose struc\u00adture is utterly obscure. Formidable problems then exist \nwith respect to readback of a term represented by a graph. In fact, the problem becomes so tortuous that \n[GAL92] largely dispenses with readback, substituting instead the use of wn\u00adtezt semantics to read back \nthe (invariant!) Bohm tree of the term. Equally intractable seems the problem of simply find\u00ading a /3-redex \nin the graph, which is by contrast absurdly trivial when reducing terms. The difficulty is never faced \nby known implementations, which just look for interacting pairs of nodes, whether or not they are @ and \nA nodes. An unfortunate consequence of computation via local rules is that optimal graph reduction evaluators \ncan exponentially duplicate graph structure even though there are no more@ redexes in the graph [LM96]. \nBecause paths between @ and A nodes may encounter intermediate sharing nodes linked in perverse ways, \nthe computationally prohibitive context S* mamtics of [GAL92] has been the only known way of doing relevant \nstatic analysis of graphs. Optimal graph reduction technology has also obscured the complexity analysis \nof reduction. In particular, in what sense is the graph technology algorithmically efficient? A re\u00adcent \npaper by Frandaen and Sturtivant proposed the cost of a reduction to be the number of parallel /3-reduction \nsteps, plus the lengths of the initial and fial terms [FS91]. Unfor\u00adtunately, graph reduction may require \ninteraction of sharing nodes that grows exponentially in the number of parallel @ steps, a result derived \nindependently by Asperti [AsP96], and in a simplified way by the authors [LM96]. As a con\u00adsequence, initial \nand tinal terms can be short, parallel re\u00adductions can be very few, yet intermediate forms can grow exponentially \nin these parameters. Mackie haa investigated optimizations of the algorithm, however, his results apply \nto the static context semantics, rather than to reduction [Mac95]. In summary, while the development \nof optimal reduction engines haa been inspired, at least in spirit, by biologist Ren6 Dubos famous adage \nto think globally and act locally, it has been damned by the admonishment of Socrates that we know the \ngood things, but we don t do them. It is certainly an open problem to improve the efficiency of implementing \nreduction in A-calculus, but it seems unlikely that parallel ~-reduction can be effected as a unit-cost \noperation, since the cost of substitution may vary widely. A better course of action, in our opinion, \nis to consider more realistic cost models that explain the inherent efficiency of optimal graph reduction \nin an implementation-independent way. Technical contributions: In this paper, we make four fundamental \ncontributions to understanding the finitary dynamics of optimal graph re\u00adduction at a global level. . \nWe define an invariant relating the number of L6vy la\u00adbels in a term to the structure of the associated \ngraph. This invariant is maintained by reduction. . We characterize a canonical form for graphs that \nwe call tan-normal ~own. This normal form makes patha explicit, and thus allows the efficient identification \nof parallel ,fLredexes, without resorting to the context se\u00admantics. Graph reduction ia reorganized into \ncanonical @steps, which reduce a single ,B-redex and return the graph to fan-normal form. . We propose \na reasonable, implementation-independent cost model to account for Lamping s abstract algo\u00adrithm, counting \nthe work of fan nodes, but not book\u00adkeeping (e.g., bracket and croissant) nodes. Namely, we replace the \nnumber of parallel @reductions in the Frandsen-Sturtivant cost model by the number of unique L6vy labels \ngenerated during a labelled reduc\u00adtion. . By restructuring graph reduction as a sequence of c~onical \n~-step~, we-can control the num~er of fan interactions between ordinary ~-reductions. Combin\u00ading the \ninvariant on path labels with the maintenance of fan-normal form, we show that Lamping s abstract algorithm \ndoes satisfy the proposed cost model. This analysis establishes that the graph redundancy intro\u00adduced \nby lazy copying can be bounded by a polynomial in the number of unique L6vy labels. Polynomial relat\u00adedness \nis the fundamental equivalence relation inherent in the invariance thesis that characterizes first class \nmachine models; this notion is the computer scientist s refinement of Church s thesis [vEB90].  In a \nrecent paper, Asperti has advocated the number of fan interactions aa the defining cost metric for A-calculus \nreduction [Asp96]. He intuitively asserts that Lamping s ab\u00adstract algorithm performs no useless work. \nWe agree with the assessment of the efficiency of the abstract algorithm. However, inspired by both the \nliterature on machine simu\u00adlation, where cost models are not linked to implementation or simulation, \nas well aa dominant themes in denotational semantics, where the meaning of a language is distinct horn \nany particular implementation technology, we prefer to ad\u00advocate our implement ation-independent metric. \nOur analysis is the first demonstration that a reasonable implementation-independent cost model for the \nA-calculus can in fact by realized by an efficient machine implemen\u00adtation. By implementation here, we \nmean Lamping s ab\u00adstract algorithm; we have shown in [LM96] that the further x Ax.E ix ,. -) E ~1 J \nFigure 1: The translation of A terms interaction of bookkeeping nodes (brackets, croissants, etc.) used \nto maintain jan indices may grow exponentially in the number of fan interactions. It remains an important \nopen research question whether an alternate bookkeeping scheme could have cost polynomial in the number \nof fan interac\u00adtions. 2 Preliminaries We begin with an overview of Larnping s abstract algorithm, and \nwith the L6vy labelled A-calculus. 2.1 Lamping s abstract algorithm Lamping s abstract algorithm is a \nvariant of the usual graph implementation of call-by-need evaluation, but in which shared structures \nare lazily duplicated by the introduction of pairs of sharing nodes. C~raphsare composed of fan nodes, \nwhich are classified as A, [Q, or shuing nodes. The transla\u00adtion of a A-term into a graph is shown in \nFigure 1. Wh-es at the bottom of a subgraph represent free variables. The fan node at the bottom of the \ngraph of EF shares a variable occurring in both E and F. Fan nodes, whether A, Q, or sharing nodes, can \nonly interact at a distinguisheti interaction port. The rules for the interaction between fan nodes are \nshown in Figure 2.1 To understand the meaning of these graph reduction rules, consider, for example, \nthe duplication of a A node by a sharing node. The sharing node indicates the use of a A-expression by \ntwo different contexts. In graph reduction, the J node is copied for each context, and two sharing nodes \nare introduced. The left sharing node shares the body of the A-expression between the two uses. The right \nsharing node dually shares the bound variable. If both A-expressions me later functions in ~-redexes, \nthe arguments will share the context given by the bound variable wire. How sharing nodes interact depends \non whether they are similar or diflerent. Two sharing nodes are said to be similar when they were created \nas part of the duplication of the same A-abstraction. Detecting whether two sharing nodes are similar \nis the responsibility of the bookkeeping nodes, which we do not consider here. In the abstract algorithm, \nwe assume that the identity of sharing nodes is determined by an oracle. The beginning of the reduction \nof (Az.zz)(Az .ZZ) is shown in Figure 3. In the second step a A-abstraction begins 1Gonthier, Abadi, \nand L.4vy present these rules more concisely by considering A and @ nodes as sharing nodes that are the \nsame as each other, but different from all other sharing nodes, Our more ver\u00adbose presentation coincides \nwit h the distinctions made by the analyses later in the paper. to be lazily duplicated to expose a @-redex. \nA more com\u00adplete and intuitive introduction to the abstract algorithm is presented in [LM96]. In the \nrest of the paper, we use the following terminology to describe the structure of graphs. Definition 2.1 \nA primary node in a gmph is either a A nodeoran @ node. A path is a sequence of edges from a port of \na primary node to a port of another primary node that does not enter or exit any other primay node. That \nis, all intermediate nodes occuring along a path are sharing nodes. A path is identified with its inverse. \nDefinition 2.2 A port is the endpoint of a graph edge in\u00adcident upon a node. Each node has three ports: \nan interac\u00adtion port, and left and right ports identi~ing the two non\u00adinteracting ports.2 Ports are further \nclassified as either value ports or environment ports. A value port of a ,4, @, or sharing node supplies, \nvia the connecting path, a value to an accompanying evaluation conteti. Dually, an environment port ofaA, \n0, or sharing node supplies, via the connecting path, an evaluation context to an accompanying subgraph. \nDefinition 2.3 A positive sharing node is one whose in\u00adteraction port is an environment port, and whose \nnon\u00adinteraction ports are value ports. Dually, a negative sharing node has an intemction port that is \na value port, and non\u00adinteraction ports that are environment ports. The graphs below illustrate A nodes, \n@ nodes, and posi\u00adtive and negative sharing nodes, where v and e mark value and environment ports. y \n&#38; i; -., e v e? e -e It is a simple observation that an edge between two nodes connects a value \nport with an environment port: continua\u00adtions need values, and vice versa. 2.2 L6vy labels There are \na variety of flavors of Lr5vylabels; in this paper, we have relied on the version in [Fie90]. The set \nof labels is made up of a countably infinite set of atomic labels (such w integers), and closed under \nthe operations of concatenation and underlining. Briefly, each subterm of the initial A-term is initially \nannotated with a unique label. As reduction oc\u00adcurs, labels are concatenated and underlined, according \nto arcane rules, so that the labels encode the history of the com\u00adputation. A labelled A-term thus codes \nthe reduction history that led to its derivation; labels can also be interpreted in terms of contezt \nsemantics [GAL92] as coding information flow in the graph representation between functions and ar\u00adguments. \nThis insight is developed in considerable detail by Asperti [Asp95]. The label on the A-abstraction in \na @ redex is called the ~amily indez of the redex, because the same label may appear on the function \nposition of a fam\u00adily of distinct redexes that should be reduced as one. When (kc.E)F is reduced, the \nlabel on each free z in E is (reverse) 2Gonthier, Abadi and L6vy call these black and grey ports; Lamp\u00ading \ncalls them star and circle ports. Rather than give in to either nomenclature, we invent our own,  -y7 \nJ, A  ,x * -+ w { similar different Figure 2: The interactions between fan nodes 1 / d ,/ ii + \\Q/ 0/ \n~ \\\\. 1 L ?? I._ Figure 3: The reduction of (Az.zz)(kz.zz) Figure 4: Graph rewriting for psmllel labelled \n/3-reduction concatenated with the underlining of the family index, and the label of the argument; the \nlabel of E is concatenated with the underlining of the family index, and the label of the redex: (AZ.E) \nF + l?~[z 1+ F~] For example, ((At . (1?z ) ) (Az. (z?J) ) )g + ((k.(z Zqyl(k(z x )y ) @ The L6vy-labelled \nJ-calculus has a dwect analogue in terms of sharing graphs, where edges in the graph are anno\u00adtated with \nlabels. For example, the above labelled reduction rule is mirrored by the labelled graph rewriting rule \nshown in Figure 5. We also need to specify how labels are shared. When a label is duplicated by a sharing \nnode, it is concate\u00adnated by a positive node, and reverse concatenated by a negative node. These rules, \nshown in Figure 6, preserve the fidelity of representation and of readback. y d /-A ef Figure 5: Commuting \nlabels and sharing nodes 3 An invariant on intermediate graphs As observed by Lamping [Lam90], it is \nnot the case that every link in the graph is associated with a unique L6vy la\u00adbel. We can state an invariant, \nhowever, relating L6vy labels to intermediate graphs. This invariant will be essential in accounting \nfor the cost of reductions. Path-label Invariant: If two distinct paths have the same ports as endpoints, \nthen the paths have different labels. Theorem 3.1 Graph reduct ion preserves the path-label in\u00ad variant. \n Proof. We consider a graph satis~ing the path-label invariant, and the three possible reductions in \nthe abstract algorithm: 1. The interaction between a pair of sharing nodes. 2. The interaction of a \nsharing node with a primary node. 3. A ,8-reduction.  The interaction between a pair of sharing nodes \nhas no effect on the paths in the graph. Thus the invariant is triv\u00adially preserved. When a sharing node \ninteracts with a primary node, paths are duplicated. Since the primary node is duplicated as well, creating \nnew endpoints, the invariant is preserved. The most complicated case is /3-reduction, which removes primary \nnodes, and hence endpoints, from the graph. Paral\u00adlel ~-reduction causes two fusings of paths: one on \nthe jrmc\u00adtion CUUside (left), and one on the argument side (right). The label of each path contains an \nunderlining of the unique family index. Thus the labels are distinct from the labels of the original \ngraph. We next show that the labels on each side are pairwise distinct. On the function call side the \npaths ending in the left port of the @ node are fused with the path through the redex and the paths beginning \nat the left port of the A node. Before the reduction each path has a unique configuration of labels and \nendpoints. Because each path ending at the Cl or A shares a common endpoint there, it is the other endpoint, \nwhich is not affected by the ~ reduction, that makes the configurations of labels and endpoints unique. \nThus, since the underlined family index acts as a unique demarcator, the configurations of labels and \nendpoints for the fused paths are pairwise distinct. The configurations of labels and endpoints created \non the argument side are similarly pairwise dktinct. However, could a label yg of a path on the function \nside be identical to the label q~z of a different path on the argument side? Since the label ~ is new \nand unique, it acts as an unam\u00adbiguous demarcator, hence we would have ~ . q andps z. Were this the case, \nreadback would show that the label p of an application was identical to the label z of a bound variable. \nHowever, the following argument shows that such a situation is impossible. It is straightforward to show \nthat every label has the form ax, where a is an atomic label of a subexpression of the source term, and \nz may be empty. If a is the label of a variable in the source term, we say that ax is a variable label. \nIf a is the label of a lambda abstraction or application in the source term, we say that ax is an expression \nlabel. Because every subexpression in the source term has a unique label, the set of variable labels \nis disjoint from the set of expres\u00adsion labels. It remains to show that ,fLreduction preserves the property \nthat variables have variable labels and lambda abstractions and applications have expression labels. \nThe only terms whose labels are affected by reduction are the parameters and body of the lambda abstraction. \nEach occurrence of the parameter is replaced by the argument. The new label begins with the label of \nthe argument. The substitution creates a variable only if the argument is it\u00adself a variable. In this \ncase, the label of the argument is a variable label, and thus the new label is also a variable label. \nSimilarly, the substitution creates a lambda abstrac\u00adtion or application only if the argument is itself \na lambda abstraction or an application. In this case, the label of the argument is an expression label, \nand thus the new label is also an expression label. We now consider the body of the lambda abstraction. \nIf it is simply the parameter (i.e., the lambda abstraction is simply Az.x), then we have seen that the \nnew label of the body begins with that of the argument, and is from the appropriate set. Otherwise the \nclassifica\u00adtion of the body is nnatfected by the reduction. The new label begins with the old label, \nwhich is a variable or ex\u00adpression label as appropriate. Thus the property that the ++ .. .... + - ,+ \n. + Figure 6: A tree of positive sharing nodes. set of labels attached to variables is distinct from \nthe set of labels attached to lambda abstraction and applications is preserved by reduction. This concludes \nthe proof of Theorem 3.1. . The previous theorem can be used, together with some basic facts about optimality, \nto give a unique characteriza\u00adtion of every path in the graph. This characterization is used in the analysis \nof Section 5. Definition 3.2 For anyAor @node n in an intermediate graph representing a step in the reduction, \nwe dejine I(n), the canonical identifier of n, as follows: . ifn is eliminated via a parallel P-step \nwith family index w, then Z(n) = W.3 . otherwise, n appears in the final gmph: Z(n) is defined as the \nordinal for n.  Optimality tells us that for any intermediate form of the graph, at most two nodes can \nhave the same canonical iden\u00adtifier w: the A and @ node involved in the pzmdlel reduction with index \nw. Definition 3.3 Given a path p with label w between the value port v of primay node m and the environment \nport e of a primay node n, we define the path identifier II(p) to be the tuple (v, Z(m), w, e, Z(n)). \nLemma 3.4 No two paths have the same path identifier. Proof. The path-label invariant implies that no \ntwo paths have the same path identifier. The source graph satisfies the path-label invariant. Theorem \n3.1 shows that the path-label invariant is preserved by reduction. . 4 Fan-normal form Definition 4.1 \nA gmph is in fan-normal form ifit has no sharing nodes facing each other on intemction ports. In fan-normal \nform no interactions between sharing nodes only are possible. As a consequence, sharing nodes accumu\u00adlate \nin binary trees of all positive or all negative nodes (a positive tree is shown in Figure 7). These trees \nare stuck on a free variable, or on the ports of @ and A nodes (see Figure 8). Lemma 4.2 A ~-redez cm \nbe found in time proportional to the size of a gmph in fan-normal form. 3We consider that when a primary \nnode is duplicated, one of the primary nodes produced ie the original, and the other is a fresh copy. \n.. .. . ,.. :U_ .. 2. The number of @ and A nodes in the graph represen\u00adtation of the normal form of \nthe term.  .+ ~ A/i \\  ,-+\\ 1 ... .,. AL y ($root / ,.. x Figure 7: Fan-normal form. Proof. Start \nat a A node, and search to each of the leaf wires of the (positive) tree above the node: in the case \nof a redex, the leaf wire will be attached to an @ node, or will be the leaf of a (negative) tree leading \nto an @ node. We remark that without the fan-normal form, paths from an Cl node to a A node, as directed \nby the context semantics, can have exponential length, due to multiple entries and exits from sh~ing \nnodes along the path; see [LM96] for details. 9 Definition 4.3 A canonical ~-reduction, based on the \nfan\u00adnorrnal form, consists of the following sequence of steps: (1) identify a ~-redex; {2) move releuant \nsharing nodes past the @ and A node of the redex; (3) reduce the redex; (~) carry out as man~ interactions \nas possible between sharing nodes, not allowing the duplication of @ or A nodes. The steps in a canonical \n/3-reduction are shown in Fig\u00adure 9. When the applied A-abstraction is Az .x, there is an additional \ninteraction between the trees P and Q . Theorem 4.4 Canonical ~-reduction preserves fan-normal form. \nProof. By induction on the structure of the source term and the number of such reductions. Since the \ngoal of graph reduction is to reduce all the ~~ redexes, clearly we obtain a graph representation of \nthe normal form of the term by considering only canonical @ redexes. The obvious and fundamental question \nis then: can fan-normal form be maintained without prohibitive cost while doing reductions? We address \nth~ question in the next section. 5 Accounting for fan interactions in @ reduction We want to show \nthat the total number of graph interac\u00adtions involving Cl, A, and sharing nodes is bounded by a polynomial \nin the sum of the following two parameters: 1. The number of unique labels generated during the rr+ duction; \nWhile the second item above seems a peculiar and implement at ion-dependent parameter, we remark that \nit is certainly bounded by the size of the output, and that it can furthermore be replaced by a technical \nand complicated pa\u00adrameter baaed purely on labels. In this latter c~e, we need only make precise what \nis an unshakable pair of applications or abstractions in a labelled term, e.g., using Lamping s idea \nof prerequisite chains [Lam90]. We account for the cost of fan interaction and related parallel ~-reduction \nby charging individual fan interactions to tuples made up of a family index and up to three path identifiers. \nLet n be the sum of the above parameters, The number of family indices is clearly O(n). The number of \npath identifiers is 0(n3), accounting for the label and the nodes at the two endpoints. Because there \nare only three kinds of port identifiers (interaction, left, right), the port identifiers only contribute \na multiplicative constant factor to the charging scheme. The bound we give in Theorem 5.4 is thus O(nlO). \nThis bound is deliberately crude and without doubt can be made tighter, but for the moment we are not \ninterested the given bound both preserves polynomial relatedness, and facilitates the analysis. A further \ntechnical analysis will doubtless re\u00adduce the bound. For tuples of labels T = (tl, ....tk) and U= (u,,. \n...ut) we write To U to denote the concatenated tuple (t,,...,tk,ul,u,),u,). The substeps of a canonical \n~-reduction consist of the interaction between a tree and a primary node, or between a tree of positive \nsharing nodes and a tree of negative sharing nodes. We begin with some observations about the cost of \nthe interaction between trees of sharing nodes. Lemma 5.1 In the interaction between a positive tree \nwith m sharing nodes and a negative tree m th n sharing nodes, there are at most mn fan intemctions, \noccurring when there are no annihilations between intemcting fan nodes. When annihilations occur between \ntrees of sharing nodes, the number of interactions decreases. Annihilation has at worst a linear effect, \nsince two sharing nodes disappear, but also has the ability to fork trees onto different paths in the \ngraph and thus eliminate any interaction. In a graph in fan-normal form, the number of leaves of a tree \ncoincides with the number of paths through the tree, and is greater than the number of nodes in the tree. \nThus we can use path identifiers to account for the number of nodes in a tree. Definition 5.2 We write \nITI to denote the number of (non\u00adinteractive) leaves of a tree T. Using this analysis of the cost of \nthe interaction between trees of sharing nodes, we make the following association between the substeps \nof a canonical /3 reduction and tuples of path identifiers. Moving R past the @ node (see Figure 9). \nBy Lemma 3.4, the II(~i) are unique. We thus charge 1 to each of the pairs (w) o II(r;), where w is the \nfamily index of the reduction, and ri is a leaf wire of R. We write this Chage as ..  R = -R, $ YQ \n42P~!,  ~j/+ P\\+,< ., +/ . ,. +/ -, : >~. ::? Q , ,\u00ad -R 0[ ..0...0 0 . . . o! .:p,, < .  + x * / \n1. ). k Lk.,. k : ~ .:-. A x + x Y - - -+ +Z x +,.+:,,+ .,)-,.,-x Y-+Z +Z ... ... ... ... z* \n44Y-AA Figure 8: A canonical ,Breduction Moving P past Q . If the function applied is Ax.x, we Moving \nR past P. IR I = IRI, therefore have the additional cost of moving P past Q . A sin\u00adgle Anode can represent \nmany c~pies of the identity function. In particular, the number is bounded by the number of possible \nconnections between the left and right ports of the A-node, i.e., the minimum of IYI Moving R paat and \n121. We arbitrarily choose to charge against the paths of Y: ~ (w)o~(~i)O~@j)O ~(@). Dual charges for \nmoving sharing nodes past A-node. Lemma 5.3 The charges made to any tuple (al,. . . . crk) Zl<i<lXl(w) \n0 (zi) + above are bounded b~ a constant. Proof. By appealing to optimality and uniqueness of path identifiers. \nTheorem 5.4 The total number of fan interactions is O(nlO), where n is the sum of the number of labels \ngen-Parallel $step. Charge 1 to (w}. erated during reduction, and the number of primay nodes in the final \ngraph. Moving Y past P. By Lemma 3.4, the II(~i) arid II(pj) are unique; we then chimge Corollary 5.5 \nIn reduction to constants, the number of fan interactions is bounded by a polynomial in the number of \nlabels genemted. 6 Conclusions Moving Q past Z. Similarly, charge We have made a first attempt at understanding \nthe global ~ (w) ~(qi)on(.j).  dynamics of graph reduction mechanisms for implementing optimal evaluation. \nWe like the straightforward, mundane nature of our arguments, and their reliance on simple in\u00advariant. \nWe hope eventually to develop an understanding of optimal evaluation that makes its dynamics and its \ncor\u00adrectness as easy to understand as quicksort. No category theory is necessary-it s only an algorithm! \nA plausible corollary to Theorem 5.4 would be an anal\u00adogous result that counts the work done by all graph \nopera\u00adtions, including bracket and croissant operators that main\u00adtain the fidelity of sharing node indices. \nWe conjecture that a similar theorem holds by replacing the number of unique labels with the sum of their \nrespective lengths. The intuition is simply that the duplication of bracket and croissant oper\u00adators \ncorresponds closely to the commuting of labels across sharing nodes; the metric bounds the bookkeeping \ninterac\u00adtions because while nodea can annihilate, labels cannot get shorter. We also hope to demystify \nthe readback procedure, based on insight we have about identifying redexes; the abil\u00adity to do so offers \nthe possibility of controlled introduction of graph operations that destroy optimality if misused, and \nvi\u00adolate context semantics at the naive level of local rewriting, but obey the semantics at a globaJ \nlevel. Acknowledgments. We thank Jean-Jacques Lkvy, Georges Gonthier, and Peter Lee for their encouragement, \nMartin Abadl for answering some questions we had con\u00adcerning context semantics, and Olivier Danvy for \nvaluable comments on an earlier draft. References [Asp94] Andrea Asperti. Linenr logic, comonads, and \nopti\u00admal reductions. Fundarnenta Informaticae 22:1, 1994. [Asp95] Andrea Asperti and Cosimo Laneve. Paths, \nampu\u00adtations, and labels in the A-cnlculus. Theoretical Computer Science 142:2 (May, 1995), pp. 277\u00ad \n297. [Asp96] Andrea Asperti. On the complexity oj beta\u00adreduction. 1996 ACM Symposium on Princi\u00adples of \nProgramming Languages, pp. 110 1 18. [Bar84] Hendrik Barendregt. The Lambda Calculus: Its Syntax and \nSemantics. North Holland, 1984. [vEB90] Peter van Ernde Boas. Machine models and sim\u00adulation. Handbook \nof Theoretical Computer Science, volume A, pp. 146. North Holland, 1990. [Chu41] Alonzo Church. The Calculi \nof Lambda\u00adconversion. Princeton University Press, 1941. [Fie90] John Field. On laziness and optimality \nin lambda in\u00adterpreters: tools for specification and anal~sis. 1990 ACM Symposium on Principles of Program\u00adming \nLanguages, pp. 1 15. [FS91] Gudmund S. Ikmdsen and Carl Sturtivant. What is an eficient implementation \nof the A-calculus? 1991 ACM Conference on Functional Program\u00adming and Computer Architecture (J. Hughes, \ncd.), LNCS 523, pp. 289-312. [GAL92] Georges Gonthier, Martin Absdi, and Jean-Jacques L&#38;y. The gwmetry \nof optimal lambda reduction. 1992 ACM Symposium on Principles of Pro\u00adgramming Languages, pp. 15 26. Stefano \nGuerrini. Sharing-gmphs, sham ng-mor\u00adphisms, and (optimal) A-gmph reductions (dmft). Unpublished manuscript. \nJune 16, 1995. [Kat90] Vinod Kathail. Optimal interpreters for lambda\u00adcalculus based functional languages. \nPh.D. Thesis, .MIT, May 1990. [Lam90] John Lamping. An algorithm for optimal lambda calculus reduction. \n1990 ACM Symposium on Principles of Programming Languages, pp. 16\u00ad 30. [LM96] Julia L. Lawall and Harry \nG, Maireon. Optimal\u00adity and inefficiency: what isn t a cost model of the lambda calculus ? 1996 ACM International \nCon\u00adference on Functional Programming, pp. 92\u00ad 101. [L&#38;y78] Jean-Jacques L6vy. Reductions wrrectes \net opti\u00admales clans le lambda-calcul. Th.%e d Etat, Univer\u00adsity! Paris 7, 1978. [L&#38;y80] Jean-Jacques \nL&#38;y. Optimal reductions in the lambda-calculus. Ib H. B. Curry: Essays in Combinatory Logic, Lambda \nCalculus and Formalism, (Jonathan P. Seldin and J. Roger Hind-Iey, editors), pp. 159-191. Academic Press, \n1980. [Msc95] Ian Mackie. The gmmetry of intemction machine. 1995 ACM Symposium on Principles of Pro\u00adgramming \nLanguages, pp. 198-208. [wad71] Christopher Wadsworth. Semantics and pmgmat\u00adics of the A-calculus. Ph. \nD. Thesis, Programming Research Group, Oxford University. 195  \n\t\t\t", "proc_id": "258948", "abstract": "Optimal graph reduction technology for the &amp;lambda;-calculus, as developed by Lamping, with modifications by Asperti, Gonthier, Abadl, and L&amp;eacute;vy, has a well-understood <i>local dynamics</i> based on a standard menagerie of reduction rules, as well as a <i>global context</i> semantics based on Girard's geometry of interaction. However, the <i>global dynamics</i> of graph reduction has not been subject to careful investigation. In particular, graphs lose their structural resemblance to &amp;lambda;-terms after only a few graph reduction steps, and little is known about <i>graph</i> reduction strategies that maintain efficiency or structure. While the context semantics provides global information about the computation, its use as part of a reduction strategy seems computationally infeasible. We propose a tractable graph reduction strategy that preserves computationally relevant global structure, and allows us to efficiently bound the computational resources needed to implement optimal reduction.A simple canonical representation for graphs is introduced that we call <i>fan-normal form</i>. This normal form allows us to reduce graphs based on efficient identification of &amp;beta;-redexes, rather than being guided by lower-level search for interacting nodes. In addition and perhaps more important, the fan-normal form facilitates a complexity analysis of graph reductions, showing that the number of fan interactions is essentially bounded by a polynomial in the number of unique L&amp;eacute;vy labels generated during a labelled reduction. This global analysis of the finitary dynamics of optimal reduction is the first demonstration that a reasonable implementation-independent cost model for the &amp;lambda;-calculus is in fact realized by Lamping's abstract algorithm. It remains to be seen whether similar claims can be made about so-called <i>bookkeeping</i> for fan interactions.", "authors": [{"name": "Julia L. Lawall", "author_profile_id": "81100529486", "affiliation": "IRISA, Campus Universitaire de Beaulieu, 35042 Rennes Cedex, France", "person_id": "PP15035219", "email_address": "", "orcid_id": ""}, {"name": "Harry G. Mairson", "author_profile_id": "81100061196", "affiliation": "Computer Science Department, Brandeis University, Waltham, Massachusetts", "person_id": "P107959", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/258948.258966", "year": "1997", "article_id": "258966", "conference": "ICFP", "title": "On global dynamics of optimal graph reduction", "url": "http://dl.acm.org/citation.cfm?id=258966"}