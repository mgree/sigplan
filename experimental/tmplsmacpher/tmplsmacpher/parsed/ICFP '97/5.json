{"article_publication_date": "08-01-1997", "fulltext": "\n Catenable Double-Ended Queues Chris Okasaki School of Computer Science Carnegie Mellon University Pittsburgh, \nPA 15213 (cokasaki@cs.cmu.edu) Abstract Catenabledouble-endedqueues aredouble-endedqueues (deques) thatsupportcatenation(i.e., \nappend)efficientlywithoutsacrificing the efficiency of other operations. We present a purely functional \nimplementationof catenabledequesfor whicheveryoperation,in\u00adcluding catenation,takea0(1) amortizedtime. \nKaplan and Tarjan haveindependentlydeveloped amuch morecomplicated implemen\u00adtationof crdenabledequesthatachievessimilarworst-casebounds. \nThe two designs aresuperficiallysimilar,butdiffer in theunderly\u00ading mechanismusedtoachieveefficiency \ninapersistentsetting(i.e., whenusedinanon-single-threadedfashion). Theirimplementation usesatechniquecalled \nrecursiveslowdown, whileoursrelieson the simpler mechanism of lazy evaluation. Besides lazy evaluation, \nour implementation rdso exemplifies theuseof twoadditionallanguagefeatures:polymorphicrecursion andviews. \nNeitherisindispensable,butbothsignificantlysimplify thepresentation. 1 Introduction Purelyfictional programmingis \ngraduallygainingrecognitionin thedatastructurescommunityasanexcellentmediumfor designing persistent (i.e., \nimmutable) data structures. Several other generrd techniques for designing persistentdata structuresexist \n[5, 4], but unfortunately,these other techniques break down when the data structurein question supportsoperationsthatcombine \ntwo or more structures.Examples of such offending operationsinclude catenat\u00ading (i.e., appending) two \nsequences, unioning two sets, or merging twopriorityqueues. Of these,sequencecatenationhasreeeivedthe \nmost attention[6, 1, 11, 17]. llvo implementationsof purely functional catenablelists have recently been \nproposed. Kaplan and Tarjan [11] described an ap\u00adproachthatsupportscatenationandall otherusuallistoperations \nin O(1) worst-case time. Okasald [17] presented a much sim\u00adpler implementationbased on lazy evaluationthatachieved \nsimilar amortized bounds. In this paper, we extend these results to the double-ended case, yiekiing a \npurely functional implementationof catemble dequesthatsupportscatenationandallotherusualdeque lllis researchwas \nsponsoredby he AdvancedResearchProjectsAgency CSTO urrdertbetitk TheFoxProject AdvancedLeoguagedforSysterrrsSoftware \n,ARPA OrdesNo.C533,issusd byESC/ENSunderCon!ractNn.FI%28-95-C-O050. Permission to make digital/hard copy \nof part or all this work for personal or claasroom use is granted without fee provided that copies are \nnot made or distributed for profit or commercial advan\u00ad tage, the copyright notice, the title of the \npublication and its date appear, and notice is given that copying is by permission of ACM, Inc. To copy \notherwise. to republish, to post on servers, or to redistribute to lists, requires prior specific permission \nand/or a fee ICFP 97 Amstardam, ND @ 1997 ACM 0-89791 -918 -1/97 /0006,.. $3.50 operationsin 0( 1) amortizedtime, \nKaplanandTarjan[12] havein\u00addependentlydevelopedanimplementationof catenabledequesthat achievesthesameboundsintheworstcase. \nHowever,ourdesignis much simpler thantheirs. Continuinginthetraditionof [16,17,18],ourimplementation \nreinforcestheimportantroleof lazyevaluationinpurelyfunctional data structures. Our implementation also \nmakes extensive use of two additional language features: polymorphic recursion [14, 7] and views [22, \n2, 20]. Although neither is indispensable, both significantlysimplify thepresentation.Wehopethatthisexample \nwill motivatemore languagedesignersto include thesefeaturesin theirlanguages. Section2brieflyreviewsrelatedwork. \nSection3describesthe notation and properties we will assume for dequea and for lazy evaluation. Section \n4 presents our implementation of catenable dequesanditsanalysis. Section5 showshowtoimplementourdata \nstructurein a language without views or polymorphic recursion. Section 6 compares our data structureto \nthe catenable deques of Kaplan and Tarjan [12]. Finally, Section 7 concludes with a few open problems. \n  2 Related Work Hood and Melville [9] presentedthe first purely functional imple\u00admentationofqueuestosupportrdlnormaloperationsin0( \n1)time. In his thesis, Hood [8] extended this design to the double-ended case. ChuangandGoldberg [3] \nlaterre-inventedHood s datastruc\u00adture. Okasaki [16] simplified these implementationsof queues and dequesusinglazyevaluation.KaplanandTarjrm[11] \nintroducedan entirely different implementationof deques, based on a teehnique called recursive slowdown. \nNoneof theabovestructuressupportcatenationefficiently.My\u00aders [15] described an implementation of AVL \ntrees that supports all relevant deque operations, including catenation, in O(log n) time, Hughes [10] \nrepresentedlists as functions in such a way that catenationbecomes simple function composition, runningin \n0( 1) time. Unfortunately,his structurecan only be inspected in toto itno longersupportsindividualheadandtailoperationsefficiently. \nDriscoll, Sleator,andTarjan[6] presentedthefirstimplementation of catenable lists to support all operations \nin sublogarithmic time: catenationin O(log log k) time, wherek is thenumberof listopera\u00adtions(whichmaybemuchsmallerthann), \nandallotheroperations in 0(1) time. Their implementationis persistent,but not purely functional. BuchsbaumandTatjan[1] \ngaveapurelyfunctionalim\u00adplementationof catenabledequessupportingdeletionof thefirstor last element in \nO(log* k) time, and all other operations in 0(1) time. KaplanandTasjan[11] finallyachievedanimplementationof \ncatenableliststhatsupportsalloperations,including catenation,in 0(1) time. Their implementationis based \non recursive slowdown and achieves its bounds in the worst case. Okasaki [17] gave a much simpler implementation \nbased on lazy evahsationthat also supportsalloperationsin0( 1)time,butonlyintheamortizedsense. The catenabledequesin \nthispaperaredescendedfrom Kaplanand Tarjan simplementationof catenablelists,butuselazyevaluation instead \nof recursive slowdown. In independentwork, Kaplan and Tarjan [12] have also extended their implementationof \ncatenable liststo thedouble-ended case. Modulo thedifferencebetweenlazy evaluationand recursive slowdown, \ntheir approachis very similar toours.Forcomparisonpurposes,we presenttheirdatastructurein Section6. Tomakethecomparisonclearer,wehaveadaptedtheir \ndatastructuretouselazyevaluationinsteadof recursiveslowdown. This greatly simplifies their design, but \nalso degrades its bounds from worst-case to amortized. 3 Prelimhsaries  3.1 Non-Catenable Deques Ourimplementationof \ncatenahledequesusesnon-catenabledeques internrdly.We will henceforthrefertocatenabledcquesas c-deques \nandto non-catenabledeques asp-&#38;ques (primitive deques). Let[cr]denotethetypeof p-dcquescontainingelementsof \ntype a, Let[a]~+denotethesubtypeofp-dequesoflengthkorgreater. We assume thatwe are given an implementationof \np-dcques that supports each of the following operations in 0(1) time (see, for example, [8, 3, 16]): \n[14 : : [a] (YX[a]+ [a] (the empty deque) (left cons) D : ~c$ czz [a] (rightCOILS) lhd, rhd : (left and \nrighthead) ltl, rtl : [a],+ + [a] (left and righttail) 1 1 : [a]+ int (size) a and D are infix operators, \nand are right-associative and left\u00adassociative, res~tively. Even though we treat p-deques as an abstractdatatype, \nwe allow [],<, andD to be used in patternmatch\u00ading. These kinds of abstractpatternsarecalled views [22, \n2, 20]. A [] patternmatches the empty deque. The patternph a ptmeans given a non-empty deque d, match \npatternph against lhd d and patternpt against lt 1 d . The patternpt Dph is interpretedsim\u00adilarly. In \nboth expressions and patterns,we use the abbreviation [X*,.,., Zn] forzl d .S. azna[](orcquivalently, \n[] bzlb. .. bz=). P-dcqucs do not support catenation efficiently, but given the aboveprimitives,itis \nsimpleto implementacatenationoperation thatrunsintimeproportionaltotheshorterof thetwoarguments. M : \n[a] x [a]-) [a] Zsbd[] = X5 []DQ~s = ys (zaz.9)c4(gs Dy) = za(mIw~9)D~ Note thatthelastline is ambiguous, \ndependingon therelativeprece\u00addences of a and D, but both readings yield the same result since z4(d Df/)=(z4d)Dy. \n 3.2 Lazy Evaluation We assume that all computation is strict except where explicitly indicatedotherwise. \nTodelaytheevaluationofanexpressioneof typer, wewriteZ.ThisreturnsasuspensionoftypeT.Toforcethe execution \nof a suspension s of type F, we write !s, which returns a value of type r. Suspensions are memoized, \nmeaning that the firsttimeasuspensionis forced, thevalueis savedso thatthenext timethesuspensionis forced, \nthevaluecanbe looked upinsteadof recomputed. Inaddition,we provideaview for suspensionsthatallows forc\u00adingduringpatternmatching. \nWhen matchingasuspensionagainsta patternF, we firstforce thesuspension,andthenmatchtheresulting value \nagainstp. This style of notationfor lazy evaluationis explored more thor\u00adoughly in [19], along with many \nexamples of its use. 4 Catenable Deques In this section, we present our implementation of c-deques. C\u00addequessupportexactlythesameoperationsasp-deques, \nbutimprove therunningtime of M to 0( 1) amortizedtime. Except for size, the remaining operations continue \nto mn in 0(1) time, although for lt1andrt 1 thisbecomes anamortizedbound, whereasfor some implementations \nof p-deques it may be a worst-case bound. If desired, we could also makesize runin0( 1)timebyaddingasize \nfield to theroot of each c-deque. Except at the level of t~s, we use the same notation for both c-deques \nand p-deques. Whether a given occurrence of, say, < refersto c-deques or p-deques will always be uniquely \ndetermined by context. 4.1 Representation Let [cr]wdenote the type of c-deques containing elements of \ntype CY.A cdeque is either a simple p-deque, written (d), or a five\u00adtuple (~, a, m, b, r), where~,m, \nandr arep-dcquesandaandbare suspendedc-deques of compound elements. ~ and r mustcontainat leastthreeelementseach \nand m mustcontainatleasttwo elements. A comparnd elementis eithera simple p-deque, written(d), or a three-tuple(~, \nc, r), where d, f, and r are p-deques containing at leasttwo elementseach, andc is a suspendedc-deque \nof compound elements.Thesetypesaresummarizedbythefollowing equations: [+ =[a]I ( [c++x [CE O]Mx [a]z+ \nx [CE CY]~X [~]s+) CEa = [c42+ I ([cr]z+x [CE~]~ x [~]z+) Whether (d) is a c-deque or a compound element \nwill always be uniquely determinedby context. Notethat[@]Mk definedintermsof [CEa]w. Supportingthis kind \nof non-uniform type in a useful way requirespofymorplric m\u00adrecursion[14, 7]. (See Section 5 for how to \ncope withoutpolymorphic recursion.) Theorderofelementsisfromlefttorightateverylevel. Hence, the firstand \nlast elementsof (~, a, m, b, r) are the firstelementof ~ andthelastelementof r, respectively. 4.2 Operations \nNext,wedefinetheoperationsonc-deques. Theemptyc-dequeis definedintermsof theemptyp-deque.   [1= ([1) \n Adding an element on the left or right simply adds the element to the p-deque on thatside. z cs(d) = \n(xad) za(~, a,m, b,r) = (za~, a,m, b,r) (d)Dx = (d~z) (f, a,m, b,r)Dz = (f, a)m, b,rbz)  Similarly, \nasking for the leftmost or rightmostelementreturnsthe appropriateelementof thep-deque on thatside. lhd \n(z4d) = x lhd(x~f, a,m, b,r) = x rhd (d Dz) x . rhd(fla, m, b,rbx) = x The auxiliary functions It1 and \nrt 1 remove the elements re\u00adturnedby lhd and rhd. ltl (z ad) = (d) ltl (z4f,a, m, b,r) = (f, a,m, b,r) \nrtl (dDz) = (d) rtl (~, a, m,b, r Dz) = (f, a, m, b,r) These auxiliary functions sometimes violate the \nsize requirements of the data structureby leaving the ~ or r fields with only two elementsinsteadof three.Wewillusethesefunctionsonlywhen \nwe intendto immediatelyreplacethemissingelement. We next turnto catenation. First, we consider catenatingtwo \nsimplepdequea. Ifoneorbothpdeques containsfewerthanfour elements,wecombine themusingp-dequecatenation. \n@I) N (dz) = (dl Wdz) .if Idll <4 v Idzl <4 Otherwise,weplacetwthpdeques inafive-tuplewithemptyaand \nb fields. We remove one element from each pdeque to form the middle field. When catenatinga pdeque with \na fivetuple, we simply invoke p\u00addequecatenationifthep-deque isshortenough,andotherwisemove the existing \nfor r field into a or b and install d as thenew ~ or r field. {d) N (f, a, m, b, r) = (dt4f, a,m, b,r) \n,ifld{<4 = (d, (f) cs!u, m, b, r) , otherwise (f,a,rra, b,r) M (d) = (f, a,m,b, rMd) ,ifldl<4 = (f,a, \nm, !b D (r), d) , otherwise The most intenxting case is catenatingtwo fivetuples. The L@ bav ofafive-toplecomprisesthe \n~andafields,andhalfofthem field. The right has of a five-tuple comprises the r and b fields, and the \notherhalf of them field. To catenatetwo five-tuples,we firstfold the right haff of the left tuple into \nthe left half, and the left half of the right tuple into the right half. Then, we glue the two halves \ntogeti-er, The definitions of lt 1 and rt 1 use several auxiliary views, Thefirstpairofviews,s andR,arejustlikeQand \nD except that they &#38;lay their tails. For example, matching PII g pt against a non-empty c-cleque \nX8 first matchesph against lhd $s and then matchespt againat ltl zs. The second pair of views, < and \n>, arejust like 4 andPexceptthattheycall1t1 andrt 1 insteadof ltlandrtl. Finally, we are ready to define \nltl and rtl. We begin with lt 1.Thesimplestcasesarewhen1t1zscand:scardtheleftmost elementofxs withoutviolatingthesizerestrictions.Thishappens \nwhen zs is a simple pdeque or when xs is a fivetuple whose f fieldcontainsmore thanthreeelements. ltl \n(zqd) = (4 ltl (za~, a,m, b,r) = (f,a, m,b, r) ,ifl~l 23 In the remaining cases, xs is a five-tuple whose \n~ field contains exactly three elements so removing the leftmost element leaves only two elements. To \nrefill the f field, we first try to remove a compoundelementfromthea field. Ifitisasimplep-deque d, we \nadd it to the ~ field. ltl ([x, y,z], (d) ga, m, b,r) = (y~z~d, a,m, b,r) Notetheuseof polymorphicrecursionhere \n bymatchingagainst thegview,1t1onac-dequeof elementsimplicitlyinvokes1t1on a c-deque of compound elements. \nHowever, note thatthe recursive callto1t1issuspendedbythegview. Thisuseoflazyevalua\u00adtion is criticat \nif the data structureis to be efficient in a persistent setting[18]. We continue with the remaining clauses \nof lt 1. If the first compound elementfrom thea field is a three-tuple(~ , c , r ), then we add ~ to \nthe ~ field and replace the three-tuplein a with (r ). Finally,wecatenatec andatoobtainthenewa field. \nltl ([z, y,z], (fl, d,r ) + a,m, b,r) = (y<z<f , !c?M ((r ) cla), rn, b,r) If the a field is empty, then \nwe attemptto remove a compound elementfrom theb field. ltl ([z,y,z],n,m,@) gb, r) = (y~<=am, [], d,b, \nr) ltl ([~, v,z], [], m,(f , c , r ) sb, r) = (ya.z~m, (fl)a!d, r , b,r) If thea and b fields are both \nempty, then we add the remaining elementsofthef fieldtomandcatenatetheresultwithr. ltl ([z, g,z], ~,m, \n~,r) = (y a.z4m) W (r) This completes the definition of ltl. rtl is defined symmetri\u00adcally. The complete \nimplementationof c-deques is summarizedin Figure 1. 4.3 Analysis Wefirstargueinformallythateveryoperationrunsin0( \n1)amor\u00adtized time. Then we prove this formally using a debit argumentin the style of [17, 18, 19]. First,note \nthatonly 1t 1and rt 1 call themselves recursively. The remaining operations clearly run in 0(1) time \nsince none of them loop. Now consider ltl (the argumentfor rt 1 is similar). Thefirsttwocasesterminateimmediately.Severafof \ntheremahing casesrecursivelycall 1t 1 ona or b. Butnotethatattheendof each of these cases, f contains \nat least four elements: y, z, and two or moreelementsfromthep-dequeusedtorefillf. Therefore,thenext call \nto 1t 1 will terminateimmediately in the second clause. This meansthatatmosteveryothercaIlto 1t 1 cancall \nitselfrecursively. Extendingthis argumenta few steps further,we note thatat most everyfourthCSI1canmaketworecursivecalls, \natmosteveryeighth callcanmakethreerecursivecalls,andsoon. Altogetherthen,the amortizedcostof anyonecallatthetoplevelis \n0(1++ +++++ ) =0(1). As anaside,thisargumentexplainsthesizerestrictionsweplace on the various pcfeques \nin five-ttrplesand compound elements. Whenwerefillan ~orr fieldthathasdroppedbelow theminimum size, we \nwish to raise it not just to the minimum size, but above it so that the next operation that removes an \nelement from that field wilf terminateimmediately. Therefore, m and the various p\u00addequesincompoundelementsthatareusedtorefill~ \nand r must [c+ = [~] I ( [~],+ x [CE ~]w x [4+ x [CEC+ x [c++) (2ECI = [a],+ I ( [a],+x [CE a]~ X [a],+) \n[1 = ([1) X 4 (d) = (x~d) z 4 (j, a,m, b,r) = (x~f, a,na, b,r) (d) ~z = (dbx) (f, a,m, b,r) Dz = (f, \na,m, b,rbz) = lhd (za d) x lhd(z~f, a,m, b,r) = x rhd (dbz) x = rhd(f, a,rn, b,rbx) = z ltl (z<d) = \n(d) ltl (z<f, a,m, b,r) = (f, a,m, b,r) rtl (dbz) = (d) rtl (f, a,m, b,r DZ) = (f, a, m, b, r)  (d,) \nN (d,) = (d, ~dz) ,ifldll<4Vld21<4 (d, bZ) W(y =ad,) = (all, [], [z, y],~, d~) ,ifldll z3Aldzl z 3 (d) \nM(f, a, m, b, r) = (dklf,a,m,b,r) ,ifldl<4 = (d,(f) a !a, m, b,r) , otherwise (f, a, m, b,r) M (d) = \n(f, a,mlb, rCQd) ,ifldl<4 = (j,a, m, !b D (r),d) , otherwise (f~,al,ml,bl,rl >x) N {Yufz, az, mz, bz, \nrz) = (fl, !al D (ml,bl,rl), [% Y], (fz,az,mz) 4 !h,rz) ltl (x~d) (d) ltl (xdj, a,m, b,r) (f, a,m, b,r) \n, if Ifl ~ 3 ltl ([z, y,z], (d) qa, m, b,r) (yazad, a,m, b,r) ltl ([z,v,z],(f , d,r ) + a,m, b,r) (yuzaf \n, !d M ((r ) ~a), m,b, r) ltl ([z, y,z], fl, rn, (d)s b,r) (y~z~m, ~,d, b,r) ltl ([z, y,z], ~,m, (f, \nc , r ) gb, r) (yazam, (fl)a!c?, r , b,r) ltl ([z, ~,z], ~,m, ~,r) (yazam)W(r) rt 1 (db X) (d) rtl (f, \na, m, b,r b z) (f, a,m, b,r) , if Irl >3 rtl (f,a, m, b E (d), [z, v, z]) (f, a,m, b,dbx by) rtl (f, \na,m, b > (fi,d,r~, [z, y,z]) (f, a,m~bb (fi)) N !d,r Dz Dy) rtl (f, a ? (d), m,~, [~, v,zl) (f, a,d, \n[], mExby) rtl (f, a E (f , c , r~, m, ~, [xl 1/1z]) (f, a, f , !c?b(r ), mDXby) rtl (f, [l,~! [1,[~, \nu,zl) Figure 1: Catenabledeques. containatleasttwoelementseach.Thef andrfieldsinfive-tuples mustcontain \natleastthreeelements,becauseduringcatenationone element is transferredto the m field and the remainderof \nthe p\u00addeqttegoes inacompound element(andthusmustcontainatleast two elements). Although the above informal \nargumentprovides a useful intu\u00adition, it fails to addresstwo importantconcerns. First,whathappens ifthereareotheroperations,suchasrt \n1,interleavedwiththecalls to 1t 1? Since 1t1 and rt 1 can both recurseon eitherthe a or b field of a \nc-deque, we cannot blithely assume thatthey will not interfere with each other. Second, what happens \nif c-deques are usedpersistently?Forexample,if 1t 1 xs recurses to depthk, how canwebesurethatrepeatingthiscalln \ntimeswillnottakeO(nk) time? We could satisfy the first concern using any of several formal techniques, \nsuch as the standardtechniques of amottized analysis using credits or potential functions [21] or the \nnon-standarddebit techniques of OkasaJci[17, 18, 19] for analyzing amortized data structuresinvolving \nlazy evaluation. The basic approach under any of these methods is to establish an invariantand show that \nanyindividualcall to 1tl or rt 1 preservestheinvariant,so any sequenceof interleavedcalls also preservestheinvariant.However, \nof thesevariousproof techniques,only debit argumentsaddressthe questionof persistence.The key ingredientin \nthistechniqueis the use of lazy evaluationto delay expensivecomputations. This allows the results of \nthese computations to be shared via memorization among multiple threads of a non-single threadedcomputation.1 \nSee[17, 18,19]forafullerdiscussionoftheroleoflazyevahsation in persistent,amortizeddatastructures. Inadebitargument,everysuspensionis \nassignedacertainnum\u00adberof debits,whichaccountforthecostofeventuallyexecutingthe suspension. Everydebitmustbedischargedbeforeitscorrespond\u00adingsuspensionmaylx \nforced. Therearethreekindsof suspensions inourdatastructure:theaandbfieldsof five-tuples,andthecfield \nof three-tuples. We limit the number of debits on each c field to four, and limit the number of debits \non each a orb field according to the sizes of ~ and r. . If 1~1>3 and jr! >3, then a and b are allowed \nfive debits each. . If1~1>3 andIrl = 3,thenaisallowedfourdebitsand b is allowed one debit. . If 1~1= \n3 and Ir{ >3, then a is allowed one debit and b is allowed four debits. . If 1~1= 3 and Irl = 3, thena \nand b are allowed zero debits each.  The amortizedcost of each operationis 0(1 + #debits discharged). \nWeshowthatNdischargesatmostfourdebitsandthat1t1 and rt 1dischargeatmostfivedebitseach. Proofi (N) The \ninterestingcase is catenatingtwo five-tuplesZSI = (~l,al,~l,bl~rl) SIIdXL3Z= (/z1az!Tnz,b2trz) We CrM@ \nand immediately discharge two debhs to pay for the suspendedd and D onto al and bZ In addition, we discharge \nat most one debh from either al or az, and at most one debit from either bl or tn. Suppose Irzl >3. Then \naz might have five debits, one of which must be discharged as az becomes the c field of a new three-tuple. \nOtherwise,iflr21= 3andIrl{>3, thentheallowanceofal might decreasebyone,requiringthedischargeof asingledebit.Asimilar \nargumentholds for bl and b2. Altogether, we discharge no more thanfour debits. (ltl andrtl) Sinceltl \nandrtl aresymmetric,wepresent theargumentonlyfor 1t1. Consideracallto1t1thatrecursesto ] llds tmninology \ncan ix somewhat cmr%sing.Hue the termrhmd refers.ot to concunent threadsof exccutioo,M ratherthegraph \ntomultipkpathstfunughof dataikpendencies.Reusing a givendcqucinducesa branchin thegraphof data dependence-createsthread. \nandhence anewdepthk andnotethateverycall excepttheoutermostisenclosed in a suspension. Five debits must \nbe discharged before each of these calls, butonly thedebitsfor theoutermostcall mustbe discharged immediately. \nFor each of the recursive calls, those five debits are charged to the enclosing suspension. These debits \nwill then be dischargedsometimebeforetheenclosing suspensionis forced and the recursivecrdl in question \nis executed. We call this transferof debitsfromonesetof suspensionstoanotherdebit passing. Now, there \nis one case for every clause of 1 t 1. We describe only the casesforclauses2,3,and4. Theothercasesaresimilar. \n . ltl(z~f, a,m, b,r)=(f, a,rn, b,r) ,ifl~[ >3 This is a terminatingcall. If the length of the ~ field \ndrops fromfourtothree,thenthedebitallowanceof a dropsby four andthedebit allowance of b dropsby one. \nWe passthesefive debits to the enclosing suspension, or discharge them if this is the outermostcall. \n . ltl ([z, Y,z], (d) ga, rn, b,r) = (y~zad, a,m, b,r) This is not a terminatingcall. Since we force \nthe a field, we mustpassor dischargeanydebhs currentlyon thatfield. If Irl>3 thenthereiscurrentlyatmostonede.bitontheafield. \nWe passthisdebittotheenclosing suspensionordischargeit ifthisistheoutermostcall. Inaddition,thenewsuspension \nfora (theonecreatebytheg view)receivesatmostfivedebits from its recursivecall to lt 1. However, the new \nallowance for a is five, so we do not pass on any of these debits. If ]rl = 3 then there are currently \nzero debits on the a field. The new suspension for a receives at most five debits from the rexxrrsivecall, \nbut the new allowance for a is four, so we passononeof thewdebits.Eitherway,wepassasingledebit (or dischargeitif \nthisistheoutermostcall).  . ltl ([z, y,z], (fi, c , r ) < a,m, b,r) = (y<zaf ,!c$ M ((r ) ~a), m,b, \nr)  Thisisaterminatingcall. Sinceweforcetheafield,wemust passonanydebitsthatarecurrentlyonthatfield. \nThereis one such debit if Irl > 3 and none if Irl = 3. The new a fieldreceivesatmostfourdebitsfromc , \natmostfourdebits fromthecall tobd,andonenewlycreateddebitthataccounts for the call to =2.The new allowance \nis five if Irl >3 so we pass on the excess four credits, making five altogether. The new allowance is \nfour if Irl = 3 so we paas on the excess fivedebits.Ineithercase,wepassordischargeatotalof five debits. \n. 5 Restricting the Language of Implementation ThecodepresentedinSection4takesadvantageof bothviewsand \npolymorphic recursion. However, few current languages support thesefeatures,so we brieflysketchhowtheimplementationchanges \nwithoutthem. 5.1 Without Views Views [22, 2, 20] area languagemechanismallowing patternmatch\u00adingonabstractdatatypes.As \nwithpatternmatchingingeneral,views areasyntacticconveniencethatcanbe replacedby explicit calls to case \npredicates(such as nul 1) and access functions (such as lhd and ltl). We use views in two ways. First, \nwe use patternssuch as xa d andd Dx on p-deques to both recognize and decompose non\u00ademptyp-deques.Theuseof \nthesepatternsrevealsnothingaboutthe representationof p-deques, which is held abstract. Second, we use \npatternssuch as z g a and z < a on c-deqttes to dexompose these deqttesin non-standardways. Note thatwe \nalso use ordinarypattern ltl (z4f;a,m,b,r) = (~, a,m,b,r) ,if[fl 23 ltl ([x, ~,%], (d) q%m,~,r) = (yaz~d, \na,m, b,r) ltl ([z, y,z], (fl, d,r ) + a,m,b,r) = (yaz4~ ,~D4 ((r ) aa),7n, b,r) ltl ([z, y,z], n,rn, \n(4 ~kr) = (yazarn, [], d,b, r) ltl ([z, v,z], fi, m,~fl, d,r )qb, r) = (y~z~m, (f )a!d, r , b,r) ltl \n([z, y,z], ~,rn, []tr) = (yaz47n)bd(r) ltl (d) = (ltld) ltl (~, a, m, b,r) = if lfl >3 then (ltl f,a, \nrn, b, r) else let z = rhd f Y= rhd (rtl f) a = !a in if not (null a ) then case lhd a of (d) + (y~z4d,ltl \na , m,b, r) I (f , c , r ) + (yaz<d, !&#38; M ((r ) a(ltl a )), m,b, r) else let b = !b in if not (null \nb ) then case lhd d of (d) + (~azam,fl, d,ltlli,r) _ I (f , c , r ) + (ga.zum, (fl)~!d, r ,ltl~, r) \nelse (y4z am) N (r) Figure2 Thelt 1fimction,writtenwithandwithoutviews. [+ CE @ = = [a] I ( [a],+ x [CE \ncY]~ X [a],+ X [CE a]~ X [Q],+) [CX]z+I ( [c42+ X [CE ct]Mx [cY]Z+) [+ CE a = = [CEa]I ( [CE (Y],+ X \n[a]M x [CE et],+ x ~ x o I [CE ct]2+ I ( [CE cr]z+ x [~]M x [~ ~]z+ ) [CE a],+) Figure 3: The type of \nc-deques, with and withoutpolymorphic recursion. matchingon c-deques to distinguishbetween,for instance,(d) \nand (~, a, m, b, r). Views are notnecessaryforthislastclassof patterns because they match the concrete \nrepresentationof c-deques, which is visible within the implementation. To remove the dependency on views, \nwe replace each view patternwithappropriatecallstonull, lhd (rhd), andltl (rtl). Forexample,Figure2contrastsversionsof \nthe1t 1functionwritten with and without views. The version with views is clearly more concise, but more \nimportantly, it is also easier to understand,at least for a readercomfortable with views. Even for a \nreadernot comfortable withviews, theversionwithviewsis probablyeasierto readforthegistof theimplementation,althoughforsuchareader \nthesecond versionmaybe preferablefor understandingthedetails. 5.2 Without Polymorphic Recursion Polymorphic \nrecursion [14, 7] allows one to write recursiveftmc\u00adtions on non-un~onn recursive datatypes. Whhout polymorphic \nrecursion,recursivefunctionscanbewrittenonly for uniform re\u00adcursive types. The type of c-deques, as presentedin \nSection 4, is non-uniform because [~]w is defined in terms of [CE CI]Mrather than[a]~. Ifpolymorphicrecursionisnotavailable,thenwemust \nmodify this type definition to be uniform. Considertheelementsin thevariousp-dequesin therepresenta\u00adtionof \nacdeque. Theseelementshavetypeo atthefirst(top)level, typeCEa atthesecondlevel,typeCE(CECY)atthethirdlevel, \nand so on. To make [a]M uniform, we must collapse all of these typesintoasingletype. First,weallowasimpleelementtobeused \nanywhereacompoundelementcanbeusedby extendingthedefin\u00aditionofCEa withathirdsummandoftypea (i.e.,CEa = \nrYl...). Next,we allow acompound elementto be usedanywhereasimple eIementcan be used by replacing each \np-deque of type [a] with a p-deque of type [CE a]. With thesechanges, we can finally replace each [CE \ncr]~ with [a]M. Figure 3 shows the final type definitions. Therestof theimplementationismostlyunaffectedbythese \nchanges. We need only provide wrapperfunctions for ~ (D) and lhd (rhd) toinjectandprojectelementsof typea \ntoandfromtype CEa. Thesewrapperfunctionsareexportedtotheuser,whileCU, 1tl, andrt 1continuetocalltheoriginalversions. \nAM-soughthese changes are all relatively minor, we feel that theoriginalimplementationusingpolymorphic \nrecursionis farsu\u00adperior. Not only dees the non-uniform type provide much better documentationof theinvmiantsof \nthedatastructure(i.e., thatthe first level p-deques contain elements of type a, the second level p-dequescontainelementsoftypeCEa, \nandsoon),italsoallows the type system to catch many more accidental violations of these invariants. \n 6 An Alternative Implementation of Catenable De\u00adques The catenable deques of Kaplan and Tarjan [12] \nshare a superfi\u00adcially similar structurewith ours, but the two implementationsare difficulttocomparebecauseof \ndifferencesintheirtmderlyingmech\u00adanisms. To facilitatecomparison we adapttheirimplementationto ourframework.Thisgreatlysimplifiesmanydetailsof \ntheirstnrc\u00adture,butalso&#38;grades itsbautds fromworst-casetoamortized.For theoppositeview,see[12],whereKaplanandT@an \nhaveadapted ourimplementationto theirframework. In KaplanandThrjan sdesign, a lejipair is a pair (f, \na), where ~ is a p-deque containing at least two elements and a is a c-deque of right pairs. A riglu \npair is a pair (Zs,r), where r is a p-deque containing at least two elements and b is a c-deque of left \npairs. A c-deque is either a simple p-deque, written (d), or a four-tuple (f, a, b, r) containing both \na left pair and a right pair. The type definitionsandoperationsfor thisdatastructurearesummarizedin Figure4. \nKaplan and Tarjan s design replaces our five-tuples with four\u00adtuples, and our three-tupleswith left pairs \nand right pairs. 1ssaddi\u00adtion,theyreducetheminimumsizeofthe~andr fieldsinac-deque fromthreetotwo. Ontheotherhand,ourstructureismoreregular, \nhavingno needtodistinguishbetweenleftpairsandrightpairs. The operationson both structuresaremostly similar. \nThe largest difference occurs in the 1t 1 and rt 1 functions. The question is: when the ~ field becomes \ntoo small, how do we refill it from the a field? In Kaplan and Tarjan s design, this is accomplished \nby the following two rules: ltl ([z, Y],(~,r ) ga, b,r) = (u~ r ,a,hr) ltl ([x, y], (( f , a ) q &#38;,r \n) + a, b,r) = (ua / , !a M ((ii, r ) aa), b,r) The secondrule,in particular,is ratherinvolved, containingatotalof \nfour views thatforce two suspensionsand remove thefirstelements of twoc-deqtres,Incontrast,thesearetheequivalentrulesforour \nimplementation ltl ([z, y,z], (d)ga, m, b,r) = (vaz~d,a,m,hr) ltl ([z, y)z], (~, c , r ) + a,rn, b,r) \n= (y~zqf , !&#38; w ((r ) aa), m,b, r) Here the second rule contains only two views, one to force the \nsuspmsionandonetoremovethefirstelementof theimer c-deque. All in all, as long as our design and Kaplan \nand Tarjan s design areboth implementedusing lazy evaluationor both using recursive slowdown,thereislittlereasontopreferone \novertheotheronthe grounds of simplicity or aesthetics. Which is to be preferred in practice can only \nbe decided by a suitable empirical study. Un\u00adfortunately,we do not yet have enough experience with catenable \ndeques-especially persistentones to determine art appropriate instructionmix for such a study.  7 Open \nProblems Thecatenabledequesof KaplanandTarjan[12]areasymptotically optimal.However,theyarerathercomplex, \nsoonemighthopethat a simpler structurewith equivalent asymptotic bounds would run fasterinpractice. The \ncatenabledequesdescribedin thispaperare simpler,butachieveonly amortizedratherthanworst-casebounds. Itisstillanopenproblemwhetherthecatenablelistsof \nOkasaki[17] can be extended to the double-ended case. Such a data structure would likelybe simpleryet,butwould \nalso achieveamortizedrather thanworst-casebounds. Isa simplerworst-caseapproachpossible? A second areaof \nfurtherresearchinvolves extendingcatenable dequeswithadditionaloperations. Forexample, itis relativelyeasy \ntoextendbothourdatastructureandKaplanandTarjan sto support both reverse and jindMin in O(1) time [12]. \nCan either design be extended with efficient primitives for random access, such m looking uporupdatingtheith \nelement,or insertingor deletingthe ithelement?Kaplanandllujan [13]havedescribedarelateddata structuresupportingtheseoperations,butcatenationin \nthatdesign requires O(log log(min{nl, nz})) time. Is it possible to achieve constant-timecatenationfor \nsuch a datastructure?  References [1] Adam L. Buchsbaum and Robert E. Tarjan. Confluently per\u00adsistentdeques \nvia data structuralbootstrapping. Journuf of Algorithms, 18(3):513-547, May 1995. [c+ = [a] I ( [CY]2+x \n[Right CY]Mx [JW CUIMx [cY]2+) L# a = [CC],+x [Right ~]M Right a = [L@ a]w x [a]*+ [1 = ([1) X 4 (d) \n= (zad) z 4 (f, a,b, r) = (z~f, a,b, r) (d) DX = (dDx) (f, a, b,r) Dz = (f, a, b,r~z) lhd(z~d) = z lhd(zdj, \na,b, r) = z rhd(dbz) = z rhd(f, a, b,r Dz) = z ltl (zQd) = (4 ltl (zaf, a,b, r) = (f, a, b,r) rtl (dbz) \n= (d) rtl (f, a,b,rbz) = (f, a,b, r) (d,) N (d,) = (d, W d,) ,ifldll<2Vldzl<2 = (d,, fl,~, dz) , otherwise \n(d) w (f, a, b, r) = (d blf,a,b,r) ,ifldl<3 = (d, (~, f) Q !a, b, r) , otherwise (f,a,b, r) D4(d) = (f,a, \nb,r C4d) ,ifldl<3 = (f,a, !b b (r,~),d) , otherwise (fl,al,bl,rd ~ (~z,az,h,rz} = (fl, !al D (bl, rl), \n(fz,az)~ !k,rz) ltl (z4d) = (d) ltl (zaf, a, b,r) = (f, a,b, r) ,iflflz2 ltl ([z, y], (~, r ) q a,b, \nr) = (~qr , a,b, r)  ltl ([z, y], ((f , a ) qlt,r ) < a,b, r) = (IJ4f , !a M ((N, r )ea), b,r) ltl ([z, \nv], H, (f , a )s hr} = (~af , a , b,r) ltl ([z,d,lj,fi,d = (yar) rtl (dDz) = (d) rtl (f, a,b;rbz) = \n(~,a, b,r) , ifIrla 2 rtl (f,a,b E (f , ~), [z, v]) = (f, a, b, f D z) rtl (f, a,b % (f , a E (b, r \nfl, [z, y]) = (f, a,(b D (f , a )) ~ !N, r PZ) rtl (f, a E (IY,r ), [], [z, y]) = (f, a, b ,r Dz) rtl \n(f>~>~, [% Y]) = (f DZ) Figure4 CatenabledequesbasedonadesignbyKaplanand hjao [12],adaptedtouselazyevaluation. \n[2] F. WarrenBurton and Robert D. Cameron. Patternmatching with abstractdatatypes. Journal of Functional \nProgramming, 3(2):171-190, April 1993. [3] ~ng-Ruey Chuang and Benjamin Goldberg. Real-time de\u00adques,multiheadThing \nmachines,andpurelyfunctionalpro\u00adgramming. In Conference on Functional Programming Lan\u00adguages and Computer \nArchitectsuv, pages 289-298, June 1993. [4] Paul F. Dietz. Fully persistentarrays. In Workshop on Al\u00adgorithms \nand Data Structures, volume 382 of LNCS, pages 67-74. Springer-Verlag,August 1989. [5] James R. Driscoll, \nNeil Samak, Daniel D, K. Sleator, and RobertE. Tarjan. Making datastmcturespersistent.Journal of Computer \nand System Sciences, 38(1):86-124, February 1989. [6] JamesR. Driscoll, DanielD. K. Sleator,andRobertE.Ta@n. \nFully persistentlists with catenation. Journal of the ACM, 41(5)943-959, September 1994. [7] Fritz Henglein. \nType inference with polymorphic recursion. ACM Transactions on Programming Lunguages and Systems, 15(2):253-289, \nApril 1993. {8] RobertHood. TheE@ientItnplementationof Very-High-Level Ptvgr~ ng Language Constructs. \nPhD thesis, Department of Computer Science, Cornell University,August 1982, (Cor\u00adnell TR 82-503). [9] \nRobertHood andRobertMelville. Real-timequeueoperations in pure Lisp. Informatt on Processing Letters, \n13(2):5&#38;53, November 1981. [10] JohnHughes.A novel representationof listsanditsapplication to the \nfunction reverse . Information Processing Letters, 22(3):141 144, March 1986. [11] HaimKaplanandRobertE.Tarjan.Persistentlistswithcatena\u00adtion \nvia recursiveslow-down. In ACM Symposiwn on Theory of Computing, pages 93-102, May 1995. [12] Haim Kaplan \nand Robefi E. Tarjan. Purely functional lists with catenation via recursive slow-down. Drait revision \nof [11], August 1996. [13] Haim KapIan and Robert E. Tarjan. Purely functional repre\u00adsentationsof catemble \nsorted lists. In ACM Symposium on Theory of Computing, pages 202-211, May 1996. [14] Alan Mycroft. Polymorphic \ntype schemes and recursivedefi\u00adnitions. InInternational Symposium on Pmgranuning, volume 167 of LNCS,pages \n217-228. Springer-Verlag,April 1984. [15] Eugene W. Myers. Efficient applicative data types. In ACM Symposium \non Principles of Programming Languages, pages 66-75, January1984. [16] ChrisOkasaki.Simpleandefficientpurelyfunctionalqueues \nand deques. Journal of Functional Ptvgramming, 5(4):583\u00ad592, October 1995. [17] ChrisOkasaki.Amortization,lazy \nevaluation,andpersistence: Lkts with catenationvia lazy linking. In IEEE Symposium on Foun&#38;tions \nof Computer Science, pages 646-654, October 1995. [18] ChrisOkasaki. The role of lazy evaluationin amortizeddata \nstructures. In ACM SIGPLAN International Conference on Functional Ptvg ramming, pages 62 72, May 1996. \n[19] Chris Okasaki. Purely Functional Data Structures. PhD the\u00adsk, School of ComputerScience, CarnegieMellon \nUniversity, September1996. [20] Pedro Palao Gostanza, Ricardo Pefsa,and Manuel Ndiiez. A new look at \npatternmatching in abstractdata types. In ACM SIGPLAN tnternatioml Conference on Functional Pmgrans\u00adming, \npages 110-121, May 1996. [21] RobertE.Tarjan.Amortizedcomputationalcomplexity. SIAM Journal on Algebraic \nand Discrete Metha&#38;, 6(2):30&#38;318, April 1985. [22] Philip Wadler. Views: A way for patternmatching \nto cohabh with data abstraction, In ACM Symposium on Prs nciples of Programming Languages, pages 307-313, \nJanuary1987.  \n\t\t\t", "proc_id": "258948", "abstract": "Catenable double-ended queues are double-ended queues (deques) that support catenation (i.e., append) efficiently without sacrificing the efficiency of other operations. We present a purely functional implementation of catenable deques for which every operation, including catenation, takes <i>O</i>(1) amortized time. Kaplan and Tarjan have independently developed a much more complicated implemen-tation of catenable deques that achieves similar worst-case bounds. The two designs are superficially similar, but differ in the underlying mechanism used to achieve efficiency in a persistent setting (i.e., when used in a non-single-threaded fashion). Their implementation uses a technique called recursive slowdown, while ours relies on the simpler mechanism of lazy evaluation.Besides lazy evaluation, our implementation also exemplifies the use of two additional language features: polymorphic recursion and views. Neither is indispensable, but both significantly simplify the presentation.", "authors": [{"name": "Chris Okasaki", "author_profile_id": "81100613198", "affiliation": "School of Computer Science, Carnegie Mellon University, Pittsburgh, PA", "person_id": "P46261", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/258948.258956", "year": "1997", "article_id": "258956", "conference": "ICFP", "title": "Catenable double-ended queues", "url": "http://dl.acm.org/citation.cfm?id=258956"}