{"article_publication_date": "08-01-1997", "fulltext": "\n A Modular, Polyvariant, and Type-Based Closure Analysis Anindya Banerjee Xinotech Research* ab@xinotech.com \nAbstract We observe that the principal typing property of a type system is the enabling technology for \nmodularity and separate compilation [10]. We use this technology to formulate a modular and polyvariant \nclosure analysis, baaed on the rank 2 intersection types annotated with control-flow information. Modularity \nmanifests itself in a syntax-directed, annotated-type inference algorithm that can analyse progmm fragments \ncontaining free variables: a princi\u00adpal typing property is used to formalise it. Polyvariance manifests \nitself in the separation of different behaviors of the same function at its different uses: this is for\u00admalised \nvia the rank 2 intersection types. As the rank 2 intersection type discipline types at least all (core) \nML programs, our analysis can be used in the separate compilation of such programs. Introduction Compiler \noptimisations are crucially dependent on the availability of control-flow information at compile time. \nFor any fist-order imperative program, this information is available via a flowchart constructed from \nthe pro\u00adgram text. Consequently, traditional dattiow analyses can be used to perform a series of compile-time \nprogram optimisations [1]. For higher-order programs, however, a control-flow graph is often unavailable. \nThe reason is that functions in a higher-order program are treated as data they can be passed between \ntwo program points via function calls and can arise as the result of evalua\u00adtion at any program point. \nThus one needs to calculate flow information it cannot be deciphered from an in\u00adspection of the structure \nof the program text. Hence, a number of control-flow analyses have been proposed [8, 11, 20] for higher-order \nprograms. Since functions are traditionally implemented as closures, such analy\u00adses me also called ckmre \nanalyses [19].1 All of them answer the following interrelated questions: what are Minneapolis, MN 55414, \nUSA. Phone: (+1) (612) 379-3S44, Fax: (+1)( 612)379-3S33. This work was supported by a postdoc\u00adtoral \nfellowship at the Laboratoire d lnformatique, Ecole Poly\u00adtechnique, PaIaiseau, France, (thanks to Radhia \nCousot) and subsequently at the Computer Science Department, Aarhus Uni\u00ad the possible functions called \nat a program point? and: what are the possible functions that can be the result of evaluation at a program \npoint? 1.1 Techdques for closure analysis The classical technique for closure analysis is abstmct interpretation \n[4] of either the denotational semantics of the language [20] or of its operational semantics [14]. An \nequivalent technique uses a system of constraints to specify these analyses so that flow information \nis ob\u00adtained as the minimal solution of the constraint system [16]. Both techniques are global in that \nthey require the availability of the entire progmm before analysis. Fur\u00adther, they assume the program \nto be closed, or, if open, to have simple (e.g., integer or boolean), non-function inputs. Recently, \nthere has been a surge of interest in using annotated type systems for program analysis. The intu\u00adition \nis that we can annotate types and expressions in a language with the properties of interest, e.g., flows \n[23], binding times, strictnws and totality [21], effects [22], regions [24], concurrent behaviors [15] \netc., so that if an expression, e, has the annotated-type, r, then evalu\u00adation of the expression exhibits \nthe properties described by the annotation of ~. Static analysis of the expres\u00adsion, e, is then synonymous \nwith the calculation, via an annotated;type inference algorithm, of its property annot ations. For closure \nanalysis, we annotate every function in artexpression with a distinct label, and associate a set of function \nlabels with every function type. The intuition is that if an expression, e, has the function type, T, \nwith flow annotation, #, then its evaluation will yield a clo\u00adsure, whose text is a function having a \nlabel predicted by d. The static determination of the set of function la\u00adbels that e can possibly evaluate \nto, is thus synonymous with the calculation, via an annotated-type inference al\u00adgorithm, of its flow \nannotations. While the type-based approach maynot be as pre\u00adcise as the abstract interpretation-based \napproach, it nonetheless outlines a method for performing local and more importantly, modular program \nanalysis. Local means that the analysis of an expression is derived through the composition of the analyses \nof its proper versity, Denmark, under the DART project of the Danish Na\u00ad 2There is of course the issue \nof decidability of type inference tional Research Councils (thanks to Flemming Nielson). in tbe underlying \ntype system: for instance, it is well known that type inference is undecidable in System F or the intersection \ntype discipline. sub-parts. We say that an analysis is modular if it can analyse pmgmm fragments containing \nfree variables, i.e., modules, in isolation, and if the linking of fragments does not require their re-analysis. \nA modular program analysis is thus indispensable in the context of separate compilation. 1.2 Related \nwork on type systems and closure analysis The inspiration for this paper comes from three sources: . \nPalsberg and O Keefe show that Amadio and Cardelli s type system with recursive types and subtyping [2] \nis equivalent to safety analysis [17, 18].3 The equivalence says that a term is declared safe by the \nanalysis if and only if it is typable in Amado and Cardelli s type system. Suppose we know that an expression \nis typable; is there an al\u00adgorithm to uncover its type-derivation tree? The answer is yes , and the method \ninvolves perform\u00ading a safety asmlysis of the expression. . Heintze shows that given a variety of type \nsystems instrumented by control-flow information the instrumented types are termed wntrol-f?ow types \n there exist corresponding closure analyses aug\u00admented by type information such that each type system \nis equivalent to its corresponding closure analysis [7]. Equivalence here means that each system calculates \nthe same flow and type infor\u00admation. Both of the above papers address type systems for closure anafysis, \nbut their methods of computation of flow information are aa follows: in Palsberg and O Keefe s work, \nthe information is indkectly obtained via a safety analysis, while for an expression in Heintze s system, \nit is obtained by enumerating all of the possible control-fiow types of the expression, and then systemat\u00adically \nremoving the (structural) type information. The upshot is that we obtain global analyses of expressions, \nin a (type-based) setting where moat analyses usually rely on compositional inference algorithms to calculate \nprogram properties. . In her Phd thesis, Tang provides a type and efled discipline for a call-tracking \nanalysis of the simply\u00adtyped A-calculus with a recursion operator [23]. Types are annotated with wntml-flow \neffects that statically approximate the set of functions called during the evaluation of an expression. \nSubtyping is used to obtain better precision for this analysis, by disarnbiguating call contexts. Tang \ns hrnework is attractive because it is local: given an expression, e, and an annotated-type envi\u00adronment, \nTE, cent aining the annotations of the free variables in e, the (ML-style) type inference algorithm can \nlocally analyse proper subexpressions of e, indepen\u00addently of the rest of the program; subsequently, \nit can compose the local analyses to obtain an analysis for the Safety analysis for the untyped A-calculus \nis basically a constraint-based, global program analysis that is used to pre\u00advent run-time errors due \nto misuse of constants (as in e.g., the application, O(AZ. Z)) without t~pe reconstruction. entire expression. \nIn fact, this is the general technique that is used for all the example program analyses men\u00adtioned in \nSection 1.1. The technique, however, is non\u00admodular: it requires the user to specify the annotated types \nof the free variables of e as is manifest in the pa\u00adramet ers to the inference algorithm.   1.3 This \npaper A curious observation due to Damas [5, Chapter 1], is that the simply typed A-calculus satisfies \nthe prin\u00adcipal typing property: given a typable program tiag\u00adment, e, possibly containing free variables, \nthere is a pair, ( TE, ~), such that TE Ee:r represents all valid typings (i. e., type-derivation trees) \nof e. Furthermore, there is an algorithm that calculates such a pair for e. The significance is, first, \nthe user does not have to sup\u00adply the types of the free variables of e they can be inferred automatically; \nsecondly, when fragments are linked, the typing of e might possibly change but principality guarantees \nthat the new typing is afways an instante of TE 1-e :r. Thus we can avoid are-inference of e upon linking. \nPrincipaf typing is therefore crucial to ensuring modularity. In the rest of the paper, we apply this \nproperty to obtain a modular closure analysis. Our goal is tirst, to provide a modular closure anal\u00adysis \nof program fragments in languages with type sys\u00adtems at least as powerful aa (core) ML s. Secondly, we \nare ah interested in making our analysis poiyuariant, i.e., a function can have diHerent behaviors (i. \ne., be applied to different functions) at its different uses. Note that in an ML-like language with polymorphic \ntype schemes, the principal typing property no longer holds [5, Chapter 2]. Instead, we obtain the weaker \nno\u00adtion of principal type schemes: if a type scheme can be inferred for an expression from a particular \nset of assumptions,4 then the expression hw a principal type scheme under those assum~tions. This entails \nthat we . cannot infer a principal type scheme for a pragmm fragment with free variables, unless supplied \nthe type schemes of the free variables; thk, in turn, entails that we ought to know the definitions of \nthe free variables so that we can type the uses of these definitions. This runs contrary to our expectations \nthat we must be able to type all uses of (free) variables in a module indepen\u00addently of their definitions, \nwhich may reside in a differ\u00adent module. Program analyses based on the ML type system are therefore often \nnon-modular. The following question [17, pp.579, 591] is open: Does there exist a direct, (i.e., modular) \nway of com\u00adputing flow information in Amadio and Cardelli s sys\u00adtem without a reduction to safety analysis \n? In this pa\u00adper we answer this question positively for another very expressive type system, namely, \nthe rank 2 intersection type system. We thus address both of our goals: indeed, Jim hss shown that this \nsystem can type more terms than ML while retaining the same complexity of type inference [10]. He has \nfurther demonstrated the useful\u00adness of this type system in typing recursive definitions, in accurate \nerror detection due to type mismatches, in incremental compilation, etc. We develop a modular, polyvariant \nand type-based closure analysis based on the rank 2 intersection type 4a proviso not required for the \nsimply-typed A-calculus. system with subtyping. Annotating types with flows, we show that there exists \na sound and complete type inference algorithm that can compute control-flow in\u00adformation directly from \nthe structure of the program text. Subtyping is used to orient flow information; the principal typing \nproperty of the annotated type system lends modularity to the analysis, so that program frag\u00adments with \nfree variables can be separately analysed; and the polymorphism inherent in the type system ren\u00adders \nthe analysis polyuatiant, so that the same function can be specified to have different behaviors at its \ndif\u00adferent uses. Polyvariance in our framework is similar to the no\u00adtion of polymorphic splitting advocated \nby Jagannathan and Wright for improving the precision of O-CFA [9]. Our work differs in that polyvariance \nis obtained as a result of the inherent polymorphism in the rank 2 inter\u00adsection type system rather than \nas a result of an explicit polyvariant closure analysis baaed on abstract interpre\u00adtation. 1.4 Organiaat \nion of the paper Section 2 briefly reviews closure analysis and gives a couple of examples. Section 3 \nintroduces the system Lz, which is the proposed type system for closure analysis. Section 4 and its subsections \nintroduce the &#38;unework for type inference in La, the crucial notion of matching, and the inference \nalgorithm. Properties of the inference algorithm are stated in Section 5. Section 6 shows an example \nwhere the inference algorithm is applied. A discussion of the framework follows in Section 7. Section \n8 concludes. 2 Closure analysis Consider an expression in the (call-by-value) A-calculus. We will label \nall .4-abstractions and variables in this expression uniquely, so that ~~z binds occurrences of Zz. We \noften refer to a A-abstraction by its label. A node in the syntax tree of an expression is called a program \npoint . Then, given a closed expression, closure analysis seeks to answer the following questions: . \nWhat set of labelled lambdas can each program point evaluate to? . What set of labelled lambdas cau \neach A-Abstraction in the expression be applied to?  Suppose the analysis detects that one of the A-Abstractions \nthat t can be applied to is d. Then this is analogous to saying that the bound variable, x!, say, of \nt?can be bound to t?. The second question above can thus be reformulated as: . What set of labelled lambdas \ncan every variable in the closed expression be bound to? Let us give a couple of examples of closure \nanalysis. For exact details of the usual abstract interpretation\u00adbaaed analysia, we refer the reader \nto the work of Seatoft [19] and Shivers [20].5 sMossin has recently discovered that Sestoft s analysis \nis not Shivers O-CFA, as is commonly mentioned in the literature. 2.1 Examples We wish to analyse the \nfollowing terms: (I) (~ g.g(.q(~ v . V)))(~3Z .~ g. u). The ~-~ysis yields the followirig results: 1.The \nfunction part of the application, A g.g(g(~ v. v)), yields {l}. The variable g yields {3}. J v. v yields \n{2}. The application, g(~ v. v), yields {4}. The application, g(g(A2 v. v)), yields {4}. 2. The ar ument \npart of the application, f A3Z. A v.y, yields {3}. y yields 0. J y. y, yields {4}. 3. The entire application \nexpression yields {4}. The interesting case is that of m it~ields both {2} and {4}! This is because, \nA3x. A y. y once gets applied to J v. w and again to the result of this application, i.e., to A y. y. \n (II) (J z. ZZ)(A2 y. ~). The analysis yields the follow\u00ading results: 1. The function part of the application, \nA1z. ZZ, yields {l}. z yields {2}. 2. The argument part of the application, A2y. y, yields {2}. ~ yields \n{2}. 3. The entire application expression yielda {2}.  One can verify the above results by reducing \nthe ex\u00adpressions. Note ~hat the that exampl~ is typab~e in the simply-typed A-calculus and in ML, whereaa \nthe sec\u00adond is not. Thus a type-baaed analysis based on the simple-type system, where properties are \nrepresented using simpl~type constructors, cannot be used to do closure analysis for the second example. \nOn the con\u00adtrary, an abstract interpretation-based analysis would succeed. For the first example, note \nthat a monovariant anal\u00adysis would analyse z and report that it possibly evalu\u00adates to the set, {2, 4}. \nFor a polyvariant analysis, how\u00adever, we should rather have a formahsm that says: at its innermost occurrence, \nx is bound to the A-abstraction labelled 2, and at its outer occurrence, x is bound to the J-abstraction \nlabelled 4. Informally, we could say that g is bound to the A-abstraction labelled 3, which haa type \n{2} + {4} at the former occurrence, and haa type {4} + {4} at the latter occurrence. We cannot unify \nthese types, instead should maintain their identities by resorting to an intersection type {2} + {4} \nA {4} + {4} . For examples, see his forthcoming Phd thesis [13, chapter 8]. The analysis presented in \nthis paper, is, in Mossin s parlance, a value-flow analysis , where we are interested only in closure \nvalues. 3 A type system for polyvariant closure anal ysis Here and in the following sections, we are \nmotivated by the general framework for type inference in the presence of subtypes as defined by Mitchell \n[12] and extended to behaviour analysis by Amtoft, Nielson and Nielson [3, 15]. We show that the rank \n2 fragment of the inter\u00adsection type discipline can be instrumented to perform a polyvariant closure \nanalysis. We will call this instru\u00adment ed system La. A type, r, is of rank k, if no intersection type \ncon\u00adstructor, A, occurs to the left of k arrows in r. We restrict ourselves to rank 2, because typability \nfor ranks higher than 2 is an open question, and in the full inter\u00adsection type discipline typability \nis undecidable; further, the rank 2 system can type more terms than ML and has the principal typing property \n[10]. The tewns of the system are the terms of the ~\u00adcalculus. The types of the system are classified \nas fol\u00adlows: To = {t [ t is a type variable}u {u~~ [ u,r ETo, @E Flow} Tl=Tou{u ATlu, ~ETl} Tz=Tou{o~~ \nI UGTI,7ET2,1$EFIOW} To is the set of simple or rrmk O types. The set T1 is the set containing runk 1 \nintersection types: i.e., it contains TO as well as finite, non-empty intersections of simple types. \nA T1 type can be written in the notation &#38;l(~i), where each ~i is in To. The set T2 contains TO and \nthe set of function types which are a subset of the rank 2 intersection types, and in which the inter\u00adsection \ntype constructor is restricted to appear only to the left of atmost one arrow. Clearly, T1 ~ Tz and TO= \nT1 n T2. The set Flow denotes flows: a flow, #, has the BNF, @ ::= NI&#38;IqhU 42, where E E P(Labels) \nand ~is a flow van able. 3.1 Subtyping Corresponding to the sets T; above, we have the sub\u00adtyping relations, \n<i, for i G {O,1,2}. A set, K, of type constraints is said to be atomic, iff all type constraints in \nK are of the form, t <0 t , where, t, t are type vari\u00adables. A set, C, of flow constraints is said to \nbe regular, iff all flow constraints in C are of the form, .$E ~, where < is a flow variable. Subtyping \njudgments take the form: K, C ~sT u <, T, where K isa setof at omit type wnstraints, C is a set of regular \nflow constraints, and i G {O, 1, 2}. The judgement should be read as: under the atomic type constraints, \nK, and the regular flow constraints, C, we can deduce that the rank i-type u is a sub\u00adtype of the rank \ni-type r, for i c {O, 1, 2}. Since func\u00adtion types are annotated with flows, subtyping on types 6Base \ntypes like int, red, boo{, etc., belong to To. For sim\u00adplicity, we omit them in this paper. requires \na comparison of flows too. Thus the judge\u00adment K, C +FL r#J ~ r#Jmeans that under the atomic type constraints, \nK, and the regular flow constraints, C, the flow, ~ , is less precise than the flow, ~. Fig\u00adure 1 provide: \na formal definition of subtyping and flow comparisons.7 ~,Ct_sT U<~U, iE {0,1,2} K, CI-5T U<, T K, C1-sT \nT<, p i E {0,1,2} K, CI-5T u<ip K, CksT t <O t , if (t <O t K, C +ST ffI <071 K, CksT rg<o ag K, Cl-FL \n# >1#  K, CI-STU<OT K, C I-ST Uszr Figure 1: Subtyping in L2 The typing rules of Lz follow in Figure \n2. For z E {O, 1, 2}, we say that a type environment TE is a Ti type environment, iff for all z G dom( \nZW), TE(z) is a T-i type. All type environments in Lz are Tl the environments whereas derived types are \nin Tz. The subtyping relation, <1 is extended to T1 type environ\u00adments so that TE <I TE Mfor all x Edom( \nTE ), it In the sequel, we will often need judgments of the form, ~, C hsT ~ and ~, C EF~ C , where, \nK and C are sets of type constraints and flow constraints. They have the obvious meanings. is the case \nthat z G dom(TE) and TE(z) <j TE (z). A typing is of the form, K,C,TE +e:r, and is read: under the atomic \ntype constraints, K, the regulw flow constraints, C, and the T1-type environment, T-E, the .. expression, \ne, has the Ta-type, r. K, C, TEFe:r K, CEST T<ga K, C, TEt-e:cr Figure 2: The system LZ 4 Type inference \nin L2   4.1 Preliminaries Given am expression, e, we wish to infer a set of atomic type constraints, \nK, a set of regular flow constraint, C, and a T1 type environment, TE, under which e can be assigned \na Tz type, ~. We are especially interested in r of the form rl ~ rz, where @ estimates the flow infor\u00admation, \ni.e., the set of all closures that e can possibly evaluate to. In preparation for the type inference \nalgorithm, we stipulate that mbstitutions map type variables to TO types, and flow van ables to flows \n the restriction to TO types assuring that all inferred types are TZ types. We wiIl also need subtypings \nbetween Tz types and T1 types. The reason is that if we have an application of the form eoel, and the \ntype of e. is inferred to be the Tz type, r ~ ~ , and the type of el is inferred to be the Tz type, n, \nthen ~1 must be a subtype of ~. But since ~ -% # is a T2 type, r is a T1 type! Accordingly, we have the \nfollowing definition of the subtyping relation 52,,. Definition 1 (<2,1) Let o bea Tz type and ~i, a \nTo type, for all i c I. Rmther, let K be a set of atomic type constmints, and C be a set of regular f70w \nconstraints. Then, K, C I-ST u <g, I Aiel rip ifiK, c hT u<g Tij for ailiEI. B Mitchell has observed \nthat the key to generating atomic type constraints from a subtype relation on types u and r, say, is \nto make u and r match [12], i.e., to force them to have the same shape [3]. Here we run into a technical \ndifficulty due to the presence of intersection *Note that Binceri is a TO type, it is a Tz type and henceit \nis legal to write a <a 71. types. As before, let us consider an application of the form, eoel. Suppose \nthe type of e. is inferred to be the Tz type, co A UI ~ c72, and that of el, the Ta type, TOA 71&#38; \n72. If the application is to successfully type\u00ad check, then clearly, To ATI% T2 <2,1 croA al. By def\u00adinition \nof the <z, 1 relation, this implies that a., al are To types and, in particular, that ToA T1 ~ T2 <2,1 \nUo. Now if we directly match uo with ToA T1% T2, then uo is forced to have the shape of a Tz type that \nis not a TO type, leading to a contradiction. We will see later that the solution to this dMiculty is \nto transform any <2,1 subtyping into a set of <O subtypings and then match on the latter set. 4.1.1 Matching \nAdapting Mitchell s notion, we say that two TO types, a and r match iff they have the same shape . Thw \nis formalised in the following detirition. Definition 2 (Matching for TO types) Two To types, u and r \nmatch iff any of the following hold: . Both u and ~ are type var%bies. . 0=7-. , . If u has form, al \n-f+ r72 and r has form, T1 &#38; T2, then it is the case that al and TI match and G2 and rz match.  \n NOW let Ai61 (ui) and Aj~J(Tj) be two T1 types. Clearly, each of the a; S and each of the Tj s are TO \ntypes. We then have the following definition of match\u00ading for T1 types. Definition 3 (Matching for T1 \ntypes) TWOT1 types, &#38;r(ui) and Aj~J (TJ) match ififor ~J ~~{rj lj~.l},themdts~~{ui li~l}, such that \nu and r match. Note that Definition 3 does not necessarily imply that two matching T1 types have the \nsame shape . Finally, we have the following definition of matching for T2 typea note that here again, \ntwo matching T1 types do not necessarily imply that they have the same shape . Definition 4 (Matching \nfor Tz types) Two T2 types, u and T match ifl either: .u and r are both TO types and they match accord\u00ading \nto Definition 2, or, $ 4 .u has form, al + 02 and r has form, rl + rz, and the T1 types, rl and al match, \nand the T2 types, uz and rz match. The three definitions above inspire the following fact: Fact 1 LetK \nbe a set of atomic type wnstmints, C be a set of regular flow constmints and u and r betwo TI types such \nthat the judgement K, C ksT u <i T can be asserted for i E {O, 1, 2}. Then u and r are matching. Since \nwe need to deal with the <z,l relation in the inference algorithm, we need to define what it means for \na Tz type and a T1 type to match. Definition 5 (Matching Tz and T1 types) Let u bea TZ type and ~iel \n(Ti)j a T1 type. Then a matches Ai~l (Ti), provided a matches the TO (hence the Tz) type, T8, for a~i \ni 6 I. The following fact is immediate from Definition 5 aud Fact 1: Fact 2 Let K beaset of atomic type \nwnstraints, C be a set of regular jlow constraints, o be a Ta type and Aiel (Ti) be a T1 type such that \nthe judgement, K, C FST a <~,1 AiE1(7i) can be assetied. Then u and Ai~l(~i) are matching. Consider the \nscenario where the types a and r are a possibly non-matching pair, such that, either, both u and ~ are \nT1 types, (i E {O, 1, 2}), or, c is a Ta type and ~ is a T1 type. If there is a substitution, S, that \nmakes So and Sr match, then such a substitution is termed a matching substitution for u and r. The notion \nof a matching substitution is extended to a set of possibly non-matching pairs of types in the obvious \nmanner.  4.1.2 Matching problems Consider a possibly non-matching set, K, of <O con\u00adstraints. Question: \nIs there an algorithm that computes a matching substitution, S, for K and reports failure if the matching \nfails? The answer is Yes . Many veraions of thki algorithm exist we will be using the Algorithm > developed \nby Nielson, Nielson and Amtoft [15], based on ideas from Fnh and Mishra s work on type inference in the \npresence of subtypes [6]. The algorithm has been shown to be sound and complete: we will just mention \nthe soundness property here. Property 1 (Soundness of Algorithm ~) Let K be a set of possibly non-matching \n<O constmints. Then Algorithm F wmputes a matching substitution for K, if one ezists, and reports failure \notherwise. More specifically, if a matching substitution for K exists, 7(K) wmputes the triple, (S , \nK , C ), where S is a matching substitution for K, restricted to type vari\u00adables only,g K is a set of \natomic type constmints, and C is a set of regular flow constmints, such that, K , C ksT S K. In our \ninference algorithm, however, we will need to compute matching substitutions for a possibly non\u00admatching \nset of ~ 2,1 constraints. The natural question is: Is there an algorithm, similar to Algorithm 3, that \ncan compute a matching substitution for such a set? We will show that for every non-matching set of <2, \nI con\u00adstraints wmputed by the inference algorithm, there ex\u00adists a corresponding non-matching set of \n<O constraints. Thus, it suffices to use Algorithm 3 on this latter set. We formalise the notions below. \nConsider the quadruple, (K, C, P, S), where K is a possibly non-matching set of <O constraints, C is \na set A substitution S is said to be restricted to type variables only, if for all type vsriables, t \nin its domain, St = r, where 7 is a TO type, and for all flow variables, ( in its domain, Sf = (. of \nregular flow constraints, P is a possibly empty set of <Z,l constraints of the form, {~i <2,1 Ui [ z \nE 1}, and S is a substitution restricted to type variables only. Then (K, C,P,S) will be called a <2,1 \nmatching problem. The special case, P = 01 will be called a <O matching problem. Definition 6 (Solution \nto <2,1 matching problems) A solution to the <z, matching problem, (K, C, P, S), is a tm ple, (K , C \n, ~j, when K is aset of atomic type constraints, Cl is a set of regular flow constraints, and S is a \nmatching substitution for K and is a matching substitution for the set, P restricted to type variables \nonly such that, K , C I-s.T S K, and K , C I-FL C, and K , C ~sT S P. Note that in Definition 6, if \nP =0, then the <2,1 matching problem reduces to the <O matching problem, (K, C, 0, S), such that, if \nit has a solution, (K , C , S ), then, K , C I-ST S SK and K , C I-FL C. We also know that Algorithm \nX can compute a solution (if one exists) for the possibly non-matching set S(K). Let X( S(K)) = (S , \nK , C ). Then, by soundness of F, since K , C l-FL S SK and K , C ~ U C I-sT C, we can assert that (K \n, C U C, S S) is a solution to the <0 matching problem, (K, C, 0, S)! We will now show that any <z, 1 \nmatching problem arising out of the inference algorithm can be rewrit\u00adten into a <O matching problem. \nFor the moment, the reader is requested to accept on faith that there can be only four basic forms of \n<z, 1 constraints arising from the inference algorithm: (a)t <z,l ~, where T is a To type, (b) r <2,1 \nrl A 72, (c) (~1 ~ 72) <2,1 t,and (d) (rl &#38; r2) <2,1 (al ~ U2). The rewriting rules appear in Figure \n3. .(K, C, Pu{t<z,lr I rGTo}, s) -{S(K U {t <o ~}), C, P,S) . (K, C,PU {~ <2,1 ~1 A T2}, S) = (SK, C,PU \n{~ <2,1 n, T <2,1 T2}, s)  . (K, C,PU {(TI ~ 72) <2,1 t}, S)  * (K , C , P , S ) whew tl, tz, &#38; \nare fresh, K = S K, C =cu{&#38; >&#38;}, P = P u {tl<2,1 n, 72 <2,1 t2}, s =[t+tl Lt2]os . (K, C,P \nU {(T1 &#38;T2) <2,1 (al ~u2)}, S) -(SK, C , P , S) where C = CU {f &#38; .$}, P = P u {al <2,1 n, T2 \n<2,1 C72} Figure 3: Rewriting of <2,1 constraints to <0 con\u00ad straints Note that Figure 3 indeed defies, \nin rewrite rule form, an algorithm to transform <2,1 constraints to <0 constraints. The rewriting terminates, \nsince every 10Thi~willbe ~1~~~by inspection when the inference algorithm is presented in the following \nsection. step of the rewriting creates a smaller set of <~, ~ constraints: by inspection, one of two \nthings happens at every rule either the number of type construc\u00adtors (+ or A) decreases, or the number \nof <2,1 in\u00adequalities is reduced. As a result, we are guaranteed that the <2,1 matching problem, (K, \nC, P, S) will be eventually rewritten into the <z,l matching problem, (K , c , o,s ). The following fact \nis immediate: Fact 3 (Properties of the relation ~) Zj (K, C,P, S) ~ (K , C , P , S ), then: . There \nezists a substitution, R, such that, RS = S . . S K = K . . C ~ C and all new jlow wnstraints generated \ndue to rewriting are between flow variables, i.e., of the form ( k(. . If (K , C , S ) is a solution \nto (K , C , P , S ), then, (K , C , S S ) is a solution to (K, C, P, S).  In summary, we have the following \ncrucial theorem re\u00adlating <z,l and <0 matching problems. Theorem 1 Let (K, C, P, S) be a <2,1 matching \nproblem, where P is a set of <2,1 constmints obtained jivm the inference algom thrn. Then, (K, C, P, \nS) &#38; (K , C , 0, S ). Fur\u00adthermore, if X( K ) = (S , K , C ), then, (K , C U C , S S ) is a sohd;on \nto both (K , C , 0, S ) and to (K, c, P, s). 4.2 The inference aIgorithm: an intuitive ex\u00adplanation For \na term e, the inference algorithm calculates the pair, ( TE, r) where TE is a T1 type environment, and \nr is a Tz type a set of type constraints, K, and a set of flow constraints, C. We will show in Section \n5 that K is atomic, C is regular, and that all flows occurring in r are ffow variables. We will also \nneed to demonstrate that K, C, TE Ee:r is a valid derivation in La. We present the inference algorithm \nin inference-rule format in Figure 4. The algorithm is in a style reminis\u00adcent of Damaa Algorithm T [5]. \nThe following notations are used: Notation: TE, denotes the type environment TE with afl occurrences \nof z deleted; further, ( TE1 + TE2)(z) = TEJ(z), z 6 dom(TEl), x @ dom(TE~) TE2(z), z E dom(Z E2), x \n@ dom(TEl) TE1 (z) A TEz(z), z G dom(TEl ) and z 6 dom(TE2) { We will only focus on the rules for application \nsince the ones for identifiers and A-abstractions are easy. There are two rules for inferring the type \nof an ap\u00adplication, eoel. For the tirst, we need to show that K , C U C , S S (TEO + TEJ) 1-eoel : S \nS (tz) is a vafid derivation in Lz. We can assume that the inference of eo yields the T1 type environment, \nTEo, the TZ type, t, a set of atomic type constraints, Ko, and a set of reg\u00adular flow constraints, CO, \nso that, Ko, CO, TEo 1-eo : t is a valid derivation in LZ. In a similar manner, we can assume that K1, \nCl, TE 1 1-el :r is a valid derivation in Lz. DX : ({z: t}, t), 0, 0, where t is fresh. be : (TE. r). \nK. C x@ dom(TE), where t, ( are fresh. { De : (TE, r), K, C ~A~x.e : (TEZ, TE(z) ~ ~), K, C x~ dom(TE), \nwhere ( is a fresh fiow variable c =cu{f~ {t}} { Deo : (TEo, t), Ko, Co Del : (TEJ, r), Kl, Cl  D eoel \n: S S (TE , tz), K , C U C where tl, tz, ~ are fiwsh, K= Kou K1, C= CO UC1, s=[t*t14t2], (SK, C,{r <z,, \nt,}, S) ~ (K , C , O,S ), F(K ) = (S , K , C ), and TE = TEo+TE1 Deo : (TEo, (AiErui)~u), ~13, CO (Vic \n1) Del : (TEi, ri), Ki, Ci Deoel : S S (TE , u), K , C uC where Vi 6 I, the tuve and tlow variables in \n(T~i, 7i)~ Ki an~ Ci, are fish, K = KoUUie-K:, C= CO UIJiEICi, P = {~; <Z,* U: I i G1}, (K, C,P, [ ]) \n&#38; (K , C , O,S ), ~(K ) = (S , K , C ) and TE = TEo + E,=J TEi Figure 4: Inference Algorithm for \nLz Clearly, t ought to be a function type of the form, tl~ tz,where tl, t2, { are fresh. Furthermore, \nr, a TZ type, ought to be made a subtype of tl, a T1 type. Let S be the substitution, [t I+ tl&#38; t2],K \n=KO U~I, and C= COUC1. Note that while K is atomic, SK is a possi\u00adbly non-matching set of <O type constraints. \nSimilarly, the types ~ and tl are possibly non-matching; hence to force a <z, I subtyping judgement between \nthem, we must find a matching substitution, a set of atomic type constraints and a set of regular flow \nconstraints, such that the obvious judgement can be asserted. Further\u00admore, the matching substitution \nshould match the <O constraints in the set SK. Now note that (SK, C, {r <2,1 tl}, S) is a <2,1 matching \nproblem ! Hence we can use the algorithm in Figure 3 to transform it into a <O matching problem, (K , \nC , 0, S ). Algorithm S can compute a matching substitution for K , (if one exists), restricted to type \nvaziables only. By Theorem 1, we know that a so\u00adlution for the <O problem also solves the <z, 1 prob\u00adlem, \n(SK, C, {~ <z,l i!l}, S). Accordingly, let Z(K ) = (S , K , C ). Then we can assert the subtyping judge\u00adment, \nK , C U C FsT S $(7) <Z,I S $(ti ). Fur\u00adthermore, since K , C U C ~sT S S K, we can assert the judgments, \nK , C uC , S (TEOE0 + 7 EI) 1-eo : S S tl ~ S S t2, and K , C U C ,S S (TEO + TEz) 1-el : S S r.  Putting \nthe pieces together, and using the rule for application and subtyping in Ls, we obtain, K , C U C , S \nS ( TEo + TE1 ) 1-eoe~ : S S (tZ). In a similar fashion, we can show that for the second application \nrule, the derivation, K , C U C , S S (TEO + ~iel T E, ) k eoel : S S (a) is valid in Lz.   5 Properties \nof the inference algorithm We state without proof the following properties of the inference algorithm. \nLemma 1 For all eqn-essions, e, if D e : ( TE, r), K, C, then, K is atomic and C is regular. firthermom, \nall f70ws in the inferred type, T, are jlow variables. Theorem 2 (Soundness) For all expressions, e, \nthe inference algorithm al\u00adways terminates either with failure,ll W,;fbe : { TE, r), K, C, then, it is \nthe case that K, C, TE 1-e : T.12 Notation: Say that ( TE, r) < (TE , ~ ), itl, TE <1 TE and ~ <z r \n. We then have the following theorem: Theorem 3 (Completeness) Suppose K,C, TE 1-e : T. Then De : (TE \n, T ), K , C succeeds, and there exists a matching substitution, R , of K , such that (i) K, C ~s~ R \n(TE , ~ ) < (TE, r). Ildue to fajlure of matching in AlgOrithm 7. 12the proof ~~e~ the property of soundness \nof AlgOrithm ~. (ii) K, C h~~ R(K and K, C \\FL R C . Given an expression, e, type inference either fails, \nor generates the pair, ( TE, ~), the set of atomic type constraints, K, and the set of regular flow constraints, \nC. Closure analysis now is just the solution of C, using the usual transitive closure algorithm.  6 \nExample Consider the term, (A1 z. ZZ)(,42 y. y). We cart show that the inference algorithm applied to \nA1z. zz yields, and, applied to AZy. y, yields (0, tbS ts),0,{&#38; &#38; {2}}. Now we can obtain the \n<2,1 matching problem, (K, C, P, S), where: K = {tl <0 ts}, c ={< >{1},( k {2},5 k {2}}, ,, P = {ts \nLts <2,1 t Lt4,:5 sf5 S2,1 h}, and S = [ ]. This matching problem can be reduced to the <O matching problem, \n(K , C , 0, S ), where: K = {tll 9t1z <0 t3, ~5 <O t12, tll <0 i5, t5 <0 t4, t3 <0 t5}, c =Cu{rgl k~}, \ns = [tl -tll %t12]. Applying Algorithm 3 to K yields the substitution: [tsI+tsl* =tsz], the ~tw,tq tql-tqz,ts \nI+t.sl set of atomic type constraints: {t31<0 t,l, i!,2 <0 t32, t-i <0 t,,,t,l so i5,t4, <0 t51, t52 \n<o t42, t51 <o t31, t32 <o t52}, and the set of regular flow constraints, c = {(31 k (11, <51 k (31,(41 \nk <51}. Upon solving the set of constraints, C U C , we see that the type of the entire expression is \nt.tl3 tqz,giv\u00ading the expected result that it evaluates to the lambda Iabelled 2. 7 Discussion A difference \nbetween the current hrnework and existing abstract interpretation-baaed approaches and Tang s effect \nsystems-based approaches is that our analysis doesn t track function calls. Instead, we only calcu\u00adlate \nwhat set of functions every program point can pos\u00adsibly evafuate to. This automatically provides a call\u00adtracking \nanalysis: suppose a program point has type, (tl~ tz)~(ts ~ tq),then we immediately know that it can evaluate \nto the function labelled 1 and the behaviour of 1 is that when applied, it will call the func\u00adtion 2 \nand yield the function 4. Moreover, we observe that 2 and 4 never call any functions. The rules for type \ninference of an application, eoel, in Figure 4, reveals that the merging of the type envi\u00adronments in \nthe consequent does not unify the possibly different types of a free variable occurring both in e and \nin e : rather the variable is given an intersection type. This is of crucial importance in providing \npolyvariance. Consider the example (Af .(Az. f 1)( f 0))1, where 1 is the identity combinator. Instead \nof giving a type T + T to f, and assigning the type T to the entire expression Isthe proof ~e~ the property \nOf completeness of AlgOrithm ~. (as is done in [17]) we can do better. First, let us anno-type. Such \nan extension would allow us to handle re\u00ad tate the term (writing out the identity combinator), as follows: \n(A1 /. (Azz. (~(A3 u. u))(~O)))(A4v. v). Then executing the inference algorithm and solving the set of \nflow constraints, we find that the type of the en\u00ad tire expression is t,~ tl,showing that it evaluates \nto closure {3}. The type of the function part of the application becomes [((tl ~ tl ) ~(tl ~ tl )) A \n(int ~ int)] ~(t, ~ ti ). which shows the expected polyvariance: the two uses of ~ expect the identity \n{4}; at one use point the identity calls the function 3 and returns it; at the other it expects an integer \nand returns an integer. Note that this automatically ensures that v is only going to be bound to the \nfunction labelled 3. The impact of modularity is that at every stage of the inference algorithm, we can \nreduce the set of flow constraints and atomic type constraints, to some nor\u00admal form and store it away. \nDuring linking, we will possibly generate some new constraints, but we do not need to recompute the normal \nforms . 8 Conclusion and Future Work We have developed a typ~baaed closure analysis by a simple extension \nof the rank 2 intersection type sys\u00adtem. The inherent polymorphism of intersection types is exploited \nto provide a polyvariant analysis. Type in\u00adference in the system is sound and complete and yields principal \ntypings, resulting in a modular analysis. Recursion has often been the bane of many type\u00adbased program \nanalyses. Whereas we would very much like polymorphic recursion, type inference becomes un\u00addecidable. \nThe type system in this paper can be easily extended to allow top-level universal quantification so that \nthe following recursion rule suggested by Jim [10] can be added: - K, C, TE+{x:7)t-e:u K; C &#38; U <vg,,- \nr K,C,TE t-pz.e :u This would be an improvement on ML-style monomor\u00adphic recursion while still retaining \nprincipal typings and polyvariance. More interesting would be the extension of the framework to handle \nintersections for arbitrary deptha for which, Jim hints, principal typings can be obtained. A ditkrent \napproach would be to use Tofte and Talpin s region analysis [24], but this analysis, being for ML, usea \nthe assumption of monovariant A-bound variables, which results in 10ss of polyvariance if such a variable \nis used multiple times within the A body. How\u00adever, it remains to be seen how region-polymorphism for \nrecursive definitions compares with the above rule for recursion. For TO types, our analysis can track \nthe same calls as Tang s call-tracking analysis. Our analysis needs to be implemented, tested for precision, \nand anal\u00adysed for complexity vis-a-vis its corresponding abstract interpretation-based analysis. It also \nremains to be seen how this work compares with the polymorphic splitting optimisation of Jagannathan \nand Wright [9]. We are continuing work on extending our framework with recursive types of the form pt.T,where \n~isaTO cursive data structures as well. It will also be interesting to develop a generic, type based \nprogram analysis framework that is modular and achieves precision comparable to that obtained via an \nabstract interpretation-based analysis. In particular, the precise relationship between flow information \nob\u00adtainable from a rank k type system and the k-CFA hi\u00aderarchy proposed by Shivers [20] needs to be explored. \nAcknowledgements: Thanks to Flemming Niel\u00adson and Hanne Riis Nielson for listening patiently to many \npresentations of this work, for their apposite com\u00adments, and for inviting me to work in their group. \nThanks to the Church Project, in particular, to Assaf Kfoury and Bob Muller for d~ussions and encourage\u00adment, \nand to Jens Palsberg for his interest. For com\u00adments on drafts of this paper, I wish to thank Torben \nAmtoft, Olivier Danvy, Allyn Dimock, Pascal Fradet, Kirsten L. S. Gaaser, Chris Hankin, Fritz Henglein, \nThomas Jensen, Pierre Jouvelot, Andrew Kennedy, Sergey Kotov, Julia Lawall, Peter Orb~k, Jakob Rehof, \nand David Schmidt. References [1]Alfred V. Aho, Ravi Sethi, and Jeffrey D. Unm\u00adan. Compilers: Principles, \nTechniques and Tools. Addison-Wesley, 1986. [2] Roberto Amadio and Luca Cardelli. Subtyping re\u00adcursive \ntypes. ACM Transactions on Progmmming Languages and Systems, 15(4):575-631, 1993. [3] Torben Amtoft, \nFlemming Nielson, and Hanne Riis Nielson. Polymorphic subtyping for behaviour analysis. Unpublished manuscript, \n1996. [4] Patrick Cousot and Radhia Cousot. Abstract inter\u00adpretation: a unified lattice model for static \nanaly\u00adsis of programs by construction or approximation of fix-points. In Proceedings of the Fourth Annual \nACM Symposium on Principles of Progmmming Languages, January 1977. [5] Luis Manuel Martins Damas. ~pe \nassignment in pmgmmming languages. PhD thesis, University of Edinburgh, Edinburgh, Scotland, April 1985. \n[6] Y. C. Fuh and Prateek Mishra. Type inference with subtypes. Theoretical Computer Science, 73(4):603-+31, \nOctober 1990. [7] Nevin Heintze. Control-flow analysis and type sys\u00adtems. In Alan Mycroft, editor, Proceedings \nof the second International Static Analysis Symposium, number 983 in Lecture Notes in Computer Sci\u00adence, \npagea 189-206, Glasgow, Scotland, Septem\u00adber 1995. [8] Suresh Jagannathan and Stephen Weeks. A uni\u00adfied \ntreatment of flow analysis in higher-order km\u00adguages. In Proceedings of the Twentysecond An\u00adnual ACM \nSymposium on Principles of Progmm \u00adming Languages, San Wmcisco, California, Jan\u00aduary 1995. [9] Suresh \nJagannathan and Andrew Wright. Effec\u00adtive flow analysis for avoiding run-time checks. In Hanne Riis Nielson \nand Kirsten Lackner Solberg, editors, Proceedings of Workshop on Types for Pro\u00adgram Analysis, DAIMI PB-495, \npages 63-79. Uni\u00adversity of Aarhus, Denmark, 1995. [10] lYevor Jim. What are principal typings and what \nare they good for? In Proceedings of the Twen\u00adtythird Annual ACM Symposium on Principles of Programming \nLanguages, St. Petersburg, Floridal January 1996. [11] Neil D. Jones. Flow analysis of lambda expres\u00adsions. \nIn Proceedings of Eighth Colloquium on Au\u00adtomata, Languages, and Programming, volume 115 of LNCS. Springer-Verlag, \n1981. [12] John C. Mitchell. Type inference with simple subtypes. Journal of llmctional Programming, \n1(3):245-285, 1991. [13] Christian Mossin. Flow analysis of typed higher\u00adorder progmms. PhD thesis, DIKU, \nUniversity of Copenhagen, January 1997. [14] Flemming Nielson and Hanrre Riis Nielson. Infini\u00adtary control \nflow analysis: a collecting semantics for closure analysis. In Proceedings of the Twenty\u00adfourth Annual \nACM Symposium on Principles of Programming Languages, Paris, France, January 1997. [15] Flemming Nielson, \nHanne F@ Nielson, and Torben Amtoft. Polymorphic subtyping for effect analysis: the afgorithm. In Mads \nDam and Fredrik Orava, editors, Proceedings of the fifth L OMAPS Work\u00adshop on Multiple-Agent Languages, \nnumber 1192 in Lecture Notes in Computer Science, pagea 207-243, 1997. [16] Jens Palsberg. Closure analysis \nin constraint form. ACM !lhansactions on Programming Lan\u00adguages and Systems, 17(1):47-62, January 1995. \n[17] Jens Palsberg and Patrick O Keefe. A type system equivalent to flow analysis. ACM 2Yansactions on \nProgmmming Languages and Systems, 17(4):576\u00ad599, July 1995. [18] Jens Palsberg and Michael Schwartzbach. \nSafety analysis versus type inference. Information and Computation, 118(1):128-141, 1995. {19] Peter \nSestoft. Analysis and Eficient Implemen\u00adtation of l%nctionai Pragmms. PhD thesis, DIKU, Copenhagen, Denmark, \nOctober 1991. Rapport Nr. 92/6. [20] Olin Shivers. Control-Flow Analysis of Higher-Order Languages or \nTaming Lambda. PhD theeis, CMU, Pittsburgh, Pennsylvania, May 1991. Tech\u00adnicaJ Report CMU-CS-91-145. \n[21] Kirsten Lac.kner Solberg. Annotated type systems for pmgmrn analysis. PhD theeis, Aarhus Univer\u00adsity, \nAarhus, Denmark, 1995. DAIM1 PB-498. [22] Jean-Pierre Talpin and Pierre Jouvelot. The type and effect \ndiscipline. Information and Computa\u00adtion, 2(1 11):245-296, 1994. [23] Yan-Mei Tang. Systimes d effet \net inter-y+tation abstraite pour 1 analyse de flot de contriile. PhD thesis, Ecole Nationale Sup&#38;ieure \ndes Mines de Paris, March 1994. Rapport A/258/CRI. [24] Mads Tofte and Jean-Pierre Talpin. Implementa\u00adtion \nof the Typed Call-by-value A-calculus using a Stack of Regions. In Proceedings of the Twen\u00adtyfirst Annual \nACM Symposium on Principles of Programming Languages, Portland, Oregon, Jan\u00aduary 1994. Permission to \nmake digital/hard copy of part or all this work for personal or classroom use is granted without fee \nprovided that copies are not made or distributed for profit or commercial advan\u00adtage, the copyright notice, \nthe title of the publication and its date appear, and notice is given that copying is by permission of \nACM, Inc. To copy otherwise, to republish, to post on servers, or to redistribute to lists, requires \nprior specific permission and/or a fee. ICFP 97 Amsterdam, ND @ 1997 ACM 0-89791 -918 -1/97 /0006 . ..$3.50 \n \n\t\t\t", "proc_id": "258948", "abstract": "We observe that the <i>principal typing property</i> of a type system is the enabling technology for <i>modularity</i> and <i>separate compilation</i> [10]. We use this technology to formulate a modular and polyvariant closure analysis, based on the rank 2 intersection types annotated with control-flow information.Modularity manifests itself in a syntax-directed, annotated-type inference algorithm that can analyse <i>program fragments</i> containing free variables: a <i>principal typing</i> property is used to formalise it. Polyvariance manifests itself in the separation of different behaviours of the same function at its different uses: this is formalised via the rank 2 intersection types. As the rank 2 intersection type discipline types at least all (core) ML programs, our analysis can be used in the separate compilation of such programs.", "authors": [{"name": "Anindya Banerjee", "author_profile_id": "81100144615", "affiliation": "Xinotech Research, Minneapolis, MN", "person_id": "PP14060901", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/258948.258951", "year": "1997", "article_id": "258951", "conference": "ICFP", "title": "A modular, polyvariant and type-based closure analysis", "url": "http://dl.acm.org/citation.cfm?id=258951"}