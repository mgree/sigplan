{"article_publication_date": "08-01-1997", "fulltext": "\n Disposable Memo Functions Extended .Abstract Byron Cook John Launchbury byron@cse. ogi. edu jl~cse. \nogl. edu Department of Computer Science and Engineering Oregon Graduate Institute To appear in proceedings \nof 1997 H~kell Workshop A memoized function, or memo function, remembers the arguments to which it has \nbeen applied, together with the resulting computation. If it is applied to the same argument again it \nreturns the stored answer rather than repeating the computation. Memorization haa been proposed as a \nsolution to numer\u00ad ous problems because it improves the asymptotic complex\u00ad ity of algorithms with redundant \ncomputations. However, most schemes for memorization can consume vast amounts of memory that are only \ngarbage-collectible by heuristic means. In contrast, we give a semantics for memorization aa an extension \nto the lazy J-calculus computational model. Programmers will find that managing the space consump\u00adtion \nof memoized functions is comparable to managing the space requirements of any other value in the heap. \nThis is an important contribution because previous purging ap\u00adproaches required that programmers adopt \nnew and foreign reasoning pnncipak. The key idea of this paper is to adapt the Hughes s [2] research \non lazy memo-functions and supply a function memo with type: memro:: Eval a => (a -> b) -> (a -> b) When \napplied to a function, memo returns an equivalent memo-function which may be used repeatedly while refer\u00adences \nto it exist. Once all references have been dropped, the garbage-collector is able to reclaim the space. \nIt is in this sense that memo functions are disposable. As a simple example imagine mapping a computationally \nexpensive function across a list with repeating values: let p x = product (take 1000 [x, x .. ]) in map \np [1,2,3,2,1,5,6,3,2,1] Rather than applying a complicated transformation to re\u00admove the redundant computation, \nthe mapped function could be memoized: map (memo p) [1,2,3,2,1,5,6,3,2,1] When the expression haa been \nreduced there will be no more references to the function (memo p). The garbage collector can then reclaim \nthe function and memo-table. Permission to make digital/hard copy of part or all this work for personal \nor classroom use is granted without fee provided that copies ara not msde or distributed for profit or \ncommercial advan\u00adtage, the copyright notice, the title of the publication and its date appear, and notice \nis given that copying is by permission of ACM, Inc. To copy otherwise, to republish, to post on servers, \nor to redistribute to lists, requires prior specific permission and/or a fee ICFP 97 Amsterdam, ND I@ \n1997 ACM 0-89791 -918 -1/97 /0006 . ..$3.50 We explore two applications of lazy memo-functions in areaa \nof recent research: parser combinatore [3] and RBMH (Reactive Behavior Modeling in Haakell) [1]. Both \nexam\u00adples are languages embedded in Haakell for specifications that might naturally contain computational \nredundancies. Although they are concisely expressed in pure functional languages, the resulting programs \ncan exhibit unreasonable run-time behavior. Rather than requiring explicit changes to improve efficiency \n(obscuring structure and degrading main\u00adtainability) memo functions provide a local and modular so\u00adlution. \nPerhaps the most important contribution of the paper is our semantics which enable reasoning about memoization \ns effect on space and time complexity. We formalize the mean\u00ading of lazy memo functions by adding the \nconstant memoto the ~-calculus and providing a reduction rule for terms con\u00adtaining memo. Baaed on the \nsemantics, we present a simple and efficient prototype implementation written with the state monad and \nan unsafe state escape primitive. Our implementation re\u00adquires no changes to the garbage-collector; memo-tables \nare simply reclaimed when no references to them remain. We demonstrate that, with the addition of several \nnon-standard primitives, there need be no direct connection between the garbage-collector and memorization. \nAn experimental ver\u00ad sion of our disposable memo-functions library is available in a modification of \nHugs (appropriately called Huggies) at http: Ilrnvu. cse. ogi. edul-byronlmemol  References [1] ELLIOTT, \nC., AND HUDAK, P. Functional reactive animation. In Proceedings International Conference on Functional \nProgramming (Amsterdam, The Nether\u00adlands, June 1997). [2] HUGHES, R. J. M. Lazy memo-functions. In Proceedings \nConference on Functional Progmmming and Computer Architecture (1985), Springer-Verlag, pp. 129-146. [3] \nHUTTON, G., AND MEIJER, E. Monadic parser combi\u00adnat ors. Tech. Rep. NOTTCS-TR-96-4, Department of Computer \nScience, university of Nottingham, 1996. 310  \n\t\t\t", "proc_id": "258948", "abstract": "", "authors": [{"name": "Byron Cook", "author_profile_id": "81323489213", "affiliation": "Department of Computer Science and Engineering, Oregon Graduate Institute", "person_id": "PP40023782", "email_address": "", "orcid_id": ""}, {"name": "John Launchbury", "author_profile_id": "81100462557", "affiliation": "Department of Computer Science and Engineering, Oregon Graduate Institute", "person_id": "PP39043890", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/258948.258979", "year": "1997", "article_id": "258979", "conference": "ICFP", "title": "Disposable memo functions (extended abstract)", "url": "http://dl.acm.org/citation.cfm?id=258979"}