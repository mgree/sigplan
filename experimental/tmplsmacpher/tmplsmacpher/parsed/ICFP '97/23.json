{"article_publication_date": "08-01-1997", "fulltext": "\n Automatic management of operating-system resources Olin Shivers MIT AI Lab Cambridge, Massachusetts, \nUSA shivers@ai .mit. edu Abstract One of theattractivefeaturesof functionalprogramminglanguages is that \nthey provide automatic management of the store, in the form of garbage collection. However, the benefits \nof automatic resource managementcan be applied to other resources as well. Scsh, a systems-programmingdiafect \nof Scheme, provides auto\u00ad matic resource management for operating-systemsstructures,no\u00adtably processes, \nl/O channels, and signal events. This kind of au\u00adtomatic management extends the benefits of garbage collection \nmodularity, robustness, simplicity, and clarity-to new sets of ob\u00adjects in programming, and also gives \nus hints as to how operat\u00ading systems should be structured from the perspective of functional programming \nlanguages. 1 Introduction Functionalprogramminglanguageshaveprovided garbagecollec\u00adtion (GC) of user-aflocateddata \nstructuresfor decades [Wilson]. There are marrybenefits [o garbage collection. GC eliminates, at one \nstroke,severalclasses of run-timeerrors, chiefly those involv\u00ading dangling pointers and storage leaks. \nIt also simplifies source code by eliminating the storage-reclamation machinery from the application \nprogram. This makes programs simpler and clearer. Fi\u00adnally, GC promotes modularity-in systems that require \nexplicit storage management, a module that exports a data structure to clients must also provide some \nway to tell when client modules no longer require the data structure. Scsh is a dialect of Scheme [R4RS] \nthat is designed for systems programming [scsh, scsh-man]. As such, it provides complete in\u00adterfaces \nto the operating system. By far the most complex and diffi\u00adcult parts of the design involved providing \ninterfaces to the underly\u00ading OS resources that harmoniously integrated the OS functionality with the \nprogramming language. For a programming language like Scheme, this typicafly meant allowing for automatic \nmanagement of the exported resources. The design of the I/O channel interface, for example, required \nnine months and four redesigns before I was satisfied with it. As users gained experience with scsh, \ncertain classes of prob\u00adlem with the design began to show up. These problems were typ\u00adically fixed by \ntaking some operating-system resource, making it Permission to make digital lhard copy of part or all \nthis work for personal or classroom use is granted without fee provided that copies are not made or distributed \nfor profit or commercial advan\u00ad tage, the copyright notice, the title of tt)e publication and Its date \nappear, and notice is gwen ihat copying is by permission of ACM, Inc. To copy otherwise, to republish, \nto post on servers, or to redistribute to lists, requires pr!or specific permission and/or a fee ICFP \n97 Amsterdam, ND 0 1997 ACM 0-89791 -918 -1/97 /0006 . ..$ 3.50 abstract, and providing automatic management \nfor it. It was strik\u00ading how quickly serious systems use turned up these design flaws. In the end, the \nprinciple of providing the OS resources in a form that admitted automatic management turned out to be \nan important guiding heuristic in developing the system to its current state. In this paper, I would \nlike to describe the techniques employed and the lessons learned from this experience. Scsh provides \nautomatic management of three types of OS re\u00adsource: I/O channels, processes, and signal events. In the \nnext three sections of the paper, we 11examine in detail the interface scsh pro\u00advides for each of these \nthree types of resource. {Note Unix system calls}   2 Managing I/O ports Perhaps the most difficult \npart of the design of scsh was the inte\u00adgration of Scheme ports and Uttix file descriptors. Deafing with \nUnix file descriptors in a Scheme environment is difficult. In Unix, open files are part of the process \nstate, and are referenced by small integers called jile descriptors. Open file descriptors are the fun\u00addamental \nway I/O redirection are passed to subprocesses, since file descriptorsarepreservedacrosssystemcaflsthatcreate \nsub\u00adprocesses. Scheme, on the other hand, uses ports for specifying I/O sources. Ports are anonymous, \ngarbage-collected Scheme objects, not integers. When a port is collected, we can deallocate any un\u00adderlying \nOS resources on which it depended. By contrast, because file descriptors are just integers, it s impossible \nto garbage collect them in order to close file descriptor 3, you must prove that the process will never \nagain pass a 3 as a file descriptor to a system call doing I/0, and that it will never invoke a program \nthat will refer to file descriptor 3, This is difficult at best. [f a Scheme program only used Scheme \nports, and never di\u00adrectly used file descriptors, this would not be a problem. Many Scheme implementations \nprovide this kind of simple automatic clo\u00adsure of file descriptors on port GC. But Scheme code that does \nseri\u00adous systems programming in Unix must violate the abstraction and descend to the file-descriptor \nlevel in at least two circumstances: when interfacing to foreign code; when interfacing to a subprocess. \nThis causes problems. Suppose we have a Scheme port constructed on top of file descriptor 2. We intend \nto fork off a C program that will inherit this file descriptor. If we drop references to the port, the \ngarbage collector may prematurely close tile 2 before we exec the C program. Scshs Unix I/O interface \nis intended to address the problems that arise from the mismatch between ports and file descriptors. \nThe fundamentrd principle is that in scsh, ports are attached to open files, not to particular file descriptors. \nFor most Scheme l/O ports, the user is completely unaware which underlying tile descriptor has been aflocated \nfor that port. This means that the scsh rim-time sys\u00adtem is free to shuffle file descriptors around underneath \nthe ports with the dup system call should it become necessary to make a specific file descriptor available. \nThe scsh inn-time system keeps careful track of which f/O ports are completely abstract by associating \na revealed count with each port. If the revealed count is zero, then the port s underlying file descriptor \nhas not been exported to the user program. Ports created with the standard procedures such as open-input-file \nhave their revealed count set to zero. If the programmer uses the port-zf des procedure to expose a port \ns underlying tile descriptor, its revealed count is incremented. Once a port s tile descriptor has been \nre\u00advealed,itis theprogrammer sresponsibilityto managetheresource explicitly. The programmercan use the \nrelease-port-handle procedureto decrementtheport s revealed count when he no longer needs to know the \nfile descriptor. Not afl file descriptors are allocated by requests to make ports. Some are inherited \non process invocation via exec, and are simply parl of the global environment. Subprocesses may depend \nupon them, so if a port is later allocated for these file descriptors, it should be considered as a revealed \nport. For example, when a scsh process starts up, it creates ports on top of the standard file descrip\u00adtors \nO, 1, and 2 for the initial values of (current-input-port), (current-output-port). and (error-output-port). \nThese ports are initialised with revealed set to 1, so that stdin, stdout, and stderr are not closed \neven if the user drops the port. Keeping track of which ports have not had their file descriptors revealed \nallows the run-time system several important freedoms: When an unrevealed port becomes eligible for garbage \ncol\u00adlection, its underlying file descriptor can also be de-allocated with a close system cafl. If the \nScheme user doesn t know what file descriptor is associated with a given port, then he can t possibly \nretain so integer handle on the open file after dropping pointers to the port itself, so the garbage \ncollector is free to close the file. . For similar reasons, the file descriptor can be closed when the \nScheme process uses the exec system call to overlay itself with a new program. All current memory is \nbeing dropped, so the port structure itself is being deallocated. If no one knows the file descriptor \nassociated with the port, then the file descriptor is afso eligible for deallocation. . The run-time \nsystem is free to shift an unrevealed port from one file descriptor~d to a new one fd should the user \ns pro\u00adgram specifically request file descnptorfd for some purpose. This last freedom is an interesting \none, and addresses a long\u00adstanding problem with UNX system programming. Some programs need to perform \nI/O operations that explicitly allocate a specific file descriptor, e.g. (fork (A () (dup (dup (exec \nprrd-iport data-ip.rt encrypt 3) ; Read password O) ; Read plaintext ion-progrem) ) ) on on fd fd 3. \nO. lt might be the case that, unbeknownst to the programmer, Unix had afready aflocated file descriptor \n3 on a previous operation, per\u00adhaps when it allocated the pipe for the Scheme port data-iport. If this \nis the case, our (dup pud-iport 3) operation will clobber our data-iport. When our encryption program \nexecutes, it will try to read both password and data from the password source not what we wanted at all! \nHowever, if scsh knows that the original port built on top of file descriptor 3 is unrevealed, it is \nfree to shift this port to some new file descriptor with an internal (dup 3) operation, freeing up file \ndescriptor 3 to be allocated by the (dup pvd-iport 3) call. This is exactly what the scsh run-time system \ndoes-all system calls that aflocate specific file descriptors first check to see if there is an umevealed \nport already associated with the target descriptor. If there is, the port is first shifted to a new tile \ndescriptor with a dup call before performing the requested operation. Note that this is not a Scheme-specific \nproblem; it arises just as easily in C programs that manipulate file descriptors. Scsh solu\u00adtion is the \nfirst one known to myself that solves the problem. Scsh s port facility preserves the transparent close-on-collect \nproperty for tile ports that are used in straightforward ways, yet al\u00adlows access to the underlying Unix \nsubstrate without interference from the garbage collector. This is critical, since systems program\u00adming \nabsolutely requires access to the actuaf file descriptors, as their numerical values are a critical part \nof the inter-process inter\u00adface. Under normal circumstances, all this machinery just works be\u00adhind the \nscenes to keep things straightened out. The only time the user has to think about it is when he starts \naccessing file descriptors from ports, which he should afmost never have to do. If a user starts asking \nwhat file descriptors have been allocated to what ports, he has to take responsibility for managing this \ninformation.  3 Managing processes The Unix operating system represents processes with integer names \ncalled process ids or pids. A process is created by the fork system call, which returns the process id \nof the new process. A process can synchronise with a child process by applying the uait system cafl to \nthe child s process id. The parent process blocks until the child process exits, at which point the vait \nprocedure returns the childs exit status. Issues of resource management affect the definition of the \nwait procedure in an interesting way: The wait call is the mechanism whereby the OS reclaims the resources \nof the process named by the process id. After the wait call, the operating system is free to reuse the \nprocess id for a new process, and it is afso free to reclaim the space in the kernel s process table \nthat stores the process externally visible state. As a result, the parent must wait on the child process \nexactly once: . nwails < 1 If the process fails to wait on children, then they accumulate in the kernel \ns process table. The kernel may not reuse the process id for new processes, nor may it reclaim this space \nas long as the childs parentis afive, since the parent might at any point decide to perform a vait on \nthe child. Eventually, the space of process ids will fill up, or the process table will overflow, and \nthe operating system will be unable to create new processes. As a trivial example, consider the following \nsimple fragment of C code: while(1) if( !forko ) exito ; Although it consumes no resources asymptotically, \nit will eventually cause the process table to fill up with dead child processes, thus causing the kernel \nto be unable to create new processes. . nwaifs > 1 If the processwaitson achild morethanonce, allwaitsafter \nthe firstwill returnarterror-if we are lucky. An even worse failuremode lurksin storefor the unwary, \na classic dangling\u00adpointer bug. After the first wait on the process id, the kernel is free to allocate \nthe process id for a new process. It is pos\u00adsible that the original process id could be allocated for \na new child of the original parent, causing the further waits on the original child to return the later \nchilds exit status. There are two points we can draw from this problem.{Note Pre\u00adscient designers} First, \nthe UNX solution is not modular. A mod\u00adule of code that waits on a child process must know that no other \nmodule will wait on the child. This is exactly analogous to the modularity problems with explicit storage \nmanagement. Second, as in our previous I/O channel case, small integer names are a poor substitute for \nabstract data types, This is a les\u00adson that applies as much to operating-system resources as it does \nto user-level data structures. Because Unix uses sixteen-bit integers to name processes, the space is \nprone to overflow-an unnecessary failure mode, since the interface uses no interesting property of in\u00adtegers. \nIt also makes it impossible to apply automatic storage man\u00adagement directly to the exported representation. \nAs with the file descriptors we discussed earlier, it is impossible to garbage-collect objects named \nby integers. The problem of process-table overtlow is, unfortunately, a prob\u00adlem of practical import. \nThe original release of the scsh system used the standard Unix model to represent processes: integer \npro\u00adcess ids on which the programmer was required to wait exactly once. This led to modularity problems \nthat caused certain simple programs to overtlow the process table. The first bug report that led us to \nthis problem concerned captur\u00ading process output in scsh. Scsh contains a procedure run/port that forks \na child process and returns an input port connected to the childs standard output. This procedure can \nbe defined very simply: (define (run/port* thunk) (call-with-values pipe (A (r w) (fork (A () -> stdout \n(fd 1) in child process ~~e~lflwl (dup w 1))) (with-current-output\u00ad port * W1 thunk) ) ) ) r))) Reading \nfrom the returned port r will return whatever the child process prints otst. Another simple procedure, \nport-> string, takes an input port, and reads from it until it encounters end-of-tile, at which point \nit returns the accumulated data as a single string. The composition of these two procedures run/string* \n= port-> string o run/port* forks a child and returns its output as a string. Notice that the run/string* \nprocedure needs automatic storage management in order to reclaim two different OS resourms: the child \ns process id (which is not revealed by the rrsn/port* procedure), and the par\u00adent s end of the parentichild \nI/O pipe (which is not revealed by the run)string* procedure). A programmer had written a loop in a program \nthat created a time-stamp string on each pass through the loop. The time stamp was made by using the \nrun/string* procedure to capture the out\u00adput of the date program: (let loop () (let ( (ts (run/string* \n(A () (exec /bin/date ))))) ... ) (loop) ) Unfortunately,because theprogramnever waited for the dead \nchil\u00ad dren, they inexorably filled up the kernel s process table. After twenty or so iterations, the \nprogram would fail by being unable to fork new children. The programmer couldn t be advised to insert \na uait call into his code, since the actual process id was hidden down inside the run/string* procedure. \nHe couldn t simply wait for any child, since that might cause him to accidentally wait on a child pro\u00adcess \nupon which he intended to wait at a later time. Changing run/string* and run/port * to export the childs \nprocess id would complicate the interfaces, damage simple composability, and violate modularity. The \nsolution was to redesign scsh so that integer process ids were replaced with an abstract data structure, \nthe process objec~. Process objects are returned by the f ork procedure, passed to the wait procedure, \nand finally reclaimed by automatic garbage col\u00adlection. Now we are free to wait on a process zero, one, \nor more times: . nwaits < 1 A process object is garbage collected by the scsh run-time system after all \npointers to it me dropped and the child pro\u00adcess exits. The garbage collector is also free to perform \na wait system call on the dead child, causing it to be deallo\u00adcated from the kernel s process table. \n . nwaits > 1 The scsh run-time system caches the exit status of the child process within its process \nobject on the first wait. Subsequent waits use the cached value.  This is modular. Because a child process \nexit status is saved witbin the child s process object, the scsh run-time system is free to eagerly wait \non a process any time between the childs death and the first time the user requests it. This is called \nreaping the process, and it has two benefits: It frees up the childs entry in the kernel s process table. \nIt makes the process object eligible for GC. What we have really done is migrate an OS resource (process \ntable entries) from the kernel into the scsh process, which makes them eligible for automatic reclamation. \n 4 Managing external signals Our final example concerns handling the reception of external, asynchronous \nsignals in scsh programs.1 Handling signals in Unix implies constructing a concurrency model-asynchronous \nsignals are essentially a mechanism for notifying a process of the actions of an external agent, such \nas the user striking the interrupt charac\u00adter on his keyboard, or a modem line being dropped by a remote \nprogram. {Note Synchronous exceptions} It was an early design decision in scsh s concurrency model not \nto provide interrupts. Rather, scsh provides only serial threads. The interrupt-handler model was not \nprovided because the interrupt model has several problems. First, interrupts confound several dis\u00adtinct \ncomputational elements, e.g., concurrency, mutex, and com\u00admunication. It is better to factor these elements \ninto their individual components, allowing the programmer to use only those which are needed by the given \napplication. *Themechanisms described in this section m not available in the cunwntlyre\u00adleessd versionsof \nscsh. Second, the interrupt model doesn t parallelism it is funda\u00admentally a uniprocessor mechanism. \nBecause the main process is suspended while an interrupt handler runs, there is a mutex built in to the \nhandler. This means that if the program is executed on a paralleI processor, the system can t run the \nhandler in parallel with the main program-to do so might violate some assumption of mutex made by the \nprogrammer. Third, interrupt handlers are not modular. If one module of code installs a handler for an \ninterrupt, it will clobber the handler instafled by any other module. Global resources are always a po\u00adtential \nsource of conflict. Finally, there is the argument of economy of mechanism: the thread model functionally \ndominates the interrupt model, so it is superfluous to provide both mechanisms. In the scsh seriaf-thread \nmodel, if a program wishes to attend to some set of external signals, it blocks and waits for an occurrence \nof a signal. If it wishes to compute concurrent]y while attending to the external signals, it spawns \na sub-thread to wait for the signal and performs the concurrent computation itself. As a simple example, \nlet us suppose we wish to perform some computation while simul\u00adtaneously printing Ouch ! every time the \nuser strikes the interrupt key on his keyboard. We introduce a blocking operator (wait-signal signal-set) \n+ signal that causes a thread to block until a signal from the specified set occurs. Our application \nwould then contain the following code: ;;; The singleton set SIGINT: (clef ine ctl-c (signal-set signal/int) \n) (fork-thread (A () (let 100P () (rfalt-signal ctl-c) (display Ouch ! ) (loop) ))) ...pe~orrn main computation... \n In this model, internrpts are no longer necessary, interrupt han\u00addfers are no longer a global resource, \nand there is no spurious seriatisation or mutex implied between the handler and the main computation \nthey are completely concurrent. However, our ex\u00adample exposes a race condition in the design: only signals \nthat ar\u00adrive while the sub-thread is blocked waiting in its wait-signal call get caught. If a signal \namives while the handler thread is ac\u00adtively processing a prior signal, it will be dropped. We can fix \nthis in our concurrency model by introducing a new data type, the event, that represents a single occurrence \nof some signal. An event has two fiekfs: the Unix signal that occurred, and a pointer to the next event \nthat occurred. hat is, events are kept in a linked list in increasing-time order. The scsh run-time system \nkeeps track of the most recent event; whenever a signal is delivered to a scsh process, the run-time \nsystem catches the signal, constructs a new event structure for it, and links it onto the tail of the \nlist (fig. 1). Given this ordering, an event e provides an index into the time-line of signal events. \nNote that if no pointers to other events are retained by the user program, events are GC d away as they \noccur, as the scsh run-time system only retains a pointer to the most recent event, i.e., the end of \nthe event queue. This value is exported to user code by the most-recent-event procedure. Now we modify \nour wait-signal procedure to take a second argument, which is an event that serves as an index into the \nportion of the event queue in which we are interested: (vait-signal signal-setevent) + event This procedure \nis now defined to block until an event whose signal is a member of signal-set occurs-but only events \noccurring after Most recent event: r SIGINT SIGHUP - SIGINT -\u00ad + L Figure 1: The event queue the event \nparameter are eligible. The occurring event is returned as the value of the procedure call. The implementation \nis simple: uait -signal simply starts with event, and scans down the event chain searching for an event \nthat satisfies the signal-set argument. If it finds one, it returns it immediate y, without blocking. \nIf it reaches the tail of the chain without finding an acceptable event, the thread is blocked by the \nthread scheduler when the proper signal arrives, it will be made runnable agsin. Our previous example \ncan now be rewritten to use events to avoid the race condition: ;;; Catch all signals: (fork-thread (A \n() (let loop ((last (most-recent-event) )) (let ((event (Wait-signal ctl-c last))) (display Ouch ! ) \n(loop event) ))) ) If we wish to discard pending signals while processing a signal, we simply drop the \ntriggering event after handling it: --e Discard signals: ,,, pending (fork-thread (A () (let loop () \n(wait-signal ctl-c (most-recent-event)) (display Ouch! ) (loop))))) What our event mechanism does is \ngive an on-demand event\u00adbuffering policy. Because retairring apointer toan event prevents subsequent \nevents from being reclaimed by the GC, the system only retains asmanyevents asthe program requires. Thatis, \nthegarbage collector mediates the amount of signal queuing required by an ap\u00adplication. This signaf-handler \nmodel isnotwithout certain limitations. It can cause the system to retain large amounts of storage. If \na pro\u00adgram retains a pointer to an event that is never freed, then all sub\u00adsequent events will be retained \nby the system. This means that the storage consumption of the program is dependent upon the behaviourofextemal \nagents thesignrd generators. Hence this model is most Iikely not appropriate for systems where signafsoc\u00adcur \nat extremely high rates. We would not want, for instance, to have an event occur upon each rotation of \nthe computer s disk. However, for typical Unix programs, signal rates should below enough to make this \nmodel practical. This event model requires all events to be totally ordered. This could be a central \nbottleneck for a system with a large number of events occurnngat high rates inadistributed machhre. Again, \nfor simple Unix signals, it should not be a problem. 5 Conclusion We ve seen how the scsh dialect of \nScheme provides automatic re\u00adsource management for threedifferentoperating-systemresources. The techniques \nused to reflect these resources into the program\u00adming language are novel. With I/O channels, scsh provides \nmechanisms for breaking the abstraction in controlled ways that do not hinder the man\u00adagement of the \nsimple, abstract uses of the resource. This de\u00adsign is the first of which I am aware to provide both \nof these features, in any programming language. . Whh processes, scsh uses techniques to migrate process\u00ad(able \nentries into the scsh process to make them eligible for automatic storage management. Again, scsh s design \nis novel, the first to provide the benefits of automatic resource management to managing the OS s process \nresources. With signal events, scsh provides a fully interrupt-free con\u00adcurrency model, and allows the \nCC to mediate the amount of event queuing required by an application according to the dy\u00adnamic needs \nof the program. The facilities traditionally pro\u00advided by interrupt handlers in other programming languages \nare provided by an aftemative mechanism which is modular and prrrallelisable. While other operating-system \nand language designs have pro\u00advided interfaces to OS resources from advanced languages, such as the Spin \nproject s use of Modula-3 [Spin], or the Standard ML of New Jersey s interface to Posix [SMIJNJ], none \nof these systems have managed to exploit automatic storage management to manage the operating system \ns resources in this manner. Although we ve considered Scheme and three different Unix resources as our \nexamples, the ideas behind these examples are not specific to Scheme or Unix. Rather than use Scheme, \nwe could just as easily use rmymodem programming language with abstract data types and automatic resource \nmanagement, such as ML or Dy\u00adlan. Nor are we confined to the bounds of Unix; the problems and limitations \nof explicit resource management and non-abstract data types named by small integers are commonly found \nin today s op\u00aderating systems. The techniques presented here can be adapted to these systems as well. \nLooking beyond current operating systems, we might consider how the lessons learned in providing for \nautomatic management of Unix s resmtrces could be applied to the design of new operating systems. For \nexample, rather than resort to the specialised trickery we employed in the process-object case to migrate \nOS resources into user space to enable GC, we might consider how to make all the OS s resources directly \nvisible to automatic management poli\u00adcies. As another example, we are using the insights derived from \nscsh s signal-handler system to guide the design of an ML-based OS kernelbeing constructed at MIT. The \nprogramminglanguagedeterminestheprogrammer sview of theoperatingsystem. So in some sense, the language \nis the OS. The message we can take away is that the principles of modem programming languages can be \ndirectly applied to the view they provide of the machine and operating-system resources.  References \n[R4RS] J. Rees and W. Clinger (editors). The revised4 report on the algorithmic language Scheme. Lisp \nPointers IV(3): 1-55, July-September 1991. [scsh] Olin Shivers. A Scheme shell. To appear in the Jour\u00adnal \nof Lisp and Symbolic Computan on. (Also available as technical report TR-635, Laboratory for Computer \nScience, MIT and technical report TR-94-1O, Depart\u00adment of Computer Science, University of Hong Kong.) \n[scsh-man] Olin Shivers. The scsh manual. November 1995, scsh release 0,4. MIT Laboratory for Computer \nScience. (Also available as URL f tp: //uw-swiss. ai .mit. edu/pub/su/scsh/sc sh--ual. ps. ) [SMLINJ] \nThe Posix API for SMLJNJ is currently available only in a pre-release form; its manual also is not available. \nInterested parties may, however, contact Dr. John Reppy, AT&#38;T Laboratories, jhr@research. att. cont. \n[Spin] Wilson Hsieh, Marc Fiuczynski, Charles Garrett, Ste\u00adfan Savage, David Becker, and Brian Bershad. \nLan\u00adguage support for extensible operating systems. In Workshop on Compiler Support for System Software, \nFebruary 1996. (Also available as URL http: //wu. cs. Washington. edu/resesrch/pro jects/spin/ uwu/papers/WCS/lsnguage. \nps) [Wilson] Paul R. Wilson. Uniprocessor garbage collection tech\u00adniques. In IntemationaJ Workshop on \nMemory Man\u00adagement, St. Malo, France, September 1992. (The Pro\u00adceedings has been published as Springer-Verlag \nLec\u00adture Notes in Computer Science no. 637. llre individ\u00adual paper is also available as URL f tp: //f \ntp. cs. utexas. edu/pub/garbage/gcsurvey. ps.) Notes {Prescient designers} Beyond theperhapsgenerousobservationthattheUnix \nsystemde\u00adsignersappearto haveanticipatedthecurrentfashion in linear lan\u00adguages by several decades.  \n {Synchronous exceptions} Synchronous exceptions, such as floating-point overflow, or divide\u00adby-zero \ntraps, are fundamentally different entities from asyn\u00adchronous interrupts, and are better handled by \ndifferent linguistic mechanisms. Scsh provides interfaces to these exceptions using dynamically-scoped \nexception handlers. We will not consider them further.  {Unix system calls} Here is a brief overview \nof the Unix system calls relevant to sec\u00adtions 24. A disk file is opened by applying the open system \ncall to a file name, returning an integer file descriptor that names the open file. After using this \ninteger in other system calls to read and write the file, the file is closed by passing the integer to \nthe close system call. Closing a tile also frees the file descriptor for reuse. A valid open file descriptor \nfd can be replicated with the dup2 (f d, neu-f d) system call, which causes tile descriptor neu_fd to \nrefer to the same open file as fd. Similarly, the dup(fd) call allocates the smallest unused file descriptor, \ncausing it to refer to the same open tile as fd, and returns it. By convention, file descriptors O, \n1, and 2 are taken by most programs to be the standard input, standard output, and standard error sources \nand sinks. A child process is created with the f ork () system call, which duplicates the calling process. \nThe call returns in both the parent and child process. In the parent process, it returns the childs non\u00adzero \nprocess id; in the child, it returns zero. The child s process state, such as its open file descriptors, \nis a duplicate of the parent s. A process (typically a newly-forked child process) may overlay it\u00adself \nwith a new program by applying the exec system call to the file name of the program to be executed, e.g., \nexec ( /bin/is ). The exec cafl does not return; instead the process commences executing the named program \nin a fresh address space. Process state, such as open file descriptors, is preserved across calls to \nexec. A process terminates by cafling the exit (status) system call, where status is a small integer \ncode. The process s par\u00adent may synchronise with the process termination by calling the wait (child_pid) \nsystem call, which blocks until the child ter\u00adminates,returningthe child s exit status. The typical scenario \nfor using these primitives is for a program to call fork, then in the child process to arrange the childs \npro\u00adcess state as it wishes (e.g., setting the standard I/O file descriptors to any desired redirection), \nand then to invoke the desired child program with an exec call.  \n\t\t\t", "proc_id": "258948", "abstract": "One of the attractive features of functional programming languages is that they provide automatic management of the store, in the form of garbage collection. However, the benefits of automatic resource management can be applied to other resources as well. Scsh, a systems-programming dialect of Scheme, provides automatic resource management for operating-systems structures, notably processes, I/O channels, and signal events. This kind of automatic management extends the benefits of garbage collection---modularity, robustness, simplicity, and clarity---to new sets of objects in programming, and also gives us hints as to how operating systems should be structured from the perspective of functional programming languages.", "authors": [{"name": "Olin Shivers", "author_profile_id": "81100129912", "affiliation": "MIT AI Lab, Cambridge, Massachusetts", "person_id": "PP39062566", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/258948.258974", "year": "1997", "article_id": "258974", "conference": "ICFP", "title": "Automatic management of operating-system resources", "url": "http://dl.acm.org/citation.cfm?id=258974"}