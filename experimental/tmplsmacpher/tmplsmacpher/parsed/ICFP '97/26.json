{"article_publication_date": "08-01-1997", "fulltext": "\n A GUI on top of a functional language Kris Aerts, Karel De Vlaminck krisQcs.kuleuven. ac.be K. U. Leuven \n-Belgium Functional programming has proved to be an uttermost declarative methodology. It focuses on \nthe what and not on the how. Aleo 1/0 can be successfully expressed in FP, although rumour has it that \nnone of the functional 1/0 sys\u00adtems really work as elegant aa functional languages can. In the field \nof graphical user interfaces (GUI), impressive results have been achieved. Two different but major mile\u00adstones \nare the Fudgets library [1] in Haskell and the Clean 1/0 system [2]. Despite the fact that they are really \nsuccess\u00ad ful, both systems suffer from the fact that they are not aa declarative aa could be, because \nthey concentrate too much on the how. They require the programmer to first choose the actual form of \nthe interface. This describes how the action is triggered, not what action. Only after the programmer \nhas defined f,e. the button, can he attach functionality to it. Notice also that the application code \nmust be attached to the button spectically. This means that changing from a button to a menu item mav \nincorporate suite some work: .. . the definition and type of the attached function may change or may \nbe attached in a different way. This is too much focus on the how on the appearance of the widget. In \nSe\u00adlectors: going beyond user-interface widgets [3] Jeff Johnson describes how each element of a user \ninterface serves one of two purposes: either to select data, or to select commands, e.g. a pull down \nmenu can be used to start a command, such aa load and save, or also as a way ta limit the input possibtities \nfor the user. This is the point we are really in\u00adterested in: are we selecting commands or data (and \nwhat data)? Whether this ia dane through a pull dawn menu or a button list is irrelevant. The actual \nvieu al appearance is only part of the how. The observed division in data and command selectors is particularly \napplicable in imperative languages, because there a certain variable can be easily connected to a wid\u00adget. \nAnd when the widget is selected, the contents of that variable will be (destructively) updated. Despite \nthe fact that (pure) functional languages do not allaw such side effects. we believe that this can be \naccom\u00adplished by the use of state transition functians. The paster will present work in progress regarding \nthe implementation of such selectors using both Fudgets and Clean 1/0. Work Permission to make digital/harrl \ncopy of part or all this work for personal or classroom use is granted without fee provided that copies \nare not made or distributed for profit or commercial advan\u00ad tage, the copyright notice. the title of \nthe publication and its date appear, and notice is given that copying is by permission of ACM, Inc. To \ncopy otherwise, to republish, to post on servers, or to redistribute to lists, requires prior specific \npermission and/or a fee ICFP 97 Amsterdam, ND C) 1997 ACM 0-89791 -918 -1/97 /0006 . ..$3.50 to be performed \nlater on, presents further advances towards a substiantally mare declarative GUI system. All the current \nfunctional GUI systems adhere to the convential method in which a widget is defined and a call back function \nis added. This may be convenient for a low level definition, but ia nat appropriate for a real declarative \nsystem. The call back function can be considered aa the what that is what really happens, whereas the \nactual widget is the how how is the call back function activated. If we want to focus on the what, it \nis no more than logical to start with what should happen. Before we reveal aur solution, let s first \npoint out that user interface specialists seem ta amee that a GUI can be best implemented in an object \noriented syet em. They also agree that the underlying functionality may be implemented in a different \nsystem. So we will use an object oriented system for the GUI. The objects in the system will be those \nthat need to be visualized (text, spread sheet, web page, clock, ...). As usual in object oriented systems, \neach of the objects defines a number of methods. These methods are the functions that we may want to \napply to the visual abjects (e.g. for a clock: setting the hour, switching to daylight saving times, \nsetting digital or analog view, ...). As soon as we have developed all these methods, we have defined \nthe what. We may then choose those methods that should be present in the user interface. Not all methods \nhave to be present, but some may be present in different ways (button, slider, key short cut, . ..) Therefore \neach methad hea a list of visual method invokers : elements of the inter\u00adface (mostly visual) that may \ninvoke the method (the widget or the selector). They describe how the action ia triggered. The calculations \nneeded to perform the methods are writ\u00adten down in a functional language. To be able to use that functional \ncode. we will imdement a manaeer that executes the needed functions and ~ands over the r~sults to our \nob\u00adjects. The functional code will be used by the GUI, or to say it in a dtierent way: the GUI will be \nbuilt on top of the (existing) functional program.  References [1] Carleson, M., Hallgren, Th. Fudgets \n-A Graphical User Interface in a Lazy Functional Language. In Proceedings of FPCA, June 1993, pp.321-330. \n[2] Achten, P., Plaemeijer, R. The Ins and Outs of Clean 1/0, br JFP 5:1, 1995, pp. 81-110. [3] Johnson, \nJ. Selectors: Going Beyond User-Interface Wid\u00adgets. In CHI 92 Conference Proceedings, pp.273-279. 308 \n \n\t\t\t", "proc_id": "258948", "abstract": "", "authors": [{"name": "Kris Aerts", "author_profile_id": "81100298569", "affiliation": "K. U. Leuven, Belgium", "person_id": "P163061", "email_address": "", "orcid_id": ""}, {"name": "Karel De Vlaminck", "author_profile_id": "81100185730", "affiliation": "K. U. Leuven, Belgium", "person_id": "P156644", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/258948.258977", "year": "1997", "article_id": "258977", "conference": "ICFP", "title": "A GUI on top of a functional language (poster)", "url": "http://dl.acm.org/citation.cfm?id=258977"}