{"article_publication_date": "08-01-1997", "fulltext": "\n Foundations for the Implementation of Higher-Order Subtyping Karl Craryt Department of Computer Science \n Cornell University Abstract We show how to implement a calculus with higher-order subtyping and subkinding \nby replacing uses of implicit sub\u00adsumption with explicit coercions. To ensure th~ can be done, a polymorphic \nfunction ia adjusted to take, as an ad\u00additional argument, a proof that its type constructor argu\u00adment \nhas the desired kind. Such a proof is extracted from the derivation of a kinding judgement and may in \nturn re\u00adquire proof coercions, which are extracted from subkinding judgments. This technique is formalized \nas a type-directed translation from a calculus of higher-order subtyping to a subtyping-free calculus. \nThis translation generalizes an ex\u00adisting result for second-order subtyping calculi (such as F<). We \nahro d~cuss two interpretations of subtyping, one that views it as type inclusion and another that views \nit es the existence of a well-behaved coercion, and we show, by a type-theoretic construction, that our \ntranslation is the minimum consequence of shifting from the inclusion inter\u00adpretation to the coercion-existence \ninterpretation. This con\u00adstruction shows that the tm.nslation is the natural one, and it also provides \na framework for extending the translation to richer type systems. Finally, we show how the two inter\u00adpretations \ncan be reconciled in a common semantics. It is then easy to show the coherence of the translation relative \nto that semantics. 1 Introduction A subtyping calculus is characterized by a subtyping relation between \ntypes and the subsumption rule: if r] is a subtype of ~ (written T1 < ~) and a term e haa type rl, then \ne can be used es a member of type 72. This rule is at the heart of a subtyping calculus, but it poses \na problem for an implementer of the calculus because if rl and m have dtierent machine representations, \nthe compiler must ensure that a computation expecting an argument of type T2 is given that object in \nthe machine representation of T2, not that of rl. ~support for this research was provided by the Office \nOf Naval R* search through grant NOO014-92-J-1764 and by the National Science Foundation through grant \nCCR9244739. Permission to make digital/hard copy of part or all this work for personal or classroom use \nis granted without fee provided that copies are not made or diswibuted for profit or commercial advan\u00adtage, \nthe copyright notice, tl}e title of ttle publication and its date appear, and notice is given that copying \nis by permission of ACM, Inc. To copy otherwise, to republish, to post on servers, or to redistribute \nto lists, requires prior specific permission and/or a fee, ICFP 97 Amsterdam, ND @ 1997 ACM 0-89791 -918 \n-1/97 /0006 . ..$3.50 For example, a subtyping system might include the ax\u00adiom int < real, reflecting \nthe mathematical fact that every integer is also a real number. In such a system it would be legal to \nwrite the code sqrt (2 ) where the square root function, sqrt, ia a function on rerde. However, integers \nand reals (or, more properly, floats) have very diferent machine representations, so the compiler must \ncoerce 2 to be a float before passing it to sqrt. One approach would be to tag all objects with their \ntypes and perform the coercions at run-time. However, this is likely unacceptable due to the performance \npenalty it would entail. To have acceptable performance, the compiler must determine the proper coercions \nstatically, at compiletime. This can easily be done in an (explicitly typed) program\u00adming language with \nfirst-class functions, records, and even parametric polymorphism, but becomes complicated with the introduction \nof bounded quantification [12]. Consider the bounded polymorphic function AIY$T. Xc:a. j(z) where ~ has \ntype r ~ r . With a unknown, It ia not possible to determine the coercion for z from type a to type r. \nSince a s r, we know there exists a coercion from a to T, but we have no idea what it is. (The reader \nfamiliar with construc\u00adtive logic may notice a parallel between this dficulty and the problem of extracting \nprograms from non-constructive proofa; we will see later that indeed the solution results from making \nkinding proofa constructive.) Breazu-Tannen et aL [4], hereafter referred to as BCGS, showed how to solve \nthis problem in the second-order case for languages such as Fun [12] and F< [11, 10]. The basic idea \nia for bounded polymorphic func~ions to take the nec\u00adessarv coercion as an additional amument. In this \nDaDerwe show-how to extend this technique ~o languages wit~ ~her\u00adorder type constructors and a subkinding \nrelation, such as Quest [9], F; [8, 28] and AK [16]. Instead of taking a coer\u00adcion es an extra argument, \nas in BCGS, polymorphic func\u00adtions take a higher-order kinding proof. In the second-order caae, this \nkinding proof turns out to be a simple coercion, so the higher-order solution proves to be a generalization \nof the second-order one. We formalize the technique by giv\u00ading a translation of programs from a source \ncalculus into a subsumption-free target calculus. This tranelation ia used in the compiler for the KML \nprogramming language [15]. We also give a type-theoretic construction that explains the translation as \na construction of the source calculus that maintains constructivity while changing the interpretation \nof subtyping from one based on type inclusion to one based on the existence of semantics-preserving coercions. \nThis construction gives a deeper understanding of the translation than simply ss a syntactic device, \nit shows that our trans\u00adlation is in some sense the natural one, and it also gives a framework for extending \nthe translation to richer type sys\u00adtems. The two interpretations of subtyping seem to be dis\u00adparate, \nbut we show that they can be reconciled in a com\u00admon semantics by quotienting the equalities of types \nmodulo coercions. In such a semantics it is easy to show the trans\u00adlation s coherence. Aside from this \ncoherence result, the common semantics is also useful for the formal definition of programming languages: \nWhile a implementation-oriented definition would specify the insertion of coercions into pro\u00adgram code, \na type-theoretic definition would be cleaner if those coercions were left out. With a common semantics \navailable for each interpret ation of subtyping, a language designer can employ both styles of definition \nand show a formal equivalence between them. This paper is organized as follows: In Section 2 we briefly \npresent the source and target calculi of our translation and in Section 3 we give the translation itself. \nThese sections are a fairly straightforward extension of the BCGS result, and the emphasis there is on \nexposition for the reader less famil\u00adiar with the technique. The remaining sections contain the more \nnovel contributions of the paper: In Section 4 we show the type-theoretic construction motivating the \ntranslation; this section assumes some familiarity with constructive type theory and the propositions-as-t \nypes principle. In Section 5 we semantically reconcile the two subtyping interpreta\u00adtions and use this \nsemantics to give simple conditions under which the translation is coherent. Related work is discussed \nin Section 6 and brief concluding remarks appear in Section 7.  2 Source and Target Calculi The Source \nWe begin by giving the definition of our source calculus. In the literature, this calculus is closest \nto Quest [9], F: [8] and AK [16]. The syntax rules appear in Figure 1. The source consists of three syntattic \nclasses: kinds, type constructors (often referred to briefly as con\u00adstructors ) and terms. A fourth synt \nattic class, cent exts, is used to assign meaning to free variables in the typing rules. The term class \ncontains variables and the usual introduction and elimination forms for functions, polymorphic functions \nand records. The type constructor class contains the types of these terms (arrow, quantified and record \ntypes), a top type, a bottom type uotd, and a simply typed lambda cal\u00adculus (with pairs) over those types. \nThus, the class of type constructors contains types and higher-order type construc\u00adtors with which types \ncan be built. The kind clsss, which gives the types of type construc\u00adtors, is the most novel. It contains \nthe power kind [7] and dependent product and sum kinds. When r is a type, the power kind P(r) contains \nall types that are subtypes of r. Since every type is a subtype of Top, the kind of all types, Type, \nis defined as P( Top). The dependent product kind, l?a:fil .m, is the kind of abstractions from kind \nRI to kind K2 where a stands for the argument and may appear free in K2. Likewise, the dependent sum \nkind, ~a:~l .62, contains pairs of a ~1 and a ~z, where a stands for the left member and may appear free \nin K2. The typing rules for the source appear in Appendix A. The system cent tins judgments for typing, \nkinding, sub\u00adkinding (denoted ~) and well-formedness of contexts. By kinds fc ::= P(c) I IIa:Kl, K2 I \nxa:K1. /c2 constructors c ::= al Aa:K.clcl[c2]l (C1, C2) I T](c)l Tz(c) I c1 +C2 IVCI:K.CI {II :cl, \n. . ..%. cn}l Topluoid term9 e ::= z I Ar:c.el ele2 I Aa:~.e Ie[c]l {.! ~=e~,..., tn=en}lx~(e) contexts \nr::= olr[a:x]lr[z:c] Figure 1: Source Calculus Syntax Rules kinds K ::= T~pe IK1+ U2IKI x IC2 constructors \nc ::= a I Aa:lc. clCl[cz] I (C1, C2) [ ml(c) I Tz(c) I c1 + C2 Iva:fc. cl {tl:cl,...,ln: c~}lunitluoid \nterms e ::= z I k~ej :l~z IAa:x.e Ie[c] I .. .,tn=en}17rl(e)] o Iany=(e)  contezts r::= Olr[a:K]lr[z:c] \nFigure 2: Target Calculus Syntax Rules using the power kind, the kinding judgement does double duty \nto specify the subtyping relation. Since constructors appear within kinds, not W kinds are well-formed, \nso some judgement must specify well-formedness of kinds; reflexive subkinding judgments serve this purpose. \nThe Target The target calculus is essentially Girard s FW [19, 20], augmented with a few additional constructs. \nThe syntax rules appear in Figure 2. There are just a few differences between the source and target calculi, \nall stem\u00adming from the absence of subtyping: At the kind level the kind Type is now primitive, replacing \nthe power kind. With\u00adout power kinds, construct ors can no longer appear within kinds, rendering dependent \nkinds unnecessary, so those are replaced by non-dependent ones. At the type constructor level the type \nTop is removed and replaced by the trivial type tmifi also the uoid type is retained as an empty type \nbut is no longer considered a bottom type. At the term level, since subsumption can no longer be used \nto view an element of void as an element of any type, an explicit elimination form for void is added; \nany.(e) has type r whenever e has type void and T is a type. Finally, an introduction form o is included \nfor unit. The typing rules for the target appear in Appendix B and are similar to those for the source, \nexcept that subsumption is omitted, ss are all rules for subtyping and subkinding. 3 Eliminating Subsumption \nBefore launching into the translation itself, we first motivate it with a few (cent rived) examples. \nConsider the bounded polymorphic function Aa: P(intlist). Az:cr. sum z where sum has type intlist ~ \n:nt.This can be tramlated, as in BCGS, as: Am: Type. ki:a ~ intlist. Az:a. sum(ci z) Implicit in this \ntranslation is the interpretation of subtyping as coercion-existence: that a < intlist exactly when there \nis a coercion from a to Intlist. Thus, any coercion a ~ intlist is a proof that a has kind P(intlist). \nWe translate a polymorphic function to one taking a type constructor argument and a proof that the argument \nhss the proper kind. Now consider the higher-order bounded polymorphic func\u00adtion: Ay:(lIa:P(int). P(list[a])). \nAz:y[int]. sum z When a type constructor ~ has kind IIa:P(int).P(list[a]), it means that for any a, \nif a has kind P(int) then y applied to a has kind P(list[cr]). Under the coercion-existence subt yp\u00ading \ninterpretation, this in turn means that for any a, if there is a coercion a ~ int, then there is a coercion \n~[a] ~ list[a]. Thus, proofs that 7 has this kind have the polymorphic type Va: Type. (a ~ int) ~ y[a] \n~ Iist[a]. That proof, call it ~, is used to translate z from type y[int] to type Iist[int] by ap plying \nit first to int and then to the proof that int hss kind P(int) (which is the identity coercion on int \n~ int), resulting in ~[int] (Az: int. z) z. Hence the term is translated: A7: Type ~ Type. A~:(Vcr: Type.(w \n~ int) a 7[cv] ~ list[cr]). k:~[int]. sum (~[int] (Az:int.z) z) In each of these examples, the coercion \nused in subsump tion was extracted directly from the proof that some vari\u00adable has its given kind. In \ngeneral, of course, a coercion may involve the proofs of more than one variable (or none at all) and \nsome additional computation. This construction of a coercion is driven by the derivation of the subtyping \njudgement. The process of constructing a coercion can be under\u00adstood as follows: In the subsumption rule \nwe are given that rl ~ r2. This is shorthand for rl : P(rz), and, un\u00adder the coercion-existence interpretation, \nthis indicates the existence of a coercion from T1 to T2. A proof of this kind\u00ading relationship would \nbe such a coercion. The translation extracts such a proof from the derivation of r] < TZ in a manner \nreminiscent of the extraction of programs from con\u00adstructive proofs [3]. The additional proof variables \nshown above (e.g., &#38;, ~) ensure that proofs are available at the leaves of the derivation. As an \nsside, we can see here the potential for a computa\u00adtional inefficiency. Consider the polymorphic type \nV~:P( Top). iist[a] + list[a], which might be assigned to a list reversal function. Proofs that a has \nkind P( Top) are of the type a+ unit (we will translate Top as unit), so this type would be translated \nVa: Type. (a ~ unit) ~ Iist[a] ~ list[a]. However. all coercions a -+ unit are eaual, since unithas only \none (convergent ) element, so the kinding proof need not, in practice, be taken as an argument. A compiler \nbased upon this technique would suppress trivial proofs, ss does the KML compiler. Nevertheless, for \nthe sake of simplicity, we will not suppress trivial proofs in this paper. 3.1 The Type-Directed Translation \nWe are now ready to begin the formal details of the transla\u00adtion. A kind is translated by converting \npower kinds to Type and erasing dependency information, as shown in Figure 3 (where the translation of \n~ is denoted i?). rIcr:K].fc2 MY:K1.K2 P(c) Figure 3: Kind Translation Ia[ = cm Ik:tc.cl = Aa:iclcl \nIC,[C2]I = Ic,l [1C21] I(c,, c,)l = (IC,I, ]C21) I?r,(c)l = ~i(lC1) ICI -+C,l = Ic,l -Icz{yfxxcl = p(a,K)+ \nIcl VCY:K-. I{t, :C,,...,ln:cn}l = {4, : Ic,l,.. , ,em : Icn{} lTopl = unit Ivoidl = void Lp(c, P(c \n)) = c+ {C 1 lp(c, rfa:fcl.lm) = V(r:i ii. p(a, ICI)+ $o(c[cr],/0) $9( C, Z(KK1.K2) = p(ml(c),fcl)x $0(r2(c), \nK2[T, (c)/a]) Figure 4: Type Constructor Translation and Proof Types The translation of type constructors \nis defined mutually inductively with the definition of proof kinds. The trans\u00adlation of the constructor \nc is denoted IcI} and P(C, ~) de\u00adnotes the type of proofs that c (a target constructor) has source kind \nE (more precisely, that c is the translation of a saurce constructor of kind ~). As we saw in the exam\u00adples \nabove, polymorphic functions are translated by adding an additional proof argument and Top is translated \nto unit. The translation of type constructors and the definition of proof types appears in Figure 4, \nwhere a[b/z] denotes the capture-avoiding substitution of b for z in a. A context is translated by mapping \nthe kind and con\u00adstructor translations over its bindings and adding additional bindings to hold kinding \nproofs, as shown in Figure 5 (where the translation of r is denoted ~). For convenience we as\u00adsume that \na subset of the term variables have been set aside = Proof Variables and are designated &#38; for each \nconstructor variable a. Proposition 1 1. If r l-scontext then T I-T context. 2.lfr+sc:~then7Frlcl:F. \n With these translations in hand, we can now give the type-directed translation for terms. The system \nconsists of three judgments plus the I I-s context judgement of the a=e r[a: ~] = T[a:K][Ci:p(cr,IC)] \nr[z : ~] = T[z: Irl] Figure 5: Context Translation source. For each rule in the source, there is a corresponding \ntranslation rule, so the translation procedure is straightfor\u00adward. If r I-s e :r, then the term translation \njudgement computes et, the translation of e. To implement the sub\u00adsumption rule, the term translation \nuses another transla\u00adtion judgement to compute kinding proofix If r I-s c :K, the proof synthesis judgement \ncomputes p, a proof that c hss kind ~. When r 1-c1 S cz, the kinding proof computed is a coercion c1 \n~ C2that can be used by the subsumption rule. In addition to these two judgments, a third judgement is \nrequired to handle sub\u00adkinding subsumption: If r I-s tcI < tcz, the prooj coercion judgement rt-~l~~z~pc \ncomputes PC, a proof coercion from proofs of membership in xl to proofs of membership in K2. That is, \nif pis a proof that c has kind m, then PC[c] p is a proof that c has kind ~2 . Selected translation rules \nappear in Figure 6; the full sys\u00adtem is given in Appendix A. Following are two propositions expressing \nstatic properties of the translation. Proposition 2 says that translations always exist for well-formed \nterms (and kinding and subkinding judgments). Proposition 3 (taken with Proposition 1) says that the \ntranslation is type correct @n well-formed types and contexts), so it satisfies our implementational \ndemands. Although it seems clear that this translation is right , at this point we can only trust our \nintuition. In the next section we address this is\u00adsue a bit more carefully, and in Section 5 we give \none formal sense in which the translation is right: the source and target calculi can be given a common \nsemantics that is preserved by the translation. Proposition 2 f.rFse:riflrFe:r~etjor some et. 2.1 t-S \nc:~i#rl-c:~~pjor some p.  3. rt-5K1~K2 iff I F~l ~fc2+pcfor90mepc. Proposition 3 f.1~rFe:r+etthen~+7et:lrl. \n 2. lir~c:K+p then~F7p:p(lcl, K). 3.Ifrk~l~sz_*pcandrkS c: Icland~krp: w(lcl, fcl) then r +7-PC IICI]P: \n9( ICI, K2). 4 Type-Theoretic Implementation of Sub\u00adsumption In Section 3 we gave a translation that \nelirniiated sub\u00adsumption. This translation suffices for our implementation al needs, but it is possible \nthat another such translation could exist. Is there any reason to prefer this one over other pos\u00adsible \ntranslations? In this section we answer this question in the affirmative by giving a type-theoretic construction \nshowing that our translation is the natural one. The construction begins by building the kinds of our \nsource calculus in the type theory of Nuprl [13] (although any sufficiently rich type theory will suffice) \nusing the in\u00adclusionary interpretation of subtyping that rl s r2 exactly when all members of rl are members \nof ~. We then reinter\u00adpret subtyping using coercion-existence and make the neces\u00adsary changes to our \nconstruction to maintain constructivity. This second construction, when expressed in terms of our target \ncalculus, is isomorphic to the results of the transla\u00adtion. From this we conclude that the translation \ncorresponds to the minimal consequence of moving from inclusionary subt yping (the programmer s model) \nto coercion-existence subtyping (the machine s model), and it is in this sense that the translation is \nthe natural one. In the inclusionary interpretation, rl s ~ when every member of rl is a member of m. \nAnother way of saying this is that rl s rz exactly when the identity function (Az .z) is a function from \nr] to r2. With this in mind, we can define the power kind using a set type:l [P(r)] = {a: Type Ia ~ ~} \nThe set type {z : S I P[z]} contains all elements z of type S such that P[z] is true (i. e., inhabited), \nbut sup presses the computatiomd content in the proofs of P. Thus ifeE{z :SI P[z]}, then P[e] is true \n(inhabited), but the inhabitant of P[e] is inaccessible and cannot be used for computation. Additional \ndetails are available in Constable [14] and Constable et al. [13]. Under our current interpretation of \nsubtyping (rl ~. r2 iff h .Z E T1~ rz), the computational content of a subtypmg proposition is always \nthe identity function, which, although suppressed by the set type in the power kind definition, can trivially \nbe reconstructed. Thus there is no problem imple\u00admenting subsumption constructively: Suppose we are given \nthat rl has kind P(rz) and e has type rl; then we can con\u00adclude that Az.z E ~1 ~ TZand hence that e = \n(Xz. z)e c r2. Now suppose we wish to weaken our interpretation of subtyping to allow T1 <new r2 whenever \nthere is any semantics-preserving 2 function from rl to r2, not neces\u00adsarily the identity function. (We \nuse rl~ n to denote the type of semantics-preserving functions.) We might naively attempt to define the \npower kind in the same manner as before:  [P(r)]new = {a: Typela~,eW r}={a:Ty~la~r} (wrong) Unfortunately, \nthe computational content of a subtyp ing proposition is now non-trivial. When rl has kind P(m), there \nis no way of reconstructing the inaccessible witness of rl4 r2 (even though we know some such witness \nexists) and hence subsumption cannot be implemented construc\u00adtively. This is identical to the basic problem \nwith implem\u00adenting bounded quantification discussed in the introduc\u00adtion. To make subsumption constructive \nagain, we must use 1 In Nuprl IS type theory, ~pe is not a member of ~Pe, but belOn&#38; instead to a \nhigher universe, so this definition of power kinds will not strictly speaking be adequate to give a full \naccount of our source calculus s impredicative types. The techniques of Mendler [271 could extend this \nconstruction to impredicative types, but the extension is omitted here for the sake of simplicity, since \nthis detail does not affect our purposes in any significant way.  2 we leave open the definition Of \nsemantics-preserving functiOnsl although any proper definition would include the identity functions. \nThis gives greater flexibility to the construction. The reader both\u00adered by this may take all strict \ntotsl functions to be semantics pre\u00adserving. Other reasonable choices include homomorphisms, injective \nhomomorphisms, and linear-time functions. I [a:~]*e:c *et rt-cz:~+p   (VE)r _~jv~(~i~~7[J/a]+ et[Iczllp \n(v l)r 1-Aa:tc.e : Va:~.c > Aa:Z. ki:q(a, ~). et rl-e:cl+et r}cl:?(cz)+p (SU13SUME) r s contexl [a: \n~] c r rl-e:cz+ pet vAR)rl-a:~*a I t_Cl:P(C~) *pi (forl<isn) r+Sc,:Tvpe (for fz+l~i~m) n<m, m>O  ({} \ns) I i-{f; :c; i=  ]} : P({lt : Cj[ =l nl}) + AX:{li : lCi[[i= m]}. {l, = pi T/,( Z)[i=  ]} rt-c;: \nP(c1) *PI r t-Cz:P(cj) * P2 r ESc: Type (-+ <)  (uoid ~) r + void : P(c)+ kr:uoid. anvc(~) rF C1+C2: \np(cl+c~) + ~~:lcll+ lc21.p2 o~opl r [a:Kl]}C:K2~p r I-c1: rIa:K1.K2*pl r+ C2:Kl+. p2 (II E)(H I)r I-~a:K1.c \n: IICY:K1.K2 ~ Aa:~. Ari:P(~, KI). P r ~ c1[C2]:K2c2~*P1 C2 p2 (~ /a] *P2 1) rbCl:Kl*pl r I-C2;K2[c1r[CY: \nKI] ~S X2 kind r I-(C1, C2): mK1. K2 + (Pi, P2) r+c:K1a P rt_fCl~K2~pC rt-c1:qc2)~p (%I13KfND) (p 4r \nt_C:K2 + pC[[Cl]p r F P(cI) ~ P(c2) ~ Aa:Type. Ap :a~ CI. pOp Figure 6: Selected Translation Rules a \ndependent sum instead, which does not suppress compu\u00adtational content: [P(r)]new = Za:Type. a ~ r The \ninhabitants of this sum are pairs containing the type itself and the semantics-preserving function. With \nthis def\u00adinition of the power kind, subsumption can again be imple\u00admented constructively. Now consider \nthe polymorphic function Aa:P(r). e. Un\u00adder the new construction, this is interpreted Aa :[P(r)]. e \n= Aa :(Xa: Type. a ~ r). e S Aa:l ype. A&#38;:a ~ r. e [(a, &#38;)/cr ] where e is the interpretation \nof e. This, when stated in terms of our target calculus (where all coercions are taken to be semantics \npreserving), is precisely the result of the translation. If the construction is extended to higher kinds \nin the obvious manner and the reasonable restriction is made that type constructors may not depend upon \nkinding proofs (which cannot happen in our source or target calculi any\u00adway), then this correspondence \nholds at higher kinds as well. That is, for all valid kinds ~, ~~] is isomorphic to Xa:it. p(a, K).3 \nThus the polymorphic function Aa:x. e is interpreted AcY :[Kj.e = Aa :(Ea:it. p(a, K)). e ~ Acr:K.Ad: \nfp(a, K). e [(cr, ci)/a ] which again is precisely the result of the translation. 5 Reconciling Inclusion \nand Coercion-Existence To this point it may appear that the two interpretations of subtyping, inclusion \nand coercion-existence, are disparate S1nfwt an ~x~jnatjon of the type za:F. w(a, ~) ~d the tYPe [x] \nreveals that the former is essentially a phase-split [22] version of the latter. ones. In this section \nwe show that this need not be so, by giving a common semantics for the two interpretations. Since there \nis insufficient space in this paper to give a math\u00adematically rigorous presentation of this semantics, \nhere we simply outline the most salient points; a formal treatment appears in Crary [17]. We begin by \nsupposing that we are given a value\u00adrespecting partial equivalence relation (VPER, defined be\u00adlow) semantics \nbuilt over some evaluation function [21, 1, 2], and that we are given a set of coercions operating on \nthat semantics primitive types. We will then build a new VPER semantics that incorporates those coercions. \nA partial equivalence relation (PER) is a symmetric and transitive relation. If &#38; is a PER, its domain, \ndenoted Dom(~), is defined u the set of terms e such that e = e. Thus a PER is an equivalence relation \nover its domain. A PER is value-respecting if evaluation respects equivalence classes, that is s e~e \nandevvimpliese~o . e~e and evvimpliese v v where we write e U v if e evaluates to V.4 A VPER semantics \nassociates each type T with a VPER =T. The members of r are those terms in Dom(s, ), and equality on \nr is given by =7. The subtyping relationship stems from two sources: sub\u00adtyping on primitive types and \ntype constructors (e.g., int s real sad list[r] < tree [r]), and the induced subtyping rela\u00adtions over \nthe type constructors. Coeraons resulting from the latter do nothing of computational interest except \nap\u00adply primitive coercions resulting from the former [5], so we will give the construction of the new \nsemantics for primi\u00adtive types and allow its extension to type constructors to be interleaved with it. \nWe construct the new semantics by induction on the sub\u00adtyping order resulting from our set of coercions. \nLet u and 4The second clause dictates that a convergent expression shall not be equal to a divergent \nor stuck expression. The conventional def\u00adinition of value-respecting omits this requirement. r be primitive \ntypes and let ~ be a coercion a ~ r. Let ~r be the VPER for r under the old semantics and (invoking induction) \nlet ~~ be the VPER for u under the new seman\u00adtics. We assume that Dom(~r) and Dom(~~) are disjoint; if \nnecessary, this can be achieved by tagging each primitive type before we begin. The new VPER for r, =~, \nis the union of ~r and ~~ that condenses equivalence classes to respect the coercion $. Formally, ~~ \nis the least symmetric, transitive relation such that: Note that Dom(rx~) = Dom(~r) u Dom(~j). If there \nare additional types u with coercions a ~ T then this construc\u00adtion is iterated over those other coercions \nas well. To complete the new VPER semantics we must update the evaluation function to incorporate coercions \nin order for the VPERS of our semantics to indeed be value respecting; otherwise the evaluation of one \nterm could become stuck while that of an equivalent term did not. For instante, fol\u00adlowing the example \nin Section 1, suppose ~ is a coercion int ~ real and suppose the original evaluation system con\u00adtains \nthe rule: el # sqrt e2Jr rEIR elez JJ/7 Then the new evaluation system must add the rule: It remains \nto make a few observations about the new se\u00admantics: First, in the new semantics, coercions are identity \nfunctions, which reconciles the two interpretations of sub\u00adtyping. Second, our augmentation of the evaluation \nsystem amounts to adding run-time coercions, In that semantic context, the translation in this paper \ntransforms a program that might need run-time coercions to one that will not. Third, the new semantics \ndoes not collapse any equivalence classes that exist in the original semantics. This is easily shown \nfrom the fact that our coercion set forms a forest. If our coercion set were permitted to form a DAG \nthen it would be necessary to require that our primitive coercions be coherent among themselves [29]. \n5.1 Coherence Since the translation of a term depends upon the derivation of its typing judgement, it \nis possible for a term to have many difierent possible translations. If we wish our programming language \nto be portable (and do not wish to fix a particular typing strategy in the language definition), it is \nimportant that any two such translations be semantically equivalent. In the first-order case, without \npolymorphic functions, the above semantics gives us this result: Coercions are built entirely of primitive \ncoercions, and primitive coercions are identity functions in the semantics (or the extension of iden\u00adtity \nfunctions to higher kinds). Thus any coercion used in subsumption is an identity function, and hence \ncoherence, However, a complication appears in the presence of poly\u00admorphic functions. Consider the function \nALY<Top. Xc:cv. (z : Top). This has two different translations, depending upon whether the VAR or TOP \nSUB rule is used to show a< Top: . Aa:Type. A&#38;:a ~ unit. ,kc:a. &#38;x . Aa: Tgpe. Mi:w ~ unit. \nAZ:IY.(Az:a. o)z  These actually are equivalent, but that is only an artifact of the restricted type \nsystem in which we are presently work\u00ading. In a language with nontermination or computational effects, \n&#38; could be instantiated with any sort of pathologi\u00adcal function, which would make the two terms inequivalent. \nThis is the direct consequence of allowing an arbitrary argu\u00adment for the kinding proof. 5 (In the terminology \nof Section 4, the problem is that such functions are not semantics pre\u00adserving.) In practice, of course, \nkinding proofs are instantiated only by the compiler and never with this sort of pathological argument. \nTo get a formal coherence result, we must restrict proof argument types so that they include only the \nsort of arguments they will actually receive. With such a restriction in place, all proof arguments will \nbe identity functions, like the primitive coercions. Then, as in the first-order case, coercions used \nin subsumption will be identity functions, and again coherence results. The necessary restriction can \neasily be implemented syntactically by adding a type of coercions which can only be built with specified \ncombinators, as in the BCGS system of variant types. 6 Related Work In the seminal paper on subtyping \nas coercion-existence [4], BCGS developed the use of coercions to eliminate subsump\u00adtion in the second-order \ncase. Their focus was on making a wider array of semantic techniques available to model sub\u00adtyping calculi. \nTo that end, they proved a syntactic co\u00adherence result, leaving the semantics of the target calculus \nopen (except to the extent to which it was constrained by the equational theory). The translation presented \nin this pa\u00adper is the generalization of their translation to higher-order subtyping; in particular, the \ncoercions used in BCGS are a special case of the kinding proofs used in this paper. Curien and Ghelli \n[18] developed another technique for showing the syntactic coherence of a similar second-order translation \nby proof rewriting. Breazu-Tannen, Gunter and Scedrov [s] gave an operational semantics to a first-order \nspecial case (without polymorphism, bounded quantification or subtyp ing on primitive types) and showed \nthat the translation in that case did not observably affect the computation. Bruce and Longo [6] developed \na model of subtyping and bounded quantification that interprets types as PERs, but interprets an element \nof type r as an equivalence class of =7, not as a member of Dom(=~). Under this interpreta\u00adtion, equality \nin a type corresponds to equality in the model, in contrast to our semantics where equality in r corresponds \nto equivalence under E,; moreover, in the Bruce and Longo model the interpretation of a term depends \nupon the type 5BCGS, for their system without variant types, show coherence of a translation that permits \narbitrary arguments, but they are able to do this because they include the rule e : unit e=o which is \nquestionable in the presence of divergent expressions, and certainly unsound in the presence of effects. \nit is placed in. Thus, a member of a subtype is not (in the model) a member of the supertype, so coercions \nare re\u00adquired to interpret subtyping; this is handled in the model by a coherent translation. In some \nsense, then, the model of Bruce and Longo is the exact opposite of the semantics in Section 5: In this \npaper we begin with a set of coercions and build a PER semantics that permits subtyping by in\u00adclusion; \nBruce and Longo begin with a PER and subtyping by inclusion (and refinement) and with it build a model \nthat uses coercions. Also closely related to this work is the work of Jones on qualified types [24, 23], \nwhich are types required to obey some predicate. These predicates are used to implement type classes \nin the Gofer programming language [26]. As here, Jones implements qualified types using a translation \nmotivated by the propositions-as-types principle. This trans\u00adlation passes evidence terms anaJogous to \nthe kinding proofs of this paper. Jones shows SJSOthat the translation is co\u00adherent whenever terms have \nunique minimal types [23, 25]. Early work in this area was done by Reynolds [29], who used category theory \nto develop a framework for defining semantics for and showing the coherence of calculi with subt yping \nand overloaded operators. More recently, the se\u00admantics for the programming language Forsythe [31] inter\u00adpreted \nintersection types as a category-theoretic pullback, a non-s ynt ax-directed definition; this was proven \ncoherent in Reynolds [30]. 7 Summary and Conclusions We have given a translation of a higher-order subtyping \ncaJ-CUIUSinto subsumption-free calculus suitable for implemen\u00adtation by conventional means. Such a translation \nis necessi\u00adtated by changing the interpretation of subtyping from in\u00adclusion (the programmer s model) \nto coercion-existence (the machine s model). A type-theoretic construction shows that our translation \nis the minimal consequence of that shift in interpretation. Finally, we have reconciled the two interpre\u00adtations \nin a common semantics. Coherence relative to that semantics is easily shown. That ease is a consequence \nof the fact, revealed by the type-theoretic construction, that the transition does not actually change \nvery much. The typ~theoretic construction also gives a framework for working out generalizations to more \nexpressive type sys\u00adtems. In particular, the translation easily generalizes to the dependent record kinds \nof AK [16]. That generalized trans\u00adlation is put to practical use in the KML compiler [15]. We also claim, \nwithout elaboration, that the construction shows how to generalize the translation to Cardelli s formulation \nof F: with monotone kinds [8]. we also hope that the reconciliation of Section 5 can be used to manage \ncomplexity in formsJized mathematics. In informal mathematics, a structure in algebra or analysis is \noften used as a substructure of another, implicitly using iso\u00admorphism. These isomorphisms must be included \nexplicitly in formalized mathematics, and lead to considerable clutter. We hope that a construction as \nin Section 5 can be used to hide such coercions of isomorphism. References [1] Stuart Allen. A non-type-theoretic \ndefinition of Martin\u00adL6f s types. In Second IEEE Symposium oj Logic in Computer Science, pages 215-221, \nIthaca, New York, June 1987. [2] Stuart Allen. A Non-Type-Theoretic Semantics for Type-Theoretic Language. \nPhD thesis, Department of Computer Science, Cornell University, Ithaca, New York, 1987. [3] Joseph L. \nBates and Robert L. Constable. Proofs ss programs. ACM Transactions on Programming Lan\u00adguages and Systems, \n7(1):113-136, January 1985. [4] VSJ Breazu-Tannen, Thierry Coquand, Carl A, Gunter, and Andre Scedrov. \nInherit ante as implicit coercion. ~n~ormation and Computation, 93:172-221, 1991. [5] VSJ Breazu-Tannen, \nCarl A. Gunter, and Andre Scr+ drov. Computing with coercions. In 1990 ACM Con\u00adference on Lisp and Functional \nProgmmmtng, pages 44\u00ad60, 1990. [6] Kim B. Bruce and Giuseppe Longo. A modest model of records, inheritance, \nand bounded quantification. In\u00adformation and Computation, 87:196-240, 1991. [7] Luca Cardelli. Structural \nsubtyping and the notion of power type. In Fifteenth ACM SIGA C T-SIGPLAN Symposium on Principles oj \nProgramming Languages, pages 70-79, San Diego, January 1988. [8] Luca Cardelli. Notes about F:,. Unpublished \nManuscript, 1990. [9] Luca Cardelli. Typeful programming. In Formal De\u00adscription oj Programming concepts. \nSpringer-Verlag, 1991. [10] Luca Cardelli. An implementation of F<,. SRC Re\u00adsearch Report 97, Digit sJ \nEquipment Corporation, Sys\u00adtems Research Center, February 1993. [11] Luca Cardelli, Simone Martini, John \nC. Mitchell, and Andre Scedrov. An extension of system F with sub\u00adtyping. In Theoretical Aspects of Computer \nSoftware 1991, volume 526 of Lecture Notes in Computer Sci\u00adence, pages 750 770, Sendai, Japan, 1991. \nSpringer-Verlag. [12] Luca Cardelli and Peter Wegner. On understanding types, data abstraction, and polymorphism. \nComputing Surueys, 17(4):471-522, December 1985. [13] R.L. Constable, S.F. Allen, H.M. Brorrdey, W.R. \nCleaveland, J.F. Cremer, R.W. Harper, D.J. Howe, T.B. Knoblock, N.P. Mendler, P. Panangaden, J.T. Sasaki, \nand S.F. Smith. Implementing Mathematics with the Nuprl Prooj Development System. Prentice-Hall, 1986. \n [14] Robert L. Constable. Constructive mathematics ss a programming logic I: Some principles of theory. \nIn Topics in the Theory of Computation, volume 24 of Annals oj Discrete Mathematics, pages 21-37. Elsevier, \n1985. Selected papers of the International Conference on Foundations of Computation Theory 1983. [15] \nKarl Crary. KML Reference Manual. Department of Computer Science, Cornell University, 1996. [16] [17] \n[18] [19] [20] [21] [22] [23] [24] [25] [26] [27] [28] [29] Karl Crary. A unified framework for modules \nand ob\u00adjects and its application to programming language de\u00adsign. Technical report, Department of Computer \nSci\u00adence, Cornell University, 1996. Karl Crary. Semantic reconciliation of subtyping by in\u00adclusion and \ncoercion. Technical report, Department of Computer Science, Cornell University, 1997. Forthcom\u00ading. Pierre-Louis \nCurien and Giorgio Ghelli. Coherence of subsumption. In Fifteenth Colloquium on Trees in Al\u00adgebra and \nProgramming, volume 431 of Lecture Notes in Computer Science, pages 132 146. Springer-Verlag, 1990. Jean-Yves \nGirard. Une extension de l interpretation de Giidel A l analyse, et son application i l 61imination de \ncoupures clans l analyse et la th~orie des types. In J. E. Fenstad, editor, Proceedings of the Second \nScandi\u00adnavian Logic Symposium, pages 63 92. North-Holland Publishing Co., 1971. Jean-Yves Girard. Interpretation \nfonctioneile et elimination des coupures de l arithm6tique d ordre suprfrieur. PhD thesis, Universit4 \nParis VII, 1972. Robert Harper. Constructing type systems over an op erationaJ semantics. Journal of \nSymbolic Computation,  14:71-84, 1992. Robert Harper, John C. Mitchell, and Eugenio Moggi. Higher-order \nmodules and the phase distinction. In Seventeenth ACM SIGACT-SIGPLAN Symposium on Principles oj Programming \nLanguages, pages 341-354, San Francisco, January 1990. Mark P. Jones. Qualified Types: Theory and Practice. \nPhD thesis, Oxford University Computing Laboratory, July 1992. Mark P. Jones. A theory of qualified types. \nIn Fourth European Symposium on Programming, volume 582 of Lecture Notes in Computer Science, Rennes, \nFrance, 1992. Springer-Verlag. Mark P. Jones. Coherence for qualified types. Re\u00adsearch Report YALE U/ \nDCS/RR-989, Yale University, Department of Computer Science, September 1993. Mark P. Jones. The implementation \nof the Gofer functional programming system. Research Report YALEU/DCS/RR-1030, Yale University, Department \nof Computer Science, May 1994. Paul Francis Mendler. Inductive Definition in Type Theory. PhD thesis, \nDepartment of Computer Science, Cornell University, Ithaca, New York, September 1987. Benjamin Pierce \nand Martin Steffen. Higher-order sub\u00adtyping. Theoretical C omputer Science, 1997. To appear. Available \naa University of Edinburgh technical report ECS-LFCS-94280 and Universitat Erlangen-Niirnberg Interner \nBericht IMMD7-01/94. John C. Reynolds. Using category theory to design im\u00adplicit conversions and generic \noperators. In Semantics-Directed Compiler Genemtion, volume 94 of Lecture Notes in computer Science, \npages 211 258. Springer-Verlag, 1980. [30] John C. Reynolds. The coherence of languages with intersection \ntypes. In Theoretical Aspects of Computer Software 1991, volume 526 of Lectuw Notes in Com\u00ad puter Science, \npages 675 700, Sendai, Japan, 1991. Springer-Verlag. [31] John C. Reynolds. Design of the programming \nlanguage Forsythe. Technical Report CNfU-CS-94146, Carnegie Mellon University, School of Computer Science, \nJune 1996. A Source and Translation Rules Since there is a one-to-one correspondence between rules in \nthe source calculus and translation rules, we present the two simultaneously in the interest of brevity. \nWhat follow are the translation rules. For any translation rule, the corre\u00adsponding rule in the source \ncalculus is obtained by dropping the extract %-e from each judgement with an extract in the rule. The \ncontext formation judgments have no extract and thus are considered as judgments in the source cslcu\u00adlus \nwitbout modification. Moreover, some translation rules ignore the extracts of some antecedent judgments \n(usu\u00adally because those extracts are trivial); such judgments are stated in source calculus form, without \nthe ignored extracts. Also, the definition of ~q-equivalence is completely standard and is omitted (also \nin Appendix B). A.1 Judgement Forms c1 =pq C2 c1 and C2 are ~q-equivalent r~context 1 is a valid context \nrt-K1~K2+pc KI, K2 are valid kinds and KI is a subkind of K2 (with proof coercion pc) rt-c:K+p c had \nkind K (with proof p) rl-e:c~e, e has type c (with translation et) A.2 Abbreviations Type ~f T( Top) \nr 1-K kind =f r~K~K rFc1~c2~p ~f r~cl:qc2)+p leta=cand z:c =eine Af (Jz:c . e [c/a]) e A.3 Context \nFormation (NULLCTX) . 1-context rl-K kind ~~r (KINDCTX) r[a : K]1-context r+c: Type ~gr (TYPECTX)r[z \n: c] 1-context A.4 Kind Formation and Subkinding  rt-K1~K2~pc rk~2AK3dpc r 1-M s K3+. Aa:fi. Jp:p(a, \nm). pc [a] (PC [cY]p) (TRANS)  r~c1<c2*p r 1-P(c1)s P(c2) * Aa:Type. AP :CY+ cl. ,kc:a. p(p Z) (Pow) \nA.5 Kinding (TYPEVAR) I [a:Kl]t-c:x2*p r t-Aa:K1.c : IIa:K1.K2 + Aa:fi. M:p(a, K1).P (PIINTRO)   r \nt-c1 : lIa:K1.x2 * r~c2:K1+P2 P1 r I-CI[C2]:+ P] [[C21]P2 K2[C2/a] (PIELIM) r[a :Kl] ~ C[a]: K2 * p \na~c I !-c: Ifa:K1.K2 e Aa:iii. A&#38;p(cr, Kl).p (PIETA)  r~cl:~l+pl rKC2 : K2[cl/a] * P2 I [cr : .KI] \n1-IC2 kind r 1-(C1, C2) : Za:m.K2 * (Pi, p2) (SIGMAINTRO) rl-c:za:~l,lcz+p (SIGMAELIM1) r~Zl(C) :Kl ~Xl(p) \n I kc:Ea:fcl. ic2 +-p (SIGMAELIM2) r~ if2(c): K2[7?I (C)/a] ~ T2(p)  r~xl(c):~l+pl r t-X2(C):~217r1(c)/~] \n+ P2 I [a : K1] F K2 kind r t-c: z~:K1.62 + (Pi, P2) (SIGMAETA) I 1-C1: Type rbcz:~w ( ARROW) r i-c1+C2 \n: Type * h:lc1 ~ C21.0 r[a:K]t-c: Type (QUANT) r 1-Va:K.C: Type + Az:IVOX.CI.O r t-context (ToP) r 1-Top \n: Type +. ,lx:unit.o r 1-context (VOID) r 1-void : Type + ,lx:void.o rsc:K1aP r+KlSK2*pC (%JFJKIND) \nr~ C: K2 ~pC[\\Cl]p A.6 Subtyping 1?t-CI : Type r F C2 : r Rc1s C2* Type Az:cl.z c1=@qC2 r 1-e : Va:K. \nCl * et r t\u00ade [cz] : Cl[cZ/a] rkc2:K+p * et [Ic21]P (QUANTELIM) (REFLEX)  rt-K2<61*pc r[a:K2]+c1<c2*p \nr h vff:i$l.cl< VLY:K2. + C2  Af:(va:iii.q(lY,/c*)+ Icll). Acr:~. A&#38;p(cr, tc2). P(f [~] (PC[~] \n~)) (QUANTSUB) ri-cl~c~*pt (for lSi Sn) I +c, :Type (forn+l~i <m) n<m m>O r~ {ti : Ci[i=l  l} < {fi \n: C[[i=l n]} * At:{ti : lCil[i=* m] }. {ti = pi 7rt,(Z)[i=* ]} (RECORDSUB)  r I-c: P(c ) (TOPSUB) \n r t-c < Top-Ar:lcl.o Note: The TOPSUB rule does not enlarge the set of prov\u00adable judgments in the source \ncslculus, so it could, strictly speaking, be omitted. However, it allows smaller proofs and extracts, \nso it is still useful in a practical system. rl-c: Type (VOIDSU13) r 1-void < c~ h:void. anyc(x) A.7 \nTyping r i-context z:c~r (VAR) rt-z:c~z 1 [z:cl]t-e:c2 *et (ARROWINTRO) r 1-Az:cl.e :c1 + C2 * Az:lcll.et \n171-e1:c1+c2*et1 rl-e2:c1*et2 rt-elez : C2+-etletz  (ARROWELIM) I?[a:x]Fe:c+et r E Aci:~.e : Vcr:E.c \n+ Aa:E. ki:~(a, IC).et (QUANTINTRO) r+e:{fl: cl,...,l~:c~}+et ~<i<n r 1-7rz, (e) : Ci * rft, (et) ... \n.. (RECORDELIM) rl-e:cl *et rt-clgcz+p (SUBTYPE)   171-e: c2 *pet B Target Rules B.1 Judgement Forms \nc1 =,g~ C 2 c1 and C2 are ~q-equivalent 171-context r is a valid context r~c:K c had kind ~ 171-e:c e \nhas type c B.2 Context Formation (NULLCTX) . 1-context r 1-context ~gr (KINDCTX) r[a : ~] 1-context \n 171-c: Type Xgr (TYPECTX)  r[z : C]1-context B.3 Kinding (TYPEVAR)  r[a:K1JFc:62 (PIINTRO) r t_kt$l.c: \n~1+ t$2  r~cl:~l +62 rbc2:K1 (PIELIM)  r t-Cl[cz]:S2 B.4 Typing r + context rt-cl:~l rkc2 :&#38;2 \n~:cgr (vAR) (SIGMAINTRO) rt-z:c  r~(cl, cz):~l XK2 I [z:cl]t-e:cz (ARROWINTRO)  ri-c:K1XK2 ~=12 (SIGMAELIMI) \nr~ Az:cl.e : Cl +C2 r 1-Ti(C) : fc, ri-e1:c1+c2 rt-ez:cl r FCl: Type r 1-C2 : Type (ARROWELIM) (ARROW) \nrl-e1e2 :CZ r~cl+cz:~yp~ (QUANTWTRO) r[a : K]1-c: Type (QUANT) r 1-VCY:K.C: Type r~e : V~:K.cl rt-cz:ti \n(QUANTELIM) r 1-context r 1-C, : Type forl<i~n r 1-e [C2]:C1[C2/CI] rk{tl:c l,.. .,ln:cn}:hpe  (RECORD) \nr 1-context J71-el:c, forl~i~nr 1-context (UNIT) rl-{ll=el ,.. .,ln=en} :{ll:cl, ln:cn}:cn} r 1-unit \n: Type (RECORDINTRO) r +context (Voro) r 1-void: Type 17i-e:{t 1: cl,. ..,ln:cn} 1< i < n (RECORDELIM) \nr 1-rf, (e) : Ci r 1-context (UNITINTRO) rt-o:tmit ri-e: void l?l-C: Type (VOIDELIM) r 1-anyc(e) : \nc rl-e:cl r 1-cz: Type r~Cl =Pn C2 rl-e:cz (EQUAL)  \n\t\t\t", "proc_id": "258948", "abstract": "We show how to implement a calculus with higher-order subtyping and subkinding by replacing uses of implicit subsumption with explicit coercions. To ensure this can be done, a polymorphic function is adjusted to take, as an additional argument, a proof that its type constructor argument has the desired kind. Such a proof is extracted from the derivation of a kinding judgement and may in turn require proof coercions, which are extracted from subkinding judgements. This technique is formalized as a type-directed translation from a calculus of higher-order subtyping to a subtyping-free calculus. This translation generalizes an existing result for second-order subtyping calculi (such as <i>F</i> &amp;le;).We also discuss two interpretations of subtyping, one that views it as type inclusion and another that views it is the existence of a well-behaved coercion, and we show, by a type-theoretic construction, that our translation is the minimum consequence of shifting from the inclusion interpretation to the coercion-existence interpretation. This construction shows that the translation is the natural one, and it also provides a framework for extending the translation to richer type systems. Finally, we show how the two interpretations can be reconciled in a common semantics. It is then easy to show the coherence of the translation relative to that semantics.", "authors": [{"name": "Karl Crary", "author_profile_id": "81100253026", "affiliation": "Department of Computer Science, Cornell University", "person_id": "P157139", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/258948.258961", "year": "1997", "article_id": "258961", "conference": "ICFP", "title": "Foundations for the implementation of higher-order subtyping", "url": "http://dl.acm.org/citation.cfm?id=258961"}