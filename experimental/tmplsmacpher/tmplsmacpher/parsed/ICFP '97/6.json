{"article_publication_date": "08-01-1997", "fulltext": "\n Statically Checkable Pattern Abstractions Manuel Fahndrich John Boyland ~omputer Science Division Computer \nScience Department Department of Electrical Engineering and Computer Science Carnegie Mellon University \nUniversity of California, Berkeley 5000 Forbes Avenue Berkeley, CA 94720-1776 Pittsburgh, PA 15213-3891 \nAbstract Pattern abstractions increase the expressiveness of pattern matthing, enabling the programmer \nto describe a broader class of regular forests with patterns. Furthermore, pat\u00adtern abstractions support \ncode reuse and code factoring, features that facilitate maintenance and evolution of code. Past research \non pattern abstractions has generally ignored the aspect of compile-time checks for exhaustiveness and \nre\u00addundancy. In this paper we propose a class of expressive patterns that admits these compile-time checks. \n Introduction Patterns promote well-structured and readable code by com\u00adbining matching and binding \nin a single synt attic picture. Furthermore, patterns permit important sanity checks on case statements \nto be performed at compile time. The two commonly used checks verify that a set of patterns is edmus\u00adtive, \nthat is, any value of the appropriate type is matched by some pattern, and detect whether any pattern \nis redundant, that is, it matches only values already matched by textually preceding patterns. There \nare however three major shortcomings with the simple patterns found in languages like ML. First, these \npat\u00adterns are very restricted in terms of the sets of trees (forests) that they can describe. A pattern \ncompares only a syntac\u00adtically fixed number of imtial nodes of each tree. Second, patterns cannot be \nused with abstract data types. Third, patterns cannot be named and reused. All problems hamper program \ndevelopment, mamtenance, and evolution. A number of proposals have addressed the first prob\u00adlem [8, 2, \n6, 12], but witbout addressing the second one. Wadler s triews[14] elegantly solve the second problem. \nHow\u00adever, whether something constitutes a view can in general not be checked by the compiler. Recently \na very general solution to all three problems has been proposed by Palao Gostanza et al [11]. However, \ntheir patterns do not admit compile-time checking. In this paper we propose a new class of expressive \npat\u00adterns that solve problems one and three. Patterns in this class can be modeled by finite-state tree \nrecognizes. Hence, Permission to make digital/hard copy of part or all this work for personal or classroom \nuse is granted without fee provided that copies are not made or distributed for profit or commercial \nadvan\u00adtage, the copyright notice, the title of the publication and its date appear, and notice is given \nthat copying is by permission of ACM, Inc. To copy otherwise, to republish. to post on servers, or to \nredistribute to lists, requires prior specific permission and/or a fee ICFP 97 Amsterdam, ND @ 1997 \nACM 0-89791-918 1/97/0006,.. $3.50 static checking reduces to the problem of containment be\u00adtween tree \nrecognizes, a property which is decidable [7]. A forthcoming technical report will address problem two \non integrating our patterns with abstract datatypes. The paper is organized as follows. Section 2 motivates \nour approach with examples and identifies two syntactic re\u00adstrictions that are sufficient to guarantee \nthat patterns cor\u00adrespond to finite state tree recognizes. Section 3 defines the syntax and semantics \nof patterns. Section 4 describes a translation of our patterns to a simpler canonical form. Construction \nof tree recognizes for canonical patterns is straight-forward. Section 5 describes this construction, \nand how the result can be used to check for exhaustion and re\u00addundancy. Section 6 discusses a source \ntranslation of canon\u00adical patterns to Standard ML patterns. Finally, Section 7 describes related work \nand Section 8 contains our conclu\u00adsions. 2 Motivation Naming of constants and functions is a fundamental \nfeature in any programming language. The two main benefits of naming are ~actoring, in which a concept \nis expressed in a single place, and encapsulation, in which a concept is im\u00adplemented separately from \nits uses. Functional languages, such as ML, support naming of values but not naming of patterns. In this \nsection, we argue the benefits of named patterns for the purpose of factoring and encapsulation, and \nmotivate our extensions to pat tems: alternation, recursion, and node creation. Consider a datatype to \nrepresent forestsl: datatype forest = Node of { label : int, left : forest, right : forest } I Union \nof forest list where empty forests are represent ed as an empty union: val empty = Union [1 ML permits \ndatatype constructors (such as Union) to be used in patterns, but does not permit values (such as empty) \nto be used as patterns. Thus the fact that empty forests are represented using empty unions is explicit \neverywhere pattern matching is used. If the forest datatype is later I For the sake of concreteness we \nwill use ML syntax and terminol\u00adogy throughout the paper. But our results should carry over nat raily \nto other call-by-value functional Ianguagea. changed by adding an explicit Empty constructor, all pat\u00adterns \ninvolving Union may need to bechanged as well. On the other hand, suppose one can define a pattern abstraction \nsuch as: pat Empty = Union [1; If this abstraction is used in patterns wherever one wishes to match the \nempty forest, it istrivial toaccommodate the rep\u00adresentation change by changing only the pattern definition. \nPattern abstractions thus enable factoring. In functional languages, we can not only name simple values, \nbut also functions. Similarly, we need the power of pattern abstractions with parameters. Consider adatatype \nmodeling types in Oberon 2, which has both fixed size arrays (with a constant integer bound) and open \narrays (with a runtime bound): datatype Type = . . I FixedArray of int * Type I OpenArray of Type; Large \nparts of a compiler will treat the two array types the same, but may need the respective element types. \nRather than having both cases wherever arrays are matched, one can use a single pattern Array, which \nis defined with two  alternatives: pat Array(elemtype) = FixedArray(.,elemtype) I Openlmray(elemtype) \n Alternative patterns are already provided in some versions of SML/NJ. We call them simply or-patterns. \nIn order to be well-formed, each alternative must bind the same set of pattern variables (elemtype in \nthis case). When a pattern abstraction is used in a pattern, it is applied to actual parameter patterns. \nWe call such uses pattern applications or pattern calls, or simply calls. The function dhneneions given \nbelow uses the pattern Array to bind the variable ty to the element type of any array type, no matter \nwhat kind of array it is, fixed or open. fun dimensions (Array (ty)) = dimensions (ty)+l I dimensions \n-= O; One can think of a pattern application as being replaced by the body of the named pattern with \nthe actual parameter patterns substituted for the formals. For simple patterns such as Array, this intuition \nis accurate, modulo renaming of bound variables. The next example illustrates the use of recursive pat\u00ad \nterns. Consider adatatype forjoinliats: datatype jlist = None [ Single of int I Append of jlist * jlist \n and consider writing a pattern that matches two-element join lists. Before we show a solution to this \nproblem, con\u00adsider the much simpler problem: howcan the set of jlist s representing empty hats be characterized? \nOf course None is empty, but so is the appending of two empty jlist s. This intuition can be translated \ninto the following pattern abstract ion: pat Nil = None I Append(Nil,Nil) This pattern abstraction is \nrecursive since it includes calls to itself. Recursive patterns can match arbitrarily mauy nodes in a \ntree. Using Nil we can define: pat One(x) = Single x I Append(One(x), Nil) I Append@ll,One(x))  Here \nwe have an example of a recursive pattern abstraction with an argument. It matches any jlist with exactly \none Single node in it, and binds xto the element of that node. Using Nil and One, we can write Pair so \nthat it handles any jlist with exactly two elements: pat Pair(x,y) = Append(Palr(x, y), Nil) I Append(One(x), \nOne(y)) I Append(Nil,Pair( x,y))  Thus a pair is always represented by an Append node and the twoelements \nareeither inthetirst subtree, spread between both subtrees, or are both in the second subtree. Our third \npattern extension node creation is moti\u00advated by the complement to the Nil pattern, namely a pat\u00adtern \nCons that matches the first element ofa jlist and also binds a variable to a j list holding the rest \nof the elements. The difficulty is that there may be no node in the structure being matched that represents \nthe rest of the elements. For example, in the tree Append(Append(Single 1, Single 2), Single 3) there \nisnosubtree holding exactly 2 and3. More trivially, the value Single 1 contains no empty list to be bound \nto the rest variable. To solve this dilemma, we introduce a limited form of expressions into patterns, \nwhich permit bindings to be augmented with newly created nodes. We can now define cons as follows: pat \nCons(x,l) = Single x where 1 = None I Append(Nil, Cons(x,l)) I Append(Cons(x,ll) ,12) where 1 = Append(ll \n,12) The first alternative matches a Single node and binds 1 (the rest variable) to a newly constructed \nempty jlist. The second alternative handles the case when all of the elements occur in the right subtree, \nin which case a simple recursive call is used. The third alternative matches Append nodes with at least \none element in the left subtree. Here 1 must be bound toa jlist holding the rest of the elements from \ntheleft subtree (available through recursion) andall of the elements of the right subtree. The jlist \nis constructed using Append.  2.1 Restrictions The syntax as we have outlined in this section permits \noverly powerful patterns. Forinstance, Pedro Palao Gostanza has shown in private communication that the \nhalting problem for llmingmachine scanbereduced to checking whether a set of (unrestricted) patterns \nis exhaustive. If we restrict patterns to match recognizable forests, compih%imechecks are decidable. \nRecognizable jorests are defined to be the forests for which there exist finite-state bottom-up tree \nrec\u00adognizes [7]. Below we give examples of two classes of pat\u00adterns that match non-recognizable forests. \nIt turns out that if we syntactically restrict our patterns to avoid these classes, then we can always \nconstruct finite tree recognizes for them, which in turn enables the desired compile-time checks. An \nexample of the first class of patterns to avoid is Cnt defined by datatype X= Aof XI Bof XIC of XID \npat Cnt(x) = C(x) I A(Cnt(B(x))) The pattern Cnt (. ) matches the set of trees of the form An (C (Bn \n(_) ) ), which is not recognizable by a finite tree recognize. The characterizing syntactic property \nof this pattern is that the recursive call to cnt contains a non-trivial argument pattern B(x). Next \nconsider the pattern PouerOf 2 defined by datatype Nat =ZIS of Nat pat Even(half) = Z where half = Z \nI S(S(Even(x))) where half = S(x) pat PouerOf2 = S(Z) I Even(PouerOf2)  The pattern PoverOf2 only matches \ntrees of the form s (2), where n is a power of 2. This set cannot be recognized by a finite tree recognize. \nHere the characterizing property is the recursive call to PouerOf2 as a pattern argument to Even. In \ngeneral, the two syntactic properties that may cause patterns tomatch non-recognizable forests are: 1. \nNon-atomic (non-variable, non-wild card) pattern ar\u00adguments to recursive calls. 2. Recursion nested \nwithin acallto a named pattern.  We can always construct finite tree recognizes for patterns that adhere \nto these restrictions (Sections 4and 5). Weaker restrictions are possible but would have made this paper \nmore complex. 3 Patterns In this section, we describe the syntax and semantics of pat\u00adterns. The static \nsemantics places our extensions in the context of the ML type system. 3.1 Syntax Figure 1 shows the abstract \nsyntax for patterns, and pat\u00ad tern definitions. ML patterns are extended with pattern definitions, or-patterns, \npattern calls, node creation, and general as-patterns. We assume a set of variable names xE Vars and \na set of pattern names f E Fimcs. Construc\u00ad tors c c Cons have fixed arity and type typeoj (c). Nullary \nconstructors and patterns are written co and f () respec\u00ad tively, afthough in examples, we drop the extra \n(). Node creation is limited to constructor applications and variables. Pattern declarations are sets \nof mutuafly recursive pattern definitions. Syntactic restrictions on patterns are listed below: 1. Patterns \nmust be linear (no variable may be bound twice). 2. Each alternative in an or-pattern must bind the \nsame set of variables. 3. Variable bindings must be used exactly once, i.e., ev\u00adery variable occurring \nin a pattern is either a formaf parameter or used exactly once in a where-clause to create a new node. \nIJnused variables must be replaced by -.  (atomic pattern) a ::= _lx (pattern) p ::= a (constructor) \nI C(pl,... ,pn) (pattern call) I f(Pl,... )Pn) (as-pattern) I PI as P2 (or-pattern) I P11P2 (where clause) \nIp where Z1 = S1 endzz=sz . . . (creation) s .. z I c (Sl, ....sn) (declaration) dec ::= ... [ pat fl($ll,... \n,zln,) = pl end ~z(zzl,... ,Z2n2) = P2 Figure 1: The syntax of patterns. 4. Arguments to recursive calls \nmust be atomic (Avoids the Cnt example of Section 2). 5. No recursive calls in pattern arguments (Avoids \nthe PowerOf2 example). 6. No cycles in the top-level call graph among mutually recursive patterns. \n Restrictions 1 and 2 are standard. Restriction 3 makes the technical materiaf in the rest of the paper \nsimpler, and re\u00adstrictions 4 and 5 guarantee that we can form finite tree recognizes for each pattern. \nRestriction 6 disallows non\u00adterminating patterns, such as pat Bottom(x) = Bottom(x) Non-terminating \npatterns cause non-termination in the im\u00adplementation as well as in the translation given in the next \nsection. They furthermore break the correspondence be\u00adtween the operational meaning of a patterns and \nits tree recognize. 3.2 Static Semantics We give a set of typing rules that extend ML s type sys\u00adtem \n[10] for patterns and declarations. The type rules use type environments TE which are finite maps from \nvariables Vars to types r, and pattern environments F, which are fi\u00adnite maps from pattern names Rmcs \nto types r. We write the union of two environments with disjoint domains as TE1 + TEz. Figure 2 contains \nthree kinda of judgments: . F I-Pp : (TE, ~) states that in pattern environment F, p matches valuss of \ntype T and binds each variable x in the domain of TE to a value of type TE(z). . TE l-. s :(r, U) states \nthat in environment TE, the expression s haa type r and uses variables U. . F +d d :F states that declaration \nd extenda envkon\u00adment F to F .  Most rules are strtight-forward, hence we only describe the ~ERE] rule. \nIntuitively, a pattern p where ~a = si matches whatever p matches, and introduces extra bindings for \nxi, defined by si. The constructs si must use variable bindings produced by p. We therefore type s, in \nthe type en\u00advironment TE produced by p. Because we want each binding to be used only once for simplicity, \nwe remove the bindings Ui used by s, from TE in the resulting environment (written TE\\u, ).  3.3 Dynamic \nSemantics In Section 6, we define the semantics with a source-level translation to Standard ML. Here \nwe informally contrast two possible match-semantics, local match vs. global match. Local and global match \ndiffer in the way pattern parameters are handled. We illustrate the distinction by means of an example. \nConsider a pattern call Elem(3) to some pattern abstraction Elem. With local match seman\u00ad tics, lIlem(3) \nmatches a tree t, if Elem(x) matchea t,and 3 matches z. Global match on the other hand expands the pattern \ndefinition of Elem, by substituting the actual ar\u00adgument pattern 3 for the formal. The resulting pattern \nis then used to match t. The two approaches yield different results if or-patterns are involved at some \nlevel. If the defi\u00adnition of Elem is as below, then Elem(x) can match the tree t = Append(Single (2) \n, Single (3)) in two different ways. pat Elem(x) = Single (x) I Append(Elem(x) ,-) I Append(_,Elem(x)) \n If the second alternative is used, then x is bound to 2, if the third isused, xisboundto3. Since wedesire \na deterministic semantics, we follow the tradition of ML by choosing the first match with alternatives \nbeing considered left to right. Now consider again the local match vs. global match dis\u00adtinction. Using \nlocal match, Elem(3) does not match t,since Elem(x) commits to the second branch without consider\u00ading \nthe pattern argument 3. Using global match, Elem(3) mat ches t, since we expand the alternatives with \nthe argu\u00adment pat tern. In our example we obtain Single(3) I Append(Elern(3), _) I Append(_,Elem(3)) \n and it is now clear that the second branch cannot match (after one more expansion). Global match only \ncommits to a branch if it matches the input tree w.r.t. the given argument patterns. Local matching enables \na simple implementation with\u00adout backtracking. This choice of semantics is used in Palao Gostanza et \nal s active destructors [11]. However, as we de\u00adscribe in Sections 4 and 6, the more powerful global \nmatch semantics can also be efficiently implemented. Hence, since global match is more expressive and \nmay be more intuitive, we chose global match semantics for our patterns. 4 Canonical Patterns This section \ndeecribea the crux of the paper, a translation from the patterns we defined in Section 3 to a simpler \ncanon\u00adical form. A pattern is canonical if the pattern arguments in any pattern cafl are variables. In \nterms of the grammar in Figure 1, the only change is in the production for pattern FFp_:(o, T) [WILD] \n F1-pz:([zt-+T], T) [PVAR] FRPpi:(TEt, ~i) dom(Z Ei) rldom(TEj) = 0 forall i #j E 1.. .n TE=TEJ+.. +TE. \ntypeof(c) =TI + ... +rn +T [PCON] FI-PC @l,... ,Pn) : (ff E,T) F+Ppi : (TE,, r,) dom(TE,) fldom( TEj) \n=0 forall i# j E l... n TE=TE1+.. +TE. F(f)=~l+...+~~~~ [PAPP] FEPf(pl,. . . ,p~): (TE, r) F1-Ppl:(TEl, \n~) F1-pp2:(TE2, T) dom(TEl ) n dom( TE~) =0 [AS] F1-Ppl as pZ : (TEJ + TE~, r) [OR] F1-Pp:(TE, r) 7 \nE KS S, : (ril Ui) ~a @ dom(!7 E) Ui Q dom(TE) xi#xj, Uifl Uj=O foralli#j TE = TE\\u, . ..\\u. [WHERE] \n F1-Pp where Xl = S1 ... and z~ ~ Sn: (TE [za I+ ~i],7) [SVAR] TEl_B si : (7,, U,) U1fl Uj=O foralli#j \nE1... n U=ulu... uun [SCON] TEFsc(~l,.. .,~n):(r, U) Ti= Til+...+Tin~+ Ti(l F = F [fi 1+ Ti] F l-ppi \n: (TEi, ~io) dom(TEi) = {~i~ ,.. . ,zini)  TEt(Zik)=Tti ~=l)..~;~i [PAT]Fl_d... fa(Xil $... s~ini) \n~~i -d . . . :F Figure 2: Type rules for patterns. calls, which becomes pat Cons3ConsY_(y) = Append(Nil \n() ,Cons3ConsY_(y) ) (pattern call) [f(zl,... ,zn) I Append(Cons3ConsY-(y), -) Non-atomic pattern arguments \naccount for nearly all the complexity (and the expressiveness) of the patterns. As we will see in Sections \n5 and 6, construction of tree au\u00adtomata and implementation of canonical patterns is almost trivial. Moreover, \nthe distinction between local and global mat ch semantics d~cussed in Section 3.3 becomes irrelevant \nfor canonicaf patterns. All the potential backtracking, and matching against node creations is handled \nby the transla\u00adtion to canonicaf patterns. To reduce a pattern to canonical form, we essentially perform \nthe expansion described w.r.t. the global match se\u00admantics, i.e. substitution of argument patterns for \nformals in the body of pattern definitions. Due to recursion, the expansion may however be infinite. \nThe following observa\u00adtion gives some intuition for why a finite partial expansion is sufficient: In \nthe infinite expansion of a given pattern, every pattern abstraction is only called with finitely many \ndistinct argument patterns. This fact follows immediately from our syntactic restriction that argument \npatterns to recursive calls must be atomic. Thus in the expansion, argument patterns to recursive calls \nare either _, or sub-patterns of the original pattern argu\u00adments. The possibilityy of sub-patterns comes \nhorn vhere\u00adpatterns, since they bind new variables to sub-patterns of arguments. Another way to look \nat the expansion is as a specializa\u00adtion of pattern abstractions to all contexts they appear in. Again, \nthe syntactic restrictions guarantee that there are only finitely many specializations. The canonicalization \nworks as follows: for each pattern cafl with non-atomic argument patterns, we create a new pattern definition \nthat takes as arguments the free variables of the originaf argument list. The body of the new definition \nis obtained by substitution of the arguments into the body of the pattern definition being called. Finally, \nthe original call is replaced with a call to the new pattern definition with arguments being the free \nvariables of the original pattern arguments. As an example, the pattern call Cons (3 ,Cons (y, -) ) is \nreplaced by a call to a specialized version of cons, namely Cons3ConsY_ (y). Assuming the definition \nof cons given ear\u00adlier, Figure 3 shows the specializations involved. Besides recursion, specialization \nis complicated by vhere\u00adpatterns. To handle node creation, we essentially partially ewduate the pattern \nmatching against created nodes. This evaluation is possible due to the absence of recursion in ar\u00adgument \npatterns and cycles in top-level call graphs (restric\u00adtions 5 and 6 in Section 3.1). Due to the matching \nperformed during translation, fail patterns (which never match) may be introduced. Fail patterns can \nalways be removed from canonical patterns, but it is simpler to deal with them dur\u00ading the automata construction \nand the source translation to ML. A cache of ongoing substitutions is used to limit the number of specializations \nto a finite number. The details of the translation are given in Appendix A. While the worst case expansion \nof patterns during the translation is exponen\u00adtial, we believe the algorithm will prove tractable for \nnormal cases. For example, patterns using chains of cons patterns yield cubic-size canonical patterns. \nI Append(Cons3Nil () ,ConsY_(y) ) end Cons3Nilo = Single (3) I Append(Nil () ,Cons3Nilo ) I Append(Cons3Nilo \n,Nilo ) and ConsY_(y) = Single(y) I Append(Nilo, ConsY_(y)) I Append(ConsY_(y ),-) Figure3: Canonicalizationof \nCons(3, Cons(y, _)). 5 From Patterns to Tree Automata In this section, weshowhow to construct non-deterministic \nbottom-up tree automata for patterns. Theproblemsofex\u00adhaustion and redundancy then reduce to deciding \ninclusion between regular tree languages. 5.1 Definitions A non-deterministic bottom-up tree automaton \nis a triple A= (A,6, F) where A isasetofstates, 6is asetof transitions of the forms c(al, ... a~) + a, \n(al, az) ~ a or al ~ az, where c is an n-ary constructor from Cons, and al, . . . ,a., aarestates from \nA. The set F ~Ais the set of accepting states. Anepsdon transitional ~azstates that theautomaton canenterstateaz \nif it can enter state al. An and transition (al, az ) ~ a states that the automaton can enter state a \nif it can enter both al and az. In order to capture the semantics of these transitions, we define the \nclosure of a set of states Aw.r.t. transitions, (denoted closurea(A)) as the smallest set satis~ing a \nE closure # a E A v a E closure Aa ~ uEdV a , a E closures(A) A(a , a ) ~ aEb Given a tree tover Cons, \na run of A is an assignment of subsets of A to each subtree in t (written A(t)) defined in a bottom-up \nfashion: A(c(tl ,.. . ,tn)) = closureJ({a I al E A(i?i), c(al,... , an) + a c 6}). A run ia successful \nif one of the states at the root of the tree tis in F (A(t) n F # 0). A accepts all trees for which there \nis a successful run. An automaton A = (A,$ F) is deterministic if 6 contains no e or A transitions and \nmoreover, when it contains two transitions for the same constructor c(al,.., an) -+ a E J and c(al,.., \nan) -a E6 thena= a . Inarun ofade\u00adterministic automaton, all the sets A(t) have at most one element. \nWe include c and A transitions in our automata to make the construction simpler. Such transitions can \nalways be eliminated. Appendix B shows how a nondeterministic automaton can be transformed into a deterministic \nautoma\u00adton. 5.2 Construction Given a canonical pattern p, we show how to construct a tree-automaton AP \nrecognizing the same forest as p. Since canonical pattern definitions are only called with pattern variables, \nparameters are only used for binding and do not fiect pattern matching. As a result, we can ignore param\u00adeters \nduring the automata construction. Let UP be a (unique) state for every sub-pattern p in the program, \nand a~ be a (unique) state for every pattern definition f. Furthermore, let U7 be a (unique) state for \nevery type 7 used in the program. Let A* be the complete set of all these states. In the following discussion, \nwe assume each ~ is a monomorphic datatype. We believe our results can be extended to polymorphic types. \nWe deiine a transition set J among the states A*. First, for each datatype ~ declared as follows: datatype \nr = CI of TII*. . .*Tlml I . . . I Crl of T l*.. .* fn7nm we add edges {cl(a~,,,.. .,arlml )+a~,... ,%(arn,,...,a~m~m) \n+a~} Next for every pattern definition pat f (. . ) = p, we add the edge aP ~ af. Then for each kind \nof pattern p of inferred type T, we add additional edges: arA aP x ar&#38; aP fail C(pl,. . . ,pn) C(apl \n>.. . ,aPm)+aP f(zl,... ,zn) afS aP PI = p2 (aPl, up, ) 3 ap PI I p2 aPl 4 aP,aP2 ~ aP p where . aP,A \nap The automaton for any pattern p, AP is (A , J , {aP}). Of course, many of the states and edges will \nbe irrelevant to a run which must eventually contain aP. One can define A; to be those states from which \naP is reachable, and d; to be 6 restricted to this set and then define AP as (A;, 15~,{a,}). 5.3 Checking \nExhaustion and Redundancy We can decide exhaustiveness of a set of patterns @i) of type r by forming \nthe union of the automata APi, and veri\u00adfying that (A;, V, {a~}) C Ui APi. For redundancy, one can test \nwhether AP ~ IJi APi holds, in which case p is redun\u00addant w .r.t. (pi). With the transformation to deterministic \nbottom-up tree automata in Appendix B, these relations are all decidable [7]. The complexity of the decision \nprocedure is worst-case exponential in the sise of the canonical patterns (due to the subset construction \nfor deterministic automata). 6 Implementation Each pattern abstraction ~ is implemented as a function \nj that takes a tree and either returns bindings for the param\u00adeters, or raises a reserved exception Fail. \nFor a pattern definition of the form pat j(zl,. ... zn) = p we generate a function definition of the \nform fun ~(node) = TP[(p, node)] (zI ,.. .,z~) fun Cons3ConsY_ (node) = (case node of Append(vl ,v2) \n=> (let () = Nil(vl) in let (y) = Cons3ConsY-(v2) in (y)) I -=> raise Fail) handle Fail => (case node \nof Append(vl ,v2) => (let (y) = Cons3ConsY-(vI) in (y)) I _ => raise Fail) handle Fail => (case node \nof Append(vi, v2) => (let () = Cons3Nil(vl) in let (y) = ConsY-(v2) in (y)) I -=> raise Fail) Figure \n4: Translation of Cons3ConsY_ from a pattern to a function. As an example, Figure 4 shows how the pattern \ndefinition Cons3ConsY from Section 4 is translated. Figure 5 gives the translation of patterns to Standard \nML. The translation function TP for patterns takes a list of pattern-variable pairs and code to be generated \nif the match succeeds. A pair (p, v)represents amatchofv against p. At runtime, v will be bound to the \ntree to be matched against p. In the translation for or-patterns we catch the Fail exception and try \nthe next alternative. To implement an expression of the form case e of pl =>el  I ; => e. we rewrite \nit to letv=ein (TP [(Ju, v)] el) handle Fail > (~P[(pz,u)]e2) h~dle Fail => (7P[(p~, v)]e. ) handle \nFail => raise Match The simple translation given here doea not make use of the many sophisticated techniques \nfor improving the effi\u00adciency of pattern-matching, such as jump tables, or Ses\u00adtoft s technique for using \ninformation known from previous matches [13]. Adapting these techniques to handle recur\u00ad sive pattern \ndefinitions is one interesting area for further research. 7 Related Work A class of work extends Hoffman \nand O Donnell s [9] sim\u00adple matchers with complex operations such as the subtree operator of lhfola [8], \nthe vertical iterator of Dora [2, 6], and Queinnec and Geffroy s recursive tree operator [12]. All these \nextensions match recognizable forests, but do not ad\u00address pattern abstraction per se. r, : (p x Vars) \n + Ezp + Exp Tpoe = e ~[(_, v):r]e = TPre Tp [(z, v) : r]e = TPr[let z = v in e] 7P [(fail, v) : r]e \n= [raise Fail] TP[(c(pl, . ,pn), v):r]e = [case v Ofc(vl, . . . ,Vn) => ~[(pl, vl) :... : (pm,vm):r]e \n1\u00ad => raise Fail] (vi b~h) 7p[(f(ZI, . . . ,h), v):~]e = [let (ZI,... ,Xn) = ~(v) in (TPr e)] (v, fresh) \n7P[(PI as p2, v) :r]e = T [(Pl, v):(P2, v):r]e ~P[(Pl I P2, v):r]e = [Gl [(Pi, v) : r]e) handle Fail \n > (~ [(pz,v) : r] e)] Tp[(pwherezl SI and . . . and% = s~, v):r]e = Tp[(p, v):r] [let m =1S1 and . \n. . and z= = S* in e] Figure 5: Translation of canonicalized patterna to Standard ML. Aitken and Reppy \ns abstract value constructors (AVC) [1] form a subclws of our named patterns without alternation, recursion \nor node creation. But unlike our patterns, some AVCS can also be used as values. The authors do not address \nstatic checking of AVCS. Wader s views [14] define alternative, free data types that are isomorphic to \nthe underlying representation. The isomorphism is described using in and out functions with general computation. \nViews naturally admit exhaustiveness and redundancy checks, but whether something constitutes a view \ncan in general not be checked by the compiler. In contrast to our patterns, views can also be used ss \nvalues. Burton and Cameron [4] drop views as values and obtain a system similar to ours. However, their \nimplementation requires translation via the in function from the underlying data type to the view before \nmatching can be performed. Such a translation is not necessary in our framework. Palao Gostanza et al \n[11] propose pattern abstractions that completely separate patterns from data types, Boy\u00adland [3] implements \nnamed patterns with recursion using first-match semantics, and Erwig has a proposal for active patterns \n[5] in which patterns are parameterized by values as well as patterns. All of these mechanisms permit \narbi\u00adtrary computation in patterns and thus cannot be statically analyzed. Conclusions We have described \nan extension to ML: pattern abstractions with recursion, alternation, and node creation. Patterns us\u00ading \nthese abstractions can be checked at compile time for exhaustiveness and redundancy using finite-state \ntree rec\u00adognizes. Implementation of the patterns is baaed on a sim\u00adplifying substitution that partially \nevaluates the patterns against nodes created in patterns. The result of the substi\u00adtution can be translated \nin a straight-forward manner to a set of ML patterns and ML functions. The size of the translation is \nworst-c=e exponential in the size of the original pattern definitiona, and the determin\u00adistic automata \nneeded for the compile time checking may be doubly-exponential. While the theoretical complexity looks \ndiscouraging, we believebwd on experience with a pro\u00adtotype implementation that these worst-case bounds \nare only met for contrived examples. Acknowledgments We thank Alex Aiken, Chris Okasaki, Pedro Palao \nGostanza, David Gay, Zhendong Su, and the anonymous referees for their helpful and insightful comments \non earlier drafts of the paper. References [1] William E. Aitken and John H. Reppy. Abstract value constructors. \nIn ACM SIGPLAN Workshop on ML and its Applications, pagee 1-11. 1992. [2] John Boyland, Charles Farnum, \nand Susan L. Gra\u00adham. Attributed transformational code generation for dynamic compilers. In R. Giegerich \nand S. L. Gra\u00adham, editors, Code Generation -Concepts, Tools, Tech\u00adniques. Workshops in Computer Science, \npages 227\u00ad 254. Springer-Verlag, Berlin, 1992. [3] John Tang Boyland. Descriptional Composition of Compiler \nComponents. PhD thesis, University of Cal\u00adifornia, Berkeley, 1996. Available as technical report UCB//CSD-96-9l6. \n[4] F. Warren Burton and Robert D. Cameron. Pattern matching with abstract data types. Journal of Rmc\u00adtional \nProgramming, 3(2):171-190, April 1993. [5] Martin Erwig. Active patterns. In 8th International Workshop \non the Implementation of Function Lan\u00adguages. 1996. [6] Charles Farnum. Potter-n-based languages for \nprototyp\u00ad ing compiler optimizers. PhD thesis, Computer Sci\u00adence Division EECS, University of California, \nBerke\u00adley, December 1990. Available as technical report UCB//CSD-9O-6O8 [7] Ferenc G6cseg and Magnus \nSteinby. lkee Automata. Akad4miai Kiad6, Budapest, 1984. [8] Reinhold Heckmann. A functional language \nfor the specification of complex tree transformations. In Har\u00adafd Ganzinger, editor, European Symposium \non Pro\u00adgramming (ESOP 88), volume 300 of Lecture Notes in Computer Science, pages 175 190. Springer-Verlag, \nBerlin, 1988. [9] Christoph M. Hoffmann and Michael J. O Donnell. Pat\u00adtern matching in trees. .lournal \nof the ACM, 29(1):68\u00ad95, kmuary 1982. [10] Robin Milner, Mads Tofte, and Robert Harper. The Definition \nof Standard ML. The MIT Press, Cambridge, MA, 1990. [11] Pedro Palao Gostanza, Ricardo Peiia, and Manuel \nNtiez. A new look at pattern matching in abstract data types. In Proceedings of the ACM SIGPLA N Inter\u00adnation \nConference on fictional Programming (ICFP 96), ACM SIGPLAN Notices, 31(6):110-121, 1996. [12] Christian \nQueinnec and Jean-Marie Getfroy. Partial evaluation applied to symbolic pattern matching with intelligent \nbacktrack. In Workshop for Static Analysis. October 1992. [13] P. Sestoft. ML pattern match compilation \nand partial evaluation. In O. Danvy, R. Gluck, and P. Thiemann, editors, Partial Evaluation. International \nSeminar. Se\u00adlected Papers, pages 446-464. Springer-Verlag, Berlin, February 1996. [14] Philip Wader. \nViews: A way for pattern matching to cohabit with data abstraction. In Conference Record of the Fourteenth \nACM Symposium on Principles of Pro\u00adgramming Languages, pages 307-313. ACM Pressl New York, January 1987. \nA Reduction to Canonical Patterns This appendix describes the translation of patterns to canon\u00adical form \nin detail. We translate a mutually recursive group of pattern definitions together. We assume that patterns \noccurring in case expressions are first factored out into pat\u00adtern definitions so that patterns outside \npattern definitions are canonical. Hence, we only have to deaf with pattern definitions. In the course \nof the translation process, we gen\u00aderate new pattern definitions, these are added to the set of mutually \nrecursive definitions currently being analyzed. F@re 7 defies four functions that perform the transla\u00adtion \nat compile-time: SP This function takes a cache of specializations, an environ\u00adment and a pattern. The \nenvironment binds parameter names to patterns. The function returns a canonical pattern, one in which \nall calls to pattern definitions have only pattern variables for arguments. Translation starts by calling \nthis function with an empty cache and an identity environment for free pattern variables. SW This function \ntakes a node expression (from a where clause) and a pattern. It returns a set of pairs: each an environment \nand a set of bindings of variables to node expressions. S, This function takes a set of bindings of variables \nto node expressions, and a single node expression. It returns a substitution of the latter using the \ngiven bindings. Sf This function takes the cache of specializations, and a pattern call. It returns a \npattern call with only the free variables as parameters. We also make use of an auxiliary function: \nfree This function (not shown) returns the free variables of a pattern or used variables of a node expression. \nWe use some operations on environments and patterns. These operations are defined in Figure 6: + This \noperation joins two environments together. If they each provide a binding for the same pattern variable, \na conjunction of the two bindings is produced. (Here we require unrestricted as patterns. ) @ This operation \njoins pairs of an environment and a set of node bindings. It is extended to operate on sets of such pairs. \nWe use it to combine results of compile\u00adtime pattern matching against node creations. V This operation \njoins patterns together in alternation. If the set of patterns to join is empty, it returns the spe\u00adcial \npattern fail that doesn t match anything. B Nondeterministic to Deterministic Automata Given a nondeterministic \ntree automaton, as defined in Sec\u00adtion 5, we show that an equivalent deterministic automa\u00adton can be \ncreated. If we did not include and transi\u00adtions in our nondeterministic automata, we could have re\u00adferred \nto Gkseg and Steinby s standard definition of tree automata [7] for the proof.  Let A = (A, J, F) be \na (nondeterministic) tree automa\u00adton. We construct a deterministic automaton A = (A , #, F ) as follows: \nA = P(A) F = {a ~A la n F#O} with a transition in # defined for every c E Cons with arity n and every \nn-tuple (a; ,. . . , u~) E A : c(aj,.,. ,a~) +closure~({a Ial C a~,c(al,... ,an) +a~ 6}) By construction, \nwe have therefore that A is deterministic and moreover, runs of the two automata are closely related: \n V, A (t)= {A(t)} Furthermore, A accepts tif and only if A(t) n F# 0 if and only if A(t) E F . Thus we \nsee the two automata accept the same tree language.  (e+ e )(z) = e(z) as e (x) e(z), e (z) defined \n(e+ e )(z) = e(z) e(z) defined (e+ e )(x) = e (z) e (z) defined (e, w) @(e , u/) = (e+e , tuUw ) {(ei, \nwi)l O<~<~}@ {(ej, wj)l O<j<~} = {(ei, Wi)@(ej)wj) 10<~<~, O<j<~} ~{} = {(0,{})} V{} = fail V{P} = P \nV{PCI>PW. ,Pn} = PO I V{P1,... ,Pn} Figure 6: Definitions of+, @, and V Env = Vars# p Bindings = P(vurs \nx s) Cache = (Funcs X (px . Xp)) + l%ncs 5P : Cache + Env+ p+ p SPCe_ = SPC ex = e(x) SP(7efail = fail \n SPCec(pl, . . ,pn) = c(SPCepl, . . . ,SPCepn) SPCe~(pl, . . . ,pn) = SfCf(SPCepl, . . . ,Sp Cepn) &#38;Ce(pl \nI P2) = SPCepl I SpCep2 SPCe(pl as p2) = SPCepl as SpCep2 SPCe(p vhere $1 = S1 and ... and z. = s.) = \nV{(S~C(e\\lz,,,,,,..l +e )p) Where w I (e ,w ) E @S~sie(zi)} Sw : s+ p+ P(Env x Bindings) S.zp = {([~ \n* P]! {})} Sws. = {([z * -I~ E f@s)], {})} S.sy = {([x -~ I ~ G free(s)],{v = s})} Sw5fail = {} Swc($l, \n,Sn)c(pl, .. ,Pn) = Sw s; pi @ Sw C(91 , ,Sn) C (pi, . . . ,pn/) = {; (c # c ) Swsf(pl, . . . ,pn) = \nSIUS (Spo [Za 1+ pi] p) where f declared as pat ~(zl,. . . ,z~) = p Sws(yl I P2) = Swspl Usw Spz SWs \n(P1 as pz) = swspl@swsp2 S~s(puhere xl = S1 and . . . andx~ =.%) = {(e, W \\u U{Zi Ss WS1lO<i sn})l(e, \nw) E5wsP} where u = U fiee(si) s, : Bindings + s + s Ss{... ,z=sc. }z}z = 9 S. {Zi = Si}Z = Z ViXi #X \nSawc(sl, . . . ..%) = C(S8WS1, . . . ,Sawsn) sf : Cache + p+ p Sfcf(a = f (~ ~i are pattern variables \nsfcf(@ = C(f, fl (free@7) (if C(f,~ ex~ts) Sfcf(fl = g (free@T), (g f-h) add declaration pat g (~ = Sp \nC [Zi * pi] P where c = C[(f,#) 1+ g] j= free@) f declared as pat f(F) =P Figure 7: lhnslation to canonical \npatterns.  \n\t\t\t", "proc_id": "258948", "abstract": "Pattern abstractions increase the expressiveness of pattern matthing, enabling the programmer to describe a broader class of regular forests with patterns. Furthermore, pattern abstractions support code reuse and code factoring, features that facilitate maintenance and evolution of code. Past research on pattern abstractions has generally ignored the aspect of compile-time checks for exhaustiveness and redundancy. In this paper we propose a class of expressive patterns that admits these compile-time checks.", "authors": [{"name": "Manuel F&#228;hndrich", "author_profile_id": "81100288438", "affiliation": "Computer Science Division, Department of Electrical Engineering and Computer Science, University of California, Berkeley, Berkeley, CA", "person_id": "P187043", "email_address": "", "orcid_id": ""}, {"name": "John Boyland", "author_profile_id": "81100598730", "affiliation": "Computer Science Department, Carnegie Mellon University, 5000 Forbes Avenue, Pittsburgh, PA", "person_id": "P143028", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/258948.258957", "year": "1997", "article_id": "258957", "conference": "ICFP", "title": "Statically checkable pattern abstractions", "url": "http://dl.acm.org/citation.cfm?id=258957"}