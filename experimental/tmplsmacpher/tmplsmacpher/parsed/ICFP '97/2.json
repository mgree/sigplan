{"article_publication_date": "08-01-1997", "fulltext": "\n Type-driven Defunctionalization Jeffrey M. Bell &#38; Frangoise Bellegarde*&#38; James Hookt Pacific \nSoftware Research Center Oregon Graduate Institute of Science &#38; Technology PO Box 91000 Portland, \nOregon 97291-1000 USA {bell ,belleger ,hook}@cse. ogi. edu Abstract In 1972, Reynolds outlined a general \nmethod for eliminat\u00ading functional arguments known as dejunctionalization. The idea underlying defunctionahzation \nis encoding a functional value as first-order data, and then realizing the applications of the encoded \nfunction via an apply function. Although this process is simple enough, problems arise when defunc\u00adtionalization \nis used in a polymorphic language. In such a language, a functional argument of a higher-order function \ncan take different type instances in different applications. As a consequence, its associated apply function \ncan be un\u00adtypable in the source language. In the paper we present a defrmctionalization transformat ion \nwhich preserves typa\u00adbility. Moreover, the transformation imposes no restriction on functional arguments \nof recursive functions, and it han\u00addles functions as results as well as functions encapsulated in constructors. \nThe key to thk success is the use of type infor\u00admation in the defunctionaliiation transformation. Run-time \ncharacteristics are preserved by defunctionalization; hence, there is no performance improvement coming \nfrom the trans\u00adformation itself. However closures need not be implemented to compile the transformed \nprogram. 1 Introduction Defunctionaiization is the transformation of a program that uses higher-order \nfunctions into a semantically equivalent first-order program. This paper presents defunctionalization \nas a source-to-source translation in a Hindley-Milner typable functional language. Defunctionalization \nis very closely re\u00adlated to closure conversion in functional compilers. We are motivated to investigate \nit as a separate transforma\u00adtion because we have developed tools for functional language compilation \nthat are based on typed source-to-source trarts\u00adformation and that generate typed first-order programs \nin conventional languages such as Ada or C. In addition, we apply first-order program transformation \ntechniques to the defunctionalized representations of programs. The explicit .Currently at the Univernit6 \nde Franche-Cornt6 (F%.nce) tThe authors are supported by a contract with Air Force Material Command \n(F19628-93-C-O069). Permission to make digital/hard copy of part nr all this work for personal or classroom \nuse is granted without fee provided that copies are not made or distributed for profil or commercial \nadvan\u00ad tage, the copyright notice, the title of the publication and its date appear, and notice is given \nthat copying is by permission of ACM, Inc. To copy otherwise, to republish, to posI on servers, or to \nredistribute to lists, requires prior specific permission and/or a fee. ICFP 97 Amsterdam, ND @ 1997 \nACM 0-69791 -918 -1/97 /0006,.. $3.50 fun mapFy = case y of Nil a Nil I Cons(x, XS) * Cons(F z, map \nF XS) fun addone 1 = map incr 1 fun subone 1 = map deer 1 Figure 1: Example higher-order program fun \napply-map enwding arg = case encoding of incr ~ incr arg I deer + deer w-g fun map Fy = case y of Nil \n~ Nil I Cons(x, XS) * Cons(apply-map F r, map F XS) fun addone 1 = map incr 1 fun subone 1 = map deer \n1 Figure 2: Defunctionalized progmn study of typed defunctionalization illuminates issues related to \ntype specialization. The algorithm presented performs necessary type specialization but does not generate \na strictly monomorphic representation. Reynolds outlined a general method for defunctionaliza\u00adtion [Rey72]. \nThe idea underlying defunctionalization is en\u00adcoding functional values as fist-order data. Since a first\u00adorder \nvalue cannot be applied as a function, applications of the encoded functional need to be modified, by \nintroducing a call to an apply function. The apply function is called wherever the functional argument \nwas applied in the origi\u00adnal higher-order function. The apply function takes as argu\u00adments the encoded \nfunctional and all the arguments to the functional. The apply function dispatches based on the en\u00adcoding, \nand applies the appropriate function to the remain\u00ading arguments. For example, if the program in Figure \n1 is defunctionalized using strings containing the function name as the representation of function values, \nthe program in Fig\u00adure 2 is the result. Reynolds method defunctionalizes functions that have fun W@y,nt \n~ ,.t encoding UTg = case encoding of incr * incr m-g fun aPPIY~tring~,nt encoding arg = case encoding \nof str2int * str2int arg fun rnapint+int F y = case y of Nil ~ Nil I Cons(z, XS) = Cons( apply-map,n~+,~t \nF X, mapini+int F XS) Fy= caseyof fun aP3tri.g+int Nil ~ Nil 1 Cons(z, ZS) * Cons(app~y-map,,ra~,+~~~ \nF Z, map~,,ing+in, F XS) fun addone 1 = mapint+%mt incr 1 fun subone 1 = map,t,ing+imt str2int 1 Figure \n3: Defunctionalized example with specialization functional arguments, but not functions that return func\u00adtions. \nChin and Darlington address this in their A-algorithm [CD96], which removes some functional results by \nq-expansion. Our transformation includes the capabili\u00adties of the A-algorithm. Problems arise when defunctionalization \nis used in a poly\u00admorphic language [Be194, BH94a]. In the above example, map is called twice, each time \npassing a function of type id -) int.Suppose that the second call to map used a function with a different \ntype, e.g. str2irat : string + int. Then the apply_map function would be: fun apply-map enwding arg = \ncase encoding of incr + incr arg I str2int * str2int arg This function is ill typed in a Hindley-Milner \nlanguage (although the resulting program will have no wrong be\u00adhaviors if the original program was type \ncorrect). Our so\u00adlution is to specialize apply functions by the type of the functional whose encodings \nare interpreted in the apply function. Under this scheme, there would be one version of apply-map that \napplies int + int functions, and another version that applies string + int functions. Since the apply \nfunctions are specialized by type, so must be the higher\u00adorder functions that rely on the various apply \nfunctions. Again, this specialization is according to the type of the encoded functions. A type-correct \ndefunctionalized version of the modified example is given in Figure 3. Another complication encountered \nby the defunctional\u00adization algorithm is illustrated in Figure 4, showing an im\u00adplementation of the sum \nfunction using continuation-passing style. Here, sum is called with a series of different function values \nfor the argument F. This requires an encoding for F that accounts for all possible values of F, which \nis accom\u00adplished by encoding F in a recursive datatype, as described in Section 2.5. Our desire for a \ndefunctionalization algorithm was moti\u00advated by work on software component generators that per\u00adform type-faithful \ntranslations of higher-order functional pro\u00ad fun sum Fy = case y of Nil~FO I Cons(z, zs) * sum (An.z \n+ F n) xs I Figure 4: Higher-order function in CPS Terms t,M, e (terms are underlined in transformation \nrules) Variables v, w, x, y,z, F,G, H Function symbols ~, g, h Type variables ~,~,~ Type terms I-f,@, \nf-l,Q Data constructors C labelled with the type and the term it encodes Type constructors T labelled \nwith the type it encodes as an index Table 2: Naming conventions grams to first-order imperative languages \n(e.g. Ada) [B+94, KBB+94]. Although specialization-based techniques for de\u00adfunctionalization exist [CD96], \nthey fail on examples such as Figure 4 where an infinite family of specializations would be generated. \nIn addition, they do not defunctionalize func\u00adtions in data constructors (e.g. lists of functions). Our \ntype-driven transformation is presented as a set of transformation rules. Two rules decrease higher-orderness \nand three rules lessen polymorphism. The rules make clear the amount of monomorphization which is necess=y \nfor de\u00adfunctionalization. The remainder of the paper is organized as follows. Sec\u00adtion 2 describes how \nthe type-driven defunctionalization trans\u00adformation is applied to higher-order programs. Section 3 summarizes \nthe results related to soundness, terminat ion, and effectiveness of the transformation (full proofs \nare given in a tethnical report [BBH96] ). Sect ion 4 presents our con\u00adclusions and future work. The \nappendices include several illustrative examples.  2 The transformation The defunctionalization transformation \napplies to a restricted form of a higher-order polymorphic strongly-typed functional language. A grammar \nfor the language is presented in Ta\u00adble 1. This is a simple polymorphic language without local let or \nlambda bindings. Only function symbols, function variables, and constructors can appear in function applica\u00adtion \nposition. A program consists of datatype declarations followed by function declarations followed by a \n(top-level) term. This language form can be calculated from, say, a core ML program by the standard lambda-lifting \ntransfor\u00admation [Joh85]. These restrictions simplify the exposition; the language can be extended without \nfundamental changes. The naming conventions used in this and following Sections are given in Table 2. \n Datatypes: ddecl ::= datatype crl...a~ T = cdecs cdecs ::= cdec 1 cdec I cdecs cdec ::= Ctypel . ..typen \n(n ~ O) Functions: jdecl ::= fun fvl. ..vn =tenn Terms: term ::= rater I rater terml . . . termn 1 \ncase term of patl => term] I . . . pat. => term. TatO?-::= flvlc pat ::= Cvl. ..vn (n~ O) Types: type \n::= a I typel +typez I Ttypel. ..type~ Program: program ::=ddecl fdecl term Table 1: Thegrammar of thepolymorphic \nhigher-order language 2.1 Functional type specialization and arrow type param\u00adeter encoding fun map~ \nFy = case yof The transformation relies on analyses of types. The basic Nil * Nilidea is to replace \narrow type arguments by appropriate ele-I CO~S(Z,ZS) + Cons( (F )int+int X,ments of a datatype. A datatype \nTn captures the arrow type map (F)int+int ZS) arguments of the arrow type II where each arrow type argu\u00adment \nof type II is encoded by a constructor in the datatype Tn. Consider the following example of a term: \nmap id [1,2] where map is declared as in Figure 1. The type of map is: Figure 5: Higher-order clone of \nmap of type V map :(a d /3)-+ list a -+ list ~ It is a higher-order function since it has an arrow type \nar\u00adgument. The type of id is a + cr. But in the context (t)n = the unencoded value oft of the application \nmap id [1, 2], id is instantiated at type int+ int. Therefore, this occurrence of id can be encoded ((v), \n)- = vby a constructor Cj~t+inf in a datatype Tint+ int which is (f t,...tn=- = f (tl)-1 . ..(%)- created \nto contain the encodings of arrow type arguments of type int * int. So doing, the type of map has to \nbe-(c t,... tnl-l = c (tl)-l... (tnl-l come Tint+in~ + list int + list int. However, in another (Vt,.. \n.tn)-l =V (tl)-l... (tnl-l application, the type of map could be instantiated other-(case tofpl=>tll \n. . . I p. => t )- = wise. The solution is to create as many different versions, case (t)-lof pl => (tl)-l \nI ... Ipn => (tn)-l called clones, of the higher-order function as needed. The I transformation requires \na different clone of the higher-order function for each type at which the higher-order function Figure \n6: Definitions for semantic functions is applied in all of its applications. Cloning is necesszmy because \neach clone of the higher-order function will use a specialized encoding of function values. A clone \nof ~ at a specialized type IT is given the function When creating and manipulating clones, it is necessary \nsymbol ~11.It is created by taking a copy of the declaration to keep track of which expressions are in \nthe encoded repre\u00adof ~ in which arrow type variables are replaced with an ap\u00adsentation and which are \nnot. This information is indicated plication of the function (.) n to the arrow type variable, aswith \nbraces. Specifically, braces subscripted by a type (on) shown in Figure 5. Note that at this point the \nrecursive call are placed around encoded fragments that are used in their to map is not encoded. This \nwill be addressed when this original context. In the dual case we write braces with aa function call \nis defunctionalized. inverse ((.) ]). The definition is given in Figure 6. The next step is to encode \narrow type arguments inThe creation of a clone of a higher-order function is not datatypes. Then, in \nthe body of the clone, an application ofa simple task. An arrow type parameter in the higher-order (F)II \nmust be transformed into an application of an applyfunction becomes a O-order type parameter in its clones, \nso function. In the body of mapw, the application (F)ini+int zit can no longer be applied as a function. \nThe tirst step is is transformed mto applyint+,nt F x as shown in Figure 7. to create a clone in which \nthe arrow type argument is still The apply function depends on the datatype. It establishes a function \nbut of a specialized type. For example, the clone a correspondence between the encoding and the encodedof \nmap as presented in Figure 5 is of type: terms. For the example, the transformation adds the decla\u00adration \nof an applyint+int function shown in Figure 8. ~ = (int * int) ~ list int + list int. 2.3 Higher-order \nrecursive functions fun map~ F y= case y of Nil + Nil \\ CCHM(Z,ZS) + Cons( applyint+,nt F X, map (F )i~t+,~t \nn) Figure 7: Clone of map where F is seen as encoded datatype !f i.~+an~ = C~~t+int fun applyin,+int \nf x = caae f of C~~,+,., * (id z) Figure 8: Encoding-derived declarations .  2.2 Transformation rules \nThe transformation informally described in the previous sec\u00adtion is guided by a set of transformation \nrules. A rule trans\u00adforms an expression of type order O, which we call jully \u00adapphed, in the context \nof a program P. It also updates the set A of function symbol declarations of P and the set E) of datatype \ndeclarations of P, so that a transformation rule transforms a triple (term, A, ~) into a new triple. \nThe three rules (FunSpec), (EncodeClosed), (ApplyVar) shown in Figures 9, 10 and 11, allow us to defunctionalize \nthe fully\u00adapplied application map id [1,2]. Definitions oft he functions order and functional used in \nthese rules can be found in Fig\u00adure 14. The rules reference type information calculated by type inference \non the original, untransformed terms. As the trans\u00adformation progresses, this information is propagated \nun\u00adchanged. Since the transformation proceeds nondet ermin\u00adistically through untyped intermediate representations, \nit is important to note that sometimes the type does not apply to the term being manipulated, but the \ninput term of which it is a residual. The rule (FunSpec) specializes a fully-applied higher\u00adorder application \nof a function symbol according to the type of its arrow type arguments. For instance, it transforms map \nid [1, 2] into mapw id [1, 2] and adds the clone mapw from Figure 5 to the function declaration set A. \nThe rule (Encode Closed) encodes arrow type arguments into construc\u00adtors of datatypes. For example,i~t \ntransforms the expres\u00adsion mapW id [1, 2] into mapw Cint+int [1, 2] and adds the encoding-derived declarations \nin Figure 8 to the declaration set A. Next, in the body of the declaration, the applica\u00adtion (F )i.t+i.f \nz is transformed into applyw F z by the rule (Appl Var). In the clone mapw there remains a fully\u00adapplied \nhigher-order application of map which comes from the original recursive application of map. No more transfor\u00admation \nrules are needed to cope with recursive calls in a set of mutually recursive clone declarations, as explained \nin the following section. In a clone, types can be deduced from the original terms, from the type label \nof the clone function symbol, and from the type annotations on applications of on. For example, in the \nbody of the mapy clone of map, the specialized type of map in the recursive application: map (F )int+int \nzs is recognized as the type w because of the subscript int + int. Since we suppose Hindley-Milner typability \nof the orig\u00adinal program, recursive calls in a set of mutually-recursive declarations are of a consistent \ninferred type. Therefore, in a set of mutually-recursive specialized clones, the types of recursive calls \nare of consistent specialized types. This serves the useful purpose of allowing the specialization rule \n(Fum$pec) to fold the specialized recursive call artywhere it occurs in the set of mutually-recursive \nclone declarations without the need for further analysis. In our example, the rule (FunSpec) can be used \nagain to change the occurrence of map (see Figure 7) into mapv in the body of the declara\u00adtion of the \nclone mapW, and change (F)int+int into F via the application of (.) 1. No more rules apply; the result \nof the transformation is the first-order program composed of the term map~ C~~t+imt [1,2] and the d&#38;larations \nin Figure 8 and below: fun mapq F y = case y of Nil * Nil I COTM(Z,ZS) * Cons(applyint+int F X, mapw \nF XS) An example of mutually-recursive functions is presented in Appendix B.3. 2.4 Polymorphic higher-order \napplication Cloning a polymorphic function is not = simple when it is specialized in such a way that \nit becomes a function that returns a function. In such a case, a polymorphic function symbol ~ with arity \na may be applied to a number of ar\u00adguments n where n > a. For example, although id is of arity 1, in \nid id (id 7) the first occurrence of id has two ar\u00adguments. In this case, the specialized clone of the \nfunction definition must not be simply a copy, but an q-extension annotated with the types of the functional \narguments. The function id in the expression id id (id 7) is instantiated at two types: the first-order \ntype int + int and the second\u00adorder type @ = (int+ int) -+ (int -+ int). In addition, the second id appears \nas a parameter to a higher-order function and the third as a first-order function. The defunct ionaliza\u00adtion \nmust distinguish on both order and these distinct roles. Since the outermost application has a functional \nargument id, an q-extended clone fun ids. z y = (~)int+int Y is pr~ duced, along with a transformation \nof the application into: ;&#38; id (id 7). This is accomplished by the rule (EzpandSpec) shown in Figure \n12. (EzpandSpec) expands the body M of the function it spe\u00adcializes with fresh variables so that it becomes \nfully-applied. This works fine if M is a function symbol or a variable, but M can also be a case expression \n(see the grammar in Ta\u00adble 1). In this case, normalize uses the rewrite rule shown in Figure 13, as much \nas needed, to push the variables inside case arms so that case expressions do not occur as operators \nin function applications, Both rules (FunSpec) and (ExpandSpec) help to decrease the occurrences of polymorphic \napplications since the func\u00adtional polymorphic arguments of fully-applied applications 3 j, j ~ 1... \nn, functional(~j) A alljunctionalvariablesinfictional argumentsareargumentsof(,)wforsomeW A n= order(rf) \nA order(fl) = OA ~ is a function symbol  AND r+ta : Ifi, Vi, iE1. ..n, rt-fh ...k : Q, rt-f:n,aI I=rIl+. \n..+ IIn+Q THEN ft, . . . tn, A, f3=+ fen (t])-l . (tn)-l, A ,@ WHERE Au {jcn Z1 .xn = M[ral i-(Z,, )ni, \n. ..X.k + (Wk)nlk]} A = whereA(~)=~zl . ..z~=Mandij. j~ l.. .k, are the indices of the fictional arguments \n{ IF Figure 9: (AmSpec) Functional type specialization transformation rule IF 3j, jE1. ..n A order(IIj)>OA \ntjisa closed term A F is a function symbol or a function variable A order(f2) = O AND rt-t; : II;, Vi, \niE1. ..n, rl-Ftl... tn:Q THEN Ftl ...i!j. ..tn, A,@~Ftl . C;, . ..tn. A ,@ WHERE if ApplyHj has not been \ndeclared in A then A U {/@~YHj ~ !/1 ~ ?40rderf~, J = A = case z Of t CnJj - tj VI . . . Yorder[n, ~} \nelse { tadd to it the cose arm 6 n]j * tj Y1 . . yorde~f~j ) if TIIj has not been declared in @ 9 = \nthen @ u {datatype TII, = C~, } { eke tadd to it the constructor C=;j Figure 10: (EncodeClosed) Closed \narrow type parameter encoding transformation rule [F 4ND THEN (F)ntl order(fl) = OA F is a variable rFFtl... \ntn:Q . t., A, OsApplyn Ftl ,.. tn, A,E) Figure 11: (ApplVar) Higher-order variable application  32, \n2 E 1...n, functional(m) A all junctional variables in junctional arguments are arguments of (,)w for \nsome W A n > order(n) A order(~) = OA j is a function symbol AND r+t~ : IIi, Vi,2E1. ..n, r+ ftl. ..tn:~, \nr+j:n, CT1-l=l-fl +.. .+ IIn+fl THEN tt, . tn,A,@=~~II (t,)- . . . (tn)- , A ,@ WHERE A = AU {frn xl \nxorder{n] U . . . Vp = normalize(kfvl . Vp)[Zi~ 4\u00ad(Zi~ )11,1 . . . . Xi~ VI, + (V{l)rrtl ,. ... % + (Vmhlml \nwhere A(f) = f zl . Xordertn) = M, + (Zi~ )IIik , Zj,j= l...k,~dlj,j~ the functional arguments, p l.. \n.narethe indicesof = n order(II) + 1. Figure 12: (ExpandSpec) Functional q-extension and specialization \n (case t of pI => tI II.. IIpn => tn)t + case t ofpl => tl t It ... IIpn => tn t Figure 13: Rewrite \nrule for case expression normalization . order : type + int = At.case t of @*o I a -)(? + 1 + order(~) \nlTII,...IIna O . functional: type + bool = At.caae t of a * }ake lcr+~+true ITHI... L * functaorsal(II~ \n)V... V functional(lIn) v3aconstructor c: I lx. ..x~ ~ + T Ill . .lI~ such that finctiOnal(I l ) v... \nv functional(r~) Figure 14: Difference between order and functional become monomorphic. The higher-orderness \nof programs is addressed by the rules (Encode Closed) and (Appl Var). In the above, example, the result \nof the transformation is the term i~ CJ~t+:nt (id 7), with the declarations: datatype Z i.~+in~ = C~~~+int \nfun idx = 2; fun aPPiYi.t+int x Y = c-e $ of C~~,+l.f a (id y) fun Z&#38;Xy = aPPIY;nt+;nt x Y This example \ncan be extended to require the encoding at an arbitrarily high order. Thus a defunctionalization based \non function declarations instead of function applica\u00adtions cannot work. It is also clear from this example \nthat the algorithm must be sensitive to the set of monomorphic types at which every function symbol in \nthe program occurs. It is necessary to start with an expression with a monomor\u00adphic type and recursively \nperform type specialization on all function symbols occurring in the monomorphic expression. The transformation \nrules require fully-applied applica\u00adtions, thereby intertwining the monomorphization of the higher-order \ncomponents and their encoding counterparts during the transformation. Consider for example the appli\u00adcation \nid (id id) (id 7). Only the higher-order argument of the application differs from the example above; \nit is (id id) which is itself a higher-order application. However in this context it is a higher-order \nzugument and as such, it has to be encoded by a constructor C~~~~t. Proceeding as above, we get first: \ndatatype Ti.f+i.i = C~~~~~~, fun applyint+int x y = case x of C~~~/nt * id idy fun ida z y = applyine+,.t \nr y with the term i~ C~~~~i~t (id 7). The application id id is fully-applied as id id y in the body of \nthe generated appiy:nt+int function. Because the rules work solely from fully-applied applications, it \nis only at this point that the defunctionalization of id id y is done. This provides the first-order \nprogram composed of the term i~ C$~~~~~,(id 7) with the declarations below: Notice that polymorphism \ncan induce functional argu\u00adments that are syntactically equal but are not of the same type, as in the \napplication id id id 7. The two arguments id of types W = (znt + int) + (int -) int)and int + int are \nencoded by two different constructors: C~dand C/~t~int since the constructor symbols are built on both \nthe type and the term they encode. The interested reader can find more realistic examples in Appendix \nB. 2.5 Encoding nonclosed arrow type arguments Closed arrow type arguments are always encodable into \ncon\u00adstant constructors, but arrow type arguments may contain variables. The transformation must be able \nto encode both kinds of arrow type arguments of fully-applied functional applications. Arrow type argument \nexpressions may contain arrow type variables as well as first-order variables. For example an ar\u00adgument \ncould be t = ((Z)n (( F)int+(int+lnL) z)), where Q is the type (int + int) -+ int + irzt. As above, such \nan arrow type argument must be encoded in a datatype that corresponds to its type. This can be done by \nencoding the argument as a function constructor rather than as a first\u00adorder constructor. First-order \nvariables are not encoded by the transforma\u00adtion. The types of the values of the first-order variables \nthus remain variable types ancl parametric datatypes are gener\u00adated to encode arrow type terms which \ncontain first-order variables. Thus we are doing as much monomorphization as needed, and no more. Since \nfunctional variable values are encoded, their types are those of the encoding datatypes. In the above \nexample, since tcontains a first-order variable, the functional argu\u00adment tof type int + int must be \nencoded in a parametric datatype a !f in~+i.t by a constructor C~nf+in~ of type (Tn X T~*t+(i.~+i.~) \nX Cl) ~ (int -+ int). By encoding functional variable values, the datatypes that axe created for the \nencodings can be recursive (See Sec\u00adtion B. 1 for an example of such a recursive datat ype). The rule \n(Encode) given in Appendix A subsumes the rule (En\u00adcode Closed) given in Figure 10. 2.6 Higher-order \nconstructors A special case of higher-order application is higher-order constructor application. A higher-order \nconstructor can be an instance of a poly\u00admorphic constructor. For example the list constructor Cons haa \nthe type (ini! + int) x ht(ant+ int) + Iist(int + int) in the application CoraS(Zrt,(~s)li~t(jnt+int) \n). The functional argument id of type int + int has to be encoded into a constructor C~~t~ iflt as for \nan application of a higher-order function. The rule (Encode) in Appendix A allows encodings of functional \narguments of higher-order functions as well aa functional arguments of constructors. By matching the \ntype II of a term tagainst the datatype of the patterns in a case expression, we know the functional \ntypes of function variables in a pattern. These types are used to apply on to functional variables in \nthe arm bodies. This is accomplished For example: by the rule (UpdateAnns) of Figure 15. case (Z)iistint+.int \nCons(xl, m) of * (z1 Y) * case z of Cons(zl, X2) * (( Zl)int~int Y) This is accomplished by matching \nthe functional type list(int + int) of x against the parametric type list a with the substitution u = \n{a + (irzt + int)}. The domain of the data constructor Cons is then specialized into (int + int) x list(int \n+ int), allowing the rule (UpdateArms) to ap\u00adply (.),. t+i.t to the arrow type variable xl. The interested \nreader can consider example B.2. Notice that the type Iist(int + int) is considered as functional (see \nFigure 14) though it is of type order O. Only term arguments of type order greater than O need to be \nen\u00adcoded but any term of a functional type may be an argument of a polymorphic function which, in this \ncase, has to be type specialized. There is a minor complication when a datatype declares a functional \nconstructor explicitly, like the constructor Store in the declaration: datatype (a, ~) store = Store \na ~ /?. Unlike a function symbol, a constructor cannot have clones in datatypes corresponding to different \ntype instances of a and ~. A way around this is to generalize such a datatype. Generalization is safe \nfor type inference. Moreover since the programs are type correct, it is useless to typecheck the arrow. \nBy the rule (GeneralizeArrows) of Figure 16 the datatype store becomes datatype o store = Store a so \nthat encoding of differently typed functional arguments in different applications of the constructor \nStore is possible. Finally, notice that rules (FunSpec) and (ExpandSpec) introduce applications of (.) \nv to functional terms. These ap\u00adplications are ultimately removed when the functional term is applied \n(in (Appl Var)), when the term is examined (in (UpdateArms)), or by applying (.)- (in (FunSpec) and (Ex\u00adpandSpec)). \nHowever, applications of (.) w are not removed when an (unapplied) functional term is used as an argument \nto a higher-order constructor, as in Cons( (j) w, Nil). For this, we use the rule (UpdateCon), as shown \nin Figure 17.  2.7 The use of types In summary, types are used by the defunctionalization algo\u00adrithm \n. to replace arrow type arguments of higher-order fnnc\u00adtion applications by appropriate elements of a \ndatatype by creating a datatype Tn for functional arguments of type If, . to create clones of polymorphic \nhigher-order functions specialized by the types of their functional arguments; the clone names are simply \nlabelled by their types, . to recover the appropriate clone name in a recursive call that occurs in \n(mutually) recursive clones of higher\u00adorder function declarations,  [F functiOnal(T@l O,) A all functional \nvariables in t are arguments of (}w for some W AND r~ t: T@l. ..@k I HEN case t Clzll of .Zlml a tl ,A, \n@= case (t) l of Clzl, . . .Zlml * t; ,A,9 Cnxn, . Xnmn +-t., Cnxn, . . . Xnmn +-ti WHERE T is declared \ndatatype al . . . a&#38; T = . vi, ci jl, iE 1... n, t:= ti[~;jlt (Zi,l)w]l,...,Zi,p )1+ (Gjp Wjp appears \nas C;*1 ~~, in the instantiated Sumtype .ICYI+ @I,..., 1 E 1 . . .p are the indices of functional pattern \nvariables. ak + @k] Figure 15: (UpdateArms) rule for updating case arm variables . to recognize the \ndat atype in which is encoded the value of a functional variable so that its application can be replaced \nby an application of an apply function, . to know when a clone must be an q-extended copy of the original \npolymorphic declaration, and . to discriminate arrow type arguments of constructors in different arms \nof a case expression by analyzing the type of the matched expression.  The encoding of arrow type arguments \ninto datatypes, to\u00adgether with a type analysis originated by fully-applied appli\u00adcations, accommodates \nthe transformation of higher-order programs into a first-order equivalent program. Study of the transformation \n A transformation rule transforms a program which contains an expression g in the context P denoted by \nP[eJ. In the previous section, a transformation rule has been written in the following abbreviated form: \nifCond g,A, @ = ~, A , @ Suppose that a function< extracts the set A of the function declarations from \nthe program and that a function O ex\u00adtracts the set e of type declarations from the program. As usual, \nthe notation iM[N /N] denotes that the occurrence(s) of the subterm N are replaced by the subterm N in \nM. A transformation rule on a program P[d could be expressed as: ifcona PM * PH[A /((P[4), Q /O(P[e])] \n Given a program, the defunctionalization algorithm ap\u00adplies the seven rules {FunSpec, ExpandSpec, Encode, \nAp\u00adpl Var, UpdateArms, GenemlizeArraws, Update Con) in any order untiI none of them is applicable. It \nrelies upon the original types of the terms and synthesized types for terms introduced by the algorithm. \nThe types of introduced terms are determined as follows, The type of (.)11 is II. The type of au apply \nfunction is the type of the functional encoding term 1; that is, applyw : T* + ~. The type of an en\u00adcoded \nterm is the datatype T*. Finally, the type of a clone function symbol fw is Q. 3.1 Theorems Below are \ntheorems addressing the iesues of soundness, ter\u00admination, and effectiveness of the transformation. Proofs \nof these theorems can be found in an extended version of this paper [BBH96]. Theorem 1 If a program is \nwell typed according to the Hindley Milner algorithm, then the transformation results in a well\u00adtyped \nprogram equirraient to the original program. Theorem 2 The transformation always terminates. Theorem \n3 The transformation of a closed program results in a first-order program. 4 Conclusion and future work \nThe defunctionalization transformation presented in this pa\u00adper is a complete algorithm for transforming \na closed higher\u00adorder well-t yped functional program, comprising an expres\u00adsion e together with its declarations, \ninto an equivalent first\u00adorder program. As far as we know, a complete algorithm such = this has not been \npresented before. The method that replaces functional applications by macros [Wad88] is elegant but macros \ncannot be recursive. Although recursion can be recovered by way of recursive local functions, the macro \nmethod supports only functional quments which remain identical in recursive calls. The method that spe\u00adcializes \nfunctional applications with respect to the values of arrow type arguments is limited to so called uariabie-ordy \narrow type arguments [CD961. None of these methods con\u00adsider th-e-case of higher~order constructor applications. \n 3j, jE1. ..n, Aorder(@j)>0 A all variables of i!j are argumentsof (}w for some V THEN Ci?I - . ..tn. \nA,@u{~l . ..~m TIC@lx Cx@jx.. x@jx... x@nl...} CtI . ..t~. A,@u{B, . ../3~l( 7@IX(Xfl X... Xf}X... X%l...} \nWHERE crl. ..cr~are thetype variablesin {.. .lC@IX@ @l...,&#38; arethetype variables inlC@lx C@lx ~ is \na fresh type variable jXXX@nl. . ..x~x... .X@nl x@~}...} . ..} Figure 16: (GeneralizeArrows) Arrow constructor \ngeneralization IF 3 j, j E 1... n, fUflC~i071Ul(l_Ij) A all ~unctional variables in junctional argumentsare \narguments of (.)w for some W A C is a constructor AND rl-t; : II,, VZ, iE1. ..n, rHEN Ct, . tn, A,@+C \n(tI)- . (tJ-l, A,EI Figure 17: (UpdateCon) Removes applications of (.)* from higher-order constructor \narguments Our transformation is based on Reynolds s method [Rey72] of encoding functional arguments. \nOur main contribution is to bring together this idea and the idea of using functional application types \nto drive the defunctional\u00adization transformation. This is crucial for handling polymor\u00adphic higher-order \nfunctions as has been noted by Chin and Darlington in their A-algorithm [CD96], which is used to re\u00admove \nsome functional results by eta-expansion. Our trans\u00adformation includes the functionality of the d-algorithm. \nWhile it always produces a first-order program, this trans\u00adformation has little effect on execution efficiency \nsince the reduction steps of the first-order program are similar to the reduction steps of the original \nhigher-order program. There is some performance penalty imposed by the execution of appiy functions to \nevaluate encoded values. In contrast, Chin and Darlington s R algorithm [CD96] relies on spe\u00adcialization \nwith respect to the values of functional arguments and returns, when it is applicable, an improved first-order \nprogram. The ideal solution is to add to our set of rules a trans\u00adformation rule to specialize variable-only \narrow type argu\u00adments with respect to their value to get the best of both worlds. For example, the first \nargument of map in the in\u00adtroductory example in Section 2 is variable-only, as is the first argument \nof wap in the example in Section B. 1. There\u00adfore in applications of map or mp, the functions map and \nmp can be specialized with respect to the value of their ac\u00adtual functional parameters rather than encoding \nthem and consequently creating an apply function that corresponds to this encoding. At a functional application \nof j, variable\u00adonly functional arguments lead to a clone of f specialized with respect to their valuea. \nIn a combined transformation, the values of the uarialde-only parameters of the applica\u00adtion would be \nsubstituted in the clone body where= other functional arguments would lead to a clone of ~ specialized \nwith respect to their types, their values being encoded into a constructor term of a datatype. In the \ncombined transfor\u00admation, since a clone is tied to its source application type, the folding of a recursive \nclone application either coming from type specialization or from value specialization is al\u00adways recognizable \nby its type. So, the type annotations and the variable-only analysis of the version body together en\u00adable \nthe algorithm to fold the recursive calls in recursive as well as in mutually-recursive versions. We \nsuggest perform\u00ading the variable-only analysis beforehand and to carry on a variable-only annotation \nto the functional arguments of functional versions. The result of applying such a combined transformation \ncan be seen in the example in Section B. 1. Note that the defunctionalization transformation per\u00adforms \na monomorphization of functions with respect to their functional arguments and functional results. Full \nmonomor\u00adphization of the program can be obtained by specializing also first order function symbol with \nrespect to the type of their applications and annotating first-order variables as well as functional \nvariables. A similar treatment of defunctional\u00adization that relies upon a monorphic program as input, \nand thus does not perform specialization of polymorphic func\u00adtions, has been developed by Tolmach [T0197]. \nThe defunctionalization transformation, we present in this paper, is a step in a pipe-line of transformations \nde\u00adsigned to automatically derive a program generator [B+94, KBB+94] from the semantics of a domain-specific \ndesign lan\u00adguage. The purpose of the transformation is to obtain sat\u00ad isfactory performance and to tailor \nthe implementation to a specific platform and software environment. Defunctional\u00ad ization accommodates \nsoftware environments which penalize or prohibit functional. It is also used to translate func\u00ad tional \nprograms into term-rewriting systems in the trans\u00ad formation system Astre [Be195b, Be195a] which uses \nterm\u00ad rewriting techniques to perform algebraic manipulation on functional programs. References [B+94] \nJ. Bell et al. Software Design for Reliability and Reuse: A proof-of-concept demonstration. In TRI-Ada \n94 Proceedings, pages 396-404. ACM, November 1994. [BBH96] Jeffrey M. Bell, Frangoise Bellegarde, and \nJames Hook. Type-driven defunctionalization. Techni\u00adcal Report CSE-96-009, Oregon Graduate Insti\u00adtute, \n1996. [Be194] J. M. Bell. An Implementation of Reynold s Defunctionafization Method for a Modern Func\u00adtional \nLanguage. Master s thesis, Department of Computer Science and Engineering, Oregon Graduate Institute, \nJanuary 1994. [Be195a] F. Bellegarde. Astre: Towards a fully automated program transformation system. \nIn Proceedings of the sizth conference on Rewriting Techniques and Applications, volume 914 of LNCS. \nSpringer-Verlag, 1995. [Be195b] F. Bellegarde. Automatic Synthesis by Comple\u00adtion. In Journ.4es Ihancophones \nSW-les Langages Applicatifs, INRIA, collection didactiques, 1995. [BH94a] Jeffrey M. Bell and James Hook. \nDefunctional\u00adization of typed programs. Technical Report 94\u00ad025, Department of Computer Science and En\u00adgineering, \nOregon Graduate Institute, February 1994. [BH94b] Fraqoise Bellegarde and James Hook. Substitu\u00adtion: \nA formal methods case study using monads and transformations. Science of Computer Pro\u00adgramming, 23(2-3):287-311, \n1994. [CD96] Wei-Ngan Chin and John Darlington. A higher order removal method. Lisp and Symbolic Com\u00adputation, \n9(4):287 322, 1996. [Joh85] Thomas Johnsson. Lambda lifting: transform\u00ading programs to recursive equations. \nIn J- P. Jouannaud, editor, Functional Programming Languages and Computer Architecture, volume 201 of \nLNCS, pages 190-203. Springer-Verlag, 1985. [KBB+94] R]chard B. Kieburtz, Frangoise Bellegarde, Jef \nBell, James Hook, Jeffrey Lewis, Dino Oliva, Tim Sheard, Lisa Walton, and Tong Zhou. Cal\u00adculating software \ngenerators from solution spec\u00adifications. Technicaf Report 0GI-CSE-94-032B, Department of Computer Science \nand Engineer\u00ading, Oregon Graduate Institute, October 1994. [Rey72] John C. Reynolds. Definitional interpreters \nfor higher-order programming languages. In ACM National Conference, pages 717-740. ACM, 1972. [To197] \nAndrew Tolmach. Combining closure conversion with closure analysis using algebraic types. In ~pes in \nCompilation Workshop, June 1997. [Wad88] P. Wadler. Deforestation: Transforming Pro\u00adgrams to eliminate \ntrees. In Proceedings of the second European Symposium on Programming ESOP 88, volume 300 of LNCS. Springer-Verlag, \n1988.  :F 3 j, j G 1... n, t,is not a variable A o~de~(IIj) >0 A all ~unctionai variables in tj are \narguments of (}W for some W A ~ is a function symbol, a function variable, or a data constructor A order(Q) \n= O kND vz,z~l,..~,r~ti ri-Ftl.. .,tn : : Q n,, w . vk am the variables in tj L HEN Ftl . ..tj. ..tn. \nA,@~Ftl . ..(C~j V1 ,., vk). ..tn,,@, @ iVHERE ij Applynj has not been declared in A then A U {Applvnj \nY ~1 order(nj ) = A = { t C&#38;Sf! y OfC~j V1 .Vk * teke add to it the arm Cnjj VI ~J . ~1 . . ?)k \n+ ~order(~j)} tj XI . . . order(nj J if Tnj has not been declared in @ then @U{datatypeal... a~ Tnj =C~j \n*1 x... x*~} e = ~{ { if vi is annotated by V v2,2E1... k,@t= then IIwhere eke /? where ~ is a fresh \ncrl . . am are the type variables in @l . @k eke add to it the constructor C~j @l x . x @k type variable \n B Examples  B.1 Second-order argument: This example is inspired from [BH94b]. Program: fun mpZFx=casezof \nNil q Nil I Cons(z, ZS) s Cons(F z, mpZ (Z F) ZS) fundb Fx=F(Fz) funincx=z+l Term: mp db inc [2,3,4] \nof type: list int Is transformed to Program: , ~::k:jnt datatype Tint+iflt = C~~~+,n, T(int+int)+(int+ \nint) x ~int--t:nt datatype T(in~+int)+(int+ irlL) cfint+int)+(tnt-t* nt) fun mp&#38;ZFz=caaexof Nil \n~ Nil I Cons(x, zs) a Cons(upplyTi.,+ln, F X, mp~ Z (@~fl~nt (-Z, F)) XS) fun Fx=case Fof apdYTi~t+i,tt \n I fun 35 fundb~ FX=applyT,n, +,n, F(app[y7 ,F Z) , +,nt funincz=x+l Where @ = ((int + int) + irli?+ \nint) + (int + int)Z nth! + list+ list v = (id+ id) + int+ int If combined with specialization with \nrespect to the value of the variable-only fist argument of mp, as described in Sec\u00adtion 4, this program \nbecomes: datat ype Tint+int = c~%+i.t b ) Txnt+,nt I d?-?, fun mpe Fx=case x of Nil ~ Nil I cons(z, \nZS) * C0n5(app~y7,~t+i=t F x, mpa db ) (db, F)) (Cin,+:n, ZS) fun apply7im,+i~t Fz=case Fof C~~~+,.t \n* inc x I (Cfj~~, G)* (db~ G z) fun db~ f z = a@yTim,+in, F (applyTin,+,m, F z) funincz=z+l Where: @ \n= ((int + + int + int) + (int + int) + list int -+ list  ire!) int 8.2 List of functions: This example \nis borrowed from [CD96]. Program: fun maph Fsy = case Fs of Nil + Nil I Cons(F, Fs) -Cons(F y, maph \nFs y) fun add5y = case y of Nil a Nil I Cons(z, ZS) + Cons(k z, add5 ZS) funkx.z=z +5*x Term: maph (add5 \nZS) y of type: list int Is transformed to Program: datatype a Tint+int ,n,+in, a fun map&#38;, Fsy \n ~~%(~)of Nil ~ Nil I Cons(F, Fs) * Cons(app/yTin,+i., F y, maph@ Fs y) fun add5y = case y of Nil a Nil \n I Cons(z, ZS) + Cons(C\\~,~in, z, add5 ZS) fun appiy~. Fy=case Fof c~;t$;t-~; k ~ y funkzz=z +5*x Term: \nWhere: @= li9t (int + int) + int list -+ list int.  B.3 Mutually recursive functions: Program: datatype \na dec=Decaxexp a datatype CYezp= Vma\\App ezpax ezp a\\Let deca xezpa fun fold-dec DVALx =case x of Dec(v)z) \n+ Dv (Jold-ezp D V A L z) fun fold-exp DVALx =case x of V4rv* VU lApp (y, z) + A (fold-ezp D VA L g) \n(jold-ezp D VA L z) lLet (x, z) = Let (fold-dec D V A Lx) (fold-exp D VA L z) Term: fold-ezp proj2 unit \nappend append ( Var z ) Is transformed to Program: datat ype TA+ E+E = C~~J~<E datat ype T string+E \n C%ing+z datat ype Tz+ x-tz = @~p~~~ fun jold-dec+ DVALx =case z of Dec(v, z) * app@&#38;+e+~ D v (fo~d-e~pn \nD V A L ~) fun fold-expn DVALx =case x of Var v * applyst~ng+x v v lApp (y, z) a appl&#38;_~+E A (fold-expn \nD J A L Y) (fold-exprr D V A L Z) ILet (x, z) * applyz.~+~ L (fold-declv D V A L ~) (fold-e~pn D v A \nL Z) fun applyA+=+= v x z = case v of C~4z+z * proj2 x z fun applyst~ng+x v x = case v of G ~t~&#38;+x \n* unit z fun applyx+z+x v x y = case v of C%%% * append x y Term: Where: \n\t\t\t", "proc_id": "258948", "abstract": "In 1972, Reynolds outlined a general method for eliminating functional arguments known as <i>defunctionalization</i>. The idea underlying defunctionalization is encoding a functional value as first-order data, and then realizing the applications of the encoded function via an <i>apply</i> function. Although this process is simple enough, problems arise when defunctionalization is used in a polymorphic language. In such a language, a functional argument of a higher-order function can take different type instances in different applications. As a consequence, its associated <i>apply</i> function can be untypable in the source language. In the paper we present a defunctionalization transformation which preserves typability. Moreover, the transformation imposes no restriction on functional arguments of recursive functions, and it handles functions as results as well as functions encapsulated in constructors. The key to this success is the use of type information in the defunctionalization transformation. Run-time characteristics are preserved by defunctionalization; hence, there is no performance improvement coming from the transformation itself. However closures need not be implemented to compile the transformed program.", "authors": [{"name": "Jeffrey M. Bell", "author_profile_id": "81100406444", "affiliation": "Pacific Software Research Center, Oregon Graduate Institute of Science & Technology, PO Box 91000, Portland, Oregon", "person_id": "P137557", "email_address": "", "orcid_id": ""}, {"name": "Fran&#231;oise Bellegarde", "author_profile_id": "81100095808", "affiliation": "Universit&#233; de Franche-Comt&#233; (France) and Pacific Software Research Center, Oregon Graduate Institute of Science & Technology, PO Box 91000, Portland, Oregon", "person_id": "P84986", "email_address": "", "orcid_id": ""}, {"name": "James Hook", "author_profile_id": "81341491447", "affiliation": "Pacific Software Research Center, Oregon Graduate Institute of Science & Technology, PO Box 91000, Portland, Oregon", "person_id": "PP31079957", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/258948.258953", "year": "1997", "article_id": "258953", "conference": "ICFP", "title": "Type-driven defunctionalization", "url": "http://dl.acm.org/citation.cfm?id=258953"}