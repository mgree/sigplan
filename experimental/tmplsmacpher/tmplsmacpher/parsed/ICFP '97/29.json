{"article_publication_date": "08-01-1997", "fulltext": "\n Affordable Dynamic Types Chris Dornan Department of Computer Science University College, Cork, Ireland. \nEmail: c. dornan~cs .UCC. ie * This poster considers a new approach to embedding dy\u00adnamic typing facilities \nin a statically-typed functional lan\u00adguage like ML and Haskell. Such a mechanism would help functional \nprogramming to break out of the byte-at-a-time mode of 1/0 inherited from its procedural ancestor, making \npossible, for example, the communication of polymorphic functions between processes or the storage of \nlazy streams of characters in file stores. A dynamic-type mechanism is needed here to enable the in\u00adput \nand processing of arbitrarily-typed objects in a running program in order to prevent the (statically-typed) \nprogram from going wrong. The problem with existing dynamic type proposals is that they are either too \nweak they don t support polytypes or, es their authors admit, they are rather complicated [1, $7][4, \n$6]. This proposal is baaed on simple tag comparison scheme that takes account of polytypes. In fact, \nthis proposaJ recycles an old idea from functional languages with exclusively dynamic type-disciplines. \nSASL, for example, provides the logical, number, char, list and f unct ion predicate functions for determining \nthe type of a value within a program [5]. If a value x were received from a remote sender then the following \nSASL code fragment could be used to ensure that x is a list (assuming that a list is expected) and invoke \nthe process list function to deal with it, but invoking an alternative vrong.t ype function for non\u00ad \nlist types. list x -> processlist x; urong-type This scheme works well in functional languages like \nLISP and SASL because they use automatic storage management schemes in which a garbage collector must \nperiodically tra\u00adverse a heap in which each live object is stored, collecting unused memory blocks for \nreuse. The use of the garbage collector pretty-much forces the heap to be tagged and it is easy to add \nthe run-time type tags to this scheme so that each tag is shared on a per-type baeis. The same technique \nis being proposed here. Each data declaration data List a = Cons a (List a) I Nil Advisor: Dr Ian Holyer, \nUniversity of Bristol, U.K. Permission to make digiial/hard copy of part or all this work for personal \nor classroom use is granted without fee provided that copies are not made or distributed for profit or \ncommercial advam tage, the copyright notice, the title of the publication and its date appear, and notice \nis given that copying ia by permission of ACM, Inc. To copy otherwise, to republish, to post on servers, \nor to redistribute to lists, requires prior specific permission and/or a fee ICFP 97 Amsterdam. ND @ \n1997 ACM 0-89791 -918 -1/97 /0006 ...$3.50 would provide a type-testingform, List?, which pattern can \nbe used to test for list values: case x of List? y -> processdist y --> wrong-type The run-time code \nused to implement this scheme is the same aa that for SASL, with a unique integral tag being allocated \nto the List type and stored with the heap objects used to represent list constructors; this tag is tested \nfor when the type test ia performed. From the type-checking point of view, x may be of any type, but \ny is assigned the type List -a, where .a represents an existentially quantified variable in the sense \nof Liufer and Oderaky [3]. In order to properly deal with polytypes, the data decla\u00adration is extended \nto support local type variables that can be either existentially bound [3] or universally-bound [2]. \nExis\u00adtentially bound variables allow values of arbitrary type to be encapsulated in data types while \nuniversally-bound variables provide for the transmission of polymorphic values. Though relatively simple, \nthis scheme loses little in prac\u00adtical terms over the more complicated proposals; we know of no substantial \napplication that can be better supported with the more complicated proposals [2]. Acknowledgements I \nwould like to thank Bjarte Ostvold, Jim Bowen and Alex Ferguson for their detailed comments, the CEDAS \ngroup for hearing me out and Ian Holyer, Neil Davies, Alastair Penney, Elenei Spiliopoulou, Henk MuUer \nand Pascal Ser\u00adrarens for four yeare of support and friendship.  References [1] M. Abadi, L. Cardelli, \nB. Pierce, and D. R6my. Dynamic typing in polymorphic languages. Journal o} Functional Programming, 5(1):111-130, \nJanuary 199s. [2] C.B. Dornan. Type-Secure 14eta-Programming. PhD the\u00adsis, University of Bristol, 1997. \nin preparation. [3] K. Liiufer and M. Odersky. Polymorphic type infer\u00adence and abstract data types. Transactions \nOn Program\u00adming Languages and Systems, 16(5):1411 1430, Septem\u00adber 1994. [4] X. Leroy and M. Mauny. Dynamics \nin ML. Journal of Functional Progmmming, 3(4):431-463, October 1993. [5] D. A. Turner. SASL language \nmanual. Technical Report CS/75/ 1, Department of Computing Science, University of St Andrews, September \n1975. 311  \n\t\t\t", "proc_id": "258948", "abstract": "", "authors": [{"name": "Chris Dornan", "author_profile_id": "81100211277", "affiliation": "Department of Computer Science, University College, Cork, Ireland", "person_id": "P46027", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/258948.258980", "year": "1997", "article_id": "258980", "conference": "ICFP", "title": "Affordable dynamic types (poster)", "url": "http://dl.acm.org/citation.cfm?id=258980"}