{"article_publication_date": "08-01-1997", "fulltext": "\n Flexible Representation Analysis* Zhong Shao Dept. of Computer Science Yale University New Haven, CT \n06520-8285 shao-zhongQcs. yale. edu Abstract Statically typed languages with Hindley-Milner polymor\u00adphism \nhave long been compiled using inefficient and fully boxed data representations. Recently, several new \ncom\u00ad pilation methods have been proposed to support more ef\u00adficient and unboxed multi-word representations. \nUnfortu\u00adnately, none of these techniques is fully satisfactory. For ex\u00adample, Leroy s coercion-based \napproach does not handle re\u00adcursive data types and mutable types well. The type-passing approach (proposed \nby Harper and Morrisett) handles all data objects, but it involves extensive runtime type analysis and \ncode manipulations. This paper presents a new flezible representation anal\u00adysis technique that combines \nthe best of both approaches. Our new scheme supports unboxed representations for re\u00adcursive and mutable \ntypes, yet it only requires little runtime type analysis. In fact, we show that there is a continuum \nof possibilities between the coercion-based approach and the type-passing approach. By varying the amount \nof boxing and the type information passed at runtime, a compiler can freely explore any point in the \ncontinuum-choosing from a wide range of representation strategies based on practi\u00adcal concerns. Finally, \nour new scheme also easily extends to handle type abstractions across ML-like higher-order mod\u00adules. \n1 Introduction Statically typed languages with Hindley-Milner polymor\u00adphwm [8] have long been compiled \nusing inefficient and jtdiy bozed data representations. Under these implementations, all program variablea, \nfunction closures, function parame\u00adters, and record fields are uniformly represented in exactly This \nresearch was sponsored in part by the Defense Advanced Research Projects Agency ITO under t he title \n(Building Evolutionary Software through Modular Executable Specifications and Incremental Derivations, \nDARPA Order No. D961, issued under Contract No. F30602-96-2-0232, and in part by an NSF CAREER Award \nCCFL 9501624, and NSF Grant CCR-9633390. The views and conclusions contained in this document are those \nof the authors and should not be interpreted aa representing the official policies, either expressed \nor implied, of the Defense Advanced Research Projects Agency or the U.S. Government. Permission to make \ndigital/hard copy of part or all this work for personal or classroom use is granted without fee provided \nIhat copies are not made or distributed for profit or commercial advan\u00ad tage, the copyright notice, the \ntitle of the publication and its date appear, and notice is given that copying ia by permission of ACM, \nInc. To copy otherwise, to republish, to post on servers, or to redistribute to lists, requires prior \nspecific permission and/or a fee ICFP 97 Amsterdam, ND 0 ?997 ACM 0-89791 -918 -1/97 /0006 . ..$3.50 \none word. If the natural representation of a value does not fit into one word, the value ia boxed (e.g., \nallocated on the heap) and the pointer to this boxed object is ueed instead. For example, in the following \nML code, fun quad (f ,x) = let val z = f(f(f(f(x)))) in (z: :z::nil) end Val p= (1.7, 3.1) fun rnv(x,y) \n=(x +3.1, y+2.7) function quad is a polymorphic function with type Va.(((a ~ a) *a) ~ CYlist); ~ of \nthe four calls to f inside quad must use the most conservative calling conventions passing z as a single-word \nobject. Vrdue p is a pair of floats, but since it might be passed to polymorphic functions and treated \nas objects of type a x a, its entire data structure ia fully boxed at each layer (see Figure 1a). Similarly, \ntbough function mv has monomorphic type (real* real) ~ (real x real), it cannot use any special calling \nconventions; not only it is rep resented w a boxed closure. but its ariruments and return results must \nbe assumed as fully boxed as well (see Fig\u00adure 1a). Uniform full boxing does implement polymorphism correctly, \nbut it has two major drawbacks: first, because of the boxing, monomorphic code runs much slower than \nthose written in C or assembly languages; second, since all data objects must be fully boxed, the interoperability \nwith low\u00adlevel C or assembly code is difficult and inefficient. Xavier Leroy [19] recently presented \na representa\u00adtion analysis technique that does not always require vari\u00adables be boxed in one word. In \nhis scheme. monomorphic objects such as p and mv can use efficient unbozed represen\u00adtations (see Figure \nlb): value p can stay in two floating\u00adpoint (FP) registers and function rnvcan freely pass the ar\u00adguments \nand return the results in two FP registers. When monomorphic objects are passed to polymorphic contexts \n(ss in quad(mv, p)), they are coerced back into fully boxed representations. Leroy s technique, unfortunately, \ndoes not handle recursive datatypes and mutable types well. Coer\u00adcions on large data structures are impractical \nbecause the cost of the copying often outweighs the benefits of unboxed represent at ions [19, 14]. More \nseriously, mutable data st ruc\u00adtures such as arrays cannot be copied or coerced; if we make a copy of \nthe value to box the components, then updates to the copy will not be reflected in the original array \nand vice versa. As a result, values such as lists and arrays must still use fully boxed representations, \neven when they are not inside polymorphic contexts. Harper and Morrisett [14, 24] later solved this problem \non recursive and mutable types using a type-passing approach. Under their scheme, data objects (including \nlists and arrays) Fully 130xed Rep (data are recursively boxed at each layer) Unboxed Rep (free form \nwithout any restrictions) Simply Boxed Rep (only the top-level data is boxed) Partially Boxed Rep (e.g., \nfunction must box its arguments and results) P &#38;1.7 3.1 FPRI: FPR2: 1.7 3.1 ~~ (a) (b) (c) (d) We \nuse boxed type trees to illustrate boxing for complicated type structures (e.g., MV S). Each box refers \nto one boxing layer. ML type real is abbreviated as the symbol r. Figure 1: Comparison of Various Data \nRepresentations.  are kept unboxed all the time, even inside polymorphic contexts. Polymorphism is \nnot implemented through coer\u00adcions, but by using runtime type analysis and code manip ulations. For example, \nfunction quad is implemented with an extra runtime type parameter a; all primitive operations inside \nquad (e.g., function call f (x), list cons z: :nil) must anaIyze the type (a) at runtime in order to \nselect and dis\u00adpatch to the appropriate code to manipulate unboxed ob\u00adjects. The type-passing approach \nis still not satisfactory, for the following reasons: . Although monomorphic code can fully take advantages \nof the unboxed representations, polymorphic code be\u00adcomes much slower than the full-boxing approach. \nIn fact, all primitive operations inside polymorphic con\u00adtexts are no longer primitive: simple function \ncalls (or returns) and record operations (e.g., creation, selec\u00adtion, list cons) now become either indirect \nprocedure calls or large typerec switches [24]. Compiler opti\u00admization such as type specialization may \neliminate part of these overheads, but they can lead to code ex\u00adplosions or excessively long compile \ntime. . A more severe problem, also called the varatw vrob\u00adlern (see [24, page 216 and 175] for details), \nis ~h~ im\u00adplementation of function definitions and function calls with arguments of unknown types (e.g., \nthe applica\u00adtion of f inside quad). The challenge is to simulate the advanced calling conventions baaed \non the runtime type information (since the actual f may use any call\u00ading conventions). For machines with \nk argument reg\u00adisters (including FP registers), this would require 2k cases (e.g., entrant code, coercions) \nto deal with all the possible calling conventions [24]. Actually, mod\u00adern compilers often use even more \nelaborate calling conventions [5, 17] making the above simulation vir\u00adtually impossible. Of course, one \ncould always resort to runtime code genemtion [18, 4, 9] or simply use a very restricted set of calhng \nconventions [24], but then, either the cost is too expensive or the interoperability suffers.  This \npaper presents a new flexible representation analysis technique that combines the best of both the coercion-based \nand the type-psssing approaches. Our new scheme supports unboxed representations for recursive and mutable \ntypes, yet it only requires little runtime type analysis. Our idea is sim\u00adple: we avoid the heavy-weight \nruntime type manipulations by boxing all polymorphic values; however, instead of doing full boxing se \nin the coercion-baeed approach [19], we use the simpl~ boxed representation (see Figure lc) or other \npartially boxed representations (see Figure Id). Intuitively, a simply boxed object just boxes the top \nlayer of the data structure so that the entire object can be referenced aa a single-word pointer. Simple \nboxing is generally much cheaper than full boxing, and most of the time, it is just an identity function \nbecause the natural representations of many unboxed ob\u00adjects (e.g., lists, closures, records, arrays) \nare already simply boxed. Simple boxing solves the problem of recursive and mutable types because any \nsimply boxed object can be ese\u00adily unboxed (at the top layer) before being cons-cd onto lists or put \ninside arrays. Simple boxing is trickier to implement than full boxing because the coercion may also \nrely on runtime type informa\u00adtion. For example, coercing an object of type /3* ~ into type w would involve \nfirst unboxing the @ and Y fields, and then pairing them up based on the actual types /3 and y have at \nruntime. More interestingly, there is a continuum of freedom be\u00ad tween the coercion-based and the type-passing \napproaches: by varying the amount of boxing and the type information passed at runtime, a compiler can \nfreely explore any point in the continuum, choosing from a wide range of representa\u00adtion strategies as \nthe canonical bozedform. This flexibilityy is particularly nice because one can trade boxing with runtime \ntype manipulations on the per-tycon (i.e., type constructor) basis. For example, using the partially \nboxed representation shown in Figure Id, we can completely elirrinate the vararg problem in the type-passing \napproach (see later sections for more details). The main contributions of this paper are: . Among all \nthe known coercion-based approaches [19, 26, 27, 15, 33, 36], our scheme is the first to successfully \nsolve the open problem on recursive and mutable types. (a) list fully boxed list CiiEiE-z (b) list simply \nboxed list A Clr r ZRT?i7k (c) list I flat list z~ A r r val z : (real * real) list = [(4.51,3.14),(4.51,2.33),.... \n(7.81,3.45)] Figure 2: Comparison of Various List Representations Unlike the type-passing approaches \n[25, 14, 24, 34], our scheme requires little runtime type analysis, even for the heavily polymorphic \nprograms. Our scheme is very flexible because a compiler can trade boxing with runtime type analysis \non the per\u00adtycon baais. In Section 3, we present a formal frame\u00adwork and a set of axioms that precisely \ncharacterize this trade-off. By choosing partially boxed representations (e.g., Fig\u00adure Id) as the canonical \nboxed form, our scheme can completely eliminate the nasty vararg problem. We extend Leroy s representation \nanalysis to a predica\u00adtive variant of the polymorphic ,1-calculus FW[10, 28]. We show that our technique \nworks for both the ML\u00adstyle polymorphism and the Fw-like higher-order poly\u00admorphism. We show how easily \nour scheme can be extended to handle type abstractions across ML-like higher-order modules [22, 21, 11, \n20]. We show that with a simple twist based on the para\u00admetricity property, most runtime type manipulations \nin our scheme can be eliminated. We have implemented our scheme (with partially boxed representations) \nin an experimental version of the SML/NJ compiler [3, 33]. Preliminary measure\u00adments show that code involving \nrecursive and mutable types gets significant speedup while normal polymor\u00adphic code remains almost as \nefficient as before. In the rest of this paper, we first give an informal presen\u00adtation of the main idea. \nWe then formalize the presentation and give several major theorems about our flexible approach. We also \nshow how to extend our scheme to handle the en\u00adtire ML language [22]. Finally, we discuss the experimented \nresults, the related work, and then conclude. 2 Informal Development In this section, we present a series \nof examples in which we il\u00adlustrate both previous approaches and our flexible approach to the implementation \nof polymorphism. 2.1 Canonical boxed form The key to the implementation of polymorphism lies on how to \ndefine the canonical bozed form given a polymorphic ob\u00adject of type a (a single type variable), what \nshould its rep resentation be like ? Of course, the representation depends on the actual instantiation \nof W. So assume a is instantiated into type r, how do we represent such a value of type r ? Canonical \nboxed form used in all the coercion-based ap preaches is indeed always boxed. That is, it can be handled \nas a single-word object. This dramatically simplifies the im\u00adplementation of polymorphism, because all \nobjects of type a can be manipulated in the same way regardless of what a really is. For example, primitive \noperations such as func\u00adtion applications and record operations can all be inlined at compile time: a \nvalue of type a * @ can be built by simply creating a two-word record, each containing the correspond\u00ading \nboxed value, and so on. In type-passing approaches, the canonical boxed form is not always boxed, so \nit may not fit in one word; this makes all polymorphic primitive operations dependent on runtime types. \nOnce the canonical boxed form is decided, two primitive coercion functions can be defined: urap[r] converts \na value of type r from its natural unboxed form into the correspond\u00ading canonical boxed form simulating \na value of type a; unwrap[r] does the reverse, Coercions for more complicated types can be inductively \ndefined based on these two primitive coercions (see Sec\u00adtion 3.5 or Leroy [19] for more details). For \nexample, to im\u00adplement the function application quad(mv, p) defined ear\u00adlier, w is coerced from (real* \nreal) -+ (real * real) to a + a as follows (assuming a call-by-value semantics): mu = ,4v : cr.urap[r*r](rnv( \nunvra~r*r]( ~))); then p is coerced into p = urap[r*r](p), and the function call to quad( mv ,p ) is \nperformed. 87 list foo(p) I cons ? list pJ\\ r =ml r but we really want   A I ;r r list rr [ /~ ,_. \n19 r / mlr bar(p) Figure 3: Coercion Must Commute with Type Instantiations Coercion-based approaches \nwould have worked nicely if all data objects were coercible. Unfortunately, many com\u00admonly used objects \nare incoercible. Coercions on large data structures are impractical because the cost of the copying of\u00adten \noutweighs the benefits of unboxed representations [19]. More seriously, mutable data structures such \nas arrays can\u00adnot be copied or coerced; if we make a copy of the value to box the components, then updates \nto the copy will not be reflected in the original array and vice versa. Therefore, all coercions on recursive \nand mutable objects must be treated aa identity functions. In the earlier example, the result of quad( \nmu ,p ) should be coerced from a list to (real *real) list. But since this is too expensive, the list \nis not coerced. This forces all lists of type (real * real) list to use same representations as those \nfor a list, (/3* y) list, or (/3* real) list, etc., since they can all possibly be instantiated into \n(real* real) list. For this reason, all previous coercion-b=ed approaches use full boxing as the canonical \nboxed form. Unlike other monomorphic values, monomorphic lists such as (real* real) 1ist and arrays must \nalways use the fully boxed rep\u00adresentations es shown in Figure 2a. 2.2 Simply boxed representations Our \nmain idea is to use the simply boxed or partially boxed representations as the canonical boxed form. \nSimple boxing just boxes the top layer of a data structure. For example, simple boxing of the value p \nwould just build a flat vector of floats (see Figure lc). Under simple boxing, application of quad( mu \n,p ) would return a simply boxed list as shown in Figure 2b. It is easy to simply box monomorphic values \nsuch as real * real, but what about polymorphic values such es ~ *7, or ~ *real, or real*y ? More generally, \nhow to define urap[r] and unurap[r] if r contains type variables ? One could attempt to box /3* real \nby treating @ as a sin\u00adgle word. This does not go very far. Consider the following ML code: fun foo(x, \ny) = (x, y+3.0): :nil fun bar(x, y) = (x+3.0, y): :nil Here, foo has type VP.(/3* real) ~ ((3* real) \nlist and bar has type V~.(real * ~) ~ (real* y) list. The list cons operation :: has type VcY.(cv*cr \nlist) ~ a list, so the pairs inside foo and bar will be coerced by either urap[~ * real] or vrap[real \n* y] before being cons-cd onto the empty list. Figure 3 shows the corresponding coercions inserted when \nwe apply foo and bar to p. Clearly, neither produces the simply boxed list. The cor\u00adrect definition of \nvrap~ * real] (or imap[real * y]) is, of course, to first uncouer (unbox) the ~ or y field and then build \nthe exact same vector as in Figure lc. The uncover operation does not have to be done recursively because \nby invariant, ~ is already in the simply boxed form. Uncover\u00ading does require the use of runtime type \ninformation (the actual type of L?);this is realized in the same way as in the type-passing approach \n[14]. One important insight we get here is that a boxing scheme can serve as a vaiid canonical boxed \nform only if it commutes with the type instantiation relations. A type variable CYcan be instantiated \ninto either ~ * real or real *y, then further into real * real; whichever path it takes, the two resulting \nboxed forms (and their corresponding coercions) must be equivalent (see Section 3.5 for the details). \nIn most compilers, data structures like lists often use the simply boxed form as their default monomorphic \nrepresen\u00adtations. This fits extremely well with simple boxing because most common list functions (e.g., \ncons, map, fold, length, append) remain aa efficient as they could be. For example, in the following \nML code: fun mapf 1 = let fun [ (a::r) = (f a) :: (m r) I [ nil = nil inml end val z = [(4.5, 3.1), (4.3, \n2.0), . ..] val nz =map mv z Here map has type Vcr/3.(cY+ /3) + (a list + @ list), so function MVis \ncoerced into mu (defined before in Sec\u00adtion 2.I). List z is incoercible, so it is not coerced. When the \ninternal loop IIItraverses the list, the only invariant it re\u00adquires is that every element be a single-word \npointer. Simple boxing does satisfy this invariant, so no extra coercions or runtime type analysis are \nnecessary. There are cases where simple boxing requires more coer\u00adcions than full boxing. These situations \nare often less com\u00admon, and when they occur, the coercions are always kept at the minimum. For example, \nwhen applying the follow\u00ading function unzip, which has type Vex@.(a * ~) list ~ o list * /3 list, to \nthe simply boxed list z in Figure 2b, fun unzip 1 = let fun h((a, b)::r, u, U) = h(r, a::u, b::u) I h(nil, \nu, u) = (rev u, rev W) in h(l, nil, nil) end the only coercion necessary occurs when applying the :: \npro\u00adjection to (a ,b) ::r where each list element (a flat float vec\u00ad tor) is coerced into a standard \nboxed record of type a * 6. (through urmrap[cr * ~]). Simple boxing also supports flat lists as shown \nin Fig\u00adure 2C and flat arrays easily because any simply boxed ob\u00adject can be uncovered at the top layer \nonly 1 and then be cons-cd onto lists or put inside arrays. Of course, all poly\u00admorphic list and array \nprimitives will now become partially dependent on the runtime types. 2.3 Partially boxed representations \nOne problem with simple boxing is that their primitive co\u00adercions, urap[r] and unvrap[r], may also run \ninto the nsst y vararg problem encountered in the type-paesing approach. Fortunately, by using the partially \nboxed representations (such as the one in Figure Id) as the canonical boxed form, we can completely avoid \nthis problem. Partial boxing here is similar to simple boxing, except it also maintains the invari\u00adant \nthat all function arguments and results are also partiallg bozed into a single word. Under partial boxing, \ncoercions on unknown function types never depend on runtime types. For example, un\u00adder simple boxing, \nvrap[a + /3] would need to uncover a and /3; this is not necessary under partial boxing because by invariant, \na and /3 should already be in the partially boxed form. The effect of using partial boxing on the rest \nof the code is very minor. Data structures such as (real* real) list are represented exactly same = those \nunder simple boxing. Flat lists or flat arrays can still be built through the simple uncov\u00adering. AU \nmonomorphic functions such as (real * real) -+ real can stiIl use the special calling conventions (passing \narguments in FP registers, etc); they will be partially boxed only if they are put inside data structures \nsuch as liits and arrays. Variant A Variant B multi-argument (or multi-return-result ) functions can \npass each argument (or result) in designated general\u00adpurpose registers. The vararg problem is not com\u00adpletely \neliminated because coercing a boxed value into a function of type a ~ ~ requires examining the run\u00adtime \ntype of a and /3. c Variant B is same as variant A except we let the entire return results be boxed as \nin the standard partial box\u00ad ing approach. Since most functions have a single re\u00adturn result (always \ntrue in C and assembly) this might be a good compromise. Of course, we could limit the number of arguments \nalso (e.g., allow 5 boxed args maximum); doing so would further simplify the imple\u00admentation of the vararg \ncoercions. This kind of flexibility is very useful when we compile languages with a richer set of type \nconstructors. One can imagine to have several different record or function tycons: all would work in \nany contexts, but some perform better on the monomorphic code and others do better on the polymor\u00adphic \nones. The flexible framework also gives us finer control on the boxing degrees, making it easier to interoperate \neffi\u00adciently with lower-level C and assembly code. 3 Formalization In this section, we present a formal \nframework to explain our flexible representation analysis techniques. Instead of performing the analysis \ndirectly on the ML source language (SRC), we use a predicative variant of the polymorphic A\u00adcalculus \nFW [10, 28, 14] as the intermediate language (IL). Representation analysis is then expressed as a type-directed \nprogram transformation that automatically inserts coercions and translates IL programs into the target \nimplementation CalCUIUS (TGT also known ss Ai ~ [14]). The benefit of doing it this way is to show that \nour analysis works not only on the ML-like polymorphism [8] but on the more general higher-order polymorphism \naa well. The rest of this section is organized m follows: we first give the syntax and semantics of the \nthree languages: SRC, IL, and TGT; we show how to embed the SRC language Bv into IL, and then presents \nthe IL-t~TGT translation algo\u00ad  A-h EE(il-h rithm that does the representation analysis; we prove the \nFigure 4: Two Variants of Partial Boxing 2.4 Other valid boxing schemes Simple boxing and partial boxing \nare not the only possible boxing schemes. In fact, one of our main contributions is to give the precise \nconditions (in Section 3) about what kind of boxing schemes can serve as the valid canonical boxed form. \nThere is actually a continuum of possibilities between full boxing and no boxing. For example, Figure \n4 gives two interesting variants of the partial boxing scheme, each with different trade-offs on the \nvararg problem: . In variant A, instead of boxing the entire arguments or results into a single word, \nwe box each individual argument and return result only. This means that 1~lly box~ ~bj=ts are recursively \nboxed at e~h laYer, so they cannot be easily uncovered. type correctness and the semantic correctness \nof our trans\u00adlation, and then give a set of axioms that characterize the valid canonical boxing schemes; \nfinally, we formally define simple boxing and partial boxing, and show why they all satisfy these axioms. \n3.1 Source language: SRC We use a variant of Mini-ML [7] as our source language (SRC). Its syntax is \ndefined by the following grammar: (monotypes)  (Jxdytps) (terrn9) (values) r ::= tlintlreallrl*m I \nrl+r21r pack a ::= rIW.a e ::= zlil~[(el,ez)lrlelmze I elez [ k.e I pke Iupke I letz=vine v ::= zlilfl(ul,tiz)l~z.elpkv \n Here, monotypes r are either type variables (t), int, real, binary product types, arrow types, or pack \ntypes. Poly\u00adtypes (i.e., type schemes) o are either monotypes or prenex quantified types. Terms e consist \nof identifiers (z), inte\u00adger constants (i), float constants (~), pairs, first and second projections, \nabstractions. applications, let expressions, and packing and unpacking expressions. Values (v) are a \nsubset of terms and include identifiers, constants, pair of values, abstractions, and packed values. \nThe static and dynamic semantics for SRC are all stan\u00addard and same as those for Mini-ML (see [7, 14, \n24]). The type inference rule (given later as part of the translation fromSRCtoILinFigure6)isintheformofA;r \nFe:r where A is a set of free type variables, and r is a type envi\u00adronment mapping identifiers to polytypes. \nWe also restrict the let-bound expressions to values [37] so that type abstrac\u00adtions can be made explicit \nin the translation. The natural (cdl-by-value) dynamic semantics for SRC can be defined as e -. u where \ne is a closed expression and v is a closed value. To show how our techniques apply to arbitrary recursive \nor mutable types, we introduce a special type constructor named pack in SRC. The typing rules and the \noperational semantics for packing and unpacking are defined as foUows: and application forms. The values \ndefined here are closed and used by the operational semantics; to account for the packed values, we use \nPKP(v) to denote the result of applying term Pk[p] to vafue v. This calculus is predicative because term \nexpressions can only be applied to constructors (~) but not arbitrary polymorphic types (u). A;rke:r \nA;rl-pke:r pack A; I 1-e:r A;rkupke:r pack e-au pke~spkv e-, pkv upk e -~ v The static semantics of \nIL, given in Figure 5, consists of a collection of rules for constructor formation, construc\u00adtor equivalence, \ntype formation, type equivalence, and term formation. The term formation rules are in the form of A;r \n1-e : u where A is a kind environment mapping type variables to kinds, and I is the type environment. \nApart from the standard language constructs [14], the pack\u00ading primitives have the following types: Pk \n: W :: Q.T(t) ~ T(Pack(t)) Upk : W ::Q T(Pack(t)) ~ T(t) The natural (cafl-by-vslue) dynamic semantics \nfor IL, also given in Figure 5, is defined as a set of axioms in the form of e -, v where e is a closed \nterm and v is a closed value. Because IL is very much like Harper and Mitchell s ,4 L [12], we can show \nin the similar way that type-checking for IL is decidable, and furthermore, its typing rules are consistent \nwith the operation semantics. 3.3 Translation from SRC to IL We divide all type constructors into two \ncategories: co\u00adercible tycons are those type constructors whose values can be readily coerced at runtime; \nincoercible tycons are those whose values cannot be coerced because either it is too ex\u00adpensive or it \nviolates the semantics. For example, int, real, binary product, and arrow tycons are usually coercible \nty\u00adcons; alI recursive and mutable tycons (e.g., lists, arrays) are incoercible tycons. To simplify the \npresentation, we use pack to serve as a representative for incoercible tycons; however, all techniques \ndescribed here easily carry to other incoercible tycons.  3.2 Intermediate language: IL We use a predicative \nvariant [12, 14] of the polymorphic ~\u00adcalculus FU [1O, 28] as our intermediate language. The four syntactic \nclasses for IL, kinds (K), constructors (p), types (u), and terms (e), are defined as follows: (kinds) \nK ::= Q/KI+ IG2 (con s) p ::= t I Int I Ileal I Pack(#) la (PI, M) I X(P1,P2) IJt ::~.p IM[P21 (type9) \nu ::= T(p) Ial + C7zIUI x U2 I Vt :: fc.a (terms) e ::= zliljl Pkl Upkl{el, e2)l r1el~2e I Az : cr.e \nI @ele2 I At :: x.e I e[p] (vaiues) v ::= i ! $ I Pk I Upk I PKu(v) I (vi, v2) I AX :u.e IAt ::~.e Here, \nkinds classify constructors, and types classify terms. Constructors of kind Q name monotypes. The monotypes \nare generated from variables, Int, Real through the con\u00adstructors ~, x, and Pack; here, Pack is the counterpart \nof the pack tycon in SRC. The application and abstraction con\u00ad structors correspond to the function kind \nK1 ~ KZ. Types in IL include the monotypes, and are closed under prod\u00aducts, function spaces, and polymorphic \nquantification. Like Harper and Morrieett [14], we use T(p) to denote the type corresponding to the constructor \np. The terms are an explic\u00aditly typed A-calculus with explicit constructor abstraction In Figure 6, we \ngive a type-directed embedding of SRC into IL. This is very similar to the translation from Cor~ML to \nXML, given by Harper and Mitchell [12]. The translation is defined as a relation A; r 1-e, : r ~ e, that \ncarries the meaning that A; r F e. : r is a derivable typing in SRC and that the translation of the SRC \nterm e. determined by that typing derivation is the IL term e,. Here, the (oar) rule turns the SRC implicit \ninstantiation of type variables into the IL explicit type application; the (pk/upk) rule shows the pack/unpack \nterms in SRC are implemented by polymorphic primitives Pk and Upk in IL; the (let) rule converts the \nSRC let expressions into normal IL function applications; the rest of the rules are all straight-forward. \nThe translations from SRC monotypes to IL construc\u00adtors (writ ten as rm ) and from SRC polytypes into \nIL types (written as a ) are defined as follows: t =t intro = Int real = Real (rI * T2) = x(r~, r~) \n(7I ~ rz)m = + (r~,r~) (r pack)m = Pack(rm) = T(rm) (Vt.a;: = Vt :: $2.U We write AP for the kind assignment \nmapping tto the kind Q for each tc A, and I p for the type environment mapping z to (r(z)) for each x \nE l)om(r ). The following standard type preservation theorem can be proved by structural in\u00adduction on \nthe translation rules: Theorem 3.1 l.. A;I !-e, : r~ ei, then AP; I 1-e: : r . A semantic correctness \ntheorem about this embedding can also be stated and proved using the standard logical-relations technique \n[24, 19].  Constructor Formation and Constructor Equivalence: ( tuar/tcon) Av{t::K}Dt::tc AD Int::~ \nA D Real :: Q ADp::fl A~pl::fl Abpz::fl ADpl::Q AD I.Q::Q (pk/fi/pair) A D Pack(p) :: ~ A D X( PI, P2)::~ \nAD ~(pl,pz)::fl AIiI{t::K }DpI::K ADp2::K (cequiv) A D (At :: /c ./.4I)[P2] E [/L2/t]#l :: K Type Formation \nand Type Equivalence: ADp::fl APUI ADOZ ADUI A~uz Aw{t::K}ou (tjorm) AD T(p) ADISIXOZ ADC1-CZ A D Vt::K.U \nTerm Formation: (const/uar) A;~ 1-i:Int A;r 1-j: Real Air t-Z:r(z) (pk/upk) A;r 1-Pk : Vt :: Q.T(t) \n~ T(Pack(t)) A; r 1-Upk: W:: $2.T(Pack(t)) ~ T(t) A;rl-el:ul A;rl-ez:az A;rt-e:olxuz (pair/ith) (1=1,2) \nA;r 1-(el, ez):ul xuz A;rl-xle:ml A;r M{z: al} F e:crz A;rt-el:a 4a A;rl-es:u (Wwp) A;r i-~z:al.e:al~crz \nA;r i-Qelez :U Aw{t:x}; rt-e:a ADp:; IC A;rl-e:Vt::~.u (tjn/tapp) A;r 1-At ::ice :Vt::K.U A; I i-e[p]: \n[p/t]@ Natural Dynamic Semantics: e] +, .4z : u .e ez +, v [v /z]e i V ea +i At :: K.e [p/t]e Q, w V+, \nv @ele2 i W e[p] i V e+; v e Qi PKP(V) el f-+, V1 e2 +1 v2 e i (7M,v2) (j= 1,2)@(Pk[p])(e) -i PK~(v) \n(e~,ez) 1 (v~,vz) rle -, vJ @(Upk[p])(e) ~~ v Figure 5: The Static and Dynamic Semantics for IL (const) \n(uar) (pk/upk)  (patr/ith) (fn/aPP) (let) A:rl-i:int+t A;rkf:real+f r(z) = w, .,. tn. r p={t, wr, [i=l,. \n... n} FTV(p(T))CA A;r 1-z : p(r)* Z[rr] [r:] A;r Ee:r~e f3; l_ 1-e:rpack*e A;r 1-pk e : r pack ~ @(Pk[# \n])(e ) A; r 1-upk e : r ~ @(Upk[rm])(e ) A; I 1-el:rlaej A;rl-ez:rz~e\\ A;rl-e:rl*~z~e (i= 1,2) A;r 1-(el, \nez) :T1 *r2* (e~, ej) A;r R x,e : ~1+ ifle A;r M{z:rl}Fe:rz~e A;rl-el:r ~r~e{ A;ri-ez:r ~e~ A;r t-Az.e \n: n ~ T2~ Az : r~.e A;r 1-elez : r~@eje~ Au{il, ....~n}.r~ v:ro~e~ UO=VtI,... ,tTOTO A;rkl{z:ao] 1-e:r~e~ \nA;r 1-let z = v in e : r + @(Az : u~.e~)(Atl :: fl,..., At~ :: fl.ej) Figure 6: Translation from SRC \nto IL  3.4 Target language: TGT The target language (TGT) for our representation analysis is very similar \nto Harper and Morrisett s ~i L [14]. In fact, because our IL is much like A ~ TGT is essentially the \npreviously defined IL plus Harper and Morrieett s typerec forms [14]. The four syntactic classes for \nTGT, kinds (K), constructors (p), types (a), and terms (e), are defined as fouows: [khnd~)7 ~ P ::= .. \n.. . . .. .. same as in IL IL constructors ... ... I Boxed(p) 1 Typerec# of (flil#rlfl-l#xl#p!P~) (types) \nu ::= . .. same as in IL ... (terms) e ::= ... IL terms ... I box I unbox I typerec p of [t.u](eile,le-le \n~lePle~) (values) v ::= ... IL vaiues .. . [ box I unbox I BX~(v) Here, the Typerec and t yperec forms \nare the keys for in\u00adtensimal type anai@ [14]. They provide the abfity to de\u00adfine new constructors and \nterms by structural induction on monotypes. Also, Boxed is a new special primitive boxing constructor; \nbox and unbox are two new term-level boxing primitives with the following types: box : W ::Q.T(t)+ T(Boxed(t)) \nrmbox : Vt ::0. T(Boxed(t)) ~ T(t) Intuitively, Boxe~fl] denotes the boxed version of a given constructor \n(monotype) p. We intentionally treat these as primitives because how they are actually implemented does \nnot affect the correctness of our representation analysis. As in IL, the values defined here are closed \nand used in the operational semantics; we use BXX(V) to denote the boxed value of applying term box[p] \nto value v. The static semantics for TGT is almost identical to those for IL in Figure 5 (the TR version \nof this paper [30] contains the details); the additional rules for Typerec and typerec are same as those \nin Harper and Morrisett [14]. The operational semantics for TGT, written u e -~ v, is similar to those \nfor IL also. Harper and Morrisett [14, 24] have shown that type\u00ad checking for APL is decidable, and furthermore, \nits typing rules are consistent with the operation semantics. Similar results hold for our target language \nTGT. 3.5 Translation from IL to TGT Now that we have translated SRC into IL and given the syntax and \nsemantics of TGT, representation analysis can be expressed as a type-directed transformation from IL \nprc\u00adgrams to TGT programs. This translation is defined as a relation A; r 1-ea : r +-et that carries \nthe meaning that A; I 1-ei : r is a derivable typing in IL and that the translation of the IL term el \ndetermined by that typing derivation is the TGT term et. We begin by introducing a special constructor \nWrap :: Cl~ Q and a pair of primitive operations: wrap : Vt :: Q. Z (t) a Z (ilrap[t]) unwrap: Vt :: \nQ. T(Hra~t]) ~ T(t) Intuitively, Ura~p] denotes the canonical boxed form of a given constructor (monotype) \np; wrap and unwrap are ex\u00adactly those primitive coercion operations mentioned in Sec\u00adtion 2.1. We intentionally \ndelay their definitions in order to show that the representation analysis framework described here does \nnot depend on any particular wrapping schemes. Both the constructor and the primitives will be defined \nlater in Section 3.6, using Typerec, typerec, and the basic boxing primitives box and unbox. The translation \nfrom IL constructors to TGT construc\u00adtors, written ss IAu,is defined as follows: t t Int Int RealU Real \n(X(p,, p,)) X(p; ,p;) (+ (M , P2)) + (P:$P;) (Pack(p)) Pack(Urap[p]) (At :: K.IJ) At :: IC.pu (M [P21)U \nIA [P:] Notice this translation is almost a trivial identity mapping except that incoercible tycons \nsuch as Pack are treated spe\u00adcially: the element type p is translated into a wrapped version of itself, \nIncoercible data structures (in TGT) will not change its representations when switching between the monomorphic \nand polymorphic contexts. (base) A;r Lc:-+c (c= i, f, Pk, Upk) (P@) A;rl-el:ul+e\\ A;r 1-(el, ez):ul A;rl-e2:u2+e~ \nxuz+(e(,e~) A;ri-e:ulxm. A;rF~ie:~i+~i +e (i= 1,2) (fn/ap) A;r A; 1 w{z:ul}l-e:u2 *e 1-Az:al.e: ul~u2*Az:u~. \ne A;rt-el:d+a A;r se\\ t-Qelez A;rl-e2:u +ej : u * @eiej A;r 1-e : Vt :: x.u * e e: = CC([pw/t]u , [p \n/t]a ) (tapp) A; r 1-e[p] : [p/t]u + @e~(e [pw]) Figure 7: Translation from IL to TGT  Cc(x(pj, p;), \nX(pl,pz)) CC(+ (P; ,A),+ (Pi,P2)) Cc(p ,p) Cc(Urap[p], p) Cc(p, Urap[p])  cT(z (# ), i (p)) c7(vt :: \nKA7 ,vt :: W) c7(a; x aj, al x c-r2) C7(C7;+ C7:,C71+ C72) = c7(T(p;)x T(pj), I (JJ,) x T(p2)) = cT(T(/.l; \n) + T(/J;), T(/J, ) + T(p2)) = ident itfip] ifp~p!andA~p::fl = unura~p] = Wrap[p] = Cc(/J ,V) = Af: \nW ::K.u .(At :: K.(@(CT(a , a))(f[t]))) = AZ :aj x a!. (@(cT(a;))(Tlz),Cr2))(T2z)) ,C7,@(c7(fY4,= V:d+&#38;Az \n:~1. (@(c7(a:, c72))(@(f)(@(c f (ul, u;))(z)))) Figure 8: The Coercion Generator The translation from \nIL types to TGT types, written as a , is just a simple extension of p : T(p)ti = T(pti) (Vt :: K.U)U \n= Vt :: Ic.u (IY,x a,) = O?xu; (al+ az) = u:-m; Finally, to make the presentation easier, we use pw \nto denote the wrapped version of the above translation p . For any IL constructor p, ~w applies the Urap \nconstructor to the result of pti: P = Urap[p ] ifflbp::f) = (At :: ict[t ])wif APt::fc+fc (At :: K./b:; \n= At :: K.pW (141[P21)W = X [PH Notice when ,u is a constructor with higher-order kinds, wrapping is \nperformed recursively on the body of the con\u00adstructor. Given a substitution p mapping t to IL constructors, \nwe write p and pw as the new substitutions mapping tto (p(~)) and (p(t))w for each tE Dom(p). We also \nwrite A for the kind assignment mapping t to the same kind A(t) for each t E Dom (A), and I for the \ntype environment mapping z to (17(z)) for each z c ~om(r). We define a set of axioms that characterize \nthe valid canonical boxing schemes and give two propositions about the type translation. Both propositions \ncan be proved by inductions on the syntactic structures of the IL constructors and types. Definition \n3.2 (valid canonical boxed form) Given a constructor definition for Wrap in TGT, we say it is in the \nvalid canonical boxed form it it commutes with substitution and the following constructor equivalence \nrules can be de\u00ad rived in TGT: Urap[p] S Urap[Urap[p]] Wra~x(jtl, p2)] E Urap[x (Wra~pl], Wrap[p2])] \nHrap[+ (flI, p2)] ~ Urap[+ (Urap[p~], Urap[p2])] J40re generall~, if SRC contains more coercible constructors \nsuch as x with arity k (k > 0), and ,y is its counterpart in IL and TGT, then Urap[x (pl, . . . . ~k)] \nmust be equivalent tO hkap[x (wrap[pl], . . . . wrap[~k])]. Proposition 3.3 Ij Hrap is in the valid canonical \nbozed form, then both p and u commute with substitution. More specifically, suppose p is a substitution \nmapping t to IL con\u00adstructors, g is an IL constructor, and u is an IL type, then (P(P))Us P (PU) and \n(P(u)) s PU(C+ ). Proposition 3.4 If Wrap is in the valid canonical boxed form, then p commutes with \nsubstitution. More specifically, suppose p is a substitution mapping t to IL constructors and p is an \nIL constructor, then (p(u))w s pw(pw). The term translation rules are given in Figure 7 as a series of \ninference rules that parallel the typing rules for IL. Most of these rules are straight-forward. The \nonly interesting case isthe ( tapp) rule; this is the place where representation co\u00adercions are inserted. \nNotice we always wrap the argument constructor p before doing the type application; this reflects the \ninvariant that all TGT values with unknown type are always wrapped. The coercion term e; is generated \nat cotn\u00adpde time by the coercion generators CC and Gr defined m Figure 8. Here, identity is the polymorphic \nidentity func\u00adtion. Given a pair of TGT types u and u, the result of C-T(U ,o) is a TGT term that coerces \nvalues of type u into those of type a; similarly, given a pair of TGT constructors p and p, Cc(p , p) \nreturns a TGT term that coerces values of type T(p ) into those of type Z (p). In essence, our co\u00adercion \ngenerator plays the same role as Leroy [19] s S and G transformations. The following proposition shows \nthat the coercions generated above remedy the type mismatches caused by constructor wrapping during type \napplication: Proposition 3.5 Suppose Wrap is in the valid canonical bozed jorm, p is a substitution mapping \nt to IL con\u00adstructors, c is an IL type. If A;r 1-z: pw(u ), then A; r 1-KI(C7(P (U ),: Similarly, ij \n Pa )) PU(U ); A;r 1-z : P (a ), then A;r 1-@(CT(p (U ), pw()))(r)(r) : p (a ); Theorem 3.6 (type preservation) \nIf Urap is in the valid canonical bozed jorm and A; r 1-ei :u* et, then A ;r F et: a . The type preservation \ntheorem can be proved by structural inductions on the translation rules, using Proposition 3.3 3.5. A \nsemantic correctness theorem about the transla\u00adtion can also be stated and proved using the same logical\u00adrelations \ntechnique used in Morrisett [24] and Leroy [19].  3.6 Valid canonical boxing schemes A boxing scheme \nis valid if its underlying constructor Wrap is in the valid canonical boxed form. Intuitively, the set \nof axioms in the Definition 3.2 guarantees that coercions baaed on the Iirap will commute with the type \ninstantiation relations. The boxing schemes described in Section 2, simple box\u00ading, partial boxing, and \nfull boxing, can be formally mod\u00adelled by defining the constructor Urap and the primitives wrap and umrrap. \nMore soph~ticated partial boxing schemes such as those described in Section 2.4 can be defined in the \nsimilar way. Definition 3.7 (simple boxing) The constructor Urap for simple boxina is defined as follows \n(here we use the pattern-match clauses to express the Typerec form): Urap[fl] = Boxed(Uncv[p]) Uncv[Int] \n= Int Unc@teal] = Real Unc~Pack(p)] = Pack(p) Uncv[Boxed(p)] Uncv[x (p], pz)] = ; (Uncv[yl], Wcv[P21) \nUncv[-+ (P1 , p2)] = ~ (Uncv[pl], Uncv[pz]) Definition 3.8 (partial boxing) The constructor Wrap jorpartial \nboxing is dejined in the same way as simple boxing, ezcept that the rule for ~cv[+ (PI, u2)] is replaced \nby the following: Uncv[~ (AI, ,uz)] =+ (Boxed(Uncv[pl]), Boxed(Uncv[pz])) Definition 3.9 (full boxing) \nThe constructor Hrap for full boxing is dejined in the same way as partial boxing, ezcept that the rule \nfor Uncv[x(pl, PZ)] is replaced by the following: Uncv[x (P1, pz)] = x (Boxed(Uncv[pl]), Boxed(Uncv[pz])) \nProposition 3.1o The simple-boxing constructor wrap is in the valid canonical boxed form. Proof First, \nWrap[p] commutes with substitutions because Wrap[p] = Boxed(Uncv[#] ), and both Boxed and Uncv com\u00admute \nwith substitutions; Boxed is a primitive constructor, and Uncv is a simple Typerec-form constructor (which \ncan be shown to commute with substitutions using structural inductions, foUowing from the constructor \nequivalence rules on Typerec defined in Harper and Morrisett [14, 24]). Second, we prove Wrap[p] s Urap[tfrap[p]]. \nFrom the definition of Uncv, we have Uncv[Boxed(p)] = p for any p, therefore: 14rap[Urap[p]] -Boxed(Uncv[Boxed(Uncv[p] \n)]) = Boxed(Uncv[#]) S Urap[p]. To prove Urap[x(pl, pz)] s hh-ap[x(wrap(pI], Ura~pz])], we notice that \nUncv[Urap[p]] = Uncv[Boxed(Uncv[p])] z Uncv[p] holds for any constructor p, thus Urap[x (Urap[pl], Urap[pz])] \ns Boxed(Uncv[x(Ura~pl], Urap(pz])]) s Boxed( x (Uncv[Ura~pl]], Uncv[Ura~pz]])) s Boxed( x(Uncv[pl], Uncv[pz])) \ns Boxed(Uncv[x(pl, I&#38;I)]) S blrap[x(pl, P2)]. Finally, Urap[~ (YI, pz)] -Ura~~ (Ura~pl], Urap[Uz])] \ncan be proved in the same way. QED. Proposition 3.11 The partial-bozing constructor wrap is in the valid \ncanonical boxed form.  Proposition 3.12 The full-bom ng constructor wrap is in the valid canonical boxed \nform. Proposition 3.11 and 3.12 can be proved in the same way as for Proposition 3.10. From the definition \nof partial boxing and full boxing, we can eaaily derive: Uncv[~ (Boxed(pl ), Boxed(pZ))] ~ ~ (Boxed(pl), \nBoxed(pZ)) This means that partial boxing and full boxing do not need to coerce arguments or results \nof unknown function types, so they completely avoid the vararg problem. Next, we give the definitions \nof the coercion primitives (wrap and unwrap) for simple boxing: (1) urap[p] box[Uncv[p]] OUtlCV[~] (2) \nunvra~p] cover[p] o unbox[Uncv[p]] (3) uncv[Boxed(p)] unbox[p] (4) Uncv[x(pl, /12)] Uncv[pl] x uncv[p2] \n (5) Uncv[+ (pl , pz)] cove~pl] ~ uncv[pz] (6) Lulcv[p] identitfip] (7) cover[Boxed(p)] box[p] (8) \ncove~x(pl, pz)] cove~pl] x cove2fp2] (9) cover[-(PI, P2)] uncv[pl] + cove~p2] (lo) cover[fl] ident itfip] \n  Here, the pattern-match syntax is representing the the term-Ievel typerec form; also, o denotes function \ncomposition, identity is the polymorphic identity function, and product and function spaces are extended \nto functions in the usual way. The coercion primitives for partial boxing and full boxing can be defined \nin the same way. For example, the definition for partial boxing can be obtained by replacing rule (5) \nand (9) with the following: (5 ) uncv[~ (PI, M,)]= (cover[#l] o unbox[Uncv[pl]]) ~ (box[Uncv[pZ]] o uncv[p2]) \n (9 ) cover[~ (pi, PZ)] = (box[Uncv[pl]] o uncv[pl]) ~ (cover[p~] o unbox[Uncv[pZ]]) Notice under partial \nboxing, the uncv and cover primitives are equivalent to the identity function on constructors such as \n+ (Boxed(pl ), Boxed(pZ)). 4 Extensions In this section, we present several extensions and variations \nof our flexible representation analysis algorithm. 4.1 Modules and type abstractions The algorithm and \nframework in Section 3 can be extended to handle the entire SML language [23] plus the MacQueen-Tofte \nstyle higher-order modules [21]. In a companion pa\u00adper [32], we show that both the SML simple modules \nand the transparent higher-order modules can all be translated into our intermediate language IL defined \nin Section 3.2 (ex\u00adtended with product kinds). Therefore, represent ation anal\u00adysis on the module languages \nis reduced to calling the same algorithm described in Section 3.5. To handle module-level type abstractions, \nwe treat all abstract t ycons as incoercible tycons, just like what we did for Iiets and arrays. Coercions \nbetween concrete and ab\u00adstract types are inserted at the places where abstractions are intreduced. For \nexample, in the following ML code: signature SIG = sig type ~a t val p:real t valf:>at->>at end functor \nF(S : SIG) = struct val r = S. f(S. p) end The parameter structure for functor F contains an abstract \ntype constructor t of arity 1. Inside the body of the functor, value S. p needs to be coerced from real \nt into >a t, but since t is incoercible, the coercion is just identity functions. When F is appkd to \nthe following structure A: structure A = struct type at= ae a Val p = (3.0,3.0) fun f (x}y) = (y, x) \nend structure T = F(A) both p and f would first be wrapped into canonical boxed form; later, after the \nfunctor application is done, the r field in the result must be unwrapped back to unboxed form. 4.2 Concrete \nvs. abstract datatypes Consistent datatype representations across functor bound\u00adary has long been a tricky \nproblem for ML compiler writ\u00aders [2]. Flexible representation analysis offers a nice solution. Consider \nthe following ML structure declaration: structure S = struct datatype t = FCOMSof (real -> real) . t \n I FIIL type u = real type s = (real -> int) . t val v = (fn x => x+1 .0, FEIL) val x = FCOIS V end \n Here, t is a recursive but monomorphic datatype; because it is monomorphic, one would not think about \ninserting co\u00adercions when applying the injection function of constructor FCONSto value v. This is, unfortunately, \nincorrect; because when structure S is paseed to the following functor F, the above concrete datatype \nt can match any similar abstract datatype definitions: functor F(A : sig type u datatype t = FCOIS of \n(u -> real) . t IFIIL end) = struct . . . end Here, the body of functor F will not know the actusl rep \nresentation of u until the functor application time. The so\u00adlution is to consistently apply a wrapping \n(or unwrap ping ) operation while injecting (or projecting) the value v into dat atype t. This wrapping \nensures that all values car\u00adried by the datatype (concrete or abstract) will have consis\u00adtent data representations \n(i.e., they are all in the canonical boxed form). The technique described above can also be used to solve \nthe clsssical list representation problem [2]. This problem occurs when we apply the following functor \nG to structure s: functor G(B : sig type s datatype t * FCOIS of s I FIIL end) = struct . . . end  Most \nexisting compilers represent the cons cell as an un\u00adtagged record with no indirection, Here, however, \nbecause type s is unknown, we cannot use the untagged record to represent the cons cell. The solution \nis to introduce a new type-dependent operator which checks at runtime to see if s is indeed a record \ntype, if that is the case, no indirection is inserted; otherwise, an extra boxing layer is added. 4.3 \nParametricity and type passing One interesting twist about our scheme is that most of the runtime type-passing \n(and also coercions that depend on runtime types) can be eliminated based on a parametricity property \nfor polymorphic functions. Consider the following example: fun f(x) = let ... x::nil ... . . . Array \n.update(a, i ,x) . . . in (x, x) end fun g(y) = f(y, 1.0) Here function f has type Vu. o --+ (O* a); \ninside f, the argu\u00adment x is cons-cd onto a list at one time and put inside an ar\u00adray at another time. \nFunction g has type V~.B + ((~*real)* (~* real)). During the function application f (y, 1. 9), the argument \nnormally should be coerced by wrap[/3 * real], which depends on the runtime type /3. In fact, neither \nf nor g really needs to know about a and /3 at runtime; they would not take them as extra parameters, \nand values of type a or /3 can be treated as single-word black boxes (as in the full-boxing approach). \nThe coercion ma~~ * real] does not need to examine and uncover /3 as welf. This is all right because \nwe can tell from the types off and g (which do not cent ain any list and array tycons) that none of the \npolymorphic lists and arrays involving a (or /3) wifl ever be exported outside function f (or g). This \nobservation can be made more precise as follows: given a polymorphic type VCY1, . . . . cY~.T, only those \na,s that actually occurred inside the element type of the array ty\u00adcon (or other incoercible tycons) \nwould be treated as ex\u00adplicit runtime type parameters, rdl the rest type variables can simply be considered \nas the single-word black boxes. This optimization does not affect separate compilation because all of \nthese information can be solely deduced from the type itself. Since many polymorphic functions do not \nin\u00advolve arrays, most runtime type manipulations can be elim\u00adinated. Finally, the pararnetricity property \ndiscussed here may not hold for compilers that use tag-free garbage collec\u00adtions [34]. The precise relationship \nbetween the two is out of the scope of the current paper. Old New Ratio Bmark total (gc) total (gc) boyer \n0.97 (0.01) 0.97 (0.00) 1.00 m i 15.8 (2.96) ] 3.56 fO.00) 0.23 Figure 9: Performance Measurements (Execution \nTime) Implementation We have imtiemented the flexible remesentation anaJvsis technique ou~lined above \nin an experirnentaJ version of-the Standard ML of New Jersey compiler (v109.25m) [3, 33, 31]. To simplify \nthe implementation, we avoid the uamrg prob\u00adlem by using partial boxing as the canonical boxed form. \nWe used the standard technique of minimaf typing deriva\u00adtions [33, 6] to eliminate local and unnecessary \npolymor\u00adphisms. We did not exploit the parametricity property (dis\u00adcussed in Section 4.3) in the current \nimplementation. All recursive and mutable tycons are treated as inco\u00adercible tycons, just like pack in \nSRC. Lists are represented using the simply boxed representations shown in Figure 2b. The polymorphic \narray tycon is implemented specially: if the element type is real or int32, then we use the flat array, \notherwise, we use the simply boxed array. The only operations that require runtime type analysis are \nthe coercion primitives (i.e., wrap and unwrap), the array primitives, and several conrep primitives \n(used to determine representations for concrete datatypes, with similar spirits to Appel [1, section \n4. l]). We compare the new technique with Leroy s standard coercion-based approach. Here, Old is the \ntype-based com\u00adpiler described in Shao and Appel [33, 29]); New is the new compiler that implements the \nflexible representation analy\u00adsis described in this paper. In Figure 9, we give the mea\u00adsurement results \n(in seconds) of running the Old and New compilers on twelve ML benchmarks on a Sun Sparc20 sta\u00adtion with \n128 Mbytes memory. For each benchmark, we measured the total execution time (including GC) and also the \ntime spent on garbage collection. Our measurements show that several benchmarks involv\u00ading recursive \nand mutable types gets from 27% -77% speedups. For example, the nucleic benchmark involves large lists \nof type (real* real* real) list, originally it has to be fully boxed, but with our new scheme, they use \nmore ef\u00adficient simply boxed representations; the simple benchmark and the fit benchmark get speedup \nfor the similar reasons (by using flat arrays). Benchmarks involving heavy poly\u00admorphic code (e.g., sieve, \nmlyacc, vliw, and knuth-bendix kb-comp) remain aJmost as efficient es before. We notice that most uses \nof polymorphic functions are to apply them directly to monomorphic data structures or to polymorphic \nincoercitde objects. The 5% to 10~0 slowdown on kb-comp and vliw is mostly caused by the extra runtime \ntype passing in the New compiler. The unzipr benchmark illustrates a worst-case scenerio on using partiaJly \n(or simply) boxed rep resentations; this benchmark calls the function unzip (de\u00adfined in Section 2.2) \nand zip upon a 10000-element list of float pairs (e.g., p in Figure 1). Because of the extra coer\u00adcions \non each element, the New compiler runs nearly twice slower than the Old compiler. In the future, we plan \nto use more aggressive type specializations [35] and to exploit the parametricity described in Section \n4.3 to to eliminate these overheads. It is worth pointing out that the .meedutr we got here is likely \nsimilar t: those Found in the pur;typ~passi~g compil\u00aders (e.g., TIL [34]). The strength of our flexible \nframework lies, however, on the fact that we can achieve the speedup without paying heavy cost on the \npolymorphic code. We intend to do a detailed performance comparison between SML/NJ and TIL (on heavily \npolymorphic code) once the TIL compiler is made publicly available. 6 Related Work and Conclusions The \nmain idea of our flexible remesentation analvsis tech\u00adnique is to explore the use of runtime type information \nto support more efficient coercions and more powerful boxing schemes. Previous coercion-baaed approaches \n[19, 26, 27, 15, 33, 36] do not take advantage of runtime type infor\u00admation, so they can only use fulf \nboxing as its canonical boxed form. On the other hand, previous type-passing ap preaches [25, 14, 24, \n34] do not box polymorphic objects, so they require extensive runtime type analysis and code manirrulations. \nM ost previous work on coercion-baaed approaches con\u00adcentrate on how to use compile-time anaJysis to \neliminate un\u00adnecessary coercions. Both Peyton Jones [26] and Poulsen [27] extend the type system to tag \nmonomorphic types with a bozity annotation, and then statically determine when to use boxed representations. \nHenglein and Jorgensen [15] present a term-rewriting method that translates a program with many coercions \ninto one that contains a formally optimal set of coercions. Shao and Appel [33] extended Leroy s scheme \nto the entire SM L module language and also used minimum typing derivations [6] to decrease the degree \nof polymorphism thus eliminate coercions. All these techniques still apply to our flexible approaches \nbecause the top-level S and G transformations in our scheme are almost identi\u00adcal to Leroy s originaJ \nones. What changed in our scheme is the interpretation of the primitive coercions urap[r] and unvra~r]. \n Morrison, et al. [25] described an implementation of Napier that passed types at runtime to determine \nthe be\u00adhavior of polymorphic operations. The type-passing ap- A4J2bY Harper and Or\u00ad proach was later \nformalized using J, risett [14, 13, 24]; the intentional type analysis framework they proposed is one \nof the main inspirations for the present work. Very recently, Tarditi and Morrisett, et al. [34, 24] \nhave implemented the type-passing approach in their TIL compiler. Their preliminary measurements showed \nthat us\u00ading unboxed representations for recursive and mutable data structures can dramatically improves \nthe performance of most of their (monomorphic) benchmarks. Unfortunately, since their compiler specialized \nall the polymorphic func\u00adtions (in their benchmarks), it is still unclear how their type\u00adpaasing approach \nwould perform on heavily polymorphic and heavily functorized code. 2 We have presented a new flexible \nrepresentation anaJy\u00adsis technique for the implementation of polymorphism and abstract data types. Unlike \nany previous approaches, our new scheme supports unboxed representations for recursive and mutable types, \nyet it only requires little runtime type analysis. Our scheme is very flexible because it allows a con\u00adtinuum \nof possibfities between the coercion-based and the type-passing approaches. By varying the amount of \nboxing and the type information passed at runtime, a compiler can freely explore any point in the continuum, \nchoosing from a wide range of representation strategies baaed on practical concerns (e.g., to avoid the \nvararg problem). Acknowledgements We would like to thank Andrew Appel, Dave Berry, Franklhr Chen, Simon \nPeyton Jones, and the ICFP program commit\u00adtee for their comments and suggestions on an early version \nof this paper. References [1] A. W. AppeL Compiling with Continuations. Cambridge UniversityPress, 1992. \n[2] A. W. Appel. A critque of Standard ML. Journal oj Func\u00adtional Programming, 3(4) :391-429, October \n1993. 2By heavily polymorphic, we mean code that involves extensive use of polymorphic functions, polymorphic \ndata structures, and parame\u00adtrized modules (functors) with type abstractions. It is unrealistic to specialize \nall polymorphic functions and functors in realistic applicw tions (e.g., theorem provers, ML-kit compilers, \nSML/NJ Compilation Manager);manyC++ templatesusersshouldhavesimilarexperi\u00adence. Even Mark Jones s experiment \n[16] only eliminates the use of type classes but not all the polymorphic functions. [3] A. \\V. Appel \nand D. B. MacQueen. Standard ML of New Jersey. In M, Wirsing, editor, Third Int 1 Symp. on l%og. Lang. \nImplementation and Logic Programming, pages 1 13, New York, August 1991. Springer-Verlag. [4] J. AuSlander, \nM. Philipose, C. Chambem, S. Eggera, and B. Bershad. Fast, effective dynamic compilation. In %oc. ACM \nSIGPLAN 96 Conj. on Pr-og. Lang. Design and Im\u00adplementation, pages 149-159. ACM Press, 1998. [5] M. W. \nBailey and J. W. Davidson. A formal model of pro\u00adcedure calling convention. In Twenty-second Annual ACM \nSymp. on Principles of Prog. Languagea, pages 298-310, New York, Jan 1995. ACM Press. [6] N. S. Bjorner. \nMinimal typing derivations. In ACM SIG-PLAN Workshop on ML and its Applications, pages 120\u00ad126, June \n1994. [7] D. Clement, J. Despeyroux, T. Despeyroux, and G. Kahn. A simple applicative language: Mini-ML. \nIn 1986 ACM Con\u00adjerence on Lisp and Functional Programming, New York, June 1986. ACM Press. [8] L. Damas \nand R. Milner. Principal type-schemes for func\u00adtional programs. In Ninth Annual ACM Symp. on Princi\u00adples \nof Prog. Languages, pages 207 212, New York, Jan 1982. ACM Press. [9] D. R. Engler. VCODE: A retargetable, \nextensible, very fast dynamic code generation system. In Proc. ACM SIGPLAN 96 Conj. on Prog. Lang. Design \nand Implementation, pages 16&#38;170. ACM Press, 1996. [10] J. Y. Girard. Interpretation Fonctionnel/e \net Elimination dea Coupurea clans l Arithmetique d Ordre Superieur. PhD thesis, University of Paris VII, \n1972. [II] R. Harper and M. Lillibridge. A type-theoretic approach to higher-order modules with sharing. \nIn Twenty-first Annual ACM Symp. on Principles oj Prog. Languagea, pages 123 137, New York, Jan 1994. \nACM Press. [12] R. Harper and J. C. Mitchell. On the type structure of Stan\u00addard ML. ACM Trans. Prog. \nLang. Syst., 15(2):211 252, April 1993. [13] R. Harper and G. Morrisett. Compiling polymorphism us\u00ading \nintensional type analysis. Technical Report CMU-CS-94\u00ad185, School of Computer Science, Carnegie Mellon \nUniver\u00adsity, Pittsburgh, PA, September 1994. [14] R. Harper and G. Morrisett. Compiling polymorphism \nuaing intentional type analysis. In Twenty-second Annual ACM Symp. on Principles of Prog. Languages, \npages 130-141, New York, Jan 1995. ACM Press. [15] F. Henglein and J. Jorgensen. Formally optimal boxing. \nIn Proc. 2fst Annual ACM SIGPLAN-SIGACT Symp. on Principles oj Programming Language*, pages 213-226. \nACM Press, 1994. [16] M. P. Jones. Dictionary-free overloading by partial evalua\u00adtion. In Proceeding \noj the ACM SIGPLAN Workshop on Partial Evaluation and Semanfics-Baaed Program Manip\u00adulation, pages 107 \n117. University of Melbourne TR 94/9, June 1994. [17] G. Kane and J. Heinrich, editors. MIPS RISC Architecture. \nPrentice Hall, Englewood Cliffs, NJ, 1992. [18] P. Lee and M. Leone. Optimizing ML with run-time code \ngeneration. In Proc. ACM SIGPLAN 96 Conf. on Prog. Lang. Design and Implementation, pages 137-148. ACM \nPress, 1996. [19] X. Leroy. Unboxed objects and polymorphic typing. In Nineteenth Annual ACM Symp. on \nPrinciples oj Pvog. Lan\u00adguages, pages 177 188, New York, Jan 1992. ACM Press. Longer version available \nas INRIA Tech Report. [20] X. Leroy. Manifest types, modules, and separate compilation. In Twenty-first \nAnnual ACM Symp. on Principles of Prog. Languages, pages 109 122, New York, Jan 1994. ACM Press. [21] \nD. B. MacQueen and ,M.Tofte. A semanticsfor higherorder functors. In The 5th European Symposium on Programming, \npages 409 423, Berlin, April 1994. Spinger-Verlag. [22] R. Milner, M. Tofte, and R. Harper. The Definition \noj Stan\u00addard ML. MIT Press, Cambridge, Massachusetts, 1990. [23] R. Milner, M. Tofte, R. Harper, and \nD. MacQueen. The Def\u00adinition of Siandard ML (Revised). MIT Press, Cambridge, Massachusetts, 1997. [24] \nG. Morrisett. Compiling with Types. PhD thesis, School of Computer Science, Carnegie Mellon University, \nPittsburgh, PA, December 1995. Tech Report CMU-CS-95-226. [25] R. Morrison, A. Dearle, R. C. H. Connor, \nand A. L. Brown. An ad hoc approach to the implementation of polymorphism. ACM Trans. Prog. Lang. S@., \n13(3), July 1991. [26] S. L. Peyton Jones and J. Launchbury. Unboxed values as first class citizens in \na non-strict functional language. In The Fifth International Conference on Functional Programming Languages \nand Computer Architecture, pages 636-666, New York, August 1991. ACM Press. [27] E. Poulsen. Representation \nanalysis for efficient implemen\u00adtation of polymorphism. Master s thesis, DIKU, University of Copenhagen, \n1993. [28] J. C. Reynolds. Towards a theory of type structure. In Proceedings, Colloque sur la Programmation, \nLecture Notes in Computer Science, volume 19, pages 408 425. Springer-Verlag, Berlin, 1974. [29] Z. Shao. \nCompiling Standard ML for Eficient Execution on Modern Machines. PhD thesis, Princeton University, Prince\u00adton, \nNJ, November 1994. Tech Report CS-TR-475-94. [30] Z. Shao. Flexible representation analysis. TecW,cal \nReport YALEU/DCS/RR-l 125, Dept. of Computer Science, Yale University, New Haven, CT, 1997. [31] Z. Shao. \nA overview of the FLINT/ML compiler. In To appear m 1997 ACM Workshop on Types in Compilation, June 1997. \n[32] Z. Shao. Typed cross-module compilation. Technical Report YALEU/DCS/RR-1126, Dept. of Computer Science, \nYale University, New Haven, CT, 1997. [33] Z. Shao and A. W. Appel. A type-based compiler for Stan\u00addard \nML. In Proc. ACM SIGPLAN 95 Conf. on Prog. Lang. Design and Implementation, pages 116 129. ACM Press, \n1995. [34] D. Tarditi, G. Morrisett, P. Cheng, C. Stone, R. Harper, and P. Lee. TIL: A type-directed \noptimizing compiler for ML. In Proc. ACM SIGPLAN 96 Conf. on Prog. Lang. Denign and Implementation, pages \n181-192. ACM Press, 1996. [35] D. R. Tarditi. Design and Implementation of Code Opti\u00admization for a Type-Directed \nCompiler for Standard ML. PhD thesis, School of Computer Science, Cmnegie Mellon Univemity, Phtsburgh, \nPA, December 1996. Tech Report CMU-CS-97-108. [36} P. J. Thiernann. Unboxed values and polymorphic typing \nre\u00advisited. In The Seventh International Conference on Fact\u00adional Programming Language8 and Computer \nArchitecture, pages 24 35, New York, June 1995. Spinger-Verlag. [37] A. K. Wright. Polymorphism for imperative \nlanguages with\u00adout imperative types. Technical Report Tech Report TR 93\u00ad200, Dept. of Computer Science, \nRice University, Houston, Texas, February 1993.   \n\t\t\t", "proc_id": "258948", "abstract": "Statically typed languages with Hindley-Milner polymorphism have long been compiled using inefficient and fully boxed data representations. Recently, several new compilation methods have been proposed to support more efficient and unboxed multi-word representations. Unfortunately, none of these techniques is fully satisfactory. For example, Leroy's coercion-based approach does not handle recursive data types and mutable types well. The type-passing approach (proposed by Harper and Morrisett) handles all data objects, but it involves extensive runtime type analysis and code manipulations.This paper presents a new <i>flexible representation analysis</i> technique that combines the best of both approaches. Our new scheme supports unboxed representations for recursive and mutable types, yet it only requires little runtime type analysis. In fact, we show that there is a continuum of possibilities between the coercion-based approach and the type-passing approach. By varying the amount of boxing and the type information passed at runtime, a compiler can freely explore any point in the continuum---choosing from a wide range of representation strategies based on practical concerns. Finally, our new scheme also easily extends to handle type abstractions across ML-like higher-order modules.", "authors": [{"name": "Zhong Shao", "author_profile_id": "81351597965", "affiliation": "Dept. of Computer Science, Yale University, New Haven, CT", "person_id": "PP14127817", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/258948.258958", "year": "1997", "article_id": "258958", "conference": "ICFP", "title": "Flexible representation analysis", "url": "http://dl.acm.org/citation.cfm?id=258958"}