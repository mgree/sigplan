{"article_publication_date": "08-01-1997", "fulltext": "\n Intensional Sets using Explicit Substitutions G. Richard and F. Saubion and A. Tellez-Arenas {richard,saubion, \ntellez}@lifo.univ-orleans.fr University of Or16ans (France) Set constraints are naturally involved in \nmany computer science areaa and there is a large agreement to recognize the availability of set data \nabstractions as a valuable feature in programming or specification languages. At this time, the main \nproblem is the choice of a relevant implementation support for such dataa. Most previous works deals \nwith finite sets represented by an enumeration of their elements. In the current implementations, data \nstructures such as lists or arrays can be easily used. But, with infinite sets, this kind of representation \ndoes not hold anymore and one must turn to an implicit representation without enumeration. Many kinds \nof such representations can be suggested but the most appropriate syntax for set expressions, inspired \nby a common practice in mathematics, is an intentional nota\u00adtion of the form {z I P(z)} specifying the \nset of elements z with the property P, where P is generally defined using first order logic. This kind \nof set expression, using an abstract set former { ~. I . . .}, becomes a logic term and is allowed to \noccur in any position where a standard term can occur. We propose a functional approach to deal with \nsuch datas whatever the cardinality of the subjacent set is. Our context is a logic language with J-abstraction \nand function variables like A-Prolog ([2]) implementing uniform proofs mechanism. Let us examine a simple \nexample extracted from [2] to highlight our discussion. . A box is sterile if all the bugs in it are \ndead. . A bug in a boiled box is dead. . A box b is boiled. The question is : is ba sterile box ?. We \nargue that a natural formal translation of this specification is : sterile(y) -bug-in(y) ~ deadJmg dead(z) \nt bug(z), zn(z, y), boiled(y) boiled(b). where bug_in(y) = {z I bug(z) A in(x, y)} and dead-bug = {z \nI bug(z) A dead(z)}. Of course, there is probably an infi\u00adnite number of bugs in a given box (at least \na very large num\u00adber) and we want to reason without any hypothesis about such a cardinality. Typically, \nnone of the known works could deal with such a specification. Permission to make digital/hard copy of \npart or all this work for personal or classroom use is granted without fee provided that copies are not \nmade or distributed for profit or commercial advan\u00ad tage, the copyright notice, the title of the publication \nand its date appear, and notice is given that copying is by permission of ACM, Inc. To copy otherwise, \nto republish, to post on servers, or to redistribute to lists, requires prior specific permission and/or \na fee. ICFP 97 Amsterdam, ND @ 1997 ACM 0-89791 -918 -1/97 /0006 ...$3.50 Our idea is rather simple : \nembedded into a first order logic language, sets are viewed as higher order objeets thus we are led to \nuse lambda-terms to represent such objects. In other words, we represent intensional sets with charac\u00adteristic \nfunctions. For inetance, in the previoue example, the eet deadlmg ie internally represented as the abstraction \nkc. bug(z) Adead(z) and the set bug-in(y) by the abstraction kz.bug(x) A in(z, y) with the free variable \ny. But, as soon as we deal with functions, we use an applied lambda-calculus and to gain efficient evaluation, \nwe translate it in a lambda\u00adcalculus with explicit substitutions ([1]). Starting with a core calculus, \nwe add operators to express standard sets op\u00aderations (intersection, union, etc... ) and specific reduction \nrules to capture sets semantics. We get a first order rewrite system which is confluent on open terms \nwith terms meta\u00advariables and whose substitution evaluation is terminating. This rewrite system allows \nto reduce set expressions con\u00adtaining intersection and union. The main constraint we deal with is the \ninclusion denoted ~. Roughtly speaking, each side of such a constraint sel ~ sez is reduced according \nto our calculus. Then, at the end of this process, we get inchr\u00adsion between intensional sete of the \nform : k.p(z) ~ Az.q(x) where p and q are user-defined predicate symbols. Then we reduce such a constraint \ninto : Vx (p(z) s q(z)). At this step, uniform proof has to be done using standard natural deduction \ntechniques ([2]). Let us turn now to our example : it ia an easy game to prove that the box b is sterile, \nstarting from the goal sterile(b) and by reducing the constraint in the body of the corresponding clause \ninto true. Tu sum up, we propose to include intensional sets in a logic language and we enlarge the standard \nknown ap\u00adproaches by allowing these sets to be infinite. At the syn\u00adtactic level, these sets are described \nusing intensional no\u00adtation {z I P(z)}. We compile such intensional sets using an applied A-calculus \nwith explicit substitutions. Abstract machines especially designed for such calculi should allow efficient \nimplementation with regard to standard criteria for high level languages. References [1] M. Abadi, L. \nCardelli, P.-L. Curien, and J.-J. L6vy. Ex\u00adplicit substitutions. Journal of Functional Progmmming, pages \n375-416, 1991. [2] D.A. Miller, G. Nadathur, F. Pfenning, and A. Scedrov. Uniform proofs es a foundation \nfor logic programming.  Annals of PtLre and Applied Logic, 51:125-157, 1991. 318  \n\t\t\t", "proc_id": "258948", "abstract": "", "authors": [{"name": "G. Richard", "author_profile_id": "81546125356", "affiliation": "University of Orl&#233;ans (France)", "person_id": "PP31093930", "email_address": "", "orcid_id": ""}, {"name": "F. Saubion", "author_profile_id": "81100583899", "affiliation": "University of Orl&#233;ans (France)", "person_id": "P82622", "email_address": "", "orcid_id": ""}, {"name": "A. Tellez-Arenas", "author_profile_id": "81100348081", "affiliation": "University of Orl&#233;ans (France)", "person_id": "P8765", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/258948.258987", "year": "1997", "article_id": "258987", "conference": "ICFP", "title": "Intensional sets using explicit substitutions (poster)", "url": "http://dl.acm.org/citation.cfm?id=258987"}