{"article_publication_date": "08-01-1997", "fulltext": "\n Inductive synthesis of recursive functional programs (poster abstract ) Bjarte M. @stvold* Department \nof Computer and Information Science Norwegian University of Science and Technology GlOshaugen, N-7034 \nTrondheim, Norway Email: bjartern@idt. ntnu. no A formulation of the inductive synthesis problem for \nfunc\u00adtional programs: given a library L of function definitions, a type r of an unknown function f and \nexamples E of equa\u00adtions about f, {~(a,,,...,a~~) =bl,...,j(a~~a~~)a~~) = bn}; find a definition for \nf, def(~), such that def(~) has type ~, is built using only deftnitlons from L (and possibly recursion) \nand reduce any left-hand side in E to the corre\u00adsponding right-hand side in a finite number of steps. \nThus, def (f) is a generalisation of E, one of a number of induc\u00adtive hypotheses derivable from the observations \nE. Example (Haskell syntax): append :: [a] -> [a] -> [a] --tau append [0] [11 == [0, 1] --el -- e2 [:, \nhead, tail, if, . ..] L append [1, 21 [3, 41 = [1, 2, 3, 41 append xs YS = if null xs then y --def (f \n) else head xs: (append (tail XS) ys) This kind of synthesis is useful when the programmer/\u00ad specifier \nonly have partial knowledge of ~, doesn t want to write down the complete definition or is unfamiliar \nwith programming/formal specification. This contrasts with de\u00adductive synthesis where ~ must be completely \nspecified. Related research on learning programs is mainly done under the labels inductive logic programming \n[2] and ge\u00adnetic programming . Ordy a small part of current research concerns learning recursive programs \nand the special prob\u00adlems this poses. (I use the term inductive synthesis in\u00adstead of learning both to \nemphasise the complementary relationship with deductive synthesis and to indicate a die\u00adtance to more \ngeneral program learning. ) Logic program\u00adming has a major advantage over functional programming: there \nis a most general relation for a domain, and gen\u00aderalisation/specialisation can be characterised syntactically \n(add/delete a literal in a clause); however, there is no most general function for any reasonable definition \nof general . Logic predicates are more flexible, e.g., predicate append with 3 arguments can be used \nbackwards to split a list in two, but consequently, they re also harder to synthesise; relations may \nsometimes be more than we want . Advan\u00adtages of functional programming: higher-order functions en\u00adable \nrepresentation of recursion schemas as first class values, Advisor: associate professor Oystein Nytr@ \n(same affiliation). Permission to mske digitsl/hard copy of part or sII this work for personal or classroom \nuse is granted without fee provided that copies are not made or distributed for profit or commercial \nadvan \u00ad tege, the copyright notice, the title of the publication and its date appear, and notice is given \nthat copying ia by permission of ACM, Inc. To copy otherwise, to republish, to post on servers, or to \n redistribute to lists, requires prior specific permission and/or a fee. ICFP 97 Amsterdam, ND @ 1997 \nACM 0-89791 -918 -1/97 /0006 . ..$3.50 e.g., divide and conquer; there s a powerful theory relat\u00ading \nrecursion, datatypes and higher-order functions [1]. An important paradigm-neutral issue is the type \nsystem it restricts the number of legal programs, but makes meta\u00adprogramming harder. Viewing expressions \nMStrees we can define an order on ex\u00adpressions baaed on the number of variable or function symbol occurrences, \ni.e., syntactic size. Example (candidate right\u00adhand sides of append xs ys): [1, Xs, ys, head XS, tail \nXS, . . . The enumeration algorithm consists in testing expressions of increasing order until one is \na definition of ~. This naive search for a solution leads immediately to a combinatorial explosion for \nmore complex problems. Improvements: there are a number of equivalent expressions, only consider the \nsmallest ones, e.g., x, not head (x: xs ); assume that solu\u00adtions are always recursive and only allow \nrecursion indirectly through the use of recursive higher-order functions [1]; de\u00adcompose problems into \nsubproblems by synthesizing differ\u00adent schema arguments separately; interleave searching and testing \nwith simplification. Example (synthesizing mapList): mapList (l+) [1,2,3] == [2,3,4] --E mapList u xs \n= foldr k a xs --initial hypothesis --gives foldr k a [1,2,3] == [2,3,4] 1 k (2 k (3 k a)) == [2,3,4] \n--subproblem: find <k >: l k . ..== 2.... --E for k> k= (:) (l+) --subsolution for Ck ) --then simplification \non original problem gives 2:3:4 :a== [2,3,4] a=[l -subsolution for a> without search complete solution \nmapList u = foldr ((:) u) [] Future work includee: allowing intermediate data structures to be required \nby the problem specification or introduced at will by synthesis; take advantage of known properties of \ndefinitions in L, e.g., inverses in general this amounts to theorem proving; improving the current implementation \nbased on enumeration to include the ideas mentioned above. Acknowledgements: Discussions with John Lloyd, \nChristopher Giraud-Carrier and Chris Dornan during a visit by the author to University of Bristol had \na major influence on this research. References [1] R. Bird, O. de Moor. The algebra of programming. Prentice \nHall international eeries in computer science. Prentice Hall, 1996. [2] S. Muggleton, L. De Raedt. Inductive \nlogic programming Theory and methods. Journal of Logic Programming, 19, 20:629-679, 1994. 323  \n\t\t\t", "proc_id": "258948", "abstract": "", "authors": [{"name": "Bjarte M. &#216;stvold", "author_profile_id": "81100533624", "affiliation": "Department of Computer and Information Science, Norwegian University of Science and Technology, Gloshaugen, N-7034 Trondheim, Norway", "person_id": "P30945", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/258948.258992", "year": "1997", "article_id": "258992", "conference": "ICFP", "title": "Inductive synthesis of recursive functional programs (poster abstract)", "url": "http://dl.acm.org/citation.cfm?id=258992"}