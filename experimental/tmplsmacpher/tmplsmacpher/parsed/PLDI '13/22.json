{"article_publication_date": "06-16-2013", "fulltext": "\n Natural Proofs for Structure, Data, and Separation Xiaokang Qiu Pranav Garg Andrei S\u00b8 tef.anescu P. \nMadhusudan University of Illinois at Urbana-Champaign, USA {qiu2, garg11, stefane1, madhu}@illinois.edu \nAbstract We propose natural proofs for reasoning with programs that ma\u00adnipulate data-structures against \nspeci.cations that describe the structure of the heap, the data stored within it, and separation and \nframing of sub-structures. Natural proofs are a subclass of proofs that are amenable to completely automated \nreasoning, that pro\u00advide sound but incomplete procedures, and that capture common reasoning tactics in \nprogram veri.cation. We develop a dialect of separation logic over heaps, called Dryad, with recursive \nde.ni\u00adtions that avoids explicit quanti.cation. We develop ways to reason with heaplets using classical \nlogic over the theory of sets, and de\u00advelop natural proofs for reasoning using proof tactics involving \ndisciplined unfoldings and formula abstractions. Natural proofs are encoded into decidable theories of \n.rst-order logic so as to be discharged using SMT solvers. We also implement the technique and show that \na large class of more than 100 correct programs that manipulate data-structures are amenable to full \nfunctional correctness using the proposed natural proof method. These programs are drawn from a variety \nof sources including standard data-structures, the Schorr-Waite algorithm for garbage collection, a large \nnumber of low-level C routines from the Glib library and OpenBSD library, the Linux kernel, and routines \nfrom a secure veri.ed OS-browser project. Our work is the .rst that we know of that can handle such a \nwide range of full functional ver\u00adi.cation properties of heaps automatically, given pre/post and loop \ninvariant annotations. We believe that this work paves the way for deductive veri.cation technology to \nbe used by programmers who do not (and need not) understand the internals of the underlying logic solvers, \nsigni.cantly increasing their applicability in building reliable systems. Categories and Subject Descriptors \nF.3.1 [Logics and Meanings of Programs]: Specifying and Verifying and Reasoning about Pro\u00adgrams: Mechanical \nveri.cation; D.2.4 [Software Engineering]: Software/Program Veri.cation: Assertion checkers Keywords \nheap analysis; data structures; natural proofs; separa\u00adtion logic; SMT solvers 1. Introduction In recent \nyears, the automated deductive veri.cation paradigm for software veri.cation that combines user written \nmodular contracts and loop invariants with automated theorem proving of the result- Permission to make \ndigital or hard copies of all or part of this work for personal or classroom use is granted without fee \nprovided that copies are not made or distributed for pro.t or commercial advantage and that copies bear \nthis notice and the full citation on the .rst page. To copy otherwise, to republish, to post on servers \nor to redistribute to lists, requires prior speci.c permission and/or a fee. PLDI 13, June 16 19, 2013, \nSeattle, WA, USA. Copyright &#38;#169;c2013 ACM 978-1-4503-2014-6/13/06. . . $15.00 ing veri.cation conditions \nhas become very powerful. The latter process is often executed by automated logical decision procedures \nsupported by SMT solvers, which have emerged as robust and pow\u00aderful engines to automatically .nd proofs. \nSeveral techniques and tools have been developed [2, 16, 20] and there have been several success stories \nof large software veri.cation projects using this ap\u00adproach (the Verve OS project [42], the Microsoft \nhypervisor veri\u00ad.cation project using VCC [16], and a recent veri.ed-for-security OS+browser for mobile \napplications [29], to name a few). Veri.cation conditions do not, however, always fall into decid\u00adable \ntheories. In particular, the veri.cation of properties of the dy\u00adnamically modi.ed heap is a big challenge \nfor logical methods. The dynamically manipulated heap poses several challenges, as typical correctness \nproperties of heaps require complex combinations of structure (e.g., p points to a tree structure, or \nto a doubly-linked list, or to an almost balanced tree, with respect to certain pointer\u00ad.elds), data \n(the integers stored in data-.elds of the tree respect the binary search tree property, or the data stored \nin a tree is a max\u00adheap), and separation (the procedure modi.es one list and not the other and leaves \nthe two lists disjoint at exit, etc.). The fact that the dynamic heap contains an unbounded number of \nlocations means that expressing the above properties requires quanti.cation in some form, which immediately \nprecludes the use of most SMT decidable theories (there are only a few of them known that can handle \nquanti.cation; e.g., the array property frag\u00adment [12] and the Strand logic [25, 26]). Consequently, \nexpress\u00ading such properties naturally and succinctly in a logical formalism has been challenging, and \nreasoning with them automatically even more so. For instance, in the Boogie line of tools (including \nVCC) of writing speci.cations using .rst-order logic and employing SMT solvers to validate veri.cation \nconditions, the speci.cation of in\u00advariants of even simple methods like singly-linked-list insert is \nte\u00addious. In such code1 , second-order properties (reachability, acyclic\u00adity, separation, etc.) are smuggled \nin using carefully chosen ghost variables; for example, acyclicity of a list is encoded by assign\u00ading \na ghost number (idx) to each node in the list, with the property that the numbers associated with adjacent \nnodes strictly increase going down the list. These ghost variables require careful manip\u00adulation when \nthe structures are updated; for example, inserting a node may require updating the ghost numbers for \nother nodes in the list, in order to maintain the acyclicity property. Once such a ghost-encoding of \nthe speci.cation is formulated, the validation of veri.cation conditions, which typically have quanti.ers, \nare dealt with using sound heuristics (a wide variety of them including e\u00admatching, model-based quanti.er \ninstantiation, etc. are available), but are still often not enough and have to be augmented by instan\u00adtiation \ntriggers from the veri.cation engineer to help the proof go through. 1http://vcc.codeplex.com/SourceControl/changeset/view/dcaa4d0ee8c2#vcc \n/Docs/Tutorial/c/7.2.list.c  In recent years, separation logic, especially in combination with recursive \nde.nitions, has emerged as a much more succinct and natural logic to express properties about structure \nand separa\u00adtion [32, 36]. However, the validation of veri.cation conditions re\u00adsulting from separation \nlogic invariants are also complex, and has eluded automatic reasoning and exploitation of SMT solvers \n(even more so than tools such as Boogie that use classical logic). Again, help from the user in proving \nthe veri.cation conditions are cur\u00adrently necessary the tools Verifast [20]and Bedrock [15], for instance, \nadmit separation logic speci.cations but require the user to write low-level lemmas and proof tactics \nto guide the veri.ca\u00adtion. For example, in verifying an in-place reversal of a linked list2 , Bedrock \nwould require several lemmas and a hint package be sup\u00adplied at the level of the code in order for the \nproof to go through. The work in this paper is motivated by the opinion that en\u00adtirely decidable logics \nare too restrictive, in general, to support the veri.cation of complex speci.cations of functional correctness \nfor heap manipulating programs, and the other extreme of user\u00adsupplied proof tactics and lemmas is too \ntedious, requiring of the user too much knowledge of the underlying proof systems/decision procedures. \nOur aim is to build completely automatic, sound, but incomplete proof techniques that can solve a large \nclass of proper\u00adties involving complex data-structures. The natural proof methodology: Our proof methodology \nof natural proofs was .rst proposed in a pa\u00adper by Madhusudan et al on natural proofs for tree data-structures \nlast year at POPL [27]. Natural proofs exploit a .xed set of proof tactics, keeping the expressiveness \nof powerful logics, retaining the automated nature of proving validity, but giving up on complete\u00adness \n(i.e., giving up decidability, retaining soundness). The idea of natural proofs [27] is to identify a \nsubclass of proofs N such that (a) a large class of valid veri.cation conditions of real-world pro\u00adgrams \nhave a proof in N, and (b) searching for a proof in N is decidable. In fact, we would even like the search \nfor a proof in N to be e.ciently decidable, possibly utilizing the automatic logic solvers (SMT solvers) \nthat exist today. Natural proofs are hence a .xed set of proof tactics whose application is itself expressible \nin a decidable logic. The natural proofs developed in [27] were too restrictive, however, handling only \nsingle trees, with no scope for handling multiple or more complex data-structures and their sepa\u00adration \n(see section on Related Work for more details). The aim of this paper is to provide natural proofs for \ngeneral properties of structure, data, and separation. Our contributions are: (a) we propose Dryad, a \ndialect of separation logic for heaps, with no explicit (classical) quanti.cation but with recursive \nde.nitions, to express second-order properties; (b) show that Dryad is both powerful in terms of expressiveness, \nand that the strongest-post of Dryad speci.cations with respect to bounded code segments can be formulated \nin Dryad, (c) show how Dryad has been designed so that it can be systematically converted to classical \nlogic using the theory of sets, allowing us to connect the more natural and succinct speci.cations to \nmore verbose but classical logic, and (d) develop a natural proof mechanism for classical logics with \nrecursion and sets that implement sound but incomplete reductions to decidable theories that can be handled \nby an SMT solver. Dryad: A separation logic with determined heaplets The primary design principle behind \nseparation logic is the decision to express strict speci.cations logical formulas must naturally refer \nto heaplets (subparts of the heap), and, by default, the smallest heaplets over which the formula needs \nto refer to. This is in contrast to classical logics (such as FOL) which implicitly refer to the entire \nheap globally. Strict speci.cations permit elegant ways to capture 2http://plv.csail.mit.edu/bedrock/Tutorial.html \nhow a particular sub-part of the heap changes due to a procedure, implicitly leaving the rest of the \nheap and its properties unchanged across a call to this procedure. Separation logic is a particular framework \nfor strict speci.cations, where formulas are implicitly de.ned on strictly de.ned heaplets, and where \nheaplets can be combined using a spatial conjunction operator denoted by *. The frame rule in separation \nlogic captures the main advantage of strict speci.cations: if the Hoare-triple {P}C{Q} holds for some \nprogram C, then {P * R}C{Q* R} also holds (with side-conditions that the modi.ed variables in C are disjoint \nfrom the free variables in R). Consider, for example, expressing that the location x is the root of a \ntree. This is a second-order property and formulations of it in classical logic using set or path quanti.cation \nare quite com\u00adplex and not easily amenable to automated veri.cation. We prefer inductive de.nitions of \nstructural properties without any explicit quanti.cation. The separation logic syntax with recursive \nde.ni\u00adtions and heaplet semantics allows simple quanti.er-free formulas to express structural restrictions; \nfor example. tree-ness can be ex\u00adpressed simply as: tree(x):: (x = nil . emp). (x -. (l, r)* tree(l)* \ntree(r)) We .rst de.ne a new logic, Dryad, that permits no explicit quanti.cation, but permits powerful \nrecursive de.nitions to de.ne integers, sets/multisets of integers, and sets of locations, using least \n.xed-points. The logic Dryad furthermore has a heaplet semantics and allows the spatial conjunction operator \n*. However, a key design feature of Dryad is that the heaplet for recursive formulas is essentially determined \nby the syntax as opposed to the semantics. In classical separation logic, a formula of the form a * \u00df \nsays that the heaplet can be partitioned into any two disjoint heaplets, one satisfying a and the other \n\u00df. In Dryad, the heaplet for a (complex) formula is determined and hence if there is a way to partition \nthe heaplet, there is precisely one way to do so. We have found that most uses of separation logic to \nexpress properties can be written quite succinctly and easily using Dryad (in fact, it is easier to write \nsuch deterministic-heap speci.cations). The key advantage is that this eliminates implicit existential \nquanti.cation the separation operator provides. In a veri.cation condition that combines the pre\u00adcondition \nin the negative and the post-condition in the positive, the classical semantics for separation logic \ninvariably introduces universal quanti.cation in the satis.ability query for the negation of the veri.cation \ncondition, which in turn is extremely hard to handle. In Dryad, the semantics of a recursive de.nition \nr(x) (such as tree above), requires that the heaplet be determined and de.ned as the set of all locations \nreachable from the node x through a set of pointer-.elds f1, . . . , fk without passing through a set \nof locations (given by a set of location terms t1, . . . tn). While our logical mech\u00adanisms can be extended \nbeyond this notion (in deterministic ways), we have found that this captures most common properties required \nin proving data-structure manipulating programs correct. Translating Dryad to classical logic with recursion: \nThe second key step in our paradigm is a technique to bridge the gap from separation logic to classical \nlogic in order to utilize ef\u00ad.cient decision procedures supported by SMT solvers. We show that heaplet \nsemantics and separation logic constructs of Dryad can be e.ectively translated to classical logic where \nheaplets are modeled as sets of locations. We show that Dryad formulas can be translated into classical \nlogic with free set variables that capture the heaplets corresponding to the strict semantics. This translation \ndoes not, of course, yield a decidable theory yet, as recursive de.nitions are still present (the recursion-free \nformulas are in a decidable the\u00adory). The carefully designed Dryad logic with determined heaplet semantics \nensures that there is no quanti.cation in the resulting formula in classical logic. The heaplets of recursively \nde.ned prop\u00aderties, which are de.ned using the set of all reachable nodes, are translated to recursively \nde.ned sets of locations.  Natural proofs for Dryad: Finally, we develop a natural proof methodology \nfor Dryad by showing a natural proof mechanism for the equivalent formulas in classical logic. The basic \nproof tactic that we follow is not just dependent on the formula embodying the veri.cation condition, \nbut also on the precise footprint touched by the program segment being veri.ed. We unfold recursive de.nitions \nprecisely across footprints, translating them to the frontier of the footprint, and then use a form of \nformula abstraction that treats recursive formulas on frontier nodes as uninterpreted functions. The \nresulting formula falls in a logic over sets and integers, which is then decided using the theory of \nuninterpreted functions and arrays using SMT solvers. The key feature is that heaplets and separation \nlogic constructs, which get translated to recursively de.ned sets of locations, are unfolded along with \nother user-de.ned recursive de.nitions and formula\u00adabstracted using this uniform natural proof strategy, \nWhile our proof strategy is roughly as above, there are many technical details that are complex. For \nexample, the heaplets de\u00ad.ned by pre/post conditions intrinsically specify the modi.ed lo\u00adcations of \nthe heap, which have to be considered when processing procedure calls in order to ensure which recursively \nde.ned metrics on locations continue to hold after a procedure call. Also, the .nal decidable theories \nthat we compile our conditions down to does require a bit of quanti.cation, but it turns out to be in \nthe array property fragment which admits automatic decision procedures. Implementation and Evaluation: \nOur proof mechanisms are essentially a class of decidable proof tactics that result in sound but incomplete \nvalidation procedures. To show that this class of natural proofs is e.ective in practice, we pro\u00advide \na prototype implementation of our technique, which handles a low-level programming language with pre-conditions \nand post\u00adconditions written in Dryad. We show, using a large class of correct programs manipulating lists, \ntrees, cyclic lists, and doubly linked lists as well as multiple data-structures of these kinds, that \nthe nat\u00adural proof mechanism succeeds in proving the veri.cations con\u00additions automatically. These programs \nare drawn from a range of sources, from textbook data-structure routines (binary search trees, red-black \ntrees, etc.) to routines from Glib low-level C-routines used in GTK+/Gnome to implement .le-systems, \nfrom the Schorr-Waite garbage collection algorithm, to several programs from a re\u00adcent secure framework \ndeveloped for mobile applications [29]. Our work is by far the only one that we know of that can handle \nsuch a large class of programs, completely automatically. Our experience has been that the user-provided \ncontracts and invariants are easily expressible in Dryad, and the automatic natural proof mechanisms \nwork extremely fast. In fact, contrary to our own expectations, we also found that the tool is useful \nin debugging: in several cases, when the annotations supplied were incorrect, the model provided by the \nSMT solver for the natural proof was useful in detecting errors and correcting the invariants/program. \n2. Related Work The natural proof methodology was introduced in [27] (see also [39]), but was exclusively \nbuilt for tree data-structures. In particular, this work could only handle recursive programs, i.e., \nno while-loops, and even for tree data-structures, imposed a large number of restric\u00adtions on pre/post \nconditions for methods the input to a procedure had to be only a single tree, the method can only return \na sin\u00adgle tree, and even then must havoc the input tree given to it. The lack of handling of multiple \nstructures means that even simple pro\u00adgrams like mergesort (that merges two lists), cannot be handled, \nand simple programs that manipulate two lists or two trees cannot be reasoned with. Also, structures \nsuch as doubly-linked lists, trees with parent pointers, etc. are out of scope of this work. Technically, \nin our present work, we can handle user-de.ned structures express\u00adible in separation logic, multiple \nstructures and their separation, programs with while-loops, etc., because of our logical treatment of \nseparation logic using classical logic. There is a rich literature on analysis of heaps in software. \nWe omit discussing literature on general interactive theorem provers (like Isabelle [31]) that require \nconsiderable manual guidance. We also omit a lot of work on analyzing shape properties of the heap [6, \n13, 18, 28, 41], as they do not handle complex functional properties. There are several proof systems \nand assistants for separation logic [32, 36] that incorporate proof heuristics and are incom\u00adplete. However, \n[3] gives a small decidable fragment of separation logic on lists which has been further extended in \n[11] to include a restricted form of arithmetic. Symbolic execution with separa\u00adtion logic has been used \nin [4, 5, 8] to prove structural speci.ca\u00adtions for various list and tree programs. These tools come \nhard\u00adwired with a collection of axioms and their symbolic execution en\u00adgines check the entailment between \ntwo formulas modulo these ax\u00adioms. Verifast [20], on the other hand, chooses .exibility of writ\u00ading richer \nspeci.cations over complete automation, but requires the user to provide inductive lemmas and proof tactics \nto aid veri.ca\u00adtion. Similarly, Bedrock [15]is a Coq library that aims at mostly automated (but not completely \nautomated) procedures that requires some proof tactics to be given by the user to prove veri.cation conditions. \nThe idea of using regions (sets of locations) for de\u00adscribing heaps in our work also extends to describing \nframes for function calls, and the use for the latter is similar to implicit dy\u00adnamic frames [38] in \nthe literature. The crucial di.erence in our framework is that the implicit dynamic frames are syntactically \nde\u00adtermined, and amenable to quanti.er-free reasoning. A work that comes very close to ours is a paper \nby Chin et al. [14], where the au\u00adthors allow user-de.ned recursive predicates (similar to ours) and \nbuild a terminating procedure that reduces the veri.cation condi\u00adtion to standard logical theories. However, \ntheir procedure does not search for a proof in a well-de.ned simple and decidable class, un\u00adlike our \nnatural proof mechanism; in fact, the resulting formulas are quanti.ed and incompatible with decidable \nlogics handled by SMT solvers. In all of the above cited work and other manual and semi\u00adautomatic approaches \nto veri.cation of heap-manipulating pro\u00adgrams like [37], inductive de.nitions of algebraic data-types \nis ex\u00adtremely common for capturing second-order data-structure proper\u00adties. Most of these approaches \nuse proof tactics which unroll induc\u00adtive de.nitions and do extensive uni.cation to try to match terms \nto .nd simple proofs. Our notion of natural proofs is very much in\u00adspired by such kinds of semi-automatic \nand manual heap reasoning that we have seen in the literature. There is also a variety of veri.cation \ntools based on classi\u00adcal logics and SMT solvers. Dafny [23] and VCC [16] compile to Boogie [2] and generate \nVCs that are passed to SMT solvers. This approach requires signi.cant ghost annotations, and annota\u00adtions \nthat explicitly express and manipulate frames. The Jahob sys\u00adtem [43, 44] is one of the .rst attempts \nat full functional veri.ca\u00adtion of linked data structures, which integrates a variety of theo\u00adrem provers, \nincluding SMT solvers, and makes the process mostly automated. However, complex speci.cations combining \nstructure, data and separation usually require more complex provers such as Mona [21], or even interactive \ntheorem provers such as Is\u00adabelle [31] in the worst case. The success of the proof search also relies \non users manual guidance.  void heapify(loc x) { assume x.left0 * nil if (x.left = nil) assume x.right0 \n* nil s := x.right; lx := x.left0 else if (x.right = nil) rx := x.right0 s := x.left; assume lx.key0 \n< rx.key0 else { s := x.right0 lx := x.left assume s * nil rx := x.right; assume s.key0 > x.key0 if (lx.key \n< rx.key) t := s.key0 s := x.right; s.key1 := x.key0 else x.key2 := t s := x.left; heapify(s) } ( def \nmheap. -(x) . = if (s.key > x.key) { x = nil . emp t := s.key; (key,left,right if (s =/= nil) pf . x \n-. (k, l, r) s.key := x.key; * (mheap. (l). {k} = keys. .(l)) x.key := t; .-- pf pf )) heapify(s); * \n(mheap. -(r). {k} = keys. .(r)) . - pf pf } ( def } keys. .(x) = - pf (key,left,right x = nil . emp \n: \u00d8 ; .pre = x -. (k, l, r) ) key,left,right * mheap. .-(l)* mheap. -(r)x -. (k, l, r)* true : . pf pf \nkeys. .-(l). {k} . keys. -(r) ; . . keys. -(x)= K pf ) pf . pf default : \u00d8 .post = mheap. -(x). keys. \n. (x)= . -K pf pf Figure 1. Motivating example: Heapify The idea of unfolding recursive de.nitions and \nformula abstrac\u00adtion also features in the work by Suter et al. [39, 40], where a pro\u00adcedure for algebraic \ndata-types is presented. However, this work focuses on soundness and completeness, and is not terminating \nfor several complex data structures like red-black trees. Moreover, the work limits itself to functional \nprogram correctness; in our opinion, functional programs are very similar to algebraic inductive speci.\u00adcations, \nleading to much simpler proof procedures. There is also a rich literature on completely automatic deci\u00adsion \nprocedures for restricted heap logics, some of which com\u00adbine structure-logic and arbitrary data-logic. \nThese logics are usu\u00adally FOLs with restricted quanti.ers, and usually are decided us\u00ading SMT solvers. \nThe logics Lisbq [22]and CSL [9, 10] o.er such reasoning with restricted reachability predicates and \nquanti.cation; see also the logics in [1, 7, 30, 33 35]. Strand is a relatively ex\u00adpressive logic that \ncan handle some data-structure properties (like BSTs) and admits decidable fragments [25, 26], but is \nagain not expressive enough for more complex properties of inductive data\u00adstructures. None of these logics \ncan express the class of VCs for full functional veri.cation explored in this paper. 3. Motivating Example \nIn this section we give intuition into our veri.cation approach through a motivating example. Recall \nthat a max-heap is a binary tree such that for each node n the key stored at n is greater than or equal \nto the keys stored at each of its children. Heaps are often used to implement priority queues. In Figure \n1, in the lower right corner, we express the property that a location x points to a max\u00adheap using recursive \nde.nitions keys. .-(x) and mheap. -(x), with . pf pf -. pf = {left, right}. These recursive de.nitions \nare written in Dryad, which is formally introduced in Section 4. Intuitively, Dryad ex\u00adtends quanti.er \nfree separation logic [32, 36] with recursive predi\u00adcates and functions. These recursive de.nitions allow \nus to express structural and data properties on the heap, like those of max-heap, without explicit quanti.cation. \nFor a location x, the recursive de.nition keys. -(x) returns the . pf set of keys at the nodes of the \ntree rooted at x: if x is nil and the heaplet is empty, then the empty-set; otherwise, the union of the \nkey stored at x and the keys stored in the left and right subtrees of x. Similarly, the recursive de.nition \nmheap. -(x)states that x points . pf to a max-heap if: x is nil and the heaplet is empty; or x and the \nheaplets of the left and right subtrees of x are mutually disjoint (x points to a tree) and the key at \nx is greater than or equal to the keys of the left and right subtrees of x. The method heapify in Figure \n1 is at the heart of the procedure for deleting the root from a max-heap (removing the node with the \nmaximum priority). If the max-heap property is violated at a node x while satis.ed by its descendants, \nthen heapify restores the max\u00adheap property at x. It does so by recursively descending into the tree, \nswapping the key of the root with the key at its left or right child, whichever is greater. The precondition \n.pre binds the free variable K to the set of keys of x. The postcondition states that after the procedure \ncall, x satis.es the max-heap property and the set of keys of x is unchanged (same as K). One of the \nmain aspects of our approach is to reduce reasoning about heaplet semantics and separation logic constructs \nto reason\u00ading about sets of locations. We use set operations like union, in\u00adtersection and membership \nto describe separation constraints on a heaplet satisfying a formula. This translation from Dryad formu\u00adlas, \nlike those in Figure 1, to formulas in classical logic with re\u00adcursive predicates and functions is formally \npresented in Section 5. Intuitively, we associate a set of locations to each (spatial) atomic formula, \nwhich is the domain of the heaplet satisfying that formula. Dryad requires that this heaplet is syntactically \ndetermined for each formula. For example, the heaplet associated to the formula x . . . . is the singleton \n{x}; for recursive de.nitions like mheap. -(x) and . pf keys. -(x), the domain of the heaplet is . reach{left,right}(x), \nwhich in\u00ad pf tuitively is the set of locations reachable from x using the pointer .elds left and right, \nand can be de.ned recursively. As shown in Figure 1, .pre is a conjunction of two formulas. If Gpre is \nthe domain of the heaplet associated to .pre, then the .rst conjunct requires Gpre to be the disjoint \nunion of the sets {x}, reach{left,right}(left(x)) and reach{left,right}(right(x)). The second con\u00adjunct \nrequires Gpre = reach{left,right}(x). From these heaplet con\u00adstraints, we can translate .pre to the following \nformula in classical logic over the global heap: Gpre = {x} . reach{left,right}(left(x)) . reach{left,right}(right(x)) \n. x f reach{left,right}(left(x)) . x f reach{left,right}(right(x)) . reach{left,right}(left(x)) n reach{left,right}(right(x)) \n= \u00d8 . x * nil . mheap(left(x)) . mheap(right(x)) . Gpre = reach{left,right}(x). keys(x)= K Similarly, \nwe translate .post to Gpost = reach{left,right}(x). mheap(x). keys(x)= K Note that the recursive de.nitions \nmheap and keys without the . superscript are in the classical logic (without the heaplet con\u00adstraint). \nHence the recursive predicate mheap satis.es ) mheap(x). x= nil.reach{left,right}(x)= \u00d8 ( . x* nil .xf \nreach{left,right}(left(x)).xf reach{left,right}(right(x)) . reach{left,right}(left(x)) n reach{left,right}(right(x)) \n= \u00d8 ( . reach{left,right}(x)= {x} . reach{left,right}(left(x)) ) .reach{left,right}(right(x)). mheap(left(x)) \n. {key(x)} = keys(left(x)) ) . mheap(right(x)) . {key(x)} = keys(right(x)) The right side of Figure 1 \npresents a basic path from method heapify, corresponding to the case when both children of x are not \nnil and the key of the right child is greater than the keys of the left child and the root. The subscript \nof a pointer/data .eld denotes the timestamp. A key insight is that any basic path touches a .nite number \nof locations and may call some recursive procedures. We refer to the touched locations as the footprint, \nand to the adjacent locations which are not part of the footprint as the frontier. For this example, \nthe footprint is { x, lx, rx } (s is known to be equal with rx)and the frontier is { left0(lx), right0(lx), \nleft0(rx), right0(rx)}. We capture the e.ect of the path until the call to heapify by  left0(x)* nil \n. right0(x)* nil . lx = left0(x). rx = right0(x) . key0(lx)< key0(rx). s = right0(x). s * nil . key0(s)> \nkey0(x). t = key0(s) . key1 = key0{s . key0(x)} . key2 = key1{x . t} Once we have expressed the veri.cation \ncondition in classical logic with recursive de.nitions over the global heap, we prove it using the natural \nproof methodology. We unfold the recursive de.nitions mheap(x), keys(x)and reach{left,right}(x)for x, \nlx and rx (the footprint), thus evaluating them in terms of their values on the frontier. The call to \nheapify preserves the recursive de.nitions on locations reachable from lx, and modi.es those on rx according \nto the pre/post condition. Finally, we abstract the recursive de.nitions on the frontier with uninterpreted \nfunctions. We decide the resulted formula (which is in a decidable logic) using an SMT solver. Section \n6 describes this process in detail. 4. The Logic Dryad In this section we present our logic Dryadsep \n; this rede.nes the logic Dryad [27]on arbitrary data-structures (not just trees), using heaplet semantics \nand separation logic primitives; the logic hence is a quanti.er-free heaplet logic augmented with recursively \nde.ned predicates/functions. However, for brevity, we will refer to the new logic we propose as Dryad, \nand refer to the logic in [27] as Dryadtree . 4.1 Syntax Let us .x a .nite set of pointer-.elds PF and \na .nite set of data\u00ad.elds DF. A record consists of a set of pointer-.elds from PF and a set of data-.elds \nfrom DF. Our logic also presumes that locations refer to entire records rather than particular .elds, \nand that address arithmetic is precluded. We will use the term locations hence to refer to these records. \nWe assume that every .eld is de.ned at every location, i.e., all memory records have the same layout \n(to simplify the presentation); our logic can easily be extended with record types. Let Bool = {true, \nfalse} stand for the set of Boolean values, Int stand for the set of integers and Loc stand for the universe \nof locations. For any set A, let S(A) denote the set of all .nite subsets of A, and let MS(A) denote \nthe set of all .nite multisets with elements in A. The Dryad logic allows expressing quanti.er-free .rst-order \nproperties over heaps/heaplets augmented with recursively de.ned notions for a location to express second-order \nproperties, denoted as a function r : Loc . D. The codomain D can be IntL, S(Loc), S(Int), MS(Int)L or \nBool, where IntL and MS(Int)L extend Int and MS(Int)to lattice domains, respectively, in order to give \nleast .xed-point semantics (explained later in this section). Typical ex\u00adamples of these recursive de.nitions \ninclude the de.nitions of the height of a tree or the height of black-nodes in the tree rooted at a node \n(recursively de.ned integers), the set of nodes reachable from a location following certain pointer .elds \n(recursively de.ned sets of locations), the set/multiset of keys stored at a particular data-.eld under \nnodes reachable from a location (recursively de.ned set/mul\u00adtiset of integers), and the property that \nthe tree rooted at a node is a binary search tree or a balanced tree or just a tree (recursively de.ned \npredicates). A Dryad formula . is quanti.er-free, but parameterized by a set of recursive de.nitions \nDef .. The syntax of Dryad logic is given in Figure 2, where the syntax of formulas is followed by the \nsyntax for recursive de.nitions. Most symbols in Dryad are common and self-explanatory. Note that the \ninequality (< or =) between integer sets/multisets indicates that any integer in the left-hand side is \nless-than/not-greater-than any integer in the right-hand side. It is also noteworthy that the separating \nconjunction (*) from separation logic is also allowed, but only if it is not above any negation (\u00ac). \nWe require that every recursive function/predicate used in the formula . has a unique de.nition in Def \n.. Each recursive function - . is parameterized by a set of pointer .elds pf and a set of program variables \nsv, denoted as f-. . The subscripts are used in de.ning the . pf ,sv semantics of recursive functions \nin Section 4.2. We usually simply use f. when the subscripts are not relevant in the context. Similarly, \nrecursive predicates are denoted as p . or simply p .. The recursive - . pf ,sv functions are de.ned \nusing the syntax: (. ff ff ) (x, sv, ss): t (x, ss) ; . . . ; . f (x, sv, ss): t (x, ss) ; default : \nt (x, ss) 1 1 kk k+1 where .u f(x, sv, ss)/tu f (x, ss)is a formula/term in our logic with ss im\u00adplicitly \nexistentially quanti.ed. The recursively de.ned predicates are de.ned using the syntax: .p(x, sv, ss), \nwhich is a formula in our logic with ss implicitly existentially quanti.ed. The recursive func\u00adtion syntax \nabove expresses a case-split, with the function evaluat\u00ading to the .rst term whose guard evaluates to \ntrue. The restrictions on the recursive de.nitions are: Subtraction, set-di.erence, and negation are \ndisallowed;  Every variable in ss should appear in the right hand side of a points-to relation binding \nit to x exactly once.  For examples of recursive functions and predicates, see the de.ni\u00adtions keys. \n-(x)and mheap. .(x) in Figure 1, respectively. The set of . - pf pf program variables sv parameterizing \nthe de.nitions is empty in both these de.nitions and the set of implicitly existentially-quanti.ed variables \nss is {k, l, r}.  4.2 Semantics Our logic is interpreted on models that are program states: De.nition \n4.1. A program state is a tuple C = (R, s, h)where R . Loc \\ {nil} is a .nite set of locations;  s \n: Vars . Int . Loc is a store mapping program variables to locations or integers (of appropriate type); \n h : R \u00d7 (PF . DF) . Int . Loc is a heaplet mapping non\u00adnil locations and each pointer-.eld/data-.eld \nto values of the appropriate type. o  Note that the set of locations is, in general, larger than the \nstate R and hence R de.nes a subset of heap locations. The store maps variables to locations (not necessarily \nin R), but the heaplet h gives interpretations for pointer and data-.elds only for elements in R. Given \na heaplet h, for every pointer .eld pf, we denote the projection of hon R\u00d7 (PF\\ {pf} . DF)as h . pf;similarly, \nfor every data-.eld df, we denote the projection of h on R\u00d7 (PF . DF \\ {df}) as h . df. Also, for every \nsubset S . R, we denote the projection of h on S \u00d7 (PF . DF)as h | S. A term/formula with free variables \nF is interpreted by interpret\u00ading the free variables in F using the map s from variables to values. The \nsemantics of Dryad is similar to that of classical Separation Logic (SL). In particular, a term/formula \nwithout recursive de.ni\u00adtions is interpreted exactly in the same way in Dryad and SL. Hence we .rst give \nthe semantics of the non-recursive part, followed by the semantics of recursive de.nitions.  . i. : \nLoc . IntL sl. : Loc . S(Loc) si. : Loc . S(Int) msi. : Loc . MS(Int)L p : Loc . Bool j. IntL Variables \nL . S(Loc)Variables S . S(Int)Variables MS . MS(Int)L Variables q . Bool Variables x . Loc Variables \nc : IntL Constant pf . PF df . DF Loc Term: lt ::= x | nil IntL Term: it ::= c | j| i. (lt)| it + it \n| it - it - . pf,sv S(Loc)Term: slt ::= \u00d8l | L | {lt} | sl. -(lt) | slt . slt | slt n slt | slt \\ slt \n. pf,sv S(Int)Term: sit ::= \u00d8s | S | {it} | si. (lt) | sit . sit | sit n sit | sit \\ sit pfs,sv MS(Int)L \nTerm: msit ::= \u00d8m | MS | {it}m | msi. (lt)| msit . msit | msit n msit | msit\\msit pfs,sv .-- . pf,df \n. s Positive Formula: . ::= true | false | q | p (lt)| emp | lt -. (slt, it)| lt = lt | lt * lt | it \n= it | it < it | sit = sit | sit < sit | msit = msit | msit < msit - . pf,sv | slt . slt | slt q slt \n| sit . sit | sit q sit | msit . msit | msit l msit | lt . slt | lt f slt | it . sit | it f sit | it \n. msit | it f msit | . . . | . . . | . * . Formula: . ::= . | . . . | . . . | \u00ac. def ()ffff f Recursive \nfunction : f. (x) = . (x, sv, s ): t (x, s ); . . . ; . (x, sv, s ): t (x, s ); default : t (x, s ) - \n. 1 1 kk k+1 pf,sv def . Recursive predicate : p (x) = .p(x, sv, s ) - . pf,sv Figure 2. Syntax of \nDryad Before de.ning the semantics of formulas, we de.ne the pure propertyfor terms/formulas. Intuitively, \na term/formula is pure ifit is independent of the heap. Syntactically, a term/formula is pure if it does \nnot contain emp, -. or any recursive de.nition. Note that in SL all terms are pure, but in Dryad, a term \ncan be impure if it contains a recursive function f. . Semantics of terms Each T -term evaluates to either \na normal value of type T , or to undef, which is only used in interpreting recursive functions (will \nbe explained later). As a special value, undef will be propagated throughout the formula: if a formula \n. contains a sub-term that evaluates to undef, then . will evaluate to false if it appears positively, \nand will evaluate to true otherwise. Intuitively, undef cannot helpin making the formula true over a \nmodel. The Loc terms are evaluated as follows: [x]C = s(x) [nil]C = nil For anybinary operator op, t \nopt ' is evaluated as follows: . ' . [t]C op [t ']C if t or t is pure . ' . . . [t]C|R1 op[t ]C|R2 else \nif there exist R1, R2 such that . . ' . [t opt ]C = . R = R1 . R2, [t]C|R1 * undef . . . . and [t ']C|R2 \n* undef . . . undef otherwise where opis interpreted in the natural way. For singletons, {it} willevaluate \nto \u00d8 if it evaluates to -8 or 8: . . . undef if [it]C = undef . . [{it}]C = \u00d8 if [it]C = -8 or 8 . . \n. . {[it]C} otherwise {it}m and {lt} evaluate similarly. Semantics of formulas The formula true is always \ninterpretedto be true: (R, s, h)|= true The formula emp asserts that the heap is empty: (R, s, h)|= emp \ni. R = \u00d8 .-- . pf,df The formula lt -. (slt, sit) asserts that the heap contains exactly .-- . one record \nconsisting of .elds pf and df, at address lt, with values slt and sit, respectively. Formally, the semantics \nof this formula is given as: .-- . pf,df (R, s, h)|= lt -. (slt, sit) i. R = {[lt]R,s,h} and h([lt]R,s,h, \npfi)= [lti]R,s,h for corresponding pfi and lti, h([lt]R,s,h, dfi)= [iti]R,s,h for corresponding dfi and \niti. Note that, as in separation logic, the above has a strict semantics the heaplet must be a singleton \nset and cannot be a larger set. For binary relations t ~ t ' between integers, sets, and multisets, including \nequality, the pure property plays an important role. Re\u00admember that in SL all terms are pure. To be consistent \nwith SL, if botht andt ' are pure, itis interpretedin the normalway. Otherwise, t ~ t ' is only de.ned \non the minimum heaplet required by t and t ' , more concretely the union of the heaplet associated witht \nand t ' . '' ' (R, s, h)|= t ~ t i. t or t is pure and [t]C ~ [t ]C ' or t and t are impure and there \nexist R1, R2 s.t. R = R1 . R2 ' ' and [t]C|R1 * undef, [t ]C|R2 * undef and [t]C|R1 ~ [t ]C|R2 where \n~ is interpreted in the natural way. The semantics of the disjoint conjunction operator * is de.ned as \nfollows. The formula .0 * .1 asserts that the heap can be split into two disjoint parts in which .0 and \n.1 hold respectively: (R, s, h)|= .0 * .1 i. there exist R0, R1 s.t. R0 n R1 = \u00d8 and R0 . R1 = R and \n(R0, s, h | R0)|= .0 and (R1, s, h | R1)|= .1 Boolean combinations are de.ned in the standard way: (R, \ns, h)|= .0 . .1 i. (R, s, h)|= .0 and (R, s, h)|= .1 (R, s, h)|= .0 . .1 i. (R, s, h)|= .0 or (R, s, \nh)|= .1 (R, s, h)|= \u00ac. i. (R, s, h) |= . Semantics of recursive de.nitions The main semantical di.erence \nbetween Dryad and SL is on recur\u00adsive de.nitions. We would like to deterministically delineate the heap \ndomain for any recursive de.nition, so that the heap domain required by any Dryad formula can be syntactically \ndetermined. - . Given a recursive de.nition rec . . , the subscripts pf andsa -v play pf,sv role in delineatingthe \nheapdomain. Intuitively, the heapdomain for rec . . (l)is the set oflocations reachable from lusingpointer-.elds \n- pf,sv - . in pf, but without goingthroughthe locationssv. In other words, we wantto take the setoflocations \nthatlie in between landsv. Precisely, this set is determined by a location l and a program state (R, \ns, h).  . We denote it as reachset-(l, (R, s, h)). Formally it is the smallest pf,sv set of locations \nL satisfying the followingtwo conditions: 1. l is in the set L ifl is not insv and l * nil; 2. for each \nc in L, with c . R, and for each pointer pf, if h(c, pf)is not insv and is not nil, then h(c, pf)is also \nin L.  Note that even though the reach set is de.ned with respect to the edges in the heaplet, we can \ndetermine whether R includes all nodes reachable from l without going throughsv in the global heap bychecking \nwhether R = reachset-(l, (R, s, h)). . pf,sv For each recursive de.nition rec . -, we usually simply \ndenote . pf,sv reachset.-as reachsetrec , as the subscripts are implicitlyknown. pf,sv Now, given a program \nstate C = (R, s, h) and a recursive function/predicate rec ., the semantics on a location l depends on \nwhether the heap domain R is exactly the required reach set reachsetrec(l, (R, s, h)). If this is not \ntrue, we simply interpret it as undef or false. Ifthe heapdomain matches the reachset(i.e.,R = . reachset-(l, \npf,sv (R, s, h))), the semantics is de.ned in the natural way (using least .xed-points). The colon operator \nin the syntax ofrecursive function f-. translates into a nested if-then-else (ITE)operator. Formally, \n. pf,sv (ff fff ) [ f-. (l)]C = ITE. , [t ]C|R1, ITE(. , [t , . . . [t ]C|Rk+1 . . . ) . 11 22]C|R2 k+1 \npf,sv where R1 . . . Rk+1 . R such that [ti f ]C|Ri * undef. In order to give least .xed-point semantics \nfor recursive de.nitions in the logic, we extend the primitive data-types to lattice domains. Bool with \nthe order false . true forms a complete lattice, and S(Loc) and S(Int) ordered by inclusion, with join \nas union and meet as in\u00adtersection, form complete lattices. Integers and multisets are ex\u00adtended to lattices. \nLet (IntL, =)denote the complete lattice, where IntL = Int.{-8, 8}, andwhere the orderingis =, join is \nmax, meet is min. Also, MS(Int)L, . denote the complete lattice constructed from MS(Int), where MS(Int)L \n= MS(Int). {.}, and . extends the inclusion relation with S . . for any M . MS(Int). It is easy to see \nthat (IntL, .)and (MS(Int)L, .)are complete lattices. Formally, let Def consists of de.nitions of integer \nfunctions I, set-of-locations functions SL, set-of-integers functions SI, multiset\u00adof-integers functions \nMSI and predicates P. Since these de.nitions could relyon each other, we evaluate them altogether as \na function vector .---- -- .. .. . . i. r = ( ,sl. ,si. ,msi. , p ) We take the cartesian product lattice \nof the individual lattices and take the least .xed-point of r . to obtain the semantics for each de.nition. \nLet selectrec(lfp(r .)), for each recursive de.nition rec . , denote the selection of the coordinate \nfor rec . in lfp(r .). Now we can formally de.ne the semantics of recursive de.ni\u00adtions. For anycon.guration \nC, the semantics ofa recursive function f. is de.ned as: { () selectf lfp(r .)([lt]C) if R = reachsetf([lt]C, \nC) [ f.(lt)]C = undef otherwise and the semantics of a recursive predicate p . is de.ned as { () selectplfp(r \n.)([lt]C) if R = reachsetp([lt]C, C) [ p .(lt)]C = false otherwise Remark: Note that we disallow negative \noperations (subtraction, set-di.erence and negation)in de.ning recursive de.nitions. This syntactical \nrestriction guarantees that each iteration of r . is mono\u00adtonic. ByKnaster-Tarskitheorem, r . admits \na least .xed-point. Examples The Dryad logic was already used in Section 3 to de.ne max\u00adheaps. Note that \nthe de.nition of a max-heap is precisely de.ned on the heaplet that includes the underlying tree nodes \nof the max\u00adheap only, as the heaplet for a recursive de.nition is the set of all reachable nodes according \nto the two pointers. To clarify the di.erence between Dryad and SL, consider now this recursive de.nition: \n[()] def l,r . .. p (x) = (x = nil . emp) . (x -. y, z) * p (y). p (z) {l,r} {l,r} {l,r} Now consider \na global heapthat has a tree rooted at x withpointer .elds landr. The above recursive formula, in separation \nlogic, will be true on any heaplet that contains the nodes of a path in this tree from x to nil. However, \nin Dryad, we require that the heaplet must satisfy the heap constraints of the formula and also be the \nprecise set of locations reachable from x using the pointer .elds l and r. Consequently, if the tree \npointed to by x has more than one path, the Dryad formula willbe false for any heaplet. The above example \nshows the advantage of Dryad; when heaplets are determined, we can avoid quanti.cation. We have not found \nnatural examples where an undetermined heaplet semantics helps in specifying properties of heaps. Dryad \ncan express structures beyond trees. The main restriction we do impose is that we allow only unary recursive \nde.nitions, as this allows us to .nd simpler natural proofs since there is only one wayto unfoldthe de.nition \nacross a footprint. However, Dryad can express structures like cyclic lists and doubly-linked lists. \nA cyclic-list is captured as (v . y)* lseg. (y). Here, v is next,v a program variable which denotes the \nhead of the cyclic-list and lseg. (y) captures the list segment from y back to the head v, next,v where \nthe subscripts next and v indicate that the heaplet of the list segment is the locations that can be \nreachedusingthe .eldnext, but without going through v: def (next) . . lseg(y) = (y = v . emp). (y . z)* \nlseg(z) next,v next,v Another interestingexample is a doubly-linked list. We de.ne a doubly-linked list \nas the followingunary predicate: next dll. (x) = (x = nil . emp) . (x . nil) . next (next(prev)) x . \ny * (y . x * true) . dll. (y) next The .rsttwo disjuncts in the de.nition cover the base case when x \nis nilor the location next to x is nil;otherwise, lety be the location next to x, then the prev pointer \nat y points to x and location y is recursivelyde.ned as a doubly-linked list. 5. Translation to a Logic \nover the Global Heap We now show one ofthe main contributions ofthis paper a trans\u00adlation from Dryad \nlogic to classical logic with recursive predicates and functions, but over the globalheap. The formulation \nofsepara\u00adtion logic primitives in the global heap allows us to express com\u00adplex structural properties, \nlike disjointness of heaplets and tree\u00adness, using recursive de.nitions over sets of locations, which \nare de.ned locally, and are amenable to unfolding across the footprint and hence amenable to natural \nproofs. For example, consider the formula mheap.(x) * mheap.(y), where mheap. is de.ned in Section 3. \nSince the heaplets for mheap.(x) and mheap.(y) are precise, it can get translated to an equivalent formula \nwitha free set variable G that denotes the global heap over whichthe formula is evaluated: mheap(x). \nmheap(y). (reachmheap(x)n reachmheap(y)= \u00d8) . (reachmheap(x). reachmheap(y)= G) where mheap and reachmheap \nare corresponding recursive de.ni\u00adtions in classical logic, which will be de.ned later in this section. \nNote that we use italics and remove the . superscript to show the di.erence from their counterpart in \nDryad. We assume the Dryad formula to be translated is in disjunctive normalform, i.e.,. operators shouldbe \nabove all* and. operators.  Construct Domain-exact Scope var/const false \u00d8 {t}/{t}m dom-ext(t) scope(t) \n' ' ' t op t dom-ext(t). dom-ext(t ) scope(t). scope(t ) f.(lt) true reachsetf(lt) true/false false \u00d8 \nemp true \u00d8 spf, sdf lt -. (slt, sit) true {lt} p .(lt) true reachsetp(lt) ' ' ' t ~ t dom-ext(t). dom-ext(t \n) scope(t). scope(t ) . . . ' dom-ext(.). dom-ext(. ' ) scope(.). scope(. ' ) . * . ' dom-ext(.). dom-ext(. \n' ) scope(.). scope(. ' ) Figure 3. Domain-exact propertyandScope function. Bothare de\u00ad.nedonlyfor terms \nandformulas without disjunction andnegation. A formula is assumed in its disjunctive normal form. This \nis not a real restriction as one can always push the disjunction out. This normalform ensures thatfor \nalloccurrences ofthe separa\u00adtion operator in a formula, there exists a unique wayofsplittingthe heap \nso as to satisfy the * separated sub-formulas. Also, it ensures that this unique heap-split can be determinedsyntacticallyfrom \nthe structure of those sub-formulas. In our translation, we model the heaplets associated with a for\u00admula \nor a term as a set of locations and all operations on these heaplets are modeled as set operations like \nset union, set intersec\u00adtions, etc. over set-of-location variables. For example the separating conjunction \nP*Qis translatedto the followingsetconstraint: the in\u00adtersection of the sets associated withthe heaplets \nin the formulas P and Qis empty. Given a formula . in Dryad andits associatedheap domain modeled by a \nset variable G, we de.ne an inductive trans\u00adlation T into a classical logic formula T(., G) in the quanti.er\u00adfree \ntheory of .nite sets, integers and uninterpreted functions. The translatedformula is not interpretedon \na heaplet, but interpretedon a global heap (i.e., withthe heap domain Loc). The translation uses an auxiliary \ndomain-exact property and an auxiliary scope function. The domain-exact property indicates whether a \nterm evaluates to a well-de.ned value or a positive formula evaluates to true on a .xed heap domain or \nnot. This is di.erent from the property pure; a pure formula or term is not domain-exact but the reverse \nimplication is not true, in general. For example, the formula (lt -. it)* true is not domain-exact but \nis also not pure. The scope function maps a term to the minimum heap domain required to evaluate it to \na normal value, and maps a positive formula to the minimum heapdomain required to evaluate it to true. \nThe domain-exact property and the scope function are de.ned inductively in Figure 3. We describe the \nlogic translation in detail in Figure 4. The ITE expression usedin the translation is shortfor if-then-else \n. Itis just a conditional expression de.ned as follows: ITE(f, t1, t2)evaluates to t1 if f is true, otherwise \nevaluates to t2. In general, our translation restricts an impure term/formula to be evaluated only on \nthe syntactically determined heap domain accordingto the semantics of Dryad. In particular, when evaluating \na recursive formula or predicate p ., we ensure that the heaplet is precisely the reach set reachp(lt). \nFor a formula . * . ' , translation to classical logic depends on whether the sub-formulas . and . ' \nare domain-exact or not. Ifa sub-formula is domain-exact then it is evaluated on its scope. Ifit is not \ndomain-exact, then it is evaluated on the rest of the heaplet. Recursive de.nitions in Dryad are also \ntranslated to recursive de.nitions in classicallogic. Translatinga recursive de.nition rec . uses the \ncorresponding de.nitions rec and reachrec , both of which are de.ned recursively in classical logic. \nThe set reachrec repre\u00adsents the domain of the required heaplet for evaluating rec ., and the .-eliminated \nde.nition rec captures the value of rec . when the T(var / const, G) = var / const T({t} / {t}m, G) = \n{t} / {t}m ' ' T(t op t , G) = T(t, G) op T(t , G) () T(f.(lt), G) = ITE reachf(lt)= G, f(lt), undefT(true \n/ false, G) = true / false T(emp, G) = G = \u00d8 pfs,df1() s s T(lt -. (slt, it), G) = G = {lt} . pfi pfiT(lt, \nG)= T(lti, G) 1() . dfiT(lt, G)= T(iti, G) dfi T(p .(lt), G) = p(lt). G = reachp(lt) . ' ' . t ~ t if \nt ~ t is not domain-exact . . ' T(t ~ t , G) = . . ' ' . t ~ t . G = scope(t ~ t ) otherwise T(. . . \n' , G) = T(., G). T(. ' , G) T(. . . ' , G) = T(., G). T(. ' , G) T(\u00ac., G) = \u00acT(., G) ()(). . T ., scope(.). \nT . ' , scope(. ' ) . . . . . scope(.). scope(. ' )= G . . . . . scope(.)n scope(. ' )= \u00d8 . . . . . . \nif both . and . ' are domain-exact . . . . .()(). . T ., scope(.). T . ' , G \\ scope(.) . . . . . . . \nscope(.). G if only. is domain-exact . T(. * . ' , G) = .()(). . . T . ' , scope(. ' ). T ., G \\ scope(. \n' ) . . . . . . scope(. ' ). G if only. ' is domain-exact . . . . .()(). . T ., scope(.). T . ' , scope(. \n' ) . . . . . . . scope(.). scope(. ' ). G . . . . . scope(.)n scope(. ' )= \u00d8 . . . if neither . nor \n. ' is domain-exact Figure 4. Translating Dryad terms/formulas to classical logic heaplet is restricted \nto reachrec . Formally, suppose rec . is a recur\u00adsive de.nition w.r.t. pointer .elds pfsand stopping \nlocations sv, then reachrec is recursively de.ned as the least .xed-point of def ( ()) reachrec(x) = \nITEx = nil . x . sv, \u00d8, {x} . reachrec(pf(x)) pf.pfsdef For each recursive predicate p . de.ned as p \n.(x) = .p(x, sv, s ), we de.ne def () p(x) = T .p(x, sv, s ), reachp(x) Similarly, for each recursive \nfunction f. de.ned as def(ffff f ) f.(x)= . (x, sv, s ): t (x, s ); . . . . (x, sv, s ): t (x, s ); default \n: t (x, s ) 1 1 kk k+1 we de.ne def (()f f-. f(x) = ITET . (x, sv, s ), reachf (x), t (x, s ) 1 1 ((f \n)f-. ITET . (x, sv, s ), reachf(x), t (x, s ) 2 2 )) f-. . . . , tk+1 (x, s ) . . . f-. f where ti (x, \ns ) is just the classical logic counterpart of ti (x, s ), when interpretedin a heapdomain within reachf(x). \nFormallyit is short for (f (f f )) ITEscope(t (x, s )). reachf(x), T t (x, s ), scope(t (x, s )), undef \ni ii Now for each set of recursive de.nitions Def . in Dryad, we can translate it to a set of recursive \nde.nitions Def in classical logic. Theorem 5.1. Let . be a Dryad formula w.r.t. a set of recursive de.nitions \nDef .. For everyprogram state C withheapdomain Loc, and for every interpretation of variables I including \na valuation for set-variable G, (C, I) |= T(., G) w.r.t. Def if and only if (C |G, I \\ {G})|= . w.r.t. \nDef . . o  P :- P ;P | stmt stmt :- u := v | u := nil | u := v.pf | u.pf := v | j:= u.df | u.df := j \n| j:= aexpr | u := new | free u | assume bexpr | u := f(sv, sz) | j:= g(sv, sz) aexpr :- int | j | aexpr \n+ aexpr | aexpr - aexpr bexpr :- u = v | u = nil | aexpr = aexpr | \u00acbexpr | bexpr . bexpr Figure 5. \nSyntax of programs 6. Natural Proofs for Dryad In this section we show how Dryad can be used in reasoning \nabout the correctness of imperative heap-manipulating programs, in terms of verifying Hoare-triples where \nthe pre-and post-conditions are expressed in Dryad. We .rst introduce a simple programming lan\u00adguage \nand the corresponding Hoare-triples, generate a classical logic formula as the veri.cation condition, \nutilizing in part the translation de.ned in Section 5. Then we present the natural proof framework which \nconsists of two steps. In the .rst step, we utilize the idea of unfolding across the footprint to strengthen \nthe veri.ca\u00adtion condition. In the second step, we prove the validity of the VC soundly using the technique \nof formula abstraction. 6.1 Programs and Hoare-triples We consider straight-line program segments that \ndo destructive pointer-updates, data-updates and procedure calls. Parameterized by a set of pointer .elds \nPF and a set of data-.elds DF, the syntax of the programs is de.ned in Figure 5, where pf . PF, f . DF, \nu and v are program variables of type location, jand z are program variables of type integer, int is \nan integer constant. To simplify the presentation, we assume all program variables are local and are \neither pre-assigned or assigned once in the program. We allow two kinds of recursive procedures, one \nreturning a location f(sv, sz) and one returning an integer g(sv, sz). Each proce\u00addure/program is annotated \nwith its pre-and post-conditions in Dryad. The pre-condition is denoted as a formula .pre(sv, sz, sc), \nwhere sv and sz are variables as the formal parameters/program vari\u00adables, sc is a set of implicitly \nexistentially quanti.ed complimentary variables (e.g., variable K in the pre-condition .pre in Figure \n1). The post-condition is denoted as a formula .post(ret, sv, sz, sc), where ret is the variable representing \nthe returned value, of corresponding type, sv and sz are program variables, sc is a set of complimentary \nvariables that have appeared in the pre-condition .pre. Given a straight-line program with its pre-and \npost-conditions {.pre} P{.post}, we de.ne its partial correctness without considering memory errors3: \nPis partially correct i. for every normal execution (memory-error free) of P, which transits state C \nto state C ' , if C |= .pre, then C ' |= .post. Given a Hoare-triple {.pre} P {.post} as de.ned above, \na set of recursive de.nitions and a set of annotated procedure declarations are presented here. Assume \nthat P consists of n statements, then consider a normal execution E, which can be represented as a se\u00adquence \nof program states (C0, . . . , Cn), where each Ci = (Ri, si, hi) represents the program state after executing \nthe .rst i statements. The veri.cation condition is just a formula interpreted on a state se\u00adquence (C0, \n. . . , Cn). Let pfi : Loc . Loc be the function mapping every location lto its pf pointer, i.e., pfi(l)= \nhi(l, pf) for every loca\u00adtion l. Similarly, dfi : Loc . Int is de.ned such that dfi(l)= hi(l, df) for \nevery l. Recall that every program variable is either pre-assigned or assigned once in the program, each \nsi is an expantion of the pre\u00advious one, and sn is the store with all program variables de.ned. 3We exclude \nmemory errors in order to simplify the presentation. Memory errors can be handled using a similar VC \ngeneration for assertions that negate the conditions for memory errors to occur. Hence we simply use \nv to denote sn(v). Moreover, every recursive predicate/function is also indexed by i. For example, pi \nis the recur\u00adsive predicate such that pi(l) is true i. Ci |= T(p .(l), reachsetp(l)). Now for every formula \n. and every index i, we can give the index i to all the pointer .elds, data .elds and recursive de.nitions. \nWe denote the indexed formula as .[i]. We algorithmically derive the veri.cation condition .VC corre\u00adsponding \nto it in classical logic with recursive de.nitions on the global heap (the algorithm is quite involved, \nand is presented in Appendix A in the supplemental material ). Theorem 6.1. Given a Hoare-triple {.pre} \nP {.post}, assume that each procedure call in P satis.es its associated pre-and post\u00adconditions. Then \nthe triple is valid if the formula .VC derived above is valid. Moreover, when P contains no procedure \ncalls, the triple is valid i. .VC is valid. Proof. Presented in Appendix B in the supplemental material. \no  6.2 Unfolding Across the Footprint The veri.cation condition obtained above is a quanti.er-free for\u00admula \ninvolving recursive de.nitions and the reachable sets of the form reachp(x), which are also de.ned recursively. \nWhile these re\u00adcursive de.nitions can be unfolded ad in.nitum, we exploit a proof tactic called unfolding \nacross the footprint. Intuitively, the footprint is the set of locations explored by the program explicitly \n(not in\u00adcluding procedure calls). More precisely, a location is in the foot\u00adprint if it is dereferenced \nexplicitly in the program. The idea is to unfold the recursive de.nitions over the footprint of the program, \nso that recursive de.nitions on the footprint nodes are related, as precisely as possible, to the recursive \nde.nitions on frontier nodes. This will enable e.ective use of the formula abstraction mecha\u00adnism, as \nwhen recursive de.nitions on frontier nodes are made un\u00adinterpreted, the unfolding formulas ensure tight \nconditions that the frontier nodes have to satisfy. Furthermore, to enable e.ective frame reasoning, \nit is also nec\u00adessary to strengthen the veri.cation condition with a set of in\u00adstances of the frame rule. \nMore concretely, we need to capture the fact that a recursive de.nition (or a .eld) on a location is \nunchanged during a segment or procedure call of the program, if the reachable locations (or only the \nlocation itself) are not a.ected by the segment or procedure call. We incorporate the above facts formally \ninto the veri.cation condition. Let us introduce a macro function fp that identi.es the location variables \nthat are in (or aliased to something in) the foot\u00adprint. The footprint of P, FP, is the set of dereferenced \nvariables in P (we call a location variable dereferenced if it appears on the left-hand side of a dereferencing \noperator . in P). Then fp(u) = v v.FP(u = v). Now we state the unfoldings and framings using a formula \nUnfoldAndFrame. Assume there are m procedure calls in P, then P can be divided into m + 1 basic segments \n(subprograms without procedure calls): S0 ; g1 ; S1 ; . . . ; gm ; Sm where Sd is the (d + 1)-th basic \nsegment and gd is the d-th procedure call. Then 11 1[ UnfoldAndFrame = rec 0=d=m u.LVars.{nil} (()()) \nrec fp(u). u= nil. Unfold (u). FieldUnchangedd(u). d (()) ] rec \u00acfp(u). u= nil. RecUnchanged (u) d The \nformula enumerates every recursive de.nition rec and every index d, and for each location u that is either \npointed to by a lo\u00adcation variable or is nil, the formula checks if u is in the footprint, and then unfolds \nit or frames it accordingly. If u is in the foot\u00adprint, then we unfold rec for the timestamps before \nand after Sd rec (represented by the formula Unfold d (u) ); moreover, all .elds of  u are unchanged \nif it is not a.ected during calling gd (represented by the formula FieldUnchangedd(u) ). If u is not \nin the footprint, i.e., in the frontier, then rec and its corresponding reach set reachrec are unchanged \nafter executing Sd, if Sd does not modify any loca\u00adtion in reachrec ; they are also unchanged if reachrec \nis not a.ected by calling gd. These frame assertions are represented by the for\u00admula RecUnchanged rec \nd (u). All the sub-formulas mentioned above are formulated in Appendix C in the supplemental material. \nNow we can strengthen the veri.cation condition by incorporat\u00ading the derived formula above: . ' VC = \n.VC . UnfoldAndFrame Since the incorporated formula is implied by the veri.cation condition, we can reduce \nthe validity of .VC to the validity of . ' . VC VC  6.3 Formula Abstraction While checking the validity \nof the strengthened veri.cation condi\u00adtion . ' is still undecidable, as we argued before, it is often \nsu.- VC cient to prove it by assuming that the recursive de.nitions are arbi\u00adtrary, or uninterpreted. \nMoreover, the uninterpreted formula falls in the array property fragment [12], whose satis.ability is \ndecidable and is supported by modern SMT solvers such as Z3 [17]. This tac\u00adtic roughly corresponds to \napplying uni.cation in proof systems. To prove . ' , we .rst replace each recursive predicate recd with \nVC an uninterpreted predicate recd, and replacing the corresponding rec reach-set function reachrec d \nwith an uninterpreted function reach d . Let the result formula be .abs . This conversion, called formula \nVC abstraction, is sound: if .abs is valid, so is . ' . When a proof for VC VC .abs is found, we call \nit a natural proof for . ' (and also for .VC). VC VC The formula abstraction step is the only step that \nintroduces in\u00adcompleteness in our framework, but helps us transform the veri.\u00adcation condition to a decidable \ntheory. Formula abstraction (com\u00adbined with unfolding recursive de.nitions across the footprint) dis\u00adcovers \nrecursive proofs where the recursion is structural recursion on the de.nitions of the data-structures. \nThe use of these tactics comes from the observation that such programs often have such recursive proofs \n(see [39] also for use of formula abstractions). \u00ac.abs Our goal now is to check the satis.ability of \nVC in a decidable theory. The resulting formula can be expressed using the theory of maps (to model sets) \nand corresponding map operations to model set operations. Formulas of the kind S1 = S2, where S1 and \nS2 are sets/multi-sets of integers, are the only ones that introduce quanti.cation, but they can be translated \nto formulas in the array property fragment, which is decidable [12]. We hence obtain a formula .APF in \nthe array property fragment combined with the theory of uninterpreted functions, maps, and arithmetic \n(details are in Appendix D in the supplementary material). Theorem 6.3. Given a Hoare-triple {.pre} P \n{.post}, if the derived array formula .APF is satis.able, then the Hoare-triple is valid. o User-provided \naxioms: While natural proofs are often e.ective in .nding recursive proofs that unfold recursive de.nitions \nand do uni.cation, they are not geared towards .nding relationships between various recursive def\u00adinitions \nthemselves. We hence require the user to provide certain obvious relationships between the di.erent recursive \nde.nitions as axioms. For example, lseg(x, y)* list(y) . list(x) is such an ax\u00adiom saying that a list \nsegment concatenated with a list yields a list. Note that these axioms are not program-dependent, and \nhence are not program-speci.c tactics that the user provides. These ax\u00adioms are necessary typically to \nrelate partial data-structure proper\u00adties (like list segments) to complete ones (like lists), especially \nin Theorem 6.2. Given a Hoare-triple {.pre} P{.post}, its veri.cation condition .VC is valid if and \nonly if . ' is valid. o Data-structure Routine Time (s) /Routine Singly-Linked List find rec, insert \nfront, insert back rec, delete all rec, copy rec, append rec, reverse iter < 1s find rec, insert rec, \nmerge rec, Sorted List delete all rec, insert sort rec, reverse iter, find last iter < 1s Doubly-Linked \nList Cyclic List Max-Heap insert iter 1.4 quick sort iter insert front, insert back rec, delete all rec, \nappend rec, mid insert, mid delete, meld insert front, insert back rec, delete front, delete back rec \nheapify rec 64.8 < 1s < 1s 8.8 find rec, find iter, insert rec, < 1s delete rec, remove root rec  insert \niter 72.4 BST find leftmost iter 4.7 remove root iter delete iter 225.2 find rec, delete rec < 1s Treap \ninsert rec 12.7 remove root rec 9.5 AVL-Tree balance, leftmost rec insert rec delete rec < 1s 4.1 13.9 \n insert rec 73.9 insert right fix rec insert left fix rec  RB-Tree delete rec 12.1 delete right fix \nrec delete left fix rec  leftmost rec < 1s Binomial find min rec 1.1  Heap merge rec 152.7 Schorr-Waite \nmarking iter < 1s (for trees) inorder tree to list rec 2.4 Tree inorder tree to list iter 42.7 Traversals \npreorder rec, postorder rec < 1s     inorder rec 3.76 Figure 6. Results of verifying data-structure \nalgorithms. (more details at http://www.cs.uiuc.edu/ madhu/dryad/sl/ ) iterative programs (as opposed \nto recursive ones), and we can .x them for each class of data-structures. We also allow the use of the \nseparating implication, -*, from separation logic while specifying these axioms. User-de.ned axioms are \ninstantiated, using the nat\u00adural proof philosophy, on precisely the footprint nodes uniformly, and get \ntranslated to quanti.er-free formulas. 7. Experimental Evaluation We have implemented a prototype of \nthe natural proof methodol\u00adogy for Dryad presented in this paper. The prototype veri.er takes as input \na set of user-de.ned recursive de.nitions, a set of pro\u00adcedure declarations with contracts, and a set \nof straight-line pro\u00adgrams (or basic blocks)annotated with a pre-condition and a post\u00adcondition specifying \na set of partial correctness properties includ\u00ading structural, data and separation requirements. Both \nthe contracts and pre-/post-conditions are written in Dryad. For each basic block, the veri.er automatically \ngenerates the abstracted formula .APF as described in Section 6, and passes .APF to Z3 [17], a state-of-the\u00adart \nSMT solver, to check the satis.ability in the decidable theory of array property fragment. The front-end \nof our veri.er is based on ANTLR and our tool is around 4000 lines of C# code. Using the veri.er, we \nsuccessfully proved the partial correctness of 59 rou\u00adtines over a large class of programs involving \nheap data structures like sorted lists, doubly-linked lists, cyclic lists and trees. Addi\u00adtionally, we \npit our natural proofs methodology against real-world programs and successfully veri.ed, in total, 47 \nroutines from dif\u00adferent projects including the list and queue implementations in the Glib open source \nlibrary, the OpenBSD library, the Linux kernel and the memory regions and the page cache implementations \nfrom two di.erent operating systems. Experimental details are available at http://www.cs.uiuc.edu/ madhu/dryad/sl/ \n.  We conducted the experiments on a machine with a dual-core, 2.4GHz CPU and 6GB RAM. The .rst part \nof our experimental results is tabulated in Figure 6. In general, for every routine, we checked the properties \nformalizing the complete veri.cation of the routines capturing the precise structure of the resulting \nheap\u00adstructure, the precise change to the data stored in the nodes and the precise heaplet modi.ed by \nthe respective routines. For every routine, the su.x rec or iter indicates if the routine was implemented \nrecursively or iteratively using while loops. The names for most of the routines are self-descriptive. \nRoutines like find, insert, delete, append, etc. are the natural implementa\u00adtions of the corresponding \ndata structure operations. The routine delete all for singly-linked lists, sorted lists and doubly-linked \nlists recursively deletes all occurrences of a particular key in the input list. The max-heap routine \nheapify accepts an almost max\u00adheap in which the heap property is violated only at the root, both of whose \nchildren are max-heaps, and recursively descends the tree to restore the max-heap property. The routine \nremove root for bi\u00adnary search trees and treaps is an auxiliary routine which is called in delete. Similarly, \nthe routines leftmost for AVL-trees and RB-trees and delete fix and insert fix for RB-trees are also \nauxiliary routines. Schorr-Waite is a well-known graph marking algorithm which marks all the reachable \nnodes of the graph using very little addi\u00adtional space. The algorithm achieves this by manipulating the \npoint\u00aders in the graph such that the stack of nodes along the path from the root is encoded in the graph \nitself. The Schorr-Waite algorithm is used in garbage collectors and it is traditionally considered as \na challenging problem for veri.cation [19]. The routine marking is an implementation of Schorr-Waite \nfor trees [24] and we check the property that the resulting output tree is well-marked. The routines \ninorder tree to list construct a list consisting of the keys of the input tree, which is traversed \ninorder. The itera\u00adtive version of this algorithm achieves this by maintaining a work\u00adlist/stack of sub-trees \nwhich remain to be processed at any given time. The routines inorder, preorder and postorder number the \nnodes of an input tree according to the inorder, preorder and postorder traversal algorithm, respectively. \nFigure 7 shows the results of applying natural proofs to the veri.cation of various other real world \nprograms and libraries. Glib is the low-level C library that forms the basis of the GTK+ toolkit and \nthe GNOME desktop environment, apart from other open source projects. Using our prototype veri.er, we \ne.ciently veri.ed Glib implementation of various routines for manipulating singly-linked and doubly-linked \nlists. We also veri.ed the queue library which forms part of the OpenBSD operating system. ExpressOS \nis an operating-system/browser implementation which provides security guarantees to the user via formal \nveri.ca\u00adtion [29]. The module cachePage maintains a cache of the recently used disc pages. The cache \nis implemented as a priority queue based on a sorted list. We prove that the methods add cachepage and \nlookup prev (both called whenever a disc page is accessed) maintain the sortedness property of the cache \npage.   Time (s) Example Routine /Routine free, prepend, concat, insert before, remove all, remove \nlink, delete link, < 1s copy, reverse, nth, nth data, find, position, glib/gslist.c index, last, length \nSingly  append 4.9 Linked-List insert at pos 11.4 LOC: 1.1K remove 3.1 insert sorted list 16.6 merge \nsorted lists 6.1 merge sort 3.0       glib/glist.c free, prepend, reverse, Doubly nth, nth data, \nposition, < 1s Linked-List find, index, last, LOC: 0.3K length    simpleq init, < 1s simpleq remove \nafter OpenBSD/queue.h  simpleq insert head 1.6 Queue simpleq insert tail 3.6 LOC: 0.1K simpleq insert \nafter 18.3 simpleq remove head 2.1    ExpressOS/cachePage.c lookup prev LOC: 0.1K add cachepage \n   ExpressOS/ memory region init < 1s memoryRegion.c  create user space region 3.6 LOC: 0.1K split \nmemory region 5.8    find vma, remove vma, linux/mmap.c < 1s remove vma list LOC: 0.1K  insert vm \nstruct 11.6    Figure 7. Results of verifying open-source libraries. (more details at http://www.cs.uiuc.edu/ \nmadhu/dryad/sl/ ) In an OS kernel, a process address space consists of a set of intervals of linear addresses \nrepresented as a memory region. In the ExpressOS implementation, a memory region is implemented as a \nsorted doubly-linked list where each node of the list with a start and an end address represents an interval \nincluded in the ad\u00address space. We also veri.ed some key components of the Linux implementation of a \nmemory region, present in the .le mmap.c. In Linux, a memory region is represented as a red-black tree \nwhere each node, again, represents an address interval. We proved meth\u00adods which .nd, remove and insert \na vma struct (vma is short for virtual memory address) into a memory region. It also worth mentioning \nthat in the process of experiments, we did make some unintentional mistakes, in writing both the ba\u00adsic \nblocks and the annotations. For example, forgetting to free the deleted node, or using . instead of * \nin the speci.cation between two disjoint heaplets, were common mistakes. In these cases, Z3 provided \ncounter-examples to the veri.cation condition that cap\u00adtured the essence of the bugs, and turned out \nto be very helpful for us to debug the speci.cation. These debugging hints are usually not available \nin other incomplete proof systems. Our experiments show that the natural proof methodology set forth \nin this paper is successful in e.ciently proving full-functional correctness of a large variety of algorithms. \nMost of the VCs gen\u00aderated for the above examples were discharged by Z3 in a few sec\u00adonds. To the best \nof our knowledge, this is the .rst automatic mech\u00adanism that can prove such a wide variety of algorithms \ncorrect, han\u00addling such complex properties of structure, data and separation. Acknowledgments This work \nis partially funded by NSF CAREER award #0747041, NSF CCF #1018182, and NSA contract H98230-10-C-0294. \n  References [1] I. Balaban, A. Pnueli, and L. D. Zuck. Shape analysis of single-parent heaps. In VMCAI \n07, volume 4349 of LNCS, pages 91 105. Springer, 2007. [2] M. Barnett, B.-Y. E. Chang, R. DeLine, B. \nJacobs, and K. R. M. Leino. Boogie: A modular reusable veri.er for object-oriented programs. In FMCO \n05, volume 4111 of LNCS, pages 364 387. Springer, 2005. [3] J. Berdine, C. Calcagno, and P. W. O Hearn. \nA decidable fragment of separation logic. In FSTTCS 04, volume 3328 of LNCS, pages 97 109. Springer, \n2004. [4] J. Berdine, C. Calcagno, and P. W. O Hearn. Symbolic execution with separation logic. In APLAS \n05, volume 3780 of LNCS, pages 52 68. Springer, 2005. [5] J. Berdine, C. Calcagno, and P. W. O Hearn. \nSmallfoot: Modular automatic assertion checking with separation logic. In FMCO 05, volume 4111 of LNCS, \npages 115 137. Springer, 2005. [6] J. Berdine, C. Calcagno, B. Cook, D. Distefano, P. W. O Hearn, T. \nWies, and H. Yang. Shape analysis for composite data structures. In CAV 07, volume 4590 of LNCS, pages \n178 192. Springer, 2007. [7] N. Bj\u00f8rner and J. Hendrix. Linear functional .xed-points. In CAV 09, volume \n5643 of LNCS, pages 124 139. Springer, 2009. [8] M. Botin.can, M. Parkinson, and W. Schulte. Separation \nlogic veri.ca\u00adtion of C programs with an SMT solver. ENTCS, 254:5 23, 2009. [9] A. Bouajjani, C. Dr.agoi, \nC. Enea, and M. Sighireanu. A logic\u00adbased framework for reasoning about composite data structures. In \nCONCUR 09, volume 5710 of LNCS, pages 178 195. Springer, 2009. [10] A. Bouajjani, C. Dr.agoi, C. Enea, \nand M. Sighireanu. On inter\u00adprocedural analysis of programs with lists and data. In PLDI 11, pages 578 \n589. ACM, 2011. [11] M. Bozga, R. Iosif, and S. Perarnau. Quantitative separation logic and programs \nwith lists. In IJCAR 08, volume 5195 of LNCS, pages 34 49. Springer, 2008. [12] A. R. Bradley, Z. Manna, \nand H. B. Sipma. What s decidable about ar\u00adrays? In VMCAI 06, volume 3855 of LNCS, pages 427 442. Springer, \n2006. [13] B.-Y. E. Chang and X. Rival. Relational inductive shape analysis. In POPL 08, pages 247 260. \nACM, 2008. [14] W.-N. Chin, C. David, H. H. Nguyen, and S. Qin. Automated veri\u00ad.cation of shape, size \nand bag properties via user-de.ned predicates in separation logic. Science of Computer Programming, 77(9):1006 \n 1036, 2012. [15] A. Chlipala. Mostly-automated veri.cation of low-level programs in computational separation \nlogic. In PLDI 11, pages 234 245. ACM, 2011. [16] E. Cohen, M. Dahlweid, M. A. Hillebrand, D. Leinenbach, \nM. Moskal, T. Santen, W. Schulte, and S. Tobies. VCC: A practical system for verifying concurrent C. \nIn TPHOLs 09, volume 5674 of LNCS, pages 23 42. Springer, 2009. [17] L. M. de Moura and N. Bj\u00f8rner. Z3: \nAn e.cient SMT solver. In TACAS 08, volume 4963 of LNCS, pages 337 340. Springer, 2008. [18] D. Distefano, \nP. W. O Hearn, and H. Yang. A local shape analysis based on separation logic. In TACAS 06, volume 3920 \nof LNCS, pages 287 302. Springer, 2006. [19] T. Hubert and C. March\u00b4e. A case study of C source code \nveri.cation: the Schorr-Waite algorithm. In SEFM 05, pages 190 199. IEEE-CS, 2005. [20] B. Jacobs, J. \nSmans, P. Philippaerts, F. Vogels, W. Penninckx, and F. Piessens. Verifast: A powerful, sound, predictable, \nfast veri.er for C and Java. In NFM 11, volume 6617 of LNCS, pages 41 55. Springer, 2011. [21] N. Klarlund \nand A. M\u00f8ller. MONA. BRICS, Department of Com\u00adputer Science, Aarhus University, January 2001. Available \nfrom http://www.brics.dk/mona/. [22] S. Lahiri and S. Qadeer. Back to the future: revisiting precise \nprogram veri.cation using SMT solvers. In POPL 08, pages 171 182. ACM, 2008. [23] K. R. M. Leino. Dafny: \nAn automatic program veri.er for functional correctness. In LPAR-16, volume 6355 of LNCS, pages 348 370. \nSpringer, 2010. [24] A. Loginov, T. W. Reps, and M. Sagiv. Automated veri.cation of the Deutsch-Schorr-Waite \ntree-traversal algorithm. In SAS 06, volume 4134 of LNCS, pages 261 279. Springer, 2006. [25] P. Madhusudan \nand X. Qiu. E.cient decision procedures for heaps using STRAND. In SAS 11, volume 6887 of LNCS, pages \n43 59. Springer, 2011. [26] P. Madhusudan, G. Parlato, and X. Qiu. Decidable logics combining heap structures \nand data. In POPL 11, pages 611 622. ACM, 2011. [27] P. Madhusudan, X. Qiu, and A. Stefanescu. Recursive \nproofs for inductive tree data-structures. In POPL 12, pages 123 136. ACM, 2012. [28] S. Magill, M.-H. \nTsai, P. Lee, and Y.-K. Tsay. THOR: A tool for reasoning about shape and arithmetic. In CAV 08, volume \n5123 of LNCS, pages 428 432. Springer, 2008. [29] H. Mai, E. Pek, H. Xue, S. T. King, and P. Madhusudan. \nVerifying security invariants in ExpressOS. In ASPLOS 13, pages 293 304. ACM, 2013. [30] G. Nelson. Verifying \nreachability invariants of linked structures. In POPL 83, pages 38 47. ACM, 1983. [31] T. Nipkow, L. \nC. Paulson, and M. Wenzel. Isabelle/HOL -A Proof Assistant for Higher-Order Logic, volume 2283 of Lecture \nNotes in Computer Science. Springer, 2002. [32] P. W. O Hearn, J. C. Reynolds, and H. Yang. Local reasoning \nabout programs that alter data structures. In CSL 01, volume 2142 of LNCS, pages 1 19. Springer, 2001. \n[33] Z. Rakamari\u00b4c, J. D. Bingham, and A. J. Hu. An inference-rule-based decision procedure for veri.cation \nof heap-manipulating programs with mutable data and cyclic data structures. In VMCAI 07, volume 4349 \nof LNCS, pages 106 121. Springer, 2007. [34] Z. Rakamari\u00b4c, R. Bruttomesso, A. J. Hu, and A. Cimatti. \nVerifying heap-manipulating programs in an SMT framework. In ATVA 07, volume 4762 of LNCS, pages 237 \n252. Springer, 2007. [35] S. Ranise and C. Zarba. A theory of singly-linked lists and its ex\u00adtensible \ndecision procedure. In SEFM 06, pages 206 215. IEEE-CS, 2006. [36] J. Reynolds. Separation logic: a logic \nfor shared mutable data struc\u00adtures. In LICS 02, pages 55 74. IEEE-CS, 2002. [37] G. Rosu, C. Ellison, \nand W. Schulte. Matching logic: An alternative to Hoare/Floyd logic. In AMAST 10, volume 6486 of LNCS, \npages 142 162. Springer, 2010. [38] J. Smans, B. Jacobs, and F. Piessens. Implicit dynamic frames. ACM \nTrans. Program. Lang. Syst., 34(1):2:1 2:58, 2012. [39] P. Suter, M. Dotta, and V. Kuncak. Decision procedures \nfor algebraic data types with abstractions. In POPL 10, pages 199 210. ACM, 2010. [40] P. Suter, A. S. \nK\u00a8oksal, and V. Kuncak. Satis.ability modulo recur\u00adsive programs. In SAS 11, volume 6887 of LNCS, pages \n298 315. Springer, 2011. [41] H. Yang, O. Lee, J. Berdine, C. Calcagno, B. Cook, D. Distefano, and P. \nW. O Hearn. Scalable shape analysis for systems code. In CAV 08, volume 5123 of LNCS, pages 385 398. \nSpringer, 2008. [42] J. Yang and C. Hawblitzel. Safe to the last instruction: automated veri.cation of \na type-safe operating system. In PLDI 10, pages 99 110. ACM, 2010. [43] K. Zee, V. Kuncak, and M. C. \nRinard. Full functional veri.cation of linked data structures. In PLDI 08, pages 349 361. ACM, 2008. \n[44] K. Zee, V. Kuncak, and M. C. Rinard. An integrated proof language for imperative programs. In PLDI \n09, pages 338 351. ACM, 2009.   \n\t\t\t", "proc_id": "2491956", "abstract": "<p>We propose natural proofs for reasoning with programs that manipulate data-structures against specifications that describe the structure of the heap, the data stored within it, and separation and framing of sub-structures. Natural proofs are a subclass of proofs that are amenable to completely automated reasoning, that provide sound but incomplete procedures, and that capture common reasoning tactics in program verification. We develop a dialect of separation logic over heaps, called Dryad, with recursive definitions that avoids explicit quantification. We develop ways to reason with heaplets using classical logic over the theory of sets, and develop natural proofs for reasoning using proof tactics involving disciplined unfoldings and formula abstractions. Natural proofs are encoded into decidable theories of first-order logic so as to be discharged using SMT solvers.</p> <p>We also implement the technique and show that a large class of more than 100 correct programs that manipulate data-structures are amenable to full functional correctness using the proposed natural proof method. These programs are drawn from a variety of sources including standard data-structures, the Schorr-Waite algorithm for garbage collection, a large number of low-level C routines from the Glib library and OpenBSD library, the Linux kernel, and routines from a secure verified OS-browser project. Our work is the first that we know of that can handle such a wide range of full functional verification properties of heaps automatically, given pre/post and loop invariant annotations. We believe that this work paves the way for deductive verification technology to be used by programmers who do not (and need not) understand the internals of the underlying logic solvers, significantly increasing their applicability in building reliable systems.</p>", "authors": [{"name": "Xiaokang Qiu", "author_profile_id": "81421595944", "affiliation": "University of Illinois at Urbana-Champaign, Urbana, IL, USA", "person_id": "P4149005", "email_address": "qiu2@illinois.edu", "orcid_id": ""}, {"name": "Pranav Garg", "author_profile_id": "81486652835", "affiliation": "University of Illinois at Urbana-Champaign, Urbana, IL, USA", "person_id": "P4149006", "email_address": "garg11@illinois.edu", "orcid_id": ""}, {"name": "Andrei &#350;tef&#259;nescu", "author_profile_id": "81485649989", "affiliation": "University of Illinois at Urbana-Champaign, Urbana, IL, USA", "person_id": "P4149007", "email_address": "stefane1@illinois.edu", "orcid_id": ""}, {"name": "Parthasarathy Madhusudan", "author_profile_id": "81100489757", "affiliation": "University of Illinois at Urbana-Champaign, Urbana, IL, USA", "person_id": "P4149008", "email_address": "madhu@illinois.edu", "orcid_id": ""}], "doi_number": "10.1145/2491956.2462169", "year": "2013", "article_id": "2462169", "conference": "PLDI", "title": "Natural proofs for structure, data, and separation", "url": "http://dl.acm.org/citation.cfm?id=2462169"}