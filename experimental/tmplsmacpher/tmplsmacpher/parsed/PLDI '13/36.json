{"article_publication_date": "06-16-2013", "fulltext": "\n Verifying Higher-order Programs with the Dijkstra Monad Nikhil Swamy1 Joel Weinberger2 Cole Schlesinger3 \nJuan Chen1 Benjamin Livshits1 Microsoft Research1 UC Berkeley2 Princeton University3 {nswamy, juanchen, \nlivshits}@microsoft.com jww@cs.berkeley.edu cschlesi@princeton.edu Abstract Modern programming languages, \nranging from Haskell and ML, to JavaScript, C# and Java, all make extensive use of higher-order state. \nThis paper advocates a new veri.cation methodology for higher-order stateful programs, based on a new \nmonad of predicate transformers called the Dijkstra monad. Using the Dijkstra monad has a number of bene.ts. \nFirst, the monad naturally yields a weakest pre-condition calculus. Second, the computed speci.cations \nare structurally simpler in several ways, e.g., single-state post-conditions are suf.cient (rather than \nthe more complex two-state post-conditions). Finally, the monad can easily be varied to handle features \nlike exceptions and heap invariants, while retaining the same type inference algorithm. We implement \nthe Dijkstra monad and its type inference algo\u00adrithm for the F* programming language. Our most extensive \ncase study evaluates the Dijkstra monad and its F* implementation by using it to verify JavaScript programs. \nSpeci.cally, we describe a tool chain that translates programs in a subset of JavaScript decorated with \nassertions and loop invariants to F*. Once in F*, our type inference algorithm computes veri.\u00adcation \nconditions and automatically discharges their proofs using an SMT solver. We use our tools to prove that \na core model of the JavaScript runtime in F* respects various invariants and that a suite of JavaScript \nsource programs are free of runtime errors. Categories and Subject Descriptors D.2.4 [Software/ Program \nVeri.cation]: Validation General Terms Veri.cation Keywords Predicate transformer, Hoare monad, re.nement \ntypes, dynamic languages 1. Introduction Once the preserve of languages like Haskell and ML, programming \nwith a mixture of higher-order functions and state is now common in the mainstream. C# and Java provide \n.rst-class closures, which interact with imperative objects in subtle ways, and in languages like JavaScript, \nhigher-order state is pervasive. When used prop\u00aderly, programming with these features can promote code \nre-use, modularity, and programmer productivity. However, the complex\u00adity of higher-order state poses \nserious dif.culties for program veri\u00ad.cation tools. Consider the JavaScript program below. Permission \nto make digital or hard copies of all or part of this work for personal or classroom use is granted without \nfee provided that copies are not made or distributed for pro.t or commercial advantage and that copies \nbear this notice and the full citation on the .rst page. To copy otherwise, to republish, to post on \nservers or to redistribute to lists, requires prior speci.c permission and/or a fee. PLDI 13, June 16 \n19, 2013, Seattle, Washington, USA. Copyright &#38;#169; 2013 ACM 978-1-4503-2014-6/13/06...$15.00. function \nincf(x) {x.f = x.f + 1; return x;}; assert (incf({f:0}).f == 1); incf=0; To understand this program, \nwe turn to Guha et al. (2010), who desugar JavaScript to . JS, an untyped lambda calculus with references \nand key/value dictionaries. We show the desugared JavaScript program below, with some super.cial modi.cations \nnotably, rather than use an untyped lambda calculus, we present the desugared program in ML, where the \ntyping is made explicit using a standard ML variant type dynamic (Henglein 1994). 1 let incf this args \n= let x = select args \"0\" in 2 update x \"f\" (plus (select x \"f\") (Int 1)); x in 3 update global \"incf\" \n(Fun incf); 4 let args = let x = update (allocObject()) \"f\" (Int 0) in 5 update (allocObject()) \"0\" x \nin 6 let res = apply (select global \"incf\") global args in 7 assert(select res \"f\" = Int 1); 8 update \nglobal \"incf\" (Int 0) The JavaScript function incf is translated to the let-bound . -term incf, with \ntwo arguments: this, corresponding to JavaScript s im\u00adplicit this parameter, and args, an object containing \nall the (vari\u00adable number of) arguments that a JavaScript function may receive. An object is a dictionary \nindexed by string keys, rather than con\u00adtaining statically known .eld names. In the body of incf, the \nx ar\u00adgument is the value stored at the key \"0\" in the args object. At line 3, the function incf is stored \nin the global object (an implicit object in JavaScript) at the key \"incf\". At line 6 we see that a function \ncall proceeds by reading a value out of the global object (using the library function select), calling \nthe apply library function, which checks that its .rst argument is a Fun f, and then applies f to its \nnext two arguments here, the global object, the receiver object for the call; and the args object containing \na single argument. Now, suppose that one wished to prove that the assertion at line 7 succeeds. One needs \nto reason that line 6 was indeed a call to incf. But, even proving this is non-trivial, since the call \noccurs via a lookup into a higher-order store, in this case, the global object. Making matters harder, \nthe store is subject to arbitrary updates, e.g., at line 8, the incf .eld is modi.ed to be Int 0 instead. \nThus, in a language like JavaScript, even to reason about simple function calls one needs to reason precisely \nabout higher-order state. 1.1 SMT-based veri.cation of higher-order stateful programs Our main technical \ncontribution is a new way of structuring spec\u00adi.cations for higher-order, stateful programs, and of inferring \nand automatically solving veri.cation conditions (VCs) for these pro\u00adgrams using an SMT solver. Speci.cally, \nwe present the Dijkstra monad, a new variant of the Hoare state monad of Nanevski et al. (2008a). The \nDijkstra monad equips a state monad with a predicate transformer (Dijkstra 1975) that can be used to \ncompute a pre-condition for a computation, for any context in which that computation may be used. We \nshow how to encode the Dijkstra monad in F*, a dependently typed dialect of ML (Swamy et al. 2011a), \nand present several examples of F* pro\u00adgrams veri.ed using this monad, ranging from higher-order com\u00adbinators \nand data structures, to implementations of cryptographic protocols with stateful invariants (\u00a72).  Veri.cation \nis facilitated by a new type inference algorithm that allows stateful programs written in direct style \nto be interpreted in the Dijkstra state monad, yielding a VC for the program. We prove our inference \nalgorithm sound, which (informally) means that if the VC computed for an F* program is provable, then \nthe program contains no failing assertions. Despite our liberal use of predicate transformers and other \nhigher-order logic constructs, we prove that the VCs computed by our algorithm can be represented in \na .rst-order theory, and hence can often be discharged effectively by SMT solvers like Z3 (de Moura and \nBj\u00f8rner 2008) (\u00a72.3). To illustrate the expressiveness of our approach, we show how to program and verify \nimplementations of abstract datatypes in\u00advolving a mixture of higher-order functions and local state. \nOur veri.cation technique employs a mixture of existentially quanti.ed abstract predicates and a lightweight \nspeci.cation style reminis\u00adcent of separation logic, all encoded using F* s higher-order logic. Nevertheless, \nwe are still able to discharge veri.cation conditions automatically using an SMT solver (\u00a73).  1.2 An \nextended case study: JavaScript veri.cation Our most extensive case study to date involves applying the \nDi\u00adjkstra monad to verify JavaScript programs, a problem of grow\u00ading practical importance. Our veri.cation \ntool chain .rst translates JavaScript programs to JS* (a subset of F*), then uses our type inference \nalgorithm to compute VCs, and, .nally, solves the VCs automatically using Z3. The diagram below depicts \nthis work.ow. Our translation, JS2JS*, adapts . JS, retargeting it to a typed language. We show how \nto make use of Gatekeeper (Guarnieri and Livshits 2009), an unsound but ef.cient pointer analysis for \nJavaScript, to convey veri.cation hints in the translation, thereby improving veri.cation times while \nstill maintaining soundness. Besides higher-order state, a program veri.er for JavaScript programs also \nhas to deal with dynamic typing. We show how to smoothly integrate the Dijkstra monad within a variant \ntype dyn, a new re.nement of type dynamic (Cartwright and Fagan 1991; Henglein 1994). Using this type, \nwe program a library of runtime support for JavaScript (called JSPrims). The full version of JSPrims \n(available online1) contains approximately 1,200 lines of carefully hand-written, mechanically veri.ed \nF* code, making heavy use of the Dijkstra monad and type dyn to prove that several key invariants related \nto the JavaScript heap are respected. Additionally, our veri.cation guarantees that well-typed clients \nof JSPrims do not raise any JavaScript runtime errors. We present a simpli.ed version of JSPrims in \u00a74. \nWe report on our experience using our tools to verify a col\u00adlection of JavaScript web-browser extensions \nfor the absence of JavaScript runtime errors. We provide a veri.cation harness that includes a partial \nspeci.cation of a sequential fragment of the Doc\u00adument Object Model (DOM) this speci.cation makes heavy \nuse 1 Supplementary material associated with this paper is available from http: //research.microsoft.com/fstar, \nand includes a compiler down\u00adload, several example programs, and a technical report including proofs \nof all the theorems in this paper. of the Dijkstra monad, illustrating its versatility. In each case, \napart from the annotation of loop invariants, veri.cation was automatic. The soundness of our veri.cation \nresults rides conveniently on the mechanized metatheory and certi.ed implementation of F* no JavaScript-speci.c \nextensions to the type system are required (\u00a75). As such, using F* as an intermediate veri.cation language, \nwe bring a methodology proven effective for .rst-order programs (us\u00ading tools like Boogie (Leino and \nR \u00a8atre ummer 2010) or Why (Filli and March \u00b4 e 2007)), to higher-order, stateful programs. 2. The Dijkstra \nMonad Monads have traditionally been used to structure effectful com\u00adputations in functional programs. \nFor example, the state monad, ST a, is the type of a computation that when evaluated in an ini\u00adtial heap, \nproduces a result of type a and a .nal heap. In a purely functional language like Coq, ST a can be represented \nby the type heap .(a * heap). In a language that provides primitive support for state, e.g., ML, the \ntype ST a can just be an abstract alias for a. As a monad, the abstract type ST comes with two operations: \nreturnST : .a. a .ST a and bindST: .a,b. ST a .(a .ST b) .ST b, and these are expected to satisfy certain \nlaws. To verify stateful programs, Nanevski et al. (2008b) propose Hoare Type Theory (HTT), where the \nmain typing construct is a state monad augmented with pre-and post-conditions. The re\u00adsulting monad, \nthe Hoare monad, written HST pre a post, can be understood as the type h:heap{pre h} .(x:a * h :heap{post \nx h })2 That is, HST pre a post is the type of a computation which when run in an input heap h satisfying \nthe predicate pre h, produces a result x:a and an output heap h satisfying post x h . The HST monad comes \nwith two operations, returnHST: .a, p. a .HST (p x) a p, which allows a pure value to be treated as a \ncomputation; and bindHST: .p a q b r. HST p a q .(x:a .HST (q x) b r) .HST p b r, which allows two computations \nto be composed, so long as the post-condition of the .rst matches the pre-condition of the second. While \nthe Hoare monad has proven effective in verifying state\u00ad ful code in a functional language, it has some \nshortcomings: -Usually, with the Hoare monad one writes speci.cations in the form of valid triples. This \nstyle does not lead directly to a VC gen\u00aderation algorithm. In order to extract a VC generation algorithm \nfrom speci.cations in this style, Nanevski et al. have adopted a va\u00adriety of strategies in several papers. \nThe original presentation of HTT (Nanevski et al. 2008b) employs a custom-built bidirectional typing \nalgorithm to exploit the speci.c structure of HST to infer VCs. Subsequent works (Nanevski et al. 2008a) \nshow how to em\u00adbed HTT in Coq, where using a slightly different style of speci.ca\u00adtion, Coq s type inference \nalgorithm can be used to compute VCs for programs in the HST monad. However, the VCs thus computed involve \na proliferation of existential quanti.ers to state properties of intermediate program states. Reasoning \nwith these quanti.ers, particularly using automated SMT solvers, can be problematic. -Additionally, writing \nprecise speci.cations with the Hoare monad requires post-conditions that circumscribe the write effects \nof a computation, e.g., to say that the input and output heaps are the same on some domain. To achieve \nthis, one usually requires two\u00adstate (a.k.a binary) post-conditions, or designs patterns like separa\u00adtion \nlogic, adding complexity to the system. Our key observation is that writing speci.cations for programs \nusing a monad of predicate transformers (Dijkstra 1975) can alle\u00adviate the above dif.culties. We call \nthe monad the Dijkstra monad, 2 Notation: we write x:t .t for a dependent function whose formal pa\u00adrameter \nx of type t is named and is in scope in the return type t ; and (x:t * t ) for a dependent pair where \nx names the t-typed .rst component and is bound in the second component t ; and x:t{f} for a re.nement \nof the type t to those elements x that satisfy the proposition f.  and write it DST a wp. This is the \ntype of a stateful computation producing a result x:a, and whose behavior is described by the weakest \npre-condition predicate transformer, wp. In a purely func\u00adtional language, one may view DST a wp as an \nabbreviation for the type .p. h:heap{wp p h} .(x:a * h :heap{p x h }). That is, in order for the output \nheap h to satisfy p x h , for any predicate p, one needs to prove wp p h of the input heap h. DST provides \ntwo operations, return and bind, with the signatures shown below: return: .a. x:a .DST a (.p. p x) bind: \n.a wp1 b wp2. DST a wp1 . (x:a .DST b (wp2 x)) . DST b (.p. wp1 (.x. wp2 x p))  To inject a value x:a \ninto the monad, one uses return, where the weakest pre-condition is simply to prove the post-condition \np for x on the input heap. To compose computations, one can use bind, where the weakest pre-condition \nof the result is simply computed by composing the weakest pre-conditions of each component. 2.1 Simple \nexamples For a .avor of the Dijkstra monad, we show a selection of small ML programs and their speci.cations. \nThese examples illustrate (1) the expressive power of the DST monad, in particular, the way we describe \nprecise effects using unary, parametric post-conditions, and, how, using parametricity over the predicate \ntransformers them\u00adselves, one can write precise speci.cations for higher-order pro\u00adgrams; (2) the way \nin which the DST monad provides a VC gener\u00adation algorithm by construction; and, (3), how the general \nconstruc\u00adtion can be varied to accommodate features like heap invariants for monotonic state, as well \nas language features like exceptions. Primitive operations on references. We start with types for the \nprimitives that manipulate references, where, as usual, the type heap is viewed in the logic as a partial \nmap from references of type ref t to values of type t. We model the map using McCarthy s select/update \ntheory of functional maps (McCarthy 1962), with the usual interpretation. To reduce clutter in the notation, \nwe assume all function types are prenex quanti.ed with their free type variables. ref : x:a .DST (ref \na) (.p..h. .l. l . dom h =. p l (update h l x)) (!) : x:ref a .DST a (.p.. h. p (select h x) h) (:=): \nx:ref a .v:a .DST unit (.p..h. p () (update h x v)) We use the function ref to allocate a reference \ncell of type ref a, initializing its contents to x:a. The weakest pre-condition of ref states that for \nany post-condition p, the proposition to prove on the input heap h is .l. l . dom h =. p l (update h \nl x), i.e., ref x returns a new heap location l not in the input heap h, and up\u00addates h at location l \nwith the argument x. We type the dereference !(x:ref a) at the type a, as usual, and give it the weakest \npre-condition .p..h. p (select h x) h, i.e., dereference returns the contents of the input heap h at \nlocation x, and leaves the heap unchanged. The type of x := v is analogous, except we return ():unit, \nand the weakest pre\u00adcondition states that the input heap h is updated just at x. Note that in each case \nwe were able to precisely state the re\u00adlation between the input and output heaps by relying on a para\u00admetric \nunary post-condition, instead of binary post-conditions. In general, given a Hoare triple with a binary \npost-condition, i.e., the type h:heap{pre h} .(x:a * h :heap{post2 x h h }), one can always represent \nit using unary post-conditions and the Dijkstra monad as DST a (.p..h. pre h . .x h . post2 x h h =. \np x h ). Swapping references. Take the following ML program: let swap x y = let tmp = !x in let = x := \n!y in y := tmp To compute a weakest pre-condition for swap, one simply computes the weakest pre-condition \nfor each of the three commands, which are then composed using two monadic binds. The resulting type is: \nswap: x:ref a .y:ref b .DST unit (.p..h. p () (update (update h x (select h y)) y (select h x))) In contrast, \nusing bidirectional VC generation for HST, one begins with a user-provided post-condition which is then \npushed back through the computation. This is usually interleaved with a forward phase that computes types \nfor let-bound variables. At each let\u00adbinding, one must close over the bound variable with an existential \nquanti.er. The additional quanti.ers make proof obligations more cumbersome to manipulate. These dif.culties \nare avoided with predicate transformers. Higher-order functions. Predicate parametricity is also essential \nfor writing speci.cations for higher-order programs. Take the fol\u00adlowing combinator: let app f x = f \nx. Its type is app: (y:a .DST b (wp y)) .x:a .DST b (wp x) By being parametric in wp, app is able to \nabstract over the spec\u00adi.cation of its function-typed argument. Similarly, the type of let twice f x \n= f (f x), abstracts over the wp of the argument. twice: (z:a .DST a (wp z)) .x:a .DST a (.p. wp x (.y. \nwp y p)) If we were to instead abstract over the pre-and post-condition of the function argument f (rather \nthan its wp) we would be forced to reason about twice f using invariants only, e.g., it would be im\u00adpossible \nto prove that twice (.x. x:=!x+1) x added 2 to x. Of course, for programs with loops, we must resort \nto invariants. For example, here is the type of the while-combinator. while: guard:(unit .DST bool wpg) \n. body:(unit .DST unit wpb) . DST unit (.p..h0. inv h0 . .h1. inv h1 =. wpg (.b h2. b=true =. wpb (. \n. inv) h2  . b=false =. inv h2) h1 . .h1. inv h1 =. p () h1) The type above is parametric in wpg, the \nspeci.cation of the guard; in wpb, the speci.cation of the loop body; and in inv, the loop in\u00advariant. \nThe three clauses of the wp of while require the invariant to hold on the initial heap (inv h0); for \nthe weakest pre-condition of the body (with respect to the invariant once again) to hold if the guard \nreturns true, and otherwise for the invariant to hold imme\u00addiately; and .nally, for the invariant to \nimply the post-condition, i.e., the DST monad makes it easy to embed the standard weakest pre-condition \nrule for a while-loop inside the types. Monotonic state with two-state invariants. Some applications \nde\u00admand variations on the basic DST monad. For instance, our supple\u00admentary material contains an example \nof an authentication proto\u00adcol based on digital signatures, veri.ed using the Dijkstra monad. A feature \nin our model of this protocol is the use of monotonic state. In particular, we make use of a stateful \nlog of protocol events, log : ref (list event). For our model to be sound, at each state update, we need \nto verify that no event has been removed from the log. Rather than insert an explicit assertion at every \ncommand (which would be impractically tedious), we would like a variant of the DST monad that yields \nVCs with the necessary checks. Our approach makes this easy to do. We provide the monad iDST, a variant \nof DST with a bind that checks the invariant, as shown in the signature below. bind: iDST a wp1 .(x:a \n.iDST b (wp2 x)) .iDST b (.p..h0. wp1 (.x h1. d h0 h1 . wp2 x post h1) h0). This type ensures that as \nthe heap evolves, every pair of adjacent heaps h0, h1 are related by the predicate d h0 h1. The particular \ninstantiation of d depends on the application. For our authoriza\u00adtion protocol, we instantiate d to .h0 \nh1. .x. In x (select h0 log) =. In x (select h1 log), (where In is for list membership), to ensure that \nthe list grows monotonically.  As we will see, our type inference algorithm is generic enough to support \narbitrary bind signatures, thereby allowing VC genera\u00adtion to be customized for the application at hand. \nIn contrast, most program veri.ers, e.g., the tools based on the Boogie framework, bake in a speci.c \nveri.cation condition generation strategy into the tool. For example, without explicitly sprinkling assertions \nbetween every pair of commands, it is impossible to make Dafny (Leino 2010) check a two-state heap evolution \ninvariant. While the signature of bind requires us to prove that successive heaps are related by d , \ndually, we would like to bene.t from the invariant as well. When d is re.exive and transitive, we show \nthat a heap and any of its descendants that may result during a program execution are related by d . \nRe.ecting this property, we can provide two axiomatic functions, witness, which takes a snapshot of the \ncurrent heap, and recall, which guarantees that the current heap is related to any prior snapshot by \nd : witness: unit .iDST heap (.p. . h. p h h) recall: h0:heap .iDST unit (.p. .h. d h0 h =. p () h) The \nvalidity of these axioms is justi.ed by our metatheory. Intu\u00aditively, since heap is abstract, the only \nheap values that are avail\u00adable to a program are those produced by witness. Thus, in recall, we know \nthat h0 is a heap snapshot, and by re.exivity and transitivity, it must be related to the current heap \nby d . Combining monads. Handling language features like exceptions within the Dijkstra monad is straightforward. \nFor example, given a monad for exceptions, we can combine it with the Dijkstra monad to yield a monad \nfor state and exceptions, with VC generation pro\u00advided by construction. We .rst de.ne a type result a \nto capture the two kinds of results a computation may produce. Normal re\u00adsults are tagged with the constructor \nV : a .result a, and excep\u00adtional results are represented using E: exn .result a, for some type of exceptions \nexn. Now, combining the result type with the DST monad, we write eDST a wp, which can be understood as \nthe type .p. h:heap{wp p h} .(x:result a * h :heap{p x h }). val return: x:a .eDST a (.p.p (V x)) val \nbind: eDST a wp1 .(x:a .eDST b (wp2 x)) .eDST b wpBindE where wpBindE = (.p. wp1 (. r h1. (. x. r=V \nx =. wp2 x p h1) . r=E =. p r h1)) val raise: e:exn .eDST a (.p.p (E e)) val tryWith: (unit .eDST a wp1) \n.(e:exn .eDST a (wp2 e)) .eDST a (.p. wp1 (.r h. (. v. r=V v =. p r h) .(. e. r=E e =. wp2 e p h))) \n 2.2 Monadic F* To develop a type inference algorithm and metatheory for the Dijk\u00adstra monad, we introduce \nmonadic F*, a programming language with a runtime semantics similar to ML (i.e., a call-by-value, higher-order \nprogramming language, with primitive support for general recursion, state, and exceptions), but with \na type system that extends ML s with dependent re.nements and the Dijkstra monad for functional correctness \nveri.cation using an SMT solver. Figure 1 shows the syntax of monadic F*. Values include vari\u00adables, \nn-ary data constructors, abstractions, and ascriptions. Ex\u00adpressions additionally include applications, \nlet bindings, and oper\u00adations on references. We exclude a .x-point form, since these can be encoded using \nrecursive data types. The full version of the paper also includes support for raising and handling exceptions. \nTypes include type variables a, formulas f, constants for the heap, unit and references, user-de.ned \ninductive types T , type application, re.nement types, and polymorphic types. We have two kinds of dependent \nfunction types: x:t .t is the type of a pure function, and is typically used to type data constructors \nonly. The type of effectful functions is more generally described using x:t .M t f, a dependent function \nwith a monadic co-domain. The v ::= x | D t\u00afv\u00af| . x:t.e | .a::..v | v:t value e ::= v | v v | v t | let \nx = e in e |!v | v := v | ref v expression | match v with D a\u00afx\u00af. e else e t ::= a | f | heap | unit \n| ref t | T | t t type | x:t{f} | .a::..t | x:t . t | x:t . M t f f ::= a | T | true | false | u = u \n| u . u | f . f formula | f . f | \u00acf | f =. f | .x:t.f | .x:t.f | .a::..f | .a::..f | .x:t.f | f u | \n.a::..f | f t u ::= v | t | select u u | update u u u | dom u | op u\u00aflogic term . ::= * | E | x:t . . \n| a::. . . kind G = \u00b7 | G, x:t | G, a::. typ. env. S = M::., ret = f, bind = f' | S, T ::.{D:t} signature \nFigure 1. Syntax of monadic F* (partial) choice of monad M is left as a parameter in the system, except \nthat it must be indexed by both a result type t and a predicate transformer f. By restricting monadic \ntypes to the co-domain of functions only, we borrow an insight from Swamy et al. (2011b), who use a similar \nrestriction to develop a type inference algorithm for monadic ML. We generalize their work to the setting \nof a dependently typed language. However, unlike that work which supports typing a program with respect \nto multiple monads, in monadic F* there is only a single monad. Note, polymorphic types have non-monadic \nco-domains corresponding to a value restriction. Formulas f describe a standard, higher-order predicate \nlogic over a term language u that includes the values v and types t, inter\u00adpreted functions from the \nselect/update theory, other theories like arithmetic, and uninterpreted functions of the user s choosing. \nThe logic includes variables a, uninterpreted predicates T , constants, equality, set membership, and \nall the usual connectives. We also in\u00adclude abstraction over terms and types (the two lambda forms) and \nthe corresponding application forms. Types are organized into kinds, ., with two base kinds: * is the \nkind of types given to computationally relevant values; and kind E is for purely speci.cational types. \nIn general, formulas f are types with kind E. We have dependent function kinds, both on values x:t . \n. and on types a::. . .. Type environments G bind variables to types and type variables to kinds. A signature \nS de.nes the set of inductive types T ::. and their data constructors, the kind of the monad M, and the \nweakest pre-condition speci.cations of its return and bind operators. We generally omit explicit type \napplications and kind annota\u00adtions on type variables. These can usually be inferred.  2.3 Typing monadic \nF* Figure 2 presents the two central judgments in the type system of monadic F*. The .rst judgment, G \nf e : t, infers a value-type t for a term e in a context G. For effectful expressions, we have G f e \n: M t f , which infers a type t and a weakest pre-condition f for an expression e from a context G. In \nboth cases, the judgments are implicitly parameterized by the signature S (when omitted). Monadic signature. \nWe de.ne K(a) as KPost(a) . heap . E for the kind of a predicate transformer from post-conditions on \na\u00adcomputations to pre-conditions. The type system is paramet\u00adric in the choice of KPost(a) one may pick \nKPost(a) to be a . heap . E for the DST monad, or result a . heap . E for the eDST monad, etc. We expect \nM to have kind a::*. K(a) . * ; S.ret : a::*. a . K(a); and S.bind : a::*. b::*. K(a) . (a . K(b)) . \nK(b). Observe how the signatures of S.ret and S.bind evoke a monad one level up , i.e., they are monadic \nin the kind K(a). We expect the fol\u00adlowing three monad laws to hold, where equality is to be interpreted \n G ok G ok S(D) = .a::..x:t' . t '' .i.G f ti :: .i[t/a] .i.G f vi : ti ' [t/a][v/x] G,a::. f v : t \nG f v : .a::..t ' G f t :: . G f x : G(x) G f D t\u00afv\u00af: t '' [t/a][v/x] G f .a::..v : .a::..t G f v t : \nt ' [t/a] G,x:t f e : M t ' f G f v : t ' G f t ' <: t G f v : t G f e1 : M t1 f1 G, x:t1 f e2 : M t2 \nf2 x . FV (t2) G f .x:t.e : x:t . M t ' f G f (v : t) : t G f v : M t (S.ret t v) G f let x = e1 in e2 \n: M t2 (S.bind t1 t2 f1 (.x:t1.f2)) G f v1 : x:t . M t ' f G f v2 : t G f v : t0 G' = a::., x:t' G,G' \nf D a\u00afx\u00af: t0 G, G' f e1 : M t f1 G f e2 : M t f2 G f v1 v2 : M t ' f[v2/x] G f match v with D a\u00afx\u00af. e1 \nelse e2 : M t (.p..h.(.a\u00afx\u00af.v = D a\u00afx\u00af=. f1 p h) . (v = D =. f2 p h)) Figure 2. Veri.cation condition \ngeneration for monadic F* as equi-satis.ability. (1) S.bind t t (S.ret v) wp = wp v (left identity) \n(2) S.bind t t wp S.ret = wp (right identity)  (3) S.bind t2 t3(S.bind t1 t2 wp1 wp2) wp3 = (associativity) \nS.bind t1 t3 wp1 (. x.S.bind t2 t3 (wp2 x) wp3) It is easy to check that the laws are satis.ed for the \nDST and eDST monads (where S.ret=.x..p.p (V x) and S.bind = wpBindE), and when the d function is re.exive, \nfor the iDST monad as well. Kinding and well-formedness of environments. We write G ok for an environment \nthat binds unique names at well-formed kinds and well-kinded types. We omit the judgments for well-formedness \nof kinds and the kinding judgment these are inherited from F* without any change and we refer the reader \nto Swamy et al. (2011a) for details. Additionally, we require each inductive de.nition in the signature \nS to be well-formed (again, this is inherited from F*). Value typing. The .rst six rules in Figure 2 \ncompute non-monadic types for values and type applications. The .rst four rules are straightforward. \nIn the .fth rule, notice how we compute speci.ca\u00adtions for functions independently of any particular \npost-condition. The sixth rule is a subsumption rule triggered by a programmer\u00adsupplied ascription. The \nsubtyping relation G f t ' <: t is inherited from F*, and is implemented by a call to an SMT solver (Swamy \net al. 2011a). The main interesting case is in proving a subtyping relation between two monadic types. \nWe have G f M t1 wp1 <: M t2 wp2 when G f t1 <: t2 and when G,p::KPost(t), h:heap |= wp2 p h =. wp1 p \nh. Expression typing. The .rst expression typing rule corresponds to a monadic unit it allows a value \nv to be injected into the monad using S.ret. We interpret let-bindings as a monadic bind we compute the \ntype of each component, insist that the let-bound variable does not escape in the result type (although \nit may appear in f2), and compose the results using S.bind. The rule for function application is standard \nfor a dependently typed language. To type a match, we type each branch and compute a predicate transformer \nby guarding the pre-conditions of each branch by the branch condition and closing over the pattern-bound \nvariables. We do not show speci.c typing rules for operations on references; these are typed according \nto the signatures of ref, (!) and (:=) shown previously. Soundness. We prove the soundness of the type \nsystem against the operational semantics for F* a standard small-step, call-by-value ' reduction relation \n(H,e) .S (H , e ' ), which relates a pair of run\u00adtime con.gurations consisting of a store H (mapping \nlocations to values) and an expression e. We prove the soundness for speci.c in\u00adstantiations of KPost(a) \nhere, for KPost(a) = result a . heap . E , i.e., for a language whose primitive effects include state \nand ex\u00adceptions. Layering other monadic effects (e.g., probabilities, or re\u00adactivity, etc.) over the \nthe primitive ones is also possible, and the same metatheory should carry over. In the theorem below, \nwe write S;G f (H,e) : M t f to type a runtime con.guration this extends expression typing with a typing \nfor the store H in a standard way. We also write asResult v for V v and asResult (raise e) for E e. TH \nE O R E M 1 (Soundness). Given S ok, and G, H , e, t , and wp such that S; G f (H,e) : M t wp; and an \ninterpretation function asH ea p from runtime stores H to the type heap; and a post-condition p such \nthat S;G |= wp p (asH ea p H ) is derivable; either: (1) e is a result r and S;G |= p (asResult r) (asH \nea p H ); or, (2) there exist H ' , ' ' e ,wp ', such that (H,e) .S (H' ,e ' ), S; G f (H' ,e ' ) : M \nt wp and ' S;G |= wp p (asH ea p H ' ). First-order VCs. We also prove that the VC generation does not \nintroduce higher-kinded quanti.cation where none exists. To state this theorem, we introduce a judgment \nf (S;G) ord1, which is true of .rst-order contexts, i.e., those that do not use higher-order formulas \nin the re.nement logic like .a::..f where . = *. The theorem states that when computing a wp for a term \nin such a .rst-order context, and when that wp is applied to a .rst-order post-condition and a heap, \nthe resulting VC can be reduced to a .rst-order normal form, e.g., no .s remain this is the essence of \nthe judgment S;G f f ord1, below. This result is important since we aim to translate VCs to SMT solvers \nwhich do not support quanti.cation over predicates. TH E O R E M 2 (First-order VCs). If S;G f e : M \nt wp; and f (S;G) ord1; and S;G f p ord1; then S; G,h : heap f (wp p h) ord1. 3. Abstract predicates \nand local state While Theorem 2 (First-order VCs) ensures that programs with\u00adout higher-order assertions \nyield VCs that are .rst-order, this does not rule out the use of higher-order speci.cations. Indeed, \ncareful use of higher-order logic in monadic F* makes it possible to rea\u00adson modularly about features \nlike local state, while still allowing automated veri.cation via an SMT solver. We brie.y present an \nexample for illustration. Consider the two functions below, evens and evens . let evens () = let x, y \n= ref 0, ref 0 in .(). let r = !x + !y in incr x; incr y; r let evens () = let x = ref 0 in . (). let \nr = 2*!x in incr x; r Both these functions return closures which yield the same se\u00adquence of even numbers \nwhen they are called. To see why, we can reason informally that the closure returned by evens captures \ntwo references x and y that remain local to the closure, both references always contain the same value \nat the entry and exit of the closure, so !x + !y is always even. A similar line of reasoning applies \nto evens , although it uses only one reference. We would like to be able to give speci.cations to both \nevens and evens that state that the references they allocate are owned by their respective closures; \nthat their invariants are maintained irrespective of the actions of their clients; and, .nally, for the \nclients view of the speci.cations of evens and evens to be identical, hiding the differences in the representation \nof their internal data structures, e.g., the number of references they use. This is a classic problem \nof information hiding and modular veri.cation considered in many lines of work (Barnett et al. 2004; \nNanevski et al. 2007; O Hearn et al. 2004; Parkinson and Bierman 2005). Monadic F* can capture the speci.cation \nstyle of several of these approaches naturally, e.g., the higher-order style of exis\u00adtentially quanti.ed \npredicates of Nanevski et al. (2007), while still retaining the ability to automatically discharge proof \nobligations. Our solution, sketched in the remainder of this section, also illus\u00adtrates common idioms \nwe employ to control and simplify the use of the DST monad.  Note, from here on, we use the concrete \nsyntax of F* in our examples. This is based closely on the syntax of the previous section and notations \nfrom F# and OCaml. We also use several conveniences such as curried function types and dependent pairs \nthat are supported by our implementation. 3.1 Notation to structure the use of the DST monad For many \nkinds of programs, exposing the full generality of the Di\u00adjkstra monad in speci.cations can be overwhelming. \nFor example, it would be preferable to not have to think about state, exceptions, and other unrelated \nconcerns when using the DST monad to write speci.cations for a pure function. To facilitate this, we \nde.ne ab\u00adbreviations for several common special cases of the DST monad, each a monad in its own right. \ntype Pure t requires ensures = DST t (.post h. requires . .x. ensures x =. post x h) type Reader t requires \nensures = DST t (.post h. requires h . .x. ensures x h =. post x h) type Writer t requires ensures m \n= DST t (.post h. requires h . (. x h . ensures h x h . Mods m h h =. post x h )) and Mods m h h = .x. \nx . dom h . x. m =. x . dom h . select h x = select h x For example, we use Writer t requires ensures \nm to type t\u00adcomputations that read the heap, whose writes are con.ned to the set of references m, and \nwhich may also allocate new references. Notice the de.nition of Mods m h h it states that h and h agree \non all references that exist in h, except for the ones in the set m. To make it easy to remember the \ninterpretation of the last three indexes of Writer, we tag them with the following identi.ers, each an \nidentity function. type Requires r = r type Ensures r = r let Modi.es m = m Using these tags, a function \nthat increments an integer refer\u00adence can be given the type below, hiding the complexity of predi\u00adcate \ntransformers under a notation evocative of that used by other Hoare-style veri.ers. x:ref int .Writer \nunit (Requires .h.True) (Ensures . h () h . select h x = select h x + 1) (Modi.es {x}) 3.2 Heap permissions \nand fragments Monadic F* provides the .exibility to work with many different styles of speci.cations. \nFor example, we can introduce a permis\u00adsion model (shown below) to control the use of references. We \nuse an abstract predicate Perm r h to indicate that the program has per\u00admission to use the reference \nr in heap h. The pre-condition to read, write or free a reference r requires the caller to hold the permission \nto r. The speci.cation of write r v ensures that the caller retains per\u00admission on r after the heap is \nupdated. The alloc function returns a new reference r and ensures the caller has permission to use it, \nwhile free consumes the permission of the deallocated reference. We also use features inherited from \nF* to axiomatize and in\u00adternalize spatial connectives (like the separating conjunction from separation \nlogic) into monadic F*. The listing below introduces a logical value Frag whose semantics is axiomatized \n(using the three assume expressions) so that Frag h fp is a heap whose domain is precisely the set of \nreferences fp and whose values on that domain agree with h. We call Frag h fp the fp-fragment of h. (* \nPermissions on heap references*) type Perm :: ref a . heap . E val read: r:ref a .Reader a (Requires \n(Perm r)) (Ensures .h v. v=select h r) val write: r:ref a .v:a .Writer unit (Requires (Perm r)) (Ensures \n.h () h . Perm r h . select h r=v) (Modi.es {r}) type Fresh s h = .r. r . s =. r . dom h val alloc: v:a \n.Writer (ref a) (Requires .h.True) (Ensures .h r h . Fresh{r}h . r.dom h . select h r = v . Perm r h \n) (Modi.es {}) val free: r:ref a .Writer unit (Requires (Perm r)) (Ensures .h r h . r.dom h ) (Modi.es \n{r}) (* Fragments of heaps *) logic val Frag : heap .refset .heap assume .fp h x. x . fp =. select (Frag \nh r) x = select h x assume .fp h x. if x . fp then x . dom (Frag h fp) .. x . dom h else x . dom (Frag \nh fp) assume .h1 h2 fp. (. x. x . fp =. select h1 x = select h2 x) =. Frag h1 fp = Frag h2 fp type Star \nP Q h = .f1 f2. f1 n f2 = 0/. P (Frag h f1) . Q (Frag h fp2) type On fp P h = P (Frag h fp) Using Frag, \nwe de.ne the heap-predicate Star P Q to be valid on a heap h if h contains disjoint fragments fp1 and \nfp2 such that P and Q are valid on each of those fragments. We also de.ne On fp P, a heap predicate valid \nif P holds on the fp-fragment of a heap.  3.3 Specifying and verifying evens and evens With the heap \npermission model in place, we show how to program and verify our examples, evens and evens . The main \nidea structur\u00ading our solution is to package a closure with an existentially quan\u00adti.ed invariant on \nits local state, where the invariant encapsulates the permissions required to use the references private \nto the closure (thereby ensuring that a client cannot access these references). The type t below de.nes \nthis existential package: type t = MkT: Inv::heap . E .fp:refset .(unit .evens t Inv fp) .t and evens \nt Inv fp = Writer int (Requires (On fp Inv)) (Ensures .h x h . x mod 2 = 0 . On fp Inv h ) (Modi.es fp) \nA t-value MkT Inv fp f is a triple consisting of a heap-predicate Inv, a set fp of references (representing \nthe footprint of the invari\u00adant), and a closure f:unit .evens t Inv fp, a function in the Writer monad \nwhose pre-condition requires that Inv be valid on the fp\u00adfragment of the input heap, and which ensures \nthat it returns an even integer; that Inv remains valid on the same fragment of the output heap; and \nthat only references in fp may be modi.ed. Ob\u00adserve that this type reveals no information about the structure \nof the local state of f, although it guarantees that f always returns an even integer. (Note, if we wanted \nto prove that each call to f returned the next even integer, we would have to augment MkT with additional \n(ghost) state. This is relatively straightforward to do, although we omit it here for simplicity.) Next, \nwe show the type of evens and evens (the same for both). val evens,evens : unit .Writer t (Requires . \nh. True) (Ensures . h v h . Fresh (fp v) h . On (fp v) (Inv v) h ) (Modi.es {}) This is the type of a \nfunction in the Writer monad with a trivial pre-condition returning a t-value. To state the post-condition, \nwe project the footprint and the invariant component of the v:t result using the logical projectors fp:t \n.refset and Inv::t . heap . E that are provided in F* s logic for the data type t. We assert, .rst, that \nthe references in the footprint (fp v) are freshly allocated, and second, that the existentially bound \ninvariant (Inv v) is valid on the fragment of the output heap h corresponding to the footprint. Additionally, \nboth functions do not modify any existing reference.  The listing below shows the implementation of \nevens and evens , each returning the closures we showed earlier packaged as a t-value with a suitable \ninvariant. The invariant for evens is Inv1 x y, which states that the closure holds the permission to \nx and y, and that the values of these references are always the same in the heap. The invariant for evens \nis just Perm x, just stating that its closure holds permission to x. type Inv1 x y h = Perm x h . Perm \ny h . select h x=select h y let evens () = let x,y = alloc 0, alloc 0 in let f () : evens t (Inv1 x y) \n{x,y} = let r = read x + read y in incr x; incr y; r in MkT (Inv1 x y) {x,y} f let evens () = let x = \nalloc 0 in let f () : evens t (Perm x) {x} = let r = read x in incr x; 2*r in MkT (Perm x) {x} f These \nexamples, while particularly simple, illustrate a general pattern in monadic F* for writing speci.cations \nover local state. We make use of this pattern in programming other, more complex examples, e.g., a veri.ed \nring buffer programmed using arrays, local state, and a record of closures to mimic an object-oriented \nprogramming style. We discuss this brie.y in \u00a75. 4. Dynamic typing in monadic F* We turn now to our main \ncase study, JavaScript veri.cation. While JavaScript is increasingly used for both web and server-side \npro\u00adgramming, it is a challenging language for veri.cation and analysis, in part due to its highly dynamic \nnature. We implement a transla\u00adtion, JS2JS*, from JavaScript to F*, based closely on . JS (Guha et al. \n2010). The image of this translation is JS*, an idiomatic sub\u00adset of monadic F* . A .rst dif.culty in \ntranslating JavaScript to F* is to represent JavaScript s dynamic typing. In principle, to handle dynamic \ntyp\u00ading in an ML-like language, one simply provides a variant type dyn, with cases for each primitive \ntype constructor in the language, e.g., Int : int .dyn, Fun: (dyn .dyn) .dyn, while systematically insert\u00ading \ninjections and projections to and from type dyn. So, intuitively, we compose the . JS translation with \na translation that adds type dyn systematically to produce a JS* program. JS* programs are linked against \na library called JSPrims, which includes type dyn, as well as functions providing runtime support for \ncoercions, object manipulation, prototype traversal, etc. The formalization of JS2JS* and the full JSPrims \nlibrary are available online. 4.1 A re.ned type dynamic The basic approach of inserting the standard \ntype dyn systemati\u00adcally throughout the program is conceptually simple, but also not very useful nearly \nevery term is typed at dyn. Our .rst step to\u00adwards verifying JavaScript programs, then, is a new re.ned \ntype dyn that recovers the precision of static typing. The listing below shows the (partial) de.nition \nof our type dyn, suitable for use with JavaScript programs translated to JS*. For ex\u00adample, we have the \nconstructor Num, which allows a number n:.oat to be injected into the dyn type. However, the type of \nNum n is d:dyn{TypeOf d = .oat}, where TypeOf: a::* . a . E is an uninter\u00adpreted function from values \nto types in the re.nement logic. In ef\u00adfect, the re.nement formula recovers the static type information. \nThe case of strings and objects is similar note, an object is repre\u00adsented as a mutable map from strings \nto dyn values. type dyn = | Num : .oat .d:dyn{TypeOf d = .oat} | Str : string .d:dyn{TypeOf d = string} \n| Obj : ref (map string dyn) .d:dyn{TypeOf d = object} | Fun : .wp::dyn . dyn . (dyn . heap . E ) . heap \n. E . (this:dyn .args:dyn .DST dyn (wp args this)) .d:dyn{TypeOf d = AsE wp} | Undef : d:dyn{TypeOf d \n= undef} . . . The type of Fun merits closer attention. JavaScript functions al\u00adways take two arguments \nthe .rst is for the implicit this param\u00adeter; the second is an object containing a variable number of \n.elds, one for each of the variable number of actual parameters. So, to a .rst approximation, the type \nof Fun is (dyn .dyn .dyn) .dyn, but this is, of course, too imprecise. To recover precision, we type \neach function in the DST monad and re.ne the type of Fun to record the predicate transformer of the function \nin the re.nement logic. From the type d:dyn{TypeOf d = AsE wp}, we can conclude that the underlying value \nis a function of type this:dyn .args:dyn .DST dyn (wp args this). (Note, AsE is just a type constructor \nthat coerces the kind of wp to E-kind.) Our full library includes other JavaScript primitive types; a \nmore complicated type for Fun, which allows functions to also be treated as objects (as required by JavaScript); \nand types/functions to model exceptions and JavaScript s control operators. We leave them out of this \npaper due to space constraints.  4.2 An API for JS* Next we discuss some key fragments of JSPrims, simpli.ed \nsub\u00adstantially for the purposes of the paper. JSPrims de.nes the set of JavaScript runtime errors we \ncapture. Safe .eld selection. To select a .eld f:string from an object o:dyn, JS* programs call selField \no f (corresponding to the JavaScript source operation o.f or o[\"f\"]). The implementation of selField \n(line 8 below) elides several details of prototype chain traversal, functions as objects, etc. In its \nmost basic form, selecting a .eld requires o to be an object. We dereference the map location, lookup \nthe key f and return the value, if it exists. 1 de.ne SelField h (Obj l) f = Map.select (select h l) \nf 2 de.ne HasField h (Obj l) f = In f (Map.domain (select h l)) 3 val unreachable: unit .DST a (.p..h. \nfalse) 4 val lookup: m:map a b .x:a .option (y:b{y=Map.select m x}) 5 val selField: o:dyn .f:string .Reader \ndyn 6 (Requires .h.TypeOf o=object.HasField h o f) 7 (Ensures . h v. v=SelField h o f) 8 let selField \no f = match o with 9 | Undef | Str | Int | Fun .unreachable () 10 | Obj l .match lookup !l f with Some \nv .v 11 | None .unreachable() We aim to give a speci.cation to selField that ensures that well\u00adtyped \nJS* clients avoid various JavaScript errors. Projecting a .eld from a non-object is prevented by the \nclause in the precondition (line 6) which requires TypeOf o = object. We also ensure that the .eld f \nbe among the de.ned .elds of the objects (HasField h o f). If the .eld does not exist, JavaScript semantics \npermits return\u00ading the undefined value, which is, strictly speaking, not an er\u00adror condition. However, \nchecking for the absence of unexpected undefined values in a JavaScript program is generally considered \na good idea (Crockford 2008), so we check for it here. At line 7, the speci.cation ensures that selField \nreturns the contents of the f .eld of o, and that the heap is unchanged. Note, the de.nitions at lines \n1-2 provide two functions in the logic, corresponding to projecting a .eld from an object and to testing \nwhether a key exists among the .elds of an object. We interpret the map type as a functional array, and \nuse functions Map.select/Map.update/Map.domain, with the usual interpretation.  Safe .eld update. To \nupdate a .eld f:string from an object o:dyn with a value v:dyn, JS* programs call updField o f v (corresponding \nto the JavaScript source operation o.f = v or o[\"f\"] = v). The speci.cation of updField has a similar \nform to that of selField. The caller is required, .rst, to prove that o is an object (trying to update \na non-object is a JavaScript error). Note, the .eld f need not exist in o JavaScript permits adding .elds \nto an ob\u00adject on the .y . The speci.cation also states that updField returns Undef and updates just the \nheap accordingly. The modi.es clause uses a projector provided in F* s logic Obj proj 0 to state that \nonly the reference held in o is modi.ed. 1 de.ne UpdField h (Obj l) f v = 2 update h l (Map.update (select \nh l) f v) 3 val insert: m:map a b .x:a .y:b 4 .m :map a b{m =Map.update m x y} 5 val updField: o:dyn \n.f:string .v:dyn .Writer dyn 6 (Requires .h. TypeOf o=object) 7 (Ensures .h u h .u=Undef . h =UpdField \nh o f v) 8 (Modi.es {Obj proj 0 o}) 9 let updField o f v Post h = match o with 10 . . . | Undef | Str \n| Int | Fun .unreachable () 11 | Obj l .l := insert !l f v; Undef Safe function application. Informally, \nfor f:dyn, this:dyn, args:dyn, the term apply f this args corresponds (roughly) to the JavaScript construct \nthis.f(a1,...,an), where args is an object containing the n actual parameters. As in the other cases, \nour goal is to ensure that function applications in JS* (and hence in JavaScript) do not cause errors. \nThere are two things that could potentially go wrong. First, f may not be a function it is an error in \nJavaScript to apply, say, an integer. Second, f s pre-condition may not be satis.ed. Addressing both \nthese concerns, we show the type and imple\u00admentation of apply below. 1 val apply: f:dyn .this:dyn .args:dyn \n.DST dyn (.p..h. 2 . wp. TypeOf f = AsE wp . wp args this p h) 3 let apply f this args = match f with \nFun fn .fn this args 4 . . . | Undef | Str | Int | Obj .unreachable () The implementation of apply is \nstraightforward it checks that f is a function and applies it. The speci.cation of apply requires the \nclient to prove that f is indeed a function with some wp, and then to prove the pre-condition computed \nby that wp for the particular arguments and post-condition needed at the call site.  4.3 Computing VCs \nfor JS* We prove that VC generation always succeeds for any loop-free JS* program. Programs with loops \nmust be annotated with invariants. We write [[e]] for the translation of a . JS program to JS* . TH EO \nR E M 3 (VC generation is complete on JS*). Given a loop\u00adfree . JS term e. Then, for the signature SJSPrims, \nthere exists wp such that \u00b7 f [[e]] : M dyn wp. By default, the VC for a JS* program is not .rst-order. \nNotably, each call to apply introduces an existentially bound predicate trans\u00adformer. Our full paper \nshows how such existentially bound trans\u00adformer variables can be eliminated using the model-.nding features \nof an SMT solver. However, this procedure can be quite expensive (cf. the veri.cation time of Facepalm \nin the next section). We describe here a more ef.cient approach that we also imple\u00adment. Speci.cally, \ninstead of apply we use apply hint shown below, where, instead of existentially quantifying over the \nwp, we require the caller to instantiate the wp explicitly. val apply hint: wp::dyn. dyn. (dyn. heap. \nE ). heap. E . f:dyn .this:dyn .args:dyn . DST dyn (fun post h . TypeOf f=AsE wp . wp args this post \nh)  Unlike apply, the type of apply hint satis.es our ord1-restriction, and the VCs produced when calling \napply hint can be handled within a .rst-order solver like Z3. Of course, one still needs a way to compute \nthe type argument of apply hint. We use Gatekeeper, a pointer analysis for JavaScript, to produce a set \nof possible function call targets. We carry this in\u00adformation in the JS2JS* translation and use it to \ncompute the type arguments of apply hint. The example below illustrates this proce\u00addure, where the JavaScript \nprogram on the left is translated to the JS* program on the right. function foo(x) {...} let foo this \nargs = ... in foo({f:0}); update global \"foo\" (Fun U0 foo); foo = 17; apply hint U0 (select global \"foo\") \nglobal (...); update global \"foo\" (Int 17) Each lambda-term in the translated program produces an applica\u00adtion \nof the Fun constructor. For each such function, JS2JS* inserts a new uni.cation variable, U0 in our example, \nas the .rst argu\u00adment to Fun. When the type inference algorithm computes a pred\u00adicate transformer for \nfoo, say FooTX, U0 is uni.ed with FooTX. Next, at each call site where Gatekeeper is able to de.nitively \nre\u00adsolve a function call to a particular closure (say, foo), JS* inserts a call to apply hint, passing \nas a .rst parameter the same uni.cation variable ( U0) that was used when translating foo. As type infer\u00adence \nproceeds and U0 is uni.ed with FooTX, the witness argument to apply hint is suitably uni.ed too. We also \nsupport variants of apply hint in case Gatekeeper cannot resolve a call target to a sin\u00adgleton. Note, \nwe do not rely on the soundness of Gatekeeper (in fact, it is occasionally unsound) an incorrect instantiation \nwill be trapped by the theorem prover. 5. Experimental evaluation To date, we have veri.ed nearly 3,000 \nlines of F* code using the Dijkstra monad, summarized in Figure 3. The veri.cation time (column TC) was \ncollected on a 3.2GHz Windows 7 machine. The .rst class of examples is a set of 26 programs, listed in \na single line in the table as ex0 ex25, and totaling 400 lines of code. These examples include the code \ndiscussed in \u00a72.1, and others of a similar .avor. We have also ported three programs implemented by Chen \net al. (2010) in Fine to monadic F*. The .rst, ac, is a simple access control scheme. Next, automaton \nis a program that implements a type-state protocol on .les coded in monadic F*, we no longer need to \nthread af.ne tokens and a store. Finally, i.ow is a monadic encoding of information .ow control. Ported \nto monadic F*, it highlights monadic layering we can easily combine the Dijkstra state monad with a programmer\u00adde.ned \ninformation .ow monad. The programs auth and auth2 implement variations of a protocol that used digital \nsignatures for authentication. They use the iDST monad to maintain an invariant on mutable memory that \nis used to track a collection of protocol events. The examples evens is the local state example of \u00a73. \nThe programs ringbuf1 and ringbuf2 program and verify a ring buffer based on a problem speci.cation provided \nby the 2012 VSTTE veri.cation competition. JSPrims is our most complex example: it provides a precise \ntype interface suitable for verifying functional correctness of JS* programs, while implementing runtime \nsupport including coercions, prototype traversal, and the JavaScript calling convention. It uses the \neDST and iDST monads to include reasoning about exceptions and a two-state invariant that controls how \nthe JavaScript heap evolves. The remaining programs are JavaScript web-browser extensions translated \nto JS* for veri.cation. These extensions are based on those studied by Guha et al. (2011). We prove each \nextension free of runtime errors, assuming a sequential model for the DOM. Our  Name LOC(JS) TC (sec) \nDescription ex0 ex25 406 9.1 Classic combinators and data struct. ac 38 6.5 Access control (PLDI 10) \nautomaton 53 7.5 Typestate on .les (PLDI 10) i.ow 115 10.1 Information .ow monad (PLDI 10) auth 52 6.2 \nDigital sig. with monotonic state auth2 53 6.8 Variation of authentication above evens 59 2.9 Local state \nfor even streams ringbuf-1 192 22.0 Ring buffer with global invariants ringbuf-2 154 21.8 Ring buffer \nwith local state JSPrims 1,131 63.5 Runtime support for JavaScript Untiny 59 (9) 11.0 Send selected URL \nDelicious 65 (13) 11.3 Bookmark selected text Passward 111 (29) 42.7 Store and retrieve passwords HoverMagn \n60 (23) 38.1 Magnify text under the cursor Typograf 106 (28) 65.5 Format text a user inputs Facepalm \n270 (82) 718.0 Find contacts from Facebook Total 2,924 (184) 17m 23s Figure 3. Summary of experiments \nveri.cation methodology is designed for proving the functional correctness of programs, although, in \nthe absence of speci.cations for JavaScript programs in the wild, our tool checks for safety. To simplify \nveri.cation, in some cases, we model collections of objects by iterators, whereas the standard DOM API \nprovides collections of objects as arrays encoded using dictionaries. We expect to support the array \nidioms in the near future, although precisely modeling asynchrony in the DOM is substantial future work. \nThe remainder of this section discusses three extensions in detail. 5.1 HoverMagni.er Our .rst extension \nis HoverMagni.er, an accessibility extension. It magni.es the text under the cursor. A key part of its \ncode is shown below it involves the manipulation of a collection of DOM elements. 1 function magnify(evt) \n{ ... } 2 var elts = document.getElementsByTagName(\"body\"); 3 var body = elts.Next(); 4 if (body !== \nundefined) { 5 body.onmousemove = function (evt){magnify(evt);}; 6 body.onmousemove(dummyEv);} //for \nverif. harness At line 2 it calls the DOM function getElementsByTagName to get all the <body> elements \nin a web page. Line 3 gets the .rst element in the result set. Then, it checks if the body is undefined \nand line 5 sets an event handler, magnify, to be called whenever the user s mouse moves we elide the \nde.nition of magnify. Setting up a veri.cation harness for such a program involves two main elements. \nFirst, we need some driver code to ensure that all the relevant parts of the program are exercised. For \nexample, we add the code at line 6 to mock the .ring of a mouse-move event, so that the code in magnify \nbecomes reachable. Without this, our veri.cation tool would still infer a weakest pre-condition for magnify, \nbut since no call to it appears in the program, the pre-condition would be trivially satis.ed. (In \u00a75.3, \nwe show how one can avoid writing such driver code by instead writing better speci.cations for library \nfunctions.) We also have to provide speci.cations for all the APIs used by the program. For our extensions, \nthis API is the DOM. For each kind of DOM concept (document, element, style, etc.), we de.ne a corresponding \nF* type a predicate stating that an object is an instance of the concept. For element, a predicate EltTyping \nh elt means that elt is an element in heap h. 1 type EltTyping h elt = 2 TypeOf elt = object . ... . \nHasField h elt \"text\" 3 . TypeOf (SelField h elt \"text\")=string 4 . HasField h elt \"getFirstChild\" 5 \n. TypeOf (SelField h elt \"getFirstChild\") = 6 AsE (.args this post h . IsElt h this . 7 .child. (child=Undef \n. IsElt h child) =. post child h ) 8 and IsElt :: heap . dyn . E 9 assume IsElt trans:. h1 h2 x.  10 \n(IsElt h1 x . 11 (SelField h1 x \"text\")=(SelField h2 x \"text\") . . . . 12 (SelField h1 x \"getFirstChild\")= \n13 (SelField h2 x \"getFirstChild\")) 14 =. IsElt h2 x 15 assume IsElt typ:. h x. IsElt h x =. EltTyping \nh x The predicate EltTyping (line 1) states that elt is an object, it has (among others) a .eld \"getFirstChild\", \nand that this .eld is a function whose speci.cation is given by the predicate transformer at lines 6 \n7. Informally, \"getFirstChild\" expects its .rst argu\u00adment (the implicit this pointer) to be a DOM element \ne, and, if e is not a leaf node, it returns another DOM element (otherwise re\u00adturning Undef). Capturing \nthis speci.cation involves the use of an abstract inductive predicate IsElt, and then providing two assump\u00adtions \n(at the bottom of the display) giving it an interpretation. The assumption IsElt trans states that IsElt \nis transitive in its heap argu\u00adment (if the relevant .elds of the element elt have not changed), and \nIsElt typ expands IsElt back into EltTyping. The next listing shows the predicate DocTyping, a partial \nspeci\u00ad.cation for the document object (line 1). It states that the object doc contains a .eld \"getElementsByTagName\" \nthat stores a function\u00adtyped value. The pre-condition for this function requires that it be called with \nits this argument set to the doc object itself. Statically predicting the this pointer of a function \nis non-trivial. For example, in the following program, the .nal function call receives the object o as \nthe this parameter: o.f = document.getElementsByTagName ; o.f(). This can be problematic, and, in the \ncase of the DOM, leads to a runtime error. We rule out this kind of error by requiring that every call \nto getElementsByTagName must pass a this parame\u00adter equal to the document object doc. 1 type DocTyping \nh doc = HasField h doc \"getElementsByTagName\" 2 . . . . . TypeOf (SelField h doc \"getElementsByTagName\") \n= 3 AsE (.args this post h1. 4 (this = doc . SingletonString h1 args . 5 (. x. Enum IsElt h1 x =. post \nx h1))) 6 and Enum p h d = TypeOf d=object . d . dom h . 7 HasField h d \"Next\" . TypeOf (SelField h d \n\"Next\") = 8 AsE (.args this post h . this = d . 9 .x. (x=Undef . p h x) =. post x h ) The pre-condition \nof getElementsByTagName also requires that its arguments object args contain a single string .eld (the \npredi\u00adcate SingletonString, elided here for brevity). The post-condition of getElementsByTagName is captured \nby line 5. It states that the function does not change the heap, and that the object x returned satis.es \nthe predicate Enum IsElt h1 x. The predicate Enum is shown at line 6. It is parameterized by a predicate \np that applies to each of the elements in the collec\u00adtion. Enumerable collections are objects that have \na function-typed \"Next\" .eld which does not mutate the heap. The function either returns Undef (if the \ncollection is exhausted), or returns a value sat\u00adisfying the predicate p h x. As with other functions, \n\"Next\" expects its this pointer to be the enclosing collection. Finally, to connect these speci.cations \nof the DOM to the pro\u00adgram itself, we type the program in an initial heap h0 satisfying the InitialHeap \nh0 predicate overleaf, which states that a document object is reachable from the global object.  val \nglobal : dyn type InitialHeap h0 = TypeOf global = object . ... . HasField h0 global \"document\" . TypeOf \n(SelField h0 global \"document\")=object . DocTyping h0 (SelField h0 global \"document\")  5.2 Facepalm \nOur next example is Facepalm, an extension that helps build a user s address book by automatically recording \nthe contact infor\u00admation of a user s friends as they browse Facebook. The veri.ca\u00adtion time of Facepalm \nwas dominated by the time spent in Z3. Our query compiler asked about 1,300 Z3 queries, and required \npro\u00adducing models to resolve 27 function calls. Gatekeeper was able to successfully provide us with a \nhint 11 times, but the remaining 16 times we fell back on Z3 s model .nding feature, which dominated \nthe Z3 time so, a reduction in the number of queries that require producing models (via better hints) \nis likely to reduce the veri.ca\u00adtion time substantially. We expect better stubs for the DOM when con.guring \nGatekeeper to help. 1 function getPath(root, p) { 2 var cur=root; var path=p; 3 while(path !== undefined \n. //needs loop invariant 4 cur !== undefined) { 5 cur = cur.getChild(path.hd); //needs a hint 6 path \n= path.tl; } 7 return cur; } 8 function start() { 9 var friendName, href; 10 if (document.domain === \nfacebook.com ) { 11 friendName = findName(); 12 href = findWebsite(); 13 if (href) { 14 console.log(\"Website \non \" + href); 15 console.log(\"Name is \" + friendName); 16 saveWebsite(friendName, href); }}} The main \nfunction of Facepalm is shown above (start at line 8). At a high level, this extension checks to see \nif the page currently being viewed is a Facebook page (line 10). If the check succeeds, it traverses \nthe DOM structure of the page looking for a speci.c fragment that mentions the name of the user s friend \n(line 11). A second traversal .nds the friend s contact and website infor\u00admation (line 12). If this information \nis successfully found, the ex\u00adtension logs it and saves it to the user s address book maintained on a \nthird-party bookmarking service (line 16). The main interest in verifying Facepalm is in verifying the \ntwo DOM traversals, findName and findWebsite. Both of these involve while-loops to iterate over the structure \nof the DOM. They do this by eventually calling the function getPath, shown at line 1. The loop in getPath \niterates simultaneously over a list (path) of integers as well as the DOM tree rooted at cur, where the \ninteger in the list indicates which sub-tree of cur to visit. Function getChild(n) returns the nth child \nof an element. To verify this code, the programmer needs to supply a loop invariant. The next listing \nshows the translation (slightly cleaned up) of getPath to JS* for veri.cation, starting with the signature \nof a function get which returns the current heap (useful for stating invariants). At lines 3 5, we initialize \nthe two local variables corresponding to cur and path in the source program. The while-loop is trans\u00adlated \nto a call to the while-combinator from \u00a72.1. The .rst three arguments to while (at line 8) are the predicate \narguments the .rst argument Inv locals h0 is provided by the programmer; the next two are wild cards \n( ) whose instantiation is inferred by F*. The fourth argument is the thunk representing the loop guard, \nand the last ar\u00adgument is a thunk for the loop body. 1 val get: unit .DST heap (.p h. p h h) 2 let getPath \nthis args = 3 let locals = allocObject () in 4 updField locals \"cur\" (selField args \"0\"); 5 updField \nlocals \"path\" (selField args \"1\"); 6 7 let h0 = get () in 8 let = while (Inv locals h0) 9 (. . (not ((selField \nlocals \"path\") = Undef)) .  10 (not ((selField locals \"cur\") = Undef))) 11 (. . 12 let ps = allocObject \n() in 13 let getChild = selField (selField locals \"cur\") \"getChild\" in 14 let hd = selField (selField \nlocals \"path\") \"hd\" in 15 updField ps \"0\" hd; 16 updField locals \"cur\" (apply getChild (selField locals \n\"cur\") ps); 17 updField locals \"path\" (selField (selField locals \"path\") \"tl\"); 18 ( )) 19 in selField \nlocals \"cur\" The code of the loop guard is straightforward. The body allo\u00adcates an object ps to pass \narguments to the function getChild. The parameters at the call on line 16 is a singleton integer containing \nthe head of the list \"path\". We then update the locals \"cur\" and \"path\" and iterate. Intuitively, verifying \nthis code for the absence of runtime errors requires two properties: at each iteration, the \"path\" local \nmust either be Undef or contain an integer hd .eld and also a tl .eld, while the \"cur\" local must contain \na DOM element (or be Undef). We state just this using the loop invariant shown below. 1 (* Typing polymorphic \nlists *) 2 type IsObject h o = TypeOf o=object . InDom h o 3 type IsList :: E . heap . dyn . E 4 type \nListTyping a h l = 5 (l=Undef . 6 (IsObject h l . 7 HasField h l \"hd\" . TypeOf (SelField h l \"hd\")=a \n. 8 HasField h l \"tl\" . IsList a h (SelField h l \"tl\"))) 9 assume typing1:. a h d.  10 IsList a h d \n.. ListTyping a h d 11 assume trans:. a h1 h2 d. 12 (IsList a h1 d . 13 (SelField h1 d \"hd\")=(SelField \nh2 d \"hd\") . 14 (SelField h1 d \"tl\")=(SelField h2 d \"tl\")) =. IsList a h2 d 15 (* The loop invariant \n*) 16 type CutIsElt h d = IsObject h d . (IsObject h d =. IsElt h d) 17 type Inv locs h0 h1 = 18 (GetFields \nh0 global)=(GetFields h1 global) . 19 IsObject h1 locs . 20 HasField h1 locs \"path\" . 21 HasField h1 \nlocs \"cur\" . 22 IsList int h1 (SelField h1 locs \"path\") . 23 ((SelField h1 locs \"cur\")=Undef . 24 CutIsElt \nh1 (SelField h1 locs \"cur\")) The invariant comes in two parts. First, at lines 2 14 we de.ne an inductive \npredicate IsList a h l, which states that in the heap h, the value l is either Undef or a list of a-typed \nvalues. The style of this inductive speci.cation is similar to the speci.cation of IsElt. The invariant \nInv itself is de.ned at line 17. The invariant is a ternary predicate relating an object holding the \nlocal variables locs, the heap h0 at the start of the loop, to a heap h1, which represents the heap at \nthe beginning of each loop iteration. The invariant states that: (1) the loop does not mutate the global \nobject (necessary to verify the code after the loop); (2) the locs object has .elds \"path\" and \"cur\"; \n(3) \"path\" is a list of integers; and (4) \"cur\" is either Undef or a DOM element. Stating and proving \n(4) required an additional hint (CutIsElt) for Z3 to .rst prove that \"cur\" is an object and then that \nit is a DOM element.  Writing such an invariant took considerable manual effort. This is unsurprising \nverifying loops in a more well-behaved language, say, C#, also requires writing invariants, although, \nof course, many simple invariants in C# can be stated using just its type system. With more experience, \nwe hope to discover JavaScript idioms that make writing loop invariants easier, and further, to apply \nideas ranging from abstract interpretation to interpolants to automatically infer these invariants. \n 5.3 Typograf Our .nal example is Typograf, an extension that formats text a user enters in a form. When \nTypograf receives a request to capture the text, it calls captureText, which calls the callback function \nin the request (line 3). At line 9, Typograf registers listener, which calls captureText, as an event \nhandler with the Chrome extension framework, by calling the function addListener. We veri.ed Typograf \nfor the absence of runtime errors. We show a simpli.ed fragment of its code below. 1 function captureText(elt, \ncallback) { 2 if(elt.tagName=== INPUT ) 3 { callback({text:elt.value}); } 4 } 5 function listener(request, \ncallback) { 6 if (request.command === captureText ) { 7 captureText(document.activeElement, callback); \n8 }} 9 chromeExtensionOnRequest.addListener(listener); Verifying this extension requires providing a \nspeci.cation for addListener, a third-order function it receives a second-order function (listener) as \nan argument. As the example below shows, our veri.cation methodology works naturally at higher order, \nand the same methodology can be used to write speci.cations for func\u00adtions of an arbitrary order. 1 type \nChromeTyping h chrome = 2 IsObject h chrome . 3 HasField h chrome \"addListener\" . 4 TypeOf (SelField \nh chrome \"addListener\")) = 5 AsE (. args this post h . 6 (. wp. TypeOf (SelField h args \"0\") = AsE wp \n. 7 (. args h . 8 (not (InDom h (Loc args)) . 9 h = Alloc h args .  10 IsObject h args . HasField \nh args \"0\" . 11 HasField h args \"1\" . 12 IsObject h (SelField h args \"0\") . 13 HasField h (SelField \nh args \"0\") \"command\" . 14 TypeOf (SelField h args \"1\") = 15 AsE (. postcb hcb. postcb Undef hcb)) \n16 =. wp args Undef post h ))) Since we do not yet model asynchrony, we require a sequential veri.cation \nharness. However, (in contrast with HoverMagni.er), we show how instead of writing driver code to include \na call to listener, we give a speci.cation to addListener that, in effect, treats it as a function that \nimmediately calls the function it receives as an argument. Using more realistic drivers is future work. \nThe listing above shows our (partial) speci.cation of the Chrome API. It states that Chrome contains \nan \"addListener\" function, which (at line 6) expects a function as its .rst argument, i.e., listener, \nin our example). The speci.cation states that it calls listener immediately in a heap h that differs \nfrom the input heap in that it contains a new object args (line 9). This arguments object args itself, \nin its zeroth .eld, contains an object with a \"command\" .eld; and in its .rst .eld, contains another \nfunction, the callback passed to listener. The callback in this case is very simple it is the constant \nUndef function but clearly, it could be given a more elaborate speci.cation. 6. Related work Our veri.cation \nmethodology is connected to a long line of litera\u00adture of Hoare logic and dependently typed programming \nlanguages. In addition to the connections already discussed, our methodol\u00adogy is related to the characteristic \nformulae of Chargu\u00b4eraud (2011). These formulae represent programs in higher-order logic, such that two \nprograms are equivalent if and only if their characteristic for\u00admulae are logically equivalent. Chargueraud \nshows how to compute a characteristic formula and manipulate it interactively in a theo\u00adrem prover. In \ncontrast, our predicate transformers are designed to be provable using an automated .rst-order theorem \nprover. Also related is work on F* and related languages. Borgstr \u00a8om et al. (2009) present an application \nof the Hoare monad within F7, a language subsumed by F* . Borgstrom et al. (2011) use substruc\u00adtural \nstate on top of a Hoare-like monad to model local state. Bhar\u00adgavan et al. (2010) adopt syntactic conventions \nto verify higher\u00adorder programs in a language with only .rst-order re.nement types. However, none attempts \nthe combination of type inference, higher\u00adorderness, and state. Fournet et al. (2013) use our JSPrims \nlibrary to prove a compiler from F* to JavaScript fully abstract. A key part of their proof methodology \ninvolves the use of the Dijkstra monad to state and prove invariants of the translation. As such, their \nwork constitutes separate validation of the expressiveness of the Dijkstra monad and the effectiveness \nof our veri.cation methodology. Another line of work on verifying higher-order programs is via higher-order \nmodel checking (Kobayashi et al. 2011) or via liquid types (Rondon et al. 2008). These approaches aim \nto be automated by discovering invariants. However, these systems generally do not handle state. Combining \nmodel checking or abstract interpretation based approaches with our work is likely to pay dividends, \nparticu\u00adlarly in the inference of invariants. Our case study of JavaScript veri.cation is related to \nwork that equips dynamic languages with static typing, starting perhaps with Cartwright (1976). More \nrecently, Henglein and Rehof (1995) de.ned a translation from Scheme to ML by encoding Scheme terms using \nthe algebraic ML type dynamic. They were able to stat\u00adically discover certain kinds of runtime errors \nin Scheme programs via their translation to ML. Our JS2JS* translation makes use of a similar translation \n(combined with . JS). Because of the richness of our target language, we are able to verify programs \nin a much more precise (and only semi-automated) manner. Besides, we need not stop at simply proving \nruntime safety our methodology enables proofs of functional correctness. There are several recent systems \nfor dynamic typing based on dependent typing. Dminor (Bierman et al. 2010) provides seman\u00adtic subtyping \nfor a .rst-order dynamically typed language. Tobin-Hochstadt and Felleisen (2010) provide re.nement types \nfor a pure subset of Scheme. System D (Chugh et al. 2012b) is a re.nement type system for a pure higher-order \nlanguage with dictionary-based objects. Our type dyn bears some resemblance to these in that the re.nement \nformulas speak about a typing property. However, none of these prior systems gives stateful re.nements \nto functions, which prevents them from handling both higher-order functions and mu\u00adtable state, as we \ndo. Chugh et al. (2012a) extends System D to provide a type system for JavaScript. They rely on explicit \ntype an\u00adnotations, and do not provide type inference or soundness of the type system. Gardner et al. \n(2012) provide an axiomatic semantics for JavaScript based on separation logic. Their semantics enables \npre\u00adcise reasoning about .rst-order, eval-free JavaScript programs, including those that explicitly manipulate \nscope objects and pro\u00adtotype chains. Technically, supporting this idiom is possible in our system with \na richer heap model. However, automated proving for such complex idioms is still hard. Indeed, at present, \nGardner et al. provide only pencil and paper proofs about small, .rst-order JavaScript programs. Nevertheless, \na potential direction for future work is to embed a subset of Gardner et al s separation logic style \nwithin F* for JavaScript veri.cation. Gardner et al. (2008) show how to write speci.cations and reason \nabout the DOM using con\u00adtext logic. Our speci.cation of the DOM, in contrast, uses classical logic, and \nis not nearly as amenable to modular reasoning about the DOM, which has many complex aliasing patterns \nlayered on top of a basic n-ary tree data structure. Understanding how to better struc\u00adture our speci.cations \nof the DOM, perhaps based on the insights of Gardner et al., is another line of future work.  Many tools \nfor automated analyses of various JavaScript sub\u00adsets have also been constructed. We have already mentioned \nGate\u00adkeeper, a pointer analysis for JavaScript used by JS2JS*. The CFA2 analysis (Vardoulakis and Shivers \n2011) has been implemented in the Doctor JS tool to recover information about the call structure of a \nJavaScript program. Our method of reasoning about JavaScript programs by extracting heap models in Z3 \ncan also be seen as a pre\u00adcise control .ow analysis. As discussed previously, there is ample opportunity \nto improve our tool to consume the results of a source\u00adlevel control-.ow analysis as hints to our solver. \nJensen et al. (2009) build a whole-program abstract interpreta\u00adtion to recover more precise type information \nof JavaScript pro\u00adgrams in order to statically .nd program errors. The goals are simi\u00adlar to our JavaScript \nveri.cation, but our modular approach does not rely on complete program analysis. They assume relatively \nsmall, complete programs while our approach allows for modular veri.cation of portions of a program. \n7. Conclusions Structuring speci.cations for higher order, stateful programs in the style of the Dijkstra \nmonad has a number of bene.ts. As we have argued, it lends itself naturally to type inference, the VCs \nit com\u00adputes can be handled by an SMT solver, and it is .exible enough to accommodate various language \ndisciplines (ranging from dy\u00adnamic typing, local state, and higher order stores, to exceptions and monotonic \nstate). Indeed, the basic methodology makes very few assumptions about the underlying monad, allowing \nour tools to be repurposed for other veri.cation tasks our initial experience com\u00adbining the Dijkstra \nmonad with an information .ow monad is illus\u00adtrative. Going further in this direction, we conjecture \nthat adapting existing monads for functional reactivity to the Dijkstra-style is a natural way for handling \nasynchrony within our framework. Using our JavaScript veri.cation tool chain we have shown that with \nthe right abstractions for reasoning about higher-order, dynamically typed stores, automated program \nveri.cation tools are within reach for JavaScript. Despite some limitations, ours is the .rst tool to \nenable sound, precise, semi-automated, modular veri.cation for a sizeable subset of JavaScript, including \nits higher\u00adorder and stateful features. References M. Barnett, R. DeLine, M. Fahndrich, K. R. M. Leino, \nand W. Schulte. Veri.cation of object-oriented programs with invariants. JOT, 3, 2004. K. Bhargavan, \nC. Fournet, and N. Guts. Typechecking higher-order security libraries. In APLAS, pages 47 62, 2010. G. \nM. Bierman, A. D. Gordon, C. Hrit\u00b8cu, and D. Langworthy. Semantic subtyping with an SMT solver. In ICFP, \n2010. J. Borgstr \u00a8 om, A. Gordon, and R. Pucella. Roles, stacks, histories: A triple for Hoare. Technical \nReport TR-2009-97, Microsoft Research, 2009. J. Borgstrom, J. Chen, and N. Swamy. Verifying stateful \nprograms with substructural state and hoare types. In PLPV, Jan. 2011. R. Cartwright. A Practical Formal \nSemantic De.nition and Veri.cation System for TYPED LISP. Garland Publishing, New York, 1976. R. Cartwright \nand M. Fagan. Soft typing. In PLDI, 1991. A. Chargu\u00b4eraud. Characteristic formulae for the veri.cation \nof imperative programs. In ICFP, 2011. J. Chen, R. Chugh, and N. Swamy. Type-preserving compilation of \nend-to\u00adend veri.cation of security enforcement. In PLDI, 2010. R. Chugh, D. Herman, and R. Jhala. Dependent \ntypes for JavaScript. In OOPSLA, 2012a. R. Chugh, P. M. Rondon, and R. Jhala. Nested re.nements: a logic \nfor duck typing. In POPL, 2012b. D. Crockford. JavaScript: The Good Parts. O Reilly Media Inc., 2008. \nL. de Moura and N. Bj\u00f8rner. Z3: An ef.cient SMT solver. In TACAS, 2008. E. W. Dijkstra. Guarded commands, \nnondeterminacy and formal derivation of programs. Commun. ACM, 18:453 457, August 1975. J.-C. Filli atre \nand C. March \u00b4e. The why/krakatoa/caduceus platform for deductive program veri.cation. In CAV, pages \n173 177, 2007. C. Fournet, N. Swamy, J. Chen, P. Evariste-Dagand, P.-Y. Strub, and B. Livshits. Fully \nabstract compilation to JavaScript. In POPL, 2013. P. A. Gardner, G. D. Smith, M. J. Wheelhouse, and \nU. D. Zarfaty. Local Hoare reasoning about DOM. In PODS, 2008. P. A. Gardner, S. Maffeis, and G. D. Smith. \nTowards a program logic for Javascript. In POPL, 2012. S. Guarnieri and B. Livshits. Gatekeeper: Mostly \nstatic enforcement of security and reliability policies for JavaScript code. In USENIX Security, 2009. \nA. Guha, C. Saftoiu, and S. Krishnamurthi. The essence of JavaScript. In ECOOP, 2010. A. Guha, M. Fredrikson, \nB. Livshits, and N. Swamy. Veri.ed security for browser extensions. In IEEE Symposium on Security and \nPrivacy, 2011. F. Henglein. Dynamic typing: syntax and proof theory. Science of Computer Programming, \n22:197 230, 1994. F. Henglein and J. Rehof. Safe polymorphic type inference for Scheme: Translating Scheme \nto ML. In FPCA, pages 192 203, 1995. S. H. Jensen, A. M\u00f8ller, and P. Thiemann. Type analysis for JavaScript. \nIn SAS, pages 238 255, 2009. N. Kobayashi, R. Sato, and H. Unno. Predicate abstraction and CEGAR for \nhigher-order model checking. In PLDI, pages 222 233, 2011. K. R. M. Leino. Dafny: An automatic program \nveri.er for functional correctness. In LPAR (Dakar), pages 348 370, 2010. K. R. M. Leino and P. R \u00a8ummer. \nA polymorphic intermediate veri.cation language: Design and logical encoding. In TACAS, 2010. J. McCarthy. \nTowards a mathematical science of computation. In IFIP Congress, pages 21 28, 1962. A. Nanevski, A. Ahmed, \nG. Morrisett, and L. Birkedal. Abstract predicates and mutable adts in hoare type theory. In ESOP, pages \n189 204, 2007. A. Nanevski, G. Morrisett, A. Shinnar, P. Govereau, and L. Birkedal. Ynot: dependent types \nfor imperative programs. In ICFP, 2008a. A. Nanevski, J. G. Morrisett, and L. Birkedal. Hoare type theory, \npolymor\u00adphism and separation. J. Funct. Program., 18(5-6):865 911, 2008b. P. W. O Hearn, H. Yang, and \nJ. C. Reynolds. Separation and information hiding. In POPL, 2004. M. Parkinson and G. Bierman. Separation \nlogic and abstraction. In POPL, 2005. P. M. Rondon, M. Kawaguchi, and R. Jhala. Liquid types. In PLDI, \n2008. N. Swamy, J. Chen, C. Fournet, P.-Y. Strub, K. Bhargavan, and J. Yang. Secure distributed programming \nwith value-dependent types. In ICFP, 2011a. N. Swamy, N. Guts, D. Leijen, and M. Hicks. Lightweight monadic \nprogramming in ML. In ICFP, 2011b. S. Tobin-Hochstadt and M. Felleisen. Logical types for untyped languages. \nIn ICFP, 2010. D. Vardoulakis and O. Shivers. CFA2: a Context-Free Approach to Control-Flow Analysis. \nLogical Methods in Computer Science, 7(2:3), 2011.    \n\t\t\t", "proc_id": "2491956", "abstract": "<p>Modern programming languages, ranging from Haskell and ML, to JavaScript, C# and Java, all make extensive use of higher-order state. This paper advocates a new verification methodology for higher-order stateful programs, based on a new monad of predicate transformers called the Dijkstra monad.</p> <p>Using the Dijkstra monad has a number of benefits. First, the monad naturally yields a weakest pre-condition calculus. Second, the computed specifications are structurally simpler in several ways, e.g., single-state post-conditions are sufficient (rather than the more complex two-state post-conditions). Finally, the monad can easily be varied to handle features like exceptions and heap invariants, while retaining the same type inference algorithm.</p> <p>We implement the Dijkstra monad and its type inference algorithm for the F* programming language. Our most extensive case study evaluates the Dijkstra monad and its F* implementation by using it to verify JavaScript programs.</p> <p>Specifically, we describe a tool chain that translates programs in a subset of JavaScript decorated with assertions and loop invariants to F*. Once in F*, our type inference algorithm computes verification conditions and automatically discharges their proofs using an SMT solver. We use our tools to prove that a core model of the JavaScript runtime in F* respects various invariants and that a suite of JavaScript source programs are free of runtime errors.</p>", "authors": [{"name": "Nikhil Swamy", "author_profile_id": "81342513197", "affiliation": "Microsoft Research, Redmond, WA, USA", "person_id": "P4149066", "email_address": "nswamy@microsoft.com", "orcid_id": ""}, {"name": "Joel Weinberger", "author_profile_id": "81467643053", "affiliation": "University of California, Berkeley, Berkeley, CA, USA", "person_id": "P4149067", "email_address": "jww@cs.berkeley.edu", "orcid_id": ""}, {"name": "Cole Schlesinger", "author_profile_id": "81490647459", "affiliation": "Princeton University, Princeton, NJ, USA", "person_id": "P4149068", "email_address": "cschlesi@princeton.edu", "orcid_id": ""}, {"name": "Juan Chen", "author_profile_id": "81100119052", "affiliation": "Microsoft Research, Redmond, WA, USA", "person_id": "P4149069", "email_address": "juanchen@microsoft.com", "orcid_id": ""}, {"name": "Benjamin Livshits", "author_profile_id": "81100637280", "affiliation": "Microsoft Research, Redmond, WA, USA", "person_id": "P4149070", "email_address": "livshits@microsoft.com", "orcid_id": ""}], "doi_number": "10.1145/2491956.2491978", "year": "2013", "article_id": "2491978", "conference": "PLDI", "title": "Verifying higher-order programs with the dijkstra monad", "url": "http://dl.acm.org/citation.cfm?id=2491978"}