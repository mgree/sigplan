{"article_publication_date": "06-16-2013", "fulltext": "\n TR A N S I T: Specifying Protocols with Concolic Snippets * Abhishek Udupa Arun Raghavan Jyotirmoy \nV. Deshmukh Sela Mador-Haim Milo M. K. Martin Rajeev Alur University of Pennsylvania {audupa, arraghav, \ndjy, selama, milom, alur}@cis.upenn.edu Abstract With the maturing of technology for model checking and \ncon\u00adstraint solving, there is an emerging opportunity to develop pro\u00adgramming tools that can transform \nthe way systems are speci.ed. In this paper, we propose a new way to program distributed pro\u00adtocols using \nconcolic snippets. Concolic snippets are sample exe\u00adcution fragments that contain both concrete and symbolic \nvalues. The proposed approach allows the programmer to describe the de\u00adsired system partially using the \ntraditional model of communicat\u00ading extended .nite-state-machines (EFSM), along with high-level invariants \nand concrete execution fragments. Our synthesis engine completes an EF S M skeleton by inferring guards \nand updates from the given fragments which is then automatically analyzed using a model checker with \nrespect to the desired invariants. The coun\u00adterexamples produced by the model checker can then be used \nby the programmer to add new concrete execution fragments that de\u00adscribe the correct behavior in the \nspeci.c scenario corresponding to the counterexample. We describe TRAN S I T, a language and prototype \nimplementa\u00adtion of the proposed speci.cation methodology for distributed pro\u00adtocols. Experimental evaluations \nof TR A N S IT to specify cache co\u00adherence protocols show that (1) the algorithm for expression infer\u00adence \nfrom concolic snippets can synthesize expressions of size 15 involving typical operators over commonly \noccurring types, (2) for a classical directory-based protocol, TR AN S I T automatically gen\u00aderates, \nin a few seconds, a complete implementation from a spec\u00adi.cation consisting of the E F SM structure and \na few concrete ex\u00adamples for every transition, and (3) a published partial description of the SGI Origin \ncache coherence protocol maps directly to sym\u00adbolic examples and leads to a complete implementation in \na few iterations, with the programmer correcting counterexamples result\u00ading from underspeci.ed transitions \nby adding concrete examples in each iteration. Categories and Subject Descriptors D.1 [Programming Tech\u00adniques]: \nAutomatic Programming; D.2.2 [Design Tools and Tech\u00adniques]: Computer-aided Software Engineering; D.2.4 \n[Software Veri.cation]: Model Checking Keywords Program Synthesis; Distributed Protocol Synthesis; Cache \nCoherence Protocols; Programming by Example. * This research was partially supported by NSF award CCF \n0905464 and NSF Expeditions in Computing grant CCF 1138996. Jyotirmoy V. Deshmukh is currently a researcher \nat Toyota Technical Center, Gardena, CA. Permission to make digital or hard copies of all or part of \nthis work for personal or classroom use is granted without fee provided that copies are not made or distributed \nfor pro.t or commercial advantage and that copies bear this notice and the full citation on the .rst \npage. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior \nspeci.c permission and/or a fee. PLDI 13, June 16 19, 2013, Seattle, WA, USA. Copyright c &#38;#169; \n2013 ACM 978-1-4503-2014-6/13/06. . . $15.00 1. Introduction Over the last few decades, technology for \nprogram analysis, model checking, and software veri.cation has matured, and has witnessed growing adoption \nin industry. However, veri.cation tools have largely been con.ned to discovering bugs in systems that \nhave already been designed. This raises the question: how can we lever\u00adage the advances in analysis tools \nto assist programmers, during the program development phase, in an interactive manner? In this paper, \nwe propose a methodology for programming distributed protocols, in which a programmer can express the \nintended design using multiple formats, which a synthesis tool then integrates into an executable implementation. \nOur approach is inspired by recent work on sketching and on programming by examples. In sketching, a \nprogrammer writes a partial program with incomplete details, and a synthesizer then .lls in the missing \ndetails based on user\u00adspeci.ed assertions [23, 24] (see also [15, 26]). With this approach, the programmer \ncan continue to use the familiar imperative style of programming, but can use the synthesis tool to .nd \nintricate details necessary for .ne-tuning code by supplying a few high-level in\u00advariants. In programming \nby examples, the programmer expresses the desired behavior using a set of example input/output traces, \nand the synthesis tool constructs an executable implementation consistent with these examples. This has \nbeen shown to be an intu\u00aditive and effective style for programming .nite-state reactive con\u00adtrollers \n[9 11], Excel macros performing string manipulations [7], and pointer-manipulations for updating data \nstructures [22]. This paper focuses on programming reactive systems such as distributed protocols. For \nsuch protocols, although the core algo\u00adrithms are published with accompanying correctness proofs and \nperformance analyses, these descriptions typically do not specify every detail, and translating them \ninto a correct working imple\u00admentation is challenging due to corner cases arising from asyn\u00adchrony and \nconcurrency [2]. A distributed protocol is typically de\u00ad scribed by listing the set of processes participating \nin the protocol, the set of channels connecting the processes, the types of messages each channel can \ncarry, and the descriptions of individual processes given as extended .nite-state-machines (E F SMs). \nAn E F S M descrip\u00adtion consists of a list of internal state variables, a set of control states, and \na set of transitions connecting control states. Each tran\u00adsition is speci.ed by a guard condition and \nupdate code that refer to the internal state variables and .elds of incoming and outgoing messages. This \nstyle of specifying distributed protocols is common in standardized descriptions of network protocols \nas RFCs, rigor\u00adous textbook descriptions of distributed algorithms [17], modeling languages supported \nby formal veri.cation tools such as SPIN [12] and Mur. [5], and domain-speci.c languages such as SLICC \n[18]. The traditional programming style requires the programmer to .ll in every detail of every transition, \nand our goal is to offer program\u00admer assistance with this tedious and error-prone task. Using the proposed \nlanguage, TR A N S IT, a programmer de\u00adscribes the communication architecture of a distributed protocol \n  Figure 1. Design methodology using concolic snippets by listing the set of processes, the set of channels \nconnecting them, the types of messages each channel can carry, and the E F S M skele\u00adton for each process \nby listing control states and internal state variables. TR A N S IT also allows behavioral speci.cation \nof each process using concolic snippets, which are fragments of desired execution that contain conditional \nupdates to variables using both concrete and symbolic values (the term concolic was coined in the context \nof testing programs using both concrete and symbolic inputs [20]). This approach offers the programmer \nthe .exibility to either describe each EFSM transition in the traditional way using symbolic expressions \nfor guards and updates, or to specify only representative examples of such transitions. The TR A NSI \nT synthe\u00adsis tool then generates a complete protocol by inferring guards and update actions that are \nconsistent with the speci.ed snippets. The programmer also speci.es high-level temporal invariants which \nthe protocol needs to satisfy. A .nite instance of the synthesized protocol is then checked against these \ninvariants using a model checker. The programmer debugs any reported counterexamples with a visualizer \nand adds more snippets to rule out erroneous be\u00adhaviors. Figure 1 illustrates the proposed methodology. \nThe main computational problem in our approach is to infer an expression to be used in a guard or an \nupdate appearing in an E F S M transition that is (1) built in a type-consistent manner us\u00ading the speci.ed \nvocabulary of function symbols and variables, and (2) is consistent with the given set of concrete and \nsymbolic ex\u00adamples. Our solution is a variant of the counterexample-guided in\u00adductive synthesis (CEGIS) \napproach [8, 13, 23], and involves an interplay between pruning based on concrete examples and con\u00adcretization \nof symbolic examples using an SMT solver. Specif\u00adically, our implementation enumerates expressions of \nincreasing sizes, where the space of expressions is pruned signi.cantly by considering two expressions \nequivalent if they evaluate to the same values for the given concrete examples. This results in an expres\u00adsion \nthat is consistent with all the concrete examples. This expres\u00adsion is then checked for consistency with \nrespect to the symbolic examples using an SMT solver. If the consistency check succeeds, then the expression \nis the desired answer. If it fails, the evidence for inconsistency returned by the solver contributes \nto a concrete example, which is considered in subsequent iterations. The TRA N S IT prototype implementation \ninvokes the SMT solver Z3 [19] and the model checker Mur. [5]. To evaluate the algorithm for inferring \nan expression from concolic examples, we consider a vocabulary of the common operations on Booleans, \nin\u00adtegers, and bounded sets. The algorithm can infer expressions with a size of 15 symbols within a few \nminutes. To evaluate the feasibility of the proposed methodology, we fo\u00adcus on cache coherence protocols, \na class representative of dis\u00adtributed protocols. We performed two case studies where students with no \nexperience with coherence protocols used the TR A N S IT prototype to program two canonical cache coherence \nprotocols from textbook descriptions using concolic examples [25]. Both case studies resulted in generating \nprotocols that were successfully checked by the model checker. We found that: (1) the .nal, cor\u00adrectly \ngenerated protocol typically required one or two concrete snippets per transition, (2) synthesizing the \nprotocol from snippets took only a few seconds, and (3) the entire iterative protocol devel\u00adopment required \na few hours of manual effort for either case study. In our .nal case study, we used TR A N S I T to specify \nthe indus\u00adtrial-strength SGI Origin protocol. The published description [16] was directly mapped to symbolic \nsnippets corresponding to typical transitions. However, as the published prose is not a complete spec\u00adi.cation, \nit results in an implementation that violates coherence in\u00advariants during the model-checking phase. \nBecause the counterex\u00adamples produced by the model checker correspond to concrete exe\u00adcutions, our methodology \nallowed the programmer to augment the original description with concrete .xes to these violating traces, \nculminating in a correct implementation of the protocol. 2. Illustrative Examples of Our Approach We \nillustrate the use of TR A N S I T using cache coherence proto\u00adcols as an example application. Such protocols \nmaintain a coherent view of shared memory among threads running in multi-core and multi-socket systems. \nAlthough programmers view memory as a single data store, most systems incorporate private per-core caches \nto reduce access latency. Coherence protocols prevent threads from reading stale data from caches by \nensuring that reads to memory locations (addresses) receive the last value written to that location by \nany thread. Coherence is conventionally enforced using mutu\u00adally exclusive read/write permissions: either \nmultiple processors may simultaneously cache an address with read permissions (i.e., shared readers) \nor a single processor may cache that address with read/write permissions (i.e., exclusive writer). Although \nseveral dif\u00adferent hardware and software approaches exist, this paper focuses on invalidation-based directory \nhardware implementations. In such a system, processors issue requests to a central directory which tracks \nthe current permissions of each cache. On receiving a request for write permission, the directory issues \ninvalidation messages to all caches that hold a valid copy (read or write permissions) and gathers acknowledgments \nfrom these caches before granting write permissions to the requester. Similarly, the directory redirects \nread requests to the last writer to that address (tracked as the owner in the directory) to ensure that \nvalid data is transferred to the request\u00ading processor. As with existing approaches for modeling protocols \nusing state machines, TR A NSI T views the protocol in terms of a well de.ned structure (referred to \nas the protocol skeleton) and its behavioral description. Protocol skeleton. A protocol description usually \nincludes the high-level structural description of the desired protocol. For ex\u00adample, from Chapter 8 \nof the coherence primer [25], the speci.\u00ad cation would include: (1) Processes: a distinguished E F SM \ncalled the Directory and one EF S M per cache controller. (2) Communica\u00adtion architecture: three networks \nthat the E F SMs use to send/receive messages, including any ordering guarantees. (3) Message types: \nsuch as Get and Data that may be carried on speci.c networks (for instance, the Response network can \nonly carry Data and Inv-Ack message types). (4) Control states of each EF S M: such as M, S and I for \nthe directory E F S M. (5) Internal variables for each EFSM: such as Sharers in directory, which is used \nto track the list of cache processes with a valid copy of data. The above protocol skeleton is usually \nexpressed as type declarations and variable de.nitions in existing approaches. The programmer speci.es \nthe protocol skele\u00adton similarly in the proposed approach as well.  Cache1 Cache2 Dir State = EXCLUSIVE \nOwner = Cache1 Sharers = {} speci.cation of the E F SMs. Protocol designers typically describe State \n= BUSY_SHARED Owner = Cache2 behavior in terms of example .ows [27] or interaction of processes Sharers \n= { Cache2 } when they exchange messages, triggering events and consequent actions. These descriptions \nare commonly expressed and commu\u00adnicated informally (using visual aids like example state diagrams and \nmessage sequence charts, or listing case-by-case actions tex\u00adtually) both in industrial protocols as \nwell as in academic litera\u00adture [16, 25]. Such informal descriptions can completely specify relatively \nstraightforward protocols like the textbook MSI exam\u00adple [25]. In these cases, the programming task is \nlargely to infer and symbolically codify the semantics implied by the examples. For more complex protocols, \nthe informal descriptions convey salient features, like common-case behavior and perhaps some of the \nmore interesting scenarios that might arise (usually in terms of rules). Implementing such protocols \ninvolves the additional step of .lling in any unspeci.ed details. However, it has been shown that this \napproach to implementing complete protocols symboli\u00adcally as a program can be error-prone even for experts, \nwith bugs manifesting even in released processors [1, 2]. Specifying behavior with snippets. We observe \nthat the complex\u00adity in protocols does not usually stem from the code for individual transitions these \ntend to be straight line code. The complexity Figure 2. The counterexample trace Figure 3. EFSM representing \na directory process. The M (mod\u00adis due to corner cases and race conditions arising from concur\u00ad rency \nand asynchrony when protocols are considered in their en\u00adi.ed) state indicates read/write permissions. \nThe S (shared) state tirety [2]. Using a concolic approach allows the programmer to mix indicates read-only \npermissions and the I (invalid) state indicates symbolic snippets (transition code) describing well-de.ned \nbehav\u00adior (like rules or state machine transitions) with concrete snippets describing speci.c example \nscenarios. The TRA N S I T tool composes the given concrete and symbolic snippets to generate an implementation \nwhich allows at least all the behaviors described in the input snippets. This implementation is then \nmodel checked for coherence invariants. Any underspeci.ca\u00adtion or error in the speci.cation of the E \nF S M behavior will result in a counterexample during model checking, which the programmer can then .x \nusing concrete snippets to prevent subsequent occur\u00adrences of at least that speci.c violation. Example \nusing concolic snippets. We illustrate this mixed (or concolic) use of TR A N S IT with an anecdote from \nour case study in implementing the SGI Origin protocol from published informal textual rules [16] (Section \n6 contains more details on this case study, and using TRAN S I T with concolic snippets to implement \nprotocols which are completely speci.ed). The protocol skeleton states that the directory E FSM has variables \nSharers and Owner to maintain its internal state. One of the rules in the paper describes the behavior \nof a directory upon a read request from a cache as: If directory state is Exclusive with another owner, \ntransitions to Busy-shared with requester as owner and send out an intervention shared request to the \nprevious owner and a speculative reply to the requester. Go to 5b . Note that this description does not \nspecify how the Sharers process variable in the directory E F S M needs to be updated. The programmer \nindicated that if the sender of the message was not the previous Owner, the value of the Sharers variable \nneeds to contain at least the sender of the received message in addition to the old value of the Sharers \nvariable. Based on this speci.cation, TR A N S I T generated the code: Sharers := Sharers . {Msg.Sender} \nHowever, an attempt to verify the generated implementation using Mur. resulted in a coherence violation. \nTRAN S I T provided a vi\u00adsual trace of the counterexample to the programmer, a simpli.ed version of which \nis shown in Figure 2. Observe that the transi\u00ad tion on the directory shown in Figure 2 is a concrete \ninstance of no permissions. The rest of the states are transient states. the scenario described earlier, \nwhere Msg.Sender is Cache2 and the Owner variable is initially set to Cache1. Upon inspecting the trace, \nthe programmer recognized that in this particular scenario, with Sharers needed to include the previous \nvalue of the Owner as well. After a concrete snippet specifying this speci.c conditional update was added, \nTRAN S I T then generated a new implementation including the correct update to Sharers as: Sharers := \nSharers . {Msg.Sender, Owner} This example illustrates how a programmer can bene.t from us\u00ading the concolic \nnature of TR ANS I T. TR A N S IT allows the program\u00admer to combine the familiar symbolic programming \nstyle for spec\u00adifying the protocol skeleton and well-understood behavior. TR A N -S I T also makes it \nconvenient to .x bugs with concrete execution fragments that describe the desired outcome in the particular \nsce\u00adnario where the bug manifests. 3. Protocol Speci.cation using Concolic Snippets A protocol implementation \nresults in transition code for commu\u00adnicating E FSMs. Figure 3 shows the E FSM for a directory process \nin a cache coherence protocol. TR ANSI T borrows from traditional software [18] and hardware [4] protocol \ndescription languages to specify the protocol skeleton (i.e., types and variable de.nitions) and transitions \n(using a guarded command language). However, TR ANSI T offers the additional ability to mix concrete \nand symbolic transitions as snippets, and to under-specify elements of transitions for the tool to infer. \nWe now describe how to specify a protocol using TRA N S IT. 3.1 High-level Building Blocks of TR A N \nS I T Coherence protocols typically assume an asynchronous, message\u00adpassing based model of communication. \nEach process description includes a list of input channels to receive messages, and output channels on \nwhich messages are sent. A channel can be modeled as a multiset or a queue depending on the desired ordering \nguarantees.  Transition(CurrentState, InputEvent) [optional guard] => (NextState, OutMsg1, ...) Pre1 \n==> Post11; Post12; . . . Pre2 ==> . . . Figure 4. A concolic snippet. CurrentState and NextState are \nthe start and end control states. The snippet speci.es zero or more out\u00adbound messages. It also speci.es \na guard-action block for each guard containing a set of conditional updates. The expression Prei speci.es \nthe condition (on process variables and the .elds of the re\u00adceived message) under which the boolean constraints \nPostij hold. Each Postij constrains the updated value of exactly one process variable or output message \n.eld in terms of the old values of the process variables and the .elds of the received message. The syntactic \nelements of TR A N SI T, shown in Figure 4, are as follows: Control states de.ne the logical state of \nthe directory and cache machines. These can be thought of as the program counter for these machines. \nProcess variables internal to each machine, such as Sharers in the directory. These may be Booleans, \nintegers or bounded sets. Input events correspond to receiving messages or external trig\u00adgers (to issue \nrequests). An input event is speci.ed as a single mes\u00adsage variable and the network on which it is received. \nGuards are Boolean expressions over process variables and .elds of received messages. Output events correspond \nto sending messages to other pro\u00adcesses. They are represented as a list of message variables and the \nname of network on which each message is sent. Action statements update process variables to new values \nand specify values for the .elds of outbound messages. We defer a discussion on Pre and Post to Section \n3.2. A com\u00ad plete speci.cation of the behavior of an EFS M is thus a set of ac\u00adtions A that are to be \nexecuted, a set of output events O that are to be generated, the next control state s' to transition \nto, all predi\u00adcated on a guard g, for each combination of input event and control state (e, s). The semantics \nof such a speci.cation are that the E F S M executes actions A, generates events O, and .nally transitions \nto control state s' in response to an input event e when the E F S M is in control state s, provided \ng evaluates to true. In the asynchronous model of computation, the order in which processes execute is \nnon\u00addeterministic. However, once a process has been chosen for execu\u00adtion, its actions are assumed to \nbe deterministic.  3.2 Programming with TR A NSIT Figure 4 shows the composition of a single transition \nsnippet in TR A N SI T. Using existing approaches such as SLICC [18] or hard\u00ad ware description languages, \nthe programmer would completely specify the guards and actions in the transition. However, TR A N S IT \nallows for guards to be left empty and for actions to be speci.ed as constraints governed by pre-and \npost-conditions as shown in Fig\u00adure 4. In such cases, the tool computes expressions for the empty guards \nand update statements satisfying the given constraints. The programmer has a choice of specifying completely \nsym\u00adbolic, completely concrete, or mixed concolic snippets. In each case, TR A N S IT generates a symbolic \nimplementation. The pre-and post-conditions are Boolean predicates over process variables and message \n.elds. Primed variables denote updated values of process variables. We assume a parallel assignment model, \nwhich precludes primed variables from appearing in pre-conditions and allows at most one primed variable \nper post-condition. Note that although guards and pre-conditions are both Boolean predicates ranging \nover the same variables, they have markedly different uses: guards ap\u00adpear in the complete protocol implementation \nof the E F S M in a guarded-command language, whereas pre-conditions are inputs to the inference engine \nwhich allow users to capture particular scenar\u00adios and are not part of the generated protocol implementation. \nSymbolic snippets. By specifying the guard and actions symbol\u00adically, we obtain a symbolic snippet which \ncompletely speci.es a transition. A non-empty guard is assumed to be symbolic (i.e., com\u00adpletely speci.ed \nand not generated by TR ANS I T). Symbolic actions are speci.ed by making the post-condition an equality \nconstraint. Concolic snippets. If the guard is left empty, or the actions are speci.ed using pre-and \npost-condition constraints (instead of equality), the snippet is concolic in nature. The TRAN S I T tool \ngen\u00aderates symbolic code for update statements and/or the guard to be consistent with the given constraints. \nThe following concolic snip\u00adpet speci.es the transition for the directory process mentioned in the SGI-Origin \nanecdote in Section 2. Transition(EXCLUSIVE, ReqNet Msg) { [] => (BUSY_SHARED, RepNet RMsg, IntNet IMsg) \n{ (Msg.MType = READ &#38; Msg.Sender != Owner) ==> { SubsetOf(SetUnion(Sharers, {Msg.Sender}), Sharers \n); . . . }}} This snippet is applicable only when the current state is EXCLUSIVE and a message is received \non the network ReqNet. To be consistent with the snippet, TR A N S IT must generate code to update the \nnew value of Sharers to be a superset of the old value and the sender of the incoming message. Concrete \nsnippets. Concolic snippets may contain symbolic pre\u00adand post-conditions over variables, but concrete \nsnippets specify concrete values for any variables in these constraints. They may leave the guard empty \nas well. For example, the concrete snippet below shows the bug-.x described in Section 2: Transition(EXCLUSIVE, \nReqNet Msg) { [] => (BUSY_SHARED, RepNet RMsg, IntNet IMsg) { (Msg.MType = READ &#38; Owner = C1 &#38; \nMsg.Sender = C2) ==> { Sharers = {C1, C2}; . . . }}} In summary, symbolic and concrete snippets can be \nthought of as instances of concolic snippets in which guards and actions are either completely speci.ed \n(symbolic), or speci.ed with concrete values for all variables (concrete). The task of the TR ANSI T \ntool is to generate expressions for guards and update expressions for variables such that they are consistent \nwith the given snippets. We formalize this problem in Section 5 after .rst describing our expression \ninference algorithm in the next section. 4. Inferring Expressions We .rst de.ne the problem of inferring \nan expression from con\u00adcrete or concolic examples in Section 4.1, which our synthesis pro\u00ad cedure uses \nas a subroutine. Section 4.2 presents a solution for a restricted version of this problem in which the \nexamples involve only concrete values, whereas Section 4.3 presents a solution for the general case where \nthe examples have concolic values. The expression inference problem corresponds to the follow\u00ading computational \nproblem: given a quanti.er-free formula C over (typed) variables V and a distinguished (output) variable \no, .nd an expression e such that the formula C[o := e] is valid, where C[o := e] is the usual notation \nfor the formula obtained by syn\u00adtactically substituting e for every occurrence of o in C. Conceptu\u00ad \n add (Int, Int) . Int Integer Addition sub (Int, Int) . Int Integer Subtraction inc (Int) . Int Add one \nto an Integer dec (Int) . Int Subtract one from an Integer setadd (Set, PID) . Set Add an entry into \na Set setsize (Set) . Int Cardinality of a Set setunion (Set, Set) . Set Set Union setinter (Set, Set) \n. Set Set Intersection setminus (Set, Set) . Set Set Difference setof (PID) . Set Create a singleton \nSet or (Bool, Bool) . Bool Boolean Disjunction and (Bool, Bool) . Bool Boolean Conjunction not (Bool) \n. Bool Boolean Negation setcontains (Set, PID) . Bool Membership test on a Set iszero (Int) . Bool Test \nif an integer is Zero .t . T equals (t, t) . Bool Equality Test ge (Int, Int) . Bool Greater than or \nequal to gt (Int, Int) . Bool Greater than .t . T , ite (Bool, t, t) . t Conditional Expression numcaches \n() . Int # of Caches (constant) Table 1. Expression Vocabulary used in Coherence Protocols ally, this \nproblem is similar to solving ..-formulas, and we use the counterexample-guided inductive synthesis (CEGIS) \nstrategy that has previously been used to solve such problems [8, 23]. The algorithm enumerates expressions, \nwith suitable pruning strategies, to .nd a candidate expression e that is consistent with the concrete \nexamples that contribute to C. It then checks if \u00acC[o := e] is satis.able. If \u00acC[o := e] is unsatis.able, \nthen e is the desired expression. Otherwise, the satisfying model contributes a concrete example that \nis added to the set of concrete examples and the entire process is repeated. Thus, the algorithm handles \nexists an expres\u00adsion using enumerative techniques and is valid for all variable values using symbolic \nconstraint solving. 4.1 Problem De.nition We de.ne an expression vocabulary G as a tuple (T , F), where \nT is a set of types, and F is a set of typed function symbols, where for each f . F , arity(f) . Ndenotes \nthe arity of f, type(f ) . T denotes the type of the range of f, and argtype(f, i) . T , i . [1, arity(f \n)] denotes the type of the domain of the ith argument to f . Function symbols of arity zero are constants. \nF is .nite, so we have a .xed number of constant symbols. However, constant expressions such as 2 are \nallowed as an abbreviation for add(1, 1). Let V denote a set of typed variable symbols and let type(v) \n. T denote the type of a variable v in V. Given an expression vocab\u00adulary G = (T , F) and a set of typed \nvariables V, we denote the set of expressions of type t as Exp(F, V, t). This set is de.ned induc\u00adtively \nas follows: (1) If v . V then v . Exp(F, V, type(v)), and (2) If f . F , and .i . [1, k] : ei . Exp(F, \nV, argtype(f, i)), then f(e1, e2, . . . , ek) . Exp(F, V, type(f )), where k = arity(f). If e . Exp(F, \nV, t), then we write type(e) = t. We assume that the Boolean type (denoted Bool) is always present in \nany in\u00adstantiation of T and that the basic Boolean operators (conjunction, disjunction and negation) \nare part of F. For specifying cache coherence protocols, we use an expression vocabulary where the set \nof types is T = {Bool, Int, PID, Set} . Enums. Here, Int denotes the integer type, PID is a special type \nfor process identi.ers, Set is a type denoting a set of values of type PID, and Enums is a set of user \nde.ned enumerated types. The set of functions F in the vocabulary is shown in Table 1. The size of an \nexpression e, size(e), is de.ned as the number of function symbols and variable symbols appearing in \ne. Further, we denote by Expk(F, V, t) the set {e : e . Exp(F, V, t) . size(e) = k}, i.e., the subset \nof expressions of type t with size k. Given a set of typed variables V and a distinguished typed variable \no ./V (henceforth known as the output variable), an example C is a Boolean formula of the form pre . \npost where pre . Exp(F, V, Bool) and post . Exp(F, V . {o}, Bool). In other words, if the variables in \nV satisfy the pre-condition pre, then the output variable o should be assigned an expression over these \nvariables such that the post-condition post holds. An example set over the output variable o, denoted \nC(o), is de.ned as the set e of examples {C1, . . . , Cn} such that the conjunction (prei . n posti) \nis satis.able. An expression e is consistent with the example set C(o) iff for all C . C(o), C[o := e] \nis a formula that is valid. Example. Let V = {x, y}, where type(x) and type(y) are both Int. Consider \nthe example set {C1}, where C1 is ((x = 0) . (y = 1)) . (o = 1). The expressions y and x + y are all \nconsistent with C(o), while the expression x is inconsistent, as C1[o := x] is the invalid formula (x \n= 0) . (y = 1) . (x = 1). Now, consider the example set {C1, C2}, where C2 is the ex\u00adample (x = 1) . \n(y = 1) . (o = 2). The expression y is not consistent with the new example set, as C2[o := y] is the \ninvalid formula (x = 1) . (y = 1) . (y = 2); however, the expression x + y is still consistent. The expression \ninference problem can now be stated as: given an expression vocabulary G = (T , F) with a set of variables \nV and an example set C(o) over the typed output variable o, .nd an expression e in Exp(F, V, type(o)) \nwhich is consistent with C(o).  4.2 Inferring Expressions from Concrete Examples e We say that an example \nis concrete if it has the form: ( v.V (v = kv)) . (o = ko), where for all v . V , kv and ko are concrete \nex\u00adpressions1 of types type(v) and type(o), respectively. An example set containing only concrete examples \nis called a concrete example set. An alternative representation for a concrete example is the tu\u00adple \n(S, ko), where S is a valuation function mapping variables in V to values and ko is the concrete value \nfor the output variable o. We use the notation S(e) to denote the evaluation of an expression e for the \nvaluation S for its constituent variables. Checking if an expression e is consistent with a concrete \nexample C is straight\u00adforward: we check if S(e) = ko. Given a concrete example set ConcreteExs = {C1, \n. . . , Cn}, e is consistent with ConcreteExs iff e is consistent with each Ci. The algorithm enumerates \nexpressions inductively until it .nds an expression e that is consistent with ConcreteExs. In the .rst \nstep, only expressions of size one are considered, i.e., variable sym\u00adbols or constants. In the n th \nstep, expressions of size n are obtained by composing expressions obtained in previous steps using func\u00adtions \nin F. As each expression e is enumerated, it is checked for consistency with ConcreteExs. To enhance \nscalability, the algorithm uses the examples to guide the search as well, rather than just to check for \nconsistency. Intu\u00aditively, if two expressions e and e ' evaluate to the same values for each example \nC . ConcreteExs, then only one of e or e ' needs to be carried forward to the next iteration, as the \ninformation encoded in ConcreteExs is insuf.cient to distinguish e and e '. The algorithm exploits this \nproperty to prune the search space of expressions. Let ConcreteExs = {C1, . . . , Cn} be a concrete example \nset. Suppose each Ci is represented as (Si, ki). Then the sig\u00adnature Sig(e, ConcreteExs) of an expression \ne with respect to ConcreteExs is a vector of values (k1, k2, . . . kn), where each ki = Si(e). In other \nwords, the signature of an expression e is the 1 These are constant-valued expressions that do not contain \nvariables. For example, if the only integer-valued constants in F are 0 and 1, then kv is allowed to \nbe the term 2 as an abbreviation for add(1, 1).  Algorithm 2: SolveConcolic Input : A set of concolic \nexamples ConcolicExs over a typed output variable o, an expression vocabulary F and a set of typed variables \nV. Output: An expression e, which is consistent with ConcolicExs. Data : ConcreteExs, a set of concrete \nexamples inferred from ConcolicExs. 1 ConcreteExs . {} 2 while true do 3 e .SolveConcrete (ConcreteExs, \nF, V) 4 if e is consistent with ConcolicExs then 5 return e 6 else 7 foreach C . ConcolicExs such that \n\u00acC[o := e] is satis.able do 8 S . a valuation of variables v . V which satis.es the formula \u00acC[o := e] \n9 ko . a value that satis.es the formula o . post(C[o := ko]) v.V v = S(v) 10 ConcreteExs . ConcreteExs \n. (S, ko) is a set of concolic examples has the form pre . post, where the structure of pre and post \nare unrestricted. Evaluating a candidate expression e is suf.cient to check if e is consistent with respect \nto a given set of concrete examples. However, checking consistency of an expression w.r.t. a concolic \nexample set requires a validity query involving terms from the expression vocabulary. For our expression \nvocabulary we can use a satis.ability modulo theories (SMT) solver to check consistency. We now discuss \nhow we can adapt Algorithm SolveConcrete to infer expressions consistent with respect to a set of concolic \nexam\u00adples. The notion of indistinguishability has been de.ned only with respect to a set of concrete \nexamples. It has no simple analogue with respect to concolic examples. But using indistinguishability \nto prune the search space contributes signi.cantly to the scalability of our enumerative approach, as \nour experiments show in Section 4.4. Thus, it would be desirable to retain the bene.ts of using indistin\u00adguishability \nto prune the search space in the solution for the general problem of inferring an expression consistent \nw.r.t. a set of concolic examples. To this end, the algorithm which we now propose uses a set of concretizations \nof the concolic examples to serve as concrete examples w.r.t. which the search space is pruned. Consider \na concolic example set ConcolicExs over an output variable o and an expression e found to be inconsistent \nwith some concolic example C of the form pre . post. Then there must exist a valuation S over the variables \nv . V which satis.es the formula \u00acC[o := e]. Now, pre must necessarily be satis.able un\u00adder the valuation \n. Let ko be a value which satis.es the formula de S v.V v = S(v) . post(C[o := ko]). The tuple (S, ko) \nis now a concretization of the concolic example C. The proposed algorithm thus maintains a concrete example \nset ConcreteExs containing concretizations of concolic examples C . ConcolicExs. By ensur\u00ading that any \nexpression e ' enumerated henceforth is consistent with ConcreteExs before checking for consistency over \nConcolicExs, the number of expensive SMT queries needed can be reduced. Whenever an expression e ' that \nis consistent with ConcreteExs, but is inconsistent with ConcolicExs is found, additional concretiza\u00adtions \nof the concolic examples are added to ConcreteExs. This technique helps in two ways: (1) the number of \nqueries to an SMT solver is reduced, and (2) the search space can be pruned on the basis of indistinguishability. \nAlgorithm 2, referred to as SolveConcolic, makes use of these pruning strategies. Note that it uses Algorithm \nSolveConcrete as a subroutine. It maintains a set of concrete examples, ConcreteExs 8 9 10 11 12 Algorithm \n1: SolveConcrete Input : A concrete example set ConcreteExs on a typed variable o, an expression vocabulary \n(T , F) and a set of typed variables V. Output: An expression e, which is consistent with ConcreteExs. \nData : The sets ExpSet(t, i), t . T , i . N, denoting sets of expressions of type t and size i, initialized \nto empty sets. A set SigSet which stores the signatures of all enumerated expressions e over ConcreteExs, \ninitially empty. 1 Goal . (k1, k2, . . . , kn), for each Ci = (Si, ki) . ConcreteExs 2 SizeOneExps .. \n3 foreach v . V do 4 SizeOneExps . SizeOneExps . {v} 5 foreach (c . F) . (arity(c) = 0) do 6 SizeOneExps \n. SizeOneExps . {c} 7 foreach e . SizeOneExps do if Sig(e, ConcreteExs) ./SigSet then 13 i . 2 14 while \ntrue do 15 16 17 18 19 20 21 22 23 24 25 SigSet . SigSet . {Sig(e, ConcreteExs)}if Sig(e, ConcreteExs) \n= Goal then return e ExpSet(type(e), 1) . ExpSet(type(e), 1) . {e} foreach f . F do m . arity(f) foreach \npartition p of i - 1 into m-partitions do foreach (e1, e2, . . . , em) . m j=1 ExpSet(argtype(f, j), \npj ) do e . f(e1, e2, . . . , em) if Sig(e, ConcreteExs) ./SigSet then SigSet . SigSet.{Sig(e, ConcreteExs)}if \nSig(e, ConcreteExs) = Goal then return e Add e to ExpSet(type(e), size(e)) vector of values obtained \nby evaluating e over the concrete exam\u00adples. Two expressions e and e ' are said to be indistinguishable \nw.r.t a concrete example set ConcreteExs iff Sig(e, ConcreteExs) = Sig(e ' , ConcreteExs). Example. Consider \nthe expression vocabulary shown in Table 1. Suppose that we wish to describe the expression to compute \nthe maximum of two integers a and b. Consider concrete example C1 = (S1, k1), where S1 is the map (a \n: 5, b : 3, c : 4). Also consider the concrete example C2 = ((a : 3, b : 1, c : 2), k2). Let ConcreteExs \n= {C1, C2}. For expressions e1 = a+b, e2 = b+a, e3 = c + c, the signatures Sig(e1, ConcreteExs) = (8, \n4), Sig(e2, ConcreteExs) = (8, 4), and Sig(e3, ConcreteExs) = (8, 4) are equal. Thus e1, e2, and e3 are \nindistinguishable with respect to ConcreteExs. Note that this implies that larger expres\u00adsions such as \na + (a + b) and a + (c + c) are also indistinguishable w.r.t. ConcreteExs. D Algorithm 1, referred to \nas SolveConcrete, implements the enu\u00admeration based strategy, with the pruning of the search space based \non the notion of indistinguishability, to .nd an expression that is consistent with respect to a given \nset of concrete examples.  4.3 Inferring Expressions from Concolic Examples We now describe an algorithm \nfor the general problem de.ned in Section 4.1, i.e., we relax the restriction that the examples be concrete. \nEach example C . ConcolicExs where ConcolicExs i . i + 1  (a : 0, b : -1, o : 0)a (a : 0, b : 1, o \n: 0) (a : 0, b : 1, o : 1)ite(iszero(dec(b)), b, a) (a : 0, b : 2, o : 0) (a : 0, b : 2, o : 2)ite(gt(b, \na), b, a) Table 2. Illustration of the working of SolveConcrete which are concretizations of examples \nin ConcolicExs and invokes the SolveConcrete algorithm on it. If SolveConcrete .nds an expression e \nwhich is consistent w.r.t. ConcreteExs, the algo\u00adrithm checks if e is consistent w.r.t. ConcolicExs with \na query to an SMT solver. If e is inconsistent with ConcolicExs, then the algo\u00adrithm augments ConcreteExs \nwith new concrete examples as de\u00adscribed earlier and repeats the entire process. Example. To illustrate \nthe working of the algorithm, consider .nd\u00ading an expression for max(a, b), with the expression vocabulary \nin Table 1. We can specify max(a, b) with the concolic example: true . (o = a) . (o = b) . ((o = a) . \n(o = b)) Table 2 shows the expressions that were checked for consistency, the witness for the inconsistency \nof the expression obtained, and the concrete example inferred from the witness. The .rst row of the table \nseeds the set of concrete examples. The subsequent rows indicate the expression queried for symbolic \nvalidity and the con\u00adcrete example inferred. We observe that the expression correspond\u00ading to max(a, \nb) was discovered after making only four calls to the SMT solver, although the algorithm enumerated approximately \n.ve hundred expressions. D  4.4 Evaluation of the Expression Inference Algorithm To evaluate the utility \nof the expression inference algorithm, we fo\u00adcus on the size of the expressions which the algorithm is \nable to compute successfully as a key metric. To benchmark the perfor\u00admance of the algorithm SolveConcrete, \na large number of ran\u00addom expressions of varying sizes were generated. For each expres\u00adsion, a set of \nten concrete examples that were consistent with the expression was generated. For each such concrete \nexample set, the Algorithm SolveConcrete was used to compute an expression that is consistent. Figure \n5 shows that the Pruned variant which prunes the search space using the notion of indistinguishability \n often explores two to three orders of magnitude fewer expressions than the Exhaustive variant which \ndoes not perform any prun\u00ading for expression sizes larger than ten (note the logarithmic scale on the \nY-axis in Figure 5). To evaluate the algorithm SolveConcolic, we used the bench\u00admarks shown in Table \n3. The algorithm computes expressions of up to size 15 within a reasonable amount of time as shown in \nTable 3. The algorithm exceeds our 30 minute time-out on only one bench\u00admark, whose solution has an expression \nsize greater than 20. The right-most column in Table 3 shows that the algorithm reaches the Figure 5. \nAverage number of expressions explored for various ex\u00adpression sizes by the Pruned and Exhaustive variants \nof Algorithm SolveConcrete. We omit data for the Exhaustive variant for sizes greater than 10 where it \nexceeds the memory limit of 3.5 GB. colic examples, each of the form Pre . Post. This is precisely the \nform in which the Algorithm SolveConcolic expects a concolic ex\u00adample and can thus be solved directly \nby the algorithm. We instan\u00adtiate o in Algorithm SolveConcolic with v ' , V with the set of all process \nvariables and incoming message .elds i.e., all the variables which can be read in the current scope and \nConcolicExs with the set of concolic examples provided in the TR A NSI T snippets. 5.2 Computing Guard \nExpressions A guard can be viewed as a Boolean-valued expression. The key difference between computing \nguards and computing update ex\u00adpressions is that for a given control state and input event, guards cannot \nbe computed independently of each other. To ensure that the behavior of the E F S M implementations generated \nby TR A NSI T are deterministic, the computed guards for each control state and input event pair are \nrequired to be pairwise mutually exclusive. To compute guards on transitions from a given state, TRAN \nS I T groups the concolic snippets with the same starting state, input event and next state into one \nguard-action as shown in Figure 4. Therefore, given a starting state and input event, each possible next \nstate has a corresponding guard-action associated with it. Given a set of guard-actions B1, . . . , Bn, \nthe jth guard-action block is a set of examples conditioned by Prej1, . . ., Prejkj . The algorithm for \ncomputing guards sequentially computes the guards for each of the blocks, starting with B1. Thus, before \nsynthesizing the jth guard, it has the guards .1, . . . , .j-1 corresponding to the guard-action blocks \nB1, . . . , Bj-1 available to it. To compute a guard .j for the guard-action block Bj , we observe that \n.j must evaluate to false whenever the guard .i evaluates to true, for any i < j. This property is expressed \nwith the concolic examples: ConcolicExs1 = {.i . \u00ac.j | i < j } Next, .j must evaluate to true whenever \nany of the preconditions Prejl , l . [1, kj ] evaluate to true. This property can be expressed with the \nfollowing concolic example: . . . . kj . . desired solution within a few iterations of the CEGIS outer \nloop. ConcolicExs2 = . . Prejl . . .j . l=1 5. The T R A N S I T Synthesis Tool Also, corresponding \nto each block Bi for which a guard has We now describe the implementation of TR A N S IT, which uses \nthe not yet been synthesized (i.e., i > j ), .j must evaluate to false algorithms described in Section \n4 to generate an implementation of whenever any of preconditions in Bi evaluate to true. This property \nthe protocol from concolic snippets. To this end, TR AN S I T needs to: is expressed with the following \nsymbolic examples ki l=1 (1) compute process-variable update expressions, and (2) compute guards for \ntransitions. ConcolicExs3 = Preil =. \u00ac.j i > j 5.1 Computing Update Expressions TR A N SI T employs \na parallel assignment model, allowing the up-Finally the concolic example set required for inferring \n.j is the date for each primed variable to be computed independently. For union of ConcolicExs1, ConcolicExs2 \nand ConcolicExs3. Again, V each primed variable v ', the TRAN S I T snippets specify a set of con-is \ninstantiated to be the set of all process variables and the incoming # Description Expected Expression \nExp. Size Constraints Time (s) # Iters 1 Max. of a, b ite(gt(a, b), a, b) 6 (a) (a > b) . (o = a); (b \n> a) . (o = b) < 1 1 (b) true . (o = a . o = b . (o = a . o = b)) < 1 2 2 Max. of a, b, c Similar to \n1 15 Similar to 1(a) 536 7 Similar to 1(b) 762 16 3 Sym. Diff. of s1, s2 setunion( setminus(s1, s2), \nsetminus(s2, s1)) 7 true . (o . (s1 . s2); true . (o n (s1 n s2)) = {}; true . (o . (s1 . s2)) = (s1 \n. s2) < 1 2 4 Sym. Diff. of 3 sets Similar to 3 11 Similar to 3 < 1 6 5 Sym. Diff. of 4 sets Similar \nto 3 15 Similar to 3 132 14 6 Conditional Update ite(equals(e, c1), a, b) 6 (e = c1) . (o = a); (e .= \nc1) . (o = b) < 1 4 7 Largest of 2 sets ite(gt(setsize(s1), setsize(s2)), s1, s2) 8 (a) (|s1| > |s2|) \n. (o = s1); (|s2| > |s2|) . (o = s2) < 1 1 (b) true . (|o| = |s1| . |o| = |s2|. (o = s1 . o = s2)) < \n1 2 8 Largest of 3 sets Similar to 7 > 20 Similar to 7(b) TO Table 3. Description of the benchmarks \nused to evaluate the algorithms and experimental results Synthesis Prot-# Sce-Updates Guards State\u00ad ocol \nnarios Num. Exps Time Num. Exps Time Space synth. tried (secs) synth. tried (secs) VI 19 49 449 < 1 17 \n525 < 1 140K MSI 77 157 3330 < 1 45 3710 < 1 854K Table 4. Performance of snippet-based design message \n.elds. o is instantiated to be .j . Algorithm SolveConcolic can now be used to infer the required guard \nexpression .j . 6. Evaluating T R A N S I T To evaluate the proposed approach for specifying protocols \nwith concolic snippets, we describe our experiences in using TR A N S IT to specify some representative \ncache coherence protocols. As the proposed aims to be easy to use, a direct scienti.c comparison with \nexisting approaches is challenging for two reasons: (1) a large user study, besides logistical dif.culty, \npresents the problem of de.ning and extracting meaningful comparative metrics, and (2) a programmer attempting \nthe same problem with two different approaches is subject to a familiarity bias. We instead document \nthe experiences of three different programmers each a co-author of this paper in specifying three coherence \nprotocols of varying complexity (two textbook examples and one industrial strength protocol) with TR \nA N S IT. We summarize the perceived advantages as well as limitations of our approach based on these \nexperiences. All experiments were performed using the expression vocabulary shown in Table 1. We .rst \nvalidated the feasibility of using our expression enu\u00admeration approach by transcribing fully speci.ed \nprotocols from the GEMS simulation toolkit [18] into fully symbolic TR A N S IT snippets. With four cache \nprocesses and one directory, the entire synthesis process took less than a second for each protocol. \nThe key results are summarized in Table 4. 6.1 Case Study A: Non-blocking MSI Protocol. We speci.ed the \nnon-blocking MSI protocol described in the synthesis lectures [25] using concolic snippets in TR A NSI \nT. A non\u00adblocking directory allows a greater number of concurrent requests to be in .ight, requiring \nthe programmer to consider a larger num\u00adber of corner cases due to increased concurrency. The scenarios \ndescribed in the text resulted in a sparse initial set of snippets, as most of the tricky corner cases \nwere either indirectly speci.ed in the textual description or were left unspeci.ed. Hence, the programmer \nadded 67 more snippets over 13 debugging itera\u00adtions before converging to a correct protocol. In each \nsuch iteration, the programmer either added symbolic snippets, when the behavior of the protocol in some \ncorner case was completely unspeci.ed, or concrete snippets, when a speci.cation existed but was incomplete. \nTable 5 summarizes the effort and complexity in this experiment. 6.2 Case Study B: From MSI to MESI \nThe goal of our second case study was to augment the blocking MSI protocol with an E state to arrive \nat the MESI protocol. The E state (shorthand for exclusive) is an optimization that grants read\u00adwrite \npermissions to the .rst reader of an unshared address (i.e., not present in any cache) as opposed to \njust read permission in MSI thereby eliminating coherence traf.c on a subsequent write to the same address. \nThe synthesis lectures [25] describe this protocol in terms of new scenarios and modi.cations to scenarios \nin the MSI protocol. Our approach was to add the corresponding snippets to the existing set of snippets \nused to specify the MSI protocol. Because the examples describe a MESI protocol with a non-blocking directory, \nwe modi.ed our baseline MSI protocol correspondingly. The extended protocol contained .ve new states \n(four for the cache, one for the directory), and seven new message types. In the .rst iteration, we added \n19 snippets to specify transitions in\u00advolving the E state and the non-blocking behavior of the directory. \nThese snippets described the behavior of the protocol in under\u00adspeci.ed corner cases and scenarios involving \ntransient states and were added in response to the errors reported by the model checker. The programmer \nwas able to obtain a fully veri.ed protocol by adding twelve additional snippets over eight iterations. \nAdditional metrics gathered during this case study are presented in Table 5.  6.3 Case Study C: The \nSGI Origin Protocol For our .nal case study, we chose the coherence protocol used in the SGI-Origin 2000 \nservers [16], which is highly cited in the cache coherence literature. The Origin protocol is a directory\u00adbased, \nMESI protocol, and it supports multiple concurrent requests to the same address. Processes communicate \nthrough messages that may be arbitrarily re-ordered in the network. The consequent race conditions made \nit an interesting candidate for this case study.  Laudon and Lenoski [16] describe the common case protocol \nbehavior using request .ows. In this experiment, ignoring the poi\u00adsoned directory state (used for page-migration), \nwe transcribed each of the read, read exclusive, upgrade, and write-back .ows us\u00ading symbolic snippets \nin TRA N S I T. Except for obvious cases, we left most of the guards empty and speci.ed all conditional \nattributes on message .elds and process variables with pre-conditions. The protocol skeleton comprised \nof the cache process and di\u00adrectory processes, four request types, twelve response types, the re\u00adquest \nand response networks, and an intervention network used to buffer intervention requests. We initially \nspeci.ed 56 transitions in the cache machine and 18 transitions in the directory machine. We also speci.ed \nthe guards in instances where the incoming message type was found to be inconsequential; doing so prevented \nthe tool from exploring arti.cially large expressions involving the disjunc\u00adtion of these enumerated \ntypes. The resulting protocol resulted in an error discovered by the model checker due to the cache process \nreceiving an unexpected message. We .xed this case by adding a concrete snippet describing the desired \nbehavior of the cache. Once again we left the guards unspeci.ed, but the pre-conditions and up\u00addate constraints \nwere predicated by identical values for the input message .elds and internal process variables, as seen \nin the violat\u00ading trace. Continuing similarly, we added concrete snippets to .x error traces. In some \ncases, the tool identi.ed inconsistencies between the added trace and a pre-existing constraint. We found \nit straight\u00adforward to reconcile these differences before converging to a proto\u00adcol that model checked. \nThe .nal synthesis step took a little over 30 minutes, exploring over four million states during model \nchecking. The generated TR A NSI T speci.cation had a total of 50 transitions.  6.4 Discussion and Limitations \nWe found the primary convenience of using TRAN S I T to be the manner in which the initial speci.cation \nphase and the iterative debugging phases could be expressed differently. Although it was natural to transcribe \nthe bulk of the protocol symbolically from the algorithmic description of .ows, corner cases invariably \nresulted. Most errors occurred due to unintended interactions between .ows. The unexpected message condition \ncited above resulted from a cache process that was participating in a read-write-back race sce\u00adnario. \nTR ANSI T generalized the concrete .xes provided by the pro\u00adgrammer in a manner that was guaranteed not \nto contradict the con\u00adstituent .ows. Fixing this bug symbolically would have required reasoning about \nthe impact on both these .ows. Similarly, another coherence violation was the result of the sharer set \nin the directory being updated incorrectly when a previous owner was downgraded. Again, the .x involved \nadding a snippet that concretely speci.ed the next contents of the sharer set with the pre-condition \nspecifying only the erroneous case. Similar to other synthesis approaches, one limitation of TR A N -S \nIT is the readability of the produced code. Although expression size might sometimes approximate desirable \nmetrics (like gate count in hardware descriptions), it can result in less intuitive code. For instance, \nconsider the following code generated by TR A N S IT in one of our case studies: SetSize(SetAdd(Sharers, \nInMsg.Sender)) -1 Although this code is more is compact than the equivalent, but more verbose: if-then-else(SetContains(Sharers, \n(InMsg.Sender)), SetSize(Sharers) -1, SetSize(Sharers)) the latter is more intuitive. Similarly, aggressive \ncombining of guard-action blocks sometimes resulted in guard expressions that Case Study A Case Study \nB Snippets in the .rst/last version 19/86 96/108 Writing .rst set of snippets 2 hrs 6 hrs Total manual \neffort 6 hrs 13 hrs Number of iterations 13 8 Number of traces inspected 5 6 Number of updates/guards \ninferred 175/80 260/74 States in veri.ed protocol 1.48M 1.5M Table 5. Effectiveness Metrics for Protocol \nDesign contained conjunctions of several different message types, making the generated code more dif.cult \nto read (although not less ef.cient than what a programmer would write). 7. Related Work Broadly speaking, \nthe topic of this paper can be classi.ed as program synthesis, an active area of research with numerous \nap\u00adproaches. We limit the comparison of our work to those that we feel are most closely related. Methodologically, \nour approach is inspired by program sketch\u00ading [23] and template-guided program synthesis [26]. In such \nap\u00ad proaches, a programmer speci.es the scaffold of a program by list\u00ading the high-level structure, the \nvariables, the functional speci.ca\u00adtion as a pre and post condition, and the form of desired assign\u00adments \ninside the speci.ed structure. The desired expressions are then formalized as terms with unknown parameters, \nwhose values are computed using constraint solving techniques analogous to the ones used for automatic \nderivation of program invariants. The problem of inferring an expression that matches a given set of \nconcrete examples is addressed by the work by Gulwani on a va\u00adriety of domains including end-user spreadsheet \nprogramming [7]. Although they do not use symbolic examples, their strategy for con\u00adcrete examples, based \non version space algebra, is different from the approach we adopt: the algorithm computes a representation \nof the set of all expressions that are consistent with each exam\u00adple, achieves compactness of the representation \nby a judicious use of data structures and pruning based on domain knowledge, and constructs the product \nof all such representations to choose an ex\u00adpression that is consistent with all the examples. The problem \nof inferring expressions consistent with con\u00adcrete and symbolic snippets can be viewed as an instance \nof the counterexample-guided inductive synthesis (CEGIS) strat\u00adegy [8, 13, 23]. As mentioned earlier, \nthe problem is analo\u00adgous to solving an .. formula. The solutions described in prior work [8, 13] explicitly \nencoded the problem into an SMT con\u00ad straint, which was then solved using an SMT solver. The approach \ndescribed in this work uses an enumerative technique to handle the existential quanti.er and uses an \nSMT solver to check for univer\u00adsality. Distributed protocols, such as cache coherence protocols, have \nbeen the canonical application for model checking [3]. In reactive synthesis, a .nite-state controller \nis derived from correctness re\u00adquirements in temporal logic, but this problem becomes undecid\u00adable when \nsynthesizing a distributed protocol (see [28] for a sur\u00ad vey and [6, 21] for recent approaches aimed \nat coping with the high computational complexity of the synthesis problem). An in\u00adteresting recent approach \nto distributed protocol design relies on genetic programming [14]: given an initial protocol and correct\u00ad \nness requirements, if the model checker .nds that the protocol does not satisfy the requirements, the \ntool tries multiple mutations of the guards and updates used in the protocol, ranks the resulting versions \nby estimating how close they are to satisfying the require\u00adments using state-space analysis, and iterates \nby probabilistically selecting a variant with weights proportional to ranks. Note that we require the \nprogrammer to specify the skeleton of the proto\u00adcol (such as control states and state variables), and \nthus we focus not on deriving protocol logic from high-level requirements, but on providing assistance \nto complete the intended design correctly.  8. Conclusions In this paper, we have proposed an approach \nfor specifying dis\u00adtributed protocols by adopting veri.cation tools that interact with the programmer. \nThe approach relies on the observation that parts of the protocol behavior, as well as .xes during the \ndebugging phase, can be naturally expressed in terms of example snippets. We described the concept of \nconcolic snippets to allow a program\u00admer to specify the protocol behavior as a mix of concrete examples \nand symbolic partial transitions. For the computational problem of inferring an expression that is consistent \nwith the given set of con\u00adcolic examples, we presented an algorithm that signi.cantly prunes the space \nof expressions that need to be considered, and also limits the number of calls to an SMT solver needed \nto check consistency with respect to symbolic constraints. To demonstrate the feasibility of our methodology, \nwe developed a prototype tool based on the al\u00adgorithm for expression inference that generates complete \nprotocol speci.cations from concolic snippets, which are then veri.ed using a model checker. Our preliminary \ncase studies using this tool allowed inexpe\u00adrienced programmers to correctly synthesize representative \ncache coherence protocols of modest complexity with several hours of human effort. We were also able \nto translate an incomplete .ow\u00adbased description of an industrial-strength protocol into a working implementation \nby effectively exploiting the .exibility afforded by concolic speci.cations. Encouraged by the initial \nexperimental re\u00adsults, our next steps are to explore techniques to automatically ana\u00adlyze counterexamples \nreturned by the model checker and alternate strategies for expression inference, and synthesizing EFSM \ndescrip\u00adtions from distributed scenarios such as message sequence charts. References [1] Intel Core2 \nExtreme Processor X6800 and Intel Core2 Duo Desk\u00adtop Processor E6000 and E4000 Sequence Speci.cation \nUp\u00addate, 2003. URL http://www.intel.com/design/processor/ specupdt/313279.htm. [2] D. Abts, D. J. Lilja, \nand S. Scott. So Many States, So Little Time: Verifying Memory Coherence in the Cray X1. In Proceedings \nof the International Parallel and Distributed Processing Symposium, IPDPS 03, pages 1 11, 2003. [3] E. \nClarke, O. Grumberg, H. Hiraishi, S. Jha, D. .Long, K. McMillan, and L. Ness. Veri.cation of the Futurebus+ \nCache Coherence Proto\u00adcol. Formal Methods in System Design, 6:217 232, 1995. [4] N. Dave, M. C. Ng, and \nArvind. Automatic Synthesis of Cache-Coherence Protocol Processors Using Bluespec. In Formal Methods \nand Models for Codesign, MEMOCODE 05, pages 25 34, 2005. [5] D. Dill, A. Drexler, A. Hu, and C. Yang. \nProtocol Veri.cation as a Hardware Design Aid. In Proceedings of the International Conference on Computer \nDesign, ICCD 92, pages 522 525, 1992. [6] B. Finkbeiner and S. Jacobs. Lazy Synthesis. In 13th International \nConference on Veri.cation, Model Checking, and Abstract Interpreta\u00adtion, VMCAI 12, LNCS 7148, pages 219 \n234, 2012. [7] S. Gulwani. Automating String Processing in Spreadsheets using Input-output Examples. \nIn Proceedings of The 38th ACM SIG-PLAN/SIGACT Symposium on Principles of Programming Languages, POPL \n11, pages 317 330, 2011. [8] S. Gulwani, S. Jha, A. Tiwari, and R. Venkatesan. Synthesis of Loop\u00adfree \nPrograms. In Proceedings of the 32nd ACM SIGPLAN conference on Programming Language Design and Implementation, \nPLDI 11, pages 62 73, 2011. [9] D. Harel. Can Programming Be Liberated, Period? IEEE Computer, 41(1):28 \n37, Jan. 2008. [10] D. Harel and R. Marelly. Come, Let s Play: Scenario-Based Program\u00adming Using LSCs \nand the Play-Engine. Springer-Verlag New York, 2003. [11] D. Harel, A. Marron, and G. Weiss. Behavioral \nProgramming. Com\u00admunications of the ACM, 55(7):90 100, Jul. 2012. [12] G. J. Holzmann. The Spin Model \nChecker: Primer and Reference Manual. Addison-Wesley, 2003. [13] S. Jha, S. Gulwani, S. A. Seshia, and \nA. Tiwari. Oracle-guided Component-based Program Synthesis. In Proceedings of the 32nd ACM/IEEE International \nConference on Software Engineering -Vol\u00adume 1, ICSE 10, pages 215 224, 2010. [14] G. Katz and D. Peled. \nMCGP: A Software Synthesis Tool Based on Model Checking and Genetic Programming. In 8th Internation Symposium \non Automated Technology for Veri.cation and Analysis, ATVA 10, LNCS 6252, pages 359 364, 2010. [15] V. \nKuncak, M. Mayer, R. Piskac, and P. Suter. Software Synthesis Procedures. Communications of the ACM, \n55(2):103 111, Feb. 2012. [16] J. Laudon and D. Lenoski. The SGI Origin: A ccNUMA Highly Scalable Server. \nIn Proceedings of the 24th Annual International Symposium on Computer Architecture, ISCA 97, pages 241 \n251, 1997. [17] N. A. Lynch. Distributed algorithms. Morgan Kaufmann Publishers Inc., 1996. [18] M. M. \nK. Martin, D. J. Sorin, B. M. Beckmann, M. R. Marty, M. Xu, A. R. Alameldeen, K. E. Moore, M. D. Hill, \nand D. A. Wood. Mul\u00adtifacet s General Execution-driven Multiprocessor Simulator (GEMS) Toolset. SIGARCH \nComputer Architecture News, 33(4):92 99, Nov. 2005. [19] L. D. Moura and N. Bj\u00f8rner. Z3: An Ef.cient \nSMT Solver. In Proceedings of the 14th International Conference on Tools and Al\u00adgorithms for the Construction \nand Analysis of Systems, TACAS 08, pages 337 340, 2008. [20] K. Sen, D. Marinov, and G. Agha. CUTE: A \nConcolic Unit Testing Engine for C. In Proceedings of the 13th ACM SIGSOFT International Symposium on \nFoundations of Software Engineering, FSE 05, pages 263 272, 2005. [21] S. A. Seshia. Sciduction: Combining \nInduction, Deduction, and Struc\u00adture for Veri.cation and Synthesis. In Proceedings of the 49th Annual \nDesign Automation Conference, DAC 12, pages 356 365, 2012. [22] R. Singh and A. Solar-Lezama. Synthesizing \nData Structure Manipu\u00adlations from Storyboards. In Proceedings of the 19th ACM Symposium on Foundations \nof Software Engineering, FSE 11, pages 289 299, 2011. [23] A. Solar-Lezama, R. Rabbah, R. Bodik, and \nK. Ebcioglu. Program\u00adming by Sketching for Bitstreaming Programs. In Proceedings of the SIGPLAN 2005 \nConference on Programming Language Design and Implementation, PLDI 05, pages 281 294, 2005. [24] A. Solar-Lezama, \nC. G. Jones, and R. Bodik. Sketching Concurrent Data Structures. In Proceedings of the SIGPLAN 2008 Conference \non Programming Language Design and Implementation, PLDI 08, pages 136 148, 2008. [25] D. J. Sorin, M. \nD. Hill, and D. A. Wood. A Primer on Memory Consistency and Cache Coherence. Morgan Claypool, 2011. [26] \nS. Srivastava, S. Gulwani, and J. S. Foster. From Program Veri.cation to Program Synthesis. In Proceedings \nof the 37th annual ACM Sym\u00adposium on Principles of Programming Languages, POPL 10, pages 313 326, 2010. \n[27] M. Talupur and M. R. Tuttle. Going with the Flow: Parameterized Veri.cation using Flows: An Industrial \nExperience. In Proceedings of the 2008 Internation Conference on Formal Methods in Computer-Aided Design, \nFMCAD 08, pages 1 8, 2008. [28] W. Thomas. Facets of Synthesis: Revisiting Church s Problem. In Foundations \nof Software Science and Computational Structures, 12th International Conference, FOSSACS 09, LNCS 5504, \npages 1 14, 2009.    \n\t\t\t", "proc_id": "2491956", "abstract": "<p>With the maturing of technology for model checking and constraint solving, there is an emerging opportunity to develop programming tools that can transform the way systems are specified. In this paper, we propose a new way to program distributed protocols using concolic snippets. Concolic snippets are sample execution fragments that contain both concrete and symbolic values. The proposed approach allows the programmer to describe the desired system partially using the traditional model of communicating extended finite-state-machines (EFSM), along with high-level invariants and concrete execution fragments. Our synthesis engine completes an EFSM skeleton by inferring guards and updates from the given fragments which is then automatically analyzed using a model checker with respect to the desired invariants. The counterexamples produced by the model checker can then be used by the programmer to add new concrete execution fragments that describe the correct behavior in the specific scenario corresponding to the counterexample.</p> <p>We describe TRANSIT, a language and prototype implementation of the proposed specification methodology for distributed protocols. Experimental evaluations of TRANSIT to specify cache coherence protocols show that (1) the algorithm for expression inference from concolic snippets can synthesize expressions of size 15 involving typical operators over commonly occurring types, (2) for a classical directory-based protocol, TRANSIT automatically generates, in a few seconds, a complete implementation from a specification consisting of the EFSM structure and a few concrete examples for every transition, and (3) a published partial description of the SGI Origin cache coherence protocol maps directly to symbolic examples and leads to a complete implementation in a few iterations, with the programmer correcting counterexamples resulting from underspecified transitions by adding concrete examples in each iteration.</p>", "authors": [{"name": "Abhishek Udupa", "author_profile_id": "81435608003", "affiliation": "University of Pennsylvania, Philadelphia, PA, USA", "person_id": "P4149023", "email_address": "audupa@seas.upenn.edu", "orcid_id": ""}, {"name": "Arun Raghavan", "author_profile_id": "81416604505", "affiliation": "University of Pennsylvania, Philadelphia, PA, USA", "person_id": "P4149024", "email_address": "arraghav@seas.upenn.edu", "orcid_id": ""}, {"name": "Jyotirmoy V. Deshmukh", "author_profile_id": "81414619509", "affiliation": "University of Pennsylvania, Philadelphia, PA, USA", "person_id": "P4149025", "email_address": "djy@seas.upenn.edu", "orcid_id": ""}, {"name": "Sela Mador-Haim", "author_profile_id": "81100241210", "affiliation": "University of Pennsylvania, Philadelphia, PA, USA", "person_id": "P4149026", "email_address": "selama@seas.upenn.edu", "orcid_id": ""}, {"name": "Milo M.K. Martin", "author_profile_id": "81100426086", "affiliation": "University of Pennsylvania, Philadelphia, PA, USA", "person_id": "P4149027", "email_address": "milom@cis.upenn.edu", "orcid_id": ""}, {"name": "Rajeev Alur", "author_profile_id": "81100359539", "affiliation": "University of Pennsylvania, Philadelphia, PA, USA", "person_id": "P4149028", "email_address": "alur@seas.upenn.edu", "orcid_id": ""}], "doi_number": "10.1145/2491956.2462174", "year": "2013", "article_id": "2462174", "conference": "PLDI", "title": "TRANSIT: specifying protocols with concolic snippets", "url": "http://dl.acm.org/citation.cfm?id=2462174"}