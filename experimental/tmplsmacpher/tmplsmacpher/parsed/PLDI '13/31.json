{"article_publication_date": "06-16-2013", "fulltext": "\n Quipper: A Scalable Quantum Programming Language Alexander S. Green Peter LeFanu Lumsdaine Neil J. \nRoss Dalhousie University Institute of Advanced Studies Dalhousie University agreen@mathstat.dal.ca p.l.lumsdaine@gmail.com \nNeil.JR.Ross@Dal.Ca Peter Selinger Dalhousie University selinger@mathstat.dal.ca Abstract The .eld of \nquantum algorithms is vibrant. Still, there is currently a lack of programming languages for describing \nquantum compu\u00adtation on a practical scale, i.e., not just at the level of toy prob\u00adlems. We address this \nissue by introducing Quipper, a scalable, ex\u00adpressive, functional, higher-order quantum programming language. \nQuipper has been used to program a diverse set of non-trivial quan\u00adtum algorithms, and can generate quantum \ngate representations us\u00ading trillions of gates. It is geared towards a model of computation that uses \na classical computer to control a quantum device, but is not dependent on any particular model of quantum \nhardware. Quip\u00adper has proven effective and easy to use, and opens the door towards using formal methods \nto analyze quantum algorithms. Keywords Quipper; Quantum Programming Languages Categories and Subject \nDescriptors D.3.1 [Programming Lan\u00adguages]: Formal De.nitions and Theory 1. Introduction The earliest \ncomputers, such as the ENIAC and EDVAC, were both rare and dif.cult to program. The dif.culty stemmed \nin part from the need to express algorithms in a vocabulary suited to the particular hardware, ranging \nfrom function tables for the ENIAC to more conventional arithmetic and movement operations for later \nmachines. The introduction of symbolic programming languages such as FORTRAN (for FORmula TRANslator \n) solved a major dif.culty for the next generation of computing devices, by enabling the speci.cation \nof algorithms in a form more suitable for human understanding, and then translating this speci.cation \ninto a form executable by the machine. Thus, programming languages assumed the important role of bridging \na semantic gap between the human and the computing device. This was achieved, among other things, by \ntwo important principles: high-level abstractions and automated bookkeeping. Quantum computation, which \nwas envisioned in the later part of the 20th century, is a computational paradigm based on the laws of \nquantum physics. It has been amply demonstrated in the liter\u00adature that quantum computing can, in theory, \noutperform classical computing for certain classes of computational problems. The de\u00adsign of new quantum \nalgorithms is a vibrant area, as witnessed by the quantum algorithm zoo of S. Jordan [11], which references \nPermission to make digital or hard copies of all or part of this work for personal or classroom use is \ngranted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page. To copy otherwise, to republish, \nto post on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. PLDI \n13, June 16 19, 2013, Seattle, WA, USA. Copyright c &#38;#169; 2013 ACM 978-1-4503-2014-6/13/06. . . \n$15.00 Beno it Valiron University of Pennsylvania benoit.valiron@monoidal.net 45 algorithms and 160 papers, \nwith no less than 14 written in 2011 and 2012. Although quantum computing is not yet ready to move from \nthe\u00adory to practice, it is nevertheless possible to make informed guesses of what form an eventual quantum \ncomputer may take, or more importantly for programming language design, of the interface by which one \nmay interact with such a quantum computer. It seems wise, then, to apply the lessons learned from programming \nclassi\u00adcal computing to the emerging quantum computing capabilities. This paper is a stepping stone towards \nmeeting this challenge. We approach quantum computation from a programmer s perspec\u00adtive: how should \none design a programming language that can im\u00adplement real-world quantum algorithms in an ef.cient, legible \nand maintainable way? We introduce Quipper, a declarative language with a monadic operational semantics \nthat is succinct, expressive, and scalable, with a sound theoretical foundation. When we speak of Quipper \nbeing scalable , we mean that it goes well beyond toy algorithms and mere proofs of concept. Many actual \nquantum algorithms in the literature are orders of magnitude more complex than what could be realistically \nimplemented in pre\u00adviously existing quantum programming languages. We put Quipper to the test by implementing \nseven non-trivial quantum algorithms from the literature: Binary Welded Tree (BWT). To .nd a labeled \nnode in a graph [4].  Boolean Formula (BF). To evaluate a NAND formula [2]. The version of this algorithm \nimplemented in Quipper computes a winning strategy for the game of Hex.  Class Number (CL). To approximate \nthe class group of a real quadratic number .eld [8].  Ground State Estimation (GSE). To compute the \nground state energy level of a particular molecule [23].  Quantum Linear Systems (QLS). To solve a linear \nsystem of equations [9].  Unique Shortest Vector (USV). To choose the shortest vector among a given \nset [17].  Triangle Finding (TF). To exhibit a triangle inside a dense  graph [13]. These algorithms \nwere chosen by IARPA, in the context of its QCS program [10], to provide a reasonably representative \ncross-section of current algorithms. They make use of a wide variety of quan\u00adtum primitives, such as \namplitude ampli.cation, quantum walks, the quantum Fourier transform, and quantum simulation. Several \nof the algorithms also require the implementation of complex clas\u00adsical oracles. The starting point for \neach of our algorithm imple\u00admentations was a detailed description of the algorithm provided by IARPA. \nRelated work. Many formalisms for programming quantum com\u00adputers have been developed in the last few \ndecades. Some of them, such as the quantum Turing machine [6] or the quantum lambda calculus of van Tonder \n[22], are mainly theoretical tools for ex\u00adploring particular aspects of quantum computation, and are \nnot de\u00adsigned with practical quantum programming in mind.  There are many recent proposals for quantum \nprogramming lan\u00adguages [7]. Of these, we pinpoint three languages that represent im\u00adportant milestones \nand can be regarded as predecessors of Quipper. In the realm of imperative programming languages, arguably \nthe oldest concrete quantum programming language is Omer s \u00a8 QCL [16]. De.ned as a C-style language, \nQCL comes with many interesting features, collectively dubbed structured quantum pro\u00adgramming. This provides \na relatively natural way of writing simple quantum algorithms. One of QCL s innovations was the separa\u00adtion \nof functions into separate syntactic classes, based on their operational behavior; thus, QCL distinguishes \nclassical proce\u00addures, which are unconstrained; quantum functions , which are restricted to de.ne unitary \noperations; and pseudo-classical op\u00aderators, which are intended to implement oracles, featuring quan\u00adtum \ntests and automatic uncomputation of ancillas. QCL lacks high-level quantum data types, and does not \nhave a well-de.ned semantics, complicating the analysis of programs. Finally, since the language was \ndesigned with simulation in mind, many of its useful programming features incur a strong computational \nover\u00adhead. In spite of these drawbacks, QCL is a milestone in the de\u00advelopment of quantum programming \nlanguages. We include a very brief comparison between circuits generated by Quipper and QCL in Section \n6. More recently, there have been two proposals for functional quantum programming languages that can \nbe regarded as precur\u00adsors of Quipper. Selinger and Valiron s quantum lambda calculus is an ML-style \nlanguage with strong static type checking [18, 19]. It is designed to run on Knill s QRAM model [12], \nbut lacks high-level facilities for circuit construction and manipulation. The quantum IO Monad of Green \nand Altenkirch [1] is, like Quipper, embedded in Haskell, provides extensible quantum data types, and \ncomes with a consistent operational semantics. However, it uses a much simpler circuit model and lacks \nmany of Quipper s advanced programming features. Outline of the paper. In Section 2, we brie.y present \nquantum computation, focusing particularly on the interface by which soft\u00adware would interact with a \nquantum device. Section 3 covers some of the main techniques that are used to describe quantum algo\u00adrithms \nand hopefully makes the case for a quantum programming language. In Section 4, we introduce Quipper. \nSection 5 discusses our implementation of the Triangle Finding algorithm, and Sec\u00adtion 6 contains a very \nbrief comparison between Quipper and QCL. We summarize our conclusions at the end. 2. Quantum computation \nWe very brie.y summarize some basic notions from quantum com\u00adputation, primarily to provide hints on \nhow a quantum program\u00adming language might interact with a quantum computer. One can\u00adnot really do this \nsubject justice in such a limited space. For a much more thorough introduction to quantum computing, \nsee e.g. [15]. In quantum computation, the storage and manipulation of data is governed by the law of \nquantum physics. We will here be concerned with idealized quantum computation, i.e., we ignore the effects \nof physical imprecisions, decoherence, etc. We will describe an idealized quantum device in terms of \nits state and operations. The state of a quantum system is given by a normalized vec\u00adtor in a Hilbert \nspace. The smallest unit of information in quan\u00adtum computing is the quantum bit or qubit;the state of \none qubit is a complex linear combination of two basis vectors |0) and |1). Similarly, the state of two \nqubits is given as a linear combination of four basis vectors {|00) , |01) , |10) , |11)}, and more generally, \nthe state of n qubits is a linear combination of 2n basis vectors. The available operations are unitary \ntransformations, which allow the state to be transformed along a user-speci.ed unitary map; and measurements, \nwhich are the only way to extract classical informa\u00adtion from a quantum state. We usually assume that \neach quantum device has some built-in set of elementary unitary transformations, called gates. Measurement \nhas a probabilistic behavior: for exam\u00adple, when measuring a qubit in state a |0) + \u00df |1), the result \nwill be 0 with probability |a|2 and 1 with probability |\u00df|2, and subse\u00adquently the state of the qubit \nwill have been changed to |0) or |1), respectively. There is an analogous rule for measuring, say, one \nof several qubits in a multi-qubit state. 2.1 Interacting with a quantum device We can now describe the \noperation of an idealized quantum device known as Knill s QRAM model for quantum computation [12]. In \nthis model, we think of a quantum computer as a specialized device that is attached to and controlled \nby a classical computer, much in the way of a co-processor. The device holds n individually address\u00adable \nqubits, for some .xed n. The operation of the quantum device is controlled by only two kinds of instructions, \nwhich can be in\u00adterleaved. Instructions of the .rst kind are unitary operations. They take the form apply \nthe built-in unitary gate U to qubit k , ap\u00adply the gate V to qubits j and k , and so on. The quantum \ndevice responds with an acknowledgement that the operation has been per\u00adformed, but there is no further \ninformation returned. Instructions of the second kind are measurements. They take the form measure qubit \nk . The quantum device responds with a measurement result, which is either 0 or 1. One can also add a \nthird kind of instruction called initialization: reset qubit k to 0 . However, this is derivable from \nthe instructions already mentioned: namely, by .rst measur\u00ading qubit k, and then negating it if and only \nif the measurement outcome was 1. 2.2 Basic properties In the above model of quantum computation, the \ncontrol .ow of an algorithm is purely classical: tests, loops, etc., are performed on the classical computer \nthat controls the quantum co-processor. Both classical and quantum data are .rst class objects. Because \nquantum measurement is a probabilistic operation, classical probabilistic computation is automatically \nincluded as a subset of quantum computation. The laws of quantum mechanics imply that quantum informa\u00adtion \ncannot be duplicated. This is the so-called no-cloning prop\u00aderty of quantum mechanics. It would not be \nphysically meaning\u00adful, for example, to apply a 2-qubit quantum gate to qubits k and k. Quantum programming \nlanguages should ensure that such non\u00adphysical operations cannot occur. This kind of property can either \nbe checked at compile time or at run time.  2.3 Hardware independence We do not claim that the idealized \nQRAM model is what an actual quantum computer will look like. An actual quantum computer might be far \nmore dif.cult to control. Because of the relatively short life span of quantum states in experimental \nsettings, many layers of quantum error correction and control will likely be required to enable meaningful \nquantum computation. Also, realistic quantum hardware may be highly sensitive to timing constraints, \nsuch as the exact timing of control pulses. So rather than performing one gate or measurement at a time, \nas suggested in the QRAM model, it may be more realistic to assume that a large number of gates will \nbe pre-computed, then executed in a single batch operation on the quantum device, possibly measuring \nall qubits at the end. A sequence of pre-computed gates is called a quantum circuit,and this model of \nquantum computation is known as the circuit model.  One operation that is available in the QRAM model, \nbut not in the circuit model, is the ability to change the sequence of quantum gates in response to the \nresults of previous measurements. This restriction can be overcome by augmenting the circuit model with \nthe ability to preserve some of the unmeasured qubits in some kind of long-term storage between successive \ncircuit executions. From the point of view of programming language design, the particular choice of physical \nquantum architecture should not be of much consequence. The purpose of a high-level programming language \nis precisely to abstract from such hardware speci.c de\u00adtails, and to present the user with the illusion \nof a uniform idealized computational model. 3. Techniques used in quantum algorithms While every quantum \nalgorithm can be ultimately speci.ed as a sequence of gates and measurements, this is rarely how quantum \nalgorithms are actually described in the literature. Rather, they are often described at a high level, \nfor example in the style of: Take the following function, which can obviously be implemented by a boolean \ncircuit of polynomial size. Translate this to a reversible quantum circuit in the standard way. Apply \nm steps of amplitude ampli.cation, then copy the result to a scratch register and un\u00adcompute . We believe \nthat a good quantum programming language should be .exible enough to allow quantum algorithms to be ex\u00adpressed \nat a level of abstraction, high or low, that is as close as possible to the intent of the algorithm s \nhuman designer, while .ll\u00ading in enough details to be unambiguous. For this reason, prior to introducing \nQuipper s high-level programming features in the next section, let us brie.y review some of the techniques \nthat are com\u00admonly used in the design of quantum algorithms. 3.1 Quantum primitives Most quantum algorithms \nmake use of one or more of a few well\u00adknown primitive building blocks. The quantum Fourier transform \nis a unitary change of basis analogous to the classical Fourier trans\u00adform, and is used in many quantum \nalgorithms, for example to .nd the period of a periodic function. Amplitude ampli.cation (also known \nas Grover s search) is used to increase the amplitude of cer\u00adtain basis states in a superposition, while \ndecreasing others. Quan\u00adtum walks can be described as the quantum counterpart to random walks. Due to \nquantum interference, some paths in the walk may cancel out (or at least, appear with decreased probability). \nIn some situations, it is possible to outperform the success probability of a similar strategy that would \nhave used a classical random walk. Phase estimation is a technique for estimating eigenvalues of a uni\u00adtary \noperator. State distillation is a method by which one starts with a large noisy set of quantum states, \nand gradually narrows them down to a smaller cleaner set of states with desirable properties. The above \nprimitives are often at the heart of what makes a quantum algorithm potentially outperform its classical \ncounterpart. But they are more than just off-the-shelf functions that can be directly used on a classical \ndata structure, and they are typically combined in non-trivial ways. 3.2 Oracles Another important part \nof many quantum algorithms is the descrip\u00adtion of an oracle. An oracle is usually given by a classical \nfunc\u00adtion f : Booln . Boolm, describing some aspect of the input to the algorithm, such as the edges \nof a graph, the winning posi\u00adtions of a game, arithmetic or number-theoretic functions, and so forth. \nTo be useable in a quantum computation, the oracle must be made reversible. This can be done by lifting \nthe function, such that a1  b1 a2 b2 a2n b2n r |0 . .  Figure 1. Example of a quantum circuit. Circuits \nare read left to right, with horizontal lines representing wires, boxes representing quantum gates, and \nvertical wires representing controls on a gate. f : Booln+m . Booln+m is de.ned as f (x, y)=(x, y . f(x)). \nThe reversible boolean function f can then be lifted into a unitary map working on quantum bits. Often, \nin the literature, the descrip\u00adtion of oracles is both low-level and high-level. It is low-level in the \nsense that, despite the fact that the oracle manipulates non\u00adtrivial data types (e.g., integers, real \nnumbers, edges of a graph, etc.), the algorithm goes into detail about how to implement these in terms \nof quantum registers. But it is also high-level, in the sense that the details of how the oracle performs \nits operations are often only sketched. 3.3 Circuit families At a low level, quantum algorithms take \nthe form of a (poten\u00adtially very long) sequence of unitary gates with occasional mea\u00adsurements. Such \na sequence of operators is called a quantum circuit and is customarily described in diagrammatic form. \nAn example of such a diagram, showing a diffusion step from the Binary Welded Tree algorithm [4], is \nshown in Figure 1. However, such diagrams are not in and by themselves good descriptions of quantum algo\u00adrithms. \nThe reason is that most quantum algorithms also depend on parameters, such as the number n in Figure \n1, and thus a quan\u00adtum algorithm really describes a family of circuits, which cannot be captured in a \nsingle diagram. Quipper permits a formal and precise description of such parameterized circuit families. \n 3.4 Circuit manipulation Although ultimately, a quantum algorithm comes down to a se\u00adquence of elementary \ngates and measurements, many quantum al\u00adgorithms are more naturally described in terms of manipulations \nat the level of entire sub-circuits, rather than individual gates. Exam\u00adples of such operations are: \n reversing;  iteration (e.g., Trotterization; amplitude ampli.cation);  automatic synthesis of classical \ncircuits (e.g., oracles) and an\u00adcilla management (i.e., initialization and recollection of auxil\u00adiary \nquantum bits);  circuit transformations (e.g., replacing one elementary gate set by another);  whole-circuit \noptimizations.   3.5 Classical processing To be useful, a complete quantum program must ultimately \npro\u00adduce a classical answer to a classical question. In particular, any parameters to the algorithm are \nclassical, as are the .nal outputs. Therefore, most quantum algorithms use some amount of classical pre-and \npost-processing. Typically, the algorithm consists of the description of a parameterized quantum circuit, \nfollowed by a .nal measurement.  In some algorithms, such as the Triangle Finding algorithm, the probabilistic \nmeasurement result can then be classically checked to see if a useful answer has been found, and if not, \nthe whole proce\u00addure is repeated, possibly for a different set of parameters. In some algorithms, such \nas the Binary Welded Tree algorithm, the validity of a potential solution cannot be ef.ciently veri.ed, \nand a statis\u00adtical argument is used to determine how many times the algorithm should be repeated until \nthe correct answer is found with the desired probability. A third class of algorithms, such as the Unique \nShort\u00adest Vector algorithm, requires a more subtle interleaving of quan\u00adtum and classical operations, \nwhereby only a subset of the qubits are measured, and the quantum memory cannot be reset between each \nquantum circuit invocation. In the paradigm of quantum cir\u00adcuits, this amounts to saying that the circuit \nis constructed on-the\u00ad.y, where later pieces depend on the value of former intermediate measurement s. \nThis is typically the case for algorithms that incor\u00adporate state distillation. We learn from this that \na usable quantum programming lan\u00adguage should also incorporate a general-purpose classical program\u00adming \nlanguage, in which classical pre-, post-, and intermediate computations can be speci.ed. It is desirable \nthat the integration between the classical and quantum parts of the language is as seam\u00adless as possible, \nbut that a clear distinction still exists. 4. Our proposal: Quipper We introduce Quipper, an embedded \nfunctional programming lan\u00adguage for quantum computation. Quipper is intended to offer a uni\u00ad.ed general-purpose \nprogramming framework for quantum com\u00adputation. It provides, among other things, a notation for quantum \ncircuits, a notation for quantum algorithms, and a notation for cir\u00adcuit transformations. Quipper was \ndesigned with correctness, scalability and usability in mind. It was originally developed in the context \nof IARPA s Quantum Computer Science program [10]. We have demonstrated Quipper s viability by implementing \nseven non-trivial quantum algorithms from the literature [2, 4, 8, 9, 13, 17, 23], as selected by IARPA \n[10]. In this section, we describe some of the basic features of Quipper s design. this is theoretically \nsuf.cient, we found it to be a cumbersome restriction in practice. Quipper natively supports a larger \nclass of circuits that also includes: Explicit qubit initialization and termination. This is useful, \namong other things, for accurately representing the scope of ancillas.  Measurements, classical bits, \nclassical gates, and classically\u00adcontrolled quantum gates.  4.2.1 Ancillas and scope Many quantum algorithms \nrequire ancillas, i.e., scratch space qubits whose state is (say) |0) outside of certain well-de.ned \nre\u00adgions where the ancilla is being used . In settings where all gates must be unitary, ancillas are \nusually treated as additional global in\u00adputs and outputs to the algorithm, which are assumed to be in \nstate |0) at the start of the algorithm, and which the algorithm is expected to reset to |0) after each \nuse . The following image shows a circuit with two ancillas, and the regions where the ancilla is in \nstate |0)are highlighted: |0 |0 |0 |0 We refer to the regions where an ancilla may potentially be used \nas the scope of the ancilla. For a compiler of quantum programming languages, there are many potential \nbene.ts to tracking the scope of ancillas explicitly. For example, it would be wasteful for error correction \nto be applied to an ancilla while it is known to be un\u00adused (and therefore disentangled from the rest \nof the computation). Moreover, if an algorithm temporarily requires two ancillas at some point in time, \nand then again two ancillas at some later time, it does not actually matter whether the two later ancillas \nare equal to the earlier ancillas, whether they are swapped, or whether they are different ancillas altogether. \nFor example, the following circuit is equivalent to the one above: 4.1 Quipper is an embedded language \nWe implemented Quipper as an embedded language, with Haskell as the host language. Therefore, Quipper \ncan be seen as a collec\u00adtion of data types, combinators, and a library of functions within Haskell, together \nwith an idiom, i.e., a preferred style of writing embedded programs. See [5, Sec. 1.3] for a general \ndiscussion of the advantages and disadvantages of embedded languages in pro\u00adgramming language design. \nWe chose Haskell as the host language because Quipper con\u00adtains many higher-order and overloaded operators, \nwhose imple\u00admentation makes heavy use of advanced features of Haskell s type system, including several \nGHC extensions. Both Haskell and Quip\u00adper are strongly-typed functional programming languages, and therefore \nthey are a relatively good .t for each other. Of course, there are some trade-offs. In particular, Haskell \nlacks two features that would be useful for Quipper: linear types and dependent types. Therefore, certain \nproperties of quantum programs that could be checked at compile time by a linear or dependent type system \nmust currently be checked at run-time. For this reason, a future implementation of Quipper may be equipped \nwith a stand-alone compiler, or at least a custom type-checker.  4.2 Quipper s extended circuit model \nThe quantum circuit model, as usually presented (see e.g. [15, Sec. 4]), is only concerned with unitary \ngates and circuits. While |0 |0 |0 |0 The problem of which particular ancillas to use from a pool of \nancillas is analogous to the classical problem of register allocation, and is best left to a late compiler \nphase that is aware of the layout of physical qubits. In Quipper s circuit model, we use the notation \n0 - to denote the allocation of a new qubit initialized to state |0). Dually, we use the notation 0 to \ndenote the deallocation of a qubit that is asserted to be in stated |0). Here is the same circuit as \nabove, represented with explicitly scoped ancillas: Keeping track of ancilla scopes also has an additional \npossible advantage. In certain physical machine models, such as photonics, it is generally better to \nwork with fresh photons than with pho\u00adtons that have been in a holding loop. This is because photons \nhave a relatively high dissipation rate. Scoped ancillas were used exten\u00adsively in our seven algorithm \nimplementations.   4.2.2 Assertive termination As explained above, the gate - 0 terminates (or deallocates) \na qubit while asserting that it is in state |0). We call this an assertive ter\u00admination, to distinguish \nit from the ordinary termination, denoted - , which simply drops the qubit (therefore resulting in a \npossibly mixed state). The concept of assertive qubit termination warrants some fur\u00adther thoughts. The \n.rst thing to note is that it is the programmer, and not the compiler, who is asserting that the qubit \nis in state |0)before being terminated. In general, the correctness of such an as\u00adsertion depends on \nintricacies of the particular algorithm, and is not something that the compiler can verify automatically. \nIt is therefore the programmer s responsibility to ensure that only correct asser\u00adtions are made. The \ncompiler is free to rely on these assertions, for example by applying optimizations that are only correct \nif the assertions are valid. The second thing to note is that circuits containing qubit ini\u00adtializations \nand assertive terminations can never result in a mixed state, and are, in a suitable sense, unitary and \nreversible. More pre\u00adcisely, where assertive qubit terminations are used in a circuit, they determine \na certain subspace of its domain: namely, the subspace of those states for which the assertions are true. \nDually, the use of qubit initializations determines a certain subspace of the co\u00addomain: namely, the \nsubspace of states that are reachable (or equiv\u00adalently, in the image of the circuit). The circuit then \nde.nes a uni\u00adtary bijection between these two subspaces. In particular, it follows that a circuit using \nn input qubits and n output qubits, and using any number of local ancillas, is unitary (provided, of \ncourse, that all termination assertions are correct, i.e., all ancillas are uncom\u00adputed correctly). For \nthis reason, Quipper will, without complaint, reverse circuits containing qubit initializations and assertive \ntermi\u00adnations.  4.2.3 Mixed classical/quantum circuits In the circuit model used by Quipper, classical \nand quantum data can co-exist. Classical wires (whose state is a classical bit), classi\u00adcal gates, and \nclassically-controlled quantum gates can be freely combined with pure quantum gates. Measurement is a \ngate that turns a qubit into a classical bit. One reason for including these fea\u00adtures is the construction \nof oracles, which we will discuss in more detail in Section 4.6. 4.3 The two run-times 4.3.1 Circuit \ngeneration and circuit execution Because Quipper is (among other things) a circuit description lan\u00adguage, \nQuipper programs have three distinct phases of execution: compile time, circuit generation time, and \ncircuit execution time. We refer to circuit generation time and circuit execution times as the two run-times \n. The phenomenon of having three distinct phases of execution is well-known and also occurs, for example, \nin hardware description languages (see e.g. [5]). 1. Compile time. Since Quipper is an embedded language, \nits compile time is the same as the Haskell compile time. It takes place on a classical computer in an \noff-line development envi\u00adronment (i.e., before speci.c algorithm parameters are known). The input to \nthis phase is source code and compile time param\u00adeters. The output is executable object code. 2. Circuit \ngeneration time. This takes place on a classical com\u00adputer in an on-line environment (i.e., when speci.c \nalgorithm parameters are known). The input to this phase is executable object code and circuit parameters \n(for example, the size of registers, problem sizes, the size of time steps, error thresholds, etc.). \nThe output is a representation of a quantum circuit.  3. Circuit execution time. This takes place on \na physical quantum computer in an on-line real-time environment. The input to this phase is a quantum \ncircuit, and possibly some circuit inputs (for example, qubits fetched from long-term storage to initialize \ncircuit inputs, if supported by the physical device; classical bits to be used as classical circuit inputs). \nThe output consists of circuit outputs (for example, classical bits that are measurement results; qubits \nto be moved to long-term storage, if supported). Many quantum algorithms require an alternation between \nthe second and third phases (circuit generation time and circuit exe\u00adcution time). In this model of execution, \nthe classical controller generates a circuit, sends it to the physical device for execution, awaits measurement \nresults, then generates another circuit, and so on. We note that this is the same as the usual quantum \ncircuit model of computation. If, moreover, the physical quantum device has the ability to preserve qubits \nin long-term storage between real-time circuit invocations, then one can support a more general model \nof computation known in Quipper as dynamic lifting: this allows cir\u00adcuit outputs (for example, the results \nof measurements) to be re\u00adused as circuit parameters (to control the generation of the next part of the \ncircuit). An example of such a model of computation is Knill s QRAM model [12]. We believe that Quipper \ns abstract computational paradigm is general enough to support a variety of such concrete computational \nmodels.  4.3.2 The parameter/input distinction We use the word parameter to refer to a value that is \nknown at circuit generation time, and we use the word input or state to refer to a value that is only \nknown at circuit execution time, i.e., the state of a bit or qubit on the physical quantum device, thought \nof as a wire in a circuit. The distinction between inputs and pa\u00adrameters must be taken seriously and \nrequires special programming language support. For example, because inputs are not known at circuit generation \ntime, if one would like to do an if-then-else op\u00aderation conditioned on a boolean input, then one must \ngenerate the circuit for the then-part and the else-part. On the other hand, if the if-then-else operation \nis conditioned on a boolean parameter,then one only needs to generate the circuit for the then-part or \nthe else\u00adpart, resulting in a smaller circuit. Because of this distinction between generation-time parameters \nand execution-time inputs, the Quipper language has three basic types for bits and qubits, instead of \nthe usual two: Bool:a boolean parameter, known at circuit generation time;  Bit:a boolean input, i.e., \na boolean wire in a circuit;  Qubit:a qubit input, i.e., a quantum wire in a circuit. A Bool is a parameter \nand can be easily converted to a Bit. The outcomes of quantum measurements are only known at circuit \nexecution time, and are therefore Bits, not Bools. As mentioned above, the converse operation, converting \na Bit to a Bool,is known as dynamic lifting in Quipper, and is usually an expensive operation, requiring \ncircuit execution to be suspended while the next part of the circuit is generated. The input/parameter \ndistinction also applies to classical data types other than booleans; for example, there are integer \nparameters and integer inputs. Moreover, some data is partly input and partly parameter. For example, \nif a quantum function inputs a list of qubits, then the length of the list is a parameter (affecting, \nfor example, circuit size), whereas the actual qubits in the list are inputs. In Quipper terminology, \nwhen a piece of data has both input and parameter  components, the parameter component is called the \nshape of the data.   4.4 Circuit description language One can readily imagine a quantum programming \nlanguage that operates by sending gate-by-gate instructions in real time to some physical quantum device. \nIndeed, this was the approach taken in [18, 19]. However, we found that this approach is not very practical \nwhen it comes to implementing larger-scale quantum algorithms. Quantum algorithms in the literature are \noften represented at a rela\u00adtively high conceptual level, and many tasks in algorithm construc\u00adtion require \nmanipulations at the level of entire circuits, rather than individual gates. Examples of such operations \ninclude inversion; iteration; ancilla management; circuit transformations (e.g., replac\u00ading one set of \nbasic gates by another); and whole-circuit optimiza\u00adtion. Another important use of whole-circuit manipulation \nis the automatic generation of reversible circuits from classical code. In our experience, it is perhaps \nfair to say that 99 percent of the quan\u00adtum programmer s task is constructing and manipulating circuits, \nand only 1 percent is actually running them. We therefore designed Quipper with the goal of supporting \nboth gate-level operations and circuit-level operations in a natural way. Quipper combines a basic procedural \nparadigm for writing quantum functions one gate at a time with a powerful higher\u00adorder paradigm for whole-circuit \nmanipulations. 4.4.1 Procedural paradigm The basic philosophy of Quipper s procedural paradigm is that \nqubits are held in variables and gates are applied to them one at a time. Subroutines can be used to \ngroup gate-level operations together where the programmer .nds it useful. When writing such procedural \ncode, the programmer may safely pretend although this is not actually true that the variables hold \nactual physical qubits, and that the speci.ed gates are applied to them in real time. Thus, the basic \nabstraction offered by Quipper is that a quantum operation is a function that inputs some quantum data, \nperforms state changes on it, and then outputs the changed quantum data. This is encapsulated in a Haskell \nmonad called Circ. For example, the following is a simple quantum function that inputs a pair of quantum \nbits, performs some unitary operations (two Hadamard gates and a controlled not-gate), and outputs the \nmodi.ed pair of quantum bits. The code is shown on the left, and the generated circuit is shown on the \nright. mycirc :: Qubit -> Qubit -> Circ (Qubit, Qubit) mycirc a b = do a <-hadamard a b <-hadamard b \n (a,b) <-controlled_not a b return (a,b) Gates can also be written in imperative style , i.e., the return \nvalue of a gate can be ignored if it consists of the same physical qubits as the gate s input. For now, \nthis is just a notational con\u00advention, but it could be formalized through the use of a linear type system \nin a future version of Quipper. 4.4.2 Block structure Quipper provides operators for introducing block \nstructure into circuits. For example, the operator with_controls :: Qubit -> Circ a -> Circ a can be \nused to let an entire block of gates be controlled by a qubit. The example also illustrates how subroutines \n(in this case, mycirc de.ned above) can be used to build up complex circuits from simpler ones. mycirc2 \n:: Qubit -> Qubit -> Qubit -> Circ (Qubit, Qubit, Qubit) mycirc2 a b c = do mycirc a b with_controls \nc $ do mycirc a b mycirc b a mycirc a c return (a,b,c) H H H H H H H H Another block structure operator \nprovided by Quipper is with_ancilla :: (Qubit -> Circ a) -> Circ a. This operator can be used to provide \nan ancilla qubit (tem\u00adporary scratch space) to a block of gates. The ancilla is initially in state |0), \nand the code is expected to return it to state |0) at the end of the block. The following example also \nillustrates the use of the controlled operator, which is an in.x version of with controls. The controls \nare speci.ed to the right of the op\u00aderator, and can be a tuple of qubits. mycirc3 :: Qubit -> Qubit -> \nQubit -> Circ (Qubit, Qubit, Qubit) mycirc3 a b c = do with_ancilla $ \\x -> do qnot x controlled (a,b) \nhadamard c controlled x qnot x controlled (a,b) 0 return (a,b,c)  4.4.3 Circuit operators In addition \nto the gate-by-gate circuit construction paradigm, Quip\u00adper also provides powerful higher-order operators \nthat operate on entire quantum functions. The block-structuring commands of the previous subsection are \nexamples of simple higher-order operators. Other high-level operators provided by Quipper include operators \nfor reversing, iterating, and transforming quantum procedures, as well as a general mechanism for turning \nclassical boolean proce\u00addures into quantum oracles. The reverse simple operator takes a quantum function \nand returns its inverse: timestep :: Qubit -> Qubit -> Qubit -> Circ (Qubit, Qubit, Qubit) timestep a \nb c = do mycirc a b qnot c controlled (a,b) reverse_simple mycirc (a,b) H H H H  return (a,b,c) It \nis important to realize that reversing a circuit is not necessarily an operation to be performed just \non the output of a program (say, by a separate tool). Many quantum algorithms require a circuit to be \nreversed in the middle of a computation, perhaps within a nested subroutine. The operator decompose generic \ndecomposes a quantum cir\u00adcuit into a speci.ed set of elementary gates. The inputs and out\u00adputs of the \ncircuit are unchanged, so the resulting quantum cir\u00adcuit has the same type as the original circuit. The \ndecomposition is achieved by .rst decomposing multiply-controlled gates into Tof\u00adfoli gates, and then \ndecomposing the Toffoli gates into binary gates [15, Sec. 4.3]. For example, the following decomposes \nthe circuit from the previous example into binary gates: timestep2 :: Qubit -> Qubit -> Qubit -> Circ \n(Qubit, Qubit, Qubit) timestep2 = decompose_generic Binary timestep   4.4.4 Boxed subcircuits Quipper \ncircuits can be very large; for example, in Section 5, we use Quipper to describe a circuit of over 30 \ntrillion gates. In order to be able to store and manipulate such large circuits ef.ciently, Quipper provides \na feature called hierarchical circuits or boxed subcircuits. The idea is simple: if a certain subcircuit \nis used multiple times throughout a larger circuit, the programmer has the option to box it. In this \ncase, the subcircuit will be replaced by a single named gate, with a separate de.nition on the side. \nBoxed subcircuits can be nested, leading to a hierarchy of circuits. The Quipper operator for introducing \na boxed subcircuit is called box. It takes a name and a circuit-generating function as its arguments. \nSee Section 5 for examples. 4.4.5 Run functions As we have already seen, in Quipper, the description \nof circuits is separated from what to do with them. Thus, the same subroutine can be used, for example, \nto run a circuit on a quantum device, or to construct and manipulate it in memory. We believe that this \nseparation provides a useful abstraction to programmers. What to do with a circuit is determined by different \nrun func\u00adtions for the Circ monad. For example, the function print gen\u00aderic can be used to print a circuit \nin a number of available output formats (such as text, PostScript, and PDF). Quipper also provides a \nfunction run generic to simulate a circuit (this is necessarily inef.cient on a classical computer). \nThe more specialized func\u00adtions run classical generic and run clifford generic can be used to simulate \ncertain classes of circuits ef.ciently; this is es\u00adpecially useful in testing oracles.  4.5 Quipper \ns extensible quantum data types Following the strategy .rst presented in Altenkirch and Green s work \non the Quantum IO monad [1], Quipper uses Haskell s type classes to provide an abstract view of the notion \nof quantum data. A type class can be thought of as a property that a type may satisfy; the property comes \nwith a set of functions. The strength of type classes is that they can be de.ned by induction on the \nstructure of types. In Quipper, the notion of quantum data is represented by the type class QCData. The \nmost basic members of this type class are Qubit and Bit, representing a quantum bit and a classical bit \nin a circuit, respectively. Expanding on this, tuples of quantum data are quantum data, lists of quantum \ndata are quantum data, and so forth: instance (QCData a, QCData b) => QCData (a,b) where ... instance \n(QCData a) => QCData [a] where ... Quipper also comes with a number of libraries de.ning addi\u00adtional \nkinds of quantum data. For example, there is an arithmetic library that de.nes QDInt, a type of .xed-size \nsigned quantum in\u00adtegers, and a real number library de.ning a type FPReal of .xed\u00adsize, .xed-point real \nnumbers. Certain generic quantum operations can be de.ned at any QCData instance, rather than just qubits. \nFor example, the built-in Quipper function controlled not, which applies a controlled not operation \nto each corresponding pair of qubits from two quantum data structures, has type: controlled_not :: (QCData \nq) => q -> q -> Circ (q, q). Quipper also provides a type class QShape, which takes 3 argu\u00adments and \nrepresents the relationship between the quantum input, classical input, and classical parameter versions \nof a type, as de\u00adscribed in Section 4.3.2. For example, we have instance QShape Bool Qubit Bit instance \n(QShape b q c, QShape b q c ) => QShape (b,b ) (q,q ) (c,c ) instance QShape IntM QDInt CInt Most of \nQuipper s built-in circuit generating functions natively use these representations. For example, the \nfunctions for initializa\u00adtion and measurement of quantum data have the type qinit :: QShape b q c => \nb -> Circ q measure :: QShape b q c => q -> Circ c For example, we can use qinit to create a pair of \nquantum bits: example = do (p,q) <-qinit (False,False) ...  4.6 Oracles in Quipper Although appending \ngates to quantum circuits is an important part of many quantum algorithms, the most challenging part \nfor the quantum programmer and the biggest, in terms of num\u00adber of gates produced is often the implementation \nof classi\u00adcal oracles. Such oracles are boolean functions represented as re\u00adversible quantum circuits. \nThey are problem speci.c and can be quite complicated. For example, Shor s factoring algorithm [21] relies \non an oracle for computing the modular exponentiation f(x)= a x (mod N),where N is the integer to be \nfactored. In the Triangle Finding algorithm, described in more detail in Sec\u00adtion 5 below, an oracle \nis used to de.ne the edges of the graph that is the input to the algorithm. Quipper provides powerful \nfacilities for programming oracles in a natural way. 4.6.1 Automatic generation of quantum oracles The \nimplementation of a quantum oracle by hand usually re\u00adquires four separate steps. The .rst step is to \nexpress the oracle as a classical program acting on classical data types. The second step is to translate \nthis program to a classical circuit for the given input size. The third step is to change the classical \ncircuit to a quantum circuit, possibly introducing many ancillas to hold intermediate or scratch space \nvalues. The fourth step is to make this quantum circuit reversible, using the standard trick of replacing \nthe function x .. f(x) by a reversible function (x, y) .. (x, y . f(x)), while also uncomputing any scratch \nspace used by the function f. In Quipper, all of these steps but the .rst one can be automated. Consider, \nfor example, a very simple oracle that inputs a list of booleans and outputs their parity (even or odd). \nThis can be natu\u00adrally expressed as a functional program: build_circuit f :: [Bool] -> Bool f as = case \nas of [] -> False [h] -> h h:t -> h bool_xor f t The keyword build circuit is built into Quipper (inciden\u00adtally, \nit has been implemented in a very interesting way, using a custom pre-processor and Template Haskell \n[20]). Its purpose is to perform an operation that we call circuit lifting, automating steps 2and 3 above. \nSpeci.cally, the effect of the build circuit key\u00adword is to produce, at compile time, a circuit-generating \nfunction template f in addition to the function f. The type of the func\u00adtion template f is obscure, but \ncan be made useful by passing it through Quipper s unpack operation: unpack template_f :: [Qubit] -> \nCirc Qubit The function template f automatically produces a circuit computing the same operation as f. \nFor example, when applied to a list of 4 qubits, it produces:  3 4 4 5 6 7 8 Note how the top four \nqubits are the inputs, the bottom qubit is x[3] the output, and the remaining two qubits are scratch \nspace. Fi\u00adnally, the fourth step, to make the circuit reversible and uncom\u00adpute the scratch space, is \ntaken care of by the Quipper operator classical to reversible:  classical_to_reversible :: (a -> Circ \n(Datable a, b) -> (a,b) QCData b) => -> Circ (a,b) Figure 2. The circuit for o4 POW17 For example, here \nis the circuit produced by classical_to_reversible (unpack template_f): Simulate:a test suite for the \noracle.  Note that in this circuit, the top four qubits are inputs, the .fth qubit is the output, and \nall intermediate ancillas have been uncomputed. Quipper s circuit lifting operation is extremely versatile. \nWe have used it to implement oracles containing millions of gates. For example, our implementation of \nthe Boolean Formula algorithm uses an oracle that determines the winner for a given .nal position in \nthe game of Hex. It uses a .ood-.ll algorithm, which we imple\u00admented as a functional program and converted \nto a circuit using the circuit lifting operation. The resulting oracle consists of 2.8 million gates. \nSimilarly, our implementation of the Linear Systems algo\u00adrithm makes liberal use of arithmetic and analytic \nfunctions, such as sin(x) and cos(x), which were implemented using the circuit lifting feature. The circuit \ncreated for sin(x), over a 32+32 qubit .xed-point argument, uses 3273010 gates. 5. The Triangle Finding \nalgorithm in Quipper We give some details of our implementation of the Triangle Finding algorithm in \nQuipper. 5.1 Background An instance of the Triangle Finding problem [3,14] is givenbyan undirected simple \ngraph G containing exactly one triangle ..The graph is given by an oracle function f, such that, for \nany two nodes v, w of G, f(v, w)= 1 if (v, w) is an edge of G and f(v, w)= 0 otherwise. To solve an instance \nof the Triangle Finding problem is to .nd the set of vertices {e1,e2,e3} forming . by querying f. The \nTriangle Finding algorithm, as described in [14] and [3], works by performing a Grover-based quantum \nwalk on a larger graph H, called the Hamming graph associated to G. It is designed to .nd . with high \nprobability. The algorithm is parametric on an oracle de.ning the graph G. In our implementation, the \noracle is a changeable part, but we have implemented a particular pre-de.ned oracle speci.ed by the QCS \nprogram. This oracle injects G into the space {0, 1, ..., 2l - 1} of l-bit integers, and each oracle \ncall requires the extensive use of modular arithmetic. The overall algorithm is parameterized on integers \nl, n and r specifying respectively the length l of the integers used by the oracle, the number 2n of \nnodes of G and the size 2r of Hamming graph tuples. 5.2 Top-level structure The Quipper implementation \nof the Triangle Finding algorithm is broken down into six modules: Definitions: global de.nitions used \nthroughout the algo\u00adrithm.  QWTFP: the quantum walk algorithm and its subroutines.  Oracle: the oracle \nand its subroutines.  Main:a command line interface.  Alternatives: alternatives and/or generalization \nof certain algorithms. These can be compiled into an executable program tf.Its com\u00admand line interface \nallows the user, for example, to plug in different oracles, show different parts of the circuit, select \na gate base, select different output formats, and select parameter values for l, n and r. Some usage \nexamples are provided throughout the remainder of this section as we discuss our implementation.  5.3 \nCode samples The quantum walk part of the algorithm is broken into about 20 subroutines, and the oracle \nconsists of 8 subroutines. For brevity, we only present the code for one of each: o4_POW17 and a6_QWSH. \nAlthough relatively simple, these subroutines are good illustrations of some of Quipper s key features. \n 5.3.1 The subroutine o4 POW17 The subroutine o4_POW17 is an arithmetic function used by the oracle. \nIt computes the seventeenth power of a quantum integer and stores the result in a fresh integer register. \nIt proceeds by .rst raising its input x to the 16th power by repeated use of a squaring subroutine, and \nthen multiplies x and x 16 to get the desired result. In the following Quipper code, QIntTF denotes the \ntype of quantum integers used by the oracle, which happen to be l-bit integers with arithmetic taken \nmodulo 2l - 1 (not 2l): o4_POW17 :: QIntTF -> Circ (QIntTF,QIntTF) o4_POW17 = box \"o4\" $ \\x -> do comment_with_label \n\"ENTER: o4_POW17\" x \"x\" (x, x17) <-with_computed_fun x (\\x -> do (x,x2) <-square x (x2,x4) <-square x2 \n(x4,x8) <-square x4 (x8,x16) <-square x8 return (x,x2,x4,x8,x16)) (\\(x,x2,x4,x8,x16) -> do (x,x16,x17) \n<-o8_MUL x x16 return ((x,x2,x4,x8,x16),x17)) comment_with_label \"EXIT: o4_POW17\" (x,x17) (\"x\",\"x17\") \nreturn (x, x17) We note the use of the pre-de.ned Quipper operators box, com\u00adment with label and with_computed_fun. \nThe operator box introduces a boxed subcircuit. The operator comment_with_label inserts a comment and \nsome qubit labels in the generated circuits. Such comments have proven to be quite useful in reading \nlarge cir\u00adcuits. The operator with_computed_fun automates the reversing of intermediary computations: \nthe .rst block of code (in this case, applications of square producing x 2 ,x 4 ,x 8 and x 16)isreversed \nonce the second block of code (here o8_MUL)has been applied. Because the uncomputation of intermediate \nresults is such a com\u00admon operation in quantum computing, the use of operators like with_computed_fun \nhelps to avoid unnecessar y and error-prone code repetitions. All three of these Quipper features can \nbe seen in  ENTER: o7_ADD_controlled ctrl ctrl ctrl EXIT: o7_ADD_controlled ENTER: double_TF EXIT: \ndouble_TF EXIT: double_TF* ENTER: double_TF* EXIT: o7_ADD_controlled* ctrl ctrl ctrl ENTER: o7_ADD_controlled* \n 0 0 0 0 6 7 8 5 0 0 0 0 y[3] y[2] y[1] y[0] x[3] x[2] x[1] x[0] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 y[3] y[2] y[1] y[0] x[3] x[2] x[1] x[0] s[0] s[1] s[2] \ns[3] x[3] x[2] x[1] x[0] x[0] x[3] x[2] x[1] y[0] y[3] y[2] y[1] x[0] x[1] x[2] x[3] 0 0 0 0 0 0 0 0 \n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 y[0] y[3] y[2] y[1] x[0] x[1] x[2] \nx[3] s[0] s[1] s[2] s[3] x[0] x[3] x[2] x[1] x[1] x[0] x[3] x[2] y[1] y[0] y[3] y[2] x[0] x[1] x[2] x[3] \n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 y[1] y[0] y[3] y[2] \nx[0] x[1] x[2] x[3] s[0] s[1] s[2] s[3] x[1] x[0] x[3] x[2] x[2] x[1] x[0] x[3] y[2] y[1] y[0] y[3] x[0] \nx[1] x[2] x[3] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 y[2] \ny[1] y[0] y[3] x[0] x[1] x[2] x[3] s[0] s[1] s[2] s[3] x[2] x[1] x[0] x[3] x[3] x[2] x[1] x[0] 0 0 0 \n0 x[3] x[2] x[1] x[0] x[2] x[1] x[0] x[3] y[2] y[1] y[0] y[3] x[0] x[1] x[2] x[3] s[0] s[1] s[2] s[3] \n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 y[2] y[1] y[0] y[3] \nx[0] x[1] x[2] x[3] x[2] x[1] x[0] x[3] x[1] x[0] x[3] x[2] y[1] y[0] y[3] y[2] x[0] x[1] x[2] x[3] s[0] \ns[1] s[2] s[3] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 y[1] \ny[0] y[3] y[2] x[0] x[1] x[2] x[3] x[1] x[0] x[3] x[2] x[0] x[3] x[2] x[1] y[0] y[3] y[2] y[1] x[0] x[1] \nx[2] x[3] s[0] s[1] s[2] s[3] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \n0 0 0 0 0 0 y[0] y[3] y[2] y[1] x[0] x[1] x[2] x[3] x[0] x[3] x[2] x[1] x[3] x[2] x[1] x[0] y[3] y[2] \ny[1] y[0] x[3] x[2] x[1] x[0] s[0] s[1] s[2] s[3] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 y[3] y[2] y[1] y[0] x[3] x[2] x[1] x[0] 0 0 0 0 0 0 0 0 6 7 8 9 10 11 \n12 5 Figure 3. The circuit for o8 MUL with_computed_fun (tt,i,v,ee,ttd,eed) the circuit for o4_POW17 \nwith parameter values l =4,n =3 and (\\(tt,i,v,ee,ttd,eed) -> do r =2 shown in Figure 2. This circuit \nis produced by the command (i,tt,ttd) <-qram_fetch qram i tt ttd line ./tf -s pow17 -l 4 -n 3 -r 2. (i,ee,eed) \n<-a12_FetchStoreE i ee eed We note that some of the circuits shown here have too many (tt,ttd,eed) <-a13_UPDATE \noracle tt ttd eed gates to be legible in a printed version of this paper; however, in (i,tt,ttd) <-qram_store \nqram i tt ttd the PDF version, it is possible to zoom in to see individual gates. return (tt,i,v,ee,ttd,eed)) \nIn the circuit in Figure 2, the vertical strings of squares marked o8 represent invocations of a boxed \nsubcircuit. Each of them de-(\\(tt,i,v,ee,ttd,eed) -> do notes an invocation of the subroutine o8_MUL \nfor multiplication, or (ttd,v) <-a14_SWAP ttd v return ((tt,i,v,ee,ttd,eed),())) its inverse. The full \nde.nition of o8_MUL is shown in Figure 3. It is possible to inline the boxed subcircuits within o4_POW17, \ncomment_with_label \"EXIT: a6_QWSH\" but the resulting circuit would be too large to be usefully included \n(tt, i, v, ee) (\"tt\", \"i\", \"v\", \"ee\") here. However, we can use Quipper s gate counting feature to pro\u00ad \nreturn (tt,i,v,ee) vide some statistics about this circuit. The is done via the command Here, the Quipper \noperator with_ancilla_init creates a list line option -f gatecount. It will compute a gate count for \neach of n ancillas, whose scope is restricted to a local block of code. The boxed subcircuit called by \no4_POW17, together with an aggregated circuit for a6_QWSH with parameter values l =4,n =3 and r =2gate \ncount for the circuit with all boxed subcircuits inlined. For is:l =4, n =3, r =2, the aggregated gate \ncount for o4_POW17 is: Subroutine a6: Aggregated gate count: ENTER: a6_QWSH ENTER: a14_SWAP EXIT: a14_SWAP \nEXIT: a6_QWSH tt[0,0] tt[0,1] tt[0,0] tt[0,1] a8 3 a13 1 a9 3 a9 3* a13 1* a8 3* a9 4* a13 2* a8 4* 1 \na8 4 a13 2 a9 4 a8 5 a13 3 a9 5 2 1636: \"Init0\" tt[0,2] tt[0,2] a9 5* a13 3* a8 5*3 3484: \"Not\", controls \n1 288: \"Not\" controls 1+1 2592: \"Not\", controls 2 1632: \"Term0\" Total gates: 9632 Inputs: 4 Outputs: \n8 Qubits in circuit: 71 In words, this circuit has 4 inputs, 8 outputs, and uses a total of 71 qubits \n(including ancillas) and 9632 elementary gates. Of these gates, about one third are qubit initializations \nand terminations, and the remainder are controlled-not gates with 1 or 2 controls. In gate counts provided \nby Quipper a distinction is made between positive and negative controls. If a gate G has a positive controls \n( .lled dots ) and b negative controls ( empty dots ), the gate count will read: \"G\", controls a+b. Moreover, \na+0 is written a.  5.3.2 The subroutine a6 QWSH The subroutine a6_QWSH implements a walk step on the \nHamming graph. By de.nition, the nodes of the Hamming graph associated to G are tuples of nodes of G, \nsuch that two such tuples are adjacent if they differ in exactly one coordinate. a6_QWSH proceeds in \ntwo steps. In the .rst step, it arbitrarily chooses an index i and a node v of G. In the second step, \nit replaces a Hamming tuple T by an adjacent one T ' by swapping the i-th component of T with v,and updates \nthe register containing the edge information concerning nodes in T '. The corresponding Quipper code \nis the following: a6_QWSH :: QWTFP_spec -> (IntMap QNode) -> QDInt -> QNode -> (IntMap (IntMap Qubit)) \n-> Circ (IntMap QNode, QDInt, QNode, IntMap (IntMap Qubit)) a6_QWSH oracle@(n,r,edgeOracle,qram) = box \n\"a6\" $ \\tt i v ee -> do comment_with_label \"ENTER: a6_QWSH\" (tt, i, v, ee) (\"tt\", \"i\", \"v\", \"ee\") with_ancilla_init \n(replicate n False) $ \\ttd -> do with_ancilla_init (intMap_replicate (2^r) False) $ \\eed -> do (i,v) \n<-a7_DIFFUSE (i,v) ((tt,i,v,ee,ttd,eed),_) <\u00ad tt[1,0] tt[1,0] 4 a8 6 a13 4 a9 6 a9 6* a13 4* a8 6* 4 \ntt[1,1] tt[1,1] 5 a8 7 a13 5 a9 7 a9 7* a13 5* a8 7* 5 tt[1,2] tt[1,2] 6 a8 8 a13 6 a9 8 a9 8* a13 6* \na8 8* 6 tt[2,0] tt[2,0] 7 a8 9 a13 7 a9 9 a9 9* a13 7* a8 9* 7 tt[2,1] tt[2,1] 8 a8 10 a13 8 a9 10 a9 \n10* a13 8* a8 10* 8 tt[2,2] tt[2,2] 9 a8 11 a13 9 a9 11 a9 11* a13 9* a8 11* 9 tt[3,0] tt[3,0] 10 a8 \n12 a13 10 a9 12 a9 12* a13 10* a8 12* 10 tt[3,1] tt[3,1] 11 a8 13 a13 11 a9 13 a9 13* a13 11* a8 13* \n11 tt[3,2] tt[3,2] 12 a8 14 a13 12 a9 14 a9 14* a13 12* a8 14* 12 i[1] i[1] 13 a7 1 a8 1 a12 1 a9 1 a9 \n1* a12 1* a8 1* 13 i[0] i[0] 14 a7 2 a8 2 a12 2 a9 2 a9 2* a12 2* a8 2* 14 v[0] r[0] r[0] v[0] 15 a7 \n3 15 v[1] r[1] r[1] v[1] 16 a7 4 16 v[2] r[2] r[2] v[2] 17 a7 5 17 ee[1,0] ee[1,0] 18 a12 3 a12 3* 18 \nee[2,0] ee[2,0] 19 a12 4 a12 4* 19 ee[2,1] ee[2,1] 20 a12 5 a12 5* 20 ee[3,0] ee[3,0] 21 a12 6 a12 6* \n21 ee[3,1] ee[3,1] 22 a12 7 a12 7* 22 ee[3,2] ee[3,2] 23 a12 8 a12 8* 23 q[0] q[0] a8 15 a13 13 a9 15 \na9 15* a13 13* a8 15* 0 0 q[1] q[1] a8 16 a13 14 a9 16 a9 16* a13 14* a8 16* 0 0 q[2] q[2] a8 17 a13 \n15 a9 17 a9 17* a13 15* a8 17* 0 0 a12 9 a13 16 a13 16* a12 9* 0 0 a12 10 a13 17 a13 17* a12 10* 0 0 \na12 11 a13 18 a13 18* a12 11* 0 0 a12 12 a13 19 a13 19* a12 12* 0 0 In this circuit, the .rst boxed subcircuit \ncorresponds to the dif\u00adfusion of the index i and node v. The remaining boxed subcircuits denote the qRam \noperations before and after the node swap.  5.4 Aggregate gate counts The command line ./tf -f gatecount \n-O -o orthodox -l 31 -n 15 -r 9 computes the gate count for just the oracle, with parameter values n \n=15, l =31 and r =9. It counts 2051926 total gates and 1462 qubits. The command line ./tf -f gatecount \n-o orthodox -l 31 -n 15 -r 6 produces the gate counts for the complete algorithm, including repeated \nquantum walk steps with inlined oracle invocations. On a standard laptop, this runs to completion in \nunder two minutes and produces a count of 30189977982990 (over 30 trillion) total gates and 4676 qubits. \n6. Comparing Quipper and QCL To enable a direct comparison between Quipper and QCL, we im\u00adplemented identical \nversions of the Binary Welded Tree algorithm [4] in both programming languages, using a hand-coded oracle. \nFor further comparison, we also gave a second implementation of an equivalent oracle, using Quipper s \nbuild circuit mechanism to automatically generate the (non-optimized) oracle from classical functional \ncode as explained in Section 3.2. We generated the main circuit for the BWT algorithm for each of the \nthree different imple\u00admentations, using the same parameters in each case. The results are summarized \nin the following table. QCL direct Quipper orthodox Quipper template Init 58 313 777 Not 746 8 0 CNot1 \n9012 472 344 CNot2 7548 768 1760 e -itZ 44 4 W 48 48 48 Term 0 307 771 Meas 0 6 6 Total 17358 1300 2156 \nQubits 58 26 108 Here Init , Term , and Meas refer to Quipper s qubit initial\u00adization, termination, and \nmeasurement gates. These are not directly comparable between QCL and Quipper, because Quipper explicitly \ntracks the scope of ancillas whereas QCL does not. Total refers to the total number of logical gates \nexcluding initialization, termi\u00adnation, and measurement. Qubits refers to the total number of qubits \nused in each circuit, i.e., the height of the circuit. It is apparent that the QCL code produces far \nmore gates than its Quipper counterpart, even when the hand-coded oracle in QCL is compared to the automatically \ngenerated oracle in Quipper. More\u00adover, the QCL circuit uses twice as many qubits as the Quipper ver\u00adsion \nwith the same oracle. On the other hand, the Quipper imple\u00admentation with automatically generated oracle \nuses more ancillas than QCL, but does so with fewer gates. 7. Conclusion We have presented Quipper, a \nscalable functional quantum pro\u00adgramming language. We demonstrated its usability by implement\u00ading seven \nnon-trivial quantum algorithms, chosen to represent a broad range of quantum computing capabilities. \nThe algorithms were implemented by a team of 11 geographically distributed Quip\u00adper programmers. Programming \nthe seven algorithms required ap\u00adproximately 55 man months and resulted in a representation usable for \nresource estimation using realistic problem sizes. On this basis we conclude that Quipper is both usable \nand useful. One of the issues left for future work in Quipper is the improve\u00adment of compile-time type \nchecking. Thanks to its Haskell imple\u00admentation, Quipper already catches many ordinary type errors at \ncompile time. However, in the absence of a linear type system, cer\u00adtain properties, such as non-duplication \nof quantum data, must be checked at runtime. Developing a fully-featured type system is the next step \nin Quipper s development, and is a work in progress. 8. Acknowledgements Thanks to Jonathan M. Smith \nfor his helpful comments. Supported by the Intelligence Advanced Research Projects Ac\u00adtivity (IARPA) \nvia Department of Interior National Business Center contract number D11PC20168. The U.S. Government is \nauthorized to reproduce and distribute reprints for Governmental purposes notwithstanding any copyright \nannotation thereon. Disclaimer: The views and conclusions contained herein are those of the authors and \nshould not be interpreted as necessarily representing the of.cial policies or endorsements, either expressed \nor implied, of IARPA, DoI/NBC, or the U.S. Government. Supported by NSERC. References [1] T. Altenkirch \nand A. S. Green. The Quantum IO Monad. In S. Gay and I. Mackie, editors, Semantic Techniques in Quantum \nComputation, pages 173 205. Cambridge University Press, 2009. [2] A. Ambainis, A. M. Childs, B. Reichardt, \nR. .Spalek, and S. Zhang. 1 +o(1) Any AND-OR formula of size n can be evaluated in time n 2 on a quantum \ncomputer. SIAM J. Comput., 39:2513 2530, 2010. [3] A. Childs and R. Kothari. Quantum query complexity \nof minor\u00adclosed graph properties. In Proceedings of the 28th Symposium on Theoretical Aspects of Computer \nScience, pages 661 672, 2011. [4] A. M. Childs, R. Cleve, E. Deotto, E. Farhi, S. Gutmann, and D. A. \nSpielman. Exponential algorithmic speedup by a quantum walk. In Proceedings of the Thirty-Fifth Annual \nACM Symposium on Theory of Computing, pages 59 68, 2003. [5] K. Claessen. Embedded Languages for Describing \nand Verifying Hardware. PhD thesis, Chalmers University of Technology and G\u00a8oteborg University, 2001. \n[6] D. Deutsch. Quantum theory, the Church-Turing principle and the universal quantum computer. Proceedings \nof the Royal Society of London, Series A, 400(1818):97 117, 1985. [7] S. J. Gay. Quantum programming \nlanguages: Survey and bibliography. Mathematical Structures in Computer Science, 16(04):581 600, 2006. \n[8] S. Hallgren. Polynomial-time quantum algorithms for Pell s equation and the principal ideal problem. \nJ. ACM, 54(1):4:1 4:19, Mar. 2007. [9] A. W. Harrow, A. Hassidim, and S. Lloyd. Quantum algorithm for \nlinear systems of equations. Phys. Rev. Lett., 103(15):150502, 2009. [10] IARPA Quantum Computer Science \nProgram. Broad Agency Announcement IARPA-BAA-10-02. Available from https://www.fbo.gov/notices/637e87ac1274d030ce2ab69339ccf93c, \nApril 2010. [11] S. Jordan. http://math.nist.gov/quantum/zoo/. Electronic resource. [12] E. H. Knill. \nConventions for quantum pseudocode. LANL report LAUR-96-2724, 1996. [13] F. Magniez, M. Santha, and M. \nSzegedy. Quantum algorithms for the triangle problem. quant-ph/0310134, 2003. [14] F. Magniez, M. Santha, \nand M. Szegedy. Quantum algorithms for the triangle problem. In Proceedings of the 16th annual ACM-SIAM \nsymposium on Discrete algorithms, pages 1109 1117, 2005. [15] M. A. Nielsen and I. L. Chuang. Quantum \nComputation and Quantum Information. Cambridge University Press, 2002. \u00a8 Information Systems, Technical \nUniversity of Vienna, 2000. [16] B. Omer. Quantum programming in QCL. Master s thesis, Institute of [17] \nO. Regev. Quantum computation and lattice problems. SIAM J. Comput., 33(3):738 760, 2004. [18] P. Selinger \nand B. Valiron. A lambda calculus for quantum compu\u00adtation with classical control. Mathematical Structures \nin Computer Science, 16(3):527 552, 2006. [19] P. Selinger and B. Valiron. Quantum lambda calculus. In \nS. Gay and I. Mackie, editors, Semantic Techniques in Quantum Computation, pages 135 172. Cambridge University \nPress, 2009. [20] T. Sheard and S. Peyton Jones. Template metaprogramming for Haskell. In Proc. Haskell \nWorkshop, 2002. [21] P. Shor. Algorithms for quantum computation: discrete logarithms and factoring. \nIn Proceedings, 35th Annual Symposium on Foundations of Computer Science. CA: IEEE Press, 1994. [22] \nA. van Tonder. A lambda calculus for quantum computation. SIAM Journal of Computing, 33(5):1109 1135, \n2004. [23] J. D. Whit.eld, J. Biamonte, and A. Aspuru-Guzik. Simulation of electronic structure Hamiltonians \nusing quantum computers. Molecu\u00adlar Physics, 109(5):735 750, 2011.     \n\t\t\t", "proc_id": "2491956", "abstract": "<p>The field of quantum algorithms is vibrant. Still, there is currently a lack of programming languages for describing quantum computation on a practical scale, i.e., not just at the level of toy problems. We address this issue by introducing Quipper, a scalable, expressive, functional, higher-order quantum programming language. Quipper has been used to program a diverse set of non-trivial quantum algorithms, and can generate quantum gate representations using trillions of gates. It is geared towards a model of computation that uses a classical computer to control a quantum device, but is not dependent on any particular model of quantum hardware. Quipper has proven effective and easy to use, and opens the door towards using formal methods to analyze quantum algorithms.</p>", "authors": [{"name": "Alexander S. Green", "author_profile_id": "81375610288", "affiliation": "Dalhousie University, Halifax, NS, Canada", "person_id": "P4149045", "email_address": "agreen@mathstat.dal.ca", "orcid_id": ""}, {"name": "Peter LeFanu Lumsdaine", "author_profile_id": "81759013357", "affiliation": "Institute of Advanced Studies, Princeton, NJ, USA", "person_id": "P4149046", "email_address": "p.l.lumsdaine@gmail.com", "orcid_id": ""}, {"name": "Neil J. Ross", "author_profile_id": "81502699153", "affiliation": "Dalhousie University, Halifax, NS, Canada", "person_id": "P4149047", "email_address": "Neil.JR.Ross@Dal.Ca", "orcid_id": ""}, {"name": "Peter Selinger", "author_profile_id": "81100088668", "affiliation": "Dalhousie University, Halifax, NS, Canada", "person_id": "P4149048", "email_address": "selinger@mathstat.dal.ca", "orcid_id": ""}, {"name": "Beno&#238;t Valiron", "author_profile_id": "81430646806", "affiliation": "University of Pennsylvania, Philadelphia, PA, USA", "person_id": "P4149049", "email_address": "benoit.valiron@monoidal.net", "orcid_id": ""}], "doi_number": "10.1145/2491956.2462177", "year": "2013", "article_id": "2462177", "conference": "PLDI", "title": "Quipper: a scalable quantum programming language", "url": "http://dl.acm.org/citation.cfm?id=2462177"}