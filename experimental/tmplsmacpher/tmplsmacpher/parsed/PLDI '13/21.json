{"article_publication_date": "06-16-2013", "fulltext": "\n Reasoning about Nondeterminism in Programs Byron Cook Eric Koskinen * Microsoft Research Cambridge \nNew York University &#38; University College London Abstract Branching-time temporal logics (e.g. CTL, \nCTL * , modal \u00b5\u00adcalculus) allow us to ask sophisticated questions about the nonde\u00adterminism that appears \nin systems. Applications of this type of rea\u00adsoning include planning, games, security analysis, disproving, \npre\u00adcondition synthesis, environment synthesis, etc. Unfortunately, ex\u00adisting automatic branching-time \nveri.cation tools have limitations that have traditionally restricted their applicability (e.g. push-down \nsystems only, universal path quanti.ers only, etc). In this paper we introduce an automation strategy \nthat lifts many of these previous restrictions. Our method works reliably for properties with non-trivial \nmixtures of universal and existential modal operators. Furthermore, our approach is designed to support \n(possibly in.nite-state) programs. The basis of our approach is the observation that existential rea\u00adsoning \ncan be reduced to universal reasoning if the system s state\u00adspace is appropriately restricted. This restriction \non the state-space must meet a constraint derived from recent work on proving non\u00adtermination. The observation \nleads to a new route for implemen\u00adtation based on existing tools. To demonstrate the practical via\u00adbility \nof our approach, we report on the results applying our pre\u00adliminary implementation to a set of benchmarks \ndrawn from the Windows operating system, the PostgreSQL database server, Soft-Updates patching system, \nas well as other hand-crafted examples. Categories and Subject Descriptors D.2.4 [Software Engineer\u00ading]: \nSoftware/Program Veri.cation Model checking; Correct\u00adness proofs; Reliability; D.4.5 [Operating Systems]: \nReliability Veri.cation; F.3.1 [Logics and Meanings of Programs]: Specify\u00ading and Verifying and Reasoning \nabout Programs; F.3.2 [Logics and Meanings of Programs]: Semantics of Programming Languages Program analysis \nGeneral Terms Veri.cation, Theory, Reliability Keywords CTL, temporal logic, formal veri.cation, termination, \nprogram analysis, model checking 1. Introduction Branching-time temporal logics facilitate reasoning \nabout the non\u00addeterminism that exists within the transition relations of systems. For example we might \nwish to prove that a program P could (but is not forced to) terminate from every reachable state, and \nfur\u00adthermore if and when termination does occur, p will hold. In the branching-time logic CTL, we can \nexpress this as1 P .A[EFp W p] * Supported in part by the CMACS NSF Expeditions in Computing award 0926166. \n1We abuse notation slightly; we mean that s . A[EFp W p] for every initial state s in program P. Here \nwe are using two temporal operators: A[a W b]speci.es that a and b are temporally sequenced in all executions \nthrough the system: either a might happen forever, or b must happen if a ever ceases to hold. A[a W b] \nis a universal temporal operator: it must hold over all executions of the system, no matter which nondeterministic \nchoices are made.  EFa speci.es that there exist nondeterministic choices that can be made such that \na will eventually hold.  Applications of this type of reasoning include planning, games, security analysis, \ndisproving, precondition synthesis, environment synthesis, and many others. In the area of planning, \nfor example, nondeterministic choices in a system often represent choices that can be manipulated by \na plan. With a proof that P .A[EFp W p], we could devise a plan that would cause the system P to termi\u00adnate \nin state p whenever desired [32]. As another example, consider environment synthesis: Imagine that we \nwould like to .nd a con\u00addition that if maintained would guarantee whenever p holds, q will eventually \nhold: AG(p . AF q). Towards this goal we can prove EG(p . AF q), which states that it s possible but \nnot guar\u00adanteed that whenever p then eventually q. With a proof in hand we can then work out the conditions \nrequired to guarantee such a de\u00adsired condition, thus giving us a restriction on the state-space such \nthat AG(p .AF q)would be true. At .rst glance the above applications of CTL reasoning look appealing. \nUnfortunately, there is a problem: The question of how to reliably automate proofs in CTL and similar \nbranching-time logics (e.g. CTL * , modal \u00b5-calculus) for in.nite-state programs remains an open problem. \nIn this paper we report on the .rst known robust automatic proof method to support both universal and \nexistential branching\u00adtime modal operators for programs. Our approach is based on the observation that \nexistential reasoning can be reduced to universal reasoning when an appropriate restriction is placed \non the the state\u00adspace of the system. For soundness we require that the restriction used meets a condition \nadapted from recent approaches to non\u00adtermination proving [22]. For example, to prove that there exists \na path in a program P such that p holds (i.e. P .EFp), we search for a restriction Con P s state-space \nsuch that in the program restricted to C-states, for all paths p eventually holds (i.e. P IC . AFp). \nTo ensure that there still exists at least one path to p in P IC we must check a condition that the restriction \nC be a recurrent set [22]. The advantage of our approach is that there are known solu\u00adtions to the problem \nof universal branching-time, as well proving non-termination. Thus, to construct a full-.edged CTL prover \nfor in.nite-state programs, we need only develop a method that synthe\u00adsizes appropriate restrictions \nC. Towards this goal we give a pro\u00adcedure that re.nes candidate restrictions on demand using failed proof \nattempts with insuf.cient restrictions. To demonstrate the practical viability of our approach we have \nbuilt a preliminary unoptimized prover and applied it to toy bench\u00admarks with a variety of combinations \nof temporal operators, as well as examples drawn the PostgreSQL database server, the SoftUp\u00addates patch \nsystem, the Windows OS kernel.  Limitations. The formal treatment given in this paper is de.ned over \ngeneral transitions systems. Thus, we make no assumption about the structure of programs (recursive, \nhigher-order, etc). In practice, however, our implementation uses constraint-based meth\u00adods as well as \nsafety and termination proving techniques that limit the applicability of the tool to non-recursive programs \nwith vari\u00adables that range over arithmetic domains. Heap-based programs can be handled by .rst constructing \na numerical abstraction (e.g. [26], [29]). For the purpose of brevity we have limited ourselves here \nto the logic CTL, as CTL is a simple logic that supports mixtures of existential and universal reasoning. \nApplying these techniques to more expressive logics (e.g. CTL * or modal \u00b5-calculus) is left as future \nwork. While the CTL proof rules we develop are sound and complete, our practical implementation is not \ncomplete for several reasons: The underlying technique for proving the universal subset of CTL is not \ncomplete.  Our heuristics for synthesizing restrictions on the state-space is not complete.  The re.nement \nprocedure for state-space restrictions may make incorrect choices early during the iterative proof search \nthat limit the choices available later in the search. In these circum\u00adstances we a form of backtracking \ncould potentially be used to consider alternative decisions.  2. Example In this section we informally \ndiscuss a simple example. In the following sections we develop the approach more rigorously. 1 x = 0; \n2 while (true) { 3 = *; .1 .1 4 y= ; 5 x = 1; 6 = *; .2 .2 7 n= ; 8 while (n>0) { 9 n = n -y; 10 } 11 \nx = 0; 12 } Here we have made all of the nondeterminism explicit through the use of variables .1 and \n.2. The symbol * represents nondeterminis\u00adtic choice. Imagine that we would like to prove that it is \npossible to maintain the invariant that, whenever x = 1, then eventually x = 0. In CTL we would express \nthis property as: EG(x = 1 .AF(x = 0)) Here EGp speci.es that there exist nondeterministic choices such \nthat p holds forever. AFp says that in all nondeterministic choices p eventually becomes true. Our method \nis based on the search for a restriction on the nondeterministic choices made (i.e. the .-variables) \nsuch that we can use tools that support only universal reasoning to do the hard work. In this case, if \nwe restrict the nondeterministic choice .1 = * at line 3 to be positive then the universal variation \nof original property, AG(x = 1 .AF(x = 0)), holds of a similar program: 1 x = 0; 2 while (true) { 3 .1 \n= *; assume(.1 = 1); .............. .1 4 y= ; 5 x = 1; 6 = *; .2 .2 7 n= ; 8 while (n>0) { 9 n = n -y; \n10 } 11 x = 0; 12 } Here we have used a restriction on the state space: C = (program is at line 3 . .1 \n= 1) which we have implemented using an assume instruction [31]. .1 = *; assume(.1 = 1); ............ \nWe have to be careful when choosing restrictions, as we have done above. For example, the restriction \nC = (program is at line 3 .false) would cause the universal reasoning to succeed. However, the assume(false) \ncommand that would appear on Line 3would cause there to be no executions of this restricted program. \nConsequently, EG does not hold. In this paper we will describe a requirement on our choice of chute so \nthat we guarantee non-emptiness. Finding restrictions. To automate the discovery of restrictions we begin \nwith C = true. We then use failed proof attempts in the universal subset of CTL to guide where further \nrestrictions need to be added. In our example we would try proving AG(x = 1 . AF(x = 0))using C = true, \nwhich fails. As a result we will get the following counterexample: A path to (x = 1): x = 0; .1 = *; \ny= ; .1 x = 1; .2 = *; n= ; .2 A cyclic path where (x = 0)never occurs: assume(n>0); n = n -y; Because \nthe cyclic path is executed forever we can infer that y = 0 is invariant in the cyclic path. That is, \nwe can strengthen the cyclic path to: assume(y<=0); assume(n>0); n = n -y; As is standard in tools \nbased on counterexample-guided abstraction re.nement (e.g. [30], [2]) we can represent this command sequence \nas a logical formula expressed using static single assignment vari\u00ad ables: . x1 = 0 . y1 = .1 1 . . . \nx2 = 1 n1 = .2 1 . . y1 = 0 n1 > 0 . . . n2 = n1 -y1 .  can compute a condition by performing quanti.er \nelimination on the variables (x1, y1, x2, n1, n2, .2 1)that are not in scope just after the command .1 \n:= *. The elimination is thus: . x1 = 0 . y1 = .1 1 x2 = 1 2 0 . . 1 .y1, x1, x2, n1, n2, .1, .1. . . \nn1 = .1 2 . = .1 = 0 y1 = 0 n1 > 0 . . . n2 = n1 - y1 . Finally, we can restrict the original program \nsuch that this path is not possible. To this end, we instrument the negation of this condition \u00ac(.1 = \n0), after the assignment .1 := *. Hence, we strengthen C with C := C. (program is at line 3 ..1 > 0) \n In more complex cases with nested temporal existential operators we must .nd families of restrictions, \nmaintaining a set of C re\u00adstrictions, indexed by their use in a CTL proof search. In the next section \nwe describe our procedure more formally and discuss this complexity in some detail. 3. Treating the \nExistential Fragment of CTL We now turn to a formal description of our technique. We begin with new proof \nrules for CTL. These generalize our previous rules for .CTL [10, 11]. Our rules are given in terms of \nsets of states, allowing us to partition the state space rather than enumerate the state space. In this \npaper we introduce a new proof rule for existential op\u00aderators that characterizes the existence of traces \nas a subset of the transition relation called a chute. This allows us to apply univer\u00adsal reasoning to \nthe subset, in order to prove existential properties. We characterize the side condition of non-emptiness \nwith recur\u00adrent sets. In later sections, we will describe how proof derivations (including discovery \nof chutes) can be obtained automatically. 3.1 Preliminaries Transition systems. A transition system M \n= (S, R, I)is a set of states S, a transition relation R . S \u00d7 S, and a set of initial states I . S. \nWe use the notation rI1 to mean the .rst projection of relation r. A trace p of a transition system is \nan in.nite sequence of states (s0, s1, ...) such that s0 . I, .i = 0. si . S and .i = 0. (si, si+1) . \nR. We denote by .(S, R, I) the set of all such traces. For convenience, we do not allow .nite traces. \nThe transition relation must be such that every state has at least one successor state: .s . S. .s ' \n. (s, s ' ). R. This is without a loss of generality, as .nal states can be encoded as states that loop \nback to themselves. The notation pi indicates a suf.x of a trace starting at the ith state in the sequence. \nWe use p0 to denote the .rst element in p. The superscript binds tighter than the subscript, i.e. p0 \ni = (pi)0. We will use similar notation for a .nite path .. Additionally, we will say that .end denotes \nthe .nal element of .. Ranking functions. For a state space S, a ranking function f is a total map from \nS to a well-ordered set with ordering relation .. A relation R . S \u00d7 S is well-founded if and only if \nthere exists a ranking function f such that .(s, s ' ) . R. f(s ' ) . f(s). We denote a .nite set of \nranking functions (or measures)as M. Note that the existence of a .nite set of ranking functions for \na relation R is equivalent to containment of R+ within a .nite union of well-founded relations [34]. \nThat is to say that a set of ranking functions {f1, ..., fn} can denote the disjunctively well-founded \nrelation {(s, s ' )If1(s ' ). f1(s). ... . fn(s ' ). fn(s)}. Temporal logic. The syntax of a CTL formula \nis F ::= p I F.F I F.F I AFF I EFF I A[FWF] I E[FWF] Note that AGp can be de.ned as A[p W false], and \nEGp can be de.ned as E[p W false]. The standard semantics of CTL is given in Figure 1. p is an atomic \nproposition. There are two classes of temporal constructors: constructors that quantify universally over \npaths (AF, AW) and constructors that quantify existentially over paths (EF, EW). The AF and EF constructors \nspecify that a state in which F holds must be reached. The [F1WF2]operator speci.es that F1 holds in \nevery state where F2 does not yet hold. We use F and W as our base temporal operators (as opposed to \nthe more standard U and R), as each corresponds to a distinct form of proof: F to termination, and W \nto safety. We omit the next state operator X as it is not particularly useful in an imperative programming \nlanguage: the next step simply is a transition across a command and can be supported via F. We assume \nthat formulae are written in negation normal form, in which negation only occurs next to atomic propositions, \nand assume that the domain of atomic propositions is closed under negation. A formula that is not in \nnegation normal form can be easily normalized. De.nition 3.1 (CTL machine entailment). For every M = \n(S, R, I)and CTL property F, M .F = .s . I. R, s .F. Our rules are composed structurally over a CTL formula. \nIn order to track components of a proof we need to uniquely identify sub\u00adformulae. To this end, our de.nition \nof subformulae maintains a context path: . = o IL . IR . that indicates the path from the root o (the \noutermost property F), to the particular subproperty of interest, at each step taking either the left \nor right subformula (L. or R.). For a CTL property F, the set of subformulae is a set of (., F)pairs \nas follows: sub(F) = sub(o,F) sub(.,p) = {(., p)} sub(., F. F ') = {(., F. F ')} . sub(L.,F) . sub(R.,F \n') sub(., F. F ') = {(., F. F ')} . sub(L.,F) . sub(R.,F ') sub(.,AFF) = {(., AFF)} . sub(L.,F) sub(., \nEFF) = {(., EFF)} . sub(L.,F) sub(.,A[FWF ']) = {(., A[FWF '])} . sub(L.,F) . sub(R., F ') sub(., E[FWF \n']) = {(., E[FWF '])} . sub(L., F) . sub(R., F ')  3.2 A Proof System for CTL Our proof system given \nin Figure 2 is a relation between a set of states X and a CTL context/formula ., F. Atomic proposition \nRAP and conjunction RAND are as expected (note that [p] means the set of states such that p holds). Disjunction \nROR partitions the set of states into two sets X1 and X2 where F1 holds of X1 and F2 holds of X2. Quanti.cation \noperators. In this paper, we generalize the proof system to encompass the universal and existential temporal \nopera\u00adtors. To this end, we decompose the temporal operators based on quanti.cation, so we have: . ::= \nFF I [F W F] F ::= p I F. F I F. F I A. I E. This decomposition allows us to treat universal and existential \ntemporal operators similarly. When an A. or E. quanti.cation operator is reached, a corresponding rule \n(RA or RE) is used to identify three key sets of states that will be relevant to .: 1. The initial states \nX 2. The chute states C 3. The frontier [10, 11]states F   R, s .p .. s . [p] R, s .F1 . F2 .. R, \ns .F1 and R, s .F2 R, s .F1 . F2 .. R, s .F1 or R, s .F2 R, s .AFF .. .(s0, s1, ...). .(S, R, {s}). .i \n= 0. R, si .F R, s .EFF .. .(s0, s1, ...). .(S, R, {s}). .i = 0. R, si .F R, s .A[F1 W F2] .. .(s0, s1, \n...). .(S, R, {s}). (.i = 0. R, si .F1) . (.j = 0. R, sj .F2 . .i . [0, j). R, si .F1) R, s .E[F1 W F2] \n.. .(s0, s1, ...). .(S, R, {s}). (.i = 0. R, si .F1) . (.j = 0. R, sj .F2 . .i . [0, j). R, si .F1) \nFigure 1: Standard CTL semantics, a relation from a state to a formula. F C F C F C X . [p] X .L., F1 \nX .R., F2 (s, t). R s . X s . F s, t . C RAP RAND X .., p X .., F1 . F2 R (s, t) X X = X1 . X2 X1 .L., \nF1 X2 .R., F2 ROR X .., F1 . F2 R (s, t) (t, u). R t . F u . C X, S, F. .., . (X, C. , F.)is rcr X, \nC. , F. .., . X RA RE X .., A. X .., E. R (t, u) X F. F. RC. is w.f. F. .L., F RC. I1 .L., F1 F. .R., \nF2 X X RF RW X, C. , F. .., FF X, C. , F. .., [F1 W F2] Figure 2: On the left is a proof system for \nCTL that uni.es the temporal treatment of universal A and existential E. There is a side condition on \nthe existential rule that the relevant states form a recurrent set. The de.nition of Ris given on the \nright. We can think about these as: the start states X, the relevant region the chute. In the case of \nR E, we must identify a chute C and ensure of the transition relation C through which execution is allowed \nto a special side condition that the triple (X, C, F) be a recurrent set, pass, and a stopping point \nat the frontier F. Visually: de.ned as follows: De.nition 3.2 (Recurrent set). For sets of states X, \nC, F and transition relation R, we say that C is a recurrent set w.r.t. X and F (denoted (X, C, F) is \nrcr) provided that X n C . \u00d8 and: 1. X n C . F, or ' 2. For every x . C, there exists x such that (x, \nx ' ) . R and ' ' x . F . x . C. Intuitively, a recurrent set C is such that either: (i) there is a path \nfrom X that either immediately intersects with F, (ii) there is a path that reaches F by following C \nat each transition or (iii) there is a path that remains in C forever, never reaching F. Note that this \nis a generalization of a previously described notion of a recurrent set [22]. For proving non-termination, \nthe simpler notion of recurrent set is suf.cient because there is no frontier. With nested temporal operators, \nwe must account for a set being recurrent modulo a frontier, wherein the subproperty is satis.ed.  The \nchute Ceffectively carves out the portion of the state space that will be relevant to the subproperty. \nThis generalization with chutes Temporal operators. The quanti.cation operators discussed provides a \nmeans of treating each quanti.cation fragment of CTL: above are designed to be compatible with either \ntemporal operator. First we identify the region (i.e. subset) of the transition relation can be treated \n1. For a given subformula, existential properties F C that is relevant to a given triple X, C, F via \nthe relation R , given by restricting the state space to a chute and applying universal reasoning on \nthat chute (R E). The non-emptiness side condition on the right-hand side of Figure 2. Notice that R \n F C . R. In the is that this chute must be recurrent, discussed below. X F C 2. For a given subformula, \nuniversal properties can be treated by base case, a transition (s, t)is in R if s . X, s . C, and s . \nF. In X letting the chute be the entire state space (R A). F C the inductive case, a transition (t, \nu)is included in R whenever X The quanti.cation proof rules (Figure 2) each involve a proof F C obligation \nfor the temporal operator ., in terms of this triple: X X, C, F . ., .. In the case of R A, we use the \nentire state space S as double-line edges in the following diagram:  Chute state transition the second \nbranch, and decrement x. Chute Co also ensures that once an execution exits the .rst loop and enters \nthe second loop, it immediately takes the p=1 branch, satisfying that p > 0. This is also the point at \nwhich frontier Fo is reached. From this state, we can ensure that EG(p > 0)holds using chute CLo , which \nspeci.es that executions of the second loop only take the p=1 branch. This must hold in every subsequently \nreachable state (i.e. the semantics of EG), so we choose FLo = false. What remains are the proof obligations: \n1. (I , Co , Fo)is rcr. This triple is recurrent because there is at least one state in I (in fact, we \ncan choose any initial state), and whenever we are at the .rst loop there is at least some successor \nin the chute (iterating x=x-1 or proceeding along the F C path 8,9,10,11,12) until the frontier Co is \nreached at location The proof that X, C, F . FF involves showing that R is well- X 12. founded. This \nwell-foundedness condition ensures that all traces Fo 2. RCo is well-founded. This holds because, when \nexecutions are through X, C, F reach the frontier F after .nitely many steps. I Moreover, the R F rule \nrequires that F . F. The proof rule RW restricted to the second branch in the .rst loop, they are well\u00adrequires \nthat along every path from X through the chute C, F1 founded: x is decremented and bounded from below \nby 0. holds (by requiring that the .rst projection of R F C satis.es F1) 3. (Fo , CLo , FLo) is rcr. \nThis set is recurrent because there is X unless the frontier F has been reached at which point F2 holds. \nalways a successor state in CLo: taking the .rst branch of the * second loop ad in.nitum. Remark: CTL \n. Note that our decomposition of quanti.cation * and temporal operators bares some resemblance to CTL \n[16]. This program appears in the EFEGp benchmark in Figure 6. * CTL is a generalization of CTL (and \nof LTL) that includes state propositions (E, A) as well as path propositions (F,W). The dif\u00adference is \nthat a path proposition F or W is already .xed on a particular path. By contrast, our treatment relates \nF or W to the triple (X, C, F), giving us more structure to work with in the tem\u00adporal operators. For \nexample, using chutes and frontiers allows us to characterize eventuality as the well-foundedness of \na subset of Equivalence to CTL semantics. The following theorem shows that our treatment in Figure 2 \nis equivalent to CTL. The proof in\u00advolves representing traces as in.nite sequences (i.e streams), and \nnumerous support lemmas based on coinduction. We also incorpo\u00adrate recurrent sets and several corresponding \nlemmas. Theorem 3.1 (Equivalence to CTL). For all F, M = (S, R, I ), the transition relation R F C . \nI .o, F .. .s . I . R, s .F. X Example 1. Consider the following program for which we would Proof. (sketch) \nWe .rst expand our proof rules for X . ., A. like to prove that the nested property F = EF(EG(p > 0)) \nholds. and X . ., E. for each . case, obtaining four direct . rules: assume(p == 0 . x > 0); // Initial \nstate 1 while(x>0) { 2 = *; .1 3 if (.1 > 0) { 4 x = x + 1; 5 } else { 6 x = x -1; 7 } 8 } 9 while(1) \n{ 10 = *; .2 11 if (.2 > 0) 12 p = 1; 13 else 14 p = 0; 15 }  Intuitively, the property holds because \nthere is an execution that exits the .rst loop, enters the second loop, sets p = 1 and then forever iterates \nthe second loop, each time avoiding p = 0. If we restrict the nondeterministic choices, then we can treat \nEFEGp like AFAGp. This can be accomplished by constraints on the . variables. A derivation for this example \nis given in Figure 3 where I = [p = 0 . x > 0]. On the left-hand side is the proof tree, built syntactically \nfrom F. Note that we are using EGp which is a special case: EGp = E[p W false]. On the right-hand side \nare values for the chutes and frontiers. (Note that pc is a special variable containing the value of \nthe program counter, i.e., line number.) Chute ensures that in the .rst loop, executions always take \nCo X . ., AFF, X . ., EFF, X . ., A[F1 W F2], and X . ., E[F1 W F2] (and no . rules). The proof then \nproceeds by induction on the (negation normal form) CTL property F. .  4. Automation In this section \nwe present an algorithm for automatically discover\u00ading the chutes necessary for proving a CTL property. \nOur method assumes an underlying proof technique for applying universal rea\u00adsoning to CTL veri.cation, \nsuch as the one we previously de\u00adscribed [10, 11]. We extend this underlying prover slightly, by adding \ncases for the existential subformulae that are identical to their universal counterparts, except that \nthe transition relation is constrained by the per-subformula chute. Our algorithm begins by assuming \nthat no chute restriction is necessary for proving existen\u00adtial subformulae. This typically leads to \ncounterexamples from the underlying prover. From counterexamples, we synthesize chutes by attempting \nto eliminate the behaviors witnessed by the counterex\u00adamples. We begin with a symbolic treatment of chutes. \nChutes, as seen in Section 3, are (potentially in.nite) sets of states. In our re.nement procedure we \nwill work with predicates instead, written in .rst\u00adorder logic: De.nition 4.1 (Chute predicate cp). Achute \npredicate cp is a .rst\u00adorder logic formula over the states of a transition system. For a given CTL property \nF, we use the notation C\u00afto mean an in\u00addexed set of chutes, consisting of a conjunctive chute predicate \nC. for every (., ). sub(F). We will abuse notation and sometimes use to refer to a chute predicate. When \nthis is then used in the C.  R FLo CLo Fo I1 . [p > 0] Co Fo = = pc = 2 ..1 = 0. pc = 10 ..2 > 0 pc \n= 12 R Fo Co I is w.f. (Fo , CLo , FLo)is rcr R FLo CLo Fo I1 .LLo, p Fo , CLo , FLo .Lo, Gp Fo .Lo, \nEGp CLo FLo = = pc = 10 ..2 > 0 false (I, Co , Fo)is rcr I, Co , Fo .o, FEGp I .o, EFEGp Figure 3: Derivation \nfor CTL property EF(EG(p > 0)). On the left is the proof tree and on the right are the values for the \nchutes and frontiers. Note that we use EG which is a simple case of EW where the second subproperty is \nsimply false. context of a set of states, we mean the set of all states such that C. holds: [C.]. Algorithm. \nGiven a CTL property Fand a program P , our re.ne\u00adment algorithm discovers a proof that P .Fby iteratively \nre.ning \u00af an indexed set of chute predicates C. Our algorithm is given in Fig\u00adure 4. It begins by initializing \neach C. to true. We then use an underlying method for attempting to prove that F holds, given the \u00af \nset C: \u00af attempt M .o, F using C We discuss our implementation of attempt in Section 5. When at\u00adtempt \nsucceeds, a candidate proof is returned. This candidate in\u00ad \u00af\u00af cludes an indexed set of frontiers F. \nTogether, C\u00afand F specify the chutes and frontiers in a . proof tree. Moreover, attempt re\u00adturns an indexed \nset of rank functions \u00af M, which are the proofs of each well-foundedness obligation in F subformulae. \nWhat remains are the recurrent set proof obligations for E. subformulae, accom\u00adplished in RCRCHECK (Section \n5.3). When attempt fails, it has discovered a counterexample to Fin the form of a path . : list (S \u00d7 \nsub(F)). 2 The path . is part of a counterexample to F and traverses the S \u00d7 sub(F)state space. (A discussion \nof counterexamples is given in [9].) Although attempt has failed, F may still hold of P . Choices may \nhave been made in E. subformulae which exercised a region of the state space where . does not hold. For \nexample, consider the property EG(x = 1)and the program: 1 x = 1; . = *; // init 2 if(. > 0) 3 while(1) \n{ x = 0 } 4 else 5 while(1) { x = 1 }  Here, attempt may return the path (pc = 1,x = 1,. = 1), (pc = \n3,x = 0,. = 1), (pc = 3,x = 0,. = 1),... While this path proves that AG(x = 1) does not hold, it is \nstill the case that EG(x = 1) does hold. If we restrict the transition relation s state space to exclude \nsuch paths, alternative decisions may be possible, leading to an alternative proof that F holds of P \n. In the case above, if we exclude all of the states where pc = 3 (by ensuring that . is never more than \nzero) then we are left with a transition system for which AG(x = 1)holds. Synthesizing chute predicates. \nThe procedure SYNTHcp is used to automatically discover predicates such as (. = 0), which are 2In our \nimplementation (see Section 5) this path is represented as a se\u00adquence of program commands rather than \nconcrete states. let SYNTHcp(.)= . (cp, .) .(., E.). sub(F). .i. 1. .0 i . [C.] \u00d7 {(., E.)} . . 2. \n.0 i+1 . [C.] \u00d7 {(., E.)} 3. .0 i+1 . [C. . cp] \u00d7 {(., E.)} . Not found otherwise . let prove(M, F) = \n\u00af C := {. .true I(., E.). sub(F)}; loop \u00af match (attempt M .o, F using C) with \u00af I Counterexample(., \nF) .. let (cp, .)= SYNTHcp(.)in C. := C. . cp \u00af with Not found .. return Fail(F\u00af, C) \u00af I MaybeProof(F\u00af, \nM) .. if (.., E. . sub(F). RCRCHECK(F, C. , F.)) return Succeed done Figure 4: Chute-re.nement procedure. \nCounterexamples from failed proofs using .CTL techniques with chutes Care used to help re.ne C. necessary \nto restrict the transition relation to the states in which the existential subproperty holds. The path \n. returned from attempt is part of a counterexample to F and traverses the S \u00d7 sub(F)state space. SYNTHcp \nmust discover a predicate cp such that path . is not possible. To this end, it examines . to .nd regions \nof . that are existential temporal operators. Let (., E.)be such a region. SYNTHcp must then look for \nnondeterministic choices that were made in that scope within . where some other alternative choice was \npossible. In our implementation we can easily .nd such cases because we have automatically lifted all \nnondeterministic choice into assignments to special variables denoted .i. Theorem 4.1 (Soundness of re.nement \nalgorithm). For every tran\u00adsition system M and CTL property F, prove(M, F) . M . F   . \u00af E(P,M\u00af,C,F) \n=.(.,.).sub(F) {enc. : s . B} where . bool enc (state s) { ...' if (*) return enc L. .(s); else return \nenc R.(s); .' } . bool enc (state s) { ...' if (encL.(s)) return true; . R. else return enc.' (s); \n} . bool enc (state s) { return p(s); } p . bool encA[. W .' ](state s) {[if (*) return true; P[ c / \nL. R. ] ; c] if (\u00ac enc (s)) return enc.' (s); . } . bool enc (state s) { E[. W .' ] .if (*) return true; \n. assume(C.); P[ c / ......... ; c] L. R. . .if (\u00ac enc (s)) return enc.' (s); . . . } bool enc . (state \ns) { AF. bool dup = false; state s; .if (*) return true; . if (encL.(s)) return true; . P[ c / if (dup \n&#38;&#38; \u00ac(.f .M. f(s) .f( s))) ; c]return false; if (\u00ac dup &#38;&#38; *) { dup:=true; s:=s;} . . . \n.}  . bool encEF. (C.)(state s) { bool dup = false; state s; .if (*) return true; . assume(C.); ......... \nif (encL.(s)) return true; P[ c / . ; c] if (dup &#38;&#38; \u00ac(.f . M. f(s) . f( s))) return false; . \n.if (\u00ac dup &#38;&#38; *) { dup:=true; s:=s; } . . } Figure 5: Encoding CTL veri.cation as a .nite set \nof procedures. Universal rules discussed in [10, 11]. The two new existential rules, which account for \n(., .)-subformula indexed sets of chute predicates are highlighted with shadow-boxes. states X . ., E., \nit is always sound to remove behaviors and apply universal reasoning (in attempt), provided that before \nwe conclude that E. holds, we ensure that there is at least one behavior (accom\u00adplished in RCRCHECK). \n. In some cases, our re.nement algorithm will give an answer that is not the expected one due to an incorrect \nre.nement choice. In cases where an incorrect chute is synthesized we can easily backtrack. 5. Implementation \nIn this section we describe some implementation-level details that proved important when developing our \nprototype tool. 5.1 CTL Proof Attempts \u00af Assume for now that we have a set of chute predicates C. In \nSection 4 we assumed the following method: \u00af attempt (M . o, F)using C When this procedure fails to prove \nthe property, it returns a path . : (S\u00d7sub(F))list that is part of a counterexample that demonstrates \nhow F can be violated given the current state-space restriction to \u00af chutes C. In our implementation \nwe developed this attempt procedure as an extension to our previous method [10, 11], which handles the \nuniversal subset of CTL. In our previous work, we introduced a reduction which, when given a transition \nsystem P and an .CTL temporal logic property F, generates a procedural program E that encodes the search \nfor the proof that Fholds of P [10, 11]. Existing program analysis tools can then be used to reason about \nthe validity of the property. Our encoding E is given in Figure 5and has been extended with the two new \nrules in large shadowed boxes so that we can now handle full CTL properties. The notation P [c/c ' ]indicates \nthat the program P is modi.ed such that each command c is replaced with a new command c ' . When given \na program P and a CTL prop\u00aderty F, the new program E encodes the search for the proof that F holds of \nP . The arguments (.s, .., M, R)passed to E are a pair consisting of the state s and a F-subformula . \nof interest, a .nite set of ranking functions M, an indexed set of chute predicates C\u00afand the program \nsource P . Executions of the procedure E explore the S \u00d7 sub(F)state space from an initial state s0 . \nI in a depth\u00ad.rst manner. At each recursive call, E is attempting to determine whether . holds of s. \nRather than explicitly tracking this informa\u00adtion, however, E returns false (recursively) whenever . \ndoes not hold of s. Consequently, if E can be proved to never return false, it must be the case that \nthe overall property Fholds of the initial state s. When a program analysis is applied to E it is implementing \nwhat is needed to prove branching-time behaviors of the original tran\u00adsition system (e.g. backtracking, \neventuality checking, tree coun\u00adterexamples, abstraction, abstraction-re.nement, etc). Formally the relationship \nbetween E and . is: for a program P (with initial states I)and CTL property F, \u00af\u00af\u00af .C\u00af. .M. .s . I. E(s, \nF, M, C, R)cannot return false . .s . I. R, s . F What remains is to understand how E determines whether \na subformula . holds of a state s. By passing the state on the stack, we can consider multiple branching \nscenarios. When a particular . is a . or AW/EW subformula, then E ensures that all possibilities are \nconsidered by establishing feasible paths to all of them. When a particular . is a . or AF/EF subformula, \nE enables executions to consider all of the possible cases that might cause . to hold of s. As soon as \none is found, true is returned. Otherwise, false will be returned if none are found. New existential \ncases. The encoding has two new cases, in large shadowed boxes, for the existential operators: the new \nsubformula . . EF. encoding enc which is similar to encAF. , as well as encod\u00ading enc . which is similar \nto enc . . Theyare de\u00ad E[.1 W .2 ] A[.1 W .2 ] signed such that we can again apply the universal reasoning \nand try . . to prove that encEF. (or enc )cannot return false. What E[.1 W .2 ] . . EF. is new is that \nenc and encE[. W .' ] must take care to restrict possible proofs/counterexamples as speci.ed by the chute \npredi\u00adcates we have discovered. This is where the indexed vector of chute . . predicates C\u00afis used. The \nencodings for encEF. and encE[. W .' ] in\u00adclude wavy underlined assume(C.) statements in Figure 5. These \nstatements restrict the behavior of the transition system to chute C. .  5.2 Synthesizing Chute Predicates \nOur re.nement algorithm, given in Figure 4, then assumes a method for synthesizing new chute predicates, \ngiven counterexam\u00adples to proof attempts. In our implementation, when the proof at\u00adtempt fails a path \n. : (c, ., .)list is returned, which is a sequence of commands in the original program P , annotated \nwith the rele\u00advant subformula. Our implementation of SYNTHcp must return a chute predicate cp and subformula \nindex . that meets the interface given in Figure 4. When our implementation of attempt generates the \nencoding E, it introduces a variable .i at each nondeterministic choice. For example, we would transform \nnondeterministic assign\u00adments as follows: x := read(); . .x := *; x := .x; We similarly transform nondeterministic \nbranching: if (read()) then C1 else C2 . .i := *; if (.i>0) then C1 else C2 These transformations simplify \nchute predicate synthesis by stan\u00addardizing the sources of nondeterminism as values of .-variables. When \nwe are given a path ., we look for a .-variable: ..., (ci-1, .i-1, .i-1), (.i:=*, .i, E.i), (ci+1, .i+1, \n.i+1), ... . Given such a path, we restrict our attention to the commands that are annotated with (.i, \nE.i), as the other commands are only relevant to other subformulae. We then build a formula T that is \nthe conjunction of inequalities in static single-assignment form that represents the remaining commands. \nAssume that V is the variables not in the (.i, E.i)scope. Using quanti.er elimination we compute T ' \n= .V.T . Our procedure then ensures that T ' is in '' ' CNF form: T = .i Ti where each Ti is an inequality \n. We prune T ' ensuring that each conjunct mentions the variable .: T. = \u00ac .{Ti ' I. . FREEVARS(Ti ' \n)} The new candidate for chute re.nement is thus pc = l . T. where l is assumed to be the location of \nthe command . := *. Example. Imagine that we have the following path: (...; , (Ro, E. . AFp)) (x:=a; \ny:=b; v:=c; y:=k; , (LRo, E.)) (rho := *; , (LRo, E.)) (assume(rho>3); , (LRo, E.)) (x := w; , (LRo, \nE.)) (y := y-1; , (LRo, E.)) (assume(x<z); , (LRo, E.)) (rho := *; , (LRo, E.)) (assume(rho>x); , (LRo, \nE.)) (x := x -1; , (LRo, E.)) (v := y; , (LRo, E.)) (rho := *; , (LRo, E.)) (assume(rho>3); , (LRo, E.)) \n The SSA formula representing this would be: x1 = a0 rho2 > x2 y1 = b0 x3 = x2 - 1 v1 = c0 v2 = y1 y1 \n= k0 rho3 > 3 rho1 > 3 a1 = x3 x2 = w0 b1 = y2 y2 = y1 - 1 c1 = v2 x2 < z0 Imagine that we d like to \n.nd a condition from the second rho := *. In this case we quantify out all variables except x2, y2, v1, \nk0, z0, and rho2. That leaves us with the condition: rho2 > x2 Thus we might use \u00ac(rho2 > x2)as the re.nement \nfor CLRo . There are usually many choices available, some of which may lead to failed proofs due to a \nviolation in RCRCHECK. To .lter out potentially bad chute predicates, our implementation performs a simple \nnon-termination check of the scope in question. If multiple candidates still exist we choose the one \nthat appears as the last assignment in the inner most scope. We have found that these heuristics for \nchoosing chute predicates was effective at proving a wide variety of CTL properties, as seen in our experimental \nresults (Section 6).  5.3 Checking Recurrent Sets Finally, when a proof attempt succeeds, recall that \nwe must check that our chutes have not restricted the state space to empty traces. To this end, we must \ncheck that chutes for existential subformulae are recurrent. This does not necessarily mean that we must \ncheck all subformula. For example, the property (EGp). (EGq)holds if EGp holds. In this case, we only \nneed to ensure that the chute CLLo for the left operator is recurrent. A proof that M . o, F involves \n\u00af\u00af indexed sets C and F. For each recurrent set obligation, we can use a simple reduction to satis.ability. \nInside our implementation of attempt, for every subformula (., E.), there is an encoding of the relevant \nsubset of the transition relation, restricted by chute predicate C.. Our implementation uses known non-termination \nproving techniques to prove, in the case of EG, that there is at least one non-terminating execution \nand, in the case of EF that there at least one execution to a place where the subproperty may hold. \n 6. Evaluation Using our prototype implementation we performed two sets of experiments. First, we ran \nthe tool on a series of small benchmarks crafted to explore the various combinations of temporal operators. \nWe then used the tool on a set of examples drawn from industrial code bases. In both cases, we generated \nthe encoding and ran our algorithm on an Intel x64-based 2.8 GHz single-core processor. The sources of \nour experiments are available please contact the authors. As discussed in Section 1, our tool is the \n.rst to handle mixtures of universal and existential quanti.ers. Thus at this time there are no competing \ntools to compare against. Note that, as our tool is not especially optimized, the purpose of these experiments \nis only to demonstrate the promise of the approach. For our small benchmarks, we wrote example programs \nin C. For each example, we wrote down corresponding CTL properties. The results of these experiments \nare given in Figure 6. Some of the CTL properties are meant to hold (denoted .)and others are meant not \nto hold (denoted .). We report the time it took to prove or discover a counterexample in the Time column. \nIn each case, we constructed another benchmark for the corresponding negated property (using the same \nprogram). For example, in the benchmark 22 where EGAGp holds, we ensure that AFEF\u00acp does not hold of \nbenchmark 49. The EFEGp benchmark is displayed in Example 1. In all but two cases we were able to prove \nthat the property held or discover a counterexample in less than a minute, often in seconds or less. \nBenchmark #20 ran out of memory during abstraction re.nement in the underlying safety proof. In benchmark \n#24 of Figure 6, our tool failed to report the correct answer for the property EG(q . EFp). This is because \nour tool made the wrong choice about synthesizing chute, but restricting execution to a particular set \nof paths (via a predicate on .). However, a more mature version of our tool can simply backtrack and \nmake other choices. Understanding these tradeoffs is an important direction for future work.  SMALL \nBENCHMARKS INDUSTRIAL EXAMPLES  # Example LOC Property shape Result Exp. Act. Time (s) 1. AFp . . 1.2 \n2. AFp . . 0.8 3. AGp . . 0.3 4. AGp . . 0.5 5. EFp . . 6. EFp . . 1.7 7. EGp . . 0.9 8. EGp . . 0.9 \n9. AGAFp . . 10.8 10. AGAFp . . 1.9 11. AGEFp . . 29.0 12. AGEGp . . 1.2 13. AFEGp . . 55.8 14. AFEFp \n. . 3.7s 15. AFAGp . . 1.3 16. AFAGp . . 11.0 17. EFEGp . . 44.3 18. EFEGp . . 54.7 19. EFAGp . . 0.6 \n20. EFAFp . ? mem 21. EGEFp . . 10.4 22. EGAGp . . 0.8 23. EGAFp . . 12.5 24. EG(q . EFp) . . 33.9 25. \nEG(q . AFp) . . 150.2 26. AG(q . EGp) . . 2.2 27. AG(q . EFp) . . 29.5 28. EG \u00acp . . 0.8 29. EG \u00acp . \n. 0.9 30. EF \u00acp . . 0.5 31. EF \u00acp . . 0.6 32. AG \u00acp . . 0.8 33. AG \u00acp . . 2.0 34. AF \u00acp . . 0.5 35. AF \n\u00acp . . 0.4 36. EFEG\u00acp . . 1.9 37. EFEG\u00acp . . 3.6 38. EFAG\u00acp . . 3.9 39. EFAF\u00acp . . 6.3 40. EGAF\u00acp . . \n10.9 41. EGAG\u00acp . . 37.7 42. EGEF\u00acp . . 2.7 43. EGEF\u00acp . . 5.8 44. AGAF\u00acp . . 3.6 45. AGAF\u00acp . . 10.2 \n46. AGEF\u00acp . . 23.8 47. AGEG\u00acp . . 7.5 48. AFAG\u00acp . . 40.3 49. AFEF\u00acp . . 0.9 50. AFEG\u00acp . . 13.8 51. \nAF(q . AG\u00acp) . . 2.0 52. AF(q . EG\u00acp) . . 13.8 53. EF(q . AF\u00acp) . . 6.3 54. EF(q . AG\u00acp) . . 3.9  1 \nOS frag. 1 29 AG(p . AFq) . . 4.6 2 OS frag. 1 29 AG(p . AFq) . . 9.1 3 OS frag. 1 29 AG(p . EFq) . . \n9.5 4 OS frag. 1 29 AG(p . EFq) . . 1.5 OS frag. 2 [8] 58 AG(p . AFq) . . 2.1 6 OS frag. 2 [8] 58 AG(p \n. AFq) . . 1.8 7 OS frag. 2 [8] 58 AG(p . EFq) . . 3.7 8 OS frag. 2 [8] 58 AG(p . EFq) . . 1.5 9 OS frag. \n3 370 AG(p . AFq) . . 38.9 OS frag. 3 370 AG(p . AFq) . . 18.0 11 OS frag. 3 370 AG(p . EFq) . . 90.0 \n12 OS frag. 3 370 AG(p . EFq) . . 107.8 13 OS frag. 4 370 AFq . AFp . . 34.3 14 OS frag. 4 370 AFq . \nAFp . . 18.8 OS frag. 4 370 EFq . EFp . . 1261 16 OS frag. 4 370 EFq . EFp . ? mem 17 OS frag. 5 43 AGAFp \n. . 569.7 18 OS frag. 5 43 AGAFp . . 65.1 19 OS frag. 5 43 AGEFp . ? time OS frag. 5 43 AGEFp . ? mem \n21 PgSQL arch 90 AGAFp . ? mem 22 PgSQL arch 90 AGAFp . . 38.1 23 PgSQL arch 90 AGEFp . ? mem 24 PgSQL \narch 90 AGEFp . . 42.7 S/W Updates 36 p . AFq . . 70.2 26 S/W Updates 36 p . AFq . . 32.4 27 S/W Updates \n36 p . EFq . . 18.5 28 S/W Updates 36 p . EFq . . 1.3 29 OS frag. 1 29 EF(p . EG\u00acq) . . 12.5 OS frag. \n1 29 EF(p . EG\u00acq) . . 3.5 31 OS frag. 1 29 EF(p . AG\u00acq) . . 18.1 32 OS frag. 1 29 EF(p . AG\u00acq) . . 105.7 \n33 OS frag. 2 [8] 58 EF(p . EG\u00acq) . . 6.5 34 OS frag. 2 [8] 58 EF(p . EG\u00acq) . . 1.2 OS frag. 2 [8] 58 \nEF(p . AG\u00acq) . . 8.7 36 OS frag. 2 [8] 58 EF(p . AG\u00acq) . . 5.6 37 OS frag. 3 370 EF(p . EG\u00acq) . . 1930.9 \n38 OS frag. 3 370 EF(p . EG\u00acq) . . 1680.7 39 OS frag. 3 370 EF(p . AG\u00acq) . ? mem OS frag. 3 370 EF(p \n. AG\u00acq) . ? mem 41 OS frag. 4 370 EG\u00acp . EG\u00acq . . 61.3 42 OS frag. 4 370 EG\u00acp . EG\u00acq . . 7.6 43 OS frag. \n4 370 AF\u00acq . AF\u00acp . . 0.9 44 OS frag. 4 370 AF\u00acq . AF\u00acp . . 0.6 OS frag. 5 43 EFEG\u00acp . . 1471.7 46 OS \nfrag. 5 43 EFEG\u00acp . . 351.1 47 OS frag. 5 43 EFAG\u00acp . . 85.5 48 OS frag. 5 43 EFAG\u00acp . . 255.8 49 PgSQL \narch 90 EFEG\u00acp . . 45.3 PgSQL arch 90 EFEG\u00acp . . 35.2 51 PgSQL arch 90 EFAG\u00acp . ? mem 52 PgSQL arch 90 \nEFAG\u00acp . . 30.2 53 S/W Updates 36 p . EG\u00acq . . 0.4 54 S/W Updates 36 p . EG\u00acq . . 4.5 S/W Updates 36 \np . AG\u00acq . . 0.5 56 S/W Updates 36 p . AG\u00acq . . 0.3 Figure 6: The performance of our tool when ap\u00ad \nplied to small benchmarks. We report the property proved/disproved, the expected/actual result, and the \nFigure 7: The results of applying our re.nement algorithm on a variety time. For each property (1 27) \nwe have also at\u00ad of examples from industrial code. In each case, we report the shape of the tempted to \nprove/disprove the negated property (28 property, the expected/actual result returned by our tool, and \nthe time it took to 54). Benchmarks 28 54 are the same as 1 27 but with prove the property or discover \na counterexample. Benchmarks 29 56 are the the property negated. same as 1 28 but with the property negated. \n In Figure 7 we report the results of applying our tool to CTL challenge problems drawn from industrial \ncode bases. The exam\u00adples were taken from code models of the I/O subsystem of the Windows kernel, the \nback-end infrastructure of the PostgreSQL database server, and the SoftUpdates patch system [25]. Line \ncounts are given in the third column. In many of these cases, heap\u00adcommands from the original sources \nhave been abstracted away using the approach due to Magill et al. [29]. This abstraction in\u00adtroduces \nnew arithmetic variables that track the sizes of recursive predicate found as a byproduct of a successful \nmemory safety anal\u00adysis using an abstract domain based on separation logic. Note that this abstraction \noften allows us to reason about nondeterminism re\u00adlated to data-structures (e.g. a subroutine that increases \nthe length of a list by some nondeterministic amount). For each benchmark, we considered a meaningful \nproperty. Many are standard acquire/release or malloc/free-style properties (AG[p . AFq]) and, for example, \nthe OS frag. 4 property (Fig\u00adure 7, #13) says that either an I/O completion occurs successfully or else \na failure code is returned. Figure 7 reports the shape of these properties (eliding the details of the \natomic propositions p, q, etc.). The .nal columns of Figure 7 report the expected/actual result returned \nby our tool, and the time it took to prove the property or discover a counterexample. In the vast majority \nof the cases, we were able to prove/disprove the property, often very quickly. In Previous tools based \non .xed a priori abstractions are known for CTL. The abstraction used by YASM [23] is aimed primarily \nat the unnested existential subset of CTL. The work of Song and Touili [36] abstracts the program to \npushdown systems. The dif\u00adference here is that we reduce the problem of CTL (in a way that information \nis not lost) to different problems, which allows abstrac\u00adtions to be computed by re.nement later using \nknown techniques. Although we solve a problem more general than termination, our iterative algorithm \nfor .nding restrictions on the state-space shares some similarity with the idea of alternation used in \nHarris et al. [24]. Related approaches are also seen in Godefroid et al. [19] and Gulavani et al. [20] \nfor proving safety properties. Our work characterizes CTL veri.cation in a way that is complete upto \na certain parameter (chutes) and gives a method and implementation for discovering these parameters automati\u00adcally. \nIn this sense it may be applicable to discovering focus sets [14] or the necessary ingredients in a games-based \nabstrac\u00adtion framework [15]. Our paper also might contribute towards novel approaches to the known problem \nof supporting mixtures of may/must [19]. Speci.cally we contribute a reduction that facil\u00aditates existing \nsuccessful universal techniques (e.g. predicate ab\u00adstraction, interpolation, etc) and gives a more general \nunderap\u00adproximation for existential properties than previously known ap\u00adproaches to may/must abstraction. \n * some cases, our implementation ran out of memory (mem) while performing SYNTHcp. We believe that these \nexamples could be proved if we applied program slicing on the encoding E. In one case our implementation \ntimed out (time) after 24 hours. In summary, we can prove CTL properties of C functions Kesten and Pnueli \n[27] describe a proof system for CTL . Due to our desire for full automation, ours differs in signi.cant \nways. For example, while a proof of eventuality (AFq or EFq) in our case involves reasoning along paths \nuntil q, we do not decom\u00adpose into path assertions in the proof system. Instead, we identify that have \nhundreds of lines of code. For example, OS frag. 3 is the appropriate fragment of the transition relation \n(i.e. R F C ) and ple safety/liveness) and the strictly-universal industrial examples 370 LOC. The majority \nof the examples (both the small bench-X a general property that must hold of this transition relation \n(well\u00ad marks in Figure 6 and industrial code in Figure 7) were exam\u00ad foundedness). In this way, we leave \nthe details of eventuality prov\u00ad ples that previously could not be proved. The exceptions are the ing \nto underlying abstraction techniques such as interpolation or single-temporal-operator small benchmarks \n(which reduce to sim\u00ad abstraction re.nement. This simpli.es the proof system and lends such as #21, \nwhich can be treated by previous work [11]. itself many different forms of reasoning over R F C . It \nis reasonable to ask about a comparison between our tool on X There are a few other connections to existing \nwork. Pruning the property AFfalse (which encodes termination) and a termina\u00adtion prover, or EGtrue \nand a non-termination prover. In fact, in our system the encoding of AFfalse is isomorphic to the reduction \nused in tools such as T ERMINATOR [12], similarly EGtrue in our sys\u00adtem reduces immediately to the identical \ntechniques used in current non-termination provers. Thus, the experimental results are essen\u00adtially identical, \nwith the variability in the performance only due to the level of optimizations implemented in the underlying \ntools. 7. Related Work Temporal property veri.cation (and related problems such as .nd\u00ading winning strategies \nin games) have been extensively studied for .nite-state systems (e.g. [1, 4, 6, 7, 28, 37]). Temporal \nproperty paths (as we do in chute re.nement) appears in many static analy\u00adsis techniques [21, 41]. Second, \nin our work we synthesize program variables that correspond to properties of the transition system (or \nof the desired system). The success of similar techniques in other contexts [35] reinforces the practical \npotential and experimental re\u00adsults of our paper. Finally, Vardhan and Viswanathan [38] describe tool \ncalled Lever which uses language inference to discover .xed points. These .xed points could potentially \nbe used in conjunction with our method once we have discovered the appropriate state re\u00adstrictions. \n8. Concluding Remarks Until now, the question of how to reliably automate proofs in * veri.cation for \nsome limited types of in.nite-state systems have also been studied (e.g. pushdown systems [36, 39, 40], \nparameter\u00adized systems [17], etc). In limited cases we can abstract programs to .nite-state systems and \napply these known methods, but existing abstraction methods usually do not allow us to reliably prove \nprop\u00aderties that mix universal and existential modal operators in non\u00adtrivial ways. Methods for proving \nlinear-time properties of in.nite\u00adstate programs have been studied in recent work (e.g. [8, 9, 13, 33]). \nThese techniques do not, however, facilitate reasoning about the nondeterminism in systems (see [9] for \na discussion on this). Methods of proving branching-time properties with only univer\u00adsal path quanti.ers \nare known (e.g. [5, 10, 11, 13]). Techniques are also known for proving AF false (a.k.a. termination \n[3, 12, 18]) as well as EG true (a.k.a. non-termination [22]). In this work we build on these known techniques. \nbranching-time logics (such as CTL, CTL and the modal \u00b5\u00adcalculus) for in.nite-state programs remained \nan open problem. In this paper we have reported on the .rst known robust automatic proof method to support \nboth universal and existential branching\u00adtime temporal operators (in CTL) for programs. In our approach \nex\u00adistential reasoning is reduced to universal reasoning together with the search for a restrictions \non the program s state-space. The ad\u00advantage of the approach is that there are known solutions for uni\u00adversal \nreasoning. To demonstrate the practical viability of our ap\u00adproach we discussed the outcome of an experimental \nevaluation with a prototype implementation using examples drawn the Post\u00adgreSQL database server, the \nSoftUpdates patch system, the Win\u00addows OS kernel. There are a few open problems left as future work. \nIt would be helpful to have a more extensive evaluation considering, for exam\u00adple, performance of properties \nthat have high levels of nesting in the temporal operators. Further, one might bring these techniques \nto the interprocedural level, investigating the use of temporal lem\u00admas to optimize the performance of \nthe proof search. Finally, these techniques could be extended to more expressive logics such as CTL * \nand the modal \u00b5-calculus.   Acknowledgments We thank Carsten Fuhs, Peter O Hearn, John Wickerson, and \nthe anonymous reviewers for their valuable feedback. References [1] BERNHOLTZ, O. , VARDI, M. Y., AND \nWOLPER, P. An automata\u00adtheoretic approach to branching-time model checking (extended ab\u00adstract). In CAV \n94 (1994), D. L. Dill, Ed., vol. 818, Springer, pp. 142 155. [2] BEYER, D. , HENZINGER, T. A. , JHALA, \nR., AND MAJUMDAR, R. The software model checker blast. STTT 9, 5-6 (2007), 505 525. [3] BRADLEY, A., \nMANNA, Z., AND SIPMA, H. The polyranking prin\u00adciple. Automata, Languages and Programming (2005), 1349 \n1361. [4] BURCH, J., CLARKE, E., ET AL. Symbolic model checking: 1020 states and beyond. Information \nand computation 98, 2 (1992), 142 170. [5] CHAKI, S., CLARKE, E. M. , GRUMBERG, O., OUAKNINE, J., SHARYGINA, \nN., TOUILI, T., AND VEITH, H. State/event soft\u00adware veri.cation for branching-time speci.cations. In \nIFM 05 (2005), J. Romijn, G. Smith, and J. van de Pol, Eds., vol. 3771, pp. 53 69. [6] CLARKE, E. , JHA, \nS. , LU, Y., AND VEITH, H. Tree-like counterex\u00adamples in model checking. In LICS (2002), pp. 19 29. [7] \nCLARKE, E. M. , EMERSON, E. A., AND SISTLA, A. P. Automatic veri.cation of .nite-state concurrent systems \nusing temporal logic speci.cations. TOPLAS 8 (April 1986), 244 263. [8] COOK, B., GOTSMAN, A., PODELSKI, \nA., RYBALCHENKO, A., AND VARDI, M. Y. Proving that programs eventually do something good. In POPL 07 \n(2007), pp. 265 276. [9] COOK, B., AND KOSKINEN, E. Making prophecies with decision predicates. In POPL \n11 (2011), T. Ball and M. Sagiv, Eds., ACM, pp. 399 410. [10] COOK, B., KOSKINEN, E., AND VARDI, M. \nTemporal veri.cation as a program analysis task [extended version]. FMSD (2012). [11] COOK, B., KOSKINEN, \nE., AND VARDI, M. Y. Temporal prop\u00aderty veri.cation as a program analysis task. In CAV 11 (2011), G. \nGopalakrishnan and S. Qadeer, Eds., vol. 6806, Springer, pp. 333 348. [12] COOK, B., PODELSKI, A., AND \nRYBALCHENKO, A. Termination proofs for systems code. In PLDI 06 (2006), M. I. Schwartzbach and T. Ball, \nEds., pp. 415 426. [13] COUSOT, P. , AND COUSOT, R. An abstract interpretation framework for termination. \nIn POPL 12 (2012), ACM, pp. 245 258. [14] DAMS, D., AND NAMJOSHI, K. S. The existence of .nite abstractions \nfor branching time model checking. In LICS (2004), pp. 335 344. [15] DE ALFARO, L. , GODEFROID, P. , \nAND JAGADEESAN, R. Three\u00advalued abstractions of games: Uncertainty, but with precision. In LICS (2004), \npp. 170 179. [16] EMERSON, E. A., AND HALPERN, J. Y. sometimes and not never revisited: on branching \nversus linear time temporal logic. J. ACM 33, 1 (1986), 151 178. [17] EMERSON, E. A., AND NAMJOSHI, K. \nS. Automatic veri.cation of parameterized synchronous systems (extended abstract). In CAV 96 (1996), \nvol. 1102, pp. 87 98. [18] GIESL, J. , SCHNEIDER-K AMP, P., AND THIEMANN, R. Aprove 1.2: Automatic termination \nproofs in the dependency pair framework. Automated Reasoning (2006), 281 286. [19] GODEFROID, P., NORI, \nA. V. , RAJAMANI, S. K. , AND TETALI, S. Compositional may-must program analysis: unleashing the power \nof alternation. In POPL 10 (2010), ACM, pp. 43 56. [20] GULAVANI, B. S., HENZINGER, T. A. , KANNAN, Y. \n, NORI, A. V., AND RAJAMANI, S. K. SYNERGY: a new algorithm for property checking. In FSE 06 (2006), \nACM, pp. 117 127. [21] GULWANI, S., JAIN, S., AND KOSKINEN, E. Control-.ow re.ne\u00adment and progress invariants \nfor bound analysis. In PLDI 09 (2009), pp. 375 385. [22] GUPTA, A., HENZINGER, T. A., MAJUMDAR, R., RYBALCHENKO, \nA., AND XU, R.-G. Proving non-termination. SIGPLAN Not. 43 (January 2008), 147 158. [23] GURFI NKEL, \nA. , WEI, O., AND CHECHIK, M. Yasm: A software model-checker for veri.cation and refutation. In CAV 06 \n(2006), vol. 4144, pp. 170 174. [24] HARRIS, W. R., LAL, A., NORI, A. V., AND RAJAMANI, S. K. Alternation \nfor termination. In SAS (2010). [25] HAYDEN, C. M., MAGILL, S., HICKS, M., FOSTER, N., AND FOS-TER, J. \nS. Specifying and verifying the correctness of dynamic soft\u00adware updates. In VSTTE 12 (2012), vol. 7152, \npp. 278 293. [26] IOSIF, R., BOZGA, M., BOUAJJANI, A., HABERMEHL, P. , MORO, P., , AND VOJNAR, T. Programs \nwith lists are counter automata. In CAV (2006). [27] KESTEN, Y., AND PNUELI, A. A compositional approach \nto ctl* veri.cation. Theor. Comput. Sci. 331, 2-3 (2005), 397 428. [28] KUPFERMAN, O. , VARDI, M., AND \nWOLPER, P. An automata\u00adtheoretic approach to branching-time model checking. Journal of the ACM 47, 2 \n(2000), 312 360. [29] MAGILL, S. , TSAI, M.-H., LEE, P., AND TSAY, Y.-K. Automatic numeric abstractions \nfor heap-manipulating programs. In POPL 10 (2010), ACM, pp. 211 222. [30] MCMILLAN, K. L. Lazy abstraction \nwith interpolants. In CAV 06 (2006), T. Ball and R. B. Jones, Eds., vol. 4144, pp. 123 136. [31] NELSON, \nG. A generalization of Dijkstra s calculus. TOPLAS 11, 4 (1989), 517 561. [32] PISTORE, M., AND TRAVERSO, \nP. Planning as model checking for extended goals in non-deterministic domains. In IJCAI 01 (2001), Springer. \n[33] PNUELI, A., AND ZAKS, A. Psl model checking and run-time veri.\u00adcation via testers. In FM (2006), \npp. 573 586. [34] PODELSKI, A., AND RYBALCHENKO, A. Transition invariants. In LICS (2004), pp. 32 41. \n[35] SOLAR-L EZAMA, A., TANCAU, L. , BOD\u00b4 IK, R., SESHIA, S. A., AND SARASWAT, V. A. Combinatorial sketching \nfor .nite programs. In PLDI (2006), ACM, pp. 404 415. [36] SONG, F. , AND TOUILI, T. Pushdown model checking \nfor malware detection. In TACAS (2012). [37] STIRLING, C. Games and modal mu-calculus. In TACAS (1996), \nvol. 1055, pp. 298 312. [38] VARDHAN, A., AND VISWANATHAN, M. Learning to verify branch\u00ading time properties. \nFMSD 31, 1 (2007), 35 61. [39] WALUKIEWICZ, I. Pushdown processes: Games and model checking. In CAV (1996), \nvol. 1102, pp. 62 74. [40] WALUKIEWICZ, I. Model checking ctl properties of pushdown sys\u00adtems. In FSTTCS \n(2000), S. Kapoor and S. Prasad, Eds., vol. 1974, pp. 127 138. [41] YANG, Z. , AL-R AWI, B. , SAKALLAH, \nK. A., HUANG, X., SMOLKA, S. A. , AND GROSU, R. Dynamic path reduction for soft\u00adware model checking. \nIn IFM (2009), vol. 5423, pp. 322 336.  \n\t\t\t", "proc_id": "2491956", "abstract": "<p>Branching-time temporal logics (e.g. CTL, CTL*, modal mu-calculus) allow us to ask sophisticated questions about the nondeterminism that appears in systems. Applications of this type of reasoning include planning, games, security analysis, disproving, precondition synthesis, environment synthesis, etc. Unfortunately, existing automatic branching-time verification tools have limitations that have traditionally restricted their applicability (e.g. push-down systems only, universal path quantifiers only, etc).</p> <p>In this paper we introduce an automation strategy that lifts many of these previous restrictions. Our method works reliably for properties with non-trivial mixtures of universal and existential modal operators. Furthermore, our approach is designed to support (possibly infinite-state) programs.</p> <p>The basis of our approach is the observation that existential reasoning can be reduced to universal reasoning if the system's state-space is appropriately restricted. This restriction on the state-space must meet a constraint derived from recent work on proving non-termination. The observation leads to a new route for implementation based on existing tools. To demonstrate the practical viability of our approach, we report on the results applying our preliminary implementation to a set of benchmarks drawn from the Windows operating system, the PostgreSQL database server, SoftUpdates patching system, as well as other hand-crafted examples.</p>", "authors": [{"name": "Byron Cook", "author_profile_id": "81323489213", "affiliation": "Microsoft Research Cambridge &#38; University College London, Cambridge, United Kingdom", "person_id": "P4149003", "email_address": "bycook@microsoft.com", "orcid_id": ""}, {"name": "Eric Koskinen", "author_profile_id": "81350575010", "affiliation": "New York University, New York, NY, USA", "person_id": "P4149004", "email_address": "ejk@cims.nyu.edu", "orcid_id": ""}], "doi_number": "10.1145/2491956.2491969", "year": "2013", "article_id": "2491969", "conference": "PLDI", "title": "Reasoning about nondeterminism in programs", "url": "http://dl.acm.org/citation.cfm?id=2491969"}