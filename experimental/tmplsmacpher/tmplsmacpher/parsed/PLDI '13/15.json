{"article_publication_date": "06-16-2013", "fulltext": "\n CONCURRIT: A Domain Speci.c Language for Reproducing Concurrency Bugs : Tayfun Elmas Jacob Burnim \n; George Necula Koushik Sen Department of Electrical Engineering and Computer Sciences, University of \nCalifornia, Berkeley {elmas,jburnim,necula,ksen}@cs.berkeley.edu Abstract We present CONCURRIT, a domain-speci.c \nlanguage (DSL) for re\u00adproducing concurrency bugs. Given some partial information about the nature of \na bug in an application, a programmer can write a CONCURRIT script to formally and concisely specify \na set of thread schedules to explore in order to .nd a schedule exhibiting the bug. Further, the programmer \ncan specify how these thread schedules should be searched to .nd a schedule that reproduces the bug. \nWe implemented CONCURRIT as an embedded DSL in C++, which uses manual or automatic source instrumentation \nto partially con\u00adtrol the scheduling of the software under test. Using C ONCURRIT, we were able to write \nconcise tests to reproduce concurrency bugs in a variety of benchmarks, including the Mozilla s SpiderMon\u00adkey \nJavaScript engine, Memcached, Apache s HTTP server, and MySQL. Categories and Subject Descriptors D.2.5 \n[Software Engineer\u00ading]: Testing and Debugging; F.3.1 [Logics and Meanings of Pro\u00adgrams]: Specifying \nand Verifying and Reasoning about Programs Keywords Concurrency Errors; Domain-Speci.c Languages; Software \nTesting 1. Introduction To diagnose and .x a software bug, a programmer often needs to .rst reproduce \nthe bug. That is, given some partial information about the nature of the bug e.g., from a bug report \nor from directly observing erroneous program behavior the program\u00admer constructs a test scenario in \nwhich they execute some piece of their software so that it reliably exhibits the bugs. Reproducing such \nbugs can require controlling a number of sources of nondeter\u00adminism in a program s execution, including \nprogram inputs, library dependencies, and interactions with the underlying operating sys\u00adtem. This task \nis especially challenging for concurrent programs, where a bug may occur only under very speci.c interleavings \nof a program s threads. :The author is currently af.liated with Google, Inc., and can be reached at tayfunelmas@gmail.com. \n;The author is currently af.liated with Sift Science, Inc., and can be reached at jburnim@gmail.com. \nPermission to make digital or hard copies of all or part of this work for personal or classroom use is \ngranted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page. To copy otherwise, to republish, \nto post on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. PLDI \n13, June 16 19, 2013, Seattle, WA, USA. Copyright c &#38;#169;2013 ACM 978-1-4503-2014-6/13/06. . . $15.00 \n To reproduce concurrent bugs in practice, programmers often do stress testing. In stress testing, a \nprogrammer imposes no con\u00adtrol over the scheduling of threads. Rather, to increase the chance of examining \ndifferent and interesting schedules, the programmer cre\u00adates a long-running test scenario with a large \nnumber of threads. In addition, the programmer adds perturbations to the timings of the threads by exploiting \nher (partial) knowledge about the bug. For example, if the programmer has intuition about potentially \nprob\u00adlematic locations in the code, she inserts sleep statements at these locations to perturb the thread \nschedule in a certain way. Such tests can be long-running and the resulting buggy executions can be very \ndif.cult to understand and debug due to the large number of threads and complex test setups. Manually \ncontrolling the schedule, e.g., by inserting sleeps, can be ad hoc and unreliable and may require nontrivial \nmodi.cations in the program text. In this paper, we propose CONCURRIT, a domain-speci.c lan\u00adguage (DSL) \nfor reproducing concurrency bugs. When using C ON-CURRIT to reproduce a bug, as with the existing approaches \nde\u00adscribed above, a programmer begins with partial knowledge about the bug, for example, a number of \nthreads and some intuition about how to schedule these threads to exhibit the bug. Then, the pro\u00adgrammer \nalso writes a test script in the CONCURRIT language. This CONCURRIT test script expresses the programmer \ns knowledge about the bug formally and concisely. In particular, the test script describes a set of potentially-problematic \nthread schedules among which the programmer intends to search for the target, buggy in\u00adterleaving. For \nthis, the test script dictates partial constraints on the thread schedule, for example, which threads \nare allowed to be in\u00adterleaved at which point of the execution, or at which code location or under what \nconditions a context switch will happen. At runtime, the script guides the interleaving of threads, within \nthe constraints given in the script, to generate these thread schedules. CONCURRIT also gives the programmer \nthe ability to imple\u00adment various techniques to search for the target schedules. For ex\u00adample, combined \nwith automatic or manual instrumentation of the program under test, the programmer can impose any level \nof con\u00adtrol from none at all, as in random search, to full control of the thread schedule, as in model \nchecking (e.g., [19]). For this, the pro\u00adgrammer uses DSL constructs to explicitly indicate nondeterminis\u00adtic \nchoices in the interleaving (e.g., a set of threads one of which will be scheduled next). At each execution \nof the test, these choices are resolved in a controlled manner, in order to search for distinct thread \nschedules with respect to these choices. While the choice points for the schedule are explicitly indicated \nin the C ONCURRIT test, the underlying mechanics of the search are transparent to the programmer. For \nexample, the search can be implemented indepen\u00addently from the test by employing one of a number of search \nstrate\u00adgies we provide, such as depth-and breadth-.rst searches. This ap\u00adproach also enables rapid prototyping \nand evaluation of a custom search strategy by writing and exploring a C ONCURRIT test. CONCURRIT allows \na programmer to simply specify and ex\u00adplore a set of thread schedules with various degrees of .exibility. \nFor example, the programmer may start with little intuition about a bug and write a fully nondeterministic \nCONCURRIT test (i.e., any thread may be scheduled any time), which results in a high num\u00adber of thread \nschedules. As she gains more insight about the bug based on the results of the C ONCURRIT test, she can \nre.ne the test to incorporate new insights, search fewer schedules, and reproduce the target bug more \nquickly. For example, if the programmer thinks that the bug resides in a small number of critical functions, \nshe can modify the test to express her interest in different interleavings of threads only when the program \nis in one of these functions, leav\u00ading a reasonable number of interleavings to explore. Furthermore, \none can write a fully deterministic test, which speci.es an exact schedule triggering the bug. A C ONCURRIT \ntest specifying one or few schedules can be used to formally document the bug and for regression testing \nafter the bug is .xed. Searching for thread schedules in our work carries similari\u00adties to model checking \ntechniques that enumerate thread sched\u00adules, e.g., [6, 14, 19, 21]. However, our approach diverges from \nthe traditional model checking in two signi.cant aspects. First, in the CONCURRIT approach, the programmer \ncan guide the exploration of the schedules by imposing, within the test script, constraints on individual \nschedules. This allows the programmer to restrict and localize the search, and to focus on small number \nof interesting program states and interleavings, and have the search terminate ear\u00adlier. Second, the \ntraditional notion of model checking assumes that (1) the thread schedule is a primary source of nondeterminism, \nand (2) the entire thread schedule can be controlled. These assumptions are fundamental for the soundness \nguarantees of such model check\u00ading. Nevertheless, these assumptions only hold for relatively small programs, \nnot for large, complex software, such as web browsers and servers. Controlling the entire schedule is \nchallenging for large programs, because precisely repeating an entire execution pre.x is very dif.cult \ndue to sources of nondeterminism (e.g., timing of computations and network events) other than the thread \nschedule. Therefore, we accept that totally avoiding uncontrolled nondeter\u00adminism is not realistic in \npractice, and we develop our testing ap\u00adproach to embrace the possibility of uncontrollable nondetermin\u00adism. \nA C ONCURRIT test can describe the controlled nondetermin\u00adism for part of the thread schedule and leave \nthe rest of the schedule unspeci.ed. As a result, for example, a search for distinct thread schedules \nwith respect to the controlled nondeterministic choices in the CONCURRIT test can be performed in the \npresence of par\u00adtially uncontrolled interleavings of threads. In fact, we do not have to control the \nentire thread schedule, because concurrency bugs in general can be triggered by controlling only a small \n(but critical) part of the schedule. From this point of view, our approach inherits the imperfect but \nlightweight and tolerant notion of control from sleep-based approaches, and formal notion of search from \nmodel checking.  Contributions and outline. In Section 2, we present a case study showing how to use \nCONCURRIT to reproduce a real bug in Mozilla s SpiderMonkey JavaScript engine. We formally present the \nC ONCURRIT DSL, discuss how to write C ONCURRIT search strategies, and present several high-level CONCURRIT \nconstructs and patterns for writing effective and concise CONCURRIT test scripts, in Sections 3, 4, and \n5, respectively. In Section 6, we present our implementation of CONCURRIT as an embedded DSL in C++. \nOur framework supports the use of C ONCURRIT for both unit test\u00ading within a single process and system \ntesting involving multi\u00adple processes. In Section 7, we describe our experimental evalu\u00adation of CONCURRIT, \non a number of of multithreaded programs from well-known Inspect [26], PARSEC [3], and RADBench [12] \nbenchmark suites. Our benchmarks include large software such as the Mozilla s SpiderMonkey JavaScript \nengine, Memcached, the Apache HTTP server, and MySQL. We demonstrate the expres\u00adsiveness and usefulness \nof C ONCURRIT by writing tests to repro\u00adduce concurrency bugs in these benchmarks. Our implementation \nis available at http://code.google.com/p/concurrit/. 2. Overview: Writing tests in CONCURRIT We present \na case study of using CONCURRIT from the perspective of a programmer who wants to write a test to reproduce \na con\u00adcurrency bug. We consider a real concurrency bug in the Mozilla SpiderMonkey JavaScript Engine \n(version 1.8RC1), a large software system with 121K lines of code. (In Section 7 this bug is named spidermonkey2.) \nThe related bug report can be found at: https://bugzilla.mozilla.org/show_bug.cgi?id=478336. The bug \nmanifests itself as an assertion violation and can be trig\u00adgered using the multithreaded program given \nin Figure 1 (supplied with the bug report). We refer to this program as the software\u00adunder-test (SUT). \nThe bug report shows a progressive understanding of the buggy interleaving. The report starts from the \nstress testing of the code in Figure 1 with 100 threads to reproduce the bug. Then, the programmers collect \ninformation from the stack traces of buggy executions to identify problematic code locations and schedules. \nFinally, they .gure out a scenario, given in Figure 2, describing of a suspicious interleaving of three \nthreads A, B, and C executing testfunc in Figure 1. Notice that, this scenario is still partial: It explains \nthe key scheduling decisions to bring the execution to a problematic pro\u00adgram state, say S, after which \nit will be highly likely that the bug will manifest. But, the description leaves unspeci.ed the rest \nof the schedule, from S to the assertion violation. By writing a C ONCUR-RIT test, we can specify 1) \nthe known scheduling decisions until S and 2) a search for the missing part of the buggy schedule after \nS. In this section, we demonstrate how to write tests in CONCUR-RIT to incrementally capture the different \nstages of understanding of the bug in the bug report. We will start with simple CONCURRIT tests that \nassume little knowledge about the bug i.e., having three threads running the code in Figure 1, but not \nknowing how to inter\u00ad leave them. To begin, we found it useful to .rst check whether the bug is due to \nconcurrency (Section 2.1), then continue with tests with many possible thread schedules, but that do \ntrigger the bug. These tests will require searching among a large number of thread schedules for a buggy \none. We will subsequently incorporate more and more intuition from the bug report to make our test more \npre\u00adcise and ef.cient, by searching among fewer schedules. In this way: (1) we show that a CONCURRIT \nscript can formally and concisely express the intuition of the programmer at various levels of detail, \nstatic JSRuntime *rt; static void* testfunc(void* ignored) { JSContext *cx = JS_NewContext(rt, 0x1000); \nif (cx) { JS_BeginRequest(cx); JS_DestroyContext(cx); } return NULL;  } int main(void) { rt = JS_NewRuntime(0x100000); \nif (rt == NULL) return 1; ... // create threads to run testfunc (and join all) return 0; } Figure 1. \nTest code manifesting a bug in SpiderMonkey (taken from the related bug report). 1 Now suppose there \nare 3 threads, A, B, C running testfunc. 2 Threads A and B call js DestroyContext and thread C calls \njs NewContext. 3 First thread A removes its context from the runtime list. That context is not 4 the \nlast one so thread does not touch rt\u00b4astate and eventually calls js GC. 5 The latter skips the above \ncheck and tries to to take the GC lock. 6 Before this moment the thread B takes the lock, removes its \ncontext from the 7 runtime list, discovers that it is the last, sets rt\u00b4astate to LANDING, runs 8 the-last-context-cleanup, \nruns the GC and then sets rt\u00b4astate to DOWN. 9 At this stage the thread A gets the GC lock, setup itself \nas the thread that 10 runs the GC and releases the GC lock to proceed with the GC 11 when rt\u00b4astate \nis DOWN. 12 Now the thread C enters the picture. It discovers under the GC lock in 13 js NewContext that \nthe newly allocated context is the .rst one. Since 14 rt\u00b4astate is DOWN, it releases the GC lock and \nstar ts the .rst context 15 initialization procedure. That procedure includes the allocation of the initial \n16 atoms and it will happen when the thread A runs the GC. 17 This may lead precisely to the .rst stack \ntrace from the comment 4. Figure 2. Bug scenario, taken from Comment #5 of the bug report, describing \nan interleaving of threads for the program in Figure 1. and (2) we highlight the common usage patterns \nof our DSL that we follow in our experiments. (In Section 5.1 we revisit the general form of these patterns.) \nWhile we demonstrate only a few steps of re.ning C ONCURRIT tests, in reality, we do not always expect \nto have a quick transition between tests, and there may be more steps before obtaining a practical test. \nWe expect the error information (such as stack traces) from the failing executions in earlier steps will \nplay the role of bug reports to re.ne tests for the later steps. Although the earlier tests .nd the bug, \nour goal is not only to trigger the bug, but to have concise, informative, and targeted (towards the \nbug) tests. 2.1 First test: Run threads sequentially until completion To begin, suppose that our intuition \nabout our target interleaving is limited: We know that three distinct threads, A, B, and C, are suf.cient \nto reproduce the bug, but we do not know how to sched\u00adule these threads to trigger the error. Indeed, \nwe do not even know whether the bug is sequential or concurrent. Thus, before interleav\u00ading the threads, \nwe want to check if the bug is really related to con\u00adcurrency. For this, we want to run every thread \nsequentially, i.e., without being interleaved with another thread until its completion. Our .rst C ONCURRIT \ntest is as follows: SearchSeqTest : 1 Tid tA, tB, tC WaitForDistinctThreadsp3, ThreadStartsq; 2 whilep!HasEndedptAq \n} !HasEndedptBq } !HasEndedptCqq t 3 Tid t ChooseThreadptA, tB, tCq; 4 RunThreadUntilpt, ThreadEndsq; \n5 } A CONCURRIT test is run concurrently with the SUT (in Fig\u00adure 1)and controls the scheduling of the \nthreads in the SUT. Test SearchSeqTest demonstrates two kinds of control CONCURRIT can impose on the \nschedule: (1) It describes how the threads A, B, and C in each execution should be scheduled; in our \ncase, each thread runs sequentially (without interleaving with another thread) until completion. (2) \nIt describes a set of schedules satisfying the constraint in (1) and differ in the scheduling order of \nthreads. In or\u00adder to realize this control, the SUT is instrumented to interact with the C ONCURRIT script. \nThe C ONCURRIT script hides the mecha\u00adnism for this interaction from the programmer and allows her to \nspecify the thread schedule without thinking about the low-level details of how the SUT is controlled. \nThe diagram in Figure 3 illustrates the interaction between three threads in the SUT and the test SearchSeqTest. \nFunc\u00adtion WaitForDistinctThreads at Line 1 waits for three distinct Figure 3. Interaction between the \nSUT threads and test script. threads in the SUT to run and reach a point satisfying its second argument \n(ThreadStarts), then binds variables tA, tB, and tC to the identi.ers of those threads. The predicate \nThreadStart indi\u00adcates that this binding occurs when the threads start executing. On binding, each thread \nis blocked until re-enabled by the test. At lines 2-5, the test controls the execution of threads tA, \ntB, and tC in a loop, which iterates until all the threads terminate (line 2). At each iteration, ChooseThread \nnondeterministically chooses one of the variables tA, tB, and tC (line 3) and assigns it to variable \nt. Then, RunThreadUntil enables the chosen thread referred to by t to execute (line 4). The second argument \nof RunThreadUntil indicates until when the thread will be allowed to execute. The predicate ThreadEnds \nindicates that thread t should keep running until it terminates. While t is executing, the other two \nthreads remain blocked. In addition, since the test binds only three threads, all other threads in the \nSUT remain blocked until the loop ends, after which the control on the SUT imposed by the test is removed. \nControlled nondeterminism. The command ChooseThread speci.es a nondeterministic choice of given arguments. \nThis non\u00addeterminism is controlled by our test and resolved to implement a search for thread schedules. \nFor example, one can implement ran\u00addom testing by using a random number generator to choose the thread. \nIn our work, we provide a search strategy that restarts the SUT multiple times and explores a distinct \ncombination of these choices until all distinct combinations are enumerated. This pro\u00advides the mechanism \nto search for all possible thread schedules speci.ed by the CONCURRIT test. During this search, for ex\u00adample, \nif ChooseThread chooses an already-terminated thread, RunThreadUntil timeouts and restarts the SUT to \nexplore a differ\u00adent schedule. While the choice points for the schedule are indicated explicitly using \nChooseThread, the underlying search strategy is transparent to the programmer. Thus, as explained in \nSection 4, one can customize the search independently of the test, for example to follow a depth-.rst \nor breath-.rst order. When guided by the test SearchSeqTest, our search generates 6 thread schedules \nin which threads tA, tB, tC are run in different orders (but sequentially). However, these schedules \ndo not trigger the assertion violation. This con.rms our intuition that the bug is due to concurrency. \nThus, we need to allow threads to interleave with each other to trigger the bug.  2.2 Second test: Interleave \nthreads at .nest granularity In our second test we want to interleave the threads. But, suppose we still \ndo not have any knowledge about what interleavings will trigger the bug. Our next step is to allow threads \nto interleave arbitrarily, and search for the buggy interleaving among these .ne\u00adgrained interleavings. \nWe can slightly change SearchSeqTest to permit such interleaving of threads tA, tB, and tC as follows: \nSearchAllTest : 1 Tid tA, tB, tC WaitForDistinctThreadsp3, ThreadStartsq; 2 whilep!HasEndedptAq } !HasEndedptBq \n} !HasEndedptCqq t 3 Tid t ChooseThreadptA, tB, tCq; 4 RunThreadUntilpt, ReadsMem }WritesMem }CallsFunc}ThreadEndsq; \n5 } We modify line 4 to replace the predicate ThreadEnds with ReadsMem }WritesMem }CallsFunc}ThreadEnds. \nThe new predicate indicates that thread t (chosen at line 3) should run until it attempts to access the \nmemory (read from or write to an address), calls a function, or terminates. When thread t attempts to \nperform one of these operations, the command RunThreadUntil ends and leaves thread t blocked before that \noperation. When RunThreadUntil is called again with t bound to the same thread, it .rst unblocks the \nthread to let it complete the operation, and then runs the thread until next operation satisfying the \npredicate. As it allows threads to interleave at .ne granularity, our second test SearchAllTest can generate \nthe buggy thread schedule vio\u00adlating the assertion. However, the buggy schedule is generated after exploring \nmillions of schedules of the test. This means, whenever we want to reproduce the bug using this test, \nwe have to wait for days to see the assertion violation. Although the test allows us to examine all schedules, \nthere are a huge number of them. Moreover, the bug is triggered by a small number of tricky interleavings; \nthus, most of the schedules do not create the buggy situation. Thus, it will not be practical to use \nSearchAllTest for the purpose of repro\u00adducing the bug. (It is for this reason that traditional model \nchecking is often impractical to use for large software.)  2.3 Third test: Localize search to suspicious \nstates The real power of CONCURRIT can be seen when we need to re\u00adstrict the search space of interleavings. \nNote that, SearchAllTest runs the search for the entire lifetime of the threads. After ex\u00adamining the \nexecutions with assertion violations generated by SearchAllTest, we next localize the search for interleavings \nto a shorter period of the execution in order to enumerate fewer inter\u00adleavings and to more quickly reach \nthe intended state at which the assertion is violated. We re.ne our test as follows: SearchInBuggyTest \n: 1 Tid tA, tB, tC WaitForDistinctThreadsp3, EntersFuncpJS NewContextqq; 2 RunThreadsUntilptA, tB, EntersFuncpJS \nDestroyContextqq; 3 RunThreadUntilptA, InFuncpjs GCq&#38;&#38; ReadsMemp&#38;rt\u00b4astateqq; 4 RunThreadUntilptB, \nThreadEndsq; // thread B does not involve after this point 5 RunThreadUntilptA, InFuncpjs GCq&#38;&#38; \nWritesMemp&#38;rt\u00b4agcThreadqq; 6 whilepInFuncptA, JS DestroyContextq } InFuncptC, JS NewContextqq t 7 \nTid t ChooseThreadptA, tCq; 8 RunThreadUntilpt, ReadsMem }WritesMem }CallsFunc}ThreadEndsq; 9 } We \n.rst notice that the problematic portion of the interleaving is after threads A and B call JS DestroyContext \nand thread C calls JS NewContext. Thus, we want to only examine interleavings starting not from the beginning \nof the execution, but after the threads enter these functions. We incorporate this new insight to our \nCONCURRIT test as follows. First, we replace the condition ThreadStart at line 1 with EntersFuncpJS NewContextq. \nThe new version of WaitForDistinctThreads waits until the threads all start executing JS NewContext and \nthen get blocked. Then, the command RunThreadsUntil at line 2 runs threads tA and tB (permitting them \nto interleave) until both threads start running JS DestroyContext, at which point they are blocked. \nFurthermore, at lines 3-5 we explicitly schedule the threads to lead the execution towards a problematic \nstate (discussed below). The search for distinct interleavings starts after this point and is performed \nat lines 6-9. The body of the loop to interleave threads differs from that of SearchAllTest in two ways. \nFirst, as thread B terminates (at line 4) before the search starts, we remove references to tB from the \nloop. Second, the loop condition indicates that we are only interested in distinct interleavings of threads \nwhile running JS NewContext and JS DestroyContext. Compared to SearchAllTest, our test SearchInBuggyTest \nis more effective in reproducing the bug: it generates the buggy interleaving after exploring less than \n10 schedules of the test. Capturing the programmer s knowledge in the bug report. Test SearchInBuggyTest \nindeed concisely and formally expresses the interleaving scenario in Figure 2. Our test also includes \na search for the .nal portion of the interleaving to address the (missing) rest of the scenario. While \nthe test scenario in Figure 2 explains our intuition about why the assertion is violated, the test formally \ndocuments and implements this intuition to reproduce the bug. In detail, we realize that the assertion \nis violated because in a buggy execution there exists a problematic state S at which thread A starts \na garbage collection routine js GC to deallo\u00adcate some shared data structures of the JavaScript engine, \nand thread C starts initializing these data structures. The scenario de\u00adscribes an interleaving to lead \nthe execution towards state S and the commands between lines 1-5 of SearchInBuggyTest guides the threads \nto follow this interleaving. During this interleaving thread B terminates (at line 4), and the rest of \nthe execution after S involves only threads A and C executing functions JS DestroyContext and JS NewContext, \nrespectively. Interleaving of A and C after S results in a data race between A and C on a shared data \nstructure, leading to an assertion violation about the data structure. Note that, our knowledge about \nthe buggy interleaving is still partial, because we do not know how A and C should interleave after S \nto trigger the assertion violation. Thus, at lines 6-9, we search for interleavings A and C during this \n.nal part of the execution. Uncontrolled nondeterminism. In addition to the controlled non\u00addeterminism \nin command ChooseThread, SearchInBuggyTest also allows uncontrolled nondeterminism. Except when speci.cally \nblocked and sequentialized by the C ONCURRIT script, the threads in the SUT are allowed to run in parallel \nfollowing a nondetermin\u00adistic schedule. For example, at Lines 1 and 2, the threads run in par\u00adallel until \nthey start executing functions from JS NewContext and JS DestroyContext. The test does not control the \nnondetermin\u00adism in the thread schedule until they start executing these functions. Thus, a search guided \nby SearchInBuggyTest may generate an\u00adother execution in which the threads follow a different interleaving \nbefore they enter these functions; such interleavings are not distin\u00adguished from each other. Moreover, \nafter Line 1, any threads other than tA, tB, and tC run in parallel without any interruption by the CONCURRIT \ntest. By embracing uncontrolled nondeterminism in this way, a CONCURRIT test can tolerate changes in \nthe execu\u00adtion context across different executions of the SUT and can still explore different schedules. \nIn addition, our tests highlight that the CONCURRIT script can express a very complicated schedule in \na compact form, as it speci.es only the key scheduling decisions and choices. Therefore, a programmer \ncan conveniently use C ONCUR-RIT to test her partial knowledge about the thread schedules without needing \nto specify uninteresting and irrelevant parts of the sched\u00adule.  2.4 Final test: Generate exact buggy \ninterleaving In SearchInBuggyTest we have localized the search (lines 6\u00ad9) for the latter, short part \nof the schedule. As a result, each interleaving explored by the loop in SearchInBuggyTest con\u00adtains few \ncontext switches of threads tA and tC. Moreover, since we have also increased the likelihood of hitting \nthe bug in SearchInBuggyTest, we will have many buggy interleavings to compare and .nd the common scheduling \ndecisions in the latter part of the schedule. Thus, it becomes manageable to analyze the latter part \nof the interleavings and extract a test without search that will trigger the bug at every execution. \nTo develop the .nal, exact schedule, we select buggy executions with the least number of context switches \nand (manually) alternated two re.nement steps: Strengthen: Using the execution trace, trans\u00adlate an exact, \nbuggy schedule to a C ONCURRIT test, i.e., express a sequence of operations by the same threads to a \nRunThreadUntil command. Weaken: Try to remove some RunThreadUntil com\u00admands and check if the bug is still \ntriggered. After several re.ne\u00adment steps, we .gure out an exact interleaving after the problem\u00adatic \nstate S to reach the assertion violation, and replace the loop in SearchInBuggyTest with a sequence of \nRunUntilThread com\u00admands to guide the execution of the SUT along the buggy interleav\u00ading. Our .nal test \nExactScheduleTest is as follows: ExactScheduleTest : 1 Tid tA, tB, tC WaitForDistinctThreadsp3, EntersFuncpJS \nNewContextqq; 2 RunThreadsUntilptA, tB, EntersFuncpJS DestroyContextqq; 3 RunThreadUntilptA, InFuncpjs \nGCq&#38;&#38; ReadsMemp&#38;rt\u00b4astateqq; 4 RunThreadUntilptB, ThreadEndsq; 5 RunThreadUntilptA, InFuncpjs \nGCq&#38;&#38; WritesMemp&#38;rt\u00b4agcNumberqq; 6 RunThreadUntilptC, EntersFuncpjs AddRootqq; 7 RunThreadUntilptA, \nReturnsFuncpjs GCqq; // violates assertion! Our .nal test concisely describes few key scheduling decisions \ncausing the bug and leaves other parts of the thread schedule un\u00adspeci.ed. The control imposed by the \nC ONCURRIT script is enough to guide the SUT to the assertion violation at every execution. Thus, we \ncan use this test to .le a bug report and to check if any .x for the bug prevents the problem; after \nthe .x, we can add the test to our regression suite. In summary, we demonstrated an iterative process \nfor one to re.ne a CONCURRIT test by incorporating new insights about the target schedules. At each step, \nwe .xed a longer, former portion of the target interleaving and localized the search for unknown portion \nof the interleaving around a smaller region of the interleaving space. Finally, we were able to simplify \nour test to describe an exact, buggy schedule in a concise and formal form. 3. DSL for controlling thread \nschedules In this section, we provide a low-level, imperative language to describe and control intended \nthread schedules of the SUT. 3.1 Software-under-test (SUT) We do not assume any speci.c syntax and semantics \nfor the Software-under-Test (SUT) we leave abstract (1) the structure of SUT-states and (2) transitions \nbetween such states. Let SUTState refer to the set of all SUT-states, S range over SUTState , and S0 \nP SUTState be the unique initial state of SUT. We assume that each SUT-state consists of a set of threads, \neach of which is referred to via a unique thread identi.er. Let T id be the set of all thread identi.ers \nand t range over T id. In case the SUT consists of multiple processes, the set T id contains all the \nthreads contained in these processes. To present the operation of a CONCURRIT test, we assume a standard \ninterleaving semantics for the execution of threads in the SUT: At any time only one thread is allowed \nto execute, modifying its own local variables, and possibly, some global variables. We also abstract \naway the memory model issues by assuming a sequentially consistent memory model. We use the notation \nS\u00ddtto indicate \u00d1S1 that a thread t P T id in the SUT can execute from state S and leads to SUT-state \nS1 . In addition, the SUT code is instrumented, so that when a thread t visits an instrumentation point, \nit generates an event carrying information about the operation to be performed next by t and blocks. \n(See Section 6 for details of this instrumentation). For this, we extend the notation for SUT-transitions \nas follows. We write S\u00ddtt also generates \u00d1S1{e to indicate that thread an event e as a result of the \nstate transition. Event. We represent each event as a record from .elds to values describing an operation \nperformed by a thread, such as accessing a memory location, entering or exiting a function, and terminating. \nLet Event be the set of events, and e range over Event . Given an event e, we write e.f to refer to .eld \nf of the event. Each event contains at least two .elds, kind and tid, to indicate the type of the operation \nfor which the event is generated and the generating thread s identi.er, respectively. Other .elds are \nused to store more information about the operation, for example, addr .eld for the memory address read \nor written, func .eld for the function being called, and pc .eld for the related source location. CONCURRIT \nscripts use a special form of boolean expression, called event predicates, to represent sets of events. \nLet EPred contain all event predicates and p range over EPred. Following is the list of event predicates \nwe commonly use in our tests: WritesMem .e. e.kind == MemWrite WritesMempaq .e. e.kind == MemWrite \n&#38;&#38; e.addr == a EntersFuncpfq .e. e.kind == FuncEnter &#38;&#38; e.func == f CallsFunc .e. e.kind \n== FuncCall ThreadEnds .e. e.kind == ThreadEnd AtControlpxq .e. e.kind == Control &#38;&#38; e.pc == \nx Predicate AtControl is used to refer to events generated at particular source locations (control point) \nin the SUT code. The events generated by SUT threads are communicated to the CONCURRIT script, and they \nprovide the mechanism to interact with and control the execution of the SUT. In particular, generating \nan event causes the originating thread to block until the C ONCUR-RIT script observes the event and explicitly \nenables the generating thread to continue. 3.2 CONCURRIT: Syntax Figure 4shows the core syntax of C \nONCURRIT. We will extend this syntax in Section 4to support exploring multiple test executions. A statement \nin our DSL is denoted by C. Our DSL extends an imperative language with two special commands: select \nand release. (Command endrun represents an instruction that marks the end of the execution.) These special \ncommands can be imple\u00admented as a library of procedures on top of an imperative language, in our case, \nC/C++. Thus, we follow the C language syntax for stan\u00addard imperative constructs and expressions in C \nONCURRIT. Symbols b, t, and e refer to C ONCURRIT variable names stor\u00ading Boolean values, thread identi.ers, \nand events, respectively. The variables have types bool, Tid, and Event, respectively. We also use x \nto refer to a variable of an arbitrary type. SUT-STEP-W ITHOUT-E VENT SUT-STEP-W ITH-E VENT SELECT t \nP T id Eptq K S t\u00dd\u00d1S1 t P T id Eptq K S t\u00dd\u00d1S1{e t P D \u00f3 T Eptq e D1 Dre \u00de\u00d1 es pS, D, E, Cq ... pS1, \nD, E, Cq pS, D, E, Cq ... pS1, D, Ert \u00de\u00d1 es, Cq pS, D, E, e selectpTq; Cq ... pS, D1, E, Cq SELECT-T \nIMEOUT RELEASE @t P D \u00f3 T. E ptq K @t P D \u00f3 T. pEptq K ^ E1 ptq Kq pTime limit for select expiresq \n@t R D \u00f3 T. E 1 ptq Eptq pS, D, E, e selectpTq; Cq ... pS, D, E, endrunq pS, D, E, releasepTq; Cq ... \npS, D, E1 , Cq IF WHILE C1 pDpbq trueq? pC1; Cq : pC2 ; Cq C1 pDpbq trueq? pC1; whilepbqtC1 u; Cq \n: C 1 1 pS, D, E, ifpbq tC1 u else tC2 u; Cq ... pS, D, E, Cq pS, D, E, whilepbqtC1 u; Cq ... pS1, D, \nE, Cq Figure 5. The operational semantics of CONCURRIT. b, t, e, x P Var T :: AnyThread |t |T`t |T\u00b4t \nThread expressions C :: e selectpTq Wait for event from thread(s) | releasepTq Unblock thread(s) | endrun \nEnd of execution | ifpbqC else C Conditional | whilepbqC |break Loop | C; C Sequential composition | \n\u00a8 \u00a8 \u00a8 Other imperative constructs Figure 4. Syntax of CONCURRIT.  3.3 CONCURRIT: Semantics We next give \nan operational semantics to C ONCURRIT. For this, we think of the software-under-test (SUT) and the test \nwritten in CONCURRIT running together as a single system, in which the SUT and the DSL script run concurrently \nand in interaction with each other (events provide the mechanism for their interaction). Thus, we de.ne \na test state as the composed state of the SUT and the DSL script in C ONCURRIT. 3.3.1 Test state A test \nstate is described by a tuple pS, D, E, Cq: S P SUTState is a state of SUT as described in Section 3.1. \nNote that we abstract out the details of SUT states.  D P DSLState is the state of the DSL script written \nin CONCURRIT. Let Var be a set of variable names. State D is a map from Var to Value . Let dom pDq denote \nthe set of variables de.ned at state D. We write Dpxqto denote the value of a variable x P dom pDq in \nstate D. We write Drx \u00de\u00d1 vs to denote the DSL state that agrees with D for all variables except that \nx is mapped to value v.  E is a map from T id to Event . For a thread t P T id, Eptq K indicates that \nt has no event associated with it, and Eptq P Event indicates that t is blocked at an event and waiting \nfor the CONCURRIT script to unblock it. We write E r.t P T id. Ks to indicate that no thread in E is \nmapped to an event. We use similar notation to D to update the map E (e.g., Ert \u00de\u00d1 es).  C is the rest \nof the DSL program (a statement from Figure 4)to evaluate next.   3.3.2 Test executions Figure 5 gives \nan operational semantics for an execution of the SUT composed by the test in CONCURRIT. Such an execution \nis expressed as a sequence of test-state transitions governed by the rules in Figure 5: pS0, D0, r.t \nP T id. Ks, C0 ; endrunq... \u00b0 pSn, Dn, En, endrunq In the initial test-state, S0 and D0 denote the unique \ninitial states of the SUT and the DSL, and C0 denotes the C ONCURRIT script written by the programmer. \nNotice that, we sequentially compose the DSL statement C0 with special command endrun. During the execution, \nthe statement C0; endrun is modi.ed by the operational semantics rules to indicate the next DSL statement \nto be evaluated, and the execution terminates when the DSL statement is fully evaluated to endrun. Without \nloss of generality, we use an interleaved semantics for the execution, where at any time either an SUT \nthread or the DSL script may take a transition. SUT-transitions. As stated by rules SUT-STEP-W ITHOUT-EVENT \nand SUT-S TEP-W ITH-E VENT, a thread t in the SUT may execute and lead the SUT from state S to a new \nstate S1 (expressed by S\u00ddt). The transitions by an SUT thread t is enabled only \u00d1S1when Eptq K holds, \ni.e., there is no event associated with t in the current test state. If thread t generates an event e \nas a result of this transition, it is associated with that event using the map E (see SUT-S TEP-W ITH-E \nVENT). This causes thread tto be blocked until the DSL script executes a release command on thread t \nto remove this mapping (see rule R ELEASE). DSL-transitions. Each DSL transition evaluates the current \nscript C to result in a new script C1, and possibly modi.es the internal DSL state D and the mapping \nE. These transitions are governed by the semantics rules other than SUT-S TEP-W ITHOUT-E VENT and SUT-STEP-W \nITH-E VENT. Transitions by the DSL do not affect the SUT-state S. The DSL script can only control the \nexecution of the SUT by modifying the map E, which affects the further transitions of the SUT by, for \nexample, unblocking a thread waiting on an event. 3.3.3 Controlling thread schedule with select and \nrelease Thread expressions. The DSL commands select and release operate on a set of thread identi.ers. \nWe use thread expressions (T of type TExpr) to identify a set of thread identi.ers. Syntax for thread \nexpressions is given in Figure 4. First, the special DSL constant AnyThread represents the set of all \nthread identi.ers, i.e., T id. Second, each thread variable t (storing the identi.er of a thread) is \nalso treated a thread expression representing the set tDptqu. Finally, we overload the ` and \u00b4 operators \nto include or exclude a thread identi.er to/from the set. We write D \u00f3 T to refer to the set of thread \nidenti.ers (subset of T id) represented by the expression T in D. This set is de.ned recursively as follows: \nD \u00f3 AnyThread T id D \u00f3 pT ` tq D \u00f3 T Y tDptqu D \u00f3 t tDptqu D \u00f3 pT \u00b4 tq D \u00f3 T z tDptqu  We say that \na thread with identi.er t satis.es T (or T is satis.ed by thread t)at a state D if t P D \u00f3 T. Waiting \nfor an event. The command e selectpTq takes a thread expression and waits for a thread whose identi.er \nis in the set D \u00f3 T to generate an event. The command then binds variable e to the generated event. For \nexample, e selectpAnyThreadq waits for any thread, e selectptq waits for thread t, and e selectpAnyThread \n\u00b4 tq waits for any thread except t to generate an event. Semantics rule S ELECT governs this operation \nof select. Note that an event generated by a thread t is recorded at E.t, so the rule simply queries \nE to retrieve this event. Timeout. Due to an incorrect test script or uncontrolled nondeter\u00adminism in \nthe SUT (as explained in Section 2), no thread in D \u00f3 T may generate an event from the current test state. \nIn order to detect such situations, we allow the implementation of a timeout mecha\u00adnisms. For this, we \ninclude the rule S ELECT-T IMEOUT, which al\u00adlows select to end the execution by evaluating the current \nDSL statement to endrun, when no thread in D \u00f3 T is associated with an event. Nondeterminism in select. \nNotice that rules SELECT and SELECT-T IMEOUT bring some nondeterminism to the semantics. For example, \nconsider a command e selectpTq. First, the com\u00admand can choose an arbitrary thread from the set D \u00f3 \nT, or, before taking effect it can even wait for a state in which more threads gen\u00aderate events and satisfy \nT. Second, if no thread in D \u00f3 T has gener\u00adated an event, the command may evaluate to endrun before waiting \na thread to generate an event. For the former case, our high-level constructs in Section 5 give examples \nto controlling this nondeter\u00adminism. For the latter case, the programmer can set, in the C ON-CURRIT \ntest, a time limit for each invocation of a select com\u00admand. Unblocking threads. The command releasepTq \ntakes a thread expression and unblocks all threads whose identi.ers are in the set D \u00f3 T. This is governed \nby the rule RELEASE. The rule requires that all threads that are speci.ed by T are associated with an \nevent. Thus, release should be called for threads that have already generated and associated with an \nevent at the current test state. A common way to ensure this condition, which we consistently followed \nin our case studies, is to match each release on a thread t to a previous select on the same thread t. \n4. Searching for thread schedules Having introduced the CONCURRIT constructs to control the scheduling \nof threads, we next extend our DSL to express a set of schedules and present mechanisms to search for \nthese schedules in the presence of uncontrolled nondeterminism. To accommodate the notion of search in \nCONCURRIT, we .rst add to the syntax of C ONCURRIT a new command: (Let k refer to a constant value.) \nC :: \u00a8 \u00a8 \u00a8 Constructs from Figure 4 | x choosepk1 , ..., kn q Ask oracle to choose a value The new construct \nchoose is used to guide the execution (in ad\u00addition to select and release) to support the search for \nschedules. To explain the semantics of choose, we include in our formalism an oracle denoted, O, which \nresolves controlled nondeterminism in the test. We extend the test state (de.ned in Section 3.3.1)to \nin\u00adclude an oracle, and add to the operational semantics two new rules shown in Figure 6. The original \nrules in Figure 4 remain the same, except that they preserve O as is during the transition. The oracle \nO may change only by the new rules in Figure 6. CHOOSE O.choosepk1 , ..., kn q pk, O1 q k P tk1 , ..., \nkn u D1 Drx \u00de\u00d1 ks pS, D, E, x choosepk1 , ..., kn q; C, Oq ... pS, D1, E, C, O1 q RESTART O.restartpq \n SomepO1 q pS, D, E, endrun, Oq ... pS0, D0, r.t P T id. Ks, C0; endrun, O1 q Figure 6. The extended \noperational semantics of CONCURRIT for search. We keep the original rules in Figure 5except that we include \nan oracle O to the test state and preserve O during the transition. Choose. Rule C HOOSE governs the \noperation of the command x choosepk1 , ..., kn q. The command is used to request an input from the oracle \nO to be used to guide the current execution. Op\u00aderation O.choosepk1, ..., knqreturns a pair pk, O1 q, \nwhere k is the value chosen by the oracle from k1, ..., kn, and O1 is the new state of the oracle. The \noracle can choose nondeterministically or it can track choices across multiple executions to implement \na search. Restart. Rule R ESTART allows the oracle O to start a new ex\u00adecution of the SUT when the current \none terminates (when the CONCURRIT script evaluates to endrun). For this, we de.ne the O.restar tpq operation \nto return either SomepO1 qor None. If the oracle decides to start a new execution, it returns SomepO1 \nq, where O1 is the oracle to guide the SUT during the new execution. In this case, the SUT and the C \nONCURRIT script are restarted from their initial states. Recall that, in the initial test-state, the \nCONCURRIT script C0 is sequentially composed with endrun. If the oracle de\u00adcides that there are no more \nexecutions to explore, it terminates the overall test by returning N one. Modularity of Test Scripts \nand Oracles. The interface of the ora\u00adcle cleanly separates (1) the description of a set of thread schedules \nin CONCURRIT and (2) the exploration of these schedules. The or\u00adacle guides the exploration in (2) by \nde.ning a search strategy and related heuristics transparently to the C ONCURRIT script. To ex\u00adplain \nthis separation, consider the following test: InterleaveTwoThreads : 1 Event e1 selectpAnyThreadq; Tid \nt1 e1.tid; 2 Event e2 selectpAnyThread \u00b4 t1q.tid; Tid t2 e2.tid; 3 whilep!HasEndedpt1q } !HasEndedpt2qq \nt 4 Tid t choosept1, t2q; // Oracle chooses one of the threads. 5 do t // Loop until thread t accesses \nthe memory. 6 releaseptq; // Enable thread t to execute. 7 Event e selectptq; // Wait until thread t \nblocks at another event. 8 u whilep!ReadsMempeq&#38;&#38; !WritesMempeqq; 9 } The test binds variables \nt1 and t2 to two distinct threads at Line 1 and 2, respectively. At each outer loop iteration, one of \nthe threads t1 or t2 is chosen by the choosept1, t2qconstruct at Line 4. Then, the chosen thread t is \nenabled to execute using release at Line 6, until the thread is blocked at another event. When the chosen \nthread is blocked at an event before an access (read or write) to the memory, the test repeats the outer \nloop and choses a new thread. Irrespective of the choice made by the oracle O at Line 4, the test describes \na set of interleavings, say I, of two distinct threads where a new scheduling decision is made (at Line \n4) after every memory access event. The described interleaving ends when both threads terminate (HasEndedptqat \nLine 3 returns true iff thread t has terminated). Different oracles, however, will differ in the order \nin which the interleavings are explored. Implementing oracles. With our oracle interface choose and restart \nit is straightforward to implement various search strate\u00ad 1 O.choosepk1 , ..., kn q: 2 if O.index a \n|O.t|then 3 // EXTEND PREFIX: Record chosen value in the pre.x 4 let K tk1 , ..., kn u 5 k nondeterministically \nchoose from set K 6 O.t.appendppk, K z tkuqq 7 else 8 // REPLAY PREFIX: Use previously chosen value in \nthe pre.x 9 let pk, Kq O.pref ixrO.indexs 10 endif 11 O.index O.index ` 1 12 return pk, Oq 13 O.restar \ntpq: 14 R ti |1 d i d |O.t|^ O.tris pk, Kq^ K Hu 15 if R H then 16 m maxpRq 17 let pk, Kq O.trms \nand k1 P K 18 O.t.pruneAf terpm \u00b4 1q 19 O.t.appendppk1 , Kztk1 uqq 20 O.index 1 21 return SomepOq 22 \nelse 23 return N one 24 endif Figure 7. Oracle implementing depth-.rst search. gies, such as breadth-.rst \nand depth-.rst search. In the following, we give an abstract, declarative description of an oracle implement\u00ading \nsearch. To make our point concrete, we explain how to instan\u00adtiate this oracle for depth-.rst search; \nother search techniques and heuristics (e.g., [17]) can be integrated to our framework following a similar \nmethodology. 4.1 Implementing oracles for search Our oracle O tracks a trace of each execution, denoted \nt. The trace consists of the inputs and outputs interchanged between the oracle and the C ONCURRIT test \nin particular the sequence of choices taken by the oracle in response to choose commands. The oracle \nalso keeps a set T of traces for the complete executions it observes. Initially, set T is empty, and \nthe oracle starts with an empty trace t. During the execution, calls to operation O.choosepq extend trace \nt. Note that, when the execution terminates, the semantic rule RESTART invokes O.r estartpq to decide \nwhether to start a new execution or to terminate the search. Operation O.restar tpq .rst adds t to set \nT , and then computes from T a new trace t1 satisfying the following: (i) Trace t1 is non-empty, (ii) \nit is not a pre.x of another trace in T , and (iii) the longest pre.x t2 of t1 such that t2 t1 is a \npre.x of some trace in T . Thus, trace t1 may be used to generate an execution (particularly, a thread \nschedule) distinct from the previously explored ones. If no such t1 exists, O.restartpq returns None, \nwhich terminates the exploration. Otherwise, during the next execution, the oracle .rst replays i.e., \nit uses the t1records in t1 to respond to calls to O.choosepq. When all records in t1 are used, the oracle \nextends t1 to a complete trace in the rest of the execution. 4.1.1 Oracle for depth-.rst search In our \nframework, we implement search by following a depth-.rst search (DFS) strategy. Figure 7 gives an implementation \nof the oracle O following a depth-.rst search strategy. We implement the trace t as a sequence of pairs \npk, Kq. Each pair records in the .rst element k a choice taken by the oracle in response to a choose \ncommand. The second element K is the set of values that has not been chosen yet. The oracle also keeps \nan index index, which points to an element of t to be considered next while replaying the trace. 1 Tid \nWaitForThread 18 void RunThreadsUntil pTExpr T, EPred pq{ pTid t1, ..., tn, EPred pq{ 2 whileptrueq{ \n19 TExpr T t1 ` \u00a8 \u00a8 \u00a8 ` tn; 3 Event e selectpTq; 20 releasepTq; 4 ifpppeqq return e.tid; 21 int c \nn; 5 releasepe.tidq; 22 whilep0 a c qt 6 } 23 Tid t WaitForThreadpT, pq; 7 } 24 T T \u00b4 t; 25 } 8 TidList \nWaitForDistinctThreads 26 } pint n, EPred pq{ 9 TExpr T AnyThread; 27 Tid ChooseThread 10 TidList ts; \npTid t1, ..., tnq{ 11 whilep0 a n qt 28 int k choosep1, ..., nq; 12 Tid t WaitForThreadpT, pq; 29 \nswitchpkq{ 13 ts.addptq; 30 case 1 : return t1; 14 T T \u00b4 t; 31 ... 15 } 32 case n : return tn; 16 return \nts; 33 } 17 } 34 } Figure 8. Our test library with high-level functions For the entire search, the oracle \nmodi.es the trace t as a DFS stack, which eliminates the need for additional traces. Thus, during the \nO.restartpq operation, the set T only contains the last explored trace t. The oracle computes the new \ntrace t1 (to replay in the next execution) from t by backtracking to the last record pk, Kq of a choose \ncommand in the trace such that K contains at least one unchosen element, say k1, and updating that record \nto pk1, Kztk1 uq. This ensures that during the replay of t1 the oracle responds to the corresponding \ninvocation of choose by returning k1 . 5. A high-level library for writing concise tests While the core \nC ONCURRIT DSL introduced in Sections 3and 4is useful to formally explain the control obtained by a CONCURRIT \ntest, the low-level primitives in the DSL may not be appropriate for programmers to write concise tests. \nIn this section, we show how these low-level primitives can be combined to implement higher\u00adlevel constructs, \nas a library of functions. Our library is shown in Figure 8. We found this library suf.cient and convenient \nto write tests for our benchmarks (Section 7). In fact, we conclude this section by describing common \nusage patterns of the library that we have learned from our experiments. Waiting for a thread. We de.ne \ntwo functions to wait for threads. Function WaitForThread takes a thread expression T and an event predicate \np, and repeatedly runs the threads satisfying T until one thread in T generates an event satisfying p. \nA common use of WaitForThread is with T AnyThread, to enable all threads in the SUT until the expected \nevent is generated. Function WaitForDistinctThreads waits for a .xed number of threads each to generate \nan event satisfying p. Once a thread generates such an event, we ensure at Line 14 that the thread is \nno longer run by removing its identi.er from the thread expression T. Running threads. The library functions \nWaitForThread and WaitForDistinctThreads return one or a set of blocked thread identi.ers, respectively. \nFunction RunThreadsUntil takes a list of already-blocked threads and reenables them (via release). Then, \nthe function runs each reenabled thread until the thread generates an event satisfying predicate p. For \nreadability, when using only a single thread identi.er t, we call the function RunThreadUntilpt, epredq. \nSelecting a thread variable. We de.ne function ChooseThread for selecting from a given set of thread \nvariables, using the prim\u00aditive choose explained in Section 4. Thus, we use this function when we want \nto introduce a scheduling point for which all possi\u00adble choices must be explored. 5.1 Test patterns \nusing high-level constructs In this section, we present common test patterns. Most of our patterns are \nbased on the following generic pattern: GenericPatternpint n, EPred p start, p schedule, BExpr loop condq \n: 1 Tid t1, ..., tn WaitForDistinctThreadspn,p startq; 2 ...... // Run threads t1, ..., tn to follow \na .xed interleaving 3 whileploop condq{ 4 Tid t ChooseThreadpt1, ..., tnq; 5 RunThreadUntilpt, p scheduleq; \n6 } The pattern has four parameters: the number (n) of threads to be controlled during the test, the \nevent predicates, p start and p schedule, and a boolean expression loop cond. We .rst wait for n threads \nuntil each of the n threads generates an event satisfying p start (line 1). Then, we use functions of \nour library in Figure 8to guide the threads to follow a particular schedule (line 2). Finally, we schedule \nthreads in a loop at each iteration running one of the threads until it generates an event satisfying \np schedule. Then, the SUT is restarted to explore a new thread interleaving. SearchAll: Traditional model \nchecking. In order to apply model checking to the SUT in the traditional way, we instrument the entire \ncode for the SUT. In particular, the instrumentation ensures that (i) every memory access (read and write) \nand (ii) every operation that may cause the executing thread to block (e.g., synchronization operations \nsuch as acquiring a mutex) generate an event. We over-approximate (ii) by inserting instrumentation before \nevery function call. Under the assumption that the only source of non\u00addeterminism in the program is the \nthread schedule, rescheduling threads at (1) and (2) is suf.cient to enumerate all possible thread schedules \nof the SUT. The pattern SearchAll instantiates our generic pattern GenericPattern as follows: (1) p start \n ThreadStart. (2) Line 2 is omitted. (3) p schedule pattern SearchInFunc restricts the search for the \ninterleaving of threads within a set of functions, say F. In this pattern, we modify GenericPattern as \nfollows: (1) We only instrument the code so that a thread generates events only when executing a function \nin F. (2) p start EntersFuncpf1q } \u00a8 \u00a8 \u00a8 } EntersFuncpfmq, where F f1, ..., fm. (3) Similarly to SearchAll, \nLine 2 is omitted. (4) loop cond InFuncpf1q || \u00a8 \u00a8 \u00a8 || InFuncpfmq, which holds if at least one of t1, \n..., tn is running a function from F.  pReadsMem }WritesMem }CallsFunc }ThreadEndsq. (4) loop cond !HasEndedpt1q \n|| \u00a8 \u00a8 \u00a8 || !HasEndedptnq. SearchInFunc: Restricting search to particular functions. The SearchInFuncLS: \nInterleaving threads at large steps. For some benchmarks, we found it useful to limit the scheduling \npoints to a few special locations in the SUT code. For this, we manually instrument these locations in \nthe SUT code to generate user-de.ned events of the form AtControlppcq. In particular, we associate each \nof these locations with a user-de.ned program counter (pc), an integer value. Then, we extend the pattern \nSearchInFunc by setting p schedule to pAtControl }ThreadEndsq. SearchInBuggy: Starting search from a \nsuspicious state. Simi\u00adlarly to the pattern SearchInFunc, SearchInBuggy searches for interleavings within \na set F of functions. However, instead of start\u00ading the search from the beginning of the functions, this \npattern includes a .xed schedule before starting the search (at line 2 of GenericPattern). This .xed \nschedule is benchmark-speci.c and is described by few lines each running RunThreadpsqUntil. ExactSchedule. \nThis pattern describes the exact thread schedule intended by the programmer to generate, for example, \nto document a buggy interleaving in a reliable way. In this case, the schedule only consists of line \n1 of GenericPattern and a sequence of RunThreadpsqUntil, omitting the search loop at lines 3-8. SearchInFuncCB: \nContext-bounded search of interleavings. There are many reduction techniques for software model checking, \nincluding partial-order reduction [5, 7], preemption bounding [19], and fair stateless model checking \n[20]. These optimizations are or\u00adthogonal to our technique. One can implement these optimizations within \nthe test script instead of modifying the underlying search al\u00adgorithm (i.e., the interface for oracle \nO). In our experiments, we found context bounding quite useful to reduce the interleavings searched when \nusing SearchInFunc. The following is an imple\u00admentation of the context-bounded version of GenericSearch. \nGenericPatternCBpint n, EPred p start, p schedule, BExpr loop cond, int context boundq : 1 Tid t1, ..., \ntn WaitForDistinctThreadspn, p startq; 2 ...... // Run threads t1, ..., tn to follow a .xed schedule \n3 forpint i 1; i d context bound &#38;&#38; loop cond; ++iqt 4 Tid t ChooseThreadpt1, ..., tnq; 5 do \n{// Run next context by thread t 6 RunThreadUntilpt, p scheduleq; 7 }whileploop cond &#38;&#38; chooseptrue, \nfalseqq; 8 } 9 ...... // Interleave each thread sequentially until completion 6. Implementation We have \nimplemented CONCURRIT as an embedded DSL for C/C++. Our implementation is available at http://code.google.com/p/concurrit/. \nA test in CON-CURRIT is simply a C++ program. Our implementation supports the use of C ONCURRIT tests \nin both unit testing and system testing. 6.1 Unit testing with CONCURRIT For unit testing, the programmer \nprovides the SUT as a shared library with an entry function named test main. The executable CONCURRIT \ntest loads this shared library and calls test main multiple times to explore different executions of \nthe SUT. To instrument the SUT we provide a library with a collection of functions. We give example instrumentation \nfunctions below. void concurritThreadStartpq; void concurritThreadEndpq; void concurritFuncEnterpvoid\u00b0 \nfunction, long arg0, long arg1q; void concurritFuncReturnpvoid\u00b0 function, long return valueq; void concurritFuncCallpvoid\u00b0 \ncaller, void\u00b0 callee, long arg0q; void concurritMemReadpvoid\u00b0 address, int size, long valueq; void concurritMemWritepvoid\u00b0 \naddress, int size, long valueq; void concurritControlPointpint pcq; CONCURRIT can operate with different \nevent granularities. At one extreme the programmer can insert these functions manually, or one can use \nour Pin tool [18] for automatically instrumenting (the binary of) the SUT at runtime, capturing all memory \noperations and function calls/returns. While the the cost can be 10-100x in the former case, the overhead \nis very small in the latter case. In our experiments with larger programs we needed to insert (manually) \nvery few instrumentation points with negligible cost, which made our approach lightweight. 6.2 System \ntesting with CONCURRIT We applied CONCURRIT in system testing of three large servers: Memcached, Apache \nhttpd, and MySQL. System tests for these servers carry unique challenges. First, the SUT is composed \nof many components with nondeterministic behaviors, such as arbi\u00adtrary network-packet delays and arbitrary \nassignment of worker threads to connections. Second, the SUT consists of multiple pro\u00adcesses interacting \nwith each other using various mechanisms. To test such servers, .rst, we run the CONCURRIT test in a \nsep\u00adarate process and perform the event communication between the SUT processes and the C ONCURRIT process \nusing named (FIFO) pipes. Except when speci.cally blocked and sequentialized by the CONCURRIT test, all \nthe threads in these SUT processes run in par\u00adallel. Except for the threads controlled by the CONCURRIT \ntest, all the threads in the distributed processes run in parallel with each other. Second, we de.ne \ntwo special events: TestStart and TestEnd to signal the beginning and the end of an SUT execu\u00adtion. For \nexample, in memcached, these events are generated when the requestor process starts and terminates, respectively. \nThe C ON-CURRIT test only controls the events generated (by the memcached server) between TestStart and \nTestEnd. 7. Evaluation In our evaluation of our proposal, we used our implementation of CONCURRIT described \nin Section 6 and conducted a case study on a collection of multithreaded programs. These programs are \nfrom well-known benchmark suits: Inspect [26], PARSEC [3], and RADBench [12]. Each of our benchmarks \ncontains a concurrency bug, either real or manually inserted by existing work [11]. For each benchmark, \nwe followed the testing process that we demonstrated in Section 2 for one of the benchmarks. Dur\u00ading \nthis process, we wrote one or more tests in the high-level DSL described in Section 5, aiming at reproducing \nthe bug in the benchmark. We started by writing less exact tests (which are not SearchAll)for each bug \nusing partial information about the bug. Based on the information obtained from these test execu\u00adtions \nwe made the tests more precise so that they could repro\u00adduce the bug by describing only a small number \nof key schedul\u00ading decisions. We found that we can write concise tests for all of our benchmarks by applying \nthe usage patterns we described in Section 5.1. For small benchmarks we also wrote tests that will search \nall thread schedules (SearchAll) in order to see if model checking could .nd these bugs ef.ciently. Moreover, \nfor some benchmarks we managed to write tests that are exact sched\u00adules (ExactSchedule). The CONCURRIT \ncode for these tests are available at http://code.google.com/p/concurrit/. We give sample tests from \nour benchmarks in Appendix A. Table 1 shows the results of our study. For each benchmark, the table shows \nthe various tests we wrote to reproduce a bug in the benchmark. Our C ONCURRIT tests detected the regarding \nbugs in all the cases. For each test, we give the number of functions in\u00advolved in the test, how many \nextra instrumentation calls were man\u00adually inserted in addition to the automated Pin instrumentation, \nthe number of C ONCURRIT DSL lines, number of threads involved in the test, and the (average) number \nof schedules explored before hit\u00adting the bug. Note that, in the sixth column we only give the num\u00adber \nof threads explicitly controlled by the test; the execution may contain other threads, which are either \nblocked or executed in an uncontrolled manner. For benchmarks streamcluster, memcached, apache-httpd, \nand mysql-server we did not use Pin and inserted all the instrumentation manually (as reported in the \nforth column). In this way, our tests become portable as they require no heavy-weight automated instrumentation. \nFull model checking. In our study, we were able to apply tra\u00additional notion of model checking on small \nbenchmarks, namely bbuf, bzip2, ctrace, pbzip2. The test type SearchAll refers to tests of this kind, \nwhich was explained in Section 5.1. In these tests, we control the scheduling decision after every memory \nac\u00adcess (read or write) and function call. We had to instrument all op\u00aderations that may introduce nondeterminism \nand change the thread schedule. However, we did not control synchronization operations for locks and \ncondition variables; instead, we inserted scheduling choices before every function call. This gives two \nbene.ts. First, it ensures that all model checking tests were able to hit the bug, since instrumenting \nevery function call over-approximates the effect of synchronization-related functions on the thread schedule. \nSecond, it makes our approach portable;we do not have to control and im\u00adplement the semantics of different \nsynchronization operations. Fi\u00adnally, as expected, we should note that full model checking works only \nfor small programs, such a data structures. In our experiments, we bounded the number of executions to \n10K, but even for some small programs SearchAll generated more than 10K executions. Customizing the \nsearch using information about the bug. While full model checking is impractical, we found that if we \nuse infor\u00admation about a bug to restrict the number of explored schedules in a CONCURRIT test, we can \nef.ciently and reliably reproduce the bugs. As discussed in Section 5.1, we restricted the traditional \nno\u00adtion of model checking to customize the search in three aspects: (1) In tests SearchInFunc , we instrumented \nonly the body of several functions, say F, that we found related to the bug. The third col\u00adumn of Table \n1 gives the size of F. Then, we started to search for thread schedules only when threads were executing \nfunctions in F. The size of F highlights a common characteristics of concurrency bugs: they occur due \nto incorrect synchronization of few functions and can be detected by focusing the search on these functions. \n(2) In tests SearchInFuncCB2 and SearchInFuncCB3 , we applied context-bounded model checking techniques \n[19] with bounds 2 and 3, respectively. (3) In tests SearchInFuncLS , we scheduled threads at coarse \ngranularity, only after reaching a manually in\u00adserted control point. We obtained information about these \ncontrol points either from the bug report (if the bug report has these details) or from insight obtained \nfrom triggering the bug with less exact CONCURRIT tests. For example, to check for atomicity violations \nusing SearchInFuncLS, we inserted these control points around the accesses to the shared variables that \nwe think will involve in the vi\u00adolation, and for ordering violations, we inserted the control points \nto mark the beginning and end of the code blocks whose differ\u00adent orderings may create an error. We found \nthat, when used in conjunction with restricting the search to functions in F, context bounding and interleaving \nthreads at coarse granularity are quite effective to reproduce the bugs in a small number of executions. \nGenerating exact buggy schedule. For 8 of our benchmarks, we were able to re.ne the test to ExactSchedule \n, after observing a buggy execution and generalizing its thread schedule in a CON-CURRIT test, which \nguides the execution towards the buggy states. Notice that, compared to tests for search, the size of \nExactSched\u00adule tests are not longer. This highlights the fact that in many con\u00adcurrency bugs only few \nscheduling decisions involve; by enforcing these decisions, the bug can still happen in spite of the \nlarger, un\u00adcontrolled part of the schedule. While sleep-based approaches ex\u00adploit this fact to effectively \nreproduce simple concurrency bugs, our technique goes further by making such approches more formal and \nreliable for reproducing even more complex bugs. 8. Related work We observe a spectrum of approaches \nto specifying and controlling the thread schedule in testing of concurrent programs. At one end of the \nspectrum, there are manual approaches, in which the program\u00admer implements synchronization mechanisms \nto restrict the pos\u00adsible schedules of threads towards a particular scenario. However, such mechanisms \nare either ad hoc and unreliable (e.g., in the case of sleep statements) or may require nontrivial and \nunportable mod\u00adi.cations in the program text. Techniques have been proposed to guide the execution to \nintended thread schedules in more portable and reliable ways, where the intended schedules are speci.ed \nby the Benchmark Test pattern Funcs involved Manual instr. Test LOC Threads controlled Schedules explored \nbbuf SearchA ll SearchInFunc1 SearchInFunc2 all 2 2 0 0 0 4 5 4 4 4 2 20 12 3 bzip2 SearchA ll SearchInFunc \nSearchInFuncLS ExactSchedul e all 2 2 2 0 0 3 3 4 5 5 6 3 3 3 3 a10K 510 8 1 ctrace SearchA ll SearchLargeSteps \nExactSchedul e all 4 2 0 2 2 4 5 6 2 2 2 a10K 15 1 pbzip2 SearchA ll SearchLargeSteps ExactSchedul e \nall 3 2 0 1 1 4 4 4 4 4 4 a10K 71 1 pfscan SearchInFunc SearchInFuncLS ExactSchedul e 1 1 1 0 1 1 4 4 \n4 2 2 2 67 51 1 dedup SearchInFunc SearchInFuncLS ExactSchedul e 1 1 1 0 1 1 4 4 5 2 2 2 8 3 1  Benchmark \nTest pattern Funcs involved Manual instr. Test LOC Threads controlled Schedules explored streamcluster \nSearchInFuncLS ExactSchedule all 3 9 9 11 11 4 4 a10K 1 mozilla-nspr1 SearchInFunc SearchInFuncCB2 1 \n1 0 0 4 6 2 2 1020 4 mozilla-nspr2 SearchInFuncCB2 ExactSchedule 2 2 0 1 6 5 2 2 6 1 mozilla-nsp3 SearchSeqFuncs \n1 0 5 2 38 spidermonkey1 SearchAll all 0 4 2 a10K SearchInFunc 2 0 5 2 a10K SearchInFuncCB3 2 0 10 2 \n451 SearchInFuncCB2 2 0 7 2 226 spidermonkey2 SearchAll all 0 4 3 a10K SearchInFunc 4 0 5 3 a10K SearchInBuggy \n4 0 8 3 8 ExactSchedule 4 0 7 3 1 memcached SearchInFuncLS ExactSchedule 2 2 12 12 4 4 2 2 10 1 apache-httpd \nSearchInFuncLS 2 14 4 3 7 mysql-server SearchInFuncLS 2 9 5 3 30 Table 1. Experimental results. Our \nCONCURRIT tests detect the bugs in all the cases. programmer relative to a global timer (ConAn [16], \nMultithread\u00adedTC [23]) or a sequence of user-de.ned events expressed in linear temporal logic (IMUnit \n[9]). While these techniques give the pro\u00adgrammer the ability to impose constraints on the interleaving \nof threads, they do not support exploration of all executions satisfying these constraints. At the other \nend of the spectrum, there are fully automated ap\u00adproaches. To alleviate the nondeterminism in the execution, \nsoft\u00adware model checking techniques have been combined with test\u00ading to control the thread scheduler \nso that distinct interleavings of the threads in the test are systematically enumerated and checked against \nthe test criteria [6, 14, 19, 21]. However, these techniques require controlling all sources of nondeterminism \nin the program, which is impractical for large programs, such as web servers. Many model checking exploration \ntechniques have been devel\u00adoped that seek to achieve high coverage of executions in a scal\u00adable way [13] \nsuch as partial-order reduction [5, 7], symmetry re\u00adduction [8], preemption bounding [19], fair stateless \nmodel check\u00ading [20], and commutativity guided scheduling [25]. These tech\u00adniques do not directly help \nto ef.ciently examine interesting and potentially-problematic interleaving scenarios. Our proposal allows \nthe tester to customize the model checking to target such scenar\u00adios. Meanwhile, the tester can still \nimplement these reduction tech\u00adniques within the C ONCURRIT test. Recent studies proposed techniques \nto control the scheduling of a model checker to target suspicious executions more quickly than traditional \nstate-space exploration. Among them, active test\u00ading [24], probabilistic scheduling [4], and change-aware \npreemp\u00adtion prioritization [10]are fully automated and rely on heuristics. However, we believe that programmers \nhelp to guide the explo\u00adration of executions is also valuable, and testing tools should be designed to \nallow the programmer to interact with the test runtime to express her intents and insights about the \ntest scenario. In fact, work on preemption sealing [2] proposed to disable preemptions that the programmer \nthinks are not interesting or can cause false warnings. In our work, we would like to give more control \nand .exibility to the programmer in this direction. Note that our approach enables rapid prototyping \nand evaluation of a custom search strategy by writing and exploring a CONCURRIT test. The work in [15] \nis in the same spirit of ours, but it focuses on Boolean programs and allows the user to describe the \nmodel check\u00ading algorithm as a compact and high-level .xed-point formulation that can be fed to a general-purpose \n.xed-point solver. Recent work in record/replay systems propose recording the thread schedule partially \nand reproducing the missing parts of the schedule during the replay [1, 22]. These systems do search \nin order to reproduce a single, feasible schedule, while in our work we do search to enumerate a space \nof speci.ed schedules. Acknowledgments This research supported in part by Microsoft (Award #024263) \nand Intel (Award #024894) funding and by matching funding by U.C. Discovery (Award #DIG07-10227), by \nNSF Grants CCF-101781, CCF-0747390, CCF-1018729, and CCF-1018730, and by a DoD NDSEG Graduate Fellowship. \nThe last author is supported in part by a Sloan Foundation Fellowship. Additional support comes from \nOracle (formerly Sun Microsystems), from a gift from Intel, and from Par Lab afliates National Instruments, \nNEC, Nokia, NVIDIA, and Samsung. References [1] G. Altekar and I. Stoica. ODR: Output-deterministic replay \nfor multi\u00adcore debugging. In SOSP, 2009. [2] T. Ball, S. Burckhardt, K. Coons, M. Musuvathi, , and S. \nQadeer. Preemption sealing for ef.cient concurrency testing. Technical Report MSR-TR-2009-143, 2009. \n [3] C. Bienia, S. Kumar, J. P. Singh, and K. Li. The PARSEC Bench\u00admark Suite: Characterization and Architectural \nImplications. In PACT, 2008. [4] S. Burckhardt, P. Kothari, M. Musuvathi, and S. Nagarakatte. A randomized \nscheduler with probabilistic guarantees of .nding bugs. In ASPLOS, 2010. [5] P. Godefroid. Partial-order \nmethods for the veri.ca\u00adtion of concurrent systems: an approach to the state\u00adexplosion problem. Springer-Verlag \nInc., 1996. URL citeseer.ist.psu.edu/godefroid95partialorder.html. [6] P. Godefroid. Software model checking: \nThe verisoft approach. In Form. Methods Syst. Des., 2005. [7] G. Gueta, C. Flanagan, E. Yahav, and M. \nSagiv. Cartesian partial-order reduction. In SPIN, 2007. [8] R. Iosif. Symmetry reduction criteria for \nsoftware model checking. In SPIN, 2002. [9] V. Jagannath, M. Gligoric, D. Jin, Q. Luo, G. Rosu, and \nD. Marinov. Improved multithreaded unit testing. In ESEC/FSE, 2011.  [10] V. Jagannath, Q. Luo, and \nD. Marinov. Change-aware preemption prioritization. In ISSTA, 2011. [11] N. Jalbert and K. Sen. A trace \nsimpli.cation technique for effective debugging of concurrent programs. In FSE, 2010. [12] N. Jalbert, \nC. Pereira, G. Pokam, and K. Sen. RADBench: A concur\u00adrency bug benchmark suite. In HOTPAR, 2011. [13] \nR. Jhala and R. Majumdar. Software model checking. In ACM Comput. Surv., 2009. [14] M. Kim, Y. Kim, and \nH. Kim. Acomparative study of software model checkers as unit testing tools: An industrial case study. \nIn IEEE Trans. Softw. Eng., 2011. [15] S. La Torre, M. Parthasarathy, and G. Parlato. Analyzing recursive \nprograms using a .xed-point calculus. In PLDI, 2009. [16] B. Long, D. Hoffman, and P. Strooper. Tool \nsupport for testing concurrent Java components. In IEEE Trans. Softw. Eng., 2003. [17] S. Lu, J. Tucek, \nF. Qin, and Y. Zhou. AVIO: Detecting atomicity violations via access interleaving invariants. In ASPLOS, \n2006. [18] C.-K. Luk, R. Cohn, R. Muth, H. Patil, A. Klauser, G. Lowney, S. Wal\u00adlace, V. J. Reddi, and \nK. Hazelwood. Pin: Building customized pro\u00adgram analysis tools with dynamic instrumentation. In PLDI, \n2005. [19] M. Musuvathi and S. Qadeer. Iterative context bounding for systematic testing of multithreaded \nprograms. In PLDI, 2007. [20] M. Musuvathi and S. Qadeer. Fair stateless model checking. In PLDI, 2008. \n[21] V. Mutilin. Concurrent testing of Java components using Java PathFinder. In ISoLA, 2006. [22] S. \nPark, Y. Zhou, W. Xiong, Z. Yin, R. Kaushik, K. H. Lee, and S. Lu. PRES: Probabilistic replay with execution \nsketching on multiproces\u00adsors. In SOSP, 2009. [23] W. Pugh and N. Ayewah. Unit testing concurrent software. \nIn ASE, 2007. [24] K. Sen. Race directed random testing of concurrent programs. In PLDI, 2008. [25] O. \nShacham, N. Bronson, A. Aiken, M. Sagiv, M. Vechev, and E. Ya\u00adhav. Testing atomicity of composed concurrent \noperations. In OOP-SLA, 2011. [26] Y. Yang, X. Chen, and G. Gopalakrishnan. Inspect: A runtime model \nchecker for multithreaded C programs. Technical Report UUCS-08\u00ad004, 2008. A. Sample CONCURRIT tests Parallel \ntracing library (ctrace) ExactSchedule : 1 Tid t1, t2 WaitForDistinctThreadsp2, EntersFuncpHASH READ \nENTERqq; 2 RunThreadUntilpt1, AtControlp43q&#38;&#38; InFuncpHASR EADE XITqq; 3 RunThreadUntilpt2, ReturnsFuncpHASH \nREAD ENTERqq; 4 RunThreadUntilpt1, ReadsMem &#38;&#38;InFuncpHASH READ ENTERqq; 5 RunThreadUntilpt2, \nReturnsFuncpHASH READ EXITqq; 6 RunThreadUntilpt1, ThreadEndsq; Online clustering kernel (streamcluster) \nExactSchedule : //Control locations and other events (FuncEnter, FuncReturn) are all manually inserted \nin functions //localSearch, localSearchSub, and pkmedian 1 Tid tmain WaitForThreadpAnyThread, EntersFuncppkmedianqq; \n2 RunThreadUntilptmain, AtControlp42qq; 3 Tid t1, t2, t3 WaitForThreadpAnyThread \u00b4 tmain, AtControlp42qq; \n4 RunThreadsUntilpt1, t2, EntersFuncpbarrierq}ReturnsFuncppkmedianqq; 5 whilepInFuncpt1, pkmedianqq{ \n6 RunThreadUntilpt3, EntersFuncpbarrierq}ReturnsFuncppkmedianqq; 7 RunThreadsUntilpt1, t2, t3, ExitsFuncpbarrierq}ReturnsFuncppkmedianqq; \n8 RunThreadsUntilpt1, t2, EntersFuncpbarrierq}ReturnsFuncppkmedianqq; 9 } 10 RunThreadsUntilpt1, t2, \nThreadEndsq; 11 RunThreadUntilptm, ThreadEndq; 12 RunThreadsUntilpt1, t2, ThreadEndsq; RADBench Bug \n4(Mozilla NSPR Library mozilla-nspr1) SearchInFuncCB2 : 1 Tid t1, t2 WaitForDistinctThreadsp2, EntersFuncpMT \nsafe localtimeqq; 2 Tid t ChooseThreadpt1, t2q; 3 whilepchooseptrue, falseqq{ 4 RunThreadUntilpt, ReadsMem \n}WritesMem }CallsFunc }ThreadEndsq; 5 } 6 t pt == t1q? t2 : t1; 7 RunThreadUntilpt, ReturnsFuncpMT \nsafe localtimeqq; //assertion violation! RADBench Bug 5(Mozilla NSPR Library mozilla-nspr2) ExactSchedule \n: //Control location 42 is in function PR WaitCondVar 1 Tid t1 WaitForThreadpAnyThread, EntersFuncpPR \nWaitCondVarqq; 2 RunThreadUntilpt1, AtControlp42qq; 3 Tid t2 WaitForThreadpAnyThread \u00b4 t1, EntersFuncpPR \nInterruptqq; 4 RunThreadUntilpt2, ReturnsFuncpPR Interruptqq; 5 RunThreadUntilpt1, ReturnsFuncpPR WaitCondVarqq; \n RADBench Bug 6(Mozilla NSPR Library mozilla-nspr3) SearchSeqFuncs : 1 Tid t1 WaitForThreadpAnyThread, \nEntersFuncpreader mainqq; 2 Tid t2 WaitForThreadpAnyThread \u00b4 t1, EntersFuncpwriter mainqq; 3 whilepInFuncpt1, \nreader mainq}InFuncpt2, writer mainq{ 4 Tid t ChooseThreadpt1, t2q; 5 RunThreadUntilpt, ReturnsFuncpPR \nRWLock Wlockq}ReturnsFuncpPR RWLock Rlockq }ReturnsFuncpPR RWLock Unlockq}ThreadEndsq; 6 } RADBench \nBug 2(Mozilla SpiderMonkey JS spidermonkey1) SearchInFuncCB3 : 1 Tid t1 WaitForThreadpAnyThread, EntersFuncpjs \nGCqq; 2 Tid t2 WaitForThreadpAnyThread \u00b4 t1, EntersFuncpJS ClearContextThreadqq; 3 Tid t ChooseThreadpt1, \nt2q; 4 whilepchooseptrue, falseqq{ 5 RunThreadUntilpt, ReadsMem }WritesMem }CallsFunc }ThreadEndsq; 6 \n} 7 t pt == t1q? t2 : t1; 8 whilepchooseptrue, falseqq{ 9 RunThreadUntilpt, ReadsMem }WritesMem }CallsFunc \n}ThreadEndsq; 10} 11 t pt == t1q? t2 : t1; 12 RunThreadUntilpt, ThreadEndsq; //segmentation fault! \n RADBench Bug 8(Memcached server memcached) ExactSchedule : //Control locations (including 42) and other \nevents (FuncEnter, FuncReturn) are all manually //inserted in functions complete incr bin and process \narithmetic command 1 Tid t1, t2 WaitForDistinctThreadsp2, EntersFuncpcomplete incr binq }EntersFuncpprocess \narithmetic commandqq; 2 RunThreadUntilpt1, AtControlp42qq; 3 RunThreadUntilpt2, ReturnsFuncq; 4 RunThreadUntilpt1, \nReturnsFuncq; RADBench Bug 15 (MySQL Server mysql-server) SearchInFuncLS : //Control locations and other \nevents (FuncEnter, FuncReturn) are all manually inserted in functions //mysql insert and MYSQL LOG::new \n.le 1 Tid t1, t2 WaitForDistinctThreadsp2, EntersFuncpMYSQL LOG : new fileq; 2 Tid t3 WaitForThreadpAnyThread \n\u00b4 t1 \u00b4 t2, EntersFuncpmysql insertq; 3 whilepInFuncpt1, MYSQL LOG : new fileq }InFuncpt2, MYSQL LOG : \nnew fileq}InFuncpt3, mysql insertq{ 4 Tid t ChooseThreadpt1, t2, t3q; 5 RunThreadUntilpt, AtControl \n}ThreadEndsq; 6 }     \n\t\t\t", "proc_id": "2491956", "abstract": "<p>We present CONCURRIT, a domain-specific language (DSL) for reproducing concurrency bugs. Given some partial information about the nature of a bug in an application, a programmer can write a CONCURRIT script to formally and concisely specify a set of thread schedules to explore in order to find a schedule exhibiting the bug. Further, the programmer can specify how these thread schedules should be searched to find a schedule that reproduces the bug. We implemented CONCURRIT as an embedded DSL in C++, which uses manual or automatic source instrumentation to partially control the scheduling of the software under test. Using CONCURRIT, we were able to write concise tests to reproduce concurrency bugs in a variety of benchmarks, including the Mozilla's SpiderMonkey JavaScript engine, Memcached, Apache's HTTP server, and MySQL.</p>", "authors": [{"name": "Tayfun Elmas", "author_profile_id": "81758886657", "affiliation": "(formerly) University of California, Berkeley, Berkeley, CA, USA", "person_id": "P4148977", "email_address": "elmas@cs.berkeley.edu", "orcid_id": ""}, {"name": "Jacob Burnim", "author_profile_id": "81442603382", "affiliation": "(formerly) University of California, Berkeley, Berkeley, CA, USA", "person_id": "P4148978", "email_address": "jburnim@cs.berkeley.edu", "orcid_id": ""}, {"name": "George Necula", "author_profile_id": "81100295630", "affiliation": "University of California, Berkeley, Berkeley, CA, USA", "person_id": "P4148979", "email_address": "necula@cs.berkeley.edu", "orcid_id": ""}, {"name": "Koushik Sen", "author_profile_id": "81100399070", "affiliation": "University of California, Berkeley, Berkeley, CA, USA", "person_id": "P4148980", "email_address": "ksen@cs.berkeley.edu", "orcid_id": ""}], "doi_number": "10.1145/2491956.2462162", "year": "2013", "article_id": "2462162", "conference": "PLDI", "title": "CONCURRIT: a domain specific language for reproducing concurrency bugs", "url": "http://dl.acm.org/citation.cfm?id=2462162"}