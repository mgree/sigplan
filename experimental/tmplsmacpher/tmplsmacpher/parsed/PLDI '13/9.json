{"article_publication_date": "06-16-2013", "fulltext": "\n It s Alive! Continuous Feedback in UI Programming Sebastian Burckhardt Manuel F \u00a8Jun Kato ahndrich Peli \nde Halleux Sean McDirmid The University of Tokyo Michal Moskal Nikolai Tillmann i@junkato.jp Microsoft \nResearch {sburckha,maf,jhalleux,smcdirm,micmo,nikolait}@microsoft.com Abstract Live programming allows \nprogrammers to edit the code of a run\u00adning program and immediately see the effect of the code changes. \nThis tightening of the traditional edit-compile-run cycle reduces the cognitive gap between program code \nand execution, improving the learning experience of beginning programmers while boosting the productivity \nof seasoned ones. Unfortunately, live programming is dif.cult to realize in practice as imperative languages \nlack well\u00adde.ned abstraction boundaries that make live programming respon\u00adsive or its feedback comprehensible. \nThis paper enables live programming for user interface pro\u00adgramming by cleanly separating the rendering \nand non-rendering aspects of a UI program, allowing the display to be refreshed on a code change without \nrestarting the program. A type and effect sys\u00adtem formalizes this separation and provides an evaluation \nmodel that incorporates the code update step. By putting live program\u00adming on a more formal footing, \nwe hope to enable critical and tech\u00adnical discussion of live programming systems. Categories and Subject \nDescriptors D.3.3 [Language Constructs and Features]; D.2.2 [Design Tools and Techniques]: User Inter\u00adfaces; \nD.2.6 [Programming Environments] General Terms Languages, Human Factors Keywords Live Programming, Graphical \nUser Interface 1. Introduction One major dif.culty in writing programs is that a programmer must effectively \nsimulate parts of the execution of the program in his mind during development [14, 19]. If we can narrow \nthe gap be\u00ad tween the program text and seeing how the program behaves, pro\u00adductivity during code editing \nand debugging could be improved substantially. This gap takes two forms: 1) the time gap between making \nan edit and seeing the effect of the change is dominated by rebuilding the program, executing the program \nand guiding it (possibly with manual input) to the place where the edit can be observed. Speeding up \nthis edit-compile-run cycle can narrow the time gap, but the re-execution part remains critical and cannot \nbe narrowed by improvements in development tools. 2) the per\u00adception gap is the cognitive distance between \nlooking at the code Permission to make digital or hard copies of all or part of this work for personal \nor classroom use is granted without fee provided that copies are not made or distributed for pro.t or \ncommercial advantage and that copies bear this notice and the full citation on the .rst page. To copy \notherwise, to republish, to post on servers or to redistribute to lists, requires prior speci.c permission \nand/or a fee. PLDI 13, June 16 19, 2013, Seattle, WA, USA. Copyright c &#38;#169; 2013 ACM 978-1-4503-2014-6/13/06. \n. . $15.00 and understanding what the code will do when it is run. Address\u00ading this perception gap requires \nan environment where code can be edited continuously with uninterrupted live feedback, show\u00ading the consequences \nof those edits. This so-called live program\u00adming [11] enables more .uid problem solving compared to today \ns common edit-compile-debug style of programming. Most people are familiar with live programming in the \ncontext of spreadsheets, where data and formulae can be edited and the ef\u00adfect of those edits be seen \nimmediately. Besides spreadsheets, lan\u00adguages based on mostly declarative programming models, includ\u00ading \nmany visual languages like Pure Data [20], already provide a live programming experience, but these languages \nare not expres\u00adsive enough for more complex general purpose programs [6]. Grafting live programming features \nonto existing mainstream imperative programming languages such as Java or C# is daunting. Currently, \nsuch languages support .x-and-continue features that al\u00adlow a restricted set of code changes to a live \nprogram and then continue execution. However, .x-and-continue alone does not pro\u00advide a live programming \nexperience. Live programming requires at a minimum some state snapshot, some re-execution of changed \ncode, and some re-displaying of results. Exactly what data to save, what code to re-execute, and which \nparts of the UI to maintain is dif.cult to answer in a general purpose language. A natural start\u00ading \npoint is re-execution of a trace of the entire program to the current point. However, apart from the \ncost of trace capturing and re-execution, traces are problematic since code changes can cause the re-execution \nto diverge from the previous trace. In light of this observation, it seems dif.cult to establish a precise \ntechnical de.\u00adnition of live programming to start with. This paper tackles the question of live programming \nin the domain of user interface (UI) programming by proposing a formal model, where a program consists \nof both code and persistent data. The program is event based and viewed as continually executing. A code \nchange is simply one possible transition of the program in our model. The bene.t of formalizing such \na language and execution model is that it unambiguously answers questions about what state is saved, \nwhat state is rebuilt, and what code is re-executed as a result of a code change. Our language is imperative \nand has an explicit imperative way of building up user-interface state in the form of nested boxes, akin \nto TeX and HTML, on a stack of pages. We separate both the UI state from ordinary state, and the render \ncode that builds UI state from ordinary code. As a result, upon code changes, we throw away the UI state, \nand then rebuild the UI state for the currently displayed page using the separated render code for that \npage. Beyond achieving live feedback, our model also reduces the perceptive gap between code and the \nUI components rendered on a page by the use of a boxed construct that builds a UI element as a side effect. \nUsing syntactic nesting and arbitrary code such  Figure 1. The two pages of the mortgage calculator \nexample; a start page is on the left; a detail page is on the right. as loops, conditionals, and procedure \nabstraction, UI construction is very expressive and not limited to a specialized declarative sub\u00adlanguage. \nWe make the following contributions: We propose a programming model where UI state is built using procedural \ncode, but maintained separate from the normal state of the program. UI s are organized as page stacks \nwith opera\u00adtions to push a new page or pop the current page.  We put live programming on a formal footing \nby providing an execution model in which one can argue what parts of the code are re-executed upon a \nprogram change.  Although live programming has recently been demonstrated [10, 27] to much fanfare, \ndesigning and building these systems is so far a black art. We report on our experience implementing \nand using our programming model in TouchDevelop [1, 25], a de\u00ad vice independent browser-based programming \nlanguage and development environment.  Section 2 further motivates live programming while Section 3 \nin\u00ad troduces how our language and environment supports it. Section 4 describes and formalizes our implementation, \nproviding insights on how to design and build future systems. Section 5 presents our ex\u00ad perience with \nour implementation and a discussion of the trade-offs made in its construction. Section 6 presents related \nwork while Sec\u00ad tion 7 concludes. 2. Motivation We now explain the motivation for live programming with \na dis\u00adcussion of how it improves on existing programming practice. For this discussion, we use as a running \nexample a simple program to browse local listings of houses for sale, and calculate mortgage payments \nand an amortization schedule. On startup, the applica\u00adtion issues a web request to obtain listings that \nare displayed on the program s start page (Figure 1, left). When the user taps an entry, the program \nnavigates to a detail page that displays the monthly mortgage payment and an amortization schedule (Figure \n1, right). The user can modify the term of the mortgage and the annual per\u00adcentage rate by tapping the \ncorresponding box. Suppose that the programmer is not satis.ed with the UI and wishes to make the following \n.xes and improvements: (I1) adjust various margins to improve the visual appearance; (I2) print the monthly \nbalance in properly formatted dollars and cents; and (I3) highlight every .fth line of the amortization \nschedule with a differ\u00adent color. If the code were written in a conventional language and programming \nenvironment, a programmer implementing the three improvements (I1-I3) would have to iterate the following \nsteps: 1. Stop the program execution. 2. Discover and navigate to the code location that needs to be \n.xed. 3. Edit the code to change the behavior. 4. Compile the code, and restart the program. 5. Navigate \nto the appropriate UI context by waiting for the list to download, and clicking on an entry. 6. Inspect \nthe display to verify the .x. 7. If not satis.ed, continue with step 1.  This cycle is time-consuming \nand tiring since temporal delays drain programmer concentration; e.g., consider the waiting for code \ncompilation or the list to download, navigating to the correct UI screen, and, while debugging, remembering \nprocedure names and the call graph to retrieve relevant code. Hancock [11] compares this way of programming \nto the activity of an archer: you aim, shoot, string another arrow, carefully correct the aim, shoot \nagain, and so on. This productivity drain is particularly harmful when dealing with design properties \nthat require many iterations in practice, such as margins, font sizes, or colors. Conventional programming \ncan currently be made more .uid in a couple of ways. First, a programmer could use a read-eval-print \nloop (REPL) to quickly experiment with code statements, such as monthly interest rate printing, on a \ncommand line. However, using a REPL precludes debugging the UI directly, and each feature must be developed \nas a command-line computation. Second, many IDEs for languages such as L ISP [23], Smalltalk [9], Java, \nand C# support a .x-and-continue feature where the programmer can modify their code without restarting \nthe debugging process. Unfortunately, .x-and-continue often does not result in responsive feedback: for \nthe common retained UI where a program builds and modi.es a tree of widget objects to be rendered, changing \nthe code that initially builds this widget tree is meaningless as that code has already executed and \nwill not execute again! If editing and debugging a program were to occur simultane\u00adously, the programmer \ncould make an adjustment to interest rate printing, observe immediately what this change produces, and \nthen  Figure 2. Code edited in the right code view is continuously type-checked, compiled, and executed, \nwhere its behavior is instantly visible in the left live view. Selecting a box in the left live view \n(highlighted red outline) causes the corresponding boxed statement to be selected in the right code view, \nand vice versa. quickly make another edit to adjust the formatting based on that ob\u00adservation. Although \nparts of the program must be re-executed, the application and UI state of the program must be maintained \nso that the programmer can focus on editing and observing. Hancock [11] compares live programming to \nusing a water hose in contrast to archery: as we adjust which way the hose is pointed, the stream of \nwater from us toward the target re.ects back as an uninterrupted stream of information about the consequences \nof our aim. Live programming has long been supported by many visual pro\u00adgramming languages; e.g., a program \nin PureData [20] is expressed as a data .ow graph that is continuously executing while the user is adding \nnodes and edges in this graph. Such visual languages re\u00adalize live programming with inexpressive declarative \nprogramming models of simpli.ed control .ow constructs and heavily encapsu\u00adlated state. For example, \nediting a PureData program simply causes re-execution of its data .ow graph where any state encapsulated \nin a node is easily preserved. Unfortunately, a large class of programs, including our running example, \ncannot easily be rewritten using existing declarative live visual languages given their inexpressive \nprogramming models. On the other hand, building an IDE that can support live program\u00adming for a more \nexpressive language like C# is technically daunt\u00ading given their support for complex control .ow and \nimperative state. Many programming environments for conventional languages do offer a limited live experience \nby separating declarative style declarations from the imperative code that generates content; e.g., HTML \nand cascading style sheets (CSS) allow designers to change box structure and stylistic properties of \nweb pages and inspect the result immediately while ignoring embedded Javascript code. This live experience \ncan handle aesthetic tweaks like the I1 improvement in the list above, but unfortunately cannot support \na wide variety of program alterations, such as the I2 and I3 improvements. As observed in [17], updating \na UI based on changes in the code is really not that different from updating the UI based on model changes. \nThe important question is how to ensure that the view is up-to-date with respect to the model in the \n.rst place. The widely used model-view-controller (MVC) pattern (pioneered in [21]) requires the programmer \nto write code that reacts to model changes and performs the corresponding updates to the view. If the \nview is a complex function of the state, writing such code can be challenging (in database systems, this \nis known as the view-update problem), and it is questionable whether the programmer should be bothered \nto perform such dangerous mental acrobatics. We adopt a more straightforward solution: the programmer \nwrites code that directly speci.es how the view is constructed from the model, and just rerun this code \nwhenever the model changes. We thus construct a fresh view instead of updating the existing one, known \nas the immediate vs. retained approach to GUI programming [18]. The immediate approach naturally enables \nlive programming, because in response to a code change we can simply re-render the UI with the new code \napplied to the program s old state. The next section describes how we leverage this technique to enable \nlive programming in our language. 3. Live Programming in TouchDevelop We modify the TouchDevelop language \n[25] with programming model changes that enable live UI programming in an enhanced programming environment. \nThe traditional edit-compile-run cycle is tightened and enhanced via the following three features: Live \nEditing. The program keeps running while the program\u00admer edits their code. Our editor provides a split \nscreen that shows program execution on the left in the live view, and pro\u00adgram code being edited on the \nright in the code view (Figure 2). All changes to UI-rendering code are immediately visible in the live \nview because the program is continuously being type\u00adchecked, compiled, and executed as the programmer \nedits. UI-Code Navigation. The environment maintains navigable bi\u00addirectional connections between rendered \nelements in the live view and code that created these elements in the code view. If the user taps a UI \nelement, which we call a box, in the live view, the editor on the right selects the boxed statement in \nthe code view that created the UI element (Figure 2). Likewise, if the user selects a boxed statement \nin the code view, the corre\u00adsponding box (or boxes) is selected in the live view. Note that a selected \nboxed statement appearing inside a loop corresponds to multiple boxes in the display, which are collectively \nselected in the live view (Figure 2). Direct Manipulation. Combining both live editing and UI\u00adcode navigation, \nthe programmer can directly change the at\u00adtributes of a box in the live view, where the code view is \nupdated automatically to re.ect these changes (known as direct manip\u00adulation in [24]). For example, to \ninsert a command to change the size of a margin, the programmer can .rst select the cor\u00adresponding box \nin the live view and then choose the margin property from a button menu, which inserts (if not present) \na command in the code and positions the code cursor on the mar\u00adgin number. The programmer can then edit \nthis number while observing the result in the live view.  Although one may imagine an implementation \nthat provides some or all of these features without any changes to the programming language, such as \nby using deterministic replay or program analy\u00adsis, we focus here on the programming language design \nrather than heroic tool construction. Thus, our main contribution is to demon\u00adstrate how to enable a \nsimple and transparent implementation of a live experience by specializing the programming model. We \ntake concepts from UI programming event-based pro\u00adgramming, model-view separation, box-based layout, \nand page\u00adstack navigation and bake them directly into the execution model, language, and type system. \nWe .rst present an example-based de\u00adscription of this model; an in depth description of the programming \nmodel appears in Section 4. As usual, programmers can de.ne global procedures and vari\u00adables in TouchDevelop. \nIn addition, programmers can now de.ne pages that take arguments like procedures (an idea we borrowed \nfrom the Mobl programming language [13]). The TouchDevelop code for the start page of our example program \nin Section 2 is shown in Figure 3. Unlike procedures, pages have two bodies rather than one: The initialization \nbody is executed before the page is rendered for the .rst time. It can update global variables, but it \ncannot create any UI elements (boxes). The initialization body for the startup page is the init code \nat the top in Figure 3. It downloads the list of properties for sale and stores it in the variable listings. \n The render body is called to build or refresh the display with interactive UI elements known as boxes; \nthe render body in Figure 3 de.nes two top-level vertically-stacked boxes1. The .rst top-level box is \nthe header. It contains two boxes of text laid out horizontally. The second top-level box contains all \nlistings, where a box for each entry is created by iterating over each listing stored in the listings \nvariable. Note that, while render code can read global variables, such as listings, it cannot write global \nvariables. The only effects of render code are the construction of UI elements through boxed constructs. \n In model-view terminology, the view of the program is thus de\u00ad.ned by the render body of a page, while \nthe model is expressed as the program s global variables. The render body is re-executed in response \nto changes to the model or to code called during ren\u00addering. The latter guarantees that the live view \nis always consis\u00adtent with the current code. Since render code cannot modify global variables, re-execution \nof a render body preserves the model (val\u00adues of global variables). Initialization of the model must \noccur in the initialization body, which is not automatically re-executed and therefore cannot undergo \nlive programming. Boxes, which are TouchDevelop s UI elements, are de.ned in a page as nested boxed statements \nin much the same way that DOM elements are de.ned in HTML. We refer to them collectively as a page s \nbox tree. Unlike widgets in conventional UI libraries, boxes are not .rst-class values in TouchDevelop, \nmeaning code does not manipulate the box tree structure directly. Instead, the box tree is created as \na side effect of the execution weaving in and out of boxed statements. This execution is free to use \nloops, arbitrary conditionals, and procedure calls. For example, the last boxed statement in the code \nof Figure 3 is embedded in a for-loop, 1 Vertical stacking is the default.  example, whose rendering \nwas shown on the left of Figure 1 in Section 2. Note on syntax: attributes and methods are accessed via \n. rather than the typical .; global functions calls are preceded by t; and global variable references \nare preceded by a square symbol. producing a number of boxes equal to the number of items in the listings \nvariable. Additionally, it creates nested boxes by calling the display listentry procedure. Boxes have \nattributes that include layout parameters (margins, size, layout direction, font sizes), and event handlers. \nEvent handlers can be registered on boxes using the on state\u00adment to respond to interactions such as \ntapping or editing by the user. To respond to an event, event handlers can modify global vari\u00adables as \nmodel state, or perform page nagivation such as popping the current page or pushing a new page. Handlers \nare not part of render code and are never executed as part of rendering. The last two lines in Figure \n3 de.ne a tapped event handler for each list\u00ading entry. When activated, it pushes the detail page for \nthat entry, whose code is de.ned in Figure 4. To maintain a clean separation between the model (global \nvari\u00adables) and the view (boxes and render code) and to guarantee that the view is a well-de.ned function \nof the model, we enforce the following rules: The view is stateless: the display content (the box tree, \ninclud\u00ading attributes and handlers) cannot be read by the code, and is discarded as soon as it becomes \nstale. Boxes are second class values and so cannot be referenced (aka aliased) outside render\u00ading code. \nAttributes of a box can only be modi.ed by statements inside the dynamic scope of the corresponding boxed \nstatement.  Render code can only read, but not modify global variables (model state).  Non-render code, \nsuch as initialization bodies and event han\u00addlers, can modify global variables, but cannot produce boxes. \n We show in Section 4 how we enforce these rules at compile time using a type and effect system.  \nexperience. Code-execution rei.cation and direct manipulation in turn are supported by TouchDevelop s \nsimple box model, which al\u00adlows the environment to easily keep track of code/box mappings. Our enhanced \nprogramming model also helps to keep UI code con\u00adcise and readable. Although the code in Figure 3 looks \na bit like declarative code, it executes just like any other procedural code: it is free to use loops \nto create multiple boxes, procedural abstraction to keep the code organized, and conditional statements \nto customize the display based on arbitrary conditions. 3.1 Example Improvements We now discuss how \nthe three improvements (I1 I3) described at the beginning of Section 2 are applied by the programmer \nin the live programming enhanced version of TouchDevelop. The programmer starts the program and begins \nediting our example program s startpage, whose code is shown in Figure 3. The .rst improvement made is \nto tweak the margins of the page (I1), which is done through direct manipulation: one simply selects \nthe box to modify in the output display which brings up a menu on the code side to change it. When the \nprogrammer taps an entry on the start page, its detail page opens (Figure 2) and the code view shows \nthe code in Figure 4. The monthly amortization table of this page is generated by calling the display \namortization function de.ned in Figure 5. Selecting one of the balance cells in the detail page selects \nthe corresponding boxed statement in the code view (last boxed in Figure 5. Changing this statement to: \nboxed var dollars := math . .oor(balance) var cents := math . round((balance -dollars) * 100) || \"\" if \ncents . count < 2 then cents := \"0\" || cents (\"balance: $\" || dollars || \".\" || cents) . post will cause \nthe balance to print correctly in dollars and cents, im\u00adplementing our I2 improvement; balance printing \nis updated for all amortization table rows as soon as we complete the last line of this modi.cation. \nThe last improvement, high-lighting every .fth year of the amortization in another color (I3), involves \nselecting an amorti\u00adzation row in in the live view, which causes the .rst top-level box Figure 5. The \nprocedure to display the amortization schedule. of Figure 5 to be selected in the code view. The programmer \ncan add the code if math . mod(i, 5) == 4 then box . set background(colors . light blue) to set the background \nof every .fth row to a light blue color. This improvement demonstrates how our live programming improves \non UI editors that operate over purely declarative languages. E.g., HTML/CSS has special support for \neven-odd coloring, but cannot go beyond that without the loss of live feedback. 4. Formal Model In this \nsection, we develop a formal operational model. This model removes any ambiguities that are often a source \nof confusion in re\u00adactive systems, where user actions (back button, box tapping, code updates) are interleaved \nwith program execution (event handling, rendering). It also clari.es how we avoid some typical problems, \nsuch as (1) the programmer unintentionally violating the view\u00admodel separation, or (2) strange failures \ndue to inconsistencies be\u00adtween various versions of the code. We start with the syntax for writing code \n(Section 4.1). Then, we present an operational model that de.nes how the system state (which includes \nthe code) evolves when handling user events, receiving code updates, or performing execution steps (Section \n4.2). Finally, we present and discuss our type and effect system (Section 4.3). We do not formalize the \nvisual layout of box trees. 4.1 Expression Syntax We show the expression syntax in Fig. 6. It is based \non the simply typed lambda calculus with the following additions: We use tuples to simplify the passing \nof multiple values to functions and page code. Also, empty tuples serve as the unit value, which we use \nheavily (since many of our operations are imperative in nature).  We use global variables (representing \nthe model state) and global function de.nitions (representing the current code). This   Identi.ers: \ng ::= ... global variables f ::= ... global functions p ::= start | ... page names a ::= ontap | margin \n| ... box attributes \u00b5 ::= p | r | s pure, render, state effect Types: t ::= number (number) | string \n(string) | (t1, ..., tn) (tuple), (n = 0) \u00b5 | t . t (function) Environment: G ::= E | G, x : t (variable \ntype) | G, a : t (attribute type) Values: v ::= n (number literal) | s (string literal) | x (variable) \n| (v1, ..., vn) (tuple) | .(x : t). e (lambda) Expressions: e ::= v (value) | e1e2 (application) | f \n(function) | (e1, ..., en) (tuple), (n = 0) | e.n (projection), (n = 1) | g (read global) | g := e (write \nglobal) | push p e (push new page) | pop (pop page) | boxed e (create box) | post e (post content) | \nbox.a := e (set box attribute) Evaluation Contexts: E ::= [] | E e | v E | (v1, ..., vi, E, ej , ..., \nen) | E.n | g := E | push p E | post E | box.a := E Figure 6. The syntax of types, values, expressions, \nand evaluation con\u00adtexts. separation is important during code updates, when we need to .x up the model \nstate and purge stale code. We use page names to identify pages, and we support operations for pushing \na new page (passing a parameter) and popping the current page.  We support boxed statements to create \na box, post e to add content to the current box, and box.a := e to modify an attribute of the current \nbox.  Our calculus is intentionally kept concise even though our exam\u00adples use a higher level syntax. \nLoops are expressible in our calcu\u00adlus via recursion through global functions, conditionals via lambda \nabstractions and thunks. Handlers on boxes are simply attributes that can be set to lambda expressions. \nThese differences are purely syntactic and no expressivity is lost. System State: s ::= (C, D, S, P, \nQ) System Components: C ::= E | C d (program code) D ::= . | B (display) S ::= E | S[g . v] (store) P \n::= E | P (p, v) (page stack) Q ::= E | Q q (event queue) Program De.nitions: d ::= global g : t = v \n(global) | fun f : t is e (function) | page p(t ) init e1 render e2 (page) Box Content: B ::= E (empty) \n| B v (leaf content) | B [a = v] (box attribute) | B (B) (nested box) Events: q ::= [exec v] (execute \nthunk) | [push p v] (push new page) | [pop] (pop page) Figure 7. De.nitions for system states, programs, \nbox content, and events.  4.2 System Model Our operational model is de.ned by a set of system states \nand a set of system transitions. A system state is a tuple (C, D, S, P, Q) as de.ned in Fig. 7. Note \nthat for simplicity, we represent our data structures as sequences (with E being the empty sequence), \nthough an actual implementation would use specialized data struc\u00adtures such as maps, sets, queues, and \nso on. The meaning of the components is as follows: C represents the code (i.e. the program). It contains \n(1) global variable de.nitions that specify a name, a type, and an ini\u00adtial value, (2) function de.nitions \nthat specify a name, a func\u00adtion type, and a lambda expression, and (3) page de.nitions that specify \na page name, the type of the argument passed to the page on construction, and two functions to respectively \nbe called on initialization and rendering. To save space, we write C(p) = (fi, fr) as a shorter form \nfor (page p(t) init fi render fr) . C.  D represents what is currently displayed to the user. It contains \neither box content B (recursively de.ned as a sequence of layout attributes, values, and nested boxes), \nor the special value . to indicate that the display is stale and needs to be refreshed.  S represents \nthe store (i.e. the values of global variables). We represent S as a sequence of key-value pairs [g . \nv]; the right\u00admost occurrence of a key g de.nes its current value, denoted S(g).  P represents the page \nstack. It is a sequence of pairs (p, v) where p is a page identi.er and v is the argument value that \nwas supplied when the page was created. We add and remove entries at the end of the sequence.  Q represents \nthe event queue. It contains three kinds of events: [exec v], [push p x], [pop]. We enqueue by adding \nelements   Pure execution steps: (fun f : t is e) . C (E P -F U N) (C, S, E [f]) .p (C, S, E [e]) (E \nP -A P P) (C, S, E [.(x : t).e) v]) .p (C, S, E [e[v/x]]) (E P -T U P L E) ((C, S, E [(v1, ..., vm).n]) \n.p (C, S, E [vn]) S(g) = v (E P -G L O BA L -1) ((C, S, E [g]) .p (C, S, E[v]) g /. dom S global g : \nt = v . C (E P -G L O BA L -2) ((C, S, E [g]) .p (C, S, E[v]) Execution steps for standard mode: (C, \nS, e) .p (C, S, e1) (E S -P U R E) (C, S, Q, e) .s (C, S, Q, e1) (E S -A S S I G N) (C, S, Q, E [g := \nv]) .s (C, S [g . v], Q, E [()]) (E S -P U S H) (C, S, Q, E [push p v]) .s (C, S, [push p v] Q, E [()]) \n(E S -P O P) (C, S, Q, E [pop]) .s (C, S, [pop] Q, E [()]) Execution steps for render mode: (C, S, e) \n.p (C, S, e1) (E R -P U R E) (C, S, B, e) .r (C, S, B, e1) (E R -P O S T) ((C, S, B, E [post v]) .r (C, \nS, B v, E [()]) (E R -AT T R) ((C, S, B, E [box.a := v]) .r (C, S, B [a = v], E [()]) (C, S, e, e) .* \n(C, S, B1, v) r (E R -B OX E D) (C, S, B, E [boxed e]) .r (C, S, B (B1), E [v]) Figure 8. Expression \nevaluation steps are de.ned by .p, .s and .r for pure mode, standard mode, and render mode, respectively. \n.* is the \u00b5 re.exive transitive closure of .\u00b5. to the left of the sequence, and dequeue by removing elements \nfrom the right end of the sequence. At the heart of our operational semantics are the small expres\u00adsion \nevaluation steps, de.ned in Fig. 8. We distinguish three differ\u00ad ent steps based on their effects. Pure \nsteps are side-effect free, but may depend on the code C and the current global state S, thus they are \nof the form (C, S, e) .p (C, S, e1). Standard execution steps are of the form (C, S, Q, e) .s (C, S 1, \nQ1, e1); they may modify the state S or add elements to the event queue Q. Render steps are of the form \n(C, S, B, e) .r (C, S, B1, e1); they may be pure, or can append an element to the current box content \nB. Our evaluation rules enforce that render functions have no side effects other than updating the display, \nand that the display cannot be accessed by any other user code. This is important, because it is otherwise \nmuch too easy for programmers to (intentionally or unintentionally) break the principles of our model-view \nseparation, with highly confusing consequences. At the system level, We de.ne the system step relation \n.g as a binary relation on system states in Fig. 9. We call a system state stable if the event queue \nis empty, and the page stack is non-empty. In stable states, the system is waiting for user actions such \nas (TA P) Three rules that enqueue events: (STA RT U P) (C, D, S, e, e) .g (C, ., S, e, [push start ()]) \n[ontap = v] . B (TA P) (C, B , S, P, Q) .g (C, ., S, P, [exec v] Q) (BAC K) (C, D, S, P, Q) .g (C, ., \nS, P, [pop] Q) Three rules that handle events: (C, S, Q, v ()) .* (C, S 1, Q1, ()) s (TH U N K) (C, D, \nS, P, Q [exec v]) .g (C, ., S 1, P, Q1) C(p) = (fi, fr) (C, S, Q, (fi v)) .* (C, S 1, Q1, ()) s (P U \nS H) (C, D, S, P, Q [push p v]) .g (C, ., S 1, P (p, v), Q1) P = P 1(p, v) or P = P 1 = e (P O P) (C, \nD, S, P, Q [pop]) .g (C, ., S, P 1, Q) One rule to refresh the display: C(p) = (fi, fr) (C, S, e, (fr \nv)) .* (C, S, B , ()) r (R E N D E R) (C, ., S, P (p, v), e) .g (C, B, S, P (p, v), e) One rule to change \nthe program code: C1 f C1 C1 : S t S 1 C1 : P t P 1 (UP DAT E) (C, D, S, P, e) .g (C1, ., S 1, P 1, e) \nFigure 9. System steps are de.ned by .g. for tapping a box in the display, (BAC K) for hitting the back \nbutton, and (U P DAT E) for code updates. We de.ne the initial system state to be (C, ., E, E, E), which \nis unstable. While the system state is unstable, one of the following transitions is always enabled: \n If the page stack is empty, we can perform the transition (STA RT U P) which enqueues an event [push \nstart ()] causing the system to create the start page.  If the event queue is not empty, we can dequeue \nthe next ele\u00adment with one of the following transitions:  (T HUN K) dequeues [exec v] and executes the \nthunk v (which is a lambda function that takes a unit value and returns a unit value). It executes v \nin standard execution mode, taking as many small steps as necessary to reduce the expression v () to \na value. (PU S H) dequeues [push p v], pushes a new page (p, v) onto the page stack, and executes the \npage initialization code (passing v as the argument), in standard execution mode. It takes as many small \nsteps as necessary to reduce to a value. (PO P) dequeues [pop], and either pops the top page, or does \nnothing (if the page stack is already empty). Some of these transitions can enqueue more events onto \nthe queue (for example, executing a push or pop expression in user code enqueues a push or pop event). \nThis can lead to an in.nite loop of pushing new pages. Also, the execution of user code may of course \ndiverge. Apart from those nonterminating cases, however, we eventually reach a stable state (we never \nget stuck, as discussed in Section 4.3). Thus the system is always live, either in an active state (executing \nsome user code), or in a stable state (ready to handle user events or code updates).  All global transitions, \nexcept for (RE N DE R), also invalidate the display (set it to .). The display remains invalid until \nwe do the (R E N D E R) transition. This transition executes the render code for the page that is currently \nat the top of the stack, in render mode, taking as many small steps as necessary. This mechanism guarantees \nthat the display is never stale, but either invalid or current with respect to the model state and the \ncode. In particular, it is not possible to activate tap handlers on a stale display: the prerequisite \nof the rule (TA P) can only be satis.ed if the display is valid, which also implies that Q is empty. \nIn a stable state, the transition (U P DAT E) allows the user to update the code (swap new code C1 for \nold code C). Its .rst prerequisite (to be formally de.ned in Section 4.3) is C1 f C1 , which means that \nC1 must be well-typed and satisfy a number of sanity conditions. Note that there is no requirement that \nC1 is related in any way to C. Instead, our transition performs a .x-up of the global state (de.ned by \nthe relations C1 : S C S1 and C1 : P C P 1 which we discuss in Section 4.3). Supporting arbitrary code \nchanges is important in practice: limiting the changes a user can make is both complex to implement and \nexplain, and unpleasant for the user. Another important guarantee we make is that after a code up\u00addate, \nthe system contains no stale code (such as closures taken in earlier versions). The reason is that after \napplying rule (U P DAT E), the display and the event queue are empty. Since neither global variables \nnor the page stack contain function values (we enforce this using the type system), the state contains \nno code.  4.3 Typing of Expressions and States Fig. 10 shows how we type expressions. Our judgments \nhave the form C; G f\u00b5 e : t, meaning that we can type e as t given the code C, context G, and effect \n\u00b5 (which is one of p, s, r for pure, state, or render). We de.ne an attribute environment Ga that contains \ntypes s for box attributes, such as ontap : () . () and margin : number. Note that our model has an implicit \ntop-level box, so render code can set attributes even outside a boxed statement. The rules in Fig. 10 \nare mostly standard [15]. Rules indexed by effect variable \u00b5 can be instantiated to all three effect \nmodes p, s, r. The types relate to the operational semantics in that an expression e typable under effect \n\u00b5 reduces to a value under . * , thereby \u00b5 guaranteeing that render code can be reduced by .r rules, \nand that stateful code can be reduced by .s rules. Fig. 11 shows how we type system states. Not surprisingly, \nit involves separate typing judgements for almost all system compo\u00adnents. The top rule (T-SY S) ensures \nthat there is a de.nition for the start page (otherwise we would be stuck before execution even starts). \nThe typing judgments C f D, C f S, C f P , and C f Q are straightforward typings for the display, global \nvariables, page stack, and event queue. The typing judgments C f C enforce that no name is de.ned twice, \nand that de.nitions use correct typings. In particular, global variables must have function-free types \n(notated as .-free), functions must be typable with the type they declare, and the render and init functions \nmust be typeable under the corre\u00adsponding effect. Preservation. All small evaluation steps preserve the \ntype of the evaluated expression (i.e. if e .\u00b5 e 1, we can type e 1 with the same type and effect as \ne), and leave the store and the queue well typed. This is a simple consequence of our type and effect \nsystem (we are using a widely known standard construction). System steps also preserve the typeability \nof the system state. This is mostly a simple consequence of manipulating the state correctly, and of \nthe preservation guarantee for small evaluation steps. However, the (U PDATE) rule is interesting since \nit completely replaces the code. In this case, to ensure typeability of the state, we need to .x up the \nC : S t S 1 (S-E M P T Y) C : e t e (S -S K I P) g . C . (C; e fs v : t) C : S [g . v] t S 1 (S -O K \nAY) C : S t S 1 global g : t =. C C; e fs v : t C : S [g . v] t S 1 [g . v] C : P tP 1 p . C . (C; e \nfs v : t) (P-E M P T Y) (P-S K I P) C : ete C : P (p, v) t P 1 C : P tP 1 C; e fs v : t page p(t) init \ne1 render e2 . C (P-O K AY) C : P (p, v) t P 1 (p, v) Figure 12. Rules for .xing up the globals and the \npage stack. global state and page stack. The algorithm for this .x-up is shown in Fig. 12. Essentially, \nit just deletes whatever does not type. Progress. Any expression e that is not a value and that types \nas C; G f\u00b5 e : t, with \u00b5 = p or \u00b5 = s, can take a step e .\u00b5 e 1. However, if \u00b5 = r, progress may be only \nindirect: if e = E[boxed e 1] and e 1 has a diverging computation, then it is only e 1 that makes progress, \nbut not e. At the system level, progress is also guaranteed with some restrictions. In a stable system \nstate, the system makes no progress unless there are user-initiated actions. In unstable states, the \nsystem can always make progress except if there is a diverging expression evaluation (again, progress \nin that case is indirect: the expression evaluation makes progress, but the system as a whole does not). \n5. Experience We now present our experiences in designing, building, and using an enhanced version of \nTouchDevelop, along with a discussion of the various tradeoffs we had to make to achieve a reasonable \nlive programming experience. TouchDevelop is public, free to use, and runs in most browsers on any device; \nwe encourage the reader to check it out [1]. We have also produced an 8-minute video that demonstrates \nthe live programming feature.2 Much of our work was focused on improving the user experi\u00adence for the \nprogrammer. Our key .nding here was to place the live and code view side by side while making elements \nin each view navigable to elements in the other view. The live view is automat\u00adically scaled down to \n.t on a smaller portion of the screen, but we support interactive zooming to allow programmers to inspect \nthe effect of detail adjustments (such as margins and font sizes). Also, because nested boxes often cover \ntheir containers completely, we support a nested selection mode where the user can tap the same box multiple \ntimes to select enclosing boxes. One limitation of our system is the representation of a UI pro\u00adgram \ns model as a collection of global variables, where the view itself cannot retain any state. For example, \nthe value of a slider widget must be de.ned as a global variable, which is then passed into render code \nto be read and manipulated. Our strict separation of model and view thus con.icts with the encapsulation \nprinciple. How to support encapsulation of state in view elements, and how to deal with tricky initialization \nsemantics, remain to be addressed by future work. Live programming can be an alternative to step-wise \ndebuggers, given the easy navigability between code and rendered UI artifacts. 2 http://bit.ly/itsalive13 \nor directly http://youtu.be/ XnWgX6cORJM. Please use HD quality setting.  (T-I N T) C; G f\u00b5 n : number \n(T-S T R I N G) C; G f\u00b5 s : string (T-VA R) C; G, x : t f\u00b5 x : t C; G f\u00b5 ei : ti (T-T U P L E) C ; G \nf\u00b5 (e1..en) : (t1..tn) C; G, x : t1 f\u00b51 e : t2 (T-L A M) \u00b51 C; G f\u00b52 .(x : t).e : t1 . t2 p C; G f\u00b5 e \n: t1 . t2 (T-S U B) C; G f\u00b5 e : t1 .\u00b52t2 \u00b5 C; G f\u00b5 e1 : t1 . t2 C; G f\u00b5 e2 : t1 (T-A P P) C; G f\u00b5 e1e2 \n: t2 fun f : t1 .\u00b52t2 is e2 . C (T-F U N) \u00b52 C; G f\u00b5 f : t1 . t2 C; G fr e : t (T-B OX E D) C; G fr \nboxed e : t C; G fr e : t (T-P O S T) C; G fr post e : () Ga(a) = t C; G fr e : t (T-AT T R) C; G fr \nbox.a := e : () global g : t = v . C (T-G L O BA L) C; G f\u00b5 g : t global g : t =. C C; G fs e : t (T-A \nS S I G N) C; G fs g := e : () C(p) = (e1, e2) C; G fs e : t (T-P U S H) C; G fs push p e : () (T-P O \nP) C; G fs pop : () C; G f\u00b5 e : (t1..tn) (T-P RO J) C; G f\u00b5 e.i : ti C f C C f D C f S C f P C f Q page \nstart().. . C (T-S Y S) f (C, D, S, P, Q) (T-E M P T Y) C f e (T-D-I N V) C f . C f B (T-B -VA L) C f \nB v C f B Ga(a) = t C; e fp v : t (T-B-AT T R) C f B [a = v] C f Bi (T-B-N E S T) C f B1 (B2) Figure \n10. Expression type rules. C f C1 g /. Defs(C1) t is .-free C; e fp v : t (T-C-G L O BA L) C f C1 global \ng : t = v C f C1 f /. Defs(C1) \u00b5 C; e fp e : t1 . t2 (T-C-F U N) \u00b5 C f C1 fun f : t1 . t2 is e C f \nC1 p /. Defs(C1) t is .-free s C; e fs e1 : t . () r C; e fs e2 : t . () (T-C-PAG E) C f C1 page p(t) \ninit e1 render e2 C f S C; e fp v : t (T-S-E N T RY) C f S [g . v] C f P C; e fp v : t page p(t) init \ne1 render e2 . C (T-R -E N T RY) C f P (p, v) s C f Q C; e fp v : () . () (T-Q-E X E C) C f Q [exec v] \nC f Q C; e fp v : t page p(t) init e1 render e2 . C (T-Q-P U S H) C f Q [push p v] C f Q (T-Q-P O P) \nC f Q [pop] Figure 11. System state type rules. However, not all aspects of program execution may be \nsuf.cently visible in the view. Also, the code in event handlers and initializa\u00adtion bodies is not debuggable \nvia live programming. Thus, a step\u00adwise debugger is still useful and future work may look at how live \nprogramming and step-wise debugging can work together. Alterna\u00adtively, we may explore enhancing the programming \nmodel so that even state-changing code can be debugged through live program\u00adming, as in the Subtext language \n[7]. One avenue to explore is the use of boxed statements to produce debugging output in batch com\u00adputations. \nOur model re-executes the render code of the current page being viewed, whenever this render code or \nthe program s model changes. Recreating the entire box tree on a redraw can become slow if there are \nmany boxes on the screen. We are currently working on a simple optimization where we can reuse box tree \nelements that have not changed. An intriguing avenue for future work is the application of research on \nself-adjusting computation [2], which would allow redundant parts of the render computation to be elided \nautomatically. 6. Related Work As mentioned previously, visual programming languages have long supported \nlive programming. Burnett et al. [5] survey these lan\u00ad guages and detail how they can support live programming \nef.\u00adciently. In contrast, we describe how live programming can be sup\u00adported in the context of a fully \nexpressive textual, imperative lan\u00adguage with standard control .ow constructs. Superglue [17] is a textual \nlanguage that adopts a model inspired by data.ow visual languages; live programming is indeed achieved, \nbut many programs are hard to express with data.ow alone. Flogo II [11] is another textual live language \nthat supports live text, where the state of an executing program is presented as graph\u00adical annotations \nin the code. Rather than annotating code with ex\u00adecution details, our work focuses on making the connection \nnavi\u00adgable between code and the program s execution (as the rendered UI). Live programming depends on \na model that persists be\u00adtween program edits, which originates from Smalltalk s support for image-based \npersistence [9]. Although Smalltalk supports .x\u00ad and-continue, it does not provide live programming as \ncode edits and execution are independent. Self [26] with its Morphic [16] UI library gets around this \nlimitation by supporting the direct manip\u00adulation [24] of object run-time structures, although such edits \nonly persist and do not affect the object s code. In contrast, our work is able to support liveness through \na deep connection between code and program execution as well as direct manipulation whose effects are \nenshrined in code.  Going beyond live programming, Subtext [7] explores how code and program execution \ncan be represented using the same encod\u00ading; code in Subtext is not so much executed as it is copied. \nOur goal is less ambitious: we view live programming as a promising next step in bridging the gap between \ncode and program execution. Mobl [13] is a programming language for mobile devices. It provides page \nstack navigation and view-model separation (using data binding), but no live programming. HyperCard [4] \nprovides an overall experience that is quite similar to ours (page stack naviga\u00adtion, persistent state, \nevent handling, and quick switching between editing the code and interacting with the program). However, \npro\u00adgramming is not live, as code does not automatically reexecute, nor is there any support for writing \nspecialized code to express the re\u00adlationship between view and state. Live programming is also related \nto the hot swapping of code, introduced by Fabry [8], an important capability of the Erlang lan\u00ad guage \n[3], both of which allow the code of an executing program to be updated without losing its state and \ncontext. However, live pro\u00adgramming is concerned with program development while code hot swapping is \nconcerned with updating programs already deployed. The former focuses more on navigable connections between \ncode and execution, while the latter focuses more on uptime and robust\u00adness. Hicks et al. [12] propose \nlive software updating via state snap\u00ad shots, state transformations, and re-starting of the changed pro\u00adgram. \nThe reconstruction of the call-stack and application of data transformation is the responsibility of \nthe programmer, rather than an automated system. This provides maximum .exibility, while making it unsuitable \nfor live programming. 7. Conclusion Live programming is an idea whose time has come: emerging in\u00adteractive \nprogramming systems [10, 22, 27] capture the imagina\u00ad tion of today s programmers and promise to narrow \nthe temporal and perceptive gap between program development and code exe\u00adcution. This paper has shown \nhow live programming can be con\u00adceptualized and realized in an expressive procedural language, by tightly \nintegrating UI construction techniques (model-view separa\u00adtion and page-stack navigation) with programming \nlanguage tech\u00adniques (syntactically nested boxes and a type and effect system). By providing a formal \nmodel, we have established a foundation for critical discussions at a technical level. Future work on \nlive programming may explore improvements in expressiveness, such as support for state encapsulation \nin the view, or improvements in performance, such as optimizations that help to scale to larger and more \ncomplex user interfaces. References [1] TouchDevelop website and web application (Microsoft Research). \nhttp://www.touchdevelop.com. [2] U. A. Acar. Self-adjusting computation: (an overview). In Proc. of Partial \nEvaluation and Program Manipulation (PEPM), pages 1 6, 2009. [3] J. L. Armstrong and S. R. Virding. Erlang \n-an experimental telephony programming language. In Proc. of International Switching Sympo\u00adsium, pages \n2 7, 1990. [4] B. Atkinson. Hypercard. Apple Computer, 1987. [5] M. M. Burnett, J. W. Atwood Jr, and \nZ. T. Welch. Implementing level 4 liveness in declarative visual programming languages. In Proc. of the \nIEEE Symposium on Visual Languages, pages 126 134, 1998. [6] M. M. Burnett, M. J. Baker, C. Bohus, P. \nCarlson, P. J. V. Zee, and S. Yang. The scaling-up problem for visual programming languages. Technical \nreport, Oregon State University, 1994. [7] J. Edwards. Subtext: uncovering the simplicity of programming. \nIn Proc. of OOPSLA Onward!, pages 505 518, 2005. [8] R. S. Fabry. How to design a system in which modules \ncan be changed on the .y. In Proc. of ICSE, pages 470 476, 1976. [9] A. Goldberg and D. Robson. Smalltalk-80: \nthe language and its im\u00adplementation. Addison-Wesley Longman Publishing Co., Inc., 1983. [10] C. Granger. \nLight Table -a reactive work surface for program\u00adming. http://www.kickstarter.com/projects/ibdknox/\u00adlight-table, \n2012. [11] C. M. Hancock. Real-time programming and the big ideas of compu\u00adtational literacy. PhD thesis, \nMassachusetts Institute of Technology, 2003. AAI0805688. [12] C. M. Hayden, E. K. Smith, M. Denchev, \nM. Hicks, and J. S. Foster. Kitsune: ef.cient, general-purpose dynamic software updating for C. In Proc. \nof OOPSLA, Oct. 2012. [13] Z. Hemel and E. Visser. Declaratively programming the mobile web with mobl. \nIn Object oriented programming systems languages and applications (OOPSLA), pages 695 712. ACM, 2011. \n[14] H. Lieberman and C. Fry. Bridging the gulf between code and behav\u00adior in programming. In Proc. of \nCHI, pages 480 486, 1995. [15] J. M. Lucassen and D. K. Gifford. Polymorphic effect systems. In In Principles \nof Programming Languages (POPL, pages 47 57. ACM Press, 1988. [16] J. H. Maloney and R. B. Smith. Directness \nand liveness in the Morphic user interface construction environment. In Proc. of UIST, pages 21 28, nov \n1995. [17] S. McDirmid. Living it up with a live programming language. In Proc. of OOPSLA Onward!, pages \n623 638, October 2007. [18] C. Muratori. Immediate-mode graphical user interfaces. www.molly\u00adrocket.com/861, \n2005. [19] D. A. Norman and S. W. Draper. User Centered System Design; New Perspectives on Human-Computer \nInteraction. L. Erlbaum Associates Inc., 1986. [20] M. Puckette. Pure Data: another integrated computer \nmusic environ\u00adment. In Proc. of International Computer Music Conference, pages 37 41, 1996. [21] T. Reenskaug. \nThing-model-view-editor an example from a plan\u00adningsystem, http://heim.ifi.uio.no/~trygver/1979. Tech\u00adnical \nreport, Xerox PARC, 1979. [22] J. Resig. Khan Academy -computer science. http://www.khan\u00adacademy.org/cs. \n[23] E. Sandewall. Programming in an interactive environment: the LI S P experience. ACM Computing Surveys, \n10(1):35 71, Mar. 1978. [24] B. Shneiderman. Direct manipulation. a step beyond programming languages. \nIEEE Transactions on Computers, 16(8):57 69, August 1983. [25] N. Tillmann, M. Moskal, J. de Halleux, \nand M. Fahndrich. TouchDe\u00advelop -programming cloud-connected mobile devices via touch\u00adscreen. In Proc. \nof SPLASH Onward!, 2011. [26] D. Ungar and R. B. Smith. Self: the power of simplicity. In Proc. of OOPSLA, \npages 227 242, December 1987. [27] B. Victor. Inventing on principle. Invited talk at the Canadian Univer\u00adsity \nSoftware Engineering Conference (CUSEC), Jan. 2012.   \n\t\t\t", "proc_id": "2491956", "abstract": "<p>Live programming allows programmers to edit the code of a running program and immediately see the effect of the code changes. This tightening of the traditional edit-compile-run cycle reduces the cognitive gap between program code and execution, improving the learning experience of beginning programmers while boosting the productivity of seasoned ones. Unfortunately, live programming is difficult to realize in practice as imperative languages lack well-defined abstraction boundaries that make live programming responsive or its feedback comprehensible.</p> <p>This paper enables live programming for user interface programming by cleanly separating the rendering and non-rendering aspects of a UI program, allowing the display to be refreshed on a code change without restarting the program. A type and effect system formalizes this separation and provides an evaluation model that incorporates the code update step. By putting live programming on a more formal footing, we hope to enable critical and technical discussion of live programming systems.</p>", "authors": [{"name": "Sebastian Burckhardt", "author_profile_id": "81350574118", "affiliation": "Microsoft Research, Redmond, WA, USA", "person_id": "P4148948", "email_address": "sburckha@microsoft.com", "orcid_id": ""}, {"name": "Manuel Fahndrich", "author_profile_id": "81548005185", "affiliation": "Microsoft Research, Redmond, WA, USA", "person_id": "P4148949", "email_address": "maf@microsoft.com", "orcid_id": ""}, {"name": "Peli de Halleux", "author_profile_id": "81385593578", "affiliation": "Microsoft Research, Redmond, WA, USA", "person_id": "P4148950", "email_address": "jhalleux@microsoft.com", "orcid_id": ""}, {"name": "Sean McDirmid", "author_profile_id": "81100205762", "affiliation": "Microsoft Research, Beijing, China", "person_id": "P4148951", "email_address": "smcdirm@microsoft.com", "orcid_id": ""}, {"name": "Michal Moskal", "author_profile_id": "81367593542", "affiliation": "Microsoft Research, Redmond, WA, USA", "person_id": "P4148952", "email_address": "micmo@microsoft.com", "orcid_id": ""}, {"name": "Nikolai Tillmann", "author_profile_id": "81548005184", "affiliation": "Microsoft Research, Redmond, WA, USA", "person_id": "P4148953", "email_address": "nikolait@microsoft.com", "orcid_id": ""}, {"name": "Jun Kato", "author_profile_id": "81416606592", "affiliation": "The University of Tokyo, Tokyo, Japan", "person_id": "P4148954", "email_address": "i@junkato.jp", "orcid_id": ""}], "doi_number": "10.1145/2491956.2462170", "year": "2013", "article_id": "2462170", "conference": "PLDI", "title": "It's alive! continuous feedback in UI programming", "url": "http://dl.acm.org/citation.cfm?id=2462170"}