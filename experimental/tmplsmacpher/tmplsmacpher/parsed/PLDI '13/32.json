{"article_publication_date": "06-16-2013", "fulltext": "\n Reconciling Exhaustive Pattern Matching with Objects Chinawat Isradisaikul Andrew C. Myers Department \nof Computer Science Cornell University Ithaca, New York, United States chinawat@cs.cornell.edu andru@cs.cornell.edu \nAbstract Pattern matching, an important feature of functional languages, is in con.ict with data abstraction \nand extensibility, which are central to object-oriented languages. Modal abstraction offers an integra\u00adtion \nof deep pattern matching and convenient iteration abstractions into an object-oriented setting; however, \nbecause of data abstrac\u00adtion, it is challenging for a compiler to statically verify properties such as \nexhaustiveness. In this work, we extend modal abstraction in the JMatch language to support static, modular \nreasoning about exhaustiveness and redundancy. New matching speci.cations al\u00adlow these properties to \nbe checked using an SMT solver. We also introduce expressive pattern-matching constructs. Our evaluation \nshows that these new features enable more concise code and that the performance of checking exhaustiveness \nand redundancy is ac\u00adceptable. Categories and Subject Descriptors D.3.3 [Programming Lan\u00adguages]: Language \nConstructs and Features Patterns, Polymor\u00adphism; D.1.5 [Programming Techniques]: Object-oriented Pro\u00adgramming; \nF.3.1 [Logics and Meanings of Programs]: Specify\u00ading and Verifying and Reasoning about Programs Pre-and \npost\u00adconditions, Mechanical veri.cation General Terms Design, Veri.cation, Languages Keywords JMatch; \npattern matching; named constructor; equality constructor; matching speci.cation; exhaustiveness; redundancy; \nmodal abstraction; Java; data abstraction; subtyping 1. Introduction Despite being an important feature \nof modern functional program\u00adming languages, pattern matching has not been adopted by most object-oriented \nlanguages. Data abstraction and extensibility, both primary goals of object-oriented languages, con.ict \nwith pattern matching. This work explores a language design for integrating pat\u00adtern matching with object-oriented \nprogramming. The following is a simple implementation of natural numbers in OCaml. The algebraic data \ntype nat, with two constructors Zero and Succ, represents a natural number; the recursive plus function \nadds two naturals by matching them with one of three patterns. type nat = Zero | Succ of nat Permission \nto make digital or hard copies of all or part of this work for personal or classroom use is granted without \nfee provided that copies are not made or distributed for pro.t or commercial advantage and that copies \nbear this notice and the full citation on the .rst page. To copy otherwise, to republish, to post on \nservers or to redistribute to lists, requires prior speci.c permission and/or a fee. PLDI 13, June 16 \n19, 2013, Seattle, Washington, USA. Copyright c 2013 ACM 978-1-4503-2014-6/13/06. . . $15.00 let rec \nplus m n = match (m, n) with (Zero, x) | (x, Zero) -> x | (Succ m , _) -> plus m (Succ n) This example \nillustrates two bene.ts of pattern matching in ML and other functional programming languages such as \nHaskell. The .rst bene.t is that patterns serve a dual role that enables al\u00adgebraic reasoning and results \nin concise, intuitive code. A construc\u00adtor such as Succ is also a pattern that matches the values produced \nby that constructor. Patterns can be nested to match complex values in a natural way, so a pattern like \nSucc(Succ(n)) matches exactly the values constructed by expressions using the same syntax. The second \nbene.t is that pattern matching helps catch common programming errors. Patterns in a match expression \ncan be checked to ensure that they are exhaustive and not redundant: that all possi\u00adble values are matched \nby some pattern, and that every pattern can match some value. Without such checks, if the programmer \nfor\u00adgot the .rst of the three cases above, the program could crash with an exception. With such checks, \nthe compiler would warn that no cases match values of the form (Zero, Succ _). Relying on access to the \nconcrete representation of data, how\u00adever, makes the ML-style pattern matching inimical to data abstrac\u00adtion \n[30]. A value produced by one module can only be matched by patterns in another module if the second \nmodule knows the un\u00adderlying representation of the value. Agreement on the concrete representation tightly \ncouples the two modules in a way usually considered undesirable for large software systems. For example, \nwe might initially implement natural numbers as above, then later want to change the representation to \nbe an int. This change is not possible in ML without breaking client code. To make pattern matching compatible \nwith data abstraction, prior work has developed pattern-matching constructs that can be implemented by \narbitrary code. Examples of this approach include views [30], extractors [5], and active patterns [29]. \nThese mech\u00ad anisms permit matching on deep patterns over abstract data, but sacri.ce other bene.ts of \nalgebraic pattern matching. There is no check that patterns are consistent with their corresponding con\u00adstructors, \nso algebraic reasoning is weakened. Further, data abstrac\u00adtion interferes with checking exhaustiveness \nand redundancy. The JMatch language [19] introduced another way to harmo\u00ad niously integrate pattern matching \ninto object-oriented languages, through modal abstractions that support multiple directions of computation. \nModal abstractions allow a constructor and its pat\u00adtern to be implemented by the same invertible computation, \nen\u00adsuring that they are inverses. Determining whether patterns are exhaustive or redundant, however, \nremained impossible under the data abstraction provided by JMatch. Furthermore, the added ex\u00adpressive \npower of patterns implemented by complex computations  1 class Nat { 2 private int value; 3 private \nNat(int n) returns(n) 4 ( value = n ) 5 public static Nat zero() returns() 6 ( result = Nat(0) ) 7 public \nstatic Nat succ(Nat n) returns(n) 8 ( result = Nat(n.value + 1) ) 9 } 10 ... 11 static Nat plus(Nat m, \nNat n) { 12 switch (m, n) { 13 case (zero(), Nat x): 14 case (x, zero()): 15 return x; 16 case (succ(Nat \nk), _): 17 return plus(k, Nat.succ(n)); 18 } 19 } Figure 1. Natural numbers with data abstraction in \nJMatch. means that programmers can accidentally omit patterns more easily than with algebraic data types. \nThe challenge for analysis of exhaustiveness and redundancy is to reason statically without violating \ndata abstraction. The main contribution of this paper is, therefore, a way to extend modal abstractions \nwith concise speci.cations that enable static reasoning about exhaustiveness and redundancy of pattern \nmatching and, more generally, about the totality of computations. Object-oriented programming involves \nmore than just data ab\u00adstraction; subtyping and inheritance are key ingredients support\u00ading extensibility. \nFor extensibility, different implementations of (subtypes of) the same interface should support the same \npatterns without clients knowing which implementation has been used. We therefore introduce named constructors \nthat can be used as patterns in this way. We also introduce two .rst-class or-patterns that gen\u00aderalize \nboth data-type constructors and or-patterns in ML. We proceed as follows. Section 2 reviews modal abstraction \nin JMatch. Section 3 introduces mechanisms that improve the expres\u00ad sive power of pattern matching and \nits integration with objects. Sec\u00adtion 4 describes new static annotations that support reasoning about \nexhaustiveness and redundancy. The veri.cation procedure is ex\u00adplained in Section 5. Section 6 describes \nour implementation of an extended version of JMatch. Using various code examples, we eval\u00aduate its expressiveness, \nanalytic power, and ef.ciency in Section 7. Section 8 discusses related work, and Section 9 concludes. \n2. Background Some background will be helpful on JMatch [17, 19], an extension to Java 1.4 that supports \npattern matching and iteration through modal abstraction. 2.1 Modal abstraction Section 1 observed that \nin OCaml, natural numbers cannot sup\u00ad port pattern matching while being represented internally with an \nint. Figure 1 shows how this can be done in JMatch. The key idea is that JMatch methods may declare multiple \nmodes that corre\u00adspond to different directions of evaluation, analogously to pred\u00adicate mode declarations \nin the logic programming language Mer\u00adcury [26]. In addition to the ordinary forward mode, which acts \nlike a Java method, a JMatch method may also provide backward modes which, given a desired result, compute \ncorresponding argu\u00adment values. Backward modes support pattern matching. For exam\u00adple, the method succ \nmay be used in the forward mode to compute the successor of a number. As indicated by the clause returns(n) \non line 7, it also has a backward mode that computes the number n for which the value given in result \nis the successor. This implementation of Nat is more complex than in OCaml because the abstract view \nthat supports pattern matching must be related to its concrete representation as an int. The methods \nof Nat demonstrates that JMatch programs can de.ne patterns that both preserve data abstraction, because \nthe .eld value is private, and are also usable outside the module that de.nes them. Lines 11 19 show \nhow the backward modes of these methods can be used to implement the method plus similarly to the earlier \nOCaml code. In general, a JMatch method implements a relation over its arguments and its result. Each \nof its modes is a different way of exploring the relation. For example, the succ operation is a binary \nrelation on Nat: a subset of Nat Nat. In each mode, some of the arguments or the return value are knowns \nsupplied by the caller, and the others are unknowns to be solved for. Individual method modes may be \nimplemented by imperative, Java-like code, but one single declarative-style implementation of multiple \nmodes is often more concise. As in each of Nat s methods in Figure 1, a declarative method implementation \nis a boolean formula placed inside parentheses, directly expressing the implemented relation. For example, \nthe equation result = Nat(n.value + 1) at line 8 exactly captures the succ relation.1 For each mode of \na method, the compiler generates an impera\u00adtive algorithm that, given values for knowns, .nds values \nof all unknowns that satisfy the formula. Thus, the backward mode of\u00adten comes nearly for free, unlike \nwith related approaches such as extractors [5]. Not only user-de.ned abstractions but also built-in types \nsuch as primitive types support modal abstractions. For example, integer operations such as + and -can \nsolve for either of their arguments, given a result to match against. 2.2 Iterative modes Modes need \nnot be functions; viewed as relations, they may be one-to-many or many-to-many. A mode is iterative when \nthere may be more than one solution to the unknowns for given knowns; the keyword iterates is used in \nplace of returns to indicate such a mode. For example, the contains method of the Collection class has \nthe signature boolean contains(Object x) iterates(x) meaning that its backward mode can be used to iterate \nover all con\u00adtained objects. Using iterative modes, the Java collections frame\u00adwork could be made 35% \nmore concise by implementing its opera\u00adtions, including iterators, as modes of relatively few methods \n[17].  2.3 Semantics and solving The semantics of JMatch is de.ned as a syntax-directed, type\u00adpreserving \ntranslation to Javayield [18], which extends Java with coroutine methods in which control is yielded \nto the caller via the yield statement, much as in languages like C#, Ruby, and, originally, CLU [16]. \nJMatch supports imperative Java code, the translation of which is relatively straightforward. The interesting \nparts of the translation involve the solving of boolean formulas and pattern expressions. JMatch considers \na formula or pattern solvable when the compiler can generate an algorithm that either .nds satisfying \nassignments to unknowns or determines that there are none. In the latter case, the formula or pattern \nis not satis.able but is still solvable. A formula or pattern may also be satis.able but not solvable \nif the 1 Note that the operator = is an equality test, which unambiguously sub\u00adsumes its usual Java role \nas imperative assignment.  interface Nat { constructor zero() returns(); constructor succ(Nat n) returns(n); \n... } Figure 2. Natural number interface with named constructors. 1 class ZNat implements Nat { 2 int \nval; 3 private ZNat(int n) returns(n) 4 ( val = n &#38;&#38; n >= 0 ) 5 constructor zero() returns() \n6 ( val = 0 ) 7 constructor succ(Nat n) returns(n) 8 ( val >= 1 &#38;&#38; ZNat(val -1) = n ) 9 ... 10 \n} 11 12 class PZero implements Nat { 13 constructor zero() returns() ( true ) 14 constructor succ(Nat \nn) returns(n) ( false ) 15 ... 16 } 17 class PSucc implements Nat { 18 Nat pred; 19 constructor zero() \nreturns() ( false ) 20 constructor succ(Nat n) returns(n) ( pred = n ) 21 ... 22 } Figure 3. Three implementations \nof Nat. compiler does not know how to generate an appropriate algorithm for determining satisfying assignments. \nAs an extension to Java, JMatch allows side effects, although its new features encourage a declarative \nprogramming style. With side effects, programmers need to reason about the order in which computations \noccur. The JMatch solver therefore solves formulas in a well-de.ned order that is left-to-right as much \nas possible. 3. Pattern-matching extensions We extend JMatch, adding new pattern-matching constructs \nto bet\u00adter support object-oriented programming and data abstraction and to increase expressive power \nin other ways. 3.1 Named constructors In JMatch, pattern matching using procedures is successful only \nif the value being matched is either their result or one of their argu\u00adments. Therefore, a JMatch procedure \ncan successfully match on its own receiver object (this) only if the procedure is a construc\u00adtor or happens \nto return its receiver object as the result. Since a constructor belongs to a particular class, code \nusing a constructor pattern is tightly coupled to that particular implementation. This tight coupling \ninterferes with extensibility and code reuse. To support implementation-oblivious pattern matching, we \nex\u00adtend JMatch with named constructors that can pattern-match an object whose run-time class is unknown. \nNamed constructors have an explicit name different from that of their class, and they can be declared \nin interfaces. For example, Figure 2 shows a Nat interface exposing two named constructors, zero and \nsucc. Figure 3 shows two partial implementations of Nat. The .rst (ZNat) corresponds to the im\u00adplementation \nof Figure 1. The second is analogous to the OCaml 1 class ZNat { ... 2 constructor equals(Nat n) 3 ( \nzero() &#38;&#38; n.zero() | 4 succ(Nat y) &#38;&#38; n.succ(y) ) 5 } 6 7 class PZero { ... 8 constructor \nequals(Nat n) 9 ( n.zero() ) 10 } 11 class PSucc { ... 12 constructor equals(Nat n) 13 ( n.succ(pred) \n) 14 } Figure 4. Equality constructors. version and consists of two classes: PZero, representing zero, \nand PSucc, representing the successor of its .eld pred at line 18. Unlike ordinary constructors, a named \nconstructor like zero can be applied to an object x of type Nat or of any subtype of Nat. It acts as \na boolean predicate in this style of invocation. For example, ZNat(0).zero() evaluates to true because \nits implementation tests the equation val = 0. A named constructor for type T may be invoked without \nan explicit receiver object when it is used to pattern-match a value of type T . In this case, the receiver \nobject is the value being matched. Finally, named constructors can be invoked to construct new objects \nof their class, as in the expression ZNat.zero(). In the forward mode, the .elds of this are in scope \nas unknowns to be solved for either directly in the formula or via another constructor. For example, \nval in the equation val = 0 at line 6 is solved directly by assigning zero to it. 3.2 Equality constructors \nAs written, the implementations of Nat in Figure 3 are incomplete. The problem is that the forward mode \nof succ in ZNat promises to construct a ZNat from an arbitrary Nat predecessor n. If n is not a ZNat, \nthe equality test at line 8 between ZNat(val -1) and n will fail. We .x this by adding an operation to \nNat that allows solving for equality between objects of different classes: constructor equals(Nat n); \nBecause equals is used to pattern-match on the receiver object, it becomes a special named constructor \nan equality constructor rather than an ordinary boolean method as in Java. If de.ned, equals is used \nfor solving equality in addition to JMatch s default strategy of direct assignment. The code of equals \nfor the classes implementing Nat is given in Figure 4. Using equals, the equality ZNat(val -1) = n is \nsolved for non-ZNat objects n by invoking ZNat.equals, de.ned at lines 2 4. This method tests whether \nn is zero or the successor of some number. If the former, it returns ZNat.zero; if the latter, it in\u00advokes \nZNat.succ recursively to retrieve the predecessor of n, which is bound to y by the constructor invocation \nn.succ(y). Operationally, ZNat s equals and succ interoperate to .nd suc\u00adcessive predecessors until either \nzero or a ZNat representation (as in PSucc.succ(ZNat(3)), which is legal!) is encountered. Once equals \nconverts n to a ZNat object, succ matches the internal representation of this ZNat object with val -1, \nsolving for val, which internally represents the desired successor.  3.3 Other extensions A complete \noverview of the existing patterns in JMatch can be found in Section 2.2 of the JMatch technical report \n[18]. We ex\u00ad tend the language with additional operators and a new pattern that increase expressive power: \n 1 public Expr CPS(Expr e) returns(e) ( 2 Var k = freshVar(\"k\", e) &#38;&#38; 3 (e, result) = 4 (Var(_), \n5 Lambda(k, Apply(k, e))) 6 | (Lambda(Var vl, Expr body), 7 Lambda(k, 8 Apply(k, Lambda(vl, 9 Lambda(k, \nApply(CPS(body), k)))))) 10 | (Apply(Expr fn, Expr arg), 11 Lambda(k, Apply(CPS(fn), 12 Lambda(f, Apply(CPS(arg), \n13 Lambda(Var(\"v\") as Var va, 14 Apply(Apply(f, va), k)))))) 15 where Var f = freshVar(\"f\", arg)) 16 \n) Figure 5. Invertible CPS conversion. JMatch already has a pattern conjunction operator called as, \nwhich generalizes ML s pattern operator of the same name by requiring two arbitrary patterns to match \nthe same value. We add a pattern disjunction operator, #, that combines two patterns into a single pattern \nthat matches either or both of the two, and solves for the same unknowns. For example, the formula int \nx = y-1 # y+1 (which should be read as int x = (y-1 # y+1)) generates the two solutions x = y-1 and x \n= y+1 when solving for x, and y = x+1 and y = x-1 when solving for y. Unlike Icon s alternation expression \n[9], a match is attempted against all alternatives even if one of them fails. We also add a disjoint \ndisjunction operator, |, that behaves like # except that the patterns must be disjoint. A pattern constructed \nwith this operator produces at most one solution when a value is matched against it, unlike #. The number \nof solutions is impor\u00adtant because the pattern-matching statements require that there be only a single \nsolution. The compiler veri.es that patterns com\u00adbined via | are disjoint. The formula x = 1 | 2 would \ntherefore be legal but x = y-1 | y+1 would not if used to solve for y. A tuple pattern, written (p1, \n: : : , pn), may be used to match multiple values at once. Tuples are not .rst-class values; uses of \ntuple patterns are equivalent to, but often more concise than, a set of equations expressed over the \ntuple components. These new constructs add expressiveness. For example, the JMatch 1.1.6 release [18] \nincludes an example of invertible con\u00ad version to continuation-passing style (CPS). The same two com\u00adputations, \nCPS conversion and its inverse, are both expressed even more concisely in Figure 5 using the new pattern \noperators. In this code, the use of tuples enables the translation rules to be expressed essentially \nas inference rules. The pattern .p where f / on line 15 re.nes pattern p to succeed only when formula \nf is also satis.\u00adable. The use of | ensures that CPS is one-to-one, though not total in its backward \nmode. Without |, the JMatch compiler would be unable to conclude that the three cases are disjoint and \nwould raise the error that CPS is not one-to-one. 4. Static annotations for exhaustiveness reasoning \nSeveral pattern-matching forms in JMatch can bene.t from veri\u00ad.cation of exhaustiveness. As we saw in \nFigure 1, switch state\u00ad ! ments are one such form. Whether switch (e) {case pi : si } is exhaustive corresponds \nto (roughly) whether n _ e D pi (1) iD1 Nat n; ... switch (n) { case succ(Nat p): ... case succ(succ(Nat \npp)): ... case zero(): ... } Figure 6. Redundant switch statement. is a tautology. A second such form \nis the JMatch statement cond ! {(fi ) {si }}, which executes the .rst statement si such that its corresponding \nformula fi is true. For exhaustiveness, at least one such formula must be true. A third pattern-matching \nform is let f , which is equivalent to cond {(f ) {}} except that variable bindings made in f are in \nscope for the remainder of the state\u00adment s block. The declaration int x = 2 is in fact syntactic sugar \nfor let int x = 2. Therefore, the formula f in a let statement should always be satis.able. In principle, \nexhaustiveness checking seems simple. Reasoning about exhaustiveness while preserving data abstraction, \nhowever, is challenging because the client code performing pattern match\u00ading is oblivious to the concrete \nrepresentation (e.g., private .elds) of objects. For example, given the code in Figure 6, the compiler \ndoes not know the implementation of succ and zero with which n will be matched. Even if it did know, \nusing this knowledge would violate modularity, coupling correctness of this code to implemen\u00adtation choices \ninternal to Nat. Moreover, given a value of type Nat, the compiler may not assume that succ and zero \nare the only ways to construct the value; there could be another constructor de.ned in Nat that could \nproduce the same value. As a result, the compiler does not have enough information about the patterns \nto show that disjunction (1) is a tautology. To enable the compiler to reason modularly about exhaustive\u00adness, \nwe must expose enough information to the client about the relation implemented by a method without exposing \nimplementa\u00adtion details. Supplied with this information for the code in Figure 6, the compiler should \nbe able to determine that all values of type Nat will be matched by some case. If that were not true \n(e.g., if the .rst case were omitted), the compiler should issue a warning. Also, in the code as written, \nthe second case is redundant because anything matching succ(succ(Nat pp)) must have matched succ(Nat \np). Redundant code often indicates errors in programmer s reason\u00ading; the compiler ought to report this \ntoo. At the same time, the exposed information should let the compiler know that zero and succ are indeed \ndisjoint and conclude that the third case and the .rst two are not redundant. Without such information, \nthe compiler could generate a false redundancy warning. To support static veri.cation of exhaustiveness \nand other prop\u00aderties, three new kinds of concise and intuitive speci.cations pro\u00advide the missing information: \nclass invariants, matches clauses, and ensures clauses. As an orthogonal bene.t, all of these speci\u00ad.cations \ncan exploit the new pattern operator | to prove patterns disjoint. We now explore these new features \nin more detail. 4.1 Class and interface invariants One way to provide the information needed to determine \nexhaus\u00adtiveness is as a class or interface invariant. For example, we can express that all instances \nof Nat match either zero() or succ() by adding the following invariant to the Nat interface, using | \nto assert that the two patterns are disjoint:  1 class ZNat implements Nat { result result 2 int val; \n 3 private invariant(val >= 0); 4 4 private ZNat(int n) matches(n >= 0) returns(n) 5 ( val = n &#38;&#38; \nn >= 0 ) 3 n >= 0 ... 2 7 } 1 Figure 7. Private invariant and matches clause. interface Nat { invariant(this \n= zero() | succ(_)); ... } This example invariant shows how to obtain the exhaustiveness analysis provided \nby algebraic data types, while preserving data abstraction and allowing extensibility. New implementations \nof the Nat interface do not alter this invariant. Class and interface invariants can be thought of as \na kind of boolean-valued method whose value is always asserted to be true and whose implementation is \nvisible to callers. Invariants may be given visibility modi.ers (public, protected, or private). To maintain \nmodularity, an invariant may only mention methods and .elds that are at least as visible as the invariant \nitself. Invariants not publicly visible may be useful for verifying the implementation of a class, such \nas the totality of the implementa\u00adtion of its methods. For instance, in the ZNat code of Figure 3, the \n.eld val cannot be negative. We can add a private invariant as\u00adserting this constraint, as in Figure \n7. This invariant supports suc\u00adcessful veri.cation of the backward mode of the implementation of the \nconstructor ZNat(), which should be total among all ZNat values. The invariant plus the .rst conjunct \nimply the second con\u00adjunct, n >= 0. The private invariant also helps verify both modes of succ().  4.2 \nMatches clauses One impediment to checking exhaustiveness is that a method mode may implement partial \nfunctions: on some inputs, its body might be unsatis.able, in which case the method will fail rather \nthan return\u00ading values for its unknowns. We extend the JMatch language with a way to specify when a method \nwill successfully produce a re\u00adsult. This matching precondition is analogous to a precondition, but rather \nthan specifying when a method call is legal, it speci.es when pattern matching is guaranteed to succeed. \nThe speci.cation is conservative in that matching could succeed even when the con\u00addition does not hold. \nFor example, consider the constructor ZNat() in Figure 3. Any ZNat object must have a representation \nas a nonnegative integer. The corresponding matching precondition for the forward mode is n >= 0, meaning \nthat for any nonnegative n, there exists a ZNat object matching that n. This matching precondition implies \nthe constructor body, allowing successful veri.cation of the forward mode. The backward mode of ZNat(), \non the other hand, is total, corresponding to the matching precondition true. Asking the programmer to \nspecify matching preconditions for each mode would be verbose and repetitive, since different modes may \nshare knowns (i.e., inputs). Our insight is that the programmer can write a single condition that captures \nwhen matching will succeed for the entire relation implemented by a method. We call this condition the \nmatches clause for the method. Methods having no matches clause defaults to matches(false), meaning that \nmatching is not guaranteed to succeed for any input. The JMatch 2.0 compiler must extract the matching \nprecondition for each mode from the consolidated matches clause. The extraction is described n n -1 3 \n4 -1 2 3 returns(result) (a) actual relation (b) matching preconditions Figure 8. The ZNat relation. \nformally in Section 4.3; the rest of this section illustrates how extraction works for ZNat(). The matches \nclause for ZNat() is shown in Figure 7. Fig\u00adure 8(a) shows the actual relation implemented by ZNat; Fig\u00adure \n8(b) shows the matches clause, describing the relation con\u00adsisting of integral points in the shaded region. \nThis relation can be viewed as an approximation to the true ZNat relation. Informally, the extraction \nobtains the matching precondition by projecting this relation onto the axis corresponding to an appropriate \nmode, ob\u00adtaining matching preconditions shown as thick arrows. For the for\u00adward mode (returns(result)), \nthe relation is protected onto the n axis, obtaining n >= 0. For the backward mode (returns(n)), it is \nprojected onto the result axis, obtaining true.  4.3 Extracting matching precondition from matches clause \nIn general, the body of a method implements some relation B and the matches clause speci.es another relation \nM . Suppose that the method is a relation over a set of variables fExg. For each mode M of the method, \nthis set is partitioned into disjoint sets of knowns (inputs) fkEgand unknowns (outputs) fEug. We can \nthen view the relations M and B as predicates over knowns and unknowns, M.k;Eu/Eand B. Eu/, respectively. \nGiven E k; Ek, the precise condition in which the body guarantees success is therefore 9Eu: B. Eu/. We \nk; E call this formula the precise matching precondition. For brevity, we de.ne a function M that constructs \nthe pre\u00adcise matching precondition for mode M by projecting an arbitary predicate B onto the knowns: \n. MB/.k/E 9Ek; E 4 u: B. Eu/ Given M and B, MB is a predicate on kEthat holds when kEpro\u00advides some way \nto satisfy B in mode M and hence to successfully pattern-match. To preserve abstraction, reasoning about \nexhaustiveness must be done using the matches clause M , not B. Intuitively, if M ) B, the body will \nbe satis.able whenever the matches clause holds; however, to require this implication would be unnecessarily \nrestric\u00adtive. In the case of ZNat relation, for example, n >= 0 does not imply the actual relation, and \nthe only matches clause that does so while preserving abstraction is false. A more useful correctness \nV condition is M ) M0 M0B, where M0 is ranges over de\u00adclared modes. In other words, satis.ability of \nthe matches clause only needs to imply satis.ability of the body in all the modes actu\u00adally available. \nThis can be visualized as expanding B (in the case of ZNat, the dots in Figure 8(a)) along all the dimensions \ncorrespond\u00ading to the supported modes (obtaining, in this case, the shaded area in Figure 8(b)). V It \nis easy to show that the formula M ) M0 M0B is equiva\u00adlent to MM ) MB for each declared mode M. This \nsuggests  that given the mode M D .fkEg; f Eug/ and the inputs kE, we should verify exhaustiveness by \nusing . MM /. E k/ as the matching pre\u00adcondition. Unfortunately, the existential quanti.ers in this formula \nmake it ill-suited to automated reasoning. Instead, we construct a weakening of MM that does not mention \nexistential quanti.ers. Let us denote this weakened predicate on kEas ExtractMM . The construction of \nExtractMM proceeds as follows. We .rst convert the matches clause into negation normal form (NNF) so \nthat the formula uses only positive logical operators over atomic formulas. We then use a variant of \nthe usual JMatch algorithm for generating solutions to a formula. The .rst step is to reorder the atoms \nso that as many unknowns as possible can be solved from left to right. After this reordering, atoms that \ndo not mention unknowns are left unchanged, as are atoms in which all unknowns are solv\u00adable in the left-to-right \norder. Atoms mentioning any unsolvable unknowns are dropped; that is, they are replaced with true. Any \nremaining occurrences of unknowns can be thought of as existen\u00adtially quanti.ed, but because each remaining \nunknown is solvable, it represents a solution expressed entirely in terms of knowns. For instance, in \nthe ZNat example, the atomic formula n >= 0 is dropped in the backward mode because n is unsolvable, \nleav\u00ading only true. As another example, consider extracting a matching precondition for x > 0 &#38;&#38; \ny >= 0 &#38;&#38; x+1 = y, where x is un\u00adknown and y known. The formula is .rst reordered to allow solving \nfor x, yielding y >= 0 &#38;&#38; x+1 = y &#38;&#38; x > 0. The .rst atom is left unchanged because it \nonly mentions y. The second is also kept because it solves fore x, allowing the third atom to be retained \nas well. Because x is solved by the value y-1, the extracted pre\u00adcondition is y >= 0 &#38;&#38; (y-1)+1 \n= y &#38;&#38; (y-1) > 0, which is equivalent to y > 1. In general, x might be solved by a user-de.ned \nmethod. Section 5 explains how atoms containing such unknowns are handled. Dropping unsolvable atoms \nis a heuristic, but it seems effec\u00adtive because such atoms are typically satis.able for all possi\u00adble \nvalues of the knowns. In general, however, dropped atoms might not be satis.able, in which case ExtractMM \nmay not be conservative. For example, if the matches clause were instead y >= 0 &#38;&#38; x < y &#38;&#38; \nx > 0, dropping the atoms x < y and x > 0 would result in the extracted precondition y >= 0. The pre\u00adcise \nmatching precondition . MM /.y/ is rather y >= 2, since there is no satisfying assignment for x when \ny < 2. ExtractMM can be used not only for analyzing exhaustiveness, but also for verifying that the method \nbody implements its extracted precondition in mode M. That is, when the method body is imple\u00admented as \na formula, the compiler veri.es in each mode M that for all inputs kE, k/ ) . MB /. E .ExtractMM /. Ek/. \nThis ensures soundness for exhaustiveness analysis done using ExtractMM . Veri.cation is done using an \nSMT solver, as described in Section 6. For imperative method implementations, this veri.cation is left \nto the programmer, though existing program logics might be used to obtain a veri.able logical interpretation \nin many cases.  4.4 Opaquely re.ning matches In general, we may want to support modes in which precondition \nextraction fails because the matches clause does not or cannot cap\u00adture the relationship among the arguments. \nFor example, consider adding to ZNat() a predicate mode returns(), in which there are no unknowns. In \nthis mode, the matches clause n >= 0 does not correctly capture the matching precondition, yet the existing \nimple\u00admentation is correct. To support such modes, matches clauses may be re.ned using the special opaque \npredicate notall. During pre\u00ad ! condition extraction, an atom notall(xi ) is treated as unsolvable if \nany of the variables xi is unknown, and is therefore dropped; if all of the variables are known or already \nsolved, however, the pred\u00adicate is treated as false. Thus, to support a predicate mode for ZNat(), the \npredicate notall(result, n) is conjoined with n >= 0 to indicate that pattern matching is not guaranteed \nto succeed when both result and n are known. This notall predicate corresponds to the re.ne\u00adment that \nconverts the gray area in Figure 8(b) into just the black dots in Figure 8(a). The opaque notall is needed \nbecause this re\u00ad.nement cannot be characterized abstractly.  4.5 Ensures clauses Matches clauses are \na kind of multimodal precondition. To im\u00adprove the precision of veri.cation and exhaustiveness reasoning \nin JMatch, we add the ensures clause, a multimodal postcondition whose syntax resembles previous, unimodal \npostcondition speci\u00ad.cations (e.g., [25, 27]). The ensures clause for a method is an abstraction of the \nrelation implemented by the method, expressed in terms that client code can understand; that is, it only \nmentions names a legal caller could name, similar to the speci.cations pro\u00adposed by Leavens and M \u00a8uller \n[14]. Unlike the matches clause, the ensures clause must de.ne an overapproximation (a superset) of the \nimplemented relation. Thus, in any context where a method call is known to have succeeded, the ensures \nclause can be assumed to hold with respect to the values supplied as knowns and the values returned as \nunknowns. Because the clauses for both matches and ensures are often identical, the syntax matches ensures(f \n) may be used as a shorthand for matches(f ) ensures(f ). 5. Checking exhaustiveness and totality JMatch \n2.0 must show the exhaustiveness of various pattern\u00admatching statements (switch, cond, and let). Similar \nveri.cation is required for methods with a matches or ensures clause, since they promise to succeed in \neach mode when the extracted matching precondition is true, and since the postcondition must hold if \nthe methods succeed. In addition, both arms of | must be veri.ed as disjoint. In each case, the analysis \nconstructs quanti.er-free formu\u00adlas that can be satis.ed only if some cases are not handled by the appropriate \npatterns or formulas. Section 4 described veri.cation informally while pretending that formulas can be \nveri.ed directly, e.g., by an SMT solver. This is not true in general, because formulas may contain user-de.ned \npredicates that must be treated abstractly. To aid in constructing formulas to be veri.ed the SMT solver, \nwe introduce an intermediate representation language F that is similar to the language of quanti.er-free \nlogical formulas. Each formula is transformed to an F formula using function VF de.ned inductively on \nthe syntax of formulas. VF takes a formula f to be transformed, along with the set U of unknowns to be \nsolved in f , and an additional F formula F that represents the rest of the constraint. VF f]] U F holds \nif (1) f is satis.able and (2) F also holds under any solution to the unknowns in U satisfying f . Because \nspace is limited, the de.nitions of the translation are elided here; they are available in the technical \nreport [11]. The Z3 theorem prover [3] is used to .nd a model satisfying these Fformulas. This model \ncan be used to construct a counterex\u00adample to explain the failure of exhaustiveness or totality to the \nuser. The veri.cation done by Z3 does not affect the dynamic semantics of JMatch 2.0; it only affects \nwarnings given to the programmer. In the remainder of this section, let f be the set of variables declared \nin f . 5.1 Verifying exhaustiveness Every switch and if statement can be written as a cond statement. \nThus, veri.cation of switch and if reduces to that of cond.  ! To verify a cond statement cond { (fi \n) {si } else s }, we begin by asserting the invariants of all the known variables in the context. We \nthen proceed case by case. The algorithm .rst checks whether fi yields a solution to its unknowns. If \nnot, the compiler issues a warning that this arm is redundant. In either case, the assertion is updated \nto rule out patterns matched up to the current arm. The else arm, if present, is equivalent to true. \nFinally, the cond statement is exhaustive if the .nal assertion is unsatis.able. If not, a counterexample \nis generated from a satisfy\u00ading assignment, and a nonexhaustive warning is reported. A cond statement \ncan be used to re.ne patterns in the same way as a where pattern. Since both switch and if are syntactic \nsugar for cond, so can they. Let I be the invariant prior to the veri.cation of a conditional case (f \n) {s}. We verify s with the stronger invariant I 0 I ^ .VF f ] f true/. To verify let f , we check whether \nthe negation of f is satis\u00ad.able. If so, a warning that the let statement may not always be total is \nreported to the programmer.  5.2 Verifying matching speci.cations As described in Section 4.3, the bodies \nof methods are checked against the matches clause of the method to ensure that the body succeeds whenever \nthe matches clause is true. Recall that this entails verifying the proposition ExtractMM ) MB. One complication \nis that the matches clause M of a method may refer to other methods. These method references may solve \nfor unknown variables in M . In turn, these unknowns may be further referenced by other atoms in M , \nimposing additional matching preconditions. The matches and ensures clauses of the referenced methods \nare used to resolve this complication. The matches clause imposes additional matching precondition to \nM , and the ensures clause constrains the values of unknowns that may be referenced later in M . In the \nfollowing example, the matches clause of method bar refers to foo: int foo(int x) matches(x > 2) ensures(result \n>= x); int bar(int y) matches(y > 0 &#38;&#38; result = foo(y) &#38;&#38; result < 4); Now, suppose we \nwant to extract bar s matching precondition for the forward mode, i.e., when y is known. The reordering \nand atom\u00addropping procedure does not alter the matches clause. This means bar(y) succeeds if y > 0, foo(y) \nreturns a result, and foo(y) < 4. The invocation of foo in bar s matches clause succeeds if y > 2, and \nfoo s ensures clause says result y. Therefore, bar(y) is guaranteed to succeed if y > 0 ^ y > 2 ^ result \n y ^ result < 4, which is equivalent to y D 3. We now give the formal translation for ExtractMM , where \nM D .fkEg; fEug/. If M is the result of reordering and dropping O atoms in M , and fuEOg fEug is the \nset of unknowns remaining in MO, then we have ExtractMM VF OfuEg [ MOtrue M ] O Similarly, the precise \nmatching precondition is de.ned as MB VF B] fEug [ Btrue With the above de.nitions, we are ready to \nformally de.ne the veri.cation conditions for JMatch methods. To verify a method ---! Tr foo(Ti xi ) \nmatches(M ) ensures(E) in mode M with body B, we prove these two assertions: ExtractMM ) MB (2) MB ) \nVF E] E true (3) Assertion (2) says that if the extracted matching precondition for M holds, then B \nsucceeds in generating a solution to all of its unknowns, which can be part of the arguments or declared \nin B itself. Assertion (3) says that if B succeeds in generating a solution, then the postcondition of \nthe method holds. For a method declared in an interface or declared abstract, and for each mode M declared \nin that method, the assertion ExtractMM ) ExtractME is proven instead. Since the matches clause must \nspecify an under\u00adapproximation of the (unimplemented) relation and the ensures clause an overapproximation, \nthis assertion says that by transitivity, if the matching precondition holds, then the postcondition \nshould hold as well. Failure to prove these assertions means that the method does not respect its contract. \nAs a result, a warning for the violation is issued to the programmer. 5.3 Verifying disjoint patterns \nJMatch 2.0 veri.es multiplicity of formulas and patterns, ensuring that they generate at most one solution \nin non-iterative modes. Disjoint pattern disjunctions allow disjunctions to be expressed without generating \nmultiple solutions, but this property must be veri.ed. We also overload the | symbol as a logical operator; \nthe formula f1 | f2 is a disjunction that may be used only if at most one of f1 or f2 is satis.able. \nLet U be the set of unsolved unknowns in p1 | p2, and let p 0 be the result of substituting each 1 unsolved \nunknown in p1 with a fresh variable, and similarly for p 0 . Patterns p1 and p2 are disjoint if .VF \nx D p 0 ] U true/ ^ 2 1 .VF x D p0 ] U true/, where x is a fresh variable, is unsatis.able. 2 Similiarly, \nwhen | is used as a logical operator, formulas f1 and f2 are disjoint if .VF f 0] U true/^.VF f 0] \nU true/ is unsatis.able. 1 2 Consider the examples in Section 3.3. The pattern 1 | 2 is disjoint because \nx D 1 ^ x D 2 is unsatis.able. The disjunction y-1 | y+1 is disjoint when y is known. When y is unknown, \nthe veri.cation procedure renames y in each arm to a fresh variable, yielding x D y1 1 ^ x D y2 C 1, \nwhich is satis.able, so the compiler generates a warning.  5.4 Soundness As in most functional programming \nlanguages, we consider failures of exhaustiveness not as errors but rather as a reason to warn the programmer. \nOur goal is to help programmers be effective. There\u00adfore, some unsoundness or incompleteness may be tolerable \nor even desirable if it rarely limits or annoys the programmer. Our veri.ca\u00adtion procedures establish \ntwo main sources of unsoundness, possi\u00adbly leading to erroneous warnings or lack of warnings. An obvious \nsource is that JMatch is an imperative language, yet the reasoning procedures described here do not take \nside effects into account. We do not consider this a serious problem because JMatch encourages a programming \nstyle in which side effects are used sparingly and are encapsulated inside data abstractions. A second \nsource of un\u00adsoundness arises from recursively de.ned methods, which are dis\u00adcussed in Section 6.2. In \nsome cases, the compiler may report that it cannot prove exhaustiveness or lack of redundancy. This does \nnot seem to be a problem in practice. 6. Implementation We have built a prototype implementation of JMatch \n2.0 by extend\u00ading the JMatch 1.1.6 compiler [18] to add the new pattern matching  interface Nat { boolean \nzero() returns(); boolean succ(Nat n) returns(n); ... } class PSucc implements Nat { Nat pred; boolean \nzero() returns() ( false ) static PSucc create$zero() ( false ) boolean succ(Nat n) returns(n) ( pred \n= n ) static PSucc create$succ(Nat n) ( result = PSucc() &#38;&#38; result.pred = n ) ... } Figure 9. \nTranslation of named constructors. features in Section 3 and the static annotations in Section 4, and \nto use the Z3 theorem prover [3] to verify exhaustiveness, totality, and multiplicity. 6.1 Translating \nnew features Each named constructor foo(...) de.ned in class C is trans\u00adlated into two JMatch methods \nhaving the same visibility as that of foo. The .rst method is boolean foo(...) and contains all the modes \nwhere result is known. The other method is static C create$foo(...) and contains the remaining modes, \nwhose body requires creating a fresh object. For named constructors de\u00ad.ned in an interface, the latter \ntranslation is omitted. An invoca\u00adtion of a named constructor is also transformed to use one of the translated \nmethods accordingly, with the exception of invocations appearing in invariants and matches and ensures \nclauses. These invocations are retained as a type object of the class and will be used directly during \nveri.cations. An example translation of Nat and PSucc is shown in Figure 9. In the JMatch implementation, \nwhen a variable w of type Tw is matched against a value x of type Tx, only an instanceof check is introduced \nif Tw is not a supertype of Tx. To use the equality con\u00adstructor, JMatch 2.0 further checks whether an \nequality constructor accepting one argument of type Tx exists in the implementation of Tw and invokes \nit on x if the instanceof check fails.  6.2 Handling recursion The veri.cation functions de.ned in Section \n5 unwind all method invocations appearing in a formula being translated into assertions expressed in \nterms of the matches and ensures clauses of the methods. In general, these translations may not be well-founded \nwhen the matches and ensures clauses of methods are mutually dependent, or in invariants of mutually \nrecursive types. Neverthe\u00adless, the veri.cation may be successful without fully unrolling all facts about \nmethod calls and types. We use Z3 s external theory plugin to implement lazy assertions by introducing \ninterpreted the\u00adory predicates and functions. Our external theory for Z3 expands facts about type invariants \nand about matching preconditions and postconditions only when instances of the theory predicates are \nas\u00adsigned a truth value. For example, if an instance of the predicate on procedure invocation is assigned \nfalse, the negation of the matches clause of the associated procedure is asserted on the procedure in\u00adputs. \nIf the instance is assigned true, the ensures clause is asserted. An interpreted theory function is used \nto enforce the uniqueness of procedure outputs when the procedure is a (partial) function. Because Z3 \ntreats each asserted axiom as global, every instan\u00adtiated axiom is asserted as an implication whose premise \nis the as\u00adsigned predicate. Z3 also keeps track of every asserted theory pred\u00adicate in its logical context, \nwhich allows proving exhaustiveness using class invariants without unrolling them entirely. To prevent \nunbounded unrolling, iterative deepening [12] is used to unroll as deeply as possible within a time budget. \nSince the theory will not further expand facts beyond the maximum depth, Z3 concludes that no satisfying \nassignment exists. If this happens when checking ex\u00adhaustiveness, the compiler warns that it did not \n.nd a counterexam\u00adple to exhaustiveness, but that there might be one. 7. Evaluation Our evaluation of \nJMatch 2.0 aims to answer three kinds of ques\u00adtions: Is the extended language expressive? In particular, \ndoes it permit concise implementations? What annotation burden is incurred by programmers using the new \nveri.cation procedures? Is the veri.cation performed by our implementation effective on different kinds \nof code? What is the compile-time overhead of veri.cation? 7.1 Code examples We have evaluated our prototype \nJMatch 2.0 implementation on a variety of different coding problems. For each of these code examples, \nwe have shown that the compiler correctly performs the three veri.cation tasks described above, and we \nhave measured the time taken by veri.cation and compared it to total compilation time. To evaluate expressiveness, \nwe have also implemented each example as concisely as we could using Java. Natural numbers The implementations \nof natural numbers shown earlier in the paper are also used for our evaluation. Lists A JMatch 2.0 interface \nList for immutable lists is shown in Figure 10. We implement this interface in four very different ways: \nthe empty list (EmptyList), regular cons lists (ConsList), snoc lists (SnocList) in which elements are \nappended to the end, and lists with an array representation (ArrList), in which the under\u00adlying array \nis imperatively updated by cons but is shared as much as possible across multiple lists that record indices \ninto it. To give the .avor of these implementations, the .gure shows how the mul\u00adtimodal named constructor \nsnoc is de.ned for ConsList. As the remaining code in the .gure shows, these four list implementations \ninteroperate smoothly, and list operations, even including reverse, can be used as patterns. CPS We implement \nCPS conversion of a simple abstract syntax tree (AST) for lambda calculus; though Figure 5 shows only \nthe key code, the implementation also includes AST classes. Type inference We implement uni.cation-based \ntype inference over the same ASTs, augmented with type declarations. The code for type inference is placed \nwithin the AST node classes. Trees A JMatch 2.0 interface Tree for binary trees is shown in Figure 11. \nWe implement the AVL tree based on this interface. The rebalance method, also shown in the .gure, returns \nthe balanced version of the input subtree having v as the value at the root and l and r as its children. \nThe invariant of Tree and the ensures clause of branch are crucial for the JMatch 2.0 compiler to verify \nthat the formula in rebalance covers all the possible input subtrees. Checking the disjoint disjunctions \nalso ensures that there is only one way to match each tree. Collections We convert the prior JMatch reimplementation \nof the key collection classes from the Java collections framework [17] into JMatch 2.0. This code base \nincludes implementations of various data structures: hash tables, red-black trees, and resizable arrays. \n interface List { invariant(this = nil() | cons(_, _)); constructor nil() matches(notall(result)); constructor \ncons(Object hd, List tl) matches(notall(result)) returns(hd, tl); constructor snoc(List hd, Object tl) \n matches ensures(cons(_, _)) returns(hd, tl); constructor equals(List l); constructor reverse(List l) \nmatches(true) returns(l); boolean contains(Object elem) iterates(elem); int size(); } constructor snoc(List \nh, Object t) // in ConsList matches ensures(cons(_, _)) returns(h, t) ( h = EmptyList.nil() &#38;&#38; \ncons(t, h) | h = cons(Object hh, List ht) &#38;&#38; cons(hh, snoc(ht, t)) ) static int length(List l) \n{ switch (l) { case nil(): return 0; case snoc(List t, _): return length(t) + 1; case cons(_, List t): \nreturn length(t) + 1; // detected as redundant } } List l = EmptyList.nil(); // l = [] l = SnocList.cons(0, \nl); // l = [[], 0] l = ConsList.snoc(l, 1); // l = [0, [1, []]] l = ArrList.snoc(l, 2); // l = [0, 1, \n2] l = ConsList.cons(3, l); // l = [3, [0, 1, 2]] let l = reverse(List r1); //r1 = [2, [1, [0, [3, []]]]] \nl = ArrList.cons(4, l); // l = [4, 3, 0, 1, 2] let l = reverse(List r2); //r2 = [2, 1, 0, 3, 4] Figure \n10. List interface and sample usage.  7.2 Expressiveness We can assess the expressiveness of JMatch \n2.0 by comparing the number of language tokens needed to implement each of the examples. The resulting \ntoken counts shown in Table 1 indicate that JMatch 2.0 code is considerably more concise than in Java: \n42.9% shorter on average. This conciseness is largely due to the JMatch support for modal abstraction \nand for equality constructors. 7.3 Effectiveness There are three new veri.cation tasks. First, switch \nand related constructs (let, cond, etc.) should be exhaustive. Second, method implementations must be \ncorrect with respect to both their declared matches clause and their ensures clause. Third, disjoint \ndisjunc\u00adtions must indeed be disjoint, to verify multiplicity. All of the examples shown in the table, \nand all prior examples shown in the paper, are successfully veri.ed for exhaustiveness, (non-)redundancy, \nand multiplicity. The compiler caught several subtle exhaustiveness bugs during development of this code, \nsuch as incorrect order of arguments to methods and invocation to an unexpected implementation of overloaded \nor overridden methods. In case of TreeMap, the absence of red-black tree invariants results in a nonexhaustive \nwarning in the balance method.  7.4 Ef.ciency Table 1 shows that veri.cation time is reasonable for \nall of the code examples, even with our unoptimized prototype implementation. The reported numbers include \ncompilation time of dependencies but exclude the overhead of initializing the compiler (689 ms) and the \nZ3 solver (680 ms). On average, the veri.cation overhead on the evaluated code is 37.5% compared to the \nregular compilation time. Implementation JMatch Java w/o verif w/ verif Nat 41 (21) 29 0.100 0.104 PZero \n85 189 0.258 0.331 PSucc 98 226 0.280 0.435 ZNat 161 319 0.377 0.459 List 114 (72) 91 0.129 0.123 EmptyList \n164 455 0.416 0.510 ConsList 309 1007 0.807 2.47 SnocList 311 1006 1.05 3.36 ArrList 473 1208 0.864 1.90 \nExpr 96 (57) 80 0.710 0.846 Variable 192 434 0.689 0.852 Lambda 239 500 1.20 1.52 TypedLambda 86 92 1.38 \n1.57 Apply 232 506 1.15 2.31 CPS 325 1279 7.88 8.37 Type 154 187 0.218 0.307 BaseType 73 163 0.350 0.443 \nArrowType 82 189 0.357 0.444 UnknownType 154 245 0.372 0.490 Environment 211 310 0.695 0.862 Tree 114 \n(44) 69 0.165 0.170 Leaf 124 351 0.420 0.510 Branch 202 553 0.529 0.682 AVLTree 439 720 2.84 9.01 ArrayList \n773 1098* 1.67 1.81 LinkedList 886 1232* 2.00 2.20 HashMap 1082 1874* 3.41 3.66 TreeMap 3606 3955* 5.90 \n6.43 Table 1. The number of tokens for implementations in JMatch 2.0 versus Java. Interface token counts \nare reported both with and with\u00adout (in parentheses) matches and ensures clauses. Veri.cation overhead \nis given in seconds as the average of 24 runs, with a stan\u00addard deviation of at most 15%. Some comparisons \n(*) are versus a PolyJ [21] implementation that is more concise than the Java one. For example, the PolyJ \nTreeMap is 20% shorter than the Java equivalent [17]. The speed of veri.cation is not surprising, because \nveri.cation is performed one method at a time. Veri.cation is simple and tractable because the abstraction \nmechanisms we introduced to JMatch allow both programmers and the SMT solver to reason locally about \ncode. Because JMatch 2.0 does not signi.cantly change the dynamic semantics of JMatch, the translation \nto Java is essentially un\u00adchanged. The performance of the compiled programs is therefore similar to one \nin the previous evaluation [17]. 8. Related work Integrating pattern matching with objects and data abstraction \nhas been the subject of quite a few research efforts. Case classes in the Scala programming language \n[22], as in Pizza [23], provide pattern matching by allowing case-class con\u00ad structors in case arms. \nScala uses sealed classes to limit the num\u00adber of case classes that can inherit them. This makes exhaustive\u00adness \neasy to verify, but sacri.ces extensibility because only one implementation is allowed per declaration \nof a sealed class. Our invariant declaration achieves the same level of exhaustiveness checking but allows \nprogrammers to extend classes freely. Closely related approaches include extensible algebraic data types \n[32] and polymorphic variants [8], which support some extensibility and  interface Tree { invariant(this \n= leaf() | branch(_,_,_)); constructor leaf() matches(height() = 0) ensures(height() = 0); constructor \nbranch(Tree l, int v, Tree r) matches(height() > 0) ensures(height() > 0 &#38;&#38; (height() = l.height() \n+ 1 &#38;&#38; height() > r.height() || height() > l.height() &#38;&#38; height() = r.height() + 1)) \nreturns(l, v, r); int height() ensures(result >= 0); } static Tree rebalance(Tree l, int v, Tree r) matches(true) \n( // in AVLTree result = Branch(Branch(Tree a, int x, Tree b), int y, Branch(Tree c, int z, Tree d)) \n&#38;&#38; ( l.height() -r.height() > 1 &#38;&#38; d = r &#38;&#38; z = v // rotation from left &#38;&#38; \n( l = branch(Tree ll, y, c) &#38;&#38; ll = branch(a, x, b) &#38;&#38; ll.height() >= c.height() // case \n1: single rot. | l = branch(a, x, Tree lr) &#38;&#38; lr = branch(b, y, c) &#38;&#38; a.height() < lr.height()) \n// case 2: double rot. | r.height() -l.height() > 1 &#38;&#38; a = l &#38;&#38; x = v // rotation from \nright &#38;&#38; ( r = branch(Tree rl, z, d) &#38;&#38; rl = branch(b, y, c) &#38;&#38; rl.height() > \nd.height() // case 3: double rot. | r = branch(b, y, Tree rr) &#38;&#38; rr = branch(c, z, d) &#38;&#38; \nb.height() <= rr.height())) // case 4: single rot. | abs(l.height() -r.height()) <= 1 &#38;&#38; result \n= Branch(l, v, r) ) Figure 11. Tree interface and the AVL tree rebalance method, which uses the interface \nto check for totality. deep pattern matching, but tie pattern matching to the data repre\u00adsentation more \nthan is ideal. Wadler s views [30] were an early, in.uential generalization of pattern matching. Views \nrequire an explicitly de.ned bijection between the abstract view and the representation. Unlike in our \nlanguage, views do not reconcile pattern matching with subtyping and do not allow matching without knowing \nthe identity of the implementation. Extractors are introduced in [5] as an alternative to case classes \nthat is compatible with data abstraction. Each extractor contains apply and unapply methods, called implicitly \nduring construc\u00adtion and pattern matching. There is no check that these methods are inverses, however. \nModal abstractions in JMatch are less verbose and reduce the chance of such errors. No exhaustiveness \nchecking was proposed for extractors. Dotta et al. [4] verify extractors by relying on sealed classes, \nand support user-de.ned constructor pat\u00adterns. Their work does check for pattern disjointness; abstraction \nprevents us from making this guarantee. Active patterns in F# [29] are similar to extractors, but support \nexhaustiveness checking by allowing the declaration that a set of patterns is complete. Because they \noffer only a backward mode, they do not support algebraic reasoning in the same way as modal abstractions. \nThey also do not support object-oriented extensibility. The RINV language of Wang et al. [31] also uses \ninvertible computation to implement pattern matching that is compatible with data abstraction. Rather \nthan extracting computations from a logi\u00adcal characterization of the computation, RINV instead uses a \nre\u00adstricted language for abstraction functions that guarantees invert\u00adibility. These functions are bidirectional \nrather than fully multi\u00admodal and do not support iterative modes. RINV analyzes exhaus\u00adtiveness via speci.cations \nof complete sets of constructors, but does not verify these speci.cations. RINV supports neither subtyping \nnor extensibility. Suter et al. [27] also use abstraction functions to reduce alge\u00ad braic data types \nto abstract values such as multisets, and use known theories of these abstract values to reason about \ndata types. Meth\u00adods may be annotated with a postcondition in terms of abstraction functions. Leon [28] \nextends this reasoning to recursive programs. Used in conjunction with sealed classes, these decision \nprocedures assist in a more precise analysis of pattern exhaustiveness by tak\u00ading type re.nement into \naccount. These decision procedures do not support modal abstraction. An orthogonal approach to integrating \npattern matching into object-oriented languages is predicate dispatch [6, 20], which ex\u00ad tends multimethods \nwith the ability to choose an implementation based on general predicates over the arguments. Predicate \ndispatch appears to be largely orthogonal and complementary to the pattern matching mechanisms described \nhere. The predicates in prior work on predicate dispatch are, however, less expressive than those we \nhave explored here. OOMatch [24] uses pattern matching in predi\u00ad cate dispatch. Its deconstructors are \nsimilar to the backward mode of JMatch constructors. OOMatch s pattern matching differs in that it can \nappear only in method headers as part of predicate dispatch, and no separation of speci.cation and implementation \nis provided. HydroJ [15] uses predicate dispatch to express extensible commu\u00ad nication patterns in distributed \nsystems; however, pattern matching is done over concrete data structures, tagged trees. Matchete [10] \nextends Java with pattern matching operators similar to extractors, but matches on regular expressions \nand other specialized expressions. It does not analyze exhaustiveness. The Thorn language integrates \npatterns to make code more con\u00adcise and robust [1]. Its rich set of patterns includes boolean com\u00ad binations \nof patterns, general list patterns, regular expressions, and .rst-class patterns. First-class patterns \nin Thorn provide pattern ab\u00adstraction that supports evolution of the data structure used in pattern matching, \nbut Thorn does not support multiple implementations. As a dynamic language, Thorn does not check exhaustiveness. \nHarmony and the Boomerang language [2, 7] support bidirec\u00ad tional computations over trees and strings \nthrough domain-speci.c lens combinators. The types in these languages support reasoning about the totality \nof transformations in these domains, but data ab\u00adstraction is not a feature of these languages. One focus \nof research on pattern matching has been on how to generate ef.cient code that shares computation across \ndifferent pat\u00adterns (e.g., [13]). Such optimizations are orthogonal to this work. 9. Conclusions A clean \nintegration of pattern matching into the object-oriented set\u00adting could simplify many programming tasks. \nPrior work has not managed to provide expressive pattern matching with strong data abstraction and subtyping, \nalong with statically checked exhaus\u00adtiveness. This is the .rst work that manages to combine these im\u00adportant \nfeatures. We improved the integration of pattern matching with object-oriented programming, yet showed \nthat even with this more powerful pattern matching, it is possible to reason statically about exhaustiveness, \nredundancy, totality, and multiplicity.  The most important insight was that programmers need to be \nable to specify the precondition for successful pattern matching in an abstract way. We showed that it \nis possible to do this while keeping the annotation burden low, by automatically extracting matching \npreconditions. The speci.cation techniques introduced may be helpful for other models of multidirectional \ncomputation. Acknowledgments Soam Vasani and Denis Bueno got the JMatch exhaustiveness project off to \na good start. Leo de Moura helped with using Z3. Ross Tate, Owen Arden, Aslan Askarov, Jed Liu, Harry \nTerkelsen, Mark Reitblatt, Robert Soul\u00b4e, Mike George, and Danfeng Zhang offered many helpful suggestions \nfor the presentation. This research was supported in part by Of.ce of Naval Research Grants N00014-09-1-0652 \nand N00014-13-1-0089, and by a grant administered by the Air Force Research Laboratory. References [1] \nBard Bloom and Martin J. Hirzel. Robust scripting via patterns. In Proc. 8th symposium on Dynamic languages \n(DLS), pp. 29 40, 2012. [2] Aaron Bohannon, J. Nathan Foster, Benjamin C. Pierce, Alexandre Pilkiewicz, \nand Alan Schmitt. Boomerang: Resourceful lenses for string data. In Proc. 35th ACM Symposium on Principles \nof Program\u00ad ming Languages (POPL), pp. 407 419, January 2008. [3] Leonardo de Moura and Nikolaj Bj\u00f8rner. \nZ3: an ef.cient SMT solver. In Proceedings of the Theory and Practice of Software, 14th Int l Conf. on \nTools and Algorithms for the Construction and Analysis of Systems, pp. 337 340, 2008. [4] Mirco Dotta, \nPhilippe Suter, and Viktor Kuncak. On static analysis for expressive pattern matching. Technical report, \nEcole Polytechnique \u00b4 F\u00b4ed \u00b4erale de Lausanne, February 2008. [5] Burak Emir, Martin Odersky, and John \nWilliams. Matching objects with patterns. In Erik Ernst, editor, Proc. 21st European Conf. on Object-Oriented \nProgramming, volume 4609 of Lecture Notes in Computer Science, pp. 273 298. Springer Berlin Heidelberg, \n2007. [6] Michael Ernst, Craig Kaplan, and Craig Chambers. Predicate dis\u00ad patching: A uni.ed theory of \ndispatch. In Proc. 12th European Conf. on Object-Oriented Programming, pp. 186 211, 1998. [7] J. Nathan \nFoster, Michael B. Greenwald, Jonathan T. Moore, Ben\u00ad jamin C. Pierce, and Alan Schmitt. Combinators \nfor bidirectional tree transformations: A linguistic approach to the view-update problem. ACM Trans. \nProgram. Lang. Syst., 29(3), May 2007. [8] Jacques Garrigue. Typing deep pattern-matching in presence \nof poly\u00ad morphic variants. In JSSST Workshop on Programming and Program\u00ad ming Languages, 2004. [9] Ralph \nE. Griswold, David R. Hanson, and John T. Korb. Generators in Icon. ACM Transaction on Programming Languages \nand Systems, 3(2):144 161, April 1981. [10] Martin Hirzel, Nathaniel Nystrom, Bard Bloom, and Jan Vitek. \nMatch\u00ad ete: Paths through the pattern matching jungle. In Proc. 10th Int l Conf. on Practical Aspects \nof Declarative Languages, pp. 150 166, 2008. [11] Chinawat Isradisaikul and Andrew C. Myers. Reconciling \nexhaus\u00ad tive pattern matching with objects. Technical report, Computing and Information Science, Cornell \nUniversity, March 2013. http: //hdl.handle.net/1813/33123. [12] Richard E. Korf. Depth-.rst iterative-deepening: \nan optimal admissi\u00ad ble tree search. Arti.cial Intelligence, 27(1):97 109, September 1985. [13] Fabrice \nLe Fessant and Luc Maranget. Optimizing pattern matching. In Proc. 6th ACM SIGPLAN Int l Conf. on Functional \nProgramming, pp. 26 37, 2001. [14] Gary T. Leavens and Peter M \u00a8uller. Information hiding and visibility \nin interface speci.cations. In Proc. 33rd Int l Conf. on Software Engineering (ICSE), pp. 385 395, 2007. \n[15] Keunwoo Lee, Anthony LaMarca, and Craig Chambers. HydroJ: object-oriented pattern matching for evolvable \ndistributed systems. In Proc. 18th ACM SIGPLAN Conf. on Object-Oriented Programming, Systems, Languages \nand Applications, pp. 205 223, 2003. [16] Barbara Liskov, Russell Atkinson, Toby Bloom, J. Eliot Moss, \nJ. Craig Schaffert, Robert Schei.er, and Alan Snyder. CLU Reference Manual. Springer-Verlag, 1984. Also \npublished as Lecture Notes in Computer Science 114, G. Goos and J. Hartmanis, Eds., Springer-Verlag, \n1981. [17] Jed Liu, Aaron Kimball, and Andrew C. Myers. Interruptible itera\u00ad tors. In Proc. 33rd ACM \nSymposium on Principles of Programming Languages (POPL), pp. 283 294, January 2006. [18] Jed Liu and \nAndrew C. Myers. JMatch: Java plus pattern matching. Technical Report TR2002-1878, Computer Science Department, \nCor\u00ad nell University, October 2002. Software release at http://www.cs. cornell.edu/projects/jmatch. [19] \nJed Liu and Andrew C. Myers. JMatch: Iterable abstract pattern matching for Java. In Proc. 5th International \nSymposium on Practical Aspects of Declarative Languages, pp. 110 127, January 2003. [20] Todd Millstein. \nPractical predicate dispatch. In Proc. 19th ACM SIG-PLAN Conf. on Object-Oriented Programming, Systems, \nLanguages and Applications, pp. 345 364, 2004. [21] Andrew C. Myers, Barbara Liskov, and Nicholas Mathewson. \nPolyJ: Parameterized types for Java. Software release, at http://www.cs. cornell.edu/polyj, July 1998. \n[22] Martin Odersky, Lex Spoon, and Bill Venners. Programming in Scala: A Comprehensive Step-by-step \nGuide. Artima Incorporation, USA, 1st edition, 2008. [23] Martin Odersky and Philip Wadler. Pizza into \nJava: translating theory into practice. In Proc. 24th ACM Symposium on Principles of Pro\u00ad gramming Languages \n(POPL), pp. 146 159, 1997. [24] Adam Richard and Ond.rej Lhot \u00b4ak. OOMatch: pattern matching as dispatch \nin Java. In Companion 22nd ACM SIGPLAN Conf. on Object-Oriented Programming, Systems, Languages and Applications, \npp. 771 772, 2007. [25] Clyde Ruby and Gary T. Leavens. Safely creating correct subclasses without seeing \nsuperclass code. In Proc. 15th ACM SIGPLAN Conf. on Object-Oriented Programming, Systems, Languages and \nApplications, pp. 208 228, 2000. [26] Zoltan Somogyi, Fergus Henderson, and Thomas Conway. The exe\u00ad cution \nalgorithm of Mercury, an ef.cient purely declarative logic pro\u00ad gramming language. The Journal of Logic \nProgramming, 29(1 3):17 64, October December 1996. [27] Philippe Suter, Mirco Dotta, and Viktor Kuncak. \nDecision procedures for algebraic data types with abstractions. In Proc. 37th ACM Sympo\u00ad sium on Principles \nof Programming Languages (POPL), pp. 199 210, 2010. [28] Philippe Suter, Ali Sinan K \u00a8oksal, and Viktor \nKuncak. Satis.ability modulo recursive programs. In Proc. 18th Int l Conf. on Static Analy\u00ad sis, pp. \n298 315, 2011. [29] Don Syme, Gregory Neverov, and James Margetson. Extensible pat\u00ad tern matching via \na lightweight language extension. In Proc. 12th ACM SIGPLAN Int l Conf. on Functional Programming, pp. \n29 40, 2007. [30] Philip Wadler. Views: a way for pattern matching to cohabit with data abstraction. \nIn Proc. 14th ACM Symposium on Principles of Programming Languages (POPL), pp. 307 313, 1987. [31] Meng \nWang, Jeremy Gibbons, Kazutaka Matsuda, and Zhenjiang Hu. Refactoring pattern matching. Science of Computer \nProgramming, in press. Available online 24 August 2012. [32] Matthias Zenger and Martin Odersky. Extensible \nalgebraic datatypes with defaults. In Proc. 6th ACM SIGPLAN Int l Conf. on Functional Programming, pp. \n241 252, September 2001.     \n\t\t\t", "proc_id": "2491956", "abstract": "<p>Pattern matching, an important feature of functional languages, is in conflict with data abstraction and extensibility, which are central to object-oriented languages. Modal abstraction offers an integration of deep pattern matching and convenient iteration abstractions into an object-oriented setting; however, because of data abstraction, it is challenging for a compiler to statically verify properties such as exhaustiveness. In this work, we extend modal abstraction in the JMatch language to support static, modular reasoning about exhaustiveness and redundancy. New matching specifications allow these properties to be checked using an SMT solver. We also introduce expressive pattern-matching constructs. Our evaluation shows that these new features enable more concise code and that the performance of checking exhaustiveness and redundancy is acceptable.</p>", "authors": [{"name": "Chinawat Isradisaikul", "author_profile_id": "81758797657", "affiliation": "Cornell University, Ithaca, NY, USA", "person_id": "P4149050", "email_address": "chinawat@cs.cornell.edu", "orcid_id": ""}, {"name": "Andrew C. Myers", "author_profile_id": "81100011022", "affiliation": "Cornell University, Ithaca, NY, USA", "person_id": "P4149051", "email_address": "andru@cs.cornell.edu", "orcid_id": ""}], "doi_number": "10.1145/2491956.2462194", "year": "2013", "article_id": "2462194", "conference": "PLDI", "title": "Reconciling exhaustive pattern matching with objects", "url": "http://dl.acm.org/citation.cfm?id=2462194"}