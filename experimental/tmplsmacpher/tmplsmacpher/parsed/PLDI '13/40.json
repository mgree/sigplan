{"article_publication_date": "06-16-2013", "fulltext": "\n Fast Algorithms for Dyck-CFL-Reachability with Applications to Alias Analysis Qirun Zhang Michael R. \nLyu Hao Yuan * Zhendong Su The Chinese University of Hong Kong BOPU Technologies University of California, \nDavis {qrzhang, lyu}@cse.cuhk.edu.hk hao@bopufund.com su@cs.ucdavis.edu Abstract The context-free language \n(CFL) reachability problem is a well\u00adknown fundamental formulation in program analysis. In practice, \nmany program analyses, especially pointer analyses, adopt a re\u00adstricted version of CFL-reachability, \nDyck-CFL-reachability, and compute on edge-labeled bidirected graphs. Solving the all-pairs Dyck-CFL-reachability \non such bidirected graphs is expensive. For a bidirected graph with n nodes and m edges, the traditional \ndy\u00adnamic programming style algorithm exhibits a subcubic time com\u00adplexity for the Dyck language with \nk kinds of parentheses. When the underlying graphs are restricted to bidirected trees, an algo\u00adrithm \nwith O(n log n log k) time complexity was proposed re\u00adcently. This paper studies the Dyck-CFL-reachability \nproblems on bidirected trees and graphs. In particular, it presents two fast algo\u00adrithms with O(n) and \nO(n + m log m) time complexities on trees and graphs respectively. We have implemented and evaluated \nour algorithms on a state-of-the-art alias analysis for Java. Results on standard benchmarks show that \nour algorithms achieve orders of magnitude speedup and consume less memory. Categories and Subject Descriptors \nF.2.2 [Nonnumerical Algo\u00adrithms and Problems]: Computations on discrete structures; D.3.4 [Processors]: \nCompilers; F.3.2 [Semantics of Programming Lan\u00adguages]: Program analysis General Terms Algorithms, Design, \nExperimentation, Languages Keywords Dyck-CFL-reachability; alias analysis 1. Introduction The context-free \nlanguage (CFL) reachability problem is a gener\u00adalization of the traditional graph reachability problem \n[27]. Many program analyses have been formulated as CFL-reachability prob\u00adlems, such as interprocedural \ndata .ow analysis [29], program slic\u00ading [28], shape analysis [26], type-based .ow analysis [22, 25], \nand pointer analysis [31 33, 36, 37, 40]. When the underlying CFL is restricted to a Dyck language which \ngenerates matched parenthe\u00adses, the CFL-reachability problem is referred to as Dyck-CFL\u00adreachability. \nAlthough a restricted version of CFL-reachability, * Part of this work was done while the author was \nworking at City Univer\u00adsity of Hong Kong. Permission to make digital or hard copies of all or part of \nthis work for personal or classroom use is granted without fee provided that copies are not made or distributed \nfor pro.t or commercial advantage and that copies bear this notice and the full citation on the .rst \npage. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior \nspeci.c permission and/or a fee. PLDI 13, June 16 19, 2013, Seattle, WA, USA. Copyright c &#38;#169; \n2013 ACM 978-1-4503-2014-6/13/06. . . $15.00 Dyck-CFL-reachability can express almost all of the applications \nof CFL-reachability in program analysis [19]. Solving Dyck-CFL-reachability of size k (i.e., k kinds \nof paren\u00adtheses) is expensive in practice. The traditional dynamic program\u00adming style CFL-reachability \nalgorithm [29, 38] runs in O(k3 n 3) time. Only recently, the .rst subcubic algorithm was proposed, re\u00adducing \nthe cubic time complexity by a factor of log n [7]. Scaling Dyck-CFL-reachability-based analyses on real-world \napplications is challenging. Various enhancements have been proposed, such as leveraging demand-driven \nproperties in speci.c analyses [33, 37, 40], making use of a specialized reduction to set constraints \n[19], and approximating the client problems [32, 33]. However, all ex\u00adisting Dyck-CFL-reachability algorithms \nrelying on the dynamic programming scheme exhibit a subcubic time complexity. When the underlying graphs \nare restricted to bidirected trees, Yuan and Eugster proposed an algorithm with O(n log n log k) time \ncom\u00adplexity [39]. In this paper, we focus on the bidirected version of Dyck\u00adCFL-reachability, as detailed \nin Section 2.2. The bidirected Dyck\u00adCFL-reachability is particularly suitable for pointer analysis. All \nstate-of-the-art demand-driven pointer analyses [31 33, 37, 40] are formulated by extending Dyck-CFL-reachability \nand compute on edge-labeled bidirected graphs. Speci.cally, matched parentheses derived from Dyck-CFL-reachability \ncan be used to capture .eld accesses (i.e., load/store) in Java [32, 33, 36, 37] and indirections (i.e., \nreferences/dereferences) in C [40]. The bidirectness of graphs is also a prerequisite for CFL-reachability \nformulations of pointer analyses as discussed by Reps [27]. Namely, edges in the origi\u00adnal graph need \nto be augmented with reverse edges (a.k.a. barred edges). Otherwise, two nodes may not be reachable even \nvia stan\u00addard graph reachability. This paper proposes two fast algorithms for solving the bidi\u00adrected \nDyck-CFL-reachability on trees and graphs respectively. The key insight behind our algorithms is the \nobservation of an equivalence property on bidirected structures that has not been fully utilized in previous \nwork. We exploit this property to obtain asymp\u00adtotically much faster algorithms by safely collapsing \nnodes that be\u00adlong to the same equivalence class. Table 1 compares our new al\u00adgorithms and some of the \nexisting algorithms for bidirected Dyck\u00adCFL-reachability, where n and m denote the numbers of nodes and \nedges in the graph respectively. We also present the design and implementation of our algorithms, and \napply them to a state-of\u00adthe-art alias analysis [37]. Empirical results on the standard bench\u00admarks show \nthat our proposed algorithms achieve orders of magni\u00adtude speedup and consume less memory compared to \nthe traditional CFL-reachability algorithm. The principal contributions of our work are as follows: For \nthe case of bidirected trees, we give an algorithm that runs in O(n) time and O(n) space, which answers \nthe Dyck-CFL\u00ad   Type Time Space Reference Tree O(n log n log k) O(n log n) [39] O(k3 3 Graph n ) O(kn2) \n[29, 38] Graph O(kn3) O(kn2) [19] Graph O(kn3/ log n) O(kn2) [7] Tree O(n) O(n) Algorithm 4 Graph O(n \n+ m log m) O(n + m) Algorithm 5 Table 1. Bidirected Dyck-CFL-reachability algorithms. reachability queries \nfor any node pair in O(1) time. This result improves the O(n log n log k) time and O(n log n) space al\u00adgorithm \nproposed by Yuan and Eugster [39]. For the case of bidirected graphs, we give an algorithm that runs \nin O(n + m log m) time and O(n + m) space, which answers the Dyck-CFL-reachability queries for any node \npair in O(1) time. This result improves the traditional subcubic time result in the literature [7]. \n We apply our algorithms to a state-of-the-art context-insensitive alias analysis for Java [37]. Our \nfast algorithms can be directly used in the analysis. Experimental results show that our al\u00adgorithm achieves \norders of magnitude speedup on real-world benchmarks.  The rest of the paper is structured as follows. \nSection 2 reviews the background material on Dyck-CFL-reachability. Section 3 dis\u00adcusses the equivalence \nproperty and a na\u00a8ive all-pairs Dyck-CFL\u00adreachability algorithm. Sections 4 and 5 present our fast algorithms \non bidirected trees and graphs respectively. Section 6 describes an existing state-of-the-art alias analysis \nfor Java as the client applica\u00adtion for our algorithms. Section 7 describes our empirical compar\u00adison \nof the performance of our algorithm versus the performance of the CFL-reachability algorithm using the \nclient alias analysis. Section 8 surveys related work, and Section 9 concludes. 2. Preliminaries This \nsection reviews basic background on Dyck-CFL-reachability and de.nes its bidirected variants. We also \ninclude the traditional subcubic solution for reference and completeness. 2.1 Dyck-CFL-Reachability \nLet CFG =(S,N,P,S ) be a context-free grammar with alphabet S, nonterminal symbols N, production rules \nP and start symbol S. Given a context-free grammar CFG =(S,N ,P,S) and a directed graph G =(V, E) with \neach edge (u, v) . E labeled by a terminal L(u, v) from the alphabet S or e, each path p = v0,v1,v2,...,vm \nin G realizes a string R(p) over the alphabet S by concatenating the edge labels in the path in order, \ni.e., R(p)= L(v0,v1)L(v1,v2)L(v2,v3) ... L(vm-1,vm).Apathin G is an S-path if the realized string can \nbe derived from the start symbol S. Node v is S-reachable from node u iff there exists an S-path from \nu to v. The CFL-reachability problem has four variants: (1) The all-pairs S-path problem: For every \npair of nodes u and v, is there an S-path in the graph from u to v? (2) The single-source S-path problem: \nGiven a source node u,for all nodes v,isthere an S-path in the graph from u to v? (3) The single-target \nS-path problem: Given a target node v,forall nodes u,istherean S-pathinthe graphfrom u to v? (4) The \nsingle-source-single-target problem: Given two nodes u and v,isthere an S-path in the graph from u to \nv?  a\u00af1 a\u00af1 a1 a1 a2 a\u00af1 a\u00af2 a1 a2  a\u00af2 a1 a\u00af2 a1 a2 a\u00af1 (a) The directed graph case. (b) The \nbidirected graph case. Figure 1. Example graphs illustrating a directed graph and its corresponding \nbidirected graph. The Dyck-CFL-reachability is de.ned similarly by restricting the underlying CFL to \na Dyck language, which generates strings of properly balanced parentheses. Consider an alphabet S over \nthe set of opening parentheses A = {a1,a2,...,ak} and the set of their \u00af matching closing parentheses \nA = {a\u00af1, a\u00af2,..., a\u00afk}. The Dyck language of size k (i.e., k kinds of parentheses) is de.ned by the \nfollowing context-free grammar: S . SS | a1Sa\u00af1 | ... | akSa\u00afk | e where S is the start symbol and e \nis the empty string. Specially, we say node v is Dyck-reachable from node u iff there exists an S\u00adpath \nfrom u to v,where S is the start symbol in the Dyck grammar above. We call such a path joining nodes \nu and v a Dyck-path.  2.2 Bidirected Dyck-CFL-Reachability In this paper, we focus on the bidirected \nDyck-CFL-reachability problems, which require the underlying graph to be bidirected and edge-labeled. \nFor any directed edge (u, v) in the graph that is not labeled by e, if it is labeled by an opening parenthesis \nai . A, there must be a reverse edge (v, u) which is labeled by a matching \u00af closing parenthesis a\u00afi \n. A, and vice versa. Formally, we have the following de.nition. DEFINITION 1 (Bidirected Dyck-CFL-Reachability). \nGiven a bidi\u00adrected graph G =(V, E) and a Dyck language of size k,the labels of directed edges in the \ngraph must satisfy the following constraints: .u, v . V, if L(u, v)= e, L(v, u) must be e;  .u, v . \nV, if L(u, v)= ai, L(v, u) must be a\u00afi;  .u, v . V, if L(u, v)= \u00afai, L(v, u) must be ai.  The bidirected \nDyck-CFL-Reachability and its four variants are de.ned similarly as Dyck-CFL-Reachability. The Dyck-CFL-reachable \nnode pairs (u, v) can be de.ned as a binary relation D. DEFINITION 2 (Dyck-CFL-Relation). Given a bidirected \ngraph G =(V, E), we call a binary relation D on V \u00d7 V a Dyck-CFL\u00adrelation iff for all (u, v) . D, v is \nDyck-reachable from u in G. We give an example to illustrate the Dyck-CFL-reachability and the bidirected \nDyck-CFL-reachability problems. EXAMPLE 1. Consider the two graphs in Figure 1. The graph to the left \nshows a directed graph for Dyck-CFL-reachability, and the one to the right is its bidirected counterpart. \nIn both graphs, the realized string R(p) of the path p =1, 2, 3, 4, 5 is a1a\u00af1a2a\u00af2 , with properly matched \nparentheses. Therefore, node 5 is Dyck\u00adreachable from node 1. However, the path 1, 4, 5 is not a valid \nDyck-path. The bidirected Dyck-CFL-reachability formulation has wide applications in pointer analysis. \nFor pointer analysis problems, the Algorithm 1: The standard CFL-reachability algorithm.  Input : Edge-labeled \ndirected graph G =(V, E), normalized CFG =(S,N,P,S ) Output:theset {(i, j ) | S(i, j ). G} 1 add E to \nW 2 foreach production X . E . P do 3 foreach node v . V do 4 if X(v, v) . E then 5 add X(v, v) to E \nand to W 6 while W = \u00d8 do 7 8 9 10 11 12 13 14 15 16 17 18 select and remove an edge Y (i, j) from W \nforeach production X . Y . P do if X(i, j) . E then add X(i, j) to E and to W foreach production X . \nYZ . P do foreach outgoing edge Z(j, k) from node j do if X(i, k) . E then add X(i, k) to E and to W \nforeach production X . ZY . P do foreach incoming edge Z(k, i) to node i do if X(k, j) . E then addX(k, \nj) to E and to W directed edges in the underlying graph must be augmented with re\u00adverse edges (a.k.a. \nbarred edges) [27], otherwise, two nodes may not be reachable from each other even by standard graph \nreachabil\u00adity. All existing CFL-reachability formulations for pointer analysis require the underlying \ngraph to be bidirected. In addition, many pointer analyses employ Dyck-CFL-reachability to match certain \nproperties, such as .eld accesses (i.e., load/store) in Java [32, 33, 36, 37] and indirections (i.e., \nreferences/dereferences) in C [40], which naturally satisfy the requirements of bidirected Dyck-CFL\u00adreachability. \n 2.3 CFL-Reachability Algorithm In the literature, there is a popular dynamic programming style al\u00adgorithm \n[29, 38] for solving the CFL and Dyck-CFL-reachability problems. The algorithm is in Algorithm 1, where \nW denotes a worklist, and X(u, v) denotes the directed edge (u, v) with label L(u, v)= X . The main algorithm \nhas two steps: (1) CFG Nor\u00admalization The underlying CFG must be converted to a normal form, similar \nto the Chomsky Normal Form. When the grammar is in the normal form, all production rules are of the form \nX . YZ, X . Y or X . e,where X is nonterminal, Y and Z are terminals or nonterminals, and e denotes the \nempty string; and (2) Filling in New Edges In order to compute the S-paths, new edges are added to the \ngraph. For example, lines 11-14 describe that for the production rule X . YZ and edge Y (i, j ),all outgoing \nedges of node j are considered. If there is an outgoing edge Z(j, k),anew edge X(i, k) is added to E \nif it is not already in E. The algorithm terminates if there are no more new edges to be inserted. The \ncomplexity of Algorithm 1 is cubic in terms of the number of nodes in the input graph [21]. Chaudhuri \n[7] shows that the well\u00adknown Four Russians Trick [5] can be employed on lines 12-13 and 16-17 in the \nCFL-reachability algorithm to immediately yield a subcubic algorithm with O(n 3/log n) time complexity. \n3. Dyck-CFL-Relation 3.1 An Equivalence Property We .rst study an equivalence property of Dyck-CFL-relations \nD on bidirected trees and graphs, which has not been fully utilized in previous work. Since trees are \nsimply graphs without cycles, we use the more general term graph to illustrate the equivalence property. \nA binary relation ~. B \u00d7B on a set B is an equivalence relation iff it is re.exive, symmetric and transitive. \nSpeci.cally, ~ is re.exive if .a . B, a ~ a;  ~ is symmetric if .a, b . B, a ~ b =. b ~ a;and  ~ is \ntransitive if .a, b, c . B, a ~ b . b ~ c =. a ~ c.  For a given bidirected graph G =(V, E), we consider \nthe Dyck-CFL-relation D over V \u00d7 V . Based on the de.nition of relation D, node v . V is Dyck-reachable \nfrom node u . V iff (u, v) . D. We list below the properties of relation D on bidirected graphs: Relation \nD is re.exive: This is because the start symbol S in the Dyck grammar is nullable (i.e., it generates \nthe empty string e). Therefore, (u, u) . D for all u . V .  Relation D is symmetric: One can identify \na symmetric relation by showing it is equal to its inverse. For the bidirected graphs, the realized string \nR(p) on a path p from node u to v is the  ' reverse of R(p) on the reverse path p' from v to u. It is \neasy ' to show R(p) is generated by the Dyck grammar iff R(p) is generated by the Dyck grammar with a \nsimple induction on the path length. As a result, if v is Dyck-reachable from u (i.e., (u, v) . D), u \nis also Dyck-reachable from v (i.e., (v, u) . D). Relation D is transitive: That is, for any three nodes \nu, v, w . V in graph G =(V, E),if v is Dyck-reachable from u (i.e., (u, v) . D)and w is Dyck-reachable \nfrom v (i.e., (v, w) . D), w is Dyck-reachable from u (i.e., (u, w) . D). It is immediate that the realized \nstring R(p1) for any path p1 connecting node u and v can be derived from the start symbol S in the Dyck \ngrammar. Similarly, the realized string R(p2) for any path p2 connecting nodes v and w is also generated \nfrom the Dyck grammar. Consequently, the concatenated string R(p1)R(p2) is generated by the Dyck grammar \nbecause of the rule S . SS. Hence, the path p1p2 from node u to w is also a Dyck-path. The discussions \nabove lead to the following lemma. LEMMA 1. The Dyck-CFL-relation D on a bidirected graph is an equivalence \nrelation. The key insight in our algorithms is that the equivalence prop\u00aderty can be exploited to obtain \nasymptotically much faster algo\u00adrithms. All nodes in the Dyck-CFL-relation D are equal to the other nodes \nin the graph, and thus nodes that belong to the same equiva\u00adlence class can be safely collapsed to a \nsingle representative node. For example, in Figure 1(b), node 3 is Dyck-reachable from 1, thus, they \ncan be collapsed into a single representative node {1, 3} indi\u00adcating that they are in the same equivalence \nclass. Similarly, node 5 can be collapsed to the representative node {1, 3} as well. Finally, we have \na representative node {1, 3, 5} re.ecting the fact that the three nodes are Dyck-reachable from each \nother in the graph.  3.2 A Na\u00a8ive Approach We proceed to give a na\u00a8ive all-pairs Dyck-CFL-reachability \nalgo\u00adrithm by collapsing the nodes in the graph that are in the Dyck\u00adCFL-relation D.Let ai(u, v) denote \nthe directed edge (u, v) labeled by ai . A. We note that while collapsing two Dyck\u00adreachable nodes x \nand y in the graph, there always exists a node z such that ai(x, z) = ai(y, z). For example, in Figure \n1(b), we have a1(1, 2) = a1(3, 2). Without loss of generality, given a bidi\u00adrected graph G(V, E), the \nna\u00a8ive algorithm can work on a directed graph G ' (V ' ,E ' ) by removing all edges labeled by closing \nparen\u00adtheses from the original graph, i.e., V ' = V and ai(u, v). E ' iff ai(u, v). E for all labeled \nedges in E '. The basic idea of the na\u00a8ive approach is to explicitly maintain a list W of nodes. For \nevery item z popped from W , we pick two incoming neighbors x and y whose edges are labeled by the same \nopening parenthesis i.e., .ai(x, z) = ai(y, z), and then collapse x and y since they are Dyck-reachable \nvia z. Due to the collapsing between nodes, E ' may possibly contain multiple edges. The whole algorithm \ntermi\u00adnates if W is empty.  The na\u00a8ive algorithm is given in Algorithm 2, where Eq nodes[v] denotes \nthe equivalence set of node v and Set[v] denotes the equivalence set number that node v belongs to. The \nprocedure HAS-SAME-IN(v) traverses all incoming neighbors of node v, and returns true if there exist \ntwo neighbors u1 and u2 such that ai(u1,v) = ai(u2,v). In Algorithm 2, line 1 transforms the given graph \nG to G ', and lines 2-5 initialize W and Eq nodes[v]. Lines 10-26 collapse node y to x w.r.t. node z, \nand remove y.The detailed procedure on collapsing y to x is given in Section 5.1.1. Finally, lines 29-31 \nassign the equivalence set number to each node v, such that any query can be answered in O(1) time. Complexity \nAnalysis. The time complexity of the na\u00a8ive algo\u00adrithm is O(kn2). We begin by analyzing the maximum number \nof steps that the while loop on line 6 can be executed. We note that Algorithm 2 adds items to W only \nthrough lines 5 and 25. On line 25, item x can be added to W for at most n - 1 times, since line 26 can \nbe executed for at most n - 1 times. On line 5, W is initialized with n items. Therefore, the worklist \nW can be .lled with at most 2n - 1 items by Algorithm 2. In the while loop, only line 28 removes an item \nfrom W , thus, the else part of the if statement can be executed for at most 2n - 1 times. Since the \nthen part of the same if statement can be executed for at most n - 1 times, the while loop can be executed \nfor at most (n - 1) + (2n - 1) = 3n - 2= O(n) times. For each item z popped from W in the while loop, \nlines 8-28 take O(kn) time to process. Speci.cally, the procedure HAS-SAME-IN(v) on lines 8 and 25 takes \nO(kn) time to traverse all neighbors of node v,and the two foreach loops on lines 15 and 16 are bounded \nby |A| = k and |V ' | = n respectively. Therefore, Algorithm 2 takes O(kn2) time. The space complexity \nis O(n + m), since the input graph can be stored using FDLL to be introduced in Section 5.1.2 with O(m) \nspace and the worklist W takes O(n) space. Putting everything to\u00adgether, we have the following theorem: \nTHEOREM 1. Algorithm 2 pre-processes the input graph in O(kn2) time and O(n + m) space to answer any \nonline bidirected Dyck\u00adCFL-reachability query in O(1) time. In the following two sections, we describe \ntwo improved algo\u00adrithms. They share the same insight with the the na\u00a8ive approach, which have better \ntime complexities on bidirected trees and graphs respectively. Speci.cally, our tree algorithm in Section \n4 uses a sin\u00adgle tree walk to .nd all equivalence sets because trees do not con\u00adtain cycles. Our graph \nalgorithm in Section 5 employs improved data structures to track nodes in W and to merge edges on x and \ny. 4. Dyck-CFL-Reachability Algorithm on Bidirected Trees This section presents our algorithm for solving \nthe all-pairs Dyck\u00adCFL-reachability problem on bidirected trees. Its time and space complexities are \nO(n) and O(n) respectively, and it answers any reachability query in O(1) time. We remind the reader \nthat the pre\u00ad 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 Algorithm 2: Ana\u00a8ive Dyck-CFL-reachability \nalgorithm. Input : Edge-labeled directed graph G =(V, E) Output: Set[v] for all v . V 1 transform the \ninput graph G to G ' =(V ' ,E ' ) 2 initialize W to be empty 3 foreach v . V ' do 4 Eq nodes[v] = {v} \n5 if HAS-SAME-IN(v) then add v to W 6 while W = \u00d8 and |V ' | > 1 do let z be the front node from W if \nz . V ' and HAS-SAME-IN(z) then let x, y be two nodes such that .ai(x, z) = ai(y, z)Eq nodes[x]= Eq nodes[y] \n. Eq nodes[x] foreach ai . A do if ai(y, y). E ' then if ai(x, x) ./E ' then add ai(x, x) to E ' remove \nai(y, y) from E ' foreach ai . A do foreach w . V ' do if ai(w, y). E ' then if ai(w, x) ./E ' then add \nai(w, x) to E ' remove ai(w, y) from E ' if ai(y, w). E ' then if ai(x, w) ./E ' then add ai(x, w) to \nE ' remove ai(y, w) from E ' add x to W if x/. W and HAS-SAME-IN(x) remove y from V ' 29 foreach v . \nV ' do 30 foreach u . Eq nodes[v] do 31 Set[u] = v else remove z from W vious best result on bidirected \ntrees [39] has O(n log n log k) time and O(n log n) space complexities. First, we describe a linear\u00adsized \ndata structure to store the all-pairs reachability information. We then show how to utilize the equivalence \nproperty to solve the all-pairs Dyck-CFL-reachability problem using a single walk on trees. 4.1 The \nSTRATIFIED -SETS Representation In our algorithm, the all-pairs Dyck-CFL-reachability information is \nstored in disjoint sets. Two nodes u and v are Dyck-reachable from each other in the tree iff they belong \nto the same set. In other words, each disjoint set C corresponds to an equivalence class described by \nrelation D, i.e., u, v . C iff (u, v) . D.Wenamethe disjoint set representation in our main algorithm \nas STRATIFIED -SETS. The STRATIFIED -SETS consist of several disjoint sets spanning over different layers. \nEach disjoint set stores the nodes that are Dyck-reachable from each other in the bidirected tree. The \nlayers are indexed by an integer i. Note that the layer information is only used for providing a better \nexplanation. The layer index i grows downward, i.e., layer i is the upper layer in any two adjacent layers \ni and i +1. The disjoint sets on the same layer i have no edges directly connecting each other. For any \ntwo adjacent layers i and i +1, there exists at least one edge connecting two disjoint sets C from layer \ni and C ' from layer i +1. Specially, the connecting edge is labeled by L(u, v) . A, respecting the fact \nthat there exist u . C and v . C ' such that (u, v) is a directed edge in the tree with the same label \nL(u, v) . A. Note that there can be at most k edges connecting the set C ' with the distinct sets from \nthe upper layer i. However, more than k edges are possible for connecting the set C with the distinct \nsets from the lower layer i +1. Figure 2(b) shows an example STRATIFIED -SETS representation, where there \nare seven sets spanning four layers.  The STRATIFIED -SETS representation is implemented using three \ningredients: one integer variable curset, two integer arrays Set[v]and Up[Set[v]][ai]. Set[v] records \nthe equivalence set num\u00adber that node v belongs to, and Up[Set[v]][ai] stores the equiva\u00adlence set number \nof the set from the upper layer that is connected to Set[v] w.r.t. the edge labeled by the opening parenthesis \nai . A. The STRATIFIED -SETS uses the integer variable curset to keep track of the current total number \nof disjoint sets. Due to the Up array, the tree algorithm does not need the layer information ex\u00adplicitly. \nThe STRATIFIED -SETS implementation also permits three operations: Init(v), Find(v)and Add(v, e) described \nin Proce\u00addure 3. The functioning of procedures Init(v)and Find(v)isfairly straightforward. The procedure \nInit(v) takes a node v as input, assigns it to a new set indexed by curset in STRATIFIED -SETS, and increases \nthe curset count. Find(v) returns the equivalence set number that node v belongs to. We detail the description \nof procedure Add(v, e) to illustrate the idea of collapsing nodes in relation D.Weuse Add(v, e)to insert \nthe node v to the STRATIFIED -SETS with regard to the edge e =(u, v) and the edge label L(u, v) in the \ntree. Node v is added to STRATIFIED -SETS by either assigning it to an new set (lines 3 and 9) or collapsing \nit to an existing set (line 13). Consider the example input tree in Figure 2(a), node 3 and edge (2, \n3) are processed by Add(v, e). The resulting STRATIFIED -SETS is in Figure 2(b). Node 3 is assigned to \na new set on layer 3.The new set is then linked with the set containing node 2 on layer 2 respecting \nthe fact that L(2, 3) = a1. Then, node 4 and edge (3, 4) are processed. Node 4 is collapsed to the set \non layer 2 that contains node 2 respecting the facts that L(3, 4) = a\u00af1 and node 4 is Dyck\u00adreachable \nfrom node 2 (i.e., (2, 4) . D). Formally, if the edge label L(u, v) in the tree is an opening parenthesis \nai . A, v is assigned to a new set indexed by curset in STRATIFIED -SETS.This new set is then linked \nwith the set returned by Find(u) on the upper layer as described by lines 2-5 . If the edge label is \na closing parenthesis \u00af a\u00afi . A, we simply collapse node v to the equivalence set that is connected via \na matched opening parenthesis ai . A from u s upper layer. The equivalence set is indexed by Up[Find(u)][ai]as \ndescribed by line 13. Lines 9-11 indicate that, for node u whose link node does not exist, we assign \nnode v to a new set indexed by curset and link the set returned by Find(u) to the new set from the upper \nlayer. Note that the Up array used in Procedure 3 is indeed a map: (Num . A) . Num,where Num denotes \nthe domain of the set numbers. For each set in STRATIFIED -SETS, line 8 in Procedure 3 needs to .nd a \nparticular edge ai from O(k) link edges in Up[s], where s . Num. The time taken to search such O(k) edges \ndepends on the actual implementation of the Up array. For example, if the Up array stores such O(k) edges \nfor each set s using a binary search tree, the lookup for an ai edge in Up[s] takes O(log k) time as \nmentioned in Yuan and Eugster s work [39]. In our algorithm, we implement the Up array using the FDLL \ndata structure illustrated as Example 3 in Section 5.1.2, thus a lookup takes expected O(1) time. The \nspace required is O(m) since there are m edges in a tree, Procedure 3: Add(v, e) to add a node v to STRATIFIED \n-SETS according to the directed edge e =(u, v). 1 if L(u, v) . A then 2 let ai = L(u, v) 3 Set[v] = curset \n4 Up[curset][ai] = Find (u) 5 curset ++ \u00af 6 if L(u, v) . A then 7 let \u00afai = L(u, v) 8 if Up[Find(u)][ai] \ndoes not exist then 9 Set[v] = curset 10 Up[Find(u)][ai] = curset 11 curset ++ 12 else 13 Set[v] = Up[Find(u)][ai] \n where m = n - 1. Therefore, the time complexity of Procedure 3 is O(1), and the space complexity of \nthe Up array is O(n).  4.2 Main Algorithm This section presents the main algorithm. The key idea is \nto operate on the linear-sized STRATIFIED -SETS data structure to build the all-pairs Dyck-CFL-reachability \ninformation during a single tree walk. The goal of our algorithm is to assign nodes u and v to the same \nset in STRATIFIED -SETS,for all (u, v) . D. The overall algorithm takes two steps: (1) Initializing \na leaf node: In this step, we pick an arbitrary leaf node v from the tree and invoke the Init(v) procedure \nto ini\u00adtialize the given node v. (2) Processing each encountered edge: For each edge (u, v) with label \nL(u, v) encountered during the tree walk, we process the edge w.r.t. the edge label and insert the node \nv to STRATIFIED -SETS according to the Add(v, e) procedure.  The complete algorithm is shown as Algorithm \n4. In the main algorithm, lines 1-6 initialize the relevant data structures, and lines 7-14 describe \na standard depth-.rst search (DFS) starting at node v. For a given bidirected tree T =(V, E) with n nodes, \nDFS takes O(n) time. For every node v,the Add(v, e) procedure takes O(1) time. The space required by \nAlgorithm 4 depends on the STRATIFIED -SETS representation, which is essentially imple\u00admented using the \nUp array. Therefore, the space complexity is O(n). EXAMPLE 2. We consider the bidirected tree in Figure \n2(a), where reverse edges are omitted for brevity. Algorithm 4 outputs the STRATIFIED -SETS in Figure \n2(b). The STRATIFIED -SETS repre\u00adsentation contains seven disjoint sets: {1, 5, 7, 8, 11, 12}, {2, 4}, \n{6}, {9}, {10}, {3} and {13}. The nodes in the same set are Dyck-reachable from each other in the tree. \nNote that the layer information is only used for providing a better explanation. Algo\u00adrithm 4 uses the \nUp array for .nding a set from the upper layer in STRATIFIED -SETS. After constructing the STRATIFIED \n-SETS, any Dyck-CFL\u00adreachability query (u, v) can be answered in O(1) time by sim\u00adply checking whether \nthe indices returned by Find(u)and Find(v) are the same. Putting everything together, we have the following \ntheorem.   Layer 0 a1 a3 a1 Layer 1 a1 a2 a1 a1 Layer 2 a1 Layer 3  (a) Input tree. (b) STRATIFIED \n-SETS representation. Figure 2. A running example for Dyck-CFL-reachability on trees. Algorithm 4: Dyck-CFL-reachability \nalgorithm on trees. Input : Edge-labeled bidirected tree T =(V, E) Output:the STRATIFIED -SETS 1 initialize \nthe Up arraytobeempty 2 foreach v . V do 3 visited[v] =false 4 Set[v] =0 5 stack.push(a leaf node v) \n6 curset =0 7 Init (v) 8 while stack is not empty do 9 v = stack.pop 10 if not visited[v] then 11 visited[v] \n=true 12 foreach unvisited neighbor u of v do 13 stack.push(u) 14 Add (u, e(v, u)) THEOREM 2. The bidirected \nDyck-CFL-reachability problem on trees can be pre-processed in O(n) time and O(n) space to answer any \nonline query in O(1) time. 5. Dyck-CFL-Reachability Algorithm on Bidirected Graphs In this section, we \nstudy the Dyck-CFL-reachability problems on bidirected graphs. Computing Dyck-CFL-reachability on graphs \nis harder than that on trees because graphs may contain cycles. Consequently, the algorithm introduced \nin Section 4 based on the STRATIFIED -SETS representation cannot be directly applied to graphs. Although \nDyck-CFL-reachability on bidirected graphs is more complicated, the Dyck-CFL-relation D shares the same \nequiva\u00adlence properties as for trees. For bidirected graphs, we utilize the idea of edge merging to collapse \nthe node pairs (u, v) . D.For a bidirected graph with n nodes and 2m edges, our algorithm pro\u00adcesses \nthe given graph in O(n + m log m) time with O(n + m) space, and can answer any Dyck-CFL-reachability \nquery over any pair of nodes (u, v) in O(1) time. 5.1 Basic Idea As the na\u00a8ive approach, given a bidirected \ngraph G(V, E), our algo\u00adrithm works on the same directed graph G ' (V ' ,E ' ) by removing all edges \nlabeled by closing parentheses from the original graph, a1 a1 a\u00af1 a\u00af1 a1 a\u00af1 (a) a\u00af1 a\u00af1 a1 a1 a\u00af1 a1 \na1 a1 a1 a1 a1 a1 (b) a1 a1 (c) (d) a1 a1 a1 a1 a1  Figure 3. A Dyck-path example. i.e., V ' = V and \nai(u, v). E ' iff ai(u, v). E for all labeled edges in E '. Therefore, G ' has n nodes and m edges. The \nkey idea behind our algorithm is to collapse any node pair (u, v) connected by a Dyck-path in the graph \nbecause such pairs (u, v) are in the Dyck-CFL-relation D. As in the na\u00a8ive approach, E ' may possibly \ncontain multiple edges due to the collapsing between nodes. To make the above idea more concrete, we \nconsider the example in Figure 3. Figure 3(a) shows the original path in G which contains two non-trivial \nsets of nodes that are Dyck-reachable from each other: {1, 5, 7} and {2, 4}. Figure 3(b) shows the corresponding \nreduced path in G '. In such directed cases, node 5 is connected to node 7 via node 6,and a1(5, 6) = \na1(7, 6). Since nodes 5 and 7 are Dyck-reachable from each other, the two edges a1(5, 6) and a1(7, 6) \nshould be merged to collapse nodes 5 and 7 into a single representative node {5, 7} in Figure 3(c). We \nde.ne a node like node 6 to be the merging node. Formally, we have the following de.nition. DEFINITION \n3 (Merging Node). If a node v . V has at least two incoming edges labeled by ai . A, we say node v merges \nai edges. We de.ne a node as a merging node iff it merges some ai . A edges. Like the na\u00a8ive algorithm \nin Algorithm 2, our main algorithm ful.lls the following two tasks: (1) Merge edges for each merging \nnode: For any merging node in the graph G ', the algorithm .nds the incoming nodes with the same labeled \nedges, and merges the two edges to collapse the nodes. In the path in Figure 3(b), nodes 3 and 6 are \ntwo merging nodes. The relevant incoming edges should be merged. (2) Track the new merging nodes: During \nedge merging, new merg\u00ading nodes can be introduced into the graph G '. The algorithm tracks all new merging \nnodes in order to perform another edge merging. For the same example in Figure 3(c), collapsing nodes \n2 and 4 generates a new representative node {2, 4},which is also a merging node. Its corresponding edges \nshould also be merged. The .nal output is shown in Figure 3(d).  In the na\u00a8ive approach, nodes x and \ny are arbitrarily picked on line 9. Merging edges from y to x by enumerating all neighbors of y exhaustively \ntakes O(kn) time. Moreover, node tracking is achieved by simply traversing all neighbors of node z on \nline 8, which takes O(kn) time as well. When the given graph is sparse, we can use additional data structures \nto improve the two tasks of merging edges and tracking nodes. Next, we describe them in detail. 5.1.1 \nMerging Edges For the directed graph G ', edge merging in G ' picks a merging node z that has two incoming \nedges (x, z) and (y, z) with ai(x, z) =  (a) Before edge (b) Collapsing (c) Collapsing (d) After edge \nmerging. self loops. all neighbors. merging. Figure 4. Steps in edge merging. Hash Map Doubly-Linked \nList Figure 5. The illustration of the FDLL data structure. ai(y, z), and collapses nodes x and y. Speci.cally, \nif we choose to merge edge (y, z) to edge (x, z), all edges connecting y and its neighbor w should be \ndeleted from G ' . Node w is made a neighbor of x by inserting the relevant edges to G '. Finally, node \ny is removed from G ', because it has been collapsed to x. The order of edge merging is important. The \nna\u00a8ive method in Algorithm 2 performs edge merging by collapsing nodes x and y arbitrarily with regard \nto the merging node z. If one adopts this approach, the time complexity can be O(kn2). When the graphs \nare sparse, it is possible to do edge merging faster. To this end, we employ a technique that is similar \nto the weighted-union heuristic (also known as the union-by-size heuristic) used in the disjoint sets \ndata structures [9]. Namely, for each edge merging operation, we always collapse the node with a smaller \ndegree to the node with a larger degree. Our new method bounds the total numbers of edge merging for \neach edge to O(log m). We provide a detailed complexity analysis in Section 5.3. Taking the na\u00a8ive approach \nin Algorithm 2 as an example, we discuss the process of edge merging. Speci.cally, our handling of edge \nmerging from node y to node x has three phases, as illus\u00adtrated in Figure 4. We assume that the degree \nof node x is larger than that of y, and all irrelevant edges are omitted in Figure 4. Fig\u00adure 4(a) shows \nthe original graph before edge merging. Figure 4(b) illustrates the handling in the .rst phase. If y \nhas a self loop, the self loop is removed and added to x if x does not already have one (lines 11-14 \nin Algorithm 2). Second, we consider all neighbors of node y. As in Figure 4(c), for all shared neighbors \nz of x and y, those edges between z and y are removed; for those neighbors w that only belong to y, new \nedges between w and x are inserted (lines 15-24 in Algorithm 2). Finally, Figure 4(d) shows that node \ny is removed from the graph and degrees for relevant nodes in edge merging are updated.  5.1.2 Tracking \nNodes During edge merging, the in-degrees of merging nodes may change. We need to explicitly maintain \na list of merging nodes whose in\u00addegrees w.r.t. an opening parenthesis are at least 2. This section describes \nthe design of our data structure to effectively maintain this information. In the na\u00a8ive algorithm, tracking \nnodes is achieved using a work\u00adlist W , which is typically implemented using a list. In our improved \nalgorithm, we uses a doubly-linked list (DLL) and a hash map. We name the data structure FAST-DOUBLY-LINKED-LIST \n(FDLL). It is important to note that traditional list W used by the na\u00a8ive ap\u00adproach on line 25 takes \nO(n) time to .nd an element while FDLL takes expected O(1) time. Figure 5 depicts an example FDLL. All \nelements in the FDLL are stored using a DLL and a hash map. The hash map associates each element with \nits position in the DLL, represented by arrows in Figure 5, to help quickly locate every el\u00adement in \nthe DLL. The insertion and pop operations on FDLL are nearly identical to DLL (or list), both of which \ntake O(1) time. Moreover, the FDLL supports two additional operations in expected O(1) time: Query: \nQuerying the membership of a particular element in FDLL is the same as querying the relevant membership \nin the hash map, which can be done in expected O(1) time.  Deletion: According to the hash map, the \nposition of the ele\u00adment to be deleted can be found in expected O(1) time. Thus removing the element \nat the speci.ed position in the DLL can also be done in O(1) time. Finally, the hash map entry associ\u00adated \nwith that element is erased in O(1) time.  EXAMPLE 3. In the tree algorithm, the Up array can be imple\u00admented \nusing FDLL to support the expected O(1) time lookup. Re\u00adcall that the Up array is indeed a map: (Num \n. A) . Num.For each set s . Num,weusean FDLL A[s] to store the set of opening parentheses ai, such that \nthere exists an ai labeled edge connecting set s and the set from the upper layer. For each ai . A[s],weuse \nanother FDLL U[s i] to store the corresponding set from the upper layer. For example, to look up an edge \na3 of set 2, we query whether a3 . A[2].Ifsuchan a3 exists, U[2 3] keeps the corresponding set number. \nThe two lookups both take expected O(1) time.  5.2 Main Algorithm We now present our algorithm solving \nbidirected Dyck-CFL\u00adreachability on graphs in Algorithm 5, combining the ideas of merging edges and tracking \nnodes. Before delving into the main algorithm, we .rst illustrate the use of FDLL in our main algorithm. \nFor each node v in the input graph G ' =(V ' ,E ' ), the set of opening parentheses of v s incoming edges \nis represented using an FDLL, denoted as Ain[v]. For each ai . Ain[v],weuse theFDLL In[v i] to store \nall v s incoming neighbors. We denote the size of In[v i] as In[v i].size(). Node v merges edge ai iff \nIn[v i].size() > 1.Werepresent Out[v i] and Aout[v] similarly. Finally, the worklist FDLLw is also repre\u00adsented \nusing an FDLL. Algorithm 5 uses the array D [v] to represent the total degree of node v, which is initialized \nto v s degree in the original graph. Notations eq nodes[v] and Set[v] are de.ned in the same way as the \nna\u00a8ive approach. The functioning of the algorithm proceeds as follows. On line 1, the original bidirected \ngraph G is pre-processed to obtain the directed graph G ' =(V ' ,E ' ).Fromlines2-5,the equivalence set \nEq nodes[v] is initialized with node v and the FDLLw is initialized with v i indicating node v merges \nai.The FDLLw in the main algorithm is used to implement the idea of node tracking. The main algorithm \nthen proceeds to handle edge merging as follows: Lines 7-11: The algorithm pops one z i from the FDLLw, \nthen chooses its two neighbors x and y for edge merging. Speci.cally, node y with a smaller total degree \nis collapsed to node x with a larger total degree.  Lines 12-18: The self loop on node y is handled \nas described in Figure 4(b). During edge merging, if a node v becomes a non\u00admerging node for ai (i.e., \nIn[v i].size() < 2), v i is removed from the FDLLw. Similarly, when node v becomes a merging node that \nmerges ai edges, v i is inserted to the FDLLw.Note      (c) (a) (b)  (d) (e)  Figure 6. A running \nexample for bidirected Dyck-CFL\u00adreachability on graphs. that when an edge is inserted/removed from E \n',all of In[v i], Ain[v], Out[v i] and Aout[v] need to be updated accordingly. Lines 19-31: All incoming \nand outgoing neighbors of y are handled as described in Figure 4(c). The update on FDLLw for merging \nnodes is similar to the handling of self loop.  Line 32: Node y is removed from V '. Note that we do \nnot need to remove z i because it was once w i.  The edge merging ends when the FDLLw is empty, i.e.,there \nare no merging nodes in the .nal graph. Lines 33-35 indicate that all nodes u in the equivalence set \nEq nodes[v] are enumerated to associate Set[u] with v. After the main algorithm terminates, Set[v] stores \nthe equiva\u00adlence set number that node v belongs to. Similar to the tree case, any Dyck-CFL-reachability \nquery (u, v) can be answered in O(1) time by simply checking the equivalence set numbers of nodes u and \nv. EXAMPLE 4. Figure 6 shows an example. All edges are labeled by \u00af a1 . A. The original edges labeled \nby a\u00af1 . A are removed .rst. Nodes 3 and 5 are two merging nodes. In the .rst iteration, nodes 2 and \n4 are collapsed by edge merging. Then node 6 is collapsed as well. Finally, node 1 is collapsed due to \nits self loop in the graph. In the .nal graph, all of the nodes in the original graph are distributed \ninto two disjoint sets.  5.3 Algorithm Correctness and Complexity Analysis This section discusses the \ncorrectness and complexity of our pro\u00adposed algorithm. First, we establish its correctness. THEOREM 3 \n(Correctness). Algorithm 5 correctly .nds all Dyck\u00adpaths in the input graph. Proof. It is clear that \nany Dyck-path reported by Algorithm 5 is indeed a Dyck-path due to the observed equivalence property \n(Lemma 1). Thus, our proof focuses on the other direction, that is Algorithm 5 .nds all Dyck-paths in \nthe input graph. Any trivial Dyck-path generated by rule S . e is handled correctly, because every node \nv in the graph is marked as Dyck\u00adreachable from itself due to line 3 in Algorithm 5. Dyck grammar essentially \ngenerates the properly matched parentheses. Therefore, the length of any non-trivial Dyck-path in the \ngraph is even. We prove by induction on the length |p| of any non-trivial Dyck-path. Base case. |p| =2. \nLet the Dyck-path be p = v1v2v3, with the realized string R(p)= L(v1,v2)L(v2,v3)= aia\u00afi. Because the \ngraph is bidirected, we have L(v3,v2)= L(v1,v2)= ai. Nodes v1 and v3 are collapsed due to the merging \nnode v2. Inductive step. Suppose Algorithm 5 correctly .nds all non-trivial Dyck-paths of length |p| \nin the graph. According to the Dyck grammar, any non-trivial Dyck-path of length |p| +2 is gener\u00ad ated \nby the following two rules: S . aiSa\u00afi indicates that the new S-path is generated by prepending an open \nparenthesis and appending by a match- Algorithm 5: Dyck-CFL-reachability algorithm on graphs. Input : \nEdge-labeled bidirected graph G =(V, E) Output: Set[v] for all v . V 1 transform the input graph G to \nG ' =(V ' ,E ' ) 2 foreach v . V ' do 3 4 Eq nodes[v] = {v}foreach ai . Ain[v] do 5 add v i to FDLLw \nif In[v i].size() > 1 6 while FDLLw = \u00d8 do 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 \n27 28 29 30 31 32 33 34 35 let z i be the front item from FDLLw let x and y be two front nodes from In[z \ni] let x denote the node such that D [x] . D [y] D [x]= D [x]+ D [y] Eq nodes[x]= Eq nodes[y] . Eq nodes[x] \nforeach ai . Ain[y] do if ai(y, y). E ' then if ai(x, x) ./E ' then add ai(x, x) to E ' add x i to FDLLw \nif x i/. FDLLw and In[x i].size() > 1 remove ai(y, y) from E ' remove y i from FDLLw if y i . FDLLw and \nIn[y i].size() < 2 foreach ai . Ain[y] do foreach w . In[y i] do if ai(w, x) ./E ' then add ai(w, x) \nto E ' add x i to FDLLw if x i/. FDLLw and In[x i].size() > 1 remove ai(w, y) from E ' remove y i from \nFDLLw if y i . FDLLw and In[y i].size() < 2 foreach ai . Aout[y] do foreach w . Out[y i] do if ai(x, \nw) ./E ' then add ai(x, w) to E ' remove ai(y, w) from E ' remove w i from FDLLw if w i . FDLLw and In[w \ni].size() < 2 remove y from V ' foreach v . V ' do foreach u . Eq nodes[v] do Set[u] = v ing closing \nparenthesis. Let the path be p = v1v2 ...v3v4, where L(v1,v2)= ai and L(v3,v4)= a\u00afi.The realized string \nR(v2 ...v3)= S indicates that nodes v2 and v3 are Dyck-reachable, where the Dyck-path joining v2 and \nv3 is of length |p|. According to the induction hypothesis, they have been collapsed into a single representative \nnode. Such a node is the merging node for v1 and v4. Thus, v1 and v4 are collapsed according to Algorithm \n5. S . SS indicates that the new S-path is composed of two S-paths. Let the path be p = v1 ...v2 ...v3,where \nR(v1 ...v2)= R(v2 ...v3)= S. Note that the length of any non-trivial Dyck-path is at least 2. Since the \nnew S\u00adpath is of length |p| +2, the lengths of both path v1,...,v2 and path v2,...,v3 are less than or \nequal to |p|. According to the induction hypothesis, both v1,v2 and v2,v3 are col\u00adlapsed into a single \nrepresentative node. As a result, v1 and v3 are collapsed into the same representation node as well. \n D Next we analyze the complexity of Algorithm 5. Note that the total degree D [v] used in our algorithm \nis different from the degree D[v] of node v respecting the fact that the total degree D [v] admits duplicated \nedges. For example, in Figure 4(c), D [x]=4 + 2=6, but D[x]=5, because edge (y, z) is duplicated with \n(x, z) accord\u00ading to the .nal representative node {x, y} in Figure 4(d). Therefore, the total degree \nD [v] never decreases during edge merging. Our al\u00adgorithm processes the merging node z and collapses \nits neighbor y with a smaller D [y] to node x with a larger D [x]. Nodes y and x are collapsed into a \nsingle representative node {x, y}. As a result, the total degree of y after merging is the same as the \ntotal degree of x according to line 10, namely, D [x]= D [x]+ D [y]. On line 9, we have D [x] ? D [y]. \nCombining the analysis of the two lines, the following lemma is immediate: LEMMA 2. For each edge merging \nin Algorithm 5, D [y] is dou\u00adbled. Let m denote the number of edges in graph G ' , i.e., 2m = v.V D[v]. \nDue to the duplicated edges, D[v] may decrease dur\u00ading edge merging. Similarly, m denotes the total number \nof edges in graph G ' w.r.t. D [v] that admits duplicated edges, i.e., m = v.V D [v]. For each edge (x, \nz) in graph G ', we say it is moved if either the total degree D [x] or D [z] is doubled according to \nLemma 2. For all v . V ,wehave D [v] . m . 2m, because in the worst case, all nodes are collapsed into \na single represen\u00adtative node (with m duplicated edges) in the .nal graph. Com\u00adbined with Lemma 2, an \nedge is moved at most (log D [x]+ log D [z] . 2 log 2m) times. The while loop on line 6 in Al\u00adgorithm \n5 takes time proportional to the number of times that an edge is moved . Therefore, the total running \ntime for the while loop is O(m log m). For lines 33-35, it takes O(n) time to enumer\u00adate all nodes u \nin the equivalence set Eq nodes[v] and to associate Set[u] with v. Therefore, the time complexity of \nour algorithm is O(n + m log m). At the beginning, each node is associated with two FDLLs In[v i] and \nOut[v i]. In each iteration of edge merg\u00ading, there is one node removed from G ', decreasing the number \nof edges m in G '. As a result, O(n + m) space is required for pro\u00adcessing the graph. Putting all these \ntogether, we have the following theorem: THEOREM 4. Algorithm 5 pre-processes the input graph in O(n \n+ m log m) time and O(n + m) space to answer any online bidi\u00adrected Dyck-CFL-reachability query in O(1) \ntime. In practice, since the graphs in client analyses are typically sparse, Algorithm 5 performs in \nO(n log n) time. When the graphs are dense, we can use the na\u00a8ive approach in Algorithm 2 for pre\u00adprocessing. \nAs a result, we have the following theorem: THEOREM 5. The bidirected Dyck-CFL-reachability problem on \ngraphs can be pre-processed in O(min{kn2 ,n + m log m}) time and O(n + m) space to answer any online \nquery in O(1) time. 6. Application: Scaling an Alias Analysis for Java This section describes a practical \napplication of our results in speeding up an alias analysis for Java [37]. The goal of alias anal\u00adysis \nis to determine if two pointer variables can point to the same memory location during program execution. \nThe aliasing infor\u00admation obtained by an alias analysis is a prerequisite for many compiler optimizations \nand static analysis tools (e.g., software ver\u00adi.ers [10], data race detectors [23], and static slicers \n[18]). Many state-of-the-art alias analyses [31, 36, 37, 40] are for\u00admulated using CFL-reachability. \nDyck-CFL-reachability plays an important role in these analyses. For instance, it has been used to model \nthe matched references and dereferences in C [40], and has also been employed to describe the .eld loads \nand stores in Java [36, 37] to capture the balanced-parentheses property ob\u00adserved by Sridharan et al. \n[33]. Yuan and Eugster s recent work [39] further shows that Dyck-CFL-reachability on bidirected trees \ncan be used to solve a simpli.ed context-insensitive pointers-to analy\u00adsis problem. To demonstrate the \npractical applicability of our results, we leverage a recent demand-driven context-sensitive alias analy\u00adsis \nfor Java [37] formulated using CFL-reachability. Dyck-CFL\u00adreachability is used to formulate its context-insensitive \nvariant. The analysis is demand-driven in the sense that it solves the single\u00adsource-single-target Dyck-CFL-reachability \nproblem. We show that our fast algorithms for all-pairs Dyck-CFL-reachability ap\u00adplies directly to this \ncontext-insensitive alias analysis. 6.1 Symbolic Points-to Graph The underlying graph representation \nof the alias analysis is called the Symbolic Points-to Graph (SPG) [36, 37]. It extends the locally\u00adresolved \npoints-to graph representation [33] by introducing addi\u00adtional symbolic nodes as placeholders for abstract \nheap objects. The SPG contains three kinds of nodes: variable nodes v .V representing variables, allocation \nnodes o .O representing allo\u00adcations for new expressions, and symbolic nodes s .S representing abstract \nheap objects. It also consists of the following three types of edges: edges v . oi .V \u00d7 O to represent \nthat variable v points to object oi;  edges v . si .V \u00d7 S to represent that variable v points to an \nabstract heap object.  f edges oi -. oj . (O. S ) \u00d7 Fields \u00d7 (O. S ) to represent that .eld f of oi \npoints to oj . A Java program s SPG is constructed in three steps. First, sym\u00adbolic nodes are introduced \nfor each procedure parameter, method invocation and .eld access. Second, the set of abstract heap loca\u00adtions \nO. S that a variable may point to1 is computed. The rele\u00advant points-to edges are inserted to the SPG. \nThird, the .eld access f edges oi -. oj are added with regard to .eld loads and stores. The f\u00af SPG also \nincludes the barred edges (i.e. oj -. oi edges) implicitly.  6.2 Context-Insensitive Alias Analysis \nThe context-insensitive alias analysis computes the aliasing relation over variables within a method. \nIn the analysis, the method invoca\u00adtion edges (i.e., entry and exit edges) are of no interest. Speci.cally, \nthe memory aliasing between the allocation or symbolic nodes that variable nodes x and y may points-to \nindicates the aliasing rela\u00adtion between x and y. The memory alias relation de.ned in [37] over (O. S \n) \u00d7 (O. S ) is described by the following context-free 1 In the original work that using SPG [36, 37], \nthe .owsTo edges are used. A .owsTo edge is obtained on the .ow graph by computing a regular language \nreachability. An abstract heap object .owsTo a variable if it is in the points\u00adto set of that variable. \n x = w.f; w.f=y; u = x.g; v = y.g; u   v v = w.g; g (a) A code snippet. (b) Its SPG. Figure 7. An \nexample of alias analysis with the SPG. grammar: \u00af \u00af memAlias . f1 memAlias f1 | ... | fk memAlias fk \n| memAlias memAlias | e Note that the alias analysis based on memAlias reachability is a simpli.cation \nof the alias reachability presented by Sridha\u00adran et al. [32, 33]. The .eld edges between abstract symbolic \nnodes in an SPG approximate the .eld loads and stores in the .ow graph [32, 33]. The approximation may \nlead spurious aliasing as detailed by Xu et al. [36, Section 4]. However, the experimental results show \nthat the overall performance is better than that pro\u00adposed by Sridharan et al. [32, 33] in practice. \nThe precision loss is insigni.cant enough compared to the performance gains. EXAMPLE 5. Consider the \nexample in Figure 7. The Java code snippet (left) and its SPG (right) are shown. In the SPG, the boxes \ndenote symbolic nodes, and the circles denote variable nodes. The reverse edges (a.k.a. barred edges) \nare omitted for brevity. Note that the Dyck-CFL-reachability formulation used in the client alias analysis \nrepresents the barred edges as the opening parentheses. There are two pairs of memAlias nodes: (x, y) \nand (u, v), because \u00af the realized strings of the two joining paths are ff\u00af and g\u00afffg respectively, \nwhich can be generated from the memAlias grammar. However, the node pair (x, v) is not memAlias because \nthe realized strings of two possible joining paths are \u00afffg , such fg and \u00afthat the parentheses along \nthe paths are not properly matched.  6.3 Applying Our Fast Algorithms Since the CFL used to describe \nthe context-insensitive memory aliasing is a Dyck-CFL with k kinds of parentheses, the two Dyck\u00adCFL-reachability \nalgorithms presented in this paper can be directly applied. Note also that this alias analysis is demand-driven \nin the sense that the original algorithm solves the single-source\u00adsingle-target Dyck-CFL-reachability \nproblem, because solving all-pairs reachability is considered computationally much more expensive in \nthese analyses. Both our algorithms are intended to solve the all-pairs Dyck-CFL-reachability problem. \nNext, we show how our all-pairs algorithm performs in practice. 7. Empirical Evaluation In this section, \nwe compare the traditional CFL-reachability algo\u00adrithm with our proposed algorithm for solving the all-pairs \nDyck\u00adCFL-reachability problem on graphs for standard, real-world Java benchmarks. The input graphs are \ngenerated from the context\u00adinsensitive alias analysis for Java described in Section 6. The re\u00adsults show \nthat our algorithm outperforms the traditional CFL\u00adreachability algorithm by several orders of magnitude. \n7.1 Experimental Setup Benchmark Selection. The benchmark suite used in our evalua\u00adtion is the DaCapo \nsuite [1]. We include the entire DaCapo-2006-10-MR2 suite which consists of 11 benchmarks with .ve additional \nlarge benchmarks form the DaCapo-9.12bach suite. Table 2 de\u00adscribes the benchmarks. For each benchmark, \ncolumns 2 and 3 list the numbers of methods and statements in intermediate representa\u00adtions of the underlying \nanalysis infrastructure, respectively. Graph Collection. We have used the same code as Xu et al. [36] \nand Yan et al. [37] to generate the Symbolic Points-to Graphs (SPGs). The analysis is built on top of \nthe Soot program analysis framework for Java [34]. All benchmarks are processed with the nightly-build \nversion2 of Soot. To measure scalability, we use the latest release of JDK 1.6 (version 1.6u37) as the \nbase analysis library for Soot. The .ve large benchmarks from DaCapo-9.12bach are processed with the \nhelp of Tami.ex [6] for re.ection resolution. Implementation. We implemented the proposed graph algorithm \nto compare with the traditional CFL-reachability algorithm. Both algorithms are implemented in C++ with \nextensive use of the Stan\u00addard Template Library (STL). The FDLL data structure described in Section 5 \nis implemented using STL unordered map and list. The underlying graphs are represented using adjacency \nlists imple\u00admented with FDLL. Our code is compiled using gcc-4.6.3 with the -O2 optimiza\u00adtion .ag. Both \nalgorithms take the same SPG as input. Their outputs are veri.ed to ensure the consistency and correctness \n. All exper\u00adiments are conducted on a Dell Optiplex 780 machine with Intel Core2 Quad Q9650 CPU and 8 \nGB RAM, running Ubuntu-12.04. 7.2 Time and Memory Consumption Table 2 shows the performance comparison \nof the two algorithms over our benchmark set. Column 4 and 5 list the numbers of nodes and edges in each \nSPG respectively. Column 6 lists the aliasing pair counts. Column 7 shows the number of different kinds \nof parentheses (i.e., the size of each Dyck grammar) in each SPG. The remaining columns list the time \nand memory consumption of the traditional CFL-reachability algorithm versus that of our algorithm. We \ndenote our algorithm as FA S T-DYC K. The results indicate that our algorithm signi.cantly improves over \nthe traditional CFL-reachability algorithm. We observe that the running time of our algorithm grows very \nslowly w.r.t. the growth of the number of nodes. For example, the running time of the CFL-reachability \nalgorithm on jython09 is 30 times over that on xalan06 . While, it is only 4 times for our algorithm \non the same benchmarks. We also note that our algorithm consumes less memory than the traditional CFL-reachability \nalgorithm.  7.3 Discussion Understanding the Asymptotic Behavior. The SPGs generated from the benchmarks \nare very sparse there are fewer edges than nodes across all SPGs. This is expected for the client alias \nanalysis and is consistent with the information in the original papers [36, 37]. For sparse graphs with \nm = O(n), the asymptotic complexity of our algorithm is O(n log n). Moreover, in the traditional CFL-reachability \nalgorithm, the grammar rules should be scanned for each iteration for inserting new summary edges. Speci.cally, \nfor the Dyck language of size k, each edge popped from the worklist (line 7) in Algorithm 1 needs to \nbe compared with the O(k) rules in the given grammar. However, in our algorithms, the above is unnecessary. \nIt takes expected O(1) time to .nd a relevant edge labeled by a matched parenthesis in both our tree \nalgorithm and graph algorithm due to the use of the FDLL. Understanding the Memory Consumption. Both \nour algorithm and the traditional CFL-reachability algorithm demand moderate amount of memory for the \nclient alias analysis. The memory cost for representing the input graphs in both algorithm is similar. \nThe 2 As of 2012-10-23.  Benchmark #Methods #Statements #Nodes SPG #Edges #S-pair #para CFL Time FA \nST-DYCK Memory CFL FA ST-DYCK antlr 9904 170402 16735 13878 19385 1087 37.42 0.041 29.68 20.21 bloat \n11818 206857 20320 16224 23080 1197 43.09 0.048 35.09 23.89 chart 25184 448984 44584 36329 50670 2948 \n253.06 0.119 76.75 52.02 eclipse 10447 181101 17527 14411 20335 1182 42.26 0.042 30.97 21.19 fop 23643 \n431569 39977 31515 45837 2724 219.53 0.101 67.99 46.08 hsqldb 9177 156265 15015 12693 17615 998 33.39 \n0.038 27.10 18.22 jython 12802 216068 21615 17381 24487 1240 49.57 0.052 37.20 25.32 luindex 9668 164598 \n16098 13336 18716 1071 35.15 0.040 28.64 19.45 lusearch 10196 175354 17003 14195 19911 1117 40.22 0.043 \n30.34 20.73 pmd 11167 193375 18167 14958 20843 1168 40.28 0.046 32.00 21.90 xalan 9181 155180 15030 12645 \n17608 996 32.93 0.038 26.93 18.21 batik 22938 404097 40273 32052 46225 2565 206.50 0.100 68.77 46.60 \neclipse 18741 354818 37531 31889 54471 2221 366.39 0.103 70.82 44.54 jython 41518 642242 63516 49005 \n85552 2855 947.49 0.163 112.14 72.18 sun.ow 22346 385873 39321 31339 45161 2484 196.23 0.096 67.22 45.57 \ntomcat 25123 441606 45966 37338 63414 3013 622.36 0.124 83.98 53.56 Table 2. Benchmarks and performance \ncomparison: time in seconds and memory in MB. traditional CFL-reachability algorithm needs more iterations \nto compute the graph closure than those in our algorithm, therefore, it requires more space as well. \nNote that we only used the cubic CFL-reachability algorithm (without applying the Four Russians Trick) \nin our comparison. The subcubic CFL-reachability algorithm demands non-trivial memory for storing the \ninput graphs in our client application. For instance, given a medium-sized graph from our client analysis \nwith 15000 nodes and 1000 parentheses, the subcubic algorithm needs about 26.2 GB memory to store the \ngraph. It is an interesting topic to scale the subcubic CFL-reachability algorithm on real-world analysis. \nInterpreting the Alias Analysis. In the .eld-sensitive, context\u00adinsensitive alias analysis for Java, \nthe aliasing pairs are typically sparse. All benchmarks in our evaluation have O(n) aliasing pairs (the \n#S-pair column in Table 2). This indicates that for real-world applications, most of the variables are \nnot aliases. We have also observed from the experiments that the length of an aliasing path is small; \nalmost all of the aliasing paths are simple paths with\u00adout cycles. This observation is consistent with \nthe state-of-the-art demand-driven analyses [33, 37, 40]. Demand-Driven vs. Exhausted. We now discuss \nperhaps one of the most interesting implications from our study. We have noticed that the performance \nof our all-pairs algorithm for .eld-sensitive, context-insensitive alias analysis is extremely fast. \nSuch an exhaus\u00adtive analysis with small time and memory cost is particularly suit\u00adable for application \nscenarios that need client analyses to be able to respond instantly, such as just-in-time (JIT) optimizations \nand in\u00adteractive development environments (IDEs). Compared to demand\u00addriven analyses, our exhaustive \nalias analysis can answer any query in O(1) time. In practice, the two algorithms introduced in this \npaper can be combined to achieve better performance. For a connected compo\u00adnent of the SPG encountered \nduring analysis, it is straightforward to check whether the component is a graph or a tree by counting \nthe number of nodes and edges. Furthermore, one can design an effective analysis switching between our \ntree and graph algorithms to achieve even better performance. 8. Related Work There are two strands of \nclosely related work: CFL-reachability and alias analysis. 8.1 CFL-Reachability The CFL-reachability \nframework was initially proposed by Yan\u00adnakakis [38] for Datalog chain query evaluation. Later, it has \nbeen used to formulate interprocedural data.ow analysis [29] and many other program analysis problems \n[11, 19, 22, 25, 27, 31 33, 36, 40]. The central theme in the CFL formulations is that many pro\u00adgram \nanalyses have the balanced-parentheses property that can be captured by Dyck-CFL-reachability. The CFL \nand Dyck-CFL\u00adreachability problems are also studied in the context of recursive state machines [4], visibly \npushdown languages [3] and stream\u00ading XML [2]. Specially, when the recursive state machines are re\u00adstricted \nto allow a constant number of entry/exit nodes per module, reachability is solvable in linear-time. CFL-reachability-based \nal\u00adgorithms have cubic worst-case complexity, commonly known as the cubic bottleneck in .ow analysis \n[14]. Finding more ef.\u00adcient algorithms for CFL-reachability is a dif.cult problem as any breakthrough \nin CFL-reachability may lead to faster algorithms for CFL parsing [27]. Chaudhuri showed that the well-known \nFour Russians Trick [5] could be employed to speed up in the original CFL-reachability algorithm to immediately \nyield a subcubic algo\u00adrithm [7]. Similar techniques were used in Rytter s work [30] for CFL parsing. \nBesides the subcubic result, Kodumal and Aiken [19] described a specialized set constraint reduction \nfor Dyck-CFL\u00adreachability on graphs and Yuan and Eugster [39] proposed an ef\u00ad.cient Dyck-CFL-reachability \nalgorithm on bidirected trees. Our paper introduces asymptotically faster algorithms for Dyck-CFL\u00adreachability \non both bidirected trees and graphs.  8.2 Alias Analysis Alias analysis has been extensively studied \nin the literature. Its goal is to decide if two pointer variables may point to the same memory location \nduring program execution. The problem is .rst formulated by Choi et al. [8] and Landi and Ryder [20]. \nPoints-to analysis is recognized as a natural approach to alias analysis because aliasing relation can \nbe decided by consulting the points-to sets of the two variables. We refer the reader to Hind s survey \npaper [16] on a large body of points-to analysis work. Deciding aliasing is a computationally hard problem \n[17, 24]. Approximations must be made for any practical alias analysis. Var\u00adious techniques have been \nproposed to scale alias analyses, such as improving the underlying points-to analysis [12, 13], making \nthe analysis demand-driven [15, 37], and using novel data struc\u00adtures [35]. Speci.cally, Zheng and Rugina \n[40] proposed an ap\u00adproach based on CFL-reachability such that the aliasing informa\u00adtion can be directed \ncomputed without .rst obtaining the points-to information. The client alias analysis [36, 37] in our \nevaluation is built on the same insight. We show in this paper that our fast al\u00adgorithms help dramatically \nspeed up the context-insensitive alias analysis.  9. Conclusion In this paper, we have proposed two \nfast algorithms for solving Dyck-CFL-reachability on bidirected trees and graphs respectively. We have \nalso applied our graph algorithm to a state-of-the-art alias analysis. The experimental results show \nthat our graph algorithm help bring orders of magnitude speedup on real-world benchmarks. The key insight \nbehind both our algorithms is that the reachabil\u00adity relation is an equivalence relation. However, this \nproperty does not hold over general trees or graphs. Some existing analyses (e.g., data.ow analysis) \ndo not seem to be good applications for the bidi\u00adrected restriction. As a result, fast results for solving \nDyck-CFL\u00adreachability on general trees and graphs are still of both theoretical and practical interests. \nAcknowledgments We would like to thank Vu Le, Earl Barr, and the anonymous reviewers for helpful comments \non earlier drafts of this paper. Special thanks to Dacong Yan and Guoqing Xu for providing us with their \nalias analysis implementation. The work described in this paper was signi.cantly supported by the Research \nGrants Council of the Hong Kong Special Administrative Region, China (Project No. CUHK 415311 of General \nResearch Fund and Project No. N CUHK405/11 of the NSFC/RGC Joint Research Scheme), and partially supported \nby United States NSF grants 0917392 and 1117603. References [1] DaCapo benchmark suite. http://dacapobench.org/. \n[2] R. Alur. Marrying words and trees. In PODS, pages 233 242, 2007. [3] R. Alur and P. Madhusudan. Visibly \npushdown languages. In STOC, pages 202 211, 2004. [4] R. Alur, M. Benedikt, K. Etessami, P. Godefroid, \nT. W. Reps, and M. Yannakakis. Analysis of recursive state machines. ACM Trans. Program. Lang. Syst., \n27(4):786 818, 2005. [5] V. Arlazarov, E. Dinic, M. Kronrod, and I. Faradzev. On economic construction \nof the transitive closure of a directed graph. Soviet Mathematics Doklady, 11:1209 1210, 1970. [6] E. \nBodden, A. Sewe, J. Sinschek, H. Oueslati, and M. Mezini. Taming re.ection: Aiding static analysis in \nthe presence of re.ection and custom class loaders. In ICSE, pages 241 250, 2011. [7] S. Chaudhuri. Subcubic \nalgorithms for recursive state machines. In POPL, pages 159 169, 2008. [8] J.-D. Choi, M. G. Burke, and \nP. R. Carini. Ef.cient .ow-sensitive in\u00adterprocedural computation of pointer-induced aliases and side \neffects. In POPL, pages 232 245, 1993. [9] T. H. Cormen, C. E. Leiserson, R. L. Rivest, and C. Stein. \nIntroduction to Algorithms (3rd ed.). MIT Press, 2009. [10] M. Das, S. Lerner, and M. Seigle. ESP: Path-sensitive \nprogram veri.cation in polynomial time. In PLDI, pages 57 68, 2002. [11] C. Earl, I. Sergey, M. Might, \nand D. V. Horn. Introspective pushdown analysis of higher-order programs. In ICFP, pages 177 188, 2012. \n[12] M. F\u00a8ahndrich, J. S. Foster, Z. Su, and A. Aiken. Partial online cycle elimination in inclusion \nconstraint graphs. In PLDI, pages 85 96, 1998. [13] B. Hardekopf and C. Lin. The ant and the grasshopper: \nFast and accurate pointer analysis for millions of lines of code. In PLDI, pages 290 299, 2007. [14] \nN. Heintze and D. A. McAllester. On the cubic bottleneck in subtyping and .ow analysis. In LICS, pages \n342 351, 1997. [15] N. Heintze and O. Tardieu. Ultra-fast aliasing analysis using CLA: A million lines \nof C code in a second. In PLDI, pages 254 263, 2001. [16] M. Hind. Pointer analysis: Haven t we solved \nthis problem yet? In PASTE, pages 54 61, 2001. [17] S. Horwitz. Precise .ow-insensitive may-alias analysis \nis NP-Hard. ACM Trans. Program. Lang. Syst., 19(1):1 6, 1997. [18] S. Horwitz, T. W. Reps, and D. Binkley. \nInterprocedural slicing using dependence graphs. ACM Trans. Program. Lang. Syst., 12(1):26 60, 1990. \n[19] J. Kodumal and A. Aiken. The set constraint/CFL reachability con\u00adnection in practice. In PLDI, pages \n207 218, 2004. [20] W. Landi and B. G. Ryder. A safe approximate algorithm for interpro\u00adcedural pointer \naliasing. In PLDI, pages 235 248, 1992. [21] D. Melski and T. W. Reps. Interconvertibility of a class \nof set con\u00adstraints and context-free-language reachability. Theor. Comput. Sci., 248(1-2):29 98, 2000. \n[22] P. Pratikakis, J. S. Foster, and M. Hicks. Existential label .ow infer\u00adence via CFL reachability. \nIn SAS, pages 88 106, 2006. [23] P. Pratikakis, J. S. Foster, and M. Hicks. Locksmith: Practical static \nrace detection for C. ACM Trans. Program. Lang. Syst., 33(1):3, 2011. [24] G. Ramalingam. The undecidability \nof aliasing. ACM Trans. Program. Lang. Syst., 16(5):1467 1471, 1994. [25] J. Rehof and M. F \u00a8ahndrich. \nType-base .ow analysis: from polymor\u00adphic subtyping to CFL-reachability. In POPL, pages 54 66, 2001. \n[26] T. W. Reps. Shape analysis as a generalized path problem. In PEPM, pages 1 11, 1995. [27] T. W. \nReps. Program analysis via graph reachability. Information &#38; Software Technology, 40(11-12):701 726, \n1998. [28] T. W. Reps, S. Horwitz, S. Sagiv, and G. Rosay. Speeding up slicing. In SIGSOFT FSE, pages \n11 20, 1994. [29] T. W. Reps, S. Horwitz, and S. Sagiv. Precise interprocedural data.ow analysis via \ngraph reachability. In POPL, pages 49 61, 1995. [30] W. Rytter. Fast recognition of pushdown automaton \nand context-free languages. Information and Control, 67(1-3):12 22, 1985. [31] L. Shang, X. Xie, and \nJ. Xue. On-demand dynamic summary-based points-to analysis. In CGO, pages 264 274, 2012. [32] M. Sridharan \nand R. Bod\u00b4ik. Re.nement-based context-sensitive points-to analysis for Java. In PLDI, pages 387 400, \n2006. [33] M. Sridharan, D. Gopan, L. Shan, and R. Bod\u00b4ik. Demand-driven points-to analysis for Java. \nIn OOPSLA, pages 59 76, 2005. [34] R. Vall\u00b4ee-Rai, E. Gagnon, L. J. Hendren, P. Lam, P. Pominville, and \nV. Sundaresan. Optimizing java bytecode using the Soot framework: Is it feasible? In CC, pages 18 34, \n2000. [35] J. Whaley and M. S. Lam. Cloning-based context-sensitive pointer alias analysis using binary \ndecision diagrams. In PLDI, pages 131 144, 2004. [36] G. Xu, A. Rountev, and M. Sridharan. Scaling CFL-reachability-based \npoints-to analysis using context-sensitive must-not-alias analysis. In ECOOP, pages 98 122, 2009. [37] \nD. Yan, G. H. Xu, and A. Rountev. Demand-driven context-sensitive alias analysis for Java. In ISSTA, \npages 155 165, 2011. [38] M. Yannakakis. Graph-theoretic methods in database theory. In PODS, pages 230 \n242, 1990. [39] H. Yuan and P. T. Eugster. An ef.cient algorithm for solving the Dyck-CFL reachability \nproblem on trees. In ESOP, pages 175 189, 2009. [40] X. Zheng and R. Rugina. Demand-driven alias analysis \nfor C. In POPL, pages 197 208, 2008.     \n\t\t\t", "proc_id": "2491956", "abstract": "<p>The context-free language (CFL) reachability problem is a well-known fundamental formulation in program analysis. In practice, many program analyses, especially pointer analyses, adopt a restricted version of CFL-reachability, Dyck-CFL-reachability, and compute on edge-labeled bidirected graphs. Solving the all-pairs Dyck-CFL-reachability on such bidirected graphs is expensive. For a bidirected graph with n nodes and m edges, the traditional dynamic programming style algorithm exhibits a subcubic time complexity for the Dyck language with k kinds of parentheses. When the underlying graphs are restricted to bidirected trees, an algorithm with O(n log n log k) time complexity was proposed recently. This paper studies the Dyck-CFL-reachability problems on bidirected trees and graphs. In particular, it presents two fast algorithms with O(n) and O(n + m log m) time complexities on trees and graphs respectively. We have implemented and evaluated our algorithms on a state-of-the-art alias analysis for Java. Results on standard benchmarks show that our algorithms achieve orders of magnitude speedup and consume less memory.</p>", "authors": [{"name": "Qirun Zhang", "author_profile_id": "81470644823", "affiliation": "The Chinese University of Hong Kong, Hong Kong, Hong Kong", "person_id": "P4149083", "email_address": "qrzhang@cse.cuhk.edu.hk", "orcid_id": ""}, {"name": "Michael R. Lyu", "author_profile_id": "81100033051", "affiliation": "The Chinese University of Hong Kong, Hong Kong, Hong Kong", "person_id": "P4149084", "email_address": "lyu@cse.cuhk.edu.hk", "orcid_id": ""}, {"name": "Hao Yuan", "author_profile_id": "81758675857", "affiliation": "BOPU Technologies, Shen Zhen, China", "person_id": "P4149085", "email_address": "hao@bopufund.com", "orcid_id": ""}, {"name": "Zhendong Su", "author_profile_id": "81100108298", "affiliation": "University of California, Davis, Davis, CA, USA", "person_id": "P4149086", "email_address": "su@cs.ucdavis.edu", "orcid_id": ""}], "doi_number": "10.1145/2491956.2462159", "year": "2013", "article_id": "2462159", "conference": "PLDI", "title": "Fast algorithms for Dyck-CFL-reachability with applications to alias analysis", "url": "http://dl.acm.org/citation.cfm?id=2462159"}