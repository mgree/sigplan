{"article_publication_date": "06-16-2013", "fulltext": "\n Thresher: Precise Refutations for Heap Reachability Sam Blackshear Bor-Yuh Evan Chang Manu Sridharan \nUniversity of Colorado Boulder University of Colorado Boulder IBM T.J. Watson Research Center samuel.blackshear@colorado.edu \nevan.chang@colorado.edu msridhar@us.ibm.com Abstract We present a precise, path-sensitive static analysis \nfor reasoning about heap reachability; that is, whether an object can be reached from another variable \nor object via pointer dereferences. Precise reachability information is useful for a number of clients, \ninclud\u00ading static detection of a class of Android memory leaks. For this client, we found that the heap \nreachability information computed by a state-of-the-art points-to analysis was too imprecise, lead\u00ading \nto numerous false-positive leak reports. Our analysis combines a symbolic execution capable of path-sensitivity \nand strong up\u00addates with abstract heap information computed by an initial .ow\u00adinsensitive points-to analysis. \nThis novel mixed representation al\u00adlows us to achieve both precision and scalability by leveraging the \npre-computed points-to facts to guide execution and prune infea\u00adsible paths. We have evaluated our techniques \nin the TH R E S H E R tool, which we used to .nd several developer-con.rmed leaks in Android applications. \nCategories and Subject Descriptors D.2.4 [Software Engineer\u00ading]: Software/Program Veri.cation Keywords \nheap reachability; path-sensitive analysis; symbolic execution 1. Introduction Static reasoning about \nnearly any non-trivial property of modern programs requires effective analysis of heap properties. In \npartic\u00adular, a heap analysis can be used to reason about heap reachabil\u00adity whether one heap object is \nreachable from another via pointer dereferences at some program point. Precise heap reachability in\u00adformation \nimproves heap-intensive static analyses, such as escape analysis, taint analysis, and cast checking. \nA heap reachability checker would also enable a developer to write statically check\u00adable assertions about, \nfor example, object lifetimes, encapsulation of .elds, or immutability of objects. Our interest in heap-reachability \nanalysis arose while develop\u00ading a tool for detecting an important class of memory leaks in Android applications. \nBrie.y, such a leak occurs when an object of type Activity remains reachable from a static variable after \nthe end of its life cycle and thus cannot be freed by the garbage col\u00adlector (explained further in Sections \n2 and 4). For this client, we found that highly precise reasoning about heap reachability, includ\u00ading \n.ow-, context-, and path-sensitivity with materialization [43], Permission to make digital or hard copies \nof all or part of this work for personal or classroom use is granted without fee provided that copies \nare not made or distributed for pro.t or commercial advantage and that copies bear this notice and the \nfull citation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. PLDI 13, June 16 19, 2013, Seattle, WA, USA. \nCopyright c &#38;#169; 2013 ACM 978-1-4503-2014-6/13/06. . . $15.00 was required to avoid emitting too \nmany spurious warnings. We are unaware of an existing analysis that can provide such precision for heap-reachability \nqueries while scaling to our target applications (40K SLOC with up to 1.1M SLOC of libraries). While \napproaches based on predicate abstraction or symbolic execution [2, 4, 11, 31] could provide the necessary \nprecision in principle, to our best knowledge such approaches have not been shown to handle heap\u00adreachability \nqueries for real-world object-oriented programs (fur\u00adther discussion in Section 5). We present an analysis \nfor precise reasoning about heap reach\u00adability via on-demand re.nement of a .ow-insensitive points\u00adto \nanalysis. When the points-to analysis cannot refute a heap\u00adreachability query Q, our technique performs \na backwards search for a path program [7] witnessing Q; a failed search means Q is refuted. Our analysis \nis .ow-, context-, and path-sensitive with lo\u00adcation materialization, yielding the precision required \nby clients like the Android memory leak detector in an on-demand fashion. In contrast to previous approaches \nto re.nement-based or staged heap analysis [25, 26, 28, 36, 44], our approach re.nes points-to facts \ndirectly and is capable of path-sensitive reasoning. Also, un\u00adlike some prior approaches [28, 36, 44], \nour analysis does not at\u00adtempt to re.ne the heap abstraction of the initial points-to analysis. Instead, \nwe focus on the orthogonal problem of on-demand .ow\u00adand path-sensitive reasoning given a points-to analysis \nwith a suf.\u00adciently precise heap abstraction. Our analysis achieves increased scalability through two \nnovel uses of the initial points-to analysis result. First, we introduce a mixed symbolic-explicit representation \nof heap reachability queries and transfer functions that simultaneously enables strong updates during \nsymbolic execution, exploits the initial points-to analysis re\u00adsult, and mitigates the case split explosion \nseen with a fully explicit representation. Crucially, our representation allows the analysis to avoid \ncase-splitting over entire points-to sets when handling heap writes, key to scaling beyond small programs. \nWe also maintain in\u00adstance constraints for memory locations during analysis, based on points-to facts, \nand use these constraints during query simpli.ca\u00adtion to obtain contradictions earlier, improving performance. \nSecond, our analysis utilizes points-to facts to handle loops ef\u00adfectively, a well-known source of problems \nfor symbolic analyses. Traditionally, such analyses either require loop invariant annota\u00adtions or only \nanalyze loops to some .xed bound. We give a sound algorithm for inferring loop invariants over points-to \nconstraints on path programs during backwards symbolic execution. Our al\u00adgorithm takes advantage of the \nheap abstraction computed by the up-front points-to analysis to effectively over-approximate the ef\u00adfects \nof the loop during the backwards re.nement analysis (Sec\u00ad tion 3.3). Our technique maintains constraints \nfrom path conditions separately from the heap reachability constraints, enabling heuristic dropping of \npath constraints at loops to avoid divergence without signi.cant precision loss in most cases.  Contributions. \nThis paper makes the following contributions: We describe a technique for re.ning a points-to analysis \nwith strong updates, path sensitivity, and context sensitivity to im\u00adprove precision for heap-reachability \nqueries. Our technique centers on enriching a backwards symbolic execution with the over-approximate \ninformation from the up-front points-to anal\u00adysis to guide the execution and prune infeasible paths. \n We introduce a mixed symbolic-explicit representation of heap reachability queries and corresponding \ntransfer functions that enable strong updates and precise disaliasing information dur\u00ading symbolic execution \nwhile reducing case splitting compared to a fully explicit approach. This representation is important \nboth for .nding contradictions early and for collapsing paths effectively.  We present a method for \ninferring loop invariants for heap\u00adreachability queries during symbolic execution based on over\u00adapproximating \nthe heap effects of loops and dropping path constraints that may lead to divergence.  We demonstrate \nthe usefulness of our analysis by applying it to the problem of .nding memory leaks in Android applications. \nOur tool refuted many of the false alarms that a .ow-insensitive analysis reported for real-world Android \napplications and .n\u00adished in less than twenty minutes on most programs we tried. We used our tool to \nsuccessfully identify real (and developer\u00adcon.rmed) memory leaks in several applications.  2. Overview \nHere we present a detailed example to motivate our precise heap\u00adreachability analysis and illustrate \nour technique. The example is based on real code from Android applications and libraries, and verifying \nthe desired heap-reachability property requires strong up\u00addates, context sensitivity, and path sensitivity, \nwhich our technique provides in an on-demand fashion. Our techniques were motivated by the need to detect \nleaks of Activity objects in Android applications. Every Android applica\u00adtion has least one associated \nActivity object to control the user in\u00adterface. Android development guidelines state that application \ncode should not maintain long-lived pointers to Activity objects, as such pointers prevent the objects \nfrom being garbage collected at the end of their lifetimes, causing signi.cant memory leaks (we discuss \nthis issue further in Section 4). To detect such leaks in practice, it is suf.cient to verify that Activity \nobjects are never reachable from a static .eld via object pointers. Figure 1 is a simple application \nthat illustrates the dif.culties of precisely checking this heap reachability property (ignore the boxed \nassertions for now). The Main class initializes and starts the application s Activity, the Act class. \nThe Vec class captures the essence of a list data structure, as implemented in Android. This example \nis free of the leak described above, as the Act object allocated on line 1 is never made reachable from \na static .eld. 1 2 3 public class Main { public static void main(String[] args) { Act a = newact0 Act(); \na.onCreate(); } } public class Act extends Activity { private static .nal Vec objs = newvec0 Vec(); public \nvoid onCreate() { Vec acts = newvec1 Vec(); 4 .vint sz < .vint cap, tacts\u00b7sz f .vint sz ,tacts\u00b7cap f \n.vint cap, this f tthis,acts f tacts,tacts\u00b7tbl f arr0,tthis f act0 acts.push(this 5 .vint sz < .vint \ncap,tthis\u00b7sz f .vint sz ,tthis\u00b7cap f .vint cap, this f vec1, vec1\u00b7tbl f arr0, val f act0 6 7 ); . . . \nobjs.push(\"hello\" 8 .vint sz < .vint cap,tthis\u00b7sz f .vint sz ,tthis\u00b7cap f .vint cap, this f vec0, vec0\u00b7tbl \nf arr0, val f act0 9 ); } } public class Vec { private static .nal Object[] EMPTY = newarr0 Object[1]; \nprivate int sz; private int cap; private Object[] tbl; 10 public Vec() { this.sz = 0; this.cap = -1; \nthis.tbl = EMPTY; 11 .vint sz < .vint cap,tthis\u00b7sz f .vint sz ,tthis\u00b7cap f .vint cap, this f tthis,tthis\u00b7tbl \nf arr0 } 12 public void push(Object val) { Object[] oldtbl = this.tbl; 13 .vint sz < .vint cap,tthis\u00b7sz \nf .vint sz , tthis\u00b7cap f .vint cap, this f tthis, tthis\u00b7tbl f arr0,val f act0 14 15 if (this.sz >= this.cap) \n{ this.cap = this.tbl.length * 2; this.tbl = newarr1 Object[this.cap]; 16 this f tthis, tthis\u00b7tbl f arr0,val \nf act0 17 18 19 for (int i = 0; i < this.sz; i++) { this.tbl[i] = oldtbl[i]; // copy from oldtbl } } \n20 this f tthis, tthis\u00b7tbl f arr0,val f act0 this.tbl[this.sz] = val; 21 arr0\u00b7contents f act0 22 } } \nthis.sz = this.sz + 1; For this example program, .ow-insensitive points-to analy\u00ad sis techniques cannot \nprove the desired heap (un)reachability property due to the manner in which the Vec class is imple\u00ad mented. \nIn the inset, we show a heap graph obtained by ap- Vec Figure 1. Refuting a false alarm with context-sensitive, \npath- EMPTY arr0 sensitive witness search. We show witness queries in the boxes. The indicate refuted \nbranches of the witness search. .eld pointers. Object-sensitive abstract locations are named appro\u00ad \nplying Andersen s analysis [1] priately, for example, vec0.arr1 for arr1 instances allocated when with \none level of object sensi-Figure 2. Vec.push(-) is invoked on instances of vec0. Each edge indi\u00adtivity \n[40] to the example. Graph nodes represent classes or ab-cates a may points-to relationship, written \nas a1\u00b7 f . a2, meaning l stract locations (whose names are shown at the corresponding al-there may be \nan execution where .eld f of abstract location a1 con\u00adlocation site in Figure 1), and edges represent \npossible values of tains the address of location a2. The graph imprecisely shows that Activity object \nact0 is reachable from both static .elds Act\u00b7objs and Vec\u00b7EMPTY, hence falsely indicating that a leak \nis possible. The root cause of the imprecision in Figure 2 is the edge arr0\u00b7contents . act0, which indicates \nthat the array assigned to l Vec\u00b7EMPTY may contain the Activity object. Vec is implemented using the \nnull object pattern [45]: rather than allocating a sepa\u00ad rate internal array for each empty Vec, all \nVec objects initially use Vec\u00b7EMPTY as their internal array. The code in Vec is care\u00adfully written to \navoid ever adding objects to Vec\u00b7EMPTY while also avoiding additional branches to check for the empty \ncase. But, a .ow-insensitive points-to analysis is incapable of reason\u00ading precisely about this code, \nand hence it models the state\u00adment this.tbl[this.sz] = val on line 20 as possibly writing to Vec\u00b7EMPTY, \npolluting the points-to graph. Real Android col\u00adlections are implemented in this way.1 Note that a more \nprecise heap abstraction would not help in this case because the (con\u00adcrete) null object is shared among \nall instances the Vec class, no re.nement on the heap abstraction alone would be suf.cient to rule out \nthis false alarm. More precise analysis of this example requires reasoning about the relationship between \nthe sz and cap .elds of each Vec. This relationship is established in the Vec s constructor and must \nbe preserved until its push method is called. Though there is a large body of work focused on the important \nproblem of re.ning heap abstractions (e.g., [36, 44]), this example shows that doing so alone is sometimes \nnot suf.cient for precise results. An analysis that lacks path sensitivity and strong updates will be \nunable to prove that Vec s never write into the shared array and must therefore con.ate the contents \nof all Vec objects. The witness-refutation technique that we detail in this paper enables after-the-fact, \non\u00addemand re.nement to address this class of control-precision issues. Re.nement by Witness Refutation. \nWe re.ne the results of the .ow-insensitive points-to analysis by attempting to refute all execu\u00adtions \nthat could possibly witness an edge involved in a leak alarm. The term witness is highly overloaded in \nthe program analysis lit\u00aderature, so we begin by carefully de.ning its use in our context. We .rst de.ne \na path as a sequence of program transitions. A path wit\u00adness for a query Q is a path that ends in a state \nthat satis.es Q. Such a path witness may be concrete/under-approximate/must in that it describes a sequence \nof program transitions according to a concrete semantics that results in a state where Q holds (e.g., \na test case ex\u00adecution). Analogously, an abstract/over-approximate/may path wit\u00adness is such a sequence \nover an abstract semantics (e.g., a trace in an abstract interpreter). Building on the de.nition of a \npath pro\u00adgram [7], we de.ne a path program witness for a query Q as a path program that ends in a state \nsatisfying Q. A path program is a program projected onto the transitions of a given execution trace (essentially, \npaths augmented with loops). Note that a path pro\u00adgram witness may be under-or over-approximate in its \nhandling of loops. In this paper, we use the term witness to refer to over\u00adapproximate path program witnesses \nunless otherwise stated, as our focus is on sound refutation of queries. Our analysis performs a goal-directed, \nbackwards search for a path program witness ending in a state that satis.es a query Q. We witness a query \nby giving a witness that produces it, or we refute a query by proving that no such witness can exist. \nOur technique proceeds in three phases. Obtain a Conservative Analysis Result. First, we perform a stan\u00addard \npoints-to analysis to compute an over-approximation of the set of reachable heaps, such as the points-to \ngraph in Figure 2. 1 In fact, we discovered buggy logic in the actual Android libraries that allowed \nwriting to a null object, thereby polluting all empty containers! The bug was acknowledged and .xed by \nGoogle (https://code.google. com/p/android/issues/detail?id=48055). Formulate Queries. Second, we formulate \nqueries to refute alarms generated using the points-to analysis result. For the Activity leak detection \nclient, an alarm is a points-to path between a static .eld and an Activity object. For example, the following \npoints-to path from the graph in Figure 2 is a (false) leak alarm: Act\u00b7objs . vec0,vec0\u00b7tbl . arr0,arr0\u00b7contents \n. act0 lll To refute an alarm, we attempt to refute each individual edge in the corresponding points-to \npath. If we witness all edges in the path, we report a leak alarm. If we refute some edge e in the path, \nwe delete e from the points-to graph and attempt to .nd another path between the source node and the \nsink node. If we .nd such a path, we restart the process with the new path. If we refute enough edges \nto disconnect the source and sink in the points-to graph, we have shown that the alarm raised by the \n.ow-insensitive points-to analysis is false. For our client, we wish to show the .ow-insensitive property \nthat a particular points-to constraint cannot hold at any program point. Thus, for each points-to edge \ne to witness, we consider a query for e at every program statement that could produce e. This information \ncan be obtained by simple post-processing or instrumentation of the up-front points-to analysis [8]. \nSearch for Witnesses. Finally, given a query Q at a particular pro\u00adgram point, we search for path program \nwitnesses on demand. In Figure 1, we illustrate a witness search that produces a refutation for the points-to \nconstraint arr0\u00b7contents fact0 holding at program point 21. That is, we prove that the points-to constraint \nis unre\u00ad alizable at that program point. By starting a witness search from each statement that potentially \nproduces the edge, we will see that arr0\u00b7contents f act0 is in fact unrealizable at any program point. \nNotationally, we use a single arrow f to denote an exact points-to constraint, whose source and sink \nare symbolic val\u00adues typically denoting addresses of memory cells, and a double arrow . to denote a may \npoints-to edge between abstract loca\u00ad l tions (cf., Section 3.1). For example, the exact points-to constraint \narr0\u00b7contents f act0 describes a single memory cell whose address is some instance in the concretization \nof arr0 and contents is some instance in the concretization of act0. This distinction is critical for \nenabling strong updates in a backwards analysis. 2.1 Mixed Symbolic-Explicit Queries We illustrate the \nwitness search by showing the sub-queries (boxed) that arise as the search progresses. Moving backwards \nfrom our starting point at line 21, the sub-query at program point 20 says that we need the following \nheap state at that point: t this f tthis, this\u00b7tbl f arr0,val f act0 ( ) where t this is a symbolic variable \nthat represents the receiver of the method. A symbolic variable (written as a hatted letter v) is an \nexis\u00adtential standing for an arbitrary instance drawn from some de.nite set of abstract locations. Here, \nt this represents some instance drawn from the points-to set of local variable this, which is {vec0,vec1}. \nWe represent this fact with an instance constraint: t this from {vec0, vec1} ( ) that we track as part \nof the query at program point 20. For the mo\u00ad ment, we elide such from constraints and discuss them further \nin Section 2.2 and Section 3. This sub-query conjoining the heap state from ( ) and the instance constraint \nfrom ( ) is an example of a mixed symbolic-explicit state because we introduce a fresh sym\u00adbolic variable \nfor the contents of this, but also have named abstract locations arr0 and act0. We say that a query is \nfully explicit if all of its points-to constraints are between named abstract locations from the points-to \nabstraction. A named abstract location can be seen as a symbolic variable that is constrained to be from \na singleton abstract location set. This connection to the points-to abstraction in an explicit query \nenables our witness search to prune paths that are inconsistent with the up-front points-to analysis \nresult, as we demonstrate in Section 2.2.  Backwards Path-By-Path Analysis. Returning to the example, \nthe path splits into two prior to program point 20, one path entering the if control-.ow branch at point \n19, the other bypassing the branch to point 13. We consider both possibilities and indicate the fork \nin Figure 2 by indenting from the right margin. For the path into the branch, the loop between program \npoints 16 and 19 has no effect on the query in question from point 20, so it simply continues backward \nto program point 16. Observe that because we are only interested in answering a speci.c query, this irrelevant \nloop poses no dif.culty. At program point 16, we encounter a refutation for this path: the preceding \nassignment statement writes an instance of arr1 to the tthis\u00b7tbl this\u00b7tbl .eld, which contradicts the \nrequirement that thold an instance of arr0 (underlined). Thus, we have discovered that no concrete program \nexecution can assign a newly allocated array to this.tbl at line 15, that is, an instance of arr1 and \nthen place an Activity object in the EMPTY array at line 20 because this.tbl will point to that newly \nallocated array by then. Resuming the path that bypasses the if branch, the analysis at program point \n13 determines that entering the if branch changed the query and thus adds a control-path constraint to \nthe abstract state indicating that the value of the this.sz .eld (i.e., vint) must sz be less than the \nvalue of the this.cap .eld (i.e., vint ). As we will cap see, tracking the path constraint above is critical \nto obtaining a refutation for the example. From here, this path reaches the method boundary, leading \nthe analysis to process the possible call sites at program points 8 and 5. The path at program point \n8 can be refuted at this point, as the query requires that the val parameter be bound to an instance \nof act0 (underlined), but the actual argument is the string \"hello\". Thus, we have identi.ed that this \ncall to push cannot be the reason that an Activity object is placed into the EMPTY array because it is \npushing a string, not an Activity. The other path from the acts.push call site (i.e., program point 5) \ncan continue. The query at program point 4 before the call simply changes the program variables of the \ncallee to those of the caller. Continuing this path, we enter the constructor of Vec at program point \n11. Here, we discover that the values of the sz and cap .elds as initialized in the constructor contradict \nthe control < vint constraint vint . Intuitively, the witness search has observed sz cap the invariant \nthat a Vec s tbl .eld cannot point to the EMPTY array after a call to its push method. We have refuted \nthe last path standing, and so we have shown that the statement at line 21 cannot produced the edge arr0\u00b7contents \nf act0. In the above, we have been rather informal in describing why certain points-to facts can be propagated \nback unaffected and why producing certain facts can be done with a strong update-style transfer function. \nFurthermore, in the example program from Fig\u00ad ure 1, there is one (and only one) more statement that \ncould pro\u00ad duce the constraint arr0\u00b7contents f act0, which is the assignment at line 17 inside the copy \nloop. A witness search for this query starting at line 17 leads to a refutation similar to the one described \nabove, but to discover it we must .rst infer a non-trivial loop invariant. Because we are interested \nin an over-approximate path program witness-refutation search, we have to obtain loop invariants. We \nconsider these issues further in Section 3.  2.2 Taming Path Explosion From Aliasing In the previous \nsubsection, we focused on how refutations can occur. For example, backwards paths were pruned at line \n15 and at program point 8 because we reach an allocation site that con.icts with our instance constraints \nin the query (e.g., we need an arr0 1 x.f = p; 2 y f y,y\u00b7f f z . z from pt \u00b0G(y.f) n \u00b0r,y from pt \u00b0G(y) \nz = y.f; 3 z f z . z from \u00b0r Figure 3. An example illustrating how from constraints help tame path explosion \nfrom aliasing. Note that the set of abstract locations to which symbolic variable z might belong is restricted \neach time we observe z .ow through a variable or .eld. not an arr1 at line 15). In this section, we present \na simple example to explain how our mixed symbolic-explicit representation enables our analysis to derive \nsuch contradictions earlier and thus mitigates the aliasing path explosion problem. An over-approximate \nbackwards symbolic executor that lacks information about aliasing will be forced to fork a number of \ncases to account for aliasing at every .eld write, quickly causing a case explosion that is worst-case \nexponential in the number of .eld writes. This case explosion is independent of (but compounded by) the \nwell-known scalability problems caused by conditional branching in a path-sensitive analysis. To address \nthis aliasing path explosion problem, the key obser\u00advation that we make is that contradictions from instance \nconstraints can be derived before the allocation site by exploiting information from the up-front points-to \nanalysis. In particular, the set of pos\u00adsible allocation sites for any instance can be restricted as \nwe rea\u00adson about how they .ow into and out of program variables and heap locations. This observation \nmotivates our mixed symbolic\u00adexplicit representation, which we demonstrate with a simple exam\u00adple shown \nin Figure 3. Our initial query at point 3 asks if program variable z can point to an instance z from \nsome set of abstract loca\u00adtions \u00b0r we call this a points-to region. Moving backwards across the statement \nz = y.f, we derive a pre-query at point 2 that says our original query can be witnessed if y points to \nsome instance y and that instance points to z through its f .eld (i.e., y f y,y\u00b7f f z). Additionally, \nwe now know that the instance z must be drawn from the intersection of \u00b0r and the abstract locations \nin the points-to set of y.f, which we write as pt G\u00b0(y.f). If we can use the points-to graph \u00b0 G to determine \nthat no such abstract location exists (e.g., if we had r\u00b0= {a0,a2} and pt G\u00b0(y.f) = {a1}), then we have \nrefuted this query and can prune this path immediately. Assuming \u00b0r and pt \u00b0r n pt \u00b0 G(y.f) are not disjoint \n(i.e., \u00b0G(y.f)= /0), we proceed with our backwards analysis to the .eld write x.f = p. We must consider \ntwo cases at program point 1: one where x and y are aliased (the top query) and one where they are not \n(the bottom query). In the aliased case, we can further constrain the instance u to be from pt G\u00b0(x) \nn ptG\u00b0(y). Some previous tools have used an up-front, over-approximate points-to analysis as an aliasing \noracle to rule out aliased cases like this one (e.g., PSE [39]) if x and y cannot possibly point to the \nsame abstract location (i.e., ptG\u00b0(x) n ptG\u00b0(y) = /0), this aliased case is ruled out. Our approach generalizes \nthis kind of aliasing check by explicitly introducing from constraints that are incrementally restricted. \nFor example, we also constrain z to be from pt G\u00b0(p) n ptG\u00b0(y.f) n r\u00b0, where the additional restriction \nis pt G\u00b0(p). This constraint says that the .eld write x.f = p produced the query in question only if \nthe instance z is drawn from some abstract location shared by these three sets.  Finally, we consider \nthe case where x and y are not aliased (i.e., x = y). Here, the only change to the query is the addition \nof the constraints x f x and x = y. This disequality further constrains the query so that if we later \ndiscover that x and y are in fact aliased, we can refute this query. Accumulation of this kind of disaliasing \nconstraint is common (e.g., [11]), but expensive (cf., Section 3.3). We remark that the instance from \nconstraints can be viewed as a generalization of a fully explicit representation. To represent from constraints \nexplicitly, instead of a symbolic points-to con\u00adstraint x f x, we disjunctively consider all cases where \nwe replace the symbolic variable x with an abstract location from pt G\u00b0(x) (the points-to set of x) For \nexample, suppose pt G\u00b0(x) = {a1,a2}; then we case split and consider two heap states: (1) x f a1 and \n(2) x f a2. This representation corresponds roughly to a backwards extension of lazy initialization [33] \nover abstract locations instead of types. Note that while PSE-style path pruning only applies to ruling \nout the aliased case in .eld writes, the explicit representation of from constraints permits the same \nkind of .ow-based restriction shown in Figure 3. However, the cost is case splitting a separate query \nfor each possible abstract location from which each symbolic variable is drawn (e.g., |ptG\u00b0(y.f) n r\u00b0| \n\u00b7 |ptG\u00b0(y)| queries at program point 2). 3. Refuting Path Program Witnesses We formalize our witness-refutation \nanalysis and argue that our technique is refutation sound that we only declare an edge re\u00adfuted when \nno concrete path producing that query can exist. The language providing the basis for our formalization \nis de.ned as follows: This language is a standard imperative programming lan\u00adguage with object .elds \nand dynamic memory allocation. statements s ::= c | skip | s1 ; s2 | s1 .s2 | loop s commands c ::= x \n:= y | x := y.f | x.f := y | x := newa t() | assume e expressions e ::= x | \u00b7 \u00b7\u00b7 types t ::= {f1, . . \n. , fn} | \u00b7 \u00b7\u00b7 program variables x, y object .elds f abstract locations a Atomic commands c include assignment, \n.eld read, .eld write, object allocation, and a guard. For the purposes of our discus\u00adsion, it is suf.cient \nif an object type is just a list of .eld names. We leave unspeci.ed a sub-language of pure expressions, \nexcept that it allows reading of program variables. The label a on al\u00adlocation names the allocation site \nso that we can tie it to the points-to analysis. Compound statements include a do-nothing statement, \nsequencing, non-deterministic branching, and looping. Standard if and while statements can be de.ned \nin the usual def way (i.e., if (e) s1 else s2 = (assume e ; s1). (assume !e ; s2) and def while (e) s \n= loop (assume e; s); assume !e). For ease of presentation, our formal language is intraprocedural. However, \nour implementation is fully interprocedural. We handle procedure calls by modeling parameter binding \nusing assignment and keeping an explicit abstraction of the call stack. The call stack is initially empty \nrepresenting an arbitrary calling context but grows as we encounter call instructions during symbolic \nexecution. If we reach the entry block of a function with an empty call stack, we propagate symbolic \nstate backwards to all possible callers of the current function. We determine the set of possible callers \nusing the call graph constructed alongside the points-to analysis. 3.1 Formulating a Witness Query over \nHeap Locations Given a program, we .rst do a standard points-to analysis to obtain a points-to graph \nG\u00b0: (V\u00b0,E\u00b0) consisting of a set of vertices V\u00b0and a set of edges E\u00b0 (e.g., Figure 2). A vertex represents \na set of mem\u00ad ory addresses, which include program variables x . Var and ab\u00adstract locations a . AbsLoc \n(i.e., V\u00b0. Var . AbsLoc). An abstract location a abstracts non program-variable locations (e.g., from \ndy\u00adnamic memory allocation). We do not .x the heap abstraction, such as the level of context sensitivity, \nbut we do assume that we are given the abstract location to which any new allocation belongs (via the \nsubscript annotation). A points-to edge from E\u00b0 is either of the form x.a or a0\u00b7 f .a1. The form x.a \nmeans a concrete memory lll address represented by the program variable x may contain a value represented \nby abstract location a. We write a0\u00b7 f . a1 to denote l that f is the label for the edge between nodes \na0 and a1. This edge form means that a0\u00b7 f is a .eld of an object in the concretization of a0 that may \ncontain a value represented by abstract location a1. A static .eld in Java can be modeled as a global \nprogram variable. Our analysis permits formulating a query Q over a .nite number of heap locations along \nwith constraints over data .elds: queries Q ::= M . P | false memories M ::= any | x f v | v\u00b7 f f u | \nM1 * M2 pure formul\u00e6 P ::= true | P1 . P2 | v from r\u00b0| \u00b7 \u00b7\u00b7 points-to regions r\u00b0, s\u00b0::= a | data | r\u00b01 \n\u00dbr\u00b02 instances v,u refutation states R ::= Q | R1 . R2 | .v.R We give a heap location via an exact points-to \nedge constraint having one of two forms: x f v or v\u00b7 f f u. Recall that in contrast to points-to edges \nthat summarize a set of concrete memory cells, an exact points-to constraint expresses a single memory \ncell. The .rst form x f v means a memory address represented by the program variable x contains a value \nrepresented by a symbolic variable v (and similarly for the second form for a .eld). Since we are mostly \nconcerned with memory addresses for concrete object instances, we often refer to symbolic variables as \ninstances. The memory any stands for an arbitrary memory. We introduce one non-standard pure constraint \nform: the in\u00adstance constraint v from r\u00b0says the symbolic variable v is an in\u00adstance of a points-to region \n\u00b0r (i.e., is in the set of values described by region \u00b0r). A points-to region is a set of abstract locations \na or the special region data. For uniformity, the region data is used to represent the set of values \nthat are not memory addresses, such as integer values. As we have seen in Section 2.2, instance constraints \nenable us to use information from the up-front points-to analysis in our witness-refutation analysis. \nAs an example, the informal query arr0\u00b7contents f act0 from Section 2 is expressed as follows: v1\u00b7contents[v3] \nf v2 . v1 from {arr0} . v2 from {act0} . v3 from data where v3 stands for the index of the array. This \nquery considers existentially an instance of each abstract location arr0 and act0. When writing down \nqueries, we assume the usual commutativ\u00adity, associativity, and unit laws from separation logic [41]. \nSince we are interested in witnessing or refuting a subset of edges cor\u00adresponding to part of the memory, \nwe interpret any memory M as M * any (or intuitionistically instead of classically [32, 41]).  3.2 Witness-Refutation \nSearch with Instance Constraints As described in Section 2, we perform a path-program by path\u00ad program, \nbackwards symbolic analysis to .nd a witness for a given query Q. A refutation state R is simply a disjunction \nof queries, which we often view as a set of candidate witnesses. We include an existential binding of \ninstances .v.R to make explicit when we introduce fresh instances, but we implicitly view instances as \nrenamed so that they are all bound at the top-level (i.e., all formul\u00e6 are in prenex normal form). Informally, \na path program witness is a query Qwit bundled with a sub-program examined so far swit and a sub-program \nleft to be explored spre. De.nition 1 (Path Program Witness). A path program witness for an input statement-query \npair (s,Q) is a triple (spre,Qwit,swit) where (1) s = spre ; spost, and (2) swit is a sub-statement of \nspost such that (a) if an execution of spost leads to a store spost satisfying the input query Q, then \nit must be from a store swit satisfying Qwit and (b) executing swit from swit also leads to spost.  \n' } s {R} f { R } s {Q} f{ R WI T CA S E S WI T RE F U T E D f { R'1 } s {R1 } f { R'2 } s {R2 }f { false \n} s {false } f { R'1 . R'2 } s {R1 . R2 } WI T FR A M E T f { Mi'. Pi'} s {M . P } s must not modify \nMfr WI T SK I P i T f { any . true } s {any . true} f { (Mfr * Mi ') . Pi ' } s {(Mfr * M) . P}i f { \nR } c {Q} WI T NE W f { any . v from a n r\u00b0 . P} x := newa t() {x v . v from r\u00b0. P} WI TAS S I G N f \n{ y v . v from ptG\u00b0(y) n r\u00b0 . P } x := y {x v . v from r\u00b0. P} WI T RE A D P' = u from ptG\u00b0(y) . v from \nptG\u00b0(y. f ) n r\u00b0 . P f { .u.y u * u\u00b7 f v . P' } x := y.f {x v . v from r\u00b0. P} WI T WR I T E Mi = x vi \n* y ui * (*vj \u00b7 f u j . vj from r\u00b0j . u j from s\u00b0j ) j=i vi from ptG\u00b0(x) n r\u00b0i . ui from ptG\u00b0(y) n s\u00b0i \n. (vj = vi ) . P j=i Q = .x.x x * (*vi\u00b7 f ui . vi from r\u00b0i . ui from s\u00b0i . vi = x) . x from ptG\u00b0(x) . \nP i Qi = Mi . T f { Q . Qi } x.f := y {(*vi\u00b7 f ui . vi from r\u00b0i . ui from s\u00b0i) . P}i i Figure 4. Witness-refutation \nsearch is a path-program by path\u00adprogram backwards analysis. Boxed terms emphasize opportunities for \nrefuting paths using instance constraints. Any intermediate state in our backwards analysis is such a \npath program witness. Intuitively, the statement swit captures the path sub-program identi.ed by the \nbackwards analysis that is relevant to producing the input query Q (so far). A refutation occurs when \nQwit is false, that is, we have discovered that it is not possible to end up in a state satisfying Q. \nA full witness is when Qwit is any; that is, we can no longer .nd a refutation. A partial witness is \na witness where Qwit is a query other than any or false. We formalize a backwards path program enumeration \ntrans\u00adforming queries into sub-queries to eventually produce an any or a false refutation state. To describe \nthe analysis, we de.ne the judg\u00adment form f { R' } s {R} in Figure 4. This judgment form is a standard \nHoare triple, but because our analysis is backwards, we read this judgment form from right-to-left. It \nsays, Given a post\u00adformula R, we .nd a pre-formula R' such that executing statement s from a state satisfying \nR' yields a state satisfying R (up to termi\u00adnation). Conceptually, the post-formula R is a (disjunctive) \nset of queries, and the pre-formula R' is the set of sub-queries. The path program swit can be obtained \nby a simple instrumentation of the rules similar to our prior work [8]. Deriving Refutations. At any \npoint, we can extend the witness\u00adrefutation search for some disjunct. Here, we express this step with \nWI T CA S E S, which says a disjunctive refutation state R1 . R2 can be derived by .nding a witness for \nR1 and R2. We make this system algorithmic for an implementation by representing cases as a disjunctive \nset of pending queries \u00b7\u00b7\u00b7 . Qi . \u00b7\u00b7\u00b7 that we extend individually. Rule WI T RE F U T E D simply says \nif we have derived false in the post-state for a statement, then we have false in the pre-state as well. \nTo scale beyond the tiniest of programs, we need to be able to refute queries quickly so that the number \nof queries to consider, that is, the number of symbolic execution paths to explore, remains small. We \nhave three tools for refuting queries: (1) separation (i.e., a query where a single memory cell would \nneed to point to two locations simultaneously), (2) instance constraints (i.e., a query where an instance \ncannot be in any points-to region), and (3) other pure constraints (i.e., a query with pure constraints \nthat are unsatis.able, such as, from detecting an infeasible control\u00ad.ow path). In our inference rules, \nwe assume a refutation state R is always normalized to false if the formula is unsatis.able. Since we \nare interested in sound refutations and over-approximate witnesses, for scaling, we can also weaken queries \nat the cost of potentially losing precision. We revisit this notion in Section 3.3. Instance constraints \nare pure constraints that tie the exact points\u00adto constraints in the query to the accumulated information \nfrom the up-front points-to analysis and the .ow of the symbolic variables as discussed in Section 2.2. \nThey can axiomatized as follows: v from /0 .. false (1) v from \u00b0r1 . v from \u00b0r2 .. v from \u00b0r1 n \u00b0r2 (2) \ntrue .. v from AbsLoc . {data} (3) In particular, we derive a contradiction when we discover an in\u00adstance \nthat can be drawn from any abstract location (axiom 1). Though our formalism groups instance constraints \nand other pure constraints together, our implementation keeps them separate for simplicity in checking. \nInstance constraints are checked using ba\u00adsic set operations and other pure constraints are checked with \nan off-the-shelf SMT solver, though it should be possible to encode instance constraints into the solver \nusing this axiomatization. We include a frame rule on M, WI T FR A M E, to simplify our presentation, \nwhich together with WI T SK I P allow us to isolate the parts of the query that a block of code may affect \nand to ignore irrelevant statements. In other words, any statements that cannot affect the memory state \nin the query can be skipped. We can thus focus our discussion on an auxiliary judgment form f { R} c \n{Q}that describes how the assignment commands affect a query and its point-to and instance constraints. \nInformally, it says, We can witness a query Q after assignment command c by executing c if we can also \nwitness one of the sub-queries R before c. From an algorithmic perspective, we can view f { R} c {Q} \nas generating sub-queries that when combined with a frame may yield additional contradictions. We assume \nthis judgment implicitly has access to the points-to graph G: (V\u00b0,E\u00b0) computed by the up-front analysis. \n\u00b0We use the pt G\u00b0(\u00b7) function to get the points-to set of a program def variable via pt G\u00b0(x) = {a | \n(x . a) . E\u00b0} or a .eld of a program def variable via pt G\u00b0(y. f ) = {a j | ali . ptG\u00b0(y) and (ai\u00b7f . \na j) . E\u00b0}. l Backwards Transfer Functions and Instance Constraints. Rule WI T NE W says that the exact \npoints-to constraint x f v can be wit\u00adnessed, or produced, by the allocation command x := newa t() if \ninstance v may have been created at allocation site a. Following our axiomatization, the instance constraint \nv from a nr\u00b0may imme\u00addiately reduce to false if a ./r\u00b0. Or, we can drop it (without loss of precision) \nbecause this instance cannot exist before its allocation at this statement. Such a contradiction is precisely \nthe reason for re\u00adfuting the path at the new arr1 allocation (program point 16) in our motivating example \n(Figure 1). Now, consider rule WI TAS S I G N: it says that the exact points\u00adto constraint x f v can \nbe produced by the assignment command x := y if y f v can be witnessed before this assignment and the \ninstance v can come from a region common to the points-to set of y and the region \u00b0r. If the points-to \nset of y and the region \u00b0r are disjoint, we can derive a contradiction because the instance v cannot \ncome from any allocation site. Observe that WI TAS S I G N leverages the from constraint and the up-front \npoints-to analysis result to eagerly discover that no allocation site satis.es the conditions required \nfor a witness (rather than observing that a particular allocation site does not satisfy the conditions \nrequired for a witness, as in WI T NE W). To get a sense for why these eager refutations are critical \nfor scaling, consider the path refutation due to the binding of val to \"hello\" at the objs.push call \nsite (program point 8). In our example, this refutation is via WI T NE W because \"hello\" is a String \nallocation, but we can easily imagine a variant where objs.push is called with a program variable y that \ncan conservatively point-to a large set of non-Activity objects. For such a program, WI TAS S I G N would \nallow us to discover a path refutation at the assignment corresponding to the binding rather than requiring \nus to continue exploration across the potentially exponential number of paths to the allocation sites \nthat .ow to y.  The WI T RE A D rule is quite similar to WI TAS S I G N except that we existentially \nquantify over the instance to which y points (i.e., u). We set up an initial points-to region constraint \nfor the fresh symbolic variable u based on the points-to set of y and narrow the points-to region of \nv using the points-to set of y. f . As in WI TAS S I G N, we can derive a contradiction based on this \nnarrowing if the region \u00b0r and the points-to set of y. f are disjoint. Here, we have taken some liberty \nwith notation placing, for example, from constraints under the iterated separating conjunctions; we recall \nthat * collapses to . for pure constraints. In the WI T WR I T E rule, the post-formula consists of two \ncases for each edge vi\u00b7 f fui in the pre-formula: (1) the .eld write x.f := y did not produce the edge \nvi\u00b7 f f ui (the .rst disjunct Q), or (2) the .eld write did produce the edge (the second set of disjuncts \nover all Qi). If the write x.f := y did produce the points-to edge vi\u00b7 f f ui, then the points-to regions \nof vi and ui are restricted based on the points\u00adto sets of x and y, respectively. The not produced case \nrepresents the possibility that this write updates an instance other than a vi (as re.ected by the x \nf x and vi = x conditions). While WI T WR I T E can theoretically generate a huge case split, we have \nobserved that the combination of instance constraints and separation typically allow us to .nd refutations \nquickly in practice (see Section 4). In particular, the not written case can often be immediately refuted \nby separation. For example, we end up with a contradictory query where a local variable x has to point \nto two different instances simultaneously (i.e., x f v * x f u . v = u). Guards and Control Flow. Except \nfor loops (see Section 3.3), the remaining rules mostly relate to control .ow and are quite standard \n(shown inset). To discover a contradiction on pure constraints, we state that the guard condition of \nan assume must hold in the pre\u00adquery. We write e[M] for interpreting the program expression e in the \nmemory state M. The WI T CH O I C E rule analyzes WI TAS S U M E each branch independently. Our f { M \n. P . e[M]} assume e {M . P }implementation avoids path ex\u00ad plosion due to irrelevant path WI T SE Q \nf { R'' } s1 {R' } f { R' } s2 {R} sensitivity by adding pure con\u00ad f { R'' } s1 ; s2 {R} straints from \nif-guards only when the queries on each side of the WI T CH O I C E branch are different (as in previous \nf { R1 } s1 {R} f { R2 } s2 {R}work [18, 39]), though our rules do f { R1 . R2 } s1 .s2 {R}not express \nthis.  3.3 Loop Invariant Inference and Query Simpli.cation In this section, we .nish our description \nof witness-refutation search by discussing our loop invariant inference scheme. Roughly speaking, we \ninfer loop invariants by repeatedly per\u00adforming backwards symbolic execution over the loop body until \nwe reach a .xed point over the domain of points-to constraints. To ensure termination, we drop all pure \nconstraints affected by the loop body and .x a static bound on the number of instances of each abstract \nlocation to materialize. In our experiments, a static bound of one has been suf.cient for precise results. \nThe WI T LO O P rule (shown inset) simply states that if the loop body has no effect on the query, the \nloop has no effect on it. By itself, this rule only handles WI T LO O P the degenerate case where a loop \ncan f { R } s {R }be treated as skip with respect to f { R } loop s {R }the query. For this case, the \ndisjunc- WI TAB S T R AC T I O N tive set of queries R is trivially a loop R' 2 |= R' f { R' 2 } s {R2 \n} R1 |= R2 1 invariant. For more interesting cases, f { R' 1 } s {R1 }we use WI T CA S E S to consider \neach query in the refutation state individually so that we can infer an over-approximate loop invariant \nfor each one. Thus, we infer a loop invariant on-the-.y for each path program rather than joining all \nqueries at the loop exit and then inferring an invariant for all back\u00adwards paths into the loop (similar \nto [35] but with heap constraints). To preserve refutation soundness, we want to ensure that a con\u00adtradiction \nfalse is only derived when there does not exist a concrete path witnessing the given query and thus must \nover-approximate loops. A sound, backwards over-approximation can be obtained by weakening the post-loop \nquery Qi. Since an individual query is purely conjunctive, we can weaken it quite easily by dropping \nconstraints (i.e., removing conjuncts). Intuitively, dropping con\u00adstraints is refutation-sound because \nit can only make it more dif.\u00adcult to derive a contradiction. This over-approximation is captured by \nthe WI TAB S T R AC T I O N rule. The rule says that at any program point, we can drop constraints, and \ndoing so preserves refutation soundness (Theorem 1). We write R1 |= R2 for the semantic entailment and \ncorrespond\u00adingly rely on a sound decision procedure in our implementation (used in WI TAB S T R AC T \nI O N). Entailment between a .nite separat\u00ading conjunction exact points-to constraints can be resolved \nin a standard way by subtraction [5]. Without inductive predicates, the procedure is a straightforward \nmatching. Entailment between the from instance constraints can be de.ned as follows: (v1 from r\u00b01) |= \n(v2 from r\u00b02) iff v1 = v2 and \u00b0r1 . r\u00b02 (\u00a7) As previously mentioned, from constraints are represented \nas sets associated with a symbolic variable and solved with ordinary set operations. We discharge other \npure constraints using an off-the\u00adshelf SMT solver, so precision of reasoning about those constraints \nis with respect to the capabilities of the solver. With these tools, our loop invariant inference is \na rather straight\u00adforward .xed-point computation. For a loop statement loop s and a post-loop query Q, \nwe iteratively apply the backwards predicate transformer for the loop body s to saturate a set of sub-queries \nat the loop head. Let R0 be some refutation state such that f { R0 } s {Q}, and let Ri+1 = Ri . R' where \nf { R' } s {Ri }. We ensure that the chain of R0 |= R1 |= \u00b7\u00b7\u00b7 converges by bounding the number of in\u00adstances \nor materializations from the abstract locations. Since there are a .nite number of abstract locations, \nthe number of points-to constraints in any particular query is bounded by the number of edges in the \npoints-to graph (i.e., |E\u00b0|). For the base domain of pure constraints, widening [14] can be used to ensure \nconvergence. Our implementation uses a trivial widening that drops pure constraints that may be modi.ed \nby the loop. Query Simpli.cation with Disaliasing. The WI TAB S T R AC T I O N rule captures backwards \nover-approximation by saying that at any point, we can weaken a refutation state without losing refutation \nsoundness. Conceptually, we can weaken by replacing any sym\u00adbolic join . with an over-approximate join \nu. We perform one such join by replacing the refutation state Q1 . Q2 with Q2 if Q1 |= Q2. Note that \nthis join does not lose precision. Intuitively, for a refu\u00adtation state R, we are interested in witnessing \nany query in R or refuting all queries in R. Here, a refutation of query Q2 implies a refutation of Q1, \nso we only need to consider Q2.  To enable this join to apply often, we enforce a normal form for our \nqueries by dropping certain kinds of constraints. As formal\u00adized in Figure 4, the backwards transfer \nfunctions for assignment commands c are as precise as possible, including the generation of disequality \nconstraints in WI T WR I T E. These disequality constraints are needed locally to check for refutations \ndue to separation, as de\u00adtailed in Section 3.2. However, if this check passes, we drop them before proceeding \nand instead keep only the disaliasing informa\u00adtion implied by separation and the instance from constraints. \nWhile this weakening could lose precision (e.g., if the backwards analy\u00adsis would later encounter an \nif-guard for the aliasing condition), we hypothesize that this situation is rare and that the most useful \ndisaliasing information is captured by separation and instance con\u00adstraints. In our implementation, we \nare much closer to a path-by-path analysis than our formalization would indicate. Refutation states are \nrepresented as a worklist of pending (non-disjunctive) queries to explore. To apply the simpli.cation \ndescribed above, we must keep a history of queries seen at a given program point: if we have previously \nseen a weaker query at this program point, then we can drop the current query. We keep a query history \nonly at procedure boundaries and loop heads. This simpli.cation has been especially critical for procedures. \nSoundness. We de.ne a concrete store s be a .nite mapping from variables or address-.eld pairs to concrete \nvalues (i.e., s : Var (Addr \u00d7 Field) -.n Val) and give a standard big-step oper\u00adational semantics to \nour basic imperative language The judgment ' form s f s . s says, In store s, statement s evaluates to \nstore s'. Furthermore, we write s |= R to say that the store s is in the concretization of the refutation \nstate R. The de.nition of s |= R is as would be expected in comparison to separation logic. We need to \nutilize two other concrete semantic domains: a valuation . that maps instances to values (i.e., . : Instance \n. Val) and a regional\u00adization . that maps abstract locations to sets of concrete addresses (i.e., . : \nAbsLoc . P(Addr)). The regionalization gives meaning to the from instance constraint. With these de.nitions, \nwe pre\u00adcisely state the soundness theorem. Theorem 1 (Refutation Soundness). If f { Rpre } s {Rpost } \nand spre f s . spost such that spost |= Rpost, then spre |= Rpre. As a corollary, refutations (i.e., \nwhen Rpre is false) are sound. Interestingly, the standard consequence rule from Hoare logic states the \nopposite in comparison to WI TAB S T R AC T I O N by permit\u00adting the strengthening of queries. Doing \nso would instead preserve witness precision; that is, any path program witness exhibits some witness \npath (up to termination). 4. Case Study: Activity Leaks in Android We evaluated our witness-refutation \nanalysis by using it to .nd Activity leaks, a common class of memory leaks in open-source Android applications. \nWe explain this client in more detail below. Our experiments were designed to test two hypotheses. The \n.rst and most important concerns the precision of our approach: we hypothesized that witness-refutation \nanalysis reports many fewer false alarms than a .ow-insensitive points-to analysis. We tried using a \n.ow-insensitive analysis to .nd leaks, but found that the number of alarms reported was too large to \nexamine manually. To be useful, our technique needs to prune this number enough for a user to effectively \ntriage the results and identify real leaks. Our second hypothesis concerns the utility of our techniques: \nwe posited that (1) our mixed symbolic-explicit is an improvement over both a fully explicit and a fully \nsymbolic representation, (2) our query simpli.cation signi.cantly speeds up analysis, and (3) our on-the\u00ad.y \nloop invariant inference is needed to preserve precision in the presence of loops. Client. Activity leaks \noccur when a pointer to an Activity object can outlive the Activity. The operating system frequently \ndestroys Activity s when con.guration changes occur (e.g., rotating the phone). Once an Activity is destroyed, \nit can never be displayed to the user again and thus represents unused memory that should be reclaimed \nby the garbage collector. However, if an application developer maintains a pointer to an Activity after \nit is destroyed, the garbage collector will be unable to reclaim it. In our experiments, we check if \nany Activity instance is ever reachable from a static .eld, a .ow-insensitive property. Though a developer \ncould safely keep a reference to an Activity object via a static .eld that is cleared each time the Activity \nis destroyed, this is recognized as bad practice. Activity leaking is a serious problem. It is well-documented \nthat keeping persistent references to Activity s is bad practice; we refer the reader to an article2 \nin the Android Developers Blog as evidence. The true problem is that it is quite easy for devel\u00adopers \nto inadvertently keep persistent references to an Activity. Sub-components of Activity s (such as Adapter \ns, Cursor s, and View s) typically keep pointers to their parent Activity, meaning that any persistent \nreference to an element in the Activity s hierar\u00adchy can potentially create a leak. Precision of Our \nTechniques: Threshing Alarms. We imple\u00admented our witness-refutation analysis in the TH RESHER tool, \nwhich is publicly available.3 Additional details on our implemen\u00adtation are included at the end of this \nsection. All of our experiments were performed on a machine running Ubuntu 12.04.2 with a 2.93 GHz Intel \nXeon processor and 32GB of memory. Though our anal\u00adysis is quite amenable to parallelization in theory, \nour current im\u00adplementation is purely sequential. To evaluate the precision of our approach, we computed \na .ow\u00adinsensitive points-to graph for each application and the Android library (version 2.3.3) using \nWALA s 0-1-Container-CFA pointer analysis (a variation of Andersen s analysis with unlimited context \nsensitivity for container classes). For each heap path from a static .eld f to an Activity instance A \nin the points-to graph, we asked TH RE S HE R to witness or refute each edge in the path from source \nto sink. If we refuted an edge in the heap path, we searched for a new path. We repeated this until TH \nR E S H E R either witnessed each edge in the heap path (i.e., con.rmed the .ow-insensitive alarm) or \nrefuted enough edges to prove that no heap path from f to A can exist (i.e., .ltered out the leak report). \nWe allowed an exploration budget of 10,000 path programs for each edge; if the tool exceeded the budget, \nwe declared a timeout for that edge and considered it to be not refuted. On paths with call stacks of \ndepth greater than three, we soundly skipped callees by dropping constraints that executing the call \nmight produce (according to a mod/ref analysis computed alongside the points-to analysis). We limited \nthe size of the path constraint set to at most two. Allowing larger path constraint sets slowed down \nthe symbolic executor without increasing precision. We ran in two con.gurations: one with the Android \nlibrary as-is (Ann?=N), and one where we added a single annotation to the HashMap class to indicate that \nthe shared EMPTY_TABLE .eld can never point to anything (Ann?=Y). We did this because we observed that \nthe use of the null object pattern in the HashMap class was a major source of imprecision for the .ow-insensitive \nanalysis (cf. Figure 1), but we wanted to make sure that it was not the only one our tool was able to \nhandle. 2 http://developer.android.com/resources/articles/ avoiding-memory-leaks.html 3 https://github.com/cuplv/thresher \n  Benchmark Size Filtering Effectiveness Computational Effort Benchmark SLOC CGB Ann? Alrms RefA(%) \nTruA(%) FalA(%) Flds RefFlds RefEdg WitEdg TO T (s) PulsePoint. no src 198K N Y 24 16 16 (67) 8 (50) \n8 8 (33) (50) 0 0 (0) (0) 3 2 2 1 47 40 40 31 1 0 750 95 StandupTimer. 2K 240K N Y 25 25 15 (60) 15 (60) \n0 0 (0) (0) 10 (40) 10 (40) 5 5 3 3 18 18 26 26 0 0 1199 1068 DroidLife. 3K 132K N Y 3 3 0 0 (0) (0) \n3 (100) 3 (100) 0 0 (0) (0) 1 1 0 0 0 0 4 4 0 0 1 1 OpenSudoku 6K 229K N Y 7 0 1 (14) 0 (0) 0 0 (0) (0) \n6 (86) 0 (0) 1 0 0 0 2 0 21 0 1 0 1596 0 SMSPopUp. 7K 232K N Y 5 5 1 (20) 1 (20) 4 4 (80) (80) 0 0 (0) \n(0) 1 1 0 0 10 10 24 24 0 0 49 46 aMetro. 20K 326K N Y 144 54 18 (12) 18 (33) 36 36 (25) (67) 90 (63) \n0 (0) 8 3 1 1 62 55 66 24 3 0 4226 18 K9Mail. 40K 394K N Y 364 208 78 (21) 130 (63) 64 64 (18) (49) 222 \n(61) 14 (7) 14 8 3 5 141 124 106 80 1 0 1130 374 Total 78K 1751K N Y 572 311 129 (22) 172 (55) 115 (20) \n115 (37) 332 (58) 24 (8) 33 20 9 10 280 247 287 189 6 0 8991 1602 Table 1. This table characterizes \nthe size of our benchmarks, highlights our success in distinguishing false alarms from real leaks, and \nquanti.es the effort required to .nd refutations. . s indicate a benchmark in which we found an observable \nleak, and . indicates a latent leak. The Size column grouping gives the number of source lines of code \nSLOC and the number of bytecodes in the call graph CGB for each app as well as the annotation con.guration \nAnn?=Y/N. The Filtering column grouping characterizes the effectiveness of our approach for .ltering \nfalse alarms. The .rst four columns list the number of (static .eld, Activity) alarm pairs reported by \nthe points-to analysis Alarms, number of alarms refuted by our approach RefA, number of true alarms TruA, \nand the number of false alarms FalA. The .nal two columns of this group give the number of leaky .elds \nreported by the points-to analysis Fields and the number of these .elds RefFlds that we can refute (i.e., \nprove that the .eld in question cannot point to any Activity). The Effort columns describe the amount \nof work required by our .ltering approach. We list the number of edges refuted RefEdg, edges witnessed \nWitEdg, edge timeouts TO, and the time T (s) taken by the symbolic execution phase in seconds. This number \ndoes not include points-to analysis time, which ranged from 8 46 seconds on all benchmarks. Table 1 shows \nthe results of this experiment. We .rst comment on the most interesting part of the experiment: the .ltering \neffec\u00adtiveness of our analysis. As we hoped, our analysis is able to refute many of the false alarms \nproduced by the .ow-insensitive points-to analysis. Overall, we refute 129/457 = 28% of these false alarms \nin the un-annotated con.guration and 172/196 = 87% of these false alarms in the annotated con.guration. \nContrary to our expectations, we found many more refutations in the Ann?=Y con.guration, con.rming that \nour technique can indeed remedy imprecision other than the pollution caused by HashMaps. Unfortunately, \nthis also means that our analysis is not always able to remedy the imprecision caused by HashMaps. The \nmajor problem is that the Ann?=N con.guration fails to refute many of the HashMap-related edges due to \ntimeouts. In fact, most of the false alarms that are not common to both con.gurations stem from (soundly) \nnot considering timed-out edges to be refuted. We observed that a timeout commonly corresponds to a refutation \nthat the analysis was unable to .nd within the path program budget. This is not surprising; .nding a \nwitness for an edge only requires .nding a single path program that produces the edge (which we can usually \ndo quickly), but to .nd a refutation we must refute all path programs that might produce an edge (which \nis slow and sometimes times out, potentially causing precision loss). For example, the single timeout \nin the Ann?=N run of K9Mail occurs on a HashMap-related edge that is refutable, but quite chal\u00adlenging \nto refute. As it turns out, refuting this edge is extremely important for precision upon further investigation, \nwe discov\u00adered that the analysis would have reduced the number of false alarms reported by over 100 if \nit had been able to refute it! In the Ann?=Y con.guration, this edge disappears from the .ow\u00adinsensitive \npoints-to graph. We can see that this increases the num\u00ad public class EmailAddressAdapter extends ResourceCursorAdapter \n{ private static EmailAddressAdapter sInstance; public static EmailAddressAdapter getInstance(Context \ncontext) { if (sInstance == null) sInstance = newadr0 EmailAddressAdapter(context); return sInstance; \n} private EmailAddressAdapter(Context context) { super(context); } } Figure 5. A con.rmed Activity leak \ndiscovered in K9Mail. ber of alarms we are able refute from 78 to 130 even though the number of alarms \nreported by the .ow-insensitive points-to analy\u00adsis falls from 364 to 208. We now comment on the computational \neffort required to re\u00adfute/witness edges. We .rst observe that the number of edges re\u00adfuted is almost \nalways greater then the number of alarms refuted, indicating that it is frequently necessary to refute \nseveral edges in order to refute a single (source, sink) alarm pair. For example, in the un-annotated \nrun of aMetro, we refute 62 edges in order to refute 18 alarms. This demonstrates that the .ow-insensitive \npoints-to analy\u00adsis is imprecise enough to .nd many different ways to produce the same false alarm. We \nnote that the running times are quite reasonable for an anal\u00adysis at this level of precision, especially \nin the annotated con.gura\u00adtion. No benchmark other than aMetro takes more than a half hour. Our tool \nwould be fast enough to be used in a heavyweight cloud service or as part of an overnight build process. \n Real Activity Leaks. As hypothesized, our tool s precision en\u00adabled us to ignore most false alarms \nand focus on likely leaks. We found genuine leaks in PulsePoint, DroidLife, SMSPopUp, aMetro, and K9Mail. \nMany of the leaks we found would only manifest un\u00adder specialized and complex circumstances, but a few \nof the nasti\u00adest leaks we found would almost always manifest and are due to the same simple problem: \nan inappropriate use of the singleton pattern. We brie.y explain one such leak from the K9Mail app. In \nthe code in Figure 5, the developer uses the singleton pattern to ensure that only one instance of EmailAddressAdapter \nis ever created. The leak arises when getInstance() is called with an Activity instance passed as the \ncontext parameter (which hap\u00adpens in several places in K9Mail). The Activity instance is passed backwards \nthrough the constructors of two superclasses via the context parameter until it is .nally stored in the \nmContext in\u00adstance .eld of the CursorAdapter superclass. For every Activity act0 that calls getInstance(), \nthe .ow-insensitive points-to analysis reports a heap path EmailAddressAdapter\u00b7sInstance . l adr0,adr0\u00b7mContext \n. act0. When the Activity instance is de\u00ad l stroyed, the garbage collector will never be able to reclaim \nit be\u00adcause none of the pointers involved in the leak are ever cleared. We found this leak in a version \nof K9Mail that was downloaded in September 2011 (all versions of the benchmarks we used are available \nin project s GitHub repository). We looked at the current version and noticed that the EmailAddressAdapter \nclass had been refactored to remove the singleton pattern. We found the commit that performed this refactoring \nand asked the developers of K9Mail if the purpose of this commit was to address a leak issue; they con.rmed \nthat it was.4 We also discovered a very simple latent leak in StandupTimer that was also due to a bad \nuse of the singleton pattern. We noticed that several of the path programs THR ES H E R produced for \na .eld in this app would be a full witness for a leak if a single boolean .ag cacheDAOInstances were \nenabled. Our tool correctly recognizes that this .ag cannot ever be set and refutes the alarm report, \nbut a modi.cation to the program that enabled this .ag would result in a leak. The path program witnesses \nour tool produces are al\u00adways helpful in triaging reported leak alarms, but in this case even the refuted \npath program witness provided useful information that allowed us to identify an almost-leak. With a less \nconstructive refu\u00adtation technique, we might have missed this detail. Utility of Our Techniques. To test \nour second set of hypotheses, we ran THR E S H E R on the benchmarks from Table 1 without using each \nof three key features of our analysis: mixed symbolic-explicit query representation, query simpli.cation, \nand loop invariant infer\u00adence. We hypothesized that: (1) using an alternative query represen\u00adtation would \nnegatively affect scalability and/or performance, (2) not simplifying queries would negatively affect \nscalability and/or performance, and (3) the absence of loop invariant inference would negatively affect \nprecision. To test hypothesis (1), we implemented a fully symbolic query representation. In a fully symbolic \nrepresentation, we do not track the set of allocation sites that a variable might belong to. We have \nup-front points-to information, but use it only to con.rm that two symbolic variables are not equal (i.e., \nto prevent aliasing case splits in the style of [39]) and to con.rm that a symbolic variable was allocated \nat a given site (as in WI T NE W). This precludes both pruning paths based on the boxed from constraints \nin Figure 4 and performing the entailment check between symbolic variables de.ned in Equation \u00a7 in Section \n3.3. Using this fully symbolic representation, our analysis ran slower and timed out more often, but \ndid not refute any fewer alarms 4 https://groups.google.com/forum/?fromgroups=#!topic/ k-9-mail/JhoXL2c4UfU \n Benchmark Ann? T (slowdown) TO (.) PulsePoint N Y 1237 (1.6X) 220 (1.9X) 7 (+6) 3 (+3) StandupTimer \nN Y 4946 (4.1X) 4104 (3.8X) 4 (+4) 4 (+4) OpenSudoku N Y 2984 (1.9X) - 4 (+3) - SMSPopUp N Y 95 (1.9X) \n76 (1.7X) 0 (+0) 0 (+0) aMetro N Y 6863 (1.6X) 18 (1X) 5 (+2) 0 (+0) K9Mail N Y 990 (0.9X) 454 (1.2X) \n2 (+1) 0 (+0) Table 2. Performance of the fully symbolic representation as com\u00adpared to the mixed symbolic-explicit \nrepresentation. than the run with the mixed representation. We observed several cases where a timeout \ncaused the fully symbolic representation to miss refuting an edge that the mixed representation was able \nto refute, but in each case the edge turned out not to be important for precision (that is, it was one \nof many edges that needed to be refuted in order to refute an alarm, but both representations failed \nto refute all of these edges). The results of this experiment are shown in Table 2. We omit the results \nfor DroidLife since they were unaffected by the choice of representation. For every other benchmark, \nwe give the time taken with a fully symbolic representation, the number of times slower than the mixed \nrepresentation this was (T (slowdown)), the number of edges that timed out, and how many timeouts were \nadded over the mixed representation (TO (.)). We can see that in both the annotated and un-annotated \ncon.g\u00adurations, most benchmarks run at least 1.6X slower and time out on at least one more edge than \nthey did with the mixed representa\u00adtion. The anomalous behavior of K9Mail in the un-annotated con\u00ad.guration \noccurs because the mixed representation is able to refute an edge that the fully symbolic representation \ntimes out on. Ulti\u00admately, this leads the mixed representation to make more progress towards (but ultimately \nfail in) refuting a particular alarm. The fully symbolic representation declares this particular alarm \nwitnessed af\u00adter the edge in question times out, which allows it to skip this effort and .nish faster. \nThus, hypothesis (1) seems to hold: using a fully symbolic representation negatively affected both performance \nand scalability as predicted, but choosing a fully symbolic representa\u00adtion did not ultimately affect \nthe precision of the analysis in terms of alarms .ltered. To test hypothesis (2), we re-ran THR E S H \nE R on our benchmarks using the annotated Android library without performing any query simpli.cation \nat all. This signi.cantly hurt the performance of TH RE S HE R on PulsePoint (102.4X slower), K9Mail \n(3.2X slower), and SMSPopUp (4.3X slower), but did not change the number of alarms refuted or witnessed \nfor these benchmarks. On StandupTi\u00admer, not performing simpli.cation caused the tool to run out of memory \nbefore completing the analysis, thus affecting both preci\u00adsion and performance. The performance of the \ntool on other apps was not signi.cantly affected. Thus, hypothesis (2) seems to hold for the benchmarks \nthat require signi.cant computational effort. Finally, to test hypothesis (3), we implemented a simple \nloop in\u00advariant inference that simply drops all possibly-affected constraints at any loop. With only \nthis simple inference, the analysis was un\u00adable to refute some critical HashMap-related edges (using \nthe un\u00adannotated library). This meant that the analysis could never distin\u00adguish the contents of different \nHashMap objects. This imprecision prevented the analysis from refuting leak reports involving multiple \nHashMap s even on small, hand-written test cases. Our full loop in\u00advariant inference (Section 3.3) handled \nthe hand-written cases pre\u00ad cisely, but due to unrelated analysis limitations, it did not achieve any \nfewer overall refutations on our real benchmarks. Nevertheless, our testing con.rmed hypothesis (3): \nour loop invariant inference was clearly necessary to properly handle Android HashMap s and similar data \nstructures.  Implementation. THR E S H E R is built on top of the on the WALA program analysis framework \nfor Java and uses the Z3 [19] SMT solver with JVM support via ScalaZ3 [34] to determine when path constraints \nare unsatis.able. Like most static analysis tools that handle real-world programs, our tool has a few \nknown sources of unsoundness. We do not reason about re.ection or handle con\u00adcurrency. We have source \ncode for most (but not all) non-native Java library methods. In particular, the Android library custom \nimplementations of core Java library classes (including collec\u00adtions) that we analyze. To focus our reasoning \non Android library and application code, we exclude classes from Apache libraries, java/nio/Charset, \nand java/util/concurrent from the call graph. Though we track control .ow due to thrown exceptions, we \ndo not handle the catch() construct; instead, we assume that thrown exceptions are never caught. Android \napps are event-driven and (in general) Android event handlers can be called any number of times and in \n(almost) any order. We use a top-level harness that invokes every event handler de.ned for an application. \nOur harness allows event handlers to be invoked in any order, but insists that each handler is called \nonly once in order to prevent termination issues. In our experiments, we did not observe any unsound \nrefutations due to these limitations. We do not do any modeling for special Android components such as \nIntent s and BroadcastReceiver s. Since most special com\u00adponents are used for communication between applications \nthat run in separate memory spaces, we would not expect THR E S H E R to miss any memory leaks due to \nthis modeling issue. 5. Related Work Dillig et al. present precise heap analyses for programs manipulat\u00ading \narrays and containers [21, 22], with path and context sensitiv\u00ad ity [20]. Our analysis introduces path \nand context sensitivity via on-demand re.nement, in contrast to their exhaustive, summary\u00adbased approach. \nOur symbolic variables are similar to their index variables [21, 22] in that both symbolically represent \nconcrete loca\u00ad tions and enable lazy case splits. Unlike index variables, our sym\u00adbolic variables do \nnot distinguish speci.c array indices or loop it\u00aderations, since this was not required for our memory \nleak client. Also, our analysis does not require container speci.cations [22]; in\u00ad stead, we analyze \ncontainer implementations directly. Hackett and Aiken [29] present a points-to analysis with intra-procedural \npath sensitivity, which is insuf.cient for our needs. Several previous systems focused on performing \neffective back\u00adward symbolic analysis. The pioneering ESC/Java system [27] per\u00ad formed intra-procedural \nbackward analysis, generating a polyno\u00admially-sized veri.cation condition and checking its validity with \na theorem prover. Snugglebug [11] performed inter-procedural back\u00ad ward symbolic analysis, employing \ndirected call graph construction and custom simpli.ers to improve scalability. Cousot et al. [17] present \nbackward symbolic analysis as one of a suite of techniques for transforming intermittent assertions in \na method into executable pre-condition checks. PSE [39] used backward symbolic analysis to help explain \nprogram failures, but for greater scalability, it did not represent full path conditions. Our work is \ndistinguished from these previous systems by the integration of points-to analysis informa\u00adtion, which \nenables key optimizations like mixed symbolic-explicit states and abstraction for loop handling. Our \nanalysis can be seen as re.ning the initial .ow-insensitive abstraction of the points-to analysis based \non a counterexam\u00adple reachability query deemed feasible by that analysis. How\u00adever, instead of gradually \nre.ning this abstraction as in, for exam\u00adple, counterexample-based abstraction re.nement (CEGAR) [13] \nand related techniques [16] , our technique immediately employs concrete reasoning about the program, \nand then re-introduces ab\u00adstraction as needed (e.g., to handle loops). In general, the above predicate-abstraction-based \napproaches have not been shown to work well for proving properties of object-oriented programs, which \npresent additional challenges due to intensive heap usage, frequent virtual dispatch, etc. Architecturally, \nour system is more similar to recent staged analyses for typestate veri.cation [25, 26], but our system \nemploys greater path sensitivity and more deeply integrates points-to facts from the initial analysis \nstage. A path program [7] was originally de.ned in the context of improving CE-GAR by pruning multiple \ncounterexample traces through a loop at once. SMPP [30] performs SMT-based veri.cation by exhaus\u00ad tively \nenumerating path programs in a forward-chaining manner (in contrast to our goal-directed search). The \nrecent DASH system [4] re.nes its abstraction based on information from dynamic runs and employs dynamic \ninformation to reduce explosion due to aliasing. Our witness-refutation search uses the bounded fragment \nof separation logic [41] and thus has a peripheral connection to recent separation-logic based shape \nanalyzers [6, 12]. In contrast to such analyzers, we do not use inductive summaries and instead use materializations \nfrom a static points-to analysis abstraction. Shape analysis using bi-abductive inference [10] enables \na compositional analysis by deriving pre-and post-conditions for methods in a bottom-up manner and making \na best effort to reach top-level entry points. The derivation of heap pre-conditions is somewhat similar \nto our witness-refutation search over points-to constraints, but our backwards analysis is applied on \ndemand from a .ow-insensitive query and is re.ned by incorporating information from an up-front, whole \nprogram points-to analysis. Recent work [24] has applied bi\u00ad abduction to detect real Java memory leaks \nin the sense of an object that is allocated but never used again. In contrast, our client is a .ow-insensitive \nheap reachability property that over-approximates a leak that is not explicit in the code, but is realized \nin the Android run-time. Similar to our path program witnesses, other techniques have aimed to either \nproduce a concrete path witness for some program error or help the user to discover one. Bourdoncle [9] \npresents a system for abstract debugging of program assertions, in which the compiler aims to discover \ninputs leading to violations statically. Rival [42] presents a system based on combined forward and back\u00ad \nward analysis for elucidating and validating error reports from the Astr \u00b4ee system [15]. Work by Ball \net al. [3] observes that for show\u00ad ing the existence of program errors (as opposed to verifying their \nabsence), a non-standard notion of abstraction suf.ces in which one only requires the existence of a \nconcrete state satisfying any partic\u00adular property of the corresponding abstract state (as opposed to \nall corresponding concrete states satisfying the property). We observe an analogous difference between \nrefutation and witness discovery in Section 3. Similar notions underlie the proof obligation queries \nand failure witness queries in recent work on error diagnosis [23]. Previous points-to analyses have \nincluded re.nement to im\u00adprove precision. Guyer and Lin s client-driven pointer analysis [28] introduced \ncontext and .ow sensitivity at possibly-polluting pro\u00adgram points based on client needs. Sridharan and \nBodik [44] pre\u00ad sented an approach for adding .eld and context sensitivity to a Java points-to analysis \nvia re.nement. Recently, Liang et al. [36 38] have shown that highly-targeted re.nements of a heap abstraction \ncan yield suf.cient precision for certain clients. Unlike our work, none of the aforementioned techniques \ncan introduce path sensi\u00adtivity via re.nement. A recent study on Andersen s analysis [8] used dependency \nrules akin to a fully-explicit analog of our mixed symbolic-explicit transfer functions in a .ow-insensitive \ncontext.  6. Conclusion We have presented THR E S H E R, a precise static analysis for rea\u00adsoning about \nheap reachability with .ow-, context-, and path\u00adsensitivity and location materialization. THR E S H E \nR introduces such precision in an on-demand manner after running a .ow\u00adinsensitive points-to analysis. \nBy integrating .ow-insensitive points\u00adto facts directly into a mixed symbolic-explicit representation \nof the program state and computing suf.ciently strong loop invariants automatically, our techniques scale \nwell while maintaining good precision. In our evaluation, we applied TH RE SHE R to the prob\u00adlem of detecting \nan important class of Android memory leaks and discovered real leaks while signi.cantly improving precision \nover points-to analysis alone. Acknowledgments. We thank Sriram Sankaranarayanan and the CUPLV group \nfor insightful discussions, as well as the anonymous reviewers for their helpful comments. This research \nwas supported in part by NSF under grant CCF-1055066. References [1] L. O. Andersen. Program Analysis \nand Specialization for the C Programming Language. PhD thesis, University of Copenhagen, DIKU, 1994. \n[2] T. Ball and S. K. Rajamani. Automatically validating temporal safety properties of interfaces. In \nSPIN, 2001. [3] T. Ball, O. Kupferman, and G. Yorsh. Abstraction for falsi.cation. In CAV, 2005. [4] \nN. Beckman, A. V. Nori, S. K. Rajamani, and R. J. Simmons. Proofs from tests. In ISSTA, 2008. [5] J. \nBerdine, C. Calcagno, and P. W. O Hearn. Symbolic execution with separation logic. In APLAS, 2005. [6] \nJ. Berdine, C. Calcagno, B. Cook, D. Distefano, P. W. O Hearn, T. Wies, and H. Yang. Shape analysis for \ncomposite data structures. In CAV, 2007. [7] D. Beyer, T. A. Henzinger, R. Majumdar, and A. Rybalchenko. \nPath invariants. In PLDI, 2007. [8] S. Blackshear, B.-Y. E. Chang, S. Sankaranarayanan, and M. Sridha\u00adran. \nThe .ow-insensitive precision of andersen s analysis in practice. In SAS, 2011. [9] F. Bourdoncle. Abstract \ndebugging of higher-order imperative lan\u00adguages. In PLDI, 1993. [10] C. Calcagno, D. Distefano, P. W. \nO Hearn, and H. Yang. Composi\u00adtional shape analysis by means of bi-abduction. In POPL, 2009. [11] S. \nChandra, S. J. Fink, and M. Sridharan. Snugglebug: a powerful approach to weakest preconditions. In PLDI, \n2009. [12] B.-Y. E. Chang and X. Rival. Relational inductive shape analysis. In POPL, 2008. [13] E. M. \nClarke, O. Grumberg, S. Jha, Y. Lu, and H. Veith. Counterexample-guided abstraction re.nement for symbolic \nmodel checking. J. ACM, 50(5), 2003. [14] P. Cousot and R. Cousot. Abstract interpretation: A uni.ed \nlattice model for static analysis of programs by construction or approxima\u00adtion of .xpoints. In POPL, \n1977. [15] P. Cousot, R. Cousot, J. Feret, L. Mauborgne, A. Min \u00b4e, D. Monniaux, and X. Rival. The ASTRE \n\u00b4 E analyzer. In ESOP, 2005. [16] P. Cousot, P. Ganty, and J.-F. Raskin. Fixpoint-guided abstraction \nre.nements. In SAS, 2007. [17] P. Cousot, R. Cousot, and F. Logozzo. Precondition inference from intermittent \nassertions and application to contracts on collections. In VMCAI, 2011. [18] M. Das, S. Lerner, and M. \nSeigle. ESP: Path-sensitive program veri.cation in polynomial time. In PLDI, 2002. [19] L. M. de Moura \nand N. Bj\u00f8rner. Z3: An ef.cient SMT solver. In TACAS, 2008. [20] I. Dillig, T. Dillig, and A. Aiken. \nSound, complete and scalable path\u00adsensitive analysis. In PLDI, 2008. [21] I. Dillig, T. Dillig, and A. \nAiken. Fluid updates: Beyond strong vs. weak updates. In ESOP, 2010. [22] I. Dillig, T. Dillig, and A. \nAiken. Precise reasoning for programs using containers. In POPL, 2011. [23] I. Dillig, T. Dillig, and \nA. Aiken. Automated error diagnosis using abductive inference. In PLDI, 2012. [24] D. Distefano and I. \nFilipovi\u00b4 c. Memory leaks detection in Java by bi\u00adabductive inference. In FASE, 2010. [25] N. Dor, S. \nAdams, M. Das, and Z. Yang. Software validation via scalable path-sensitive value .ow analysis. In ISSTA, \n2004. [26] S. J. Fink, E. Yahav, N. Dor, G. Ramalingam, and E. Geay. Effective typestate veri.cation \nin the presence of aliasing. ACM Trans. Softw. Eng. Methodol., 17(2), 2008. [27] C. Flanagan, K. R. M. \nLeino, M. Lillibridge, G. Nelson, J. B. Saxe, and R. Stata. Extended static checking for Java. In PLDI, \n2002. [28] S. Z. Guyer and C. Lin. Error checking with client-driven pointer analysis. Sci. Comput. Program., \n58(1-2), 2005. [29] B. Hackett and A. Aiken. How is aliasing used in systems software? In FSE, 2006. \n[30] W. R. Harris, S. Sankaranarayanan, F. Ivancic, and A. Gupta. Program analysis via satis.ability \nmodulo path programs. In POPL, 2010. [31] T. A. Henzinger, R. Jhala, R. Majumdar, and G. Sutre. Lazy \nabstrac\u00adtion. In POPL, 2002. [32] S. S. Ishtiaq and P. W. O Hearn. BI as an assertion language for mutable \ndata structures. In POPL, 2001. [33] S. Khurshid, C. S. Pasareanu, and W. Visser. Generalized symbolic \nexecution for model checking and testing. In TACAS, 2003. [34] A. S. Kksal, P. Suter, and V. Kuncak. \nScala to the Power of Z3: Integrating SMT and Programming. In CADE, 2011. [35] K. R. M. Leino and F. \nLogozzo. Loop invariants on demand. In APLAS, 2005. [36] P. Liang and M. Naik. Scaling abstraction re.nement \nvia pruning. In PLDI, 2011. [37] P. Liang, O. Tripp, M. Naik, and M. Sagiv. A dynamic evaluation of the \nprecision of static heap abstractions. In OOPSLA, 2010. [38] P. Liang, O. Tripp, and M. Naik. Learning \nminimal abstractions. In POPL, 2011. [39] R. Manevich, M. Sridharan, S. Adams, M. Das, and Z. Yang. PSE: \nexplaining program failures via postmortem static analysis. In FSE, 2004. [40] A. Milanova, A. Rountev, \nand B. G. Ryder. Parameterized object sensitivity for points-to analysis for Java. ACM Trans. Softw. \nEng. Methodol., 14(1), 2005. [41] J. C. Reynolds. Separation logic: A logic for shared mutable data structures. \nIn LICS, 2002. [42] X. Rival. Understanding the origin of alarms in Astr\u00b4ee. In SAS, 2005. [43] M. Sagiv, \nT. Reps, and R. Wilhelm. Solving shape-analysis problems in languages with destructive updating. ACM \nTrans. Program. Lang. Syst., 20(1), 1998. [44] M. Sridharan and R. Bod\u00b4ik. Re.nement-based context-sensitive \npoints-to analysis for Java. In PLDI, 2006. [45] B. Woolf. Null object. In Pattern languages of program \ndesign 3. Addison-Wesley Longman Publishing Co., Inc., 1997.   \n\t\t\t", "proc_id": "2491956", "abstract": "<p>We present a precise, path-sensitive static analysis for reasoning about heap reachability, that is, whether an object can be reached from another variable or object via pointer dereferences. Precise reachability information is useful for a number of clients, including static detection of a class of Android memory leaks. For this client, we found the heap reachability information computed by a state-of-the-art points-to analysis was too imprecise, leading to numerous false-positive leak reports. Our analysis combines a symbolic execution capable of path-sensitivity and strong updates with abstract heap information computed by an initial flow-insensitive points-to analysis. This novel mixed representation allows us to achieve both precision and scalability by leveraging the pre-computed points-to facts to guide execution and prune infeasible paths. We have evaluated our techniques in the Thresher tool, which we used to find several developer-confirmed leaks in Android applications.</p>", "authors": [{"name": "Sam Blackshear", "author_profile_id": "81460655714", "affiliation": "University of Colorado, Boulder, CO, USA", "person_id": "P4149020", "email_address": "samuel.blackshear@colorado.edu", "orcid_id": ""}, {"name": "Bor-Yuh Evan Chang", "author_profile_id": "81464662824", "affiliation": "University of Colorado, Boulder, CO, USA", "person_id": "P4149021", "email_address": "evan.chang@colorado.edu", "orcid_id": ""}, {"name": "Manu Sridharan", "author_profile_id": "81100641428", "affiliation": "IBM T.J. Watson Research Center, Yorktown Heights, NY, USA", "person_id": "P4149022", "email_address": "msridhar@us.ibm.com", "orcid_id": ""}], "doi_number": "10.1145/2491956.2462186", "year": "2013", "article_id": "2462186", "conference": "PLDI", "title": "Thresher: precise refutations for heap reachability", "url": "http://dl.acm.org/citation.cfm?id=2462186"}