{"article_publication_date": "06-16-2013", "fulltext": "\n Asynchronous Functional Reactive Programming for GUIs Evan Czaplicki Stephen Chong Harvard University \nHarvard University evan.czaplicki@post.harvard.edu chong@seas.harvard.edu Abstract Graphical user interfaces \n(GUIs) mediate many of our interac\u00adtions with computers. Functional Reactive Programming (FRP) is a promising \napproach to GUI design, providing high-level, declara\u00adtive, compositional abstractions to describe user \ninteractions and time-dependent computations. We present Elm, a practical FRP language focused on easy \ncreation of responsive GUIs. Elm has two major features: simple declarative support for Asynchronous \nFRP; and purely functional graphical layout. Asynchronous FRP allows the programmer to specify when the \nglobal ordering of event processing can be violated, and thus en\u00adables ef.cient concurrent execution \nof FRP programs; long-running computation can be executed asynchronously and not adversely af\u00adfect the \nresponsiveness of the user interface. Layout in Elm is achieved using a purely functional declarative \nframework that makes it simple to create and combine text, images, and video into rich multimedia displays. \nTogether, Elm s two major features simplify the complicated task of creating responsive and usable GUIs. \nCategories and Subject Descriptors D.3.2 [Language Classi.ca\u00adtions]: Data-.ow languages; Applicative \n(functional) languages General Terms Languages, Design Keywords Functional Reactive Programming, Graphical \nUser In\u00adterfaces 1. Introduction Elm is a functional reactive programming language that aims to simplify \nthe creation of responsive graphical user interfaces (GUIs), and speci.cally targets GUIs for web applications. \nFunc\u00adtional reactive programming (FRP) applies pure functional pro\u00adgramming paradigms to time-varying \nvalues, known as signals. FRP is a highly promising approach for implementing GUIs, where time-varying \nvalues can represent input and output (including user interaction, server requests and responses), and \nother information about the execution environment. By enforcing a purely functional programming style, \nprogrammers can explicitly model complex time-dependent relationships in a high-level declarative way. \nHowever, previous FRP languages and implementations have suffered from at least two kinds of inef.ciencies: \nunnecessary recomputation and global delays. Permission to make digital or hard copies of all or part \nof this work for personal or classroom use is granted without fee provided that copies are not made or \ndistributed for pro.t or commercial advantage and that copies bear this notice and the full citation \non the .rst page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires \nprior speci.c permission and/or a fee. PLDI 13, June 16 19, 2013, Seattle, WA, USA. Copyright c &#38;#169; \n2013 ACM 978-1-4503-2014-6/13/06. . . $10.00 Semantics of most FRP languages assume that signals change \ncontinuously. Thus, their implementations sample input signals as quickly as possible, and continually \nrecompute the program with the latest values for the signals. In practice, however, many sig\u00adnals change \ndiscretely and infrequently, and so constant sampling leads to unnecessary recomputation. By contrast, \nElm assumes that all signals are discrete, and uses this assumption to detect when a signal is unchanged, \nand in that case, avoid unnecessary recompu\u00adtation. In Elm, signals change only when a discrete event \noccurs. An event occurs when a program input (such as the mouse position) changes. Events require recomputation \nof the program, as the result of the program may have changed. Previous FRP systems require that events \nare processed synchronously: one at a time in the exact order of occurrence. In general, synchronization \nis required to allow the programmer to reason about the behavior of the FRP system, and ensure correct \nfunctionality. However, processing an event may take signi.cant time, result\u00ading in delays to the entire \nFRP system. Pipelining event processing can help to reduce latency, but because the global order of events \nmust be respected, an event cannot .nish processing until all pre\u00advious events have .nished. In GUIs, \nthis is unacceptable behavior: the user interface should remain responsive, even if a previous user action \ntriggered a long-running computation. Elm provides programmers with a simple abstraction to spec\u00adify \nwhen computation can occur asynchronously. Combined with pipelined execution of event processing, this \nallows long-running computation to execute concurrently with other event processing, avoids global delays, \nand allows GUIs to remain responsive. The ability to specify asynchronous computation within an FRP paradigm \nis the key novelty of Elm. We formalize this language feature by presenting the semantics of a core Asynchronous \nFRP calculus. However, Elm is also a practical and expressive program\u00adming language, which we demonstrate \nthrough the implementation of an Elm compiler, and the use of the resulting compiler to develop rich, \nresponsive GUIs that perform non-trivial computation. The Elm compiler produces JavaScript code that \ncan be immediately and easily deployed in web applications. Elm is publicly available.1 Like previous \nwork on ef.cient FRP (e.g., [25, 30, 31]), Elm restricts use of signals to enable ef.cient implementation. \nElm is strictly more expressive than these previous approaches, since (1) discrete signals generalize \ncontinuous signals [31], (2) we em\u00ad bed a discrete version of Arrowized FRP [25] in Elm, and (3) we additionally \nallow the programmer to specify when signal updates should be computed asynchronously. The rest of the \npaper is structured as follows. In Section 2 we describe key features of Elm through several simple Elm \nprograms. In Section 3 we present a formalization of the core language of Elm, including semantics and \na type system. The full Elm language 1 Available at http://elm-lang.org/.   Figure 1. Purely functional \ngraphics: basic layout extends the core language with libraries and syntactic sugar to sim\u00adplify the \ncreation of expressive GUIs. In Section 4 we describe some of these libraries (including the embedding \nof discrete Arrow\u00adized FRP [25]). Elm has a fully functional compiler that compiles Elm programs to JavaScript \nand HTML, suitable for immediate in\u00adclusion in web applications. We describe the compiler in Section \n5. We discuss related work in Section 6 and conclude in Section 7. 2. Elm through Examples We present \nkey features of Elm through several simple Elm pro\u00adgrams. The .rst example highlights Elm s purely functional \ngraph\u00adical layout. The second example demonstrates how Elm s graph\u00adics primitives use FRP to easily produce \nrich interactive GUIs. The third example shows Elm s async construct, which allows programmers to specify \nthat potentially long-running computation should execute asynchronously, and thus ensures that the user \nin\u00adterface remains responsive. Example 1 The following Elm program lays out three graphical elements \nvertically, as shown in Figure 1. content = flow down [ plainText \"Welcome to Elm!\" , image 150 50 \"flower.jpg\" \n, asText (reverse [1..9]) ] main = container 180 100 middle content Variable main is distinguished in \nElm: the value of this variable will be displayed on the screen when the program is executed. In the \nprogram above, main is de.ned to be a 180 by 100 container with content de.ned by variable content. The \ncontent is placed in the middle of the container. (Positioning elements is notoriously dif.cult in HTML; \nElm provides a simple abstraction, allowing the position of content within a container to be speci.ed \nas topLeft, midTop, topRight, midLeft, middle, and so on.) Variable content has type Element, indicating \nthat it is a graphical element that can be displayed, and/or composed with other graphical elements. \nThe value of content at runtime is a composite element, comprising three elements stacked vertically. \nThe three elements are the text \"Welcome to Elm!\", a 150 by 50 image, and the text representation of \na list containing numbers from 9 down to 1, which are combined together using function flow : Direction \n-> [Element] -> Element (i.e., flow is a function that takes a value of type Direction, a list of Elements, \nand produces an Element). Values of type Element occupy a rectangular area of the screen when displayed, \nmaking Elements easy to compose. Elm provides primitives and library functions to create more complex \nElement values, and non-rectangular graphical elements. Elm and its li\u00adbraries provide a simple declarative \nsyntax and semantics, making layout easy to reason about. Example 2 This example displays the position \nof the mouse pointer, as seen in Figure 2. Although extremely simple to de- Figure 2. A basic FRP program: \ntracking mouse movement scribe, this is often head-scratchingly dif.cult to implement in to\u00adday s GUI \nframeworks, since the content is dynamically updated. In Elm, however, it is a one liner: main = lift \nasText Mouse.position This code relies on signals, which are the key abstraction of FRP. A signal is \na value that changes over time. In Elm, a signal that represents a value of type t changing over time \nhas type Signal t . For example, a graphical element that changes over time, such as an animation, is \na Signal Element. Indeed, variable main typically has type Signal Element, since what to display on the \nscreen changes over time.2 In the code above, the position of the mouse is represented as a signal of \na pair of integers, indicating the coordinates of the mouse. Mouse.position : Signal (Int,Int) Function \nlift : (a -> b) -> Signal a -> Signal b takes a function from values of type a to values of type b, and \na signal of values of type a, and applies the function to each value, resulting in a signal of type b. \nIn the example above, func\u00adtion asText : a -> Element (which converts Elm values into a textual representation) \nis applied to every value of the signal Mouse.position, thus converting a signal of coordinates into \na signal of Elements. As the position of the mouse changes, so does the Element that is being displayed. \nThis is shown in Figure 2. In Elm, all signals are discrete. That means that instead of the system needing \nto frequently sample a continuously changing value (i.e., the system pulls values from the external environment), \nthe system waits to be noti.ed when the value has changed (i.e., values are pushed to the system only \nwhen they change). Elm is a push-based system [12], meaning that computation is performed only when values \nchange. This reduces needless recomputation. In the example above, function asText is only applied to \na mouse coordinate when the mouse position changes. Example 3 This example highlights Elm s ability to \nperform asynchronous computation over signals. It uses words entered by the user to .nd and fetch an \nimage from a web service (such as Flickr), which may take signi.cant time. The program simultane\u00adously \ndisplays the current position of the mouse, with the position being updated in a timely manner, regardless \nof how long image fetching takes. (inputField, tags) = Input.text \"Enter a tag\" getImage tags = lift \n(fittedImage 300 200) (syncGet (lift requestTag tags)) scene input pos img = flow down [ input, asText \npos, img ] main = lift3 scene inputField Mouse.position (async (getImage tags)) 2 Variable main is also \nallowed to have type Element, as in Example 1.  Code Input.text \"Enter a tag\" creates a text input .eld, \nand returns a pair (inputField, tags), where inputField is a signal of graphical elements for the input \n.eld, and tags is a signal of strings. Each time the text in the input .eld changes (due to the user \ntyping), both signals produces a new value: the updated element and the current text in the input .eld. \nFunction getImage takes a signal of strings, and returns a sig\u00adnal of images. For each string that the \nuser enters, this function requests from the server a URL of an image with tags (i.e., key\u00adwords) that \nmatch the string. Function requestTag takes a string, and constructs an appropriate HTTP request to the \nserver. (We elide the de.nition of requestTag, which simply performs string con\u00adcatenation.) Expression \nlift requestTag tags is thus a signal of HTTP requests. Built-in function syncGet issues the requests, \nand evaluates to a signal of image URLs (actually, a signal of JSON objects returned by the server requests; \nthe JSON objects contain image URLs). Function fittedImage (de.nition elided) takes di\u00admensions and an \nimage URL and constructs an image Element. Function scene takes as its arguments input (an Element), \npos (an arbitrary value) and img (an Element), and composes them vertically. Value main puts the pieces \ntogether, applying function scene to three signals: the signal of elements representing the text .eld \nin which the user types, the mouse position (Mouse.position), and the signal of images derived from the \nuser s input (getImage tags). Primitive function lift3 is similar to function lift described above, but \ntakes a function a -> b -> c -> d, a signal of values of type a, a signal of values of type b, and a \nsignal of values of type c, and applies the function to the current values of the three signals, each \ntime any of the three signals produces a new value. Keyword async indicates that the getImage computation \nshould run asynchronously. Without the async keyword, the pro\u00adgram must respect the global ordering of \nevents: when the tags signal produces a new string, processing of new Mouse.position values must wait \nuntil an image is fetched from the server. The result would be an unresponsive GUI that hangs (i.e., \ndoes not dis\u00adplay the current mouse position) from when the user types in the input .eld until an image \nis fetched. By contrast, with the async keyword, the program does not have to respect the order of values \ngenerated by getImage tags with respect to values generated by Mouse.position. The GUI remains responsive, \nregardless of how long it takes to fetch an image from the web service. The async construct can be applied \nto any signal, and provides a simple, composable way for the programmer to specify when computation over \na signal may occur asynchronously, and thus to ensure that long-running computation does not cause the \nGUI to become unresponsive. The behavior of this example Elm program is dif.cult to im\u00adplement in most \npractical programming frameworks. For example, implementation with JavaScript+AJAX requires nested call-backs. \nAlso, such an example is impossible to implement in current FRP languages as no previous work permits \nexplicit asynchrony and concurrent execution. 3. Core Language The full Elm language contains libraries \nand syntactic sugar that simplify the creation of rich and responsive GUIs. In this section, we present \na simple core language FElm, for Featherweight Elm that presents the semantics of Elm s key abstractions. \nFElm combines a simply-typed functional language with a small set of reactive primitives. Programmers \nhave direct access to signals, which can be transformed and combined with the full power of a functional \nlanguage. A type system restricts the use of reactive primitives to ensure that the program can be executed \nef.ciently. FElm uses a two-stage semantics. In the .rst stage, func- Numbers n . Z Variables x . Var \nInput signals i . Input Expressions e ::= () | n | x | .x:.. e | e1 e2 | e1 . e2 | if e1 e2 e3 | let \nx = e1 in e2 | i | liftn e e1 ... en | foldp e1 e2 e3 | async e Simple types t ::= unit | int | t . t1 \nSignal types s ::= signal t | t . s | s . s1 Types . ::= t | s Figure 3. Syntax of FElm tional constructs \nare evaluated, and signals are left uninterpreted. In the second stage, signals are evaluated: as the \nexternal environ\u00adment generates new values for input signals, the new values are processed as appropriate. \n 3.1 Syntax The syntax of FElm is presented in Figure 3. Expressions include the unit value (), integers \nn, variables x, functions .x : .. e, appli\u00adcations e1 e2, let expressions let x = e1 in e2, and conditional \nexpressions if e1 e2 e3 which are all standard constructs for func\u00adtional languages. (Conditional expression \nif e1 e2 e3 evaluates to e2 if e1 evaluates to a non-zero value, e3 otherwise.) Metavariable . ranges \nover total binary operations on integers. We assume a set of identi.ers Input that denote input signals \nfrom the external environment, and use i to range over these identi\u00ad.ers. Signals can be thought of as \nstreams of values. For example, an input signal representing the width of a window can be thought of \nas a stream of integer values such that every time the window width changes, a new value for the signal \nis generated. An input sig\u00adnal representing whether the left mouse button is currently pressed down may \nbe represented as a stream of boolean values. Input sig\u00adnals may also include special signals, for example, \nto generate a new unit value at .xed time intervals, creating a timer. An event occurs when an input \nsignal generates a new value. Events may trigger computation. In FElm, every signal always has a current \nvalue: it is the most recent value generated by the signal, or, for an input signal that has not yet \ngenerated a new value, it is an appropriate default value associated with that input signal. Thus, every \ninput signal is required to have a default value, which then induces default values for other signals. \nThe remaining expressions (liftn e e1 ... en, foldp e1 e2 e3, and async e) are primitives for manipulating \nsignals, and are described in more detail below. Transforming and combining signals For each natural \nnumber n = 0, we have primitive liftn e e1 ... en which allows a function e to transform and combine \nsignals e1 . . . en. Intuitively, if e is a function of type t1 . t2 . \u00b7 \u00b7 \u00b7 . tn . t , and expressions \nei are of type signal ti respectively, then liftn e e1 ... en applies function e to the values from signals \ne1 . . . en, and has type signal t (i.e., it is a signal that produces values of type t). For example, \nlift1 (.x :int. x+x) Window.width is a signal of integers obtained by doubling the values from input \nsignal Window.width.  Signals can also be combined. For example, expression lift2 (.y : int. .z : int. \ny \u00f7 z) Mouse.x Window.width takes two input signals of integers (Mouse.x and Window.width), and produces \na signal of integers by combining values from the two input signals. It computes the relative position \nof the mouse s x-coordinate with respect to the window width. Note that the rela\u00adtive position is computed \neach time an event occurs for either input signal. Moreover, events are globally ordered, and signal \ncompu\u00adtation is synchronous in that it respects the global order of events: the sequence of relative \npositions will re.ect the order of events on Mouse.x and Window.width. Past-dependent transformation \nThe liftn primitives operate only on the current values of signals. By contrast, the foldp prim\u00aditive \ncan compute on both the current and previous values of a signal. Primitive foldp performs a fold on a \nsignal from the past, similar to the way in which the standard function foldl performs a fold on lists \nfrom the left of the list. The type of foldp is 111 1 (t . t . t ) . t . signal t . signal t for any \nt and t1. Consider foldp e1 e2 e3. Here, e1 is a function of type t . t 1 . t1 , e2 is a value of type \nt1 and e3 is a signal that produces values of type t . Type t 1 is the type of the accumulator, and e2 \nis the initial value of the accumulator. As values are produced by signal e3, function e1 is applied \nto the new value and the current accumulator, to produce a new accumulator value. Expression foldp e1 \ne2 e3 evaluates to the signal of accumulator values. For example, suppose that Keyboard.lastPressed is \nan input signal that indicates the latest key that has been pressed. Then the following signal counts \nthe number of key presses. (We assume that which key is pressed is encoded as an integer.) foldp (.k \n:int. .c :int. c+1) 0 Keyboard.lastPressed Asynchronous composition The async primitive allows a pro\u00adgrammer \nto specify when certain computations on signals can be computed asynchronously with respect to the rest \nof the program. This annotation allows the programmer to specify when it is per\u00admissible to ignore the \nglobal ordering of events. The use and bene.t of this construct is described in more detail, including \na thorough example, in Section 3.3.2.  3.2 Type System FElm s type system ensures that FElm programs \ncannot produce signals of signals. There are two kinds of types: simple types t and signal types s. Type \nsyntax is presented in Figure 3. Simple types include base types (unit for the unit value and int for \nintegers) and functions from simple types to simple types (t . t 1). Signal types s include type signal \nt (for signals that produce values of type t ), and functions that produce signal types (t . s and s \n. s1). The type system rules out programs that use signals of sig\u00adnals, for the following reason. Intuitively, \nif we have signals of signals, then after a program has executed for, say 10 minutes, we might create \na signal that (through the use of foldp) depends on the history of an input signal, say Window.width. \nTo compute the current value of this signal, should we use the entire history of Window.width? But that \nwould require saving all history of Window.width from the beginning of execution, even though we do not \nknow whether the history will be needed later. Alternatively, we could compute the current value of the \nsignal just using the cur\u00adrent and new values of Window.width (i.e., ignoring the history). But this \nwould allow the possibility of having two identically de\u00ad.ned signals that have different values, based \non when they were created. We avoid these issues by ruling out signals of signals. This T-UN I T T-NU \nMB ER T-VAR T-IN P U T G(x) = . G(i) = signal t G f () : unit G f n : int G f x : . G f i : signal t \n T-LAM T-AS Y N C G, x : . f e : .1 G f e : signal t G f .x:.. e : . . .1 G f async e : signal t T-OP \nT-AP P G f e1 : int G f e1 : . . .1 G f e2 : int G f e2 : . G f e1 . e2 : int G f e1 e2 : .1 T-CO N D \nT-LE T G f e1 : int G f e1 : . G f e2 : . G f e3 : . G, x : . f e2 : .1 G f if e1 e2 e3 : . G f let \nx = e1 in e2 : .1 T-LI F T G f e : t1 . \u00b7 \u00b7\u00b7 . tn . t G f ei : signal ti .i . 1..n G f liftn e e1 ... \nen : signal t T-FO L D G f ef : t . t 1 . t1 G f eb : t 1 G f es : signal t G f foldp ef eb es : signal \nt1 Figure 4. Inference rules for typing judgment G f e : . does not overly restrict the expressiveness \nof the language, which we discuss further in Section 4. The typing judgment for FElm has the form G f \ne : ., indicat\u00ading that expression e has type . under type context G, which maps variables and input \nsignal identi.ers to types. Figure 4 presents in\u00ad ference rules for this judgment. The rules for the \nprimitive operators that manipulate signals are as described above, and the remaining inference rules \nare mostly standard. Note that the typing rule for conditional expressions if e1 e2 e3 requires that \nthe test expres\u00adsion e1 has type int, and in particular, cannot be a signal. A program e is well typed \nif Ginput f e : . holds for a type environment Ginput that maps every input i . Input to a signal type. \n 3.3 Semantics FElm programs are evaluated in two stages. In the .rst stage, all and only functional \nconstructs are evaluated, resulting in a term in an intermediate language that clearly shows how signals \nare connected together. The intermediate language is similar to the source language of Real-Time FRP \n[30] and Event-Driven FRP [31]. In the second stage, signals are evaluated: new values arriving on input \nsignals trigger computation in a push-based manner. 3.3.1 Functional Evaluation We de.ne an intermediate \nlanguage according to the grammar in Figure 5. The intermediate language separates values of simple types \n(unit, numbers, and functions over simple types), and signal terms (which will be the basis for the evaluation \nof signals). A small step operational semantics for evaluation of FElm pro\u00adgrams to the intermediate \nlanguage is given in Figure 6. A FElm program e will evaluate to a .nal term, which is either a simple \nvalue v, or a signal term s. The inference rules use evaluation contexts E to implement a left-to-right \ncall-by-value semantics. Rule APPL IC ATI O N converts function applications to let expres\u00ad  Values \nv ::= () | n | .x :t . e Signal terms s ::= x | let x = s in u | i | liftn v s1 ... sn | foldp v1 v2 \ns | async s Final terms u ::= v | s Figure 5. Syntax of intermediate language E ::= [\u00b7] | E e | E . e \n| v . E | if E e2 e3 | let x = E in e | let x = s in E | liftn E e1 ... en | liftn v s1 ... E ... en \n| foldp E e2 e3 | foldp v1 E e3 | foldp v1 v2 E | async E F ::= [\u00b7] e | [\u00b7] . e | v . [\u00b7] | if F e2 e3 \n| liftn [\u00b7] e1 ... en | foldp [\u00b7] e2 e3 | foldp v1 [\u00b7] e3 CO NT E X T OP CO N D-TRUE e -. e 1 v = v1 \n. v2 v= 0 E[e] -. E[e 1] v1 . v2 -. v if v e2 e3 -. e2 CON D -FA L S E AP P LI CAT ION if 0 e2 e3 -. \ne3 (.x : .. e1) e2 -. let x = e2 in e1 RE D U C E let x = v in e -. e[v/x] EX PA N D x . f v(F [\u00b7]) F \n[let x = s in u] -. let x = s in F [u] Figure 6. Semantics for functional evaluation sions. Rule REDU \nC E performs beta-reduction for let expressions let x = v in e, but only when x is bound to a simple \nvalue. If x is bound to a signal term, then (as shown by context let x = s in E) subexpression e is evaluated \nwithout substitution of x. This ensures that signal expressions are not duplicated, and reduces unnecessary \ncomputation in the second stage of evaluation, which is described in Section 3.3.2. (This is similar \nto a call-by-need calculus [5, 22], which avoids duplication of unevaluated expressions.) Rule EX PA \nN D expands the scope of a let expression to allow evaluation to continue. Contexts F describe where \nRule EXPA N D can be applied, and includes all contexts where a simple value v is required. For a context \nF , we write f v(F [\u00b7]) for the set of free variables in F . We assume that expressions are equivalent \nup to renaming of bound variables, and an appropriate variable x can always be chosen such that x . f \nv(F [\u00b7]). If a FElm program is well typed, then the .rst stage of evalua\u00adtion does not get stuck, and \nalways evaluates to a .nal term. (We write -. * for the re.exive transitive closure of the relation -..) \nTheorem 1 (Type Soundness and Normalization). Let type en\u00advironment Ginput map every input i . Input \nto a signal type. If Ginput f e : . then e -. * u and Ginput f u : . for some .nal term u. lift2 (.y \n: int. .z :int. y \u00f7 z) Mouse.x Window.width Figure 7. Signal graph for relative x-position of mouse \n 3.3.2 Signal Evaluation If a FElm program evaluates to a simple value v, then the program does not use \nsignals, and is not a reactive program. If, however, it evaluates to a signal term s then we perform \nthe second stage of evaluation, performing computation as input signals produce new values. We .rst present \nthe intuition behind signal evaluation, then present a working example to solidify the intuition. We \nthen provide a semantics for signal terms by translation to Concurrent ML (CML) [27]. Intuition A signal \nterm can be visualized as a directed acyclic graph, where nodes are input signals (i . Input), liftn \nterms, and foldp terms. The de.nition and use of variables de.ne edges between the nodes. (Asynchronous \nterms async s are described below.) We refer to these visualizations as signal graphs. Nodes representing \ninput signals have no incoming edges from other signal nodes, a node representing term liftn v s1 ... \nsn has n incoming edges, and a node representing term foldp v1 v2 s has a single incoming edge. Signal \ngraphs are acyclic since FElm has no way to construct recursive signal terms. Figure 7 shows an example \nof a signal graph for a simple FElm program. We refer to nodes with no incoming edges as source nodes. \nSource nodes include input signals, and, as we will see below, async s nodes. Source nodes are the source \nof new values. An event occurs when the signal represented by a source node produces a new value. Input \nsignal events are triggered by the external envi\u00adronment, for example, mouse clicks or key presses. A \nglobal event dispatcher is responsible for notifying source nodes when events occur. The global event \ndispatcher ensures that events are totally ordered and no two events occur at exactly the same time. \nIn signal graphs, we draw dashed lines from the global event dispatcher to all source nodes. Nodes for \nliftn and foldp terms perform computation on values produced by signals. Lift terms perform (pure) computation \non the current values of signals: term liftn v s1 ... sn applies function v to the current values of \nthe n signals to produce a new value. A node for term foldp v1 v2 s maintains the current value of the \naccumulator (initially v2), and when a new value is received from signal s, applies function v1 to the \nnew value and the current value of accumulator, to produce the new value of the accumulator, which is \nalso the new value for the signal foldp v1 v2 s. Conceptually, signal computation is synchronous: when \nan event occurs (i.e., a source node produces a new value), then it is as if the new value propagates \ncompletely through the signal graph before the next event is processed. However, if the actual semantics \nused this approach, then global delays would occur, as processing of a new event would be blocked until \nprocessing of all previous events has .nished. We maintain the simple synchronous semantics, but allow \nmore ef.cient implementations, by pipelining the execution of the signal graph: conceptually, each node \nin a signal graph has its own thread of control to perform computation, and each edge in a signal graph \nholds an unbounded FIFO queue of values. Whenever an event occurs, all source nodes are noti.ed by the \nglobal event dispatcher: the one source node to which the event is relevant produces the new value, and \nall other source nodes generate a special value noChange v, where v is the current (unchanged) value \nof the signal. Thus, every source node produces one value for each event. When a node in the signal graph \nperforms computation, it must take a value from the front of each incoming edge s queue: computation \nat the node is blocked until values are available on all incoming edges. If all incoming values indicate \nno change, then the node does not perform any new computation, but instead propagates the value noChange \nv 1, where v 1 is the latest value of the signal represented by the node. If any value on the incoming \nedge is a new value (i.e., is not a noChange v value), then the node performs computation (which, in \nthe case of a foldp node, updates the state) and propagates the newly computed value. This preserves \nthe simple synchronous semantics, but allows computation at each node to occur in parallel.  The noChange \nv 1 values are a form of memoization allowing nodes to avoid needless recomputation but in the case of \nfoldp nodes, are also critical to ensure correct execution. For example, a foldp term that counts the \nnumber of key presses (as in Sec\u00adtion 3.1) should increment the counter only when a key is actually pressed, \nnot every time any event occurs. The synchrony of execution can be bypassed with the async construct. \nThe node for a term async s is a source node: it has no incoming edges from other signal nodes, and whenever \nan event at another source node occurs, a noChange v value is propagated from the node. When signal s \nproduces a new value, then a new event for term async s is generated. That is, when s produces a value, \nit is treated like an event from the external environment, and will be processed in a pipelined manner \nby the signal graph. The async construct, combined with pipelined execution of the signal graph, allows \nthe programmer to easily separate long-running com\u00adputations, while maintaining a relatively straightforward \nsemantics for the FRP program. This allows a programmer to ensure that a GUI remains responsive even \nin the presence of signi.cant compu\u00adtation trigged by user actions. Example Consider the following program \nwhich takes in a signal of English words, pairing both the original word and the French translation of \nthe word in a 2-tuple: wordPairs = lift2 (,) words (lift toFrench words) For simplicity, we assume that \nwords is an input signal (i.e., words are given by the external environment), and function toFrench takes \nan English word and produces a French word, and may take signi.cant time to perform the translation. \nFunction (,) takes two arguments and constructs a pair from them. The signal graph for wordPairs is shown \nin Figure 8(a). Although function toFrench may take signi.cant time, it is important that the propagation \nof values from signal words is synchronous, as each English word must be matched up with its translation. \nThis example motivates the need for FRPs to be synchronous: the programmer must be able to ensure that \nvalues from signals are matched up appropriately. However, there is a tension between synchronization \nand fast updates. Consider an expression that combines our wordPairs signal with the mouse position. \nlift2 (,) wordPairs Mouse.position The intent of this program is to display the current position of the \nmouse, in addition to translating English words to French. Figure 8(b) shows the signal graph for this \nprogram. However, synchronous update means that while translation is occurring, the mouse position will \nnot be updated. In this case, it is not important to maintain the synchronization between updates of \nthe mouse position and updates of the wordPairs signal: it is perfectly .ne (a) (b) (c) Figure 8. Example \nsignal graphs (and, in this case, preferable) to allow the mouse events to jump ahead of the translation \ncomputation. The async primitive allows the programmer to break this syn\u00adchronization in a controlled \nway. Informally, the annotation says this subgraph does not need to respect the global order of events \n. The following code uses async to indicate that the wordPairs subgraph should not block mouse updates. \nlift2 (,) (async wordPairs) Mouse.position The signal graph for this program, shown in Figure 8(c), has \ntwo distinct sections: the primary subgraph that combines translation pairs with the mouse position and \nthe secondary subgraph that produces translation pairs. Effectively, the async primitive breaks a fully \nsynchronous graph into one primary subgraph and an arbitrary number of secondary subgraphs. Event order \nis maintained within each subgraph, but not between them. The resulting graph is more responsive, but \nit does not respect global event ordering. In the example above, this is a desirable improvement. Translation \nto Concurrent ML We de.ne the semantics of FElm by translation to Concurrent ML (CML) [27]. We target \nCML because it has simple support for concurrency, it is type safe, and its theory is well understood. \nThe translation to CML is a direct instantiation of the intuition given above: each node in the signal \ngraph has a thread that per\u00adforms computation for the node, there is a channel for each edge in the signal \ngraph (representing the FIFO queue for the edge), and the global event dispatcher is explicitly represented. \nFigure 9 de.nes a datatype and several CML helper functions that assist with the translation. The event \ndata type wraps a value to indicate whether the value of the signal has changed. Function change takes \nan event value, and indicates whether it represents a changed value or not, and function bodyOf unwraps \nan event value to return the actual value. Function guid is used to obtain unique identi.ers for source \nnodes. Figure 10 presents the translation of signal terms to CML. Translation of signal s, denoted [s], \nproduces a pair (v,c), where  datatype a event = NoChange a | Change a change e = case e of | NoChange \n_ => False | Change _ => True bodyOf e = case e of | NoChange v => v | Change v => v counter = ref 0 \nguid () = counter := !counter + 1; !counter Figure 9. Translation helper functions = [ (i, mci, vi) ] \n[i] [ (id, mc, v) ] = spawn (fn _ => loop v) ; (v, cout) where cout = mailbox () loop prev = let msg \n= if (recv (port eventNotify)) == id then Change (recv (port mc)) else NoChange prev in send cout msg \n; loop (bodyOf msg) [liftn f s1 ... sn] = spawn (fn _ => loop v) ; (v, cout) where (v1, c1), ... , (vn, \ncn) = [s1], ... , [sn] v, cout = v1 ... vn, mailbox () [f]V loop prev = let (m1, ... , mn) = (recv c1, \n... , recv cn) msg = if exists change [m1, ... , mn] then Change ([f]V (bodyOf x1) ... (bodyOf xn)) else \nNoChange prev in send cout msg ; loop (bodyOf msg) [foldp f v s] = spawn (fn _ => loop [v]V ) ; ([v]V \n, cout) where (_, cin), cout = [s], mailbox () loop acc = let msg = case recv cin of | NoChange _ -> \nNoChange acc | Change v -> Change v acc) ([f]V in send cout msg ; loop (bodyOf msg) [let x = sin in sout] \n= spawn loop ; (let xv,xch = v,mcout in [sout]) where (v, cin), mcout = [sin], mChannel () loop () = \nsend mcout (recv cin) ; loop () = (xv, port xch) [x] = [v] [v]V [async s] = spawn loop ; [ (id, cout, \nd) ]where (d, cin), cout, id = mChannel (), guid () [s], loop () = case recv cin of | NoChange _ -> loop \n() | Change v -> send cout v ; send newEvent id ; loop () Figure 10. Translation from signal terms to \nCML v is the default and initial value of the signal, and c is a mailbox, a buffered non-blocking channel \nto which new values of the signal are sent. Recall that we assume that every input signal has an appropriate \ndefault value, which then induces default values for all other signals. We assume a translation function \n[\u00b7]V that translates values (i.e., unit (), integers n, and functions .x:t. e) to CML. The translation \nof each signal term creates a new thread that performs computation to produce values for the signal. \nFor source nodes, this involves listening on a multicast channel for messages sent from the global dispatcher. \nFor other nodes, the thread waits for input on all incoming edges, then either performs the appropri\u00adate \ncomputation for the node (if at least one of the incoming values is an event of the form Change v), or \npropagates an event value NoChange v where v is the latest computed value for the signal. We now describe \nthe translation of each signal term in more detail. The translation for input signal i assumes that i \nis a CML in\u00adteger value, that there is a suitable default value vi for the signal, and that there is \na multicast channel mci on which new values for the input signal will be sent. We abstract translation \nof this triple (i, mci, vi), since it is re-used by the translation for async. Trans\u00adlation of the triple \ncreates a mailbox cout to publish values for the input signal. It creates a thread that receives messages \nfrom the global event dispatcher on the eventNotify multicast channel ( recv (port eventNotify) ). For \neach event, the global event dispatcher sends a message on the eventNotify channel that con\u00adtains the \nunique integer identi.er of the source node for which the event is relevant. If this is the id of the \ninput signal, then the thread takes a value v from the input signal channel ( recv (port mc) ) and sends \nChange v on cout. Otherwise, the thread sends value NoChange v 1, where v 1 is the last value of the \ninput signal. Translation of liftn f s1 ... sn creates a mailbox cout on which to send new values for \nthe signal. It spawns a thread that waits to receive an event value from each of n signals. If any of \nthe values indicate a change has occurred, then function f is applied to the current value of the signals \nto produce a value v and Change v is sent on the signal s channel. Otherwise, NoChange v 1 is sent on \nthe channel, where v 1 is the last value of the input signal. Translation of foldp f v s is similar to \na lift term, except that the fold has a single input signal, the initial value for the signal is the \nexplicitly speci.ed value v, and function f is given the previous value of the fold signal in addition \nto values received on signal s. Translation of let expressions and variables work together to en\u00adsure \nthat FElm s runtime system does not have duplicate nodes. A let expression node serves as a multicast \nstation, forwarding mes\u00adsages to possibly many different nodes. Translation of let x = sin in sout translates \nsin, and binds variables xv and xch in the translation of sout to be, respectively, the initial value \nof signal sin and a multicast channel on which values produced by sin are mul\u00adticast. Thus, variables \nare translated to the pair (xv, port xch), where port xch returns a port that allows receipt of messages \nsent on the multicast channel. Translation of async s returns the translation of the triple (id, cout, \nv), where id is a newly generated unique identi.er for the source node representing the term, cout is \na newly created multicast channel, and d is the default value for signal s. The translation spawns a \nthread that listens for Change v events to be produced by signal s, upon receiving a new value, sends \nthat value on multicast channel cout, and noti.es the global event dispatcher that source node id has \na new event ( send newEvent id ). The translation of program s is executed within the context of the \nFElm CML runtime system, presented in Figure 11. There are two important loops: the global event dispatcher \neventDispatch receives events from the newEvent mailbox, and noti.es all source nodes of the new event, \nusing the eventNotify multicast channel; the display loop displayLoop updates the user s view as new \ndis\u00adplay values are produced by the translation of the program s. To\u00adgether, these loops are the input \nand output for a FElm program, with eventDispatch feeding values in and displayLoop out\u00adputting values \nto the screen. Note that the newEvent mailbox is a FIFO queue, preserving the order of events sent to \nthe mailbox. The displayLoop depends on the translation of a signal term s. The translation produces \nboth the initialDisplay which is the .rst screen to be displayed and the nextDisplay channel upon which \ndisplay updates are sent. The display loop just funnels values from the nextDisplay channel to the screen. \n newEvent = mailbox () eventNotify = mChannel () eventDispatch () = let id = recv newEvent in send eventNotify \nid ; eventDispatch () (initialDisplay, nextDisplay) = [s] send display initialDisplay displayLoop () \n= let v = recv nextDisplay in send display v ; displayLoop () spawn eventDispatch ; spawn displayLoop \nFigure 11. FElm CML runtime system 4. Building GUIs with Elm Elm extends the FElm core calculus to a \nfull language for build\u00ading rich interactive GUIs, including libraries for constructing and composing \nGUI components. Elm can represent quite complex in\u00adteractions with a small amount of code. The signal \nabstraction en\u00adcourages a separation between reactive code and code focused on the layout of GUI components. \nThis separation is due in part to Elm s purely functional and declarative approach to graphical lay\u00adout, \nwhich allows a programmer to say what they want to display, without specifying how this should be done. \nElm has additional base values, including strings, .oating point numbers, time, tuples, and graphical \nvalues such as Elements and Forms. Elm libraries provide data structures such as options, lists, sets, \nand dictionaries. Elm provides support for receiving input from mouse, keyboard, and touch devices, for \naccessing window attributes, and for network communication via HTTP. Elm supports JSON data structures \nand Markdown (making text creation easier). Elm s type system allows let-polymorphism and recursive simple \ntypes (but not recursive signal types). Elm supports type inference, has extensible records, and has \na module system. In this section we describe some key concepts and libraries for building GUIs with Elm, \nfocusing on features unique to Elm. 4.1 Elements and Forms Elm has two major categories of graphical \nprimitives: elements and forms. An element (a value of type Element) is a rectangle with a known width \nand height. Elements can contain text, im\u00adages, or video. They can be easily created and composed, making \nit simple to quickly lay out a multimedia display. Elements can be resized using functions width and \nheight, both of which have type Int -> Element -> Element. Examples in the Introduc\u00adtion demonstrated \nthe composition of elements. A form (a value of type Form) allows non-rectangular shapes and text to \nbe de.ned and composed. A form is an arbitrary 2D shape (including lines, shapes, text, and images) and \na form can be enhanced by specifying texture and color. Forms can be moved, rotated, and scaled. There \nare several subtypes of Form, including Line and Shape. Primitive functions can be used to construct \nforms, including line (which takes a list of points, and returns a line that goes through each point), \npolygon (which takes a list of points and returns an irregular polygon that goes through each of the \npoints), and library functions such as rect to create rectangles, oval to construct ovals, and ngon to \nconstruct regular polygons. Several functions allow lines and shapes to be given different colors, .lls, \nand rendering. Forms can be moved, scaled, and rotated using primitive functions move, scale, and rotate. \nFunction collage provides the ability to combine forms in an unstructured way to produce an element. \nIt takes as arguments square = rect 70 70 pentagon = ngon 5 20 circle = oval 50 50 zigzag = path [ (0,0), \n(10,10), (0,30), (10,40) ] main = collage 140 140 [ filled green pentagon, outlined (dashed blue) circle, \nrotate (degrees 70) (outlined (solid black) square), move 40 40 (trace (solid red) zigzag) ] Figure 12. \nCreating and combining shapes Signal Mouse.position Mouse.clicks Window.dimensions Time.every Time.fps \nTouch.touches Touch.taps Keyboard.keysDown Keyboard.arrows Keyboard.shift Input.text Type and Description \nSignal (Int, Int) Current coordinates of the mouse. Signal () Triggers on mouse clicks. Signal (Int, \nInt) Current dimensions of window. Time -> Signal Time Update every t milliseconds. Float -> Signal Time \nTime deltas, updating at the given FPS. Signal [Touch] List of ongoing touches. Useful for de.ning gestures. \nSignal { x:Int, y:Int } Position of the latest tap. Signal [KeyCode] List of keys that are currently \npressed. Signal { x:Int, y:Int } Arrow keys pressed. e.g., up+right is {x=1,y=1} Signal Bool Is the shift \nkey down? String -> (Signal Element, Signal String) Create a text input .eld. Figure 13. Some Elm input \nsignals and signal constructors width, height, and list of forms. collage : Int -> Int -> [Form] -> Element \nFigure 12 shows an example of creating several forms, changing their attributes, transforming them, and \nusing collage to combine them into an element.  4.2 Reactive GUIs To allow programmers to write GUIs \nthat interact with the user, and react to user input and events in the external environment, Elm provides \nseveral primitive signals that can be used in Elm programs. These are the identi.ers Input used in FElm \nto denote input signals from the external environment. Figure 13 describes some of Elm s signals and \nsignal constructors. Signal constructor  pics = [ \"shells.jpg\", \"car.jpg\", \"book.jpg\" ] display i = \nimage 475 315 (ith (i mod length pics) pics) count s = foldp (\\_ c -> c + 1) 0 s index1 = count Mouse.clicks \nindex2 = count (Time.every (3 * second)) index3 = count Keyboard.lastPressed main = lift display index1 \nFigure 14. A simple slide-show: reacting to user input Time.every takes a .oating point number t. The \nresulting signal is the current time, updated every t milliseconds. This signal enables time-indexed \nanimations and allows update rates to be tuned by the programmer. Signal constructor Time.fps allows \na programmer to specify a desired frame rate. The resulting signal is a sequence of time deltas (i.e., \nthe time elapsed since the last event), making it easy to do time-stepped animations. The frame rate \nis managed by the Elm runtime system, accommodating performance constraints. Input components such as \ntext boxes, buttons, and sliders are represented as a pair of signals: an element (for the graphical \ncomponent) and a value (for the value input). For example, the library function Input.text : String -> \n(Signal Element, Signal String) allows a programmer to construct a text input component. The code (Input.text \n\"Name\") returns a pair of a signal of Elements (for the graphical input .eld) and a signal of Strings \nrepresenting the current user input. The graphical element uses the string \"Name\" as the greyed-out default \ntext, indicating the desired user input. The element can be displayed on the screen, and the signals \nwill be updated every time the text in the .eld changes. Figure 14 shows how different user inputs can \nbe used to imple\u00ad ment a slide show. The code displays a single image from a list of images, pics. The \nuser can cycle through the images by clicking the mouse. (In the accompanying diagram, the arrows indicate \npos\u00adsible transitions between pictures, not actual graphical elements.) The program could easily be modi.ed \nto change images using a timer as seen in index2 which increments every three seconds. It could also \nchange images when a key is pressed as in index3. The Keyboard.lastPressed signal updates to the latest \ncharacter pressed.  4.3 Signal Functions Elm embeds an implementation of discrete Arrowized FRP (AFRP), \nbased on the naive continuation-based implementation described in the .rst AFRP paper [25]. To better \ncapture the fact that our imple\u00ad mentation is discrete (stepping forward only when provided with an input) \nthis is called the Automaton library in Elm. Arrowized FRP is a purely functional way to structure stateful \nprograms. It introduced signal functions [25] which can encapsu\u00ad late state and safely be switched in \nand out of a program. A signal function is conceptually equivalent to Elm s signal nodes: a set of external \ninputs, internal state, and an output. Although signal func\u00adtions and signal nodes are equivalent, Elm \ns core language does not allow one to work with signal nodes directly. Arrowized FRP allows this, making \nit possible to dynamically recon.gure a single node. This direct embedding of AFRP gives Elm the .exibility \nof signal functions without resorting to the use of signals-of-signals. An Automaton is de.ned as a continuation \nthat when given an input a, produces the next continuation and an output b. data Automaton a b = Step \n(a -> (Automaton a b, b)) This allows state to be kept around by continually placing it in the next continuation \n(the next step). Dynamic collections and dynamic switching are possible because an automaton is a pure \ndata structure with no innate dependencies on inputs (whereas signals depend on an input by de.nition). \nElm provides the following functions to make it easier to create pure and stateful automata: pure : (a \n-> b) -> Automaton a b init : (a -> b -> b) -> b -> Automaton a b This lets a programmer create stateful \ncomponents that can be switched in and out of a program. Notice the similarity between the types of init \nand foldp. To use an Automaton, Elm provides the step function which steps an automaton forward once, \nand the run function which feeds a signal into an automaton, stepping it forward on each change. step \n: a -> Automaton a b -> (Automaton a b, b) step input (Step f) = f input run : Automaton a b -> b -> \nSignal a -> Signal b run automaton base inputs = let step input (Step f, _) = f input in lift snd (foldp \nstep (automaton,base) inputs) Functions run and foldp are equivalent in expressive power. We de.ned run \nusing foldp, but we could have taken Automatons as primitives and de.ned foldp using run, as follows. \nfoldp : (a -> b -> b) -> b -> Signal a -> Signal b foldp f base inputs = run (init f base) base inputs \nWe chose foldp as our underlying abstraction partly because it makes Elm more accessible to users unfamiliar \nwith arrows, arrow notation, type classes, and category theory. It also allows us to improve on our naive \nembedding of discrete AFRP, or add alternate embeddings, without changing the core language. 5. Implementation \nWe have implemented an Elm-to-JavaScript compiler, and have a prototype implementation of Elm as an embedded \ndomain-speci.c language (DSL) in Haskell. The use of Asynchronous FRP has the potential to ensure that \nGUIs remain responsive despite long-running computation. We do not provide direct performance evaluations \nof Elm, although in our experience GUIs implemented with Elm have not required any performance tuning \nother than identifying signals to mark as asynchronous. We note that it is easy to write programs such \nthat Elm provides arbitrarily better responsiveness over synchronous FRP. For example, in the following \ncode, function f can be made arbitrarily long-running. While the asynchronous code (signal asyncEg) will \nremain responsive (continuing to display Mouse.x), the synchronous case (signal syncEg) will be unresponsive \nuntil evaluation of f completes. syncEg = lift2 (,) Mouse.x (lift f Mouse.y) asyncEg = lift2 (,) Mouse.x \n(async (lift f Mouse.y)) Similarly, it is possible to write programs such that the pipelined evaluation \nof signals has arbitrarily better performance than non\u00adpipelined execution by ensuring that the signal \ngraph of the pro\u00adgram is suf.ciently deep.  Elm-to-JavaScript compiler The Elm-to-JavaScript compiler \nis implemented in about 2,700 lines of Haskell code. The output of compiling an Elm program is an HTML \n.le. The compiler can also output a JavaScript .le for embedding an Elm program into an existing project. \nThe compiler output works on any modern browser. We provide a Foreign Function Interface to JavaScript \nto allow Elm to integrate with existing JavaScript libraries. We have targeted JavaScript as it is extremely \nexpressive for graphics and has unmatched cross-platform support. It is perhaps the most widely used \nand supported GUI platform, albeit notori\u00adously dif.cult to reason about its graphical layout model and \nto create readable asynchronous code. JavaScript has poor support for concurrency, and as such the Elm-to-JavaScript \ncompiler supports concurrent execution only for asynchronous requests, such as HTTP requests and non-blocking \n.le I/O. JavaScript does provide heavy-weight threads, called Web Workers, but communication and interaction \nbetween threads is limited. We investigated using Web Workers to implement async, but found their overhead \nto be too high compared with simpler ap\u00adproaches. We anticipate that if and when JavaScript supports \nlight\u00adweight threads, we will be able to more fully support asynchrony and concurrency in the Elm-to-JavaScript \ncompiler. Elm programs typically take longer to execute than an equiva\u00adlent hand-written JavaScript program, \nin a similar way that hand\u00adtuned assembly code is often more ef.cient than compiled high\u00adlevel language \ncode. Indeed, a key bene.t of Elm is providing bet\u00adter abstractions to programmers for building GUIs. \nHowever, the current prototype Elm-to-JavaScript compiler is ef.cient enough to execute all existing \nElm programs while providing a responsive user experience on commodity web browsers on standard laptop \nand desktop machines. The Elm-to-JavaScript compiler has been used to build the Elm website (http://elm-lang.org/) \nalong with nearly 200 exam\u00ad ples, including a nine-line analog clock, forms with client-side error checking, \na graphing library that handles cartesian and radial coor\u00addinates, a slide-show API, and a Flickr image \nsearch interface. Elm has also been used to make Pong and other games, which require highly interactive \nGUIs. Elm-in-Haskell library We also have a prototype Elm-in-Haskell library (144 lines of Haskell code) \nthat supports the key features of Elm. While it does not have as extensive a suite of libraries and syntactic \nsugar, it does fully support the async construct and implement concurrent (pipelined) evaluation of signals. \nWe use the Control.Concurrent.Chan.Strict module and General\u00adized Abstract Data Types to provide a type-safe \nimplementation of Elm. By using strict channels we ensure that unevaluated expres\u00adsions do not escape \nand cause unintended sequentialization. 6. Related Work Elm is an asynchronous FRP programming language \nfor creating rich and interactive GUIs. We focus on work related to the ef.cient FRP implementation, \nand to FRP frameworks for creating GUIs. 6.1 Ef.cient FRP Implementation Traditional Functional Reactive \nProgramming (FRP) was intro\u00adduced in the Fran system [13] which suffered severe ef.ciency problems as \na result of its expressive semantics. It permitted sig\u00adnals that depended on any past, present, or future \nvalue. As a result, its implementation had to save all past values of a signal just in case, growing \nmemory linearly with time. Real-time FRP (RT-FRP) [30, 32] ensures that signals cannot be used in ways \nthat do not have an ef.cient implementation. Like Elm, RT-FRP uses a two-tiered language: an unrestricted \nbase lan\u00adguage (.-calculus with recursion) and a limited reactive language for manipulating signals, \nwhich supports recursion but not higher\u00adorder functions (making it less expressive than traditional FRP). \nRT-FRP ensures that reactive updates will terminate as long as the base language terms terminate, and \nmemory will not grow unless it grows in the base language. Although not strong guarantees, they are a \nsigni.cant improvement over traditional FRP, which might (needlessly) use space linear in a program s \nrunning time. Event-Driven FRP (E-FRP) [31] builds on the ef.ciency gains of RT-FRP by introducing discrete \nsignals. E-FRP programs are event-driven in that no changes need to be propagated unless an event has \noccurred (i.e., the value of a signal has changed) which improves ef.ciency of the computation. Xu and \nKhoo [32] suggest a concurrent runtime for RT-FRP as future work but to the best of our knowledge, this \nhas not been pursued. Like RT-FRP, Elm uses a two-tiered language to restrict the inef.cient use of signals. \nHowever, whereas RT-FRP uses different syntactic constructs to separate functional and signal terms, \nElm has a uni.ed syntax but a strati.ed type system. This allows Elm to avoid non-standard syntactic \nconstructs and accept more expressions, while restricting inef.cient use of signals. Like E-FRP, Elm \nuses discrete signals to ensure ef.ciency and does not support recursively de.ned signals. The original \npaper on E-FRP suggests that discrete signals may be compatible with RT-FRP style recursion [31], but \nwe have found that such an extension is not particularly important for creating GUIs. Improving upon \nthese systems, we provide a concurrent runtime, and introduce a simple mechanism the async annotation \nto allow programmers to easily take advantage of concurrency. Arrowized FRP (AFRP) [20, 21, 24, 25, 29] \naims to regain much of the expressiveness of traditional FRP and keep the ef.ciency gains of RT-FRP. \nThis is achieved by requiring programmers to use signal functions instead of having direct access to \nsignals. Signal functions are conceptually equivalent to functions that take a signal of type a as an \ninput, and return a signal of type b. Signal functions solve the semantic problems associated with dynamically-created \nstateful signals by keeping state in signal functions instead of in signals. Unlike traditional FRP, \na signal function cannot depend on arbitrary past values. Thus, AFRP al\u00adlows programs to dynamically \nchange how signals are processed without space leaks. Although there is no direct access to sig\u00adnals, \nAFRP achieves the expressiveness of traditional FRP via continuation-based switching and dynamic collections \nof signal functions. Signal functions can be embedded in Elm (see Section 4.3), which brings the bene.ts \nof discrete AFRP to Elm programmers, allowing programs to dynamically create graphical components, without \nrequiring signals of signals. Elm s discrete semantics make it clear how to allow asynchrony and concurrency, \nwhich appears to be semantically problematic in a continuous AFRP. Parallel FRP [26], like Elm, enables \nconcurrent signal process\u00ad ing. Parallel FRP relaxes the order of events within a single signal, allowing \nevents to be processed out of order. In a server setting, this means that requests do not need to be \nprocessed in the order received, so responses can be computed in parallel and returned immediately. In \na GUI setting, such intra-signal asynchrony is typ\u00adically inappropriate, as it would allow, for example, \nkey presses to be processed out of order. Instead, Elm permits inter-signal asyn\u00adchrony: relaxing the \norder of events between multiple signals. We believe that intra-and inter-signal asynchrony are compatible, \nbut inter-signal asynchrony is more useful in GUI programming. Self-adjusting computation (e.g., [1, \n2, 11]) is motivated by the desire to reduce redundant re-computation. As seen in FElm s pipe\u00adlined signal \nevaluation (Section 3.3.2), avoiding needless recom\u00ad putation helps performance and is required for correctness \n(due to the stateful nature of the foldp construct). Although FElm avoids some needless recomputation, \nit currently propagates many noChange v messages through the signal graph. Insights from self\u00adadjusting \ncomputation could be used to reduce these messages and improve performance. Indeed, it appears likely \nthat modi.able ref\u00aderences [1] (used in self-adjusting computation to represent values that may change \nand thus trigger recomputation) can be used to encode signals, and can also express asynchronous signals \n[3].  6.2 FRP GUI Frameworks Both traditional FRP and Arrowized FRP have been used as the basis of \nseveral Haskell-embedded GUI frameworks, including: FranTk [28] (the original GUI framework for Fran \n[13]); Fruit [9] and Yampa/Animas [10, 16] (based on Arrowized FRP); and Reac\u00ad tive Banana [4] (based \non traditional FRP but avoids time leaks with carefully restricted APIs, disallowing signals-of-signals). \nEach of these Haskell-embedded libraries suffer from two problems. First, due to its lazy semantics, \nembedding the language in Haskell can lead to unexpectedly slow updates and unnecessary memory usage, \nwhich can be an issue for GUIs. Second, these Haskell-embedded libraries are a wrapper around a Haskell \nwrapper around an im\u00adperative GUI framework. This complicates both the design and the installation of \nthe frameworks. Indeed, FranTk [28] includes event listeners an imperative abstraction because they map \nmore nat\u00adurally onto the Tcl/Tk backend. Several frameworks embed FRP in imperative languages. Flap\u00adjax \n[23] extends JavaScript with traditional FRP. Flapjax interoper\u00ad ates easily with existing JavaScript \ncode, as it is simply a JavaScript library. Frapp \u00b4 e [8] adds FRP functionality to Java. Ignatoff et \nal. [18] adapt an object-oriented GUI library for use with the FRP lan\u00adguage FrTime [7]. By necessity, \nthese projects including Elm all rely on imperative GUI frameworks. This creates incentive to work well \nwith existing code using these frameworks, or to be close to the metal of the framework. However, these \nincentives can be destructive, with imperative constructs muddying the clarity and simplicity of FRP. \nTo maintain the declarative nature of FRP, Elm introduces a purely functional graphics library on a platform \nthat is widely supported and easy to install. Interaction between Elm and JavaScript is handled by a \nsimple foreign function inter\u00adface (FFI) that maintains a clean separation between functional and imperative \ncode. Elm provides a functional abstraction for graphical layout. Elm s collage API is similar to previous \nwork on free-form func\u00adtional graphics [6, 14, 15, 17, 19]. Unlike this previous work, Elm supports user \ninteraction and designs for animation, enabling cre\u00adation of GUIs as opposed to purely static pictures \nand graphics. 7. Conclusion We have developed the Elm programming language, a practical asynchronous \nFRP language focused on easy creation of responsive GUIs. We introduced Asynchronous FRP to allow programmers \nto easily specify when a potentially long-running signal computation should be computed asynchronously, \nand thus enable ef.cient con\u00adcurrent execution of FRP programs. We captured the key concepts of asynchronous \nFRP in a core calculus. By combining asynchronous FRP with purely functional layout of graphical elements, \nElm simpli.es the complicated task of cre\u00adating responsive and usable graphical user interfaces. Acknowledgments \nWe thank Greg Morrisett, Stuart Shieber, the anonymous reviewers, Umut Acar, Stefan Muller, David Darais, \nJan Midtgaard, and the Aarhus Programming Languages group for their helpful comments and feedback. We \nthank the Elm user community. This research is supported in part by the National Science Foundation under \nGrant No. 1054172. References [1] U. A. Acar, G. E. Blelloch, and R. Harper. Adaptive functional programming. \nIn Proceedings of the 29th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, pages \n247 259, New York, NY, USA, 2002. ACM. [2] U. A. Acar, A. Ahmed, and M. Blume. Imperative self-adjusting \ncomputation. In Proceedings of the 35th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming \nLanguages, pages 309 322, New York, NY, USA, 2008. ACM. [3] U. A. Acar, G. E. Blelloch, K. Tangwongsan, \nand D. T \u00a8urko .glu. Robust kinetic convex hulls in 3D. In Proceedings of the 16th Annual Eu\u00adropean Symposium \non Algorithms, pages 29 40, Berlin, Heidelberg, 2008. Springer-Verlag. [4] H. Apfelmus. Reactive-banana. \nHaskell library available at http: //www.haskell.org/haskellwiki/Reactive-banana, 2012. [5] Z. M. Ariola \nand M. Felleisen. The call-by-need lambda calculus. Journal of Functional Programming, 7(3):265 301, \nMay 1997. [6] E. Chailloux, G. Cousineau, and A. Su `arez. MLgraph. http://www.pps.univ-paris-diderot.fr/~cousinea/ \nMLgraph/mlgraph.html, 1992. [7] G. H. Cooper. Integrating Data.ow Evaluation into a Practical Higher-Order \nCall-by-Value Language. PhD thesis, Brown Univer\u00adsity, May 2008. [8] A. Courtney. Frapp\u00b4e: Functional \nreactive programming in Java. In Proceedings of the Third International Symposium on Practical As\u00adpects \nof Declarative Languages, pages 29 44, London, UK, 2001. Springer-Verlag. [9] A. Courtney and C. Elliott. \nGenuinely functional user interfaces. In Proceedings of the 2001 ACM SIGPLAN Workshop on Haskell, pages \n41 69, 2001. [10] A. Courtney, H. Nilsson, and J. Peterson. The Yampa arcade. In Proceedings of the 2003 \nACM SIGPLAN Workshop on Haskell, pages 7 18, New York, NY, 2003. ACM. [11] A. Demers, T. Reps, and T. \nTeitelbaum. Incremental evaluation for attribute grammars with application to syntax-directed editors. \nIn Pro\u00adceedings of the 8th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, pages \n105 116, New York, NY, USA, 1981. ACM. [12] C. Elliott. Push-pull functional reactive programming. In \nProceedings of the 2nd ACM SIGPLAN Symposium on Haskell, pages 25 36, New York, NY, 2009. ACM. [13] C. \nElliott and P. Hudak. Functional reactive animation. In Proceedings of the 2nd ACM SIGPLAN International \nConference on Functional Programming, pages 263 273, New York, NY, 1997. ACM. [14] R. B. Findler and \nM. Flatt. Slideshow: functional presentations. In Proceedings of the Ninth ACM SIGPLAN International \nConference on Functional Programming, pages 224 235, New York, NY, USA, 2004. ACM. [15] S. Finne and \nS. Peyton Jones. Pictures: A simple structured graphics model. In Proceedings of the Glasgow Functional \nProgramming Workshop, 1995. [16] G. Giorgidze and H. Nilsson. Switched-on Yampa: declarative pro\u00adgramming \nof modular synthesizers. In Proceedings of the 10th Inter\u00adnational Conference on Practical Aspects of \nDeclarative Languages, pages 282 298, Berlin, Heidelberg, 2008. Springer-Verlag. [17] P. Henderson. Functional \ngeometry. In Proceedings of the 1982 ACM Symposium on LISP and Functional Programming, pages 179 187, \nNew York, NY, USA, 1982. ACM. [18] D. Ignatoff, G. H. Cooper, and S. Krishnamurthi. Crossing state lines: \nAdapting object-oriented frameworks to functional reactive languages. In Proceedings of the International \nSymposium on Functional and Logic Programming, 2006.  [19] S. N. Kamin and D. Hyatt. A special-purpose \nlanguage for picture\u00addrawing. In Proceedings of the Conference on Domain-Speci.c Lan\u00adguages on Conference \non Domain-Speci.c Languages (DSL), 1997, pages 23 23, Berkeley, CA, USA, 1997. USENIX Association. [20] \nH. Liu and P. Hudak. Plugging a space leak with an arrow. Electron. Notes Theor. Comput. Sci., 193:29 \n45, Nov. 2007. [21] H. Liu, E. Cheng, and P. Hudak. Causal commutative arrows and their optimization. \nIn Proceedings of the 14th ACM SIGPLAN International Conference on Functional Programming, pages 35 46, \nNew York, NY, 2009. ACM. [22] J. Maraist, M. Odersky, and P. Wadler. The call-by-need lambda calculus. \nJournal of Functional Programming, 8(3):275 317, May 1998. [23] L. A. Meyerovich, A. Guha, J. Baskin, \nG. H. Cooper, M. Greenberg, A. Brom.eld, and S. Krishnamurthi. Flapjax: a programming lan\u00adguage for Ajax \napplications. In Proceedings of the 24th ACM SIG-PLAN Conference on Object Oriented Programming Systems \nLan\u00adguages and Applications, pages 1 20, New York, NY, 2009. ACM. [24] H. Nilsson. Dynamic optimization \nfor functional reactive program\u00adming using generalized algebraic data types. In Proceedings of the 10th \nACM SIGPLAN International Conference on Functional Pro\u00adgramming, pages 54 65, New York, NY, 2005. ACM. \n[25] H. Nilsson, A. Courtney, and J. Peterson. Functional reactive pro\u00adgramming, continued. In Proceedings \nof the 2002 ACM SIGPLAN Workshop on Haskell, pages 51 64, New York, NY, 2002. ACM. [26] J. Peterson, \nV. Trifonov, and A. Serjantov. Parallel functional reactive programming. In Proceedings of the Second \nInternational Workshop on Practical Aspects of Declarative Languages, pages 16 31, London, UK, 2000. \nSpringer-Verlag. [27] J. H. Reppy. Concurrent programming in ML. Cambridge University Press, 1999. ISBN \n9780521480895. [28] M. Sage. FranTk -a declarative GUI language for Haskell. In Proceedings of the 5th \nACM SIGPLAN International Conference on Functional Programming, pages 106 117, New York, NY, 2000. [29] \nN. Sculthorpe and H. Nilsson. Safe functional reactive programming through dependent types. In Proceedings \nof the 14th ACM SIGPLAN International Conference on Functional Programming, pages 23 34, New York, NY, \n2009. ACM. [30] Z. Wan, W. Taha, and P. Hudak. Real-time FRP. In Proceedings of the 6th ACM SIGPLAN International \nConference on Functional Programming, pages 146 156, New York, NY, 2001. ACM. [31] Z. Wan, W. Taha, and \nP. Hudak. Event-driven FRP. In Proceedings of the 4th International Symposium on Practical Aspects of \nDeclarative Languages, pages 155 172, London, UK, UK, 2002. Springer-Verlag. [32] D. N. Xu and S.-C. \nKhoo. Compiling real time functional reactive programming. In Proceedings of the ASIAN Symposium on Partial \nEvaluation and Semantics-Based Program Manipulation, pages 83 93, New York, NY, 2002. ACM.    \n\t\t\t", "proc_id": "2491956", "abstract": "<p>Graphical user interfaces (GUIs) mediate many of our interactions with computers. Functional Reactive Programming (FRP) is a promising approach to GUI design, providing high-level, declarative, compositional abstractions to describe user interactions and time-dependent computations. We present Elm, a practical FRP language focused on easy creation of responsive GUIs. Elm has two major features: simple declarative support for <i>Asynchronous FRP</i>; and purely functional graphical layout.</p> <p>Asynchronous FRP allows the programmer to specify when the global ordering of event processing can be violated, and thus enables efficient concurrent execution of FRP programs; long-running computation can be executed asynchronously and not adversely affect the responsiveness of the user interface.</p> <p>Layout in Elm is achieved using a purely functional declarative framework that makes it simple to create and combine text, images, and video into rich multimedia displays.</p> <p>Together, Elm's two major features simplify the complicated task of creating responsive and usable GUIs.</p>", "authors": [{"name": "Evan Czaplicki", "author_profile_id": "81758676957", "affiliation": "Harvard University, Cambridge, Massachusetts, USA", "person_id": "P4149078", "email_address": "evan.czaplicki@post.harvard.edu", "orcid_id": ""}, {"name": "Stephen Chong", "author_profile_id": "81548379156", "affiliation": "Harvard University, Cambridge, Massachusetts, USA", "person_id": "P4149079", "email_address": "chong@seas.harvard.edu", "orcid_id": ""}], "doi_number": "10.1145/2491956.2462161", "year": "2013", "article_id": "2462161", "conference": "PLDI", "title": "Asynchronous functional reactive programming for GUIs", "url": "http://dl.acm.org/citation.cfm?id=2462161"}