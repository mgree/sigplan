{"article_publication_date": "06-16-2013", "fulltext": "\n Rely-Guarantee References for Re.nement Types Over Aliased Mutable Data Colin S. Gordon, Michael D. \nErnst, and Dan Grossman University of Washington {csgordon,mernst,djg}@cs.washington.edu Abstract Reasoning \nabout side effects and aliasing is the heart of verifying imperative programs. Unrestricted side effects \nthrough one refer\u00adence can invalidate assumptions about an alias. We present a new type system approach \nto reasoning about safe assumptions in the presence of aliasing and side effects, unifying ideas from \nreference immutability type systems and rely-guarantee program logics. Our approach, rely-guarantee references, \ntreats multiple references to shared objects similarly to multiple threads in rely-guarantee pro\u00adgram \nlogics. We propose statically associating rely and guarantee conditions with individual references to \nshared objects. Multiple aliases to a given object may coexist only if the guarantee condition of each \nalias implies the rely condition for all other aliases. We demonstrate that existing reference immutability \ntype systems are special cases of rely-guarantee references. In addition to allowing precise control \nover state modi.cation, rely-guarantee references allow types to depend on mutable data while still permitting \n.exible aliasing. Dependent types whose denotation is stable over the actions of the rely and guarantee \nconditions for a reference and its data will not be invalidated by any action through any alias. We demonstrate \nthis with re.nement (subset) types that may depend on mutable data. As a special case, we derive the \n.rst reference immutability type system with dependent types over immutable data. We show soundness for \nour approach and describe experience using rely-guarantee references in a dependently-typed monadic DSL \nin CO Q. Categories and Subject Descriptors D.2.4 [Software/Program Veri.cation]: Correctness Proofs; \nF.3.2 [Semantics of Programming Languages]: Program Analysis Keywords reference immutability, rely-guarantee, \nre.nement types 1. Introduction A common way to reason about side effects in imperative languages is \nto restrict (disable) mutating some state in some code sections. This is seen most clearly in reference \nimmutability [22, 44, 49, 50], but also in ownership [14] and region-based type systems [6]. The common \napproach is to attach permission/ownership/region Permission to make digital or hard copies of all or \npart of this work for personal or classroom use is granted without fee provided that copies are not made \nor distributed for pro.t or commercial advantage and that copies bear this notice and the full citation \non the .rst page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires \nprior speci.c permission and/or a fee. PLDI 13, June 16 19, 2013, Seattle, WA, USA. Copyright c &#38;#169; \n2013 ACM 978-1-4503-2014-6/13/06. . . $15.00 information to references, where certain operations (mainly \nwrites to the heap) through references with certain permissions are prohibited. The program logic literature \nincludes work ensuring that actions by one section of code do not interfere destructively with the assumptions \nof another section of code. This appears most often in the form of concurrent program logics, where the \ngoal is to prevent destructive interference between threads. This reaches at least as far back as Owicki \nand Gries s technique [37], which checks thread non-interference by ensuring that no action would invalidate \nany intermediate assumption of another thread. Jones abstracted cross\u00adthread interactions to a rely relation \nbounding interference by other threads, and a guarantee relation bounding actions of the current thread \n[27]. Each thread s local proof then requires all local actions to fall within its guarantee, and that \nall of its intermediate assertions are stable with respect to (that is, not invalidated by) any possible \naction permitted by the rely. Parallel composition of threads is then safe if each thread s guarantee \nimplies each other thread s rely. Our central idea is to treat aliases to objects similarly to threads \nof control in rely-guarantee program logics. Each reference s type carries a rely and a guarantee, bounding \nactions on an object through other references (rely) and bounding actions through the reference itself \n(guarantee). We call these augmented reference types rely\u00adguarantee references. The type system maintains \nthe invariant that the guarantee of any reference implies the rely of any alias. The type system checks \nthese constraints when a program duplicates an alias. This raises the issue that some references cannot \nsoundly coexist: no two references to the same object can each guarantee nothing (the reference permits \narbitrary actions) and rely on restricted behavior through aliases. This presents us with a logical account \nof aliasing: some references may not be aliased without weakening the rely or guarantee of the source, \nand a reference with an empty rely necessarily has no aliases. Rely-guarantee references generalize reference \nimmutability [22, 44, 49, 50] to .ner-grained control over interference through aliases. The traditional \nreference immutability quali.ers correspond to simple rely and guarantee conditions. For ref t[R,G] as \na reference to data of type t with rely R and guarantee G: readable t = ref t[any interference, no writes] \n writable t = ref t[any interference, any writes]  immutable t = ref t[no interference, no writes] \n Rely-guarantee references let us reason about some re.nements of referents. Let a stable predicate \nover a reference be one that is preserved by its rely. Then a stable predicate cannot be invalidated \nby actions through an alias, and any new predicate that is stable and ensured by a guarantee-permitted \naction (on an object satisfying the old predicate) is true after the action, providing a form of strong \nupdate on arbitrarily aliased mutable data. (An action allowed by the guarantee that preserves the current \npredicate is a special case.)  1.1 Contributions Re.nement Types Over Mutable Data Rely-guarantee references \npermit re.nement types [21] that depend on mutable data, without requiring any aliasing restrictions \nto support strong updates. We leverage the notion of a stable assertion from rely-guarantee pro\u00adgram \nlogics, allowing any re.nements that are not invalidated by actions performed through other references. \nWe prove that our type system is sound. Generalizing Reference Immutability We generalize reference immutability \nby combining it with rely-guarantee techniques. This is of independent interest, but also outlines an \neffort/precision spectrum from unrestricted references to reference immutability to rely-guarantee references. \nA Prototype Implementation We prototype an implementation as a shallow monadic embedding in CO Q. We \nhave used it to verify the examples in the paper, including implementing reference immutability as a \nspecial case. We brie.y discuss our experience implementing a language as a CO Q DSL and the manual proof \nburden for our technique versus purely functional versions. The implementation is available at https://github.com/csgordon/rgref/. \nWe believe rely-guarantee references make a compelling argu\u00adment that rely-guarantee reasoning is a promising \nway to statically reason about aliasing. Further, any technique traditionally used to reason about thread \ninterference can be adapted to modularly reason about effects in the presence of aliasing (we present \nrely-guarantee references as a type system, but our ideas could be implemented in other ways, such as \na program logic). Ultimately we believe the proper way to support unknown aliases in program veri.cation \nis by treating aliases as different threads of control. 2. Rely-Guarantee References A rely-guarantee \nreference is a reference to a heap structure of a given type, as in ML s ref t, with three additional \ntype components: A re.nement predicate P over the t and a heap h that can enforce local properties and/or \ndata-structure well-formedness.  A guarantee relation G over pairs of ts and heaps, restricting the \neffects to the referent (and state heap-reachable from that referent) that may be performed through this \nreference or those produced by dereferencing it.  A rely relation R specifying the actions permitted \nby (the guarantees of) other aliases to the referent.  We use the form ref{t | P}[R,G] for a rely-guarantee \nreference. Predicates and relations are de.ned not only over the t a reference refers to, but also over \nheaps, to re.ne data reachable from the immediate referent. For a rely-guarantee reference type to be \nwell\u00adformed, the predicate P must be stable with respect to the rely R: for all values and heaps for \nwhich the predicate holds, if the rely R allows another value and heap to be produced by actions on another \nalias, then the predicate holds for the new value and heap as well: P v h . R v v ' h h ' =. P v ' h'. \nThis ensures that actions through aliases do not invalidate the re.nement, and that all actions that \nmay invalidate the re.nement are local, so reasoning about such changes allows strong updates to the \nre.nement. These issues are formally treated in Section 4. A simple example of rely-guarantee references \nis a monotoni\u00adcally increasing counter, which we can represent as a value of type ref{nat | any}[increasing, \nincreasing] where any is the trivial (always true) re.nement, and increasing (Section 3.1) is a relation \non natural numbers and heaps that requires the second nat to be greater than or equal to the .rst. Given \na variable x with the type above, x . !x + 1 type-checks (! is ML s dereference operator). By contrast, \nincorrect code that decrements the counter cannot satisfy the guarantee relation increasing. A read-only \nalias to an increasing counter can be expressed as: ref{nat | any}[increasing, ] where is a relation \npermitting no change. We might wish to know more about a counter value, for example that it is greater \nthan 0 so it is safe as a divisor to compute an average. Any write to the counter via any reference will \nincrease its value, and may therefore conclude the result is greater than 0.1 Furthermore, it is safe \nto continue assuming the value is greater than 0 because the reference s rely ensures no alias can decrease \nthe value. We say .x : nat..h : heap.x > 0 is stable with respect to the rely increasing. When a write \nestablishes a new stable predicate over the data, strong updates to the reference s predicate (changing \nthe predicate in the type) are sound. (Similarly, when a write invalidates a reference s predicate, a \nstrong update is required, to a new predicate stable over the rely.) Many veri.cation techniques for \nimperative programs struggle to verify examples of this kind. Reference immutability and fractional permissions \n[7, 28] can only allow or outright prevent mutation, not control it. Separation logic cannot concisely \nspecify the counter s in\u00adtended semantics, only code s behavior. Rely-guarantee and related systems can \nexpress the semantics among threads [18, 27, 45], but only coarsely [46] among different program sections. \nMost program logics can constrain the actions of a function on an argument, but the speci.cation must \ndeal with aliasing, either by giving linear semantics to knowledge of the counter (as in separation logic), \nor by explicitly treating aliasing (as in more traditional Hoare logics [24]). With rely-guarantee references, \nfunctions are written without concern for aliasing among their arguments. A function cannot be called \nwith unsafe aliasing among arguments: since each alias s guarantee must imply each other s rely, each \nfunction explicitly accounts for its possible actions. If two arguments of the same type have con.icting \nrely/guarantee conditions, they cannot be aliased. 2.1 Subtleties of Rely-Guarantee References While \nthe intuition behind rely-guarantee references is straightfor\u00adward, this section overviews some more \nsubtle features of our system that avoid problems. Non-duplicable References A reference may be freely \nduplicated if its guarantee implies its own rely, as with the monotonically increasing counter. But consider \na reference y : ref{nat | any}[decreasing,increasing] Making an alias to y where the the alias has the \nsame type as y violates soundness, because the guarantee of the duplicate does not imply the rely of \ny! Instead, aliasing y requires splitting it into two aliases with weaker rely/guarantee conditions. \nWe support such splitting via a novel substructural resource semantics (Section 4). Reference to References \nWe need a reference s guarantee to re\u00adstrict all actions performed using that reference, which must include \nactions performed via references acquired by dereferencing the .rst reference. Otherwise, reading a reference \nout of the heap and writing through it could violate the original reference s guarantee, violating the \ncapability to perform effects in the guarantee intuition, and potentially invalidating a predicate. So \nreading from the heap must somehow transform the type of the referent to restrict resulting ref\u00aderences. \nReference immutability systems can give a simple binary function on permissions [22], to capture the \ntransitive meaning of 1 Because the type nat of natural numbers contains no negative numbers.  quali.ers. \nFor example, dereferencing a readable reference to a writable reference returns a readable reference \n(assuming a deep interpretation of reference immutability, where permissions apply transitively). By \ncontrast, our type system combines arbitrary rela\u00adtions (Section 3.2). Furthermore, if one reference \npoints to another, how should the rely of the inner reference be related to the outer one? It is unsound \nif it permits more interference than the outer rely, so our type system prevents this.2 Footprint How \nmuch of the heap may a rely-guarantee reference s predicate or conditions mention? It is not productive \nor sound to let a reference constrain unrelated heap data: letting a reference arbitrarily constrain \nthe heap could lead to allocating a new heap cell whose rely is not implied by existing references. The \ntype system restricts the expressiveness of these predicates to ensure sound and tractable reasoning: \npredicates and relations may depend only on the heap reachable from the reference. Cycles Many useful \ndata structures contain cycles, so we wish to reason effectively about them. The solution turns out to \nbe simple (propositions describing cycles require .nite proofs, and recursion based on heap structure \nis not permitted in predicates), but was not immediately obvious to us. 3. Examples We present examples \nusing rely-guarantee references to verify pro\u00adgrams. The examples are small, but highlight distinct capabilities \nof rely-guarantee references. Rather than writing examples in our core language RGR E F (Section 4), \nwe present them using a slight simpli.cation of our shallow embedding in COQ [12]. The embed\u00ad ding is \nlargely in the style of YN OT [11, 34], using axioms for heap interactions. Reading CO Q Source COQ s \nlanguage for de.ning functions and types is based strongly on ML, though many keywords are differ\u00adent: \nDefinition and Fixpoint for non-and recursive de.nitions, Inductive for de.ning inductive variant datatypes \nby specifying constructors. Parameter declares assumptions, external functions, or abstract elements \nin a module signature. Functions and parameter\u00adized type de.nitions can put some arguments in braces \nrather than parentheses; these arguments are implicit, and inferred when pos\u00adsible from later arguments. \nAnother notable syntactic change from ML is that = is an operator for propositional equality, not a boolean \ndecision procedure for structural equality. Therefore, := is often used where ML would use = in de.nitions. \nThe set of types is much richer than ML, not only due to dependent types but because there are universes \n(types of types): Prop is the type of propositional types (erasable during extraction, such as proof \nterms with conjunction, implications, etc.), and Set is the type of normal (computationally relevant) \ndata types. C O Q also includes a notation feature that allows users to extend the grammar with additional \nparsing rules, allowing programs to use syntax closer to mathematical de.nitions (such as ref{T | P}[R,G]). \nOur notation uses ML s dereference operator (!) and uses r . e for writing e to the location referenced \nby r. We introduce further notations as they arise. The P RO G R A M extension [42] (used via de.nitions \npre.xed with Program) allows the omission of explicit proof terms in programs. Omitted terms are either \nsolved automatically via a (customizable) proof search tactic, or set aside for subsequent manual interactive \nsolving, improving readability. 2 This is actually a design decision that simpli.es checking stability. \nAn alternative design could check a predicate for stability over any change permitted by any reference \nreachable from the predicate s target referent. 3.1 Monotonic Counter Consider again our running example \nof a monotonically increasing counter. Generally, rely and guarantee conditions must be de.ned over pre-and \npost-heaps as well as values, to describe the interfer\u00adence they tolerate on reachable substructures. \nFor a simple counter, there is no other reachable data, so the pre-and post-heaps may be ignored. Thus \nthe relation for increasing over time is de.ned as: Definition increasing (n n :nat) (h h :heap) : Prop \n:= n = n. Code to allocate a counter is straightforward: Program Definition mkCounter (_:unit) : ref{nat|any}[increasing,increasing] \n:= alloc 0. The allocation function mkCounter generates well-formedness proof obligations for the resulting \ntype: that any is stable with respect to increasing  that any and increasing are precise: they access \nonly the (empty) heap segment reachable from the natural number they apply to  that any is true of 0 \n In our prototype implementation (Section 5), most of these obliga\u00ad tions are proven automatically by \nlightly-guided automatic proof search. Type errors for actions that fall outside the guarantee (or ill-formed \nrely/guarantee relations, or predicates that are not precise, etc.) manifest as unsolvable proof obligations. \nUsing a monotonic counter is also straightforward: Program Definition example (_:unit) := let x = mkCounter \n() in x . !x + 1; An assignment typechecks only if the change implied by the write is permitted by the \nreference s guarantee relation, for any pre-heap and pre-value satisfying the reference s re.nement. \nIn this case, the assignment generates a proof obligation of the form .x, h.any (!x) h =. increasing \n(!x) (!x + 1) h h[x . h[x] + 1]. which is easily solved, with little effort beyond what is required to \nverify a pure-functional increment function (see Section 5.3). Each read also generates a proof obligation \nthat the guarantee increasing is re.exive : it allows a reference to be used without modifying the heap \n(.n, h.increasing n n h h). By contrast, an empty guarantee relation would disallow using a reference. \nThe monotonically increasing counter was proposed by Pilkiewicz and Pottier [40] as a challenging goal \nfor program veri.cation. Un\u00ad like their solution and another in .ctional separation logic [26], we can \nstate the monotonicity property plainly and require no abstrac\u00adtion to prevent unchecked interference. \nOn the other hand, their solutions verify that the increment occurs, while ours ensures that increment \nis the only permitted action.  3.2 Monotonic List We can de.ne a monotonically growing (prepend-only) \nlist, either using a mutable reference to a pure-functional list, or using mutable nodes. The former \napproach is similar to the monotonic counter, so to show the power of rely-guarantee references for recursive \ndata structures, Figure 1 shows the latter.3 We .rst de.ne hpred and hrel, type-level functions that \nallow shorter type declarations. We use them throughout this paper. Next we de.ne a linked list structure, \nwith restricted references to the 3 The most natural design uses mutual inductive types where one indexes \nthe other, which we assume here. CO Q does not support this, so we use an encoding, discussed further \nin Section 5 and our technical report [23].  Definition hpred (A:Set) := A -> heap -> Prop. Definition \nhrel (A:Set) := A -> A -> heap -> heap -> Prop. Inductive list : Set := | nil : list | cons : forall \n(n:nat), ref{list|any}[list_imm,list_imm] -> list with (* list tails are immutable (_imm) *) list_imm \n: list -> list -> heap -> heap -> Prop := | imm_nil : forall h h , list_imm nil nil h h | imm_cons: forall \nn tl h h , list_imm h[tl] h [tl] h h -> list_imm (cons n tl) (cons n tl) h h . (* Convenient allocation \nfunctions *) Program Definition Nil {P:hpred list} : ref{list|P}[list_imm,list_imm] := alloc nil. Program \nDefinition Cons {P P :hpred list} (n:nat)(tl:ref{list|P}[list_imm,list_imm]) : ref{list|P n(. l h=>l=cons \nn tl)}[list_imm,list_imm] := alloc (cons n tl). (* A prepend-only list container *) Record list_container \n(P:hpred list) := mkList { head : ref{list|P}[list_imm,list_imm] }. Inductive prepend : hrel (list_container \nP) := | prepended : forall c c h h n, h [head c ]=cons n (head c) -> prepend c c h h | prepend_nop : \nforall c h h , prepend c c h h . Program Definition newList (P:hpred list) : ref{list_container|any}[prepend,prepend] \n:= let x = Nil in alloc (mkList P x). Program Definition doPrepend {P:hpred list}(n:nat) (l:ref{list_container|any}[prepend,prepend]) \n: unit := let x = Cons n (head l) in l . mkList P x. Figure 1. RGREF code for a prepend-only linked list. \ntail. list imm constrains the tail to be immutable. For the reader unfamiliar with CO Q, list imm is \na GADT [48] constructing a proposition on different constructions of lists. The .rst constructor declares \nthat an empty list must remain empty, regardless of heaps. The second constructor accepts a nat, a tail, \ntwo heaps, and a proof that list imm holds over the tail of the list in those heaps, returning a declaration \nthat a cons cell must remain constant. The immutability requirement is not essential to this example \n(we could, for example, permit the numbers to change but require the length to increase), but is included \nfor completeness. We then de.ne convenient helper functions for heap-allocating nil or cons cells. We \nenforce the prepend-only behavior through reference to a list container structure, which holds a reference \nto a list parameterized by some predicate. The prepend relation on list containers allows prepending \nand no-ops (required for read\u00ading the reference). Finally we have helper functions to allocate a new \nlist and to prepend the list with a new cell. prepend is essentially the speci.cation of what doPrepend \nis permitted to do with the list. Note the predicate conjunction (n) in the return type of Cons. This, \nalong with the predicate conversion rule, is how .ow-sensitive assumptions can be handled (notice that \nthe equality is stable with respect to list imm). This is important in doPrepend, where information from \nthe result of one write (inside Cons) must be carried into another (the assignment through l), because \nit is otherwise unavailable in the expression stored. Not shown in Figure 1 are implicit obligations \nsuch as .h.P nil h in Nil. Other such obligations include: .t l,h.P t l h =. P' (cons n t l) h in Cons \n That prepend permits the write in doPrepend (under the trivial assumption that any holds of the initial \nlist container and heap).  This obligation requires a richer type for the allocation result, because \nmkList must know x is a cons cell whose tail is the old list. This information is not available locally \n(within the write statement itself). Other systems propagate hypotheses separately, but we only need \nto track variables: the required equality is present in x s predicate because of Cons s return type. \n The stability and precision properties that must hold for various predicates and list imm.  Propagations \nof these obligations to indirect polymorphic callers, such as newList and prepend.  Also omitted in \nFigure 1 are obligations related to folding and containment. Folding is the restriction of read result \ntypes to ensure that for any reference r with guarantee G, references produced via reads of r do not \nallow actions exceeding those permitted by G on r s referent. This ensures actions via a reference read \nfrom inside a data structure cannot invalidate predicates over the whole structure. Containment is a \ncheck that the rely R for a reference r captures all interference allowed by the interference summaries \nof references reachable from r. This ensures that any predicate preserved by R is also preserved by actions \non aliases to internal structures. Both operations require projecting a given relation component\u00adwise \nonto a datatype s members. For our prepend-only list, project\u00ading prepend is trivial (it does not constrain \nthe list cells values), and the result of projecting list imm is logically equivalent to list imm itself. \n 3.3 Reference Immutability as a Special Case Reference immutability [22, 44, 49, 50] adds permissions \n(type quali.ers) to references to permit or disallow side effects through a particular reference. Multiple \naliases at different permissions may coexist if compatible: for example, there may be write-permitting \nand read-only aliases to an object. We can de.ne the permissions of reference immutability like this: \nDefinition havoc {A:Set} : hrel A := fun x => fun x => fun h => fun h => True. Definition readable (T:Set) \n:= ref{T|any}[havoc, ]. Definition writable (T:Set) := ref{T|any}[havoc,havoc]. Definition immutable \n(T:Set) := ref{T|any}[ , ]. Our de.nitions encode the standard semantics for reference im\u00admutability \nquali.ers: only immutable assumes limited interference via other aliases, and readable and immutable \ndisallow muta\u00adtion through a reference. Restrictions on aliasing among reference immutability permissions \nare re.ected in the rely and guarantee relations: no heap cell may have writable and immutable aliases \nsimultaneously, as the guarantee of the writable reference (havoc) is not a subrelation of the immutable \nrely ( ). The containment requirement (Section 3.2) for rely conditions on nested datatypes is satis.ed \nby the rely for readable and writable, and for immutable the rely prevents it from (transitively) referencing \nmutable data. Reading through one of these references requires considering how the rely and guarantee \naffect the read s result. In reference immutability, result types are adapted using a simple binary func\u00adtion \non permissions (Figure 2). Our rely-guarantee reference type system must combine arbitrary relations \n(folding), using the type of the referent. Intuitively, folding is projection of the reference s guarantee \nonto the referent type. Any projection of havoc and cor\u00adrespond with the simpli.ed version in Figure \n2. Projecting havoc is equivalent to reading through a writable reference, which simply produces the \ninner type. Projecting is equivalent to the weak\u00adening that occurs when reading through readable or \nimmutable references. We can also give a reference immutability system with limited dependent types by \na small extension: Figure 2. Combining reference immutability permissions, from [22]. Using a p reference \nto read a q T .eld produces a (p Cq) T .  [ immutable = immutable immutable [ = immutable readable [ \n= readable writable [ q = q Definition refined (T:Set) (P:hpred T) := ref{T|P}[ , ]. At .rst glance \nthis is weaker than proposed systems that let mutable data s type depend on arbitrary immutable data, \nbecause we require any reference predicate to access only heap state reachable from its referent. At \nthe cost of some space the referent could maintain its own extra reference to relevant immutable data. \nCareful code extraction work can improve the space overhead in executables. Another bene.t of implementing \nreference immutability via rely-guarantee references is interoperability between reference immutability \nand richer rely-guarantee references. For example, a function accepting a readable reference to a natural \nnumber can be passed a read-only monotonically-increasing counter from Section 3.1. This offers a natural \npath for gradually adding stronger veri.cation guarantees to code using reference immutability (which \nitself is a gradual re.nement of unrestricted references [22]).  3.4 RCC/Java with Reference Immutability \nThe core of RCC/Java [20] is also implementable as a small library using our CO Q DSL, and we present \na translation of an early version [19]. The key idea in these type systems and related systems is to \nparameterize the type of a reference by the identity of a particular lock. The type system tracks the \nset of held locks and permits reads and writes through a reference only when the reference s lock parameter \nis statically known to be held. A CO Q module wraps standard acquire and release primitives and exposes \na new reference type that quanti.es over a lock. The RCC reference type can be abstracted with a module \nsignature, but can be concretely represented by a RGR E F ref type: (* Signature *) Parameter rccref \n: forall (A:Set), hpred A -> hrel A -> hrel A -> lock -> Set. ... (* Implementation *) Definition rccref \nA P R G (l:lock) := ref A P R G. The module then exposes its own read and write primitives, and external \nways of proving goals like guarantee satisfaction that do not expose the internal rccref representation. \nThis mostly consists of re-exporting existing axioms using new names. Then an explicit lock witness (since \nthe type system is not specialized to track lock witnesses) can be abstracted using: Parameter lockwitness \n: lock -> Set. Parameter locked : forall {l:lock}, hpred (lockwitness l). Parameter unlocked : forall \n{l:lock}, hpred (lockwitness l). The acquire and release operations must respectively produce and consume \na witness that a lock is held, that permits release. Using a binary operator --> on predicates that produces \na relation allowing changes from states where the .rst predicate holds to states where the second holds \n(a limited encoding of protocols), a witness may have type ref{lockwitness | locked}[empty,locked-->unlocked]. \nUsing an empty rely implies uniqueness, and requiring such a witness to release the lock prevents splitting \nthe witness, which would requiring weakening the rely of both resulting references. The read and write \nfor rccrefs would need to also require some witness that the lock was held: Figure 3. Syntax, omitting \nbooleans (b : bool), unary natural num\u00adbers (n : nat), unit, pairs, propositional True and False, and \nstandard recursors. The expression/type division is presentational; the lan\u00adguage is a single syntactic \ncategory of PTS-style [2] pseudoterms. Expressions e ::= x Variable Types t |||||||||::= e e !e e[e] \nalloc e (.x : t.e) (.M (x : t).e) t x . e swap(x, e) = Application Dereference Heap Select Allocation \nPure Function Procedure Types Store Atomic swap Propositional equality |||| ||| Prop ref{t | e}[e, e] \nType .x : t . t' t M. t' heap e Propositions Reference Type of Prop Dep. Product (pure) Impure Function \nHeaps Expressions Program Definition rcc_read ...{l:lock} (w:ref{lockwitness l | locked}[empty,locked-->unlocked]) \n (r:rccref A P R G l)... := (!r,w).(* return the witness *) This encoding of RCC/Java using dependent \ntypes is not novel, but note the rely, guarantee, and predicate of the underlying reference are exposed, \nyielding the .rst combination of race-free lock acquisition and reference immutability we are aware of, \nin addition to exposing the full power of rely-guarantee references over lock-guarded data. 4. A Type \nSystem for Rely-Guarantee References Figure 3 gives the syntax for a core language RGR E F with rely\u00adguarantee \nreferences. The expressions combine features from the ML-family (e.g., references) and dependently typed \nlanguages (e.g., dependent product), speci.cally from the Calculus of Construc\u00adtions [2, 13]. We include \na few basic datatypes (natural numbers, booleans, pairs, unit), a type for propositional equality, and \ntheir stan\u00addard recursors [25]. We also distinguish effectful functions through the term former .M and \nthe effectful non-dependent function type . t' former t M(M for mutation). The language supports reasoning \nabout heaps: not only is there a standard form of dereference, but there is a term for dereferencing \na reference in a particular heap, used to specify predicates and rely/guarantee relations using the propositions-as-types \nprinciple. The language is designed to use propositions-as-types to specify predicates and relations, \nand to use the pure sublanguage as a computational language amenable to rich reasoning, but to use external \nmeans for discharging obligations like a write satisfying a guarantee. The presence of current-heap-dereference \nmakes the pure term language itself unsound as a logic, internally offering assurances similar to Cayenne \n[1]. In general, the language for predicates and relations can be distinct from the term language, and \nthe term language does not require advanced types; our design is motivated by our implementation as a \nCO Q DSL (Section 5). Figure 4 presents the primary typing rules for the core language. There are two \nkey judgments: G f e : t for pure terms (useful for proofs), and G f e : t . G' for impure and substructural \ncomputation. Those pure rules omitted here (recursors for the assumed inductive types, typing the primitive \ntypes in Prop, etc.) are standard for a pure type system. The imperative typing judgment G f e : t . \nG' is .ow-sensitive to allow reasoning about when references are duplicated. Crucially, it allows reasoning \nabout when a reference must not be duplicated because its guarantee does not imply its own rely. For \nthis reason, we have two impure variable rules: one consumes the variable (V-0/), and the other uses \nan auxiliary relation G f t -t *t to split a type (V-*). Primitive types (nat, bool, unit) freely split \ninto two copies of themselves. We require that any variable captured by a closure has a self-splitting \ntype (.-I and FUN), and thus functions may be duplicated freely. We require that only values of self-splitting \ntypes are captured by dependent type constructors (.-F and the not\u00adshown propositional equality rule), \nso types are also self-splitting. Variables read in pure computation must also be self-splitting (V). \n References (and structures that may contain them, like pairs) are the only types with non-trivial splitting. \nReference types split into reference types that may coexist (each guarantee implies the other rely, both \nrelies are no stronger than the original rely, stable predicates, etc.), and pairs split into pairs of \nthe component-wise split results. For example, the problematic reference from Section 2.1 has non-trivial \nsplitting behavior, mediated by REF-*: y : ref{nat | any}[decreasing,increasing] Splitting this reference \nrequires consuming the original and produc\u00ading two weaker references: each guarantee may permit at most \nwhat the original guarantee allowed, and each rely must assume at least as much interference as the original. \nFor example, e f ref{nat | any}[decreasing,increasing] -ref{nat | any}[havoc,increasing] *ref{nat | any}[havoc,increasing] \nThe natural use of simply duplicating a reference whose guarantee implies its own rely (as in the monotonic \ncounter) is a degenerate case of the very general rule RE F -*. The conversion relation G f t . t is \na directed call-by-value \u00df\u00adconversion (so for example \u00df-reduction is not used with arguments containing \ndereferences) plus reducing abstractions whose bound variable is free in the result, and what amounts \nto subtyping by converting predicates and relations to weaker versions: P-. weakens the predicate; R-. \nassumes more interference may occur; and G-. sacri.ces some permissions; P and R changes may affect stability. \nMutation The most interesting rules are those for mutation, partic\u00adularly for writing to the heap (WR \nIT E). This rule requires (beyond basic type safety) that the effects fall within the guarantee, assuming \nthe reference s predicate holds in the current heap.4 It also allows the option of a strong update to \nthe reference s predicate, if the change establishes some new stable predicate. For example, x : ref{nat \n| . x..h.x = 3}[empty, havoc] f x . 4 : unit . x : ref{nat | .x.. h.x = 4}[empty,havoc] Thus R G RE F \nnaturally supports strong updates on unique references as a degenerate case. The atomic swap operation \n(which permits modifying substructural .elds) leverages the heap-write rule s premises. Allocation simply \nrequires a well-formed type as a result and establishing the predicate over the value in any heap. The \nimperative part of the language also includes non-dependent function types, application, and the use \nof pure expressions. Dereference uses the relation folding function [R,G] \u00bb t (Figure 5) to reason about \nthe rely and guarantee in result types. It has no effect for non-reference types. For types containing \nreferences, the result type is rewritten by intersecting the projection of the guarantee onto each component \nwith the stated guarantee for the component itself. This can cause some precision loss. The effect of \nfolding on the rely has no impact: because the rely for any well-formed 4 The re.exivity goals D E R \nE F generates could also assume the predicate (i.e., re.exive on states satisfying the predicate), but \nwe haven t needed this. reference type has to contain / admit the effects allowed by the rely of any \nreachable reference type, the intersection on the rely component would produce a relation semantically \nequivalent to the syntactically present rely on the inner reference (the same type of relation projection \nis used to check rely containment as is used in folding the guarantee). In general, relation folding \nand checking containment are straightforward for types whose members are al\u00adways re.ected in a type index \n(e.g., pairs, references). Folding for richer types, such as full inductive types [39] is left to future \nwork. The Deref rule also checks that the source type is self-splitting. This ensures that the (possibly \nweaker) guarantee of the result implies the original location s rely, and the original value s guarantee(s) \nwill imply the (unaltered) rely relations of the result. The rule for typing reference types themselves \n(W F -RE F) im\u00adposes several additional requirements on predicates and relations. First, the predicate \nP must be stable with respect to R. Second, the relations and predicates must be precise: all depend \nonly on heap state reachable from the referent. This prevents code from rendering the system unsound \nby allocating a new cell whose rely condition requires the heap to be invariant: that rely would be undesirable \nif enforced as it prevents all mutation and allocation, but unsound if ignored because all predicates \nare stable over such a rely. Finally, the rely must be closed (contained): any changes permitted by relies \nof references reachable from the referent are also permitted by the checked rely. This ensures that checking \nstable P R is suf.cient to ensure P is not violated (otherwise P could depend on other references reachable \nfrom the referent, whose rely relations might permit P to be invalidated). Figure 5 de.nes these notions \nprecisely. W F-RE F also requires as a side condition that P, R, and G are free of dereference expressions \n(!e), since implicitly heap-dependent predicates are not sensible. We foresee no technical dif.culty \nin building the system directly atop stronger calculi such as the Calculus of Inductive Construc\u00adtions \n[4] (CIC) beyond richer treatment of folding for the full spec\u00ad trum of inductive types (Section 5.2). \nThere are a few essential qualities required for soundness. First, effectful terms and abstrac\u00adtions \nare encapsulated in a separate judgment (which corresponds to a monadic treatment of effects in translation \nto a pure system). Any term in the pure fragment must be re.exively splittable, to avoid introducing \nresource semantics into the pure sublanguage. Captured variables have re.exively splittable types (G \nf t -t *t). In princi\u00adple this could be weakened, but we prefer the simplicity of allowing function terms \nto be arbitrarily duplicated. We build upon CC for simpler presentation. 4.1 Soundness Sketch Soundness \nfollows a preservation-like structure. Evaluation must preserve a couple invariants beyond standard heap \nsoundness: For each reference r : ref{T | P}[R,G] in the stack, heap, or expression under reduction, \nthere exists a proof of P (h[r]) h for the current heap h.  For each pair of references p : ref{T | \nP}[R,G] and q : ref{T |P' }[R' ,G'] in the stack, heap, or expression under reduction, if p and q alias \n(point to the same heap cell) then 0/ . G' . R and 0/ . G . R' .  Initially there are no references, \nso these hold trivially. On allocation, the predicate for the new object is true in all heaps by inversion \non the allocation typing, so the result is immediate. On any action through a reference, the type system \nensures the action falls within the guarantee. The action either preserves the predicate or produces \na new (stable) one, and the proof for that reference s new re.nement is easy to construct from the typing \nderivation results. For aliases, the used reference s guarantee must imply the rely of any alias, and \nthe alias s predicate is stable over its rely, and therefore preserved by the  . t' } t . {nat,bool,unit,Prop,Type,heap, \n= , .x : t . t' , t MG f t -ta *tb G f s -sa *sbG f t -t *t G f t -t *t G f (t,s) -(ta ,sa) *(tb,sb) \nG f ref{b | f' }[R' , G'] G f ref{b | f'' }[R'' ,G''] 0/ . [G'] . [R'' 0/ . [G''] . [R]' [G'] . [G'' \n[R] . [R' [R] . [R'' RE F -* ] ] . [G]] ] ,G''] G f ref{b | f}[R,G] -ref{b | f' }[R' ,G'] *ref{b | f'' \n}[R'' G f t -t *t AX I O M V G f e : t G f n : nat G f b : bool G f tt : unit G f Prop : Type G, x : \nt f x : t G f t -t *t .t . G.f t -t *t G f (.x : t . t') : s s . {Type,Prop} G,x : t f e : t' G f e1 \n: .x : t . t' G f e2 : t .-I .-E G f (.x : t. e) : .x : t . t' G f e1 e2 : t'[x/e2] DE R E F .-F e f \nt e f t' G f e : ref{t | P}[R,G] = [R, G] \u00bb t G f t : . G f t -t *t CO N V t' x : t f e : t' . G' G f \nt -t *t G re.exive G,x : t f t' : s ., s . {Type, Prop} G f e : t G f t t' G f!e : t' G f .x : t . t' \n: s G f e : t' . t' P-. R-. G-. G f (.M x : t. e) : t M .v,h. P v h . P' v h stable P' R [R] . [R' stable \nP R' [G'] . [G] G f t t ] G f ref{t | P}[R, G] ref{t | P' }[R,G] G f ref{t | P}[R,G] ref{t | P}[R' , \nG] G f ref{t | P}[R, G] ref{t | P}[R, G'] .t . G.f t -t *t . t' G f t -t' *t'' G,x : t f e : t' . G' \nG f e1 : t M. G1 G1 f e2 : t . G2 V-0/ V-* M -I M -E . G, x : t'' . t' G f e : t . G G,x : t f x : \nt . G G,x : t f x : t' G f (.M (x : t).e) : t M. G G f e1 e2 : t' . G2 WR I T E IDE R E F G f e : t . \nG' ,x : ref{t | P}[R,G] .h,h' : hea p. h' = [e](h) . P (!x) h' . P' [e] h'[x . [e]] G f e : ref{t | P}[R, \nG] t' = [R,G] \u00bb t stable P' R .h,h' : hea p.h' = [e](h) . P (!x) h' . G (!x) e h' h'[x . [e]] G f t -t \n*t G re.exive G f x . e : unit . G' ,x : ref{t | P' }[R, G] G f!e : t' . G' G f e : t . G' 0/. G stable \nP R .h : hea p.P e h G f x . e : unit . G' ,x : ref{t | P' }[R, G] e f e : t e f t : Prop AL L O C SWA \nP PU R E G f alloc e : ref{t | P}[R, G] . G' G f swap(x,e) : t . G' ,x : ref{t | P' }[R, G] G f e : t \n. G e f R : hrel(t) e f G : hrel(t) e f P : h pro p(t) closed R f e2 : t . G'' G f e1 : .x : t . t' \n. G' G' x . FV(t') precise R precise G precise P stable P R e f t : Prop I.-E W F -R E F . G'' G f e1 \ne2 : t' G f t : s G f ref{t | P}[R, G] : Prop with metafunctions hrel(t) def = t . heap . Prop = t \n. t . heap . heap . Prop and h pro p(t) def Figure 4. Typing. Not shown: standard recursors for naturals, \nbooleans, pairs, identity types [25]. Also not shown: standard well-formed contexts, most of (pure) expression/type \nconversion (G f t t) (see our technical report [23]). action within the used reference s guarantee. For \nother references, the action will fall within its rely (by containment) and thus a similar use of a stability \nproof suf.ces, or the changed cell is not reachable from the reference in question, in which case the \npredicate is preserved by precision. This proof is simpli.ed by slightly nonstandard operational se\u00admantics. \nFirst, we execute an elaborated language where conver\u00adsions, strong updates, and substructural reads \nof variables are ex\u00adplicit (translation from a typed source program is straightforward). To prove soundness \nof substructural manipulation, impure code ma\u00adnipulates a mutable stack, and references are fat pointers \nof the underlying pointer, rely, guarantee, and predicate. Variable capture in imperative closures occurs \nvia a rule that inlines all free variables when reducing to a value. Folding has a runtime representation, \nsince folded types sometimes occur as part of runtime values. Finally, the semantics sometimes reduce \nmultiple dereferences at once inside pure expressions, when type equivalence requires the dereference \nexpressions to be de.nitionally equal. This avoids trouble where the na\u00a8ive reduction might reduce de.nitionally \nequal dereferences in different heaps (with different values). We have yet to conceive of desirable computational \ncode that observes this behavior. Our technical report provides more details [23]. 5. Implementation \nTo understand R G R EF s effect on data structure design and the effort required for veri.cation, we \nhave implemented R GR EF as a shallow embedding in CO Q, and used it to implement Section 3 s examples. \nThis includes implementing reference immutability, meaning our RGR EF implementation can be used to write \nprograms using refer\u00adence immutability, and to gradually re.ne parts of those programs to use more .ne-grained \nrely and guarantee conditions and predicates. Overall, we found that RG R E F required careful choice \nof type re.ne\u00adments, but did not affect algorithm design and had reasonable proof burden (commensurate \nwith the complexity of the code veri.ed). The implementation is done largely in the style of Y N OT [11, \n34], with axioms for heap interaction, and using C O Q s notation facilities to elaborate source terms \nto C O Q terms with proof holes, which are then elaborated and semi-automatically solved by Sozeau s \nPRO-GR A M extension [42]. Each structure typically requires its own slightly customized PRO G RA M tactic \nfor effectively solving most goals, but we .nd that following the tactic development style Chli\u00adpala \nrecommends [10] tends to work well, as each module typi\u00ad cally handles its own family of predicates and \nrelations. Proofs involving heaps are carried out using a small set of axioms re.ect\u00ading invariants maintained \nby the semantics. The most useful ax\u00adiom is heap lookup : .h,A,P, R,G..r : ref{A | P}[R,G]. P (h[r]) \nh which means that in any heap, the type system ensures there is a proof of the re.nement for every valid \nreference. The implementa\u00adtion also relaxes some restrictions present in the formal language, such as \nallowing values to be projected into predicates (as in Section 3.2); predicates, rely and guarantee relations \nmust simply abstain from dereference.  def .x : t..h, h' stablet (P : hprop(t)) (R : hrel(t)) = : heap. \nP x h . R x h h' . P x h' def preciset (P : hpred(t)) = .x,h,h' .(.l, ReachFromIn l x h . h[l] = h'[l]) \n. P x h . P x h' def preciset (R : hrel(t)) = .x,x ' , h,h' ,h,h' .(.l, ReachFromIn l x h . h[l] = h'[l]) \n. (.l, ReachFromIn l x' h . h[l] = h'[l]) . R x x' h h . R x x' h' h' .. . . t' True if t . {nat, bool, \nunit,.x : t' . t'' , t M, True, False,heap, = } if t = (s * s') def closedt (R : hrel(t)) = closed R.1 \n. closed R.2 closed R' . .l, h,h' .R' h[l] h'[l] h h' . R l l h h' if t = ref{t' | P' }[R' ,G'] def \n[R,G] \u00bb t = . . . ... . t'' , t M t if t . {nat, bool, unit,.x : t' . t' , True, False, heap, = } ([R.1, \nG.1] \u00bb s * [R.2,G.2] \u00bb .) if t = (s * .) (.a,a ' , h,h' .G' a a ' h h' . ref{s | P}[R' , ' if t = ref{s \n| P}[R' , G'] (.l,h[l] = a . h'[l] = a . G l l h h')) ] R.2 def = .x, x ' : s..h,h' = .y, y ' : s. .h,h'where \nfor R : hrel(s * s'): R.1 def : heap. .y : s' . R (x, y) (x ' ,y) h h' and : heap..x : s' . R (x, y) \n(x, y ') h h' Figure 5. Selected auxiliary judgments and predicates We made compromises to .t into COQ. \nNotably, COQ lacks support for mutual inductive types where one indexes the other (e.g., a datatype simultaneously \nde.ned with an inductive predicate on that type). Our implementation adapts a standard encoding [8] of \ninduction-recursion [17] outlined in our technical report [23] to support examples like the list in Section \n3.2. Any use of this encoding somewhat complicates generated proof obligations and data structure designs. \nThus our current implementation is best\u00adsuited to functional-.rst designs that make only light use of \nreferences, as is common in OCaml, Scala, and F# code. We stress that this is a limitation of our implementation \nby embedding in COQ, not a fundamental limitation of rely-guarantee references. To use COQ s rich support \nfor inductive types, we require trusted user-provided de.nitions of relation folding, immediate reachability \n(without heap access) of references from a pure datatype, and relation containment. These are provided \nas typeclass instances. The de.nitions are fairly mechanical, and can be synthesized automatically for \nsimple types if we extend COQ s support for inductive datatypes. We also move some proof obligations \nsuch as stability, precision, and containment from type formation to allocation. This allows the de.nition \nof functions over ill-formed types, but such functions are unusable: only well-formed types may actually \nbe constructed. This avoids some redundant proof obligations. Our implementation is publicly available \nat https://github.com/csgordon/rgref/. 5.1 Proving Obligations with Dependent Types RGREF contains as \na sublanguage the full Calculus of Constructions (CC). Speci.cally, it contains a full Pure Type System \n(PTS) with sorts S = {Prop,Type}, axioms A = {Prop : Type}, and product formation rules R = {(s1,s2) \n| s1,s2 . S} as formulated by Barendregt [2]. This sublanguage is part of the pure (G f e : t) subset \nof RGREF. Thus the language is amenable to embedding directly into CC with a few extensions (natural \nnumbers, etc.) and RGREF\u00adspeci.c axioms. Our technical report details the translation [23]. This provides \nus with an approach to proving predicate and guar\u00adantee obligations in a way well-integrated with the \nsource language, justifying the use of proof terms in RGREF s implementation. This also allows straightforward \ntranslation of proof goals from our typ\u00ading derivations into COQ, where we can use tactic-based theorem \nproving to solve proof obligations. The only subtleties arise from the fact that our embedding treats \ndereference as an uninterpreted function, allowing two potential inconsistencies. First, we permit recursion \nthrough the store, so applying a function read (via dereference) from the heap could result in an in.nite \nloop; by treating dereference as an uninterpreted function in the embedding, this potential recursion \nis lost. The prototype may accept proofs about non-terminating terms. Second, there is a potential to \nequate dereference expressions that will be evaluated in different heaps (e.g., when a returned pure \nclosure dereferences some reference). Our implementation only uses full equational reasoning for cases \nwhere all dereferences occur in the same heap, and otherwise abstracts terms with only their type. 5.2 \nData Structure Design We were able to use natural data structures for the examples in Section 3, but \nthe types require careful consideration for propagating information through data .ow. For example, the \nreturn type of Cons in Figure 1 must carry the additional re.nement that the reference points to a cons \ncell whose tail is the tl argument, or the obligation to prove that the write prepends a cell in doPrepend \nis unprovable. From Simple Types to Inductive Types For the types whose split\u00adting, folding, and containment \nwe have examined formally (.rst\u00adorder data types, pairs, and references), the structure of the types \nis simple enough to provide a straightforward structural projection for each type. Much imperative code \n(e.g. in C, Java, etc.) heap-allocates similarly-simple structures. We have not worked out the theory \nfor full inductive types. For types whose constructor arguments are not re.ected as type indices, splitting \nand the like depend on the values passed to constructors, complicating the de.nitions for splitting because \nthey then depend not only on type indices, but the actual value being potentially-split. This is an issue \neven though we expect to only require support for small inductive types. For self-referential datatypes, \nsuch as the list, we have only used guarantees for which folding is idempotent. In general, folding a \nrestricted guarantee when dereferencing an datatype de.ned with concrete relations on recursive references \nis not expressible in the current system; if the guarantee on the recursive member changes, the result \nmay not match a constructor of the type! Supporting this would require some sort of datatype-generic \nsupport, or a hybrid dereference-and\u00adpattern-match to avoid directly representing not-quite-typed read \nresults. We leave full support for inductive types to future work.  5.3 Proof Burden RGREF imposes proof \nobligations for precision, folding, contain\u00adment, and guarantee satisfaction. For verifying the examples \nin Sections 3.1, 3.2, and 3.3, the proof burden is not substantially dif\u00adferent from verifying the analogous \npure-functional version. This section will call out which parts were particularly straightforward, as \nwell as the few challenging aspects. Precision obligations are typically easy to prove when they are \ntrue, as are the re.exive relation goals generated when references are used for reading: most are discharged \nby a simple induction, use of constructors for the relevant relation, and/or .rst order reasoning (e.g., \nCOQ s firstorder tactic). When the goals are not true (e.g., a relation or predicate is not precise), \nthe goal is simply not provable, and it is up to the developer to recognize this. In this respect, RG \nR EF is similar to verifying a functional program in C O Q: a developer can waste time on unsolvable \n(false) proof goals.  In cases where relation folding is a no-op (e.g., [R,G] \u00bb t = t as in the monotonic \ncounter) folding goals are a simple matter of reduction and basic equality. In cases where relation folding \nis not a no-op (e.g., for references to references where the outer reference s guarantee bounds effects \non other reachable objects), the folding obligations complexity depends on the relations involved. The \nmost dif.cult proof obligations generated are those checking that heap writes satisfy the guarantee.5 \nThis is partly because these goals sometimes require reasoning about reads from an updated heap, in particular \nproving non-aliasing between references to dif\u00adferent base types. Some goals are also complicated by \nnon-identity folding results in types. In the formal system, we abstract away the mechanism for checking \nguarantee satisfaction through a de\u00adnotational semantics for writes. Our implementation uses CO Q s notation \nfacilities for a sort of punning, to duplicate expressions into two contexts with different semantics \nfor dereference. The normal program s use of the dereference expression chooses the appropriate relation \nfolding type class instance, while the duplicated version used to check guarantee satisfaction is placed \ninside a context where a no-op fold instance overrides all others. This way the guarantee and predicates, \nwhich are speci.ed as predicates over a type A, can be applied directly to ! x at type A in the proofs \ninstead of at a weakened type. The disadvantage of this approach is that the expression duplication also \nduplicates proof goals. Many of the smaller goals are automatically discharged when using CO Q s PRO \nGR AM extension, but because the generated goals are formed in slightly different contexts, the solved \nlemmas proof terms have different arities, and are therefore not interchangeable in equalities. We encountered \nthis twice, and solved it by using the proof irrelevance axiom on applications of the equivalent lemmas. \nBecause stability, re.exivity, and satisfaction results tend to be reused within a module and by clients, \nit should be considered proper practice for modules exporting a given API to also export most goals proven \ninternally about properties of rely and guarantee relations, and predicates, as lemmas registered in \na module-speci.c hint database. This is best practice for verifying purely functional programs in COQ \nas well; in general most of the useful habits in verifying functional programs can be reused in our implementation. \n6. Future Work: Extensions and Adaptations The type system we present in this paper has a few limitations \n(these are orthogonal to the implementation-speci.c limitations described in Section 5). We brie.y mention \na couple here, and discuss them in more detail in our technical report [23]. One weakness is that every \nindividual write must fall within a guarantee relation. This means that a series of writes that individ\u00adually \nviolate a guarantee but in aggregate satisfy it are disallowed. This is a common challenge for veri.cation \ntechniques [3, 5, 41], and we expect related work to inspire suf.cient solutions. Also, as execution \nprogresses, the actions permitted on an object through all references strictly decreases, by weakening \nand splitting guarantees. We have no way to strengthen guarantees based on addi\u00adtional information, as \nin the recovery technique [22] used to combine reference immutability with uniqueness, allowing uniqueness \nto be temporarily lost and then recovered. A resource-based approach to splitting, as in deny-guarantee \nprogram logics [16], suggests one promising approach to preserving possible actions. 5 Not all are dif.cult; \nSection 3.1 s guarantee obligation is discharged by automatic proof search with arithmetic hints: auto \nwith arith. Finally, it would be useful to separate out a logically-consistent fragment of the pure sublanguage \n(possibly using techniques like F* s kind system [43]). 7. Related Work The most closely related work \nfalls into three categories: restricting mutation on a per-reference basis, techniques for reasoning \nabout interference among threads (which can be adapted to interference among aliases), and dependent \ntypes for imperative languages. Alias-based Mutation Control Many techniques exist to control side effects \nby restricting actions through particular references. No\u00adtable examples include reference immutability \n[22, 44, 49, 50], and the owner-as-modi.er interpretation of ownership and uni\u00adverse types [14]. Rely-guarantee \nreferences generalize reference immutability permissions (Section 3.3), allowing precise control over \nwhat modi.cation is permitted through a given alias, not simply a choice between arbitrary mutation and \nlocal immutability. The fact that reference immutability is a special case of rely-guarantee refer\u00adences \nsuggests a natural transition path from reference immutability to stronger veri.cation guarantees. Developers \ncould employ a pay\u00adas-you-go model for veri.cation, where a code base .rst transitions to using reference \nimmutability (which need not be onerous [22]), and then gradually enrich the types for some parts of \nthe system where more assurance is desired. Typestate approaches typically use reference immutability \nlike access permissions to control sharing of objects in a certain type\u00adstate, which is a weak form of \nre.nement [5, 29, 31, 35]. Nistor and Aldrich describe a program-logic style type system [35] using abstract \npredicates [38] and connectives inspired by separation logic to specify object propositions, essentially \nan enriched typestate much closer to a full predicate logic; we believe object propositions and RGREF \nhave similar expressivity in terms of what predicates they can verify. They pair access permissions with \nre.nements to let aliases share coinciding views of an object s properties, and handle non-atomic updates. \nHowever, propositions on aliased objects cannot change over time and all aliases must have identical \ncapabilities (simply preserving the proposition if the object is aliased), while RGR E F allows asymmetric \npermissions and some strong updates to re.nements even with aliasing. Milit ao and Aldrich present a \nsystem that splits objects into substates that each carry their own typestate, and ways to merge par\u00adticular \nsubstates into a typestate of the parent object [29]. Aliases to an object may exist and allow modi.cation \nprovided each reference is to a different substate, rather than to the full substate. Concurrently with \nour work, they have proposed a rely-guarantee typestate [30], where the rely is a typestate each alias \nassumes an object may be in, and the guarantee is a typestate each alias is required to produce when \nunpacked. The properties they can verify are limited to those expressible as typestate (.nite state partitioning) \nand the system requires the programmer to add many dynamic typestate checks to aid veri.cation, but using \ntheir system is easier than the theorem-proving RGR E F requires. RGR E F can express stronger properties \nand forces no extra dynamic checks. Reasoning About Thread Interference Generally, any technique that \ncan reason about interference among threads can be adapted to reason about interference among references. \nThe most closely related system for reasoning about thread interference is rely\u00adguarantee reasoning [27] \ndescribed in Section 1. The original rely-guarantee approach focused on global rela\u00adtions and assertions, \nhampering modularity. Several adaptations exist to treat interference over disjoint state separately. \nVafeiadis and Parkinson integrated rely-guarantee reasoning with separation logic [45], allowing separation \nof state with linear resource seman\u00ad tics from shared state with interference. Feng later generalized \nthis to add separating conjunction of rely and guarantee conditions [18]. The conditions split into separate \nrelations over separated pieces of shared state. Rely-guarantee references are heavily inspired by these \napproaches. However, RGR E F allows substantial overlap among heap segments.  Dodds et al. adapted standard \n(non-separating) rely-guarantee reasoning to give resource semantics to rely and guarantee relations \nas assumptions in a context [16]. This allows the interference on shared state to change over time as \npermission to modify disjoint parts in particular ways is split, rejoined, and split again differently. \nThis style of strong changes to the rely and guarantee over time could be adapted in a rely-guarantee \nreference system to allow the natural rely-guarantee reference generalization of the recovery technique \nof Gordon et al. [22], which allows recovering unique (or immutable) references from writable (or readable) \nreferences in a .ow-sensitive type system given some constraints on the input context to a block of code. \nWickerson et al. [46] apply a modularized rely-guarantee logic to treat (non-)interference in the degenerate \ncase of sequential access to the UNIXv7 memory manager. Related systems [15, 18, 45] could be applied \nsimilarly, but to our knowledge haven t. Most have only .rst-order treatment of interference. Only Concurrent \nAbstract Predicates [15] can (with some effort) store capabilities into the heap, while R G R EF naturally \nsupports this since mutation capabilities are tied to data. Our design closely follows a technique already \nshown successful in large-scale uses (reference-immutability [22]). Dependent Types for Imperative Code \nMany others have worked on integrating dependent types into imperative programming lan\u00adguages. Most take \nthe approach of using re.nement types [21, 43] that restrict modi.cation to mutable data, but the re.nements \nthem\u00adselves may depend only on immutable data. Examples include DML [47], ATS [9], and X10 s constrained \ntypes [36]. The re\u00ad .nement language is often also restricted to some theory that can be effectively \ndecided by an SMT solver, as in Liquid Types [41]. RGR E F allows re.nements to depend on mutable heap \ndata, and does not arti.cially restrict the properties that can be veri.ed (at the cost of requiring \nmanual guidance for proofs). A notable approach to dependent types in imperative code is Hoare Type Theory \n(HTT) [32, 33] and its implementation YN OT [11, 34]. HTT uses a monadic Hoare Triple to encode effectful \ncomputation. It allows using effectful code in speci.cations: it decides equality of effectful speci.cation \nterms by using canonical forms where traditional dependent type systems use \u00df-conversion. This approach \ncould be adapted for rely-guarantee references as well. Y N OT implements the core ideas of H T T as \na domain speci.c language embedded in CO Q. It supports traditional Hoare logic speci.cations and, by \nembedding, separation logic speci.cations as well. A later version [11] builds a family of targeted proof \nsearch tactics that can automatically discharge most separation logic proof goals generated while typechecking \nYNOT programs. We modeled our implementation after Y NOT, and are currently building a library of combinators \nand transformers in hopes of supporting similarly robust automatic proof discharge. H TT (and separation \nlogic in general) support proving functional correctness rather than the somewhat weaker safety properties \nveri\u00ad.ed by rely-guarantee references (and most other stable-assertion\u00adbased approaches [18, 27, 45]). \nBut this comes at the cost of spec\u00ad i.cations explicitly specifying aliasing constraints through choice \nof standard or separating conjunction. Separation logic speci.es the behavior of code, not the restrictions \non data transformation. Rely-guarantee reference types specify the possible evolution of data in the \ndescription of data itself. This means that assumptions and permission to modify state follow data-.ow, \nrather than the control-.ow-centric passing of assertions in most program logics. 8. Conclusion We have \nintroduced rely-guarantee references, an adaptation of rely\u00adguarantee program logics to reasoning about \ninterference among aliases to shared objects. The technique generalizes reference immutability, connecting \ntwo previously-separate lines of research and addressing a fundamental problem in verifying imperative \nprograms. We have shown the technique s usefulness by verifying correctness for several small examples \n(which are dif.cult to specify or verify with other approaches) in a prototype implementation. Our experience \nsuggests that at least for small examples, the proof burden is reasonable. Rely-guarantee references \ndemonstrate that aliasing in program veri.cation can be addressed by adapting ideas from reasoning about \nthread interference. Acknowledgments This work was supported by NSF grants CNS-0855252 and CCF\u00ad1016701; \nand by DARPA contracts FA8750-12-C-0174 and FA8750\u00ad12-2-0107. We thank the anonymous referees for their \ncomments, which helped improve the paper. References [1] L. Augustsson. Cayenne A Language with Dependent \nTypes. In ICFP, 1998. [2] H. Barendregt. Lambda Calculi with Types. 1991. [3] M. Barnett, M. F\u00a8uller, \nW. Schulte, ahndrich, K. R. M. Leino, P. M \u00a8and H. Venter. Speci.cation and Veri.cation: The Spec# Experience. \nCommun. ACM, 54(6):81 91, June 2011. [4] Y. Bertot and P. Cast \u00b4Interactive Theorem Proving and Pro\u00ad \neran. gram Development; Coq Art: The Calculus of Inductive Constructions. Springer Verlag, 2004. [5] \nK. Bierhoff and J. Aldrich. Modular Typestate Checking of Aliased Objects. In OOPSLA, 2007. [6] R. L. \nBocchino, Jr., V. S. Adve, D. Dig, S. V. Adve, S. Heumann, R. Komuravelli, J. Overbey, P. Simmons, H. \nSung, and M. Vakilian. A Type and Effect System for Deterministic Parallel Java. In OOPSLA, 2009. [7] \nR. Bornat, C. Calcagno, P. O Hearn, and M. Parkinson. Permission Accounting in Separation Logic. In POPL, \n2005. [8] V. Capretta. A Polymorphic Representation of Induction-Recursion. Retrieved 9/12/12. URL: http://www.cs.ru.nl/ \nvenanzio /publications/induction recursion.pdf, March 2004. [9] C. Chen and H. Xi. Combining Programming \nwith Theorem Proving. In ICFP, 2005. [10] A. Chlipala. Certi.ed Programming with Dependent Types. http: \n//adam.chlipala.net/cpdt/. [11] A. Chlipala, G. Malecha, G. Morrisett, A. Shinnar, and R. Wisnesky. Effective \nInteractive Proofs for Higher-order Imperative Programs. In ICFP, 2009. [12] Coq Development Team. The \nCO Q Proof Assistant Reference Manual: Version 8.4, 2012. [13] T. Coquand and G. Huet. The Calculus of \nConstructions. Information and Computation, 76, 1988. [14] W. Dietl, S. Drossopoulou, and P. M \u00a8 uller. \nGeneric Universe Types. In ECOOP, 2007. [15] T. Dinsdale-Young, M. Dodds, P. Gardner, M. Parkinson, and \nV. Vafeiadis. Concurrent Abstract Predicates. In ECOOP, 2010. [16] M. Dodds, X. Feng, M. Parkinson, and \nV. Vafeiadis. Deny-Guarantee Reasoning. In ESOP. 2009. [17] P. Dybjer. Inductive Families. Formal Aspects \nof Computing, 6:440 465, 1994. [18] X. Feng. Local Rely-Guarantee Reasoning. In POPL, 2009. [19] C. Flanagan \nand M. Abadi. Types for Safe Locking. In ESOP, 1999. [20] C. Flanagan and S. N. Freund. Type-Based Race \nDetection for Java. In PLDI, 2000. [21] T. Freeman and F. Pfenning. Re.nement types for ml. In PLDI, \n1991. [22] C. S. Gordon, M. J. Parkinson, J. Parsons, A. Brom.eld, and J. Duffy. Uniqueness and Reference \nImmutability for Safe Parallelism. In OOPSLA, 2012.  [23] C. S. Gordon, M. D. Ernst, and D. Grossman. \nRely-Guarantee Ref\u00aderences for Re.nement Types Over Aliased Mutable Data (Extended Version). Technical \nReport UW-CSE-13-03-02, University of Washing\u00adton, March 2013. [24] C. A. R. Hoare. An Axiomatic Basis \nfor Computer Programming. Commun. ACM, 12(10):576 580, Oct. 1969. [25] M. Hofmann. Syntax and Semantics \nof Dependent Types, in Semantics and Logics of Computation, chapter 3. 1997. [26] J. B. Jensen and L. \nBirkedal. Fictional Separation Logic. In ESOP, 2012. [27] C. B. Jones. Tentative Steps Toward a Development \nMethod for Interfering Programs. ACM TOPLAS, 5(4):596 619, Oct. 1983. [28] K. R. Leino and P. M \u00a8A Basis \nfor Verifying Multi-threaded uller. Programs. In ESOP, 2009. [29] F. Milit ao, J. Aldrich, and L. Caires. \nAliasing Control with View-based Typestate. In FTfJP, 2010. [30] F. Milit ao, J. Aldrich, and L. Caires. \nRely-Guarantee View Types\u00adtate. Retrieved 8/24/12, July 2012. URL http://www.cs.cmu.edu/ foliveir/papers/rgviews.pdf. \n[31] K. Naden, R. Bocchino, J. Aldrich, and K. Bierhoff. A Type System for Borrowing Permissions. In \nPOPL, 2012. [32] A. Nanevski, G. Morrisett, and L. Birkedal. Polymorphism and Separation in Hoare Type \nTheory. In ICFP, 2006. [33] A. Nanevski, A. Ahmed, G. Morrisett, and L. Birkedal. Abstract Predicates \nand Mutable ADTs in Hoare Type Theory. In ESOP. 2007. [34] A. Nanevski, G. Morrisett, A. Shinnar, P. \nGovereau, and L. Birkedal. Ynot: Dependent Types for Imperative Programs. In ICFP, 2008. [35] L. Nistor \nand J. Aldrich. Verifying Object-Oriented Code Using Object Propositions. In IWACO, 2011. [36] N. Nystrom, \nV. Saraswat, J. Palsberg, and C. Grothoff. Constrained Types for Object-Oriented Languages. In OOPSLA, \n2008. [37] S. Owicki and D. Gries. An Axiomatic Proof Technique for Parallel Programs I. Acta Informatica, \npages 319 340, 1976. [38] M. Parkinson and G. Bierman. Separation Logic and Abstraction. In POPL, 2005. \n[39] C. Paulin-Mohring. Inductive De.nitions in the System Coq: Rules and Properties. In Typed Lambda \nCalculi and Applications, 1993. [40] A. Pilkiewicz and F. Pottier. The Essence of Monotonic State. In \nTLDI, 2011. [41] P. M. Rondon, M. Kawaguchi, and R. Jhala. Low-Level Liquid Types. In POPL, 2010. [42] \nM. Sozeau. Program-ing Finger Trees in Coq. In ICFP, 2007. [43] N. Swamy, J. Chen, C. Fournet, P.-Y. \nStrub, K. Bhargavan, and J. Yang. Secure Distributed Programming with Value-dependent Types. In ICFP, \n2011. [44] M. S. Tschantz and M. D. Ernst. Javari: Adding Reference Immutability to Java. In OOPSLA, \n2005. [45] V. Vafeiadis and M. Parkinson. A Marriage of Rely/Guarantee and Separation Logic. In CONCUR. \n2007. [46] J. Wickerson, M. Dodds, and M. Parkinson. Explicit Stabilisation for Modular Rely-Guarantee \nReasoning. In ESOP, 2010. [47] H. Xi and F. Pfenning. Dependent Types in Practical Programming. In POPL, \n1999. [48] H. Xi, C. Chen, and G. Chen. Guarded Recursive Datatype Constructors. In POPL, 2003. [49] \nY. Zibin, A. Potanin, M. Ali, S. Artzi, A. Kiezun, and M. D. Ernst. Object and Reference Immutability \nUsing Java Generics. In ESEC-FSE, 2007. [50] Y. Zibin, A. Potanin, P. Li, M. Ali, and M. D. Ernst. Ownership \nand Immutability in Generic Java. In OOPSLA, 2010.    \n\t\t\t", "proc_id": "2491956", "abstract": "<p>Reasoning about side effects and aliasing is the heart of verifying imperative programs. Unrestricted side effects through one reference can invalidate assumptions about an alias. We present a new type system approach to reasoning about safe assumptions in the presence of aliasing and side effects, unifying ideas from reference immutability type systems and rely-guarantee program logics. Our approach, rely-guarantee references, treats multiple references to shared objects similarly to multiple threads in rely-guarantee program logics. We propose statically associating rely and guarantee conditions with individual references to shared objects. Multiple aliases to a given object may coexist only if the guarantee condition of each alias implies the rely condition for all other aliases. We demonstrate that existing reference immutability type systems are special cases of rely-guarantee references.</p> <p>In addition to allowing precise control over state modification, rely-guarantee references allow types to depend on mutable data while still permitting flexible aliasing. Dependent types whose denotation is stable over the actions of the rely and guarantee conditions for a reference and its data will not be invalidated by any action through any alias. We demonstrate this with refinement (subset) types that may depend on mutable data. As a special case, we derive the first reference immutability type system with dependent types over immutable data.</p> <p>We show soundness for our approach and describe experience using rely-guarantee references in a dependently-typed monadic DSL in Coq.</p>", "authors": [{"name": "Colin S. Gordon", "author_profile_id": "81496660244", "affiliation": "University of Washington, Seattle, WA, USA", "person_id": "P4148944", "email_address": "csgordon@cs.washington.edu", "orcid_id": ""}, {"name": "Michael D. Ernst", "author_profile_id": "81100204056", "affiliation": "University of Washington, Seattle, WA, USA", "person_id": "P4148945", "email_address": "mernst@cs.washington.edu", "orcid_id": ""}, {"name": "Dan Grossman", "author_profile_id": "81405594870", "affiliation": "University of Washington, Seattle, WA, USA", "person_id": "P4148946", "email_address": "djg@cs.washington.edu", "orcid_id": ""}], "doi_number": "10.1145/2491956.2462160", "year": "2013", "article_id": "2462160", "conference": "PLDI", "title": "Rely-guarantee references for refinement types over aliased mutable data", "url": "http://dl.acm.org/citation.cfm?id=2462160"}