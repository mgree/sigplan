{"article_publication_date": "10-01-2001", "fulltext": "\n Recursive Structures for Standard ML Claudio V. Russo Microsoft Research Ltd., St George House, 1 Guildhall \nStreet, Cambridge CB2 3NH crusso@microsoft.com ABSTRACT Standard ML is a statically typed programming \nlanguage that is suited for the construction of both small and large programs. Programming in the small \nis captured by Stan\u00addard ML s Core language. Programming in the large is captured by Standard ML s Modules \nlanguage that pro\u00advides constructs for organising related Core language de.ni\u00adtions into self-contained \nmodules with descriptive interfaces. While the Core is used to express details of algorithms and data \nstructures, Modules is used to express the overall archi\u00adtecture of a software system. In Standard ML, \nmodular pro\u00adgrams must have a strictly hierarchical structure: the depen\u00addency between modules can never \nbe cyclic. In particular, de.nitions of mutually recursive Core types and values, that arise frequently \nin practice, can never span module bound\u00adaries. This limitation compromises modular programming, forcing \nthe programmer to merge conceptually (i.e. archi\u00adtecturally) distinct modules. We propose a practical \nand simple extension of the Modules language that caters for cyclic dependencies between both types and \nterms de.ned in separate modules. Our design leverages existing features of the language, supports separate \ncompilation of mutually recursive modules and is easy to implement.  Categories and Subject Descriptors \nD.3.3 [Programming Languages]: Language Constructs and Features Modules,packages General Terms LANGUAGES, \nTHEORY  Keywords recursive modules, datatypes, Standard ML, type theory 1. INTRODUCTION Standard ML \n[12] (henceforth SML) is a high-level pro\u00adgramming language that is suited for the construction of Permission \nto make digital or hard copies of all or part of this work for personal or classroom use is granted without \nfee provided that copies are not made or distributed for pro\u00a3t or commercial advantage and that copies \nbear this notice and the full citation on the \u00a3rst page. To copy otherwise, to republish, to post on \nservers or to redistribute to lists, requires prior speci\u00a3c permission and/or a fee. ICFP 01, September \n3-5, 2001, Florence, Italy. Copyright 2001 ACM 1-58113-415-0/01/0009 ...$5.00. both small and large programs. \nSML s general-purpose Core language supports programming in the small with a rich range of types and \ncomputational constructs that includes mutually recursive datatypes and functions, control con\u00adstructs, \nexceptions and references. SML s special-purpose Modules language supports pro\u00adgramming in the large \n. Constructed on top of the Core, the Modules language allows sequential de.nitions of identi\u00ad.ers denoting \nCore language types and terms to be packaged together into possibly nested structures, whose components \nare accessed by the dot notation. Structures are transpar\u00adent:by default, the realisation (i.e. implementation) \nof a type component within a structure is evident outside the structure. Signatures are used to specify \nthe types of struc\u00adtures, by specifying their individual components. A type component may be speci.ed \nopaquely, permitting a variety of realisations, or transparently, by equating it with a partic\u00adular Core \ntype ([10] uses the terminology abstract and man\u00adifest instead; we follow [8]). A structure matches asigna\u00adture \nif it provides an implementation for all of the speci.ed components, and, thanks to the subtyping relation \ncalled enrichment, possibly more. A signature may be used to opaquely constrain a matching structure. \nThis existentially quanti.es over the actual realisation of type components that have opaque speci.cations \nin the signature, e.ectively hiding their implementation. A functor de.nition de.nes a polymorphic function \nmapping structures to structures. A functor may be applied to any structure that realises a sub\u00adtype \nof the formal argument s type, resulting in a concrete implementation of the functor body. Despite the \n.exibility of the Modules type system, it does su.er from an awkward limitation. Unlike the de.nitions \nof the Core language, module bindings must have a strictly hierarchical structure: the dependency between \nmodules can never be cyclic. In particular, although de.nable within the con.nes of a single module, \nde.nitions of mutually recursive types and values can never span module boundaries. While this does not \na.ect the expressiveness of the Core language, the restriction does compromise modular programming. The \nprogrammer is typically left with two choices. She can either merge conceptually distinct modules into \na single module, just to satisfy the type checker. Or she can resort to tricky encodings in the Core \nlanguage to break the cycles between modules. The .rst approach obscures the architecture of the program; \nthe second obscures its implementation. Neither solution is satisfactory. In this article, we relax the \nhierarchical structure of Mod\u00adules, allowing structures to be recursive. Our extension sup\u00adports mutual \nrecursion at the level of Core datatypes and (independently) values. Although di.erent in detail, our \nproposal may be seen as adapting Crary, Harper and Puri s theoretical analysis of module recursion to \nStandard ML [2]. Our main contribution is to provide a practical type system for recursive modules in \nStandard ML that avoids some of the typing challenges of the formalism in [2], and exploits Standard \nML s subtyping on modules to provide slightly more expressive and convenient constructs. Our extension \npreserves the existing features of Standard ML. For presentation purposes, we formulate our extension, \nnot for Standard ML, but for a representative toy language called Mini-SML. The static semantics of Mini-SML \nis based directly on that of Standard ML. Mini-SML includes the es\u00adsential features of Standard ML Modules \nbut, for brevity, only has a simple Core language of explicitly typed, mono\u00admorphic functions and non-parametric \ntype and datatype de.nitions. [14] treats a more realistic Standard ML-like Core with implicitly typed, \npolymorphic functions and pa\u00adrameterised type de.nitions. Our proposal has been adapted to full Standard \nML and is available in MoscowML [17]. Section 2 introduces the syntax of Mini-SML. Sections 3 gives a \nmotivating example to illustrate the limitations of acyclic Modules. Section 4 reviews the static semantics \nof Mini-SML. Section 5 de.nes our extension to recursive mod\u00adules and its static and dynamic semantics. \nSection 6 recasts the .rst example so that its mutually dependent components may be separately compiled. \nSection 7 presents a real-world example that uses recursive modules to implement an ad\u00advanced data structure. \nSection 8 assesses our contribution. 2. THE SYNTAX OF MINI-SML Figure 1 de.nes the abstract syntax of \nMini-SML. A type path tp is a projection t or sp.t of a (Core) type component from the context or a structure \npath. A core type umay be used to de.ne a type identi.er or to specify the type of a Core value. These \nare just the types of a simple functional language, extended with type paths. A signature body Bisa sequential \nspeci.cation of a structure s components. A type component may be speci.ed transparently, by equating \nit with a type, or opaquely, permitting a variety of realisations (ie. implementations). The implementation \nof a transpar\u00adent component is .xed (up to the realisation of any opaque types that it mentions). An \nopaque datatype speci.cation describes an arbitrary (recursive) datatype with .nite set of constructors \nK. Each constructor c .Kisspeci.edtotake nc (= 0) arguments of type uc,0 \u00b7\u00b7\u00b7uc,nc-1; nc is the con\u00adstructor \ns arity. In short, a datatype is a recursive, named sum of anonymous, possibly empty products The speci.\u00adcation \nmay be realised by any datatype with compatible constructors. Transparent datatype replication speci.es \na datatype that is equivalent to, and thus compatible with, the type tp (which must itself be bound to \na datatype). Transparent types and datatype replication may be used to express type sharing constraints \nin the usual way. Value and structure components are speci.ed by their type and signa\u00adture. The speci.cations \nin a body are dependent in that subsequent speci.cations may refer to previous ones. A sig\u00adnature expression \nS encapsulates a body, or is a reference to a bound signature identi.er. Informally, a structure en\u00adriches \n(has a subtype of) a completely transparent signature (ie. one containing no opaque type or datatype \nspeci.ca\u00adtions) if it provides an implementation for all of its speci.ed components, and possibly more. \nA structure matches asig\u00adnature containing opaque type or datatype speci.cations if it enriches a complete \nrealisation of that signature. Core expressions e describe a simple functional language extended with \nthe projection of a value identi.er from a structure path. Constructor applications and case expres\u00adsions \nare tagged with the name of the datatype (tp) that they introduce or eliminate. A constructor application \ntakes the values of its n arguments and builds a tuple tagged with the constructor c, introducing a value \nof type tp. The typ\u00ading rules ensure that the constructor is fully applied. A case expression evaluates \ne to a constructed value of type tp and choosesacontinuationbasedonthe tagofthisvalue. K is a .nite set \nof constructors used to index the set of alternative continuations. Each alternative binds nc constructor \nargu\u00adments xc,0 \u00b7\u00b7\u00b7xc,nc-1 in the continuation body ec (typing will ensure that nc is the arity of c \nin the datatype). A case expression need not be exhaustive, in which case evaluation aborts by raising \nthe built-in exception match. A structure path sp is a reference to a bound structure identi.er, or the \nprojection of one of its substructures. A structure body b is a dependent sequence of de.nitions: sub\u00adsequent \nde.nitions may refer to previous ones. A type def\u00adinition abbreviates a type. A datatype de.nition is \nlike a datatype speci.cation but generates a new(and thus dis\u00adtinct) type with the corresponding set \nof constructors. As in signatures, datatype replication declares a datatype that is equivalent to, and \nthus compatible with, the datatype tp. Datatype replication is used to copy a datatype into an\u00adother \nscope whilst preserving compatibility with that type. Value, recursive function and structure de.nitions \nbind term identi.ers to the values of expressions. A functor de.nition introduces a named function on \nstructures: X is the func\u00adtor s formal argument, S speci.es the argument s type, and s is the functor \ns body that may refer to X. The functor may be applied to any argument that matches S. A signature de.nition \nabbreviates a signature. A structure expression s evaluates to a structure. It may be a path or an encapsulated \nstructure body, whose type, value and structure de.nitions become the components of the structure. The \napplication of a functor evaluates its body against the value of the actual argument. A transparent constraint \n(s : S) restricts the visibility of the structure s components to those speci.ed in the signature, which \nthe structure must match, and reveals the actual realisations of all type components in the sig\u00adnature \n(even those with opaque speci.cations). An opaque constraint (s :> S) is similar, but hides the actual \nrealisation of type components with opaque speci.cations, introducing newabstract types.  3. MOTIVATING \nEXAMPLE We can illustrate the limitations of the acyclic Modules language of Mini-SML (and Standard ML) \nby attempting to implement mutually recursive functions over mutually re\u00adcursive datatypes. For more \ngood examples, see [2]. Suppose we wish to de.ne evaluation functions for two mutually recursive types \nof natural number and boolean ex\u00adpressions. Natural expressions include a conditional expres\u00adsion, If, \nthat tests a boolean condition; boolean expressions include a predicate, Null, on naturals. For each \nsort of ex\u00adpression, the evaluation function eval reduces an expression to normal form. Figure 2 is what \nwe would like to write in Mini-SML, but Meta-variables t . TypId, c . ConId, x, f . ValId, X . StrId, \nF . FunId and T . SigId range over disjoint sets of type, constructor, value, structure, functor and \nsignature identi.ers. The meta-variable K ranges over .nite sets of constructor identi.ers.  The meta-notationpc \nandpi ranges over .nite sequences of phrases p, indexed by constructor c or natural i. c.K i<n Type \nPaths and Core Types tp ::= t | sp.t type identi.er, type projection u ::= tp | u . u' type path, function \ntype Signature Bodies B ::= type t = u; B transparent type speci.cation | type t; B opaque type speci.cation \n | datatype t=(c ofuc,i) ; B opaque datatype speci.cation c.K i<nc | datatype t= datatype tp ; B transparent \ndatatype replication | val x : u; B value speci.cation | structure X : S; B structure speci.cation | \nEB empty body Signature Expressions S ::= sig B end | T encapsulated body, signature identi.er Core Expressions \ne ::= x value identi.er | .x:u.e function | ee' application | sp.x value projection  | c(ei) : tp constructor \napplication i<n | case e:tp ofcxc,i . ec constructor elimination c.K i<nc Structure Paths sp ::= X \n| sp.X structure identi.er, structure projection Structure Bodies b ::= type t = u; b type de.nition \n | datatype t=(c ofuc,i) ; b datatype de.nition c.K i<nc | datatype t= datatype tp ; b datatype replication \n| val x=e; b value de.nition | fun f(x:u):u' = e; b recursive function de.nition | structure X = s;b \nstructure de.nition | functor F (X : S) = s; b functor de.nition | signature T = S; b signature de.nition \n| Eb empty body Structure Expressions s ::= sp structure path | struct b end structure body | F(s) functor \napplication | s : S transparent constraint | s:> S opaque constraint (Mini-SML supports local functor \nand signature de.nitions so that structure bodies can play the role of Standard ML s separate top-level \nsyntax. In SML, constructors can have a most one argument, with multiple arguments encoded as tuples \n in Mini-SML, we support multiple arguments simply to avoid introducing separate syntax and rules for \ntuples. In SML, constructors are referenced by (long) value identi.ers, with the constructor status (and \nassociated datatype) recorded in the type of the identi.er. To avoid formalizing this machinery, we simply \ntreat constructors as uninterpreted tags, relying on explicit type annotations at constructor applications \nand case expressions to indicate membership of a particular datatype. Since we are only interested in \ncross-module recursion, datatype and function declarations are singly-recursive; support for mutual recursion \nis a by-product of our extension.) Figure 1: Syntax of Mini-SML structure Nat = struct datatype t = Zero \n| Succ of t 1 |Ifof Bool.t *t*t fun eval(n:t):t = case n : t of Zero => n | Succ m => Succ(eval m):t \n 2 3 |Ifbte=> case Bool.eval b: Bool.t of True => eval t | False => eval e end structure Bool = struct \ndatatype t = True | False | Null of Nat.t fun eval(b:t):t = case b : t of True => b | False => b | Null \nn => case Nat.eval n : Nat.t of Zero => True:t | Succ m => False:t end Figure 2: mutually recursive structures \ncannot. The code is rejected because of the three forward references to Bool (shown boxed) in the de.nition \nof Nat. Permuting the structure de.nitions does not help. In Standard ML, the easiest way to de.ne Bool \nand Nat is to use two global, simultaneous de.nitions (joined with and) of the datatypes and functions: \ndatatype tNat = ... | If of tBool * tNat * tNat and tBool = ... | Null of tNat fun evalNat(n:tNat):tNat \n= ... evalBool ... and evalBool(n:tBool):tBool = ... evalNat ... structure Nat = struct datatype t = \ndatatype tNat val eval = evalNat end structure Bool = struct datatype t = datatype tBool val eval = evalBool \nend In larger examples, this solution is unsatisfactory. It re\u00adquires the programmer to mangle the names \nof the types and functions and de.ne them in a scope that encompasses both modules, obscuring the program \ns architecture. The solu\u00adtion also impedes separate compilation, since most compilers do not allowsimultaneous \nde.nitions to be split across com\u00adpilation units. Another solution is to give a forward declara\u00adtion, \nForwardNat, whose individual components are param\u00adeterised by their forward references to Bool. Bool \ncan then be de.ned in terms of ForwardNat. We subsequently de.ne Nat so that its components are the .xed-points \nof apply\u00ading ForwardNat s components to the appropriate members of Bool. This solution is tedious, error-prone \nand ine.cient, since the only way to represent Bool.t in ForwardNat.eval is as an abstract type, not \na datatype. It is instructive to analyse the forward references in Figure 1 2. The type reference Bool.t \nmerely refers to a type de.ned in Bool the fact that Bool.t is a datatype with a set of constructors \nis irrelevant since we are neither trying to eliminate or introduce a value of the type. The term 2 reference \nBool.eval refers to a value de.ned in Bool:the only information we need to typecheck this reference is \nits 3 type. Finally, the type reference Bool.t againreferstoa type de.ned in Bool, but, unlike the .rst \nreference, the fact that Bool.t is actually a datatype is crucial in this context, since we are eliminating \na value of the datatype and need to knowits constructors and their types. If Bool.t was an ordinary type \nabbreviation or an abstract type, the case expression would fail to typecheck. Suppose we now try to \ntypecheck these forward references by throwing in some forward declarations. The .rst ref\u00aderence typechecks \nif we make a forward declaration that Bool.t is a type; the second typechecks if we make a forward declaration \nthat Bool.eval has type Bool.t -> Bool.t;the third (and its enclosing case statement) typechecks if we \nmake a forward declaration that Bool.t is the datatype datatype t = True | False | Null of Nat.t. Inspired \nby the similar constructs in [2], we propose to extend the Modules language with two new constructs for \nexpressing such forward declarations. The .rst construct is a newsignature expression, rec(X:S1)S2, called \na recursive signature (similar to the recursively dependent signatures of [2]). It constructs a signature \nfrom the body signature S2, under the forward declaration of a structure X matching the signature S1. \nRecursive signatures are useful for spec\u00adifying mutually recursive types that span module bound\u00adaries \nwithin the signature.1 Formally, we will require that the forward signature is enriched by (ie. a supertype \nof) the body, under some contractive (ie. non-circular) realisation of the type components in the forward \nspeci.cation. The realisation identi.es datatypes in the body with any of their forward declarations \nas opaque types; it ties the recursive knot. The contractiveness condition forces each recursive type \nto be mediated by a datatype, which is consistent with ordinary SML. Allowing for enrichment lets us \nget away with only giving forward speci.cations for those components that are actually required in the \nbody. signature EVAL = rec(X: sig structure Bool: sig type t end end) sig structure Nat: sig datatype \nt = Zero | Succ of t | If of X.Bool.t *t*t end structure Bool: sig datatype t = True | False | Null of \nNat.t val eval: t -> t end end; Figure 3: type recursion using a recursive signature With a recursive \nsignature, we can specify the mutually recursive datatypes declared in Bool and Nat (Figure 3). Notice \nthat we only need a forward declaration of X.Bool.t, since the signature of Bool canmakeanordinary(backward) \nreference to Nat. The speci.cation of Bool.eval in the body, although super.uous here, will be used below. \nThe second construct, rec(X:S)s, is a newstructure ex\u00adpression, called a recursive structure, that lets \nus construct 1 The term recursive signature is perhaps a misnomer, since the forward declaration declares \na structure, not a signature, and allows us to take the a .xed-point of the datatypes speci.ed in the \nbody, not a .xed-point of the body itself. structure Eval = rec(X:EVAL) struct structure Nat = struct \ndatatype t = datatype X.Nat.t fun eval(n:t):t = casen:tof Zero => n | Succ m => Succ(eval m):t |Ifbte=> \ncase X.Bool.eval b : X.Bool.t of True => eval t | False => eval e end structure Bool = struct datatype \nt = datatype X.Bool.t fun eval(b:t):t = caseb:tof True => b | False => b | Null n => case Nat.eval n \n: Nat.t of Zero => True:t | Succ m => False:t end end Figure 4: term recursion using a recursive structure \na cyclic value for s, given a forward declaration of this value as the structure X, and a partial speci.cation \nof its type S. Recursive structures are used to de.ne mutually recursive values whose de.nitions span \nmodule boundaries within s. Formally, we will require that the forward declaration of a recursive structure \nis enriched by the body. Allowing for enrichment lets us get away with only giving forward dec\u00adlarations \nfor those components that are actually required in the body. Opaque datatypes and types in the forward \ndeclaration must be implemented in the body by datatype replication or an equivalent type abbreviation \n(respectively), and simply introduce newabstract types. Nowwe can de.ne the structures Bool and Nat as \nsub\u00adstructures of the recursive structure bound to Eval in Figure 3. The recursive structure is typechecked \nunder the assump\u00adtion that its body enriches the forward declaration of X (ie. that it matches the signature \nEVAL). The datatypes declared in EVAL are implemented by replicating them in the body. Since the function \nX.Bool.eval is declared in EVAL and the type X.Bool.t is declared as an appropriate datatype in EVAL, \nthe boolean case expression in Nat.eval typechecks. Notice that the forward declaration only declares \na subset of the body s components: we omitted Nat.eval,since no forward reference to it is required. \nEval.Nat.eval will still be accessible, since the type of the body, not the forward declaration, determines \nthe type of a recursive structure. Operationally, a recursive structure is evaluated by eval\u00aduating its \nbody under the initial assumption that X is un\u00adde.ned. If evaluation of the body attempts to evaluate \nX, execution aborts by raising the (new) exception . (an al\u00adternative design is to enter a loop). If \nnot, and evaluation of the body produces a value, we update the binding of X with this value and return \nthe value as the value of the en\u00adtire expression. This is similar to the treatment of recursive thunks \nin lazy languages, except that we evaluate recursion eagerly, to ensure that the order of any side-e.ects \nis de\u00adterministic. In our example, Eval is well-de.ned, since all (dynamic) references to X are delayed \nunder abstractions. Kinds, Type Variables, Variable Sets and Types . .Kind ::= * ranging over types |. \nranging over datatypes a. def {a. .Var. = ,\u00df. ,...} kinded type variables def a .Var = Var * .Var. type \nvariables def P,Q .VarSet =Fin(Var ) type variable sets u .Type ::= a type variable | u .u ' function \nspace Realisations def .n . .Real = Var * .Var. .Type .Var. .nConstructor Environments and Type Structures \ndef .n K.ConEnv =ConId . n=0 Typen F .TyStr ::= u | (a. ,K) Structures, Signatures, and Existential Structures \n. . . St . . . . St .TypId .n.TyStr, . . . S .Str def = Sx . . . Sx .ValId .n.Type, . . SX . . SX .StrId \n.n.Str . . L .Sig ::= .P.S X .ExStr ::= .P.S Functors and Contexts F .Fun ::= .P.S.X . . . . . . . . \nCt . CT . . . . . . Ct .TypId .n.TyStr, CT .SigId .n.Sig, . . . . . . . . C .Context def = Cx . . . . \nCx .ValId .n.Type, . . . . . . . CX . CF . . . . CX .StrId .n.Str, CF .FunId .n.Fun . . . . . . . Figure \n5: semantic objects of Mini-SML  4. STATIC SEMANTICS OF MINI-SML Before we can propose our extension, \nwe need to review the static semantics, or typing judgements, of Mini-SML. Following [12], our static \nsemantics distinguishes syntac\u00adtic types of the language from their semantic counterparts, called semantic \nobjects. The semantic objects, de.ned in Figure 5, play theroleoftypes in thesemantics. Welet O range \nover all semantic objects. Notation 1. For sets A and B,Fin(A) denotes the set of .n .nite subsets of \nA,and A . B denotes the set of .nite maps from A to B.Let f and g be .nite maps. D(f) denotes the domain \nof de.nition of f.The .nite map f + g def has domain D(f) .D(g) and values (f + g)(a)=if a . D(g)then \ng(a)else f(a). Finally, if p = i<n gi is an n\u00adtuple of .nite maps we let f .p be the .nite map de.ned \ndef def inductively as follows: (f .p)= f if n =0 and (f .p)= (f . i<m gi)+ gm if n= m+1. Type variables \na . Var are just kinded variables rang\u00ading over semantic types. Ordinary variables of kind *range over \narbitrary semantic types, but variables of kind . are restricted to range only over other (datatype) \nvariables. Se\u00admantic types u .Type are the semantic counterparts of syn\u00adtactic Core types, and are used \nto record the denotations of type identi.ers and the types of value identi.ers. The sym\u00adbols ., .and \n.bind .nite sets, P, of type variables. A realisation . .Real maps type variables to semantic types and \ndatatype variables to datatype variables. It de\u00ad.nes a substitution on type variables (and a renaming \non datatype variables) in the usual way. The operation of ap\u00adplying a realisation . to an object Ois \nwritten . (O). Re\u00adalisations of datatype variables are restricted to renamings to ensure that the set \nof type structures (below) is closed under realisation. Type structures F .TyStr record the denotations \nof type components, and may either be a simple type u, arising from an ordinary type speci.cation or \nde.nition, or a pair (a. , K) of a datatype variable and its constructor environment,aris\u00ading from a \ndatatype speci.cation or de.nition. K.ConEnv is a .nite map from constructors to tuples of argument types. \nSemantic structures S. Str are used as the types of structure identi.ers and paths. A semantic structure \nmaps type components to the type structures they denote, and value and structure components to the types \nthey inhabit. def For clarity, we de.ne the extension functions t c F, S = def def {t .F}+ S,x: u, S \n= {x .u}+ S,andX : S, S ' = {X.S} + S ' , and let ES denote the empty structure \u00d8. A semantic signature \n.P.S is a parameterised type: it describes the family of structures . (S), for . a realisation of the \nparameters in P. .-bound type variables are introduced by datatype speci.cations and opaque speci.cations. \nThe existential structure .P.S, on the other hand, is a quanti.ed type: variables in P are existentially \nquanti.ed in S and thus abstract. Existential structures describe the types of structure bodies and expression. \nExistentially quan\u00adti.ed type variables are explicitly introduced by datatype de.nitions and opaque constraints \ns :> S, and implicitly eliminated at various points in the static semantics. A semantic functor .P.S.X \ndescribes the type of a functor identi.er: the universally quanti.ed variables in P are bound simultaneously \nin the functor s domain, S,and its range, X. These variables capture the type components of the domain \non which the functor behaves polymorphically; their possible occurrence in the range caters for the propa\u00adgation \nof type identities from the functor s actual argument: functors are polymorphic functions on structures. \nThe range X is the type of the functor body, that may introduce new (existential) types. A context C \nmaps type and signature identi.ers to the type structures and signatures they denote, and maps value, \nstructure and functor identi.ers to the types they inhabit. def For clarity, we de.ne the extension functions \nC, t c F= C+ def def {t.F}, C, T c L= C+ {T }, C, x: u = C+ {x. u}, .L def def C, X: S= C+ {X .S},and \nC, F: F= C+ {F .F}. We let V(O) denote the set of type variables occurring free in O, where the notions \nof free and bound variable are de.ned as usual. We also identify semantic objects that are equivalent \nup to a-conversion of bound type variables. The operation of applying a realisation to a type (sub\u00adstitution) \nis extended to all semantic objects in the usual, capture-avoiding way. De.nition 1. Enrichment Relation \n Given two type structures F and F ' ,F enriches F ' , written F CF ' , if and only if 1. F=F ' ;or \n 2. F =(a. , K)and F ' =a. .   Given two structures Sand S ' , Senriches S ' , written SCS ' , if and \nonly if D(S) .D(S ' )and 1. forallt .D(S ' ), S(t) CS ' (t); and 2. forallx .D(S ' ), S(x) = S ' (x); \nand 3. forallX .D(S ' ), S(X) CS ' (X).   Enrichment is a pre-order that de.nes a subtyping relation \non semantic structures (SCS ' means Sis a subtype of S ' ). The relation allows entire components to \nbe forgotten in the supertype, but also allows a datatype to be equated with an ordinary type component, \nby hiding its constructors. De.nition 2. Functor Instantiation A semantic functor .P.S.X instantiates \nto a functor '' '' instance S .X , written .P.S.X > S .X ,if and only if . (S)= S ' and . (X)= X ' , \nfor some realisation . with D(.)= P. De.nition 3. Signature Matching A semantic structure S ' matches \nasignature .P.S if and only if S ' C. (S) for some realisation . with D(.)= P. The static semantics of \nMini-SML is de.ned by the judge\u00adments in Figures 6 and 7. Denotation judgements (Cf p c O) relate type \nphrases to their denotations; classi.\u00adcation judgements (Cfp: O) relate term phrases to their semantic \ntypes. We deviate from the presentation in the De.nition [12] by classifying structure expressions and \nbod\u00adies using existentially quanti.ed semantic structures. The De.nition classi.es structure expressions \nusing bare seman\u00adtic structures, but, to capture generativity of type de.ni\u00adtions, uses a state from \nwhich to generate new type variables . We prefer our presentation because it is stateless and thus more \ndeclarative ([6] uses a similar presentation). The pro\u00adcedural and declarative formalisations of the \nsemantics are explained in detail, and proved equivalent, in [14, 15]. We only explain the additional \nrules concerning datatypes here. Note that a constructor application or case expression is well-formed \nonly if the explicit type path tp denotes a type structure with a constructor environment, ie. a datatype. \n(datatype t=( c of uc,i) ; p): A datatype c.K i<nc declaration, where p is a signature or structure body, \nis checked by building a constructor environment K from its constructor declarations, under the forward \nbinding that t denotes a new(ordinary) type a. . The side condition a..V (C) ensures that a. is not confused \nwith any existing type in the context. The datatype t is added to the con\u00adtext with its constructor environment \nbefore classifying the remaining declarations in the body. A binding of the type structure for t is added \nto the resulting structure S.The side condition on P prevents the capture of any free type variables \nin this type structure, by any of the parameters or existential types in P. In a signature, a. is a newtype \nparameter; in a structure, it is a newexistential type. (datatype t= datatype tp ; p) Datatype replication \nmerely rebinds the existing type structure of the type tp to t, so that tp and t denote the same datatype \nin the body p. t.D(C) Cfsp:S t.D(S) CftpcF CftcC(t) Cfsp.tcS(t) Cfucu Cftpcu Cftpcu Cftpc(a. ,K) Cftpca. \nCfucu Cfu ' cu ' Cfu.u ' cu .u ' Cfucu t.D(S) C,tcu fBc.P.S P nV(u)=\u00d8 CfBcL Cf(type t=u;B)c.P.(tcu,S) \na * .V(C) C,tca * fBc.P.S t.D(S) a * .P Cf(type t;B)c.{a * }.P.(tca * ,S) a. .V(C) .c.K..i<nc.C,tca. \nfuc,i cuc,i K={c. uc,i |c.K} i<nc C,tc(a. ,K)fBc.P.S P n({a.}.V(K))=\u00d8 t.D(S) Cf (datatype t=( cof uc,i);B) \nc.K i<nc c .{a.}.P.(tc(a. ,K),S) Cftpc(a. ,K) C,tc(a. ,K)fBc.P.S P n({a.}.V(K))=\u00d8 t.D(S) Cf (datatype \nt= datatype tp;B) c.P.(tc(a. ,K),S) Cfucu C,x:u fBc.P.S x.D(S) P nV(u)=\u00d8 Cf(val x:u;B)c.P.(x:u,S) CfSc.P.S \nP nV(C)=\u00d8 C,X:SfBc.Q.S ' X.D(S Q n(P .V(S))=\u00d8 ' ) Cf(structure X:S;B)c.P .Q.(X:S,S ' ) CfEB c.\u00d8.ES CfScL \nCfBc.P.S T.D(C) Cfsig Bend c.P.S CfTcC(T) x.D(C) Cfe:u Cfx:C(x) ' '' Cfucu C,x:u fe:u ' Cfe:u .u Cfe:u \nCf.x:u.e:u .u ' Cfee ' :u Cftpc(a. ,K)c.D(K) K(c)=.i<nui .i<n.Cfei :ui Cf(c( i<n ei):tp):a. . . Cfe:aCftpc(a,K) \n.c.K. c.D(K).K(c)=.i<nc uc,i . ' C..i<nc {xc,i .uc,i}fec :u Cf(case e:tpof cxc,i . ec):u ' c.K i<nc Cfsp:S \nx.D(S) Cfsp.x:S(x) X.D(C) Cfsp:S CfX:C(X) Cfsp:S X.D(S) Cfsp.X:S(X) Cfsp:S Cfs:X Cfsp:.\u00d8.S Cfb:.P.S \nCfstruct bend :.P.S Cfs:.P.S P nV(C(F))=\u00d8 ''' ' C(F)>S ..Q.S SCS Q nP =\u00d8 CfF(s):.P .Q.S '' ' Cfs:.P.S \nP nV(.Q.S ' )= CfSc.Q.S \u00d8 SC.(S ' ) D(.)=Q ' Cf(s:S):.P..(S) Cfs:.P.S CfSc.Q.S ' P nV(.Q.S ' )=\u00d8 SC.(S \n' ) D(.)=Q Cf(s:>S):.Q.S ' Cfb:X Cfucu C,tcu fb:.P.S P nV(u)=\u00d8 Cf(type t=u;b):.P.(tcu,S) a. .V(C) .c.K..i<nc.C,tca. \nfuc,i cuc,i K={c. uc,i |c.K} i<nc C,tc(a. ,K)fb:.P.S P n({a.}.V(K))=\u00d8 Cf (datatype t=( cof uc,i);b) \nc.K i<nc :.{a.}.P.(tc(a. ,K),S) Cftpc(a. ,K) C,tc(a. ,K)fb:.P.S P n({a.}.V(K))=\u00d8 Cf (datatype t= datatype \ntp;b) :.P.(tc(a. ,K),S) Cfe:u C,x:u fb:.P.S P nV(u)=\u00d8 Cf(val x=e;b):.P.(x:u,S) ' ' Cfucu Cfu cu ' ' \nC,f:u .u ,x:u fe:u C,f:u .u ' fb:.P.S P nV(u .u ' )=\u00d8 Cf(fun f(x:u):u ' =e;b):.P.(f:u .u ' ,S) Cfs:.P.S \nP nV(C)=\u00d8 C,X:Sfb:.Q.S ' Q n(P .V(S))=\u00d8 Cf(structure X=s;b):.P .Q.(X:S,S ' ) CfSc.P.S P nV(C)=\u00d8 C,X:Sfs:XC,F:.P.S.Xfb:.Q.S \nCf(functor F(X:S) = s;b):.Q.S CfScLC,TcLfb:.P.S Cf(signature T = S; b):.P.S CfEb :.\u00d8.ES Figure 6: Denotation \nand Core classi.cation judge- Figure 7: Modules classi.cation judgements ments 5. THE EXTENSION Formally, \nour extension requires two new syntactic con\u00adstructs, both additions to the Modules language: S ::= ... \n| rec(X:S)S ' recursive signature s ::= ... | rec(X:S)s recursive structure Two new rules extend the \nModules judgements CfS c L and Cfs: X (the semantic objects are unchanged): CfS c .P.S P nV(C)= \u00d8 C, \nX: SfS ' c .Q.S ' Q n(P .V(S)) = \u00d8  . (S ' ) C. (S) D(.)= PP n a.P V(. (a)) = \u00d8 Cf(rec(X:S)S ' ) c .Q.. \n(S ' ) (1) Rule 1 relates a recursive signature expression to its de\u00adnotation, a semantic signature. \nThe parameters P of the se\u00admantic signature .P.Sstem from opaque type and datatype speci.cations in the \nforward declaration s syntactic signa\u00adture S. The denotation of the signature body, S ' ,is deter\u00admined \nin the current context, extended with the assumption that X has type S. The side-condition P nV(C)= \u00d8pre\u00advents \nthe capture of free variables in Cby the bound vari\u00adables in P and ensures that these variables are treated \nas parameters for the classi.cation of S ' . The forward param\u00adeters P, which may occur in S andthusin.Q.S \n' ,must be realised in a way that ensures the body enriches the for\u00adward speci.cation. The realisation \n. identi.es type vari\u00adables stemming from opaque and datatype speci.cations in the forward signature \nwith types speci.ed in the body. Note that the variables in P may occur in S ' , so we apply the re\u00adalisation \nto both structures when checking enrichment; the simultaneous realisation ties the recursive knot. The \n.rst side condition on the domain of . ensures that all forward speci.cations are realised. The second \nside condition on the range of . ensures that the realisation is not circular, hence contractive and \nunique. The parameters Q of thebodyde\u00adtermine the parameters of the entire signature .Q.. (S ' ). CfS \nc .P.S P nV(C)= \u00d8 C, X: Sfs: .Q.S ' Q n(P .V(S)) = \u00d8S ' CS Cf(rec(X:S)s) : .P .Q.S ' (2) Rule 2 relates \na recursive structure expression to its type. If the forward declaration s signature S denotes .P.S,the \nbody s of the structure expression is classi.ed in the ex\u00adtended context C, X: S. The side-condition \nP nV(C)= \u00d8 prevents the capture of free variables in C by the bound variables in P and ensures that these \nvariables from the forward declaration are treated as new types for the clas\u00adsi.cation of s. During this \nclassi.cation, the constructors of any datatypes and the types of any values speci.ed in S are known. \nSince S is intended as a forward declaration of the types and values in s, the rule requires that the \ntype of s, .Q.S ' , enriches the forward declaration. In particular, this checks that any forward declared \nvalues that might be referenced in s are actually de.ned with the correct type in s (when the value of \ns is de.ned). Note that s may itself declare some newtypes Q. Before checking that the type of the body \nenriches the forward declaration, we eliminate the existential quanti.cation over Q, ensuring that these \nhypothetical types cannot capture any types in the forward declaration. The newtypes returned by the \nphrase are the union of the newtypes in the forward declaration and the newtypes of the body. Although \nnot fully illustrated by our examples, Rule 1 allows a mixture of opaque and transparent type speci.ca\u00adtions \nin both the forward declaration and the body. Opaque type components in the forward declaration must \nbe speci\u00ad.ed in the body as either a non-circular transparent type, an (inherently non-circular) opaque \ntype, or a potentially cir\u00adcular datatype; transparent type components must simply be implemented by \nequivalent types in the body (modulo realisation by .). (The side condition on the range of . rules out \nthe declaration of equi-recursive types -we only support recursion through named, iso-recursive types. \nAt higher kinds (type constructors), this restriction appears to avoid the typing di.culties associated \nwith equi-recursive types, whose equivalence at higher kinds is not known to be decidable [2].) Unlike \nRule 1, Rule 2 merely requires that the type of the body enriches the forward declaration, without allowing \nthe further realisation of any opaque types in the forward signature. Omitting the realisation step is \na design decision but is motivated by the principle that type equiv\u00adalences valid outside the body should \nalso be valid inside it: in particular, a forward reference to a type component should be compatible \nwith a backward reference to its cor\u00adresponding declaration in the body. Given a semantic signature .P.S, \nand a semantic struc\u00adture S ' , the algorithm for matching the structure against the signature is a straightforward \nadaptation of the folk\u00adlore two-pass algorithm (a simpler, one-pass variant, suitable in the absence \nof recursive types, is described and proved correct in [14]). The .rst-pass of the algorithm is used \nto construct a candidate realisation . of the variables in P. The algorithm traverses the structure of \nSkeeping S ' .xed. Each type variable a in P (and only those in P) is realised incrementally (by the \ncorresponding type component in S ' ), as we encounter its .rst occurrence in a type structure of the \nform a or (a, K)in S(corresponding to the opaque or datatype speci.cation that introduced a). The incremental \nrealisation is applied to the current realisation of S before resuming the traversal. After the construction \nof ., the folk\u00adlore algorithm conducts a second traversal of . (S), to check that the original S ' enriches \n. (S). Our algorithm, however, must also be able to check the enrichment condition in Rule 1, namely \n. (S ' ) C. (S)for some . with D(.)=P where . is not circular (P n a.P V(. (a)) = \u00d8). Observe that enrichment \nmust hold under a simultaneous realisation of not only S, but also S ' , which is di.erent from the ordi\u00adnary \nsignature matching problem where S ' is assumed not to mention any of the variables in P. Our solution \nis to use a modi.ed signature matching algorithm, that, during the .rst traversal of S, performs an occur \ncheck at each re\u00adalisation step, preventing variables in P from appearing in the range of .. In addition, \nbefore resuming the traversal, the incremental realisation is applied not only to the cur\u00adrent realisation \nof S, but also of S ' . The second pass of the algorithm simply checks that . (S ' ) C. (S). Note that \nthe algorithm is very similar to uni.cation. The algorithm and its correctness proof will appear in a \nfuture technical report. It easily scales to cope with Standard ML s type constructors (parameterised \ntypes). We can present the dynamic semantics of recursive struc\u00adtures as a simple extension of a sketched \ncall-by-value se\u00admantics for Mini-SML. The Mini-SML semantics is intended to model the semantics of Standard \nML. Our presentation follows the style of the De.nition [12]. The dynamic objects used during evaluation \nconsist of: aset of exceptions ex .Exn (distinct from values) that includes the existing exception match \nraised by the at\u00adtempted evaluation of a missing case alternative, and a newexception ., raised by a \npremature reference to an unde.ned recursive structure identi.er.  aset of core values v .CorVal that \nincludes recursive function closures and applications of n-ary construc\u00adtors to values (whose form we \nshall leave unspeci.ed).  aset of structure values, mapping value and structure identi.ers to values: \n  . .n def Vx . . Vx .ValId .CorVal V .StrVal =. .n VX . VX .StrId .StrVal aset of core results r .CorRes \n::= v | ex to cap\u00adture the values returned or exceptions raised by Core evaluation.  aset of structure \nresults R . StrRes ::= V | ex to capture the values returned or exceptions raised by Module evaluation. \n aset of functor closures <X,E,s> .FunVal.  a in.nite set of heap locations l .Loc, distinct from StrVal. \n a set of .nite heaps mapping locations to structure values or the distinguished unde.ned element .: \n def .n H.Heap =Loc .StrVal .{.} a set of environments E. Env mapping value iden\u00adti.ers to core values, \nstructure identi.ers to structure values or locations and functor identi.ers to closures: .. . . .n. \nEx . .. . Ex .ValId .CorVal . def . .n E.Env = EX . . EX .StrId .StrVal .Loc .. . . EF . .n. EF .FunId \n.FunVal The dynamic semantics is de.ned by environment based evaluation judgements (Figure 8). Each judgement \nform re\u00adlates an environment, initial heap and expression to a pair, consisting of a result (a value \nor an exception) and a possi\u00adbly updated heap. The omitted judgements E,Hfe .r,H ' E,Hfb .R,H ' for Core \nexpressions and structure bodies are a straightforward adaptation of the existing Standard ML rules, \nmodi.ed to propagate a heap in the same way that Standard ML s evaluation rules already propagate a store \n(in an implementation, the store can simply be re-used for the heap). Recursive structure expressions \nare evaluated by choosing a newlocation in the heap, initialized to ..If evaluation of the recursive \nstructure s body yields a value, we update the heap and return that value (Rule (6)). If it yields an \nexception, perhaps because of a premature eval\u00aduation of X, we simply propagate the exception (Rule(7)). \nAlthough we have omitted many of the rules, as in Standard ML, structure declarations and functor applications \nalways X .D(E) E(X) = V (1) E,Hfsp .R,H ' E,HfX .V,H X .D(E) E(X) = ll .D(H) H(l)=V (2) E,HfX .V,H X \n.D(E) E(X) = ll .D(H) H(l)= . (3) E,HfX ..,H E,Hfsp .V ' ,H ' X .D(V ' )V ' (X) = V (4) E,Hfsp.X .V,H \n' E,Hfsp .ex,H ' (5) E,Hfsp.X .ex,H ' . . E,Hfs .R,H ' . (E,X= l),(H,l = .) fs .V,H ' l .D(H) E,Hfrec(X:S)s \n.V,(H ' ,l =V) (6) (E,X= l),(H,l = .fs .ex,H ' ) l .D(H) (7)E,Hfrec(X:S)s .ex,H ' F .D(E) E(F) = <X,E,s \n' > ' '' '' E,Hfs .V,H (E,X=V),Hfs .R,H (8) E,HfF(s) .R,H '' F .D(E) E(F) = <X,E,s ' > E,Hfs .ex,H ' \n(9)E,HfF(s) .ex,H ' Figure 8: evaluation judgements bind structure identi.ers to values, not locations. \nEvaluat\u00ading a structure identi.er that refers to a functor argument or structure declaration returns \nthe value bound to that iden\u00adti.er in the environment (Rule (1)). If the identi.er refers to a recursively \nbound identi.er, which is necessarily bound to a location, we dereference that location in the heap, \nand return the stored value (Rule (2)), or raise the exception .if the location contains .(Rule (3)). \nEvaluating a projection either projects a value from the path s value, or propagates an exception (Rules \n(5) and (6)). In an implementation, we can distinguish references to recursive and non-recursive bindings \nstatically, so there is no need for a run-time test to distinguish applications of Rules (2) or (3) from \nRule (1). This is important because it ensures that the compi\u00adlation of references to non-recursive bindings, \nthat occur in ordinary Standard ML programs, is not penalised by our extension. Since we evaluate the \nbodies of recursive struc\u00adtures eagerly, and only once, the execution order of their side-e.ects (if \nany) is completely deterministic: this means that it is straightforward to extend Mini-SML with the im\u00adpure \nfeatures of ordinary SML (references, exceptions and I/O) that rely on a .xed evaluation order. Note \nthat functor application remains call-by-value (Rules (8) and (9)). Although we do not attempt it here, \nwe should be able to prove type soundness for (an instrumented version of) this semantics using the technique \nof Tofte [18] and its re\u00ad.nement by Elsman [6]. The main technical challenge in proving the type soundness \nresult has less to do with the presence of the heap, which is similar to ML s store and should succumb \nto known proof techniques. The di.culty lies with ML s treatment of datatypes as named recursive types. \nAlthough type generativity ensures that each new datatype is assigned a unique type variable, a priori, \nthere is nothing in the static semantics that prevents an existing datatype variable from being associated \nwith more than one constructor environment in the context, making it impos\u00adsible to deduce the structure \nof a constructed value from its type. Type soundness can still be proved modulo an in\u00adterpretation of \ndatatype variables as recursive types that is consistent with each type structure in the context (cf. \n[6]). The proof will appear in a future technical report. 6. SEPARATE COMPILATION It is a simple exercise \nto showthat the de.nition of the recursive signature and structure in Figures 3 and 4 type\u00adcheck. Although \nthe de.nition of Eval contains two mutu\u00adally recursive structures, it is not clear that we have gained \nvery much. We have obtained the desired modular struc\u00adture, but the substructures are still de.ned simultaneously, \nand, in their present form, cannot be typechecked or com\u00adpiled in isolation. Support for separate compilation \nis one of the main motivations for introducing a module system. If the cost of programming with recursive \nmodules is that their substructures must be de.ned in a single compilation unit, then, aside from better \ncontrol of the namespace, we have not progressed much beyond the original restriction that con.nes recursive \nde.nitions to a single module. (* unit EVAL.sig *) signature EVAL = rec(X: sig structure Nat: sig type \nt end structure Bool: sig type t end end) sig structure Nat: sig datatype t = Zero | Succ of t | If of \nX.Bool.t *t*t val eval: t -> t end structure Bool: sig datatype t = True | False | Null of X.Nat.t val \neval: t -> t end end; (* unit NatFun.sml *) functor NatFun(X:EVAL) = struct datatype t = datatype X.Nat.t \nfun eval(n:t):t = case n : t of Zero => n | Succ m => Succ(eval m):t |Ifbte=> case X.Bool.eval b : X.Bool.t \nof True => eval t | False => eval e end; (* unit BoolFun.sml *) functor BoolFun(X:EVAL) = struct datatype \nt = datatype X.Bool.t fun eval(b:t):t = case b : t of True =>b|False =>b | Null n => case X.Nat.eval \nn : X.Nat.t of Zero => True:t | Succ m => False:t end Figure 9: separately compiled functors Ideally, \nwe would like to separately compile the de.ni\u00adtions of Bool and Nat as functors, each parameterised by \nthe implementation of the other (Figure 9), and then take their .xed point in a separate compilation \nunit. The func\u00adtors BoolFun and NatFun are completely independent and can be compiled separately (the \ncommon signature EVAL is a convenient abbreviation only, and could be in-lined, and indeed made smaller, \nat each occurrence). The di.culty arises when we try to take the naive .xed point of the two functor \napplications: structure Eval = rec(X:EVAL) struct structure Nat = NatFun(X) structure Bool = BoolFun(X) \nend This de.nition of Eval typechecks, but raises .,since the body of Eval attempts to evaluate its forward \ndeclaration before converging to a value (functor application is strict). structure Eval = rec(X:EVAL) \nstruct structure EtaX = struct (*an eta-expansion of X*) structure Nat = struct datatype t = datatype \nX.Nat.t val eval = .n:t. X.Nat.eval n end structure Bool = struct datatype t = datatype X.Bool.t val \neval = .b:t. X.Bool.eval b end end structure Nat = NatFun(EtaX) structure Bool = BoolFun(EtaX) end Figure \n10: using eta-expansion to reach a .xed-point Fortunately, we can still obtain the correct .xed point \nif we apply the functors to an eta-expansion of the forward declaration (Figure 10). While awkward, and \nslightly less e.cient than a direct de.nition (Figure 4), this solution applies whenever the forward \ndeclared values have function types. Note that our primary goal was to support cross\u00admodule recursive \nfunctions, which satisfy this criterion. Another alternative, that lets us get away with the naive de.nition \nand avoid eta-expansion, would be to change our dynamic semantics and bind all structure identi.ers to \nlo\u00adcations into the heap; this modi.cation has the e.ect of penalising all structure projections, not \njust those from re\u00adcursively bound structures, and reduces the performance of ordinary Standard ML programs. \n 7. ADVANCED EXAMPLE Aside from modular programming, recursive modules also have applications in the \nimplementation of advanced algo\u00adrithms and data structures. Chris Okasaki s excellent book [13] gives \na pseudo code implementation of bootstrapped heaps that requires recursive structures. Figure 11 con\u00adtains \na simpli.ed version of his construction. The example compiles in MoscowML but relies on some features \nnot for\u00admalised in Mini-SML (pattern matching and higher-order, applicative functors [11, 14, 16]). The \nBootstrap functor takes an arbitrary primitive heap functor, F, and an ordered signature ORD = sig type \nt val leq:t*t->bool end signature HEAP = sig structure Elem: ORD type heap val empty: heap val insert: \nElem.t * heap ->heap val merge: heap * heap -> heap val findMin: heap -> Elem.t option end functor Bootstrap(F:functor \nO:ORD -> HEAP where type Elem.t = O.t) (O:ORD): HEAP = struct signature BOOT= rec(X:sig structure Elem:ORD \nend) sig structure Heap: sig type heap = App.heap where App = F(X.Elem) end structure Elem: sig datatypet=E|HofO.t* \nHeap.heap val leq:t*t-> bool end end structure Boot = rec(X:BOOT) struct structure Elem = struct datatype \nt = datatype X.Elem.t fun leq (H (x, _), H (y, _))= O.leq (x, y) end structure Heap = F(Elem) end structure \nElem = O datatype heap = datatype Boot.Elem.t val empty = E fun merge(E, h)=h| merge(h, E) = h | merge(h1 \nas H(x,p1), h2 as H(y,p2)) = if O.leq(x,y) then H(x,Boot.Heap.insert(h2,p1)) else H(y,Boot.Heap.insert(h1, \np2)) fun insert(x,h) = merge (H(x,Boot.Heap.empty),h) fun findMin E = NONE | findMin (H(x,_)) = SOME \nx end Figure 11: Okasaki s bootstrapped heaps type, O, and returns an improved implementation of heaps \nover O. The datatype Boot.Elem.t is the type of boot\u00adstrapped heaps. A bootstrapped heap is either empty, \nE, or a node, H(x,p), consisting of a root element x of type O.t and an F-constructed primitive heap \np of bootstrapped heaps. The root x caches the minimum element amongst all those bootstrapped heaps contained \nin the primitive heap p. Bootstrapped heaps are ordered by Boot.Elem.leq with respect to their root \nvalues. Note the use of signature re\u00adcursion to construct the type Heap.heap from the recursive application \nF(X.Elem) (which relies on the assumption that F is applicative). With these data structures in place, \nthe construction uses bootstrapped heaps to represent heaps of O.t elements as follows. To merge two \nheaps we insert the underlying bootstrapped heap with the larger root into the underlying bootstrapped \nheap with the smaller root, using the insert operation on bootstrapped heaps (not heaps). To insert an \nelement into a heap, we create a singleton heap from the element and merge it. The minimum element of \na (non-empty) heap is just the root at the node of the under\u00adlying bootstrapped heap. This construction \nimproves the  running time of both findMin and merge to 0(1) worst-case time, assuming that the original \nheap F supports insert in 0(1) and merge and findMin in 0(log n) worst-case time [13]. 8. RELATED WORK \nAND CONCLUSION For presentation purposes, we restricted our attention to an explicitly typed, monomorphic \nCore language, but the extension scales to full Standard ML [15], whose Core lan\u00adguage supports parameterised \ntypes and polymorphic val\u00adues. Our extension is available in the current release of MoscowML [17]. Adding \nrecursive structures to Standard ML immediately extends the language with (explicit) poly\u00admorphic recursion, \nsince a recursive function may call it\u00adself through a forward reference, that can be speci.ed to have \nthe required polymorphic type. In combination with MoscowML s .rst-class modules [16], recursive structures \nmay be used to de.ne (syntactically heavy-weight) encod\u00adings of class-based objects with virtual methods, \nusing func\u00adtors to capture code inheritance (but not subtyping). Much more compelling is the useful combination \nof MoscowML s higher-order functors with recursive structures, that we il\u00adlustratedinSection 7. MoscowML \ns implementation of recursive structures is unsophisticated. We currently make no attempt to avoid dynamic \nchecks, and the cost of accessing a forward decla\u00adration is proportional to its depth in the forward \nsignature. We do, however, depart from the naive dynamic semantics by compiling enrichment as a coercion \nto a pruned structure value: in particular, the heap allocated value for a forward declaration is a pruned \nversion of the structure body s value, reducing the potential for space leaks. Another obvious opti\u00admization \nwould be to .atten the representation of this value to support depth-independent, constant-time access \nfor each component in the forward declaration. Although it is dif\u00ad.cult to construct realistic benchmarks, \nthe current cost of calling a recursive function through a forward declaration at depth 0 appears to \nbe approximately 60% more expen\u00adsive than an ordinary recursive call. Removing the dynamic check for \nde.nedness (when safe) reduces the .gure to 40%. Another possible optimisation is to represent the forward \nreference as a cell storing, not a tagged value, but a function that initially returns . and is updated \nwith a function that returns the value of the forward declaration, thus caching the result of the check. \nReplacing the dynamic checks by calls to these functions may be less expensive. The important observation \nthat recursive signatures can be used to specify mutually recursive types that span mod\u00adule boundaries, \nwhile recursive structures should be used to de.ne mutually recursive values, appears in the paper by \nCrary, Harper and Puri [2] (recently revisited in [3]). That work is more theoretical than ours, and \npresents recursive signatures and modules as an extension of the phase dis\u00adtinction calculus of [9]. \nThe authors use pseudo Standard ML syntax for their examples but leave the integration with Standard \nML to future work. Our work may be seen as a concrete design based on this proposal, but it does di.er \nin some aspects. In [2], a recursive signature does not con\u00adtain a forward signature: all types in the \nsignature body are considered to be mutually recursive and must be fully transparent. We allow.ner control \nof the recursion in sig\u00adnatures and support opaque types in the signature body. More importantly, in \n[2] the forward declaration in a recur\u00adsive module determines the type of the entire phrase, while in \nour proposal the body of a recursive structure must only enrich the forward declaration, but the full \ncomplement of its components will still be accessible from the expression as a whole. Our construct is \nmore practical for the program\u00admer, who must only make a forward declaration for those components that \nrequire forward references in the body; the remaining components in the body will not be hidden by the \nforward declaration, and need not be speci.ed. Allowing for the addition of ordinary subtyping to [2] \ndoes not remove the distinction between our construct and theirs. Another di.erence is that the system \nin [2] statically rejects recursive modules that may be unde.ned, while we allow such mod\u00adules at the \ncost of an inexpensive run-time check, that must be performed only when recursion crosses a module bound\u00adary. \nTo allow.xed-points of module expressions other than values, but at the same time guarantee de.nedness, \n[2] uses a re.ned type system that draws a distinction between valu\u00adable and possibly unde.ned expressions. \nThis is a cleaner solution, but we prefer to pay the cost of the run-time check rather than burden the \nStandard ML programmer with sup\u00adplying more accurate type information in signatures. An optimizing compiler \ncan still track valuability internally to remove unnecessary heap indirections and dynamic checks. Duggan \nand Sourelis s [4] mixin modules , although re\u00adlated to this work, solve a more general problem: to allow \nthe de.nition of individual ML functions and datatypes to span module boundaries. Their system is an \nextension of SML-style Modules that allows datatypes, functions and ini\u00adtialisation code de.ned in one \nmixin module to be extended by constructors, match rules and further initialisation code de.ned in another, \nusing a newoperator called mixin com\u00adposition. Composition merges two mixins to produce a new mixin; \na separate construct closes a mixin module to take the .xed-point of its components. In [5], the authors \npropose an additional construct that links a simultaneous declara\u00adtion of mixins containing unrelated, \nbut mutually recursive, components, supporting cross-module recursion of the kind considered here. In \ncombination, these extensions are more expressive than our own, but they also require more sig\u00adni.cant \nchanges to Standard ML and its implementations. The semantics of the linking construct are not spelled \nout in detail, making a comparison with our approach di.cult. More distantly related to our work are \nFlatt and Felleisen s units [7], a module language for Scheme that caters for cyclicly dependent and \npossibly dynamically linked units : although the authors present a typed version of the lan\u00adguage, they \npoint out that it does not give a satisfactory treatment of ML style type sharing, which we do support. \nClosely related to that proposal are Ancona and Zucca s [1] mixin modules, and Wells and Vestergaard \ns [19] simi\u00adlar module calculus. In those systems, a module may only contain terms, not types. The goals \nof these systems are di.erent from ours, but this simpli.cation avoids the main di.culty with type checking \nrecursive modules, namely ac\u00adcommodating mutually recursive, cross-module type de.ni\u00adtions, which is \nthe focus of this paper. 9. REFERENCES [1] Ancona, D., and Zucca, E. 1999. A primitive calculus of mixin \nmodules. In Proc. Principles and Practice of Declarative Programming,LNCSvol. 1702 , pages 69-72, Berlin. \n[2] Crary, K., and Harper, R., and Puri, S. 1999. What is a recursive module? In Proc. ACM SIGPLAN 99 \nConf. on Programming Language Design and Implementation, pages 50-63. [3] Dreyer, D., and Harper, R., \nand Crary, K. 2001. Toward a Practical Type Theory for Recursive Modules. TR CMU-CS-01-112, Computer \nScience, Carnegie-Mellon University, March.. [4] Duggan, D., and Sourelis, C. 1996. Mixin modules. In \nProc. ACM SIGPLAN International Conference on Functional Programming,pages 262-273, Philadelphia. [5] \nDuggan, D., and Sourelis, C. 1998. Parameterized modules, recursive modules, and mixin modules. In Proc. \nACM SIGPLAN Workshop on ML, pages 87-96, Baltimore. [6] Elsman, M. 1999. Program Modules, Separate Compilation, \nand Intermodule Optimisation. PhD thesis. University of Copenhagen. [7] Flatt, M., and Felleisen, M. \n1998. Units: cool modules for HOT languages. In Proc. ACM SIGPLAN 98 Conf. on Programming Language Design \nand Implementation, pages 236-248. [8] Harper, R., Lillibridge, M. 1994. A type-theoretic approach to \nhigher-order modules with sharing. In 21st ACM Symp. Principles of Programming Languages. [9] Harper, \nR, and Mitchell, J. C., and Moggi, E. 1990. Higher-order modules and the phase distinction. In 17th ACM \nSymp. Principles of Programming Languages [10] Leroy, X., 1994. Manifest types, modules, and separate \ncompilation. In 21st ACM Symp. Principles of Programming Languages, pages 109 122. ACM Press. [11] Leroy, \nX., 1995. Applicative functors and fully transparent higher-order modules. In 22nd ACM Symp. Principles \nof Programming Languages.ACM Press. [12] Milner, R., and Tofte, M., and Harper, R., and MacQueen, D. \n1997. The De.nition of Standard ML (Revised). MIT Press. [13] Okasaki, C. 1998. Purely Functional Data \nStructures. Cambridge University Press. [14] Russo, C. V. 1998. Types For Modules. PhD Thesis, LFCS, \nUniversity of Edinburgh. [15] Russo, C. V. 1999. Non-Dependent Types For Standard ML Modules. In 1999 \nInt l Conf. on Principles and Practice of Declarative Programming. [16] Russo, C. V. 2000. First-Class \nStructures for Standard ML. In Nordic Journal of Computing, 7(4):348, Winter 2000. [17] Sestoft, P., \nand Romanenko, S., and Russo, C. V. 2000. MoscowML V2.00. [18] Tofte, M. 1988. Operational Semantics \nand Polymorphic Type Inference. PhD thesis, Computer Science, University of Edinburgh. [19] Wells, M., \nand Vestergaard, R. 2000. Equational reasoning for linking with .rst-class primitive modules. In Programming \nLanguages &#38; Systems, 9th European Symp. Programming,LNCSvol. 1782 , pages 412-428, Berlin.  \n\t\t\t", "proc_id": "507635", "abstract": "Standard ML is a statically typed programming language that is suited for the construction of both small and large programs. \"Programming in the small\" is captured by Standard ML's Core language. \"Programming in the large\" is captured by Standard ML's Modules language that provides constructs for organizing related Core language definitions into self-contained modules with descriptive interfaces. While the Core is used to express details of algorithms and data structures, Modules is used to express the overall architecture of a software system. In Standard ML, modular programs must have a strictly hierarchical structure: the dependency between modules can never be cyclic. In particular, definitions of mutually recursive Core types and values, that arise frequently in practice, can never span module boundaries. This limitation compromises modular programming, forcing the programmer to merge conceptually (i.e. architecturally) distinct modules. We propose a practical and simple extension of the Modules language that caters for cyclic dependencies between both types and terms defined in separate modules. Our design leverages existing features of the language, supports separate compilation of mutually recursive modules and is easy to implement.", "authors": [{"name": "Claudio V. Russo", "author_profile_id": "81100638789", "affiliation": "Microsoft Research Ltd., Cambridge, UK", "person_id": "P345490", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/507635.507644", "year": "2001", "article_id": "507644", "conference": "ICFP", "title": "Recursive structures for standard ML", "url": "http://dl.acm.org/citation.cfm?id=507644"}