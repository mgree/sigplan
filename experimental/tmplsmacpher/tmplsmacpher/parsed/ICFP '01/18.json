{"article_publication_date": "10-01-2001", "fulltext": "\n Functional Array Fusion Manuel M. T. Chakravarty University of New South Wales School of Computer Science \n&#38; Engineering Sydney, Australia chak@cse.unsw.edu.au ABSTRACT Thispaperintroduesanewapproahtooptimisingarray \nalgorithmsinfuntionallanguages.Wearespeifallyaim\u00adingatane\u00c6ientimplementationofirregulararrayalgo\u00adrithmsthatarehardtoimplementinonventionalarray \nlanguagessuhasFortran.Weoptimisethestoragelay\u00adoutofarraysontainingomplexdatastruturesandredue therunningtimeoffuntionsoperatingonthesearraysby \nmeansofequationalprogramtransformations.Inparti\u00adular,thispaperdisussesanovelformofombinatorloop fusion,whihbyremovingintermediatestruturesoptimises \ntheuseofthememoryhierarhy. WeidentifyaombinatornamedloopPthatprovidesa generalshemeforiteratingoveranarrayandthatinon\u00adjuntionwithanarrayonstrutorrepliatePissu\u00c6ient \ntoexpressawiderangeofarrayalgorithms.Onthisba\u00adsis,wedefneequationaltransformationrulesthatombine traversalsofloopPandrepliatePaswellassequenesof \nappliationsofloopPintoasingleloopPtraversal. Ourapproahnaturallygeneralisestoaparallelimple\u00admentationandinludesfailitiesforoptimisingloadbalan\u00adingandommuniation.Aprototypeimplementationbased \nontherewriterulepragmaoftheGlasgowHaskellCom\u00adpilerissignifantlyfasterthanstandardHaskellarraysand approahesthespeedofhandodedCforsimpleexamples. \n1. INTRODUCTION Funtionalprogramminglanguagestypiallyfousonlists ratherthanarraysduetothemoreelegantalgebraiprop\u00adertiesoftheformer.Notableexeptionsarespeialpurpose \nlanguageslikeSisal[9],SAC[32],andFISh[18],whihtar\u00adgetappliationsfromomputationalsieneandengineer\u00adingthatareusuallyimplementedinarray\u00adentredlanguages, \nsuhasFortran.Consequently,thedesignoftheselanguages tendstobeinfuenedbytheirimperativepredeessors;in \n*TheseondauthorhasbeenworkingattheUniversityof Tehnology,Sydney,whileperformingtheworkreportedin thispaper. \nPermission to make digital or hard copies of all or part of this work for personal or classroom use is \ngranted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page. To copy otherwise, to republish, \nto post on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. ICFP \n01, September 3-5, 2001, Florence, Italy. Copyright 2001 ACM 1-58113-415-0/01/0009 ...$5.00. * Gabriele \nKeller University of New South Wales School of Computer Science &#38; Engineering Sydney, Australia keller@cse.unsw.edu.au \nfat,SACisanabbreviationforSingleAssignmentCand FIShmakesheavyuseofimperativefeatures.Inlinewith thisapproah,Sisal,SAC,andFIShaswellastheirimple\u00admentationsalsofousonwhatthehigh\u00adperformaneom\u00adputingommunityallsregularalgorithms.Theseoperate \noverdatastruturesthatanonvenientlybestoredinret\u00adangulararraysandtheyiterateoverregularlyshapedindex spaes.Formanyappliationsthisisnotsu\u00c6ient. \nIrregularalgorithmsthatoperateonsparsedatastru\u00adtures(suhassparsematries)orarraysoftrees(suhas adaptiveorhierarhialnumerialgorithms)requireriher \ndatastruturesandindexspaes.Sophistiateddatastru\u00adturesareertainlyakeystrengthofmodernfuntionallan\u00adguages;so,itstandstoreasonthatifwewanttomakean \nimpatonarrayprogrammingwithfuntionallanguages, weshouldtrytobeatimperativelanguagesinappliations whereirregularalgorithmsareentral.Havingrealisedthis, \nitisstartlingthatmostworkonarraysinfuntionallan\u00adguagesappearstohavefousedonregularode[2,12,14, 23].Maybethisisbeauseofthetraditionalfousonreg\u00adularproblemsinarraylanguages. \nAnotherreasonisprobablythatirregularalgorithmsare, independentofthelanguage,muhhardertoimplementef\u00adfiently,espeiallyonparallelarhitetures.However,Blel\u00adloh&#38;Sabot[8]observedthateveryirregularalgorithm \nanbetransformedintoasemi-regularonethatoperates onafattenedrepresentationoftheoriginalnestedstru\u00adturesandusesexpliitstruturalinformationtorepresent \ntheirregularityoftheoriginaldata.Wehavepreviously shownhowthistehnique,knownunderthenamefatten\u00adingtransformation,anbegeneralisedtoapplytotyped, \ngeneral\u00adpurposefuntionallanguageslikeHaskellandStan\u00addardML[11]. However,fatteningisonlyhalfthestory.Flattenedarray \nalgorithmsareombinator\u00adbasedandgeneratemanyinter\u00admediatestrutures.Infat,theyareratherfarawayfrom whatpreviousworkidentifedasbeinge\u00c6ientformulations \nofarrayalgorithmsingeneral\u00adpurposefuntionallanguages: Theyshouldbebasedonunboxedandupdatablearrays[16, \n33].Anunboxedarraystoresthebinaryrepresentationofan element(e.g.,anintegernumber)diretly,whereasaboxed \narraywouldstoreapointertoaheap\u00adalloatedellon\u00adtainingtheintegervalue.Unboxedarraysnotonlysaveon memory,butallowaompilertobetterpreditthemem\u00adorylayout,whihanleadtolargeperformaneimprove\u00admentsduetobetteraheutilisation.Updatable,orsingle\u00adthreadedarraysavoidsuperfuousopying.Therearealso \napproahesthataimatsimilare\u00c6ienyusingpersistent arrays[23],buttheyoftendonotsupportunboxedvalues well. \nSerrarens[33]learlydemonstratestheperformanedif\u00adferenebetweenastraight\u00adforwardimplementationofanar\u00adrayalgorithmusinglazyarraysandanoptimisedversion \nbasedonunboxedandupdatablearrays.Heperformsthe transformationofthestraight\u00adforwardintotheoptimised implementationmanually.Thissurelyisnotwhatwewant! \nSo,thegoaloftheresearhpresentedhereissimplystated: Givenapurelyfuntional,ombinator\u00adbasedimplementa\u00adtionofanarrayalgorithm,automatiallyprodueanef\u00adfientimplementationthat(1)avoidsintermediatestru\u00adtures,(2)usesunboxedarrays,and(3)isbasedonde\u00adstrutiveupdates.Weahievethisbyanovelformofloop \nfusion-deforestation[37]ofarraysifyoulike-inombina\u00adtionwithstandardoptimisationslikeinliningandspeiali\u00adsationoperatingonoverloadedunboxedarrays.Whilewe \narespeifallyinterestedinarrayodegeneratedbythe fatteningtransformationandpresentanimplementationof ourapproahinHaskell,thetehniquespresentedinthispa\u00adperareneitherrestritedtofattening\u00adgeneratedodenorto \nHaskell,butaregenerallyappliable.Infat,reentworkin theontextofStandardML[4]isexploringanarraymodel thatisverysimilartotheonethatwearedisussingandwe \nexpetthatourimplementationtehniqueisusefulinthe StandardMLsenario,too.Insummary,theontributions ofthispaperarethefollowing: \n Twoarrayombinators(anarrayonstrutoranda loopabstration)thataresu\u00c6ienttoexpressawide rangeofarrayomputations(Setion4) \n Anovelformofloopfusionbasedonequationalrewrite rulesthatamalgamateonseutiveloopsoverarrays (Setion4) \n Fusionoverbothargumentsofanarrayvariantof zip-deforestationtehniquesforlistsoftenstumble overthisase(Setion5.1) \n Amethodforapplyingarrayfusionarossfuntion boundariesofreursivefuntions(Setion5.2)  Figuresoftherunningtimes(Setion6)forafrst \nimplementation(Setion3&#38;4.4)  Theimplementationisbasedonanumberofadvanedfea\u00adturesoftheGlasgowHaskellCompiler[35],namelyun\u00adboxedtypes[29],mutablearrays[26],andoptimisingrewrite \nrules[25].However,thesefeaturesmerelyafettheinter\u00adnalsofourarraylibrary-anordinaryuserisstillprovided \nwithalean,purelyfuntionalinterfae.Infat,aswe shalldisussinSetion2,wedonotevenexpettheappli\u00adationprogrammertodiretlyuseourarrayombinators; \ninstead,weprovideaonvenientinterfaebasedonarray omprehensionsandwell\u00adknownombinatorslikethosefor listsinHaskell'sprelude.Theruntimefguresindiatethat \nforsomealgorithmsbasedonsparseandirregularstrutures, ourapproahtoarraysismoree\u00c6ientthanbothHaskell's \nstandardarraysaswellastheorrespondinglistalgorithms. Moreover,wegetverylosetothespeedofhand\u00adodedC forsimpleexamples. \nLoopfusionisnotanewtehnique.Ithasbeenexten\u00adsivelystudied(see,e.g.,[1,21,22,31,39])anditisused invaryingstagesofsophistiationinprobablyallhigh\u00adper\u00adformaneompilers.Itisoftenusedtoinreaseloalityof \nsyntatisupport forparallelarrays nested-fat; removesarray omprehensions Haskell&#38;[::] Typehek&#38;Desugarer&#38;Flattening \n Core&#38;PArrays Simplifer CodeGeneration additionalrules forarrayfusion asinputto CCodeIAssembler \ntheSimplifer Figure1:GHCwithextraarraysupport referene,toavoidommuniation,andtoinreasethegran\u00adularityofparallelism.Theunusualfeaturesofourapproah \naretheexpliithandlingofsegmentedloops,whihareru\u00adialforirregularodes,andtheuseofequationalrewrite rulestoexpressloopfusion.Thelattersimplifestheimple\u00admentationandismoreaessibletoformalanalysis. \nTheremainderofthepaperisorganisedasfollows:Se\u00adtion2providesanoverviewofthevarioustransformations thatweapply.Setion3outlinestheinterfaeandimple\u00admentationofthearraylibrary.Setion4presentsthetwo \narrayombinatorsoverwhihthefusionrulesaredefned andintroduestherulesneededtofusefuntionsonsum\u00adingasinglearray.Setion5oversthemoreelaboratease \noffuntionsonsumingmultiplearraysandoffusionaross funtionboundaries.Setion6presentsbenhmarks.Se\u00adtion7disussesrelatedworkanddrawsonlusions. \n 2. THE BIG PICTURE Letusstartwithanoutlineofaompilationframework forfuntionalarrays,whihalsolarifestherolethatloop \nfusionhasinthisframework.Figure1displaysthemain phasesoftheGlasgowHaskellCompiler(GHC)[35],whih weenrihwithsupportforarrays(setinbolditali).The \nfrontendreadsHaskellmodules,whihinludesyntatisu\u00adgarforarrays(inthefgure,indiatedbythearraynotation [:.:]).Aftertypeheking,thedesugareronvertstheinput \nintoCore,whihisGHC'sentralintermediaterepresenta\u00adtion.Weextendthedesugarerwithafatteningtransfor\u00admationthatmapsnestedarrayoperationstoarrayombi\u00adnatorsthatoperateonlyonfatarraysontainingelements \nofbasitype;theseombinatorsareprovidedbyourarray libraryPArrays.Wehavepreviouslypresentedaformalisa\u00adtionofthisfatteningtransformation[11].GHC'ssimplifer \noptimisestheCorelanguageusingawiderangeofsoure\u00adto\u00adsouretransformations[28,30,27].Weextendthesetrans\u00adformationsbyequationalloopfusionusingGHC'ssupport \nforrewriterulesthatarespeifedaspragmasinthesoure language[25].Theodegenerationitselfisnotafeted. 2.1 \nParallel Arrays: An Example Asanexample,onsiderafuntionthatmultipliesasparse matrixbyavetor,wherethesparsematrixisstoredinthe \nso\u00adalledompressedsparserowformat[13].Thisformat representsasparserowbyanarrayofolumn\u00adindexIvalue pairs,whereeahpairrepresentsanon\u00adzeroelementofthe \nsparsematrix.Anarrayofthesesparserowsimplementsa sparsematrix.Toimprovereadability,wewilltakethefree\u00addomtousethespeialsyntax[:.:]forthearrayonstrutor \ninthefollowingHaskellode.Pleasenotethat,although weareusingHaskellhere,thepresentedoneptsapplyto othertypedfuntionallanguagessuhasStandardML,too. \ntypeSparseRow=[:(Int,Float):]\u00ad\u00adindex,value typeSparseMatrix=[:SparseRow:] Nowonsiderthemultipliationofasparsematrixwitha \ndensevetor,resultinginanotherdensevetor.Usingalittle morespeialsyntax,namelyarrayomprehensions,lwean \nimplementsparse\u00admatrixIvetormultipliationasfollows: smvm::SparseMatrix-[:Float:]-[:Float:] smvmsmve= \n[:sumP[:x*(!:ol)I(ol,x).o :] Irow.sm:] J produtsofonerow ThefuntionsumPaddsuptheelementsofanarrayand \ntheinfxoperator(!:)representsindexing. Thissmallalgorithmalreadyshowswhyonventionallists areoftensuboptimalforalgorithmsfromsientifomput\u00ading.Thesealgorithmstendtouseindexingininnerloops; \nanoperationthatisofonstantostforarraysandofost proportionaltothelengthoftheindexedlistforlists.In smvm,theindexingintheinnerarrayomprehensionisfre\u00adquentlyexeutedand,astheindexvaluesdependonthe \ninputdata,thereislittlesopeforstatioptimisation. Despitethebiastowardsarrays,theproesseddatastru\u00adtureaswellastheomputationalbehaviourofsmvmare \nhighlyirregular,asthenumberofnon\u00adzeroelementsindif\u00adferentrowsmayvarysignifantly.Consequently,theprin\u00adipaldatastrutureofonventionalarraylanguageslike \nFortran-namelyregulararrays,whereallsub\u00adstrutures mustbeofthesamesize-isalsonotappropriate.Over\u00adall,nestedarraysthatallowsub\u00adstruturesofvaryingsize \nseemtobethemostadequatestruture.Otherimportant algorithms,suhas,adaptiveiterativealgorithms,havesim\u00adilarproperties. \nBlelloh[6]hasdemonstratedthatirregular,nestedarrays arewellsuitedforexpressingtheparallelisminalgorithms \nlikesmvmandothers.Infat,theimplementationteh\u00adniquepresentedinthispaperwasoriginallyaimedatopti\u00admisingnodeprogramsinparallelimplementationsofnested \narraylanguages.Consequently,ourapproahissuitablefor arangeofsequentialandparallelarhitetures[10]. Thereasonforallingthesearraysparallelarraysis,how\u00adever,morefundamental.Wheneveranyelementofaparal\u00adlelarrayisdemanded,allelementsareevaluated.2Inother \nwords,weassumeaparallelevaluationsemantisforarrays. Wedistinguishombinatorsoverparallelarraysfromthose \noverlistsbythesu\u00c6x\"P\",asinsumP. l Thereisnooneptualreasonforthespeialsyntax.Itis justamatterofpresentation. \n2 InalazylanguagelikeHaskell,thismeansthattheyare evaluatedtoWHNF. 2.2 Changing the Data Representation \nThefrstprogramtransformationthatweapplytoadef\u00adinitionlikesmvmisalledfatteninganditsoriginalformu\u00adlationisduetoBlelloh&#38;Sabot[8].Itonvertsdatastru\u00adturesontainingarraysofnon\u00adbasitypeintostrutureson\u00adtainingarraysofbasitypeonlyandrewritesnestedarray \niterationsintoasingle,fatiteration.Thebeneftistwofold: (1)Traversalsoverarraysofbasitypesusetheproessor \nahemoree\u00c6iently,astheelementsanbestoredunboxed inaontiguousmemoryregion;and(2)itimprovesloadbal\u00adaninganddatadistributioninaparallelimplementation. \nWereentlyextendedfatteningtobesuitablefortyped funtionallanguagessuhasHaskellandStandardML[11]. Inthefollowing,wesummarisethemainpropertiesofthe \noderesultingfromfattening,asfattenedodeistheinput tothetransformationsdisussedinthispaper. Todistinguishthetypeandfuntionnamesoftheorig\u00adinalfromthefattenedvariants,weunderlinethelatter. \nCentraltounderstandingfatteningistounderstandhow itafetstypes.Mostimportantly,fatteneddatastru\u00adturesonlyontainarraysofbasitype(Int,Float,and \nsoon);todistinguishthemfromthenestedarraysofthe sourelanguage,wedenotethemwiththetypeonstru\u00adtorPArray.Flatteningrepresentsarraysofarrays-e.g., \n[:[:Float:]:]-bytwoarrays:adatavetorontainingallthe elementsandasegmentdesriptorstoringthestruture,i.e., \nthelengthsofallsub\u00adarrays.Forexample,[:[:Float:]:]be\u00adomes(Segd,PArrayFloat)where typeSegd=PArrayInt\u00ad\u00adsegmentdesriptor \nSo,thevalue[:[:1,2,4:],[::],[:3,5:]:]isnowrepresentedby thedatavetor[:1,2,4,3,5:]andthesegmentdesriptor \n[:3,0,2:].Moreover,arraysofpairsarerepresentedbya pairofarrays.Consideringthesetworules,thetypefor SparseMatrixshouldbeomelear. \ntypeSparseRow=(PArrayInt,PArrayFloat) typeSparseMatrix=(Segd,SparseRow) Havingpresentedthetypes,letushavealookattheode \ntransformation.Thefattenedodesmvmmakesuseofthe threenewfuntionszipWithP,bakpermuteP,andsumSP operatingonfatarrays. \nsmvm::SparseMatrix-PArrayFloat-PArrayFloat smvm(segd,(ind,val))ve= sumSPsegd(mull(bakpermutePveind)val) \nwhere mull=zipWithP(*) Aapital\"S\"inafuntionnameindiatesasegmentedfun\u00adtion,i.e.,afuntionthattakesthesegmentationofanar\u00adrayintoaount.Forexample,sumSPsegdarrindividually \nsumsupthesub\u00adarraysofarrasdeterminedbythesegment desriptorsegd,resultinginanarrayofsums.Segmented funtionsareknowntobeusefulforthehigh\u00adperformane \nimplementationofarrayalgorithms[5,7].Moreover,the funtionbakpermutePisapermutationoperationwherethe permutationvetorgivesthesoureratherthanthedesti\u00adnationindexofeahvalue.Thefattenedsmvmorrelates \ntotheoriginalsmvmasfollows:ThebakpermutePper\u00adformsalltheindexingoperationsve!:oloftheoriginal odeinoneolletiveoperation.Then,mullomputesall \nprodutsbetweenvetorandmatrixelements;andfnally, sumSPsumsupallprodutsthatbelongtothesamerow ofthematrixasindiatedbythesegmentdesriptorsegd. \nFlattenedarrayodeusesawholerangeofarrayombina\u00adtors,suhassumSPandbakpermuteP,themostommonof whiharedefnedinAppendixA.Thee\u00c6ientimplemen\u00adtationofprogramsonstrutedfromtheseombinatorsis \ntheaimofthepresentpaper-whethertheseprogramswere generatedbyfatteningorarehandodedisseondary. 2.3 Fusion \nof Array Operations Fromnowon,letusassumethat,asinsmvm,allar\u00adrayomputationsarebasedontheombinatorsfromAp\u00adpendixAandoperateonfatarraysonly-withoneexep\u00adtion.ForreasonsexplainedinSetion5.1,weanextend \nthesopeoffusionbyalsopermittingarraysofpairs. Insmvm,wehavethreearrayombinatorsappliedinse\u00adquene,allofwhoseindexspaerangesoverthenon\u00adzero \nelementsofthesparsematrix.Consideringaheperfor\u00admane,itisine\u00c6ienttoimplementtheombinatorsinthree distintiterationsunlessalldataftsintotheahe.Thisis \nwhereloopfusionomesintoplay.Itamalgamatesallthree ombinatorsofsmvmintoone,whihanbeimplemented byasingleiterationoverthenon\u00adzeroelementsofthesparse \nmatrix.Thisleadsustothequestionofwhihombinator anexpresstheresultoffusion,insmvmandingeneral. Itturnsoutthat,asintheaseoflistfusionbasedon \nfoldr/build[15],weneedtwoelementaryarrayombina\u00adtorsthatanexpressalltheothersaswellasallpossible outomesoffusion.Thefrstofthesetwoombinators,the \narrayonstrutorrepliatePnv,simplyreatesanarrayof lengthnwithallelementshavingthevaluev.Theseond, thearrayonsumerloopP,ismoreinvolved,asitanexpress \nvariousformsofmapping,redution,san,andpermutation operationsaswellasombinationsofthem.Itstypeis . loopP \n:: (e -a -(Maybe e ,a)) \u00ad\u00adm: mutator -(a -a) \u00ad\u00adh: segment -(a -Bool) \u00ad\u00adp: ollet -a \u00ad\u00adaumulator -SPArraye \n-(SPArraye . , PArraya,a) whereSPArrayisaPArraypairedwithitssegmentdesrip\u00adtor.AnexpressionoftheformloopPmhpapatraverses \nthesegmentedinputarraypaonefromlefttoright.The mostinterestingargumentisthemutatorm,whihanbe regardedasaombinationofthefuntionsthatarepassed \ntothelistombinatorsmap,flter,andfoldl.Itisappliedto eaharrayelemente,whihiteithermapstoJuste .;or,if \n3 itsflteringomponentrequiresso,toNothing.Inaddition, themutatoranuseandupdatetheaumulatora,whih enablestheimplementationoffoldandsanfuntionality. \nTheremainingtwoarguments,handp,determinethe behaviouroftheloopatsegmentboundaries.Thefuntion hupdatestheaumulatorateahsegmentboundary;for \nexample,intheaseofasegmentedsum,itwouldresetthe aumulator.Finally,pisusedattheendofeahsegment todeterminewhethertheurrentaumulatorvalueisin\u00adludedintotheaumulatorarrayPArrayaoftheresult. \nOverall,theloopproduesthreeresults:(1)anarrayon\u00adtainingalle . returnedbythemutatorm,(2)anarrayof aumulatorvaluessampledindependeneonp,and(3) \nInHaskell,MaybeaisavaluethatiseitherNothingor Justv,wherevmustbeoftypea. thefnalaumulatorvalue.Setion4.1defnesloopPmore \npreisely. GivenloopP,weannowpresentthefullyfusedvari\u00adantofsmvm,whihistheresultofapplyingthetehnique presentedinthispapertosmvm(wherezipPisthearray \nversionofHaskell'slistfuntionzip): smvm::SparseMatrix-PArrayFloat-PArrayFloat smvm(segd,(ind,val))ve=projAs \n(loopPombine(onst0)(onstTrue)0segdIndlal) where segdIndlal=(segd,(zipPindval)) ombine(i,v)a=(Nothing, \n(ve!:i)*v+a) Theodeessentiallytraversesthesegmentedarrayofin\u00addexIvaluepairssegdIndlalandineahiterationextrats \nthevetorelementve!:iorrespondingtotheolumnin\u00addexofamatrixvaluev.Theprodutofthetwovaluesis addedtotherunningsummaintainedintheaumulator. \nTherunningsumisstoredintheaumulatorarray(thisis whatonstTruespeifes)andresettozeroateahsegment boundary(thisiswhatonst0speifes). \nHowwegetfromsmvmtothefullyfusedodeofsmvm isdesribedintherestofthispaper.Figure4,inSetion6, showstheimprovedrunningtimeofthefusedodeover \nsmvmaswellasoverthesamealgorithmimplementedwith standardHaskellarraysorwithlists.  3. BASIC ARRAYS Beforedivingintothedetailsofloopfusion,letuslook \nmoreloselyatthearraytype.PArrayeisthetypeofarrays ontainingelementsofbasitypee,whereeisguaranteed tobestoredunboxed(f.[29]regardingunboxedvaluesin \nHaskell).Therestritiononelementtypesisenforedbya typelassPAE(meaning\"ParallelArrayElement\"): lassPAEewhere \n(!:)::PArraye-Int-e  ThereareinstanesofPAEforallbasiHaskelltypes,suh asInt,Float,andsoon.Theuseofoverloadinghasthead\u00advantagethatweanstoreelementsunboxedinthesearrays, \nwhihinturnimprovesperformanesignifantly(f.[33] forabenhmark).Infat,thisoverloading\u00adbasedapproah tounboxedarrayswasinspiredbytheHaskelllibrariesof \nGHC[36],whihinturnfollowtheCleanarraylibrary[16]. Theabovelassdefnitionisnotomplete.Infat,most ofthelassmethodsareimpureandoperateonamutable \nvariantofPArray.Thesestate\u00adbased,monadifuntions inludeoperationsforalloatinguninitialisedarrays,and readingandwritingtothesearrays.Theimpurefuntions \narenotvisibletoauserofthelibraryandasthedetails arenotrelevanttothispaper,wesparethem.Moreabout destrutivearrayfuntionsinHaskellanbefoundin[26]. \nTheimpuremethodsofPAEareusedtoimplementthe purelyfuntional,basiarrayombinatorsrepliatePand loopPonwhiharrayfusionisbased.Finally,theuser\u00advisibleinterfaeofthePArrayslibraryisdefnedinterms \nofthebasiombinatorsrepliatePandloopP.Itinludes arrayversionsoftheommonlistproessingfuntions,for example,mapP,zipWithP,flterP,enumFromToP,foldP4, \n4 ThefuntionfoldPleavestheredutionorderunspeifed, sumPaswellassegmentedversionswherethismakessense. Moreover,array\u00adspeiffuntions,suhaspermutations(e.g., \nbakpermuteP),areinluded. Asmentionedearlier,weassumeaparallelevaluationse\u00admantisforarrays;i.e.,wheneverasingleelementofanarray \nisdemanded,thewholearrayisevaluated.Suharraysare alsoalledstrit.Theyarelessfexiblethanlazyarrays[2], \nbutneessaryaswewouldliketoguaranteealearparallel interpretationofourarrayombinators[11]. Furthermore,weusethefollowingtwoabbreviationsfor \nsegmentdesriptorsandsegmentedarrays: typeSegd=PArrayInt typeSPArraye=(Segd,PArraye) Asanexampleofasimpleombinator\u00adbasedarraypro\u00adgram,onsiderthefollowingdefnition: \nsumSq::Int-Int sumSqn=sumP(mapPsquare(enumFromToP1n)) where squarex=x*x First,sumSqgeneratesanarrayontainingthevalues1up \ntonoverwhih,then,thesalarfuntionsquareismapped. Finally,theresultofapplyingmapPissummedup.The twointermediatearrays(produedbyenumFromToPand \nmapP,respetively)anbothbeeliminatedbyfusion. 4. FUSION: THE SIMPLE CASE Setion2.3alreadymentionedthatpreviousworkindi\u00adatesthatsuessfulfusiontehniquesarebasedonasmall \nnumberofombinatorsoverwhihequationalfusionrules aredefnedandwhiharesu\u00c6ientlyexpressivetodenoteall omputationsthatwewanttoonsiderforfusion[15,24,34]. \nThemostsuessfulapproah-intermsofatualusage-to equationalfusion,namelyfoldr/build[15],isrestritedto handlingstruturetraversalsthatareexpressedintermsof \naombinatorlibrary-suhas,e.g.,theHaskellPrelude.We imposethesamerestrition.However,asfuntionalarrays aregenerallyproessedbyombinatorsimplementingbulk \noperationsandnotbyreursivetraversals,thisrestritionis oflittlepratialonsequeneintheaseofarrays. Intheremainderofthissetion,wewillfrstdefnethe \nmeaningoftheloopPombinatorinmoredetail,andthen, explorethebasifusionrules.Wedeferthemoreompli\u00adatedasestothefollowingsetion. \n4.1 The loopPCombinator Now,wewillfnallyprovideapreisedefnitionofthese\u00admantisoftheombinatorloopP,whosetypeandintuition \nwedisussedinSetion2.3.Forthepurposeofkeeping thedefnitiononise,werepresentarraysaslistsandseg\u00admentedarraysaslistoflists.Inotherwords,wedefnethe \ndenotationalsemantisofloopP,butignoretheoperational propertiesofarraysforthemoment. typePArraya=[a]\u00ad\u00adJustforthepurpose... \ntypeSPArraya=[[a]]\u00ad\u00ad...ofthisdefnition loopPmhpab[]=([],[],ab) . ... loopPmhpab(seg:segs)=(seg :segs \n,as,a) andthus,requiresanassoiativeredutionfuntion-thisis usefulfortheparallelimplementation. where (seg \n. ,a)=looplm(hab)seg (segs . ,as,a .)=loopPmhpasegs as . =ifpathena:aselseas loopl::(e-a-(Maybee . ,a)) \n-a-PArraye-(PArraye . ,a) .. looplmab[]=([],ab) ... .. looplmab(e:es)=(es,a) where .. (me,a)=meab .... \n(es,a)=looplmaes es .. =asemeof Nothing-es . . .. Juste-e:es Theauxiliaryfuntionlooplhandlesthetraversalofasingle \nsegmentofthesegmentedarray.Foreahsegment,itre\u00adturnstheorrespondingsegmentoftheresultarray(whih willbeshorterifmeverreturnsNothing)aswellasthe \nvalueoftheaumulatorafterthewholesegmenthasbeen proessed.ThefuntionloopPinvokeslooploneforeah segmentandombinestheresultingsegmentsintothefrst \nomponentofitsresult.Moreover,itapplieshtothea\u00adumulatorvaluebeforeproessingasegmentandusespto determinetheaumulatorvaluesthatareolletedintothe \nseondomponentoftheoverallresult. Theargumentshandpareonlyneededtoimplementar\u00adraytraversalswhihtakethesegmentationstrutureofan \narrayintoaount.Assomefuntions,mostnotablymapP, areentirelyoblivioustoanarray'ssegmentation,wemake theirdefnitionsmorereadablebyintroduingtheabbrevi\u00adationloopA: \nloopAmapa=loopPmid(onstFalse)apa Infat,wewilldefnesomefusionrulesintermsofloopA insteadofloopPwherethisinreasesreadabilitywithout \nomittingimportantinformation. Forexample,weannowdefnemapPandsumPasfol\u00adlows: mapPf=letme =(Just(fe),())inloopAm() \nsumP=letmea=(Nothing,e+a)inloopAa0 GiventhedefnitionofloopP,itisnotdi\u00c6ulttoseethat itanonlyproduearraysofasizesmallerorequaltothat \nofitsinputarray,whihraisesthequestionastohowwe generatenewarrays;forexample,toimplementaombi\u00adnator,suhasenumFromToP,whihweusedinsumSqin \nSetion3. 4.2 Array Generation with repliateP Fortunately,itturnsoutthatasimpleombinator,whih orrespondstothelistfuntionrepliateinHaskell,isall \nthatisneededtogeneratearrays: repliateP::PAEe=Int-e-PArraye Itgeneratesarraysofarbitrarysize,whereallelementsare \ninitialisedtothesamevalue. WiththehelpofrepliateP,weanindeedimplementthe funtionenumFromToPmentionedintheprevioussetion: \nenumFromToP::(PAEe,Nume) =e-e-PArraye enumFromToPfromto=projMap$ loopAmutfrom(repliatePlen1) where \nlen=(to-from+1)'max'0 mutea=(Justa,a+e) whereprojMap(pa, , )=paprojetsthefrstomponent ofresultofaloop.Unfortunately,thisisaratherwasteful \ndefnition.First,repliatePonstrutsanarrayonsisting of1sonly;andthen,theatualresultisomputedfromthe arrayof1sbyloopA.Obviously,itwouldbemoree\u00c6ientto \ngeneratetheresultingarrayinasingleiteration,butneither loopPnorrepliatePareabletodothejobontheirown. \nAninterestingpropertyofparallelarraysofunittype() anhelpusoutofthisdilemma:Theonlyinformational ontentofanarrayoftypePArray()isitslength.This \npropertydependsontheparallelevaluationsemantis,asit guaranteesthatthewholearrayisundefnedifonlyasingle \nelementisundefned(whihisnottheaseforlazyarrays). Asaonsequene,thereisnoneedtoeveronstrutanarray oftypePArray();simplystoringitslengthissu\u00c6ient.We \nanimplementthisspeialrepresentationeasilyusingthe overloadingprovidedbythetypelassPAE: instanePAE()where \n !:i=() Asaresult,theevaluationofrepliatePn()isveryheap. So,itistheidealandidateforprovidinganarrayoverwhih \nloopPaniteratetoprodueanewarray.Thisindeedleads ustoourfrstfusionrule:5 (loopIrepliatefusion)Vmane loopAma(repliatePne)- \nloopA(A -me)a(repliaten()) ItstatesthatanyourreneofrepliatePfollowedbyloopA shouldbereplaedbygenerationofaunitarrayfollowed \nbyamodifedalltoloopA,wherethemutatormontains theonstanteinline.Duetotheoptimisedrepresentation ofunitarrays,thisruleremovestheexpliitonstrution \noftheintermediatearray.Itshouldbeobvioushowthe rule(loopIrepliatefusion)optimisestheimplementationof \nenumFromToPstatedearlier. Generally,wedenoterewriterulesasfollows: (rulename) exp2 Vvl v .expl\u00ad wherethev \n. arethefreevariablesintherules.Theserules shouldbereadasreplaeeveryourreneofexplbyexp2. 4.3 Fusion \nRules for Loops Moresophistiatedisthefusionoftwoonseutiveloops: (loopIloopfusion)Vmlalm2a2pa loopAm2(projMap(loopAalpa)) \n a2ml\u00ad 5 ThesameruleforloopPdoesnotaddanythingnew,sowe leaveitwiththesimplerloopA. let m3e(al,a2)= asemlealof \n(Nothing,a. -(Nothing,(a. a2)) l)l, (Juste . ,a. \u00ad l) asem2e . a2of (Nothing,a. -(a. a. 2)(Nothing,l,2)) \n(Juste2,a. -(Just,(a. a. 2)e2l,2)) in drop1stA(loopAm3(al,a2)pa) Themostinterestingaspetisthewayinwhihthemu\u00adtatorsmlandm2ofthetwoloopsareombinedintoone, \nalledm3.Thenewmutatorfrstappliesmland,onlyif thatreturnsaresult,withJuste . ,thatwouldhavebeen storedintheintermediatearray,itallsm2.Moreover,the \naumulatorsofthetwoloopsareombinedintoasingle aumulatorofpairtype.Asaonsequene,theseondand thirdomponentoftheresultofthefusedloophavetobe \nadjustedtoobtainthesameresultthatisproduedbythe loopsbeforefusion.Thisadjustmentisperformedby drop1stA::(PAEel,PAEe2)= \n(x,PArray(el,e2),(el,e2))-(x,PArraye2,e2) drop1stA(pa,as,(al,a2))=(pa,mapPsndas,a2) Toaterfortheasewheremorethantwoonseutive \nloopsaretobefused,wehavetoensurethatanydrop1stA followedbyaprojMapiseliminated.Weahievethisbya simplerewriterule: \n(projMapIdrop1stAelimination)Vv projMap(drop1stAv)- projMapv  4.4 Rewrite Rules in GHC GHCsupportsthespeifationofequationalrewriterules \nthatareusedbytheSimplifer(seeFigure1)toapplydomain\u00adspeifoptimisations[25].Theserulesareinludedasprag\u00admasintosourefles.Inourase,theyarepartofthedef\u00adnitionofthePArrayslibrary. \nForexample,theeliminationrulefordrop1stAstated attheendoftheprevioussubsetionisdenotedas {-#RULES \"projMapIdrop1stA\" \nforallvprojMap(drop1stAv)=projMapv #-} Thisrulewillmaketheoptimiserspotourrenesofthe patternprojMap(drop1stAv),wherevanbeanarbitrary \nexpression,andreplaeitbytheright\u00adhandsideoftherule. TherewritemehanismoferedbyGHCfailitatestheim\u00adplementationofarraysupportonsiderably-itwouldnot \nhavebeenpossibletoprovideaprototypeimplementation inthegiventimeframeotherwise.However,theimplemen\u00adtationofsuhrulesinpratiseanbehallenging,duetothe \ninterationwithotheroptimisationssuhasinlining.Onthe otherhand,theoptimisationsprovidedbytheSimpliferby \ndefaultareruialtosimplifyande\u00c6ientlyimplementthe loopbodiesgeneratedbyourlibrary. 4.5 How it all works \ntogether LetusnowgobaktothesumSqexample(fromSetion3) toseehowthediferenttehniquesworktogether.Westart \nfromthedefnitionofsumSqafterunfoldingthedefnitions formapPandsumPaswellasthatforenumFromToPafter appliationof(loopIrepliatefusion): \nsumSqn= projA$loopAfl0$ projMap$loopAf2()$ projMap$loopAf3npa where f flea=(Nothing,e+a)\u00ad\u00adsumP f2e =(Just(squaree),())\u00ad\u00admapP \n3 a=(Justa,a+1)\u00ad\u00adenumFromToP size=(m-n+1)'max'0 pa=repliatePsize() Aspaandsizedonothange,weomittheminthenextstep \nofthetransformation.Therule(loopIloopfusion)isim\u00admediatelyappliable,andfusestheloopsofenumFromToP andmapPintoasingleloop.Forf2aswellasf3,thefrst \nomponentoftheresultpairisaJustvalue,independentof theatualvaluesoftheirarguments.Therefore,thease\u00addistintionintroduedbythefusionruleanbeeliminated \nbyGHC'sSimplifer.Moreover,(projMapIdrop1stAelimi\u00adnation)fresone.Overall,wegetthedefnition sumSqn= projA$loopAfl0$ \nprojMap$loopAf4(n,())pa where f4 (a, )=(Just(squarea),(a+1)) flea=(Nothing,e+a) Thenextappliationof(loopIloopfusion),then,fusesthe \nremainingtwoloops,resultinginadefnitionwithasingle loop,whihdoesnotreateanyarrayatall: sumSqn= projA$loopAf5((n,()),0) \n where f5 ((al, ),a2)=(Nothing, ((al+1,()),squareal+a2)) size=(m-n+1)'max'0 pa=repliatePsize()  5. ADVANCED \nFUSION Inthepresentationoffusion,sofar,wehaveignored twoadditionalompliations.Firstly,somefuntions,like \nzipWithP,onsumetwoormorearraysinlokstep.We mightwanttofusesuhfuntionswiththeproduersofboth arrays.Thisistriky,andimportantlist\u00adbasedfusionteh\u00adniquesarenotabletofusetwoonsumers.Seondly,fora \nfusionruletofre,thefusedombinatorshavetobeadjaent intheprogramode,whihweusuallyahievebyombining inliningwithsimplifation.Thereare,however,situations, \nsuhasthefuntionboundariesofreursivefuntions,where inliningisnotappliable.Intherestofthissetion,weshall \nillustrateoursolutionstothesetwoproblems. 5.1 Traversing Two Arrays Simultaneously Thefattenedversionofthesparse\u00admatrixvetormultipli\u00adationodesmvmfromSetion2.2ontainedtheequation \nmull=zipWithP(*) whihimplementsvetorisedmultipliation-i.e.,multipli\u00adationliftedpointwise.Insmvm,mullwasappliedto \ntheresultofabakpermutePandoneoftheargumentsto smvm.InAppendixA,bakpermutePisdefnedinterms ofloopP.So,wewouldobviouslyliketofusezipWithP \nandbakpermuteP.Furthermore,insomeappliationsof smvm-afterthedefnitionofsmvmhasbeeninlined-the seondargumenttozipWithPmayalsobetheresultofan \nappliationofloopPorrepliateP.Inthisase,wewant tofusezipWithPwithbothofitsarguments.Otherwise,if onlyoneoftheargumentsisinthe\"right\"form(i.e.,the \nresultofrepliatePorloopP),wewantfusethisargument intotheloop.Thelistfusionmethodfoldr/buildimple\u00admentedinGHCisnotabletoperformfusioninallthese \nases[15]-instead,fusionisonlypossibleforasingleargu\u00admentthathastobefxedwhenimplementingzip.Other approahes[34,24]laimtofusezipfully,butthedetails \narenotentirelylearandnoworkingsysteminludingthese tehniquesisavailable. Ourapproahtothisproblemonsistsoftwoomponents: \n(1)anunboxedrepresentationforarraysofpairsand(2)a setofspeialisedfusionrules. 5.1.1 Arrays of Pairs are \nPairs of Arrays Letusnowonsiderfuntionsthatonsumetwoormore arraysinlokstep.Aswithgenerators,weanreduethe \nproblemtoasinglefuntion,inthisasezipP.Forexample, weanimplementzipWithPbyzipPfollowedbyaloop: zipWithP::(PAEa,PAEb,PAE) \n=(a-b-) -PArraya-PArrayb-PArray zipWithPfpalpa2 =loopAapplyF()(zipPpalpa2) where applyF(el,e2) =(Just(fee2),()) \nl InSetion2.2,wementionedthatfatteningrepresentsan arrayofpairsasapairofarrays-aswitnessedinthetype SparseRow.ThisatuallymeansthatzipPdoesnothave \ntotraversetheargumentarraysatall,nordoesitproduea newarray.Instead,itproduesapairontainingreferenes tothetwoarrays.Havingonlyonefuntion,namelyzipP, \nwhihhandlestheloksteptraversalofmultiplearrays,sim\u00adplifestheorrespondingfusionrulessignifantly. Nevertheless,weneedtorepresentvaluesoftypePArray \n(el,e2)anddefnearrayoperationsonthem,whileretaining thepropertythatarraysstoreunboxedbasidataonly.Or \ninotherwords,howanweimplementaninstaneofPAE forpairs.Wedosobyperformingaruntimedispathonthe elementtypeofarrays.Infat,asallelementsofPArray \nmustbeinstanesofthetypelassPAE,itsu\u00c6estodefne aninstaneforpairsthatgoesasfollows: instane(PAEel,PAEe2)=PAE(el,e2)where \n(PAPairpalpa2)!:i=(pal!:i::el,pa2!:i::e2) HerePAPairisthepaironstrutorthatweusetorepresent arraysofpairs. \nItisinterestingtonotetherelationshipbetweenouruseof overloadingandHarper&#38;Morrisett's[17]intensionaltype \nanalysis.AsWeirih[38]hasalsoobserved,typelasses anbeusedtoimplementsomeformsofintensionaltype analysis.Inessene,themethoddispathviaditionaries \nthatimplementstypelassesisusedtorealiseHarper&#38; Morrisett'stypease.Thisrelationshipprovidesaroute \ntoimplementingourapproahinaompilerthatsupports typease,butnottypelasses. 5.1.2 Fusion Rules for zipP \nWenowhavetoonsidertwoasesforwhihthefusion rulesshouldfre:TheargumentarrayofzipPaneither bearesultofanappliationofrepliatePorloopP.Forthe \nformer,weandragthegenerationintothesueedingloop, therebyeliminatingzipPaltogether.Again,wespeifythe rulesforloopAonly,tokeepthepresentationlearer: \n(zipIrepliatefusion)Vmaneles2 loopAma(zipP(repliatePnel)es2)\u00adloopA(Ae-m(el,e))aes 2 Weomitthesymmetriruleforfusingtheseondargument. \nWehandlefusionofaloopPthatoursasanargumentto zipPbypropagatingtheloopPthroughzipP.Thesideon\u00additionisthatthemutatoroftheloopneverdropselements, \nwhihimpliesthatthelooppreservesthelengthofthear\u00ad f(el,e2)let(e)fe1in((ee2),) ray. We a n express thisonstraint \nby u sin g anauxiliary funtionrestritingtheloopfuntion: mapSFL:: (e-a-(e . ,a)) -(e-a-(Maybe e . ,a)) \nmapSFL(e,a) = (Juste,a) Now th e fu sion ru le is (zipIlooppropagation) V f a e sles2 zipP(loopA(mapSFLf)a \ne sl)es2 \u00ad loopA(mapSFLf.)a(zipPesles2) where . . . . . a=l,a=al,a Again,weomittheorrespondingrulefortheseondargu\u00adment.TheuseofmapSFLallowsustoexpressthesideon\u00additionwithoutleavingtheframeworkofappliativerewrite \nrules,whihiswhatGHCsupports.Havingtousethese speialfuntionsmayseemtoorestritive,butonsiderthat thisisnotvisibleattheinterfaeofthearraylibrary,whih \nonsistsofombinatorssuhasmapPandfoldP.Weuse mapSFLonlyinthelibrary\u00adinternalimplementationofthe ombinators. \n 5.2 Fusion over Function Boundaries Equationalfusionhasaseriousweakness:Forthefusion rulestofre,theombinatorshavetoappearadjaentlyin \ntheprogramode.GivenspeialisedfuntionssuhasmapP andfoldP,whiharedefnedintermsofloopP,thisisvir\u00adtuallynevertheaseinthesoureode.So,thewhole \ntehniquereliesonotheroptimisationtehniques-inpar\u00adtiular,inlining-toonverttheodesuhthatfusionrules anfre.However,therearesituations,whereinliningalone \ndoesnothelp.Considerthefollowing(slightlyartifial) funtiondefnition:6 foo::PArrayInt-Int fooxsInullPxs=0 \nIotherwise=let n=lengthPxs v=sumPxs in foo(pliat P(n-1)) Thefuntionreduesitsargumentarraytoasalarfrom \nwhihitproduesanotherarray,whihispassedtothenext reursion.Inotherwords,thearrayreatedbythesubex\u00adpressionrepliateP(n-1)visimmediatelyonsumedand \n6 Thissituationalsooursfrequentlyinrealistifuntions. disardedinthenextreursivestep.Itislearlyawasteof \ntimeandmemorytobuilditinthefrstplae. Asdisussedearlier,sumPisimplementedintermsof loopP,soafterinliningsumPthearrayonstrutedbythe \nappliationofrepliatePisimmediatelyonsumedbyaloopP inthefollowingreursion.Aperfetopportunityforfusion, \nbuttheuseofrepliatePandloopPareseparatedbyafun\u00adtionboundary.Thus,thefusionruleannotfre! Thisisverysimilartothesituation,whereaprimitive \nvalueisboxedfora(reursive)funtionall,onlytobeim\u00admediatelyunboxedbytheallee.ReognisingthatrepliateP isanarrayonstrutorandloopPadestrutor,thesituation \nisverysimilarindeed.Withthisinsight,itisnotsurprising thattheideabehindtheonstrutorspeialisationtehnique \nof[25]providestheseedforasolutionofourproblem. Theessentialideaistogenerateaspeialisedversionoffoo forthease,whereitisalledwithanargumentonstruted \nbyrepliateP.Inthisase,weanpulltheuseofrepliateP intofoo'sbodyandobtainthefollowingvariant: fooR::Int-Int-Int \nfooRnvInullPxs=0 Iotherwise=let n=lengthPxs v=sumPxs in foo(repliateP(n-1)v) where xs=repliatePnv NowsumPisimmediatelyappliedtotheresultofrepliateP \nand,aftersomeinlining,(loopIrepliatefusion)anfre.All thatislefttobedone,istoreplaeeveryourrenefoowith \nanargumentapplyingrepliatePbyanappropriateallto fooR.Again,GHC'srewriterulesometotheresue.For eahspeialisedversionofafuntion,wegenerateasimple \nrulelikethis: (fooIrepliatePspeialisation)Vnv foo(repliatePnv)-fooRnv WhenappliedinthebodyoffooRitself,fooRbeomesre\u00adursive.Inombinationwith(loopIrepliatefusion),weget \nfooR::Int-Int-Int fooRnvIn==0=0 Iotherwise=fooR(n-1)v where v=projA(loopAmut0(repliatePn())) mut (i,a)=(Nothing,(i+1,i+a)) \nVoila!Wehavesuessfullyeliminatedallarrays.Asmen\u00adtioned,repliatePn()doesnotatuallyonstrutanarray, soloopAwillompiletoasimpleloopaddingup1ton. \n  6. PERFORMANCE Thefgurespresentedinthissetionwereobtainedwitha frstexperimentalimplementationofequationalloopfusion \nonthebasisofGHC'srewriterules.Weusedtheurrentde\u00advelopmentversionofGHC(version5.01)withthefollowing optimisationoptions-02-fliberate-ase-thresholdl00 \n-funfolding-use-thresholdl0-fno-method-sharing.In addition,wepathedtheompilertouseamaximumworker\u00adwrapperargumentountof20(ratherthanthedefaultof \n6).AllCodewasompiledwithg2.96using-02.All  N Figure2:PerformaneofsumSq testswereexeutedonanunloaded333MHzPIIwith256kB \nseondlevelahe,runningGNUILinux. 6.1 Basic Loop Kernels 6.1.1 Sum-Square ThefuntionsumSqfromSetion3isanextremeexam\u00adplethatdemonstratesthepossibleimpatthatloopfusion \nanhave,asallintermediatestruturesanbeeliminated. Figure2displaystheperformaneofapplyingsumSqto valuesbetween1,000,000and5,000,000.Therearefour \nversions:(1)\"fused\",fullyfusedandoptimised;(2)\"not fused,\"butstilloptimised;(3)\"lists(fused)\",theHaskell \nprogramsum(mapsquare[1n]),whihGHCfusesusing foldrIbuild;and(4)\"C\",thefollowingCode: result=0; for(i=0;i<size;i++) \nresult+=i*i; Thefullyoptimisedandfusedarrayodeisonly26%to 39%slowerthantheCversion.Moreover,loopfusionim\u00adprovestherunningtimeofthisfuntionbyafatorof45to \n5overthefattenedodeasitanremoveallarraysfromthis ode.Thelist\u00adbasedprogramisslower,asGHCmanagesto eliminateonlyoneoutofthetwointermediatestrutures \nwithitsurrentPreludedefnitions. 6.1.2 Sieve of Eratosthenes TheseondbenhmarkisasimpleversionoftheSieveof \nEratosthenestoomputetheprimenumbersuptoagiven bound.UsingstandardHaskellarrays,thealgorithmsisas follows: \nprimes::Int-[Int] primesnIn:2=[] Iotherwise= Upperbound Figure3:Performaneoftheprimesieve let sqrPrms=primes$eiling(sqrt(fromIntegraln)) \nsieves=onat [[2*p,3*pn-1]IpsqrPrms] range=(2::Int,n-1) fags=aumArray(&#38;&#38;)Truerange (zipsieves(repeatFalse)) \nin [nI(n,f)assosfags,f] Figure3displaystheexeutiontimesfor(1)standard Haskellarrays,(2)anequivalentprogramusingPArrays, \nand(2)aorrespondingCprogrambasedoninplaeup\u00addates.ThisbenhmarklearlyshowsthatPArraysperform atleastanorderofmagnitudebetterthanstandardHaskell \narraysinGHC.However,thehand\u00adwrittenCodeisstillby afatorof4to55fasterthanourarraylibrary.Themain reasonforthisperformanegapisthattheoderequires \naso\u00adalled\"defaultbakpermute\",apermutationfuntion verysimilartostandardHaskell'saumArray.Thisfun\u00adtionannotbeexpressedwithloopPinitsurrentform, \nwhihmeansthatitannotfusewithadjaentloops. 6.1.3 Sparse Matrix Vector Multiplication Figure4displaystherunningtimesforthesparsematrix \nvetormultipliationsmvmappliedtoasetofmatrieswith 160,000non\u00adzeroelements,butvaryingdensity(fromdense \nto01%non\u00adzeroelements).Thefgureontainsurvesfor (1)standardHaskellarrays,(2)PArraysoptimised,butnot fused,(3)PArraysfullyfused,and(4)hand\u00adwrittenCode. \nTheversionoftheodeusingstandardHaskellarraysis fusedbyGHCusingfoldrIbuild(Haskellarraysareon\u00adstrutedandreduedvialists).Nevertheless,theyarenot \nabletoompetewiththeodebasedonPArray.Compar\u00adingtheexeutiontimesforthefusedandnotfused,but fattenedPArrayode,weseethatloopfusionimprovesthe \nperformaneoftheodebyafatorof4to6.Nevertheless, thehand\u00adodedCprogramisstillnearlyafatorof2faster thanthefusedPArraysode.Asthereisstilloneunbox\u00adingoperationperformedpersegmentinthefattenedmatrix \nrepresentation,wehopetobeabletolosethatgapfurther byimprovingunboxing. Wehavealsotestedapurelylist\u00adbasedversionofsmvm, \n Density in % Figure4:Timingofsmvm(160knon-zeroelements) 1000 2000 3000 4000 5000 6000 7000 8000 9000 \nNo of Particles Figure5:PerformaneoftheBarnes-Hutode butdespitefoldr/build,theodewastooslowtobedis\u00adplayedinthegraph. \n 6.2 Barnes-Hut .-Body Code Thelargestexamplethatwehavetestedtodateisan implementationoftheBarnes\u00adHutN\u00adbodyalgorithm[3], \nwhihomputesthegravitationalforesbetweenasetof partiles.Thisodeishighlyirregularandentredaround atree\u00adshapedspatialdeomposition.Wehaveompareda \nstandardHaskellimplementationoftheodewithaversion usingaombinationofarraysandtreesasdisussedin[19]. Forthebenhmark,weusedastandard\"Plummer\"distribu\u00adtionof1000to9000partiles.Thearray\u00adbasedodelearly \noutperformsthestandardHaskellode;although,theabso\u00adluteperformanestillleavessignifantroomforimprove\u00adment. \n  7. CONCLUSIONS Thetwomaintehniquesthatweuseintheimplementa\u00adtionofarrays,fatteningandfusion,happenintwodiferent \nstagesoftheompilation,yettheydointerat.Theinitial motivationtousefusionwastoeaseshortomingsofthe fatteningtransformationbyombiningsequenesofarray \ntraversalsintofewer,butmoreomplexoperationsthatex\u00adhibitbetterloalityofreferene.Moresurprisingly,however, \nfattening,ormorepreiselythefattenedrepresentationof thedatatypes,alsosimplifesfusion:Byexpressingallar\u00adraygeneratorsintermsofrepliatePofunittype,weould \nsimplifytheframework.Similarly,thezipproblemissim\u00adplifedbythefatthatzipPitselfdoesnotatuallyprodue anewarray,sinearraysofpairsarerepresentedbyapair \nofarrays. 7.1 Related Work Loopfusionforimperativelanguagesiswellresearhed[1, 39,21,22,31].However,thehallengesandtehniques \nofloopfusioninimperativeandfuntionalontextsdifer signifantly.Theextensiveuseofindexalulationsand sideefetsinimperativearrayalgorithmsoftenrequiresso\u00adphistiatedanalysistehniquesbeforeloopsanbemanip\u00adulated.Infuntionaland,inpartiular,ombinator\u00adbased \napproahesthedatafowismoreexpliit,whihprovides moresopefortransformations.Inafuntionalontext, itisespeiallyimportanttoremoveintermediatestrutures \nandsuperfuousopyingand,instead,useupdate\u00adin\u00adplae. Anderson&#38;Hudak[2]argueformonolithi,lazyarrays defnedbyHaskellarrayomprehensionsandadaptsub\u00adsriptanalysis,suhthatitanbeusedtoimplementsome \nalgorithmsmoree\u00c6iently.Theyfousonregularode. Ellmenreih,Lengauer&#38;Griebl[14]alsohandleHaskell arrayomprehensionsandadaptananalysisthatwasorig\u00adinallyintroduedforimperativeprogramstothefuntional \nase.Theyalsofousonregularode. Chuang[12]introduedombinator\u00adbasedarraysforML. Hestaysquitelosetotypiallistombinators,butalso \nonsidersupdate\u00adin\u00adplae.Hementionsloopfusionbriefy, butonlyintheformoftypiallistfusionrules,suhasfusion \nofmapf\u00c6mapg.Theemphasisis,again,onregularode. O'Neill&#38;Burton[23]introdueamethodforfastpersis\u00adtentarrays.They,aswellasrelatedapproahes,essentially \naimatafast,purelyfuntionalupdateoperationforsingle elementswithoutopyingthewholearray.Thisprovides someofthee\u00c6ienygainsofupdate\u00adin\u00adplae,butom\u00adpletelyignorestheissueofunboxing. \n 7.2 Future Work Sofar,weonlyappealtointuitiontoreasonthatthe rewriterulesareindeedoptimisations.Amoresystemati \ntreatmentrequiresaostmodelwhihtakesintoaountthe ostofmemoryaess,andideally,eventhememoryhier\u00adarhytoguidetransformations.Moreover,weareurrently \ninvestigatinghowweanextendthesopeofthetransfor\u00admationtoinludetupling;i.e.,ombiningtwoindependent loopsoverstruturesofthesamesize.Suhatransforma\u00adtionannotbeexpressedasasimplerewriterule,asitre\u00adquiresthatertainsideonditionshold.Dependenttypes \noronstraint\u00adbasedanalysismayprovideasolutionhere. Moreover,weplantointegratetheapproahpresented herewithourpreviousworkonintegratingfusionwitha \ndistributedimplementationofarrays[20].Thedistributed implementationwillusetheparallelsemantisofPArrays \ntomakeuseofmultipleproessingnodes. 7.3 Acknowledgements WearegreatlyindebtedtoSimonPeytonJoneswhohelped \nusinmanyways.Henotonlyexplainedtousthesubtleties ofGHC'srewriterulesandotheroptimisations,butalso extendedGHCwithanumberofoptimisationsthatwere \nruialforustomakeprogress,andhepointedustotheon\u00adstrutorspeialisationtransformationthatameinsohelp\u00adfulinSetion5.2.Furthermore,heandKaiEngelhardtgave \nusvaluablefeedbakonearlyversionsofthispaper.More\u00adover,wearegratefultoKevinGlynnandBernardPopeas wellastheanonymousrefereesfortheirdetailedomments \nandhelpfulsuggestions.  8. REFERENCES [1]W.Abu\u00adSufah.ImprovingthePerformaneoflirtual MemoryComputers.PhDthesis,Dept.ofComputer \nSiene,UniversityofIllinois,1979. [2]S.AndersonandP.Hudak.CompilationofHaskell arrayomprehensionsforsientifomputing.In \n ProeedingsoftheACMSIGPLAN'9OConfereneon ProgrammingLanguageDesignandImplementation, pages137-149,1990. \n[3]J.BarnesandP.Hut.AhierarhialO(nlogn)fore alulationalgorithm.Nature,324,Deember1986. [4]G.Blelloh,H.Burh,K.Crary,R.Harper,G.Miller, \nandN.Walkington.Persistenttriangulations.Journal ofFuntionalProgramming,2001.http://www.s. mu.edu/-rwh/papers/triangulations/jfp.ps.To \nappear. [5]G.E.Blelloh.Prefxsumsandtheirappliations. TehnialReportCMU\u00adCS\u00ad90\u00ad190,Shoolof ComputerSiene,CarnegieMellonUniversity,Nov. \n1990. [6]G.E.Blelloh.Programmingparallelalgorithms. CommuniationsoftheACM,39(3):85-97,1996. [7]G.E.Blelloh,M.A.Heroux,andM.Zagha. \nSegmentedoperationsforsparsematrixomputation onvetormultiproessors.TehnialReport CMU\u00adCS\u00ad93\u00ad173,ShoolofComputerSiene, \nCarnegieMellonUniversity,Aug.1993. [8]G.E.BlellohandG.W.Sabot.Compiling olletion\u00adorientedlanguagesontomassivelyparallel \nomputers.JournalofParallelandDistributed Computing,8:119-134,1990. [9]D.Cann.Retirefortran.Adebaterekindled. \nCommuniationsoftheACM,35(8):81,Aug.1992. [10]M.M.T.ChakravartyandG.Keller.Howportableis nesteddataparallelism.InPro.of6thAnnual \nAustralasianConf.onParallelAndReal-Time Systems,pages284-299.Springer\u00adVerlag,1999. [11]M.M.T.ChakravartyandG.Keller.Moretypesfor \nnesteddataparallelprogramming.InP.Wadler, editor,ProeedingsoftheFifthACMSIGPLAN InternationalConfereneonFuntionalProgramming \n(ICFP'OO),pages94-105.ACMPress,2000. [12]T.Chuang.Afuntionalperspetiveofarray primitives.In2ndFujiInt.WorkshoponFuntional \nandLogiProgramming,pages71-90,1996. [13]I.S.Duf,A.M.Erisman,andJ.K.Reid.Diret MethodsforSparseMatries.OxfordSiene \nPubliations,1986. [14]N.Ellmenreih,C.Lengauer,andM.Griebl. Appliationofthepolytopemodeltofuntional programs.InJ.Ferrante,editor,Pro.12thInt. \nWorkshoponLanguagesandCompilersforParallel Computing(LCPC'99).ComputerSieneand EngineeringDepartment,UCSanDiego,1999. \n[15]A.J.Gill,J.Launhbury,andS.L.PeytonJones.A shortuttodeforestation.InArvind,editor, FuntionalProgrammingandComputerArhiteture, \npages223-232.ACM,1993. [16]J.H.v.Groningen.Theimplementationande\u00c6ieny ofarraysinClean1.1.InW.Kluge,editor, \nProeedingsofImplementationofFuntional Languages,8thInternationalWorkshop,IFL'96, SeletedPapers,number1268inLNCS,pages \n105-124.Springer\u00adVerlag,1997. [17]R.HarperandG.Morrisett.Compilingpolymorphism usingintensionaltypeanalysis.InProeedingsofthe \n22ndAnnualSymposiumonPriniplesof ProgrammingLanguages,pages130-141.ACMPress, 1995. [18]C.B.Jay.Partialevaluationofshapedprograms: \nexperienewithFISh.InO.Danvey,editor,ACM SIGPLANWorkshoponPartialEvaluationand Semantis-BasedProgramManipulation(PEPM'99), \n1999. [19]G.KellerandM.M.T.Chakravarty.Flatteningtrees. InD.PrithardandJ.Reeve,editors,Euro-Par'98, ParallelProessing,number1470inLetureNotesin \nComputerSiene,pages709-719,Berlin,1998. Springer\u00adVerlag. [20]G.KellerandM.M.T.Chakravarty.Onthe distributedimplementationofaggregatedata \nstruturesbyprogramtransformation.InJ.Rolim etal.,editors,ParallelandDistributedProessing, FourthInternationalWorkshoponHigh-LevelParallel \nProgrammingModelsandSupportiveEnvironments (HIPS'99),number1586inLetureNotesin ComputerSiene,pages108-122,Berlin,Germany, \n1999.Springer\u00adVerlag. [21]K.KennedyandK.S.MKinley.Maximizingloop parallelismandimprovingdataloalityvialoopfusion \nanddistribution.In1993WorkshoponLanguagesand CompilersforParallelComputing,number768,pages 301-320.SpringerVerlag,1993. \n[22]N.Manjikian.Combiningloopfusionwithprefething onshared\u00admemorymultiproessors.InProeedingsof the1997InternationalConfereneonParallel \nProessing(ICPP'97).IEEEComputerSoietyPress, 1997. [23]M.E.O'NeillandF.W.Burton.Anewmethodfor funtionalarrays.JournalofFuntionalProgramming, \n7(5):487-513,1997. [24]Y.Onoue,Z.Hu,H.Iwasaki,andM.Takeihi.The alulationalfusionsystemHYLO.InIFIPTC2 \nWorkingConfereneonAlgorithmiLanguagesand Caluli,pages76-106.Chapman&#38;Hall,1997. [25]S.PeytonJones,T.Hoare,andA.Tolmah.Playing \nbytherules:rewritingasapratialoptimisation tehnique.2001.MirosoftResearhCambridge. http://researh.mirosoft.om/Users/simonpj/ \npapers/rules.ps.gz. [26]S.PeytonJonesandJ.Launhbury.StateinHaskell. LispandSymboliComputation,8(4):293-341,1995. \n[27]S.PeytonJonesandS.Marlow.Seretsofthe GlasgowHaskellCompilerinliner.InInternational WorkshoponImplementationofDelarative \nLanguages,1999.http://researh.mirosoft.om/ Users/simonpj/papers/inline.ps.gz. [28]S.L.PeytonJones.CompilingHaskellbyprogram \ntransformation:areportfromthetrenhes.InH.R. Nielson,editor,ProeedingsoftheEuropean SymposiumonProgramming,volume1058ofLeture \nNotesinComputerSiene,pages18-44,Berlin,1996. Springer\u00adVerlag. [29]S.L.PeytonJonesandJ.Launhbury.Unboxed \nvaluesasfrstlassitizensinanon\u00adstritfuntional language.InJ.Hughes,editor,Proeedingsofthe InternationalConfereneonFuntionalProgramming \nandComputerArhiteture,1991. [30]S.L.PeytonJones,W.Partain,andA.Santos. Let\u00adfoating:Movingbindingstogivefasterprograms. \nInProedingsoftheInternationalConfereneon FuntionalProgramming,1996. [31]G.RothandK.Kennedy.LoopfusioninHigh \nPerformaneFortran.InConfereneProeedingsof the1998InternationalConfereneonSuperomputing, pages125-132.ACMPress,1998. \n[32]S.\u00adB.Sholz.Ondefningappliation\u00adspeif high\u00adlevelarrayoperationsbymeansof shape\u00adinvariantprogrammingfailities.InProeedings \nofAPL'98,pages40-45.ACMPress,1998. [33]P.Serrarens.Implementingtheonjugategradient algorithminafuntionallanguage.InW.Kluge, \neditor,ProeedingsofImplementationofFuntional Languages,8thInternationalWorkshop,IFL'96, SeletedPapers,number1268inLNCS,pages \n125-140,1997. [34]A.TakanoandE.Meijer.Shortutdeforestationin alulationalform.InConf.Reord7thACM SIGPLAN/SIGARCHIntl.Conf.onFuntional \nProgrammingLanguagesandComputerArhiteture, pages306-316.ACMPress,NewYork,1995. [35]TheGHCTeam.GlasgowHaskellCompiler. \nhttp://haskell.org/gh/,2001. [36]TheGHCTeam.HaskellLibraries:Languagesupport. http://haskell.s.yale.edu/gh/dos/latest/ \nset/se-lang.html,2001. [37]P.Wadler.Deforestation:Transformingprogramsto eliminatetrees.TheoretialComputerSiene, \n73:231-248,1990. [38]S.Weirih.Type\u00adsafeast:Funtionalpearl.In ProeedingsoftheFifthACMSIGPLANInternational \nConfereneonFuntionalProgramming(ICFP'OO). ACMPress,2000. [39]M.WolfandM.Lam.Analgorithmiapproahto ompoundlooptransformations.InT.G.A.Niolau, \nD.GelernterandD.Padua,editors,Advanesin LanguagesandCompilersforParallelComputing, pages243-259.TheMITPress,1991. \nAPPENDIX A. THE ARRAY LIBRARY &#38; RULES Figure6displayspartoftheinterfaeofthePArraysli\u00adbraryandprovidesdefnitionsforsomeoftheombinators \nthatanbedefnedintermsofrepliatePandloopP. dataPArraye typeSegd=PArrayInt typeSPArraye=(Segd,PArraye) \nidSAL::PAEa=a-a idSALa=a noSAL::PAEa=a-() noSALa=() falseSPL::PAEa=a-Bool falseSPL =False noAL::() noAL=() \nmapEFL::(PAEe,PAEe .)= (e-e .)-(e-a-(Maybee . ,a)) mapEFLf=Aea-(Just$fe,a) foldEFL::(PAEe,PAEa)= (e-a-a)-(e-a-(Maybe(),a)) \nfoldEFLf=Aea-(Nothing,fea) sanEFL::(PAEe,PAEa)= (e-a-a)-(e-a-(Maybea,a)) sanEFLf=Aea-(Justa,fea) projMap::(a,b,)-a \nprojMap(x,y,z)=x projAs::(a,b,)-b projAs(x,y,z)=y projA::(a,b,)- projA(x,y,z)=z mapP::(PAEe,PAEe .)= \n(e-e .)-SPArraye-SPArraye . mapPf= projMaploopP(mapEFLf)noSALfalseSPLnoAL flterP::PAEe= (e-Bool)-SPArraye-SPArraye \nflterPp= projMap$loopP(flterEFLp)noSALfalseSPLnoAL enumFromToP:: Int-Int-SPArrayInt enumFromToPstartend= \nprojMap$loopP(sanEFL(+))idSALfalseSPLstartpa where len=0'max'(end-start+1) pa=repliatePlen1 foldP::(PAEe,PAEe \n.)= ... . (e-e-e)-e-SPArraye-e foldPgn= projAloopP(foldEFLg)idSALfalseSPLn Figure6:Commonarrayombinators \n  \n\t\t\t", "proc_id": "507635", "abstract": "This paper introduces a new approach to optimizing array algorithms in functional languages. We are specifically aiming at an efficient implementation of irregular array algorithms that are hard to implement in conventional array languages such as Fortran. We optimize the storage layout of arrays containing complex data structures and reduce the running time of functions operating on these arrays by means of equational program transformations. In particular, this paper discusses a novel form of combinator loop fusion, which by removing intermediate structures optimizes the use of the memory hierarchy. We identify a combinator named loop P that provides a general scheme for iterating over an array and that in conjunction with an array constructor replicate P is sufficient to express a wide range of array algorithms. On this basis, we define equational transformation rules that combine traversals of loop P and replicate P as well as sequences of applications of loop P into a single loop P traversal. Our approach naturally generalizes to a parallel implementation and includes facilities for optimizing load balancing and communication. A prototype implementation based on the rewrite rule pragma of the Glasgow Haskell Compiler is significantly faster than standard Haskell arrays and approaches the speed of hand coded C for simple examples.", "authors": [{"name": "Manuel M. T. Chakravarty", "author_profile_id": "81408595395", "affiliation": "Univ. of New South Wales, Sydney, Australia", "person_id": "P187027", "email_address": "", "orcid_id": ""}, {"name": "Gabriele Keller", "author_profile_id": "81100011375", "affiliation": "Univ. of New South Wales, Sydney, Australia", "person_id": "PP39023133", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/507635.507661", "year": "2001", "article_id": "507661", "conference": "ICFP", "title": "Functional array fusion", "url": "http://dl.acm.org/citation.cfm?id=507661"}