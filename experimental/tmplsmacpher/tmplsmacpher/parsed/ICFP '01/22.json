{"article_publication_date": "10-01-2001", "fulltext": "\n Cost Recurrences for DML Programs*  Bernd Grobauer  BRICS Department of Computer Science University \nof Aarhus ABSTRACT A cost recurrence describes an upper bound for the running time of a program in terms \nof the size of its input. Finding cost recurrences is a frequent intermediate step in complex\u00adity analysis, \nand this step requires an abstraction from data to data size. In this article, we use information contained \nin dependent types to achieve such an abstraction: Depen\u00addent ML (DML), a conservative extension of ML, \nprovides dependent types that can be used to associate data with size information, thus describing a \npossible abstraction. We au\u00adtomatically extract cost recurrences from .rst-order DML programs, guiding \nthe abstraction from data to data size with information contained in DML type derivations. 1. INTRODUCTION \nAnalyzing the time complexity of a program is usually car\u00adried out in two steps. First, one establishes \nan upper bound of the program s running time as a function of the size of its input. Second, one approximates \nthe growth of this ex\u00adtracted bounding function, thus determining the complexity class of the program. \nThe .rst step requires an abstraction from data to data size. Information contained in dependent types \ncan be used to achieve such an abstraction. In this article, we show how to automatically extract time \nbounds from .rst-order programs written in Dependent ML (DML), an extension of ML that provides a limited \nform of depen\u00addent types. If a bound is successfully extracted, we can guarantee that it is a recurrence, \ni.e., an equation de.ning a function in terms of its result on smaller inputs. A recur\u00adrence that describes \nan upper bound for the running time of a program is called a cost recurrence. * An extended version of \nthis article is available as BRICS report RS-01-25. Ny Munkegade, Building 540, 8000 Aarhus C, Denmark. \nE-mail: grobauer@brics.dk Basic Research in Computer Science (www.brics.dk), funded by the Danish National \nResearch Foundation. Permission to make digital or hard copies of all or part of this work for personal \nor classroom use is granted without fee provided that copies are not made or distributed for pro.t or \ncommercial advantage and that copies bear this notice and the full citation on the .rst page. To copy \notherwise, to republish, to post on servers or to redistribute to lists, requires prior speci.c permission \nand/or a fee. ICFP 01, September 3-5, 2001, Florence, Italy. Copyright 2001 ACM 1-58113-415-0/01/0009 \n...$5.00. Limits and achievements of automated cost analysis Automated cost analyses have inherent limits. \nFor example, .nding a cost recurrence for a program is at least as hard as proving termination of the \nprogram. Also, .nding good approximations for the growth of recurrences (or, in general, almost any kind \nof function) is known to be a hard problem. Nevertheless, automated methods for cost analysis have been \nproposed. One choice is to restrict the class of pro\u00adgrams such that termination is guaranteed, and the \nex\u00adtracted time bounds can easily be approximated. For ex\u00adample, Reistad and Gi.ord [8] consider functional \nprograms without general recursion, using only combinators such as map and zip. Methods that treat more \ngeneral programs, as for example proposed by Le M\u00b4etayer [6] and Rosendahl [9], usually focus on extracting \na cost program p c;if p c termi\u00adnates, it calculates an upper bound for the running time of a program \np. Transforming p c may yield a version compact enough to read o. the complexity class of p.If not, p \nc still may be useful for more empirical attempts to determine the time complexity of p, such as plotting \ninput size against the running time calculated by p c . Dependent ML DML, which was developed by Xi [12, \n15] in his PhD thesis, extends ML with a limited form of dependent types: A DML type can be enriched \nwith indices taken from a constraint domain (e.g., integers equipped with their usual operations, with \nlinear (in)equalities as constraints). For example, the data type of lists can be enriched with a notion \nof length or a data type of trees with a notion of height. The type language is expressive enough to \nencode well-formedness cri\u00adteria, such as a tree being balanced. DML function types can express non-trivial \nproperties, for example that a list is always mapped to a list of the same length, or that a func\u00adtion \nwith a balanced tree as input always returns a balanced tree. The design philosophy of DML is to use \ntype-checking for the veri.cation of non-trivial correctness properties of ML programs every valid ML \nprogram is a valid DML pro\u00adgram, because DML extends ML conservatively. For exam\u00adple, to verify that \na program for inserting an element into a balanced tree indeed returns a balanced tree, the user needs \nto (1) enrich a data type of trees such that only balanced trees are accepted, and (2) declare in a type \nannotation that the insert function maps balanced trees to balanced trees. A range of similar examples \nconvincingly demonstrates that DML is a useful tool for practical programming [12, 13, 15]. This work \nWe use information contained in DML type derivations to extract cost recurrences from DML programs. With \nDML types, data can be associated with a measure of data size, which essentially describes an abstraction \nfrom data to data size that is necessary for extracting a cost recurrence. For example, enriching the \ndata type of lists with a notion of length describes an abstraction from lists to their length. More \nintricate measures also can be de.ned the high ex\u00adpressiveness of DML types allows the user to tailor \nmea\u00adsures to each situation. Size measures often coincide with shape information for data that is useful \nfor verifying pro\u00adgram properties by DML type-checking. Therefore, in many cases, DML types that express \ncorrectness properties of a program can be reused for establishing the complexity of the program. We \nallow recurrences to contain logical formulas, which are used to restrict arguments that cannot be completely \ndetermined. Thus, logical information contained in DML type derivations about such arguments can be included \nin cost recurrence rather than approximating them in an ad\u00adhoc way. Compared with other methods that \nextract exe\u00adcutable cost bounds and therefore are required to carry out approximations we leave the choice \nof how to approximate to the user, thus separating concerns between extracting a cost recurrence and \nsolving it. We combine the extraction of a cost bound with a check whether the result is indeed a recurrence: \nThe information contained in DML type derivations facilitates a check of whether the size measure decreases \nfor each recursive call under a wellfounded ordering. In other words, the user has to choose a size measure \nthat constitutes a termination order for the program in question. This is no limitation compared to other \nmethods: Because .nding a cost bound entails a termination proof, in all methods for cost analysis a \ntermi\u00adnation proof needs to be found in some way. It is an asset of using DML that the termination proof \ncan be concisely encoded through the size measure. An example Consider a zip function written in ML: \nfun zip lp = case lp of (nil,nil) => nil | (cons(x,xs),cons(y,ys)) => cons((x,y),zip(xs,ys)) DML o.ers \nthe possibility to annotate zip with a type con\u00adtaining an enriched version of lists. We enrich the data \ntype of lists with a notion of length; the type of a-typed lists consisting of n elements is written \nas alist(n). Obviously, zip should take two lists of equal length and return a list of the same length. \nDML type checking validates that zip has the type . n : N .alist(n) \u00d7 \u00dflist(n) . (a\u00d7 \u00df)list(n). Intuitively, \n. can be read as for all .1 In ML, a pair of two lists with di.erent lengths could be passed to zip,which \nwould result in a runtime error. In DML, the given type 1Formally, . introduces a dependent product, \ni.e., a product where the value of the .rst component (here n) determines the type of the second component \n(here the function from a pair of lists of length n to a list of length n). Dependent products are also \ncalled .-types. of zip allows zip only to be called with two lists of equal length. The type also shows \nthat the resulting list is of the same length as the input lists. Let us measure running time as the \nnumber of calls to user-de.ned functions, giving each call a cost of one unit. The resulting recurrence \ndescribes the number of calls to zip as a function of the length of the two input lists: n=0. 0 zipc(n)= \nn>0. 1+zipc(n- 1) This cost recurrence is extracted from a DML type deriva\u00adtion for zip. In the type \nderivation, the arguments to zip two lists are associated with an index n that represents their length. \nUsing this information, the extraction algo\u00adrithm abstracts from the lists to their length n.For ex\u00adample, \nthe case expression is turned into a conditional by inferring for each branch a condition on n that has \nto hold if the pattern is matched. Similarly, the algorithm derives from the type derivation that the \nrecursive call of zip has a list of length n- 1 as argument, and thus generates a call zipc(n- 1). Obviously, \nn- 1 <n, so the extracted bound is a recurrence. The recurrence can easily be solved: zipc(n)= n. The \nremainder of the article The article is structured as follows: Section 2 gives an intro\u00adduction to DML, \nSection 3 presents an intuitive account of our method for extracting cost recurrences and gives several \nexamples, Section 4 contains a formal account, Section 5 treats related work, and Section 6 concludes. \n 2. BACKGROUND: DEPENDENT ML DML provides dependent types in which type index ob\u00adjects are limited to \nsome constraint domain C.Type check\u00ading for DML is decidable; it is based on solving constraints in C. \nFor dependently typed languages with signi.cantly more expressive types (e.g., Cayenne [1]) type checking \nis undecidable. We consider an e.ect-free fragment of DML. As constraint domain, we choose integers, \nconstrained by linear (in)equ\u00adalities we write Z both for the sort of integers and the constraint domain. \nIn the following, we present a short in\u00adtroduction to programming in DML and sketch the formal speci.cation \nof DML. The latter forms the basis for the for\u00admal development presented in Section 4. 2.1 A programmer \ns view of DML The only new aspect for an ML programmer is the ex\u00adtended type system, which contains type \nindices, in the present case integers. 2.1.1 Enriched recursive data types As indicated in the example \nin Section 1, in DML a list type can be enriched with a notion of length, enabling us to express the \ntype of a-typed lists of n elements as alist(n). The DML data-type de.nition is datatype alist with N \n= nil(0) | .n:N .cons(n+1)of a\u00d7 alist(n) It is obtained from an ordinary de.nition of lists in ML by \nmaking the following additions: 1. The phrase with N has been added. This signi.es that the data type \nof lists is to be enriched with one index and that this index is restricted to the sort of natural numbers. \nThe constraint language of DML allows the de.nition of subsorts of an already de.ned sort: N stands for \n{k : Z | k = 0}. 2. Constructors and occurrences of list are augmented with an index. The constructor \nnil is indexed with 0, thus de.ning the empty list to be of type a list(0). A list built with cons is \nof type a list(n +1), provided that cons was applied to an element of type a list(n). Hence, cons is \nindexed with n +1. 3. The de.nition of the cons case exhibits a quanti.ca\u00adtion over an index variable \nn. This index variable is necessary to express the dependence between the in\u00addex of cons and the index \nof the list appearing in its branch. The quanti.cation restricts the index variable to the sort of natural \nnumbers.  Similarly, we can de.ne the data type of a list of lists a llist(m,n)as datatype allist with \n(N,N)= lnil(0,0) | .m,n1,n2 :N .lcons(m+1,n1 +n2)of alist(n1) \u00d7 allist(m,n2 ) The .rst index stands \nfor the number of inner lists and the second index for the total number of elements the inner lists contain. \nThe example of lists provides some intuition of how to de\u00ad.ne enriched recursive data types in two steps: \nFirst, decide on the number of indices to be used in the data type, along with the sorts the indices \nare to be restricted to. Second, an\u00adnotate each constructor with the appropriate indices. When an index \nof a constructor depends on indices of recursive data types that appear under that constructor, introduce \nnew index variables using quanti.cation. An index can be de.ned as a function of other indices using \nall operations of the constraint domain. In the introduction we mentioned that enriched data types can \nencode well-formedness criteria. As an example, we de\u00ad.ne a data type of height-balanced trees, i.e., \nthe height di.erence between the two children of a node can be at most one. We use two indices, where \nthe .rst represents the height of the tree and the second represents the number of elements stored in \nthe tree. When de.ning a node, we require for the heights h1 and h2 of the subtrees, that they di.er \nby at most one. This can be achieved by (1) de.ning a sort of natural numbers k that di.er by at most \none from h1, and (2) restricting h2 to this new sort: datatype a HBtree with (N,N)= Leaf(0,0) | .s1,s2,h1 \n:N ..h2 :{k :N | h1 - 1= k = h1 +1} . Node(1+max (h1,h2),s1 +s2 +1)of a HBtree(h1,s1) \u00d7 a \u00d7 a HBtree(h2,s2) \n As a consequence, only two trees with a height di.erence of at most one can be the children of a node, \ni.e., only height\u00adbalanced trees can have type a HBtree. Note that for de.ning a new sort, all predicates \nand oper\u00adations of the chosen constraint domain can be used. In the case of height-balanced trees, we \nuse -,+, and =. 2.1.2 DML function types As in ML, a data-type de.nition gives rise to type decla\u00adrations \nfor its constructors. For example, the de.nition of enriched lists presented above yields a type a list(0) \nfor the constructor nil,and the type . n : N .a \u00d7 a list(n) . a list(n +1) for the constructor cons. \nappend : .n1,n2 :N .alist(n1)\u00d7 alist(n2). alist(n1 +n2) fun append lp = case lp of (nil,l2) => l2 | (cons(x,xs),l2) \n=> cons(x,append(xs,l2)) flatten : .m,n :N .allist(m,n). alist(n) fun flatten ll = case ll of lnil => \nnil | lcons(xs,rest) => append(xs,flatten rest) occurs : .h,s:N .string \u00d7 string HBtree(h,s). bool fun \noccur(e,t) = case t of Leaf => false | Node(t1,e ,t2) => if e = e then true else ife < e then occurs(s,t1) \nelse occurs(s,t2) Figure 1: Some functions with their DML types Figure 1 shows three functions operating \non the data types de.ned in Section 2.1.1, together with their DML types: append takes two lists of \nn1 and n2 elements, respec\u00adtively, and returns a list of n1 + n2 elements.  flatten takes a list of \nlists that contain a total number of n elements, and returns a list of n elements  occurs takes a string \nand a balanced tree, and returns a truth value, according to whether the string is stored in the tree \nor not (assuming a sorted balanced tree). The DML types of append, flatten and occurs add shape information \nto the respective ML type of each function: In the case of append and flatten, we learn about the shape \nof the result, i.e., how long the output list is. For occurs, the DML type restricts the input tree to \ntrees of a special shape, namely balanced trees. So far, the output indices in the DML type of a function \ncould always be speci.ed as a function of the input indices. For relational dependencies, DML o.ers existential \ntypes. These allow one to restrict the index of an output to a sort because sorts can be de.ned in terms \nof already declared indices, relational dependencies can be expressed. Consider, for example, a function \nthat inserts a string into a balanced tree. Depending on how the tree is rebalanced, the result can be \na tree of equal height or a tree higher by one. Similarly, the number of elements in the tree stays equal \nif the element to be inserted already was in the tree, otherwise the number is increased by one. A valid \nDML type for a correct insert function on height-balanced trees is as follows: . h, s : N . string \u00d7HBtree(h,s) \n. .h' : {k : N |h =k =h +1}. .s' : {k : N |s =k =s +1}. HBtree(h',s') The type of the output tree restricts \nheight and size to be either equal or larger by one than the height and size of the input tree, respectively. \n 2.2 A formal speci.cation of DML In the theoretical development of DML [12], several lan\u00adguages are \nde.ned: ML0 formalizes a manageable subset of ML; DML0(C) extends ML0 with .-types over elements from \na 0 (C) extends the term constraint domain C;DML. language of DML0(C) with indices, and is explicitly \ntyped. DML.0 (C) allows easy type-checking, because it is explic\u00aditly typed and indices are part of the \nterm language. For thesamereason, however, DML.0 (C) is impractical for ac\u00adtual programming. Instead, \nthe user works with DML0(C), which corresponds to the language, the example programs of Section 2.1.2 \nare given in: Their displayed DML-types are the type-annotations that are required for the implicit .xed-point \nde.nitions. Type-checking is carried out by a type elaboration algorithm [12, Chapter 4], evaluation \nby applying the erasure and the ML0 evaluation mechanism. In the following, we .rst give some basic facts \nabout con\u00adstraint domains and the constraint language used to express the index objects for DML types. \nWe then brie.y describe DML.0 (C).2 The description glosses over many details we refer the reader to \nXi s PhDthesis [12] for the complete picture. 2.2.1 Constraints in DML A constraint domain C is de.ned \nby (1) a signature S that declares a base sort along with basic operations and predi\u00adcates and (2) a \nS-structure. For example, for the constraint domain Z, the signature declares the base sort Z and the \nusual operations (+, -, mod, etc.) and predicates (<, =, etc.) over integers; the S-structure is given \nby the standard model of integers. sorts . ::= b | 1 | .1 \u00d7.2 | |{a : . |P}propositions P ::= T|||.| \np(i) | P1 .P2 | P1 .P2 objects i, j ::= a | f(i) | |()| |(i, j)|| fst(i) | snd(i) contexts f ::= \u00b7|| \nf,a : . | f,P Figure 2: Constraint language DML uses the constraint language de.ned in Figure 2 to express \nthe index objects for DML types. New sorts can be de.ned by pairing already de.ned sorts or restricting \nan al\u00adready de.ned sort with a sort proposition. Sort propositions are built from the basic predicates \np of the constraint do\u00admain. Index sorts serve as types for index objects, in which basic operations \nf of the constraint domain can appear. An index context is given as a collection of index propositions \nand type declarations for index variables. 2For simplicity, we restrict the presentation to the monomor\u00adphic \ncase without existential types polymorphism and ex\u00adistential types are treated in extensions of DML.0 \n(C). DML type-checking requires a constraint solver that is able to handle constraints of the form F \n::= T|||.| i = j | p(i) | F1 .F2 | F1 .F2 | |.a : ..F | |.a : ..F Constraint satisfaction under a given \nindex context, which is written as f |= F, is de.ned in the canonical way. 2.2.2 The language DML.0 (C) \nA grammar of the DML.0 (C) syntax is given in Figure 3. t ::= d(i) | 1 | (t1 \u00d7t2) | (t1 .t2) | . a : \n..t e ::= x | |()| |(e1,e2)|| c[i1] .. . [in] | c[i1] ... [in](e) | (case e of ms) | (lam x : t. e) | \ne1(e2) | let x = e1 in e2 end | (.x x : t.e) | (.a : ..e) | e[i] p ::= x | c[a1] ... [an] | c[a1] .. \n. [an](p) | |()| |(p1,p2) ms ::= p .e | p .e |ms Figure 3: Syntax of DML. 0 (C) In the grammar of the \ntype language, d(i) stands for a data type d that is indexed with index object i. Several examples of \ntypes appeared in Section 2.1.2. In addition to the usual constructs, the term language provides abstraction \nover index variables (.a : ..e)and ap\u00adplication of an expression to an index object (e[i]). Further\u00admore, \na constructor c of a recursive data type only appears with a number of index arguments index variables \nwhen appearing in a pattern p and index objects otherwise. The number and sorts of index arguments is \ndetermined by the constructor type, which is inferred from the corresponding data type de.nition (see \nSection 2.1.2). A typing judgment for DML.0 (C) has the form f;G f e : t, where f is an index context \nand G a normal context; an overview over the typing rules for DML.0 (C)is presented in Appendix A.  \n 3. EXTRACTING COST RECURRENCES We .rst give an intuitive account of our method for ex\u00adtracting cost \nrecurrences from DML programs, deferring a formal treatment to Section 4. We then present examples illustrating \nsome distinctive features of the method. 3.1 The intuition behind extracting cost recur\u00adrences We extract \ncost recurrences from .rst-order DML pro\u00adgrams of the form F1 :. a0 : .0.... al1 : .l1 ..11 . .12 F1 \n(x0 ,x1 ,...,xl1 ) = body1 . . . Fk :. a0 : .0.... alk : .lk ..k1 . .k2 Fk (x0 ,x1 ,...,xlk ) = bodyk \nwhere we write . for .rst-order types. Because indices are used to abstract from data to data size, we \nrequire that (1) all sorts . have been constructed only with subsorts of N and (2) data types are enriched \nsuch that for any i, all indices occuring in a branch of a data type d(i) must be bounded. The .rst requirements \navoids abstractions to negative data size, the second requirement rules out data-type de.nitions that \nwould be useless for an abstraction guided by index information. We count cost in terms of the number \nof calls to user\u00adde.ned functions F and to constructors c, assigning a cost of cF and cc for each call, \nrespectively. cF and cc are constants of the domain in which cost is measured, e.g., the natural numbers. \nThe .rst step of extracting a cost recurrence from a DML program is type elaboration, which yields a \nDML.0 (Z)pro\u00adgram. Example For the append function from Figure 1, type elaboration yields the DML.0 (Z) \nprogram displayed in Fig\u00adure 4. Type elaboration makes the indices explicit in the term language: index \nvariables n1 and n2 are abstracted over; pattern matching against cons introduces a new index variable \nn1' ; cons and the recursive call of append are passed index objects that describe the length of the \nrespective list ar\u00adguments passed to cons and append. Because DML.0 (Z) is monomorphic, assume that the \ndata type list has been de.ned for a .xed type of elements, say string. The constructors nil and cons \nthen are typed as follows: nil : list(0) cons :. n : N .string \u00d7list(n) .list(n+1) .x append :. n1 : \nN .. n2 : N .list(n1) \u00d7list(n2) .list(n1 + n2). .n1 : N ..n2 : N .lam lp: list(n1) \u00d7list(n2) . case lp \nof (nil,l2).l2 |(cons[n1' ](x,xs),l2).cons[n1 ' + n2](x,append[n1' ][n2](xs,l2)) Figure 4: The append \nfunction in DML.0 (C) We now describe intuitively how the extraction algorithm works. Note that all steps \ncan be carried out automatically; for manipulating constraints, the algorithm uses a constraint solver \nfor Z. The type of each function determines the arguments of the corresponding recurrence equation. A \nfunction F :. a0 : .0.... al : .l ..1 ..2 gives rise to a recurrence equation Fc with a0 ...al as formal \nparameters. Example (cont.) For append, a recurrence equation appendc with formal parameters n1 and n2 \nis extracted. The extraction algorithm works on the body of the func\u00adtion de.nitions. The issues that \nhave to be dealt with are 1. How to treat case expressions? 2. How to treat index variables introduced \nby pattern matching? 3. How to assign and add up cost?  3Because type elaboration as de.ned by Xi [12, \nChapter 4] works on DML0(C) programs, the program has to be rewritten in DML0(Z). This is easily done \nby replacing the ML function-de.nition syntax with a .xed-point de.nition (keyword .x), a lambda-abstraction \n(keyword lam), and a case expression with a single pattern, and declaring F1 ...Fk in a row of nested \nlet-statements. How to treat case expressions? To abstract from data to data size, we need to turn case \nexpressions, which exam\u00adine data, into conditionals that examine data size. Such a transformation can \nbe achieved using information contained in the DML.0 (Z) type derivation: During type checking, con\u00adstraints \nover the index objects in the program are collected in an index context. Consider a branch of a case \nexpression over some type .. The type derivation contains a collec\u00adtion of constraints that have to be \nsatis.ed when entering the branch, i.e., when the pattern of the branch is matched. By projecting out \nthese constraints over the index variables contained in ., i.e., eliminating all other index variables, \na guard for the corresponding branch of a conditional can be derived. Example (cont.) The case expression \nin append is type\u00adchecked under the index context f= n1 : N,n2 : N For the two branches, additional constraints \nare generated: For the branch with pattern (nil,l2), the index context n1 =0 is generated.  For the \nbranch with pattern (cons[n1' ](x,xs),l2),the index context n1 ' : N,n1 = n1 ' +1 is generated.  From \nthe conjunction of f and the newly generated index context of each branch, we can derive a condition \nin terms of n1 and n2 by projecting out over n1 and n2:The result is n1 =0 for the .rst branch and n1 \n> 0 for the second branch. In general, it is possible that the generated guards over\u00adlap, even though \nthe patterns of the case expression are mutually exclusive. When, during the evaluation of a recur\u00adrence \nequation, more than one guard is satis.ed, all possible branches are evaluated and the maximum value \nis returned. How to treat index variables introduced by pat\u00adtern matching? A pattern can introduce new \nindex vari\u00adables; these index variables may appear within the branch guarded by the pattern, and thus \nalso may play a role in the corresponding conditional branch of the extracted re\u00adcurrence equation. Often, \nwe can eliminate such index vari\u00adables by deriving equality constraints that de.ne a new in\u00addex variable \nin terms of other index variables. If not, then theconstraints can beused toderivearestriction for the \nval\u00adues of the new index variables. This restriction is inserted into the extracted conditional branch. \nExample (cont.) The second branch of the case expres\u00adsion in append introduces the new index variable \nn1' .The constraints allow us to derive that n ' 1 = n1 -1,so n ' 1 can be eliminated. How to count and \nadd up cost? When extracting a cost recurrence, we need to count every call to a user\u00adde.ned function \nF with a cost of cF and every use of a constructor c with a cost of cc. Consider .rst a constructor c \nwithout arguments: In the cost recurrence, we simply re\u00adplace c[i1] ...[ik]with cc. For constructors \nwith arguments c[i1] ...[ik](e) and function calls F[i1] ...[ik](e), the cost in\u00adcurred by e also needs \nto be taken into account. Hence, we .rst extract a recurrence-equation expression t that repre\u00adsents \nthe cost of evaluating the argument, and then add it to the cost incurred by the function call: The total \ncost of c[i1] ...[ik](e)is t+ cc The total cost of F[i1] ...[ik](e)is t+cF +(Fci1 ...ik), guarantees \nwe pro.t from the fact that DML can express where Fci1 ...ik is a call to the cost recurrence ex-properties \nof the input that are not inferable from the code. tracted for F. Our method yields the following cost \nrecurrence for occurs: In our cost model, constants and variables can be accessed without cost, and therefore \nare turned into the constant 0 h =0 . s=0 . 0 . .. . .. . 0h> 0 . s>0 . 1 + occurs c occurs c hs= when \nextracting a cost recurrence. .... h1 s1 .. Example (ended) We now assemble all the pieces of a 1 + occurs \nc h2 s2 cost recurrence for append. If we assign a cost of one unit to recursive calls of append and \nassume the use of cons to be cost free, then the cost of append is described by where h1 - 1 = h2 = h1 \n+1 . max(h1,h2)+1= h n1 =0. 0 appendc n1 n2 = n1 > 0. 1+append c(n1 - 1) n2 (In the second branch, we \nhave removed additions of zero that resulted from the variables x,xs and l2, and the appli\u00adcation of \nconstructor cons.)  3.2 Example: Flattening a list of lists The flatten function (see Figure 1) is an \ninteresting prob\u00adlem for extracting a cost recurrence because of the choice of size measure for the input: \nThe size of a list of lists is mea\u00adsuredbothinterms of the number ofinnerlists andthe total number of \nelements contained in the inner lists. We measure cost in terms of calls to user-de.ned func\u00adtions. Our \nmethod yields the following cost recurrence:4 m=0 . n=0 . 0 . s1 + s2 +1= s (Each if expression gives \nrise to a guardless conditional, be\u00adcause no restrictions on indices can be inferred from its test expression.) \nThe recurrence looks more daunting than it is: It keeps track both of the height and the number of elements \nin the tree, but it is easy to see that the number of elements is of no consequence to the result of \nthe cost recurrence. Ap\u00adproximating both h1 and h2 with h- 1 gives rise to a simple recurrence equation \nwhose solution is occurs c(h,s)= h. The complication of eliminating size information could have been \navoided by chosing a tree type which only keeps track of the height of a tree. Also keeping track of \nthe num\u00adber of elements, however, allows us to derive a cost measure in terms of the number of elements \nrather than the height of the tree. The crucial observation to make is that DML data\u00ad . .. .. type de.nitions \ngive rise to induction principles for proving .attenc mn= m>0 . 2+ appendc n1 n2 relations among the \nindices of a data type. The de.nition of + .attenc (m- 1) n2 HBtree, for example, yields the following \ninduction schema: where n1 + n2 = n Here, a restriction n1+n2 = nfor the new variables n1 and n2 introduced \nby pattern matching has been inserted by the extraction algorithm neither n1 nor n2 can be eliminated \nautomatically. Using the equation appendc n1 n2 = n1 derivedinSec\u00adtion 3.1, we can rewrite the cost recurrence \nfor .atten as For R . N \u00d7 N,if 1. R(0,0) 2. if for all h1,h2,s1,s2 with h1 - 1 = h2 = h1+1, R(h1,s1)and \nR(h2,s2)itfollows that R(max(h1,h2)+1,s1 + s2 +1)  then whenever a value has type HBtree(h,s), the relation \nR(h,s)holds. .attenc mn= . .. .. m=0 . n=0 . 0 m>0 . 2+ n1 Using this induction schema, one can show \nthat s= 2h -1 + .attenc (m- 1) n2 for any height-balanced tree with height hand size s.Taking the logarithm, \nwe see that h = log(s+ 1); combining this where n1 + n2 = n with the cost recurrence occurs c(h,s)= h,we \nderive that the cost of occurs is logarithmic in s. This derivation is It is easy to see that the maximal \ncost incurred by n1 in the fully formal, i.e., based only on assumptions explicit in thesecond branch, \nadded over all recursive calls, is n; all in all, we can approximate the cost of flatten as .attenc(m,n)= \n2m+ n. The size measure chosen here for a list of lists is intuitive and seems to be crucial for deriving \na useful bound. Yet it is unclear how this measure could be be de.ned without the expressiveness o.ered \nby DML types, e.g., when using abstract-interpretation techniques [9].  3.3 Example: Searching a balanced \ntree The occurs function (see Figure 1) provides an example of how two cost bounds in terms of di.erent \nsize measures can be obtained: One in terms of the height of a tree, and one interms of the number of \nelementsstoredina tree. The latter bound is obtained by reasoning with DML type 4Here and in all the \nfollowing recurrences we have simpli.ed additions of constants. types or the extracted recurrence.  \n3.4 Example: Merge sort Merge sort provides an example of how the extraction algorithm preserves useful \ninformation contained in a pro\u00adgram s DML type. An implementation of merge sort in DML is given in Fig\u00adure \n5 (adapted from the distribution of de Caml,a DML prototype [11]): Function initlist converts the list \nto be sorted into a list of lists such that each of these lists is sorted and has length two (apart from \na possible last singleton list). Function merge2 goes through a list of lists, merg\u00ading every two adjacent \nlists into one. Function mergeall iterates the application of merge2 until a single list is ob\u00adtained. \nThe types of initlist and merge2 capture the fact that the size measure that steers the recursion is \ncontinu\u00adally halved the index expression .n/2. can be encoded as  4.1 A .rst-order fragment of DML \nAs pointed out in Section 3.1, the .rst step of extract\u00ading cost recurrences for the functions de.ned \nin a .rst-order DML0(Z) program of the form given in Figure 7a is type elaboration, which results in \na DML.0 (Z) program. It is easy to show that only the bodies of the de.ned functions are a.ected by type \nelaboration, and that the grammar dis\u00adplayed in Figure 7b describes all possible function bodies that \ncan result from type elaboration. All in all, Figure 7 de.nes the language on which the extraction algorithm \nto be presented in Section 4.4 operates (cf. the full language in Figure 3). let F1 = .x F1 :. a0 : .0.... \nal1 : .l1 ..11 ..12. lam x: .11 .case x of (x0,...,xi1 ).body1 . . . Fk = .x Fk :. a0 : .0.... alk : \n.lk ..k1 ..k2. lam x: .k1 .case x of (x0,...,xik ).bodyk in e end a: Def. of functions F1 ... Fk 0 (Z)in \nDML0(Z)/ DML. e p ms ::= ::= ::= x| |()| |(e1,e2)|| c[i1] ...[in] | c[i1] ...[in](e) | (case e of ms) \n| let x= e1 in e2 end | Fi[i1] ...[in](e) x| c[a1] ...[an] | c[a1] ...[an](p) | |()| |(p1,p2)p.e| p.e|ms \nb: Grammar of function body e Figure 7: A .rst-order fragment of DML.0 (Z) 4.2 Measuring cost of computation \nOne way of introducing a cost measure into functional pro\u00adgrams is the monadic translation (see, for \nexample, Filinski s work [4]) with a cost monad. It is well-known that state can be added to a program \nby (1) performing a monadic trans\u00adlation with the state monad [10] and (2) taking the term model of the \nresult, i.e., expanding the monadic constructs inserted by the translation to code. Similarly, using \nthe cost monad instead of the state monad, we can transform a pro\u00adgram such that a cost counter is maintained. \nThe cost monad pairs computations that result in a value of type t with a second component of a type \nC that expresses the cost of the computation; all we need to know about C is that it is an ordered Abelian \ngroup (C, + ,0,=). We write C a as a type abbreviation for a\u00d7C. A call-by-value monadic translation with \na cost monad that is based on C turns a function of type . a0 : .0.... ak : .k ..1 ..2 into a function \nof type . a0 : .0.... ak : .k ..1 .C .2.The intended meaning is that the transformed function not only \nreturns the result value, but also the cost of computing it. The cost monad can be de.ned by specifying \ntwo language constructs, valC and letC, which a monadic translation in\u00adserts into a program text. The \ntyping rule for valC is f;G f e: . f;G f valC e: C . The construct valC is used to inject a value v : \n. into C . as (v,0) values do not require any computation and thus incur no cost. The typing rule for \nletC is f;G f e1 : C .1 f;G,x : .1 f e2 : C .2 f;G f letC x= e1 in e2 end : C .2 In (letC x = e1 in e2 \nend), the expression e1 is evaluated toaresult v1 wrapped with a cost z1.To calculate e2,the unwrapped \nv1 is used, yielding (v2,z2). The .nal result of the let expression is (v2,z1 + z2). The monadic translation \nprovides only the infrastructure for tracking cost, but does not assign costs to any program constructs. \nThis assignment of costs is done by inserting a monadic construct costz with typing rule f;G f e: C .z \n.C f;G f costz e: C . into the transformed program. costz is particular to the cost monad: It adds z \nto the cost component of the value it is applied to. A cost-conscious version of a program, i.e., a program \nthat keeps track of the cost incurred by calls to user-de.ned functions and uses of constructors, is \ngenerated as follows: We .rst perform a monadic translation of the program and then enclose (1) each \napplication of a user-de.ned function F with costcF , and (2) each application of a constructor cwith \ncostcc . We denote the combined translation that performs a monadic translation and inserts costz where \nappropriate with (\u00b7. Note that the monadic constructs valC , letC and ) * cost are only syntactic sugar \nand can easily be exanded into standard DML. 4.3 A language of recurrence equations The language of \nrecurrence equations is based on the nat\u00adural numbers part N of the constraint domain Z and the cost \ndomain C. Natural numbers and tuples thereof serve as ab\u00adstractions of input size, and therefore are \nused as arguments of recurrence equations. The result of a recurrence equation represents cost of computation \nand is expressed in C. 4.3.1 Syntax and types We describe a system of recurrence equations with the language \ngiven in Figure 8: Conditionals, which so far have been pretty printed, are introduced with the keyword \ncond followed by a number of branches. Within a branch, the .rst constraint F1 represents the guard of \nthe branch, whereas the second constraint F2 represents a where-clause. The scope of the quanti.cation \n(we write aa : as as shorthand for the quanti.cation over variables a1 : s1 ...ak : sk) extends both \nover F2 and the branch body t.For .aa: as.F2 we require that for any interpretation of its free variables, \nthere are only .nitely many instantiations of aa such that F2 is satis.ed; this requirement is met for \nrecurrence equations extracted from DML programs in which the data types are enriched in a sensible way \nas required in Section 3.1. The rationale behind the shape of recurrence equation types is that for a \nfunction Fl of type . a0 : .0 .. a1 : .1.... ak : .k ..1 ..2, the associated cost recurrence Flc should \nhave type .0 ..1 .....k .C, where \u00b7maps an index sort to the associated index type. For example {a: N \n\u00d7N |fst(a) =snd(a)}is mapped to N \u00d7N. index types s ::= N | 1 | s1 \u00d7s2 types . ::= C | s .. de.nitions \nE ::= Fc 1 a0 a1 ...al1 = t1 . . . Fc k a0 a1 ...alk = tk body t ::= z| t1 + t2 | Fc ai| (cond brs) index \nobjects i,j ::= a| f(i) | |()| |(i,j)|| fst(i) | snd(i) branches brs ::= br| br |brs branch br ::= (F1 \n..aa: as.F2 .t) Figure 8: Syntax of recurrence equations T[[z]].. = Lz. T[[t1 + t2]].. = T[[t1]]..+. \nT[[t2]].. T[[Fc l i0 ...ik]].. =.(Fc l )(I[[i0[.]]]) ...(I[[ik[.]]]) T[[cond br0 |... |brk]].. = max.{B[[br0]]..,...,B[[brk]]..} \nB[[(F1 ..aa: as.F2 .t)]].. = L0. if F1[.]isfalse B[[(F1 ..aa: as.F2 .t)]].. = max.{T[[t]]..[aa .az] |az \n.I[[as]] . F2[.[aa .az]]} if F1[.]istrue Figure 9: Semantics of recurrence equations The typing rules \nfor recurrence equations are straightfor\u00adward and have been omitted. 4.3.2 Semantics We give a simple \ndenotational semantics to the language of recurrence equations. A recurrence equation of type s0 .s1 \n....sk .C is interpreted in the domain of continuous functions [I[[s0]] .I[[s1]] ....I[[sk]] .C.]. Here \nI[[\u00b7] is the canonical semantics given to ground index objects i and index types s by the constraint \ndomain Z. With C. we denote the domain that results from interpret\u00ading C as a discrete domain and lifting \nit in the canonical way in the semantics de.nition we also mark operations on C that have been lifted \nin the canonical way by sub\u00adscripting them with .. Figure 9gives asemantics T[[\u00b7]].. for recurrence-equation \nexpressions, where . is a mapping from recurrence-equation names to functions and . an index substitution. \nThe seman\u00adtics treats a conditional by taking the maximum of the values returned by the branches of the \nconditional. If the guard of a branch does not hold, the branch returns 0.Otherwise, all possible values \nfor the universally quanti.ed index variables in the branch are tried out and the maximum is returned. \nBecause, as required in Section 4.3.1, there are at most a .nite number of such values, the semantics \nof a branch is well-de.ned (we assume that max .\u00d8= L0.). Given the de.nition of a recurrence equation \nFc a0 a1 ...ak = t and a mapping . that ranges over all recurrence-equation names that occur in texcept \nFc, the semantics of the de.ned function is the .xed point of the functional .F..n0 n1 ...nk.T[[t]](.[Fc.F])[a0,...,ak \n.n0,...nk]. This semantics of a single recurrence equation extends naturally to a system E of recurrence \nequations and yields a mapping from recurrence-equation names to functions; we write S[[E]].  4.4 The \nextraction algorithm We extract cost recurrences from DML.0 (Z)type deriva\u00adtions. A DML.0 (Z) typing \njudgment is of the form f;G f e: t, where f is an index context and G is a variable context (see Appendix \nA for details). The central part of the extraction algorithm operates on the type derivations for the \nbodies of function de.nitions F1 ...Fn: From an expression e of .rst-order type that occurs within the \nbody of a function de.nition, a recurrence-equation expression t of type C is extracted. The algorithm \nis de.ned in form of a judgment f;G f e: . . t. Consider the following de.nition of a function F (see \nFig\u00adure 7a): let F = .x F :. a0 : .0.... al : .l ..1 ..2. lam x: .1 .case x of (x0,...,xk).body Assuming \nthat body is typed as f;Gfbody :.2, the extracted recurrence equation is Fc a0 ...al = t,where t results \nfrom f;G f body : .2 . t. Most rules are fairly straightforward. For example, ac\u00adcessing a variable or \nthe unit value has no cost: f;G f x: t . 0 f;G f(): 1 . 0 The cost of executing a user-de.ned function \nF has three components: the cost of evaluating its argument, the cost cF of calling the function, and \nthe cost incurred by evaluating the function. For the latter component, a recursive call with the appropriate \narguments is generated: f;G f e: .1 . t f;G f F[i1] ...[ik](e): .2 . t+ cF +(Fci1 ...ik) The heart of \nthe extraction algorithm is displayed in Fig\u00adure 10. It shows how to convert a case expression into a \nconditional: Each branch of a case expression is turned into a branch of the resulting conditional. The \nrule that handles branches extracts a conditional branch from a type deriva\u00adtion for a branch of a case \nexpression: f;G f (p.e): . ' ... This judgment types the branch of a case expression that matches a pattern \np against a value of type . ' ; the expres\u00adsion e in the branch has the same type . as the total case \nexpression. Before we examine the corresponding rule of the extraction algorithm in detail, we explain \nhow to extract constraints from index contexts. 4.4.1 Turning an index context into a constraint DML.0 \n(Z) expressions are typed under a normal context and an index context of form f::= \u00b7|| f,a: .| f,P (See \nFigure 2). Basically, the index context collects con\u00adstraints over index variables. It is straightforward \nto de.ne a function C that rewrites an index context f intoacon\u00adstraint F such that sort de.nitions are \n.attened out , i.e., C(a: {k : N |k>0},b: {k : {k ' : N |k ' >1}|k =a})= = a> 0 .b> 1 .b =a A useful \noperation over constraints is to project out acer\u00adtain set of variables, i.e., hide all remaining variables \nby existential quanti.cation. We write .aa.F for the constraint that results from existentially quantifying \nover the variables a in F. With a constraint solver such as used for DML type-checking, existentially \nquanti.ed variables usually are simpli.ed away. Often equalities can be derived from a constraint F. \nLet a be a subset of the free variables in F; we de.ne a substitution . := mk substa(F) as follows: For \nall a.a such that i is an index expression without free variables in a ,and a = i can be derived from \nF, we have .(a)= i. f;G fe: . ' t f;G f(p0 .e0): . ' .. br1 . . . f;G f(pk .ek): . ' .. brk f;G f(case \ne of p0 .e0 |...|pk .ek): . t+(cond br1 |br2 |... |brk) p.. ' . (f ' ;G ' ) f,f ' ;G,G ' fe: .t F1 = \n.(dom(f,f ' )\\var(. ' )).C(f,f ' ) . = mk substdom(f.)(C(f ' )) F2 = .(dom(.)).C(f ' ) f;G f(p.e): . \n' .. F1 ..(dom(f ' )\\dom(.)).F2 .t[.] Figure 10: The heart of the extraction algorithm 4.4.2 The heart \nof the algorithm Now we return to the second rule of Figure 10 and explain its premises one by one. 1. \nThe judgment p.. ' . (f ' ;G ' ) is de.ned as part of the DML.0 (C) type-checking rules. It generates \nan index context f ' and a variable context G ' that describe the index variables and normal variables \noccurring in the pattern p. For example, after translation into DML.0 (Z), the pat\u00adtern of the second \nbranch in flatten (Figure 1 and Section 3.2) is lcons[m ' ][n1][n2](xs,rest ); type-checking under index \ncontext f= m: N,n : N generates the fol\u00adlowing index context: '' ' f = m : N,n1 : N,n2 : N,m = m +1,n= \nn1 + n2. 2. DML.0 (C) type-checking types the branch expression under the contexts f,f ' and G,G ' . \nFrom the resulting type derivation, a recurrence-equation expression t is extracted. For the second branch \nof flatten, this yields t=2+(appendc n1 n2)+(.attenc m ' n2) 3. The guard of the branch F1 is derived \nby projecting out from C(f,f ' ) over the index variables contained in . ' . In flatten, the only index \nvariable in . ' = llist(m,n) are m and n; projecting them out yields m> 0. For n there is no information, \nbecause we only know that n .N, and (as pointed out in Section 3.1) we require all indices to be of subsorts \nof N anyways. 4. All index variables declared in f ' that can be expressed in terms of index variables \nfrom f should be are elimi\u00adnated using substitution .: In the branch returned by the rule, the body is \nt[.] rather than t. For the second branch of flatten,we can infer that m ' = m-1, so . =[m ' .m-1]. \n 5. Index variables declared in f ' for which no equality constraint can be derived have to be restricted. \nThis is done by (1) hiding the variables dom(.) via existen\u00adtial quanti.cation in C(f ' ), and (2) universally \nquanti\u00adfying over the remaining variables of dom(f ' ), binding variables both in F2 and in t[.]. Conjuncts \nin F2 con\u00adtaining none of the universally quanti.ed variables can be dropped.  For the second branch \nof flatten, existential quan\u00adti.cation over m ' in f ' yields, after normalization, m>0 .n = n1 + n2. \nWe universally quantify over n1 and n2, and drop the conjunct m>0. To complete the running example: The \nsecond branch of flatten gives rise to the following branch of the conditional in .attenc: m>0 ..n1,n2 \n: N.n1 + n2 = n . 2+(appendc n1 n2)+(.attenc (m-1) n2) 4.4.3 Checking whether the bound is a recurrence \nIt remains to check whether we really extract a recurrence, i.e., a function de.ned in terms of its value \non smaller ar\u00adguments. For the presented language without mutual re\u00adcursion (for handling mutual recursion, \nXi s most recent work [14] could be adapted see Section 5), this can be con\u00adveniently done during extraction \nwhen generating a recur\u00ad sive call Fc i1 ...ik inside the body that de.nes Fc a1 ...ak: The extraction \nyields a recurrence if for every such call, (i1,...,in)<(a1,...,an) can be derived from the collected \nconstraints for a well\u00adfounded order < on tuples. In practice, one could .x for example the usual lexicographic \nordering, requiring the user to enrich data correspondingly, or leave the user a choice as to which ordering \nshould be used. 4.4.4 Correctness The following theorem captures the correctness of the ex\u00adtraction \nalgorithm: Theorem 1 Let functions F1,...,Fk be a well-typed block of function de.nitions. Let E be the \nsystem of recurrence equations for F1 c,...,Fkc extracted from these de.nitions. Let p be a well-typed \nprogram consisting of these function de.ni\u00adtions F1,...,Fk and a program body Fl[z1] ...[zl. ](u),where \nz1,...,zl. are ground index objects and u is a value. Then, if T [[Flc z1 ...zl. ]](S[[E]])[] = Lz ' \n. then there exists a value v and z . C such that p * evalu\u00adates to (v,z) under the semantics of DML.0 \n(C),and z = z ' . Further, if during extraction it has been checked that the ex\u00adtracted bounds are recurrences \nas described in Section 4.4.3, Fc ' z1 ...zl. is guaranteed to yield a result Lz .. Because the translation \n(\u00b7) * (see Section 4.2) captures our cost model in the translated program, a cost counter z is calculated \ntogether with the actual result the theorem shows that Flc indeed is a cost bound for Fl. The proof [5] \nuses structural induction over the derivations of the extrac\u00adtion algorithm and .xed-point induction \nover the semantics de.nition for recurrence equations.   5. RELATED WORK We discuss related work regarding \nautomated complexity analysis and type systems. Le M\u00b4etayer s ACE system [6] automatically extracts cost \nbounds for a subset of FP, expressing the extracted bounds as FP programs. The system is based on program \ntrans\u00adformation. The .rst step transforms the original program into a step-counting version, i.e., a \nprogram that takes the same arguments, but returns the cost of computation for these arguments rather \nthan the result. Subsequent trans\u00adformation steps try to transform the step-counting version into a composition \nof a cost bound and a measure function, where the measure function is composed from selector func\u00adtions \nand the length function for lists. The principal goal of the ACE system is to eliminate recursion in \nthe cost bound, which corresponds to solving recurrences; the system s li\u00adbrary holds more than 1000 \ntransformation rules, many of them tailored to recognize patterns of recursion. The pro\u00adcess of .nding \na measure function is interleaved with the process of eliminating recursion and cannot easily be decou\u00adpled. \nPointing the system to a given measure thus seems di.cult. In contrast, our method separates concerns: \nThe user can specify an appropriate measure using dependent types, but no attempts are made to solve \nthe extracted cost recurrence. Rosendahl [9] develops a system that uses abstract inter\u00adpretation and \nprogram transformation techniques to extract cost bounds from a .rst-order subset of Scheme. An abstract \ninterpretation is used to extend the set of S-expressions with partially known structures unknown parts \nof a structure are represented by a special token that stand for all possible structures. Size measures \nare expressed through inverse size functions : For a given size, an inverse size function returns a partially \nknown structure that approximates all data structures of that size. For example, for lists, the in\u00adverse \nsize function generates for size n a list containing n times the special token representing all possible \nstructures. An initial cost bound for a program is achieved by (1) com\u00adposing a suitable inverse size \nfunction with the abstract in\u00adterpretation of the step-counting version of the program and (2) taking \nthe term model. Program transformation is then used to simplify this initial cost bound as much as possible. \nLiu and G\u00b4omez [7] propose a method based on Rosendahl s work in which they use advanced program-transformation \ntechniques to make the cost bound more e.cient and more accurate. Both methods requires the user to de.ne \nthe ab\u00adstraction from datatodatasize. However, with dependent types, measures can be expressed that are \nimpossible to de\u00ad.ne with an inverse size function the measure used in Sec\u00adtion 3.2 for analyzing flatten \nis one example. Reistad and Gi.ord [8] use an e.ect type system for au\u00adtomatically inferring cost estimates \nof functional programs written with combinators such as map and fold. Two in\u00addexed data-types, lists \nand vectors, are built into the type system. The e.ects associated with function types are cost expressions \nthat may depend on indices of list/vector argu\u00adments and on cost expressions associated with function \nar\u00adguments. The main focus of Reistad and Gi.ord is to guide parallelization of programs with the inferred \ncost estimates. Crary and Weirich [3] present a decidable type system for the speci.cation and certi.cation \nof resource consump\u00adtion in the setting of Typed Assembly Language. The type system simulates dependent \ntypes using sum and inductive kinds. Essentially, it allows the user to annotate function arrows with \nresource bounds (e.g., time bounds or space bounds) in terms of the shape of data arguments and of cost \nbounds associated with function arguments. The fo\u00adcus lies on the certi.cation of resource bounds through \ntype checking rather than the derivation of resource bounds. Chin and Khoo [2] propose sized types in \nwhich size infor\u00admation is expressed with Presburger formulas. They use a a constraint solver to infer \nsize information. It is very likely that complexity analysis in the style of this paper could be integrated \ninto their setting. Recently, Xi [14] presented an extension of the DML type system that allows program \ntermination veri.cation. The basic observation is the same as for our work, namely that DML types can \nbe used to encode a notion of input size. For each function, the programmer supplies a metric in terms \nof the input indices; if type checking succeeds, the metrics are guaranteed to specify a termination \norder. Both higher\u00adorder functions and general recursion are handled. We be\u00adlieve that our work would \nbene.t substantially from refor\u00admulating it in this extended type system: As an immediate bene.t, extracted \ncost bounds could be easily veri.ed to be recurrences also for general recursion. Also an extension of \nthis work to higher-order functions, if possible, should be easier within Xi s new type system, though \nof course our work handles defunctionalized programs (`ala Reynolds) and thus, indirectly, higher-order \nfunctions. 6. CONCLUSION We have presented a method for automatically extracting cost recurrences from \n.rst-order DML programs. The dis\u00adtinct feature of our method is the use of dependent types to describe \na size measure that abstracts from data to data size. The user has to choose an appropriate size measure \nfor our method to successfully extract a cost recurrence. Because of the high expressiveness of its types, \nDML o.ers high .ex\u00adibility for tailoring size measures. The required DML type annotations usually are \neasy to .nd: Because size measures encode shape information of data types, they closely corre\u00adspond to \nthe programmer s intuitive understanding of how his program works. Our method harnesses this intuition \nfor automatic cost analysis. Acknowledgments I am indebted to Olivier Danvy, Julia Lawall and Zhe Yang \nfor their encouragement and fruitful discussions on the sub\u00adject of this work. Further thanks are due \nto Olivier Danvy, Andrzej Filinski and Julia Lawall for their numerous con\u00adstructive comments. I am also \ngrateful to the anonymous referees and Neil Jones for further comments. 7. REFERENCES [1] Lennart Augustsson. \nCayenne a language with dependent types. In Paul Hudak and Christian Queinnec, editors, Proceedings of \nICFP 98, pages 239 250, Baltimore, Maryland, September 1998. ACM Press. [2] Wei-Ngan Chin and Siau-Cheng \nKhoo. Calculating sized types. Higher-Order and Symbolic Computation, 14(2/3), 2001. To appear. [3] Karl \nCrary and Stefanie Weirich. Resource bound certi.cation. In Thomas Reps, editor, Proceedings of POPL \n00, pages 184 198, Boston Massachusetts, January 2000. ACM Press. [4] Andrzej Filinski. Representing \nmonads. In Hans-J. Boehm, editor, Proceedings of POPL 94, pages 446 457, Portland, Oregon, January 1994. \nACM Press. [5] Bernd Grobauer. Cost recurrences for DML programs. Technical Report RS-01-25, BRICS, Department \nof Computer Science, University of Aarhus, 2001. [6] Daniel Le M\u00b4etayer. ACE: An automatic complexity \nevaluator. ACM Transactions on Programming Languages and Systems, 10(2):248 266, April 1988. [7] Yanhong \nAnnie Liu and Gustavo G\u00b4omez. Automatic accurate time-bound analysis for high-level languages. In Frank \nMueller and Azer Bestavros, editors, Proceedings of LCTES 98, number 1474 in LNCS, pages 31 40, Montr\u00b4eal, \nCanada, June 1998. Springer-Verlag. [8] Brian Reistad and David K. Gi.ord. Static dependent costs for \nestimating program execution time. In Carolyn L. Talcott, editor, Proceedings of LFP 94, LISP Pointers, \nVol. VII, No. 3, Orlando, Florida, June 94. ACM Press. [9] Mads Rosendahl. Automatic complexity analysis. \nIn Joseph E. Stoy, editor, Proceedings of FPCA 89, pages 144 156, London, September 1989. ACM Press. \n[10] Philip Wadler. The essence of functional programming. In Andrew W. Appel, editor, Proceedings of \nPOPL 92, pages 1 14, Albuquerque, New Mexico, January 1992. ACM Press. [11] Hongwei Xi. de Caml. A prototype \nimplementation of DML, based on Caml-light. Available from http://www.ececs.uc.edu/~hwxi/DML/DML.html. \n[12] Hongwei Xi. Dependent Types in Practical Programming. PhDthesis, Carnegie Mellon University, 1998. \n[13] Hongwei Xi. Dependently typed data structures. In Chris Okasaki, editor, Proceedings of WAAAPL 99, \npages 17 32, Paris, September 1999. Available from http://www.cs.columbia.edu/~cdo/waaapl99.pdf. [14] \nHongwei Xi. Dependent types for program termination veri.cation. In Proceedings of LICS 01, Boston, Massachusetts, \nJune 2001. IEEE Computer Society Press. [15] Hongwei Xi and Frank Pfenning. Dependent types in practical \nprogramming. In Alex Aiken, editor, Proceedings of POPL 99, pages 214 227, San Antonio, Texas, January \n1999. ACM Press. APPENDIX A. DML TYPING RULES A typing judgment for DML.0 (C) has the form f;G f e: \nt. Typing is with respect to a signature S that assigns types to constructors. We restrict the presentation \nof type check\u00ading in DML.0 (C) to typing rules that treat indices the re\u00admaining rules are standard, \nglossing over details such as type-formation rules, well-formedness of contexts, and type\u00adequivalence. \nDetails can be found in Xi s PhD thesis [12, Chapters 2 4]. Figure 11 displays typing rules for constructors, \ncase state\u00adments, index abstraction, and application of an expression to an index object: the rules for \nconstructors and application to an index object use a judgment f f i : . that expresses that i : . can \nbe derived from the index context f;the rule for typing pattern-matching branches uses a judgment p. \nt ' . (f ' ;G ' ) de.ned in Figure 12 to gather information about variables and index variables occuring \nin pattern p. S(c)= . a1 : .1.... ak : .k .d(i) ff i1 : .1 ... f f ik : .k f;G f e: t[a1,...,ak . i1,...,ik] \nf;G f c[i1] ...[ik](e): d(i[a1,...,ak . i1,...,ik]) f;G f e: t ' f;G f (p1 . e1): t ' . t . . . f;G f \n(pk . ek): t ' . t f;G f (case e of p1 . e1 | ... | pk . ek): t p. t ' . (f ' ;G ' ) f,f ' ;G,G ' f e: \nt f;G f (p. e): t ' . t f,a: .;G f e: t f;G f (.a: ..e): . a: ..t f;G f e:. a: ..t ff i : . f;G f e[i]: \nt[a. i] Figure 11: Typing rules for DML. 0 (C) x. t . (\u00b7; x: t) () . 1 . (\u00b7; \u00b7) p1 . t1 . (f1;G1) p2 \n. t2 . (f2;G2) (p1,p2). t1 \u00d7 t2 . (f1,f2;G1,G2) S(c)= . a1 : .1.... ak : .k .d(i) c[a1] ...[ak] . d(j) \n. (a1 : .1,...,ak : .k,i= j; \u00b7) S(c)= . a1 : .1.... ak : .k .t . d(i) p. t . (f;G) c[a1] ...[ak](p) . \nd(j) . (a1 : .1,...,ak : .k,i= j,f;G) Figure 12: Typing rules for patterns in DML. 0 (C)   \n\t\t\t", "proc_id": "507635", "abstract": "A cost recurrence describes an upper bound for the running time of a program in terms of the size of its input. Finding cost recurrences is a frequent intermediate step in complexity analysis, and this step requires an abstraction from data to data size. In this article, we use information contained in dependent types to achieve such an abstraction: Dependent ML (DML), a conservative extension of ML, provides dependent types that can be used to associate data with size information, thus describing a possible abstraction. We automatically extract cost recurrences from first-order DML programs, guiding the abstraction from data to data size with information contained in DML type derivations.", "authors": [{"name": "Bernd Grobauer", "author_profile_id": "81100236402", "affiliation": "Univ. of Aarhus", "person_id": "P29493", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/507635.507666", "year": "2001", "article_id": "507666", "conference": "ICFP", "title": "Cost recurrences for DML programs", "url": "http://dl.acm.org/citation.cfm?id=507666"}