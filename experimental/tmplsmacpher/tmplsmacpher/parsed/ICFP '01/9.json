{"article_publication_date": "10-01-2001", "fulltext": "\n Generic Validation of Structural Content with Parametric Modules * Tyng-Ruey Chuang Institute of Information \nScience Academia Sinica Taipei 115, Taiwan trc@iis.sinica.edu.tw ABSTRACT WedemonstrateanaturalmappingfromXMLelementtypes \ntoMLmoduleexpressions.Themappingisinductiveand defnitionsofcommonXMLoperationscanbederivedas themoduleexpressionsarecomposed.Weshowhowtode\u00adrive,inagenericway,thevalidationfunction,whichchecks \nanXMLdocumentforconformancetoitsDTD(Document TypeDefnition).OnecanviewvalidationasassigningML typestoXMLelementsandthevalidationprocedureapre\u00adrequisitefortypefulXMLprogramminginML. \nOurmappingusestheparametricmodulefacilityofML insomecontrivedway.Forexample,invalidatingWML (WAPMarkupLanguage)documents,weneedtouse36\u00adarytypeconstructors,aswellashigher-ordermodulesthat \ntakeinasmanyas17modulesasinput.Thatonecansys\u00adtematicallymodelXMLDTDsatthemodulelevelsuggests ML-likelanguagesaresuitablefortype-safeprototypingof \nDTD-awareXMLapplications.  Categories and Subject Descriptors F.3.3[StudiesofProgramConstructs]:Programand \nrecursionschemes. General Terms Design,Languages,Theory.  Keywords fxedpoints,functionalprogramming,modulesandinter-faces,validation,ML,XML. \n* Thisresearchissupported,inpart,byNationalSci\u00adenceCouncilofTaiwan(NSC89-2219-E-001-005)andby theInstituteofAppliedScienceandEngineeringResearch, \nAcademiaSinica(\\WirelessInternetResearchInitiative\"). PartofthisworkwasfacilitatedbyavisittotheSchool \nofComputing,NationalUniversityofSingapore,inJuly-August2000. Permission to make digital or hard copies \nof all or part of this work for personal or classroom use is granted without fee provided that copies \nare not made or distributed for pro.t or commercial advantage and that copies bear this notice and the \nfull citation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. ICFP 01, September 3-5, 2001, Florence, Italy. \nCopyright 2001 ACM 1-58113-415-0/01/0009 ...$5.00. 1. INTRODUCTION &#38; MOTIVATION XML(eXtensibleMarkupLanguage)isalanguagefortag\u00adgingdocumentsfortheirstructuralcontent[2].AnXML \ndocumentistaggedintoatreeofnestedelements.XML isextensiblebecauseeachXMLdocumentcanincludea DTD(DocumentTypeDefnition)whichliststhetagsof \ntheelementsandspecifesthetaggingconstraints.Acen\u00adtralconceptinXMLdocumentprocessingisvalidation.An XMLdocumentisvalidifitisasingle-rootedelementtree \nandtheelementsaretaggedwiththeconstraintsspecifed byitsDTD.AnXMLdocumentiswell-formedifeachofits elementsisenclosedwithamatchingpairofstart-tagand \nend-tag.Awell-formedXMLdocumentisnotnecessarily valid. ThefollowingXMLdocumentcontainsaDTDthatde\u00adfnestwoelementtypesfolderandrecord.Thedocument \ncontainsasarootafolderelement,whichhasanempty recordelementasitsonlychild.ItisavalidXMLdocu\u00adment. <?xmlversion=\"1.0\"?> \n<!DOCTYPEfolder[ <!ELEMENTfolder((record,(folder|record)*)| (folder,(folder|record)+))> <!ELEMENTrecordEMPTY> \n]> <folder><record></record></folder> TheDTDintheaboveXMLdocumentmodelsthestruc\u00adturewherearecordmustcontainnootherelement,andno \nfolderiseveremptyorcontainsjustonefolder.Onemay thinkofitasmodelingatidybookmarkfle.Ofthefol\u00adlowingthreeelements,f3isvalid,butitemsf1andf2are \nnot. f1<folder></folder> f2<folder><folder><record></record></folder> </folder> f3<folder><folder><record></record></folder> \n<record></record></folder> Thetagsequence<record><folder></record></folder>is anexampleofnot-well-formedness. \nTosimplifydiscussion,wemaysaythateachelementtype intheDTDisspecifedbyitselementcontentmodel(i.e., itstaggingconstraint)whichisaregularexpressionwiththe \nelementtypenamesassymbols.Thecontentmodelofan elementtypespecifeswhatelementsequencesareallowed asthechildrenoftheelement.Naturally,whencodingXML \nprograms,oneneedstomaptheelementtypesinaDTDto thecorrespondingdatatypesintheprogramminglanguage. Afurtherrequirementofthemappingisthatcontentvalida\u00ad \ntionistranslatedintotypecorrectnessintheprogramming languagesothatwell-typedprogramswillalwaysproduce \nvalidXMLelements.Noticethatthisgoesbeyondwhatis requiredoftheso-called\\validatingXMLprocessor\",which \nneedonlyreportviolationsofelementcontentmodelsinthe inputXMLdocumentbutneednotimposerestrictionson theoutput. \nTherearemanyresearchworksonprogramminglanguage supportsforbuildingXMLapplications.Weclassifythem intothefollowingthreecategories. \nADTforwell-formedelements.Abstractdatatypesand theassociatedlibraryroutineshavebeendesignedto traverseandtransformwell-formedXMLelements.The \nXMLdataisassumedtobevalidatedinaseparate phase,oritsvalidationisaseparateissueandmaynot evenberequired.Examplesinthiscategoryinclude \nstandardXMLAPIinC++,Java,orotherlanguages (e.g.,DocumentObjectModel,DOM[1])andacombi\u00adnatorapproachtowritingXMLprocessingfunctional \nprograms[24]. TypetranslationofDTD.Astronglytypedlanguageis usedforXMLprogrammingandthetypesystemofthe \nlanguageisusedtoembedDTDs.Examplesinthis categoryincludeHaXml[24],PaX[21],andXM>[18]. Ifthestronglytypedlanguageisstaticallytyped,then \nnotype-checkedprogramwillproduceinvalidXML elements.Onecanalsouselogicprogramminglan\u00adguagestoencodeXMLcontentmodelsinasimilar \nway[25].Thetypetranslationapproachisnotcom\u00adpletelysatisfactoryfortworeasons.Oneisthatthe typetranslationschememaynotbesystematic.The \nprocesscanbetediousifdonemanually.Theother inconvenienceisthatcodeforgenericXMLprocessing operationsneedtoberewrittenforeveryDTDbecause \ntheyaretranslatedintodiferenttypes.XMLcontent validation,whichcheckwell-formedXMLdocuments forconformancetotheirDTDs,issuchagenericop\u00aderation. \nNativelanguagesupportofDTD.Newlanguageshave beendesignedwithbuiltinXMLsupportstohelpbuild XMLapplications.XDuceisafunctionallanguage \nwithregularexpressiontypessoastoallowdirectrep\u00adresentationsofDTDsandprocessingofvalidelements [14,15].Expressionsinthelanguageareevaluatedto \nvalidXMLelements,butvariablesmustbeannotated withtheirelementtypes.Theconceptofvalidationis builtintothelanguageastypecorrectness,andpro\u00adgramsaretype-checkedatcompile-time.XDucealso \nprovidesregularexpressionpatternswhichfurtherhelp writeconciseXMLprograms.XDuce,however,iscur\u00adrentlyafrst-orderandmonomorphiclanguage,and \nlackssomelanguagefeatures(e.g.,amodulesystem). AnXMLquerylanguageisbeingdevelopedaround thetypesystemofXDuce[11]. \nInthispaper,weshowhowtouseparametricmodulesin ML-likelanguagestowriteXML-supportingprogrammod\u00adulesthatarebothexpressiveandgeneric.Itisexpressive \nbecauseallXMLDTDscanbeconstructedfromthepara\u00admetricmodules.Itisgenericbecausecommonoperations, includingthevalidationfunction,areautomaticallygener\u00adated.Assuch,ourapproachhastheadvantagesofboththe \ntypetranslationapproachandthenativeDTDsupportap\u00adproach,butwithouttheirdisadvantages.Thereisnoneed torecodegenericoperations,andnoneedtodesignnew \nlanguages. 2. AN ILLUSTRATING EXAMPLE ForthetidybookmarkexampledescribedinSection1,the followingistheactualcodewewriteinObjectiveCaml[22] \ntospecifytheDTD,andtoproducethevalidationfunctions forthetwoelementtypesintheDTD. moduleBookmarkTag= \nstruct type('x0,'x1)t=Folderof'x0 |Recordof'x1 letmap(f0,f1)t= matchtwith Folderx->Folder(f0x) |Recordx->Record(f1x) \nend moduleTidySys= struct moduleF0=Alt(Seq(P1)(Star(Alt(P0)(P1)))) (Seq(P0)(Plus(Alt(P0)(P1)))) moduleF1=Empty \nmoduleTag=BookmarkTag end moduleTidyDtd=Mu(TidySys) TheabovemoduleTidySyscontainstwomodulesF0and F1,whicharetranslations,wordbyword,inObjectiveCaml \nmodulelanguagetheXMLelementtypedeclarationsoffolder andrecord.Thehigher-ordermoduleAltisfor\\|\",Seq for\\,\",Starfor\\*\",andPlusfor\\+\".Ideally,wewould \nliketodefnethetwoXMLelementtypesastwomutually recursivemodulesT0andT1asthefollowing. modulerecT0=Alt(Seq(T1)(Star(Alt(T0)(T1)))) \n(Seq(T0)(Plus(Alt(T0)(T1)))) andT1=Empty ButObjectiveCaml,asmanyML-likelanguages,doesnot supportrecursivemodules.Insteadweusetwo\\placeholder\" \nmodulesP0andP1asthetwoparameterstohigher-order modulesAlt,Seq,etc.,anduseanotherhigher-ordermod\u00aduleMu(pronouncedasf)toderivethetwosimultaneous \nfxedpoints. ModuleTidyDtdcontains amoduleU,whichdefnesthetypeforwell-formed elements;  amoduleV,whichcontainsmodulesT0andT1that \neachdefnesthetypeforvalidfolderandrecordele\u00adments,respectively;  functionsvalidateandforget,whichprovidemap\u00adpingsbetweenwell-formedelementsandvalidelements. \n ItalsodefnesexceptionInvalid,whichmayberaised byfunctionvalidate.Noticethatthefollowingequa\u00adtionsalwayshold \nforget0validate id,(mayraiseexception) validate0forget id Thefolderelementf3fromSection1cannowbedefned \nandvalidatedbythefollowingObjectiveCamlcode(f3 uis well-formedandf3 visvalid):1 let f3_u=folder[folder[record[]];record[]] \nlet f3_v=TidyDtd.validatef3_u Inaddition,thevalidelementreturnedbythevalidation functionisparsedandtypedinthesensethatallofitssub\u00adstructuresaregivenspecifcMLtypesandcanbeextracted \nbyMLpattern-matching. Inthispaper,wewillusetheaboveexampletoexplain theideaanddescribetheconstruction.However,theidea \nandtheconstructioncanbesystematicallyappliedtoDTDs withnelementtypes.Oneneedsjusttodefnean-aryfxed pointmoduleMunthatwilltakeasystemofnn-arymod\u00adulesF0,F1,:::,Fn;1,andproducethesimultaneousfxed \npoints.ThedefnitionofMunissymmetricandissimilarto Mu.WewilllateruseWML(amarkuplanguageforwire\u00adlessapplicationswhoseDTDdefnes35elementtypes)as \nabenchmarkingexampletoshowtheefectivenessofour approach. 3. SYSTEMATIC TRANSLATION OF XML ELEMENT TYPES \nTO ML TheXMLelementtypesinthefolderexamplecanbe translatedintoObjectiveCamlusingaseriesoftypedefni\u00adtionsasshownbelow. \ntype ('a,'b)alt=Lof'a|Rof'b type ('a,'b)seq='a*'b type 'astar='alist type 'aplus=Oneof'a|Moreof'a*'aplus \ntype folder=Folderof ((record,(folder,record)altstar)seq, (folder,(folder,record)altplus)seq)alt and \nrecord=Record Onecanabstracttwobinarytypeconstructorsf0andf1 fromtheright-handsidesofthetypeequationsforfolder \nandrecord,andviewfolderandrecordastheleastfxed pointsoff0andf1. type ('a,'b)f0=(('b,('a,'b)altstar)seq, \n('a, ('a,'b)altplus)seq)alt type ('a,'b)f1=unit type folder=Folderof(folder,record)f0 and record=Recordof(folder,record)f1 \n1Functionsfolderandrecordaredefnedby let folderulist=BookmarkTag.Folder (TidyDtd.U.upulist) let recordulist=BookmarkTag.Record \n(TidyDtd.U.upulist) ThiswillbemadeclearinSection5. Onecanfurtherrewritef0andf1usingthetwo\\projection\" \ntypeconstructorsp0andp1,andthe\\null\"typeconstructor empty. type ('a,'b)p0='a type ('a,'b)p1='b type (`a,'b)empty=unit \ntype ('a,'b)f0= ((('a,'b)p1, (('a,'b)p0,('a,'b)p1)altstar)seq, (('a,'b)p0, (('a,'b)p0,('a,'b)p1)altplus)seq)alt \ntype ('a,'b)f1=('a,'b)empty Atthispoint,itbecomesclearthatonecanprogramXML elementtypesattheMLmodulelevel.Wecandefnetype \nconstructorsf0andf1viatwomodulesF0andF1,each composedfromapre-defnedandreusablesetofconstant modules(forp0,p1,empty,etc.),unaryparametricmodules \n(forstar,plus,etc.),andbinaryparametricmodules(for alt,seq,etc.).Eachofthesemoduleswilldefne,inan inductiveway,abinarytypeconstructorcalledt,aswellas \nfunctionsforcomputingt{typedvalues(likefunctionmap). Figure1containsacodefragmentthatdefnesthereusable \nmodules,andusesthemtocomposetwomodulesF0andF1, fromwhichthetwoXMLelementtypesfolderandrecord arederived. \n 4. GENERIC PROGRAMMING WITH PARA-METRIC MODULES InFigure1,weusethemoduletypeFUNtospecifymod\u00adulesthatdefnesbothabinarytypeconstructortanda \nfunctionmap.ThemoduletypeF2Fspecifesparametric modulesthateachtakesinaFUNmoduleasinputandre\u00adturnsaFUNmoduleasoutput.ThemoduletypeF2F2Fspec\u00adifesparametricmodulesthateachtakesintwoFUNmodules \nandreturnsaFUNmodule.Similarly,onecandefnemodule typesF2F2F2FthattakesinthreeFUNmodulesasinput,and soon. \nThemapfunctionineachFUNmodule(i.e.,Empty,P0,and P1)isdefnedinsuchawaythatitpreservesidentityand functioncomposition: \nmap(ida,id() id(a,()t map(f0,g 0)0map(f,g) map(f00f,g 00g) whereaandjaretypes,andtthebinarytypeconstructor \ndefnedintheFUNmodule. Furthermore,forF2FmoduleslikePlusandStar,the mapfunctionofthereturnedmoduleisdefnedtopreserve \nidentityandfunctioncompositionaswell,aslongasthemap functionintheinputmodulepreservesidentityandfunction \ncomposition.Similarly,forF2F2FmoduleslikeAltandSeq, thereturnedmapfunctionpreservesidentityandfunction \ncompositionifbothofthetwoinputmapfunctionspreserve identityandfunctioncomposition. WemaysaythatFUNmodulesareobjectsinafunctor \ncategorywhereeachobjectconsistsofabinarytypecon\u00adstructorttomaptypestotypes,andafunctionmaptomap typedfunctionstotypedfunctions.Parametricmodules, \nwhosemoduletypesareF2ForF2F2F,are(endo)functorin thefunctorcategory:TheymapFUNmodulestoFUNmod\u00adules. moduletypeFUN= \nsig type('a,'b)t valmap:('a->'x)*('b->'y)-> ('a,'b)t->('x,'y)t end moduletypeF2F=functor(F:FUN)->FUN \nmoduletypeF2F2F=functor(F0:FUN)-> functor(F1:FUN)->FUN moduleEmpty:FUN= struct type('a,'b)t=unit letmap(f,g)t=() \nend moduleP0:FUN= struct type('a,'b)t='a letmap(f,g)t=ft end modulePlus:F2F=functor(F:FUN)-> struct type('a,'b)t= \nOneof('a,'b)F.t |Moreof('a,'b)F.t*('a,'b)t letrecmap(f,g)t= matchtwith Ones->One(F.map(f,g)s) |More(v,w)-> \nMore(F.map(f,g)v,map(f,g)w) end moduleSeq:F2F2F=functor(F0:FUN)-> functor(F1:FUN)-> struct type('a,'b)t=('a,'b)F0.t*('a,'b)F1.t \nletmap(f,g)(u,v)=(F0.map(f,g)u, F1.map(f,g)v) end moduleP1:FUN=... moduleStar:F2F=... moduleAlt:F2F2F=... \nmoduleF0:FUN=Alt(Seq(P1)(Star(Alt(P0)(P1)))) (Seq(P0)(Plus(Alt(P0)(P1)))) moduleF1:FUN=Empty typefolder=Folderof(folder,record)F0.t \nandrecord=Recordof(folder,record)F1.t Figure1:De.neXMLelementtypesusingMLpara\u00admetricmodules. Note:Formodulenamesnotactingasformalparameters, \ntheirmoduletypeannotationscanbe,andoftenare,omit\u00adted.Forexample,onecanerasethe\\:F2F\"partin \\modulePlus:F2F=:::\"andatthesametimeexpose \ntheimplementationofmodulePlus.Themoduletypean\u00adnotationisaddedforclarityandtype-checkingpurposes. Weviewthisdefnitionofthemapfunctionageneric \none.EachFUNmodulecomposedfromthepre-defnedFUN, F2F,F2F2Fmoduleswillalwaysdefneamapfunctionthat preservesidentityandfunctioncomposition.Thatis,the \ngenericmapfunctionisacollectionofuniformfunctionsin\u00addexedbypropermoduleexpressions. 5. PARAMETRIC CONTENT \nMODELS AND SIMULTANEOUS FIXED POINTS InFigure1,modulesF0andF1eachdefnesabinarytype constructort,andthethetwotypeconstructorsareused \ntogethertomutuallydefnetypesfolderandrecord.The codeisreproducedbelow. moduleF0:FUN=Alt(Seq(P1)(Star(Alt(P0)(P1)))) \n(Seq(P0)(Plus(Alt(P0)(P1)))) moduleF1:FUN=Empty type folder=Folderof(folder,record)F0.t and record=Recordof(folder,record)F1.t \nThetypeconstructorsF0.tandF1.tareparametriccontent modelsinthesensethateachmapsapairoftypeinstancesto \nacontentmodel.Forexample,giventypeinstancesfolder andrecord,thetypeexpression(folder,record)F0.t expandsto \n((record,(folder,record)altstar)seq, (folder,(folder,record)altplus)seq)alt whichisexactlythecontentmodelforelementtypefolder. \nThekeyideaistousetypeconstructorsasparametric contentmodels,andviewXMLelementtypesassimulta\u00adneousfxedpointsofasetofparametriccontentmodels. \nThisviewpointhelpsusconcentrateonfunctionalprimi\u00adtivesthatdealwithasetof(fxed-arity)typeconstructors. \nTheseprimitivesarepolymorphic,henceapplicabletovari\u00adousinstancesof(fxed-arity)contentmodels.Oneofthese \nprimitivesisthesimultaneousinductionoperator|thefold function.WewilllatershowthattheXMLvalidationpro\u00adcedurecanbedefnedbyusingthefoldfunction. \nThesimultaneousfoldfunctionwillbegeneratedbya parametricmodulewhenevergivenasinputasetofmodules defningtheparametriccontentmodels.Inordertodoso, \nweneedtoabstractawayfromthenamingoftype(folder andrecord)andvalueconstructor(FolderandRecord)of theXMLelementtypes.Wecanmodeltworecursivelyde\u00adfnedXMLelementtypesbytwointerdependentmodules \nT0andT1whicheachdefnesatypetfortheelementtype. ModuleT0andT1willhavethefollowingrecursivemodule types. \nmodulerecT0:sig type ('x0,'x1)cm=('x0,'x1)F0.t type t val up:(T0.t,T1.t)cm->T0.t val down:T0.t->(T0.t,T1.t)cm \nend and T1:sig type ('x0,'x1)cm=('x0,'x1)F1.t type t val up:(T0.t,T1.t)cm->T1.t val down:T1.t->(T0.t,T1.t)cm \nend Theabovetypeconstructor('x0,'x1)cmisforparamet\u00adriccontentmodels,andtypetisforelementtypes.Func\u00adtionsupanddownconvertbetweenanXMLelementandits \ninternalstructure,andtogetherdefnetheirequivalence: down0upid up0downid Asanexample,thepreviousMLtypesfolderandrecord \narenowT0.tandT1.t,andthevalueconstructorFolderis replacedbyfunctionsT0.upandT0.down. Theaboverecursivemoduletypedefnitions,however, \narenotallowedinObjectiveCaml(asinmanyML-like languages).Nevertheless,onecanusebothauxiliarytype namesandadditionaltypesharingconstraintstoovercome \nthisrestriction: type t0 type t1 moduleT0:sig type ('x0,'x1)cm=('x0,'x1)F0.t type t=t0 val up:(t0,t1)cm->t0 \nval down:t0->(t0,t1)cm end moduleT1:sig type ('x0,'x1)cm=('x0,'x1)F1.t type t=t1 val up:(t0,t1)cm->t1 \nval down:t1->(t0,t1)cm end Wecannowdefneahigher-ordermoduleMuValidthat derivesmodulesT0andT1whenevergivenamodulespecify\u00adingthesetofparametriccontentmodelsandthetagset,see \nFigure2.InFigure2,modulesF0andF0oftheinputmod\u00aduleSspecifytheparametriccontentmodels,andmoduleTag specifesthetagset.Noticethat,inthemodulereturnedby \nMuValid,typest0andt1arestilldefnedassimultaneous fxedpointsofthetwoparametriccontentmodels: type t0=V0of(t0,t1)S.F0.t \nand t1=V1of(t0,t1)S.F1.t Thetypeforallvalidelementsissimplydefnedasthedis\u00adjointsumofT0.tandT1.t: type \nt=(t0,t1)Tag.t Thesimultaneousfoldfunctionhastype val fold:(('a,'b)T0.cm->'a)* (('a,'b)T1.cm->'b)-> (T0.t->'a)*(T1.t->'b) \nFunctionfoldreturnswithtworeductionfunctions(whose typesareT0.t->'aandT1.t->'b)ifgiventwoproperly typedinductionfunctionsasbases(whosetypesare('a, \n'b)T0.cm->'aand('a,'b)T1.cm->'b). Similarly,ahigher-ordermoduleMuWFcanbedefnedto deriveamoduleforallwell-formedelements,seeFigure3.In \nmoduleMuWF,typeconstructor('x0,'x1)cm|thepara\u00admetriccontentmodelforwell-formedelements|isdefned asalistoftaggedvalues: \ntype ('x0,'x1)cm=('x0,'x1)Tag.tlist andtypeu|thetypeforwell-formedelements|isdefned asthefxedpointoftheparametriccontentmodelcm: \ntype u=Uof(u,u)cm Noteaswellthattypeofallwell-formedelements,typet, isdefnedasthedisjointsumofuandu,meaningthatthe \nelementscomewithtwodistincttags.Thedefnitionofthe simultaneousfoldfunctionisthesameasthatinmodule MuValid. \nInFigure3,thereareseveralfunctionsinmoduleU2V andV2Uthataregiventheirtypesbutareleftundefned. Theyareusedtospecifyfunctionsvalidateandforget. \nFunctionvalidatemapsawell-formedelementtoavalid element,whileforgetistheinversefunction.Letuslook atfunctionscm0andcm1inmoduleU2Vfrst.Theirtypes \narethefollowing val cm0:(V.T0.t,V.T1.t)U.cm-> (V.T0.t,V.T1.t)V.T0.cm val cm1:(V.T0.t,V.T1.t)U.cm-> (V.T0.t,V.T1.t)V.T1.cm \nFunctioncm0mapsawell-formedcontent,whoseconstitut\u00adingchildrenarevalidelementsalready,intoavalidcontent. \nIffunctioncm0iscomposedwithfunctionV.T0.up,onegets afunctionthatreturnsavalidelementoftypeV.T0.tas result(weuse$asthefunctioncompositionoperator): \nV.T0.up$cm0:(V.T0.t,V.T1.t)U.cm->V.T0.t V.T1.up$cm1:(V.T0.t,V.T1.t)U.cm->V.T1.t Giventhesetwofunctionsastheinductivebasestothesi\u00admultaneousfoldfunction,onederivesthevalidationfunc\u00adtionsforelementsoftypesV.T0.tandV.T1.t. \nU.fold(V.T0.up$cm0,V.T1.up$cm1): (U.u ->V.T0.t)*(U.u->V.T1.t) Recallthatthetypesforallwell-formedelementsandall \nvalidelementsaredefnedby let U.t=(U.u,U.u)Tag.t let V.t=(V.T0.t,V.T1.t)Tag.t Itfollowsthatthevalidationfunctionisdefnedby \nletvalidate=Tag.map$U.fold(V.T0.up$cm0, V.T1.up$cm1) AsshowninFigure3,onecandefnefunctionforgetina similarway.Itremainstobeshownhowfunctionslikecm0 \nandcm1aredefnedforallcontentmodels.Thisisshownin thenextsection. 6. GENERIC VALIDATION OF CONTENT MODELS \nRecallthat,inFigure1,functionmapisdefnedina genericwayforanyFUNmodulecomposablefromapre\u00addefnedsetofparametricmodulessuchasEmpty,P0,P1, \nmoduletypeTAG= sig type('x0,'x1)t valmap:('x0->'y0)*('x1->'y1)-> ('x0,'x1)t->('y0,'y1)t valfold:('x0->'y)*('x1->'y)-> \n('x0,'x1)t->'y valx0:'x0->('x0,'x1)t valx1:'x1->('x0,'x1)t valorder:('x0,'x1)t->int end moduletypeSYS= \nsig moduleF0:FUN moduleF1:FUN moduleTag:TAG end moduleMuValid=functor(S:SYS)-> struct moduleTag=S.Tag \ntypet0=V0of(t0,t1)S.F0.t andt1=V1of(t0,t1)S.F1.t typet=(t0,t1)Tag.t moduleT0= struct type('x0,'x1)cm=('x0,'x1)S.F0.t \nletmap=S.F0.map typet=t0 letup cm=V0cm letdown(V0cm)=cm end moduleT1= struct type('x0,'x1)cm=('x0,'x1)S.F1.t \nletmap=S.F1.map typet=t1 letup cm=V0cm letdown(V0cm)=cm end letrecfold(f0,f1)= letfold0x=f0(T0.map(fold(f0,f1)) \n(T0.downx)) inletfold1x=f1(T1.map(fold(f0,f1)) (T1.downx)) in (fold0,fold1) end Figure2:ModuleMuValidderivesXMLelement \ntypesT0.tandT1.tasthesimultaneous.xedpoints ofparametriccontentmodelsF0.tandF1.t. moduleMuWF=functor(T:TAG)-> \nstruct moduleTag=T type('x0,'x1)cm=('x0,'x1)Tag.tlist letmap(f,g)=List.map(Tag.map(f,g)) typeu=Uof(u,u)cm \ntypet=(u,u)Tag.t letup t=Ut letdown(Ut)=t letrecfold(f0,f1)= letfold0x=f0(map(fold(f0,f1)) (downx)) \ninletfold1x=f1(map(fold(f0,f1)) (downx)) in (fold0,fold1) end moduleMu=functor(S:SYS)-> struct moduleSys=S \nmoduleU=MuWF(Sys.Tag) moduleV=MuValid(Sys) exceptionInvalid moduleU2V= struct letcm0:(V.T0.t,V.T1.t)U.cm-> \n(V.T0.t,V.T1.t)V.T0.cm=... letcm1:(V.T0.t,V.T1.t)U.cm-> (V.T0.t,V.T1.t)V.T1.cm=... let(t0,t1):(U.u->V.T0.t)*(U.u->V.T1.t)= \nU.fold(V.T0.up$cm0,V.T1.up$cm1) lett:U.t->V.t=Sys.Tag.map(t0,t1) end moduleV2U= struct letcm0:(U.u,U.u)V.T0.cm->(U.u,U.u)U.cm=... \nletcm1:(U.u,U.u)V.T1.cm->(U.u,U.u)U.cm=... let(t0,t1):(V.T0.t->U.u)*(V.T1.t->U.u)= V.fold(U.up$cm0,U.up$cm1) \nlett:V.t->U.t=Sys.Tag.map(t0,t1) end letvalidate=U2V.t letforget=V2U.t end Figure3:ModuleMuWFderivesthetypeforwell\u00adformedelements.ModuleMuusesfoldtode.nethe \nvalidationandforgetfulnessfunctions. Note:$isthefunctioncompositionoperator.Functionsare annotatedwiththeirtypesforclaritypurposesonly.They \ncanbesafelyomitted. Star,etc.Thevaildationandforgetfulnessfunctionscanbe defnedinagenericwayaswell.Firstwedefnethevalida\u00adtionfunctionsfortheinductivebases.Validationfunctions \nforothercontentmodelscanthenbederived,automatically, asmoduleexpressionsforthecontentmodelsarecomposed. \nThereremainseveraldetailsintheconstructionofageneric andefcientvalidationfunction.First,thecontentmodels \ndonotknowaboutthesetofnamestheXMLelementswill betaggedwith|Thecontentmodelsareaboutstructures oftheelements,notabouttheirnames.Wehaveusedan\u00adothermodule,withmoduletypeTAG,todefnethevariant \ndatatypefortaggingelements.See,forexample,module BookmarkTaginSection2.Thevalidationfunction,however, \nneedstousetheelementtagnametoselecttherightXML elementtypewithwhichitvalidatetheelement.Asaresult, thevalidationandforgetfulnessfunctionsmustresideina \nhigher-ordermodulethattakesinaTAGmoduleasinput. Wealsoneedstomaintainanullablepredicateanda firstsetofelementtags.Acontentmodelisnullableif \nitacceptstheemptyelementsequence.Thefirstsetcon\u00adtainsalltagsthatcanappearatthefrstpositionofavalid elementsequence.Itcanbeusedtocheckifacontentmodel \nis\\non-deterministic\",e.g.,whenthefirstsetsoftheal\u00adternativesub-modelsofa\\|\"contentmodeloverlapwith oneanother.XMLdisallowsanynon-deterministiccontent \nmodelbecasueanon-backtrackingvalidationproceduremay notbeeasilyderivablefromthemodel'snon-deterministic \nfniteautomaton.Fordeterministiccontentmodels,how\u00adever,onecanusea\\lookahead\"tagvalueandthefirst settoimplementanon-backtrackingvalidationprocedure. \n(MoreonthisinSections9and11.1.)Bothnullableand firstaregenericvalues. ThemoduletypeFUNforaparametriccontentmodelnow \nconsistsofthefollowingcomponents: moduletypeFUN= sig type('x0,'x1)t valmap:('x0->'y0)*('x1->'y1)-> ('x0,'x1)t->('y0,'y1)t \nvalnullable:bool valfirst:Natset.t moduleContent:functor(T:TAG)-> sig valvalidate:('x0,'x1)T.tlist-> \n(('x0,'x1)t* ('x0,'x1)T.tlist)option valforget:('x0,'x1)t->('x0,'x1)T.tlist end end Functionvalidatetakesalistoftaggedvaluesasinputand, \nifsuccess,returnsaSomevalueconsistingofthecontentand theremaininglist.Iffail,itreturnsNone.SomeandNone \narethetwovalueconstructorsoftypeconstructoroption: type'aoption=None|Someof'a Noticethatthetypeoftheinputvalues,('x0,'x1)T.t \nlist,isthesameasthecontentmodelofwell-formedele\u00admentifthetwosharethesametagsetT. Figure4showstheimplementationsofmodulesP0and \nStar.Thevalidationandforgetfulnessfunctionsarewrapped inparametricmoduleContent.ThedefnitionofContentis \nitselfinductive:ItusestheContentmodulesfromitssub\u00admodels,aswellasthenewlysuppliedTAGmodule,todefne alocalvalidationfunctionforitssub-models.Thelocalval\u00adidationfunctionisthenusedtoextractavalidsub-sequence \n(w.r.t.tehsub-model)fromtheinputelementsequence. See,e.g.,themoduleexpressionCM=F.Content(T)inmod\u00aduleStar.Wecanviewthisasconstitutingagenericdefni\u00adtionofthevalidationfunction,aseachinstanceissystem\u00adaticallygeneratedbythemoduleexpressionofitscontent \nmodel. LetuslookatfunctionvalidateinmoduleStarinde\u00adtails.Iftheelementsequenceisempty,thenitisavalidcon\u00adtentof('x0,'x1)F.tlistnomatterwhatcontentmodel \nF.tis.Ifthefrstelementofthesequence,thelookahead, isinthefirstset,thenitrepeatedlyusesthevalidation functionofthesub-modelFtolookforalongestvalidprefx \nfromtheelementsequence.Ifthelookaheadisnotinthe firstset,thenitreturnstheemptylistasavalidcontent. Theremainingelementsequenceisreturnedwiththevalid \nprefxsothatitcanbevalidatedwithsubsequentcontent models.Asdescribedabove,wehaveusedthelongestpre\u00adfxmatchingruleinvalidatinganelementsequenceagainst \nthe\\*\"contentmodel.Indeed,thelongestprefxmatching ruleisusedinthevalidationfunctionsofallcontentmodels. \nValidationfunctionsforothermodules|Empty,P1,Plus, Seq,andAlt|canbesimilarlydefnedandareomitted here. \nWenowreturntoFigure3tocompletethedefntionsof functionscm0andcm1inmodulesU2VandV2U.Function U2V.cm0validatesasequenceoftaggedvaluewiththecon-tentmodelofelementtypeV.T0.t,usingthecurrenttag \nset.Thisisaccomplishedbyusingthevalidationfunction ofthecontentmodelF0.Theonlydiferenceisnowthat,af\u00adtermatchingalongestvalidprefxfromtheinputsequence, \ntheremainingsequencemustbeemptyinorderfortheen\u00adtireinputsequencetobeconsideredvalid.Otherwise,the inputsequenceisinvalid.Theforgetfulnessfunctionofan \nelementtype,ontheotherhand,canjustreusetheforget\u00adfulnessfunctionofitscontentmodel.TheMLcodeisasthe following. \nmoduleU2V= struct moduleCM0=Sys.F0.Content(Sys.Tag) letcm0ulist= matchCM0.validateulistwith Some(v,[])->v \n|_ ->raiseInvalid moduleCM1=Sys.F1.Content(Sys.Tag) letcm1ulist=... end moduleV2U= struct moduleCM0=Sys.F0.Content(Sys.Tag) \nletcm0=CM0.forget moduleCM1=Sys.F1.Content(Sys.Tag) letcm1=CM1.forget end moduleP0:FUN= struct type('x0,'x1)t='x0 \nlet nullable=false let first=Natset.of_list[0] moduleContent=functor(T:TAG)-> struct (*Ifsuccess,returna\"Some\"valueof \n(validelement,remaininglist)pair; otherwisereturns\"None\".*) letvalidateulist= matchulistwith []->None \n|h::t->T.fold((funx->Some(x,t)), (funx->None))h (*Returnasingletonlistofthetaggedvalue*) letforgeta=[T.x0a] \nend end moduleStar:F2F=functor(F:FUN)-> struct type('x0,'x1)t=('x0,'x1)F.tList.t let nullable=true let \nfirst=F.first moduleContent=functor(T:TAG)-> struct moduleCM=F.Content(T) letrecvalidateulist= matchulistwith \n[]->Some([],ulist) (*Anemptylistisvalid.*) |h::_-> if...hisinthe\"first\"set... (*Lookforanon-emptyvalidprefix.*) \nthenmatchCM.validateulistwith Some(u,t)-> (matchvalidatetwith Some(us,s)->Some(u::us,s) |None ->Some([u],t)) \n(*Repeatedlyusethevalidation functionofthesub-modelF togetalongestvalidprefix.*) |None->None (*Failtofindavalidprefix.*) \nelseSome([],ulist) (*Anemptyprefixisvalid ifhisnotinthe\"first\"set.*) letrecforgett= matchtwith []->[] \n|h::t->(CM.forgeth)@(forgett) end end Figure4:Genericde.nitionsofthevalidationand forgetfulnessfunctions. \n 7. TYPEFUL XML PROGRAMMING IN ML OneofthepurposesofvalidationinXMLprogramming istoassigntheintendeddatatypetoanwell-formedXML \nelement.ProgrammingwithvalidatedXMLelementsisnow programmingwithtypedvalues.Usingastaticallytyped langaugetoprogramwithvalidatedXMLelementswillthen \nallowonetodetecttypeerrors,i.e.,expressionsproducing invalidelements,atcompile-time. OurgenericvalidationfunctionassignstheintendedML \ntypestowell-formelements,iftheyarevalid.Thevalidation functionallowsonetobuildXMLprocessorsinMLina typefulway.Thefollowingdiagramshowthebigpictureof \ntypefulXMLprogramminginML. g - UU 6 validateforget - 0 VV f UistheMLtypeforwell-formedelements,andVandV0 \naretheMLtypesforspecifcXMLelementtypes.XML elementsfrom/toexternaldatasources,e.g.,fles,areinU. AnXMLprocessorreceivingelementsfromexternalinput \nandproducingelementsforexternaloutputisafunctionin U!U.However,functionsinU!Uareuntypedasthey mayproduceinvalidelements.Ontheotherhand,functions \ninV!V0 aretypedastheyalwaysoutputvalidelements. Therefore,ifoneisprogrammingafunctiong:U!U,and requirestheoutputtobealwaysvalid,onecandosoby \nprogrammingatypedfunctionf:V!V0 sothat gforget0f0validate InFigure5,weshowsomeMLcodefragmenttoillustrate \ntheapproach.Thecodemapsawell-formedtidybookmark toawell-formedfatbookmark(functiontidy2flat u).Be\u00adcausethemappingiscomposedfromatypedconversionrou\u00adtine(functiontidy2flat \n v),itwillalwaysoutputavalid elementiftheinputelementisvalid.Noticethatthetypes forthefunctionsinFigure5willbeautomaticallyinferred \nbyML.Thefunctionsareannotatedwiththeirtypesfor claritypurposesonly.  8. COMBING GENERICITY WITH POLY-MORPHISM \nGenericmodelingofXMLDTDswithparametricmodules canbefurthercombinedwithpolymorphictypeschemesto achieveabetterresult.Indeed,weneedbothgenericityand \npolymorphismtomodelXMLelementtypesthatareac\u00adcompaniedwithattribute-listdeclarations.Wecanextend thetidybookmarkDTDbyrequiringanoptionalsubject \nattributeforeachfolderelement,andapairoftitleand urlattributesforeachrecordelement.Thefollowingisa validXMLdocumentwiththenewlyextendedDTD. \n<?xmlversion=\"1.0\"?> <!DOCTYPEfolder[ <!ELEMENTfolder((record,(folder|record)*)| (folder,(folder|record)+))> \n<!ELEMENTrecordEMPTY> <!ATTLISTfolder moduleTidySys=... (*CodeformoduleTidySysisinSection2.*) moduleFlatSys= \nstruct moduleF0=Plus(P1) moduleF1=Empty moduleTag=Tag end (* ModuleFlatSysmodelsthefollowingDTD: <!DOCTYPEfolder[ \n<!ELEMENTfolder(record+)> <!ELEMENTrecordEMPTY> ]> *) moduleTidyDtd=Mu(TidySys) moduleFlatDtd=Mu(FlatSys) \nmoduleTidyFolder=TidyDtd.V.T0 moduleTidyRecord=TidyDtd.V.T1 moduleFlatFolder=FlatDtd.V.T0 moduleFlatRecord=FlatDtd.V.T1 \nlettidy2flat_folder: (FlatFolder.t,FlatRecord.t)TidyFolder.cm-> (FlatFolder.t,FlatRecord.t)FlatFolder.cm= \nfunfd->matchfdwith L(r,t)->... (*Dealwiththecaseofaflatrecord rfollowedbyalisttofflat recordsorfolders*) \n|R(f,t)->... (*Dealwiththecaseofaflatfolder ffollowedbyanon-emptylisttof flatrecordsorfolders*) lettify2flat_record: \n(FlatFolder.t,FlatRecord.t)TidyRecord.cm-> (FlatFolder.t,FlatRecord.t)FlatRecord.cm= fun()->() letflatten_v:(TidyFolder.t,TidyRecord.t)Tag.t-> \n(FlatFolder.t,FlatRecord.t)Tag.t= Tag.map(TidyDtd.V.fold (FlatFolder.up$tify2flat_folder, FlatRecord.up$tify2flat_record)) \nletflatten_u:TidyDtd.U.t->FlatDtd.U.t= FlatDtd.forget$flatten_v$TidyDtd.validate Figure5:AnexampleoftypefulXMLprogram\u00adming:Convertingtidybookmarkstofatbook\u00admarks. \nNote:Typeannotationsforfunctionsareaddedforclarity purposes. subjectCDATA#IMPLIED> <!ATTLISTrecord titleCDATA#REQUIRED \nurlCDATA#REQUIRED> ]> <foldersubject=\"ResearchInstitutes\"> <recordtitle=\"AcademiaSinica\" url=\"http://www.sinica.edu.tw\"/> \n</folder> Theoriginaldefnitionsoffolderandrecord typefolder=Folderof(folder,record)F0.t andrecord=Recordof(folder,record)F1.t \ncannowbereplacedby type('u,'v)folder=Folderof 'u*(('u,'v)folder,('u,'v)record)F0.t and('u,'v)record=Recordof \n'v*(('u,'v)folder,('u,'v)record)F1.t typeatt0={subject:stringoption} typeatt1={title:string;url:string} \ntypefolder_with_att=(att0,att1)folder typerecord_with_att=(att0,att1)record Theaboveattributedeclarationsaremodeledatthetype \nlevel.Itcanbeliftedtothemodellevelifneeded.Further\u00admore,thegenericvalidationfunctioncanbemodifedac\u00adcordinglytoaccommodateadditionalvalidationchecksfor \nattributeformatsandvalues. 9. MORE ON XML CONTENT VALIDATIONS XMLrequireselementcontentmodelstobedeterminis\u00adtic.Briuggemann-KleinandWoodfurtherclarifedthere\u00adquirementasmeaning1-unambiguity[8,9].Aregularex\u00adpressionis1-unambiguousifitssequenceofsymbolscan \nberecognizeddeterministically,withone-symbollookahead, bythecorrespondingnon-deterministicfnite-statemachine. \nForexample,thecontentmodel((b,c)|(b,d))isnot1\u00adunambiguous,becausegivenaninitialb,onecannotknow whichbinthemodelisbeingmatchedwithoutlookingfur\u00adtheraheadtoseewhatfollowsb.However,theequivalent \ncontentmodel(b,(c|d))is1-unambiguous[2].Wecanuse thenullablepredicateandthefirstsettocheckwhether thecontentmodelasspecifedbyamoduleexpressionis \n1-unambiguous.Thecheckcanbeperformedatthetime ofmoduleexpressioncompositionsothatnon-deterministic contentmodelsaredetectedassoonaspossible.Acontent \nmodelmayalsocontainepsilonambiguitywhichisallowed byXMLbutdemandsadditionalworkduringvalidation.An exampleofepsilonambiguityis(a*|b*),whentheempty \nsequenceisderivablefrombotha*andb*. Besideselementcontentmodels,i.e.,regularexpressions onelementtypenames,anXMLelementtypemayuse \nothercontentspecifcations.Forexample,itmayhaveEMPTY orANYspecifcation,ormixedcontentspecifcation.These \nspecifcationsimposenoadditionaldifcultyinthedefni\u00adtionofthegenericvalidationfunction.TheANYspecifcation \nmeansthatthesequenceofchildelementsmaycontainele\u00admentsofanydeclaredelementtypes,includingtext,inany order.Themixedcontentspecifcationallowstextdatato \nbeinterspersedwithelementsofsomeelementtypes.One maythinkofANYasaspecialcaseofmixedcontent. Onecanviewtextdata,whichisdenotedas#PCDATA \n(\\ParsedCharacterData\")inamixedcontentspecifcation, aselementsenclosedwithinanpairofimplicit<text>start\u00adtagand</text>end-tag.APcdatamodule,similartothe \nEmptymodulewealreadyhave,canbedefnedtohelpde\u00adfnemixedcontentspecifcations.Forexample,foraDTD with2elementtypes,onecanusea3-aryalternativemodule \nAlt3todefnetheAnymodule: moduleAny:FUN=Star(Alt3(P0)(P1)(Pcdata)) 10. EXPERIENCE WITH LARGER DTDS WMLisamarkuplanguageforWAP(WirelessApplica\u00adtionProtocol)applications[3].ItsDTDincludes35element \ntypedefnitions.Wehaveappliedthegenericapproachto constructaprototypevalidatorforWMLdocuments.The validatorrequiresMLmodulesthatoperateupon36-ary \ntypeconstructors(35elementtypesplus1morefor#PC\u00adDATA).Italsouseshigher-ordermodulesthattakeinas manyas17modulesasinput:Oneoftheelementtypedef-initionsneedsa17-aryAlt17module.Ourexperiencehas \nbeenquitesatisfactory.TheMLcodeiscompiledwithout problemwithObjectiveCaml.Compilingthevalidatordoes takesometime:About1min.onadesktopSparcworksta\u00adtion.Thevalidationtimeisnegligible,however,atleastfor \nsomesmallexampleswehavetried(around100elementsfor eachdocument). ThesizeoftheMLsourcecodeisquitelarge.Takethe \nfollowingMLmoduleexpressionasanexample. moduleF10=Seq10(P0)(P1)(P2)(P3)(P4) (P5)(P6)(P7)(P8)(P9) Oneneeda10-arymoduleSeq10toconstructtherequired \ncontentmodel,whichspecifesasequenceof10elements, eachofadiferentelementtype.CodeformoduleSeq10 lookslikethefollowing: \nmoduleSeq10=functor(F0:FUN)-> functor(F1:FUN)-> ...-> functor(F9:FUN)-> struct type('x0,'x1,...,'x35)t \n=('x0,'x1,...,'x35)F0.t *('x0,'x1,...,'x35)F1.t * ... *('x0,'x1,...,'x35)F9.t ... end Itisclearfromtheabovethat,foraDTDwithnele\u00admenttypes,thesourceformoduleSeqm \nwillhavecodesize O(mn).Attheworstcase,foraDTDoflengthn,ourcode willneedO(n)uniquetypevariables,willcontaintypeshar\u00adingconstraintsoflengthO(n \n2),andwillhaveaoverallcode sizeofO(n 2).ThesourcecodeofallthenecessaryMLmod\u00adulesforthe35-elementWMLDTDhasasizeofabout0.5 \nMB.Whencompiled,itproducesabinaryfleofsize175 KB(*.cmofleinObjectiveCaml),andaninterfacefleof size2.3MB(*.cmifleinObjectiveCaml).MLcodeforthe \nWAPexampleisaccessibleatthefollowingURL: http://www.iis.sinica.edu.tw/~trc/x_dot_ml.html 11. RELATED \nWORK Inthissection,wediscussrelatedworkonXMLcontent modeling,genericprogramming,andrecursivemodulesfor \nML. 11.1 XML Content Modeling Briuggemann-KleinandWoodshowedthatlineartime sufcestodecidewhetheracontentmodelis1-unambiguous. \nItisshownthatregularexpressionsinboth\\starnormal form\"and\\epsilonnormalform\"arealways1-unambiguous [7].TheGlushkovautomatonthatcorrespondstoaregu\u00adlarexpressionisusedforchecking1-unambiguityand,if \n1-unambiguous,forvalidationaswell.Murataproposeda datamodelforXMLdocumenttransformationthatisbased onforest-regularlanguagetheory[19,20].Hismodelis \nalightweightalternativetoXMLSchemaandprovidesa frameworkforschematransformation.Thereisalsowork ontypemodelingfordocumenttransformationinstructured \neditingsystemsusingdatatypes[5].Noneoftheabovework hasusedaparticularprogramminglanguageasamodeling language. \nXMLSchemaisaspecifcationlanguageforXMLcontent developedbytheWorldWideWebConsortium[4].XML SchemaismoreexpressivethanDTD,andthespecifcation \nlanguageitselfusesXMLsyntax.Thekeydiferencesbe-tweenXMLSchemaandDTDincludeXMLSchema'sabil\u00aditytoderivenewtypesbyextendingorrestrictingthecon\u00adtentmodelsofexistingtypes.XMLSchemaalsoprovides \na\\substitutiongroups\"mechanismtoallowelementstobe substitutedforotherelements.Weareinvestigatingwhether \nML-likemodulelanguagesareexpressiveenoughtomodel thesemechanismsinasatisfactoryway. 11.2 Generic Programming \nBackhouse,Jansson,andJeuring,andMeertenshavewrit\u00adtenadetailedintroductiontogenericprogramming[6].See \nalsotheintroductiontofold/unfoldbyMeijer,Fokkinga, andPaterson[17],aswellasworkonusingfold/unfoldfor \nstructuringandreasoningaboutprogramsemanticsbyHut\u00adton[16]. Previousworkongenericprogrammingbyfunctionalpro\u00adgrammingresearchersseemedtorelyonHaskelltypeclasses \ntoderivetype-specifcinstancesofagenericfunction.We haveshowninthispaperthatparametricmodulesinML\u00adlikelanguagesareverysuitableforgenericprogrammingas \nwell.Infact,webelieveparametricmodulesallowoneto takefnercontrolontheinductivederivationsofgenericval\u00adues,hencearemoreexpressive.Furusehasreportedanother \napproachtoaddinggenericvaluestoObjectiveCaml[12]. 11.3 Recursive Modules for ML RussoshowshowtoextendthemodulelanguageofStan\u00addardMLtoallowcyclicdependenciesbetweentypedefni\u00adtionsandfunctiondefnitionsinseparatelydefnedmodules \n[23].Cyclictypedependenciesbetweentwomodulesare specifedbyajointmoduletypewiththetwomoduletypes (typecomponentsonly)appearingasrec-boundparameters. \nThefollowingisanexampleinStandardMLsyntax: signatureJOINT= rec(X:sig structureM0:sigtypetend structureM1:sigtypetend \nend) sig signatureM0: sig datatypet=...X.M1.t... valfold:...->t->'a end signatureM1: sig datatypet=...X.M0.t... \nvalfold:...->t->'b end end Cyclicfunctiondependenciesbetweenthetwomodulesare thenspecifedtogetherwiththejointmoduletype. \nstructurejoint=rec(X:JOINT) struct structureM0= struct datatypet=datatypeX.M0.t funfold(f,g)t=...X.M1.fold(f,g)... \nend structureM1= struct datatypet=datatypeX.M1.t funfold(f,g)t=...X.M0.fold(f,g)... end end Toallowseparatecompilation,eachofthetwomodulescan \nalsobespecifed,separately,as(partof)thefxedpointof ahigher-ordermodulewhoseinputmoduleisofthejoint moduletype. \nIntheaboveapproach,onestartswithajointmodule typedefnitionthatincludesalltheinter-dependentmod\u00aduletypes.Letuscallthisapproachthedirectstyle:Cyclic \ndependenciesbetweentypesandfunctionsareexpresseddi\u00adrectly.Onthecontrary,ourapproachendswithamod\u00aduleexpression(e.g.,MuValid(Sys))tobringinindepen\u00addentmodules,andtoderivefromthemcyclictypedef\u00adinitions(T0.tT0.1)andtheassociatedfunctionalprimi\u00adtives(fold).Letuscallthisapproachthe.xed-pointstyle: \nInter-dependenciesareexplicitlycodifedbyafxed-point module(MuValid).Thedirectstyleismoreconvenientif \noneworksonastaticcollectionofmodulesthathasfxed inter-dependencyrelationship,ascyclicdependenciescanbe \nexpresseddirectlybytheuserandsupportedbythelan\u00adguage.Thefxed-pointstyleismoreconvenientifonewants tobuildfromadynamiccollectionofindependentmodules \nadditionalinter-dependencyrelationship,asmodulesfrom thecollectioncanbeeasilyconnectedtooneanother.The \nfxed-pointstylecanbelessefcient:Thefxed-pointmodule introducesapairofupanddownfunctionstomapbetween atypeanditsinternalstructure.Ontheotherhand,itis \nalsomoreabstracthenceveryexpressive.Thepolymorphic fold/unfoldprimitivesarereadilyavailable,andcanbeused \ninmanycontexts(see,e.g.,[10,13]). Thefxed-pointstylecanbeviewedasanMLcodifcation ofthedefningdiagramofthesimultaneousfoldfunction, \nseeFigure6.IntheMLcodifcationofthediagram,apara\u00admetricmodule,e.g.,MuValid,takesmodulesF0andF1as input,andreturnsfunctionfoldalongwithmodulesT0and \nT1asoutput.Weuseanotherexampletoillustratetheab\u00adstractionpowerofthefxed-pointstyle.Figure7defnesthe foldfunctionforaunaryfunctorcategorywhereeachobject \nTisdefnedasthefxedpointofsomebinaryfunctorobject F.LetaparametricmoduleMucodifythisdiagram,withF asinputandTandthefoldfunctionasoutput.Thenone \ncanexpresstheusuallistdatatypebythefollowing: moduleList=Mu(Alt(Empty)(Seq(P0)(P1))) type'alist='aList.t \nwheremodulesEmpty,P0,P1,Alt,andSeqareasdefnedin Figure1. 12. FUTURE WORK AND CONCLUSION OurworkcanbethoughtasusingtheMLmodulefa\u00adcilitytogenerateadeterministicautomatonspecializedfor \nthevalidationofXMLelementsofaDTD.Thevalidation automatonalsoassignsspecifcMLtypestovalidelements. Inaddition,theconstructionofthevalidationautomatonis \nentirelygeneric,andthecodecanbeautomaticallygener\u00adated.OurworkalsoservesasausecaseofMLmodules,and canbeusedtostress-testcurrentMLimplementations.Itis \nadelighttoseeourcontrivedcodeof36-arytypeconstruc\u00adtorsand17-aryhigher-ordermodulescompiledandexecuted \nwithnoproblemunderObjectiveCaml. Futureworkincludesthefullimplementationofageneric XMLvalidator,theapplicationofthegenericvalidatorto \nlargerDTDsanddocuments,andthecollectionofmoreper\u00adformancedata.Wealsoneedmoreexperienceindeveloping largerXMLapplicationswithintheproposedtypefulpro\u00adgrammingframework(cf.Figure5). \n13. ACKNOWLEDGMENTS WethankJeremyGibbons,Jan{LiLin,Yih{KuenTsay, participantsofthe1stAsianWorkshoponProgramming \nLanguagesandSystems,andtheICFPrefereesforvaluable commentsonearlierversionsofthispaper. 14. REFERENCES \n[1]Documentobjectmodel(DOM)level1specifcation, version1.0.W3CRecommendation1October,1998. [2]ExtensibleMarkupLanguage(XML)1.0(Second \nEdition).W3CRecommendation,6October2000. [3]Wirelessmarkuplanguage(WML)documenttype defnition. <http://www.wapforum.org/DTD/wml \n 1.1.xml>. [4]XMLSchemaPart0:Primer.W3CRecommendation, 2May2001. [5]E.Akpotsui,V.Quint,andC.Roisin.Typemodelling \nfordocumenttransformationinstructuredediting systems.MathematicalandComputerModelling, 25(4):1{19,1997. \n[6]R.Backhouse,P.Jansson,J.Jeuring,and L.Meertens.Genericprogramming:Anintroduction. InAdvancedFunctionalProgramming,3rd \nInternationalSchool,pages28{115,Sept.1999. LectureNotesinComputerScience,Volume1608, Springer{Verlag. \n[7]A.Briuggemann-Klein.Regularexpressionsintofnite automata.TheoreticalComputerScience, 120(2):197{213,1993. \nhdownT0,downT1i - hT0,T1i hF0hT0,T1i,F1hT0,T1ii hupT0,upT1 i fold(f0,f1)hmapF0(fold(f0,f1)),mapF1(fold(f0,f1))i \nhf0,f1i ha,ji hF0ha,ji,F1ha,jii Figure6:Thede.ningdiagramofthesimultaneousfoldfunction. downT - Ta Fha,Tai \nup T foldfmaphid,foldfi F f j Fha,ji [8] [9] [10] [11] [12] [13] [14] [15] [16] [17] Figure7:Thefoldfunction \nA.Briuggemann-KleinandD.Wood.Thevalidationof SGMLcontentmodels.MathematicalandComputer Modelling,25(4):73{84,1997. \nA.Briuggemann-KleinandD.Wood. One-unambiguousregularlanguages.Informationand Computation,140(2):182{206,1998. \nT.-R.ChuangandS.-C.Mu.Out{of{corefunctional programmingwithtype{basedprimitives.InPractical AspectsofDeclarativeLanguages,2ndInternational \nWorkshop,pages32{46,Jan.2000.LectureNotesin ComputerScience,vol.1753,Springer{Verlag. M.Fernandez,J.Simeon,andP.Wadler.Analgebra \nforXMLquery.InFoundationsofSoftware TechnologyandTheoreticalComputerScience,20th Conference,pages11{45,Dec.2000.LectureNotesin \nComputerScience,vol.1974,Springer{Verlag. J.Furuse.GenericpolymorphisminML.InJourneees FrancophonesdesLangagesApplicatifs,pages75{96, \nJan.2001.<http://pauillac.inria.fr/jfla/2001>. J.GibbonsandG.Jones.Theunder-appreciated unfold.InProceedingsofthe3rdACMSIGPLAN \nInternationalConferenceonFunctionalProgramming, pages273{279,Sept.1998.ACMPress. H.HosoyaandB.C.Pierce.XDuce:AtypedXML \nprocessinglanguage(preliminaryreport).InThe WorldWideWebandDatabases,3rdInternational Workshop,pages226{244,May2000.LectureNotesin \nComputerScience,vol.1997,Springer{Verlag. H.Hosoya,J.Vouillon,andB.C.Pierce.Regular expressiontypesforXML.InProceedingsofthe5th \nACMSIGPLANInternationalConferenceon FunctionalProgramming,pages11{22,Sept.2000. ACMPress. G.Hutton.Foldandunfoldforprogramsemantics.In \nProceedingsofthe3rdACMSIGPLANInternational ConferenceonFunctionalProgramming,pages 280{288,Sept.1998.ACMPress. \nE.Meijer,M.Fokkinga,andR.Paterson.Functional programmingwithbananas,lenses,envelopesand forunaryfunctorobjects. \nbaredwire.InFunctionalProgrammingLanguages andComputerArchitecture,pages124{144,Aug.1991. LectureNotesinComputerScience,vol.523, \nSpringer{Verlag. [18]E.MeijerandM.Shields.XM>:Afunctional languageforconstructingandmanipulatingXML documents.Draft,1999. \n [19]M.Murata.Transformationofdocumentsand schemasbypatternsandcontextualconditions.In PrinciplesofDocumentProcessing,3rdInternational \nWorkshop,pages153{169,Sept.1996.LectureNotes inComputerScience,vol.1293,Springer{Verlag. [20]M.Murata.Datamodelsfordocumenttransformation \nandassembly.InPrinciplesofDigitalDocument Processing,4thInternationalWorkshop,pages 140{152,Mar.1998.LectureNotesinComputer \nScience,vol.1481,Springer{Verlag. [21]D.Plaindoux.ProgrammationfronctioncelleetXML: PaX.InJourneeesFrancophonesdesLangages \nApplicatifs,pages129{143,Jan.2001. <http://pauillac.inria.fr/jfla/2001>. [22]ProjectCristal.TheCamlLanguage. \n<http://caml.inria.fr>. [23]C.V.Russo.Recursivestructuresforstandardml.In Proceedingsofthe6thACMSIGPLANInternational \nConferenceonFunctionalProgramming,Sept.2001. ACMPress. [24]M.WallaceandC.Runciman.HaskellandXML: Genericcombinatorsortype-basedtranslation?In \n Proceedingsofthe4thACMSIGPLANInternational ConferenceonFunctionalProgramming,pages 148{159.Paris,France,Sept.1999.ACMPress. \n[25]C.-L.Yeh.Alogicprogrammingapproachto supportingtheentriesofXMLdocumentsinanobject database.InPracticalAspectsofDeclarative \nLanguages,2ndInternationalWorkshop,pages 278{292,Jan.2000.LectureNotesinComputer Science,vol.1753,Springer{Verlag. \n  \n\t\t\t", "proc_id": "507635", "abstract": "We demonstrate a natural mapping from XML element types to ML module expressions. The mapping is inductive and definitions of common XML operations can be derived as the module expressions are composed. We show how to derive, in a generic way, the validation function, which checks an XML document for conformance to its DTD (Document Type Definition). One can view validation as assigning ML types to XML elements and the validation procedure a pre-requisite for typeful XML programming in ML. Our mapping uses the parametric module facility of ML in some contrived way. For example, in validating WML (WAP Markup Language) documents, we need to use 36ary type constructors, as well as higher-order modules that take in as many as 17 modules as input. That one can systematically model XML DTDs at the module level suggests ML-like languages are suitable for type-safe prototyping of DTD-aware XML applications.", "authors": [{"name": "Tyng-Ruey Chuang", "author_profile_id": "81452596926", "affiliation": "Academia Sincia, Taipei, Taiwan", "person_id": "P285674", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/507635.507649", "year": "2001", "article_id": "507649", "conference": "ICFP", "title": "Generic validation of structural content with parametric modules", "url": "http://dl.acm.org/citation.cfm?id=507649"}