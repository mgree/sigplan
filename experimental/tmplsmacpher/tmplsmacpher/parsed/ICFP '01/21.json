{"article_publication_date": "10-01-2001", "fulltext": "\n Extensible Algebraic Datatypes with Defaults Matthias Zenger Swiss Federal Institute of Technology \nINR Ecublens 1015 Lausanne, Switzerland  matthias.zenger@ep..ch ABSTRACT A major problem for writing \nextensible software arises when recursively de.ned datatypes and operations on these types have to be \nextended simultaneously without modifying ex\u00adisting code. This paper introduces Extensible Algebraic \nDatatypes with Defaults which promote a simple program\u00adming pattern to solve this well known problem. \nWe show that it is possible to encode extensible algebraic datatypes in an object-oriented language, \nusing a new design pattern for extensible visitors. Extensible algebraic datatypes have been successfully \napplied in the implementation of an ex\u00adtensible Java compiler. Our technique allows for the reuse of \nexisting components in compiler extensions without the need for any adaptations. 1. INTRODUCTION 1.1 \nExtensibility Problem The extensibility problem has been extensively studied [5, 6, 10, 11, 16, 19, 22, \n30]. It can be paraphrased as follows: Given a recursively de.ned set of data and operations on them, \nhow can one add both new data variants and new op\u00aderations on variants without changing or duplicating \nexist\u00ading code? This is not only an academic question. Extending a system by modifying source code is \nan error-prone task. Furthermore, creating an extended system by duplicating source code also results \nin duplicated maintenance costs, if the old and the new system are both going to be used. In some cases, \nit is not even possible to apply source code mod\u00adi.cations, because some parts of the system might only \nbe available in binary form. For example, consider a representation of lambda terms as trees, with variants \nLambda, Apply and Variable and an eval operation on those trees. As one possible extension, con\u00adsider \nadding variants Number and Plus to the term type. As another extension consider adding an operation that \nprints aterm. Permission to make digital or hard copies of all or part of this work for personal or classroom \nuse is granted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page. To copy otherwise, to republish, \nto post on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. ICFP \n01, September 3-5, 2001, Florence, Italy. Copyright 2001 ACM 1-58113-415-0/01/0009 ...$5.00. Martin Odersky \nSwiss Federal Institute of Technology INR Ecublens 1015 Lausanne, Switzerland martin.odersky@ep..ch \nThe traditional object-oriented and functional approaches both make extensions in one dimension easy, \nbut extensions in the other dimension very hard. In the object-oriented ap\u00adproach, data is modelled by \na set of classes, sharing a com\u00admon interface. For the lambda term example, there would be an interface \nor abstract class Term specifying the eval method with subclasses Lambda, Apply and Variable.Each subclass \nde.nes its own implementation of eval.Whereas extending the datatype with new variants is simply done \nby creating new classes, adding new operations involves modi\u00ad.cations of the abstract base class. On \nthe other hand, in the functional approach, the vari\u00adants of a datatype are typically implemented as \nan algebraic type. Here, de.ning new operations is easy. One just writes a new function which matches \nagainst the data variants. But since ordinary algebraic datatypes cannot be extended without modi.cations \nto the source code, it would not be possible to add new variants. Each of the two approaches can encode \nthe other. In one direction, object-oriented languages can model the func\u00adtional approach using the Visitor \ndesign pattern [14]. In the other direction, objects can be represented in functional languages as closures \ntaking an algebraic datatype of mes\u00adsages as parameter. However, each of these encodings ex\u00adchanges both \nthe strengths and weaknesses of one approach with the strengths and the weaknesses of the other; neither \nencoding gains simultaneous extensibility of both data and operations. 1.2 Extensibility by Subclassing \nWe can make the object-oriented approach extensible without modifying source code if we allow type casts. \nFor adding a new operation, we have to extend the common vari\u00adant interface with the new operation. In \nour lambda exam\u00adple, one would de.ne an extension ExtendedTerm of interface Term that adds a print method. \nAs a consequence, all three variants have to be subclassed to provide an implementation for the new operation. \nWhenever we want to invoke the new operation, we .rst have to cast the receiver to the extended type. \nFor instance to invoke the print method of a variable t of type Term one uses ((ExtendedTerm)t).print().Otherwise \nwe would not be able to access the new operation. This approach supports extensibility of both data and \nfunctions. But adding a new function is very tedious, since it requires that all variants have to be \nsubclassed. Krishnamurthi, Felleisen and Friedman show that we can apply a similar coding scheme to the \nfunctional approach to make it also support variant extensions [19]. They de\u00adscribe the composite design \npattern Extensible Visitor that keeps visitors open for later extensions. Whenever a new variant class \nis added, all existing visitors have to be sub\u00adclassed in order to support this new variant. Otherwise \na runtime error will appear as soon as an old visitor is applied to a new variant. Again, variants and \noperations are exten\u00adsible. But this time, adding a new variant requires all vis\u00aditors to be subclassed. \nSince the extensible visitor pattern is rather complex and error-prone to implement by hand, a special \nsyntax is proposed for specifying extensible visi\u00adtors. A preprocessor translates these speci.cations \ninto an object-oriented programming language. A pattern compa\u00adrable to the one of Krishnamurthi, Felleisen \nand Friedman is described by Gagnon and Hendren [13]. They explain how to add new variants and operations, \nbut the extension or reuse of operations is not discussed. In summary, subclassing techniques can provide \nextensi\u00adbility in the previously missing dimension, but they rely on the use of type casts and require \npossibly extensive adapta\u00adtion code. 1.3 Extensibility with Default Cases In practice, it appears quite \noften that an operation de\u00ad.nes a speci.c behaviour only for some variants and all other variants are \nsubsumed by a default treatment. Such an oper\u00adation could be reused without modi.cations for an extended \ntype, if all new variants are properly treated by the existing default behaviour. In fact, our experience \nwith the imple\u00admentation of an extensible Java compiler shows that at least for this sort of application, \nthe majority of the existing oper\u00adations can be reused as is for extended types (Section 5.3 presents \nstatistics). In this case, extending a system with the techniques of Section 1.2 would be very cumbersome, \nsince for most cases we would just have to map an opera\u00adtion for all new variants to the default behaviour. \nIf we would be able to specify a default case for every func\u00adtion operating on an extensible type, a \nfunction would have to be adapted only in those situations where new variants require a speci.c treatment. \nThis technique would improve as is code reuse signi.cantly. Previously mentioned ap\u00adproaches were not \nable to handle default cases since datatype and function de.nitions were tightly coupled: one of the \ntwo always speci.ed the interface of its partner completely. In this paper we present a solution to the \nextensibility problem which is based on the new notion of extensible al\u00adgebraic datatypes with defaults. \nWe describe these exten\u00adsible algebraic types in the context of an object-oriented language. The approach \npresented in this paper smoothly combines object-oriented extensibility through subclassing and overriding \nwith type-safe pattern matching on algebraic datatypes, known from functional programming languages. \nOur work was inspired by the algebraic types o.ered by Pizza [24], a superset of Java [18]. From an extensible \nalgebraic datatype one can derive ex\u00adtended types with new variants in addition to the ones de\u00ad.ned in \nthe original type. These types enable us to solve the extensibility problem in a functional fashion; \ni.e. the de.ni\u00adtion of the datatype and operations on that type are strictly separated. Extensions on \nthe operation side are therefore completely orthogonal to extensions of the datatype. In addition to \nadding new variants and operations, we also support extending existing variants of a datatype and mod\u00adifying \nexisting operations. Furthermore, applying existing operations to new variants is possible, since operations \nfor extensible algebraic types de.ne a default case. Extensibil\u00adity is achieved without the need for \nmodifying or recompiling the original program code or existing clients. We show that it is possible to \nencode programs using ex\u00adtensible algebraic types in languages with just objects and subtyping such as \nJava. The encoding takes the form of a new design pattern for extensible visitors with default cases. \nSince this pattern is rather di.cult to implement by hand, we decided to include direct support for extensible \nalgebraic types in an extension of Java. Extensible algebraic types have been used heavily in the design \nand implementation of our extensible Java compiler JaCo. JaCo has been used in several projects to rapidly \nim\u00adplement language extensions for Java. The implementation work in these projects showed that the notational \nconve\u00adnience a.orded by default cases was very important. Statis\u00adtics taken from several compiler extensions \nindicate that on average three quarters of all functions operating on algebraic types could be reused \non extended types without any modi\u00ad.cations. Extensible algebraic datatypes allowed us to reuse these \nfunctions without having to add adaptation code. The rest of this paper is organized as follows. Section \n2 presents a simple programming protocol that explains how extensible algebraic datatypes with defaults \nsolve the exten\u00adsibility problem. Section 3 discusses various aspects of ex\u00adtensible algebraic datatypes \nin more detail. Section 4 gives an encoding of extensible algebraic datatypes with visitors. Section \n5 discusses the experience we gained from using ex\u00adtensible algebraic types in the design and implementation \nof an extensible Java compiler and presents statistics about the level of code reuse in this system. \nRelated work is reviewed in Section 6. Section 7 concludes.  2. EXTENSIBILITY WITH ALGEBRAIC DATATYPES \nA typical example where the extensibility problem plays a signi.cant role is the implementation of extensible \ninter\u00adpreters and compilers. A wrong design limits extensibility or complicates at least the task of \nextending the system. In this section we use algebraic datatypes to derive a pro\u00adgramming pattern for \nwriting extensible interpreters. We start with a small language consisting of variables, lambda abstractions \nand lambda applications. For declaring algebraic types we use the syntax introduced by the programming \nlanguage Pizza [24]. Here is an alge\u00adbraic datatype de.ning abstract syntax tree nodes for our example \nlanguage: class Term { case Variable(String name); case Apply(Term fn, Term arg); case Lambda(String \nname, Term body); } The algebraic type Term declares constructors Variable, Lambda and Apply for the \nthree language constructs. We now de.ne a simple interpreter that evaluates terms based on a call-by-value \nevaluation strategy with dynamic scop\u00ading. Our Interpreter class contains a single method eval that implements \nthe operation for evaluating a term. Pattern matching is used to distinguish the di.erent variants of \nthe Term type in the eval method. Pizza uses switch statements to perform pattern matching for objects \nof an algebraic type. class Interpreter {Term eval(Term term, Env env) {switch (term) {case Variable(String \nn): return env.lookup(n); case Apply(Term fn, Term arg): switch (eval(fn, env)) {case Lambda(String n, \nTerm body): return eval(body, env.bind(n, eval(arg, env))); default: throw new Error( function expected \n); } default: return term; } } } By using this approach, it is straightforward to add new op\u00aderations \nover type Term to the interpreter simply by de.ning further methods. The following code adds a method \nthat transforms a term into a string: class Formatter {void toString(Term term) {switch (term) {case \nVariable(String n): return n; case Apply(Term fn, Term arg): return ( + toString(fn) +  + toString(arg) \n+ ) ; case Lambda(String n, Term b): return ( + n + > + toString(b) + ) ; default: return <unknown> \n; } } } We now come to the problem of adding new variants to the Term datatype. This paper proposes \nextensible algebraic datatypes with defaults to solve this problem. These types enable us to de.ne a \nnew algebraic datatype by adding ad\u00additional variants to an existing algebraic type. Here is the declaration \nof an extended Term datatype, which de.nes two new variants Number and Plus: class ExtendedTerm extends \nTerm { case Number(int val); case Plus(ExtendedTerm left, ExtendedTerm right); } With this de.nition, \nwe introduce a new algebraic datatype ExtendedTerm consisting of .ve constructors Variable, Apply, Lambda, \nNumber and Plus. One can think of an extensible algebraic datatype as an algebraic type with an implicit \nde\u00adfault case. Extending an extensible algebraic type means re.ning this default case with new variants. \nFor the exam\u00adple above, the new type ExtendedTerm inherits all variants from Term and de.nes two additional \nones. With our re.ne\u00adment notion, these two new variants are subsumed by the implicit default case of \nTerm. The next section shows that this notion turns ExtendedTerm into a subtype of Term.This subtype \nrelationship is crucial for code reuse, since it allows us to apply all functions over the original type \nto terms con\u00adtaining nodes from the extended type. Since the existing functions perform a pattern matching \nonly over the origi\u00adnal variants, an extended variant is handled by the default clause of the switch \nstatement. For our current eval method, the default clause simply re\u00adturns the same node, so numbers \nand additions would not get evaluated by the eval operation. To support evaluation of the new variants, \nwe have to adapt our interpreter ac\u00adcordingly. We do this by subclassing the Interpreter class and overriding \nthe eval method. class ExtendedInterpreter extends Interpreter { Term eval(Term term, Env env) { switch \n(term) { case Plus(ExtendedTerm left, ExtendedTerm right): return ExtendedTerm.Number( evalNum(left, \nenv) + evalNum(right, env)); default: return super.eval(term, env); }} int evalNum(ExtendedTerm term, \nEnv env) { switch (eval(term, env)) { case Number(int val): return val; default: throw new Error( number \nexpected ); } } } The example shows that we only have to provide an imple\u00admentation for the Plus variant. \nFor all the other variants, we delegate the method call to the overridden method. Even our freshly introduced \nNumbers are handled properly by the overridden method. In the new interpreter we make use of an additional \nmethod evalNum which projects Number terms to integers and throws an exception if the given term is not \na Number. These code fragments demonstrate the expressiveness of extensible algebraic datatypes in the \ncontext of an object\u00adoriented language like Java. We are able to extend datatypes and operations in a \ncompletely independent and uniform way. An extension in one dimension does not enforce any adaptations \nof the other dimension. Since in pattern match\u00ading statements new variants are simply subsumed by the \nde\u00adfault clause, existing operations can be reused for extended datatypes. Operations are de.ned locally \nin a single place. The conventional object-oriented approach would distribute a function de.nition over \nseveral classes, making it very dif\u00ad.cult to understand the operation as a whole. Our approach supports \na modular organization of datatypes and operations with an orthogonal extensibility mechanism. With the \ntechnique presented in this section, extended interpreters are derived out of existing ones simply by \nsubclassing. Only the di.erences have to be implemented in subclasses. The rest is reused from the original \nsystem, which itself is not touched at all. Roudier and Ichisugi re\u00adfer to this form of software development \nas programming by di.erence [29]. 3. PRINCIPLES OF EXTENSIBLE ALGE-BRAIC DATATYPES In this section, \nwe review the type theoretic intuitions be\u00adhind extensible algebraic datatypes with defaults. Usually, \nalgebraic types are treated as sum types of variants. Classi\u00adcal sum types can be straightforwardly extended \nby adding new variants. However, such an extension yields a subtype relation which is the reverse of \nthe extension relation, i.e. extensions become supertypes of the original type. In the following subsection, \nwe review these concepts, and argue that the induced subtyping relation is not useful for writing extensible \nsoftware. We then re.ne in Section 3.2 our model  A1A2 B1 Figure 1: Subtyping for extensible sums of \nalgebraic types to include default cases. This has the ef\u00adfect of reversing the original subtype relation, \nbringing it in sync with the extension relation. 3.1 Extensible Sums Algebraic datatypes can be modelled \nas sums of variants. Each variant constitutes a new type, which is given by a tag and a tuple of component \ntypes. For instance, consider the declaration: class A { case A1(T1,1 x1,1,... ,T1,r1 ); x1,r1 case \nA2(T2,1 x2,1,... ,T2,r2 ); x2,r2 } This de.nes a sum type A consisting of two variant types A1 and A2, \nwhich have components T1,1 x1,1,... ,T1,r1 x1,r1 and T2,1 x2,1,... , T2,r2 x2,r2 , respectively. Let \nallcases(A) denote the set of all variants of the alge\u00adbraic type A. For example, allcases(A)= {A1,A2}. \nTo describe extensions of algebraic types, we introduce a partial order between algebraic types. B A \nholds if B extends A by adding new variants to it. A priori the alge\u00adbraic extension relation is independent \nof the subtyping relation. In our setting . is de.ned explicitly by type declara\u00adtions. For example, \nthe following code de.nes an algebraic datatype B A that extends A with an additional variant B1: class \nB extends A { case B1(...); } The new type B is described by the set of its own vari\u00adants owncases(B)= \n{B1} and the inherited variants allcases(A). Thus, for the extended algebraic type B,we get allcases(B)= \nallcases(A) .owncases(B)= {A1,A2,B1}. The standard typing rules for sum types [3] make A a sub\u00adtype of \nB if all variants of A are also variants of B.In our example, we have allcases(A) .allcases(B), so our \norigi\u00adnal type A is a subtype of the extended type B.Figure 1 summarizes the relationships between types. \nIn this .gure, algebraic datatypes are depicted as boxes, variants are dis\u00adplayed as round boxes. Arrows \nhighlight subtype relation\u00adships. More speci.cally, outlined arrows represent algebraic type extensions, \nwhereas all other arrows connect variants with the algebraic types to which they belong. Unfortunately, \nthe subtype relation between extensible sum types is often the opposite of what one would like to have \nin practice. Imagine we have the following Term type: class Term { case Number(int val); case Plus(Term \nleft, Term right); } Adding a new variant Ident would yield a new algebraic type ExtendedTerm. class \nExtendedTerm extends Term {case Ident(String name); } Since ExtendedTerm is a supertype of Term, we cannot \nrep\u00adresent the sum of two identi.ers with the Plus variant. This variant expects two Terms as its arguments, \nbut the variant Ident is not included in the Term type. In other words, ex\u00adtensible sums do not support \nopen recursion in the de.nition of a datatype. So the classical way of describing algebraic types by \na .xed set of variants does not provide extensibility in the way we need it. 3.2 Extensible Algebraic \nTypes with Defaults In order to turn extended types into subtypes, we have to keep the set of variants \nopen for every extensible algebraic type. We achieve this by adding a default variant to every algebraic \ndatatype, which subsumes all variants de.ned in future extensions of the type. The set of all variants \nof an extensible algebraic datatype is now given by the following equation. allcases(Y )= inherited(Y \n) .owncases(Y ) .default(Y ) where owncases(Y )= {Yi} i inherited(Y ) =  owncases(X) Y =X,Y =X default(Y \n)= owncases(Z) Z=Y,Z =Y That is, every extensible algebraic type Y is de.ned by three disjoint variant \nsets owncases(Y ), inherited(Y )and default(Y ). inherited(Y ) includes all inherited variants from the \nalgebraic type Y is extending, owncases(Y )de\u00adnotes Y s new cases, and default(Y ) subsumes variants \nof future extensions. With this understanding, our variant sets for types A and B from Section 3.1 now \nlook like this: allcases(A)= {A1,A2}.default(A), and allcases(B)= {A1,A2,B1}.default(B). Since default(A)captures \nB1 as well as default(B), {B1}.default(B) is a subset of default(A). Therefore allcases(B) . allcases(A)and \nB is a subtype of A. One might be tempted to believe now that one has even allcases(A)= allcases(B). \nThis would identify types A and B. But a closer look at the de.nition of default reveals that default(B) \nonly subsumes variants of extensions of B.Vari\u00adants of any other extension of A are contained in default(A), \nbut not covered by default(B). This is illustrated by the fol\u00adlowing algebraic class declaration: class \nC extends A {case C1(...); } C is another extension of algebraic type A,which is com\u00adpletely orthogonal \nto B.It s case C1 is not included in default(B), but is an element of default(A). As a conse\u00adquence, \n{B1}.default(B) is a proper subset of default(A), and therefore the extended type B is a proper subtype \nof  C1 A1 A2 B1 Figure 2: Subtyping for alternative extensions of algebraic types A. C is a proper subtype \nof A for the same reasons, but the types B and C are incompatible. The subtype relationships of our example \nare illustrated in Figure 2. Again, boxes represent extensible algebraic datatypes, round boxes represent \nvariants. Subtype rela\u00adtionships are depicted with arrows. Extending an algebraic datatype means creating \na new type which is a subtype of the old one and which inherits all the variants of the old one. Furthermore \nthis new type may also de.ne additional variants. Dashed arrows connect inherited variants with the algebraic \ntype to which they get inherited. With our approach, extended algebraic types are subtypes of the types \nthey extend. Therefore existing functions can be applied to values of extended types. New variants are \nsim\u00adply subsumed by the default clause of every pattern match\u00ading construct. Another interesting observation \ncan be made when looking at two di.erent extensions of a single alge\u00adbraic type (like B and C in the \nexample above). They are incompatible; neither of them is a supertype of the other one. This separation \nof di.erent extensions is a direct con\u00adsequence of single-inheritance: an extensible algebraic type can \nonly extend a single other algebraic datatype. Extending the same type more than once yields extended \nalgebraic types that share some variants, but that are in\u00adcompatible to each other. Of course, it is \nalso possible to extend an extension of an algebraic type further: class D extends B { case D1(...); \n } Here, the algebraic type D extends B and de.nes an ad\u00additional variant D1. Figure 3 shows the resulting \nsubtype relations. 3.3 Compilation of Extensible Algebraic Types with Defaults The previous section \npointed out that extensible algebraic datatypes with defaults are subject to single-inheritance; i.e. \nan algebraic type can only extend a single other algebraic datatype. This restriction enables an e.cient \ncompilation of pattern matching for extensible algebraic types using the conventional technique for sealed \ndatatypes. The conven\u00adtional compilation scheme assigns unique tags to every vari\u00adant of an algebraic \ntype. Pattern matching can then simply be implemented with a switch over all tags. For extensible algebraic \ndatatypes with defaults, variants are tagged with subsequent numbers starting with the num\u00adber which \nis equivalent to the number of inherited variants. Figure 3: Subtyping for linear extensions of alge\u00adbraic \ntypes By doing this, we never tag two variants of any algebraic type with the same number. But we observe \nthat two dif\u00adferent extensions of an algebraic type (like B and C in Sec\u00adtion 3.2) may share the same \ntags. Since two extensions of a single algebraic datatype always yield incompatible types, this issue \nusually does not cause any problems. Only pattern matching statements that mix variants of two incompatible \nextensions have to be split up in two separate pattern match\u00ading statements together with a dynamic typecheck \nthat se\u00adlects one of the two statements. We implemented an e.\u00adcient version of this compilation scheme \nfor our extensible Java compiler JaCo [33].  4. VISITOR ENCODING In object-oriented languages, algebraic \ndataypes can be encoded with the visitor design pattern [14]. Krishnamurthi, Felleisen and Friedman extended \nthis design pattern to en\u00adable extensibility [19]. In this section, we take their ap\u00adproach even further \nby adding support for default cases. Our programming pattern models extensible algebraic types in a purely \nobject-oriented language (with some small di.er\u00adences which are discussed at the end of this section). \nWe start with a review of the standard visitor pattern. All code fragments of this section are written \nin Java. 4.1 Design Pattern Visitor The visitor design pattern models algebraic types with abstract classes. \nThe variants of an algebraic type are rep\u00adresented by subclasses which de.ne the .elds of the variant \nand a corresponding constructor. Operations are encapsu\u00adlated in visitor objects. A visitor object contains \nan over\u00adloaded method visit for every variant, which implements the operation speci.cally for this variant. \nTo be able to apply a visitor, every variant de.nes an accept method. These methods take a visitor and \ninvoke the appropriate visitor method. Here is a visitor framework for the example from Section 2. We \nonly show the code for variant Variable.The other variants of the Term type are encoded analogously. \ninterface Visitor { void visit(Variable term); void visit(Apply term); void visit(Lambda term); } abstract \nclass Term { abstract void accept(Visitor v); } class Variable extends Term {String name; Variable(String \nname) { this.name = name; }void accept(Visitor v) { v.visit(this); } } ... Concrete operations implement \nthe visitor interface and pro\u00advide a mechanism for passing arguments and returning re\u00adsults. Various \nsolutions are possible here. We present a technique where for every visitor invocation a new visitor \nobject gets created. The visitor constructor stores the argu\u00adments in .elds inside the visitor. There \nis also a public .eld res in which the result of an operation is stored. The follow\u00ading implementation \nof Eval uses an anonymous visitor in the visit(Apply term) method for applying a lambda abstraction to \nan argument. Since we refer to the formal parameter term from inside the anonymous class, Java requires \nus to mark this parameter as .nal. class Eval implements Visitor { private Env env; public Term res; \nEval(Env env) { this.env = env; } void visit(Variable term) { res = term; } void visit(Lambda term) \n{ res = term; } void visit(.nal Apply term) { Eval eval = new Eval(env); term.fn.accept(eval); eval.res.accept(new \nVisitor() { void visit(Variable t) { throw new Error(); }void visit(Apply t) { throw new Error(); }void \nvisit(Lambda t) { Eval evArg=new Eval(env); term.arg.accept(evArg); Eval evFun=new Eval(env.bind(t.x, \nevArg.res)); t.body.accept(evFun); res = evFun.res; } }); } } The Visitor interface describes all the \ndatatype s variants. Since this interface is .xed, it this not possible to add new variants. On the other \nside, adding new operations is easy by creating a new visitor implementation.  4.2 Extensible Visitors \nwith Default Cases We now show how to derive an extensible visitor design pattern with default cases. \nOperations with default cases can be applied to extended algebraic datatypes. They pro\u00advide a generic \ntreatment for variants of any future datatype extension. In our visitor framework we model default cases \nwith an additional visit method in the Visitor interface. interface Visitor { void visit(Term term); \nvoid visit(Variable term); void visit(Apply term); void visit(Lambda term); } In the code fragments \nof this section, new code is highlighted in italics. The Term class now de.nes a generic implementation \nof the method accept which calls the default case of the visitor. Like in the standard visitor pattern, \nvariants override this method by calling their own visit method. abstract class Term { void accept(Visitor \nv) { v.visit(this); } } class Variable extends Term { String name; Variable(String name) { this.name \n= name; } void accept(Visitor v) { v.visit(this); } } ... Note that even though the accept methods of \nclass Term and Variable are syntactically identical, a di.erent visit method is called. So far, except \nfor the additional default case of visitors and the default implementation of the accept method, set\u00adting \nup the extensible visitor framework was identical to the standard pattern. Now, we look into the implementation \nof concrete visi\u00adtors. Since we want visitors to be extensible, it should be possible to subclass a visitor \nin order to override existing methods or to add further visit methods for new variants. In the standard \nvisitor pattern, we created a new visitor for every visitor application. For example, in the code above, \nwe implemented a recursive call of the visitor Eval with the following two lines: Eval eval = new Eval(env); \nterm.fn.accept(eval); For extensible visitors, this hard-coded visitor creation does not work anymore, \nsince it does not consider the fact that we might use an extension of Eval. We use instead a scheme .rst \nproposed by Krishnamurti, Felleisen and Friedman [19]: Every visitor object has to provide factory methods \n[14] for creating all non-anonymous visitors that are being used in the visitor object. Extensions are \nsupposed to override these factory methods. Here is an extensible visitor that implements our Eval op\u00aderation. \nCompared to the version from the previous sec\u00adtion, we only added the default visit method and a factory \nmethod newEval for creating instances of Eval.This factory method gets invoked in the recursive operation \ncall of the visit method for lambda applications. class Eval implements Visitor { protected Env env; \npublic Term res; Eval(Env env) { this.env = env; } Eval newEval(Env env) { return new Eval(env); } void \nvisit(Term term) { res = term; } void visit(Variable term) { res = term; } void visit(Lambda term) { \nres = term; } void visit(.nal Apply term) { Eval eval = newEval(env); term.fn.accept(eval); eval.res.accept(new \nVisitor() { void visit(Term t) {throw new Error( function expected ); } void visit(Variable t) { throw \nnew Error( function expected ); } void visit(Apply t) { throw new Error( function expected ); } void \nvisit(Lambda t) {Eval evArg=newEval(env); term.arg.accept(evArg); Eval evFun=newEval(env.bind(t.x, evArg.res)); \nt.body.accept(evFun); res = evFun.res; } }); } } Next, we are going to extend the system by adding new \nvariants Number and Plus. We do this by .rst creating an abstract intermediate class XTerm which extends \nthe old Term class. The new variant classes are direct subclasses of XTerm. With this approach, we have \na type XTerm which subsumes our new variants. Now we have to update the Vis\u00aditor interface accordingly. \nThe extended XVisitor interface inherits all methods from the original Visitor interface and de.nes two \nadditional visit methods for the Number and Plus variant. The following code shows that there is also \nan ex\u00adtra default visit method for XTerms. We explain later how the default methods for Term and XTerm \nvariants are going to be used. Before, we focus our attention again on class XTerm. Like class Term, \nthis class de.nes an accept method, which, this time, takes an XVisitor and calls the correspond\u00ading \ndefault case. Note that this method does not override the inherited accept method. The new accept simply \nover\u00adloads the existing one. As before, the variants override the new accept method in order to call \ntheir own specialized vis\u00aditor method. The following code fragment summarizes the framework we described. \nExcept for the additional extends clauses, this code for extending an algebraic type is com\u00adpletely analogous \nto the one for de.ning a new algebraic type. interface XVisitor extends Visitor { void visit(XTerm term); \nvoid visit(Number term); void visit(Plus term); } abstract class XTerm extends Term { void accept(XVisitor \nv) { v.visit(this); } } class Number extends XTerm { int value; Number(int value) { this.value = value; \n} void accept(XVisitor v) { v.visit(this); } } ... We quickly verify that it is possible to apply an \nexisting visitor like Eval to a term structure containing variants of the extended type. Since XTerm \nand variants of XTerm do not override the accept method of Term, the default visit method of the visitor \ngets invoked as desired in this case. The rest of this section provides the last missing piece in the \npuzzle by looking at extensions of existing visitor classes like Eval. Here, we have to make sure that \nthe visit methods of extended variants are called, rather than the default method of the original visitor. \nAs explained before, for variants of extended types we automatically get into the original default method, \nso why not re.ning the dispatch here in order to incorporate the visitor s new visit methods? We do this \nby overriding the default visit method in the extended visitor. The overriding method performs a new \ndispatch with a more re.ned Term type. For this purpose, we have to insert a type cast to XTerm that \ntells the typechecker that our class is going to extend the Eval visitor speci.cally for XTerms. We defer \na discussion about this type cast until the full pattern is explained. Since we override the default \nvisit(Term term) method from class Visitor, we have to provide a new default visit(XTerm term) method \nto keep the visitor open for fur\u00adther extensions. In most cases, this new method will just refer to the \nformer default method via super.visit. class XEval extends Eval implements XVisitor {void visit(Term \nterm) {((XTerm)term).accept(this); } void visit(XTerm term) { super.visit(term); } void visit(Number \nterm) { super.visit(term); } void visit(Plus term) { ... } } Let us trace back the di.erent method calls \nfor the follow\u00ading visitor application to verify that our extended visitor is behaving in the desired \nway. Term term = new Plus(new Number(1), new Number(2)); term.accept(new XEval(env)); The initial accept \ninvocation refers to the accept method of class Term, since the dynamic type of term is Plus which does \nnot override this accept method. Method accept of class Term calls the visit(Term term) method of our \nvisi\u00adtor. Here, the argument term gets cast to XTerm and a new dispatch on accept is performed. With \nJava s strategy for .nding the best overloaded method, we refer to method accept(XVisitor v) this time. \nBut now, this method is over\u00adridden in Plus, the dynamic type of our term,and we au\u00adtomatically end up \nin the visit method for Plus.Figure 4 illustrates the full sequence of method calls for the given visitor \napplication. A full implementation of the extended Eval visitor is given below. We used a slightly di.erent \napproach for implement\u00ading the evaluation of Plus variants, compared to the version with extensible algebraic \ndatatypes in Section 2. class XEval extends Eval implements XVisitor {XEval(Env env) { super(env); }Eval \nnewEval(Env env) { return new XEval(env); }void visit(Term term) { ((XTerm)term).accept(this); } void \nvisit(XTerm term) { super.visit(term); } void visit(Number term) { super.visit(term); } void visit(Plus \nterm) { class EvalNum implements XVisitor {int res = 0; void visit(Term t) { throw new Error(); }... \nvoid visit(XTerm t) { throw new Error(); }void visit(Plus t) { throw new Error(); }void visit(Number \nt) { res += t.value; } } EvalNum evalNum = new EvalNum(); Eval eval = newEval(env); term.left.accept(eval); \neval.res.accept(evalNum); eval = newEval(env); term.right.accept(eval); eval.res.accept(evalNum); res \n= new Number(evalNum.res); } }  Figure 4: Sequence of method calls for a visitor invocation With the \nprotocol presented in this section, it is possible to implement extensible datatypes and visitors in \nan object\u00adoriented language. Datatype extensions do not require any adaptations for existing visitors. \nThey provide a default case for variants that are added later on. It is possible to extend existing visitors \nto modify the treatment of existing variants, but also to re.ne the default case for a new set of variants. \nThis approach completely decouples datatype extensions from extensions of operations.  4.3 Extensible \nAlgebraic Types in Compari\u00adson In contrast to the source-level extensible algebraic types, the extensible \nvisitor pattern opens the possibility of run\u00adtime errors because of the type cast in the extended concrete \nvisitor class XEval. For programs adhering to the design pat\u00adtern, this type cast only fails, if we try \nto apply an extended visitor to an incompatible datatype extension. For instance, if we would apply XEval \nto variants of another extension of Term, we would get a runtime error. XEval only handles variants of \nTerm, XTerm, and any extension of XTerm.So, if we only extend a datatype linearly without introducing \nany branches, the type cast will never fail at runtime. Pattern matching dispatch di.ers slightly between \nexten\u00adsible algebraic types and extensible visitors. With the exten\u00adsible visitor technique, the visit \nmethod for variants of Term is found after one double-dispatch. For variants of XTerm we need two double-dispatches \nuntil the proper visit method of the extended visitor is called. In general, for variants of the n-th \ndatatype extension, we need n + 1 double-dispatches. Now, let us look back to the extensible algebraic \ndatatypes. Here, we had an analogous situation. Every ex\u00adtension of an operation was implemented by overriding \nthe old operation. The new operation matched against the new variants and forwarded the call to the old \noperation for the existing variants. So, for n extensions, we need in total n+1 single method dispatches \nand n + 1 pattern matching state\u00adments. Only the order in which we dispatched on variants is now reversed. \nIn the solution with extensible algebraic types, the variants from the latest extension are matched .rst. \nBut since extensible algebraic datatypes can be used much more .exibly in practice, we do not need to \nobserve a special implementation pattern, like the one presented in Section 2. This is indeed one of \nthe main weaknesses of the de\u00adscribed design pattern. It is complicated to implement the full protocol \nby hand. Furthermore, even in the presence of anonymous local classes, visitors are rather heavy-weight \nconstructs, imposing a lot of implementation work on the programmer. For this reason, we decided to have \ndirect language sup\u00adport for extensible algebraic datatypes in Java. This also allowed us to implement \nthe more e.cient pattern match\u00ading scheme that was brie.y introduced in Section 3.3. 4.4 Extensibility \nIssues Extensible algebraic datatypes as well as extensible visi\u00adtors achieve simultaneous extensibility \nof types and opera\u00adtions. For both approaches, the main limitation is that we can extend a system only \nin a linear way, where each new ex\u00adtension explicitly refers to the previous one by name. Thus, it is \nnot possible to merge orthogonal extensions. The restriction to linear extensions is explicit in the \nex\u00adtensible visitor approach, where a type cast .xes a visitor extension to be used only for a speci.c \nextension branch. The switch statement for extensible algebraic types does not have this restriction. \nIt allows pattern matching against any variant of an extended type. For instance, in the following switch \nstatement, we have a switch selector of type Term, but we can also match against variants of any extension \nof Term. Term eval(Term term, Env env) { switch (term) { case Variable(String name): ... case Number(int \nval): ... default: ... } } This .exibility can be seen as an advantage or a disadvan\u00adtage. One might \nregret the loss of type security, because it is now possible to apply the eval method to a datatype extension \nof Term for which it was not designed. But of course, one can model the behaviour of extensible visitors \nwith the extensible algebraic type approach by introducing an explicit type cast. Term eval(Term term, \nEnv env) { switch ((ExtendedTerm)term) { ... } } In practice, we did not experience any problems with \nthis issue. For the applications in which we used extensible al\u00adgebraic types, namely extensible compilers \nand interpreters, we never happened to use two alternative extensions of a sin\u00adgle algebraic datatype \nsimultaneously. We also experienced that most extensions of our extensible compiler could not have been \nformulated in an orthogonal way. Therefore, the linearity restriction did not really limit the way we \nextended our system. We emphasized already that in our approach, extensibility in one dimension does \nnot require any adaptations in the other dimension due to the presence of default cases. This improves \nas is code reuse signi.cantly, as Section 5.3 will show. On the other hand, the type system does not \ndetect cases where an operation needs a re.nement.  5. EXPERIENCE 5.1 Extensible Compilers Originally, \nthe work presented in this paper was motivated by a project which aimed at implementing an extensible \nJava compiler [33, 34]. At that time and still today, it was very popular to experiment with various \nlanguage extensions of Java. Unfortunately, implementing these language exten\u00adsions turned out to be \na very di.cult and time consuming task, since a suitable compiler infrastructure was missing. But even \nif a compiler prototype was available, implemen\u00adtation of new language features was rather done in an \nad-hoc fashion by hacking a copy of the existing compiler. By doing this, the implementation of the new \nfeatures and the original version get mixed. Thus, the extended compiler evolves into an independent \nsystem that has to be maintained separately. Opposed to this destructive reuse of source code, we devel\u00adoped \na framework where extended compilers reuse the com\u00adponents of their predecessors, and de.ne new or extended \ncomponents without touching any predecessor code. Ex\u00adtended compilers are derived out of existing ones \nsimply by subclassing. Only the di.erences have to be implemented in subclasses. Thus, all extended compilers \nthat are de\u00adrived from an existing base compiler share the components of this base compiler. With this \napproach we created a com\u00adpiler infrastructure which provides a basis for maintaining all compilers together. \nOne of the main di.culties of the implementation of this compiler was the representation of abstract \nsyntax trees in an extensible fashion. The work with EspressoGrinder [23, 24, 27], a Java compiler with \na rigorous object-oriented ar\u00adchitecture, demonstrated the disadvantages of the classical object-oriented \napproach for implementing syntax trees and compiler phases. With an object-oriented approach, a com\u00adpiler \nphase gets distributed over the whole code. This makes it very di.cult to understand but also to extend. \nFurther\u00admore, adding new passes is a pain, as explained in Sec\u00adtion 1.1. Standard visitors do not provide \nan ideal solution either, because they do not allow extensibility for variants. They also tend to be \nrather heavy-weight syntactically. Extensible algebraic datatypes o.ered what we needed: extensibility \nof the datatype itself, extensibility of opera\u00adtions and a very light-weight pattern matching construct \nwhich even supports nested patterns. They allowed us to apply a functional programming style in an object-oriented \nlanguage. Object-oriented features were mainly used for providing extensibility by subclassing and overriding. \nFur\u00adthermore they were used to implement an extensible com\u00adponent framework for gluing the di.erent components \nof the compiler together in a .exible and extensible manner.  5.2 JaCo: an Extensible Java Compiler \nThe implementation of our extensible Java compiler JaCo [32] makes extensive use of extensible algebraic \ndatatypes. Since JaCo is a plain Java 2 compiler without support for extensible algebraic datatypes, \nit is not possi\u00adble to compile JaCo with itself. Instead, JaCo is compiled with an extension of itself, \nsupporting extensible algebraic types. This complicated the bootstrapping process quite a bit. The .rst \nversion of JaCo was implemented in Pizza, which already o.ers algebraic types. We then modi.ed the Pizza \ncompiler to allow a very restricted form of extensible algebraic types. With this modi.ed Pizza compiler \nwe ex\u00adtended JaCo so that this extension supported our restricted form of extensible algebraic types \nintroduced in Pizza. After this step, we were able to compile JaCo with an extension of itself and we \n.nally implemented full support for extensible algebraic types as described in [34]. Throughout the last \ntwo years we utilized our extensible Java compiler successfully in various projects. Several lan\u00adguage \nextensions have been implemented and are still being maintained. Among the implementations is a compiler \nfor Java with synchronous active objects, proposed by Petit\u00adpierre [26]. Another extension introduces \nB\u00a8uchi and Weck s compound types together with type aliases [2]. In addition, we added operator overloading \nto the Java programming language in the style proposed by Gosling [17]. Eugster, Guerraoui and Damm implemented \na domain speci.c lan\u00adguage extension supporting publish/subscribe primitives on top of JaCo [8]. A rather \nexotic extension of JaCo is an im\u00adplementation of a small language based on join calculus [12]. It replaces \nthe syntactic analyzer pass with a full compiler for join calculus that generates a Java syntax tree \nas out\u00adput. This tree is then fed into the remaining Java compiler to generate Java bytecodes. In this \nextension, JaCo is basi\u00adcally used as a backend for a compiler of a language, which has nothing in common \nwith Java. During the implementation of the extensions mentioned before, we did not have to modify the \nbase compiler a single time. Its architecture was open enough to support all sorts of extensions we needed \nso far. Changes of the base compiler were all related to minor modi.cations in the speci.cation of the \nJava programming language or to bugs found in the compiler. These changes can usually be elaborated in \nsuch a way that binary compatibility of Java class.les is not bro\u00adken. As a consequence, all compilers \nderived from the base compiler bene.t immediately from the changes, since they inherit them. Because \nof Java s late binding mechanism it is not even necessary to recompile derived compilers. JaCo PiCo \nCJavaC SJavaC 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. Lines of code Classes Algebraic types Algebraic type \nextensions Visitors Visitor extensions Visitors reused as is Visitors for extended types in JaCo Visitors \nfor extended types Visitor extensions for extended types Visitors for extended types reused as is 25590 \n134 5 0 135 4   5462 48 2 1 46 17 118 63 30 14 49 (78%) 6972 58 3 3 54 39 96 108 54 39 69 (64%) 2335 \n34 1 1 13 11 124 63 11 10 53 (84%) Table 1: Statistics for the extensible compiler JaCo and derived \ncompilers 5.3 Code Reuse in JaCo Extensions Table 1 shows some data regarding the base compiler JaCo \nand three compiler extensions: PiCo, written by Zenger [33], extends JaCo by adding extensible algebraic \ntypes, CJavaC, written by Zermatten [35], extends JaCo with compound types and type aliases, and SJavaC, \nwritten by Cavin [4], is the synchronous active objects compiler. The .rst row in Table 1 shows the code \nsize of the base compiler and all extensions (given in lines of code including comments and whitespaces). \nThese data show that all ex\u00adtensions reuse large parts of the base compiler unchanged. The next three \nrows state the number of classes, algebraic types and algebraic type extensions of the four compilers \nunder consideration. The base compiler JaCo contains .ve algebraic types. These types are used to represent \nthe abstract syntax, sym\u00adbols, types and constants. Furthermore, the implementation of the backend uses \nitems to enable delayed code genera\u00adtion [31]. Two of the three extensions of JaCo extend only the abstract \nsyntax tree type. CJavaC also extends the sym\u00adbol and thetyperepresentation. The data presented in the \nfollowing rows are supposed to give an indication how the di.erent compiler extensions bene.t from the \nuse of extensible algebraic types. The row labelled Visitors gives the number of methods that contain \nat least one pattern matching construct. This analogy be\u00adtween visitors and methods is a relatively conservative \nap\u00adproximation, because it counts methods with multiple switch statements as single visitors. The row \nlabelled Visitor exten\u00adsions shows the number of methods that override a method with a pattern matching \nconstruct in a supertype. The row labelled Visitors reused as is lists the number of visitors in the \nbase compiler that are reused in an extension with\u00adout being overridden. This number is for each extension \nthe di.erence between the number of visitors in JaCo (135) and the number in row 6. For instance, the \nPiCo extension de.nes 46 visitors, but only 17 of them override one of the 135 visitors of JaCo. So PiCo \nincorporates 118 visitors from the base compiler without changing them. Most derived compilers extend \nonly some of the algebraic types in JaCo, whereas others are left unchanged. To assess the usefulness \nof default cases in visitors, we need to disre\u00adgard algebraic data types which are unchanged. Line 8 \nof Table 1 shows the number of visitors in the base compiler that match over types which are subsequently \nextended in the derived compiler. Line 9 shows the number of visitors in the derived compiler which match \nover extended types. Line 10 gives the number of methods that override a visitor method for an extended \ntype. Line 11 gives the di.erence between lines 8 and 10, and therefore shows the number and percentage \nof visitors for extended types that are reused as is . Note that this is a lower bound for code reuse \nsince the data does not show whether a method counted in line 10 overrides a method in the base compiler \n(counted in line 8) or a method de.ned in the derived compiler (counted in line 9). The data show that \nPiCo de.nes 30 visitors for the ex\u00adtended abstract syntax tree type, 14 of them override one of the 63 \ntree visitors of the base system. So more than 75% of the tree visitors are reused without re.ning their \nde\u00adfault case for the new variants. For CJavaC we do not have to re.ne the default case of more than \n63% of visitors for extended types. For SJavaC, the numbers are even better. This compiler reuses 84% \nof the tree visitors from the base system without adapting them. These statistics indicate that for our \nextensible compiler project, operations with default cases help to improve the as is code reuse enormously. \nWithout default cases we would have to update every single operation if the corre\u00adsponding datatype was \nextended.  6. RELATED WORK For the language ML, several proposals have been made to support extensibility \nfor algebraic types. With Garrigue s polymorphic variants, an algebraic type constructor does not belong \nto any algebraic datatype in particular [15]. So there is no need anymore to de.ne an algebraic type \nbefore using a speci.c variant. Type inference is used to infer admissible variants according to their \nuse. With polymorphic variants, a programming style like the one presented in this paper is possible, \nbut results in less precise types. For functions that are de.ned by a pattern matching clause with a \nde\u00adfault case, it is possible to pass any existing variant not necessarily one, the function was intended \nfor. This is due to the fact that it is not possible to declare to which alge\u00adbraic types a variant constructor \nbelongs. In [16] Garrigue presents an alternative solution to the extensibility problem based on polymorphic \nvariants. This solution has more pre\u00adcise types, but does not provide default cases for operations. It \nsupports a modular organization of datatype extensions. But when combining two datatypes, it is necessary \nto re\u00adde.ne every function in order to forward the call to one of the previous implementations. OCaml \nsupports polymor\u00adphic variants from version 3.00 on [20]. The proposal for ML2000 contains a generalization \nof SML s exception types [1]. These extensible types are intro\u00adduced in order to tag objects to support \nruntime dispatch and type-safe downcasting. Therefore they can also be seen as an extensible form of \nalgebraic types. An extensible type is described by an initial variant constructor. Extending this type \nmeans re.ning the variant. The extended variant is a subtype of the previous one. In a pattern matching \ncon\u00adstruct it is possible to match against variants that have a common supertype, thus giving the programmer \nthe ability to de.ne a typecase facility. It is possible to implement our programming protocol with these \ntypes, but ML2000 s ex\u00adtensible types provide a slightly weaker typing, since they do not support deriving \nextended datatypes from existing types. It is only possible to add new variants to an existing type by \nspecializing a variant. So, a type like ExtendedTerm from Section 2 could not be formulated. ML2000 s \nextensi\u00adble types are a re.nement of the Object ML design of Reppy and Riecke [28]. In the literature, \nextensibility of algebraic datatypes was mostly discussed in the context of building modular inter\u00adpreters \nin functional programming languages. Existing ap\u00adproaches like [21] and [9] allow a restricted form of \nextensi\u00adbility: algebraic types are extensible, but the .nal datatype has to be closed before being used. \nFurthermore, extensions of datatypes always require updates of all existing functions to support the \nnew variants due to the lack of default cases in pattern matching constructs. On the other hand, these \napproaches support the combination of orthogonal exten\u00adsions. Basically the same holds for mixin modules \nproposed by Duggan and Sourelis [7]. Open classes, proposed by Clifton, Leavens, Chambers and Millstein, \no.er extensibility with default cases [5] for the object-oriented approach. Open classes allow the user \nto add new methods to existing classes without modifying ex\u00adisting code and without breaking encapsulation \nproperties. With open classes, a datatype is modelled by an abstract su\u00adperclass, variants are concrete \nsubclasses. New operations are speci.ed as external top-level methods. The default case is given in the \nform of a method for the abstract superclass. If a speci.c behaviour for a variant has to be provided, \nthis method has to be overridden for the variant. With open classes, we get extensibility for data and \noperations where extensions in one dimension do not require modi.cations of the other one. But in practice, \nopen classes su.er from several drawbacks. Whereas a new operation is typically de.ned as an external \ntop-level method in a single compila\u00adtion unit, extending or modifying an existing operation can only \nbe done by explicitly subclassing all a.ected variants and overriding the corresponding methods. This \nleads to an inconsistent distribution of code, making it very di.cult to group related operations and \nto separate unrelated ones. Furthermore, extending or modifying an operation always entails extensions \nof the datatype. This restricts and com\u00adplicates reuse. For instance, accessing an extended operation \nin one context and using the original operation in another one cannot be implemented in a straightforward \nway. Languages equipped with multiple dispatch o.er this functionality. For instance, MultiJava introduces \nmulti\u00admethods for Java [5]. For type-safety, MultiJava requires default implementations for generic methods \nas well. Therefore, a programming protocol similar to ours could be used to solve the extensibility problem. \nOn the other hand, multimethods do not support deep pattern matching, and they are syntactically more \nheavy-weight and less .exible to apply than our switch statements. In the context of Java it is furthermore \ndi.cult to compile multiple dispatch e.ciently. Dispatch costs are linear with the number of methods \nthat dynamically overload a method. Palsberg and Jay s Generic Visitor design pattern o.ers a way to \ncompletely decouple datatype and function de.\u00adnitions [25]. Therefore, their generic visitors are very \n.exi\u00adble to use and to extend. Since generic visitors rely on re\u00ad.ective capabilities of the underlying \nsystem, this approach lacks static type-safety and is subject to substantial runtime penalties. 7. CONCLUSION \nWe classi.ed solutions of the extensibility problem ac\u00adcording to the degree of possible code reuse. \nThe plain object-oriented and functional solution allow extensibility of datatypes and operations only \nthrough source code mod\u00adi.cations. With subclassing and by using type casts, exten\u00adsions are possible \nwithout touching source code. But de\u00adpending on the approach, an extension on the datatype side entails \nextensions of all existing operations or vice versa. A solution for the extensibility problem in which \noperations provide a default case that handles future extensions does not require adaptations of operations \nfor new datatype vari\u00adants. We introduced extensible algebraic datatypes that fa\u00adcilitate a simple programming \nprotocol supporting exten\u00adsibility with default cases. Extensible algebraic datatypes allow us to freely \nextend datatypes and operations simul\u00adtaneously and independently of each other. We presented a novel \ndesign pattern for extensible visitors with default cases, showing that it is possible to encode a similar \npro\u00adgramming protocol in an object-oriented language. This pattern does not rely on additional language \nfeatures, but is much more complicated to implement by hand. Based on extensible algebraic datatypes, \nwe designed and implemented an extensible Java compiler. For experiment\u00ading with programming language \nextensions, such an extensi\u00adble compiler is essential for rapidly implementing language extensions. Extending \nthis compiler does not require any source code modi.cations. Extended compilers evolve out of existing \nones simply by subclassing. Since they share most components with their predecessors, our technique provides \na basis for maintaining the systems together. Statistics show that extended compilers reuse large parts \nof the base com\u00adpiler unchanged. An extended compiler reuses on the aver\u00adage 75% of the operations on \nextended algebraic types from the base compiler without any adaptations. This number shows that default \ncases contribute signi.cantly to the level of as is code reuse. In the last two years our extensible \ncompiler framework was used in various other projects to quickly implement new language extensions of \nJava. Acknowledgments Special thanks to Christoph Zenger and Michel Schinz for numerous helpful discussions. \nFurthermore we thank Stew\u00adart Itzstein, David Cavin, Stephane Zermatten, Yacine Saidji and Christian \nDamm. They implemented extensions of JaCo and provided feedback on the implementation. 8. REFERENCES \n[1] A. Appel, L. Cardelli, K. Crary, K. Fisher, C. Gunter, R. Harper, X. Leroy, M. Lillibridge, D. B. \nMacQueen, J. Mitchell, G. Morrisett, J. H. Reppy, J. G. Riecke, Z. Shao, and C. A. Stone. Principles \nand preliminary design for ML2000, March 1999. [2] M. B\u00a8uchi and W. Weck. Compound types for Java. In \nProc. of OOPSLA 98, pages 362 373, October 1998. [3] L. Cardelli and P. Wegner. On understanding types, \ndata abstraction, and polymorphism. Computing Surveys, 17(4):471 522, December 1985. [4] D. Cavin. Synchronous \nJava compiler. Projet de \u00b4 semestre. Ecole Polytechnique F\u00b4ed\u00b4erale de Lausanne, Switzerland, February \n2000. [5] C. Clifton, G. T. Leavens, C. Chambers, and T. Millstein. MultiJava: Modular open classes and \nsymmetric multiple dispatch for java. In Proceedings of OOPSLA 2000, volume 35, pages 130 145, October \n2000. [6] W. R. Cook. Object-oriented programming versus abstract data types. In Foundations of Object-Oriented \nLanguages, REX School/Workshop, Noordwijkerhout, The Netherlands, 1990, volume 489, pages 151 178. Springer-Verlag, \nNew York, NY, 1991. [7] D. Duggan and C. Sourelis. Mixin modules. In Proceedings of the 1996 ACM SIGPLAN \nInternational Conference on Functional Programming, pages 262 273, Philadelphia, Pennsylvania, 24 26 \nMay 1996. [8] P. Eugster, R. Guerraoui, and C. Damm. On objects and events. In Proceedings for OOPSLA \n2001,Tampa Bay, Florida, October 2001. [9] R. B. Findler. Modular abstract interpreters. Unpublished \nmanuscript, Carnegie Mellon University, June 1995. [10] R. B. Findler and M. Flatt. Modular object-oriented \nprogramming with units and mixins. In Proceedings of the ACM SIGPLAN International Conference on Functional \nProgramming (ICFP 98), volume 34(1), pages 94 104, 1999. [11] M. Flatt. Programming Languages for Reusable \nSoftware Components. PhD thesis, Rice University, Department of Computer Science, June 1999. [12] C. \nFournet and G. Gonthier. The re.exive chemical abstract machine and the join-calculus. In Proc. 23rd \nACM Symposium on Principles of Programming Languages, pages 372 385, Jan. 1996. [13] E. Gagnon and L. \nJ. Hendren. SableCC an object-oriented compiler framework. In Proceedings of TOOLS 1998, August 1998. \n[14] E. Gamma, R. Helm, R. Johnson, and J. Vlissides. Design Patterns : Elements of Reusable Object-Oriented \nSoftware. Addison-Wesley, 1994. [15] J. Garrigue. Programming with polymorphic variants. In ML Workshop, \nSeptember 1998. [16] J. Garrigue. Code reuse through polymorphic variants. In Workshop on Foundations \nof Software Engineering, Sasaguri, Japan, November 2000. [17] J. Gosling. The evolution of numerical \ncomputing in Java. Sun Microsystems Laboratories. http://java.sun.com/people/jag/FP.html. [18] J. Gosling, \nB. Joy, G. Steele, and G. Bracha. The Java Language Speci.cation. Java Series, Sun Microsystems, second \nedition, 2000. ISBN 0-201-31008-2. [19] S. Krishnamurthi, M. Felleisen, and D. Friedman. Synthesizing \nobject-oriented and functional design to promote re-use. In European Conference on Object-Oriented Programming, \npages 91 113, 1998. [20] X. Leroy, D. Doligez, J. Garrigue, D. R\u00b4emy, and J. Vouillon. The Objective \nCaml system release 3.00, documentation and user s manual, April 2000. [21] S. Liang, P. Hudak, and M. \nJones. Monad transformers and modular interpreters. In Symposium on Principles of Programming Languages, \npages 333 343, January 1992. [22] P. M\u00a8aenp\u00a8a\u00a8a and K. Oksanen. Extensible algebraic datatypes through \nprototypes and subtyping. Unpublished, 2000. [23] M. Odersky and M. Philippsen. EspressoGrinder distribution. \nhttp://wwwipd.ira.uka.de/~espresso, Dec. 1995. [24] M. Odersky and P. Wadler. Pizza into Java: Translating \ntheory into practice. In Proc. 24th ACM Symposium on Principles of Programming Languages, pages 146 159, \nJanuary 1997. [25] J. Palsberg and C.B.Jay.The essence ofthe visitor pattern. Technical Report 5, University \nof Technology, Sydney, 1997. [26] C. Petitpierre. A case for synchronous objects in \u00b4 compound-bound \narchitectures. Unpublished. Ecole Polytechnique F\u00b4ed\u00b4erale de Lausanne, 2000. [27] M. Philippsen and \nM. Zenger. JavaParty transparent remote objects in Java. Concurrency: Practice and experience, 9(11):1225 \n1242, November 1998. [28] J. Reppy and J. Riecke. Simple objects for Standard ML. In Proc. of the ACM \nSIGPLAN 96 Conference on Programming Language Design and Implementation, pages 171 180, Philadelphia, \nPennsylvania, 1996. [29] Y. Roudier and Y. Ichisugi. Mixin composition strategies for the modular implementation \nof aspect weaving the EPP preprocessor and it s module description language. In Aspect Oriented Programming \nWorkshop at ICSE 98, April 1998. [30] P. Wadler and et al. The expression problem. Discussion on the \nJava-Genericity mailing list, December 1998. [31] N. Wirth. Compiler Construction. Addison-Wesley, 1996. \n[32] M. Zenger. JaCo distribution. http://lampwww.epfl.ch/jaco/.University of South Australia, Adelaide, \nNovember 1998. \u00a8 [33] M. Zenger. Erweiterbare Ubersetzer. Master s thesis, University of Karlsruhe, August \n1998. [34] M. Zenger and M. Odersky. Implementing extensible compilers. In Proceedings of the ECOOP 2001 \nWorkshop on Multiparadigm Programming with Object-Oriented Languages, pages 61 80, Budapest, Hungary, \nJune 2001. [35] S. Zermatten. Compound Types in Java. Projet de \u00b4 semestre. Ecole Polytechnique F\u00b4ed\u00b4eraledeLausanne, \nSwitzerland, June 2000. http://lampwww.epfl.ch/jaco/cjava.html  \n\t\t\t", "proc_id": "507635", "abstract": "A major problem for writing extensible software arises when recursively defined datatypes and operations on these types have to be extended simultaneously without modifying existing code. This paper introduces Extensible Algebraic Datatypes with defaults, which promote a simple programming pattern to solve this well-known problem. We show that it is possible to encode extensible algebraic datatypes in an object-oriented language, using a new design pattern for extensible visitors. Extensible algebraic datatypes have been successfully applied in the implementation of an extensible Java compiler. Our technique allows for the reuse of existing components in compiler extensions without the need for any adaptations.", "authors": [{"name": "Matthias Zenger", "author_profile_id": "81100449273", "affiliation": "Swiss Federal Institute of Technology, Lausanne, Switzerland", "person_id": "PP31042728", "email_address": "", "orcid_id": ""}, {"name": "Martin Odersky", "author_profile_id": "81100056476", "affiliation": "Swiss Federal Institute of Technology, Lausanne, Switzerland", "person_id": "PP14030830", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/507635.507665", "year": "2001", "article_id": "507665", "conference": "ICFP", "title": "Extensible algebraic datatypes with defaults", "url": "http://dl.acm.org/citation.cfm?id=507665"}