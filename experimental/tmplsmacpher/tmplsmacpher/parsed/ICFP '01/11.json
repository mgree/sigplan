{"article_publication_date": "10-01-2001", "fulltext": "\n Developing a Stage Lighting System from Scratch Michael Sperber Wilhelm-Schickard-Institut f\u00a8 ur Informatik \nUniversit\u00a8at Tubingen \u00a8 sperber@informatik.uni-tuebingen.de ABSTRACT Lula is a system for computer-assisted \nstage lighting design and control. Whereas other systems for the same purpose are usually the results \nof long chains of incremental improve\u00adments of historic concepts, Lula represents a complete re\u00addesign. \nWhereas other systems focus on control aspects of lighting, Lula focuses on design and generates control \nin\u00adformation from it. This approach gives signi.cantly more .exibility to the lighting designer and shortens \nthe design process itself. Lula s design and implementation draw from a number of disciplines in advanced \nprogramming. It is written in Scheme and runs atop PLT Scheme, and bene.ts from its high-level GUIlibrary. \nLula uses an algebraic model for lighting looks based on just three combinators. It employs Functional \nReactive Programming for all dynamic aspects of lighting, and is programmable via a functional-reactive \ndomain-speci.c language. Lula is an actual product and has users who have neither interest in nor knowledge \nof functional programming. 1. THE DEMANDS OF STAGE LIGHTING Live shows require lighting. This applies \nto theater, but also to concerts and industrial presentations. Lighting a stage well is surprisingly \nhard. Modern stage lighting pre\u00adscribes multiple colored light sources for a single place on stage. Even \nthough the complexity of the lighting is often not apparent to the spectator, the di.erence between white \nhead-on lighting and a setup which takes into account mod\u00adelling, focus, environmental representation, \nmood, temper\u00adature, etc. is striking. This makes lighting design a di.cult craft and an art with recognized \nmasters [17, 20]. The demands of the craft have produced a stunning ar\u00adsenal of technology available \nto today s lighting designer: Modern intelligent lighting .xtures (or just .xtures for short) have electronic \ncontrols for intensity, direction, focus, color, beam shape, and many other parameters. Their practical \nuse requires computerized control systems. Permission to make digital or hard copies of all or part of \nthis work for personal or classroom use is granted without fee provided that copies are not made or distributed \nfor profit or commercial advantage and that copies bear this notice and the full citation on the first \npage. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior \nspecific permission and/or a fee. ICFP 01, September 3-5, 2001, Florence, Italy. Copyright 2001 ACM 1-58113-415-0/01/0009 \n...$5.00. Figure 1: Set groundplan for Doctor Love. Lighting Looks. Consider a simple lighting session \nin a theatrical setting. The basic ingredients are a stage with props and actors, and simple theatrical \n.xtures with variable intensity. The play is Doctor Love:Doctor Love, a mad scientist, is working on \na new hybrid virus which attacks both humans and computer programs written in functional languages. Her \nassistant, Frederick Thirst, has to do most of the computer programming while Doctor Love works mostly \nat the bio lab during alternate shifts. Between them, one of them usually sleeps on a sofa in the lab. \nDuring the course of the play, Thirst discovers the beauty of functional languages and convinces Doctor \nLove to abandon her evil plan. As the sun rises, they fall in love on the sofa. End of play. Figure 1 \nshows the set groundplan. The director sets the following requirements for the lighting: The main acting \nareas gravitational centers for the actors movements are on the chair behind the desk, the two lab tables, \nthe sofa, and on the downstage center area between the desk and the lab tables.  When Doctor Love emits \nher evil laugh, always behind the upstage lab table, she must look particularly evil.  The contrast \nbetween the normal, sterile lighting dur\u00ading most of the play and the sunrise at the end must be very \nstrong and visible.  A lighting designer, faced with these requirements, will usu\u00adally start by lighting \nthe basic acting areas: the chair be\u00adhind the desk, the sofa and the two lab tables, and the cen\u00adter. \nEach such area will need several .xtures pointed at it to ensure good illumination and facial modelling, \npos\u00adsibly with di.ering intensities. The designer will proba\u00adbly light the two lab tables separately. \nAdditionally, she might place footramps under the downstage lab table for the Frankenstein-type evil-laugh \nlighting. A number of yellow\u00adorange backlights provide the sunrise lighting. These basic lighting components \nappear in a variety of combinations as lighting looks during the play: Basic, neu\u00adtral lighting is a \nsimple combination of the desk-area light\u00ading, the sofa, the lab table lighting (itself consisting of \ntwo subcomponents), and the center area. Monologues might dim down all but one of these components to \nhighlight a particular area. Special combinations include the evil-laugh look and the sunrise. Technically, \nall of these lighting looks are merely inten\u00adsity speci.cations for the stage .xtures if the .xtures \nare numbered with indices, looks are simply vectors of intensi\u00adties. However, it is immediately obvious \nthat the intentions of the lighting designer carry a hierarchical structure. Design Goals. Most commercial \nlighting control systems only support the construction of lighting components with depth two, and do \nnot store their hierarchical structure at all. At present, only two consoles support hierarchical mod\u00adelling \nfor lighting looks, but their usage is discouraged by in.exible user interfaces, intricate semantic issues \nand in\u00adsu.cient documentation [3, 9]. The e.ect is that existing systems represent looks at the control \nor implementation level rather than at the conceptual level of the design. In fact, the schism between \nthese two levels bears striking simi\u00adlarities to the di.erence between imperative and declarative programming. \nTherefore, the major goal of Lula is a more faithful repre\u00adsentation of the structure of a lighting design. \nThis requires re-examining all basic design premises of existing systems, and has resulted in a complete \nredesign of the very concept of the lighting control system: Lula has been developed from scratch, both \nimplementation-wise and conceptually. Lula also tries to address another shortcoming of existing systems: \nThese systems exhibit signi.cant non-linearities between the user-interface controls and the actual situation \non stage. Lighting designers often .nd themselves operating a control on the console and wondering, why \nnothing hap\u00adpens on stage, or why something di.erent happened from what they expected. As a result, Lula \ns lighting compo\u00adnent model is based on a rigorous formal speci.cation. This speci.cation is the basis \nfor Lula s internal data representa\u00adtions, but, more importantly, determines the structure of its graphical \nuser interface. The uniformity of the speci.cation is not a guarantee, but a necessary prerequisite and \ngood indicator for the usability of the interface. This Paper. The faithful representation of the structure \nof lighting looks, described in Sections 2, 3, and 4 is the main innovation of Lula, and hence the main \ntopic of this paper. Another central aspect of the system is its treatment of animated lighting, which \nbuilds upon Functional Reactive Programming, described in Section 5. The paper brie.y reviews substrate \nconsiderations in Section 6, and experience gained in practice in Section 7.  2. BUILDING CUES Consider \nthe hierarchical structure of the lighting looks as suggested by the play as shown in Figure 2. The sofa, \nfor ex\u00adample, has three .xtures pointing at it hooked to electrical channels 7, 14, and 23, at some speci.ed \nintensity. Simi\u00adlarly, the ellipses under the other basic components stand for some combinations of electrical \nchannels and the intensi-  Sun Desk Sofa Center Lab tables Frankenstein ... ... 7 14 23 ... ... DS Lab \ntables US Lab tables ... ...  Figure 2: Partial cue structure of Doctor Love. ties of their .xtures. \nThe Lab tables components has two subcomponents, each of which itself consists of subcompo\u00adnents. The \nhierarchy builds up with the Basic components for the basic stage look, and the Sunrise look consisting \nof a dimmed version of Basic and added Sun lighting, and the Evil Laugh look which features the Frankenstein \nfootramp and again dimmed basic lighting. The resulting structure of the lighting components is a di\u00adrected \nacyclic graph, and it is desirable that a lighting design system support manipulating such graphs. Lula \ncalls static lighting components cues (a somewhat unfortunate term in retrospect, but it has stuck). \nThe simplest cues represent single electrical channels. More complex cues consist of sev\u00aderal subcues \nwhich might themselves have more structure. In lighting designs more realistic than the example presented \nhere, the dag is often signi.cantly deeper. Note that cues correspond to conceptual entities in the lighting \ndesign rather than implementation details like what .xture performs what function or to which electrical \ncircuit it is connected. Fixtures occur only at the leaves of the dag structure. Above the leaf level, \nthe dag is indepen\u00addent of the concrete stage. This is an essential step forward from current commercial \nsystems which ignore the structure and represent only the individual parameter settings The example design \nabove involves only one single, addi\u00adtive operator for cue composition: The .xtures involved in lighting \nthe Lab tables cue are the union of the .xtures in DS Lab tables and US Lab tables at their respec\u00adtive \nintensities. If both component cues share a .xture, the compound cue has the .xture at the maximum of \nthe in\u00adtensities in the component cues, a principle called Highest Takes Precedence or HTP in the industry. \nTwo other combinators besides HTP have proven useful for cue construction in practice: Cue subtraction \nremovesasetof.xtures from acue. This is useful when talking about cues that result from other cues by \ntaking parts away: The entire stage without the upstage-left corner, for example.  Cue restriction combines \ntwo component cues in a similar way as HTP does, but behaves di.erently for shared .xtures: one of the \ntwo cues has precedence for specifying the intensities of shared .xtures. This oc\u00adcurs in situations \nlike The entire stage, but with the kitchen table darker than the rest.  The cue language is e.ectively \na domain-speci.c language (DSL) [22]. It has methodological similarities to Haskore [12] and recent work \nin using combinator languages to describe .nancial contracts [13]. 2.1 Simple Cue Terms Initially, it \nis easiest to consider a setting with exclusively theatrical .xtures which only have intensity control. \nHow\u00adever, the concepts presented here extend straightforwardly to multi-parameter .xtures. Section 4 \nshows how. The basic algebra for cues builds on three primitive sorts: The cue sort is for cues themselves. \nfactor represents a scalar factor; the scale function uniformly scales the inten\u00adsity of a cue. Moreover, \n.xture represents a .xture, with an assumed constant for every .xture. Here is a signature for the operations \non cues: The from.xture constructor assembles a cue from a single .xture at its maximum intensity: from.xtureA0 \n(f):=({ f} ,{ f. M} ) The scale function scales all .xtures in a cue uniformly: 0 scaleA(\u00b5,(F,p)) := \n(F,pd)where p d(f):=min(\u00b5\u00b7 p(f),M) The HTP combinator merges the .xtures involved, and as\u00adsigns maximal \nintensities: 0 from.xture : .xture . cue (F1,p1) U A scale : factor \u00d7 cue . cue .(F):=(FF),p,p2212.. \n.(f)for fF.p12 black : cue where p(f):= U : cue \u00d7 cue . cue .. p2(f) for f . F1 k : cue \u00d7 cue . cue \n\\ : cue \u00d7 cue . cue max(p1(f),p2(f)) otherwise Restriction also merges the .xtures involved, but gives \nprece\u00addence to the intensities of the second cue: The black cue denotes darkness. The scale function \nscales the intensity of a cue by some factor. (Presumably, the A0 (F1,p1)k (F2,p2):=(F1 . F2,p) signature \nwould also contain constructors for factor values. These were omitted for brevity.) The from.xture constructor \nconverts a .xture into a cue containing only that .xture at maximum intensity. The combinators U , k \n,and \\ are HTP, restriction, and cue di.erence, respectively.  2.2 Carrier Sets for Cues Ultimately, \nthe goal is to construct an equational speci.\u00adcation for the cue operators in the previous section. Since \nthe cue operators originate from the application domain where they already have .xed semantics, I.rst \nformalize the semantics, and backtrack from there to the speci.cation. A cue conceptually consists of \na set of .xtures that are part of the cue, and intensities for these .xtures. The cue contains .xture \nnotion is explicit: The model distinguishes between a cue c which does not contain some .xture f and \nd acue cwhich di.ers from c only by including f at zero intensity. The resulting algebra is called A0 \n. An intensity is a non-negative real number, bounded by some maximum value M: I := R0,+ =M Its carrier \nset A0 for .xture contains elements for all .xture .xtures. A0 is a set with: cue 00 0 Acue .P (A.xture \n) \u00d7 (A.xture . I) A0 . I is the set of partial functions from A0 to .xture .xture I. A cue must de.ne \nintensities for exactly the .xtures it contains. Hence, A0 is the largest set ful.lling the above cue \ncondition as well as: (F,p) . Acue 0 .. F = dom(p). Factors are non-negative real numbers: 0Afactor := \nR0,+  2.3 Semantics of Cues The next step in constructing A0 is assigning meaning to its constants and \noperators. The black cue is easiest: blackA0 := (\u00d8,\u00d8) p1(f)for f . F2 where p(f):= p2(f) otherwise The \ndi.erence combinator is the set-theoretic di.erence be\u00adtween the .xtures contained in the operand cue: \n(F1,p1) \\ A0 (F2,p2):=(F1 \\ F2,p1|F1\\F2 )  3. AXIOMS AND THEOREMS FOR CUES The A0 algebra has a number \nof pleasant properties which will form an axiomatic basis for the speci.cation. The proofs of the axioms \nand theorems presented are straightforward and have been omitted for brevity [21]. Here are the three \nmost immediate axioms1: 3.1 Axiom HTP is commutative and associative. 3.2 Axiom HTP and restriction \nare idempotent. For every cue c: cU A0 c = c 0 A ck c = c  3.3 Axiom For any cue c: 00 cU AA black= \nc (1) 00 ck AblackA= c (2) kA0 blackc = c (3) c\\ A0 blackA0 = c (4) 00 0 blackA\\ Ac =blackA(5) A c\\ A0 \nc =black0 (6) 1They are called axioms here because they are axioms in the resulting speci.cation. At \nthis point, they still require proofs of their validity in A0 . The theorems, in contrast, are exclusively \nderived from the axioms. Restriction is expressible in terms of HTP and di.erence:  3.4 Lemma For any \ncues a and b: 0 00 ak Ab =(a \\ Ab) U Ab Moreover, \\ and U have some of the properties of their set\u00adtheoretic \ncounterparts: 3.5 Axiom The following equations hold for all cues a, b,and c: (a U A0 b) \\ A0 c =(a \\ \nA0 c) U A0 (b \\ A0 c) (7) a \\ A0 (b U A0 c)=(a \\ A0 b) \\ A0 c (8) (a \\ A0 b) \\ A0 c =(a \\ A0 c) \\ A0 \nb (9) (a \\ A0 b) \\ A0 c =(a \\ A0 (b \\ A0 c)) \\ A0 c (10)  3.6 Theorem Restriction is associative. For \nall cues a, b,and c: 00 00 ak A(bk Ac)=(ak Ab)k Ac 3.7 Theorem Restriction left-distributes over HTP. \nFor cues a, b, c: 00 000 (a U Ab)kAc =(akAc) U A(bkAc) Note that restriction does not right-distribute \nover HTP. Finally, a number of trivial axioms concern the interaction of scaling with the various cue \ncombinators:  3.8 Axiom For any factor \u00b5 and cues a and b: scale(\u00b5, black) = black (11) scale(\u00b5, a U \nb) = scale(\u00b5, a) U scale(\u00b5, b) (12) scale(\u00b5, ak b) = scale(\u00b5, a)k scale(\u00b5, b) (13) scale(\u00b5, a \\ b) = \nscale(\u00b5, a) \\ b (14) 3.1 Differentiating Cues and Fixture Sets The de.nition of cue di.erence is somewhat \nugly: it im\u00adplicitly disregards the intensity speci.cations of its second argument, treating it as a \nmere set of .xtures. Making the distinction between a cue and its .xture set explicit yields another \ncue operator: the complement.For a cue c,the complement yields a cue which contains exactly those .x\u00adtures \nnot contained in c. Besides making the speci.cation slightly more pleasant, this step also has practical \nbearing on the use of the speci.cation for the construction of Lula s graphical user interface, as Iwill \nshow later. The new signature for cue terms includes an new sort .xtureset for .xture sets: from.xture \n: .xture . cue scale : factor \u00d7 cue . cue black : cue U : cue \u00d7 cue . cue k : cue \u00d7 cue . cue  . : \ncue . .xtureset : .xtureset . .xtureset \\ : cue \u00d7 .xtureset . cue The natural algebra for this signature, \nA1, is a straightfor\u00adward modi.cation of A0. Here are the di.erences between the two: First o., .xture \nsets are sets of .xtures: 1 1A.xtureset := P (A.xture ) Cue abstraction extracts the .rst component \nfrom a cue: . A0 (F, p):= F The complement has the set-theoretical interpretation: 1 F := A.xture \\ \nF Thus, subtracting the complement of c, c, works like apply\u00ading a stencil. Double complement is the \nidentity on .xture sets:  3.9 Axiom Forany .xtureset F , the following holds: F = F The semantics of \nthe di.erence operator needs to re.ect the change in signature: (F1,p1) \\ A1 F2 := (F1 \\ F2,p1|F1\\F2 \n) To avoid overly complicating the presentation and having to rewrite all terms involving di.erences, \ncue abstraction will sometimes be implicit from here on. With this notational agreement, all axioms of \nSection 3 hold as before. In A1 , another axiom holds: 3.10 Axiom For cues a, b,and c, the following \nequation holds: 111 1 a \\ A(b \\ Ac)=(a \\ Ab) U A1(a \\ Ac) Actually, it would be easier to make statements \nabout di.er\u00adence if the intersection operator from set theory were avail\u00adable. However, intersection \ndoes not have clear intuitive meaning when applied to lighting. Section 3.2 contains more discussion \nof this issue. 3.2 A Domain-Theoretic Interpretation of Cues Denotational semantics uses partial orderings \non the el\u00adements of semantic domains to distinguish the amount of information they contain [10]. From \na conceptual stand\u00adpoint, lighting works in a similar way: the more light there is on stage, the more \nis visible to the audience. Consequently, it is possible to de.ne an ordering on cues, induced by the \nHTP operator: a . b :.. a U b = b The meaning of the . operator becomes clearer when related to the \nsemantics: (F1,p1) . A1 (F2,p2):.. F1 . F2 and p1(f) = p2(f) for all f . F1 Thus, a . b means that all \n.xtures contained in a are also contained in b and shine at least as bright as in b. Therefore, a . b \nis pronounced a is at least as dark as b or b is at least as bright as a. 3.11 Theorem . is a partial \norder. This makes U a least upper bound. It is possible to drive the analogy between cues and semantic \ndomains even further:  3.12 Theorem Cues form a complete partial order in A1:every .-chain in A1 cue \nhas a least upper bound. Here is another straightforward correspondence of the cue algebra with semantic \ndomains: 3.13 Theorem HTP and restriction are continuous in both arguments. The relationship with domains \nends with the di.erence op\u00aderator which is continuous in its .rst but not in its second argument. This \nis hardly surprising as, conceptually, di.er\u00adence removes information from a cue. Note also that .xture \nsets are a natural abstraction of cues in a domain-theoretic sense cues and .xture sets form a Galois \nconnection [10]. The domain-theoretic interpretation of cues has no great relevance in the intensity-only \nsetting. However, it is a crucial ingredient in formulating the extension to multi\u00adparameter .xtures. \n  4. MULTI-PARAMETER FIXTURES The equational speci.cation so far is surprisingly speci.c to .xtures \nwhich allow intensity control only. Non-intensity parameters require a more elaborate treatment, both \nin the implementation and in the formal speci.cation. There are two reasons for this: Intensity is qualitatively \ndi.erent from other parame\u00adters: If the intensity is zero, no change to any of the other parameters is \nvisible. On the other hand, every change in intensity is visible, at least in principle.  Even though \nmost numeric parameters do have a lim\u00adited parameter range, they mostly do not have an ev\u00adident ordering. \n(Is a color a with a higher proportion of red than another color b larger or smaller?)  Applying the \nsemantic view to a lighting installation with multi-parameter light helps .nd a principle for resolving \nthe problem. This principle translates fairly directly into a new algebraic speci.cation for cues. The \ndomain-theoretic interpretation of cues assumes that, for any two cues a and b, a least upper bound a \nU b exists: a U b is a cue which reveals everything a and b reveal. a U b is at least as bright as both \na and b. This view is not powerful enough for handling multi-pa\u00adrameter .xtures: Even though every .xture \nin a cue a might be brighter than every .xture in cue b,the .xtures might point in di.erent directions, \ntherefore revealing some other thing entirely, and leaving the target of a in the dark. The speci.cation \nof di.erent settings for a non-intensity parameter in the same cue term is called a con.ict. Such cue \nterms do not correspond to well-de.ned parameter settings. Consequently, two cues a and b containing \nmulti-parameter .xtures can only be comparable if the non-intensity param\u00adeters of all .xtures included \nin a and b have the same set\u00adtings. This means that not all pairs of cues have least upper bounds. Furthermore, \nnot all pairs of cues have HTPs: a U b does not exist if a and b share .xtures with di.erent settings \nfor non-intensity parameters. Thus, the domain-theoretic interpretation yields a precise notion of con.icts. \nThis is in sharp contrast with existing lighting control systems which do not notify the user of con\u00ad.icts \nat all, and only o.er ad-hoc mechanisms for resolving them. In contrast, Lula informs the user when she \ntries to introduce a con.ict into the cue hierarchy, and gives (based on the speci.cation below) detailed \ninformation about the source of the con.ict. In the absence of con.icts, all results from the intensity\u00adonly \ncase carry over to multi-parameter .xtures. 4.1 Modelling Parameter Transformations Besides the issue \nof con.ict, the introduction of multi\u00adparameter .xtures requires generalizing the notion of scal\u00ading \nto arbitrary transformations of parameters. Intensity scaling stands for a function from intensity values \nto inten\u00adsity values. Similarly, all transformations represent function from parameter values to parameter \nvalues. Here are some examples beside intensity scaling: Color Set A color-set transformation sets the \ncolor of all .xtures in a cue that allow color control. Pan/Tilt Set A pan/tilt-set transformation sets \nthe pan and tilt parameters of all moving lights of a cue. X/Y/Z Set An X/Y/Z-set transformation sets \nstage coor\u00addinates for the moving lights of a cue to focus on. X/Y/Z O.set An X/Y/Z-set transformation \nmoves the light beams of moving lights by an o.set in the hori\u00adzontal plane at the speci.ed Z coordinate. \nThis is use\u00adful, for example, to correct light positioning on dancers with a preprogrammed choreography. \nEach transformation is speci.c to a certain parameter, and applies uniformly to all the .xtures in a \ncue. As the operator assembles cues by applying transforma\u00adtions and applying the cue combinators, transformations \nac\u00adcumulate in two di.erent ways: Composition arises when a transformed cue is transformed again: the \ntwo transformations compose functionally. Juxtaposition arises from the HTP combination of two cues which \ncontain a common .xture. For two in\u00adtensity transformations, juxtaposition produces their least upper \nbound. For non-intensity parameters, jux\u00adtaposition is only meaningful in the absence of con\u00ad.icts. The \nintroduction of these two concepts justi.es separating out the speci.cation of transformations into their \nown spec\u00adi.cation. The next subsection shows how composition and juxtaposition interact with the cue \ncombination operators. The signature for transformations only supports param\u00adeters for intensity and \npan/tilt. However, adding further parameters is completely analogous. The signature di.eren\u00adtiates between \nsorts for speci.c transformations for intensity and pan/tilt itrafo and pttrafo and general transformations \ntrafo. The . operators are composition operators for transfor\u00admations of individual parameters. I is \nfor juxtaposition of intensity transformations. A transformation in trafo is conceptually a tuple of \nan intensity transformation and a pan/tilt transformation: the # operator assembles one from its components. \nThe 0 operator composes two transforma\u00adtions; * is for juxtaposition. scale : factor . itrafo Eitrafo \n: itrafo .itrafo : itrafo \u00d7 itrafo . itrafo I : itrafo \u00d7 itrafo . itrafo pan/tilt : angle \u00d7 angle . \npttrafo Epttrafo : pttrafo .pttrafo : pttrafo \u00d7 pttrafo . pttrafo #: itrafo \u00d7 pttrafo . trafo 0 : trafo \n\u00d7 trafo . trafo * : trafo \u00d7 trafo . trafo Juxtaposition is conceptually a partial function; hence, it \nuses a special exception value notrafo in the trafo sort trafo. Presumably, the scale constructor builds \nintensity-scale transformations from scale values, pan/tilt constructs trans\u00adformations that set pan/tilt \nfrom two angle values. More\u00adover, Eitrafo and Epttrafo are special constants meaning no intensity (or \nno pan/tilt, respectively) transformation spec\u00adi.ed. Transformations obey the following laws: Eitrafo \n.itrafo i= i i.itrafo Eitrafo = i Epttrafo .pttrafo p = p p.pttrafo Epttrafo = p (i1#p1) 0 (i2#p2)=(i1 \n.itrafo i2)#(p1 .pttrafo p2) Eitrafo I i= i i1 I i2 = i2 I i1 (i1#Epttrafo) *(i2#p)=(i1 I i2)#p t1 *t2 \n= t2 *t1 p1 = Epttrafo ,p2 = Epttrafo =. (i1#p1) *(i1#p2) = notrafo The propagation of the notrafo exception \nvalue is implicit. It may seem strange that the speci.cation does not al\u00adlow composing two identity pan/tilt \ntransformations. This restriction re.ects Lula s user interface which distinguishes between the absence \nof a transformation and the presence of an identity transformation. Otherwise, the user could create \na con.ict simply by operating the slider associated with a pan/tilt transformation, which is not desirable. \nFinding an algebra A2 for this equational speci.cation is straightforward: transformations are functions \nwith special values for the E constructors added. Intensity transformations are mappings from intensities \nto intensities plus a bottom value. The E constructors cor\u00adrespond semantically to bottom values, hence \nthe symbols chosen for A2: 2 Aitrafo := (I . I)+ {.pttrafo} Eitrafo := .itrafo A2 uses distinguished \nvalues for the E constructors rather than the identity on the associated parameters. This in turn is \nto re.ect the con.icts of the speci.cation in the model which also is the basis for con.ict detection \nin the implementation in Lula. The scale function applies an intensity transformation in A1 receives \na new meaning in A2: it turns a factor into a function which scales intensity values: 2 scaleA(\u00b5)(i):=min(\u00b5\u00b7 \ni,M) The de.nition of A2 itrafo:A pttrafo is analogous to that of A2 pan/tilt setting consists of two \nangles. 2 R0,+ A:= angle =2p 2 22 22 Apttrafo := ((Aangle \u00d7 Aangle ) . (Aangle \u00d7 Aangle)) + {.pttrafo} \nEpttrafo := .pttrafo The pan/tilt operator constructs a constant function: A pan/tilt2 (ap,at):= (-ap,at) \n For non-bottom intensity transformations i1 and i2 or pan/ tilt transformations p1 and p2, composition \nis simply func\u00adtional composition: i1 .A2 := i1 . i2 itrafo i2 p1 .A2 pttrafo p2 := p1 . p2 As an aside, \nnote that, even if scaling is the only transfor\u00admation available for intensities, it is not possible \nto repre\u00adsent a scaling transformation by its factor, and thus achieve composition of two intensity-scaling \ntransformation by mul\u00adtiplication of their factors. To see why, consider the cue term: apply(scale(0.5),apply(scale(2),from.xture(f))) \n Composition by factor multiplication would pleasantly re\u00adduce this to: apply(scale(1),from.xture(f)) \n and, hence, from.xture(f). Unfortunately, this is wrong: There is no such thing as double maximum intensity \nfor a real .xture. Hence, apply(scale(2),from.xture(f)) is equiv\u00adalent to from.xture(f) in a faithful \nmodel. Compositionality really does require that the example term has f only at half the maximum intensity. \nTo get back to de.ning compositions for intensity and pan/tilt transformations, the two bottoms are neutral \nwith respect to composition as in the speci.cation: i.A2 itrafo .itrafo := i 2 .itrafo .A:= i itrafo \ni p.A2 itrafo .pttrafo := p 2 .itrafo .Apttrafo p := p Intensity transformations allow juxtaposition \nvia forming the least upper bound: (i1 I i2)(v) := max(i1(v),i2(v)) Finally, a transformation really \nis a tuple of an intensity and a pan/tilt transformation. Also, trafoA2 contains an exception element \ncalled itrafo : A2 := (itrafo \u00d7pttrafo)+ {itrafo} trafo notrafoA2 := itrafo Composition of two transformation \nworks by pointwise com\u00adposition and must take care to preserve exceptions: 2 22 (i1,p1) 0A(i2,p2):=(i1 \n.AA itrafo i2,p1 .pttrafo p2) 2 A itrafo 0t := itrafo 2 A t0itrafo := itrafo Juxtaposition also works \nas in the speci.cation: A2 A2 (i1,.pttrafo) *(i1,p):=(i1 Ii2,p) 2 2 (i1,p) *A(i1,.pttrafo):=(i1 IAi2,p) \n2 A (i1,p1) *(i1,p2):= itrafo for p1,p2 = .pttrafo 2 A itrafo *t := itrafo 2 A t0*itrafo := itrafo  \n4.2 Modelling Multi-Parameter Cues The new signature for cues with pan/tilt .xtures is an extension of \nthe signature for transformations. The parts not related to the application of an intensity scale are \nlargely unchanged. Dealing with con.icts requires considerably more elabo\u00adration on the semantics of \ncues on the part of the speci.\u00adcation:a con.ict happens at the level of a parameter setting for a single \n.xture, so the speci.cation needs to de.ne how cues de.ne parameter settings.To this end, the signature \nhas a new sort setting.A setting is an association of a .xture with a transformation. In the new signature, \nat setting has, for a .xture f and a transformation t, the form f@t, pronounced f is at t. The \". operator \nrelates a cue c with a setting s: c\". s means that c speci.es a setting s. The pronunciation of c\".f@t \nis c has f at t. Here is the signature: @: .xture \u00d7trafo .setting \". : cue \u00d7setting .bool from.xture \n: .xture .cue apply : trafo \u00d7cue .cue black : cue U : cue \u00d7cue .cue k : cue \u00d7cue .cue  . : cue ..xtureset \n: .xtureset ..xtureset \\ : cue \u00d7.xtureset .cue Here is an equational speci.cation for the new operators: \napply(t,black) = black apply(t,aUb) = apply(t,a) Uapply(t,b) apply(t,ak b) = apply(t,a)k apply(t,b) apply(t,a\\b) \n= apply(t,a) \\b apply(t1,apply(t2,c)) = apply(t1 0t2,c) apply(t,from.xture(f)) \".f@t a\".f@t1 .b\".f@t2 \n=.(aUb) \".f@(t1 *t2) a\".f@t1 .\u00ac(.t2.b \".f@t2)=.(aUb) \".f@t1 b\".f@t =.(ak b) \".f@t a\".f@t1 .\u00ac(.t2.b \".f@t2)=.(ak \nb) \".f@t1 a\".f@t1 .\u00ac(.t2.b \".f@t2)=.(a\\b) \".f@t1 The rules for apply look much like the rules for scale \nin the old speci.cation. However, there is an additional rule explaining the composition of transformations \nin terms of composition of its components. The rules for apply are able to propagate transformations \nto the leaves of a cue term, the from.xture terms. More\u00adover, the composition rule for apply allows squashing \nseveral nested transformations into one. In turn, the \".relation infers an obvious setting for a .x\u00adture \nfrom a leaf term of the form apply(t,from.xture(f)). The other rules propagate settings upwards inside \ncompound cues. This upwards propagation works only through the reg\u00adular cue combinators, not through \ntransformation applica\u00adtions. Hence, inferring setting information for the .xtures contained in a cue \nmeans .rst pushing the transformations inwards, squashing them there and inferring setting infor\u00admation \nfor the .xture leaf nodes, and then propagating the settings back outwards. Building an algebra A2 for \nthe speci.cation is more in\u00advolved than the construction of A1 . First o., A2 includes A1 unchanged. \nThe construction of the cue carrier must map .xtures to transformations instead of intensities as in \nA1 . A well-de.ned cue must only have de.ned transforma\u00adtion. An exceptional transformation, when part \nof a cue, produces an exceptional cue. The new A2 is a set with: cue 2222 Acue .(P(A.xture ) \u00d7(A.xture \n(Atrafo \\{itrafo})) + {icue} As above, A2 must also ful.ll the following condition: cue (F,p) .Acue 2 \n..F = dom(p). The black cue has the same meaning as before: 2 blackA:= (\u00d8,\u00d8) A single-.xture cue has \nonly an unde.ned transformation associated with it: 2 from.xtureA(f):=({f},{f .(.itrafo,.pttrafo)}) \nThe setting constructor @ is simple tupling: 22 A:= A setting trafo f@t := (f,t) Application of a transformation \ntreats all .xtures contained in a cue uniformly: 2 2 applyA(t,(F,p)) := (F,pd)with p d(f):= t0Ap(f) \nOf the cue combinators, HTP is the most interesting as it 4.3 Theorem involves the juxtaposition of \ntransformation, and, therefore, Again assume has constants c1,...,cn : cue. For each cue the potential \nfor con.icts: term t, there exists a .at cue term td equivalent to t.More\u00adover, it is possible to choose \ntd such that it contains the same (F1,p1) UA2(F2,p2):=(F1 .F2,p) . .. atoms as t. p1(f) for f .F2 Proof \nBy term rewriting, using the axioms and theorems p2(f) for f .F1 where p(f):= of the previous sections. \nD .. 2 p1(f) *Ap2(f) otherwise 2 A This de.nition is only valid if all p1(f) *p2(f)involved do not produce \nan exception. If juxtaposition does produce a transformation exception, the HTP is unde.ned, signaling \na con.ict: (F1,p1) UA2(F2,p2):= icue if there is an f .F1 nF2 with p1(f) *A2 p2(f)= itrafo Restriction \nand di.erence basically work as before: 0 (F1,p1)k A(F2,p2):=(F1 .F2,p) p1(f) for f .F2 where p(f):= \np2(f) otherwise (F1,p1) \\A0 (F1,p1):=(F1 \\F2,p|F1\\F2 ) Relating settings to cues is straightforward in \nA2: .A2 (F,p) \"(f,t):.. f .F and p(f)= t  4.1 Theorem A2 is a model of the equational speci.cation. \n 4.3 A Graphical User Interface for Cues Naturally, ordinary users prefer not to deal with algebraic \nconstructs. Therefore, Lula o.ers a simple graphical user interface for constructing and editing cues. \nThis is made possible by another algebraic result about the equivalence of cue terms to terms with bounded \nheight:  4.2 De.nition Assume constants c1,...,cn : cue.An atom is either one of the ci or a term of \nthe form from.xture(f) for a .xture constant f. A .at cue term has the following form: n si i=1 whereeachofthe \nsi is either an atom or has one of the following two forms: a1k a2k ...k awith a1,...,aatoms ni ni a1 \n\\a 2 \u00b7\u00b7\u00b7\\a with a1,...,aatoms ni ni Eacha i is either ai itself or its complement ai. The di.er\u00adence \noperator is assumed to be left-associative. The fundamental result associated with .at cue form is that \nevery cue term has one:  Figure 4: Cue editor displaying a restriction page. Flat cue form, along with \nother properties such as asso\u00adciativity or commutativity, corresponds directly to desirable properties \nof a graphical user interface. Hence, the design of Lula s editor widget for cues is based directly upon \ncue .at form. Figure 3 shows such a cue editor widget. In Lula, each cue has a name (Sofa in this case, \ntaken from yet another play) and the user constructs new cues in .at cue form where each atom in the \nsense of De.nition 4.2 is either a .xture or another named cue together with a set of transformations. \nThe white area on the left represents an si subterm, a so\u00adcalled page in the terminology of Lula: it \nis a list box show\u00ading the atomic subcues. There are three kinds of pages, HTP, Restriction,and Difference. \nThe latter two correspond directly to the form of the si subterms in De.nition 4.2; HTP pages represent \nterms of the form a1 Ua2 U...Uani This is in trivial accordance with Theorem 4.3. These terms have their \nown page type because HTP is the most common form of cue combination. The list box on the right displays \navailable .xtures, the white box to its left displays a list of already-de.ned cues; it is a tree widget, \nand the user can expand the hierarchical display by clicking on the little triangles. The cue editor \nshows an HTP page with three subcues at di.erent inten\u00adsities. The slider in the middle changes the intensities \nof selected subcues. Figure 4 shows a cue editor displaying a restriction page. Here, the .rst cue has \na special role. All subsequent cues may have a complement operator applied to it: the user can click \non the little box to the left of the Window cue to toggle the complement.  5. ANIMATING LIGHTING While \ncues are the cornerstones of lighting design, they do not cover the time element in a show: The lighting \ndesign for a theatrical performance usually consists of a sequence of cues with transitions (so-called \nfades) between them. How\u00adever, the real animated lighting extends far beyond fades between cues: even \nin theater, the lighting might have to change dynamically, concerts often involve animated multi\u00adparameter \n.xtures with impressive moving e.ects. Lula internally expresses all light changes as animations in term \nof Functional Reactive Programming or FRP. Func\u00adtional Reactive Programming is a programming technique \nfor representing values that change over time and react to events. It is suitable for a wide range of \napplications, among them graphics animations as pioneered by Elliott s Fran sys\u00adtem [2], graphical user \ninterfaces [19], and robotics [16]. As it turns out, it is also applicable to animated lighting. For \nconstructing complex animations, the user has direct access to FRP via a built-in domain-speci.c programming \nlanguage called Lulal, a restricted dialect of Scheme. Lulal allows the construction of reusable components \nfor anima\u00adtions which are accessible through a simpler graphical user interface, enabling even non-programmers \nto design their own animations. This section builds on the terminology of FRP [2]. 5.1 Presets Lighting \nanimations build upon cues as their static com\u00adponents. Procedurally, the user constructs a library of \ncues with thegraphicaluserinterfacepresented in theprevious section, and then uses these as the building \nblocks for ani\u00admated lighting. A lighting animation can create looks that do not correspond to any cue \nthe user has created: many animation operators, such as fades, have no counterpart in the cue language. \nMoreover, o.ering the HTP operator in the animation language is dangerous, as it may lead to un\u00adpredictable \ncon.icts at inopportune times. Therefore, the primitive static entity in Lulal is not the cue, but the \npreset. Just like a cue, it speci.es .xture parameter settings, and every cue is also a preset. Presets \ndi.er from cues in the set of operations available for their construction. The key ingredient for the \nrepresentation of animated lighting is the preset behavior, a specialized representation for presets \nchanging over time. Lulal o.ers a rich algebra for constructing preset behaviors, as well as traditional \nre\u00adstriction and di.erence operators on presets, but no HTP.  5.2 The Lulal Language Lulal is a higher-order, \npurely functional, strongly typed language with parametric polymorphism. Lulal s syntax is mostly borrowed \nfrom Scheme [14]. As its semantics also builds upon Scheme, the description of Lulal in the section is \nbrief and focuses on the di.erences. The design of Lulal makes a number of departures from Scheme syntax \nand semantics which gear Lulal more specif\u00adically towards its use in an end-user application. Most of \nthem are restrictions on Scheme semantics to prevent an average user from making unnecessary mistakes. \nHere is a summary of the changes: No side e.ects.  Explicit recursion is not allowed.  Lulal is strongly \ntyped. Its type system is a modi.ed version of the popular Hindley/Milner system [1]. This restricts \nexpressiveness somewhat, but catches many common programming errors before the actual show.  The language \nallows a limited form of overloading of constant values with constant behaviors.  Lulal has additional \nsyntax for dealing with the task monad, similar to Haskell s do notation [11].  Cues are prede.ned objects \nin Lulal, represented by a string literal containing its name.  Lulal s value domain includes behaviors, \nevents, and tasks for constructing reactive values. To simplify the work of the programmer, Lulal allows \na limited form of overloading: a value of a base time is also overloaded as the correspond\u00ading constant \nbehavior. This results in a programming style similar to programming Fran animations in Haskell [2]. \nTasks represent actions to be done in the reactive frame\u00adwork: a task de.nes a preset behavior as well \nas a time at which it ends. Tasks form a monad [23], a special value domain for repre\u00adsenting computations. \nLulal s use of monads for represent\u00ading tasks is similar to the one in used in Monadic Robotics [16]. \nLulal supports the usual monadic combinators return and bind as well as a Haskell-do-like sequence operator. \nWithin the monad, the Lulal semantics propagate two val\u00adues: the start time of a task s action as well \nas the preset de.ned by the previous action at its end. FRP Primitives. Lulal s basic facilities for \nFRP are similar to Fran s: it has lifted versions of the standard numerical op\u00aderations, integral and \nderivative behaviors, a primitive time behavior, and time transformation. Moreover, the user has access \nto the usual FRP event alge\u00adbra with primitive event constructors from alarm times and GUIcomponents, \nas well as the usual event-handling com\u00adbinators, the usual switcher and stepper procedures for converting \nevents into behaviors, as well as event merging. Preset Behaviors. In an animated setting, presets gener\u00adalize \nnaturally to preset behaviors. In Lulal, cues de.ne the primitive preset behaviors. A string literal \nis implicitly a ref\u00aderence to a cue. The behavior associated with a cue changes its value whenever the \nuser modi.es the cue. Lulal con\u00adtains a subset of the primitives available for cue construc\u00adtion: restrict-with \nis the lifted restriction operator, and subtract is the lifted di.erence. Transformation Behaviors. A \nLulal program can obtain new lighting animations by applying transformation behav\u00adiors to preset behaviors. \nA number of constructors for such transformations are available: Intensity Lulal treats behaviors of \nreals as intensity trans\u00adformation behaviors. Pan/tilt The pan/tilt constructor builds a pan/tilt trans\u00adformation \nbehavior from a tuple of two behaviors of reals, specifying the pan and tilt angles, respectively. It \nis also possible to construct a pan/tilt transforma\u00adtion behavior from three Cartesian coordinate behav\u00adiors \nvia a constructor called xyz. Xyz-offset creates a behavior which shifts the target of a light beam in \na speci.ed horizontal plane by two behaviors of the X and Y coordinates. Color A number of constructors \nare available for making color transformation behaviors from behaviors speci\u00adfying the RGB, HSV, or CMY \ncomponents. Applying Transformations. A number of combinators cre\u00adate new preset behaviors by combining \ntransformation be\u00adhaviors with preset behaviors: the result is a preset behavior resulting from the application \nof the values of the transfor\u00admation behavior to those of the preset behaviors. Scale scales the intensity \nof a preset behavior by a real behavior. With-pan/tilt applies the pan/tilt transformations result\u00ading \nfrom a pan/tilt transformation behavior; with-color does the same with a color transformation behavior. \n 5.3 Tasks Tasks are the top-level entities in Lulal relevant to the user: When the user speci.es an \naction that triggers an ani\u00admation, she must specify a task de.ned by the Lulal program which describes \nthe animation. A task de.nes a preset behavior as well as an event whose .rst occurrence signals completion \nof the action of the task. The user can combine arbitrary preset behaviors with events to form tasks. \nIn addition, Lulal provides fades as primitive tasks. The user can combine tasks by sequencing or running \nthe actions side-by-side.  5.4 Example Consider the following lighting assignment: A moving light follows \nan actor on stage. Another one follows the .rst one with a two-second delay. Another one follows with \na four-second delay. Assume that some sensory equipment is hooked up to the console which reports the \nactor s position. Further assume the procedure get-position returns a behavior tuple which reports the \nX, Y, and Z coordinates of the actor s head (or whatever portion of his body should be lit). Here is \nan expression yielding an appropriate task: (let* ((position (get-position)) (later-position (time-transform \nposition (delayed time -2.0))) (even-later-position (time-transform later-position (delayed time -2.0)))) \n(preset-behavior->task (restrict-with (with-pan/tilt (xyz position) \"Followspot #1\") (restrict-with (with-pan/tilt \n(xyz later-position) \"Followspot #2\") (with-pan/tilt (xyz even-later-position) \"Followspot #3\"))))) \nTime is the primitive time behavior. Delayed time-trans\u00adforms a behavior by shifting it. Preset-behavior->task \ndirectly turns a preset behavior into a task that never ends.  Figure 6: Start of playback.  5.5 Assembling \na Show FRP (or, as a matter of fact, any kind of programming) is not for every user of a lighting control \nsystem. Thus, it is crucial to make the .exibility a.orded by Lulal avail\u00adable to these user and to the \ndesigner of dynamic lighting components, but hide it from the user who merely wants to assemble a show \nfrom cues, fades and prefabricated pieces. Figure 5 shows Lula s script editor. It is essentially a sim\u00adple \nmultimedia editor (based directly on powerful compo\u00adnents already provided by the PLT Scheme system) \nwhich allows pasting events into a script. An event corresponds to an event on stage which requires a \ncoordinated lighting change. Figure 5 shows the .nal lighting event of a simple show, a fade-to-black \nwhich takes 8 seconds. Each event can triggle multiple lighting changes simultaneously, arranged sequen\u00adtially \nor in parallel. Since the multimedia editor allows including ordinary text and images, it can, for example, \nhold the playscript of a the\u00adatrical production. This has proved to be tremendous ad\u00advantage as compared \nwith traditional systems, where light\u00ading events carry numbers which the operator needs to coor\u00addinate \nwith numbers written in a paper version of the script. Figure 6 shows the beginning of playback during \na show: the script editor splits to show the progress of the lighting events in the bottom half. Lula \no.ers numerous opportu\u00adnities for manual intervention: the operator can suspend lighting changes, interrupt \nand abort actions as well as slow down or speed up the animation. Most of the GUIcontrols are directly \nhooked up to FRP components; this has made the implementation extremely simple. Figure 7: E.ect event \nin script window. Figure 7 shows how the user can access programmed ani\u00admations written in Lulal: she \nsimply speci.es a term which yields a lighting task.  6. SUBSTRATE CONSIDERATIONS Lula is written in \nScheme and runs top PLT Scheme [4]. The feature set of PLT Scheme makes it suitable for appli\u00adcation \ndevelopment in general and for Lula in particular: concurrent threads of execution,  a GUIframework \nportable between X Windows, Mi\u00adcrosoft Windows, and MacOS [7, 6] which includes a collection of GUIwidgets \nfor multimedia editors,  a higher-order, fully-parameterized module system [5],  an object system supporting \nparametric inheritance via mixins [8],  the Zodiac framework [15] for building scanners and parsers \nfor Scheme-like languages.  In particular, multithreading and the portable GUI frame\u00adwork are enabling \ntechnologies for applications like Lula. This combination is still fairly rare in functional-language \nimplementations. If functional languages are to succeed in the marketplace, more implementations must \nprovide this kind of application-level support. Two aspects of PLT Scheme have proved somewhat more problematic \nfor Lula: PLT Scheme uses a non-incremental garbage collec\u00adtor. Machines have only recently become fast \nenough make GC pauses short enough to not cause noticeable delays during complex lighting animations. \n(However, straightforward linear animations runs just .ne on a 133-Mhz Pentium.) Threads are not particularly \nlightweight each thread takes up about 20kBytes. This precludes some pro\u00adgramming styles that depend \non threads being ex\u00adtremely cheap (such as the use CML-style synchronous operations [18]), and some e.ort \nwas necessary to keep the number of threads down, particularly in the sam\u00adpling subsystem and in the \nuser interface. All in all, however, PLT Scheme has proven an excellent substrate for the development \nof Lula. 7. LULA IN PRACTICE Lula has been in development since 1997. It has since been in constant \nuse in the University Theater, and has a number of users there. It has toured with Theater U34, a local \ntheater out.t, to a number of venues in T\u00a8 ubingen, Reutlingen, Stuttgart, and Munich. It has also been \nin use at Stuttgart State Theater by the lighting designers there. In theatrical use, Lula drastically \ncuts down on the time usually needed for programming the control system, often by a factor of two or \nmore. This is signi.cant since the time spent on programming the control system is usually not available \nfor set construction or rehearsal. Moreover, allows the lighting designer or director to communicate \nthe structure of the lighting design prior to the on-stage phase. The time saved immediately translates \nto better designs. Lula is especially e.ective for touring productions: Since it allows separating the \nconceptual components of a design from its implementation, the operator can preserve large parts of the \nprogramming between venues. In this environ\u00adment, the use of Lula can dramatically improve the lighting \nbecause the time available on-stage is usually very limited. The response from users has been uniformly \npositive. The University Theater has seen a successful bootstrap of the system and conducts its own workshops \non the use of the system, taught by operators rather than computer program\u00admers. This takes about two \nhours on the average for groups of 4 12; after that, the participants are on their own, and usually do \nwell. Results are especially good when we teach lighting design in conjunction with the use of the system, \nas the principles of both go hand in hand. Perhaps surprisingly, experienced lighting operators .nd it \nharder to get used to Lula than beginners, mainly because of their long exposure to traditional lighting \ncontrol system and the resulting assumptions about how a lighting con\u00adsole works. They initially try \nto use Lula as they use a traditional system, and are disappointed when they see no signi.cant immediate \nimprovement. These designers need to see Lula applied to an existing design to see its bene.ts. The animated \nlighting component of Lula is still under development. We expect similar results in that arena. 8. CONCLUSION \nLula is a powerful system for lighting design and control. Its main departure from existing systems is \nits modelling of the conceptual structure of a lighting design rather than its implementation. This simpli.es \ninput and editing of lighting designs, and greatly improves the .exibility of the result as compared \nwith existing systems. Both design and the implementation have bene.ted from the use of advanced software \nengineering techniques: The use of a functional wide-spectrum language has greatly shortened development \ntime. The .rst proto\u00adtype of Lula (presented at CeBIT 97) was .nished in just under a week.  The rigorous \nalgebraic model for cues and its domain\u00adtheoretic interpretations have been instrumental in cre\u00adating \na consistent and powerful user interface for cre\u00adating and editing cues.  The embedded DSL approach, \npioneered in the func\u00adtional programming community is pervasive in Lula, both in the design of the cue \nalgebra and the anima\u00adtion subsystem.  Functional Reactive Programming is an ideal technique for expressing \nlighting animation.  The outward design of Lula mirrors its internal structure. Consequently, Lula demonstrates \nthat modern functional language substrates are eminently suitable for application development. Availability. \nA demo of the current stable Lula system is available under http://www-pu.informatik.uni-tuebingen. de/lula/. \nAcknowledgments. Iwould like to thank the anonymous reviewers for their excellent comments which were \ninstru\u00admental in revising the paper.  9. REFERENCES [1] Damas, L., and Milner, R. Principal type-schemes \nfor functional programs. In Proc. 9th Annual ACM Symposium on Principles of Programming Languages (1982), \nACM, pp. 207 212. [2] Elliott, C., and Hudak, P. Functional reactive animation. In Proc. International \nConference on Functional Programming 1997 (Amsterdam, The Netherlands, June 1997), M. Tofte, Ed., ACM \nPress, New York. [3] ETC, Inc. Obsession II User Manual, version 4 ed. Middleton, Wisconsin, 1998. Available \nelectronically as http://www.etcconnect.com/user_manuals/ consoles/obsn_4.pdf. [4] Felleisen, M., Findler, \nR. B., Flatt, M., and Krishnamurthi, S. The DrScheme project: An overview. SIGPLAN Notices 33, 6 (June \n1998), 17 23. [5] Flatt, M., and Felleisen, M. Units: Cool modules for HOT languages. In Proceedings \nof the 1998 ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI) (Montreal, \nCanada, June 1998), K. D. Cooper, Ed., ACM, pp. 236 248. Volume 33(5) of SIGPLAN Notices. [6] Flatt, \nM., and Findler, R. B. PLT Framework: GUI Application Framework. Rice University, University of Utah, \nAug. 2000. Version 103. [7] Flatt, M., and Findler, R. B. PLT MrEd: Graphical Toolbox Manual. Rice University, \nUniversity of Utah, Aug. 2000. Version 103. [8] Flatt, M., Krishnamurthi, S., and Felleisen, M. Classes \nand mixins. In Proc. 25th Annual ACM Symposium on Principles of Programming Languages (San Diego, CA, \nUSA, Jan. 1998), L. Cardelli, Ed., ACM Press, pp. 171 183. [9] Flying Pig Systems Ltd. WHOLEHOG II Handbook, \nversion 3.2 ed. London, UK, 1999. Available electronically as http://www.flyingpig.com/Hog2/ cgi/ftp.cgi?file=pub/nils/hogIIv3_2.pdf. \n [10] Gunter, C. A. Semantics of Programming Languages: Structures and Techniques. Foundations of Computing. \nMIT Press, Cambridge, MA, 1992. [11] Haskell 98, a non-strict, purely functional language. http://www.haskell.org/definition, \nDec. 1998. [12] Hudak, P., Makucevich, T., Gadde, S., and Whong, B. Haskore music notation an algebra \nof music . Journal of Functional Programming 6,3 (May 1996), 465 483. [13] Jones, S. P., Eber, J.-M., \nand Seward, J. Composing contracts: An adventure in .nancial engineering. In Wadler [24], pp. 280 292. \n[14] Kelsey, R., Clinger, W., and Rees, J. Revised5 report on the algorithmic language Scheme. Higher-Order \nand Symbolic Computation 11, 1 (1998), 7 105. Also appears in ACM SIGPLAN Notices 33(9), September 1998. \n[15] Krishnamurthi, S. Zodiac: A framework for building interactive programming tools. Tech. Rep. Technical \nReport CS TR 95-262, Rice University, Department of Computer Science, 1995. [16] Peterson, J., Hager, \nG., and Hudak, P. A language for declarative robotic programming. In Proceedings of the International \nConference on Robotics and Automation Information 1999 (Detroit, Michigan, May 1999), Y. F. Zheng, Ed., \nIEEE Press. [17] Reid, F. The Stage Lighting Handbook,third ed.A&#38; C Black, London, England, 1987. \n[18] Reppy, J. H. Synchronous operations as .rst-class values. In Proc. Conference on Programming Language \nDesign and Implementation 88 (Atlanta, Georgia, July 1988), ACM, pp. 250 259. [19] Sage, M. FranTk a \ndeclarative GUIlanguage for Haskell. In Wadler [24], pp. 106 117. [20] Shelley, S. L. A Practical Guide \nto Stage Lighting. Focal Press, Oxford, England, 1999. [21] Sperber, M. Computer-Assisted Lighting Design \nand Control. PhD thesis, Universit\u00a8ubingen, 2001. at T\u00a8 [22] van Deursen, A., Klint, P., and Visser, \nJ. Domain-speci.c languages: An annotated bibliography. SIGPLAN Notices 35, 6 (June 2000), 26 36. [23] \nWadler, P. Monads for functional programming. In Advanced Functional Programming, vol. 925 of Lecture \nNotes in Computer Science. Springer-Verlag, May 1995, pp. 24 52. [24] Wadler, P.,Ed. International Conference \non Functional Programming (Montreal, Canada, Sept. 2000), ACM Press, New York.  \n\t\t\t", "proc_id": "507635", "abstract": "Lula is a system for computer-assisted stage lighting design and control. Whereas other systems for the same purpose are usually the results of long chains of incremental improvements of historic concepts, Lula represents a complete redesign. Whereas other systems focus on control aspects of lighting, Lula focuses on design and generates control information from it. This approach gives significantly more flexibility to the lighting designer and shortens the design process itself. Lula's design and implementation draw from a number of disciplines in advanced programming. It is written in Scheme and runs atop PLT Scheme, and benefits from its high-level GUI library. Lula uses an algebraic model for lighting looks based on just three combinators. It employs Functional Reactive Programming for all dynamic aspects of lighting, and is programmable via a functional reactive domain-specific language. Lula is an actual product and has users who have neither interest in nor knowledge of functional programming.", "authors": [{"name": "Michael Sperber", "author_profile_id": "81100100127", "affiliation": "Univ. T&#252;bingen", "person_id": "PP14044834", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/507635.507652", "year": "2001", "article_id": "507652", "conference": "ICFP", "title": "Developing a stage lighting system from scratch", "url": "http://dl.acm.org/citation.cfm?id=507652"}