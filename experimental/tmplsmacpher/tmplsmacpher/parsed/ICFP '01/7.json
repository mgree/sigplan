{"article_publication_date": "10-01-2001", "fulltext": "\n Macros as Multi-Stage Computations: Type-Safe, Generative, Binding Macros in MacroML Steven E. Ganz \n* Amr Sabry Walid Taha Computer Science Computer Science Department of Computer Department Department \nScience Indiana University Indiana University Yale University sganz@cs.indiana.edu sabry@cs.indiana.edu \ntaha@cs.yale.edu ABSTRACT With few exceptions, macros have traditionally been viewed as operations on \nsyntax trees or even on plain strings. This view makes macros seem ad hoc, and is at odds with two de\u00adsirable \nfeatures of contemporary typed functional languages: static typing and static scoping. At a deeper level, \nthere is a need for a simple, usable semantics for macros. This paper argues that these problems can \nbe addressed by for\u00admally viewing macros as multi-stage computations. This view eliminates the need for \nfreshness conditions and tests on variable names, and provides a compositional interpre\u00adtation that can \nserve as a basis for designing a sound type system for languages supporting macros, or even for compi\u00adlation. \nTo illustrate our approach, we develop and present Macro-ML, an extension of ML that supports inlining, \nrecursive macros, and the de.nition of new binding constructs. The latter is subtle, and is the most \nnovel addition in a statically typed setting. The semantics of a core subset of MacroMLis given by an \ninterpretation into MetaML, a statically-typed multi-stage programming language. It is then easy to show \nthat MacroMLis stage-and type-safe: macro expansion does not depend on runtime evaluation, and both stages \ndo not go wrong . 1. INTRODUCTION Most real programming language implementations pro\u00advide a macro facility \nthat can be used to improve either performance or expressiveness, or both. In the .rst case, macros are \nusually used for inlining (or unfolding) partic\u00adular function calls. In the second case, macros are usually \n* This work was supported in part by the National Science Foundation under Grant # CCR-9987458. This \nmaterial is based upon work supported by the Na\u00adtional Science Foundation under Grant # CCR-0196063. \nFunded by subcontract #8911-48186 from Johns Hopkins University under NSF agreement Grant # EIA-9996430. \nPermission to make digital or hard copies of all or part of this work for personal or classroom use is \ngranted without fee provided that copies are not made or distributed for pro\u00a3t or commercial advantage \nand that copies bear this notice and the full citation on the \u00a3rst page. To copy otherwise, to republish, \nto post on servers or to redistribute to lists, requires prior speci\u00a3c permission and/or a fee. ICFP \n01, September 3-5, 2001, Florence, Italy. Copyright 2001 ACM 1-58113-415-0/01/0009 ...$5.00. used to \nde.ne new language constructs or shorthands. Many tasks can be achieved using such macro systems, includ\u00ading \nconditional compilation, con.guration of applications to particular environments, templates for parameterized \ncom\u00adputations, and even the implementation of domain-speci.c languages. Yet macros are not part of the \nstandards for the mainstream statically-typed functional languages such as MLand Haskell, even though \nthey are supported by the implementations in various forms. For example, Ocaml in\u00adcludes a set of macro-processing \ntools called Camlp4, and GHC provides some support for inlining. So, why are they ignored? Often, macros \nare considered to be either an implemen\u00adtation detail (and therefore not interesting) or, a form of black \nmagic (and therefore should be discouraged). Both these stands are unfounded. First, it is a mistake \nto give macros (or even inlining pragmas) the status of a compiler directive that the implementation \nmay or may not take into account: macros a.ect the semantics of programs (see Sec\u00adtion 2). Second, the \nabsence of a macro facility almost in\u00advariably forces programmers to resort to ad hoc solutions to achieve \nthe same functionality. There are also technical di.culties: macros are hard to specify from .rst principles. \nMacro designers (as for exam\u00adple is the case for Camlp4) often .nd themselves forced to describe macros \nat the level of program text or syntax trees. Working at this lower level means that macros can generate \nprograms that might not be well-typed, or even syntactically well-formed. In addition, the inevitable \nhygiene and scoping problems must be addressed using gensym (or freshness con\u00additions) and using many \nunintuitive equality and inequality tests on variables names [21]. Not only are such low-level speci.cations \nhard to communicate (making macros acquire the appearance of being unsystematic), they are also at odds \nwith static typing: if variable names and their binding re\u00adlationships are not known until after macro \nexpansion, it becomes hard (if not impossible) to type-check macros be\u00adfore expansion. This paper argues \nthat macro systems can be viewed for\u00admally and usefully as multi-stage computations. Multi-stage programming \nlanguages (including two-level languages [32, 16], multi-level languages [13, 14, 15, 8, 7], and MetaML[48, \n45, 4]) have been developed to provide precise and usable models of such computations that occur in multiple \ndistinct stages. Over the last few years, the study of MetaMLand related systems has resulted in a good \nunderstanding of the types and semantics of multi-stage systems. Formalizing macros as multi-stage computations \nalso em\u00adphasizes that the technical problems associated with macros are genuine: specifying the denotational \nsemantics of macros involves the same advanced tools as the denotational se\u00admantics for two-level, multi-level, \nand multi-stage languages (such as functor-categories or topoi [27, 28, 3]). A denota\u00adtional semantics \nhas particular relevance to realistic compil\u00aders, which invariably involve a translation phase. A com\u00adpositional \n(denotational) semantics is generally one of the most helpful kinds of semantics in developing and verifying \nsuch compilers [34]. In addition to dictating and controlling inlining, macros are often used to abstract \ncommon syntactic patterns in programs. In a language with higher-order procedures, es\u00adpecially a lazy \nlanguage, some of these abstractions can be expressed (maybe with a loss of e.ciency) using functions. \nBut many of the syntactic patterns over which one wants to abstract would need to bind variables. Constructs \nthat bind variables are not directly expressible using functions. For example, overloading an existing \nbinding construct such as the do-notation of Haskell to allow recursive bindings can\u00adnot be expressed \nusing functions, and requires a change to the compiler [10]. 1.1 MacroML While this paper demonstrates \nthat MetaMLis a good meta-language for de.ning macros, MetaMLis not the ideal language for writing macros: \nit does not have support for de.ning new binding constructs. This paper presents an ex\u00adpressive, typed \nlanguage that supports generative macros. This language, called MacroML, is de.ned by an interpreta\u00adtion \ninto MetaML, and can express (both simple and recur\u00adsive) inlining and the de.nition of new binding constructs. \nA key design goal for MacroMLis that it be a conserva\u00adtive extension [11] of ML. This implies that its \ntype system should include all well-typed MLprograms and that it not break the reasoning principles for \nMLprograms, such as a\u00adand \u00dfv-conversion. We also want the language to remain statically typable. Given \nthat our goal is a conservative ex\u00adtension of ML, there are some notable points about what MacroMLis \ndesigned not to do: MacroMLdoes not blur the distinction between pro\u00adgrams and data. Although many applications \nnatu\u00adrally view programs as data, there is a fundamental distinction between the two. While both programs \nand data can be represented (using, e.g., natural num\u00adbers, S-expressions), the notions of equality associated \nwith each one (syntactic and semantic equality, respec\u00adtively) cannot and should not be mixed. Furthermore, \ninternalizing syntactic equality into a language, while still maintaining an interesting semantic equality \nis nontrivial [25, 51, 45]. For better or worse, it is rel\u00adatively easy to pick one or the other, that \nis, to ei\u00adther have syntactic equality or semantic quality every\u00adwhere. In MacroML, we choose to allow \nonly semantic equality in the language and we avoid introducing syn\u00adtactic equality (on programs) by \nnot introducing any re.ective or code-inspection capabilities into the lan\u00adguage. This is achieved mainly \nthrough the next point:  MacroMLdoes not allow macros that inspect or take apart code (i.e., analytic \nmacros). This restriction seems necessary to maintain static typing. Instead all  macros in MacroMLare \nlimited to constructing new code and combining code fragments (i.e., generative macros). This paper presents \na number of examples that suggest that many useful tasks can be accom\u00adplished using such statically typed \ngenerative macros. MacroMLdoes not introduce accidental dynamic scop\u00ading and/or variable capture. These \nproblems gener\u00adally arise from an overly simplistic view of programs as data, suchasinearly LISPsystems \nor in C. The Scheme community has had a substantial role in rec\u00adognizing and addressing this problem \nand promoting the notion of hygienic macro expansion [21, 9]. More recently, there have been more sophisticated \npropos\u00adals, like higher-order abstract syntax (HOAS) [37, 24, 19, 12], and FreshML[38]. The key contribution \nof all these proposals is to provide a means to express the fact that programs are not just data. The \n.rst point is certainly inspired by multi-stage languages, but to an extent, so are the other two. A \nkey issue that arises in the presence of macros that de\u00ad.ne new binding constructs is the handling of \na-conversion. While it is not clear how this problem can be addressed in the untyped setting, it is addressed \nin MacroMLby using a type system. As such MacroMLtries to achieve a bal\u00adance between being an expressive \nmacro system and being a macro system that we can reason about. 1.2 Organization Section 2 introduces \nMacroMLby a series of motivating examples, and discusses the issue of a-equivalence in the presence of \nmacros that can de.ne new binding constructs. Section 3 reviews the MetaMLsyntax, type system, and semantics. \nSection 4 presents the main technical contri\u00adbution: a compositional interpretation of Core MacroML into \nMetaMLthat provides a semantics that is both exe\u00adcutable and reasonably easy to communicate. Neither \nthe MacroMLlanguage nor the translation use any operations nor side-conditions to generate fresh names. \nInstead this is relegated to the semantics of the target language of the translation. The target language \nitself, MetaML, has an op\u00aderational semantics de.ned using nothing but the standard notion of substitution. \nThe translation is shown to produce only well-typed MetaMLterms thus providing a type safety result for \nMacroML. Section 5 considers several extensions to Core MacroMLand discusses implementation issues. Sec\u00adtions \n6 and 7 discuss related work and conclude.  2. MACROML BY EXAMPLE In this section, we use a sequence \nof examples to intro\u00adduce the basic issues motivating and governing our design of MacroML. Each example \nis followed by a summary of the basic semantic concerns that it raises. 2.1 Simple Inlining: A First \nAttempt Consider the following code excerpt, where the functions iterate and shift_left have the expected \nmeaning: let val word_size = 8 in ... iterate shift_left word_size ... end. Here, word_size is used \npurely for reasons of clarity and maintainability in the source code, and most implementa\u00adtions are likely \nto inline it producing: ... iterate shift_left 8 ... But in a general situation where word_size is bound \nto a more complicated expression like x+4 or an expression whose evaluation might have side-e.ects like \n1/x, the situation is more delicate. Some compilers might inline x+4 and some might not. And no compiler \nis at liberty to inline expressions with e.ects: this is clear in a call-by-value (CBV) language like \nML, but it is also the case in pure languages like Haskell where compilers must restrict inlining when \ndealing with built-in monadic e.ects [40, 1]. Compilers also cannot be left to inline or not inline at \nwill when we care about resource behavior [31]. Since inlining a.ects not only the performance but also \nthe semantics of MLprograms, we elevate it to a full language construct with concrete syntax, typing \nrules, and formal se\u00admantics. In MacroML, programmers can require inlining of an expression using a new \nvariant of let-expressions called let-mac. For example, the fragment: let mac word_size = raise Unknown_size \nin ... iterate shift_left word_size ... end dictates that, even though raise Unknown_size is not an MLvalue, \nwe want it inlined, producing: ... iterate shift_left (raise Unknown_size) ... Semantics: The semantics \nof this kind of inlining is simply the standard capture-avoiding substitution of a variable by an expression \n[6, 2]. Problem: Unfortunately, while this is a good example of the essence of inlining, introducing \ninlining in this fash\u00adion (through the mere occurrence of a variable) can in\u00adterfere with established \nreasoning principles for CBV lan\u00adguages. For example, in a standard CBV calculus [39], (fny=>5)x is observationally \nequivalent to 5 since vari\u00adables are values. But in a term: let mac x = raise Error in ...(fn y => 5) \nx... end these two terms behave di.erently. In particular, the tradi\u00adtion of treating variables as values \nin CBV no longer holds, because we sometimes replace variables by non-values. , because, contrary to \nthe usual assumption about CBV variables, x is replaced by a non-value. 2.2 Functional Inlining To retain \nthe established reasoning principles of CBV lan\u00adguages, we restrict all de.nitions and uses of macros \nin MacroMLto be syntactically non-values (e.g., non-values, let-expressions, etc). Thus, we will allow \nonly macros that take arguments. Their form (as non-values) ensures that they do not interfere with a \ncommon reasoning principle for CBV languages, namely that variables are values. To illustrate functional \ninlining, consider the following ex\u00adample: mac$e=fnx=>e mac?e=e() The declared operators $ and ?, read \ndelay and force, respectively, implement a simple variant of Okasaki s pro\u00adposal for suspensions [33]. \nUnder the above macro decla\u00adrations, the expression fnx=>$(tl x) expands to the expression fnx=>fnx =>tlx,where \nx is a freshly generated name (with a base name x only to hint to its source). There are two notable \nfeatures about this example. First, we cannot de.ne $ as a CBV function since the evaluation of $e should \nnot allow the premature evaluation of e . Thus, this is a genuinely useful application of a macro sys\u00adtem. \nSecond, macro expansion should not allow the binding occurrence of x in the macro de.nition to accidently \ncapture free occurrences of x in macro arguments. Semantics: The semantics of functional inlining involves \ntwo substitutions. First, the argument of the macro application is substituted into the body. Given that \nwe are using the standard notion of substitution, the variable x in the above example cannot occur in \nthe expression bound to the vari\u00adable e. Second, the resulting macro body is substituted back into the \ncontext of application, again using the standard no\u00adtion of substitution. The example demonstrates another \nkey feature of macro systems: because macro calls can occur under binders, the semantics requires evaluation \nunder binders. This generally involves manipulating open terms which can be signi.cantly more complicated \n[48, 29, 44] than dealing only with closed terms, which is possible for most traditional programming \nlanguages (whether CBV, CBN, or call-by-need). 2.3 Recursive Macros What if we wish to perform more \ncomputations during macro expansion? Consider the classic power function pow: let fun pownx= if n=0then1elsex*(pow \n( n-1) x) in pow (2*3) (5+6) end. If we replace the fun keyword by mac, macro expansion goes into an \nin.nite loop, which is probably not the de\u00adsired behavior. What happens? Intuitively, the macro call \npow (2*3) (5+6) expands into : if 2*3 = 0 then 1 else (5+6) * (pow (2*3-1) (5+6)) which itself expands \ninto : if2*3 =0 then1 else (5+6) * (if (2*3-1) = 0 then 1 else (5+6) * (pow ((2*3-1)-1) (5+6))) and the \nexpansion goes on inde.nitely. Macro expansion can only terminate if the if-expression is evaluated dur\u00ading \nexpansion, and not reconstructed as part of the result. To require the execution of the if expression \nduring macro expansion, we must explicitly indicate that n is an early pa\u00adrameter, rather than a regular \nmacro parameter (which we call late), and annotate the term to distinguish early and late computations. \nThe intended pow macro can now be written as: letmacpow~n x= ~(if n = 0 then <1> else <x * (pow ~(n-1) \nx)>) in pow ~(2*3) (5+6) end. The two constructs e and (e) (read escape and brack\u00adets , respectively) \nare borrowed directly from MetaML. Es\u00adcape interrupts the default macro expansion mode and ini\u00adtiates \nregular MLevaluation. Brackets stops regular evalu\u00adation to return to the default macro expansion mode. \nThe expansion of the macro call above now yields: (5+6) * (5+6) * (5+6) * (5+6) * (5+6) * (5+6) * 1. \nSemantics: The need for introducing the brackets and es\u00adcape constructs is directly related to the need \nto have a well-speci.ed order for evaluating various sub-expressions. In particular, with recursion, \nit becomes clear that there are two di.erent kinds of computations: early ones and late ones. The need \nto intermix these two kinds of computation is what requires a more substantial type system than usual. \nWe must enforce what is called congruence in the partial evaluation literature: a well-formed multi-stage \ncomputa\u00adtion should not contain an early computation that depends on the result of a late computation \n[20]. A simple example of a program that the type system should reject is: let macfbn=~(if b=0 then <n> \nelse <n+1>) in fna=>fnm=>fam end. The macro application fam needs to be expanded before the lambda abstraction \nfn a => ... is ever applied. But the conditional in the if statement requires that the .rst argument \nof f be known at that time, which it is not. 2.4 De\u00a3ning New Binding Constructs We now come to a novel \nfeature of MacroML: the ability to de.ne new binding constructs in the typed setting. Let us say that \nwe are using the macros $ and ? for suspensions to implement a notion of a computation [26]. We de.ne \na suitable monadic-let for this setting as follows: mac (let seqx=e1 ine2 end)= $(let val x = ?e1 in \n?e2 end). The de.nition introduces a new binding construct let seq which expands to the core binding \nconstruct let val.For example, let seqy=f$7ingyend expands to: $(let valx=?(f$7) in ?(gx) end). Semantics: \nA key insight behind this aspect of our proposal is to allow the user to only de.ne new binding constructs \nthat follow the patterns of existing binding constructs, such as lambda abstractions, value declarations, \nand recursive declarations. In these binding constructs every occurrence of a variable can be immediately \nidenti.ed as either a binding occurrence or a bound occurrence. The semantics of our proposal is designed \nto re.ect this distinction. But even when this distinction is taken into account, a-equivalence is still \nsubtle. For example, the de.nition above cannot be rewritten into: mac (let eeqx=e1 ine2 end)= $(let \nval y = ?e1 in ?e2 end). The problem is that in the seq declaration there are two di.erent binding occurrences \nof the variable x,and each is of a di.erent nature. The .rst one (in the parameter of the macro) says \nthat there is a variable, let s call it x,which can occur free in the expression bound to e2. This means \nthat the use of the variable name x in the second declaration now has special meaning. The second declaration \nnow says use x locally as a normal variable name, but make sure that it is treated in the output of the \nmacro as the binding occurrence for the x in e2. The type system for MacroMLaddresses this issue by means \nof two mechanisms: .rst, special type environments are used to keep track of the declarations of macro \nparam\u00adeters, and most importantly, the body parameters like e2. Second the type of these body parameters \nwill explicitly carry around the name of the bindee parameter x,which comes from the .rst occurrences \nof x. The second declara\u00adtion of x is in fact a completely normal declaration. With this typing information, \nit is possible to reject the local re\u00adplacement of x into y as above. It is important to note the di.erence \nbetween this mechanism and the classic acciden\u00adtal dynamic scoping: the dependency on a free variable \nis re.ected explicitly in the type. Essentially the same prin\u00adciple underlies the recent proposal for \nimplicit parameters [22]. We know that the type system provides an adequate solution to the problem of \na-conversion in the source pro\u00adgram because the type system guarantees that well-typed MacroMLprograms \ncan be translated to MetaMLprograms, andinthe latter, a-renaming is completely standard, even in the \nuntyped setting. At this point, the reader may wonder how are variables passed around in MacroML? We \nreturn shortly to this ques\u00adtion in Section 4.  3. MULTI-STAGE LANGUAGES Macro systems introduce a \nstage of computation before the traditional stage of program execution. Early computa\u00adtions during this \nnew stage include macro expansion as well as various other traditional computations (e.g., conditionals, \napplications, etc). Multi-level languages have been developed to model such kinds of staged computation. \nThe o.er constructs for build\u00ading and combining code, often in a typed setting. Multi\u00adstage languages \nare multi-level languages that provide the user with a means of executing the generated code. The notion \nof code described here is an abstract one. For ex\u00adample, it has been proven that beta-reductions are \nsound inside this notion of code [45]. This means that code in such systems is never inspected syntactically. \nAn alterna\u00adtive, equally valid way of thinking about these languages, therefore, is that they provide \n.ne control over the evalua\u00adtion order [48, 46, 42]. A premier example of a statically-typed, functional, \nmulti\u00adstage language is MetaML. In addition to the normal con\u00adstructs of a functional language, MetaMLalso \nhas three constructs for building, e.ciently combining, and execut\u00ading code. These three constructs are \n(e), e,and run e.For the purposes of our study, we use the following small subset MetaML: e .EMetaML \n::= x |.x.e |ee | letrec fx1 x2 x3 = e1 in e2 |(e)| e |run e. Restricting the number of arguments of \nrecursive function declarations to exactly three is su.cient for our purposes, and simpli.es the presentation. \nWe present a type system for this language with the fol\u00adlowing types: t .TMetaML ::= nat |t .t |(t). \nHere nat is the type for natural numbers. Function types as usual have the form t .t. The MetaMLcode \ntype is denoted by (t). In this section we present a sound type n x : tn . GG,x : t1 .n e : t2 G .n \ne1 : t2 . t G .n e2 : t2 G .n x : t G .n .x.e : t1 . t2 G .n e1e2 : t nnn G,f :(t1 . t2 . t3 . t)n ,x1 \n: t1 ,x2 : t2 ,x3 : t3 .n e1 : t G .n+1 .n G .n G+ .n G .n letrec fx1 x2 x3 = e1 in e2 : t4 G .n (e) \n: (t) G .n+1 e : t G .n run e : t G,f :(t1 . t2 . t3 . t)n e2 : t4 e : te : (t) e : (t) Figure 1: MetaML \nType System system for MetaML. The soundness of this type system is studied and established elsewhere \n[46, 29, 44]. While this type system is not the most expressive type system available for MetaML(see \nfor example [29, 44, 4]), it is simple and su.cient for our purposes here. The type system is de.ned \na judgment G .n e : t where n is a natural number called the level of a term. The role of the notion \nof level is explained below where we consider the type rules and the semantics for brackets and escape. \nThe context G is a map from identi.ers to types and levels, and is represented by the following term \nlanguage: G ::= [] | G,x : tn . In any valid G, there should be no repeating occurrences of the same \nvariable name. We write x : tn . Gwhen x : tn is asub-term of avalid G. The rules of the type system \nare presented in Figure 1. The .rst four rules of the type system are standard, except that the level \nn of each term is passed around everywhere. Note that in the rule for lambda (and recursive functions), \nwe take the current level and use it as the level of the bound variable when we add it to the environment. \nThe rule for brackets says (e) can have type (t) when e has type t. In addition, e must be typed at level \nn +1, where n is the level for (e). The level parameter is therefore counting the number of surrounding \nbrackets. The rule for escape does basically the converse. Note, therefore, that escapes can only occur \nat level 1 and higher. Escapes are supposed to undo the e.ect of brackets. Finally, the rule for run \ne is rather subtle: we can run a term of type (t) to get a value of type t.However, we must be careful \nto note that the term being run must be typed under the environment G+, rather than simply G. We de.ne \nG+ as having the same variables and corresponding types as G, but with each level incremented by 1. Without \nthis adjustment the type system is unsafe [46, 29, 44]. Figure 2 de.nes the big-step semantics for MetaML. \nThere are a number of reasons why the big-step semantics for MetaML[29, 46] is an instructive model for \nthe formal study of multi-stage computation: .rst, by making evaluation un\u00adder lambda explicit, this \nsemantics makes it easy to illustrate how a multi-stage computation often violates one of the ba\u00adsic \nassumptions of many works on programming language semantics, namely, the restriction to closed terms. \nSecond, by using just the standard notion of substitution [2], this se\u00admantics captures the essence of \nstatic scoping, and there is no need for using additional machinery to handle renaming at runtime. The \nbig-step semantics for MetaMLis a family of partial n functions . : EMetaML . EMetaML from expressions \nto answers, indexed by a level n. Taking n to be 0, we can see that the .rst two rules correspond to \nthe rules of a CBV lambda calculus. The rule for run at level 0 says that an expression is run by .rst \nevaluating it to get an expression in brackets, and then evaluating that expression. The rule for brackets \nat level 0 says that they are evaluated by re\u00adbuilding the expression they surround at level 1. Rebuilding, \nor evaluating at levels higher than 0, is intended to elimi\u00adnate level 1 escapes. Rebuilding is performed \nby traversing the expression while correctly keeping track of levels. Thus it simply traverses a term \nuntil a level 1 escape is encoun\u00adtered, at which point the normal (level 0) evaluation function is invoked. \nThe escaped expression must yield a bracketed expression, and then the expression itself is returned. \nInteresting examples of MetaMLprograms can be found in the literature [48, 44, 42]. For the purposes \nof this paper, we focus on illustrating how three relevant kinds of computation can be achieved using \nMetaML: Evaluation Under Lambda: Consider the term .xy.(.z.z) x and let us say that we are interested \nin eliminating the inner application. In both CBV and CBN, evaluation only works on closed terms, and \ntherefore, never goes under lambda. With MetaMLit is possible to force the inner computation by rewriting \nthe expression as run (.xy. ((.z.z) (x))),and then evaluating it. The result is the desired term: .xy.x. \nWe use such a pattern of run, brackets, and escape in our interpretation of the macro language to ensure \nthat compu\u00adtations are performed in the desired order. Substitution: Consider the term (.x.f xx)(gy). \nCan we force the outer application to be done .rst, producing f (gy)(gy)? This operation is not expressible \nin CBV evaluation semantics, but is expressible in MetaMLby an\u00adnotating the term as follows: run ((.x.(f \nx x)) (gy)). Renaming: It seems not widely known that simply using the standard notion of substitution \nin de.ning the semantics of a language like MetaMLis su.cient for providing the cor\u00adrect treatment of \nfree and bound variables everywhere. In MetaML, there is never any accidental variable capture, and there \nis never any need to express any freshness conditions or to use a gensym-like operation. Our semantics \nfor MacroML is simple, because we build on the fact that using the stan\u00addard notion of substitution in \nthe MetaMLsemantics really means that renaming is taken care of.  4. CORE MACROML We are now at a point \nwhere we can precisely de.ne and interpret our macro language. We present the syntax, type system, and \nsemantics of Core MacroML. The language has the usual expressions for a CBV language, augmented with \nthe previously motivated let-mac construct for de.ning 0 e1 ..x.e 0 e2 .e3 F =.x1..x2..x3.e1[f := letrec \nfx1 x2 x3 = e1 in f] 0 0 e[x := e3] .e4 e2[f := F ] .e3 00 0 .x.e ..x.e e1 e2 .e4 letrec fx1 x2 x3 = \ne1 in e2 .e3 00 n+1 n+1 n+1 e1 .(e2) e2 .e3 e1 . e2 e1 . e3 e2 . e4 0 n+1 n+1 n+1 run e1 .e3 x. x .x.e1 \n. .x.e2 e1 e2 . e3 e4 n+1 n+1 n+1 n+1 n+1 0 e1 . e3 e2 . e4 e1 . e2 e1 . e2 e1 . e2 e1 .(e2) n+1 n+2 \n1 letrec fx1 x2 x3 = e1 in e2 n (e1).(e2) run e1 . run e2 e1 . e2 e1 .e2 n+1 . letrec fx1 x2 x3 = e3 \nin e4 Figure 2: MetaML Big-Step Semantics 1 mm x : tm .G x : t .. x2 :[x1 : t1]t2 ..and x1 : t1 .G \nS;.;.;G,x : t1 .e : t2 m 11 m S; .; .; G .x : t S; .; .; G .x : t S; .; .; G .x2 : t2 S; .; .; G ..x.e \n: t1 .t2 f :(t1,t2, [t3]t4) .t5 .S G. =G,f :(t1 .t2 .t3 .t)m S; .; .; G .0 e1 : t1 m mmmm 1 S; .; .; \nG .e1 : t2 .t S; .; .; G. ,x1 : t1 ,x2 : t2 ,x3 : t3 .e1 : t S; .; .; G .e2 : t2 mm 1 S; .; .; G .e2 \n: t2 S; .; .; G. .e2 : t4 S; .; .,x : t3;G .e3 : t4 mm 1 S; .; .; G .e1e2 : t S; .; .; G .letrec fx1 \nx2 x3 = e1 in e2 : t4 S; .; .; G .f(e1,e2, .x.e3): t5 S. =S,f :(t1,t2, [t3]t4) .t5 S. 01 ;.,x2 :[x : \nt3]t4;.,x1 : t2;G,x0 : t1 .e1 : t5 1 10 S;.;.;G .e2 : t S; .; .; G .e : t S; .; .; G .e : (t) S; .; .; \nG .1 letmac f( x0,x1, .x.x2)= e1 in e2 : t S; .; .; G .0 (e): (t) S; .; .; G .1 e : t Figure 3: MacroML \nType System macros, and the e and (e)used to control recursive inlining: e .EMacroML ::= x |.x.e |ee \n| letrec fx1 x2 x3 = e1 in e2 | letmac f( x0,x1,.x2.x3)= e1 in e2 | f(e1,e2, .x.e) |(e)| e. For clarity, \nall macros in Core MacroMLhave exactly three parameters representative of the three kinds of possible \npa\u00adrameters in MacroML. Restricting ourselves to macros with exactly three parameters allows us to avoid \nsubstantial ad\u00administrative detail in Core MacroML. The three kinds of macro arguments are as follows: \n1. x0, as indicated by the preceding , is an early param\u00adeter, which can be used during macro expansion, \n 2. x1 is a late parameter, which might appear in the out\u00adput of the expansion, and 3. .x2.x3 de.nes \na bindee/body pair of parameters, repre\u00adsenting a late parameter x3 with a variable x2.The two variables \nx2 and x3 are bound variables in the scope of the macro de.nition but they can only be used in rather \nspecial ways enforced by the type system. The variable x2 must be bound again using a regular bind\u00ading \nconstruct before x3 can be used. The variable x3 canonlybeusedinthe scopeof x2. A legal use of such \n a bindee/body pair is: letmac f( , , .x.y)= .a..x.a + x + y in ... The x in the macro declaration binds \nthe two occur\u00adrences of x in the macro de.nition! All three occur\u00adrences of x could be renamed to z without \nchanging the meaning. The semantics would, however, be changed if we only change the body of the macro \nto .a..z.a+z+y, because we would be returning a result that could have an unbound variable (that was \nbound to x)in a subterm (that was bound to y). The bindee/body parameter illustrates how de.ning new \nbinding con\u00adstructs works in MacroML. For Core MacroML we have picked the simplest binding construct \nin the lan\u00adguage, namely lambda abstraction .x.e. The other binding constructs follow naturally. The \napplication of a macro f(e1,e2, .x.e) also takes exactly three arguments: the .rst is an early argument, \nthe sec\u00adond is a late argument, and the third is a bindee/body ar\u00adgument. The bindee/body argument explains \nthe core of our treatment of new binding constructs: it must be clear what variables are free in what \nsub-expressions, and both must always be passed together. Note that a bindee/body argument must have \nthe right form for the binding struc\u00adture (in this case, lambda). For example, the application f((), \n(),.z.z + a) of the macro de.ned above expands to: 4.2 The Semantics of Core MacroML .a..x.a + x +(x \n+ a). In this section, we present the de.nition of the semantics 4.1 Typing Core MacroML The types of \nMacroMLare the same as MetaML: t .TMacroML ::= nat |t .t |(t). The type system, however, is more involved. \nTyping judg\u00adments have the form S; .; .; G .m e : t where m is the level of a term. We restrict the levels \nhere to 0 (representing early computations) and 1 (representing late computations). The environments \nhave the following roles (and de.nitions): of Core MacroMLvia an interpretation into MetaML. For any \nwell-typed Core MacroMLprogram .1 e : t the inter\u00adpretation [ .1 e : t] is a MetaMLterm. To get the .nal \nresult of running the MacroMLprogram, we simply evaluate the MetaMLterm run ([[.1 e : t]]). To get a \nmore .ne-grained view of the evaluation of [ .1 e : t] , we can view it as pro\u00adceeding into two distinct \nsteps: Macro expansion: the MacroMLprogram e expands to a MetaMLprogram e . 1 if: 1Sthe macroenvironmentItkeepstrackofthevarious \n(.).[[]]: tee. 0 macros that have been declared. 1. These bindings are 1 of e then evalu\u00adof the form \n(t1,t2, [t3]t4) .t5. In this binding, the tu\u00ad Regular execution: The expansion e ates to the answer e \n2 if:ple provides information about the three standardized parameters. Note that we write [t3]t4 to describe \nthe 0 2. .e run e bindee/body argument. Intuitively, the bindee/body 1 argument is a pair of a bound \nvariable declared to be of type t3 and an expression of type t4, which could contain a free occurrence \nof the bound variable. This notation is inspired by types in FreshML[38]. .the body parameter environment. \nIt carries bindings of the form [x : t1]t2. This environment is needed for type-checking the body of \na macro that uses a bindee/body parameter of the form .x.x1,sothatwe know that we can only use x1 at \ntype t2 in a context where x is bound (with type t1). .the late parameter environment. It carries bindings \nof the form t. This environment is needed for type\u00adchecking the body of a macro that uses a late param\u00adeter. \nIt is also used to type-check a body argument that references a bindee argument. It includes vari\u00adables \nbound by regular binding constructs. Gthe regular environment. Because we are in a multi\u00adstage setting, \nit carries bindings of the form tm . The domains of all the environments are required to be dis\u00adjoint. \nThe rules of the MacroMLtype system are presented in Figure 3. The .rst three rules deal with variable \nlookup. The .rst rule is the variable (projection) rule from MetaML. The next rule is similar, although \nit re.ects the fact that late macro parameters can only be used at level one. The third rule is also \nsimilar but it checks that the body variable is used in a context where its bindee variable has already \nbeen bound. The next three rules are standard for a multi-level lan\u00adguage. All the usual rules of SMLwould \nbe lifted in the same manner (although some care is required with e.ects. See Section 7.) The next four \nrules are speci.c to macros. The .rst rule is for a macro de.nition. Because we allow macro de.nitions \nto be recursive, the body of the macro declaration is checked under the assumption that the macro being \nde.ned is al\u00adready declared. We also add the appropriate assumptions about the bindee/body parameters, \nthe late parameter, and the early parameter to the appropriate environments. The rest of the rule is \nstandard. Macro application is also anal\u00adogous to application, although one should note that e1 and e2 \nare checked at di.erent levels. The rules for brackets and escape are special cases of the same rules \nin MetaML. Note that the only new part in the above semantics is the translation from MacroMLto MetaML. \nThe two stages of MacroMLevaluation are then just standard MetaMLre\u00adbuilding and evaluation, respectively. \nWhenever the original term does not have any code types in its MacroMLtype, the latter step should coincide \nwith standard MLevaluation. Figure 4 presents the translation, .rst de.ned on environ\u00adments, and then \nde.ned on judgments. Although the trans\u00adlation can be made to map untyped terms to untyped terms, it \nis context-sensitive, and it is therefore easier to de.ne it on judgments of well-typed Core MacroMLprograms. \nTo avoid the risk of potentially confusing notation, the trans\u00adlation maps judgments to terms (rather \nthan judgments to judgments), as the full MetaMLjudgments are easy to re\u00adconstruct. Empty environments \nare mapped to empty environments. The binding for a macro is translated into a MetaMLtype that, in essence, \nre.ects the semantics of the special notation we have used: t1 .(t2).((t3).(t4)) .(t5) corresponds to \na function that takes three (curried) param\u00adeters. The .rst parameter is a true value of type t1 cor\u00adresponding \nto the early parameter. The second parame\u00adter, however, is a delayed (or code) value of type t2 corre\u00adsponding \nto the late parameter. The third parameter (the bindee/body parameter) is in fact translated to a function \nfrom code to code. It is at this point that we can start to explain how the interpretation of the bindee/body \nparame\u00adters works. Recall that in the examples section we promised to explain how variables are passed \naround. The answer is, in fact, that variables are never passed around! During macro-expansion time, \nthe bindee/body parameter is passed in what can be considered its Higher-order Abstract Syntax (HOAS) \nrepresentation. The type of a bindee/body param\u00adeter is also translated to a function type. Naturally, \nthis is consistent with the external type of this parameter. The type of a late parameter is simply a \ndelayed (or code) version of the MacroMLtype of that parameter. No translation is shown for regular environments, \nas the translation is simply the identity embedding. The translation on judgments proceeds as follows. \nTerms that do not involve macros are translated homomorphically. Late parameters are translated by putting \nan escape around Environments [[\u00d8]] = \u00d8 [[S,f :(t1,t2,[t3]t4) .t5]] = [ S]],f :(t1 .(t2).((t3).(t4)) \n.(t5))0 [[.,x2 :[x1 : t1]t2]] = [ .]],x2 :((t1).(t2))0 [[.,x: t]] = [ .]],x: (t)0 Lambda Terms 1 [ S; \n.; .; G .m e1 : t2 .t]] = e mm m .G [ S;.;.;G,x: t1 .e: t2]] = e [ S; .; .; G . m e2 : t2]] = e 2 x: \nt mm m [ S; .; .; G .x: t]] = x [ S; .; .; G ..x.e : t1 .t2]] = .x.e. [ S; .; .; G .e1e2 : t]] = e 1e2 \n1 m m mm [ S; .; .; G,f :(t1 .t2 .t3 .t)m ,x1 : t1 ,x2 : t2 ,x3 : t3 . [ S; .; .; G,f :(t1 .t2 .t3 .t)m \n.m e2 : t4]] = e 2 e1 : t]] = e 2 [ S; .; .; G .m letrec fx1 x2 x3 = e1 in e2 : t4]] = letrec fx1 in \ne = e x2 x31 Macros x: t .. x2 :[x1 : t1]t2 ..and x1 : t1 1 .G [ S; .; .; G .1 x : t]] = x [ S; .; .; \nG .1 x2 : t2]] = (x2 (x1)) [[S,f :(t1,t2,[t3]t4) .t5;.,x2 :[x : t3]t4;.,x1 : t2;G,x0 : t10 .1 e1 : t5]] \n= e 1 [[S,f :(t1,t2,[t3]t4) .t5;.;.;G .1 e2 : t]] = e 2 [ S; .; .; G .1 letmac f( x0,x1,.x.x2)= e1 \nin e2 : t]] = (letrec fx0 x1 x2 = ( )(inee1 2)) [ S; .; .; G .0 e1 : t1]] = e [ S; .; .; G .1 e2 : t2]] \n= e . 1 . 2 [ S; .; .,x: t3;G .1 e3 : t4]] = e 3 f :(t1,t2,[t3]t4) .t5 .S [ S; .; .; G .1 f(e1,e2,.x.e3): \nt5]] = (fe 1 )(.x.ee2 3)) ( Code Objects 1 0 [ S; .; .; G .[ S; .; .; G . )]]=te e: t]] = e e: ( e: \nt]] = e [ S; .; .; G .0 (e): (t)]] = (e ) [ S; .; .; G .1 Figure 4: Translating MacroML to MetaML them. \nThe intuition here is that late parameters only occur inside the de.nition of a macro, and when they \noccur, they are supposed to be spliced into the context where they are used in order to appear in the \noutput of macro expansion as expected. The key rule in the translations is the one for the body parameters: \nwhen a body parameter x2 is used in the body of a macro de.nition, its translation corresponds to an \nap\u00adplication of x2 to a piece of code carrying the corresponding bindee parameter x1. All of this is \nescaped so that the appli\u00adcation is performed at macro expansion time. To understand what is going on \nhere, keep in mind the translation of the environment ., and note that it introduces an arrow type out \nof nowhere during the translation. Thus, in the target of the interpretation, x2 has an arrow type. This \nis because, as we said earlier, the translation produces code that is passing around a HOAS representation \nof the bindee/body pair. Macro declarations are translated to escaped function dec\u00adlarations, i.e., function \ndeclarations that are to be executed during expansion. Note however that the body of the func\u00adtion being \nde.ned and the context where it is used are both in brackets. This is because we want to treat both as \ncode, except in places where the translation has added other es\u00adcapes. A macro application is translated \ninto an escaped appli\u00adcation. The .rst (early) argument to the application is not bracketed, but the \nsecond (late) argument is. As hinted earlier by the translation of the types, the bindee/body ar\u00adgument \nis translated into a function whose body is itself a piece of code. Intuitively, making the body a piece \nof code delays its evaluation. It is worth noting that the HOAS en\u00adtities only exist during the .rst \nstage (macro expansion), and not during the execution of the program proper. The translation of brackets \nand escape is straightforward.  4.3 Examples We illustrate the e.ect of the translation on three simple \nexamples. The translation produces a few adminstrative bracket-escape redices that can be easily eliminated, \nand so we omit those for clarity. The simplest macros use just late arguments, as in: let mac $e=fnx=>e \ninfn x=> $(tlx) end. In this case, a macro is translated into a function that takes a piece of code and \nreturn a piece of code. The application of the macro is translated into an escaped (i.e.,level 0) function \napplication to a piece of code. The translation of the above term results in the following code fragment: \n~(letrec $e=<fnx=>~e> in <fn x => ~($ <tl x>)>) end. When this expression is evaluated, it results in \na piece of code that is spliced into the context, which is ultimately the program that results from macro \nexpansion. Recursive macros usually require early arguments to con\u00adtrol the amount of inlining, as in: \nlet mac pow ~n x = ~(if n=0 then <1> else <x * (pow ~(n-1) x)>) in pow ~(2*3) (5+6) end. This macro is \ntranslated to the MetaMLterm: ~(letrec pownx= (if n=0 then <1> else <~x * ~(pow (n-1) x)>) in (pow (2*3) \n<5+6>)) end. Note that the early argument is not passed as a piece of code: its value is needed during \nexpansion. Finally we look at macros that bind parameters, as in: let mac (let seqx=e1ine2 end) = $ (let \nval y = ?e1 in ?e2 end) in (let seqy=(f$7) ing~y) end which corresponds to passing both a late argument \nand a bindee/body argument and can be translated to: ~(letrec seq e1 e2 = <$((fn x => ?~(e2 <x>)) ?~e1)> \nin <~(seq <f $7> (fn y => <g y>))>) end. We have not expanded the macros $e and ?e to avoid clutter. \nThe translation shows that the term <g ~y> in the macro call is parameterized over the variable y. In \nthe output of the macro the term is instantiated to use the variable x. Hence the binding for x introduced \nby the macro captures the variable x occurring in the output of the macro. 4.4 Type Safety As mentioned \nin the introduction, de.ning the seman\u00adtics of Core MacroMLby interpretation into MetaMLmakes proving \ntype safety fairly direct. In what follows, we state and outline the proof of this result. Theorem 4.1 \n(Type Safety). If []; []; []; [] .m e : t is a valid MacroML judgment, then translating it to MetaML \nyields a well-typed MetaML program, and executing that pro\u00adgram does not generate any MetaML runtime \nerrors. Proof. The .rst part is by Lemma 4.2, and the second part follows from the type safety property \nof the MetaML type system presented in previous work [46, 29]. In the statement of the theorem, MetaMLruntime \nerrors include both errors that might occur at macro expansion and runtime errors (de.ned precisely in \n[46, 29, 44]). The nec\u00adessary auxiliary lemma states that our translation preserves typing. Lemma 4.2 \n(Type Preservation). If S; .; .; G .m e : t is a valid MacroML judgment, then [ S]], [ .]], [ .]], G \n.m [ S; .; .; G .m e : t]] : t is a valid MetaML judgment. Proof. Routine induction on the height of \nthe derivation of S;.;.;G .m e : t.  5. PRACTICAL EXTENSIONS OF CORE Core MacroMLhandles simple functional \ninlining, recur\u00adsive inlining, and the de.nition of simple binding constructs. By design, Core MacroMLis \na minimal language whose pur\u00adpose is to demonstrate how the main semantic subtleties of a typed macro \nsystem can be addressed. We have im\u00adplemented Core MacroMLusing a toy implementation of MetaML. We have \nused the implementation to run a bench\u00admark of simple programs in Core MacroML, and the results have \nconsistently been as expected. In this section, we de\u00adscribe extensions of Core MacroMLwith additional \nfeatures that would be desirable in a practical implementation. We expect that all these extensions are \nnot hard to implement. Let Bindings: In the introduction, we have presented exam\u00adples of let-expression \nmacros with only one binding. How\u00adever, the same macro de.nition can be used to expand let\u00adexpressions \nwith multiple bindings. For this purpose, we propose the use of a comprehension-like notation to allow \nthe user to express such macros. For example, the expres\u00adsion: let mac (let seq x{i} = e1{i} in e2 end) \n= $(let val x{i} = (print (Int.toString i); ?e1{i}) in ?e2 end) in let seqy=f$7 seqz=hy in g z end end \nwouldexpandto: $(let val x1 = (print (Int.toString 1); ?(f $7)) val x2 = (print (Int.toString 2); ?(h \nx1)) in ?(g x2) end) where it becomes apparent that i is an implicit comprehen\u00adsion parameter that gets \nbound to the index of the binding under consideration, and that x{i} and e{i},are the pa\u00ad rameters for \nthis ith-binding. Note that the number of declarations (the range of i) will be known at translation \ntime, as it is manifest from the ap\u00adplication of the macro. However, because vanilla MetaML does not \nhave support for constructing declarations of ar\u00adbitrary length, the most direct approach to interpret \nthis proposal would be to produce one MetaMLfunction for each macro application. This trick is similar \nto polyvari\u00adant specialization in partial evaluation [20]. The obvious disadvantage of this approach \nis that it in.ates the size of the generated MetaMLprogram. We would like to explore extensions to MetaMLthat \nwould allow us to interpret this new construct in a more natural fashion. Recursive Bindings: A simple \nbut still important issue is how recursive binding constructs should be treated. In par\u00adticular, when \na macro is de.ning a new binding construct in terms of an existing recursive binding construct, this \nin\u00adformation should be maintained in the type of the macro. Consider the following declaration: mac (let \nfin x{i} _ = e1{i} in e2 end) = (let fun x{i} _ = e1{i} in e2 end). This declaration may appear ambiguous \nbecause we can ei\u00adther expand the fin comprehension into a sequence of fun declarations or a sequence \nof mutually-recursive ( anded ) fun declarations. However, this can be completely deter\u00admined by how \nthe fin construct is used: if it is used as a disjoint sequence, then that is what should be produced. \nIf it is used as an anded sequences, then the result should be like-wise. In the latter case, however, \nwe need to check that the parameters to the anded sequences of fins should not have duplicate variables \nnames. All these checks can be done statically. Dist-.x Operators: Finally, we come to an extension that \nis rather orthogonal to the rest of our proposal. However, in practical macro systems, it is a valuable \naddition. In particular, it is relatively easy to add dist-.x operators to our language. The key idea \nis that each macro de.nition should still be determined by the .rst symbol used in its name. With such \nan extension, it is possible to de.ne some other basic constructs in a language: mac {if, then, else} \nif c then t else f = case c of true => t | false => f. The syntax simply extends what we have seen before \nby a declaration of keywords that can be used in conjunction with the macro if. Then, the rest of the \nargument list dictates the dist-.x arity of this macro. The only com\u00adplication with the introduction \nof such macros is that they make parsing context sensitive. However, this is already the case in SMLbecause \nof in.x operators. 6. RELATED WORK Our approach for deriving the type system for MacroML was to .rst \ndevelop the translation in an essentially untyped setting, and then to develop a type system that characterizes \nwhen the result of the translation is a well-typed MetaML program. The earliest instance of such a translation \nap\u00adpears in a work by Wand [50]. Because we start with the untyped setting, we expect that similar derivations \nare pos\u00adsible for richer MetaMLtype systems (including features such as polymorphism and e.ects, for \nexample). Syntactic abstraction in Chez Scheme [9] promotes the idea that macros should operate on an \nabstract datatype of code (called a syntax-object) rather than strings or parse trees. Our brackets are \nsimilar to syntax-objects but are more abstract in that they do not allow the analysis (tak\u00ading apart) \nof code. To deal with macros that bind vari\u00adables, Chez Scheme includes runtime predicates that check \nwhether an identi.er would be captured in the output of the macro. Our proposal relies instead on distinguishing \nbind\u00ading and usage occurrence of variables once and for all in the source language, thereby avoiding \nthe need to inspect vari\u00adables at runtime. It remains an interesting question whether or not a safe and \nexpressive type system can be found for the full macro system of Chez Scheme. The earliest use of a binary \ntype constructor to indicate the type of a piece of code with a free variable in it such as our [t1]t2 \nseems to have been in Miller s proposal for an extension of MLto handle bound variables in data struc\u00adtures \n[24]. Miller s proposal is more ambitious than ours in that it tries to deal with data types that have \nsome bind\u00ading structure, but it neither addresses the issue of de.ning new binding constructs in a user-level \nlanguage nor gives a formal semantics for the proposed constructs. Indeed, work by Pa.sali\u00b4c, Sheard \nand Taha suggests that Miller s proposal may need to be reformed before it can have a simple seman\u00adtics \n[36]. More recently, FreshML[38] has also used a similar binary type constructor based on a denotational \nmodel. The Twelf system uses a mixture of dependent types that seems to be, at least intuitively, similar \nto our [x : t1]t2 construc\u00adtion. To our knowledge, our work seems to be the .rst to investigate the application \nof such type systems directly to the domain of macro systems, and to expose the connections with multi-stage \nlanguages and higher-order syntax. Gri.n [17] shows how mathematical notational de.ni\u00adtions can be interpreted \n` ala Church into NuPRL, which is a theorem-proving environment based on a strongly nor\u00admalizing lambda \ncalculus. He formalizes the notion of a no\u00adtational de.nition as what he calls .-equations, and gives \na very clear and complete formal account of how de.nitions of new binding constructs can be interpreted \nin a (normaliz\u00ading) lambda calculus. Our work shows that multi-stage lan\u00adguages allow us to achieve a \nsimilar result in a typed lambda calculus that is not necessarily strongly normalizing. Thus, we are \nable to handle, for example, a kind of recursive notational de.nition. Gri.n s work also gives a clear \nfor\u00admulation of the set of terms that can be treated as binding patterns (in the arguments of macros, \nfor example), and giving us a clear interpretation of such patterns into plain lambda calculus expressions. \nIn our present work we opted for conceptual clarity rather than generality, and used only one binding \npattern (.x.y) in our formal development. Cardelli, Matthes, and Abadi [5] give one of the most expressive \nsystems for syntactically-extensible programming languages. Their system allows the modi.cation, extension, \nand restriction of an existing grammar, all within a frame\u00adwork that respects binding structure. Not \nonly that, but their system also pays careful attention to the issue of pars\u00ading (concrete syntax) of \nthe new constructs. Typing is not addressed explicitly, but because parsing is decidable, typing the \nextended language seems automatic. Part of the inspiration for the present paper is Monnier and Shao \ns work on inlining as staged computation [30], where they present a thorough investigation of the utility \nof two-level intermediate languages for an inlining compiler. This is the .rst work known to us that \napplies ideas from multi-level languages to intermediate languages for compil\u00aders. One di.erence between \nthis work and ours is that we are interested in design and semantics issues for user-level pro\u00adgramming \nlanguages, rather than an implementation tech\u00adnology. Thus, the issue of de.ning new binding constructs \ndoes not arise in their setting. Nevertheless, the approach presented here would also apply to their \ntwo-level languages. Their work also address modules and separate compilation in addition to the issue \nof code duplication, which we have not considered. It will be very interesting in the future to explore \nthe possibility of combining the two works in a uni\u00adform framework. The idea of inheriting the binding \nstructure from existing constructs to keep the declarations of new constructs concise appears to be novel. \nNot all type systems for MetaMLrequire that the type of the generated code be known at compilation-time. \nMore permissive type systems where typing the generated code can be postponed until runtime have also \nbeen studied [43]. Care should be taken when using this approach, however, as it can sometimes have an \ne.ect on the equational theory [47]. A close relative of multi-stage computation is the work on computing \nwith contexts [18, 41, 23]. This is a connection which we intend to investigate in more detail in future \nwork. 7. CONCLUSION We have presented a proposal for a typed macro system, and have shown how it can \nbe given a rigorous yet read\u00adable semantics via an interpretation into the multi-stage programming language \nMetaML. The interpretation is es\u00adsentially a denotational semantics where MetaMLis the in\u00adternal language \nof the model. Such models have already been studied elsewhere [3]. But because MetaMLenjoys a simple \nand intuitive operational semantics, our proposal is easy to implement in a directly usable form. The \nmacro language that we have presented, MacroML, has useful and novel features, combining both static \ntyping and allowing the user to de.ne new binding constructs. In trying to achieve this, we have used \nideas from both HOAS [37] (to implement our proposal in a multi-stage setting) and FreshML(to provide \nthe surface syntax and ideas in the source language) [38]. It may well be that our language provides \nsome new insights on the link between the two ap\u00adproaches to treating binding constructs. We have argued \nthat macros are useful. But the moral of the paper is of a more technical nature: multi-stage program\u00adming \nlanguages are a good foundation for the semantics\u00adbased design of macro systems. We have shown how a \nformal multi-stage interpretation of macro systems provides an ele\u00adgant way of avoiding binding issues \nand de.ning new binding constructs, and provides a sound basis for developing type systems for macro \nlanguages. In this paper, we have not considered type safety in the presence of imperative features (references, \nexceptions) dur\u00ading expansion time. In this setting, we expect the work on imperative multi-stage languages \nto be of direct relevance [49, 4]. We have also not considered a multi-level macro system primarily for \nthe reason of simplicity. We would like to consider such an extension in future work. But there are restrictions \non out system that may be a bit more chal\u00adlenging to alleviate. For example, we have not considered higher-order \nmacros (macros that take other macros as pa\u00adrameters) and we have not considered macros that generate \nother macros. For such expressiveness, however, we expect that it may be simpler and more appropriate \nto move di\u00adrectly to a full-.edged multi-stage programming language. Part of the appeal of macro systems, \nwe believe, goes away when we attempt to push them to the higher-order and re\u00ad.ective setting. On the \nother hand, given that we have de\u00ad.ned macros in terms of a multi-stage language, it should be possible \nto merge macros and MetaMLinto the same language without any surprising interactions. To conclude, while \nthis paper addresses key semantic con\u00adcerns in developing an expressive, type-safe macro system, this \nis only a start. We have only built a simple prototype during this work. The prototype involved a direct \nimple\u00admentation of MetaMLsemantics and a direct implementa\u00adtion of the translation. We hope to integrate \nthis work with ongoing work on extensions of SML, Ocaml, and Haskell. Acknowledgements: We thank Antony \nCourtney, Stefan Monnier, Henrik Nilsson, Emir Pa.sali\u00b4c, Carsten Sch\u00a8urmann, and Tim Sheard for reading \nand commenting on this paper, and Kent Dybvig, Zhong Shao, Valery Trifonov and Oscar Waddell for many \ninteresting discussions.  8. REFERENCES [1] Ariola, Z. M., and Sabry, A. Correctness of monadic state: \nAn imperative call-by-need calculus. In ACM Symposium on Principles of Programming Languages (1998),ACM \nPress,pp. 62 74. [2] Barendregt, H. P. The Lambda Calculus: Its Syntax and Semantics,revised ed.,vol. \n103 of Studies in Logic and the Foundations of Mathematics. North-Holland,Amsterdam, 1984. [3] Benaissa, \nZ. E.-A., Moggi, E., Taha, W., and Sheard, T. Logical modalities and multi-stage programming. In Federated \nLogic Conference (FLoC) Satellite Workshop on Intuitionistic Modal Logics and Applications (IMLA) (1999). \n[4] Calcagno, C., Moggi, E., and Taha, W. Closed types as a simple approach to safe imperative multi-stage \nprogramming. In 27th International Colloquium on Automata, Languages, and Programming (ICALP) (Geneva,2000),vol. \n1853 of Lecture Notes in Computer Science,ACM Press,pp. 25 36. [5] Cardelli, L., Matthes, F., and Abadi, \nM. Extensible grammars for language specialization. In Database Programming Languages (DBPL-4) (Feb. \n1994),C. Beeri, A. Ohori,and D. E. Shasha,Eds.,Workshops in Computing,Springer-Verlag. [6] Curry, H. \nB., and Feys, R. Combinatory Logic, Volume I. Studies in Logic and the Foundations of Mathematics. North-Holland,Amsterdam,1958. \nSecond printing 1968. [7] Davies, R. A temporal-logic approach to binding-time analysis. In 11th Annual \nIEEE Symposium on Logic in Computer Science (LICS) (New Brunswick,1996),IEEE Computer Society Press,pp. \n184 195. [8] Davies, R., and Pfenning, F. A modal analysis of staged computation. In In proceedings of \nthe ACM Symposium on Principles of Programming Languages (POPL) (St. Petersburg Beach,1996),pp. 258 270. \n[9] Dybvig, R. K., Hieb, R., and Bruggeman, C. Syntactic abstraction in Scheme. Lisp and Symbolic Computation \n5, 4 (Dec. 1992),295 326. [10] Erk\u00a8ok, L., and Launchbury, J. Recursive monadic bindings. In Proceedings \nof the Fifth ACM SIGPLAN International Conference on Functional Programming, ICFP 00 (September 2000),ACM \nPress,pp. 174 185. [11] Felleisen, M. On the expressive power of programming languages. In Science of \nComputer Programming (1991), vol. 17,pp. 35 75. Preliminary version in: Proc. European Symposium on Programming,Lecture \nNotes in Computer Science,432. Springer-Verlag (1990),134 151. [12] Fiore, M., Plotkin, G., and Turi, \nD. Abstract syntax and variable binding. In Proceedings of the 14th Annual Symposium on Logic in Computer \nScience (LICS 99) (Trento,Italy,July 1999),G. Longo,Ed.,IEEE Computer Society Press,pp. 193 202. [13] \nGl\u00a8uck, R., and J\u00f8rgensen, J. E.cient multi-level generating extensions for program specialization. In \nProgramming Languages: Implementations, Logics and Programs (PLILP 95) (1995),S. D. Swierstra and M. \nHermenegildo,Eds.,vol. 982 of Lecture Notes in Computer Science,Springer-Verlag,pp. 259 278. [14] Gl\u00a8uck, \nR., and J\u00f8rgensen, J. Fast binding-time analysis for multi-level specialization. In Perspectives of System \nInformatics (1996),D. Bj\u00f8rner,M. Broy,and I. V. Pottosin,Eds.,vol. 1181 of Lecture Notes in Computer \nScience,Springer-Verlag,pp. 261 272. [15] Gl\u00a8uck, R., and J\u00f8rgensen, J. An automatic program generator \nfor multi-level specialization. LISP and Symbolic Computation 10,2 (1997),113 158. [16] Gomard, C. K., \nand Jones, N. D. A partial evaluator for untyped lambda calculus. Journal of Functional Programming 1,1 \n(1991),21 69. [17] Griffin, T. G. Notational de.nitions a formal account. In Proceedings of the Third \nSymposium on Logic in Computer Science (1988). [18] Hashimoto, M., and Ohori, A. A typed context calculus. \nTheoretical Computer Science. To appear. Preliminary version. Preprint RIMS-1098,Research Institute for \nMathematical Sciences,Kyoto University,1996. [19] Hofmann, M. Semantical analysis of higher-order abstract \nsyntax. In Proceedings of the 14th Annual Symposium on Logic in Computer Science (LICS 99) (Trento,Italy,July \n1999),G. Longo,Ed.,IEEE Computer Society Press. [20] Jones, N. D., Gomard, C. K., and Sestoft, P. Partial \nEvaluation and Automatic Program Generation. Prentice-Hall,1993. [21] Kohlbecker, E., Friedman, D. P., \nFelleisen, M., and Duba, B. Hygienic macro expansion. In Proceedings of the ACM Conference on LISP and \nFunctional Programming (Cambridge,MA,Aug. 1986),R. P. Gabriel,Ed.,ACM Press,pp. 151 181. [22] Lewis, \nJ. R., Launchbury, J., Meijer, E., and Shields, M. Implicit parameters: Dynamic scoping with static \ntypes. In In proceedings of the ACM Symposium on Principles of Programming Languages (POPL) (N.Y.,Jan. \n19 21 2000), ACM Press,pp. 108 118. [23] Mason, I. A. Computing with contexts. Higher-Order and Symbolic \nComputation 12,2 (Sept. 1999),171 201. [24] Miller, D. An extension to ML to handle bound variables in \ndata structures: Preliminary report. In Informal Proceedings of the Logical Frameworks BRA Workshop (June \n1990). Available as UPenn CIS technical report MS-CIS-90-59. [25] Mitchell, J. C. On abstraction and \nthe expressive power of programming languages. In Theoretical Aspects of Computer Software (1991),T. \nIto and A. R. Meyer,Eds., vol. 526 of Lecture Notes in Computer Science, Springer-Verlag,pp. 290 310. \n[26] Moggi, E. Notions of computation and monads. Information and Computation 93,1 (1991). [27] Moggi, \nE. A categorical account of two-level languages. In Mathematics Foundations of Program Semantics (1997), \nElsevier Science. [28] Moggi, E. Functor categories and two-level languages. In Foundations of Software \nScience and Computation Structures (FoSSaCS) (1998),vol. 1378 of Lecture Notes in Computer Science,Springer \nVerlag. [29] Moggi, E., Taha, W., Benaissa, Z. E.-A., and Sheard, T. An idealized MetaML: Simpler,and \nmore expressive. In European Symposium on Programming (ESOP) (1999), vol. 1576 of Lecture Notes in Computer \nScience, Springer-Verlag,pp. 193 207. [30] Monnier, S., and Shao, Z. Inlining as staged computation. \nTech. Rep. YALEU/DCS/TR-1193,Department of Computer Science,Yale University,Mar. 2000. [31] Moran, A., \nand Sands, D. Improvement in a lazy context: An operational theory for call-by-need. In In proceedings \nof the ACM Symposium on Principles of Programming Languages (POPL) (San Antonio,Texas,Jan. 1999),ACM, \npp. 43 56. [32] Nielson, F., and Nielson, H. R. Two-level semantics and code generation. Theoretical \nComputer Science 56,1 (1988),59 133. [33] Okasaki, C. Purely Functional Data Structures.PhD thesis,School \nof Computer Science,Carnegie Mellon University,1996. [34] Oliva, D. P., Ramsdell, J. D., and Wand, M. \nThe VLISP veri.ed prescheme compiler. Lisp and Symbolic Computation 8,1/2 (1995),111 182. [35] Oregon \nGraduate Institute Technical Reports. P.O. Box 91000,Portland,OR 97291-1000,USA. Available online from \nftp://cse.ogi.edu/pub/tech-reports/README.html. Last viewed August 1999. [36] Pa.sali\u00b4c, E., Sheard, \nT., and Taha, W. DALI: An untyped,CBV functional language supporting .rst-order datatypes with binders \n(technical development). Tech. Rep. CSE-00-007,OGI,2000. Available from [35]. [37] Pfenning, F., and \nElliott, C. Higher-order abstract syntax. In Proceedings of the Symposium on Language Design and Implementation \n(Atlanta,1988),pp. 199 208. [38] Pitts, A. M., and Gabbay, M. J. A metalanguage for programming with \nbound names modulo renaming. In Mathematics of Programme Construction (2000),vol. 1837 of Lecture Notes \nin Computer Science,Springer-Verlag, pp. 230 255. [39] Plotkin, G. D. Call-by-name,call-by-value and \nthe lambda-calculus. Theoretical Computer Science 1 (1975), 125 159. [40] Sabry, A. What is a purely \nfunctional language? Journal of Functional Programming 8,1 (Jan. 1998),1 22. [41] Sands, D. Computing \nwith contexts: A simple approach. In Second Workshop on Higher-Order Operational Techniques in Semantics \n(HOOTS II),A. D. Gordon, A. M. Pitts,and C. L. Talcott,Eds.,vol. 10 of Electronic Notes in Theoretical \nComputer Science. Elsevier Science Publishers B.V.,1998. [42] Sheard, T. Using MetaML: A staged programming \nlanguage. Lecture Notes in Computer Science 1608 (1999), 207 239. [43] Shields, M., Sheard, T., and Peyton \nJones, S. Dynamic typing through staged type inference. In In proceedings of the ACM Symposium on Principles \nof Programming Languages (POPL) (1998),pp. 289 302. [44] Taha, W. Multi-Stage Programming: Its Theory \nand Applications. PhD thesis,Oregon Graduate Institute of Science and Technology,1999. Available from \n[35]. [45] Taha, W. A sound reduction semantics for untyped CBN multi-stage computation. Or,the theory \nof MetaML is non-trivial. In Proceedings of the Workshop on Partial Evaluation and Semantics-Based Program \nManiplation (PEPM) (Boston,2000),ACM Press. [46] Taha, W., Benaissa, Z.-E.-A., and Sheard, T. Multi-stage \nprogramming: Axiomatization and type-safety. In 25th International Colloquium on Automata, Languages, \nand Programming (ICALP) (Aalborg,1998),vol. 1443 of Lecture Notes in Computer Science,pp. 918 929. [47] \nTaha, W., and Makholm, H. Tag elimination or type specialisation is a type-indexed e.ect. In Subtyping \nand Dependent Types in Programming,APPSEM Workshop. INRIA technical report,2000. [48] Taha, W., and Sheard, \nT. Multi-stage programming with explicit annotations. In Proceedings of the Symposium on Partial Evaluation \nand Semantic-Based Program Manipulation (PEPM) (Amsterdam,1997),ACM Press, pp. 203 217. [49] Thiemann, \nP., and Dussart, D. Partial evaluation for higher-order languages with state. Available online from http://www.informatik.uni-freiburg.de/ \nthiemann/papers/ index.html,1996. [50] Wand, M. Embedding type structure in semantics. In In proceedings \nof the ACM Symposium on Principles of Programming Languages (POPL) (1985),pp. 1 6. [51] Wand, M. The \ntheory of fexprs is trivial. Lisp and Symbolic Computation 10 (1998),189 199.  \n\t\t\t", "proc_id": "507635", "abstract": "With few exceptions, macros have traditionally been viewed as operations on syntax trees or even on plain strings. This view makes macros seem ad hoc, and is at odds with two desirable features of contemporary typed functional languages: static typing and static scoping. At a deeper level, there is a need for a simple, usable semantics for macros. This paper argues that these problems can be addressed by formally viewing macros as multi-stage computations. This view eliminates the need for freshness conditions and tests on variable names, and provides a compositional interpretation that can serve as a basis for designing a sound type system for languages supporting macros, or even for compilation. To illustrate our approach, we develop and present MacroML, an extension of ML that supports inlining, recursive macros, and the definition of new binding constructs. The latter is subtle, and is the most novel addition in a statically typed setting. The semantics of a core subset of MacroML is given by an interpretation into MetaML, a statically-typed multi-stage programming language. It is then easy to show that MacroML is stage- and type-safe: macro expansion does not depend on runtime evaluation, and both stages do not \"go wrong.", "authors": [{"name": "Steven E. Ganz", "author_profile_id": "81100106414", "affiliation": "Indiana Univ.", "person_id": "P269862", "email_address": "", "orcid_id": ""}, {"name": "Amr Sabry", "author_profile_id": "81100016804", "affiliation": "Indiana Univ.", "person_id": "P16266", "email_address": "", "orcid_id": ""}, {"name": "Walid Taha", "author_profile_id": "81100239752", "affiliation": "Yale Univ.", "person_id": "PP39034018", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/507635.507646", "year": "2001", "article_id": "507646", "conference": "ICFP", "title": "Macros as multi-stage computations: type-safe, generative, binding macros in MacroML", "url": "http://dl.acm.org/citation.cfm?id=507646"}