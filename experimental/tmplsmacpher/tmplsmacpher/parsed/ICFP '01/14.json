{"article_publication_date": "10-01-2001", "fulltext": "\n Events in Haskell, and How to Implement Them George Russell Bremer Institut f\u00a8at Bremen ur Sichere \nSysteme, FB3, Universit\u00a8Postfach 330440, 28334 Bremen ger@informatik.uni-bremen.de ABSTRACT We describe \na new and simpler implementation in Haskell of CML s events, which encode reactions by a thread to combinations \nof messages from other threads. We add a newtypeof Guarded Events, by which recipients can .lter messages \nwith conditions on their value known as Guards. We implement guarded channels. The guard type and the \nindexing algorithm are not part of the channel de.nition, so that the user can trade o. what guards are \nrequired against the cost of indexing. As an example we sketch the encapsulation of a graph\u00adical user \ninterface toolkit. This can be done concisely not only because of guarded events, but also because we \ncon\u00adstruct events monadically. Monadic events are especially helpful for representing concurrent processes \nwhich trans\u00adform themselves in reaction to external communications. 1. INTRODUCTION In PML and CML, \nJohn H. Reppy introduced an event type, and primitives on it, which gave the programmer a new way of \nencoding communication between threads [19, 20, 21]. One common abstraction for thread communication \nis the channel.Let a chan be a channel of values of type a.Then CML provides a function recv : a chan \n-> a which waits until a value becomes available on the channel, and then returns it. But what if we \nwant to listen to several channels at once? We could of course have a separate thread listening to each \nchannel, but then we would need a way for the threads to communicate. Instead CML wraps the operation \nof listen\u00ading to a channel in an event, so that we have recvEvt : a chan -> a event Events can be combined \nusing choose : a event list -> a event Permission to make digital or hard copies of all or part of this \nwork for personal or classroom use is granted without fee provided that copies are not made or distributed \nfor profit or commercial advantage and that copies bear this notice and the full citation on the first \npage. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior \nspecific permission and/or a fee. ICFP 01, September 3-5, 2001, Florence, Italy. Copyright 2001 ACM 1-58113-415-0/01/0009 \n...$5.00. To use events, sync : a event -> a is provided. So sync (choose (map recvEvt channels)) returns \nthe .rst value to arrive on any of the channels in the list channels. However it gives no indication \nof which channel the value came from. We can do this with wrap : (a event * (a -> \u00df)) -> \u00df event which \nattaches a computation to be done after an event, which transforms the event value. For example sync \n(choose (map (fn ch => wrap (recvEvt ch, fn value => (value,ch))) channels)) returns the .rst value to \ncome along one of the channels, paired with the originating channel. This is a comparatively trivial \napplication of wrap, which canbeusedtolistento channels of di.erent types, and attach arbitrarily lengthy \n(or even non-terminating) computations to events. CML s basic channels are Synchronous. This means that \nwriting to a channel blocks until a reader is prepared to accept the value. sendEvt : (a chan * a) -> \nunit event is the event corresponding to writing to a channel; it is not satis.ed until a matching reader \nis found. For example, after sync(choose[sendEvt(ch1,value),sendEvt(ch2,value)]) we can be sure that \nexactly one reader to one of the channels ch1 and ch2 has received the value. Reppy s primitives thus \nprovide an elegant extensible ab\u00adstraction for thread communication. It turns out that they also correspond \nnicely to theoretical models such as CSP [22] or the p-calculus [13]1 . We are particularly interested \nin events as part of the UniForM workbench, a large framework we are developing for con.guration management \nin Haskell [10]. This needs to encapsulate a large variety of tools. Events correspond to communications \nfrom these tools. We have implemented CML-style events in Haskell. A new feature is that we provide guarded \nchannels, which are similar to CML s channels, except that we have a new listen operator, allowing us \nto .lter values by a condition, which we call a Guard. Guards are not new; for example Er\u00adlang [2] provides \nthem. However here the set of guards varies with the channel. This allows guarded channels to incorpo\u00adrate \narbitrarily complex indexing schemes, trading o. the 1This was pointed out to me by Christoph L\u00a8uth. \nset of available guards against the amount of housekeeping and processor time required. We will give \na small example in section 3, where we will describe an encapsulation of events in a graphical user in\u00adterface. \n1.1 Concurrent Haskell We now summarise Concurrent Haskell. More details can be found in [16, 15]. New \nthreads are created using forkIO: forkIO :: IO () -> IO ThreadId which registers the given IO action \nto be executed in parallel with this one, and immediately returns. Concurrent Haskell s MVars provide \nboth shared mutable state and locking. They can be either empty or full. newEmptyMVar :: IO (MVar a) \nputMVar :: MVar a -> a -> IO () takeMVar :: MVar a -> IO a putMVar .lls an empty MVar; takeMVar waits \nuntil the MVar is full, then empties it. 1.2 Operations on Events The basic operators on Events we shall \nimplement are 2 sync :: Event a -> IO a (+>) :: Event a -> Event a -> Event a (>>>=) :: Event a -> (a \n-> IO b) -> Event b computeEvent :: IO (Event a) -> Event a sync corresponds to CML s sync, +> is an \nin.x operator which is like CML s choose but only takes two events, and >>>= is an in.x operator like \nCML s wrap. computeEvent turns an action which computes an event, into an event it\u00adself; the action is \nperformed immediately before synchro\u00adnisation. Thus computeEvent corresponds to CML s own guard function, \nallowing a pre-registration action, but the name is changed, to avoid confusion with our own guards, \nwhich unlike CML s can depend on the value of the event. We shall also present a wrapAbort combinator \ncorrespond\u00ading to CML s wrapAbort or wrapNack but as its de.nition is quite complex we shall leave that \nto subsection 2.9. Like CML, we shall also implement, in addition to chan\u00adnel events, two trivial events: \nnever :: Event a always :: IO a -> Event a never is the event which is never satis.ed. always on the \nother hand is always satis.ed; when you synchronise on it the supplied computation is performed, and \nthe resulting value returned as the value of the event. Thus, apart from guarded channels, the events \nin this pa\u00adper are roughly equivalent in functionality to CML s. How\u00adever there is an important di.erence, \nnamely that the choice operator +> is asymmetric. If we synchronise on event1 +> event2, and both events \nare immediately satis.able, event1 will be selected. According to CML s approach, as pre\u00adsented in [20], \nwe would select randomly between event1 and event2. 2The parentheses in (+>) and (>>>=) make an in.x \noperator non.x, like SML s op. Thus these operators are called +> and >>>=. I am indebted to Einar W. \nKarlsen [4] for these names. CML s approach, of making the choice operator symmet\u00adric and random, has \nthe advantage of being closer to the\u00adoretical models such as CSP [22]. The author s reasons for making \n+> asymmetrical were purely practical. The most important one is that there are some cases where we actu\u00adally \nwant one event to take priority over another, such as when we implement poll (subsection 2.7). However \nit is in any case not hard to implement something like CML s symmetric choice operator in our model. \nLet randomise :: [a] -> IO [a] be a function which returns a random permutation of its argument. Then \nwe may de.ne choose :: [Event a] -> Event a choose events = computeEvent( do randomised <-randomise events \nreturn (foldl (+>) never randomised) ) An event created with choose will then, at each synchro\u00adnisation, \ncompute a list of its component events in random order, and synchronise on them.  1.3 Guarded Channels \nand Events In section 3 we will describe a small Tk encapsulation writ\u00adten for this paper. Tk [28] is \na popular toolkit for creating graphical user interfaces. We will use Tk via a Tcl/Tk inter\u00adpreter called \nwish. Tk makes much use of callbacks. These are commands which get executed each time some event occurs. \nHowever our only communication with wish is through its standard input and output, so we cannot simply \nwrite a Tk callback which directly executes a Haskell action. Even if we could, callbacks do not seem \nthe right model for Haskell, since they rely on asynchronous changes to the program s state. In\u00adstead \nwe map Tk callbacks to events. We do this by making callbacks write to standard output a line containing \nan identifying CallBackId. At the Haskell end we parse this, and send the CallBackId along a channel. \nWe then would like a function taking a CallBackId to an Event (), such that this event is satis.ed when \nthere is a corresponding CallBackId in the channel. This is not pos\u00adsible with CML s channels, since \nCML s recvEvent does not look at a value on a channel before accepting it. What we would really like \nis a function listen :: (CallBackId -> IO Bool) -> Channel CallBackId -> Event CallBackId which listens \nto a channel, only accepting those values for which the supplied function returns True. But this is in \ngeneral not a good idea, because if we had a large number of callbacks, we might have to test every single \none of them before .nding a matching listener. This would be especially bad as during this process we \nwould have to lock the entire channel. Another approach, used by Erlang [2], is to allow a small .xed \nrestricted set of guards. The problem is that the set of available guards is both too big, in that a \ncompiler would have di.culty implementing them e.ciently, and too small, in that certain operations the \nuser might want are not im\u00adplemented, for example checking that a string matches a regular expression. \nThe approach we adopt instead is to introduce a new type GuardedEvent guard a A GuardedEvent guard a \ncan be converted to an Event a via the function toEvent :: GuardedEvent guard a -> Event a Thus it is \nat least as powerful as an Event. However it is also possible to qualify it with a condition of type \nguard: (|>) :: Guard guard => GuardedEvent guard a -> guard -> GuardedEvent guard a GuardedEventsare \ncreatedfrom GuardedChannels via the listen function, which reads from a GuardedChannel: listen :: GuardedChannel \nguard a -> GuardedEvent guard a Thus if Eq key is the guard corresponding to being equal to key,and \nchan is a guarded channel, listenChan chan key = toEvent(listen chan |> Eq key) is an event which only \naccepts values equal to key. If we want to accept any value, we simply don t specify any guards. Thus \nwe de.ne receive :: GuardedChannel guard a -> Event a receive = toEvent . listen which is just like CML \ns recvEvt. Writing values to a guarded channel is also like CML: send :: GuardedChannel guard a -> a \n-> Event () Like CML s channels, guarded channels are synchronous, so that the send event is not satis.ed \nuntil a matching listen is found. We could dispense with the GuardedEvents altogether, and just provide \nlistenChan.But GuardedEvents are more general than GuardedChannels. For example we could im\u00adplement a \nConfirmChannel guard a type with listen and send events as above, but also with confirm events. confirm \n:: ConfirmChannel guard a -> GuardedEvent guard a A successful communication would require a send,a \nlisten and a confirm event to be all satis.ed simultaneously. All GuardedChannels used in this paper \ncome from newEqGuardedChannel :: Ord key => IO (GuardedChannel (EqMatch key) (key,value)) The values \ncarried by these channels have type (key,value), and the EqMatch key guards include the Eq key guards \nmen\u00adtioned above, which select only those (key ,value) pairs where key equals key. The Ord key constraint \nmeans that the key type has a linear ordering. This is needed by newEqGuardedChannel, which uses balanced \ntrees to do the indexing. The Haskell class system is used, so that GuardedChannels themselves know nothing \nof this indexing. Thus, we could replace newEqGuardedChannel with an equivalent function which indexes \nusing hash tables. The only change in the type would be to the constraint Ord key, which would need to \nbe replaced by a constraint specifying a hash function. We could also have completely di.erent, perhaps \nmore complicated, guards. For example, GuardedChannelshave also been implemented which match Strings \nagainst regular expressions. Thread 1 Thread 2 sync (send chan value) sync (receive chan) Figure 1: Thread \n1 sends a message to Thread 2  2. IMPLEMENTATION 2.1 Synchronising on Channel Events Suppose we have \njust two threads, and one channel chan. Thread 1 has a value to send along chan, and executes sync(send \nchan value) If Thread 2 is not listening, Thread 1 will block. Later Thread 2 executes value <-sync(receive \nchan) Thread 2 receives the value, and Thread 1 and Thread 2 will be free to continue. Figure 1 illustrates \nthis. The dashed lines show the time each thread is within the sync action. The horizontal line corresponds \nto the moment when we match the two synchronisations, the commit point. After the commit point, each \nsync performs any actions attached to the event with >>>=. The commit point is the crux of the synchronisation. \nSup\u00adpose that a thread uses +> to synchronise on more than one channel at a time. After this synchronisation, \nthe thread should be committed to exactly one channel communication. The channel events should also match \nup, so that for each send event we are committed to, there is exactly one cor\u00adresponding committed receive \nevent, and vice-versa.We implement committal using Toggles. 2.2 Toggles For each synchronisation there \nis a unique Toggle.A Toggle can be thought of as a cell containing a Bool; initially this is True; when \nwe commit we change it to False.Since there is no way of undoing a committal, it cannot be changed back. \nThus we have newToggle :: IO Toggle toggle1 :: Toggle -> IO Bool where toggle1 either commits, or returns \nFalse. For chan\u00adnels we need to be able to commit to the send and receive events simultaneously. We cannot \nuse two successive appli\u00adcations of toggle1 for this, since we might .nd ourselves committed to handling \nthe .rst event, when someone else has already committed to satisfying the synchronisation con\u00adtaining \nthe second event. So we also need toggle2 :: Toggle -> Toggle -> IO (Maybe (Bool,Bool)) which returns \nNothing if the commitment succeeds, other\u00adwise the state of the Toggles. Just(True,True) means that the \ntwo input toggles are identical; in this case the commit\u00adment must fail since a synchronisation can only \nbe satis.ed by exactly one event. We leave the implementation of Toggles to Appendix A.  2.3 The Event \ntype and the sync function We de.ne data Result = Immediate | Awaiting (IO ()) data Event a = Event (Toggle \n-> (IO a -> IO ()) -> IO Result) There are four uses of IO here, and the reader may wonder why, with \nso much stateful computation, we don t simply implement events in C. But the advantage of using a func\u00adtional \nlanguage is that we can easily manipulate the various computations and actions in an Event, which we \nneed to do to implement our combinators. Since the Event type is rather complex, we shall build it up \ngradually. We might try this: data Event1 a = Event (Toggle -> (a -> IO ()) -> IO ()) To synchronise \non an event including this Event1,we would call the enclosed event function with the synchronisation \ns Toggle. We would also pass in an a->IO() function which would write the event value to an MVar,and \nat the end of the synchronisation we would take the value from the MVar and return. One optimisation \nwe can make is to allow the event func\u00adtion to signal that the event can immediately be satis.ed. We \ndo this by making it return a Result1. data Result1 = Immediate | Awaiting data Event2 a = Event (Toggle \n-> (a -> IO ()) -> IO Result1) If the event function returns Immediate, we know that the event has been \nsatis.ed, and can immediately go on to pick up the value from the MVar. The problem comes when we try \nto implement >>>=.If we want to attach a computation a->IOb to the event, there is nothing we can do \nbut pass it into the event function, which will need to execute it, perhaps in another thread, to compute \na b. This is undesirable because the computa\u00adtion may raise an exception (which should be raised in this \nthread), or may never terminate. Indeed we shall see in sub\u00adsection 2.10 that it is often useful to attach \nnon-terminating computations to an event. Our solution is to ask the event function, not to generate \nan a, but to generate a computation returning an a.Then we can execute the computation in this thread. \n data Event3 a = Event (Toggle -> (IO a -> IO ()) -> IO Result1) This is almost what we want. But there \nare also circum\u00adstances when the event function needs to specify an action to be done when the event \nis not satis.ed. One reason for this is as an optimisation; it allows the event source to clean up its \ndata structures to forget this synchronisation. But we also need the extra action for wrapAbort.So we \nde.ne data Result = Immediate | Awaiting (IO ()) data Event a = Event (Toggle -> (IO a -> IO ()) -> IO \nResult) as at the start of this section. To sum up how we use these actions, here is sync: sync (Event \nregisterFn) = do toggle <-newToggle aActMVar <-newEmptyMVar status <-registerFn toggle (\\ aAct -> putMVar \naActMVar aAct) aAct <-takeMVar aActMVar case status of Immediate -> done3 Awaiting postAction -> postAction \naAct If registerFn returns Awaiting, we always execute the at\u00adtached action, even though the event was \nsatis.ed. This is necessary for events generated by +>, where the synchronisa\u00adtion code can t know which \ncomponent event was satis.ed. For this reason the actual code, not in this paper, includes an extra re.nement: \na third constructor AwaitingAlways (IO ()) to Result, generated only by +>. Note that the action aAct \nis called tail-recursively, which is useful for the non-terminating events of subsection 2.10.  2.4 \nThe Events always and never We now present two CML events. never does nothing. always aAction attempts \nto commit to the synchronisation; if successful it passes aAction back to the caller, via the supplied \naActSink :: IO a -> IO (). never :: Event a never = Event (\\ toggle aActSink -> return (Awaiting done)) \n always :: IO a -> Event a always aAction = Event ( \\ toggle aActSink -> do goAhead <-toggle1 toggle \nif goAhead then aActSink aAction else done return Immediate ) 3done = return () 2.5 >>>= >>>=, our name \nfor CML s wrap, looks like this: (>>>=) :: Event a -> (a -> IO b) -> Event b (>>>=) (Event registerFn) \ncontinuation = Event ( \\ toggle bActionSink -> registerFn toggle ( \\ aAction -> bActionSink ( do a <-aAction \ncontinuation a ) ) ) Thus >>>= event continuation replaces the registerFn of event by one appending \nthe continuation. 2.6 +> We implement +> by making the new registerFn call the two component registerFn \ns. (+>) :: Event a -> Event a -> Event a (+>) (Event registerFn1) (Event registerFn2) = Event (\\ toggle \naActSink -> do status1 <-registerFn1 toggle aActSink case status1 of Immediate -> return Immediate Awaiting \npostAction1 -> do status2 <\u00adregisterFn2 toggle aActSink case status2 of Immediate -> do postAction1 return \nImmediate Awaiting postAction2 -> return (Awaiting ( do postAction1 postAction2 )) )  2.7 poll poll \nis like sync, except that if the event cannot be sat\u00adis.ed immediately, it returns anyway. poll :: Event \na -> IO (Maybe a) poll event = sync ( (event >>>= (\\ a -> return (Just a))) +> (always (return Nothing)) \n) 2.8 computeEvent This turns an action computing an event, into an event itself. computeEvent :: IO \n(Event a) -> Event a computeEvent getEvent = Event ( \\ toggle aActSink -> do (Event registerFn) <-getEvent \nregisterFn toggle aActSink ) 2.9 wrapAbort wrapAbort is like the wrapAbort combinator included in early \nversions of CML [20] and withNack which replaced it later [21]. Our version of wrapAbort has type wrapAbort \n:: IO (Event a,IO ()) -> Event a wrapAbort is given an IO action which computes an event and an abortAction \nof type IO(). The meaning of the event it generates is that once, on synchronisation, this IO action \nis executed, exactly one of three things will happen: event is satis.ed.  The synchronisation is satis.ed \n(but not by event)and abortAction is performed.  The synchronisation is never satis.ed.  For example, \nsuppose we are implementing a remote-pro\u00adcedure call, taking an args value to a result.One way is to \nimplement callServer :: args -> IO (Event result,IO ()) which returns an event which receives the result, \nand an abort action to execute if the client is no longer interested. If we synchronise on an event including \n(via +>) wrapAbort (callServer args), we are assured that should some other event be satis.ed before \nthe server replies, the abort action will be executed. A longer example can be found in [21] (section \n4.2.6), where CML s withNack is used to implement alockserver. The implementation of wrapAbort is quite \nlong, so we relegate it to Appendix B. However note that unlike CML we don t fork o. a separate thread \nto execute the abort action. This makes a di.erence if the abort action raises an exception or fails \nto terminate. Of course we can achieve the e.ect of CML s wrapAbort by putting the fork action into the \nabort action explicitly. 2.10 Monadic Events The name >>>= is reminiscent of Haskell s monadic oper\u00adator \n>>=. We can pursue the analogy further: instance Monad Event where (>>=) event1 getEvent2 = event1 >>>= \n(\\ val -> sync(getEvent2 val)) return val = always (return val) fail str = always (ioError (userError \nstr)) In fact, as pointed out in [14], events are not strictly monads, since return as given is not a \nleft identity. In Haskell terms, that means that the event do x <-return y fx is not equivalent to fy, \nbecause the former begins with an always event, and so will always be satis.ed, even if fx then blocks. \nIt would in fact be possible to extend the Event type so that the result was truly a monad, by adding \nspecial constructors just for return, but we don t do this since Haskell does not require instances of \nMonad to be monads [17]. We make Event an instance of Monad so that we can ex\u00adploit Haskell s do-notation \nto manipulate events just like IO actions. For example forever event is a new event which repeatedly \nsynchronises on event. forever :: Event a -> Event () forever event = do event forever event allowWhile \nevent1 event2 is really waiting for event2, but is prepared in the meantime to handle event1. allowWhile \n:: Event () -> Event a -> Event a allowWhile event1 event2 = event2 +>(do event1 allowWhile event1 event2 \n) Our last example is intended for mouse motion events, which happen every time the mouse moves and give \nits new position. If for example we were repositioning some large structure, we might not have time to \nreact to every mouse motion, and the best thing to do would be to throw away out-dated events. Something \nlike this is done by the skip channels of [16], but there it is necessary to de.ne a new sort of channel. \nHere we show how to write a new event combinator which does the same job. This is called watch, and takes \nthe mouse event as argument. watch :: Event a -> IO (Event a,IO ()) watch (event :: Event a) = do channel \n<-newChannel dieChannel <-newChannel let waitForNext :: Event () waitForNext = do next <-event passOn \nnext +> receive dieChannel passOn :: a -> Event () passOn val = waitForNext +> (do send channel val waitForNext \n) forkIO(sync waitForNext) return (receive channel, sync(send dieChannel ())) watch forks a thread which \nrepeatedly synchronises on one of two events. waitForNext is satis.ed when a new mouse event arrives; \nit then synchronises on passOn to pass on the information. passOn passes on the mouse event at most once, \nbut then goes back to waitForNext. watch returns an event for listening to the mouse events. It also \nreturns an action which terminates the thread by sending a message along dieChannel,causing waitForNext \nto quit. Of course sometimes we need to execute IO actions within events. The always function lets us \ndo this, by turning an IO a into an Event a. In section 3 we will see further examples of monadic events. \n 2.11 Guarded Events Guarded Events are events which can be .ltered with guards. De.ning them is fairly \nsimple. class Guard guard where nullGuard :: guard andGuard :: guard -> guard -> guard The nullGuard \nis the trivial guard which allows everything. andGuard encodes the guard which only permits events which \nboth the constituent guards permit. data GuardedEvent guard value = GuardedEvent (guard -> Event value) \nguard  (|>) :: Guard guard => GuardedEvent guard value -> guard -> GuardedEvent guard value (|>) (GuardedEvent \ngetEvent guard1) guard2 = GuardedEvent getEvent (guard1 andGuard guard2) toEvent :: GuardedEvent guard \nvalue -> Event value toEvent (GuardedEvent getEvent guard) = getEvent guard Thus a function constructing \na guarded event will normally construct getEvent of type guard -> Event value and pair it with nullGuard. \n 2.12 Guarded Channels Guarded Channels are implemented as an MVar contain\u00ading a queue of guards waiting \nfor values, and a queue of values waiting for guards.4 The former correspond to syn\u00adchronisations on \nlisten events, the latter to synchronisa\u00adtions on send events. We maintain the invariant that no pair \n(guard, value) in these queues can be matched. Thus each new guard has to be tested against all the values \nin the queue of values, and vice-versa. We now describe what happens when the registerFn in\u00adside the \nEvent type is called for a listen event on a partic\u00adular guard. We don t need to describe what happens \nwhen a send event is synchronised on, with a particular value, since this is exactly the same, except \nthat guards and values are interchanged. Indeed most of the work for both cases is done by the same function. \n(1) We try to match the guard with a value from the queue of values.  (2) If we can t do that, we add \nthe guard to the queue of guards.  During these steps, the MVar is empty, preventing anyone else from \naccessing the channel. This makes it particularly important that the queue operations are as fast as \npossi\u00adble. They are described by the overloaded functions add and remove. The overloadings we need for \nlisten are 4We use the term queue to emphasise that, all things be\u00ading equal, values placed in the queue \nearlier take priority. add :: guardQueue gD -> guard -> gD -> IO (guardQueue gD,IO ()) remove :: valueQueue \nvD -> guard -> IO (Maybe (value,vD,IO (valueQueue vD)), valueQueue vD) These are complicated as they \nare meant to encode whatever indexing schemes the user might need, whether balanced trees or hash tables. \nThe add function adds a new guard to the queue of guards, returning the new queue. We also get an IO \naction. The latter is executed after the synchronisation, and allows the queue implementation a neat \nway of removing surplus guards when we know that they can no longer be relevant. But note that this is \nonly an optimisation, since Toggles are still used to provide the de.nitive check of whether we can commit \nto an event. The remove function searches the queue of values to .nd a value matching a given guard. \nIf it doesn t .nd one, it returns (Nothing,newQueue) where newQueue isanew value queue to be used instead \nof the old one. If a match is found, we get (Just(value,vD,backtrack),newQueue) where vD is the data \nassociated with value,and newQueue contains the queue with this entry deleted. backtrack puts value and \nvD back in the queue; we will need this if we .nd that, after all, we cannot use this value. Each queue \nvalue is used only once; after we have used add or remove we throw away the old value. This is helpful \nif we want to use hash tables or other imperative structures for indexing, and also for data structures \nlike the standard functional representation of a queue as two lists. Once we have a value matching the \nguard, we do toggle2 guardToggle valueToggle for the two toggles. If this re\u00adturns Nothing the match \nsucceeds and we return Immediate. Otherwise there are 4 possible reasons why, which we can deduce from \nthe result: Just(True,False). The synchronisation for valueToggle is already satis.ed. Hence we can throw \naway this value, and try again with the rest of the value queue. Just(False,True). The synchronisation \nfor guardToggle is already satis.ed. This means that the synchronisa\u00adtion for this listen event has already \nbeen satis.ed by someone else. So we backtrack to put the value back on the value queue, and return Immediate. \nJust(False,False). Both synchronisations are satis.ed and we return Immediate. Just(True,True). This \nonly happens when the two toggles are the same, so the user is trying to synchronise on a send and listen \nevent on the same channel. We attempt to match the guard with the remaining values. If that succeeds, \nwe can throw away this value, since the synchronisation containing it is matched. If it fails, we backtrack, \nand add the guard to the guard queue. The HasGuardedChannel class is a multi-parameter type class which \nindicates that all the add and remove functions are available. The GuardedChannel data type uses it as \npart of an existential type: data GuardedChannel guard value = forall guardQueue valueQueue . HasGuardedChannel \n guardQueue valueQueue guard value => GuardedChannel (MVar (Contents guardQueue valueQueue value)) where \nContents encodes the pair of a guard queue and a value queue. If we were writing this in SML, we could \navoid the existen\u00adtial type by representing a queue as a pair of its add and remove functions. However \nthe best way would probably be to use functors.5  2.13 Examples of Guarded Channels The simplest guarded \nchannels allow no non-trivial guards. Thus they exactly correspond to CML s chan type. We im\u00adplement \nthem with functional queues to store unsatis.ed send and listen events. newEqGuardedChannel is of the \nnext order of complexity. This is used for values containing keys which can be lin\u00adearly ordered. Guards \nallow us to extract only those values with a particular key. We will use this several times in our encapsulation \nof Tk events. The implementation is straight\u00adforward; we use Glasgow Haskell s FiniteMaps, which imple\u00adment \nbalanced trees. Each node of a balanced tree contains a functional queue. However the logical thing to \ndo with keys that can be lin\u00adearly ordered is to provide guards which match keys within intervals. We \ncan do this by modifying a balanced tree al\u00adgorithm, adding extra data to each node. We can write any \ninterval of nodes as a union of at most a logarithmic num\u00adber of subtrees and single nodes, so we handle \nguards by splitting them in this way. Another form of matching is of strings against regular expressions. \nWe have implemented RegexChannelswhich are GuardedChannelsof Strings. matchEvent chan ptn re\u00adturns an \nEvent String which selects those Stringsmatched by ptn. In this case no indexing is possible, because \nthe regular-expression library we use only permits one String to be matched with one regular expression. \nUnsatis.ed send and listen events are stored in imperative queues. This demonstrates that in fact we \ncan usefully trade o. functionality against time, space and program complexity when deciding what guards \nto implement. Much more com\u00adplicated implementations are possible; for example we might use some sophisticated \ndatabase engine to do the indexing.  3. A SMALL Tk ENCAPSULATION As we mentioned before Tk is a toolkit \nfor writing graph\u00adical user interfaces. It is extremely useful for implementing portable graphics and \nhas already been encapsulated sev\u00aderal times in Haskell [7, 11, 23, 27]. The greatest challenge in encapsulating \nTk would appear to be representing user interactions, for which Tk uses a simple callback model. In this \nsection we shall see how the events we have developed provide an elegant solution. We present this as \nan example of a style of event programming which could be used for any complex system. 3.1 A Brief Introduction \nto wish We access Tk via the Tcl/Tk interpreter known as wish. When wish starts interactively it displays \na graphics win\u00addow, and (somewhere else) a command prompt. One can then type the equivalent of hello, \nworld into wish: 5This was suggested to me by Christoph L\u00a8uth. button .click -text \"Click me\" \\ -command \n{puts \"Clicked!\"} pack .click The .rst command creates a button widget; the second places it in the \ngraphics window. Clicking the button causes wish to display the string Clicked! . To create and display \nthe button in Haskell we use the IO action button <-pack ( text \"Click me\" $$6 clickable $$ newButton \n) top where top is the top widget, the wish graphics window. We don t have callbacks; instead there \nis a function clicks :: Button -> Event () Tk also allows a widget s attributes to be changed after it \nhas been displayed, and so do we. For example text \"Don t click me\" $$> button is an IO action which \nchanges the text on the button. Button clicks are one sort of Tk event. Another is provided by the bind \ncommand: bind . <Motion> {puts \"Mouse at %x %y\"} After this, wish periodically reports the mouse s position, \nwhen it moves over the top widget. More complicated bind\u00adings are possible. The <Motion> event can be \nreplaced by an event with modi.ers, such as <Control-Shift-A>,orby a sequence of events, such as <H><E><L><P> \n(which happens when the user types HELP quickly). We can also get more information about the event; as \nwell as %x and %y,there are 26 other event parameters we can specify. When we encapsulate bind in Haskell, \nit would be nice if it could have the type bind :: HasWidget widget => widget -> [WishEvent] -> Event \nEventInfo where EventInfo contains the event parameters and widget is a type, like Button, that, because \nof the constraint that it instance HasWidget, must be a widget. But this is impos\u00adsible, because as the \nnumber of potential Tk events we can bind to is in.nite, we must bind to just the events we want before \nlistening to them. We could use the wrapAbort com\u00adbinator to do this just before we sync on the event, \nbut then we d miss events which occurred when we weren t actually inside sync. So instead we implement \nbind :: HasWidget widget => widget -> [WishEvent] -> EventInfoSet -> IO (Event EventInfo,IO ()) The EventInfoSet \ndescribes what event parameters (such as the mouse co-ordinates) we want. In return we get an event to \nsync on to wait for the event to happen, plus an action to undo the binding. 6In the encapsulation, each \nTk class of widgets, for example buttons, has its own type, and so does each sort of attribute. $$ is \noverloaded, so that we can never apply an attribute to an inappropriate widget. wish  classi.er  event \nforwarder  user Figure 2: Information Flow out of wish 3.2 Encapsulating Tk events Figure 2 shows how \nwish s output reaches the user. The classi.er splits up output depending on whether it repre\u00adsents the \nreturned value from some operation, or an event. Events are then passed to the event forwarder, which \nde\u00adtermines the type of event and places it on the appropriate channel. We arrange that when wish outputs \na line it has one of four types, represented by data WishMessageType = OKType | ERType | COType | EVType \nderiving (Eq,Ord) OKType and ERType correspond to successful or erroneous execution of a command. COType \nrepresents a callback, and EVType represents a bind event. The classi.er reads lines from wish s standard \noutput, and sends them down a guarded channel keyed by WishMessageType,known as wishInChannel. readParseWish \nreads a line and classi.es it, so the classi.er, an Event (), looks like forever( do next <-always (readParseWish \nfdb) send wishInChannel next ) where we use the monadic events of subsection 2.10. The function which \nexecutes a wish command sends it to wish and synchronises on two listen wishInChannel events guarded \nwith Eq OKType and Eq ERType to get the response. The event forwarder dispatches incoming events to one \nof two guarded channels. bind events are sent to eventQueue, and callback events to coQueue. eventForwarder \n:: Event () eventForwarder = forever handleEvent handleEvent :: Event () handleEvent = (do (_,evStr) \n<-toEvent ( listen wishInChannel |> Eq EVType) noWait(send eventQueue (parseEVString evStr)) ) +> (do \n(_,coStr) <-toEvent ( listen wishInChannel |> Eq COType) noWait(send coQueue (parseCallBack coStr)) ) \nnoWait queues the events and immediately returns, so the events don t have to be picked up immediately. \nSince callback and bind events are forwarded to guarded channels allowing testing by equality, it is \neasy to make events which listen for particular callbacks or bindings. For example, callback events are \nconstructed with toEvent(listen coQueue |> Eq callBackId) 3.3 Tk programming with events Followingalongtradition, \nwecodeabuttonnexttoa counter. The main part of the code is: button <-pack ( text \"Click me\" $$ clickable \n$$ newButton ) top label <-pack newLabel top let handleClicks :: Int -> Event () handleClicks n = do \nalways(text (show n) $$> label) clicks button handleClicks (n+1) sync(handleClicks 0) handleClicks displays \nthe current counter, then waits for the next click. Our next example is a function which tracks the mouse \nwhen the mouse button is depressed, drawing a line after it. With bind, and using >>>= to extract the \nappropriate co\u00adordinates, we produce three events, each of which is an Event (Double,Double) and returns \nthe current mouse position. pressB1 reports when the button is pressed; moveB1 reports mouse motions \nwhile the button is down; releaseB1 reports when the button is again released. Then to follow the mouse \nin a canvas we execute the IO action: sync(forever( do point <-pressB1 followMouse point )) where we \nhave previously de.ned drawLine :: (Double,Double) -> (Double,Double) -> Event () drawLine point1 point2 \n= always (paint canvas (line [point1,point2])) followMouse :: (Double,Double) -> Event () followMouse \nlastPoint = (do point <-moveB1 drawLine lastPoint point followMouse point ) +> (do point <-releaseB1 \n drawLine lastPoint point done ) To .nd out whether the events would work on a large scale, the .rst \nexample in this section of a button next to a counter was somewhat enlarged. Instead of just one button, \nwe have a variable number of rather smaller buttons. The counter event increments each time one of the \nbuttons is clicked. This is done by repeatedly waiting, using +>,onall theseparatebuttons. (Thereare \nanumberofmoree.cient ways of writing this program!) When we wait for the next click we have to reregister \nfor every single button event. This causes a noticeable delay for 1000 buttons. With 10000 buttons the \ndelay is about a second. We will have more to say about this in section 6.  4. CODE DETAILS In this \npaper I have attempted to summarise the main problems that faced me when I implemented events, guarded \nevents, and the small Tk-encapsulation. In fact there were not many others; all the code described in \nthis paper was implemented almost from scratch in a few weeks, though it was inspired by some much more \ncomplicated previous attempts. When comments and blank lines are removed, there are less than 3000 lines \nof code in total. The Glasgow Haskell compiler version 4.08.2 [6, 26] was used throughout. Apart from \nConcurrent Haskell (subsec\u00adtion 1.1) the main extensions to Haskell 98 [17, 18] used were multi-parameter \ntype classes and (inside guarded chan\u00adnels) existential types. Glasgow Haskell s RULES extension is also \nused, to tell it to elide synchronisations on an always event. However it should be possible to implement \nevents in the style of this paper in any functional language with concurrency, shared reference cells, \nand locks. The code on which this paper was based can be found at http://www.informatik.uni-bremen.de/~ger/events/. \n 5. RELATED WORK Since CML as described in [20] there have been a number of implementations of its events, \nfor example [3, 25, 11]. As far as I know, guarded channels, in the way we have imple\u00admented them here, \nare new, though Erlang [2] comes closest since it allows events to be guarded by a small .xed set of \nexpressions. It is thus not possible to select an indexing al\u00adgorithm appropriate to the guards we actually \nneed, as we do here. Indeed, though Erlang s guards are fairly simple, they would be hard to implement \nwithout testing each guard against each value. The event type di.ers considerably between implementa\u00adtions. \nFor example, in CML7 an event is a tree of compo\u00adnent base events; a base event corresponds to a single \nevent such as waiting on single channel. An important di.erence is that CML also has to implement concurrency, \nwhich is al\u00adready done for us by Concurrent Haskell. I think the division of labour, where Concurrent \nHaskell de.nes fast lightweight MVars, and we build more complicated abstractions on top of them, is \nthe right one. The existing implementation of CML-like events most resembling ours is probably that of \nThimble [25]. The basic type of an event there is 7Here I am comparing with version 110.7,from[24]. datatype \na event = Event of flag -> unit -> (unit -> a) option Here a flag is like our Toggle, except that you \ncan wait on it. To synchronise on a Thimble event, you call the function, and get a completion function \nof type unit -> (unit -> a) option. You then wait for the .ag to be raised, and execute the completion \nfunction, and its result. To poll, you call the completion function without waiting for the .ag to be \nraised, obtaining NONE if the event cannot be immediately satis.ed. However a major problem with Thimble \ns events is that the same synchronisation cannot include both a send and a receive event. This rules \nout, for example, watch as implemented in subsection 2.10. We have shown how the events in this paper \ncan encapsu\u00adlate Tk events. So it seems reasonable to look at how other Tk encapsulations do it. Gtk+HS \n[7] is a fairly faithful encapsulation of Gtk+ in Haskell. In particular it uses the same theory of signals \nand callbacks. When an event occurs, the concerned widget emits a signal. These signals are similar to \nthe standard Unix signals, in that to catch them you set up a signal han\u00addler which binds with a callback \nfunction. FranTk [23] uses a di.erent approach. As in this paper, there are events with combinators for \ncombining them. But in fact the events are radically di.erent, based as they are on reactive animation. \nThe di.erence becomes apparent when you try to use them. Instead of sync, FranTk has listeners. A Listener \na is a consumer of values of type a;on a low level we can think of it as encoding a callback. Just like \nevent combinators, there are combinators for combining listeners. Finally, there is a function addListener \n:: Event a -> Listener a -> IO (IO ()) for gluing the two together. Both Gtk+HS and FranTk provide a \nconsistent and useful view of interactions with Tk. However they essentially han\u00addle Tk events with callbacks, \nas do other encapsulations, such as TkGofer [27]. Callbacks occur asynchronously and are not naturally \nconnected with the rest of the program. This means extra shared state is required if the main program \nis to react to user events. With composable events, the pro\u00adgram can access events directly, but only \nneeds to do so when it is ready to handle them. So I prefer event-based graphical user interfaces, such \nas eXene [5] and Einar Karlsen s HTk encapsulation for the UniForM workbench [11], on which this paper \nis most directly based. In HTk, Tk events include a register and deregister action. For example, the \nregister function for a bind event sends a bind command to wish, which the deregister event later can\u00adcels. \nThe di.culty that arises is that sync no longer su.ces, as youmisseventswhich happen outside sync. Therefore \nHTk has a new class of event listeners called interactors.In\u00adteractors do not deregister interest after \nan event occurs, but only via an explicit become operation. Interactors are somewhat similar to the actors \ndescribedin[1]. Our events only need sync. Perhaps it is a disadvantage that bind commands must be explicit; \nin my opinion it is not very much of one. Where possible, I think bindings should only be done when a \nwidget is created. Where bindings must be done at other times, they should be explicit because they change \nstate; before the binding the event is ignored, and afterwards it is acted upon. 6. CONCLUSIONS AND \nFURTHER WORK We have introduced a new and simple implementation of CML s events, and used it to implement \nTk events. This is easier as we have channels which are guarded e.ciently by guards which pick out values \nmatching particular keys. We have also used events as monads. With Haskell s do notation this gives us \na concise means of writing program components which transform themselves in response to ex\u00adternal communications. \nOne problem with events as we have implemented them is that we cannot re-use a synchronisation. For example, \nwith the last example of 3.3, where we synchronised on a choice of several thousand button events, there \nwas a noticable delay while all the events were registered. This registration has to be redone each time \na button is clicked. One approach would be the introduction of a faster indexing algorithm, such as hash \ntables. But a better approach might be to do some pre-computation on the alternatives. For example, we \ncould introduce new primitives for channels, which would allow us to group lots of guards, or lots of \nvalues, sorting them in some way, so that we could register one group in a single action. There is a \nresemblance between events and combinator parsing [8, 9], in that both are monad-like with a choice combinator. \nCould we use techniques from combi\u00adnator parsing to make +> group events automatically? 7. ACKNOWLEDGMENTS \nI am grateful to Christoph L\u00a8uth, Ian Stark and the anony\u00admous reviewers for reviewing this paper and \nmaking numer\u00adous suggestions. Christoph in particular was in the neigh\u00adbourhood, and always ready to \nprovide advice and encour\u00adagement. I am also indebted to the GHC Team for their untiring and e.cient \nsupport. 8. REFERENCES [1] G.A.Agha. Actors:A model of Concurrent Computation in Distributed Systems. \nMIT Press, 1986. [2] J. Armstrong, R. Virding, and M. Williams. Concurrent Programming in Erlang. Prentice \nHall, 1st edition, 1993. [3] E. D. Demaine. Higher-Order Concurrency in PVM. In Cluster Computing Conference \n97, 1997. Available from http://www.mathcs.emory.edu/ccc97. [4] E.W.Karlsen. The UniForM Concurrency \nToolkit and its Extensions to Concurrent Haskell. In Glasgow Functional Programming Workshop 97, 1997. \n[5] E. R. Gansner and J. H. Reppy. A Multi-threaded Higher-order User Interface Toolkit,volume1of Software \nTrends, pages 61 80. Wiley, 1993. [6] The Glasgow Haskell Compiler. Available from http://www.haskell.org/ghc. \n [7] A GTK+ Binding for Haskell. Available from http://www.cse.unsw.edu.au/~chak/haskell/gtk. [8] S. \nHill. Combinators for parsing expressions. Journal of Functional Programming, 6(3):445 463, 1996. [9] \nG. Hutton and E. Meijer. Monadic parsing in Haskell. Journal of Functional Programming, 8(4):437 444, \n1998. [10] E. Karlsen. The UniForM WorkBench -a Higher Order Tool Integration Framework. In International \nWorkshop on Current Trends in Applied Formal Methods, 1998. Available from http://www.informatik.uni-bremen.de/~ewk. \n[11] E. Karlsen. Tool Integration in a Functional Programming Language. PhD thesis, Universit\u00a8at Bremen, \n1998. Available from http://www.informatik.uni-bremen.de/uniform/wb. [12] D. Lehmann and M. O. Rabin. \nOn the Advantages of Free Choice: A Symmetric and Fully Distributed Solution to the Dining Philosophers \nProblem. In Eighth Annual ACM Symposium on Principles of Programming Languages, Williamsburg, Virginia, \npages 133 138, 1981. [13] R. Milner. Communicating and Mobile Systems:the p-Calculus. Cambridge University \nPress, 1999. [14] P. Panangaden and J. Reppy. The Essence of Concurrent ML. In F. Nielson, editor, ML \nwith Concurrency. Springer, 1997. [15] S. Peyton Jones. Tackling the awkward squad: monadic input/output, \nconcurrency, exceptions, and foreign-language calls in Haskell. In C. Hoare, M. Broy, and R. Steinbrueggen, \neditors, Engineering theories of software construction, Marktoberdorf Summer School 2000, NATO ASI Series, \npages 47 96. IOS Press, 2001. [16] S. Peyton Jones, A. Gordon, and S. Finne. Concurrent Haskell. In 23rd \nACM Symposium on Principles of Programming Languages, St Petersburg Beach, Florida, pages 295 308, Jan \n1996. Available from http://research.microsoft.com/users/simonpj. [17] S. Peyton Jones, J. Hughes, et \nal. Haskell 98: A Non-strict, Purely Functional Language, Feb 1999. Available from http://www.haskell.org/onlinereport. \n[18] S. Peyton Jones, J. Hughes, et al. Standard Libraries for Haskell 98, Feb 1999. Available from http://www.haskell.org/onlinelibrary. \n[19] J. H. Reppy. Synchronous Operations as First-class Values. In SIGPLAN 88 Conference on Programming \nLanguage Design and Implementation, pages 250 259, 1988. [20] J. H. Reppy. Higher-order Concurrency. \nTechnical Report 92-1285, Cornell University, June 1992. Available from http://cm.bell-labs.com/who/jhr. \n[21] J. H. Reppy. Concurrent Programming in ML. Cambridge University Press, 1999. [22] A. W. Roscoe. \nThe Theory and Practice of Concurrency. Prentice Hall, 1998. [23] M. Sage. FranTk -A Declarative GUI \nLanguage for Haskell. In Fifth ACM SIGPLAN International Conference on Functional Programming (ICFP 00), \npages 106 117, 2000. [24] Standard ML of New Jersey home page. At http://cm.bell-labs.com/cm/cs/what/smlnj. \n[25] I. Stark. Thimble -Threads for MLj. In First Scottish Functional Programming Workshop, pages 337 \n346, 1999. Available from http://www.dcs.ed.ac.uk/home/stark. [26] The GHC Team. Glasgow Haskell Compiler \nUser s Guide, Version 4.08, 2000. Available from http://www.haskell.org/ghc. [27] T. Vullinghs, D. Tuijnman, \nand W. Schulte. Lightweight GUIs for Functional Programming. In 7th International Symposium on Programming \nLanguages: Implementations, Logics and Programs,pages 341 356, 1995. [28] B. B. Welch. Practical Programming \nin Tcl &#38; Tk. Prentice Hall, 2nd edition, 1997. APPENDIX  A. IMPLEMENTATING Toggles We now explain \nthe implementation of Toggles, which were introduced in subsection 2.2. We .rst implement SimpleToggles. \nnewSimpleToggle, simpleToggle1 and simpleToggle2 correspond to newToggle, toggle1 and toggle2 respectively. \nThey also have the same types, substituting SimpleToggle for Toggle. The only dif\u00adference is that simpleToggle2 \ncan deadlock. newtype SimpleToggle = SimpleToggle (MVar Bool) newSimpleToggle = do mVar <-newMVar True \nreturn (SimpleToggle mVar) simpleToggle1 (SimpleToggle mVar) = do oldVal <-takeMVar mVar putMVar mVar \nFalse return oldVal simpleToggle2 (SimpleToggle mVar1) (SimpleToggle mVar2) = do oldVal1 <-takeMVar \nmVar1 oldVal2 <-takeMVar mVar2 if (oldVal1 &#38;&#38; oldVal2) then do putMVar mVar2 False putMVar mVar1 \nFalse return Nothing else do putMVar mVar2 oldVal2 putMVar mVar1 oldVal1 return (Just (oldVal1,oldVal2)) \nConsider simpleToggle2 toggle toggle. This empties the MVar in toggle; it then tries to empty it again, \nand blocks. We might try making simpleToggle2 check that its ar\u00adguments are di.erent, but this is not \nenough. Suppose toggle1 and toggle2 are two di.erent SimpleToggles, and we have two threads. One thread \nexecutes simpleToggle2 toggle1 toggle2, and the other simpleToggle2 toggle2 toggle1. Then we might have \na situation where the two threads successfully execute the .rst takeMVar, emptying both MVars, after \nwhich both threads are blocked on the second takeMVar. The solution we adopt is to wrap SimpleTogglesin \nToggles so that they are linearly ordered: data Toggle = Toggle ObjectID SimpleToggle The ObjectIDs are \nin fact non-negative integers, but all we need to know about them is that they are linearly ordered, \nand that every set of them has a least element. They are created with the newObject action. newToggle \ncreates a new ObjectID on each call. Apart from that, newToggle and toggle1 simply call newSimpleToggle \nand simpleToggle1: newToggle :: IO Toggle newToggle = do uniqVal <-newObject stoggle <-newSimpleToggle \nreturn (Toggle uniqVal stoggle) toggle1 :: Toggle -> IO Bool toggle1 (Toggle _ stoggle) = simpleToggle \nstoggle As there is exactly one ObjectID per SimpleToggle,and one SimpleToggle per MVar, we can regard \nthe MVarsasbe\u00ading ordered with the ordering of their associated ObjectIDs. toggle2 rearranges its arguments \nso that the arguments to simpleToggle2 are always in decreasing order. toggle2 :: Toggle -> Toggle -> \nIO (Maybe (Bool,Bool)) toggle2 (Toggle unique1 stoggle1) (Toggle unique2 stoggle2) = case compare unique1 \nunique2 of GT -> simpleToggle2 stoggle1 stoggle2 LT -> do result <-simpleToggle2 stoggle2 stoggle1 case \nresult of Nothing -> return Nothing Just (r1,r2) -> return (Just (r2,r1)) EQ -> do r <-peekSimpleToggle \nstoggle1 return (Just (r,r)) toggle2 returns the initial state of the Toggles, if the toggle fails. When \nthe two toggles are equal, we need an additional function peekSimpleToggle, which reads the contents \nof a SimpleToggle but leaves it unchanged: peekSimpleToggle (SimpleToggle mVar) = do value <-takeMVar \nmVar putMVar mVar value return value We can prove that toggle1 and toggle2 always termi\u00adnate under the \nfollowing two fairness assumptions, which are quoted from subsection 6.3 of [16]: no runnable process \nwill be in.nitely delayed. and no process can be blocked inde.nitely on an MVar unless another process \nholds that MVar inde.nitely. Athread holds an MVar when it has emptied it, but not yet .lled it again. \nThen we may observe of newToggle, toggle1 and toggle2: (1) Toggle MVars are created full. (2) A thread \nwhich empties a Toggle MVar using takeMVar later .lls it, if not blocked inbetween, using putMVar, and \nthese are the only accesses to Toggle MVars.  (3) When a thread attempts to take from an MVar m1 while \nit already holds some Toggle MVar m2,then m1 is also a Toggle MVar,and m2 is greater than m1. We observe \nfrom (2) that putMVars always succeed (since the MVar will be empty). From the .rst fairness assumption, \nit follows that we are done if we can show that none of the takeMVars block inde.nitely. If not, let \nm2 be a Toggle MVar on which a takeMVar is blocked inde.nitely, and subject to this condition choose \nm2 so that it is minimal. By the second fairness assumption, m2 must be held inde.nitely by a process. \nThe process holding m2 must itself be inde.nitely blocked on a takeMVar on some MVar m1,sothat by(3) \nm2 must be greater than m1.But this contradicts the minimality of m2. Hence the toggle functions terminate \ncorrectly. We have also almost completely avoided global locking in their imple\u00admentation, and so in \nthe implementation of events. Specif\u00adically, we only use global locking when we generate the ObjectIDs. \nIf even this global locking is undesirable, it might be better to generate unique ObjectIDs locally by \ninserting thread or processor identi.ers, or else use a ran\u00addomised scheme such as that described in \n[12].  B. IMPLEMENTATING wrapAbort We now implement wrapAbort, described in 2.9. We store the abort \nevent in postAction. The abort action is tagged onto the Awaiting action, and we use a Toggle to prevent \nit being executed except when needed. wrapAbort :: IO (Event a,IO ()) -> Event a wrapAbort preAction \n= computeEvent ( do postDone <-newToggle (Event registerFn,postAction) <-preAction let postAction = do \ngoAhead <-toggle1 postDone if goAhead then postAction else done return (Event ( \\ toggle aActSink -> \ndo status <-registerFn toggle (\\ aAct -> do toggle1 postDone aActSink aAct ) case status of Immediate \n-> (postAction >> return Immediate) Awaiting action -> return (Awaiting (postAction >> action)) )) ) \n \n\t\t\t", "proc_id": "507635", "abstract": "We describe a new and simpler implementation in Haskell of CML'sevents, which encode reactions by a thread to combinations ofmessages from other threads. We add a new type of Guarded Events,by which recipients can filter messages with conditions on theirvalue known as Guards. We implement guarded channels. The guardtype and the indexing algorithm are not part of the channeldefinition, so that the user can trade off what guards are requiredagainst the cost of indexing. As an example we sketch theencapsulation of a graphical user interface toolkit. This can bedone concisely not only because of guarded events, but also becausewe construct events monadically. Monadic events are especiallyhelpful for representing concurrent processes which transformthemselves in reaction to external communications.", "authors": [{"name": "George Russell", "author_profile_id": "81332525036", "affiliation": "Univ. Bremen, Brenen, Germany", "person_id": "PP14203416", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/507635.507655", "year": "2001", "article_id": "507655", "conference": "ICFP", "title": "Events in Haskell, and how to implement them", "url": "http://dl.acm.org/citation.cfm?id=507655"}