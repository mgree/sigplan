{"article_publication_date": "10-01-2001", "fulltext": "\n Type-Based Hot Swapping of Running Modules [Extended Abstract] Dominic Duggan Dept of Computer Science \nStevens Institute of Technology Hoboken, New Jersey 07040 dduggan@cs.stevens-tech.edu ABSTRACT While \ndynamic linking has become an integral part of the run-time execution of modern programming languages, \nthere is increasing recognition of the need for support for hot swapping of running modules, particularly \nin long-lived server applications. The inter\u00adesting challenge for such a facility is to allow the new \nmodule to change the types exported by the original module, while preserv\u00ading type safety. This paper \ndescribes a type-based approach to hot swapping running modules. The approach is based on a re.ective \nmechanism for dynamically adding type sharing constraints to the type system, realized by programmer-de.ned \nversion adapters in the run-time. Categories and Subject Descriptors D.3.1 [Programming Languages]: \nFormal De.nitions and The\u00adory Semantics; D.3.3 [Programming Languages]: Language Con\u00adstructs and Features \nData Types and Structures General Terms Languages Keywords Module Interconnection Languages, Hot Swapping, \nDynamic Typ\u00ading, Shared Libraries 1. INTRODUCTION Various operating and window systems, and mobile code \nlan\u00adguages such as Java, have popularized dynamic linking of program libraries as a fundamental part \nof run-time execution. These fa\u00adcilities are typically provided for languages such as C, C++ and Java, \nusing facilities such as the COM API or the Java ClassLoader class. A facility that is missing from all \nof these is the ability to hot swap a running library, in the sense of changing the imple\u00admentation of \na module that is currently running. The program may for example be a server running 24/7, and the module \na standard Permission to make digital or hard copies of all or part of this work for personal or classroom \nuse is granted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page. To copy otherwise, to republish, \nto post on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. ICFP \n01, September 3-5, 2001, Florence, Italy. Copyright 2001 ACM 1-58113-415-0/01/0009 ...$5.00. service \nprovided to client worker threads. Hot swapping refers to the ability to change or swap the module implementation \nwith\u00adout the client threads noticing the change. New clients link with the new module implementation, \nwhile old clients should be migrated gracefully to the new implementation. An interesting challenge in \nsupporting hot swapping is allowing the new module implementa\u00adtion to rede.ne the representations of \nsome of its data structures. A reasonably large-scale example is given by the upgrade of the Internet \nfrom the IPv4 network protocol to IPv6. Packet headers for IPv4 and IPv6 are not compatible, with IPv6 \nexpanding some .elds (principally the address .eld) and adding some services while removing others. Hot \nswapping is a reality in the Internet, with routers being upgraded from IPv4 to IPv6 while there is still \nmuch traf.c in IPv4 packets. Internet routers need to be able to distin\u00adguish IPv4 packets from IPv6 \npackets. This is done using a version .eld in the packet header. Our type-based approach to hot swap\u00adping \nis similar to the approach to converting the Internet to IPv6. To understand the challenges with supporting \nhot swapping, con\u00adsider the following example, where we assume a module Cap (say implementing capabilities) \nthat provides a get operation for ob\u00adtaining capabilities and a combine operation for combining capa\u00adbilities: \nCap.t x = Cap.get (); // Old version // Hot swap happens here Cap.t y = Cap.get (); // New version Cap.t \nz = Cap.combine(x,y); // Which version? The problem is that another client thread may have a value of \nthe old implementation type on its thread stack (x in the above exam\u00adple), and may provide this old version \nto the operations of the new implementation. It is also possible for a client to be executing code from \nthe old implementation, perhaps in a long-lived loop, so it is possible for old version code to obtain \nnew version values. As discussed later in Sect. 7, there are various approaches to hot swapping of running \nmodules. Those approaches are characterized into: version barrier, passive partitioning, and global update. \nThe approaches of version barriers and global update prevent values of different version types from coexisting \nin the same address space, but both have practical defects. In this paper we consider a seman\u00adtics for \nhot swapping that follows the model of passive partitioning, in which values of different versions may \ncoexist. The challenge in this is to allow values of different types to be used interchangeably and in \na reasonably ef.cient manner, without violating type safety. One possible approach to allow different \nversion values to co\u00adhabit is to use views [56]. Views were originally designed to allow pattern-matching \n(in functional programming) against values of ab\u00adstract type, by having the ADT export isomorphisms between \nitself and a datatype representation. Similarly, different version values could be allowed following \na library update, by having the update operation specify isomorphisms between the old version type and \nthe new version type. When a procedure requires an old version value as its formal argument, for example, \nbut the actual argument is a new version value, the view speci.es how to translate from the new version \nto the old version. If this procedure returns an old version value, but the caller requires a new version \nvalue, then the view is used in the opposite direction. Unfortunately there are major problems with using \nviews for ver\u00adsion update: 1. First, translating an entire data value from one representation to another \nwill often be too heavyweight. For example, sup\u00adpose the old and new libraries provide implementations \nof lists. Then the new version operation for taking the head of a list, when applied to an old version \nlist, will have to translate the entire list to the new version. An even worse scenario unfolds with \nan operation for taking the tail of a list: the newly constructed new version list must be translated \nback to an old version list before it is returned (since the client of the operation expects to be returned \nan old version list). This is related to the problems of using coercions to implement polymorphism [38], \nthat in turn motivated work on inten\u00adsional polymorphism [31, 49, 51]. 2. Second, this translation will \noften be unnecessary. For ex\u00adample, suppose a generic hash table module was instantiated with the old \nversion type, and the table now contains several old version values. After the hot swap, the application \nwould like to continue using this hash table for both old and new version values. However inserting a \nnew version value into the hash table requires that it be converted to the old version, and taking it \nout of the hash table requires that it be converted back again. All of this is done despite the fact \nthat the hash table is oblivious to the actual types of the objects it stores.  We can say that the \nproblems with views will be true for any approach that continues to treat the old and new version types \nas distinct types. As long as we require that a variable of type T only contain values of type T , and \nno other type, then a value that crosses type boundaries must be converted to the expected type. In this \npaper we relax this requirement. A variable of type T may actually be bound to values of type T ', where \nT . is not necessarily the same as T . This is currently allowed in object-oriented lan\u00adguages, where \na variable of type T may be bound to values of any subtype of T . . The subtype relation may be de.ned \neither struc\u00adturally or be declared by the programmer. As discussed in Sect. 6, our approach can be considered \nas a generalization of subtyping in object-oriented languages: 1. The subtype relation is a pre-order, \nre.ecting the fact that it only allows variables of old version type to be bound to new version values. \nIn contrast, we de.ne an equivalence relation between types, because it must be possible to map back \nand forth between two versions of a type. 2. Subtyping is based on structural containment of object \nin\u00adterfaces, generalized to function types and other types. In contrast we allow equivalences to be added \nbetween any two types, without any restrictions on their compatibility. The only restriction is that, \nwhen an equivalence is introduced between two types, this must be realized by a pair of func\u00adtions that \ntranslate between the types. This is analogous to the isomorphisms declared in a view, but the difference \nis in where these isomorphisms are applied and the mechanisms for their application.  In our approach \nto changing data representations, the following must be speci.ed to change a data representation from \nT to T ': 1. An equality is asserted between the types T and T . . We re\u00adquire a type system with a very \nlimited form of type equal\u00adity (such as ML or Modula-3; it would need to be added to Java). Type equality \nis limited to equating type constructors (datatypes and abstract data types); we cannot assert equali\u00adties \nbetween arbitrary type expressions. The types T and T . are required to be type constructors; this is \nreasonable, since they are supposed to be types exported by a library. We re\u00adfer to type equalities as \ntype sharing constraints, since they have independent application in supporting shared libraries (explained \nbelow). 2. With this equality, a pair of isomorphisms must be provided that can convert between values \nof type T and T '. By analogy with the semantics of constructive logic, we can say that this pair of \nisomorphisms realizes the equality asserted between T and T . . We refer to such an isomorphism as a \nversion adapter.  In our approach, the effect of asserting an equality between two types is profound: \na value of type T can be used anywhere a value of type T . is expected, and vice versa. This is allowed \nby a form of subsumption in the type system: e has type T (T = T ') is derivable e has type T . This \nrule is the point of departure between our approach and ap\u00adproaches such as views that do not identify \ntypes in the type system itself. Now the obvious question is: when do we apply the version adapters? \nSuppose x is a variable of type T bound to a value of type T ', and the program tries to access the T \n'-value of x as a T -value. Intuitively our approach is to check at the point of accessing a value if \nit needs to be converted. Doing this check on every single access to every single value would be at least \nproblematic. This would re\u00adquire the provision of run-time type information on the same scale as dynamically \ntyped languages such as Lisp and Scheme, and in\u00adcur the cost of a type check on every access to a data \nvalue. This would greatly limit the generality of the approach. We address this issue as follows: we \nmake dynamic type infor\u00admation explicit in the language, as .rst-class type tags [26]. There are explicit \noperations for attaching type tags to values, and for ac\u00adcessing a tagged data value. Our language can \nbe considered as a target language into which statically typed languages with dy\u00adnamic typing, such as \nJava and Modula-3, could be compiled, and the overhead of supporting dynamic typing is no more onerous \nthan in any implementation of such languages. For example, typed as\u00adsembly language uses a similar set \nof dynamic typing operations to represent Java objects with run-time type information [48, 26]. We require \nthat all types exported by libraries have the property that they have run-time type tags associated with \nthem. Modula-3 has a similar restriction on types exported by modules. In this paper this restriction \nis enforced by introducing a type constructor for types of tagged values, the box type constructor. Any \ntype exported by a module must be a box type. It must be possible to compare types for equality at run-time: \nthis is how we determine if a value is of the expected type version. Therefore we require that every \nbox type have exactly one run-time type tag associated with it. This uniqueness property is ensured, \nin the semantics of our language, by allocating run-time type tags as part of the semantics of module \ninitialization. Checking is then automated as follows: before a value of boxed type can be used, the \nvalue must be extracted. We refer to this operation as unfolding. For example, if an object-oriented \nlan\u00adguage such as Java is compiled to our language, method invoca\u00adtion is translated to the sequence: \nunfold the object, extract the method implementation, then apply the method to the object and the method \narguments. The unfold operation is where the version check is peformed. The unfolding step checks the \ntype tag associated with the value. If the type tag is not that expected by the unfolding operation, \nthen it applies a version adapter to the value to convert it to the required type. Both the expected \nand actual type versions are identi.ed by their run-time type tags, therefore the pair of these type \ntags can be used as an index to obtain the required version adapter. Type safety ensures that, if the \nprogram type-checks, then such a version adapter is guaranteed to exist for the two types. The approach \nis se\u00adcure: the type system prevents unauthorized clients from updating implementations, while branded \ntypes prevent accidental confusion of types. The only requirements of the core language are that it provide \nbranded types (with type equality based on name type equivalence) and that values of branded types are \ntagged with run-time type tags. Both of these requirements are satis.ed by the Modula-3 and Java programming \nlanguages. With small modi.cations it can be ap\u00adplied to a version of ML where all abstract data types \nare imple\u00admented by datatypes. Also it is compatible with Modular Typed Assembly Language [27], although \nit provides support for shared libraries that is missing in MTAL. Shared libraries refer to the abil\u00adity \nto load an often-used library into machine memory and initial\u00adize it once, and thereafter have that instance \nof the library shared by other programs. Type sharing constraints are the basis for sup\u00adporting shared \nlibraries in our system. In the next section we describe the core language .box that we use throughout \nthe paper. In Section 3 we introduce a very simple module language .swap for this core language. In Section \n4 we describe the approach to hot swapping in this language. In Sect. 5 we provide a computational semantics \nand verify its correctness. We consider extensions of this basic approach in Section 6. We consider related \nwork in Section 7, while Section 8 provides our conclusions. 2. CORE LANGUAGE In this section we describe \nthe core language that will be used throughout the paper. We call this language .box. It forms a subset \nof .swap, the complete language including modules and hot swap\u00adping. The extensions for the latter are \nprovided in the next section. The actual form of the core language is largely immaterial to the rest \nof the paper, except for the mechanisms for tagging values with types described in this section. The \ncomplete language syntax for .swap is provided in Fig. 1. This is a conventional polymorphic typed .-calculus. \nTypes in\u00adclude type identi.ers t and base types (we only include the base type int). There is a type \nfor procedures: A . B denotes the type of a procedure that expects an argument of type A and returns \na result of type B. There are also record types: {l1: A1,... ,lk : Ak} denotes the type of a record with \n.elds labelled l1,... , lk, where the ith .eld has label li and type Ai. Expressions of the language \ninclude vari\u00adables x and base constants (integers) n. The expression (.x : A.e) denotes a procedure of \none parameter, x, that returns the result of executing the expression e. The expression {l1 = e1,... \n,ln = en}denotes a n-ary record. Application of a procedure is denoted by (e1 e2), while e.l denotes \nan access to the .eld labelled l in a record. This language includes type operators and polymorphism, \nso it can be considered as a kernel language for languages such as Ada, ML and dialects of Java with \nparameterized types [36, 47, 6, 10]. Our approach to hot swapping extends straightforwardly to these \nlatter languages. In this type system we distinguish between domain kinds DK and interface kinds IK. \nThe former are used to describe the domains of type operators, while the latter are used to describe \ntype operators exported in module interfaces. 2.1 Swapping Implementations We .rst of all address the \nissue of swapping implementation code (without changing representation types). At the concrete level, \nthis is already a dif.cult problem; what happens if we try to change the code for a currently running \nthread? Although one may consider schemes for setting resting points in the code at which it is safe \nto replace that code, it appears unlikely that such approaches will scale, given the degree of cooperation \nrequired from the application and the level of sophistication this demands of the implementation. It \nshould be clear that replacing the stack frame and restarting the procedure is not a viable option in \ngeneral. Cowan et al [14] de\u00adscribe an approach where code update for a function or method is blocked \nwhile a client thread is executing the old version code; this has obvious problems if the client thread \nis executing a long-lived loop in the code. Another approach is to simply kill any threads running the \ncode that is being replaced [44]. Our approach is to allow the thread to continue running, and to provide \nthe new code to subsequent clients of the module. A client obtains code in the form of a closure or object \nfrom the library (say by calling a method of a factory object). Since we do not perform global update \n(described in Sect. 8), this value is unchanged by a library update. This then gives rise to the possibility \nof old version code receiving new version values, as explained in the introduction. It is perhaps tempting, \nfor example in the case of updating Java classes, to update method code for any fresh invocations of \nmeth\u00adods of that object. This approach works only as long as the object layout is not modi.ed by the \nclass update. But this is not the sce\u00adnario that we are interested in. When only considering update of \nimplementation code, we model this scenerio in an abstract setting very simply. A module in this simple \nscenario is a mutable reference cell. Hot swapping is then simply an assignment to this cell with a new \nimplementation. We only require that this assignment be atomic in a multi-threaded set\u00adting. What if \nthe updated library has state, for example, a Java class has a mutable class variable and the class is \nupdated? In the ab\u00adstract setting a module can be represented as a record, and state is represented by \na mutable .eld in this record. The state in the original module is replaced by the state in the new module. \nIf the new module wishes to incorporate the old module state, then it will retain references to the old \nmodule state. All of this can be repre\u00adsented by a two-step operation of applying a conversion operation \nto map the old implementation to the new implementation, then de\u00adstructively updating the mutable reference \ncell for the module with the new implementation. This very simple scenario already brings up an important \npoint: how do we prevent malicious threads from performing unwanted updates on the code? We can prevent \nthis in the type system, by controlling access to the ability to mutate the reference cell for the module. \nML has a notion of reference types, that delineate the parts of a program where bindings can be mutated \nby assignment: deref\u00aderencing !x and assignment x := e are only allowed by the type system if x has a \nreference type ref (A) for some A. We re.ne a ref\u00aderence type to three reference types, for read-only, \nwrite-only and < F8::= 0/ |{(t : IK)}| F1 . < F2 Type heap env . ::= 0/ |{(t : DK)}| .1 . .2 Type var \nenv . ::= 0/ |{Con}| .1 . .2 Sharing constraints T8::= 0/ |{(a : Tag(.t))}| T81 . T82 Runtime tag heap \nenv .8::= 0/ |{(x : .A)}| <.2 Value heap env .1 . <G ::= 0/ |{(x : A)}| G1 . G2 Value param env DK . \nDomain Kind ::= ty Simple kind | DK . DK Kind of type operator IK . Interface Kind ::= lA Box kind | \nty Simple kind | .t : DK.IK Kind of type operator A . Type ::= t Type identi.er | int Type constant | \nA . B Procedure type |{l1: A1,... , lk : Ak} Record type | Tag(.t) Type tag type | DA Box type | (AB) \nType application | .t : DK.A Type operator e . Exp ::= x Program identi.er | a Type tag | n Value constant \n| .x : A.e Procedure | (e1 e2) Application | .t : DK.e Polymorphic procedure | (eA) Polymorphic instantiation \n|{l1 = e1,... ,lk = ek} Record | e.l Selection | !x Dereference cell | x := e Mutate cell | fold(tA1 \n...Ak )(e1,e2) Add type tag | unfold(tA1...Ak)(e1,e2) Remove type tag | init Decl in e Bind package in \nprogram | share v realizes Con in e Re.ect sharing v . Value ::= a | n | .x : A.e | .t : DK.e |{ln = \nvn}| foldA(a,v) . . Variance ::= .| + |- Pty . Pkg Type ::=[t : .1IK,.2A, Con] Package Type Decl . Pkg \nDecl ::= ((t,a),x) : Pty . [A, e] New Package Decl | ((t,a),x) : Pty ~,a'] Sharing Existing Package = \n[(t''),x ~ Con . Constraints ::= t1 = t2 . DK Sharing Constraint Figure 1: Syntax for .box and .swap \nread-write variables. This is similar to the use of variances in the object calculi of Abadi and Cardelli, \nto control access to the .elds of objects [2]. Speci.cally we extend the syntax of module interfaces \nwith re\u00ad.ned reference types . for value .elds, as described in Fig. 1. Mod\u00adule value .eld types, annotated \nwith reference type constructors, have three forms: Field Type Interpretation +A Values can only be read \n-A Values can only be mutated .A Values can be accessed and mutated  Interface matching for modules \nincludes subtype inclusion for .eld types based on inclusion of reference type constructors1: A = A ' \n. . {.,+} A ' = A . . {.,-} A = A ' .A = +A' .A =-A'.A =.A'  This allows an implementor to export a \npackage to clients with\u00adout allowing those clients to rede.ne the package implementation (by weakening \nthe exported reference constructors from . to +). For example, using ML modules this can be described \nas: module type SERVICE = sig type t; val x : +t end module Service : SERVICE = struct type t = int; \nval x : .t = ref(3) fun updater () : () = ... val = fork(updater) end The reader is cautioned that the \nboxed parts of the example are not valid ML types; we are only using ML to illustrate the use of re.ned \nreference types. In this example, the reader is invited to consider t and x as the type and value .elds, \nrespectively, of a li\u00adbrary that might be updated. Clients of the Service module can only access it through \nthe SERVICE interface; this interface pre\u00advents clients from mutating the x .eld. Within the module, \na thread is forked that may (say in response to network messages) perform library updates; this is possible \nbecause the thread code can view x as a mutable variable. 2.2 Dynamic Typing Dynamic typing is a crucial \naspect of our approach to hot swap\u00adping. We review the line of reasoning that leads to this conclusion: \n1. A client (call her the swapper) that changes the type de.\u00adnitions for a module must supply version \nadapters that map between old and new versions of the type. 2. Whenever a value is accessed, an implicit \ntypecase is used to see what version that value corresponds to. If the value does not have the required \nversion, it is transformed to the expected version, using version adapters. 3. We use run-time type \ntags to index version adapters. The swapper identi.es the types that are to be related by version adapters, \nby using the type tags for those transformers.  1In Java a similar effect can be obtained by only allowing \npublic access to a get static method, while the set static method is kept private within a class. In \nour kernel language this is not suf.cient, since it may be possible to mutate the get procedure. The \nJava ap\u00adproach represents a special case of our approach where all .elds of procedure type have reference \ntype constructor of + and therefore are immutable. However we desire our approach to be applicable to \nseveral languages, including but not limited to Java. Box types are the basis for tagging data values \nwith run-time type tags: 1. The type DA denotes the type of values of type A tagged with a run-time type \ntag. 2. Type tags are .rst-class values a (denoting addresses in a type tag heap [26]). 3. A constructor \nfold(tA1...Ak )(a,e) attaches the type tag a to the value e, where e must have type (tA1 ...Ak) and a \nmust have type Tag(.t) for some reference type constructor .. This reference type constructor is necessary \nfor the same reason that a module implementation has a reference type: to control the ability of untrusted \nclients to perform library updates.  The ML language uses structural equivalence for types in general \n(unless the type de.nition is opaque or is a datatype). We require name equivalence for types exported \nby a module. This is neces\u00adsary because otherwise it would be possible for a malicious client to forge \na run-time type tag for a type and perform unwanted up\u00addates. A type exported by a module must be treated \nas a (partially) opaque type both outside and inside the module. Again this is nec\u00adessary because otherwise \nit would be possible to forge run-time type tags. Since types exported by a module must be opaque both \ninside and outside the module, this raises the question of how we can ever build values of such a type. \nIn ML, type information is exported from modules by type abbreviations in interfaces. There are two reasons \nwe cannot pursue this approach. First, it makes the type transparent (singleton kinds also have this \nproblem [55]). Second, we restrict type equations in the type system to only express shar\u00ading between \ntype constructors; there are notorious problems with allowing arbitrary forms of type sharing to be asserted \n[45]. There\u00adfore we require an alternative mechanism for exporting representa\u00adtion type information. \nThis is provided by box kinds lA, the kinds of box types DA. In summary, box types use the following \nmechanisms: 1. Given a type A, the box type DA denotes the type of values of type A tagged with a run-time \ntype tag. 2. A module only exports types with run-time type tags, that is, box types. However such an \nexported type is always partially opaque both inside and outside the module. The only type de.nition \ninformation available is revealed in the box kind for the exported type. The actual type de.nition is \na boxed type DA; inside and outside the module, it is only visible as an opaque type with box kind lA. \nIK denotes the syntax of interface kinds, the kinds of types exported in module inter\u00adfaces. 3. There \nis a subkind rule lA = ty that allows a partially opaque type to be made opaque. This allows a module \nto export a type as an abstract data type. 4. Given a type identi.er t with box kind lA (bound in a \nmod\u00adule interface), the type Tag(.t) denotes the type of a run-time type tag for boxed values of that \ntype at run-time. The type tag maintains a phase distinction between the compile-time box type and the \nrun-time type tag identifying that type. Type tags are represented by type identi.ers a. 5. Given a \ntype t of box kind, and a type tag et for that boxed type, there is a corresponding operation foldt (et \n,e) for at\u00adtaching a run-time type tag to a value (injecting the value into  a box type), and an operation \nunfoldt (et ,e) for extracting the tagged value from a value of box type. It is this latter opera\u00ad tion \nthat may trigger the application of version adapters. An example of these mechanisms is provided by: \n // Assume tint : lint, aint : Tag(+int) // Tag an integer with a type tag x : tint = foldtint (aint \n,3) // f removes the tag from a tagged integer f = .x : tint . unfoldtint (aint ,x) where aint is a run-time \ntype tag for the boxed int type, tint . Box kinds generalize to kinds for type operators, as explained \nin the full version of this paper [20]. Box kinds are similar to the use of singleton kinds to expose \nrepresentation information in module interfaces [55]. The main difference between the approaches is that \nwe assume that values of abstract type have run-time type tags, so we require folding and unfolding operations \nfor adding and removing these tags.  3. MODULES AND BRANDED TYPES To build a value tagged with a run-time \ntype tag, we need a run\u00adtime type tag. We have not explained how to generate these type tags. As explained \nin Sect. 1, it is important for dispatching version adapters that every type exported by a module has \nexactly one type tag associated with it. Therefore generation of run-time type tags is incorporated into \nthe semantics of module initialization, since this is where a type is made available to clients of a \nmodule. Because of this, our approach to combining branded types and run-time type tags is novel, as \nexplained in Sect. 7. The .box and .swap languages include simple modules called packages, as described \nin Fig. 1. A new package is de.ned using the syntax ((t,a), x) : Pty [A,e] According to this syntax, \na package is a pair of a type A (the repre\u00adsentation type or witness type) and an expression e (an implemen\u00adtation \nbased on that representation type). Clients of the module can access the type component using the type \nidenti.er t, the run\u00adtime type tag using the identi.er a, and the value component of the module using \nthe identi.er x. Packages are similar to structures in the structure calculus [30]. A more complete module \nsystem, compatible with the very simple module system presented here, is developed in another paper [19]. \nA package type Pty, the interface provided by a package to clients, has the form [t ' : .1IK, .2B, Con] \n Assuming the module is declared as above, a module with this in\u00adterface has three components: 1. The \ninterface exports a type component t with interface kind .1IK. The type t has kind IK, while a has type \nTag(.1t). So the reference type constructor .1 for the type component controls the ability of clients \nto update the module s type def\u00adinitions. The type identi.er t ' is bound in the package type, and allows \nreference to the type component of the module in the type of the value component A. The type identi.er \nt and tag identi.er a are visible both to clients of this module de.nition, and also in the value body \ne of the module itself, to make the type tag visible within the value component of the package body: \n((t,a),x) : [t ' : .IK,, ][A, (... t ... a ...)] fold and unfold are used within the package to build \nand ac\u00adcess tagged data values. These operations are also available to clients of the package if the \nkind of the witness type re\u00adveals the representation type via an open kind. 2. B is the type of the value \ncomponent (implementation). Clients access the value component using the identi.er x, with type .2B. \nAgain the reference type constructor controls updates. 3. Con is a type sharing constraint. For a new \nmodule de.nition this will be simply t ~t . (IK)*. More meaningful type shar\u00ad  = ing constraints are \nexported by shared libraries, as explained below. We also include an init construct that allows packages \nto be bound locally in a program. Dynamic linking can be incorporated into this framework [19]. With \nthese operations, a library can be loaded via a three-step process of (a) deserializing the library from \ndisk or network to an in-memory dynamically-loaded library, (b) re.ecting the DLL from the core language \ninto the module lan\u00adguage ([19]), and (c) using the init construct to initialize the library and bind \nits contents in the local scope of the continuation for the init. Modules play an integral r ole in \nthe proper typing of the fold and unfold operations for box types. Suppose we have: ((t,a),x) : Pty [int,... \n] y = foldt (aint , 3) z = foldt (a,3) This example de.nes a module with a witness type of int. The de.nition \nof y attempts to build a value of type t that is tagged with the type tag for the witness type, int. \nWere this to succeed, it would mean that aint is a legitimate type tag for t. This would be disastrous \nfor security, because any client could update the type de.nition of the module, defeating any attempt \nto prevent untrusted clients from modifying libraries. However the de.nition of y is prevented by the \ntype system. The de.nition of z, using the type tag a that is the legitimate type tag for t, successfully \ntype-checks. Shared libraries can be established using type aliasing, but there is a problem with using \ntype de.nitions to de.ne aliases. Consider the following package de.nitions: ((t1,a1),x1) : [t : .ty,.{a \n: t, f : t . t},t ~[int,...] = t . ty] ((t2,a2),x2) : [t : .ty,.{a : t, f : t . t},t ~[t1,x1] = t . ty] \n The former module de.nition is intended to be a shared library, loaded and initialized once by the operating \nsystem and thereafter shared by other processes. The interesting issue we consider is the sharing of \ntype information with clients of the shared library. The latter package is intended to be an alias for \nthe .rst package, both providing the same package type. However with this de.nition of the client module, \nthe type system is not expressive enough to reveal the fact that the witness type t2 is the same as the \nwitness type t1. Therefore the following code fails to type-check: (x2. f )(x1.a). We provide support \nfor shared libraries with type sharing con\u00adstraints. This is a rather old idea from the SML 90 module \ntype system [46, 45]. Type sharing constraints are equations in the type system that equate type constructors. \nAs with SML 90, we only allow type sharing constraints between type constructors (the type components \nof package types). Type sharing constraints are not allowed between arbitrary types. Type abbreviations \nin package types are provided using box kinds. Unlike ML, type abbreviations are assumed to de.ne branded \ntypes. The de.nition of a client of a shared library is given by the alter\u00adnative syntax for de.ning \na package s: ' ((t,a), x) : Pty ~, a '),x '] = [(t This includes the type tag for the original package, \nto ensure that dynamic as well as static type identity are shared. As well as shar\u00ading type identity, \nthe de.nition of shared libraries ensures that all clients of a shared library are updated with any changes \nto the li\u00adbrary implementation. The following is the correct de.nition of a shared library and client: \n((t1,a1),x1) : [t : .ty, .{a : t, f : t . t},t ~[int,...] = t . ty] ((t2,a2),x2) : [t : .ty, .{a : t, \nf : t . t},t '~= [(t1, a1),x1] = t . ty] ~ In summary, we have the following analogy with ML modules: \nML .swap New Mod module S = ((t,a),x) : Pty [A,e] struct ... end Shared Lib module S = S = [(t ''), x \n'] ((t,a),x) : Pty ~,a  4. HOT SWAPPING Hot swapping is based on a re.ective mechanism that allows the \nprogrammer to add type sharing constraints to the type system, jus\u00adti.ed by version adapters. These version \nadapters are run-time co\u00adercions between the types that are to be shared. An expression e ~ is evidence \nfor the sharing constraint t1 = t2 . DK if e is a triple (e0, e1,e2) where: 1. e0 is a pair of coercion \nfunctions between the types B1 and B2, where ti has box kind lBi and (lBi)* = DK for i = 1, 2; 2. e1 \nis a type tag for t1, with type Tag(.t1), and 3. e2 is a type tag for t2, with type Tag(.t2).  The \nconstruct for hot swapping a new package implementation into a running package is speci.ed by: e . Exp \n::= share v realizes Con in e The share construct allows two package witness types to be shared, by \nre.ecting version adapters for values of the two types. The syn\u00adtax v denotes a value, so there is guaranteed \nto be no further evalu\u00adation by the version adapter (until it is applied). The reason for this syntactic \nrestriction is given at the end of this section. Consider the following interfaces of two packages with \ndifferent witness types: ((t1,a1),x1) : [t : .ty, .(int \u00d7 int), ... ] ... ((t2,a2),x2) : [t : .ty, .(int \n\u00d7 float \u00d7 int), ...] ... Now a version adapter is constructed to map between these witness types (float() \nand int() are type casts), and used as evidence for the assertion of a sharing constraint between t1 \nand t2: f = .(x,y) : (int \u00d7 int). (x,float(y),0) g = .(x,y, ) : (int \u00d7 float \u00d7 int). (x,int(y)) share \n( f ,g) realizes t1 ~ = t2 in ... It is to be noted that the coercion functions map from the unfolded \nwitness types to the witness types. This is necessary in order to allow version adapters to be composed. \nThe following examples illustrate when version adapters are and are not invoked (we assume a print operation \nfor the example): x : t2 = foldt2 (a2, (3,4.0,5)) y : t1 = x // No coercions z : t2 = y // All original \n.elds retreived print(p3(unfoldt2 (a2,z))) // Output 5 // The following causes an implicit coercion \n w = unfoldt1 (a1, y) Reference types (for values allocated in the store) allow package implementations \nto be rebound. Reference cell creation is implicit in the operation of initializing a package. With these \nconstructs, an operation for hot swapping can be de.ned as: rebind ((t1,a1),x1) : [t : .,A,Con] with \n((t2,a2),x2) isovin e ~ = ( share v realizes (t1 = t2 . (IK)*) in (x1:=!x2; e)) There is a subtlety \nin the form of the share construct: the version adapter is required to be a value. To explain why this \nis so, consider the type rule for the share construct: F8; T8;.;. .{Con};.8;G fval v : Con F8;T8;.;. \n.{Con};.8;G fval e : A F8;T8;.;.;.8;G fval (share v realizes Con in e) : A (VAL SHARE) The interesting \npoint is that the sharing constraint being realized is available to type the de.nitions of the version \nadapters. This means that the version adapter may be invoked recursively while it is executing. This \nis safe because the version adapter will not be invoked until it is installed; hence the value restriction. \nThe reason for allowing the version adapter to be typed with the realized shar\u00ading constraint visible, \nis to allow lazy adaptation of potentially recursive data structures. For example, consider an adapter \nfrom t1 to t2 where: t1: l(t1,int,int,t1) t2: l(t2,(int,int),t2) We do not allow this form of recursive \nbox kinds, but we will allow it now for expository purposes. At this point we merely want to demonstrate \nthe .exibility of the approach. A version adapter from t1 to t2 can be de.ned as: .(x, y,z,w). foldt2 \n(a, (x,(y, z), w)) using an obvious abbreviation for projections. The important point is that the triple \nconstructed by the adapter has type (t1 \u00d7 (int \u00d7 int) \u00d7t1) Using the sharing constraint that this adapter \nis realizing, this type is equal to (t2 \u00d7 (int \u00d7 int) \u00d7t2) So the tagging of this value with the type \ntag for t2 type checks. This means that adapting recursive data structures such as lists and trees does \nnot require the entire data structure to be converted. In fact adaptation can be de.ned (as above) to \nunfold lazily as application code walks over the data structure. 5. COMPUTATIONAL SEMANTICS A type system \nis provided in the full version of the paper [20]. A computational semantics is provided in Figure 2. \nThis semantics is based on both local and global computation rules. The local computation rules are the \nreduction rules for the core language: (.x : A.e) v -. {v/x}e (.t : DK.e) A -. {A/t}e {l1 = v1,... ,ln \n= vn}.li -. vi unfold(tA1...Ak )(a,fold(tB1...Bk)(a,v)) -. v The global computation rules are speci.ed \nusing con.gurations of the form let TH,RTH, VH, SH inE[e] where: 1. TH is a type heap, a mapping from \ntype identi.ers to box types. Because of the way that types with box kind are used, this de.nition is \nunnecessary for typing con.gurations, but we maintain it for completeness. The type heap is not nec\u00adessary \nfor evaluation and can be removed in a type-erasure semantics. 2. RTH is a runtime tag heap, a collection \nof runtime type tags, one for each type introduced by a module initialization (where the module is not \nde.ned using a sharing de.nition). 3. VH is a value heap, a set of bindings of heap locations to values \n(for the mutable module value de.nitions). 4. SH is a sharing realization heap, a set of coercions that \nre\u00adalize sharing constraints in the type system. This is a map\u00adping from pairs of runtime type tags to \ncoercions from the .rst type to the second type. This heap is extended by the share construct. 5. E[] \nis an evaluation context specifying where the next redex is in the expression (We omit the familiar de.nition). \n  The key step in the operational semantics in Fig. 2 is the rule for unfolding a folded type, where \nthe type tag for the expected type an is different from the type tag a0 associated with the data value. \nType correctness (the progress lemma below) ensures that there must be some sequence of type tags a1,... \n, an-1 such that there is a coer\u00adcion from ai to ai+1 for i = 0,... ,n-1. This sequence corresponds to \nthe applications of transitivity in a derivation of the equality of the type represented by a0 and the \ntype represented by an, based on hypotheses for the equality of types represented by ai and ai+1. Recall \nfrom Fig. 1 that F8denotes a type heap environment, T8a run-time tag heap environment, .8a value heap \nenvironment, and . a context of type sharing constraints. The following results are veri.ed in the full \nversion of this paper [20]. De.nition 5.1 (CONFIGURATION TYPE). De.ne f (let TH,RTH,VH,SH ine) : (F8;T8; \n.; .8;A) if 1. F8;T8; 0/;.;.8;0/ f0; 2. dom(TH)= dom(F8) and F8; .;. f TH(t) : F8(t) for all t . dom(TH); \n 3. RTH = dom(T8); 4. dom(VH)= dom(.8) and F8; T8;0/;.; .8;0/ fval VH(x) : .8(x) for all x . dom(VH); \n ~ 5. for all (t1 = t2 . DK) . . where t1 = t2, we have (a1: Tag(.t1)),(a2: Tag(.t2)) . T8for some a1,a2 \n. RTH, and (a1,a2),(a2, a1) . dom(SH), and F;T8; 0/;.; 8 = t2 . DK) 8.; 0/ fval ((v1,v2),a1,a2) : (t1 \n~ where v1 = SH(a1,a2) and v2 = SH(a2,a1); and 6. F8;T8; 0/;.;.8;0/ fval e : A. Theorem 1 (SUBJECT REDUCTION). \nIf f (let TH1,RTH1, VH1,SH1 in e1) : (F<1;T<1; .1;.<1;A) and let TH1, RTH1,VH1,SH1 in e1 -. let TH2, \nRTH2,VH2,SH2 in e2, then f (let TH2,RTH2, VH2,SH2 in e2) : (F<2;T<2; .2;.<2;A) for some F<2,T<2, .<2,.2 \nwhere F<1 . F<2, T<1 . T<2, .<1 . .<2,.1 . .2. Theorem 2 (PROGRESS). Assume f (let TH1,RTH1, VH1,SH1 \nin e1) : (F<1;T<1; .1;.<1;A) Then either e is a value v or ' let TH, RTH,VH,SH ine -. let TH ' ,RTH \n' ,VH ' , SH ine '] for some expression e ' . 6. EXTENSIONS 6.1 Mutable Versions: The semantics of \nhot swapping is based on programmer-de.ned version adapters between old and new version values. What \nshould be done if one of the versions has a mutable .eld? For example, suppose we have old version code \nthat expects values with a muta\u00adble x .eld, and this code is passed a new version value without such \na .eld. For any kind of backward compatibility, it must be possible to emulate the state of the x .eld \nusing the state of the new ver\u00adsion value. The best avenue to model this is by considering every version \nvalue as an object (or equivalently a closure in our kernel language .box). Each .eld in the original \nvalue has a get method for retrieving its value, and a set method for mutating the value of that .eld. \nThe version adapter then constructs a proxy object for the old version value, that performs updates on \nthe state of the new version value in response to updates that are requested on the old version value. \nThere is an apparent relationship here between coercing values between versions and marshalling values \nfor transmission in net\u00adworks. For example Java RMI distinguishes between remote ob\u00adjects and ordinary \nobjects, with the former objects transmitted by reference between address spaces and the latter transmitted \nby value. For objects with only immutable .elds, a version adapter maps to another object of the required \nversion. For an object with mutable .elds, the version adapter constructs a proxy object with references \nto the state in the original object. However while mar\u00adshalling can be automated from type descriptions \nof values (see for example [16]), in general we do not expect this automation support to be useful for \nconverting between version values, because the dif\u00adferences between versions are much more than simple \ndifferences of data format. 6.2 Inheritance and Subtyping What is the relationship between coercing \nversion values and in\u00adheritance in object-oriented languages? We identify these differ\u00adences: 1. In terms \nof data representation, inheritance only allows the addition of new instance variables to a class. We \nexpect much more general changes in representation in going from one version to another. '' let TH,RTH,VH,SH \ninE[e] -. let TH ' ,RTH,VH ' , SH inE[e '] if e -. e under one of the following evaluation rules: '' \ne eTH ' RTH ' VH ' SH init ((t,a), x) : [t : IK,A,Con] e0 TH . {t .. DB} RTH . {a} VH . {x .. v} SH a \n/. RT H [B, v] in e0 t /. dom(TH) x /. dom(VH) init ((t,a), x) : [t : IK,A,Con] ~= [(t ' ,a '),x '] in \ne0 {t ' /t, a ' /a, TH RTH VH SH x ' /x}e0 share ((v1,v2), a1,a2) realizes Con e TH RTH VH SH[(a1,a2) \n.. v1, in e (a2,a1) .. v2] !x v TH RTH VH SH VH(x) = v x := v v TH RTH VH[x .. v] SH unfold(tn A1...Ak \n)(an, v '(v) TH RTH VH SH a0,... ,an distinct fold(t0 B1...Bk )(a0,v)) vi = SH(ai-1,ai) v ' i = vi A1 \n...Ak v ' = v ' n . \u00b7\u00b7\u00b7 . v ' 1 ' ' e0 e0 TH RTHVH SH e0 -. e0 Figure 2: Evaluation Rules for .swap \n2. Subtyping based on inheritance allows a method of the su\u00adperclass to receive an object of a subclass \nas an argument, so old version code can handle new version values (by forget\u00adting the added instance \nvariables). However it is not pos\u00adsible for new version code to receive old version values (for example, \nthe combine method from Section 1). In general the object-oriented approach breaks down in the presence \nof binary methods, because there is then no longer any subtype relationship between the subclass and \nsuperclass [11, 12, 7, 9]. Named subtyping relations, based on programmer-de.ned inher\u00aditance hierarchies, \nare purely static in typed object-oriented lan\u00adguages. On the other hand, our semantics for hot swapping \nis based on allowing the program to dynamically assert the equiva\u00adlence of two (branded) types. This \nappears to allow some interest\u00ading possibilities when incorporated into object-oriented languages. For \nexample it allows two nodes in the subtype hierarchy to be equated, allowing the program to dynamically \nmodify the inheri\u00adtance hiearchy in a type-safe way. This provides an avenue for al\u00adlowing objects to \nmove dynamically between r oles in the inheri\u00adtance hierarchy, in a type-safe way, and potentially with \nthe version adapters performing security checks on when this is allowable. 6.3 User Control of Updating \nIn an imperative language it might be desirable to notify clients of an update, as an invitation to update \nthe values that they have ob\u00adtained from the library. This noti.cation could be provided simply in the \nform of a library function that returns the current version of the library, say as the run-time type \ntag for the type exported. It is trivial to provide an operation in our language that allows clients \nto update values to a new version; the only proviso is that this opera\u00adtion may fail due to the absence \nof a version adapter, because there is not enough type information in client code to statically check \nthis update.  7. RELATED WORK COM, CORBA and JavaBeans [13, 54, 28] provide limited ver\u00adsion support \nfor updating modules, with clients able to use run-time type checks to determine what versions of a module \nare available. This is apparently how COM was designed to cope with version changes in servers (COM terminology \nfor a DLL). This approach has the obvious problem that old version code may need to be main\u00adtained in \nthe system inde.nitely, to cater to old clients. Since this approach is essentially object-oriented, \nit does not handle binary methods (such as the combine method above) where old version values may be \npassed to new version code. In general the object\u00adoriented approach only allows limited support for code \nupdate (ex\u00adtending the state of objects) and breaks down for binary methods (since subtyping does not \nhold between superclass and subclass in the presence of binary methods [11, 12, 9]). Similar remarks \nhold for Java interfaces, that provide similar functionality to COM inter\u00adfaces. Dynamic linking [24] \nallows libraries to be loaded from disk or over the network at run-time. However dynamic linking does \nnot allow the code of an existing library to be replaced with new code. Although there are many problems \nwith hot swapping, the prob\u00adlem we are particularly concerned with is ensuring type safety when the data \nrepresentations exported by a module are changed by up\u00addates. Hjalmtysson and Gray [35] identify several \nmodels for up\u00addating values in the program when a library (including data repre\u00adsentations) is changed: \n1. Version barrier: With this approach, a library (and its type de.nitions) cannot be changed while there \nare values of its type in the program. In object-oriented parlance, a class can\u00adnot be rede.ned while \nthere are any objects of that class in the program. This has obvious drawbacks and is very in.ex\u00adible \nfor the kinds of applications envisaged for hot swapping. 2. Passive partitioning: This model allows \nvalues of both the old and new implementations to coexist in the program. Old version values continue \nto exist after the library update, while new version values are generated by the updated library. This \nmodel is implicit in the example above involving the combine method. As that example demonstrates, the \nchallenge with this approach is to ensure that values of the different type versions (objects of the \ndifferent classes) can interoperate in a type-safe manner. 3. Global update: This is the dual of version \nbarries. The latter avoid the multiple version problem by preventing the cre\u00adation of new versions until \nold versions are gone from the program. Global update takes the dual approach of replacing all old version \nvalues with new version values. This process is typically analogous to running a garbage collector, using \nan adapted garbage collector algorithms to scavenge the heap and thread stacks for old version values \n[25, 44]. Another ap\u00adproach is to require that all values of updateable library types be proxy objects, \nand a library update then causes all proxy objects to update their implementation pointers [35]. This \nhas the advantage of being possible to provide in libraries, and the disadvantage of having poor performance \ndue to in\u00addirection through proxy objects.  Although matters are greatly simpli.ed once the global up\u00addate \nis done, there are obvious challenges with accomplish\u00ading this. For example there is the issue of interaction \nwith threads: values must be locked with an update lock and threads must check this lock every time they \ntry to access a value. It is not clear how this would work in a distributed environ\u00adment, where the application \nmay be distributed in several ad\u00address spaces and the old version values must be updated in all of these \naddress spaces. A distributed implementation of this approach would be at least as hard as distributed \ngarbage collection. More fundamentally for our purposes, global update does not solve the problem of \nthreads executing old version code. For example one implementation of global update in a Java VM [44] \naborts a thread if a class update is attempted while the thread is executing a method of that class; \nactive classes cannot be updated without breaking something. If we post\u00adpone library updates until it \nis no longer active, then this ap\u00adproach degrades to the version barrier approach. It is quite reasonable \nto expect that the library has forked threads that last as long as the program s execution. Finally there \nis the problem with providing a reasonable real-time guarantee about when the update will happen; if \nthe update is necessitated by a revision in security policy [32], this real-time guarantee will be critical. \n Module interconnection languages (MILs) are recognized as an essential tool in managing the complexity \nof increasingly vast soft\u00adware systems. The last few years have seen several developments in the semantics \nof MILs [30, 29, 39, 40, 52, 21, 8, 23, 27]. While much of the work has centered on the module system \nfor the ML functional language, because of some of the ambitious design goals of this MIL, more recent \nwork has looked at more low-level se\u00admantics for MILs, essentially giving a type-theoretic semantics \nfor linking in the Unix and Windows environments. Semantics have recently been given for type dispatch \nfor named hierarchical types in object-oriented languages (Java in particular) [26, 37]. The work of \nLeague et al [37] gives a translation of Java classes into extensible datatypes in a typed intermediate \nlanguage. They do not consider hot swapping of running modules. Glew [26] gives a calculus of branded \ntypes with named subtyping and dy\u00adnamic type dispatch. In his calculus all values with type tags are \ngiven the type tagged; a typecase construct is required to examine this tag, and tag types carry information \nabout the type denoted by a tag. Relating type tags and branded types through the module sys\u00adtem is a \ncontribution of this work. It appears plausible that Glew s mechanisms for representing type tags in \ntyped assembly language could be adapted to a translation of our core language to TAL. An incorporation \nof our semantics for hot swapping into typed assem\u00adbly language is an obvious next step in this work. \nWork on dynamic linking has focussed on class loading in the Java virtual machine [42]. Work on dynamic \nlinking in ML has focussed on dynamic types [3, 41, 1, 53, 17]. In other work we are considering a richer \nmodule language that is compatible with the approach described here, and includes support for dynamic \nlinking. Gilmore et al [25] give a design description of Dynamic ML, a version of ML that allows hot \nswapping of ML modules in run\u00adning programs. In their system the new module may change some of the data \nrepresentations exported by the original module. They describe how to use a modi.ed two-space garbage \ncollector to per\u00adform global update. Malabarba et al [44] describe the actual imple\u00admentation of global \nupdate in a Java VM, adapting an incremental algorithm. Hjalmtysson and Gray [35] also perform global \nupdate, but they require updatable classes to use proxy objects, and then an update is performed by telling \nthe proxy object to change its im\u00adplementation pointers. This has the bene.t of being independent of \nthe run-time, and the cost of incurring the run-time of indirecting all object accesses through proxy \nobjects. In the untyped object-oriented community, for example in Smalltalk and CLOS environments, there \nis a great deal of .exibility in allow\u00ading parts of the application (and the run-time itself) to be modi.ed, \nfor example using meta-object protocols). However the challenge of this work has been to provide .exible \nmechanisms for allowing types to be changed at run-time, while ensuring type safety. The Argus system \n[43, 5, 4] provided some support for updating a running system, using guardians, however versioning was \nlargely of the nature provided by object-oriented languages, and support mainly focused on properly terminating \ntransactions. Evans and Dickman [22] describe an approach to managing mul\u00adtiple versions of modules in \na distributed environment. Their ap\u00adproach uses type transformers and programmer-de.ned change ab\u00adsorbers \nto manage transformations between versions as they cross zones (a zone is a collection of process address \nspaces). However they do not handle the problem of updating a module within a pro\u00adcess (P. Dickman, personal \ncommunication), so this work is largely orthogonal to our approach to hot-swapping. Although change ab\u00adsorbers \nare super.cially analogous to our notion of coercions be\u00adtween values, there are important differences. \nFor example change absorbers are invoked when values cross zones, whereas coercions in our approach are \ninvoked after crossing the boundary between code versions, and then only when for example new version \ncode tries to unbox an old version value. Crary, Hicks and Weirich [15, 34] extend TAL with primitive \nop\u00aderations for building type-safe DLLs, on top of which more expres\u00adsive dynamic linking mechanisms \ncan be constructed. A compari\u00adson of their approach to dynamic linking with ours is provided in [18]. \nHicks et al [33] describe an approach to hot swapping where an old version module is replaced by a proxy \nthat redirects API calls to the new version module, marshalling and unmarshalling between old and new \nversion values where necessary. This is somewhat analogous to the approach of views described in the \nintroduction, and has all the de.ciencies of that approach. Sewell [50] describes a distributed module \ncalculus where differ\u00adent versions of the same abstract type may be exported at different sites. At the \ncore of this calculus is an operation for allowing one version of an abstract type to be used in place \nof another. There is no notion here of changing data representations on-the-.y and indeed two different \nversions can only be treated as equivalent pro\u00advided they have the same underlying representation type. \n 8. CONCLUSIONS We have described an approach to hot swapping of running mod\u00adules, that allows the type \nrepresentations exported by the replaced module to be changed by the new module. This approach is based \non the dynamic addition of type-sharing constraints, realized by programmer-de.ned version adapters that \nare re.ected into the run\u00adtime. Our approach is based on the provision of transformations map\u00adping between \nold and new versions. Subtyping in object oriented languages requires only a transformation from new \nversions to old versions, but this severely limits its usefulness for hot swapping (as explained in the \nprevious section). Global update requires only a transformation from old versions to new versions, but \nthen it is necessary to abort threads executing old version code (no update of active classes). In some \ncases it may not be possible to specify a version map\u00adping in one or the other direction. In this case \na run-time exception must be raised. The reader who is not satis.ed with this, should consider for example \nhow one can produce a record with a .eld from an empty record, where there is no default value for the \nnew .eld. Suppose that all values are objects, and all .elds are accessed via method invocations. It \nis straightforward to say that raising this exception should happen in the coercion from new version \nvalues to old version values. However this may be too coarse-grained, since the .eld access may be performed \ninfrequently. Following the above model, the programmer can choose to raise the exception in the accessor \nmethod for the .eld of the proxy object. Therefore for example an update change that adds .elds is allowed \nin our ap\u00adproach; the transformation from old version values to new version values must raise an exception \nfor a .eld for which a default value is not available, but even then only if that .eld is actually accessed. \nThis extra .exibility is not available with global update. For this approach to scale, we expect some \ncaching of coercions of values. It is straightforward to add a cache as another heap area in the semantics \nof Section 5. We are currently developing an im\u00adplementation of this approach in Typed Assembly Language \n[48]. In this regard we have already reported on work to add box kinds and type sharing constraints to \nTAL [18], where this latter work is independently motivated by the desire to support dynamic linking \nand shared libraries in TAL [19]. 9. REFERENCES [1] M. Abadi, L. Cardeli, B. Pierce, and D. Remy. Dynamic \ntyping in polymorphic languages. In P. Lee, editor, Proceedings of the ACM SIGPLAN Workshop on ML and \nits Applications, San Francisco, California, June 1992. Carnegie-Mellon University Technical Report CMU-CS-93-105. \n [2] M. Abadi and L. Cardelli. A Theory of Objects. Springer-Verlag, July 1996. [3] M. Abadi, L. Cardelli, \nB. Pierce, and G. Plotkin. Dynamic typing in a statically typed language. ACM Transactions on Programming \nLanguages and Systems, 13(2):237 268, 1991. [4] T. Bloom. Dynamic Module Replacement in a Distributed \nProgramming System. PhD thesis, MIT, 1983. [5] T. Bloom and M. Day. Recon.guration and module replacement \nin Argus: Theory and practice. Software Engineering Journal, 8(2):102 108, 1993. [6] G. Bracha, M. Odersky, \nD. Stoutamire, and P. Wadler. Making the future safe for the past: Adding genericity to the Java programming \nlanguage. In C. Chambers, editor, Proceedings of ACM Symposium on Object-Oriented Programming: Systems, \nLanguages and Applications, pages 183 200, Vancouver, British Columbia, 1998. ACM Press. [7] K. Bruce. \nA paradigmatic object-oriented programming language: Design, static typing and semantics. Journal of \nFunctional Programming, 4:127 206, 1994. [8] L. Cardelli. Program fragments, linking and modularization. \nIn Proceedings of ACM Symposium on Principles of Programming Languages, pages 266 277. ACM Press, January \n1997. [9] L. Cardelli and M. Abadi. On subtyping and matching. ACM Transactions on Programming Languages \nand Systems, 8(4):401 423, 1996. [10] R. Cartwright and G. Steele. Compatible genericity with run-time \ntypes for the Java programming language. In C. Chambers, editor, Proceedings of ACM Symposium on Object-Oriented \nProgramming: Systems, Languages and Applications, pages 201 215, Vancouver, British Columbia, 1998. ACM \nPress. [11] W. Cook. A proposal for making eiffel type-safe. In European Conference on Object-Oriented \nProgramming, pages 57 70, 1989. [12] W. Cook, W. Hill, and P. Canning. Inheritance is not subtyping. \nIn C. A. Gunter and J. C. Mitchell, editors, Theoretical Aspects of Object-Oriented Programming. The \nMIT Press, 1994. [13] M. Corporation. DCOM technical overview. Technical report, Microsoft Corporation, \n1996. [14] C. Cowan, T. Autrey, C. Krasic, C. Pu, and J. Walpole. Fast concurrent dynamic linking for \nan adaptive operating system. In International Conference on Con.gurable Distributed Systems (ICCDS 96), \nAnnapolis, MD, 1996. [15] K. Crary, M. Hicks, and S. Weirich. Safe and .exible dynamic linking of native \ncode. In Workshop on Types in Compilation, Lecture Notes in Computer Science, Montreal, Quebec, Canada, \nSeptember 2000. Springer-Verlag. [16] D. Duggan. Type-safe on-the-wire marshalling. Submitted for publication, \n1998. [17] D. Duggan. Dynamic typing for distributed programming in polymorphic languages. ACM Transactions \non Programming Languages and Systems, 21(1):11 45, January 1999. [18] D. Duggan. Sharing in typed module \nassembly language. In Workshop on Types in Compilation, Montreal, Quebec, Canada, September 2000. [19] \nD. Duggan. Type-safe dynamic linking with recursive DLLs and shared libraries. Technical report, Stevens \nInstitute of Technology, 2001. [20] D. Duggan. Type-based hot swapping of running modules. Technical \nreport, Stevens Institute of Technology, 2001. [21] D. Duggan and C. Sourelis. Mixin modules. In Proceedings \nof ACM International Conference on Functional Programming, pages 262 273, 1996.  [22] H. Evans and P. \nDickman. Zones, contracts and absorbing change: An approach to software evolution. In Proceedings of \nACM Symposium on Object-Oriented Programming: Systems, Languages and Applications, pages 415 434, Denver, \nCO, November 1999. ACM Press. [23] M. Flatt and M. Felleisen. Units: Cool modules for HOT languages. \nIn Proceedings of ACM SIGPLAN Conference on Programming Language Design and Implementation, 1998. [24] \nM. Franz. Dynamic linking of software components. IEEE Computer, 18(9162):74 81, March 1997. [25] S. \nGilmore, D. Kirli, and C. Walton. Dynamic ML without dynamic types. Technical report, Department of Computer \nScience, University of Edinburgh, 1997. [26] N. Glew. Type dispatch for named hierarchical types. In \nProceedings of ACM International Conference on Functional Programming, Paris, France, September 1999. \nACM Press. [27] N. Glew and G. Morrisett. Type-safe linking and modular assembly languages. In Proceedings \nof ACM Symposium on Principles of Programming Languages, San Antonio, Texas, January 1999. ACM Press. \n[28] G. Hamilton. JavaBeans API Speci.cation v1.01. Technical report, Sun Microsystems, 1997. [29] R. \nHarper and M. Lillibridge. A type-theoretic approach to higher-order modules with sharing. In Proceedings \nof ACM Symposium on Principles of Programming Languages, pages 123 137, Portland, Oregon, January 1994. \nACM Press. [30] R. Harper, J. Mitchell, and E. Moggi. Higher-order modules and the phase distinction. \nIn P. Hudak, editor, Proceedings of ACM Symposium on Principles of Programming Languages, pages 341 354. \nAssociation for Computing Machinery, 1990. [31] R. Harper and G. Morrisett. Compiling polymorphism using \nintensional type analysis. In P. Lee, editor, Proceedings of ACM Symposium on Principles of Programming \nLanguages, San Francisco, California, January 1995. ACM Press. [32] B. Hashii, S. Malabarba, R. Pandey, \nand M. Bishop. Supporting recon.gurable security policies for mobile Java programs. In World Wide Web \nConference (WWW9), 2000. [33] M. Hicks, J. Moore, and S. Nettles. Dynamic software updating. In Proceedings \nof ACM SIGPLAN Conference on Programming Language Design and Implementation, 2001. [34] M. Hicks and \nS. Weirich. A calculus for dynamic loading. Technical Report MS-CIS-00-07, University of Pennsylvania, \n2000. [35] G. Hjalmtysson and R. Gray. Dynamic C++ classes: A lightweight mechanism to update code in \na running program. In USENIX Technical Conference, June 1998. [36] Intermetrics, Cambridge, Mass. Ada-95 \nReference Manual, 1995. International standard ISO/IEC 8652:1995(E). [37] C. League, Z. Shao, and V. \nTrifonov. Representing java classes in a typed intermediate language. In Proceedings of ACM International \nConference on Functional Programming, Paris, France, September 1999. ACM Press. [38] X. Leroy. Unboxed \nobjects and polymorphic typing. In Proceedings of ACM Symposium on Principles of Programming Languages, \npages 177 188. ACM Press, 1992. [39] X. Leroy. Manifest types, modules, and separate compilation. In \nProceedings of ACM Symposium on Principles of Programming Languages, pages 109 122, Portland, Oregon, \nJanuary 1994. acmp. [40] X. Leroy. Applicative functors and fully transparent higher-order modules. In \nProceedings of ACM Symposium on Principles of Programming Languages, pages 154 163, San Francisco, California, \nJanuary 1995. ACM Press. [41] X. Leroy and M. Mauny. Dynamics in ML. Journal of Functional Programming, \n3(4):431 463, 1993. [42] S. Liang and G. Bracha. Dynamic class loading in the Java virtual machine. In \nProceedings of ACM Symposium on Object-Oriented Programming: Systems, Languages and Applications. ACM \nPress, October 1998. [43] B. Liskov. Distributed programming in Argus. Communications of the ACM, 31(3):300 \n312, March 1988. [44] S. Malabarba, R. Pandey, J. Gragg, E. Barr, and J. F. Barnes. Runtime support for \ntype-safe dynamic java classes. In European Conference on Object-Oriented Programming, 2000. [45] R. \nMilner and M. Tofte. Commentary on the Standard ML De.nition. The MIT Press, 1991. [46] R. Milner, M. \nTofte, and R. Harper. The De.nition of Standard ML. The MIT Press, 1990. [47] R. Milner, M. Tofte, R. \nHarper, and D. MacQueen. The Revised De.nition of Standard ML. The MIT Press, 1997. [48] G. Morrisett, \nD. Walker, K. Crary, and N. Glew. From System F to typed assembly language. In Proceedings of ACM Symposium \non Principles of Programming Languages, 1998. [49] J. G. Morrisett. Compiling With Types. PhD thesis, \nCarnegie-Mellon University, 1995. [50] P. Sewell. Modules, abstract types and distributed versioning. \nIn Proceedings of ACM Symposium on Principles of Programming Languages, London, England, January 2001. \nACM Press. [51] Z. Shao. Flexible representation analysis. In Proceedings of ACM International Conference \non Functional Programming, pages 85 98. ACM Press, 1997. [52] Z. Shao. Transparent modules with fully \nsyntactic signatures. In Proceedings of ACM International Conference on Functional Programming, Paris, \nFrance, September 1999. [53] M. Shields, T. Sheard, and S. Peyton-Jones. Dynamic typing as staged type \ninference. In Proceedings of ACM Symposium on Principles of Programming Languages, pages 289 302, San \nDiego, California, January 1998. ACM Press. [54] J. Siegel, D. Frantz, H. Mirsky, R. Hudli, P. deJong, \nA. Thomas, W. Coles, S. Baker, and M. Balick. CORBA Fundamentals and Programming. John Wiley and Sons, \n1996. [55] C. Stone and R. Harper. Decidable type equivalence with singleton kinds. In T. Reps, editor, \nProceedings of ACM Symposium on Principles of Programming Languages, Boston, MA, January 2000. ACM Press. \n[56] P. Wadler. Views: a way for pattern matching to cohabit with data abstraction. In 14 th ACM Symposium \non Principles of Programming Languages, Munich, Germany, January 1987.  \n\t\t\t", "proc_id": "507635", "abstract": "While dynamic linking has become an integral part of the run-time execution of modem programming languages, there is increasing recognition of the need for support for hot swapping of running modules, particularly in long-lived server applications. The interesting challenge for such a facility is to allow the new module to change the types exported by the original module, while preserving type safety. This paper describes a type-based approach to hot swapping running modules. The approach is based on a reflective mechanism for dynamically adding type sharing constraints to the type system, realized by programmer-defined version adapters in the run-time.", "authors": [{"name": "Dominic Duggan", "author_profile_id": "81100303097", "affiliation": "Stevens Institute of Technology, Hoboken, NJ", "person_id": "P67811", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/507635.507645", "year": "2001", "article_id": "507645", "conference": "ICFP", "title": "Type-based hot swapping of running modules (extended abstract)", "url": "http://dl.acm.org/citation.cfm?id=507645"}