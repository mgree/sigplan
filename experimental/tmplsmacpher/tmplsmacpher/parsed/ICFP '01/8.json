{"article_publication_date": "10-01-2001", "fulltext": "\n Generic Uni.cation via Two-Level Types and Parameterized Modules [Functional Pearl] Tim Sheard Paci.c \nSoftware Research Center Oregon Graduate Institute sheard@cse.ogi.edu ABSTRACT As a functional pearl, \nwe describe an e.cient, modularized implementation of uni.cation using the state of mutable ref\u00aderence \ncells to encode substitutions. We abstract our algo\u00adrithms along two dimensions, .rst abstracting awayfrom \nthe structure of the terms to be uni.ed, and second over the monad in which the mutable state is encapsulated. \nWe choose this example to illustrate two important tech\u00adniques that we believe manyfunctional programmers \nwould .nd useful. The .rst of these is the de.nition of recursive data types using two levels: a structure \nde.ning level, and a recursive knot-tying level. The second is the use of rank-2 polymorphism inside \nHaskell s record types to implement a form of type parameterized modules. Keywords Generic programs, \nuni.cation, parameterized modules 1. INTRODUCTION This pearl describes the modularization of a whole \nclass of algorithms that compare two instances of the same data structure. This class contains algorithms \nfor uni.cation, matching,and equality amongst others. E.cient implemen\u00adtations of manyof these algorithms \nrelyon mutable state. We show how to modularize these algorithms using Haskell. Our modularization is \nperformed along two dimensions, ab\u00adstracting over the monad in which the mutable state resides, and the \nstructure of the terms being compared. The pearl demonstrates two di.erent techniques of inter\u00adest to \nserious functional programmers: generic programming in standard Haskell (without using anyextensions), \nand type-parameterized modules (using higher-order kinds, and the rank-2 polymorphism extension). Generic \nprogramming is the construction of a single algorithm that works over mul\u00adtiple data structures. This \nallows the programmer to write an algorithm once and to reuse it at manydi.erent types. A Permission \nto make digital or hard copies of all or part of this work for personal or classroom use is granted without \nfee provided that copies are not made or distributed for pro.t or commercial advantage and that copies \nbear this notice and the full citation on the .rst page. To copy otherwise, to republish, to post on \nservers or to redistribute to lists, requires prior speci.c permission and/or a fee. ICFP 01, September \n3-5, 2001, Florence, Italy. Copyright 2001 ACM 1-58113-415-0/01/0009 ...$5.00. type-parameterized module \nis a collection of (possibly poly\u00admorphic) algorithms or functions parameterized bya set of types. This \nallows a single module to be reused, simply by instantiating it at di.erent types. The work reported \nhere has been in.uenced stronglyby two papers. Basic Polymorphic Type Checking[1]byLuca Cardelli, and \nUsing Parameterized Signatures to Express Modular Structure[10] byMark Jones. Luca Cardelli s paper describes \nhow to implement Hindley-Milner type inference for an ML-like language. The algo\u00adrithm uses destructive \nupdate to achieve an e.cient imple\u00admentation of uni.cation over terms representing types. This kind of \nuni.cation algorithm is extremelyversatile and use\u00adful. The author of this paper has based literallydozens \nof other implementations on it, unifying datatypes represent\u00ading manydi.erent kinds of terms. Mark Jones \npapers describes how to implement a mod\u00adule system by using parameterized signatures. The idea is to \nde.ne functor-like operators, as de.ned byML s mod\u00adule system[2], that use parameterization over types \nrather than sharing constraints to express sharing[3]. The recent addition of rank-2 polymorphism to \nthe Hugs Haskell inter\u00adpreter, and the GHC compiler, allows the encoding of mod\u00adules as .rst class objects. \nOur experience with this encoding provides strong evidence that type-parameterized modules reallywork. \n 2. UNIFICATION Uni.cation of xand y is usuallyde.ned as .nding a sub\u00adstitution s such that sx = sy. \nThe terms x and y may contain variables, and a substitution is a partial function from variables to terms \n(often represented as a list of pairs). An e.cient implementation of uni.cation relies on rep\u00adresenting \nvariables as pointers to terms. A substitution in this case is represented bythe global state of the \npointers. If a variable points to null, it is said to be unbound. If the pointer is not null, then the \nvariable is bound to the term it points to. This can be implemented in Haskell byusing the state monad \n(ST)[12]. In what follows we assume the reader has a rudimentaryknowledge of Haskell, uni.cation and \nthe ST monad. Some additional features of Haskell, perhaps un\u00adknown to some readers can be found in Figure \n2. In Figure 1 we give a basic transcription of Cardelli s uni\u00ad.cation algorithm into Haskell. The goal \nof this paper is to abstract details from this implementation, and to modu\u00adlarize it into several orthogonal \ncomponents. Grasping the details of this concrete instance of the algorithm, will make type Ptr a = STRef \na (Maybe (TypeExp a)) data TypeExp a = MutVar (Ptr a) | GenVar Int | OperType String [ TypeExp a ] prune \n:: TypeExp a -> ST a (TypeExp a) prune t = case t of MutVar r -> do{m<-readSTRef r ;casemof Nothing -> \nreturn t Just t2 -> do { t <-prune t2 ; writeSTRef r (Just t ) ; return t }} other -> return t occursInType \n:: Ptr a -> TypeExp a -> ST a Bool occursInType r t = do { t <-prune t ; case t of MutVar r2 -> return(r==r2) \nGenVar n -> return False OperType nm ts -> do { bs <-mapM (occursInType ; return(or bs) } } r) ts unifyType \n:: TypeExp a -> TypeExp a -> ST a () unifyType t1 t2 = do { t1 <-prune t1 ; t2 <-prune t2 ; case (t1 \n,t2 ) of (MutVar r1, MutVar r2) -> if r1==r2 then return () else writeSTRef r1 (Just t2 ) (MutVar r1, \n_) -> do{b<-occursInType r1 t2 ; if b then error \"occurs in\" else writeSTRef r1 (Just t2 ) } (_,MutVar \n_) -> unifyType t2 t1 (GenVar n,GenVar m) -> if n==m then return() else error \"different genvars\" (OperType \nn1 ts1,OperType n2 ts2) -> if n1==n2 then unifyArgs ts1 ts2 else error \"different constructors\" (_,_) \n-> error \"different types\" } where unifyArgs (x:xs) (y:ys) = do { unifyType x y; unifyArgs xs ys } unifyArgs \n[] [] = return () unifyArgs__= error \"different lengths\" instantiate :: [TypeExp a] -> TypeExp a -> \nTypeExp a instantiate ts x = case x of MutVar _ -> x OperType nm xs -> OperType nm (map (instantiate \nts) xs) GenVar n -> ts !! n Figure 1: Basic uni.cation modelled after the algorithm described in Luca \nCardelli s Basic Polymorphic Type Checking. The algorithm is transcribed from Modula-2 into Haskell. \nit easier to understand the abstract version we will produce. We enumerate the important parts of Figure \n1. In the ST monad, everyfunction that accesses a muta\u00adble variable (to either read, write, or create \na new one) has a range of type (STax). We saythat such func\u00adtions have a monadic type. Each computation \nthat ac\u00adcess a mutable variable takes place in some thread. It is instructive to think of the type variable \na in the type signatures of the state mutating functions as represent\u00ading this thread. Thus functions \nwhose signature con\u00adtains several parameters with the same type variable a, must manipulate these objects \nin the same thread.  A TypeExp is either a variable (MutVar), a generic type (GenVar, which is used \nfor template variables, see the last bullet of this enumeration), or a type constructor applied to a \nlist of types (OperType). For example Int is represented by (OperType \"Int\" []) and [x] by (OperType \n\"[]\"[x]).  A pointer to a (TypeExp a) is a reference cell in the ST monad that holds an object of type \nMaybe(TypeExp a). Nothing represents the null pointer, and Just x represents a pointer to x.  Objects \nof type (TypeExp a) often contain long chains of MutVar s pointing to other MutVar s. The function prune \nfollows such a chain, side-e.ecting each of the pointers in the chain to point to the element at the \nbottom of the chain. The value returned by prune is this last element. This is sometimes called path \ncompression, and is illustrated below. --Monads in general mapM :: Monad a => (b -> a c) -> [b] -> a \n[c] mapM_ :: Monad a => (b -> a c) -> [b] -> a () --References in the ST monad readSTRef :: STRefab->STab \nwriteSTRef :: STRef a b -> b -> ST a () newSTRef :: a -> ST b (STRef b a) --Haskell s Record Syntax \n--definition data R = R { one :: Int, two :: Bool } --field selection one(R {one = 5, two = False}) --> \n5 --partial construction R{one=5}-->R {one =5, two = undefined} --field updating x{one=4} --> R{one=4, \ntwo =twox} Figure 2: Types of Haskell library functions deal\u00ading with monads in general, references \nand the ST monad, and uses of Haskell record syntax. The function occursInType determines if a pointer \nap\u00adpears somewhere inside another TypeExp. Note that pointers maybe changed bythe call to prune. This \nis why occursInType has a monadic type, indicating that it might mutate state.  The function unifyType \n.rst calls prune on its two arguments to eliminate anychains of MutVar s. The resulting objects (t1 and \nt2 ) maystill be MutVar s, but if theyare, then theyare guaranteed to be null pointers (i.e. be references \nto Nothing). A simultane\u00adous case analysis of the two resulting objects succeeds if both have the same \ntop-level constructor, or if at least one is a variable.  If theyare both the same variable, then there \nis noth\u00ading to do. If two variables are matched, but are dif\u00adferent variables, make the .rst variable \npoint to the second. This is how chains of variables are created. If one is a variable, and the other \nis not, check if the vari\u00adable occurs in the other. If it does, this is an error. If not, then make the \nvariable point at the other object. If theyboth have the same top-level constructor then recursivelyanalyze \nthe substructures. This is the pur\u00adpose of the local function unifyArgs. The function instantiate behaves \nlike a substitution function, replacing every (GenVar n) with the n th ele\u00adment of the substitution list \nts. The function instantiate is the generic interface to templates. A template is a GT object containing \nno MutVars. Templates are used when one wants to unifyone GT term with manyother GT terms. Once a MutVar \nbecomes bound, it is di.cult to unbind it without jeopardizing the correctness of the uni.cation algorithm. \nIf it is necessaryto unifya sin\u00adgle term manytimes, then a template structure must be used. A template \nstructure contains template vari\u00adables (GenVar) in place of MutVar variables. Each time the template \nis to be used, it is instantiated bymak\u00ading a copyof the template, replacing each template\u00advariable with \nfresh type variables. The instantiate function provides this capability. The technique of us\u00ading Int \nto represent template variables, and a list of TypeExp as their instantiations derives from the paper \nTyping Haskell in Haskell[11]. Uni.cation using the state of updatable reference cells to encode substitutions \nis hard to get right. On reason is the algorithmic details of chasing and overwriting pointers. Pointer \nchasing is necessaryto ensure the invariant that a pointer, and and the thing it points to, are in some \nsense semanticallyequivalent. Everyfunction that manipulates TypeExps must maintain this invariant. One \nwayto accom\u00adplish this is to use a copying algorithm that removes these excess pointers as other computations \nare performed. Over\u00adwriting a minimal number of pointers ensures that the time behavior of the algorithm \nremains tractable, and adds to the complexity. Because overwriting is a stateful operation, everything \nmust be in some appropriate monad. As the datatype representing terms becomes more com\u00adplex, the control \nstructure of the algorithm becomes more sophisticated. Terms with complex sub-structure require sophisticated \ncontrol to make recursive calls on subterms properly, and to combine the results of the recursive calls \nto build a suitable overall result. It would be nice to separate the pointer issues from the control \nissues; get each one done right, and then combine them. The pointer chasing could be abstracted over \ndi.erent monads, and reused with multiple data structures represent\u00ading di.erent kinds of terms. The \ncontrol structure could be reused when de.ning additional algorithms over terms other than uni.cation. \nAfter all matching (where onlyone of the terms can have variables), and equality testing have control \nstructure remarkablysimilar to uni.cation. In the rest of this paper we explain how this can be done \nin Haskell. 3. MODULAR DATA Separating the pointer algorithms from the algorithms that deal with the \nstructure of terms, requires splitting the datatype TypeExp into several datatypes. This separates the \nstructure of terms and the use of variables into two di.er\u00adent datatypes. All kinds of terms which support \nuni.cation will have variables, but their structure will varyaccording to what the terms are meant to \nrepresent. We separate terms into two levels. The .rst level incorporates the two kinds of variables \nencoded in the constructors MutVar and GenVar. The second level incorporates the role played by the con\u00adstructor \nOperType. It abstracts the structure of all the other constructor functions of terms. The recursive structure \nof terms will be split between the two levels. We will make this more clear byapplying our technique \nto the same kinds of terms we used in Figure 1. We split the de.nition of TypeExp into the two components \nS (for the Structure of terms) and GT (for Generic Term). --Structure operator, hence \"S\" dataSx= OperType \nString [x] --Generic Terms, hence \"GT\" --\"s\" abstracts over structure, \"r\" over references data GT s \nr =S(s(GTsr)) | MutVar (r (Maybe (GT s r))) | GenVar Int type TypeExp a = GT S (STRef a) We call S the \nstructure operator because it captures the structure of the terms we are manipulating. Note how it is \nparameterized by x which appears in places where recursive calls to TypeExp were placed in the original \nde.nition. This is the .rst half of capturing the recursive structure of terms. The structure of TypeExp \nis quite simple, so S onlyhas one constructor (OperType), but we will soon see examples where the structure \nof terms is much richer. The GT datatype incorporates the role of variables in terms: template variables \n(GenVar), and normal variables (MutVar). It abstracts over the rest of the structure of terms using the \nparameter s. It is in the type of the S constructor function that GT captures the second half of the \nrecursive structure of TypeExp. Note how a recursive call (GT s r) is passed to the parameterized structure \noperator s. It is important to note that the parameter s to GT is a type constructor, not a type. The \nparameter r is also a type con\u00adstructor. It abstracts over the type constructor constructing mutable \nreferences. The type constructor GT is recursive in both the MutVar and S constructor functions, forwarding \nthe recursion through the type constructors s and r. The new version of TypeExp is an instantiation of \nGT, choosing for its two parameters the structure operator S, and the STRef type constructor for references \nfrom the ST monad. Values of type TypeExp are constructed in two levels. An outer level consisting of \none of the constructors of GT: S, MutVar,or GenVar; and in the case of the constructor func\u00adtion S an \ninner level consisting of the constructor function of the type constructor S:(OperType) (in general the \ntype constructor S mayhave manyconstructor functions). We illustrate this in the table below. New, two \nlevel examples Old, one level examples GenVar 4 GenVar 4 S(OperType \"Bool\" []) OperType \"Bool\" [] S(OperType \n\"[]\" OperType \"[]\" [S(OperType \"Int\" [])]) [OperType \"Int\" []] This pattern of pre.xing everyconstructor \nof S with S to construct a TypeExp is captured byemploying a convention that de.nes a new function for \neveryconstructor of S. These functions have the same name as the constructor, except their initial upper \ncase letter is made lower case. operType s ts = S(OperType s ts) The bene.t of employing this convention \nis that the pro\u00adgrammer need not continuallyemploythe type constructor S everytime a term is constructed. \n 3.1 Abstract Operations How are functions over objects of type (GT s r) written if s and r are unknown? \nOne wayto do this is to assume that s and r are instances of some special classes that enumerate their \ngeneral operations. For s we have found the following class useful. class Sclass s where mapS ::(x->y)->sx->sy \naccS ::(x->y-> y) -> sx->y-> y seqS :: Monad m => s(m x) -> m(s x) matchS ::sx->sx->Maybe[(x,x)]\\  One \nwayto understand these functions is to imagine ob\u00adjects of type (s x) as boxes labeled S, with compartments \nof type x. The operation mapS applies a function of type (x -> y) to each compartment, producing a box \nlabeled s with compartments of type y. S S map(+1) -----. 3 5 4 6 The operation accS accumulates a sum \nbyrepeat\u00adedlyapplying a binary addition function to each of the compartments and the previous subtotal \n. S .s. acc (+) s 0 ---------. 3+5+0 3 5 The operation seqS produces a single m-e.ecting com\u00adputation \nthat produces an object of type sx from a box labeled s where the compartments are each .lled bysmaller \nm-e.ecting computations, each of which pro\u00adduces an object of type x. It does this byordering all the \nsub-computations into one large computation. S do { print \"x\" do { print \"y\" ; return 0 } ; return 1 \n} do { print \"x\" seq; print \"y\" - . ; return S 0 1 } Finally, matchS compares the top level constructors \nof two s boxes. If the constructors match (then both boxes contain the same kind of compartments ) it \nreturns Just applied to a list of pairs, pairing corre\u00adsponding compartments from each box. If the con\u00adstructors \ndo not match then it returns Nothing. S . . a b . . . . . match----. Just [(a,c),(b,d)] S . . . . c d \n. .  When s is the S datatype from our TypeExp example, we can use the following instance. instance \nSclass S where mapS f (OperType s xs) = OperType s (map f xs) accS acc (OperType s xs) ans = foldr acc \nans xs seqS (OperType s xs) = do {xs <-order xs; return(OperType s xs )} where order [] = return [] order \n(x:xs) = do { x <-x ; xs <-order xs ; return (x :xs ) } matchS (OperType s xs) (OperType t ys) = if s==t \n&#38;&#38; (length xs)==(length ys) then Just(zip xs ys) else Nothing  3.2 Using the abstract operations \nIt is now possible to write the instantiate function with\u00adout knowing the structure of s at all. instantiate \n:: Sclass s => [GT s r] -> GT s r -> GT s r instantiate ts x = case x of S y -> S(mapS (instantiate ts) \ny) MutVar _ -> x GenVar n -> ts !! n In the .rst clause of the case expression, the variable y has type \n(S (TypeExp a)). The mapS function applies re\u00adcursive calls of instantiate to each of the compartments, \nobtaining another object of type (S (TypeExp a)) that is wrapped by S into the .nal answer with type \n(TypeExp a). It is possible to write manyfunctions over (GTsr) without actuallyknowing the exact structure \nof its s substructure. The type of instantiate, (Sclass s => [GT s r] -> GT sr->GTsr), makes precise \nthe requirement that not anystructure operator will do. Onlythose s that are a member of the class Sclass. \nTo write the functions occursInType and unifyType addi\u00adtional structure must be known about the type \nconstructor r. This can be captured using two additional classes, that abstract over the operations on \nreferences. class EqR r where sameVarR ::rx->rx-> Bool class Monad m => Rclass r m where writeVarR :: \nr x -> x -> m() readVarR :: rx-> mx newVarR :: x -> m(r x) The class EqR captures that references must \nbe compara\u00adble for equality. The class Rclass aggregates the operations that create, read, and write \nreferences into a single class with a common multiparameter constraint. Rclass is mul\u00adtiparameter, because \nit relates two type constructors, r the reference type constructor, and m the monad in which it op\u00aderates. \nThe function prune over GTsr objects can be de.ned in exactlythesamemannerasitwas over TypeExp objects. \nThe de.nition found in Figure 1 is identical to the new def\u00adinition, so we omit it here. This is possible \nbecause prune returns a default action on all non-MutVar objects, so the changes in the structure of \nterms is not noticed. Of course it has a di.erent type: prune :: (Rclass r m) => GT s r -> m (GT s r) \n With these classes in place the function occursInType can be written in a generic manner. occursInType \n:: (Rclass r m, Sclass s, EqR r) => r (Maybe (GT s r)) -> GTsr->mBool occursInTypert= do { t <-prune \nt ;caset of MutVar r2 -> return(sameVarR r r2) GenVar n -> return False Sx-> do { bs <-seqS(mapS (occursInType \nr) x) ; return(accS (||) bs False) } } To determine if reference r occurs in term t prune awayany leading \nchain of MutVar s. If the result of the prune is MutVar r2 then r occurs in t onlyif r and r2 are the \nsame reference. If the result is an S structure, x, then use the generic opera\u00adtors. First apply occursInType \nto all the compartments in x. The operation mapS performs this task. This produces an S structure .lled \nwith monadic computations, each of which returns a Bool. Applying the seqS operation to the S struc\u00adture \nproduces a larger computation returning an S structure .lled with booleans. This structure is bound to \nbs. All the Bools inside bs s compartments can then be logicallyor-ed together (using accS) to produce \nthe .nal result. The function unifyType can be made general in a similar manner. Replace each call to \nreference equalitywith one to sameVarR, readSTRef with readVarR, writeSTRef with writeVarR,and newSTRef \nwith newVarR. Finally, replace the case clause that compares two OperType constructors with some generic \ncode written in terms of the operations of the Sclass class. The important di.erence are summarized here: \nunifyType :: (Rclass r m, Sclass s, EqR r) => (GTsr,GTsr)->m() unifyType (t1,t2) = do { t1 <-prune t1 \n; t2 <-prune t2 ; case (t1 ,t2 ) of ... (S x,Sy)-> case matchSxyof Nothing -> error \"different constructors\" \nJust pairs -> mapM_ unifyType pairs ... } If we are unifying two S structures, determine if their top \nlevel constructors are the same using matchS.Iftheydon t match (Nothing is returned) then uni.cation \nfails. If they do match, then pairs is a list of corresponding subcompo\u00adnents. Recursively, unifyeach \npair and succeed onlyif all are successful. The function mapM :: Monadm=>(b-> mc)->[b] ->m() is part \nof the standard monad library and performs exactlythe task necessary. 3.3 Comments about modularity \nand classes The solution above makes heavyuse of classes. So heavy, in fact, that there are serious questions \nabout its scalabil\u00adity. The type of unifyType is cluttered with three class con\u00adstraints: (Rclass r m, \nSclass s, EqR r) => (GT s r, GT sr)->m(). And, this type doesn t explicitly mention the implicit constraint \nMonad m that is implied by Rclass r m. When a function s type is pre.xed bytoo manyclass con\u00adstraints \nit becomes hard for the programmer to grasp the full meaning of the type. Having manyclass constraints \nalso has implications for program maintainability. As a means of documentation, it is standard practice \nfor Haskell programmers to annotate functions with their types, even though their types could be inferred. \nSuch annotations become hard to maintain if the number of class constraints gets large. We have built \nricher implementations than the one de\u00adscribed here. These implementations introduce recoverable errors, \nadd a return type for unifyType other than (), and add a notion of generalization (a wayof creating templates \nfrom terms with unbound variables). Each of these exten\u00adsions adds an additional class or two. The types \nof our func\u00adtions become so constrained with these additional classes that theybecome unreadable. The \ntypes also become so general that type inference often fails to assign a unique type to each function, \nrequiring explicit typing annotations. What is needed is one big class-like thing that abstracts over \nall the types s, r and m, and all their operations at once. Something like: aBetterKindOfClass RSclass \nr m s where sameVarR ::rx->rx-> Bool writeVarR :: r x -> x -> m() readVarR ::rx->mx newVarR :: x -> m(r \nx) seqS :: s(m x) -> m(s x) mapS ::(x->y)->sx->sy accS ::(x->y-> y) -> sx-> y->y matchS :: s x -> s x \n-> Maybe[(x,x)] Unfortunately, in Haskell such a class is impossible to de.ne. The desire for type inference \nrequires that every method in everyclass mention all of the abstracted vari\u00adables; in this example, all \nof r, m, and s, which is just not the case. The recent suggestion[9] of using functional de\u00adpendencies \nto partiallyalleviate this restriction is still not strong enough for the example above. Doing without \nclass constraint inference, and requiring ex\u00adplicit type annotations at every overloaded function, could \nalleviate this problem. But class constraint inference is so useful in other contexts, that this is hardlya \ncredible solu\u00adtion. What is needed is something along the lines suggested byMark Jones in his paper Using \nParameterized Signatures to Express Modular Structure[10]. Fortunately, we need not wait for a new version \nof Haskell with such a module system built in. We can build this func\u00adtionalityourselves using an existing \nextension to Haskell: rank-2 polymorphism. Without rank-2 polymorphism, universal quanti.cation must \nbe completely outside all other types. For exam\u00adple in the type of (++) :: forall a . [a] -> [a] -> [a],the \nforall quanti.es the whole type. With rank-2 polymorphism we can place the quanti.er inside other type \nconstructors. For example: runST :: forall a . (forall b. ST b a) -> a. Here the outermost quanti\u00ad.er \n(forall a), quanti.es the whole expression, but the (forall b) quanti.es onlythe back end of the arrow \ntype. Rank-2 polymorphism admits functions, like runST, that re\u00adquire (and make use of) polymorphic parameters. \nOf course the type of such functions must be explicitlydeclared bythe programmer[13], as theycannot be \ninferred. These type dec\u00adlarations are necessary since type inference of rank-2 poly\u00admorphic types is \nin general undecidable. This extension also applies to constructor functions inside of data declarations. \nTheycan be given polymorphic com\u00adponents. Using this technique we can express the structure we require. \ndata RSclasssrm= RSclass { sameVarRS :: forall x.rx->rx-> Bool , writeVarRS :: forall x.rx->x->m() , \nreadVarRS :: forall x.rx->mx , newVarRS :: forall x. x -> m(r x) , seqRS :: forall x. s(m x) -> m(s x) \n, mapRS :: forall x y. (x -> y) -> s x -> s y , accRS::forall x y. (x -> y -> y) -> s x -> y -> y , matchRS \n:: forall x. s x ->sx->Maybe[(x,x)] , errorRS :: forallx.String -> m x } The RSclass datatype de.nition \nplays the role of a type\u00adparameterized signature. It speci.es an aggregation of (pos\u00adsiblypolymorphic) \nfunctions parameterized bya set of types. An object of type RSclass plays the role of a module. Ev\u00aderysuch \nobject will specialize the type parameters to some concrete types. A function from RSclass to some other \ntype\u00adparameterized signature plays the role of an ML-style func\u00adtor. In RSclass we have added an errorRS \n.eld to the oper\u00adations we have previouslydiscussed. In Figure 1 the use of Haskell s error function \nmakes aborting the program the onlypossible response to errors. The errorRS .eld allows the possibilitythat \ngeneric operations, such as unifyType can handle errors in some more graceful manner. Under this scheme, \nan instance declaration corresponds to a value of type RSclass, instantiated at real types for s, r, \nand m. rs :: RSclass S (STRef a) (ST a) rs = RSclass { sameVarRS = (==) :: STRefab->STRef ab->Bool , \nwriteVarRS = writeSTRef , readVarRS = readSTRef , newVarRS = newSTRef , seqRS = seqS , mapRS = mapS , \naccRS = accS , matchRS = matchS , errorRS = error } Here the STRef functions are the libraryfunctions \nwhose types were given in Figure 2, and seqS, mapS, accS,and matchS are de.ned exactlyas theywere in \nthe Sclass in\u00adstance for S in Section 3.1. We have instantiated errorRS as error but other instances \ncould use a di.erent error function. The collection of functions we wish to generate in a generic manner \ncan also be aggregated into a data structure. data GTstruct s r m = B { unifyGT :: GT s r -> GT s r -> \nm () , occursGT :: Ptr s r -> GT s r -> m Bool , instanGT :: [GT s r] -> GTsr-> m(GT s r) , pruneGT :: \nGT s r -> m(GT s r) } Here the record .elds of the GTstruct are populated with generic versions of the \nfunctions UnifyType, OccursInType, instantiate, and prune. The aggregate GTstruct structure can be generated \nbya function with type Monad m => RSclasssrm-> GTstruct srm. This function can be written once, and applied \nto di.erent RSclass objects to generate uni.cation structures for manydi.erent term types. It can also \nbe instantiated on di.erent monads. We call such a function makeUnify, and a skeleton for it is given \nbelow: makeUnify :: Monad m => RSclass s r m -> GTstruct s r m makeUnify lib = B { freshGT = freshVar \n... } where freshVar = do { r <-newVarRS lib Nothing ; return (MutVar r) } ... Note the explicit parameter \nlib of type RSclass to makeUnify, and the explicit application of the .eld selector newVarRS to lib. \nUsing the class system, rather than encoding our own type parameterized modules, allows this parameterization \nand selection to be implicit, but allows onlya single instance at each type, and admits all the disadvantages \nenumerated in Section 3.3. In Appendix A we have included the the complete code for makeUnify. In the \nappendix we have also enriched the GTstruct to include operations for matching, equality, and several \nother generic operations as well.  4. A RICHER MONAD In this section we illustrate how a di.erent monad \ncan be used to instantiate the RSclass structure. A obvious choice mightbetouse the IO monad, since it \ntoo supports references. Instead we show how to extend the monad in a di.erent direction. Manyprograms \nmust recover from failed uni.cation. We can accommodate this in several ways. One way, that we do not \nillustrate here, is to design generic uni.cation algorithms with type: term -> term -> M ans, where ans \nis some type other than (). Thus uni.cation can return an interesting result, that indicates what happened. \nTypes like Bool , [ Failure ],or Maybe ErrorMessage spring to mind. We have done this, and it requires \nadding an answer type to the type parameters of RSclass and adding several new opera\u00adtions to the class, \nas well as making slight modi.cations to makeUnify. A more interesting wayto accommodate this is to de\u00adsign \na richer monad that models failure, and to instantiate makeUnify with an instance that uses this richer \nmonad in\u00adstead of the ST a monad. data Error=EString newtype EMax=EM(STa (Either Error x)) instance Monad \n(EM a) where return x = EM(return(Right x)) (>>=) (EM z) g = EM(do{c<-z ;casecof Left e -> return(Left \ne) Right x -> let EM w = g x in w }) runEM :: (forall b. EM b a) -> Either Error a runEMx=let EMz=xinrunST \nz The (EM a) monad is a simple extension to the (ST a) monad. The possibilityof failure is accommodated \nbyre\u00adturning Either an error (Left x) or a normal answer (Right x). The bind (>>=) operator of the monad \npropagates failure in its .rst argument without evaluating its second argument. We lift the runST operation \nto the EM monad with the func\u00adtion runEM.Weuse the newtype declaration, rather than the data declaration, \nwhen de.ning EM to avoid the extra level of indirection that an actual constructor function EM would \nintroduce. When using a newtype the constructor function is virtual and is onlyused to supplytype inference \nanno\u00adtations. We add two new operations to the (EM a) monad, raise, and handle. The operation raise introduces \nan error, and handle catches an error, and then begins a new computa\u00adtion. raise :: String -> EM a x \nraise s = EM(return(Left (E s))) handle :: (EM a x) -> (EM a x) -> (EM a x) handle (EM x) (EM y) = EM \n(do{x <-x ; case x of Left_->y Right x -> return(Right x) }) 4.1 Using the richer monad The RSclass \naggregates nine separate operations. We can de.ne a partiallyde.ned RSclass object, where onlythe 5 reference \nand monad operations have been .lled in. The laziness of Haskell makes this possible. Later in the program \nsource we can construct manyother instances of RSclass objects, that .ll in the holes with the missing \noperations. readVar r = EM(do{a<-readSTRef r; return(Right a) }) writeVarrx= EM(do{a<-writeSTRef r x; \nreturn(Right ()) }) newVar x = EM(do{r<-newSTRef x; return(Right r) }) emPartial :: RSclass s (STRef \na) (EM a) emPartial = RSclass { sameVarRS = (==)::STRefab->STRef ab-> Bool , writeVarRS = writeVar , \nreadVarRS = readVar , newVarRS = newVar , errorRS = raise } Note that emPartial is still polymorphic \nin its s parame\u00adter. We can use the .eld updating syntax of Haskell to make more complete copies of emPartial \nat manydi.erent instan\u00adtiations of s. We do this in the de.nition of commandClass in Section 5 below. \n  5. A RICHER TERM-STRUCTURE. In this section we illustrate instantiating our general frame\u00adwork on \na type for representing terms. We consider a type of terms representing commands in a simple imperative \nlan\u00adguage. We build the S structure operators for this type, in\u00adstantiate our general framework with \nthe (EM a) monad of the previous section and illustrate the use of the framework to build a simple transformation \nsystem over commands. data C x = If Exp x x -\u00ad if e then s2 else s1 | While Exp x -\u00ad while e do s | Begin \nx x -\u00ad { s1 ; s2 } | Skip -\u00ad {} | Assign Var Exp -\u00ad x := e --the lowercase constructor convention ifc \ne x y = S(If e x y) while e x = S(While e x) begin x y = S(Begin x y) skip = S Skip assignve= S(Assign \nv e) type Commanda=GTC(STRefa) In Appendix B we give the de.nitions of the S structure op\u00aderators seqC, \nmapC, accC,and matchC. These are easyto de.ne, and in fact, could be generated automaticallygiven the \nright tools[4, 5]. To build an RSclass instance using the (EM a) monad reference operators, we simplyuse \nthe record update syntax on the partially de.ned RSclass value emPartial de.ned in the previous section. \ncommandClass :: RSclass C (STRef a) (EM a) commandClass = emPartial { seqRS = seqS , mapRS = mapS , accRS \n= accS , matchRS = matchS } Our transformation system will implement simple rewrites over terms. For \nexample, rewrites like (if True then x else y) -. x. To build the machineryneeded, generic ver\u00adsions \nof matching, instantiation, and the creation of fresh variables will be needed. At this point we can \nconjure up working examples of these and several other generic opera\u00adtors, simplybyusing the generic \nmakeUnify function from Appendix A. B{ matchGT = match , instanGT = instan , freshGT = fresh , tofixGT \n= toFix , fromfixGT = fromFix } = makeUnify commandClass Two things to note here. First, when using a \nrecord pat\u00adtern on the left-hand-side of a binding, it is the variables to the right of the equals (=) \nthat are being de.ned. In this example, those variables being bound are match, instan, fresh, etc. Second, \nseveral of the .eld names in this exam\u00adple are derived from the de.nition in Appendix A, rather than \nthe one in the running text. A transformation system is de.ned by rewrite rules, and an engine that \napplies those rules. A simple system for the command language can be built succinctlyusing our framework. \nFirst, de.ne the structure of rules: data Rulea=RInt (Command a) (Command a) Aruleisan Int and a pair \nof (Command a) objects. The Int represents the number of template variables in the rule, and the pair \nof (Command a) objects represent the left-and right-hand sides of the rewrite rule it encodes. We use \nthis representation to simplifythe implementation. The (Command a) objects have template variables where \nthe rule maymatch anysub-command. We give some example rules below. (w,x,y,z) =(GenVar 0,GenVar 1,GenVar \n2,GenVar 3) r1,r2,r3,r4 :: Rule a r1=R3(beginw (begin x y)) (begin (begin w x) y) r2=R2(ifc Truewx)w \nr3=R2(ifc False w x) x r4=R1(while False x) skip To applya rule we instantiate the template variables \nwith real variables, applythe matching procedure to the left-hand side of the rule and the term being \ntransformed. If the match succeeds, then the instantiated right-hand side contains the result of the \nmatch. rewrite (R n lhs rhs) x = handle (do { freshvs <\u00ad sequence(take n (repeat fresh)) ; lhs <-instan \nfreshvs lhs ; match lhs x ; instan freshvs rhs }) (return x) If the matching fails, then the whole (do \n... ) fails. The failure is captured by handle, and the original term is returned unchanged. 6. ESCAPING \nTHE MONAD Monads (M) with mutable references have the unfortunate problem that there is no simple wayto \ntransform a compu\u00adtation of type (M x) into a value of type x. This restriction is imposed because it \nensures that no reference escapes its scope. It .rst appears, that because generic types (GTsr)have references \ninside them, that once inside the monad there is no hope of ever escaping the monad to produce pure values. \nIf the monad is built on top of the IO monad this will always be the case, but if the monad is built \non top of the ST monad (like the EM monad) this need not be the case. Computations with type (STax) that \nare completely polymorphic in the thread type variable a can be converted into values of type x using \nthe function runST. Fortunatelymanyterms are completelypolymorphic in the state thread variable a. All \ntop-level program constants with type (GT C (STRef a)), and larger constants derived from them, are always \npolymorphic in the state thread, a. Witness the type of r1:: Rulea. An important role of the GenVar constructor, \nand the instanGT generic function is to allow the construction of templates. Templates, because theycontain \nno MutVar con\u00adstructors, are always completely polymorphic. Templates can be used to create non-polymorphic \ninstances (with MutVar constructors) bythe use of the pattern illustrated in the function rewrite in \nthe previous section. Create a list of fresh type variables and instantiate the template using the function \ninstan. Polymorphic terms can also be constructed algorithmi\u00adcally, by a parser for example, if the algorithms \nnever use the MutVar constructor. A term completelypolymorphic in its thread variable can be extracted \nfrom the monad using runST in the ST monad or its equivalent (such as runEM)in other monads. In order \nto do this we need a form of terms that does not mention the thread variable. If we know a generic term \nhas no MutVar or GenVar con\u00adstructors we can turn it into a type with similar structure. The Fix type \nconstructor, like the GT type constructor, takes a type constructor as argument, but has a single constructor \nfunction, Fix. It plays the same role as the S constructor function. newtype Fix s = Fix (s (Fix s)) \nConversion between the two types can be made generic as well. In Appendix A, generic functions have been \nadded to the GTstruct aggregate structure. tofixGT :: GTsr-> m(Fix s) fromfixGT :: Fix s -> GT s r We \ncan now illustrate a complete program. try1 :: (forall a . GT C (STRef a)) -> Either Error (Fix C) try1 \nx = runEM(do { x1 <-rewrite r1 x; toFix x1}) transform :: Fix C -> IO() transform x = let x = fromFix \nx in case try1 x of Left (E s) -> print $ \"Fail: \" ++s Right y -> print(show x++\" =\\n\"++show y++\"\\n\") \n 7. DISCUSSION We have shown how to abstract the class of algorithms that includes uni.cation, matching \nand equality, over both the structure of terms, and over the monad in which the computations occur. We \nused two techniques that we believe are generallyuseful and should be in the repertoire of every functional \nprogrammer. The .rst is the use of two-level algebraic data-types, and utilization of generic operators \nsuch as map, seq, acc, and match. This allows the construction of generic algorithms in Haskell without \nthe use of anylanguage extensions. It also allows a brevityof expression in non-generic algorithms. We \nhave not demonstrated such use in this paper for lack of space. The second is the use of rank-2 polymorphism \nto encode user-de.ned parameterized modules. Such modules allow a level of abstraction not possible using \nHaskell s class system since theyallow arbitrary overlapping instances. Such .exibilitycomes at the cost \nof a few explicit type annota\u00adtions. Our exploration of this new paradigm has not been with\u00adout its setbacks. \nUsing advanced features often pushes the limits of a paradigm or a language implementation. Three issues \nare worth discussion. Mutual recursion. To generalize two level datatypes to mutuallyrecursive structures \none needs to parameter\u00adize each structure operator over all of the recursive compo\u00adnents, both direct \nand indirect. We can illustrate this using a simple language for Haskell-like expressions and declara\u00adtions. \nBelow E is the structure operator for expressions, and D is the structure operator for declarations. \nBoth E and D have parameters e and d which are used where recur\u00adsive sub-components of type expression \nor declaration would normallybe used. type N = String --names dataEde =VarN --x | Const Integer --5 |Appee \n--fx |Abs [N] e --\\x1x2->e | Let [d] e --let x=e1 in e2 dataDde = Fun N [([N],e,[d])] --f p1 p2=bwhereds \n|ValNe[d] --p=ewhere ds newtype Exp=E(E Decl Exp) newtype Decl=D(DDecl Exp) Since the structure operators \n(E and D) have more than one parameter, the generic operators map and seq must be gen\u00aderalized as well. \nFor example: mapD :: (a->b) -> (c->d) ->Dac->Dbd seqD :: Monad m => D (m a) (m b) -> m(D a b) Two level \ntypes are not restricted to lazy languages like Haskell. We have used them in ML as well. In fact we \nhave found them to scale quite well to even verylarge, highly mutually-recursive datatype declarations. \nWe use two level types to represent all the datatypes in the MetaML1 imple\u00admentation. We found them both \neasyto use, and advanta\u00adgeous in the genericitytheysupplied. The following two problems were encountered \nusing the Hugs interpreter in our initial research. Each has simple work-arounds. Further investigation \nas shown that neither occurs when using GHC. Pattern matching polymorphic records. Using data types with \npolymorphic components as the input to func\u00adtors (like makeUnify) worked well, but when we tried using \npattern matching to bind the results of functor application, we stretched the limits of the Hugs implementation. \nFor example consider the functor-like function makeSeqmap that takes a (RSclasssrm) as input and produces \na (T1 s m) object as output: 1See http://www.cse.ogi.edu/PacSoft/projects/metaml/index.html data T1 s \nm = T1 {seqmapGT :: forallxy. (x->m y) -> (s x) -> m(s y) } makeSeqmap :: RSclasssrm-> T1 sm makeSeqmap \nlib = T1 { seqmapGT = seqmap } where seqmapfx= seqRS lib(mapRS lib f x) Everything works .ne until we \ntry and use the pattern matching feature of records to produce an actual instance of a (T1 s m) object \nwith a component called seqmap.This top-level de.nition is not allowed: T1 { seqmapGT = seqmap } = makeSeqmap \nrs because of restrictions on the use of rank-2 polymorphism in pattern matching in Hugs. A work around \nfor this is not to use pattern matching, but use the .eld selection mechanism instead. lib = makeSeqmap \nrs seqmap = seqmapGT lib Update syntax of polymorphic records. In Section 5 we specialized the emPartial \nstructure byupdating its (un\u00adde.ned) .elds for seqRS, mapRS, accRS,and matchRS. Un\u00adfortunately, in the \nHugs interpreter, the record update syn\u00adtax is not implemented for records that contain explicitly\u00adtyped \npolymorphic components. Fortunately there is a work around for this as well. We can replace the elegant: \ncommandClass :: RSclass C (STRef a) (EM a) commandClass = emPartial { seqRS = seqS , mapRS = mapS , accRS \n= accS , matchRS = matchS } with the equivalent, but much less elegant: addSpart (RSclass sv wv rv nv \ne s m a mtch) = (RSclass sv wv rv nv e seqC mapC accC matchC) commandClass :: RSclass C (STRef a) (EM \na) commandClass = addSpart emPartial  8. CONCLUSION Despite these minor complications, the techniques \ndis\u00adcussed here show great promise in writing high-level, generic, reusable programs in Haskell (with \nminor extensions). The two techniques demonstrated here: two level syntax with generic operators, and \ntype-parameterized data types with rank-2 polymorphic components, are both useful and com\u00adplementaryideas \nthat everyfunctional programmer should be aware of. The second idea could be made easier to use byincorpo\u00adrating \nit into a high-level module system based upon pa\u00adrameterized signatures as suggested byMark Jones. Such \na system should include the facility to de.ne parameter\u00adized modules. Theywould serve the same purpose \nas the makeUnify function of this paper. A good design for param\u00adeterized modules would allow the names \nof components in the input module to be used directly, rather than relying on the selector function mechanism \nas was done in the de.ni\u00adtion of makeUnify in Appendix A. A well designed module system would also alleviate \nthe last two problems discussed in the previous section. 9. HISTORY The author was introduced to the \nuse of two-level types byErik Meijer in the fall of 1996, in a talk in which he used them to de.ne catamorphisms, \nand other uniform control structures in Haskell. data Fix f = Fix (f (Fix f)) fmap :: Functor f => (a->b) \n-> f a -> f b cata :: Functor f => (f a -> a) -> Fix f -> a cata phi (Fix x) = phi (fmap (cata phi) x) \nThis started a long period of experimentation with these ideas as a mechanism to write programs that \ndid not de\u00adpend upon the structure of the datatype they operated on. Ultimately, the use of uniform control \nstructures, like cata, turned out to be too in.exible, but the generic operators, like fmap above, and \nacc, match, and seq turned out to be just the right stu.. Most of these generic operators originate in \nthe work of Jo\u00adhan Jeuring and his colleagues on polytypic programming[6, 8]. The one exception is seq \n:: Monad m => s(m a) -> m(s a), which the author likes to believe he independently discovered (though \nit s probablybeen around for years). Generic uni.cation is one of the prime examples[7] of poly\u00adtypic \nprogramming, but the e.cient algorithm employing mutable references has not been described. The type \nparameterized modules idea originated from a discussion with Mark Jones about examples illustrating mul\u00adtiparameter \ntype classes. Mark suggested abstracting the operations on stateful references awayfrom the actual ref\u00aderence \ntype constructor and monad type constructor. class Monad m => Mutablermwhere read ::rx->mx write ::rx->x->m() \nnew ::x-> m(rx) Frustration trying to retro.t some existing examples into this framework led to the \ntechniques presented. 10. ACKNOWLEDGMENTS The work described here was supported byNSF Grant CDA-9703218, \nthe M.J. Murdock Charitable Trust and the Department of Defense. The author would also like to thank \nAndyGill, Andy Moran, Mark Jones, Emir Pasalic, and Simon Peyton Jones for discussions about these ideas, \nFrank Taylor for LaTex wizardry, and the entire Advanced Functional Programming class, at the Oregon \nGraduate Institute, in the winter of 2001, who su.ered through endless versions of the imple\u00admentation. \n11. REFERENCES [1] L. Cardelli. Basic polymorphic typechecking. Science of Computer Programming, 8(2):147 \n172, Apr. 1987. [2] R. Harper and M. Lillibridge. A type-theoretic approach to higher-order modules \nwith sharing. In ACM, editor, Conference record of POPL 94, 21st ACM SIGPLAN-SIGACT Symposium on Principles \nof Programming Languages: papers presented at the Symposium: Portland, Oregon, January 17 21, 1994, \npages 123 137, New York, NY, USA, 1994. ACM Press. [3] R. Harper and B. C. Pierce. Advanced module systems \n(invited talk): a guide for the perplexed. ACM SIGPLAN Notices, 35(9):130 130, Sept. 2000. [4] R. Hinze. \nMemo functions, polytypically! In J. Jeuring, editor, Proceedings 2nd Workshop on Generic Programming, \nWGP 2000, Ponte de Lima, Portugal, 6 July 2000, Tech. Report UU-CS-2000-19, Dept. of Computer Science, \nUtrecht Univ., pages 17 32. June 2000. [5] R. Hinze. A new approach to generic functional programming. \nIn Proceedings of the 27th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (POLP-00), \npages 119 132, N.Y., Jan. 19 21 2000. ACM Press. [6] P. Jansson and J. Jeuring. PolyP a polytypic programming \nlanguage extension. In ACM, editor, Conference record of POPL 97, the 24th ACM SIGPLAN-SIGACT Symposium \non Principles of Programming Languages: papers presented at the symposium, Paris, France, 15 17 January \n1997, pages 470 482, New York, NY, USA, 1997. ACM Press. [7] P. Jansson and J. Jeuring. Functional pearl: \nPolytypic uni.cation. Journal of Functional Programming, 8(5):527 536, Sept. 1998. [8] J. Jeuring and \nP. Jansson. Polytypic programming. In J. Launchbury, E. Meijer, and T. Sheard, editors, Tutorial Text \n2nd Int. School on Advanced Functional Programming, Olympia, WA, USA, 26 30 Aug 1996, volume 1129 of \nLecture Notes in Computer Science, pages 68 114. Springer-Verlag, Berlin, 1996. [9] M. Jones. Type classes \nand functional dependencies. In Proceedings of the 9th European Symposium on Programming, ESOP 2000, \nvolume LNCS 1782. Springer-Verlag, March 2000. [10] M. P. Jones. Using parameterized signatures to express \nmodular structure. In 23rd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (POPL \n96), pages 68 78, St. Petersburg Beach, Florida, 21 24 Jan. 1996. [11] M. P. Jones. Typing haskell in \nhaskell. In Proceedings of the 1999 Haskell Workshop, pages 68 78, Paris, France, 21 24 Oct. 1999. Published \nin Technical Report UU-CS-1999-28, Department of Computer Science, Universityof Utrecht. [12] J. Launchburyand \nS. Peyton-Jones. Lazyfunctional state threads. In PLDI 94: Programming Language Design and Implementation, \nOrlando, Florida, pages 24 35, New York, June 1994. ACM Press. [13] M. Oderskyand K. L\u00a8aufer. Putting \ntype annotations to work. In ACM, editor, Conference record of POPL 96, 23rd ACM SIGPLAN-SIGACT Symposium \non Principles of Programming Languages: papers presented at the Symposium: St. Petersburg Beach, Florida, \n21 24 January 1996, pages 54 67, New York, NY, USA, 1996. ACM Press. APPENDIX  A. MAKEUNIFY data GTstructsrm= \nB { unifyGT :: GTsr->GTsr->m() , matchGT :: GTsr->GTsr->m() , equalGT :: GTsr->GTsr->Bool , freshGT :: \nm (GT s r) , occursGT :: Ptrsr->GTsr->mBool , colGT :: GTsr->m(GTsr) , pruneGT :: GTsr-> m(GT s r) , \ninstanGT :: [GT s r] -> GTsr->m(GTsr) , tofixGT :: GTsr-> m(Fix s) , fromfixGT :: Fix s -> GT s r } \n makeUnify :: Monad m => RSclass s r m -> GTstructsrm makeUnify lib = B { unifyGT = unify , matchGT = \nmatch , equalGT = equal , freshGT = freshVar , occursGT = occursIn , colGT = col , pruneGT = prune , \ninstanGT = inst , tofixGT = toFix , fromfixGT = fromFix } where --first some common patterns seqmapfx= \nseqRS lib(mapRS lib f x) writerx= writeVarRS lib r x freshVar = do{r<-newVarRS lib Nothing ; return \n(MutVar r) } prune (typ @ (MutVar ref)) = do{m<-readVarRS lib ref ;casemof Just t -> do { newt <-prune \nt ; write ref (Just newt) ; return newt } Nothing -> return typ} prune x = return x colx= do { x <-prune \nx ; case x of (S y) -> do{t<-(seqmap col y) ; return (S t)} (MutVar r) -> return(MutVar r) (GenVar n) \n-> return(GenVar n)} occursInvt= do { t2 <-prune t ; case t2 of Sw-> do{s<-(seqmap (occursIn v) w) ; \nreturn(accRS lib (||) s False) } MutVar z -> return(sameVarRS lib v z) GenVar n -> return False } varBind \nr1 t2 = do{b<-occursIn r1 t2 ;ifb then errorRS lib \"OccursErr\" else write r1 (Just t2) } unify tA tB \n= do { t1 <-prune tA ; t2 <-prune tB ; case (t1,t2) of (MutVar r1,MutVar r2) -> if sameVarRS lib r1 \nr2 then return () else write r1 (Just t2) (MutVar r1,_) -> varBind r1 t2 (_,MutVar r2) -> varBind r2 \nt1 (GenVar n,GenVar m) -> if n==m then return () else errorRS lib \"Gen error\" (S x,S y) -> case matchRS \nlib x y of Nothing -> errorRS lib \"ShapeErr\" Just pairs -> mapM_ (uncurry unify) pairs (_,_) -> errorRS \nlib \"ShapeErr\" } match tA tB = do { t1 <-prune tA ; t2 <-prune tB ; case (t1,t2) of (MutVar r1,_) -> \nwrite r1 (Just t2) (GenVar n,GenVar m) -> if n==m then return () else errorRS lib \"Gen error\" (S x,S \ny) -> case matchRS libxyof Nothing -> errorRS lib \"ShapeErr\" Just pairs -> mapM_ (uncurry match) pairs \n(_,_) -> errorRS lib \"ShapeErr\" } equalxy= case (x,y) of (MutVar r1,MutVar r2) -> sameVarRS lib r1 r2 \n(GenVar n,GenVar m) -> m==n (S x,S y) -> case matchRS lib x y of Nothing -> False Just pairs -> all \n(uncurry equal) pairs (_,_) -> False inst sub x = do { x <-prune x ; case x of MutVar r -> return(MutVar \nr) GenVar n -> col (sub !! n) Sx-> do { x <-(seqmap (inst sub) x) ; return (S x ) }} fromFix (Fix x) \n= S(mapRS lib fromFix x) toFix x = do { x <-prune x ; case x of MutVar r -> errorRS lib \"No vars\" GenVar \nm -> errorRS lib \"No generic vars\" S y -> do { y <-seqmap toFix y ; return(Fix y ) }}  B. COMMAND LANGUAGE \nEXAMPLE type Var = String type Exp = Bool data C x = If Exp x x -\u00ad if e then s2 else s1 | While Exp x \n-\u00ad while e do s | Begin x x -\u00ad { s1 ; s2 } | Skip -\u00ad {} | Assign Var Exp -\u00ad x := e --the lowercase constructor \nconvention ifcexy=S(Ifexy) whileex= S(While e x) beginxy= S(Begin x y) skip = S Skip assignve= S(Assign \nv e) type Commanda=GTC (STRef a) ----The S structure operators mapCf(Ifexy)=Ife(fx)(fy) mapC f (While \ne x) = While e (f x) mapCf(Beginxy) = Begin(fx)(fy) mapC f Skip = Skip mapC f (Assign v e) = Assign v \ne accC acc (Ifexy)ans=acc x(accy ans) accC acc (While e x) ans = acc x ans accC acc ( Begin x y) ans \n= acc x (acc y ans) accC acc Skip ans = ans accC acc (Assign v e) ans = ans seqC (Ifexy)= do { x <-x; \ny <-y; return (If e x y )} seqC (While e x) = do { x <-x; return(While e x )} seqC ( Begin x y) = do \n{ x <-x; y <-y; return( Begin x y ) } seqC Skip = return Skip seqC (Assign v e) = return(Assign v e) \nmatchC (Ifewx)(Iffyz)= if f==e then Just[(w,y),(x,z)] else Nothing matchC (While e w) (While f y) = if \nf==e then Just[(w,y)] else Nothing matchC (Begin w x) (Begin y z) = Just[(w,y),(x,z)] matchC Skip Skip \n= Just[] matchC (Assign v e) (Assign u f) = if v==u &#38;&#38; e==f then Just [] else Nothing matchC__= \nNothing  \n\t\t\t", "proc_id": "507635", "abstract": "As a functional pearl, we describe an efficient, modularizedimplementation of unification using the state of mutable referencecells to encode substitutions. We abstract our algorithms along twodimensions, first abstracting away from the structure of the termsto be unified, and second over the monad in which the mutable stateis encapsulated. We choose this example to illustrate two importanttechniques that we believe many functional programmers would finduseful. The first of these is the definition of recursive datatypes using two levels: a structure defining level, and a recursiveknot-tying level. The second is the use of rank-2 polymorphisminside Haskell's record types to implement a form of typeparameterized modules.", "authors": [{"name": "Tim Sheard", "author_profile_id": "81331504269", "affiliation": "Oregon Graduate Institute", "person_id": "PP43124236", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/507635.507648", "year": "2001", "article_id": "507648", "conference": "ICFP", "title": "Generic unification via two-level types and parameterized modules", "url": "http://dl.acm.org/citation.cfm?id=507648"}