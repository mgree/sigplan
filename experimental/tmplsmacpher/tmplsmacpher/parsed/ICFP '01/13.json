{"article_publication_date": "10-01-2001", "fulltext": "\n Real-Time FRP* Zhanyong Wan Walid Taha Paul Hudak Yale University Department of Computer Science New \nHaven, CT 06520, USA {wan-zhanyong,taha-walid,hudak-paul}@cs.yale.edu ABSTRACT Functional reactive programming \n(FRP) is a declarative pro\u00adgramming paradigm where the basic notions are continuous, time-varying behaviors \nand discrete, event-based reactivity. FRP has been used successfully in many reactive program\u00adming domains \nsuch as animation, robotics, and graphical user interfaces. The success of FRP in these domains en\u00adcourages \nus to consider its use in real-time applications, where it is crucial that the cost of running a program \nbe bounded and known before run-time. But previous work on the semantics and implementation of FRP was \nnot explicitly concerned about the issues of cost. In fact, the resource con\u00adsumption of FRP programs \nin the current implementation is often hard to predict. As a .rst step towards addressing these concerns, \nthis pa\u00adper presents Real-Time FRP (RT-FRP), a statically-typed language where the time and space cost \nof each execution step for a given program is statically bounded. To take advantage of existing work \non languages with bounded re\u00adsources, we split RT-FRP into two parts: a reactive part that captures the \nessential ingredients of FRP programs, and a base language part that can be instantiated to any generic \nprogramming language that has been shown to be terminating and resource-bounded. This allows us to fo\u00adcus \non the issues speci.c to RT-FRP, namely, two forms of recursion. After presenting the operational explanation \nof what can go wrong due to the presence of recursion, we show how the typed version of the language \nis terminating and resource-bounded. Most of our FRP programs are expressible directly in RT-FRP. The \nrest are expressible via a simple mechanism that integrates RT-FRP with the base language. * Funded 9900957. \nFunded by DARPA F33615-99-C-3013 and also by subcontract #8911-48186 NSF from CCR-Johns Hopkins University \nunder NSF agreement Grant # EIA\u00ad9996430. Permission to make digital or hard copies of all or part of \nthis work for personal or classroom use is granted without fee provided that copies are not made or distributed \nfor pro\u00a3t or commercial advantage and that copies bear this notice and the full citation on the \u00a3rst \npage. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior \nspeci\u00a3c permission and/or a fee. ICFP 01, September 3-5, 2001, Florence, Italy. Copyright 2001 ACM 1-58113-415-0/01/0009 \n...$5.00. 1. INTRODUCTION Many real-world software systems are required to respond to external stimuli \nin a bounded amount of time. In addi\u00adtion, some need to execute using a .xed amount of memory. Today, \nmany such real-time and embedded systems are being designed, implemented, and maintained. As this trend \ncon\u00adtinues, the reliability and safety of programming languages for such systems becomes more of a concern, \nand real-time systems become a natural domain for a high-level program\u00adming language. Functional Reactive \nProgramming (FRP) [16, 39] is a paradigm that has been used for building a host of interest\u00ading reactive \nsystems in domains such as animation [8, 9, 33], graphical user interface design [5], and robotics [27, \n28, 31]. As such, FRP is a good candidate for a high-level language for real-time programming. The central \nsemantic notions in FRP are behaviors and events. Each is provided to the user in the form of a parametric \ntype, namely Behavior a and Event a, respectively. In the original denotational semantics for FRP [9, \n39], a behavior is simply a function of continuous time, corresponding to the intuition that a behavior \nhas a value at any given instant. Time itself is modeled by the real numbers. An event, in contrast, \nis a time-ordered sequence of event occurrences. Together, these two notions provide a natural foundation \nfor describing systems of recursive equa\u00adtions over time-parametric, hybrid (that is, continuous and \ndiscrete) operators. 1.1 Problem Although FRP has proven to be fast enough for most of the applications \nwe have considered, it is not easy to estab\u00adlish strong guarantees about its time and space behavior. \nOur goal is to provide a practical framework where clear guarantees about the cost of an FRP computation \ncan be made. There are three distinct problems that need to be addressed: First, the reference semantics \nfor FRP is deno\u00adtational [9, 39]. While a denotational model helps in under\u00adstanding the meaning of an \nFRP program, it does not ex\u00adplain how a program can be e.ectively executed on a digital computer with \n.nite resources, nor does it provide a natu\u00adral notion of cost. Second, because FRP was initially im\u00adplemented \nas an embedded language in Haskell [13, 14, 15], making assertions about the cost of a computation was \nnon\u00adtrivial. Third, embedding a language into a higher-order language introduces all of the power of \nthe lambda calculus. Inherent in this expressiveness is the possibility of writing programs that perform \nunreasonable or unbounded amounts of computation at each time step, or that have subtle (hard to .nd) \nspace leaks. 1.2 Our Approach The .rst step towards addressing these problems is to specifyanoperational \nmodelofthe executionofanFRP program. By their very nature, FRP programs do not ter\u00adminate: they continuously \nemit values and interact with the environment. Thus it is appropriate to model FRP program execution \nas an in.nite sequence of steps. In each step, the current time and current stimuli are read, and the \nre\u00adsult is an output value and an updated program state. Our goal is to guarantee that every step executes \nin bounded time, and that overall program execution occurs in bounded space. However, we cannot make \nsuch guarantees for arbi\u00adtrary FRP programs, and thus we de.ne a subset of FRP called Real-Time (RT-)FRP \nfor which we can make such guarantees. With this approach, we solve each of the above three problems \nas follows: 1. RT-FRP is given an operational semantics [29] that provides a well-de.ned notion of cost. \nThat is, the size of the derivation for the judgment(s) de.ning a step of execution provides a measure \nof the amount of time and space needed to execute that step on a digital computer. 2. RT-FRP is a closed \nlanguage [21] in the sense that it is not embedded into a larger language such as Haskell. This makes \nit possible to give a direct operational se\u00admantics to the language, and therefore to provide a tractable \nnotion of cost. In addition, having an explicit notion of state is a fea\u00adture of our model that was \nnot present in previous work. Making state explicit allows us to specify an ef\u00ad.cient destructive-update \nsemantics, which is hard to enforce with the embedded approach. 3. A key aspect of our approach is to \nsplit RT-FRP into two naturally distinguishable parts: a reactive part and a base language part. Roughly \nspeaking, the re\u00adactive part is comparable to a synchronous system [4], and the base language part can \nbe any language that we wish to extend to a reactive setting. As we will show, the reactive part has \nbounded cost in terms of both time and space, independent of the base lan\u00adguage. Thus we can reuse our \napproach with a new base language without having to re-establish these re\u00adsults. Real-time behavior of \nthe base language can be carried out independently, and such techniques already exist even for a functional \nbase language [12, 18, 19, 24].  One important question that our work needs to address is the treatment \nof recursion, as it is a source of both ex\u00adpressiveness and computational cost. A key contribution of \nour work is restricting the reactive part of the language so as to limit both the time and space needed \nto execute such computations. We achieve this by .rst distinguishing two di.erent kinds of recursion \nin FRP: one for pure signals, and one for reactivity. Without constraint, the .rst form of recursion \ncan lead to programs getting stuck, and the sec\u00adond form can cause terms to grow in size. We address \nthese problems using carefully chosen syntax and a carefully de\u00adsigned type system. Our restrictions \non one of the forms of recursion is inspired by tail-recursion [30]. 1.3 Organization of the Paper Section \n2 introduces the syntax and basic concepts of RT-FRP. Section 3 de.nes and explains the type system and \noperational semantics for RT-FRP. In this section we also explain how two di.erent forms of recursion \nin RT-FRP can cause the semantics to either get stuck or use unbounded space. Section 4 presents our \nmain technical results, namely, termination and type preservation, and resource-bounded\u00adness. All of \nthese properties are quali.ed by explicit assump\u00adtions about the base language. Section 5 discusses related \nwork. The operational semantics of the example base language that we use is presented in Appendix A. \n 2. A BRIEF INTRODUCTION TO RT-FRP In this section we introduce the syntax and basic concepts of RT-FRP. \n2.1 Behaviors and Events as Signals A key di.erence between discrete models (such as our op\u00aderational \nsemantics) and continuous models (such as a deno\u00adtational semantics) is that in the discrete case behaviors \nand events only need to have values at a countable set of points. This means that there is an interesting \ntype isomorphism [7] relating behaviors and events, namely [16]: Event a Behavior (Maybe a) where Maybe \na is a data type with data constructors Nothing and Just a. This isomorphism makes it possible in our \nwork to combine behaviors and events into one common type that we call a signal, and thus treat both \nconcepts uniformly. 2.2 A Concrete Base Language Syntax To simplify the presentation, we will work with \na concrete base language, which has the syntax: e ::= x |c |() |(e1,e2) |e. |.|.x.e |e1 e2 v ::= c |() \n|(v1,v2) |v. |.|.x.e where x and c are the syntactic categories of variables and real numbers, respectively. \nThe only unusual feature is that the terms e. and .are used as a more concise way of writing Just e and \nNothing introduced earlier. For clarity, we also occasionally take the liberty of using some common syntax \nnot provided here, such as where clauses and if-then-else. Values in thebaselanguageare representedbythe \nterms v. 2.3 Reactive Language Syntax The reactive part of RT-FRP is given by: s, ev ::= input |time \n|ext e |delay vs |let snapshot x .s1 in s2 |s1 switch on x .ev in s2 |let continue {kj xj = uj } in s \n|u u ::= s until (evj . kj ) where k is the syntactic category of continuation variables. Note that the \nbase language terms can occur inside signal terms, but not the other way around. Furthermore, a vari\u00adable \nbound by let-snapshot can only be used in the base language. In therestofthissection we explaineachofthe \nreactive constructs of RT-FRP in more detail. 2.3.1 Primitive Signals The two primitive signals in RT-FRP \nare the current stim\u00adulus input and the current time time in seconds. In this paper we only make use \nof time, as it is su.cient for illustrating all the operations that one might want to de.ne on exter\u00adnal \nstimuli. In practice, however, input may be instantiated to much more interesting types such as mouse \nclicks, key\u00adboard presses, network messages, and so on since there are few interesting systems that \nreact only to time. 2.3.2 Interfacing with Base Language The reactive part s of RT-FRP does not provide \nprimitive operations such as addition and subtraction on the values of signals. Instead, this is relegated \nto the base language e. To interface with the base language, the reactive part of RT-FRP has a mechanism \nfor exporting snapshots of signal values to the base language, and a mechanism for importing base language \nvalues back into the signal world. Speci.cally, to export a signal, we snapshot its current value using \nthe let-snapshot construct, and to invoke an external computa\u00adtion in the base language we use the ext \ne construct. To illustrate, suppose we wish to de.ne a signal represent\u00ading the current time in minutes. \nWe can do this by: let snapshot x . time in ext (x/60) To compute externally with more than one signal, \nwe have to snapshot each one separately. For example, the term: let snapshot x . s1 in let snapshot y \n. s2 in ext (x + y) is a signal that is the point-wise sum of the signals s1 and s2. Those familiar with \nFRP will recognize this idea as one of the lifting primitive operations into the signal world. We can \nde.ne lifting operators such as: [[lift0 e]] = ext e [[lift1 es]] = let snapshot x . s in ext (ex) [[lift2 \nes1 s2]] = let snapshot x1 . s1 in let snapshot x2 . s2 in ext (ex1 x2) in which case the above two examples \ncould be written more simply as: lift2 (/) time (lift0 60) lift2 (+) s1 s2 2.3.3 Stateful Constructs \nThere are two stateful constructs in RT-FRP: delay and switch. The signal delay vs is a delayed version \nof s, whose initial value is v. To illustrate the use of delay, the following term computes the di.erence \nbetween the current time and the time at the previous program execution step: let snapshot t0 . time \nin let snapshot t1 . delay 0 time in ext (t0 - t1) As another example, the when operator in FRP turns \na Boolean signal s into an event that occurs whenever s transi\u00ad tions from False to True. This useful \noperator can be de.ned using delay: [[when s]] = let snapshot x1 . s in let snapshot x2 . delay False \ns in ext (if \u00acx2 . x1 then (). else .). The second stateful construct, switch, is used to de.ne sig\u00adnals \nthat react to other signals. For example, a sample-and\u00adhold register that remembers the most recent event \nvalue it received can be de.ned as: (ext 0) switch on x . ev in (ext x). This signal starts out as 0. \nWhenever the event ev occurs, its current value is substituted for x in the body ext x,and that value \nbecomes the current value of the overall switch construct. 2.3.4 Recursion In addition to its role in \nexporting signal values to the base language, the let-snapshot construct can also be used to de.ne recursive \nsignals. By combining delay with recursive signals, we can add internal state to signals. For example, \nwe can de.ne the running maximum of a signal s as follows: let snapshot cur . s in let snapshot rmax \n. delay (-8)(ext max{rmax, cur}) in ext rmax rmax is -8 in the initial step. At the (n + 1)-th step, \nit is updated to be the larger one of its previous value and the value of s at step n. Therefore rmax \nrecords the maximum value of s up to the previous step. A particularly useful stateful operation that \nwe can ex\u00adpress in RT-FRP is integration over time, de.ned below us\u00ading the forward-Euler method: [[integral \ns]] = let snapshot t . time in let snapshot v . s in let snapshot st . delay (0, (0, 0)) (ext ((i, (v, \nt)) where (i0, (v0,t0)) = st i = i0 + v0(t - t0)) in ext (fst st). Note that the internal state of integral \ns is a tuple (i, (v, t)), where i is the running integral, v is the previous value of s, and t is the \nprevious sample time. Integration is extremely useful in the de.nition of control systems. For example, \nthe velocity of a mass m under force f and friction kv can be described by the recursive integral equation: \nv =(f - kv)/m dt The RT-FRP encoding for this signal is simply: let snapshot v . integral (ext (f - k \n* v)/m). 2.3.5 Modes and Continuations RT-FRP provides two additional constructs, namely let\u00adcontinue \nand until, that allow the de.nition of multi-modal signals, that is, signals that shift from one operating \nmode to another depending on the occurrence of events.1 For ex\u00ad 1It is technically possible to use let-snapshot \nand switch to do this, but the result is much more awkward, and requires extensive escape to the base \nlanguage. ample, here is a system that switches between two signals s1 and s2 depending on the occurrence \nof an event ev: let snapshot y1 .s1 in let snapshot y2 .s2 in let snapshot x .ev in let continue { k1 \ny = ext y1 until (ext x .k2), k2 y = ext y2 until (ext x .k1)} in ext y1 until (ext x .k2). The let-continue \ndeclaration de.nes a set of mutually re\u00adcursive continuations. A continuation is essentially a signal \nparameterized by a variable, and corresponds naturally to a mode in control systems design. The until \nconstruct is used to jump between continuations at event occurrences. As a more concrete example, consider \nthe task of imple\u00admenting a thermostat in RT-FRP. A thermostat has two modes. In the On mode, the heater \nis on, and the tem\u00adperature rises according to some .ow condition. When the condition temperature = Thigh \noccurs, itswitchestothe O. mode, and the temperature gradually drops. The ther\u00admostat jumps back to the \nOn mode when temperature = Tlow becomes true. The following program de.nes such a system: let snapshot \nt .temperature in let continue { on x =(ext 1) until (when (ext (t =Thigh)) .o.), o. x =(ext 0) until \n(when (ext (t =Tlow)) .on)}in (ext 1) until (when (ext (t =Thigh)) .o.) 2.3.6 Switch in Terms of Continuations \nIt is possible to express the switch construct in terms of continuations (where y and k are fresh): [[s1 \nswitch on x .ev in s2]] = let snapshot y .ev in let continue {kx = s2 until (ext y .k)}in (s1 until (ext \ny .k)). For clarity, we will de.ne the typing rule and operational se\u00admantics for switch directly. When \nwe present the semantics, it should be easy to verify that the translation is preserved by execution. \nFor this reason we will not consider switch when proving properties about RT-FRP.   3. SEMANTICS OF \nRT-FRP In this section we present and explain the type system and operational semantics of RT-FRP. 3.1 \nNotation We use the notation (fj )j.{1..n} as shorthand for a .nite sequence (f1,f2,...,fn).We omit the \nsuperscript j .{1..n}when it is obvious from the context. Similarly, we write {fj}j.{1..n} or {fj } for \na .nite set {f1,f2, \u00b7\u00b7\u00b7 ,fn}.  3.2 Type System For simplicity of presentation, we do not explicitly \ndistin\u00adguish between the reactive types for RT-FRP and the types provided by the base language. 3.2.1 \nTypes The syntax for RT-FRP types is de.ned as follows: g ::= input |real |unit |g \u00d7g |g. |g .g. The \nmeaning of these types will vary depending on whether they are assigned to base language terms or RT-FRP \nsig\u00adnals. In the .rst case, g will have its usual interpretation. In the second case, it will mean a \nsignal carrying a value of type g . In FRP, these would be written e :: g and s :: Behavior g, respectively. \nUsing two di.erent interpre\u00adtations makes it possible to describe the latter case as a signal of type \ng . The type input is a placeholder for the signature of the external stimuli visible to the system. \nThe real is for real numbers, and unit is a singleton type. The type g. is a maybe g value. Having the \nlatter type in the base lan\u00adguage allows us to treat behaviors and events uniformly as signals (in the \nmanner explained at the beginning of the pre\u00advious section). The type g1 . g2 is for functions that take \nan argument of type g1 andreturnavalueoftype g2. It will be convenient in the de.nition of the type system \nto identify the following set of base types, that is, types that do not have a functional part: b ::= \ninput |real |unit |b \u00d7b |b. 3.2.2 Contexts A variable context G is a function from variables to anno\u00adtated \ntypes. An annotated type could be either exportable (written . g)or local (written g). These annotations \nare need to ensure that the phase distinction between the eval\u00aduation of a term and updating a term is \nre.ected in enough detail so as to allow us to guarantee type safety, even in the presence of recursion. \nWe will also treat contexts functions as sets (their graph). We require all variable names in a program \nto be distinct. Variable contexts G ::= {xj :?gj } where ?g is an annotated type. The annotations allow \nus to de.ne the following two functions on variable contexts, called expose and export, respectively: \n.{xj :?gj } = {xj :.gj } .({xj : .gj }.{xk : gk })= {xj : gj }. A continuation context . is a function \nfrom continuations to types. ' Continuation contexts . ::= {kj : gj .gj }. ' A binding k : g . gin . \nmeans that k is a continuation ' that takes a value of type g and returns a signal of type g.  3.2.3 \nTyping Judgment Figure 1 de.nes the RT-FRP type system using a judg\u00adment G; . fS s : g,read s is a signal \nof type g . The signal input has type input. The signal time has type real. The term ext e is a signal \nof type g when e is a base lan\u00adguage term of type g. In this typing rule, e is typed without using .. \nIntuitively, this means that continuations cannot be exported to the base language. The type of delay \nvs is the type of s, given that the base language term v has the same type. Note, however, that the term \ns must have a base type b. This technical restriction is necessary to ensure type preservation. Aterm \nlet snapshot x .s1 in s2 has the same type as s2, assuming that s1 is well-typed. The typing re.ects \nthe fact that this is a recursive binding construct, and that x can occur anywhere. In s1 switch on x \n.ev in s2, ev must have G .{x : g1};. fS s1 : g1 G .{x :.g1};. fS s2 : g2 (t1)(t2)(t3) G; . fS input \n: input G; . fS time : real G; . fS let snapshot x . s1 in s2 : g2 G; . fS s1 : g1 \u00d8f. v : b .G; . fS \nev : g2. .G f. e : g .G; . fS s : b G .{x :.g2};. fS s2 : g1 (t4)(t5)(t6) G; . fS ext e : g G; . fS delay \nvs : b G; . fS s1 switch on x .ev in s2 : g1 ..i.J G .{xi :.gi}; {kj : gj .gj ' }j.J fS ui : gi ' G; \n. .{kj : gj .gj ' }j.J fS s : g G; \u00d8fS s : g {.G; \u00d8fS evj : gj . } (t7)(t8) G; . fS let continue {kj \nxj = uj }j.J in s : g G; . .{kj : gj .g}fS s until (evj . kj ): g Figure 1: Type System for Reactive \npart of RT-FRP G f. e : g (s1)(s2)(s3)(s4)(s5) G .{x : g}f. x : g G f. c : real G f. () : unit G f. \ne. : g. G f. .: g. G f. e1 : g1 .g2 G f. e1 : g1 G .{x : g1}f. e : g2 G f. e2 : g1 G f. e2 : g2 (s6)(s7)(s8) \nG f. .x.e : g1 .g2 G f. e1 e2 : g2 G f. (e1,e2): g1 \u00d7g2 Figure 2: Type System for an Example Base Language \nfor RT-FRP an event type, s1 and s2 should be of the same type, and 3.3.1 Environments the scope of x \nis in s2. Program execution takes place in the context of a variable The type of a continuation k has \nthe form g .g ' , meaning environment E and a continuation environment K: that when fed a value of type \ng, k becomes a signal of type g ' . Variable environments E ::= { xj.vj } A group of mutually recursive \ncontinuations are de.ned by Continuation environments K ::= {kj. .xj .uj }. let-continue. A continuation \nde.nition has the form kx = u, where x is the formal parameter for k,and u (an until term) A variable \nenvironment is used to store the current values is the de.nition body. Note that u can only contain those \nof signals, and hence maps signal variables to values. The continuations being de.ned in the same declaration. \nThese environment K maps a continuation to its de.nition. The constraints resemble tail recursion, and \nso we call such terms lambda abstraction makes explicit the formal argument and tail signals. Intuitively, \nthe constraints establish a set of the signal parameterized by that argument. simple scoping rules for \ncontinuations:  3.3.2 Two Judgment Forms of cannot refer to surrounding continuation declarations t,i \n1. The de.nitions {uj }in a new continuation declaration Figure 3 de.nes the single-step semantics by \nmeans two judgments: Ef s . v,read s evaluates to v , and .. '' t,i E; Kf s -. s ,read s is updated to \nbecome s . Note that the semantics for each step is parameterized by the cur\u00ad 2. In s until (evj .kj \n), none of the sub-terms can con-rent time t and the current input i. Sometimes we combine t,i tain \nfree continuations, as shown by the rule t8. the two judgments and write E; Kf s . v, s ' . When the \nt,i environments are empty, we write s . v, s ' . The analogy with tail recursion lies in that just \nas tail calls The role of evaluation is to compute the output of a term. have to be the last calls made, \nan invocation of a tail signal The role of updating is to modify the state of the program. has to be \nthe last invocation made. We will explain the rules of each of these judgments shortly. In a term s until \n(evj .kj ), the type of an event evj must The overall execution, or run , of an RT-FRP program is match \nthe parameter type of the continuation kj ,and the modeled as an in.nite sequence of interactions with \nthe en\u00adresult type of all kj must be the same as the type of s. vironment, and in that sense does not \nterminate. Formally, To use a concrete example for the base language, Figure for a given sequence of \ntime stamps and external stimuli 2 de.nes a fairly standard type system using a judgment ((t0,i0), (t1,i1), \n...),a run of an RT-FRP program s0 pro\u00adG f. e : g,read e is a base language term of type g. tk,ik duces \na sequence of values (v0,v1, ...),where sk . vk,sk+1 for some sequence (sk+1). Thus, a run can be visualized \nas  3.3 Operational Semantics an in.nite chain of the form: We now present the full details of the \noperational seman\u00ad t0,i0t1,i1tn,in tics of the reactive part of RT-FRP. s0 . v0,s1 . v1,s2 ...sn . vn,sn+1 \n... Evaluation Rules Updating Rules (e1) (u1) t,i t,i Efinput .i E; Kfinput -.input (e2) (u2) t,i t,i \nEftime .t E; Kftime -.time Efe .v (e3) (u3) t,i t,i Efext e .v E; Kfext e -.ext e t,i E; Kfs . v ' ,s \n' (e4) (u4) t,i t,i Efdelay vs .v E; Kfdelay vs -.delay v ' s ' t,i Efs1 .v1 t,i t,i Efs1 .v1 E.{x \n.v1}; Kfs1 -.s1 ' t,i t,i E.{x .v1}fs2 .v2 E.{x .v1}; Kfs2 -.s2 ' (e5) (u5) t,i t,i Eflet snapshot x \n.s1 in s2 .v2 E; Kflet snapshot x .s1 in s2 -. let snapshot x .s1 ' in s2 ' t,i t,it,i Efs1 .v E; Kfs1 \n-.s1 ' E; Kfev ...,ev ' (e6) (u6) t,i t,i Efs1 switch on x .ev in s2 .v E; Kfs1 switch on x .ev in s2 \n-. s1 ' switch on x .ev ' in s2 t,i E; Kfev . v.,ev ' (u7) t,i E; Kfs1 switch on x .ev in s2 -. s2[x \n:= v] switch on x .ev ' in s2 t,i t,iEfs .v E; K.{kj ..xj .uj }fs -.s ' (e7) (u8) t,i t,i Eflet continue \n{kj xj = uj }in s .v E; Kflet continue {kj xj = uj }in s -. let continue {kj xj = uj }in s ' t,i t,it,i \nEfs .v E; \u00d8fs -.s ' {E; \u00d8fevj ...,evj ' } (e8) (u9) t,i t,i Efs until (evj . kj ).v E; Kfs until (evj \n. kj )-. s ' until (ev ' . kj ) j t,i t,i j.{1..m-1} {Efevj ..}Efevm .v. (u10) E; K.{km ..x.u}f t,i \ns until (evj . kj )-.u[x := v] Figure 3: Operational Semantics for RT-FRP 3.3.3 The Mechanics of Evaluating \nand Updating instantaneous value of s,and s ' is the new term resulting from updating s. The evaluation \nrule for calls to the base language (rule Evaluation of let snapshot x .s1 in s2 consists of two e3) \nuses the judgment Efe .v to evaluate the .-term e. stages: .rst, s1 is evaluated to get v; second, s2 \nis evaluated An example de.nition for this judgment is given in the ap-with x bound to v, yielding the \nresult. Updating the term pendix. Lambda terms are left unchanged during updating. is done by updating \nboth s1 and s2. Evaluating the input and time constructs simply returns The rules for s1 switch on x \n.ev in s2 are a bit involved. the current value for the input and the time, respectively. If the event \ndoes not occur, the default signal s1 is evalu-Updating these two constructs leaves them unchanged. Note \nated as usual. Note that the updating rules do not update that, operationally, time is just one of the \ninputs. the signal s2 that is to be (eventually) switched into. This The instantaneous value of delay \nvs is just v. But it is means that signal begins execution only after the event oc\u00ad '' ' updated to \na new term delay vs ,where v is the previous curs. Moving to the next rule, if the event does occur, \nwe make a new default value consisting of s2 where x has been replaced by the current value of the event. \nThe evaluation of let-continue and until is straightforward with one exception: the value returned by \ns until (evj .kj )does not depend on any of the events {evj }. This behavior is similar to that of switch. \nThe motivation for this design is to allow the user to de.ne signals that react to themselves, such as \nlet snapshot x .s1 switch on y .when (ext (x> 10)) in s2, which switches to the signal s2 when the value \nof itself ex\u00adceeds 10. The updating rules for let-continue and until are more in\u00advolved. For the construct \nlet continue {kj xj = uj }in s the continuation de.nitions {kj xj = uj } are unchanged, and s is executed \nwith the continuation environment ex\u00adtended with the new de.nitions. For the construct s until (evj .kj \n) the events (evj )are tested one after another until the .rst occurrence, then the signal evolves to \nthe de.nition of the corresponding continuation, with its formal parameter re\u00adplaced by the value of \nthe event. If no event occurs, then we get back the original term with the sub-terms updated.  3.4 What \nCan Go Wrong? RT-FRP supports two forms of recursion [6]: recursive pure signals as de.ned by let-snapshot,and \nrecursive switch\u00ading as de.ned by let-continue and until. This section dis\u00adcusses these two forms and \nthe concrete run-time problems they can cause. 3.4.1 Getting Stuck To see how untyped programs that use \nlet-snapshot can get stuck, consider this example: evaluating let snapshot x .ext x in ext x requires \nevaluating ext x in an environment where x is not bound (rule e5). The essence of this problem is that \nany occurrence of x in the body of the let-snapshot should not be needed during evaluation, although \nit could be used during updating. In fact, the distinction between evaluation and updating exists primarily \nso that evaluation can be used to bootstrap the recursion in an early phase, so that we can give a sensible \nnotion of updating to such expressions. 3.4.2 Needing More Space The second rule for updating until \nrequires special atten\u00adtion, as it replaces a reactive term by a possibly larger re\u00adactive term from \nthe environment, and so could lead to un\u00adbounded program size. As an example, the program let continue \n{kx = s1 until (ev .k)} in s2 until (ev .k) becomes larger when ev occurs, if the size of s1 is larger \nthan that of s2.  4. PROPERTIES OF RT-FRP In this section we prove the basic resource-boundedness properties \nof RT-FRP, namely, that the time and space in each execution step is bounded: Theorem 1 (Main). For any \nclosed and well-typed pro\u00adgram, we know that 1. its single-step execution terminates and preserves type, \nand 2. there is a bound for the time and space it needed during its execution.  Proof. The proof of \nthe .rst part is a special instance of Lemma 4. The proof of the second part requires formalizing notions \nof cost and showing that they are bounded during the execution of any program. In the rest of this section, \nwe present the technical details required to establish this result. 4.1 Type Preservation and Termination \n4.1.1 Compatibility In order to express the type safety property concisely, we must have a concise way \nfor expressing the necessary con\u00adstraints on the environments involved in the statement of the properties. \nIn general, we will need to assume that a given value environment is consistent with a given type context. \nWe say an environment E={xj .vj }j.J is compatible with a context G ={xj : gj }j.J , and de.ne G fE as \nfollows: i.Jj.J {xj : gj }f. vi : gi . j.Jj.J {xj : gj }f{xj .vj } Similarly, we say K={kj ..xj .uj }j.J \nis compatible with ' j.J Gand . ={kj : gj . gj }, and de.ne G; . fK as follows: i.J ' j.J ' G .{xi : \n.gi}; {kj : gj .gj }fS ui : g i . ' j.Jj.J G; {kj : gj .g }f{kj ..xj .uj } j It is easy to show the above \nde.nitions enjoy the following forms of weakening: Lemma 2 (Basic Properties). G fE G f. v : g G; \u00d8f\u00d8 \nG .{x : g}fE.{x .v} G; . fK G; . ' fK ' G .{x : g1};. fs : g2 G; . ..' fK.K' .G .{x : g1};. fs : g2 \n4.1.2 Assumptions about Base Language In order to prove the key properties of RT-FRP, we must be explicit \nabout our assumptions about the base language. We assume three key properties of the base language: First, \nthat evaluation terminates and preserves typing. Second, that values of lifted type be of the two obvious \nforms dis\u00adtinguished at the head. Third, that the type system enjoys substitutivity. These requirements \nare formalized as follows: . G fE . G f . e : g . v. ( Ef e . v . G f . v : g ) . G f . v : g. v =. or \n. v ' . ( v = v ' v ' : g ) . . G f . . G f . e : g . G .{ x : g}f. e ' : g ' . G f . e ' [x := e]: g \n' 4.1.3 Substitutivity Using the substitutivity assumption about the base lan\u00adguage, it is now possible \nto establish the following lemma for RT-FRP: Lemma 3 (Substitution). Whenever . G f . v : g and G .{ \nx : . g} ;. f S s : g ' , we have G; . f S s[x := v]: g ' . 4.1.4 Main Lemma Lemma 4 (Type Preservation \nand Termination). For all G, ., E , K , s,and g, 1. if . G fE and G; . f S s : g, then there exists a \nvalue t,i v such that Ef s . v and . G f . v : g,and 2. if .. G fE ,and G; . fK and G; . f S s : g,then \nthere exists a term s ' such that E ; Kf s t,i-. s ' and ' G; . f S s : g. Proof. The proof of both \nparts is by induction over the height of the typing derivation. The proof of the .rst part uses the assumptions \nabout the base language to establish the soundness of the ext construct. The proof of the second part \nuses the substitutivity property, and the .rst part of the lemma. After this property is established, \nit is easy to see that not only is evaluation always terminating, but it is also deter\u00administic whenever \nthe base language is also deterministic.  4.2 Resource Boundedness Having established that the language \nis terminating, we now come to the proof of the second part of our main the\u00adorem, namely, time-and space-boundedness. \nAs a measure of the time and space needed for executing a program, we will use term size at run-time \n(modulo the size of base lan\u00adguage terms). This measure is reasonable because of two observations: First, \nthe size of a derivation tree is bounded by the term size. Second, the derivation is syntax directed, \nand so the time needed to propagate the information around a rule is bounded by the size of the term \n(assuming a naive implementation, where each term is copied in full). Thus, our focus will be on showing \nthat there exists a measure on programs that does not increase during run-time. We formally de.ne the \nsize of a term s, written | s| ,tobe the number of constructors, base language expressions, and continuationsinthe \nterm: | input| =1 | time| =1 | ext e| =2 | delay vs| =2+ | s|| let snapshot x . s1 in s2| =2+ | s1| + \n| s2| | let continue { kj xj = uj } j.{ 1..n} in s|=1+2n +Sn j=1| uj | + | s| | s until ( evj . kj ) \nj.{ 1..n} | =1+ n + | s| +Snj=1| evj | . As mentioned earlier, the size of a term can grow at run\u00adtime. \nHowever, we can still show that there exists a bound for the size of the term at run-time. The following \nfunction (on continuation environments and terms) will be used to de.ne such a bound: ||{ kj . .xj .uj \n}|| =max{ 0}. || uj || 0 || input|| =1 m || time|| =1 m || ext e|| =2 m || delay vs|| =2+ || s|| mm || \nlet snapshot x . s1 in s2|| =2+ || s1|| + || s2|| m mm || let continue { kj xj = uj } j.{ 1..n} in s|| \nm =1+2n +Snj=1| uj | + || s|| . .xj.uj } j.{1..n}|| ,m} max{ ||{ kjr || s until ( evj . kj ) j.{ 1..n} \n|| m =max 1+ n + || s|| j=1|| evj || ,m . 0 +Sn 0 where m in || s|| is the size bound for the free continuations \nm in s. In order to establish the bound, we must always consider a term in the context of a particular \ncontinuation environ\u00adment. Thus we de.ne the term size bound for a term s under continuation environment \nK to be || s|| ||K | . First, it is useful to know that this measure is an upper bound for term size \n| s| : Lemma 5. For all m and s, | s|=||s|| . m Proof. By induction on s. Now we can show that even though \nterm size can grow dur\u00ading execution, its size bound as de.ned by ||-| ||K | does not: t,i Lemma 6. (Bound \nPreservation) E ; Kf s -. s ' im\u00adplies || s ' || ||K | =|| s|| ||K | . Proof. The proof is by induction \non the derivation for t,i E ; Kf s -. s ' . In what follows, we let m = ||K| . 1. The last rule used \nin the derivation is u1, u2,or u3.In this case s = s ' .Hence || s ' || =|| s|| . mm 2. The last rule \nin the derivation is u4.Then s = delay vs1, t,i ''' ' s = delay vs1,and E ; Kf s1 -. s1. By induction \nhypothesis, || s ' || =2+ || s1' || = 2+ || s1|| = || s|| . m m mm 3. Thelastruleis u5,or u9. The proof \nis by induction hypothesis. 4. Thelastruleis u8. Weknowthat  s = let continue { kj xj = uj } in s1 \ns ' = let continue { kj xj = uj } in s ' 1 t,i and E ; K.{ kj . .xj .uj }f s1 -. s1 ' Note that ||K . \n{ kj . .xj .uj }|| =max{ max{|| uj || } ,m} 0 =max{||{ kj . .xj .uj }|| ,m} Hence by induction hypothesis, \n|| s ' || m =1+2n +Snj=1| uj | + || s1' || max{ ||{kj r ..xj.uj }||,m} = 1+2n +Sn j=1| uj | + || s1|| \nmax{ ||{kj r ..xj.uj }||,m} = || s|| m 5. The last rule is u10. In this case, s = s1 until ( evj . kj \n) j.{1..n}, and s ' = u[x := v], where (k . .x.u) .K for some k and x. || s ' || m = || u|| m =max{ 1+ \nn + || s2|| +Sj || evj || ,m } 00 where u = s2 until ( evj . kj ) j.{1..n} =max{ 1+ n + || s2|| +Sj || \nevj || 0, 0,m } 0 =max{|| u|| ,m} 0 = m (since (k . .x.u) .K ) =|| s|| m And we are done.  5. DISCUSSION \nAND RELATED WORK Several languages have been proposed around the syn\u00adchronous data-.ow notion of computation. \nThe general\u00adpurpose functional language Lucid [38] is an example of this style of language. More relevant \nto the present paper are the languages Signal [10], Lustre [3], and Esterel [1, 2], which were speci.cally \ndesigned for control of real-time systems. In Signal, the central notion a signal, a time-ordered sequence \nof values. This is analogous to the sequence of values gener\u00adated in the execution of an RT-FRP program. \nThe designers of Signal have also developed a clock calculus with which one can reason about Signal programs. \nLustre is a language sim\u00adilar to Signal, rooted again in the notion of a sequence, and owing much of \nits nature to Lucid. Esterel is perhaps the most ambitious language in this class. Compilers are available \nthat translate Esterel pro\u00adgrams into .nite state machines or digital circuits for em\u00adbedded applications. \nIn relation to our current work, a large e.ort has been made to develop a formal semantics for Es\u00adterel, \nincluding a constructive behavioral semantics, a con\u00adstructive operational semantics, and an electrical \nsemantics (in the form of digital circuits). These semantics are shown to correspond in a certain way, \nconstrained only by a notion of stability. None of these synchronous data .ow languages seem to have \nconsidered recursion. Synchronous Kahn networks [4] extended these proposals with recursion and higher-order \nprogramming, yielding a large increase in expressive power. The downside of such extension is that resource-boundedness \nis no longer guaranteed. In RT-FRP we have shown that, using some syntactic restrictions and a type system, \nit is possible to achieve such a bound. Mycroft and Sharp [25] develop a statically allocated par\u00adallel \nfunctional language for the speci.cation of hardware. Their language allows recursion, and restricts \nrecursive calls to tail calls. However, they use an explicit notion of a syntac\u00adtic context to specify \nwhat is a tail call, and restrict recursive functions. In our work, we have integrated this restriction \ninto the type system. It will be interesting to see an inte\u00adgration is also possible in their setting. \nA hybrid automaton [11, 22] is a commonly used formal model for a hybrid system, and consists of a .nite \nnumber of control modes. Discrete events trigger the system to jump from one mode to another. Within \none mode, the system state changes continuously. Although we have not formally established such a result, \nwe expect that, in the limit as the maximum sampling period goes to zero, an RT-FRP program can implement \na hybrid automaton. CML (Concurrent ML) formalizes synchronous operations as .rst-class, purely functional, \nvalues called events [32]. FRP sevent combinators .|. and ==> correspond to CML s choose and wrap functions. \nThere is a basic di.er\u00adence, however, between the meaning given to events in these two approaches. In \nCML, events are ultimately used to per\u00adform an action, such as reading input from or writing output to \na .le or another process. In contrast, our events are used purely for the values they generate. Previous \nwork on FRP de.ned an implementation seman\u00adtics that uses streams (potentially in.nite sequences). This \nsemantics is used as the basis for most current FRP imple\u00admentations. The fundamental di.erence in our \nwork is that we de.ne sequences of whole program execution and not just sequences of values. As such \nour work presents an explicit model of the mechanics of executing a subset of FRP pro\u00adgrams, and shows \nhow this model can be used to establish guarantees that are relevant to embedded systems applica\u00adtions. \nIt may be surprising to a reader familiar with FRP that some of its basic constructs are missing in RT-FRP. \nMany of these constructs, however, are de.nable in RT-FRP. In\u00addeed,we have already de.ned when, several \nlift operators, and integral. In addition, FRP s never and once operators generate event values that \nnever occur and occur exactly once, respectively. They can be expressed in RT-FRP as follows: [[never]] \n= ext . [[once ev]] = let snapshot x2 . ev in let snapshot x1 . delay . (ext (if x1 = . then x2 else \nx1)) in ext (if x1 = . then x2 else . ) FRP s till operator, similar to the until construct in RT-FRP, \ncan be translated as follows: [[s1 till ev then s2]] = s1 switch on x . once ev in s2 Frapp\u00b4e [5] is \nan e.cient implementation of a subset of FRP in Java. The exact subset has not yet been formally de\u00adscribed \nor characterized. With suitable extensions, RT-FRP could serve as a model for Frapp\u00b4e. In addition, a \nnumber of interesting evaluation strategies (called push, pull, and hybrid) have been explored in the \ncontext of Frapp\u00b4e 2 and we are interested in formalizing these models and studying their properties. \n2Antony Courtney, personal communication, December 2000. This paper presented a model of machines that \nwork in an environment that provides a type of stimulus. Although we have discussed how a base language \ncan be invoked from within FRP, we have not proposed a method for combining or integrating the kind of \nmachines that we have presented here. Ongoing work at Yale by Antony Courtney, Henrik Nilsson and John \nPeterson suggests that Hughes arrows [17] provide a natural mechanism for modeling signals that are explicitly \nparameterized by an input type3 . We expect that this approach can be used as a bases for a language \nfor com\u00adbining RT-FRP machines. We are particularly interested in seeing if this approach can be used \nto model asynchronous systems of synchronous processes. In this paper, we have chosen to focus on the \nissue of bounded resources in the presence of recursion. Ultimately, however, we are interested in more \nsophisticated models for real-time systems, where resources are allocated according to their priority \n(see Kieburtz [20] for a nice account from the Haskell point of view). Signal, Lustre, and synchronous \nKahn networks [4] account for this via a clock calculus. While this technique may apply directly to RT-FRP, \nthis still remains to be established. There are many connections between the semantics here and the semantics \nof multi-stage languages. Evaluating re\u00adcursive let-snapshot declarations requires evaluation under a \nbinder. This problem arises constantly in the context of multi-level and multi-stage languages [35]. \nOur approach the treatment of this problem, namely, using the exporta\u00adbility annotations in the type \nsystem, is inspired by the work on multi-stage languages [23, 37]. Our evaluation and up\u00addating functions \nare also analogous to the evaluation and rebuilding functions of multi-stage language [35]. It will be \ninteresting to see if this analogy continues to hold as we continue the development of RT-FRP. Finally, \nwe are interested in the study of cost-preserving notions of equivalence in RT-FRP along the lines developed \nby Sands [34]. Acknowledgements: We would like to thank the members of the FLINT, FRP, and PacSoft groups, \nArvind Krishna\u00admurthy, Simon Peyton-Jones and the anonymous reviewers for many comments on drafts of \nthis paper that improved the .nal version. We would especially like to thank Antony Courtney, Henrik \nNilsson, and John Peterson for valuable discussions and for sharing with us their work and ideas in relation \nto FRP. APPENDIX A. BASE LANGUAGE SEMANTICS Figure 4 gives the operational semantics of the base lan\u00adguage \nused in this paper.  B. REFERENCES [1] G. Berry and L. Cosserat. The esterel synchronous programming \nlanguage and its mathematical semantics. In A.W. Roscoe S.D. Brookes and editors G. Winskel, editors, \nSeminar on Concurrency,volume 197 of Lect. Notes in Computer Science, pages 389 448. Springer Verlag, \n1985. [2] Gerard Berry. The constructive semantics of pure esteral (draft version 3). Draft Version 3, \nEcole des 3Personal communication, May 2001. Mines de Paris and INRIA, July 1999. [3] P. Caspi, N. Halbwachs, \nD. Pilaud, and J.A. Plaice. Lustre: A declarative language for programming synchronous systems. In 14th \nACM Symp. on Principles of Programming Languages, January 1987. [4] Paul Caspi and Marc Pouzet. Synchronous \nKahn networks. ACM SIGPLAN Notices, 31(6):226 238, 1996. [5] Antony Courtney. Frapp\u00b4e: Functional reactive \nprogramming in Java. In Proceedings of Symposium on Practical Aspects of Declarative Languages.ACM, 2001. \n[6] Anthony C. Daniels. A Semantics for Functions and Behaviours. PhD thesis, The University of Nottingham, \nDecember 1999. [7] Roberto Di Cosmo. Isomorphisms of Types: from .-calculus to information retrieval \nand language design. Progress in Theoretical Computer Science. Birkh\u00a8auser, 1995. [8] Conal Elliott. \nModeling interactive 3D and multimedia animation with an embedded language. In Proceedings of the .rst \nconference on Domain-Speci.c Languages, pages 285 296. USENIX, October 1997. [9] Conal Elliott and Paul \nHudak. Functional reactive animation. In International Conference on Functional Programming, pages 163 \n173, June 1997. [10] Thierry Gautier, Paul Le Guernic, and Loic Besnard. Signal: A declarative language \nfor synchronous programming of real-time systems. In Gilles Kahn, editor, Functional Programming Languages \nand Computer Architecture, volume 274 of Lect Notes in Computer Science, edited by G. Goos and J. Hartmanis, \npages 257 277. Springer-Verlag, 1987. [11] Thomas A. Henzinger. The theory of hybrid automata. Technical \nreport, University of California, Berkeley, 1996. [12] Martin Hofmann. A type system for bounded space \nand functional in-place update. In European Symposium on Programming (ESOP), Lecture Notes in Computer \nScience. Springer-Verlag, 2000. [13] P. Hudak, S. Peyton Jones, and P. Wadler (editors). Report on the \nProgramming Language Haskell, A Non-strict Purely Functional Language (Version 1.2). ACM SIGPLAN Notices, \n27(5), May 1992. [14] Paul Hudak. Building domain speci.c embedded languages. ACM Computing Surveys, \n28A:(electronic), December 1996. [15] Paul Hudak. Modular domain speci.c languages and tools. In Proceedings \nof Fifth International Conference on Software Reuse, pages 134 142. IEEE Computer Society, June 1998. \n[16] Paul Hudak. The Haskell School of Expression Learning Functional Programming through Multimedia. \nCambridge University Press, New York, 2000. [17] John Hughes. Generalising monads to arrows. Science \nof Computer Programming, 37:67 111, May 2000. [18] John Hughes and Lars Pareto. Recursion and dynamic \ndata-structures in bounded space: Towards embedded ML programming. In Proceedings of the Fourth ACM SIGPLAN \nInternational Conference on Functional Programming (ICFP-99),volume34.9of ACM Sigplan Efe1 .v1 Efe2 \n.v2 Efe .v E.{x .v}fx .v Efc .c Ef() .() Ef(e1,e2) .(v1,v2) Efe. .v. Efe1 ..x.e Efe[x := e2] .v Ef... \nEf.x.e ..x.e Efe1 e2 .v Figure 4: Operational Semantics of a Functional Base Language Notices, pages \n70 81, N.Y., September 27 29 1999. ACM Press. [19] John Hughes, Lars Pareto, and Amr Sabry. Proving the \ncorrectness of reactive systems using sized types. In Guy L. Steele Jr, editor, In proceedings of the \nACM Symposium on Principles of Programming Languages (POPL), volume 23, St Petersburg, Florida, 1996. \nACM Press. [20] Richard Kieburtz. Real-time reactive programming for embedded controllers. Available \nfrom author s home page, March 2001. [21] Richard B. Kieburtz. Implementing closed domain-speci.c languages. \nIn [36], pages 1 2, 2000. [22] O. (Oded) Maler, editor. Hybrid and real-time systems: international workshop, \nHART 97, Grenoble, France, March 26 28, 1997: proceedings, volume 1201 of Lecture Notes in Computer Science, \nNew York, NY, USA, 1997. Springer-Verlag. [23] Eugenio Moggi, Walid Taha, Zine El-Abidine Benaissa, and \nTim Sheard. An idealized MetaML: Simpler, and more expressive. In European Symposium on Programming (ESOP), \nvolume 1576 of Lecture Notes in Computer Science, pages 193 207. Springer-Verlag, 1999. [24] A. S. Murawski \nand C.-H. L. Ong. Can safe recursion be interpreted in light logic? In Second International Workshop \non Implicit Computational Complexity, Santa Barbara, June 200. [25] Alan Mycroft and Richard Sharp. A \nstatically allocated parallel functional language. In Automata, Languages and Programming, pages 37 48, \n2000. [26] Oregon Graduate Institute Technical Reports. P.O. Box 91000, Portland, OR 97291 -1000,USA. \nAvailable online from ftp://cse.ogi.edu/pub/tech-reports/README.html. Last viewed August 1999. [27] John \nPeterson, Gregory Hager, and Paul Hudak. A language for declarative robotic programming. In International \nConference on Robotics and Automation, 1999. [28] John Peterson, Paul Hudak, and Conal Elliott. Lambda \nin motion: Controlling robots with haskell. In First International Workshop on Practical Aspects of Declarative \nLanguages. SIGPLAN, Jan 1999. [29] Gordon Plotkin. A structural approach to operational semantics. Technical \nreport, Computer Science Department, Aarhus University, 1981. [30] J. Rees and W. Clinger (eds.). The \nrevised3 report on the algorithmic language Scheme. SIGPLAN Notices, 21(12):37 79, December 1986. [31] \nAlastair Reid, John Peterson, Greg Hager, and Paul Hudak. Prototyping real-time vision systems: An experiment \nin DSL design. In Proc. Int l Conference on Software Engineering, May 1999. [32] John H. Reppy. CML: \nA higher-order concurrent language. Proceedings of the ACM SIGPLAN 91 Conference on Programming Language \nDesign and Implementation, pages 293 305, 1991. [33] Meurig Sage. FranTk a declarative GUI language \nfor Haskell. In Proceedings of Fifth ACM SIGPLAN International Conference on Functional Programming, \npages 106 118, Montreal, Canada, September 2000. ACM. [34] David Sands. A na\u00a8ive time analysis and its \ntheory of cost equivalence. Journal of Logic and Computation, 5(4):495 541, 1995. [35] Walid Taha. Multi-Stage \nProgramming: Its Theory and Applications. PhD thesis, Oregon Graduate Institute of Science and Technology, \n1999. Available from [26]. [36] Walid Taha, editor. Semantics, Applications, and Implementation of Program \nGeneration, volume 1924 of Lecture Notes in Computer Science,Montr\u00b4eal, 2000. Springer-Verlag. [37] Walid \nTaha, Zine-El-Abidine Benaissa, and Tim Sheard. Multi-stage programming: Axiomatization and type-safety. \nIn 25th International Colloquium on Automata, Languages, and Programming (ICALP), volume 1443 of Lecture \nNotes in Computer Science, pages 918 929, Aalborg, 1998. [38] W.W. Wadge and E.A. Ashcroft. Lucid, the \nData.ow Programming Language. Academic Press U.K., 1985. [39] Zhanyong Wan and Paul Hudak. Functional \nreactive programming from .rst principles. In Proceedings of Symposium on Programming Language Design \nand Implementation. ACM, 2000.  \n\t\t\t", "proc_id": "507635", "abstract": "Functional reactive programming (FRP) is a declarative programming paradigm where the basic notions are continuous, time-varying behaviors and discrete, event-based reactivity. FRP has been used successfully in many reactive programming domains such as animation, robotics, and graphical user interfaces. The success of FRP in these domains encourages us to consider its use in real-time applications, where it is crucial that the cost of running a program be bounded and known before run-time. But previous work on the semantics and implementation of FRP was not explicitly concerned about the issues of cost. In fact, the resource consumption of FRP programs in the current implementation is often hard to predict. As a first step towards addressing these concerns, this paper presents real-time FRP (RT-FRP), a statically-typed language where the time and space cost of each execution step for a given program is statically bounded. To take advantage of existing work on languages with bounded resources, we split RT-FRP into two parts: a reactive part that captures the essential ingredients of FRP programs, and a base language part that can be instantiated to any generic programming language that has been shown to be terminating and resource-bounded. This allows us to focus on the issues specific to RT-FRP, namely, two forms of recursion. After presenting the operational explanation of what can go wrong due to the presence of recursion, we show how the typed version of the language is terminating and resource-bounded. Most of our FRP programs are expressible directly in RT. The rest are expressible via a simple mechanism that integrates RT-FRP with the base language.", "authors": [{"name": "Zhanyong Wan", "author_profile_id": "81100388303", "affiliation": "Yale Univ., New Haven, CT", "person_id": "P309663", "email_address": "", "orcid_id": ""}, {"name": "Walid Taha", "author_profile_id": "81100239752", "affiliation": "Yale Univ., New Haven, CT", "person_id": "PP39034018", "email_address": "", "orcid_id": ""}, {"name": "Paul Hudak", "author_profile_id": "81100539650", "affiliation": "Yale Univ., New Haven, CT", "person_id": "PP40028396", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/507635.507654", "year": "2001", "article_id": "507654", "conference": "ICFP", "title": "Real-time FRP", "url": "http://dl.acm.org/citation.cfm?id=507654"}