{"article_publication_date": "09-19-2004", "fulltext": "\n Functional Morphology Markus Forsberg and Aarne Ranta Department of Computing Science Chalmers University \nof Technology and the University of Gothenburg {markus, aarne}@cs.chalmers.se Abstract This paper presents \na methodology for implementing natural lan\u00adguage morphology in the functional language Haskell. The main \nidea behind is simple: instead of working with untyped regular ex\u00adpressions, which is the state of the \nart of morphology in computa\u00adtional linguistics, we use .nite functions over hereditarily .nite al\u00adgebraic \ndatatypes. The de.nitions of these datatypes and functions are the language-dependent part of the morphology. \nThe language\u00adindependent part consists of an untyped dictionary format which is used for synthesis of \nword forms, and a decorated trie, which is used for analysis. Functional Morphology builds on ideas introduced \nby Huet in his computational linguistics toolkit Zen, which he has used to imple\u00adment the morphology \nof Sanskrit. The goal has been to make it easy for linguists, who are not trained as functional programmers, \nto ap\u00adply the ideas to new languages. As a proof of the productivity of the method, morphologies for \nSwedish, Italian, Russian, Spanish, and Latin have already been implemented using the library. The Latin \nmorphology is used as a running example in this article. Categories and Subject Descriptors D.1.1 [Programming \nTechniques]: Applicative (Functional) Pro\u00adgramming General Terms Languages, Design, Performance  Keywords \nMorphological Description, Functional Programming, Linguistics, Embedded Languages, Finite Functions \nPermission to make digital or hard copies of all or part of this work for personal or classroom use is \ngranted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page. To copy otherwise, to republish, \nto post on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. ICFP \n04, September 19 21, 2004, Snowbird, Utah, USA. Copyright 2004 ACM 1-58113-905-5/04/0009 ...$5.00 1 Introduction \nThis paper presents a systematic way of developing natural lan\u00adguage morphologies in a functional language. \nWe think of functions and linguistic abstractions as strongly related in the sense that given a linguistic \nabstraction, it is, in most cases, natural and elegant to express it as a function. We feel that the \nmethodology presented is yet another proof of this view. An implementation of the methodology is presented, \nnamed Func\u00adtional Morphology [8]. It can be viewed as an embedded domain\u00adspeci.c language in Haskell. \nIts basis are two type classes: Param, which formalizes the notion of a parameter type, and Dict, which \nformalizes the notion of a part of speech as represented in a dic\u00adtionary. For these classes, Functional \nMorphology gives generic Haskell functions for morphological analysis and synthesis, as well as generation \nof code that presents the morphology in other formats, including Xerox Finite State Tools and relational \ndatabases. The outline of the paper is the following: The morphology task is described in section 2, \nand then the contemporary approaches are discussed in section 3. The main part of the paper, section \n4, focuses on describing the Functional Morphology library. We conclude in sections 5 and 6 with some \nresults and a discussion. 2 Morphology A morphology is a systematic description of words in a natural \nlan\u00adguage. It describes a set of relations between words surface forms and lexical forms. A word s surface \nform is its graphical or spoken form, and the lexical form is an analysis of the word into its lemma \n(also known as its dictionary form) and its grammatical description. This task is more precisely called \nin.ectional morphology. Yet another task, which is outside the scope of this paper, is deriva\u00adtional \nmorphology, which describes how to construct new words in a language. A clarifying example is the English \nword functions . The graphical form functions corresponds to the surface form of the word. A pos\u00adsible \nlexical form for the word functions is function +N +Pl +Gen. From the analysis it can be read that the \nword can be analyzed into the lemma function, and the grammatical description noun,in plu\u00adral, genitive \ncase. A morphological description has many applications, to mention a few: machine translation, information \nretrieval, spelling and gram\u00admar checking and language learning. A morphology is a key component in machine \ntranslation, assum\u00ading that the aim is something more sophisticated than string to string translation. \nThe grammatical properties of words are needed to han\u00addle linguistic phenomena such as agreement. Consider, \nfor exam\u00adple, the subject-verb agreement in English Colorless green ideas sleep furiously, not *Colorless \ngreen ideas sleeps furiously. In information retrieval, the use of a morphology is most easily ex\u00adplained \nthrough an example. Consider the case when you perform a search in a text for the word car. In the search \nresult, you would also like to .nd information about cars and car s, but no informa\u00adtion about carts \nand careers. A morphology is useful to do this kind of distinctions. 3 Implementations of Morphology \n3.1 Finite State Technology The main contemporary approach within computational morphol\u00adogy is .nite \nstate technology -the morphology is described with a regular expression [17, 26, 18, 15] that is compiled \nto a .nite state transducer, using a .nite state tool. Some of the tools available are: the commercial \ntool XFST [29], developed at Xerox, van Noord s [28] .nite state automata utilities, AT&#38;T s [19] \nFSM library and Forsberg s [6] FST Studio. Finite state technology is a popular choice since .nite state \ntrans\u00adducers provide a compact representation of the implemented mor\u00adphology, and the lookup time is \nclose to constant in the size of the lexicon. Finite state technology is based on the notion of a regular \nrelation. A regular relation is a set of n-tuples of words. Regular languages are a special case, with \nn = 1. Morphology tools such as XFST work with 2-place relations. They come with an extended regu\u00adlar \nexpression notation for easy manipulation of symbol and word pairs. Such expressions are compiled into \n.nite-state transducers, which are like .nite-state automata, but their arcs are labelled by pairs of \nsymbols rather than just symbols. Strings consisting of the .rst components of these pairs are called \nthe upper language of the transducer, and strings consisting of the second components are called the \nlower language. A transducer is typically used so that the upper language contains structural descriptions \nof word forms and the lower language contains the forms themselves. A trivial example of a regular relation \nis the description of the in\u00ad.ection of three English nouns in number. The code is XFST source code, \nwhere the |is the union operator, and .x. is the cross product of the strings. Concatenation is expressed \nby juxtaposition. NOUN = \"table\" | \"horse\" | \"cat\" INFL = NOUN .x. \"Sg\" | NOUN \"s\" .x. \"Pl\" If a transducer \nis compiled from this regular relation, and applied upward with the string \"tables\", it will return {\"Pl\"}. \nIf the built transducer is applied downward with the string \"Sg\", it will return {\"table\", \"horse\", \"cat\"}. \nOne problem with .nite-state tranducers is that cycles (correspond\u00ading to Kleene stars in regular expressions), \ncan appear anywhere in them. This increases the complexity of compilation so that it can be exponential. \nCompiling a morphological description to a trans\u00adducer has been reported to last several days, and sometimes \nsmall changes in the source code can make a huge difference. Another problem is that transducers cannot \ngenerally be made deterministic for sequences of symbols (they are of course deterministic for se\u00adquences \nof symbol pairs). This means that analysis and synthesis can be worse than linear in the size of the \ninput. 3.2 The Zen Linguistic Toolkit Huet has used the functional language Caml to build a Sanskrit \ndic\u00adtionary and morphological analysis and synthesis. [12]. He has generalized the ideas used for Sanskrit \nto a toolkit for computa\u00adtional linguistics, Zen [13]. The key idea is to exploit the expres\u00adsive power \nof a functional language to de.ne a morphology on a high level, higher than regular expressions. Such \nde.nitions are moreover safe, in the sense that the type checker guarantees that all words are de.ned \ncorrectly as required by the de.nitions of differ\u00adent parts of speech. The analysis of words in Zen is \nperformed by using tries. A trie is a special case of a .nite-state automaton, which has no cycles. As \nHuet points out, the extra power added by cycles is not needed for the morphological description inside \nwords, but, at most, be\u00adtween words. This extra power is needed in languages like Sanskrit where word \nboundaries are not visible and adjacent words can af\u00adfect each other (this phenomenon is known as sandhi). \nIt is also needed in languages like Swedish where compound words can be formed almost ad libitum, and \nwords often have special forms used in compounds. Compositions of tries, with cycles possible only on \nword boundaries, have a much nicer computational behaviour than full-scale transducers. 3.3 Grammatical \nFramework The Grammatical Framework GF [25] is a special-purpose func\u00adtional language for de.ning grammars, \nincluding ones for natural languages. One part of a grammar is a morphology, and therefore GF has to \nbe capable of de.ning morphology. In a sense, this is triv\u00adial, since morphology requires strictly less \nexpressive power than syntax (regular languages as opposed to context-free languages and beyond). At \nthe same time, using a grammar formalism for mor\u00adphology is overkill, and may result in severely suboptimal \nimple\u00admentations. One way to see the Functional Morphology library described in this paper is as a fragment \nof GF embedded in Haskell. The Param and Dict classes correspond to constructs that are hard-wired in \nGF: parameter types and linearization types, respectively. Given this close correspondence, it is no \nwonder that it is very easy to gen\u00aderate GF code from a Functional Morphology description. On the other \nhand, the way morphological analysis is implemented ef.\u00adciently using tries has later been adopted in \nGF, so that the argu\u00adment on ef.ciency is no longer so important. Thus one can see the morphology fragment \nof GF as an instance of the methodology of Functional Morphology. However, complicated morphological \nrules (such as stem-internal vowel changes) are easier to write in Haskell than in GF, since Haskell \nprovides more powerful list and string processing than GF.  4 Functional morphology 4.1 Background \nThe goal of our work is to provide a freely available open-source library that provides a high level \nof abstraction for de.ning natural language morphologies. The examples used in this article are col\u00adlected \nfrom Latin morphology. Our Latin morphology is based on the descriptions provided by [20, 5, 16, 2]. \nOur work is heavily in.uenced by Huet s functional description of Sanskrit [12] and his Zen Toolkit [13]. \nThe analyzer provided by Functional Morphology can be seen as a Haskell version of Huet s reference implementation \nin Caml. At the same time, we aim to provide a language-independent high-level front-end to those tools \nthat makes it possible to de.ne a morphology with modest training in functional programming. The idea \nof using an embedded language with a support for code generation is related to Claessen s hardware description \nlanguage Lava [4], which is compiled into VHDL. For the same reasons as it is important for Lava to generate \nVHDL the needs of the main stream community we generate regular expressions in the XFST and LEXC formats. \nFunctional Morphology is based on an old idea, which has been around for over 2000 years, that of in.ection \ntables. An in.ection table captures an in.ectional regularity in a language. A morphol\u00adogy is a set of \ntables and a dictionary. A dictionary consists of lemmas, or dictionary forms, tagged with pointers to \ntables. An in.ection table displaying the in.ection of regular nouns in En\u00adglish, illustrated with the \nlemma function, is shown below. Case Number Nominative Genitive Singular function function s Plural functions \nfunctions Different ways of describing morphologies were identi.ed by Hockett [9] in 1950 s. The view \nof a morphology as a set of in\u00ad.ection tables he calls word and paradigm. The paradigm is an in.ection \ntable, and the word is an example word that represent a group of words with the same in.ection table. \nIn a sense, the research problem of describing in.ectional mor\u00adphologies is already solved: how to fully \ndescribe a language s in.ectional morphology in the languages we studied is already known. But the are \nstill problematic issues which are related to the size of a typical morphology. A morphology covering \na dictio\u00adnary of a language, if written out in full form lexicon format, can be as large as 1-10 million \nwords, each tagged with their grammatical description. The size of the morphology demands two things: \n.rst, we need an ef.cient way of describing the words in the morphology, general\u00adize as much as possible \nto minimize the effort of implementing the morphology, and secondly, we need a compact representation \nof the morphology that has an ef.cient lookup function. 4.2 Methodology The methodology suggests that \nparadigms, i.e. in.ection tables, should be de.ned as .nite functions over an enumerable, hered- Figure \n1. Functional Morphology system overview itarily .nite, algebraic data type describing the parameters \nof the paradigm. These functions are later translated to a dictionary, which is a language-independent \ndatastructure designed to support analyzers, synthesizers, and generation of code in other formats than \nHaskell. All parameter types are instances of the Paramclass, which is an ex\u00adtension of the built-in \nEnum and Bounded class, to be able to de.ne enumerable, .nite types over hierarchical data types. Parts \nof speech are modelled by instances of the class Dict, which automate the translation from a paradigm \nto the Dictionary type. 4.3 System overview A Functional Morphology system consists of two parts, one \nlan\u00adguage dependent part, and one language independent part, illus\u00adtrated in .gure 1. The language dependent \npart is what the morphology implementor has to provide, and it consists of a type system,an in.ection \nengine and a dictionary. The type system gives all word classes and their in.ection and inherent parameters, \nand instances of the Param class and the Dict class. The in.ection machinery de.nes all valid in\u00ad.ection \ntables, i.e. all paradigms, as .nite functions. The dictionary lists all words in dictionary form with \nits paradigm in the language. De.ning the type system and the in.ection machinery can be a de\u00admanding \ntask, where you not only need to be knowledgeable about the language in question, but also have to have \nsome understanding about functional programming. The libraries provided by Func\u00adtional Morphology simpli.es \nthis step. However, when the general framework has been de.ned, which is actually a new library built \non top of ours, it is easy for a lexicog\u00adrapher to add new words, and this can be done with limited or \nno knowledge about functional programming. The lexicographer does not even have to be knowledgeable about \nthe inner workings of a morphology, it is suf.cient that she knows the in.ectional patterns of words \nin the target language.  4.4 Technical details 4.4.1 Parameter types In grammars, words are divided \ninto classes according to similarity, such as having similar in.ection patterns, and where they can occur \nand what role they play in a sentence. Examples of classes, the part of speech, are nouns, verbs, adjectives \nand pronouns. Words in a class are attributed with a set of parameters that can be divided into two different \nkinds of categories: in.ectional parame\u00adters and inherent parameters. Parameters are best explain with \nan example. Consider the Latin noun causa (Eng. cause). It is in.ected in number and case, i.e. number \nand case are the in.ectional parameters. It also has a gen\u00adder, which is an inherent parameter. The in.ection \nof causa in plu\u00adral nominative is causae, but it has feminine gender. These parameters are described \nwith the help of Haskell s data types. For example, to describe the parameters for Latin noun, the types \nGender, Case and Number are introduced. data Gender = Feminine | Masculine | Neuter deriving (Show,Eq,Enum,Ord,Bounded) \n data Case = Nominative | Genitive | Dative | Accusative | Ablative | Vocative deriving (Show,Eq,Enum,Ord,Bounded) \n data Number = Singular | Plural deriving (Show,Eq,Enum,Ord,Bounded) The in.ectional parameter types \nCase and Number are combined into one type, NounForm, that describes all the in.ection forms of a noun. \nNote that Gender is not part of the in.ection types, it is an inherent parameter. data NounForm = NounForm \nNumber Case deriving (Show,Eq) The parameter types of a language are language-dependent. A class Paramfor \nparameters has been de.ned, to make it possible to de.ne language independent methods, i.e. implement \ngeneric algorithms. class (Eq a, Show a) . Param a where values :: [a] value :: Int . a value0 :: a prValue \n:: a . String value n = values !! n value0 = value 0 prValue = show The most important method the only \none not de.ned by default is values, giving the complete list of all objects in a Param type. The parameter \ntypes are, in a word, hereditarily .nite data types: not only enumerated types but also types whose constructors \nhave arguments of parameter types. An instance of Param is easy to de.ne for bounded enumerated types \nby the function enum. enum :: (Enum a, Bounded a) . [a] enum = [minBound .. maxBound] The parameters \nof Latin nouns are made an instance of Param by the following de.nitions: instance Param Gender where \nvalues = enum instance Param Case where values = enum instance Param Number where values = enum instance \nParam NounForm where values = [NounForm nc|n <-values , c <-values] prValue (NounForm n c) = unwords \n$ [prValue n, prValue c] The default de.nition for prValue has been rede.ned for NounForm to remove \nthe NounForm constructor. Usually, a more sophisticated printing scheme is preferred, using a particular \ntag set, i.e. adopting a standard for describing the parameters of words. Latin nouns can now be de.ned \nas a .nite function, from a Noun-Form to a String. The choice of String as a return type will be problematized \nin section 4.4.5 and another type, Str, will be intro\u00adduced. type Noun = NounForm -> String More generally, \na .nite function in Functional Morphology, is a function f from a parameter type P to strings. f :: P \n-> String Note that the .nite functions have a single argument. This is, how\u00adever, not a limitation, \nbecause we can construct arbitrarily complex single types with tuple-like constructors. 4.4.2 Type hierarchy \nA naive way of describing a class of words is by using the cross product of all parameters. This would \nin many languages lead to a serious over-generation of cases that do not exist in the language. An example \nis the Latin verbs, where the cross product of the in.ec\u00adtion parameters generates 1260 forms (three \npersons, two numbers, six tenses, seven moods and .ve cases1), but only 147 forms actu\u00adally exist, which \nis just about a ninth of 1260. This problem is easily avoided in a language like Haskell that has algebraic \ndata types, where data types are not only enumerated, but also complex types with constructors that have \ntype parameters as arguments. The type system for Latin verbs can be de.ned with the data types below, \nthat exactly describes the 147 forms that exist in Latin verb conjugation: data VerbForm = Indicative \nPerson Number Tense Voice | Infinitive TenseI Voice | ParticiplesFuture Voice | ParticiplesPresent | \nParticiplesPerfect | Subjunctive Person Number TenseS Voice | ImperativePresent Number Voice | ImperativeFutureActive \nNumber PersonI | ImperativeFuturePassiveSing PersonI | ImperativeFuturePassivePl | GerundGenitive | GerundDative \n| 1The verb in.ection in case only appears in the gerund and supine mood, and only some of the six cases \nare possible. GerundAcc | GerundAbl | SupineAcc | SupineAblative This representation gives a correct \ndescription of what forms exist, and it is hence linguistically more satisfying than a cross-product \nof features. The type system moreover enables a completeness check to be performed. 4.4.3 Tables and \n.nite functions The concept of in.ection tables corresponds intuitively, in a pro\u00adgramming language, \nto a list of pairs. Instead of using list of pairs, a functional counterpart of a table a .nite function \ncould be used, i.e. a .nite set of pairs de.ned as a function. To illustrate the convenience with using \n.nite functions instead of tables, consider the in.ection table of the Latin word rosa (Eng. rose): Singular \nPlural Nominative rosa rosae Vocative rosa rosae Accusative rosam rosas Genitive rosae rosarum Dative \nrosae rosis Ablative rosa rosis The word has two in.ection parameters, case and number, that, as discussed \nin section 4.4.1, can be described in Haskell with alge\u00ad braic data types. data Case = Nominative | Vocative \n| Accusative | Genitive | Dative | Ablative data Number = Singular | Plural data NounForm = NounForm \nCase Number The in.ection table can be viewed as a list of pairs, where the .rst component of a pair \nis an in.ection parameter, and the sec\u00adond component is an in.ected word. The in.ection table of rosa \nis described, in the de.nition of rosa below, as a list of pairs. rosa :: [(NounForm,String)] rosa = \n [ (NounForm Singular Nominative,\"rosa\"), (NounForm Singular Vocative,\"rosa\"), (NounForm Singular Accusative,\"rosam\"), \n(NounForm Singular Genitive,\"rosae\"), (NounForm Singular Dative,\"rosae\"), (NounForm Singular Ablative,\"rosa\"), \n(NounForm Plural Nominative,\"rosae\"), (NounForm Plural Vocative,\"rosae\"), (NounForm Plural Accusative,\"rosas\"), \n(NounForm Plural Genitive,\"rosarum\"), (NounForm Plural Dative,\"rosis\"), (NounForm Plural Ablative,\"rosis\") \n ] The type NounForm is .nite, so instead of writing these kinds of tables, we can write a .nite function \nthat describes this table more compactly. We could even go a step further, and .rst de.ne a func\u00adtion \nthat describes all nouns that in.ects in the same way as the noun rosa, i.e. de.ning a paradigm. rosaParadigm \n:: String . Noun rosaParadigm rosa (NounForm n c) = let rosae = rosa ++ \"e\" rosis = init rosa ++ \"is\" \n in case n of Singular . case c of Accusative . rosa + \"m\" Genitive . rosae Dative . rosae _ . rosa \nPlural . case c of Nominative . rosae Vocative . rosae Accusative . rosa ++ \"s\" Genitive . rosa ++ \"rum\" \n_ . rosis It may seem that not much has been gained, except that the twelve cases have been collapsed \nto nine, and we have achieved some shar\u00ading of rosa and rosae. However, the gain is clearer when de.ning \nthe paradigm for dea (Eng. goddess), that in.ects in the same way, with the exception of two case, plural \ndative and ablative. dea :: Noun deanf = case nf of NounForm Plural Dative . dea NounForm Plural Ablative \n. dea _ . rosaParadigm dea nf where dea = \"dea\" Given the paradigm of rosa, rosaParadigm, we can describe \nthe in.ection tables of other nouns in the same paradigm, such as causa (Eng. cause) and barba (Eng. \nbeard). rosa, causa, barba :: Noun rosa = rosaParadigm \"rosa\" causa = rosaParadigm \"causa\" barba = rosaParadigm \n\"barba\"  4.4.4 Turning a function into a table The most important function of Functional Morphology \nis table, that translates a .nite function into a list of pairs. This is done by ensuring that the parameter \ntype is of the Param class, which enables us to generate all forms with the class function values. table \n:: Param a . (a . Str) . [(a,Str)] table f = [(v, f v) | v . values] A function would only be good for \ngenerating forms, but with table, the function can be compiled into lookup tables and further to tries \nto perform analysis as well. 4.4.5 String values The use of a single string for representing a word \nis too restricted, because words can have free variation, i.e., that two or more words have the same \nmorphological meaning, but are spelled differently. Yet another exception is missing forms, some in.ection \ntables may have missing cases. Free variation exists in the Latin noun domus (Eng. home) in sin\u00adgular \ndative, domui or domo, in plural accusative, domus or domos, and in plural genitive, domuum or domorum. \nMissing forms appear in the Latin noun vis (Eng. violence, force), a noun that is defective in linguistic \nterms. Singular Plural Nominative vis vires Vocative - vires Accusative vim vires Genitive - virium Dative \n- viribus Ablative vi viribus These two observations lead us to represent a word with the ab\u00adstract \ntype Str, which is simply a list of strings. The empty list corresponds to the missing case. type Str \n= [String] The Str type is kept abstract, to enable a change of the representa\u00adtion. The abstraction \nfunction is called strings. strings :: [String] . Str string = id The normal case is singleton lists, \nand to avoid the increased com\u00adplexity of programming with lists of strings, we provide the mkStr function, \nthat promotes a String to a Str. mkStr :: String . Str mkStr = (:[]) The description of missing cases \nis handled with the constant nonExist, which is de.ned as the empty list. nonExist :: Str nonExist = \n[] The in.ection table of vis can be described with the function vis below. vis :: Noun vis (NounForm \nn c) = case n of Singular . case c of Nominative . mkStr $ vi ++ \"s\" Accusative . mkStr $ vi ++ \"m\" \nAblative . mkStr vi _ . nonExist Plural . mkStr $ case c of Genitive . vir ++ \"ium\" Dative . viribus \nAblative . viribus _ . vir ++ \"es\" where vi = \"vi\" vir =vi ++ \"r\" viribus = vir ++ \"ibus\"  4.4.6 \nString operations Functional Morphology provides a set of string operation functions that captures common \nphenomena in word in.ections. Some of them are listed below to serve as examples. The string operations \ncannot be quite complete, and a morphology implementer typically has to write some functions of her own, \nre\u00ad.ecting the peculiarities of the target language. These new func\u00adtions can be supplied as an extended \nlibrary, that will simplify the implementation of a similar language. The goal is to make the li\u00adbrary \nso complete that linguists with little knowledge of Haskell can .nd it comfortable to write morphological \nrules without recourse to full Haskell. Here is a sample of string operations provided by the library. \nThe Haskell standard functions take and drop take and drop pre\u00ad.xes of words. In morphology, it is much \nmore common to consider suf.xes. So the library provides the following dual versions of the standard \nfunctions: tk :: Int . String . String tk is = take(max 0(lengths -i))s dp :: Int . String . String dp \nis = drop(max 0(lengths -i))s It is a common phenomenon that, if the last letter of a word and the .rst \nletter of an ending coincide, then one of them is dropped. (+?) :: String . String . String s +? e = \ncase (s,e) of (_:_,c:cs) | last s == c . s++ cs _ . s++ e More generally, a suf.x of a word may be dependent \nof the last letter of its stem. ifEndThen :: (Char . Bool) . String . String . String . String ifEndThen \ncond s a b = case s of _:_ | cond (last s) . a _ . b A more language dependent function, but interesting \nbecause it is dif.cult to de.ne on this level of generality with a regular expres\u00adsion, is the umlaut \nphenomenon in German, i.e. the transformation of a word s stem vowel when in.ected in plural. findStemVowel \n:: String . (String, String, String) findStemVowel sprick = (reverse rps, reverse i, reverse kc) where \n(kc, irps) = break isVowel $ reverse sprick (i, rps) = span isVowel $ irps umlaut :: String . String \numlautman =m ++ mkUma ++n where (m,a,n) = findStemVowel man mkUmv =case v of \"a\" . \"\u00a8a\" \"o\" . \"\u00a8o\" \"u\" \n. \"u\" \"au\" . \"\u00a8au\" _ . v The plural form of Baum, can be describe with the function baumPl. baumPl :: \nString . String baumPl baum = umlaut baum ++ \"e\" Applying the function baumPl with the string \"Baum\" \ncomputes to the correct plural form \"B\u00a8 aume\". Obviously, the function umlaut is a special case of a \nmore gen\u00aderal vowel alternation function, that is present in many language, for instance, in English \nin the thematic alternation of verbs such as drink-drank-drunk: vowAltern :: [(String,String)] . String \n. String vowAltern alts man = m ++ a ++ n where (m,a,n) = findStemVowel man a = maybe a id $ lookup \na alts A general lesson from vowel alternations is that words are not just strings, but data structures \nsuch as tuples.2 If regular expressions are used, these data structures have to be encoded as strings \nwith special characters used as delimiters, which can give rise to strange errors since there is no type \nchecking.  4.4.7 Exceptions Exceptions are used to describe paradigms that are similar to an\u00adother paradigm, \nwith the exception of one or more case. That is, instead of de.ning a completely new paradigm, we use \nthe old de.\u00adnition only marking what is different. This is not only linguistically more satisfying, it \nsaves a lot of work. Four different kinds of ex\u00adceptions, excepts, missing, only and variants, are listed \nbelow. The exception excepts, takes a .nite function, or a paradigm in other words, and list of exceptions, \nand forms a new .nite function with with exceptions included. excepts :: Param a . (a . Str) . [(a,Str)] \n. (a . Str) excepts f es p = maybe (f p) id $ lookup p es The paradigm of dea de.ned in section 4.4.3 \ncan be described with the function dea using the exception excepts. dea :: Noun dea = (rosaParadigm dea) \nexcepts [(NounForm Plural c, dea) | c <-[Dative, Ablative]] where dea = \"dea\" The exception functions \nmissing and only are used to express missing cases in a table; missing enumerates the cases with miss\u00ading \nforms, and only is used for highly defective words, where it is easier to enumerate the cases that actually \nexists. missing :: Param a . (a . Str) . [a] . (a . Str) missing f as = excepts f [(a,nonExist) | a . \nas] only :: Param a . (a . Str) . [a] . (a . Str) onlyf as= missingf [a |a . values, notElem a as] \nThe paradigm of vis described in section 4.4.5, can be described with the only exception and the paradigm \nof hostis (Eng. enemy). vis :: Noun vis = (hostisParadigm \"vis\") missing [ NounForm Singular c|c<-[Vocative, \nGenitive, Dative] ] An often occurring exception is additional variants, expressed with the function \nvariants. That is, that a word is in a particular paradigm, but have more than one variant in one or \nmore forms. 2E.g. in Arabic, triples of consonants are a natural way to repre\u00adsent the so-called roots \nof words. variants :: Param a . (a . Str) . [(a,String)] . (a . Str) variants f es p = maybe (f p) (reverse \n. (: f p)) $ lookup p es  4.4.8 Dictionary The Dictionary type is the core of Functional Morphology, \nin the sense that the morphology description denotes a Dictionary. The Dictionary is a language-independent \nrepresentation of a mor\u00adphology, that is chosen to make generation to other formats easy. A Dictionary \nis a listof Entry, where an Entry corresponds to a speci.c dictionary word. type Dictionary = [Entry] \n An Entry consists of the dictionary word, the part of speech (cat\u00adegory) symbol, a list of the inherent \nparameters, and the word s, lacking a better word, untyped in.ection table. type Dictionary = [Entry] \n type Entry = (Dictionary_Word, Category, [Inherent], Inflection_Table) type Dictionary_Word = String \n type Category = String type Inherent = String type Parameter = String type Inflection_Table = [(Parameter,(Attr,Str))] \n The Attr type and de.nitions containing this type concerns the handling of composite forms, that will \nbe explained later in section 4.6. To be able to generate the Dictionary type automatically, a class \nDicthas been de.ned. Only composite types, describing the in.ec\u00adtion parameters of a part of speech, \nshould normally be an instance of the Dict class. class Param a . Dict a where dictword :: (a . Str) \n. String category :: (a . Str) . String defaultAttr :: (a . Str) . Attr attrException :: (a . Str) . \n[(a,Attr)] dictword f = concat $ take 1 $ f value0 category = const \"Undefined\" defaultAttr = const \natW attrException = const [] Note that all class functions have a default de.nition, but usually we \nhave to at least give a de.nition of category, that gives the name of the part of speech of a particular \nparameter type. It s impossible to give a reasonable default de.nition of category; it would require \nthat we have types as .rst class objects. It may be surprising that category and defaultAttr are higher\u00adorder \nfunctions. This is simply a type hack that forces the inference of the correct class instance without \nthe need to provide an object of the type. Normally, the function argument is an in.ection table (cf. \nthe de.nition of entryI below). The most important function de.ned for types in Dict is entryI, which, \ngiven a paradigm and a list of inherent features, creates an Entry. However, most categories lack inherent \nfeatures, so the function entry is used in most cases, with an empty list of inherent features. entryI \n:: Dict a . (a . Str) . [Inherent] . Entry entryI f ihs = (dictword f, category f, ihs, infTable f) entry \n:: Dict a . (a . Str) . Entry entry f = entryI f [] Returning to the noun example, NounForm can be de.ned \nas an instance of the class Dict by giving a de.nition of the category function. instance Dict NounForm \nwhere category _ = \"Noun\" Given that NounForm is an instance of the Dict class, a function noun can \nbe de.ned, that translates a Noun into an dictionary entry, including the inherent parameter Gender, \nand a function for every gender. noun :: Noun . Gender . Entry noun n g = entryI n [prValue g] masculine \n:: Noun . Entry masculine n = noun n Masculine feminine :: Noun . Entry feminine n = noun n Feminine \n neuter :: Noun . Entry neuter n = Noun n Neuter Finally, we can de.ne a set of interface functions \nthat translates a dictionary word into a dictionary entry: d2servus (Eng. servant, slave), d1puella (Eng. \ngirl) and d2donum (Eng. gift, present). d2servus :: String -> Entry d2servus = masculine . decl2servus \n d1puella :: String -> Entry d1puella = feminine . decl1puella d2donum :: String -> Entry d2donum s \n= neuter . decl2donum Given these interface function, a dictionary with words can be cre\u00adated. Note \nthat the function dictionary is an abstraction function that is presently de.ned as id. latinDict :: \nDictionary latinDict = dictionary $ [ d2servus \"servus\", d2servus \"somnus\", d2servus \"amicus\", \nd2servus \"animus\", d2servus \"campus\", d2servus \"cantus\", d2servus \"caseus\", d2servus \"cervus\", d2donum \n\"donum\", feminine $ (d1puella \"dea\") excepts [(NounForm Plural c,\"dea\") | c <-[Dative, Ablative]] \n] The dictionary above consists of 11 dictionary entries, which de\u00ad.nes a lexicon of 132 full form words. \nNote that when using excep\u00adtions, the use of interface functions has to be postponed. We could de.ne \nexceptions on the entry level, but we would then loose the type safety. Even more productive are the \ninterface functions for Latin verbs. Consider the dictionary latinVerbs below, that uses the interface \nfunctions v1amare (Eng. to love) and v2habere (Eng. to have). latinVerbs :: Dictionary latinVerbs = \ndictionary $ [ v1amare \"amare\", v1amare \"portare\", v1amare \"demonstrare\", v1amare \"laborare\", v2habere \n\"monere\", v2habere \"admonere\", v2habere \"habere\" ] The dictionary latinVerbs consists of 7 dictionary \nentries, that de.nes a lexicon of as many as 1029 full form words. 4.4.9 External dictionary When a \nset of interface functions have been de.ned, we don t want to recompile the system every time we add \na new regular word. Instead, we de.ne an external dictionary format, with a translation function to the \ninternal Dictionary. The syntax of the external dictionary format is straightforward: just a listing \nof the words with their paradigms. The .rst entries of the dictionary latinVerbs are written v1amare \namare v1amare portare v1amare demonstrare v1amare laborare Notice that the external dictionary format \nis a very simple special\u00adpurpose language implemented on top of the morphology of one language. This \nis the only language that a person extending a lexi\u00adcon needs to learn. 4.4.10 Code generation The Dictionary \nformat, described in section 4.4.8, has been de\u00ad.ned with generation in mind. It is usually easy to de.ne \na transla\u00adtion to another format. Let us look at an example of how the LEXC source code is generated. \nThe size of the function prLEXC, not the details, is the interesting part. It is just 18 lines. The functions \nnot de.ned in the function, is part of Haskell s standard Prelude or the standard API of Functional Morphology. \nprLEXC :: Dictionary . String prLEXC = unlines . ([\"LEXICON Root\",[]] ++) . (++ [\"END\",[]]) . map (uncurry \nprLEXCRules) . classifyDict prLEXCRules :: Ident . [Entry] . String prLEXCRules cat entries = unlines \n$ [[],\"! category \" ++ cat,[]] ++ (map (prEntry . noAttr) entries) where prEntry (stem,_,inhs,tbl) = \nconcat (map (prForm stem inhs) (existingForms tbl)) prForm stem inhs (a,b) = unlines [x ++ \":\" ++ stem \n++ prTags (a:inhs) ++ \" # ;\"|x<-b] prTags ts = concat [\"+\" ++w|t <-ts, w <-words (prFlat t)] altsLEXC \ncs = unwords $ intersperse \" # ;\" [ s | s <-cs] Currently, the following formats are supported by Functional \nMor\u00adphology. Full form lexicon .A full form lexicon is a listing of all word forms with their analyses, \nin alphabetical order, in the lexi\u00ad con. In.ection tables. Printer-quality tables typeset in LATEX GF \ngrammar source code. Translation to a Grammatical Frame\u00adwork grammar. XML. An XML[27] representation \nof the morphological lexicon. XFST source code. Source code for a simple, non-cyclic trans\u00adducer in the \nXerox notation. LEXC source code. Source code for LEXC format, a version of XFST that is optimized for \nmorphological descriptions. Relational database. A database described with SQL source code. Decorated \ntries. An analyzer for the morphology as a decorated trie. CGI. A web server for querying and updating \nthe morphological lexicon.3  4.5 Trie analyzer The analyzer is a key component in a morphology system \n to an\u00adalyze a word into its lemma and its grammatical description. Syn\u00adthesizers are also interesting, \nthat is, given an analysis, produce the word form. In a trivial sense, an analyzer already exists through \nthe XFST/LEXC formats, but Functional Morphology also provides its own analyzer. Decorated tries is currently \nused instead of transducers for analy\u00adsis in our implementation. Decorated tries can be considered as \na specialized version of one of the languages in a transducer, that is deterministic with respect to \nthat language, hence pre.x-minimal. If we have an undecorated trie, we can also achieve total minimal\u00adity \nby sharing, as described by Huet [14]; full-scale transducers can even achieve suf.x sharing by using \ndecorated edges. This ap\u00adproach has been used by Huet [12], when de.ning a morphology for Sanskrit. The \ntrie is size-optimized by using a symbol table for the return value (the grammatical description). 4.6 \nComposite forms Some natural languages have compound words words composed from other words. A typical \nexample is the (outdated) German word for a computer, Datenverarbeitungsanlage, composed from Daten, \nVerarbeitung, and Anlage. If such words are uncommon, they can be put to the lexicon, but if they are \na core feature of the language (as in German), this productivity must be described in the morphol\u00adogy. \nHighly inspired by Huet s glue function [14], we have solved the problem by tagging all words with a \nspecial type Attr that is just a code for how a word can be combined with other words. At the analysis \nphase, the trie is iterated, and words are decomposed according to these parameters. The Attr type is \nsimply a integer. Together with a set of constants 3In a previous version, a CGI morphology web server \nwas gen\u00aderated. Meijer s [21] CGI library was used, further modi.ed by Panne. There exists a prototype \nweb server [7] for Swedish. How\u00adever, the CGI implementation scaled up poorly, so it is no longer generated. \nThis is to be replaced by a SQL database and PHP. atW, atP, atWP and atS, we can describe how a word \ncan be com\u00adbined with another. The atW for stand-alone words, atP for words that can only be a pre.x \nof other words, atWP for words that can be a stand-alone word and a pre.x, and .nally, atS, for words \nthat can only be a suf.x of other words. type Attr = Int atW, atP, atWP, atS :: Attr (atW, atP, atWP, \natS) = (0,1,2,3) As an example, we will describe how to add the productive question particle ne in Latin, \nthat can be added as a suf.x to any word in Latin, and has the interrogative meaning of a questioning \nthe word. We begin by de.ning a type for the particle, and instantiate it in Param. The Invariant type \nexpresses that the particle is not in\u00ad.ected. data ParticleForm = ParticleForm Invariant deriving (Show,Eq) \n type Particle = ParticleForm -> Str instance Param ParticleForm where values = [ParticleForm p | p \n<-values] prValue _ = \"Invariant\" We continue by instantiating ParticleForm in Dict, where we also \ngive a de.nition for defaultAttr with atS, that expresses that the words of this form can only appear \nas a suf.x to another word, not as a word on its own. instance Dict ParticleForm where category _ = \"Particle\" \ndefaultAttr _ = atS We then de.ne an interface function particle and add ne to our dictionary. makeParticle \n:: String -> Particle makeParticle s _ = mkStr s particle :: String -> Entry particle = entry . makeParticle \n dictLat :: Dictionary dictLat = dictionary $ [ ... particle \"ne\" ] Analyzing the word servumne, \nthe questioning that the object in a phrase is a slave or a servant, gives the following analysis in \nFunc\u00adtional Morphology: [ <servumne> Composite: servus Noun -Singular Accusative -Masculine | # ne \nParticle -Invariant -]   5 Results The following morphologies have been implemented in Functional Morphology: \na Swedish in.ection machinery and a lexicon of 15,000 words [8]; a Spanish in.ection machinery + lexicon \nof 10,000 words [1]; major parts of the in.ection machinery + lexicon for Russian [3], Italian [24], \nand Latin [8]. Comprehensive in.ec\u00adtion engines for Finnish and French have been written following the \nsame method but using GF as source language [23] One interesting fact is that the Master students had \nvery limited knowledge of Haskell before they started their projects, but still managed to produce competitive \nmorphology implementations. An interface between morphology and syntax, through the Gram\u00admatical Framework, \nexists. An implemented morphology can di\u00adrectly be used as a resource for a grammatical description. \nThe analyzer tags words with a speed of 2k-50k words/second (de\u00adpending on how much compound analysis \nis involved), a speed that compares with .nite state transducers. The analyzer is often com\u00adpiled faster \nthan XFST s .nite state transducers, because Kleene s star is disallowed within a word description. \n6 Discussion One way of viewing Functional Morphology is as a domain speci.c embedded language [10, 11], \nwith the functional programming lan\u00adguage Haskell [22] as host language. There are a lot of features \nthat make Haskell suitable as a host lan\u00adguage, to mention a few: a strong type system, polymorphism, \nclass system, and higher-order functions. Functional Morphology uses all of the mentioned features. One \ncould wonder if the power and freedom provided by a general\u00adpurpose programming language does not lead \nto problems, in terms of errors and inconsistency. Functional Morphology avoids this by requiring from \nthe user that the de.nition denotes an object of a given type, i.e. the user has full freedom to use \nthe whole power of Haskell as long as she respects the type system of Functional Morphology. Embedding \na language into another may also lead to ef.ciency issues an embedded language cannot usually compete \nwith a DSL that has been optimized for the given problem domain. This is avoided in Functional Morphology \nby generating other formats which provide the ef.ciency needed. A simple representation of the morphology \nin the core system has been chosen, which enables easy generation of other formats. This approach makes \nthe framework more easily adaptable to future ap\u00adplications, which may require new formats. It also enforces \nthe single-source idea, i.e. a general single format is used that gener\u00adates the formats of interest. \nA single source solves the problems of maintainability and inconsistency. Programming constructs and \nfeatures available in a functional framework make it is easier to capture generalizations that may even \ntranscend over different languages. It is no coincidence that Spanish, French and Italian are among the \nlanguages we have im\u00adplemented: the languages morphology are relatively close, so some of the type systems \nand function de.nitions could be reused. We believe that we provide a higher level of abstraction than \nthe mainstream tools using regular relations, which results in a faster development and easier adaption. \nNot only does the morphology implementor have a nice and .exible framework to work within, but she gets \na lot for free through the translators, and will also pro.t from further development of the system. \n7 References [1] I. Andersson and T. S\u00a8oderberg. Spanish Morphol\u00adogy implemented in a functional programming \nlan\u00adguage. Master s Thesis in Computational Linguistics, 2003. http://www.cling.gu.se/theses/finished.html. \n[2] C. E. Bennett. A Latin Grammar. Allyn and Bacon, Boston and Chicago, 1913. [3] L. Bogavac. Functional \nMorphology for Russian. Master s Thesis in Computing Science, 2004. [4] K. Claessen. An Embedded Language \nApproach to Hardware Description and Veri.cation. PhD thesis, Chalmers Univer\u00adsity of Technology, 2000. \n[5] E. Conrad. Latin grammar. www.math.ohio-state.edu/ econrad/lang/latin.html, 2004. [6] M. Forsberg. \nFststudio. http://www.cs.chalmers.se/ markus/fstStudio [7] M. Forsberg and A. Ranta. Svenska ord. http://www.cs.chalmers.se/ \nmarkus/svenska, 2002. [8] M. Forsberg and A. Ranta. Functional morphology. http://www.cs.chalmers.se/ \nmarkus/FM, 2004. [9] C. F. Hockett. Two models of grammatical description. Word, 10:210 234, 1954. [10] \nP. Hudak. Building domain-speci.c embedded languages. ACM Computing Surveys, 28(4), 1996. [11] P. Hudak. \nModular domain speci.c languages and tools. In P. Devanbu and J. Poulin, editors, Proceedings: Fifth \nInterna\u00adtional Conference on Software Reuse, pages 134 142. IEEE Computer Society Press, 1998. [12] G. \nHuet. Sanskrit site. Program and documentation, http://pauillac.inria.fr/ huet/SKT/, 2000. [13] G. Huet. \nThe Zen Computational Linguistics Toolkit. http://pauillac.inria.fr/ huet/, 2002. [14] G. Huet. Transducers \nas lexicon morphisms, phonemic segmentation by euphony analysis, application to a sanskrit tagger. Available: \nhttp://pauillac.inria.fr/ huet/FREE/, 2003. [15] L. K. Kenneth R. Beesley. Finite State Morphology. CSLI \nPublications, United States, 2003. [16] G. Klyve. Latin Grammar. Hodder &#38; Stoughton Ltd., Lon\u00addon, \n2002. [17] K. Koskenniemi. Two-level morphology: a general computa\u00adtional model for word-form recognition \nand production. PhD thesis, University of Helsinki, 1983. [18] G. G. L. Karttunen, J-P Chanond and A. \nSchille. Regular expressions for language engineering. Natural Language En\u00adgineering, 2:305 328, 1996. \n[19] A. Labs-Research. At&#38;t fsm library. http://www.research.att.com/sw/tools/fsm/. [20] J. Lambek. \nA mathematician looks at the latin conjugation. Theoretical Linguistics, 1977. [21] E. Meijer and J. \nvan Dijk. Perl for swine: Cgi programming in haskell. Proc. First Workshop on Functional Programming, \n1996. [22] S. Peyton Jones and J. Hughes. Report on the Programming Language Haskell 98, a Non-strict, \nPurely Functional Lan\u00adguage. Available from http://www.haskell.org, February 1999. [23] A. Ranta. Grammatical \nFramework Homepage, 2000 2004. www.cs.chalmers.se/ aarne/GF/. [24] A. Ranta. 1+n representations of Italian \nmorphology. Essays dedicated to Jan von Plato on the occasion of his 50th birth\u00adday, http://www.valt.helsinki.fi/kfil/jvp50.htm, \n2001. [25] A. Ranta. Grammatical Framework: A Type-theoretical Grammar Formalism. The Journal of Functional \nProgram\u00adming, 14(2):145 189, 2004. [26] M. K. Ronald M. Kaplan. Regular Models of Phonologi\u00adcal Rule \nSystems. Computational lingustics, pages 331 380, 1994. [27] The World Wide Web Consortium. Extensible \nMarkup Lan\u00adguage (XML). http://www.w3.org/XML/, 2000. [28] G. van Noord. Finite state automata utilities. \nhttp://odur.let.rug.nl/ vannoord/Fsa/ [29] Xerox. Xerox .nite-state compiler. http://www.xrce.xerox.com/competencies \n/content-analysis/fsCompiler/.  \n\t\t\t", "proc_id": "1016850", "abstract": "This paper presents a methodology for implementing natural language morphology in the functional language Haskell. The main idea behind is simple: instead of working with untyped regular expressions, which is the state of the art of morphology in computational linguistics, we use finite functions over hereditarily finite algebraic datatypes. The definitions of these datatypes and functions are the language-dependent part of the morphology. The language-independent part consists of an untyped dictionary format which is used for synthesis of word forms, and a decorated trie, which is used for analysis.Functional Morphology builds on ideas introduced by Huet in his computational linguistics toolkit Zen, which he has used to implement the morphology of Sanskrit. The goal has been to make it easy for linguists, who are not trained as functional programmers, to apply the ideas to new languages. As a proof of the productivity of the method, morphologies for Swedish, Italian, Russian, Spanish, and Latin have already been implemented using the library. The Latin morphology is used as a running example in this article.", "authors": [{"name": "Markus Forsberg", "author_profile_id": "81100249318", "affiliation": "Chalmers University of Technology and the University of Gothenburg", "person_id": "PP25002194", "email_address": "", "orcid_id": ""}, {"name": "Aarne Ranta", "author_profile_id": "81100455778", "affiliation": "Chalmers University of Technology and the University of Gothenburg", "person_id": "PP17010143", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1016850.1016879", "year": "2004", "article_id": "1016879", "conference": "ICFP", "title": "Functional morphology", "url": "http://dl.acm.org/citation.cfm?id=1016879"}