{"article_publication_date": "09-19-2004", "fulltext": "\n A Sound (and Complete) Model of Contracts Matthias Blume David McAllester Toyota Technological Institute \nat Chicago Toyota Technological Institute at Chicago blume@tti-c.org mcallester@tti-c.org Abstract Even \nin statically typed languages it is useful to have certain invari\u00adants checked dynamically. Findler and \nFelleisen gave an algorithm for dynamically checking expressive higher-order types called con\u00adtracts. \nIf we postulate soundness (in the sense that whenever a term is accused of violating its contract it \nreally does fail to satisfy it), then their algorithm implies a semantics for contracts. Unfortu\u00adnately, \nthe implicit nature of the resulting model makes it rather unwieldy. In this paper we demonstrate that \na direct approach yields es\u00adsentially the same semantics without having to refer to contract\u00adchecking \nin its de.nition. The so-de.ned model largely coincides with intuition, but it does expose some peculiarities \nin its inter\u00adpretation of predicate contracts where a notion of safety (which we de.ne in the paper) \nleaks into the semantics of Findler and Felleisen s original unrestricted predicate contracts. This counter-intuitive \naspect of the semantics can be avoided by changing the language, replacing unrestricted predicate contracts \nwith a restricted version. The corresponding loss in expressive power can be recovered by also providing \na way of explicitly ex\u00adpressing safety as a contract either in ad-hoc fashion or, e.g., by including \ngeneral recursive contracts. Categories and Subject Descriptors: D.3.1 Programming Lan\u00adguages: Formal \nDe.nitions and Theory semantics General Terms: Languages, Theory, Veri.cation Keywords: contracts, predicates, \nsafety 1 Introduction Static types can serve as a powerful tool for expressing program invariants that \na compiler can verify. Yet, many invariants a com\u00adpiler cannot enforce. It is therefore useful to allow \nfor dynamic checks of runtime properties of programs, regardless of whether the language is statically \ntyped or not. Many languages have mech\u00adanisms for reporting abnormal situations that arise at runtime. \nFor example, in the ML programming language [13, 12] one typically Permission to make digital or hard \ncopies of all or part of this work for personal or classroom use is granted without fee provided that \ncopies are not made or distributed for pro.t or commercial advantage and that copies bear this notice \nand the full citation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. ICFP 04, September 19 21, 2004, Snowbird, Utah, \nUSA. Copyright 2004 ACM 1-58113-905-5/04/0009 ...$5.00 raises an exception when an intended program invariant \nis violated. While these mechanisms enable people to program defensively in an ad-hoc manner, they are \nan inappropriate basis for designing, implementing, and composing program components. Findler and Felleisen \nintroduced the notion of contracts [9]as a more systematic way of expressing and monitoring runtime invari\u00adants. \nContracts are a form of types too expressive for static veri.ca\u00adtion, but an implementation such as the \nDrScheme system [8, 5] can provide a meaningful way of checking contracts dynamically. The contract checker \nautomatically raises exceptions called contract ex\u00adceptions. Once an exception indicates the violation \nof an intended invariant one would like to identify the part of the program (the module) that is actually \nin error. Thus, a raised contract exception should blame a speci.c contract declaration. To be somewhat \nmore concrete, con\u00adsider a program of the form let x1: t1 = e1 in ...let xn : tn = en in xn where each \nti is a closed contract expression acting as the interface of module ei. Findler and Felleisen give an \nalgorithm for assign\u00ading blame to one of the ei in the case when a contract exception is raised. Intuitively, \nthis means that ei does not satisfy contract ti,but the concept of contract satisfaction had not actually \nbeen de.ned formally. Still, we can view the algorithm as implying a seman\u00adtics of contracts. In particular, \nwe can say e satis.es t unless there is some program for which the algorithm claims otherwise. More formally, \nlet [[t]]FF be the set of values that the Findler-Felleisen contract checking algorithm cannot blame \nfor violating t. It is important to show that the Findler-Felleisen algorithm is cor\u00adrect. This means \nthat when the algorithm blames a contract decla\u00adration, that contract declaration is actually wrong. \n[[\u00b7]]FF as infor\u00admally de.ned above makes correctness vacuously true, because a declaration is wrong \nby de.nition if the algorithm blames it. A more meaningful notion of correctness must be based on an \ninde\u00adpendent de.nition of the meaning of contracts, preferably de.ned in a mostly compositional manner, \nfor example the one we give in this paper. A compositional semantics is desirable because the structure \nof [[\u00b7]]FF is not at all obvious. With just the informal de.nition given above, an answer to the question \nDoes e satisfy t? is dif.cult because it requires consideration of all possible contexts for e. In\u00addeed, \nsome aspects of [[\u00b7]]FF do turn out to be counterintuitive. An important part of the Findler-Felleisen \ncontract language are pred\u00adicate contracts, here written (f), which are checked by applying their predicate \nf to the value in question. An exception is raised if the result is not true. In particular, checking \n(.x.1), where the predicate is always true, is a no-op. One might expect every value to satisfy (.x.1) \nand, consequently, the identity function .x.x to  i, j,... .I ::= 0 |1 |... x,y,... .Var ::= x |y |... \nF ::=+ |-|<|=|... elements common to both external and internal languages   Var te .T e ::= int |safe \n|Te Vart .T ::= int |safe |T .T |(T ;.Var.P ) .T e |(T e;.Var.P e) fe .P e ::= P0e|(P e Var) f .P ::= \nP0|(P Var). e P0 . Ee closed predicate terms P0 . E closed predicate terms . .X ::= .|T0 |T1 |T2 |... \n ee .Ee ::= Var |I |.Var.Ee |(Ee Ee) |F(Ee ,...,Ee) e .E ::= Var |I |.Var.E |(EE)X |FX (E,...,E) | (W \nX,XE) |E?XE T p .P ::= Var |let Var : Te = Ee in P Figure 1. External language Figure 2. Internal language \nCt (int)= int Ct (safe)= safe C. e(i ;G)= i xx Ct (te .te = Ct (te .Ct (te C. e(x;G)= x ;x. domain(G) \n12 ) 1 ) 2 ) Ct ((te;.x.ee ))= (Ct (te);.x.Ce (ee;0/ )) . C. e(x;G)= (W .,.' x) ;G(x)=(.',t) t ee ee \n,. C e 2);G)= (Ce 1;G) C e 2;G)) C p(x;G)= (W .x) G(x)=(.,t) t . ((e1 e. (e. (e. ee C e e )= .x.C e \ne;G |) C p(let x : te = e1 in e2;G) = ((.x.e2 ) e1). . (.x.e. (e= x ee = C p(e.(Ti ee ee where e1 = \nCTei (e1;G); e2 2;G,x ,Ct (te))); C. e( f (e1,...,ek );G)= f.(C. e(e1;G),...,C. e(ek ;G)) i uniquely \nidenti.es the module named x Figure 3. Translation from external to internal language. satisfy (int \n.int) .(.x.1 ). (Every legal argument would be a legal result.) But DrScheme disagrees. When evaluating \nthe fol\u00adlowing example (translated to Scheme) in DrScheme, the identity f is blamed for violating (int \n.int) .(.x. 1): let f : (int .int) .(.x.1 )= .y.y in (( f .z.z) .w.w) We account for this effect by interpreting \n(.x. 1)as the set of safe values (see Section 2.9). Not all values satisfying int .int are safe, justifying \nthe claim that the identity violates (int .int) .(.x. 1). As a non-trivial theorem we prove that the \nFindler-Felleisen algo\u00adrithm is sound and complete with respect to our semantics. Sound\u00adness and completeness \ntogether mean that this semantics is equiva\u00adlent to [[\u00b7]]FF. For a given interpretation [[\u00b7]] of contracts, \nwe call the contract checking algorithm sound if blame on a module ei is explained by the fact that ei \nviolates one of it contract interfaces. If ei is closed this says that its evaluation result (written \n[[ei]]) is not in [[ti]].If ei contains free references to variables xj (with j < i)it means that there \nare values v1 .[[t1]],...,vi-1 .[[ti-1]] such that produces a result that is not in [[ti]].1 Soundness \nei[vj/xj] j=1...i-1 relative to [[\u00b7]] can be stated as .t.[[t]] .[[t]]FF. Conversely, we say that the \nalgorithm is complete with respect to the semantics if the contract checker can detect every interface \nvi\u00adolation in at least one context. Concretely, let e have free variables x1,...,xi-1. If there are values \nv1,...,vi-1 satisfying t1,...,ti-1 such that the result of e[vj/xj] j=1...i-1 is not in [[t]], then there \nare 1As usual, we write A[B/x] for the term A' obtained from A by substituting B in a capture-free manner \nfor all free occurrences of x in A. terms e1,...,ei-1 and some p such that running the algorithm on let \nx1: t1 = e1 in ... let xi-1: ti-1 = ei-1 in let xi : t = e in p results in e being blamed. Completeness \nrelative to [[\u00b7]] can be stated as .t.[[t]] .[[t]]FF. Soundness and completeness together im\u00adply [[\u00b7]] \n= [[\u00b7]]FF. The remainder of this paper is organized as follows: In Section 2 we formally introduce our \nterm-and contract\u00adlanguages together with a corresponding operational semantics of terms and an interpretation \n[[\u00b7]] for contracts as sets of values. We also give several de.nitions of safety a concept central to \nthis paper and prove them pairwise equivalent. In Section 3 we state the central lemma and use it to \nsketch the proof of soundness for [[\u00b7]]. The next two sections are devoted to proofs of the central lemma: \nin Section 4 we take a step back and prove it in a setting that as\u00adsumes all predicates in contracts \nto be total. This simpli.cation al\u00adlows us to show the main idea of the proof without getting bogged \ndown in details of dealing with contracts that have effects. It also allows us to prove that [[\u00b7]] is \nmaximal and therefore coincides with [[\u00b7]]FF. Section 5 then proves soundness (but not completeness) \nin the general case where predicates in contracts may diverge. Before we conclude in Section 7 we take \na brief excursion and discuss the addition of recursive contracts in Section 6. Recursive types have \nvarious practical applications, for example, the encoding of object types [2], but we also .nd that they \nprovide yet another angle from which to understand the notion of safety that is so central to our proofs \nand our results.  2 The formal setting We consider programs at two different language levels: an ex\u00adternal \nand an internal one.2 The former can be thought of as a syntactically-sugared re.nement of the latter. \n2.1 Syntax At their core, both external and internal languages (see Figures 1 and 2) consist of untyped \n.-calculi with constants. As usual, there are variables x,y,... . Var, .-abstractions .x.e, and applications \n(e1 e2). For simplicity we restrict ourselves to integer constants 0,1,... . I and some primitive operations \nlike + (addition) or > (comparison) over such integers. (In examples we often use in\u00ad.x notation for \nthose.) For boolean values we use the convention: 1 = true,everything else = false. Either language makes \nuse of a sub-language of contract expres\u00adsions consisting of int (the contract satis.ed by all integer \nvalues); x dependent function contracts t1 . t2 (satis.ed by functions that take values v satisfying \nt1 to values satisfying t2[v/x]) and their non\u00addependent special case t1 . t2; the contract safe of safe \nvalues; and restricted predicate contracts (t;f) (satis.ed by values v also satis\u00adfying t such that f \napplied to v yields true). The unrestricted version of predicate contracts (f) shown in the introduction \nis not explicitly part of our languages and should be thought of as an abbreviation for the operationally \nequivalent (safe;f). External: Programs in external form are closed terms ee let x1: te = e1 in ...let \nxn : te = ein xn 1 nn where the ee i are individual modules bound to module identi.ers xi. The module \ninterface of ee i is governed by contract ti e. The scope of each let-bound xi consists of everything \nto the right of ee i (i.e., ee i+1,...,ee n,xn). Predicates in predicate contracts within the te are \ni taken from the expression language. Module interfaces are the only place where contract expressions \nti e can appear. Moreover, without loss of generality we require each such contract te to be closed. \n(The effect of a free occurrence of xj i in te can be simulated by abstracting from xj in both ee (using \n.) ii and in ti e (using a dependent function contract).) Internal: The internal language makes pervasive \nuse of contract exceptions T1 ,T2 ,... as well as the pseudo-exception .. When an exception Ti is raised, \nthe entire program immediately termi\u00adnates, producing Ti as the .nal result. Raising ., however, causes \nthe program to diverge. (We use . as a technical device to make characterization and construction of \nsafe expressions easier.) One use of exceptions is to signal violations of language contracts: applications \nof non-functions or ill-typed (i.e., non-integer in our case) arguments to primitive operations. For \nthis, they appear as annotations on all applications (e1 e2). and on all primitive opera\u00ad tions f.(e1,...,ek).3 \nThere are also two additional expression forms: Wrapped expressions (W .' ,. e) represent module contracts \nt and are at the heart of contract checking. They act as guards looking for evidence of violations of \ncontract t by either e or 2In practice there often will be a third level: a statically typed surface \nlanguage. Here we assume that static types if origi\u00adnally present have been checked and erased. Appendix \nB brie.y touches upon the likely interaction between static types and con\u00adtracts. In general it suf.ces \nto assume a dynamically typed setting. 3A static type system can often eliminate the need for language \ncontracts, but we do not make this assumption here. the context. If evidence for e violating t is found, \nthen excep\u00adtion . is raised. Similarly, when it is detected that the context tries to use e in a way \nthat is not consistent with t, then .' is raised. The one-armed conditional e1?.e2 evaluates to the value \nof e2 if e1 evaluates to true. If e1 does not evaluate to true, then . is raised. (This form was added \nto make it easier to state the operational semantics of predicate contract wrappers.) There is no let-form \nin the internal language. Instead, module boundaries and the contracts governing their interfaces are \nex\u00adpressed using wrapped terms and function application. 2.2 From external to internal syntax Figure \n3 shows the de-sugaring translation from external to in\u00adternal syntax. The idea is to arrange for Ti \nto be raised when the contract checker .nds evidence for ee i not respecting its contracts. e There are \nthree ways in which a module ei of the external language can fail to respect its contracts: 1. Its value \nmight not satisfy its export interface ti e. 2. It might try to use xj (where xj is one of its free \nvariables) in a way that is not consistent with the import interface te j . 3. It might use one of the \nlanguage s primitive operations incor\u00adrectly4 (trying to apply an integer, passing a non-integer or the \nwrong number of arguments to one of the built-in operations).  The translation from external to internal \nlanguage re.ects this clas\u00adsi.cation: contract exception Ti appears 1. in W .,Ti which is wrapped around \nuses of xi, ti ,. e 2. in W Ti which is wrapped around uses of xj within e tj i , 3. and as an annotation \non every application and built-in opera\u00ad e tion within the translation of ei . The translator is given \nin three parts: C. e(ee;G) annotates appli\u00adcations and primitive operations within ee with exception \n. and replaces free occurrences of variables bound in G with wrapped versions of these variables; Ct \n(te) translates external contracts to internal ones; C p(p;G) translates let-expressions. Environments \nG are used to map let-bound module identi.ers to their respective module exceptions and translated contracts. \nThus, a closed external program p is translated using C p(p;0/). The statement of our central lemma (Lemma \n5) requires that predi\u00adcates within contracts do not raise contract exceptions of their own. This property, \nformally captured by the notion of safe contracts,is guaranteed in part by the fact that Ct (\u00b7) never \ninserts wrapper ex\u00adpressions while arti.cially using . for all language contracts (ap\u00adplications and \nprimitive operations), thus sending the program into an in.nite loop as opposed to having it raise an \nunaccounted-for contract exception should a predicate violate one of these. In a practical implementation \nit makes sense to use a separate Tcontract instead of . for this purpose, effectively putting contracts \non contract predicates. To account for Tcontract, most of the de.\u00adnitions and proofs in this paper would \nhave to be adjusted, making them super.cially (but not intrinsically) more complicated. Since the increased \ncomplexity does not pay off, we do not explore this direction here.  2.3 Core semantics We follow Felleisen \nand Hieb [6] and make use of evaluation con\u00adtexts to specify the operational semantics of the internal \nlanguage (see Figure 4). Every closed expression e . E that is not a value 4One can think of this as \nhaving contract wrappers on those primitive operations (and even implement it that way).  V V * Ce C \n::= ::= ::= ::= I | .Var.E values V | X results {\u00b7} | evaluation contexts (Ce E)X | (VCe)X | FX (V,...,V,Ce,E,...,E) \n| (W X,X T Ce) | Ce?X E | V ?X Ce [\u00b7] | contexts .Var.C | (CE)X | (EC)X | FX (E,...,E,C,E,...,E) | (W \nX,X T C) |C?X E | E?X C v .0 v e = ce{e ' } e ' . e '' ce[e ''].nv e.n+1v f.(i1,...,ik) . A( f ,i1,...,ik) \n((.x.e) v). . e[v/x] . v (W .' ,. int i) . i (W .' ,. safe v) . v (W .' ,. t1 z.t2 .x.e) . .y.(W .' ,. \nt2[(W .,.' t1 y)/z] ((.x.e) (W .,.' t1 y)).) (W .' ,. (t;.x.e) v) . ((.x.e) (W .,. t v)).?.(W .' ,. t \nv) ( ) ce{(i v)Tj } ce{ f j T(v1,...,.x.e,...,vk )} ce{(W .,Tj int .x.e)} ce{(W .,Tj t1 x.t2 i)} ce{v?Tj \nv ' } .0 .0 .0 .0 .0 Tj Tj Tj Tj Tj ;v = 1 (i v). f.(v1,...,.x.e,...,vk ) (W .,. int .x.e) (W .,. t1 \nx.t2 i) v?.v ' . . . . . ((.x.(xx).) .x.(xx).). ((.x.(xx).) .x.(xx).). ((.x.(xx).) .x.(xx).). ((.x.(xx).) \n.x.(xx).). ((.x.(xx).) .x.(xx).). ;v = 1 Figure 4. Operational semantics of the internal language. v \n.V has a unique decomposition into an evaluation context ce .Ce ' and a current \u00dfv-redex e . E; we write \ne = ce{e '} for this. Eval\u00aduation proceeds by repeatedly replacing the current redex with its corresponding \n1-step reduction until a value is reached or a contract exception is raised.5 Evaluation immediately \nterminates with a non-value result of Tj if the contract exception Tj gets raised at any point during \nevaluation. Raising the pseudo-exception . is modeled by replacing the current redex with an in.nite \nloop. Evaluation of e either diverges or produces a result r (either in V or some Tj) after k steps. \nThe latter fact is expressed by the relation e.kr. The valuation function [[\u00b7]] from closed expressions \nto results is de.ned as follows: e.kr . [[e]] = r (.k,r.\u00ac(e.kr)) . [[e]] = . It is easy to check that \nthe full set of rules given here is exhaustive. This means that there are no stuck terms in the internal \nlanguage. The meaning of built-in primitives is assumed to be given by the semantic function A.  2.4 \nContract checking The heart of the contract checker is the set of rules dealing with the case when the \ncurrent redex is a wrapped expression (W.' ,. v). t These rules are directed by the syntax of the contract \nt.If t is safe, then the wrapper acts as an identity function; if t is int, then the wrapper checks v \nfor being an integer, raising . if it is not. x If t is a (potentially dependent) function contract t1 \n. t2, then v is .rst checked for being a .-term. If that is the case, then rule ( ) '' 5Notice that e \n= ce{e '} and e ' . e does not imply that substi\u00ad '' ''tuting e for {\u00b7} in ce has the form ce{e ''} since \nin general e is not ''] the next current redex. For this reason we use the notation ce[e when substituting \ninto the hole of an evaluation context (just like we do when substituting into the hole of a general \ncontext c . C). applies: the wrapper constructs a function that .rst accepts an argu\u00adment y and wraps \nit using contract t1, then applies v to the wrapped y, and .nally wraps the result using contract t2 \nwhere (a wrapped version of) the original argument y has been substituted for x. The original exception \nsuperscripts appear in reversed order in the argu\u00adment wrapper a detail that is a crucial aspect of Findler-Felleisen\u00adstyle \ncontract checking since it re.ects the role reversal between the producer of a value and its context. \nSuch role reversals take place at the domain part of function contracts, the intuition behind it being \nthat a value f acts as the context of any arguments that f is applied to, whereas the context of f is \nsupplying these argument values. Formally, the rule follows the standard construction for projections. \nIndeed, contract wrappers are idempotent, so we can view them as retractions.6 If t is a restricted predicate \ncontract (t ' ;f), then v is wrapped using t ' and checked for satisfying the predicate f. When an arbitrary \nvalue v meets predicate code (which happens when a predicate is applied to v or when v is substituted \ninto a de\u00adpendent type), v gets wrapped with a special wrapper where the ex\u00adception dedicated to blaming \nthe context (i.e., the predicate code) is .. This technical device is part of our effort of maintaining \nsafety of contracts. As hinted in Section 2.2, a practical implementation should use some Tcontract instead \nof .. We give an operational semantics to external programs by way of their translation into E. Thus, \n[[ p]]e is de.ned to be the same as [[C p( p;0/)]]. In the following examples, it is instructive to verify \nhow the rule 6Unfortunately, the corresponding retracts do not coincide with the interpretation of contracts \nthat we would like to use, which is why we have not pursued this direction here (but elsewhere [7]). \nFor example, we want .x.x : int . int to be true, but no term equivalent to .x.x is in the image of W \n.,.' . int.int for any .,.' e : t . [[e]] .[[t]] .{.} [[int]] = { 0, 1,...} [[safe]] = Safe x [[t1 .t2]] \n= {.y.e |.v .[[t1 ]].e[v/y] : t2[v/x]}[[(t;.x.e)]] = {v .[[t]] |[[e[v/x]]] .{ 1,.}} [[te]]e = [[Ct (te)]] \nFigure 5. Semantics of contracts. marked ( ) in Figure 4 produces the results in cases (2) and (3): ((W \nT1 ,T2 int.int 0) 1) . T2 (1) ((W T1 ,T2 int.int .x.x + 1) .y.y) . T1 (2) ((W T1 ,T2 int.int .x..y.x) \n2) . T2 (3) ((W T1 ,T2 int.int .x.x + 1) 1) . 2 (4) 2.5 Semantic equivalence '' We write e ~= e to say \nthat e and e are semantically equivalent, i.e., that there is no context c .C that could distinguish \nbetween the two: '' ([[c[e]]] .[[int]] .X .[[c[e ]]] .[[int]] .X) . [[c[e ]]] = [[c[e]]] '' ' We will \nalso use the notation e =e for e,e .E (or t =t for t,t '. T )if e ' (or t ') can be obtained from e (or \nt) by replacing zero or more occurrences of T with .. We write leJ and lcJ to denote the expression or \ncontext obtained from e or c by replacing every occurrence of T(regardless of label) with .(implying \nleJ=e). LEMMA 1. If e '=e then the following is true: [[e ']] = Ti .[[e]] = Ti [[e]] = ..[[e ']] = . \n[[e]] = i .[[e ']] = i PROOF SKETCH. By showing that the rules of the operational se\u00admantics preserve \nthe = relation on terms until an exception is raised. 2.6 Semantic interpretation of contracts The interpretation \nof a contract t is some set [[t]] .V . A closed ex\u00adpression e is said to satisfy t (written e : t) if \nit either diverges or pro\u00adduces a result in [[t]]. The rules in Figure 5 de.ne [[t]] for contracts t \n.T . The semantics [[\u00b7]]e for the external contract language Te is handled by viewing it as a re.nement \nof T . (This means that exter\u00adnal types are interpreted as sets of internal values. See Appendix B for \na justi.cation.) The de.nition of Safe is given in Section 2.9. Notice that the semantics of contracts \ninvokes the operational se\u00admantics for terms re.ecting the fact that contract satisfaction is determined \nbased on runtime behavior. Any diverging term satis.es all contracts while a term whose eval\u00aduation raises \nsome contract exception Ti satis.es no contract. For\u00adtunately, the same is true under [[\u00b7]]FF.If e satis.es \nt under [[\u00b7]]FF then (W .' ,. v) should not raise . in any context c .C that does not t contain . (assuming \n. = .'). However, this condition is violated if e itself raises .. 2.7 Findler-Felleisen-style contract \nchecking We found it remarkable that contract checking works at all, i.e., that one can prove it sound \nwith respect to a simple compositional semantics. Checking higher-order contracts requires type tests \nat higher-order types. Membership in [[t1 .t2]] is, however, by Rice s theorem [14] undecidable! The \ntrick used by the Findler-Felleisen algorithm is to give up on this unattainable goal and settle for \nless. When a runtime error is generated, the contract checker reports that a certain claim of the form \nv : t is false. However, even the ability to do that might come as a bit of a surprise since it seems \nto re\u00adquire being able to verify claims of the form v : t1 .t2 after all. In particular, consider proving \nthat \u00ac( f : (t1 .t2) .t3). This re\u00adquires showing the existence of a witness v such that v : t1 .t2 and \n\u00ac(( fv) : t3). As pointed out before, we generally cannot know whether some v satis.es t1 .t2. What we \ndo know, however, is that even if v was not in t1 .t2, at the time f got blamed for not being in (t1 \n.t2) .t3 this fact had not yet been found out. In other words, the argument v of f has so far behaved \nlike a value in t1 .t2. The idea behind the soundness proof is to show that there is some v ' that in \nthis particular context acts just like v but which actually does satisfy t1 .t2. The construction of \nv ' is one of the technical dif.culties of the soundness proof. Let us look at two examples: First, let \nt1 stand for the contract i int .((int;.x.x < i).(int;.x.x >0)) in the program fragment: let x1: t1 = \n.i..k.k -i in let x2 : int = ((x14) 3)in x2 This code will fail at runtime and report a contract violation. \nThe ar\u00adguments to x1 pass their respective tests while the return value does not, so the contract checker \nproduces T1, accusing x1 for breaking t1. This is correct because the arguments to x1 constitute a coun\u00adterexample \nto x1: t1. Take a look at this variant of the program: let x1: t1 = .i..k.i -k in let x2 : int = ((x13) \n4)in x2 The body of x1 now produces a positive number as promised, if the arguments satisfy their contracts. \nThe order of the arguments, how\u00adever, have been inverted so that they no longer satisfy x1 s contract. \nThe contract checker now raises T2 because x2 abuses x1. Notice how important it is for the argument \ncontract to be checked before the result contract, as otherwise the wrong exception would have been raised. \nIn our second example, let t1 stand for (int .(int;.x.x =0)) .(int;.x.x =0) and consider: let x1: t1 \n= .g.((g 1) -1) in let x2 : int = (x1 (.x.(x -1)))in x2 Again, this is a call of a function with an argument \nthat is not in its stated domain, but it escapes discovery because it is itself a func\u00adtion and never \ngets applied to a value that would witness this fact. Instead, the Findler-Felleisen algorithm detects \na violation of the range contract of x1, so the result is T1 which says that x1 does not satisfy its \ncontract even though the checker has not really seen a counterexample! Blaming x1 is nevertheless correct \nhere since there exist other values, for example .x.0 .[[int .(int;.x.x =0)]] that can witness the problem \nwith x1 in precisely the same way. 2.8 Behavioral correctness An important property of contract checking \nis that it must not change the behavior of a program in an essential way. By this we       mean \nthat as long as no exceptions are raised, there is no other way of operationally distinguishing between \ne and (W .' ,. e): t (W .' ,. LEMMA 2. Let e ' = e).If [[c[e ']]] = i (with i . I) then t [[c[e]]] = \ni . Also, if [[c[e]]] = i and [[c[e ']]] .V, then [[c[e ']]] = i . PROOF SKETCH. Using a bi-simulation \nbetween expressions that contain instances of W and corresponding terms with some of these wrappers stripped \nout. For brevity we omit the details of the proof here. 2.9 Safety The concept of safety that we use \nhere formalizes the familiar prac\u00adtice of coding as defensively as possible. It means that before at\u00adtempting \nany operation that could go wrong the program makes sure that it will, in fact, not go wrong. For example, \na safe program in a dynamically typed language must verify that the arguments of + are indeed numeric \nand take evasive action if they are not.7 In the higher-order case the caveat is that one can never be \nsure that an unknown function does not itself raise an exception after being called. The de.nition of \nsafety takes this into account. Behavioral safety: An expression e is safe if and only if it is im\u00adpossible \nto trigger any of its syntactically embedded contract ex\u00adceptions. Thus, e must remain semantically unchanged \nif some or all of its Ts are replaced with .: DEFINITION 1(SAFETY, TAKE 1). Safe1 = {v .V |lvJ~ = v} \nLet Safesyn = {lvJ|v .V } be the set of syntactically safe values, i.e., values that do not contain syntactic \noccurrences of Ti . From de.nition 1 it is then immediately clear that Safesyn .Safe1. Safe in syntactically \nsafe contexts: The second de.nition charac\u00adterizes safe values as those that do not trigger a contract \nexception in any syntactically safe context (i.e., contexts without syntactic oc\u00adcurrences of T): DEFINITION \n2(SAFETY, TAKE 2). Safe2 = {v .V |.c .C.[[lcJ[v]]] .V .{.}} Safety as a greatest .xpoint: To explicitly \ndeal with the problem of safety in a higher-order setting we would like to say that a func\u00adtion f is \nsafe whenever the result of applying f to a safe value v is still safe. Unfortunately, this is not a \nde.nition for precisely the same reason that makes the interpretation of recursive types dif.\u00adcult. The \noperator whose .xpoint we are after is not monotonic. To get around this problem we weaken the condition \nand say that v is safe if it is a .at value (0 ,1 ,...in our case) or a function returning something \nsafe whenever applied to a syntactically safe argument. Thus, we take Safe3 to be the greatest .xpoint \n.S of the monotonic operator S: DEFINITION 3(SAFETY, TAKE 3). S(Q)= {v .V |.w .V.[[(v lwJ).]] .Q .{.}} \nSafe3 = .S Properties of safety: All notions of safety are pairwise equivalent. 7Depending on what one \nconsiders wrong, even statically typed programs must perform certain runtime tests to be safe. Ex\u00adample: \nindex range checks in subscript expressions. LEMMA 3. Safe1 = Safe2 = Safe3 PROOF. This follows from \nlemmas 10 and 11, both shown and proved in appendix A.1. Since the three versions of safety are equivalent \nwe drop the sub\u00adscript and simply write Safe. We use the subscripted version when we want to indicate \nthe properties of Safe that we use for a proof. By de.nition, it is impossible to operationally distinguish \nbetween a v .Safe1 and the corresponding lvJ. By plugging this fact into the de.nition of Safe3 we conclude \nthat Safe is also the greatest .xpoint of S , de.ned as S(Q)= {v .V |.w .Q.[[(vw).]] .Q .{.}} This coincides \nwith our original intuition of safe values being those that remain safe when applied to other safe values, \na fact that can be stated as follows: LEMMA 4. e,e ' : safe .(ee '). : safe PROOF. Follows immediately \nfrom Safe being the greatest .xpoint of S and [[safe]] = Safe. 3 Soundness and completeness We would \nlike to show that [[\u00b7]]FF and [[\u00b7]] are the same, but this is true only if we make certain assumptions \nabout predicates. A suf.cient condition is all predicates being total. But even without assuming totality \nwe can show contract checking to be sound, i.e., [[t]] .[[t]]FF. This means that any difference between \n[[t]]FF and [[t]] can always be explained by non-terminating predicate code.8 In any case, blame assignment \nis sound as every blame is justi.ed by a corresponding contract violation: THEOREM 1([[t]] .[[t]]FF). \nIf ee [[let x1: te = e1 in ...let xn : te = ein xn]]e = Ti 1 nn then .v1 .[[t1e]]e ,...,vi-1 .[[tie -1]]e \nsuch that [[ei[vj/xj] j=1...i-1]] .[[ti e]]e .{.} where ei = CTei (ee i ;0/). Moreover, there are ve1,...,ve \ni-1 .Ee such that e C ej;0/) ~ Ti (v= vj i.e. ~ee = CTei (ei [vj/xj] ;0/) ei[vj/xj] j=1...i-1 j=1...i-1 \nFurthermore, we can get a completeness result if P0 is assumed to contain only total predicates. (For \nexample, we could take P0 to be the set of functions that return false if one of their arguments is not \nan integer, and which otherwise compute a boolean combination of the results of comparing its arguments \nwith one another. Such a class could be de.ned by a suitable syntactic restriction on E.) In this case \nevery contract violation has the potential for causing corresponding blame: 8For example, the contract \nchecker cannot determine that .x..y.y does not satisfy (int .int;.z.(.x.(xx) .x.(xx))) because it always \ngets stuck in the in.nite loop that is the body of the pred\u00adicate. st(e;t) st(x1,...,xk ;int) t .Tsafe \nst(x1,...,xk ;safe) st(x1,...,xk ;t) .x1.\u00b7\u00b7\u00b7.xk ..x.e .Safe st(x1,...,xk ;(t;.x.e)) st(x1,...,xk ;t1 \n) st(x1,...,xk ,x;t2) x st(x1,...,xk ;t1 .t2) Figure 6. Safe contracts. THEOREM 2([[t]] .[[t]]FF). If \nall predicates in P 0 are total and .v1 .[[t1e]]e ,...,vi-1 .[[tie -1]]e with [[e[vj/xj] j=1...i-1]] \n.[[te]]e .{.} where e = CTei (ee;0/) for some ee . Ee with free variables x1,...,xi-1, then there are \nee1,...,ee i-1 .Ee and p .P such that: e let x1: te = e1e in ...let xi-1: tie -1 = eie -1 in 1 = Ti \nlet xi : te = ee in p (The ee1,...,ee i-1 can be picked from the set of closed expressions.)  3.1 The \ncentral lemma Before we can state the central lemma we need to introduce a safety restriction on contracts \n(Figure 6). Safety guarantees that predicates within contracts do not raise exceptions of their own. \nThe formula st(x1,...,xk;t) expresses that t, which may have free variables in {x1,...,xk}, is safe. \nA closed contract t is in Tsafe if st(e;t) where e denotes the empty sequence of variables. ,. ,. By \nslight abuse of notation, let s write W .' for .x.(W .' x) and tt W .' 1,.1 .W .' 2,.21,.1 (W .' 2,.2 \nfor .x.(W .' x)). t1 t2 t1 t2 An easy induction on the structure of contract t shows that contract wrappers \nhave a telescoping property: W .1,.2 .W .3,.4 = W .1,.4 tt t ,. Thus, wrappers W Ti and W .,Tj can be \nseen as two halves of tt W Ti ,Tj t . The central lemma states that one half coerces safe val\u00adues into \nvalues satisfying the contract while the other half coerces contract-satisfying values into safe values:9 \nLEMMA 5(CENTRAL LEMMA). For any . . X and any t . Tsafe: a. v : t .(W .,. v) : safe t b. v : safe .(W \n.,. v) : t t Once again abusing notation, we can render this as: W .,. W .,. t : t .safe t : safe .t \n 3.2 Proof of soundness The proof for Theorem 1 uses Lemma 5(b) to construct the required values v1,...,vi-1 \nand then .nishes by applying Lemma 5(a). 9One is tempted to look for an embedding-projection pair here, \n,..W .,Tj = W Ti .W Ti ,. but notice that neither Wt Tit t ,Tj nor Wt .,Tjt = W .,. t is an identity \non a domain we are interested in. PROOF THEOREM 1(SKETCH). First we de.ne a substitution s de.ned by \nthe equation ,Tj e s(xi)= CTei (ei ;0/)[(WCTti (tj) s(xj))/xj] j=1...i-1 Let e be the expression (W .,Tn \ns(xn)). Note that e is the let- Ct (te) n expansion of the original program s internal form. Suppose \n[[e]] = Ti. Intuitively, there is a particular occurrence of an exception label in e, the offending Ti, \nwhich gets returned as the exception value. We can write e as W Tj ,Ti e ,Tk cCTei (ei ;0/)[(W Ti ti \ntk s(xk))/xk]k=1...i-1 such that the offending Ti is not in c .C. Since the offending Ti is neither in \nc nor in any of the s(xk), using ei = CTei (ei e;0/), we have W .,Ti ,. [[lcJei[(W Ti ]] = Ti ti tk \nls(xk)J)/xk]k=1...i-1 ,. Pick vk for k = 1...i -1to be (W Ti ls(xk)J). By Lemma 5(b) tk we .nd vk . [[tk \ne]]e as required. Each vk has a semantically equiva\u00adlent external version ve k (see Appendix B). Substituting \nvk into the above equation yields W .,Ti [[lcJti ei[vk/xk]k=1...i-1]] = Ti which means that ei[vk/xk]k=1...i-1: \n[[ti e]]e would contradict Lemma 5(a). The proof sketch for Theorem 2 is shown in Section 4.2. 4 Assuming \ntotal predicates In this section we consider the case that each . . P0 in a predi\u00adcate contract (t;.xn.(...(. \nx1). ...xn).) is a total function from n arbitrary values to int. This assumption implies that contracts \nare always in Tsafe. Moreover, relying on Lemma 2 we can equivalently write the operational semantics \nfor contract wrappers in a simpler way: (W .' ,. ,. z.x.e) . .y.(W .' ((.x.e) (Wt.1 ,.' y))) t2[y/z] \n.t1.t2 ,. ,. (W .' v) . ((.x.e) v).?.(W .' v) t(t;.x.e) 4.1 A simple proof of the central lemma We now \ngive a proof of Lemma 5 under the assumption of totality for predicates: PROOF CENTRAL LEMMA. By simultaneous \ninduction on the structure of t. We only show the two most important cases. (All zother cases are trivial.) \nThe .rst is t = t1 .t2 and v = .x.e: a. Consider any syntactically safe w: By induction hypothesis (part \nb.) we have (W .,. w) : t1, so using the contract on .x.e t1 we get ((.x.e) (W .,. w)) : t2[(W .,. w)/z]. \nIf this expression t1 t1 diverges, then by de.nition it satis.es t2[w/z]. Otherwise, we get the same \nresult by noting that [[t2[w/z]]] must be equal to [[t2[(W .,. w)/z]]]. This again follows from Lemma \n2 since t1 otherwise one of the total integer-result predicates would have to be able to distinguish \nbetween w and (W .,. w). Using the t1 induction hypothesis (part a.) we .nd that (W .,. t2[w/z] ((.x.e) \n(W .,. w))) t1 is safe. By de.nition of Safe3, using the (simpli.ed) rule for W .' ,. z this means that \n(W .,z..x.e) is safe. t1.t2 t1.t2 b. Consider any w : t1: By induction hypothesis (part a.) we know that \n(W .,. w) is safe, so by Lemma 4 we .nd t1 ((.x.e) (W .,. w))to be safe as well. By induction hypoth\u00ad \nt1 . esis (part b.) this means that: (Wt.2[,w. /z] ((.x.e) (W .,. w))) : t2[w/z] t1 . z Using our semantics \nfor t1 .t2 and the corresponding (sim\u00adpli.ed) operational rule we get the desired result, namely z (W \n.,. z .x.e) : t1 .t2 t1.t2 The other interesting case is t = (t ' ;.x.e): a. Since v .[[(t ' ;.x.e)]] \nwe also have v .[[t ']] and [[((.x.e) v).]] = 1. But (W .,. v) makes a transition (t ' ;.x.e) ?.(W .,. \nv) and .nally evaluates to [[W .,. v]], which is safe by part a. of the induction hypothesis. to ((.x.e) \nv).t ' t ' b. ((.x.e) v). must evaluate to an integer (by our totality as\u00adsumption). If that result is \nnot 1, then ((.x.e) v).?.(Wt .' ,. v) raises the . exception which is in [[t ']]. The outcome 1 makes \nthe .nal result (W .,. v), which by induction hypoth\u00ad t ' esis (part b.) is in [[t ']]. Furthermore, \nLemma 2 tells us that ((.x.e) (Wt .' ,. v)) cannot evaluate to anything other than 1, so the result is \nindeed in [[(t ' ;.x.e)]].  4.2 Completeness We now show that [[\u00b7]] is maximal under the totality assumption. \nFirst we need the following lemma: (c[(W Ti ,Tj LEMMA 6. If v : t ' but \u00ac(c[v] : t), then \u00act ' v)] : \nt) The proof for this is shown in appendix A.2. PROOF THEOREM 2. To complete the proof of Theorem 2, \nrecall that we have v1 .[[t1e]]e ,...,vi-1 .[[tie -1]]e such that CTei (ee;0/)[vj/xj] j=1,...,i-1 does \nnot satisfy Ct (te). We pick ee e1,...,ei-1 equivalent to lv1J...,lvi-1J. (See Appendix B for how e this \ncan be done.) Now consider the let-expansion of ewhich is equivalent to ,Tj C e Ti (ee;0/)[(WCTti (tj) \nlvjJ)/xj] j=1...i-1 It is easy to see that lvjJ: tj, so according to Lemma 6 this expres\u00adsion, let s \ncall it e, does not satisfy Ct (ti e). What remains to be shown is the existence of a context c such \nthat c[(W Ti+1 ,Ti e )] evaluates to Ti. From such a c one can then easily ti construct a p that completes \nthe proof, for example p = let xi+1: int = ((.y.0) c[xi]). in xi+1. (For this we need c to be syntactically \nsafe. Again, see Appendix B for details.) The construction of c proceeds by induction on the structure \nof ti. We make use of the fact that the constructed context is always strict in its hole. First we note \nthat if evaluating e raises an exception, then this exception must be Ti since all other available Tj \nwould, by Theorem 1, blame one of the vj, and those do satisfy their re\u00adspective contracts. We now consider \nthe case [[e ]] .V and construct c according to ti. int It suf.ces to make c strict in its hole so that \nthe wrapper for xi will be evaluated, causing Ti to be raised. For example, we can simply use [\u00b7]. e \n:e e ' 1 :e1 \u00b7\u00b7\u00b7 e ' k :ek e ' 1 :e1 e ' 2 :e2 f.(e ' 1,...,e ' k ) : f.(e1,...,ek ) (e ' 1 e ' 2). :(e1 \ne2). e ' :et ' :t e ' :et .Tsafe (W .,. t ' e ') :(W .' ,. t e) (W .,. t e ') :e e ' :et ' :t t :t (W \n.' ,. t ' e ') :(W .' ,. t e) t ' 1 :t1 t ' 2 :t2 t ' :t f' :f t ' 1 x.t ' 2 :t1 x.t2 (t ' ;f' ):(t;f) \n Figure 7. A partial order on expressions and contracts. safe We pick c to be a context witnessing [[e \n]] . Safe2. Since the witnessing context itself is (syntactically) safe, it must be strict in its hole \nto be able to trigger the exception. (t;f) We use the induction hypothesis, construct the c ' correspond\u00ading \nto t, and make c = c '. Because of totality, f applied to [[e ]] must be either true or false. If it \nis false, the wrapper will trig\u00adger Ti (because c is strict in its hole). If the predicate returns true, \nthen [[e ]] must violate t, so by induction hypothesis c will cause Ti to be raised. x t1 .t2 If [[e \n]] is of the form .y.e ' , then there must be some v .[[t1]] such that ((.y.e ') v). does not satisfy \nt2[v/x]. By Lemma 6 ,Ti+1 this means that ((.y.e ') (W Tiv))also violates t2[v/x]. t1 . Using the induction \nhypothesis for this contract-expression combination, we pick a c ' in such a way that '[(W Ti+1 ,Ti ,Ti+1 \nc ((.y.e ') (W Tiv)))] t2[v/x] t1 . raises Ti. But then c '[((W Tix+1 ,Ti .y.e ') lvJ) ] will also trig\u00adt1.t2 \n. ger Ti . This means that we can pick c to be c '[([\u00b7] lvJ).].If e does not evaluate to .y.e ', then \nany strict c such as [\u00b7] will do. This concludes our demonstration that given totality of predicates \nour semantics for contracts [[\u00b7]] is the same as [[\u00b7]]FF. 5 Not assuming total predicates In the absence \nof totality, there are two potential problems with predicates in contracts: they might diverge, or they \nmight raise con\u00adtract exceptions of their own. We cannot completely avoid either problem. However, by \nmaintaining the safety of contracts we man\u00adage to contain the damage well enough to keep soundness intact. \nAs hinted earlier, contract safety relies on details in the translation of external types (Ct (\u00b7), where \n. is used as the exception annota\u00adtion on predicate code; see Section 2.2) and the way the operational \nsemantics inserts wrappers that raise . when predicate code mis\u00adbehaves (see Section 2.4). Without totality, \nneither the simpli.cations of the operational rules used in Section 4 nor conclusions such as [[t2[w/z]]] \n= [[t2[(W .,. w)/z]]] t1 are true. To prove Lemma 5 under these conditions, we have to strengthen the \ninduction hypothesis, using a partial order : on terms and contract expressions. The de.nition of this \nrelation, which is a generalization of the =introduced in Section 2, is shown in Figure 7. Roughly, we \nsay e ':e (or t ':t)if e ' (or t ') can be ob\u00adtained from e (or t) by turning some or all occurrences \nof T into . and, at the same time, inserting zero or more wrappers of the form W .,. t where t .Tsafe. \nUsing this relation we can state a generalization of Lemmas 1 and 2 as follows: LEMMA 7. If e ': e and \n[[e ']] = i for some i . I, then [[e]] = i. Also, if [[e]] = i and [[e ']] . V, then [[e ']] = i. The \nproof for this proceeds like that for Lemma 2 (using a bi\u00ad simulation between terms related via :). We \nomit the details here ' and just point out that the basic idea is to have e either diverge or, as long \nas it does not diverge, behave exactly like e. 5.1 The stronger version of the central lemma Now we \nare ready to state the stronger version of Lemma 5: LEMMA 8(STRONGER VERSION OF CENTRAL LEMMA). For any \n. . X, any t '. Tsafe, and t such that t ': t a. v : t . [[(W .,. v)]] : safe t ' b. v : safe . [[(W \n.,. v)]] : t t ' PROOF. As in the proof given in Section 4 we only consider the two most important cases. \nz t1 . t2,.x.e By de.nition, we have t1 ': t1,t2 ': t2. 2[(W .,. v)/z] : t2[(W .,. a. Using the fact \nthat t ' t ' t ' v)/z] 11 we need to show that the result of applying (W .,. z .x.e) t '.t ' 1 2 to a \nsafe value v is safe. This can be seen as follows: t1 ;' safe ;' (W .,. ((.x.e) (W .,. v ))) t ' t2' \n[(W .,. v)/z] 1 t ' 1 ' ; t2[(W .,. v)/z] t ' 1 ' ; safe For this, from inside-out, we are using the \nassumption about v, the induction hypothesis (b.), the assumption about the contract on .x.e, and the \ninduction hypothesis (a.). b. Let v be a value in t1. Then, by induction hypothesis (a.), (W .,. v) is \nsafe, so by de.nition of Safe1 it is, in t ' 1 fact, equal to (W .,. v), which means that we have: t \n' 1 v)/z] ~2[(W .,.t2' [(W .,. = t ' v)/z] : t2[v/z] t ' t ' 11 Using this we need to show that the result \nof applying (W .,. z .x.e) to v satis.es t2[v/z], which can be seen t '.t ' 1 2 from the following: safe \n ;' t1 ;' (W .,. ((.x.e) (W .,. v ))) t ' t2' [(W t .' ,. v)/z] 1 1 ' ; safe ' ; t2[v/z] Again, from \ninside-out, we used the contract satisfac\u00adtion assumption about v, induction hypothesis (a.), the safety \nassumption about .x.e, and induction hypothesis (b.). z Remark: Notice that under the assumption of t \n'. t2 ' being in 1 Tsafe we .nd that all contracts in wrapper expressions are also in Tsafe. (t;f) By \nde.nition we have t ': t and f': f. a. Let v . [[(t;f)]], which means that v . [[t]] and [[(f v)]] . \n{.,1}. Consider (W .,. v) which expands into (t ' ;f') tt ;' ;' (W .,. ?.(W .,. (f' t ' v )) t ' v ) \n' ;' ; safe safe ' ; safe As before, the annotations show the conclusions we can draw from induction \nhypotheses and contract satisfac\u00adtion assumptions. The only way the shown expression (W .,. might not \nbe safe is by having (f' v)), which by t ' (W .,. the properties of safety is the same as (f' v)), t \n' yielding a proper value other than 1. By Lemma 7 this would imply that (f v) also returns a value other \nthan 1, and that contradicts the assumptions. b. Let v . Safe and consider (W .,. v) which expands (t \n' ;f') into safe ;' safe ;' (f' (W .,. v ))?.(W .,. v) t ' t ' ' ; safe Clearly, if the .nal value here \nis not ., then it must be true that (W .,. [[(f' v))]] = 1 t ' and the result is (W .,. v). But in that \ncase, since f': f t ' by Lemma 7 we also have [[(f (W .,. v))]] = 1, which t ' means that the value satis.es \n(t;f). Lemma 5 is implied by Lemma 8. As a result, we have a proof for Theorem 1 (stating the soundness \nof contract checking) even in the more general setting where contract predicates might not termi\u00adnate, \nand where the substitution of unsafe terms into predicate terms can cause contract exceptions from predicate \ncode. The key here is to carefully control the latter effect: contract exceptions raised by predicate \ncode always correctly point to genuine contract violations in other parts of the program. 6 Recursive \ncontracts Adding recursive contracts \u00b5a.t to the contract language and ac\u00adcounting for this change in \nthe operational semantics is relatively straightforward.10 Here are the changes: TyVar ::= a | \u00df | ... \nT e ::= ... | \u00b5TyVar.Te | T e . T e T ::= ... | \u00b5TyVar.T | T .T Ct (\u00b5a.te)= \u00b5a.Ct (te) Ct (t1e .t2e)= \nCt (t1e) . Ct (t2e) 10We also add a form of sum contracts t1 . t2 where [[t1]] and [[t2]] are recursively \nseparable (meaning there is a computable total predicate on V which is true for all of [[t1]] and false \nfor all of [[t2]]). Such sums are sometimes called tidy sums. (W .' ,. (W .' ,. \u00b5a.tv) . t[\u00b5a.t/a] v) \n(W .' ,. (W .' ,. t1 v) : if v .[[t1]] v) . t1.t2 ,. (W .' v) : if v .[[t1]] t2 Because of the rule in \nthe operational semantics that identi.es \u00b5a.F(a) with F(\u00b5a.F(a)) (where F is a contract function), struc\u00adtural \ninduction on contract expression breaks down in the presence of recursive contracts. If we could restrict \nF to covariant contract functions, then we would be able to salvage the situation using co\u00adinduction. \nFor many uses of recursive contracts this is suf.cient. However, there are useful applications of recursive \ntypes (and con\u00adtracts) where F is not covariant. For example, several popular en\u00adcodings of object types \nhave this property. There is another reason why considering recursive contracts in the context of contract \nchecking is useful: it provides us with a different (but consistent!) view on the problem of how to interpret \nFindler and Felleisen s original unrestricted predicate contracts. 6.1 Indexing We have made extensive \nuse of structural induction, so our proofs do not work in the presence of recursive contracts. Fortunately, \nit is straightforward (although tedious) to adopt Appel and McAllester s indexed model of recursive types \n[1] and to modify proofs accord\u00adingly. In the indexed model, a contract t is interpreted as a set [[t]]idx \nof indexed terms (k,v). The idea is that v is a k-approximation of a value satisfying t, i.e., that no \ncontext c can tell in k or fewer steps that v does not satisfy t. The original interpretation of contracts \ncan then be recovered as [[t]] = Tk{v |(k,v).[[t]]idx}. Along with this interpretation of contracts as \nindex-value pairs goes an indexed contract-satisfaction relation e:kt, which is de.ned as e.jv .(k - \nj,v).[[t]]idx. Of course, an adaptation of the proof also requires an indexed model of safety. But with \nrecursive contracts in the language we can de.ne safety as a contract: safe ' = \u00b5a.int .(a .a) Although \nthis looks suspiciously like the equation often used to characterize the domain of untyped .-terms [15], \nit should be noted that here it does not refer to the set of all possible values but rather a proper \nsubset thereof. (Of course, the original untyped .-calculus does not have contract exceptions, so all \nterms are safe there.) Signi.cant effort in our non-indexed proofs was spent on showing that (abusing \nnotation) Safe = \u00b5a.int .(Safesyn .a) where Safesyn = {lwJ|w .V }(see Lemmas 3 and 4). Here F = .a.int \n.(Safesyn .a) is covariant, so co-induction works. In the indexed proof, safety can be treated directly \nas a con\u00adtract, so no such detours are necessary. Lemma 5 can be restated as LEMMA 9(CENTRAL LEMMA WITH \nRECURSIVE CONTRACTS). If t .Tsafe then e:kt .(W .,. e):k+1safe e:ksafe .(W .,. e):k+1t tt The proof for \nthis proceeds by induction on k, using a close adapta\u00adtion of the techniques presented by Appel and McAllester \n[1]. We omit the details here since they do not add any new insights.  6.2 Recursion, safety, and predicates \nWe presented our interpretation of safe as Safe in an ad-hoc fashion. Clearly, we made the right decision \nsince we ended up with a sound (and under reasonable assumptions complete) model. However, we could have \nmotivated our choice by looking at the statement of Lemma 5 and noting that the contract wrapper for \nthe always-true predicate is simply the identity. If the identity must map safe values to values satisfying \nthe contract and vice versa, then satisfying the contract and being safe should better mean the same. \nStill, as before, our choice is guided by our desire for a particular theorem or lemma to hold. Although \nwe feel that this does consti\u00adtute strong motivation, it still might seem like a matter of personal taste. \nThe treatment of recursive contracts, together with the observa\u00adtion that safe is such a contract, gives \nyet another explanation for [[safe]] = Safe, this time deriving this fact directly from the rest of the \nexisting model and not depending on any proof details. ,. Observe that W \u00b5.a' .int.(a.a) is an identity \nfunction. The formal proof for this proceeds by induction on the number of unfoldings of the recursive \ncontract. Informally, the wrapper is clearly the iden\u00adtity on int. All other values are of the form .x.e \nwhere the wrapper makes two copies of itself one wrapped around the argument, the other wrapped around \nthe result. But if the copies are identities, then so is the original. We should consider contracts as \nbeing identical if their correspond\u00ading wrappers are semantically equivalent. Thus, safe is equivalent \nto \u00b5a.int .(a .a), showing that our choice of interpretation for safe is more than just a trick to make \nthe proof for Lemma 5 go through. Another consequence of being able to de.ne safe as a re\u00adcursive contract \nis that we can keep the full expressive power of the original Findler-Felleisen system while dropping \nour ad-hoc addi\u00adtion of safe from the language of contracts. As noted in the introduction, their system \nhas unrestricted predicate contracts (f)which are operationally equivalent to our (safe;f).We originally \nstarted with a hunt for the proper semantics of (f).By the above equivalence, the answer turns out to \nbe {v .Safe |(f v) . {1,.}}and not, as naively expected, {v .V |(f v) .{1,.}}. No\u00adtice that counterexamples \nlike that in Section 1 work in dynami\u00adcally typed settings such as DrScheme but not in the calculus given \nin Findler and Felleisen s paper [9] because they fail to statically type-check there. A contract places \ncomplementary burdens of responsibility on an expression and its context. This is the key to understanding \nwhy [[(.x.1)]] = Safe. The contract checker does nothing at all here, so expression and context must \njointly do their best at avoiding con\u00adtract exceptions. This idea is precisely captured by our notion \nof safety. 7 Conclusions and outlook We developed an independent model of Findler and Felleisen s con\u00adtracts \nfor higher-order functions and proved the soundness of their contract checker. Under reasonable assumptions, \nit is also com\u00adplete. In short, the contract checker discovers all violations and always assign blame \nproperly. The main technical insight from these proofs is in the simple and apparently fundamental theoretical \nproperties of contract wrappers expressed in the central lemma (Lemma 5). The central lemma shows that \nthere is strong interaction between the semantics of con\u00adtracts and the notion of safety. Furthermore, \nthe fact that Findler\u00adFelleisen-style unrestricted predicate contracts (f)are operationally equivalent \nto our (safe;f) implies that the semantics of (f) has to mention safety. In our system we can avoid this \nleakage of the soundness proof into contract semantics by eliminating unrestricted predicate contracts, \nletting the restricted version take their place. The full expressiveness of the original system can be \nrestored by making it possible to express safety explicitly as a contract either using a new ad-hoc phrase \nlike safe or via recursive contracts. Under reasonable assumptions about predicates, our model [[\u00b7]] \nfor contracts is exactly equivalent to the one implied by the contract checking algorithm. Moreover, \nwhile completeness does not stay intact, soundness is not compromised even if we drop those ex\u00adtra assumptions. \nIt should be noted, however, that this result cru\u00adcially relies on the fact that our language is essentially \npure, the only effects being non-termination and contract exceptions. If the language has constructs \nwith general effects (mutation, I/O), then a compositional semantics that preserves soundness seems out \nof reach at this point. In the calculus shown here, contracts cannot interfere with a program s execution \nother than by changing the ter\u00admination behavior. To make them into a reliable debugging tool even in \nthe general case with arbitrary effects, one de.nitely needs to preserve this property. One should be \nable to remove contracts without altering the semantics of the program in an essential way. A separate \ninvestigation of the restrictions on predicates that one needs for this is currently under way [7]. There \nare several possible future directions for this work. We have not extended the algorithm to handle polymorphism, \nalthough it may not be dif.cult to use higher-order wrappers, i.e., functions from wrappers to wrappers, \nto treat contracts of the form .a.t in- T terpreted as t '.T [[t[t ' /a]]]. Our soundness proof is for \na language with call-by-value semantics. Since most real-world languages that are pure (e.g., Clean [3] \nor Haskell [11]) are also lazy, it seems desirable to translate our results to a lazy setting. We believe \nthat doing so will not be dif.cult. Of course, a natural direction for further work is to implement con\u00adtracts \nin a strongly typed language such as ML or Haskell. 7.1 Program veri.cation It also seems possible to \napply ideas from contract checking to static program veri.cation. In particular, symbolic evaluation \nof programs with contract wrappers might be able to statically verify that a particular contract exception \nTi can never be raised, i.e., that e module ei satis.es ti in the [[\u00b7]]FF model. Assuming completeness \nthis implies contract satisfaction in the [[\u00b7]] model as well. One way of showing that Ti cannot be raised \nis to eliminate it from the program. (There are no operational rules that generate new ex\u00adceptions.) \nOne might hope to rely on the telescoping property of contract wrappers, but this law is applicable only \nif the wrappers in question are indexed by the same contract: .' .' .' 2,.21,.12,.1 W . W = W tt t Now \nconsider t1 and t2 with [[t1]] . [[t2]]. In this case we would like to argue that the left side of .' \n.' 2,.21,.1 W . W t2 t1 is redundant because of the stronger wrapper on the right. How\u00adever, the right \nside is stronger only from the point of view of the wrapped value while it is actually the left side \nthat is stronger from the context s point of view. Thus, we cannot simply eliminate either t1 or t2, \nbut we can argue that neither .' 1 nor .2 could ever be raised here. It is possible to express this, \ne.g., as .' 2,.. W .,.1 W t2 t1 but doing so seems clumsy. A leaner notation separates the two roles \nof W .' ,. (watching the value and watching the context) by t de.ning each contract wrapper as the composition \nof two parts: W .' ,. = W -.'. W +. t tt Operational rules for W -.' and W +. are easy to set up. The \nmain tt idea is to alternate between W - and W + instead of swapping ex\u00adception superscripts in contravariant \npositions. Here are the rules (abusing notation when raising .) for a simple contract language with only \nint and .: (W +. i ) . i int (W +..x.e) . .y.(W +. ((.x.e) (W -. y))) t1.t2 t2 t1 . (W +. v) . . ;otherwise \nt (W -..x.e) . .y.(W -. ((.x.e) (W +. y))) t1.t2 t2 t1 . (W -. v) . v ;otherwise t W - and W + commute \nregardless of their contract subscripts, and assuming [[t1]] . [[t2]] we have: W +.' W -.' = W -.' . \nW +. = W +. and . W -. t2 t1 t1 t2 t1 t2 Notice that the requirements on the context expressed, by W-, \nare preconditions while the requirements on the value, expressed by W + , are postconditions. Thus, the \nabove laws precisely capture the fact that one has to keep the weakest precondition and the strongest \npostcondition [10, 4]. Using [[t1]] . [[t2]] we get .2' ,.2 .1' ,.1 W -.' 2 . W +.2 . W -.' 1 . W +.1 \nW . W = t2 t1 t2 t2 t1 t1 -.'-.' . W +.2 . W +.1 = W 2 . W 1 t2 t1 t2 t1 -.' 2 . W +.1 = W t2 t1 which \nconcisely captures the idea of eliminating contract exceptions (here .2 and .' 1) that can never be raised. \n8 Acknowledgments We greatly bene.ted from extensive discussions with Robby Find\u00adler as well as from \nhelpful advice given by Matthias Felleisen and several anonymous reviewers. 9 References [1] A. W. Appel \nand D. McAllester. An indexed model of recursive types for foun\u00addational proof-carrying code. ACM Trans. \non Programming Languages and Systems, 23(5):657 683, 2001. [2] K. B. Bruce, L. Cardelli, and B. C. Pierce. \nComparing object encodings. In Theoretical Aspects of Computer Software, pages 415 438, 1997. [3] T. \nBrus, M. van Eekelen, M. van Leer, and M. Plasmeijer. CLEAN: A Language for Functional Graph Rewriting. \nIn G. Kahn, editor, Proc. of the Conf. on Functional Programming Languages and Computer Architecture \n(FPCA 87), Portland, Oregon, USA, volume 274 of Lecture Notes in Computer Science. Springer-Verlag, Berlin, \nGermany, 1987. [4] E. W. Dijkstra. A Discipline of Programming. Prentice-Hall, 1976. [5] M. Felleisen, \nR. B. Findler, M. Flatt, and S. Kristnamurthi. The DrScheme project: An overview. SIGPLAN Notices, 33(6):17 \n23, 1998. [6] M. Felleisen and R. Hieb. A revised report on the syntactic theories of sequen\u00adtial control \nand state. Theoretical Computer Science, 103(2):235 271, 1992. [7] R. B. Findler, M. Blume, and M. Felleisen. \nAn investigation of contracts as projections. Technical Report TR-2004-02, University of Chicago Computer \nScience Department, 2004. [8] R. B. Findler, J. Clements, M. F. Cormac Flanagan, S. Krishnamurthi, P. \nSteck\u00adler, and M. Felleisen. DrScheme: A programming environment for Scheme. Journal of Functional Programming, \n12(2):159 182, March 2002. [9] R. B. Findler and M. Felleisen. Contracts for higher-order functions. \nIn Proc. of the 7th ACM SIGPLAN Int. Conf. on Functional Programming, pages 48 59. ACM Press, 2002. [10] \nC. A. R. Hoare. An axiomatic basis for computer programming. Commun. ACM, 12(10):578 580, October 1969. \n[11] S. P. Jones. Haskell 98 Language and Libraries. Cambridge University Press, 2003. [12] X. Leroy. \nThe ZINC experiment: an economical implementation of the ML language. Technical Report No. 117, INRIA, \nFeb. 1990. [13] R. Milner, M. Tofte, R. Harper, and D. MacQueen. The De.nition of Standard ML (Revised). \nMIT Press, Cambridge, MA, 1997. [14] H. G. Rice. Classes of recursively enumerable sets and their decision \nproblems. Trans. Amer. Math. Soc., 74:358 366, 1953. [15] D. S. Scott. Continuous lattices. In F. W. \nLawvere, editor, Toposes, Algebraic Geometry and Logic, volume 274 of Lecture Notes in Mathematics, pages \n97 136. Springer, 1972. A Additional proofs A.1 Safe1 = Safe2 = Safe3 We split this statement into two \nparts: LEMMA 10. Safe1 = Safe2 PROOF .. By de.nition we have v = lvJ,soif [[lcJ[v]]] = T then also [[lcJ[lvJ]]] \n= T,but T does not even occur in lcJ[lvJ]. PROOF .. Suppose v = lvJ and c is a witnessing context that \ndis\u00adtinguishes between the two. By Lemma 1 it must be the case that [[c[v]]] = Ti for some i. Ti is generated \nfrom some particular occur\u00adrence of Ti in either v or c, so it must also be the case that either Ti Ti \n11 [[lcJ[v]]] = or [[c[lvJ]]] = . But since c is the witnessing context for v and lvJ being different, \nthe latter is impossible. This concludes the proof. LEMMA 11. Safe2 = Safe3. PROOF .. Indirect: If v \n. Safe3 then there must be a .nite se\u00adquence of values v1,...,vk such that [[(...(v lv1J). ...lvkJ).]] \n= T but [[(...([\u00b7] lv1J). ...lvkJ).]] is a syntactically safe context. PROOF .. Indirect: Pick a v . \nSafe3 \\ Safe2 and a corresponding c . C with lcJ[v].nTi for some i so that n is minimized (i.e., we pick \nan unsafe but operator-safe value together with the context that demonstrates non-membership in Safe2 \nin the smallest number of evaluation steps). The number n cannot be 0: there are no occurrences of T \nin lcJ, so if lcJ[v].0Ti then also v.0Ti, which contradicts the assumption that v . Safe3. For the case \nof n >0 there is a unique evaluation context ce .Ce and corresponding e . E such that ce{e } = lcJ[v] \nwhere e is the next \u00dfv \u00adreduction to do in lcJ[v] [6]. The proof proceeds by case analysis on the possible \nshapes of e and shows that the transition system de.n\u00ading the operational semantics can perform at least \none step which ' gives rise to another pair (v ,lc 'J) with v '. Safe3 \\ Safe2 such that lc 'J[v '].n-1Ti \n. If e, which cannot be a subexpression of the value v, is a subex\u00adpression of lcJ, this is immediately \nclear. The remaining cases are those where v is a subexpression of e. For brevity we only show the analysis \nfor the two most interesting situations: 1. If v = .x.b and e = (v lv 'J). for some subexpression lv \n'J of lcJ, then ce is also syntactically safe. Moreover, since v . Safe3 we can consider d = b[v ' /x] \nand .nd that [[d]] . Safe3 as well. This means that for some k with 0 < k < n we have d.kd ' and d '. \nSafe3.But ce[d '].n-k-1Ti, which is the con\u00adtradiction that we are looking for. '' 2. If e = ((.x.b) \nv '). where v is a subexpression of v (v = c0[v]), then b, ce, and c0 are syntactically safe. We know \nthat ce[b[v ' /x]].n-1Ti . Since the value Ti is generated from some single occurrence of Ti which must \nbe within one of the copies of v within b[v ' /x], we can replace all occurrences of T in every other \ncopy of v by ., thus rewriting b[c0[v]/x] as lc1J[c0[v]]. This means that ce[lc1J[c0[v]]].n-1Ti, which \n11Making this informal argument precise is not dif.cult but te\u00addious. An extended version of this paper \nwith these details included can be obtained from the authors. is the contradiction we are looking for \nsince ce[c1[c0[\u00b7]]] is a syntactically safe context.    A.2 Preservation of contract violation Lemma \n6 states that, under the totality assumption of Section 4, if v : t ' and \u00ac(c[v] : t) then \u00ac(c[(W Ti \n,Tjv)] : t). t ' PROOF. By induction on the structure of t: int Because of totality the extra wrapper \ncannot cause non-termination. But by Lemma 2, if c[(W Ti ,Tjv)] were to t ' return an integer, then so \nwould c[v]. safe We use the de.nition for Safe2 and consider the witnessing ' context c where [[lc 'J[c[v]]]] \n= Tk while ,Tj [[lc 'J[c[(W Tiv)]]]] . V .{.}. The remainder of this t ' case proceeds like the proof \nfor Lemma 2 (e.g., using bi\u00adsimulation), showing that given totality of predicates the sec\u00adond term must \nraise either Tk or Ti. (It cannot raise Tj since v satis.es t '.) (t;f) By Lemma 2 and totality, the \nresults of f have to agree in both cases. Now use the induction hypothesis with t. x t1 . t2 The only \nnon-trivial case is where c has the form .x.c ', and by de.nition there has to be a w : t1 such that \n\u00ac(c '[v][w/x] : '[(W Ti ,Tj '' t2[w/x]) while ct ' v)][w/x] : t2[w/x]. Consider c = c '[w/x] and use \nthe induction hypothesis with t2. B Witness expressions On a number of occasions, in particular in the \nproof of Theo\u00adrem 1 shown in Section 3.2 and also in the proof of Theorem 2 in Section 4.2, we construct \nvalues v . V , e.g., as witnesses for the fact that some contract is being violated. Since the main theorem \nis stated in terms of the external language, we need semantically equivalent ee . Ee for these v. The \nconstruction of such equivalents is possible because all our witnesses v . V are syntactically safe, \nand given suf.cient language support safety can be coded up. A more realistic language Ee than the one \nwe have for simplicity of the presentation restricted ourselves to would have some form of conditional \nthat can branch on equality to 1 . If the language also comes with a mechanism for separating functions \nfrom inte\u00adgers, e.g., via some typecase construct, then all witnesses lvJ have an operationally equivalent \ncounterpart in Ee. (Typecase might be troublesome for the static type system of the surface language, \nbut if the surface language is indeed statically typed and safe in the sense well-typed programs do not \ngo wrong , then typecase is not even needed since all of its outcomes would be statically known.) Let \nus be more concrete. Suppose (tycase e1 e2 e3) evaluates to ' [[e2]] if [[e1]] . [[int]] and to [[e3]] \nif [[e1]] = .x.e . Now consider an ee e application (e1 e2) and re-code it as ((. f .(tycase f . ( fee2))) \ne1) where . is a diverging term, e.g., . = ((.x.(xx)) .x.(xx)) and run that through the translator C \n. The implicit exception inserted by the translator ends up being protected by our explicit test. This \nmeans that the result is equivalent to (e1 e2). (where e1 is the translation of ee1 and e2 that of ee2). \nImplicit exceptions in primitive operations can be protected in a similar fashion. Finally, in the proof \nfor Theorem 1 we need to be able to represent ,. wrappers of the form W .,. and W Ti . Given conditionals \nand tt typecase, coding up a wrapper in a type-directed fashion is straight\u00adforward. Raising . just means \ngoing into an in.nite loop. Raising Ti can be simulated by, e.g., evaluating ( 0 0). Since the overall \nexpression gets translated using CTei (\u00b7;0/) (see Theorem 1), the ex\u00ad ception annotation on (00) will \nindeed be Ti .  \n\t\t\t", "proc_id": "1016850", "abstract": "Even in statically typed languages it is useful to have certain invariants checked dynamically. Findler and Felleisen gave an algorithm for dynamically checking expressive higher-order types called contracts. If we postulate soundness (in the sense that whenever a term is accused of violating its contract it really does fail to satisfy it), then their algorithm implies a semantics for contracts. Unfortunately, the implicit nature of the resulting model makes it rather unwieldy.In this paper we demonstrate that a direct approach yields essentially the same semantics without having to refer to contract-checking in its definition. The so-defined model largely coincides with intuition, but it does expose some peculiarities in its interpretation of <i>predicate contracts</i> where a notion of <i>safety</i> (which we define in the paper) \"leaks\" into the semantics of Findler and Felleisen's original <i>unrestricted</i> predicate contracts.This counter-intuitive aspect of the semantics can be avoided by changing the language, replacing unrestricted predicate contracts with a restricted version. The corresponding loss in expressive power can be recovered by also providing a way of explicitly expressing safety as a contract-either in ad-hoc fashion or, e.g., by including general recursive contracts.", "authors": [{"name": "Matthias Blume", "author_profile_id": "81100215091", "affiliation": "Toyota Technological Institute at Chicago", "person_id": "PP43117671", "email_address": "", "orcid_id": ""}, {"name": "David McAllester", "author_profile_id": "81100488875", "affiliation": "Toyota Technological Institute at Chicago", "person_id": "PP39045275", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1016850.1016876", "year": "2004", "article_id": "1016876", "conference": "ICFP", "title": "A sound (and complete) model of contracts", "url": "http://dl.acm.org/citation.cfm?id=1016876"}