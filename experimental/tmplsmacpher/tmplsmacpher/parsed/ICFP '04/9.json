{"article_publication_date": "09-19-2004", "fulltext": "\n Translating Dependency into Parametricity Stephen Tse Steve Zdancewic University of Pennsylvania Abstract \nAbadi et al. introduced the dependency core calculus (DCC) as a unifying framework to study many important \nprogram analyses such as binding time, information .ow, slicing, and function call tracking. DCC uses \na lattice of monads and a nonstandard typing rule for their associated bind operations to describe the \ndependency of computations in a program. Abadi et al. proved a noninterference theorem that estab\u00adlishes \nthe correctness of DCC s type system and thus the correctness of the type systems for the analyses above. \nIn this paper, we study the relationship between DCC and the Girard-Reynolds polymorphic lambda calculus \n(System F). We encode the recursion-free fragment of DCC into F via a type-directed translation. Our \nmain theoretical result is that, following from the correctness of the translation, the parametricity \ntheorem for F implies the noninterference theorem for DCC. In addition, the translation provides in\u00adsights \ninto DCC s type system and suggests implementation strategies of dependency calculi in polymorphic languages. \n Categories and Subject Descriptors D.3 [Software]: Programming Languages  General Terms Languages, \nSecurity  Keywords Dependency, parametricity, noninterference, translation, DCC, information .ow, security, \nmonads, polymorphism, lambda calculus, logical relations, protection contexts, Haskell 1. Introduction \nAbadi et al. introduced the dependency core calculus (DCC) as a unifying framework to study many important \nprogram Stephen Tse <stse@cis.upenn.edu> and Steve Zdancewic <stevez@cis.upenn.edu>. Permission to make \ndigital or hard copies of all or part of this work for personal or classroom use is granted without fee \nprovided that copies are not made or distributed for pro.t or commercial advantage and that copies bear \nthis notice and the full citation on the .rst page. To copy otherwise, to republish, to post on servers \nor to redistribute to lists, requires prior speci.c permission and/or a fee. ICFP 04, September 19 21, \n2004, Snowbird, Utah, USA. Copyright 2004 ACM 1-58113-905-5/04/0009 ...$5.00. analyses such as binding \ntime, information .ow, slicing, and function call tracking. DCC uses a lattice of monads and a nonstandard \ntyping rule for their associated bind operations to describe the dependency of computations in a program. \nFor example, information-.ow security analyses prevent publicly visible outputs of a program from revealing \ninfor\u00admation about con.dential inputs [15]. Consider the program e with security type as follows: e : \nboolH \u00d7 boolL . boolH \u00d7 boolL Here, the label H indicates high-security or con.dential data and the label \nL indicates low-security or public data. A correct information-.ow analysis must ensure that the low\u00adsecurity \noutput of the function depends only on the low\u00adsecurity input to the function. Or, more formally, if \nwe .x the low-security input to be a constant e0, the second out\u00adput does not depend on the .rst input. \nThis is equivalent to requiring that the following is a constant function: .x : boolH . prj2 (e <x, e0 \n>) : boolH . boolL (1) If there are no illegal dependencies, e is said to satisfy non\u00adinterference. Note \nthat the high-security output of e may depend on either of the two inputs. DCC describes dependency analyses \nby interpreting pro\u00adgrams using a lattice of monads, rather than a single monad as in Moggi s computational \nlambda calculus [10]. The lat\u00ad tice order captures permissible dependencies: computation interpreted \nin a monad higher in the lattice is permitted to depend on data interpreted in a monad lower in the lattice, \nbut not vice-versa. Intuitively, computation higher in the lattice is held abstract with respect to computation \nlower in the lattice. In our example above, the two-point lattice L . H su.ces: H outputs may depend \non H or L inputs, but L outputs may depend only on L inputs. DCC uses the type constructor T\u00a3 to denote \nthe monad corresponding to lattice level \u00a3,sothe type of e in DCC is: e : TH bool \u00d7 TL bool . TH bool \n\u00d7 TL bool The denotational semantics for DCC extensively uses par\u00adtial equivalence relations (PERs) indexed \nby the lattice el\u00adements, suggesting a connection to Reynolds PER seman\u00adtics [14] for the Girard Reynolds \npolymorphic lambda calcu\u00ad lus [5, 13] (System F). It is, therefore, natural to ask whether the parametric \npolymorphism in F can express the depen\u00addency in DCC. This paper answers this question a.rmatively by \ngiving a type-directed translation of DCC into F in such that the parametricity theorem for F implies \nthe correctness of the dependency analysis for DCC. The key idea behind our translation is surprisingly \nsimple. In DCC, the type TH bool represents a boolean value that is visible only to H computations (computations \nthat produce data with label H). L computations must treat such a value opaquely and hence cannot distinguish \nbetween true and false at the type TH bool. DCC models this situation via an observation relation that \nsays these two values are equal at L (written .H true ~L .H false : TH bool) but not at H.In fact, ~L \nrelates every possible pair of booleans at the type TH bool, whereas the corresponding H observation \nrelation ~H is the identity relation. Our translation simulates DCC s observation relations by encoding \nTH bool as aH . bool.An L observer translates to a piece of code that does not have access to any values \nof type aH , hence any function of type aH . bool may not be applied. Therefore, in such a context, the \ntwo functions .x : aH . true and .x : aH . false, which are the translations of .H true and .H false, \nare indistinguishable. The contributions of this paper are: the development of this translation of DCC \ninto F and proofs of the static and dynamic correctness of this translation;  a proof of DCC s noninterference \nderived from F s para\u00admetricity theorem;  a sound extension of DCC s type system suggested by the translation \ninto F; and  a sketch of how the translation can be used to imple\u00adment DCC style types in languages \nwith parametric polymorphism.  Although the correctness of DCC s type system has been proved previously \n[1], the proof method proposed here is in\u00ad teresting in its own right. These results not only help to \nexplain how the nonstandard type system in DCC relates to the well-understood abstract types in F, but \nalso provide in\u00adsights on how to make DCC s type system more expressive. This translation may also lead \nto implementation strategies of dependency calculi in polymorphic languages. We demon\u00adstrate this possibility \nby giving a Haskell implementation of the translation for the two-point lattice. It is known that adding \nfix to a language weakens the parametricity theorem [22, 8, 7] and the noninterference theorem [6, 1] \nbecause programs may diverge. For most of this paper we focus on the terminating fragment of DCC in order \nto emphasize the connection between noninterfer\u00adence and parametricity. Section 6.2 discusses the extension \nto the translation for the full DCC with fix. The remainder of this paper is organized as follows. The \nnext section introduces the source language of our trans\u00adlation, the dependency core calculus. Section \n3 presents the translation and proves the correctness of the transla\u00adtion. Section 4 shows that the parametricity \ntheorem for F implies the noninterference theorem for DCC. Section 5 ex\u00ad tends DCC s type system with \na protection context to make it more expressive. The paper concludes with a prototype implementation \nin Haskell and a discussion of future and related work.  2. Dependency core calculus This section describes \nthe recursion-free fragment of de\u00adpendency core calculus (DCC) and explains how dependency information \nis tracked in its type system [1]. The following grammar de.nes the syntax for DCC s contexts, types, \nval\u00adues and terms: G ::= \u00b7| G, x : t s ::= 1 | s \u00d7s | s + s | s . s | T\u00a3 s v ::= <> | <e, e> | inji e \n| .x : s. e | .\u00a3 e e ::= v | prji e | caseevv | x | ee | bind x = eine DCC is a call-by-name, simply-typed \nlambda calculus with one additional language construct a lattice of monads that restrict dependencies \nin the program. Let Lbe a lattice of dependency levels with join U and order .We write L\u00a3 for the set \nof lattice labels and Lc for the lattice order such that L= (L\u00a3, Lc). For each element \u00a3 .Lthere is a \nmonad T\u00a3 and its corresponding unit .\u00a3 and bind operations. The typing rules for constructs other than \nthe monad op\u00aderations (.\u00a3 and bind) are completely standard, so we omit them here. The following rules \nprevent low-level computa\u00adtion from depending on high-level computation: G fe : s (DT-Prot) G f.\u00a3 e : \nT\u00a3 s G fe1 : T\u00a3 s1 G, x : s1 fe2 : s2 s2 \u00a3 (DT-Bind) G fbind x = e1 in e2 : s2 The .\u00a3 e operation marks \nthe computation e with the la\u00adbel \u00a3, restricting how it interacts with the rest of the program (DT-Prot). \nThe bind x = e1 in e2 operation exposes the computation e1 hidden inside the monad T\u00a3 to the scope of \ne2 (DT-Bind). Here, e2 may depend on e1, but the results eventually produced by the entire bind expression \nmust still be protected from computation with label lower than (or incomparable to) \u00a3 in the lattice. \nOperationally, bind eval\u00aduates e1 to a value .\u00a3 e and then substitutes e for x in e2 : bind x = .\u00a3 eine2 \n-. e2 {e/x} Protection rules s \u00a3 (type s protects information at level \u00a3) enforce the restrictions on \ndependencies between compu\u00adtations at di.erent levels of the lattice: 1 \u00a3 (P-Unit) s1 \u00a3 s2 \u00a3 s1 \u00d7s2 \u00a3 \n(P-Pair) \u00a3 \u00a3 s \u00a3 T\u00a3 s \u00a3 (P-Label1) s2 \u00a3 s1 . s2 \u00a3 (P-Fun) \u00a3 \u00a3 T\u00a3 s \u00a3 (P-Label2) No information can be \ntransmitted by a value of type 1 because there is only one such value, so computations of type 1 protect \nany \u00a3 (P-Unit).1 Information can be transmitted by a product only by examining its components, so a product \ntype protects information when both of its components do (P-Pair). A function will protect the data as \nlong as the return type of the function protects the data (P-Fun). A monad at a lower (or incomparable) \nlevel of computa\u00adtion does not protect data at a higher monadinthe lattice, unless the contents are already \nprotected at the higher level (P-Label1). On the other hand, a monad at a higher (or 1Note that if this \nlanguage permitted diverging computa\u00adtions, then information could be transmitted via termina\u00adtion. The \nfull DCC calculus includes lifted types to distin\u00adguish between total and partial types. [[ 1 \u00a3]] (x \n: t, m1, m2) = <> (LP-Unit) [[ s1 \u00d7s2 \u00a3]] (x : t, m1, m2) = <[[ s1 \u00a3]] (x : t, m1, prj1 m2), [[ s2 \u00a3]] \n(x : t, m1, prj2 m2)> (LP-Pair) [[ s1 . s2 \u00a3]] (x : t, m1, m2) = .x0 : s 1. [[ s2 \u00a3]] (x : t, m1, m2 \nx0) (fresh x0) (LP-Fun) [[ T\u00a3 s \u00a3]] (x : t, m1, m2) = .x0 : a\u00a3 . [[ s \u00a3]] (x : t, m1, m2 x0) (fresh x0, \n\u00a3 \u00a3 ) (LP-Label1) [[ T\u00a3 s \u00a3]] (x : t, m1, m2) = .x0 : a\u00a3 . (.x : t. m2 x0)(m1 (k\u00a3 \u00a3 x0)) (fresh x0, \u00a3 \n\u00a3 ) (LP-Label2) Figure 1: Protection translation equal) level in the lattice su.ciently protects the \nresults at a lower level (P-Label2). Note that a sum type, which transmits information via the injection \ntags, does not protect data at any level. To protect asum in a bind expression, we must put the sum into \na monad. For example, the program bind x = .H inj1 <> in x is insecure because it leaks the high-security \nvalue inj1 <>. The type system will reject the program as ill-typed because of the typing rule DT-Bind: \nx has type 1 + s but the sum type 1 + s does not protects information at the high level (that is, 1 + \nsH). To make examples in the rest of the paper more read\u00adable, we de.ne some syntactic sugar for Boolean \nvalues. Let bool = 1 + 1, true = inj1 m1 and false = m2,where both m1 and m2 have type unit, and, for \nfresh variables x1 and x2, if e then e1 else e2 = case e (.x1.e1)(.x2.e2)  3. DCCtoF This section describes \na type-directed translation that im\u00adplements DCC s monads using parametric polymorphism. The target of \nthe translation is the polymorphic lambda cal\u00adculus (System F) extended with unit, products and sums. \nThe following grammar de.nes the syntax for F s type con\u00adtexts, term contexts, types, values and terms: \n. ::= \u00b7| ., a G ::= \u00b7| G, x : t t ::= 1 | t \u00d7t | t + t | t . t | a | .a. t u ::= <> | <m, m> | inji m \n| .x : t. m | .a. m m ::= u | prji m | case m u u | x | mm | m[t] We use the standard type system and \nthe call-by-name dynamic semantics for F [9, 11]. We write its typing judg\u00adment as .; G fm : t and its \nevaluation as m1 -. m2. Although both languages have the same basic features, only DCC has the dependency \nconstructs (.\u00a3 e and bind x = e1 in e2) while F has the parametric polymorphism (.a.e and e [t]). The \nkey observation for the translation is that a function whose input type is abstract cannot be applied \nwithout an argument of the appropriate type. Hence, if we keep that input type abstract throughout the \ntranslation, such functions can hide expressions in their body and the type system can ensure that other \nparts of the program do not depend on the expressions inside.2 2Therefore, we are actually translating \nindependency into parametricity. 3.1 Translation Let us start by de.ning the type translation s = t \nand the term translation e * = m. As both DCC and F have the same semantics for the basic constructs, \nthe following rules simply recurse on the structure of the terms and do not perform any interesting translation: \n1 (s1 \u00d7s2) (s1 + s2) (s1 . s2) <> * <e1, e2> * (prji e) * (inji e) * (case e v1 v2) * * x (.x : s. e) \n* (e1 e2) * = 1 = s \u00d7s 12 = s + s 12 = s . s 12 = <> = <e * 1, e * 2> = prji e * = inji e * *** = \ncasee v v = x 12 * = .x : s . e ** = ee 12 Now, we translate a protection under label \u00a3 as follows: (T\u00a3 \ns) = a\u00a3 . s (.\u00a3 e) * = .x : a\u00a3. e * (fresh x) We can understand a value of type a\u00a3 as a key needed to \naccess the data e.Since a\u00a3 is abstract, the only way to access the data under protection is to apply \nthe function clo\u00adsure to the right key. We will formalize this noninterference property of DCC in the \nnext section. A privileged compu\u00adtation that has a key high in the lattice, however, should be able to \nuse that key to access values lower in the lattice. We allow such downgrading of keys via coercion functions \nk\u00a3\u00a3 of type a\u00a3 . a\u00a3 . These keys and coercions are generated fresh from the translation of the lattice \nL= (L\u00a3, Lc): L = {a\u00a3 | \u00a3 .L\u00a3} \u00a3 L = {k\u00a3\u00a3 : a\u00a3 . a\u00a3 | \u00a3\u00a3 .Lc} c The real work is in the translation of \nbind:we have to insert keys and key coercions such that they satisfy the type translation above. Recall \nthat the typing rule of bind in DCC is G fe1 : T\u00a3 s1 G, x : s1 fe2 : s2 s2 \u00a3 G fbind x = e1 in e2 : s2 \nThe type system ensures that a protected expression is elim\u00adinated only if the result of the bind term \nprotects the label (s2 \u00a3). Therefore, we must translate bind into F terms that have the corresponding \nparametric property. Since this property depends on the protection derivation (s2 \u00a3), our translation \nis actually directed by the typing derivation of the term. To simplify the presentation, we enrich the \nterm bind x = e1 in e2 with its typing information and de.ne the translation on the enriched term as \nfollows: * ** (bind x : s1 = e1 in e2 : s2 \u00a3) =[[ s2 \u00a3]] (x : s1,e1,e2) Figure 1 shows the protection \ntranslation [[ s \u00a3]] (x : t,m1,m2), which is de.ned inductively on the protection derivation s \u00a3. The \n.rst four rules in the .gure simply recurse into components using extensionality. Only the last rule \nreveals the value of e1 * to e2* , which is sound because e2 is also a protection type T\u00a3 s with \u00a3\u00a3 . \nSuch dependency of e2 on e1 is translated as follows: we coerce a key of type a\u00a3 into that of a\u00a3 by applying \nthe coercion k\u00a3\u00a3 and then reveal the value of m1 = e * 1 to m2 = e * 2 by function applica\u00adtion. Note \nthat x of type s is free in e2; we keep track of the binding variable x : t = x : s and close m2 = e2 \n* only after the key is applied (.x : t. m2 x0). Let us illustrate the translation rules with an example. \nConsider the typing G f e : s in DCC, f .x1 : TL bool. bind x2 = x1 in .H x2 : TL bool . TH bool The \ntranslations of the type and the enriched term are: (TL bool . TH bool) = (TL bool) . (TH bool) = (aL \n. bool) . (aH . bool) (.x1 : TL bool. bind x2 : bool = x1 in .H x2 : TH bool L) * = .x1 : aL . bool. \n[[ TH bool L]] (x2 : bool ,x1* ,(.H x2) * ) = .x1 : aL . bool. [[ TH bool L]] (x2 : bool,x1,.x3 : aH.x2) \n= .x1 : aL . bool..x0 : aH. (.x2 : bool. (.x3 : aH. x2)x0) (x1 (kHL x0)) We also need to translate the \nlattice to obtain L \u00a3 = aH,aL and L = kHL : aH . aL and use them to close the translated c ; L * term \nto obtain the typing L \u00a3c,G f e : s in F:3 aH,aL ; kHL : aH . aL f .x1 : aL . bool..x0 : aH. (.x2 : \nbool. (.x3 : aH. x2)x0) (x1 (kHL x0)) : (aL . bool) . (aH . bool) 3.2 Correctness In this subsection \nwe prove that the translation is correct with respect to its static and dynamic semantics. These correctness \ntheorems are essential in proving the noninter\u00adference theorem in the next section. The static correctness \ntheorem below states that trans\u00adlated terms are well-typed. We only give proof sketches in this paper; \ncomplete proofs can be found in our companion technical report [20]. Theorem 1 (Static correctness). \nIf G f e : s with (L\u00a3,Lc),then * L ; L \u00a3c,Gf e : s 3Actually, as the lattice order is re.exive, we should \nhave L c = kHL : aH . aL,kHH : aH . aH,kLL : aL . aL .We leave out the last two coercions to simplify \nthe presentation in later sections. Proof. We prove the theorem by induction on the typing derivation \nand use the following lemma in case of bind. Lemma 2. If .; G f m1 : a\u00a3 . t and .; G,x : t f m2 : s \n, then .; G f [[ s \u00a3]] (x : t,m1,m2) : s . In order to relate the dynamic semantics of the two lan\u00adguages \nin a declarative style, we de.ne the following transla\u00adtion relation v . u : t to relate a DCC value \nv to an F value u at DCC type t. It is a logical relation [9] that formalizes the behavioral equivalence \nof the dynamic semantics. <> . <> : 1 (DF-Unit) e1 . m1 : s1 e2 . m2 : s2 (DF-Pair) <e1,e2> . <m1,m2> \n: s1 \u00d7 s2 e . m : si (DF-Inj) inji e . inji m : s1 + s2 .(e . m : s1). ve . um : s2 (DF-Fun) v . u : \ns1 . s2 .( f m : t). e . um : s (DF-Prot) .\u00a3 e . u : T\u00a3 s e -. * vm -. * uv . u : s (DF-Term) e . m : \ns The last rule de.nes the translation relation e . m : s for terms by extending the corresponding relation \nfor values v . u : t with evaluation. We will similarly extend other logical relations for values to \nterms by evaluation in later sections. Note that the relation above is de.ned for closed types and terms. \nOur translated types and terms, however, have free type variables a\u00a3 for the lattice labels and free \nterm variables k\u00a3\u00a3 for the lattice order. By the static correctness theorem, we know that those types \nand terms are closed under L and L . \u00a3 c At runtime, we need to link the open term with a well\u00adtyped \nimplementation of the keys and the coercions. We formalize this linking using term and type substitutions. \nLet . denote a .nite map from term variables to values and let d denote a .nite map from type variables \nto closed types: . ::= \u00b7 | x . v d ::= \u00b7 | a . t We de.ne d(G) as the pointwise application of d to the \nrange of G such that (d(G))(x) = d(G(x)). Also, we gen\u00aderalize the de.nition of the translation relation \nfor values v . u : t to term substitutions such that . . . : d(G) if .(x) . . (x) : d(G(x)) for all x \n. dom(.) = dom(. ) = dom(G). Formally we state the typing requirements of the substitutions as: . |= \nG i. f .(x) : G(x) d |= . i. dom(d) = . At last, the dynamic correctness theorem below states that if \na term and a linking are well-typed, then the source and the target terms have the same dynamic behavior. \nTheorem 3 (Dynamic correctness). If G f e : s L L with (L\u00a3,Lc), d0 |= \u00a3, . . . : d0(G),and .0 |= c, then \n.(e) . d0.0. (e * ) : s Proof. We prove the theorem by induction on the typing derivation and use the \nfollowing lemma in case of bind. Lemma 4. If .; G, x : t f m2 : s, d0 |= ., .0 |= G , m1 m0 -. * m and \ne2 . m2 {m/x} : s,then e2 . d0 .0[[ s \u00a3]] (x : t, m1 , m2 ).  4. Theorems This section proves the main \ntheoretical result of the pa\u00adper: the parametricity theorem for F implies the noninterfer\u00adence theorem \nfor DCC. Both theorems are de.ned in terms of logical equivalence of the dynamic semantics; therefore, \nwe will use logical relations again to de.ne related values for DCC and those for F. Then, we come up \nwith a canonical implementation consisting of substitutions for terms, types and relations in F. Using \nthese substitutions we can instan\u00adtiate parametricity to prove noninterference. 4.1 Logical equivalences \nWe formalize logical equivalences as logical relations. For DCC, they extend the identity relations, \nexcept that data in a monad higher in the lattice is opaque at levels lower in the lattice. We write \nv ~. v : s to denote two related DCC values v and v at type s below observation bound ..These relations \nare de.ned as follows: <> ~. <> : 1 (DR-Unit) e1 . e1 : s1 e2 . e2 : s2 (DR-Pair) <e1 , e2 > ~. <e1 , \ne2> : s1 \u00d7 s2 e . e : si (DR-Inj) inji e ~. inji e : s1 + s2 .(e . e : s1 ). ve . ve : s2 (DR-Fun) v \n~. v : s1 . s2 \u00a3. (DR-Label1) .\u00a3 e ~. .\u00a3 e : T\u00a3 s e . e : s \u00a3. (DR-Label2) .\u00a3 e ~. .\u00a3 e : T\u00a3 s e -. * \nve -. * vv ~. v : s (DR-Term) e . e : s Except for protection .\u00a3 e, the de.nitions above are stan\u00addard \n[9]. The parameter . is the context s observation label, capturing the intuition that the equivalence \nof two terms de\u00adpends on the label of the observer [21, 6, 24, 16, 12]. For T\u00a3 s, either the observer \ns label is below the bound (\u00a3.) in which case all values are related (DR-Label1), or two pro\u00adtected terms \nare actually related recursively (DR-Label2). Similarly, we de.ne related values for F. However, instead \nof labels and bounds for DCC, two F values are related at type t under relation substitution . (which \nmaps type vari\u00adables to relations), written v ~ v : t | .. These relations are de.ned as follows: <> \n~ <> : 1 | . (FR-Unit) m1 m1 : t1 | . m2 m2 : t2 | . (FR-Pair) <m1 , m2 > ~ <m1 , m2 > : t1 \u00d7 t2 | \n. m m : ti | . (FR-Inj) inji m ~ inji m : t1 + t2 | . .(m m : t1 | .). um um : t2 | . (FR-Fun) u ~ \nu : t1 . t2 | . (u, u) . R (FR-Var) u ~ u : a | (., a . R) .(R . t2 . t2 ). u[t2] u [t2] : t1 | (., \na . R) (FR-All) u ~ u : .a. t1 | . m -. * um -. * uu ~ u : t | . (FR-Term) m m : t | . The relation \nis the usual logical relation for System F [22]. Rule FR-All says that . maps type variable a to any \nrelation respecting the types (R . t2 . t2 ). We write t2 . t2 to denote the set of all binary relations \nover values of the types t2 and t2. For example, the empty relation \u00d8 and the diagonal relation {(<>, \n<>)} for unit (which we will use in later sections) are both in the set of all binary relations over \nunit and unit. We can also derive the related values at bool in F as follows. The encoding of Boolean \nin Section 2 and the rules FR-Unit and FR-Inj imply the following equivalence: m m : 1 | . inji m ~ \ninji m : 1 + 1 | . That is, at bool, logical equivalence implies \u00df-equivalence modulo the de.nitions \nof true and false in Section 2. In particular, the de.nition does not relate the values true and false. \nThe same is true for Booleans in DCC. 4.2 Parametricity System F s parametricity theorem (below) states \nthat, in\u00addependent of substitutions for terms, types and relations, a well-typed term is related to itself. \nWe write . . d . d as the pointwise extension of R . t2 . t2 (which is de.ned in the last subsection) \nsuch that .(a) . d(a) . d (a) for all a . dom(.) = dom(d) = dom(d ). Theorem 5 (Parametricity). If .; \nG f m : t and d, d |= . and . . : G | . and . . d . d ,then d.(m) d. (m) : t | . Proof. Proofs can \nbe found in standard references [14, 22]. We have a full proof in our notation in the technical report \nand we use the following substitution lemma when the induction case is type application. Lemma 6. If \nm m : t1 | (., a . [[ t2]] . ),then m m : t1 {t2/a} | . where [[ t2 ]] . = {(u, u) | u ~ u : t2 | .}. \nTo motivate our general proof of noninterference from this parametricity theorem, we demonstrate a simple \napplication using Wadler s free theorems [22]. Recall from the introduc\u00adtion,that a DCCterm oftype TH \nbool . TL bool translates to a term m of type (aH . bool) . (aL . bool).We use a free theorem to demonstrate \nthat m is a constant function, which is required for noninterference.. In this instance, we pick the \nfollowing substitutions for types, terms and relations: d0 = aH. 1, aL. 1 .0 = kHL. .x : 1.x .0 = aH \n. \u00d8,aL . {(<>, <>)} By the parametricity theorem and the typing L ; L fm : \u00a3 c (aH . bool) . (aL . bool),wehave \nd0.0 (m) d0.0 (m) : (aH . bool) . (aL . bool) | .0 Applying FR-Fun two times, we have d0.0 (m) m1 m2 \n d0 .0(m) m1 m2 : bool | .0 for all m1 m1 : aH . bool | .0 and for all m2 m2 : aL | .0 .Since .0 maps \naH to the empty re\u00adlation, m1 and m1 can be di.erent terms (such as .x : 1. true and .x : 1. false). \nYet .0 maps aL to the diagonal re\u00adlation. As the relation of related values at bool implies \u00df-equivalence, \nd0.0 (m) m1 m2 is equivalent to d0 .0(m) m1 m2 despite the di.erence in the arguments. In other words, \nm is a constant function, or its argument does not interfere with its output. The key point is that .0 \nmaps thetypevariable for the high view to be the empty relation (aH . \u00d8) and the variable for the low \nview to be the diagonal relation on 1 (aL. {(<>, <>)}). Because we translate a protection type T\u00a3 s intoafunction \ntype a\u00a3 . s , we have the complete relation over s when \u00a3 = H and we have the relation de.ned by s \nwhen \u00a3 = L. The complete relation formally captures the requirement that the observer cannot distinguish \nvalues in the high view. Another way to motivate the construction of .0 is the following two isomorphisms \nof relations: \u00d8. R =~T and ~ 1 . R = R. The former isomorphism says that a function relation from an \nempty relation \u00d8to an arbitrary relation R is isomorphic to the total relation T. Thus, setting aH. \u00d8 \nimplies the total relation for the high view, meaning all val\u00adues are related (see DR-Label1 in Section \n4.1). On the other hand, the latter isomorphisms says that a function relation from a diagonal relation \n1 and an arbitrary relation R is iso\u00admorphism to the relation R itself. Thus, setting aL 1 . implies \nthe relation R itself for the low view, meaning values are related if they are related recursively (see \nDR-Label2). 4.3 Noninterference We generalize the approach above to arbitrary lattices and terms to \nprove the noninterference theorem. First, we de.ne an appropriate implementation of keys based on the \nlattice L: [[ L\u00a3 ]] 1 = {a\u00a3 . 1 | \u00a3 .L\u00a3} [[ Lc]] 1 = k\u00a3\u00a3 | \u00a3\u00a3 .Lc} . .x : 1.x { a\u00a3 if \u00a3 . \u00d8 . [[ L\u00a3 \n]] . = a\u00a3 if \u00a3 . {(<>, <>)} . This canonical implementation substitutes unit for keys and identity functions \nfor key coercions. The relation sub\u00adstitution is the diagonal relation if the observer s label is higher \nthan the data s label, or the empty relation other\u00adwise. This property of [[ L\u00a3 ]] . is critical in proving \nLemma 8 and Lemma 9 below. The noninterference theorem states that a well-typed term cannot distinguish \nsubstitutions of di.erent values higher than the observer s bound. We de.ne . * as . * (x) = e * i. .(x) \n= e. Theorem 7 (Noninterference). If G f e : s with (L\u00a3, Lc) and . . . : G ,then .(e) . . (e) : s Proof. \nBy Theorem 1 (Static correctness), the trans\u00ad * lated term is well-typed: L\u00a3 ; Lc,G fe : s . By the \ndef\u00ad inition of d0 =[[ L\u00a3 ]] 1 ,we have d0 |= [[ L\u00a3 ]] . By Lemma 8 (Relation correctness), the translated \nsubstitutions are re\u00adlated: .0. * .0 . * : Lc ,G | .0 .Since .0 =[[ L\u00a3 ]] . is either the empty relation \nor the diagonal relation, .0 .d0 . d0. Then, by Theorem 5 (Parametricity), the translated terms ) d0.0 \n. * are related: d0 .0. * (e * (e * ) : s | .0 . By the de.nition of .0 |= [[ Lc]] 1 ,we have .0 |= Lc \n.The result then follows by Theorem 3 (Dynamic correctness) and Lemma 9 (Adequacy). Lemma 8 (Relation \ncorrectness). 1. If . . . : G with (L\u00a3, Lc) and .0 |= Lc,then .0. * .0. * : Lc,G | [[ L\u00a3 ]] . . 2. If \ne . e : s with (L\u00a3, Lc) and .0 |= Lc,then .0(e * ) .0 (e * ) : s | [[ L\u00a3 ]] . . Proof. We prove part \n2 by induction on the derivation of the related terms and thus, by inversion, the deriva\u00adtion of the \nrelated values v ~. v : s.The important case is s = T\u00a3 s0 .When \u00a3. and thus [[ L\u00a3 ]] . is the empty relation, \nthere do not exist m and m such that m m : a\u00a3 | [[ L\u00a3 ]] . . The substituted values are related at the \ns0) function types (T\u00a3 = a\u00a3 . s0 because the premise .(m m : a\u00a3 | [[ L\u00a3 ]] . ). um um : s0 | [[ L\u00a3]] \n. is vacuously true. When \u00a3., we use the induction hypothesis. Lemma 9 (Adequacy). If e . d0(m) : s, \ne . d0(m ) : s with (Ld0 |= L and m m : s | [[ L\u00a3]] . ,then \u00a3 , Lc), \u00a3 e . e : s. Proof. We prove the \nlemma by induction on the type s. When s = T\u00a3 s0 and \u00a3. and thus [[ L\u00a3 ]] . is the diagonal relation, \nm m : a\u00a3 | [[ L\u00a3]] . for all m, m .Since (T\u00a3 s0 ) = a\u00a3 . s 0 and thus m and m are related at the function \ntypes, we have um um : s | [[ L\u00a3]] . given that m -. * u and m -. * u . We can then use induction hypothesis \nto satisfy DR-Label2. In the last subsection, we used the parametricity theorem to prove that a term \nm of type (TH bool . TL bool) = (aH . bool) . (aL . bool) is a constant function in F. As an exercise, \nwe want to prove, directly from the noninterference theorem, that a term e of type TH bool . TL bool \nis also a constant function in DCC. Suppose fe : TH bool . TL bool. By the noninterference theorem, e \n. e : TH bool . TL bool. Expanding the de.nition of DR-Fun, we have ee2 . ee2 : TL bool for all e2 . \ne2 : TH bool. Since there are only two points in the lattice, we have L .. Let us pick . = L such that \nH ..Hence e2 and e2 can be di.erent terms (such as .\u00a3 true and .\u00a3 false) but still related by DR-Label1. \nYet ee2 and ee2 are related by DR-Label2, implying that both terms evaluate to related Boolean values \ndespite their arguments. Because the relation at type bool implies \u00df\u00adequivalence (up to the de.nition \nof bool), it follows that e is a constant function.  5. Extending DCC Having shown that TH bool . TL \nbool is a constant func\u00adtion, it is natural to ask: what about functions of other combinations of high \nbooleans and low booleans? We can easily construct both the constant functions and the identity functions \nof types TL bool . TL bool and TH bool . TH bool; therefore, functions of these two types are unconstrained. \nThe other interesting case is TL bool . TH bool. We claim that, from the high observer s view (. = H), \nTL bool . TH bool is isomorphic to bool . bool. This isomorphism gives us con.dence that adding labels \nto a language does not reduce the expressiveness of the language: if we have a function of type bool \n. bool, we can always write an equiva\u00adlent function of TL bool . TH bool such that the dependency information \nis explicit. But, because of typing, we fail to prove such an isomor\u00adphism in DCC. This section describes \nhow we instead prove the isomorphism in F and, using insights of the proof, how we extend DCC to type-check \nthe mediating functions for the isomorphism. 5.1 Excursion to parametricity First, we propose the following \nmediating functions in DCC for the isomorphism of s = TL bool . TH bool and bool . bool: f1 : (bool . \nbool) . s = .x1 : bool . bool..x2 : TL bool. bind x3 = x2 in .H (x1 x3 ) g1 : s . (bool . bool) = .x4 \n: s..x5 : bool. bind x6 = x4 (.L x5 )inx6 But g1 does not type-check. We cannot show bool H in type-checking \nx4 : s, x5 : bool fbind x6 = x4 (.L x5 )inx6 : bool with DT-Bind. Instead we will show that t is isomorphic \nto (bool . bool) = bool . bool in F where t = .aH . .aL . (aH . aL) . (aL . bool) . (aH . bool) First, \nwe construct these mediating functions in F: f2 : (bool . bool) . t = .x1 : bool . bool..aH ..aL ..x2 \n: aH . aL. .x3 : aL . bool..x4 : aH. x1 (x3 (x2 x4 )) g2 : t . (bool . bool) = .x5 : t..x6 : bool. x5 \n[1][1] (.x7 : 1. x7)(.x8 : 1. x6 )<> Now we need to prove that g2 . f2 and f2 . g2 are identity functions. \nThe .rst identity g2 . f2 is straightforward from \u00df.-reductions and we use = to denote \u00df.-equivalence. \nFor all fm0 : bool . bool, (g2 . f2 )m0 = .x6 : bool. (.x2 : 1 . 1. .x3 : 1 . bool..x4 : 1. m0 (x3 (x2 \nx4))) (.x7 : 1. x7)(.x8 : 1. x6 )<> = .x6 : bool. (.x4 : 1. m0 x6 )<> = m0 The second identity f2 . g2 \nrequires the parametricity theorem: for all fm1 : .aH . .aL . (aH . aL ) . (aH . bool) . (aL . bool): \n(f2 . g2 )m1 = .aH ..aL ..x2 : aH . aL..x3 : aL . bool..x4 : aH . (.x6 : bool. m1 [1][1](.x7 : 1. x7 \n) (.x8 : 1. x6) <>) (x3 (x2 x4 )) = .aH ..aL ..x2 : aH . aL..x3 : aL . bool..x4 : aH . m1 [1][1](.x7 \n: 1. x7 )(.x8 : 1. (x3 (x2 x4 ))) <> We appear to be stuck at this point: there are no more \u00df.\u00adreductions \nto apply because m1 is abstract. However, m1 has a polymorphic type t and, by the parametricity theorem, \nm1 m1 : .aH . .aL . (aH . aL ) . (aH . bool) . (aL . bool) | .. Expanding the de.nitions of FR-All and \nFR-Fun (together with FR-Term) for a few times, we obtain m1 [t1 ][t2 ]m2 m3 m4 m1 [t1][t2]m2 m3 m4 : \nbool | . as long as the following conditions are satis.ed: . = ., aH . R1 ,aL . R2 R1 . t1 . t1 R2 . \nt1 . t1 m2 m2 : aH . aL | . m3 m3 : aL . bool | . m4 m4 : aH | . We pick the types, relations and terms \nas follows: t1 = 1 t1 = aH t2 = 1 t2 = aL R1 = .x1 : 1. x4 R2 = .x2 : 1. x2 x4 m2 = .x7 : 1. x7 m2 = \nx2 m3 = .x8 : 1. x3 (x2 x4 )m3 = x3 m4 = <> m4 = x4 But we need to check that these de.nitions satisfy \nthose conditions above. First, since R1 is a function of type 1 . aH, we have R1 . 1 . aH (a binary relation \nof 1 and aH ). The same goes for R2 of type 1 . aL. Then, we check that m2 m2 : aH . aL | . .By FR-Fun, \nit is equivalent to check that m2 m5 m2 m5 : aL | . for all m5 m5 : aH .By FR-Var, m5 = R1 m5 = x4 \nand it is equivalent to check that R2 (m2 m5) = m2 m5 . Indeed, R2 (m2 m5 ) = (.x1 : 1. x2 x4 )((.x7 \n: 1. x7)m5) = x2 x4 and m2 m5 = x2 (R1 m5 ) = x2 x4 . Similarly, we check that m3 m3 : aL . bool | . \n.For all m6 m6 : aL | . such that m6 = R2 m6 = x2 x4,we have m3 m6 = (.x8 : 1. x3 (x2 x4 )) m6 = x3 \n(x2 x4) and m3 m6 = x3 (x2 x4 ).At last, we check that m4 m4 : aH | . which follows from R1 m4 = x4 and \nm4 = x4. Since the relation of related values at bool implies \u00df\u00adequivalence, the parametricity theorem \nimplies that m1 [1][1](.x7 : 1. x7 )(.x8 : 1. (x3 (x2 x4 ))) <> = m1 [aH ][aL ]x2 x3 x4 which we can \nuse to .nish the proof: (f2 . g2 )m1 = \u00b7\u00b7\u00b7 = .aH ..aL ..x2 : aH . aL..x3 : aL . bool..x4 : aH. m1 [aH \n][aL ]x2 x3 x4 = m1 5.2 Protection contexts The excursion to F and parametricity shows that our intu\u00adition \nis right: TL bool . TH bool is isomorphic to bool . bool (from the high observer s view) in a richer \nsystem like F, even though their mediating function does not type-check in DCC. Using insights from the \ntranslation, we now show how to extend DCC s type system to allow such an isomor\u00adphism. From the translation, \nwe observe that the protection con\u00adtext is explicit in the typing rule of functions in F but missing \nin the typing rule of bind in DCC. In F, protections .\u00a3 e are translated into functions and the type \nsystem uses the typ\u00ading context G to keep track of the variable assumptions and thus the protection assumptions. \nIn DCC, the type system does not make such protection assumptions of a term. For example, .H (bind x \n= .H true in x) should type-check, be\u00adcause the result of the bind is protected by .H in the outside \ncontext, but this term is not well-typed in DCC. Therefore, we propose to extend the typing judgment \nof DCC to be G; p fe : s where p .L\u00a3 is the protection context. This is similar to the program counter \nlabels that provide contextual information found in security-typed lan\u00adguages [6, 25, 19]. The function \ntypes s1 . s2 now becomes [p]s1 . s2 to account for the protection context. The new typing rules are: \nG, x : s1; p2 fe : s2 G; p1 f.x : s1 . e : [p2]s1 . s2 G; p1 fe1 : [p2]s1 . s2 G; p1 fe2 : s1 p2 p1 G; \np1 fe1 e2 : s2 G; p U\u00a3 fe : s G; p f.\u00a3 e : T\u00a3 s G; p fe1 : T\u00a3 s1 G, x : s1 ; p fe2 : s2 p fs2 \u00a3 G; p \nfbind x = e1 in e2 : s2 The other typing rules are essentially the same but now pass around the protection \ncontext. We add the following new protection rules that make use of the protection context, or call the \nold rules otherwise: \u00a3p s \u00a3\u00a3 p p fs \u00a3p fs \u00a3 It appears to be straightforward to extend the transla\u00adtion \nfor this augmented version of DCC by using the fol\u00adlowing type translation for functions: ([p]s1 . s2 \n) = (ap \u00d7s1 ) . s2 . Protection contexts are also useful for other types whose values may contain delayed \ncomputations. For example, in call-by-name calculi like DCC, the protection context of a product type \n([p]t1 \u00d7t2 ) expresses the con\u00adstraint that a projection of the product can be made only in a context \nhigher or equal to p. The typing and translation rules for protection contexts of other types are similar \nto those for function types; we do not investigate further here. 5.3 Isomorphism Given the modi.ed type \nsystem for DCC, we now go back to show the isomorphism of s = TL bool . TH bool and bool . bool by proving \nthat g1 .f1 and f1 .g1 are identity functions from the high observer s view (. = H). The tech\u00adnique is \nsimilar to proving the identities of f2 and g2 using the parametricity theorem in Section 5.1, but instead \nuses the noninterference theorem. The mediating functions now type-check and have the fol\u00adlowing types. \nWith the additional constraint [H] on the pro\u00adtection context of g1 ,the term bind x6 = x4 (.L x5 )inx6 \nsatis.es the new rule above because H fbool H. f1 : [L] ([L] bool . bool) . ([L] TL bool . TH bool) g1 \n: [H] ([L] TL bool . TH bool) . ([L] bool . bool) As before, we use \u00df.-reductions in DCC to prove the \niden\u00adtities, using these equivalences: bind x = .\u00a3 einx =\u00df e .\u00a3 (bind x = ein x) =. e The .rst identity \ng1 .f1 is straightforward: for all fe0 : [L] bool . bool,we have (g1 .f1 )e0 = .x5 : bool. bind x6 = \n.H (e0 x5 )inx6 = e0 . The second identity f1 .g1 requires the noninterference theorem: for all fe1 : \n[L] TL bool . TH bool,we have (f1 .g1 )e1 = .x2 : TL bool. bind x3 = x2 in e1 (.L x3 ). There are no \nmore \u00df.-reductions to apply because e1 is abstract. But, using the noninterference theorem, we will prove \nthe following to order to .nish the proof: .x2 : TL bool. bind x3 = x2 in e1 (.L x3) = .x2 : TL bool. \ne1 x2 Consider the applications of these two functions with two related terms. For all m2 H m2 : TL bool \nsuch that m2 -. * .L m3 and m2 -. * .L m3 and m3 H m3 : bool,wehave (.x2 : TL bool. bind x3 = x2 in e1 \n(.L x3)) m2 -. * e1 (.L m3) and (.x2 : TL bool. e1 x2)m3 -. * e1 (.L m3).By DR-Label2, .L m3 H .L m3 \n: TH bool. By noninterference and the typing fe1 : TL bool . TH bool,wehave e1 H e1 : TL bool . TH bool. \nExpanding the de.nition of DR-Fun, we have e1 (.L m3 ) H e1 (.L m3 ) : TL bool.Hence, .x2 : TL bool. \nbind x3 = x2 in e1 (.L x3 ) H .x2 : TL bool. e1 x2 : TL bool . TH bool,which is the \u00df.\u00adequivalence from \nthe high observer s view.  6. Discussion We have shown in this paper that dependency analyses embodied \nby DCC s type system can be translated into F s parametricity. This embedding uses only a small subset \nof F for instance it does not require any nontrivial use of type abstraction or application. DCC therefore \nappears to be much weaker than F. One possible future direction is to investigate additional extensions \nthat preserve DCC s spirit while admitting more of the expressiveness of F. For in\u00adstance, generating \nnew labels dynamically may correspond to .rst-class type abstraction in F. This connection is al\u00adready \nbeing explored by Fluet and Morrisett, who are in\u00advestigating the relationship between region-based memory \nmanagement, Haskell-style monadic e.ects, and polymor\u00adphism [3].  6.1 Haskell implementation Another \nfuture direction is to use the ideas behind this translation to provide implementations of dependency \nanal\u00adyses in polymorphic languages. Figure 2 shows a prototype implementation in Haskell4 for DCC with \nthe two-point lat\u00adtice LH. 4We use Glasgow Haskell Compiler (GHC) 6.2 with .ags -fglasgow-exts and -fallow-undecidable-instances. \ndata H eta :: s-> Tl newtype Tl s= class Bind l s2 instance Bind l bind m1m2 = instance (Bind bind m1m2 \n= instance (Bind bind m1m2 = instance (Bind bind m1m2 = instance Bind L s T (l -> s) ; ; ; data L = \nKhl H eta e = T (\\x -> t (T x) = x e) -\u00ad-\u00ad-- Lattice Monad injection T constructor/destructor where bind \n:: T l s1 -> (s1 -> s2) -> s2 () where () l s1, Bind l s2) => Bind l (s1, s2) where (bind m1 (fst . m2), \nbind m1 (snd . m2)) l s2) => Bind l (s1 -> s2) where \\x0 -> bind m1 (\\x -> m2 x x0) H s) => Bind H (T \nL s) where T (\\x0 -> bind m1 (\\x -> t (m2 x) x0)) -\u00ad-\u00ad-\u00ad-\u00ad P-Unit, LP-Unit P-Pair, LP-Pair P-Fun, LP-Fun \nP-Label1, LP-Label1 with H </= L (T H s) where -\u00ad P-Label2, LP-Label2 with L <= H bind (T m1) m2 = T \n(\\x0 -> t (m2 (m1 (Khl x0))) x0) instance Bind l (T l s) where --P-Label2, LP-Label0, reflexive bind \n(T m1) m2 = T (\\x0 -> t (m2 (m1 x0)) x0) Figure 2: Prototype implementation in Haskell for the two-point \nlattice Abstract datatypes H and L along with the key coercion function Khl :: H -> L encode the lattice. \nThe type of the function eta:: s -> T ls corresponds to the typing rule DT-Prot in Section 2: G f e \n: s (DT-Prot) G f .\u00a3 e : T\u00a3 s The de.nitions of the type newtype Tl s= T(l -> s) and the function eta \ne =T (\\x ->e) correspond to the translation rule for protection under label \u00a3 in Section 3.1: (T\u00a3 s) \n= a\u00a3 . s (.\u00a3 e) * = .x : a\u00a3. e * (fresh x) Finally the destructor t(Tx)= x encodes the evaluation rule \nof bind: bind x = .\u00a3 eine2 -. e2{e/x} The last part of the implementation is to use the type\u00adclass Bind \nto encapsulate the typing rule DT-Bind and its protection rules s \u00a3 for the bind operations in Section \n2. Each instance of the Bind typeclass corresponds to a trans\u00adlation rule in Figure 1, except that we \nalso have the instance for the implicit re.exive cases LP-Label0 when HH and L L. The example in Section \n3.1 type-checks in Haskell: e :: T LBool -> T HBool e x1 = bind x1 (\\x2 -> eta x2) On the other hand, \nif e is constrained to have the type e :: T HBool ->T LBool, Haskell will correctly report a type error \nbecause of the illegal dependency of a low output on the high input. If we omit the type annotation, \nHaskell can even do label inference: e :: forall s l1 l. (Bind l(T l1 s))=> T ls -> T l1s Unfortunately, \nthis implementation requires O(n 2 ) type\u00adclass instances to encode the bind translation for a lattice \ncontaining n labels. We could have factored the lattice edges into two classes, class LE ( , less than \nor equal to) and class GT ( , greater than), such that the number of class instances is shifted to these \ntwo classes, and Bind would only have two instances (one for LE and one for GT). This construc\u00adtion still \nhas the same complexity of class instances and it requires non-standard Haskell extensions for checking \nnon\u00adoverlapping and complementary instances, but it may be a more modular approach. It would also be \ninteresting to see whether other clever programming tricks, such as phantom types [4], could reduce this \noverhead. Another alternative is to use explicit sub\u00adtyping and bounded quanti.cation, such as F<: [11], \nwhich would simplify the description of the label lattice consider\u00adably.  6.2 Fixpoints and termination \nIt is known that adding fix (and side-e.ects in general) to System F weakens the parametricity theorem \nbecause pro\u00adgrams may diverge [22, 8, 7]. A similar phenomenon arises in noninterference, which may be \nde.ned to be termination sensitive [6, 1]. This paper focuses on the terminating fragment of DCC, which \nhelps to emphasize the connection between noninter\u00adference and parametricity. Like the original DCC, \nwe would need to add pointed types and a fix operator to F to account for termination. We expect that \nall of the results presented here carry through to the case where fix is added to both DCC and F, assuming \nthat noninterference and parametric\u00adity are suitably weakened to account for the possibility of diverging \ncomputations [7]. However, the translation should be slightly altered to prevent forged keys from being \nused to access protected data. The problem is that having fix in the language allows arbitrary keys or \ncoercions to be created, because all types are inhabited. For example, the following term fix (.x : aH \n. x) : aH can be used to unlock any high-security data. Note that, however, this term is non-terminating. \nTo prevent such keys from being used by a bad F context, we can simply force the evaluation of the key \nby using a construct similar to seq in Haskell. Essentially, we need to modify the translation rules \nfor protection LP-Label1 and LP-Label2 in Figure 1 as follows: [[ T\u00a3 s \u00a3]] (x : t, m1, m2) where \u00a3\u00a3 = \n.x0 : a\u00a3 . seq x0 ([[ s \u00a3]] (x : t, m1 , m2 x0 )) [[ T\u00a3 s \u00a3]] (x : t, m1, m2) where \u00a3\u00a3 = .x0 : a\u00a3 . seq \nx0 ((.x : t. m2 x0)(m1 (k\u00a3\u00a3 x0))) Further investigating the interactions between side e.ects and relational \nparametricity is an important area of ongoing research. 6.3 Related work The ideas behind our encoding \nof DCC into F are simi\u00adlar to Sumii and Pierce s work on the cryptographic lambda calculus [17]. They \nuse logical relations (and, more recently, bisimulations [18]) to capture the e.ects of encryption as \nan information-hiding mechanism. Knowledge of a crypto\u00adgraphic key is su.cient to reveal the encrypted \ndata. In this paper, our translation uses function closures with types of the form a\u00a3 . t to represent \nhidden data of type t. Posses\u00adsion of a key of type a\u00a3 allows the computation to obtain the data hidden \nin the closure. Unlike Sumii and Pierce s work, our translation must also account for DCC s lattice order \nusing key coercions. Sabelfeld and Sands used PER models to prove nonin\u00adterference properties in the \ncontext of information-.ow se\u00adcurity [16]. Benton uses logical relations to prove program transformations \nrelated to information-.ow and dependency correct [2]. Both of these approaches, as we do here, use complete \nrelations to represent abstract views of data. Other researchers have studied languages via translation \ninto F. For example, Washburn and Weirich [23] use para\u00ad metric polymorphism to encode higher-order abstract \nsyn\u00adtax. There, parametricity is also essential to show that the encoding is adequate.  7. Conclusion \nThis paper has shown how to encode the dependency core calculus, which is useful for modeling many kinds \nof pro\u00adgram analyses, into System F. This encoding provides both novel insights into the relationship \nbetween dependency and parametricity and an alternate proof of DCC s noninterfer\u00adence theorem. We also \ngive a prototype implementation of this translation in Haskell.  Acknowledgments The authors thank Eijiro \nSumii, Stephanie Weirich, and the anonymous reviewers for their comments on drafts of this paper. Stephanie \nalso provided the Haskell prototype. This research was supported in part by National Science Foundation \ngrants CNS-0346939 (CAREER: Language-based Distributed System Security) and CCR-0311204 (Dynamic Security \nPolicies). References [1] Mart\u00b4in Abadi, Anindya Banerjee, Nevin Heintze, and Jon Riecke. A core calculus \nof dependency. In Proc. 26th ACM Symp. on Principles of Programming Languages (POPL), pages 147 160, \nSan Antonio, TX, January 1999. [2] Nick Benton. Simple relational correctness proofs for static analyses \nand program transformations. In Proc. 31st ACM Symp. on Principles of Programming Languages (POPL), pages \n14 25. ACM Press, 2004. [3] Matthew Fluet and Greg Morrisett. Monadic regions. In Proc. ACM SIGPLAN International \nConference on Functional Programming (ICFP), 2004. [4] Matthew Fluet and Riccardo Pucella. Phantom types \nand subtyping. In Proc. of the 2nd IFIP International Conference on Theoretical Computer Science, 2002. \n[5] J.-Y. Girard. Interpr\u00b4etation Functionelle et \u00b4 Elimination des Coupures dans l Arithm\u00b4etique d \nOrder Sup\u00b4erieure. PhD thesis, Universit\u00b4e Paris VII, 1972. [6] Nevin Heintze and Jon G. Riecke. The \nSLam calculus: Programming with secrecy and integrity. In Proc. 25th ACM Symp. on Principles of Programming \nLanguages (POPL), San Diego, California, 1998. [7] Patricia Johann and Janis Voigtl\u00a8ander. Free theorems \nin the presence of seq. In Proc. 31st ACM Symp. on Principles of Programming Languages (POPL), 2004. \n[8] J. Launchbury and R. Paterson. Parametricity and unboxing with pointed types. In Proc.ofthe 9th European \nSymposium on Programming, 1996. [9] John C. Mitchell. Foundations for Programming Languages. The MIT \nPress, 1996. [10] Eugenio Moggi. Notions of computation and monads. Information and Computation, 1:55 \n92, 1991. [11] Benjamin C. Pierce. Types and Programming Languages. The MIT Press, 2002. [12] Fran\u00b8cois \nPottier and Vincent Simonet. Information .ow inference for ML. In Proc. 29th ACM Symp. on Principles \nof Programming Languages (POPL), 2002. [13] John C. Reynolds. Towards a theory of type structure. In \nProgramming Symposium,volume 19of Lecture Notes in Computer Science. Springer-Verlag, 1974. [14] John \nC. Reynolds. Types, abstraction, and parametric polymorphism. In Information Processing. Elsevier Science \nPublishers B.V., 1983. [15] Andrei Sabelfeld and Andrew C. Myers. Language-based information-.ow security. \nIEEE Journal on Selected Areas in Communications, 21(1):5 19, January 2003. [16] Andrei Sabelfeld and \nDavid Sands. A PER model of secure information .ow in sequential programs. Higher-Order and Symbolic \nComputation, 14(1):59 91, March 2001. [17] Eijiro Sumii and Benjamin C. Pierce. Logical relations for \nencryption. In Proc. of the 14th IEEE Computer Security Foundations Workshop, 2001. [18] Eijiro Sumii \nand Benjamin C. Pierce. A bisimulation for dynamic sealing. In Proc. 31st ACM Symp. on Principles of \nProgramming Languages (POPL).ACM Press, 2004. [19] Stephen Tse and Steve Zdancewic. Run-time principals \nin information-.ow type systems. In Proc. IEEE Symposium on Security and Privacy, 2004. To Appear. [20] \nStephen Tse and Steve Zdancewic. Translating dependency into parametricity. Technical report, University \nof Pennsylvania, January 2004. [21] Dennis Volpano, Geo.rey Smith, and Cynthia Irvine. A sound type system \nfor secure .ow analysis. Journal of Computer Security, 4(3):167 187, 1996. [22] Philip Wadler. Theorems \nfor free! In Proceedings of the 4th International Symposium on Functional Programming and Computer Architecture, \nSeptember 1989. [23] Geo.rey Washburn and Stephanie Weirich. Boxes go bananas: Encoding higher-order \nabstract syntax with parametric polymorphism. In Proc. of the 8th ACM SIGPLAN International Conference \non Functional Programming, Upsala, Sweden, August 2003. [24] Stephan Zdancewic. Programming Languages \nfor Information Security. PhD thesis, Cornell University, 2002. [25] Steve Zdancewic and Andrew C. Myers. \nSecure information .ow and CPS. In Proc. of the 10th European Symposium on Programming, 2001.  \n\t\t\t", "proc_id": "1016850", "abstract": "Abadi et al. introduced the <i>dependency core calculus</i> (DCC) as a unifying framework to study many important program analyses such as binding time, information flow, slicing, and function call tracking. DCC uses a lattice of monads and a nonstandard typing rule for their associated <i>bind</i> operations to describe the dependency of computations in a program. Abadi et al. proved a <i>noninterference</i> theorem that establishes the correctness of DCC's type system and thus the correctness of the type systems for the analyses above.In this paper, we study the relationship between DCC and the Girard-Reynolds polymorphic lambda calculus (System F). We encode the recursion-free fragment of DCC into F via a type-directed translation. Our main theoretical result is that, following from the correctness of the translation, the parametricity theorem for F implies the noninterference theorem for DCC. In addition, the translation provides insights into DCC's type system and suggests implementation strategies of dependency calculi in polymorphic languages.", "authors": [{"name": "Stephen Tse", "author_profile_id": "81405592295", "affiliation": "University of Pennsylvania", "person_id": "PP17000844", "email_address": "", "orcid_id": ""}, {"name": "Steve Zdancewic", "author_profile_id": "81384616728", "affiliation": "University of Pennsylvania", "person_id": "PP14144604", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1016850.1016868", "year": "2004", "article_id": "1016868", "conference": "ICFP", "title": "Translating dependency into parametricity", "url": "http://dl.acm.org/citation.cfm?id=1016868"}