{"article_publication_date": "09-19-2004", "fulltext": "\n A Type-Theoretic Foundation of Continuations and Prompts Zena M. Ariola* Hugo Herbelin Amr Sabry* University \nof Oregon INRIA-Futurs Indiana University ariola@cs.uoregon.edu Hugo.Herbelin@inria.fr sabry@indiana.edu \n Abstract There is a correspondence between classical logic and program\u00adming language calculi with .rst-class \ncontinuations. With the addi\u00adtion of control delimiters (prompts), the continuations become com\u00adposable \nand the calculi are believed to become more expressive. We formalise that the addition of prompts corresponds \nto the addi\u00adtion of a single dynamically-scoped variable modelling the special top-level continuation. \nFrom a type perspective, the dynamically\u00adscoped variable requires effect annotations. From a logic perspec\u00adtive, \nthe effect annotations can be understood in a standard logic extended with the dual of implication, namely \nsubtraction. Categories and Subject Descriptors: F.3.2 [Logics and Mean\u00adings of Programs]: Semantics \nof Programming Languages Operational Semantics; F.3.3 [Logics and Meanings of Pro\u00adgrams]: Studies of \nProgram Constructs Control primitives; F.4.1 [Mathematical Logic and Formal Languages]: Mathematical \nLogic Lambda calculus and related systems General Terms: Languages, Theory Keywords: callcc, continuation, \nmonad, prompt, reset, shift, sub\u00adcontinuation, subtraction 1 Introduction Programming practice suggests \nthat control operators add expres\u00adsive power to purely functional languages. For example, control operators \npermit the implementation of backtracking [18], corou\u00adtines [19], and lightweight processes [41], which \ngo beyond pure functional programming. Of course, any complete program that uses these abstractions can \nbe globally transformed to a purely functional program, but this misses the point. As Felleisen [9] for\u00admalises \nand proves, the additional expressiveness of control oper\u00ad * Supported by NSF grant number CCR-0204389. \nPermission to make digital or hard copies of all or part of this work for personal or classroom use is \ngranted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page. To copy otherwise, to republish, \nto post on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. ICFP \n04, September 19 21, 2004, Snowbird, Utah, USA. Copyright 2004 ACM 1-58113-905-5/04/0009 ...$5.00 ators \ncomes from the fact that no local transformation of program fragments using control operators is possible. \nThere is another way to formalise the additional expressive power of control operators that is based \non the Curry-Howard isomor\u00adphism [22]. The pure .-calculus corresponds to intuitionistic logic; extending \nit with the control operator C [8] makes it equivalent to classical logic [15], which is evidently more \nexpressive. Felleisen also showed that the control operator callcc is less expressive than C [9]. Ariola \nand Herbelin provided the logical explana\u00adtion [1]: callcc corresponds to minimal classical logic where \nit is possible to prove Peirce s law but not double negation elimina\u00adtion, whereas C corresponds to (non-minimal) \nclassical logic which proves double negation elimination. This logic-based expressiveness is arguably \na simpler approach but it has so far only been applied to a small family of control operators, and the \nsituation for the other control operators is much less under\u00adstood. For example, the operators shift \nand reset [6] are widely believed to be more expressive than C but it is not clear how to formalise this \nbelief for at least three reasons: 1. Several incompatible type systems and type-and-effect sys\u00adtems \nhave been proposed for these operators [23, 30, 24, 5], and it is not apparent which of these systems \nis the right one even when moving to the world of continuation-passing style [40]. Furthermore, for the \ntype-and-effect systems, there are several possible interpretations of the effect annotations, which \nshould be completely eliminated anyway to get a cor\u00adrespondence with a standard logic. 2. Under the \nCurry-Howard isomorphism, reductions rules cor\u00adrespond to proof normalisation steps and hence we expect \nthe reductions rules for the control operators to be con.uent and, in the simply-typed case, strongly \nnormalising. But although the semantics of many control operators (including shift and reset [25]) can \nbe given using local reduction rules, many of the systems are not con.uent, and under none of the type\u00adand-effect \nsystems are the typed terms known to be strongly normalising. 3. The operators shift and reset can simulate \na large number of other computational effects like state and exceptions [12]. This seems to indicate \nthat the understanding of the expressive power of such control operators must also include an under\u00adstanding \nof the expressive power of other effects. Thielecke et. al. [38, 37, 33] have formalised the expressive \npower of various combinations of continuations, exceptions and state but their results need to be generalised \nand explained using standard type systems and logics.  Based on the technical results in this paper, \nwe propose a calculus ..- C -which corresponds to classical subtractive logic [32, 2], as a foundation \nin which to reason about all control operators and their relative expressive power. Restrictions of classical \nsubtractive logic have been independently (and recently) shown to correspond to coroutines and exceptions \n[3] but our connection to the more ex\u00adpressive world of .rst-class continuations and prompts is novel. \nIn more detail, we establish that the additional expressiveness of shift and reset comes from the fact \nthat reset essentially corresponds to a dynamically-scoped variable, and in the presence of dynamic scope, \ncontinuations can model other effects like state and exceptions. Logically this is apparent from the \nfollowing equivalences that hold classically: A.\u00acT .B = A .B.T = A.\u00acT .B.\u00acT. In other words, in the presence \nof control operators, a function that takes a dynamically-scoped environment entry of type \u00acT is the \nsame as a function that throws an exception of type T , which is the same as a function that manipulates \na state variable of type \u00acT . Each of these views leads to a different type-and-effect system for shift \nand reset, which can all be embedded in the type A -T . B -U that uses the subtraction connective. We \nalso note that shift and re\u00adset only use a limited amount of the expressive power of classical subtractive \nlogic. This leaves room for investigating other control operators that are believed to be even more expressive. \nThe next three sections review some background material and set up the stage for our technical development. \nSection 2 reviews some of the basic control operators and their connection to classical logic discovered \nby Grif.n. Section 3 improves on Grif.n s original for\u00admulation by using the .. C -tp-calculus from our \nprevious work. Sec\u00adtion 4 reviews the semantics of shift and reset and their equivalent formulation using \nC and prompt. It explains that an essential ingre\u00addient of the semantics is the dynamic nature of prompt. \nOur contributions are explained in detail in the remaining sections. The main point of Section 5 is that \nit is possible to explain the se\u00admantics of shift and reset in the context of .. C -tp by generalising \nthe calculus to include just one dynamically-scoped variable. The sec\u00adtion formalises this point by giving \nthe semantics and establishing its soundness and completeness with respect to the original seman\u00adtics. \nSection 6 investigates various ways to extend the type sys\u00adtem of .. C -tp to accommodate the dynamically-scoped \nvariable. We present three systems (which are closely related to existing type\u00adand-effect systems) and \nreason about their properties. Sections 7 and 8 explain how to interpret the effect annotations in a \nstandard logic. The .rst focuses on motivating the dual connective of impli\u00adcation, namely subtraction, \nand formally de.ning ..- C -. The second focuses on using the subtractive type for explaining and managing \nthe effect annotations. Section 9 concludes with a discussion of other control operators. 2 Control \nand Classical Logic We review the semantics of continuation-based control operators and their connection \nto classical logic. 2.1 Operational Semantics Figure 1 introduces a call-by-value calculus extended with \nthe op\u00aderators abort (A), callcc (K ), and C . The semantics of the control operators can be described \nmost concisely using the following three operational rules, which rewrite complete programs: E[A M] M \n. E[K M] E[M (.x.A E[x])] . E[C M] M (.x.A E[x]) . x,a, v, f ,c . Vars M,N .Terms ::= x | .x.M |MN |A \nM |K M |C M V .Values ::= x |.x.M E .EvCtxt ::= . |EM |VE Figure 1. Syntax of .C In each of the rules, \nthe entire program is split into an evalua\u00adtion context E representing the continuation, and a current \nredex to rewrite. The operator A aborts the continuation returning its subexpression to the top-level; \nthe other two operators capture the evaluation context E and reify it as a function (.x.A E[x]). When \ninvoked, this function aborts the evaluation context at the point of invocation, and installs the captured \ncontext instead. The rules show that C differs from K in that it does not duplicate the evaluation context. \nThis difference makes C at least as expressive as both A and K ; it can be used to de.ne them as follows: \nA M = . C (. . M) (Abbrev. 1) K M = . C (.c. c (Mc)) (Abbrev. 2) We use to refer to an anonymous variable. \nWe will therefore focus on C in the remainder of the paper, but still occasionally treat A as a primitive \ncontrol operator to provide more intuition. EXAMPLE 1. (A .C -term and its evaluation) We have: C (.c. \n1 + c 2) .(.c. 1 + c 2)(.x.A x) . 1 + A 2 .2 The invocation of the continuation c abandons the context \n1 +[]. 2.2 Reduction Rules \u00dfv : (.x.M) V . M[V /x] CL : (C M) N . C (.c.M (. f .A (c ( fN)))) CR : V \n(C M) . C (.c.M (.x.A (c (Vx)))) Ctop : C M . C (.c.M (.x.A (cx))) Cidem : C (.c.C M) . C (.c.M (.x.A \nx)) Figure 2. Reductions of call-by-value .C Instead of presenting the semantics of .C as a relation \non complete programs, it is possible to give local reduction rules that are appli\u00adcable anywhere in a \nterm and in arbitrary order. (See Figure 2.) Instead of capturing the entire evaluation context at once, \nthe rules allow one to lift the control operation step-by-step until it reaches another control operator. \nAt any point, it is possible to use Ctop to start applying M to part of the captured context and then \ncontinue lifting the outer C to accumulate more of the context. The rules are in correspondence with \nthe operational semantics in the sense that there is a standard reduction sequence that reaches an answer \nwhich is almost identical to the answer produced by the operational semantics [10, Th. 3.17]. For the \nterm in Example 1, the standard reduction sequence produces C (.c.c 2) instead of 2. 2.3 Grif.n s Type \nSystem Grif.n introduced a type system for .C where types can also be read as propositions [15]. The \nset of basic types is assumed to include a special type . which represents an empty type or the proposi\u00adtion \nfalse. The type system is given in Figure 3. In the rule b . BaseType = {.,... }A,B . TypeExp ::= b | \nA . B G,x : A f M : B .i Ax G,x : A f x : A G f .x.M : A . B G f M : A . B G f MI : A .eG f MMI : B G \nf M : (A ..) .. \u00ac\u00acE G f C M : A Figure 3. Type system of .C (Grif.n) \u00ac\u00acE , a continuation accepting a \nvalue of type A is given the type A .. (which corresponds to the negation \u00acA). Thus, the closed term \n.x.C x provides a proof of the double negation elimination rule \u00ac\u00acA . A. PROPOSITION 1(GRIFFIN). A formula \nA is provable in classical logic iff there exists a closed .C term M such that f M : A.  3 The .. C \ntp -calculus - Our previous work [1] introduced a re.nement of the .C -calculus called the .. C -tp-calculus, \nwhich is better behaved both as a reduction system and as a logical system. We introduce this calculus \nand use it in the remainder of the paper as the basis for developing a uniform framework for reasoning \nabout control operators. 3.1 The Top-Level Continuation When reasoning about continuations, the issues \nrelated to the top\u00adlevel are often swept under the rug. In Section 2.1, we stated that the reduction \nrules are in correspondence with the operational semantics dismissing the spurious context C (.c.c 0) \nwhich sur\u00adrounds the answer. Grif.n notes a similar situation in the type system of Figure 3. Ac\u00adcording \nto the operational semantics, a complete program E[C M] would rewrite to (M (.x.A E[x])). For the right-hand \nside to type\u00adcheck E[x] must have type ., which implies that the rule is only ap\u00adplicable when the program \nE[C M] has type .. In Grif.n s words, since there are no closed terms of this type, the rule is useless! \nGrif.n addressed this problem by requiring that every program M be wrapped in the context C (.c. c 0), \nwhich provides an explicit binding for the top-level continuation, and by modifying the oper\u00adational \nrules to only apply in the context provided by the top-level continuation. In particular, the rule used \nabove becomes: C (.c.E[C M]) . C (.c.M (.x.A E[x])) Since the issue of the top-level becomes critical \nfor functional continuations, it is well-worth an explicit and formal treatment. The .. C -tp -calculus \nprovides such a treatment by introducing a special constant tp denoting the top-level continuation. \n3.2 Syntax and Semantics The syntax of .. C -tp is in Figure 4. We distinguish between regu\u00adlar variables, \ncontinuation variables, and the special continuation constant tp. We also restrict the use of C such \nthat the argument is always a .-abstraction which binds a continuation variable and x,a,v, f . Vars k \n. KVars KConsts = { tp }M,N . Terms ::= x | .x.M | MN | C -(.k.J) V . Values ::= x | .x.M J . Jumps ::= \nkM | tp M Figure 4. Syntax of .. C -tp immediately performs a jump. The restriction does not lose expres\u00adsiveness \nbut imposes a useful structure on the terms. Indeed the .. C -tp -calculus is isomorphic to Parigot s \n.\u00b5-calculus [31] extended with a tp continuation constant. With the presence of tp, the grammar distinguishes \ntwo kinds of jumps: a jump to the top-level (which aborts the program execution) and a jump to a previously \nde.ned point (which throws a value to a continuation). We abbreviate the terms which abstract over these \njumps as follows: . A -M = C -(. .tp M) (Abbrev. 3) . throw k M = C -(. .kM) (Abbrev. 4) \u00dfv : (.x.M)V \n. M[V /x] - CL : (C -(.k.J)) N . C -(.kI.J [kI (MN)/kM]) - CR : V (C -(.k.J)) . C -(.kI.J [kI (VM)/kM]) \n--(.k.kII (C C -(.kI.J))) . C -(.k.J [kII/kI]) idemI :C - C -(.k.tp (C -(.kI.J))) . C -(.k.J [tp/kI]) \nidem : C - C -(.k.kM) . M where k . FV(M) elim : C Figure 5. Reductions of call-by-value .. C -tp The \nreduction rules of the .. C -tp -calculus are in Figure 5. In addition to the regular substitution operation \nM[V /x], the rules use structural substitutions of the form J[k (MN)/kM] from the .\u00b5-calculus. Such substitutions \ncan be read as: for every free occurrence of k, replace the jump (kM) by the jump (k (MN)). The reductions \nrules are closely related to the ones of .C in Figure 2 with small - differences: there is a new variant \nof Cidem dealing with a regular continuation variable, there is a new rule C\u00ad elim that eliminates a \nsuper.uous jump whose target is the current continuation, and the rule Ctop is no longer needed. (C M). \n= C -(.k.tp (M. (.x.throw k x))) (A M). = A-M. Figure 6. Embedding of .C in .. C -tp (interesting clauses) \nThere is a natural embedding of the terms of the .C -calculus into the .. C -tp -calculus, under which \nthe reductions of one system are sound and complete with respect to the other [1]. Figure 6 shows the \ninter\u00adesting clauses of the embedding: for all other term constructors the embedding is homomorphic. \nThe embedding of C looks similar to a Ctop-reduction. The embedding of A is calculated using Abbrev. \n1 followed by a simpli.cation rule. The term in Example 1 is embed\u00added as C-(.k.tp ((.c. 1 + c 2)(.x.throw \nk x))) which reduces to C -(.k.tp (1 + throw k 2)). 3.3 Type System The set of base types in .. C -tp \nincludes . which represents an empty type or the proposition false as before but it no longer plays a \nspecial role in the judgements. Instead, the judgements refer to a b . BaseType = {.,... }A,B,T . TypeExp \n::= b | A . B G . Contexts ::= \u00b7| G,x : A | G,k : A ... G,x : A f M : B;T .i Ax G,x : A f x : A;T G f \n.x.M :A . B;T G f M :A . B;T G f MI :A;T .e G f MMI : B;T G,k : A ...f J :. ;T G f C -(.k.J) : A;T RAA \nG,k : A ...f M : A;T G f M : T ;T .tp .k e e G,k : A ...f kM :. ;T G f tp M :. ;T Figure 7. Type system \nof .. C -tp distinct special type . which is used as the type of jumps, i.e., the type of expressions \nin the syntactic category J. The type . is not a base type; it can never occur as the conclusion of any \njudgement for terms in the syntactic category M, but it may occur in the context G as the return type \nof a continuation variable. It is possible [2] with a bit of juggling to inject a continuation of type \nT ... into the type of functions T .. used in the Grif.n s system: G,k : T ...,x : T f x : T ;T G,k : \nT ...,x : T f kx :. ;T G,k : T ...,x : T f C -(. .kx) : .;T G,k : T ...f .x.C -(. .kx) : T ..;T  Thus \nit does no harm to informally think of . as . remembering that an explicit coercion is required to move \nfrom one to the other. But the special nature of the type . can perhaps be best understood by examining \nthe situation in the isomorphic .\u00b5-calculus extended with tp. In that type system, there is no need for \n. : the types of continuation variables are maintained on the right-hand side of the sequent and jumps \nhave no type. In other words, a more accurate understanding of . is as a special symbol denoting no type. \nIn the original presentation of the type system [1], the continua\u00adtion constant tp was given the type \n... . This is because the purpose in there was to characterise the computational content of (non-minimal) \nclassical logic. A common and useful generalisa\u00adtion is to give the top-level continuation the type T \n... for some arbitrary but .xed type T [30]. We adopt this generalisation and modify the system to keep \ntrack of the special type T . Instead of providing an explicit signature for the type of the constant \ntp,we keep the type T on the right-hand side of the judgements where it acts as a global parameter to \nthe type system. The axioms and inference rules of the type system are in Figure 7. The rule RAA (Reductio \nAd Absurdum) is similar to the double\u00adnegation rule \u00ac\u00acE in Grif.n s system of Figure 3 except that it \nuses the special type . instead of .. The special top-level continuation can only be invoked with a value \nof the distinguished type T . The presence of the top-level type may give more information about the \ntype of a term. For example, this judgement: f A -5 == \"Hello\" : bool; int accurately predicts that the \nexpression returns a bool or jumps to the top-level with an int. But in the following judgement: f .x.x \n+ A -\"Hello\" : int . int; string the presence of the type string is actually restrictive and worse, mis\u00adleading \nas we explain in Sections 6.1 and 6.2 where we talk about generalisations of the system. The .. C -tp-calculus \nre.nes the .C -calculus and has all the right prop\u00aderties. PROPOSITION 2(ARIOLA AND HERBELIN). (i) .. \nC -tp is con.uent and typed terms are strongly normalising. (ii) Subject reduction: Given .. C -tp terms \nM and N, if G f M : A;T and M . N, then G f N : A;T.  (iii) A formula A is provable in minimal classical \nlogic iff there exists a closed .. C -tp term M such that f M : A;B is provable without using rule .tp \ne. (iv) A formula A is provable in classical logic iff there exists a closed .. C -tp term M such that \nf M : A;..  4 Functional Continuations We aim to extend the results for C to the more expressive control \noperators associated with delimited functional continuations. We focus on three of the basic operators: \nshift which captures a func\u00adtional continuation [6], and the two identical operators prompt and reset \n(the .rst introduced by Felleisen [8] and the second introduced by Danvy and Filinski [6]) which delimit \ncontinuations. 4.1 The Operators shift and reset The operational semantics of shift (S) and reset (#) \nin the context of a call-by-value calculus is given below: x,a,v, f ,c . Vars M . Terms ::= x | .x.M \n| MM | S M | # M V . Values ::= x | .x.M E . EvCtxt ::= 0 | EM | VE | # E E[# V ] . E[V ] E.[# (E.[S \nM])] . E.[# (M (.x.# E.[x]))] The .rst rule indicates that the role of a reset terminates when its subexpression \nis evaluated; indeed the point of reset is to delimit the continuation captured during the evaluation \nof its subexpres\u00adsion. When compared to the semantics of C or K given in Sec\u00adtion 2.1, we note at least \nthree points about the semantics of S : 1. Unlike either C or K , the control operator S only captures \npart of the surrounding evaluation context. This surrounding context is split into three parts: a part \nE. which extends to the closest occurrence of a reset, the occurrence of the reset itself, and the rest \nof the evaluation context E. surrounding the .rst reset and which may include other occurrences of reset.It \nis an error to use S in a context that is not surrounded by a reset. 2. Like C but unlike K , the action \nof capturing the context by S also aborts it. In particular, the context E. is removed and shifted inside \nthe captured continuation.  3. Unlike C or K , the captured context is rei.ed into a function which \ndoes not include an A. Indeed, the rei.ed continuation is a functional continuation whose invocation \nreturns to the point of invocation just like an ordinary function application. The term in Example 1 \nrewritten with shift and reset evaluates as follows: # S (.c.1 + c 2) . # ((.c.1 + c 2)(.x.# x)) . # \n(1 + #2) . 3  The invocation of the continuation c does not abort, but returns to the context 1 +[]. \nIn general, functional continuations are com\u00adposable. For example, # (S (.c. c (c 1)) + 2) returns 5 \nbut the same term with a C returns 3. 4.2 The Operators C and prompt x,a,v, f ,c . Vars M,N . Terms \n::= x | .x.M | MN | C M | #M V . Values ::= x | .x.M Figure 8. Syntax of .C # There is an equivalent \nformulation of shift and reset using C and prompt (#). This representation is more suitable for our purposes \nsince we already have all the machinery to deal with C . The syntax of .C # is given in Figure 8: it \nconsists of adding prompt\u00adexpressions to the syntax of .C in Figure 1. The intention is that the continuation \ncaptured by C will be delimited by the prompt. No other changes to the semantics of C is assumed. In \nparticular, the continuation captured by C still includes an A. Since A is an abbreviation for a particular \nuse of C , its action is also delimited by the prompt. This also means that it is an error to use C in \na context that is not surrounded by a prompt. \u00dfv : (.x.M)V . M[V /x] CL : (C M)N . C (.c.M (. f .A (c \n( fN)))) CR : V (C M) . C (.c.M (.x.A (c (Vx)))) Cidem : C (.c.C M) . C (.c.M(.x.A x)) #C #(C M) . #(M \n(.x.A x)) #v #V . V Figure 9. Reductions of call-by-value .C # Formally, we give the semantics using \nlocal reduction rules in Fig\u00adure 9. The reduction rules extend those of Figure 2 with rules for the prompt \nbut omit the Ctop rule. All uses of the omitted rule can be simulated with the new #C rule, except for \nthe erroneous occur\u00adrences not surrounded by a prompt. The use of .C # to study functional continuations \nde.ned by shift and reset is justi.ed by the following facts. A prompt is just a synonym for reset and \nthe operators S and C can be mutually simulated as follows [12]: S M = . C (.c.M (.v.# (cv))) C M = . \nS (.c.M (.x.A (cx))) The mutual simulation is based on the facts that AM = S (. .M) and that for any \nvalue V , A (# V )= A V and # (A V )= # V [25]. 4.3 Dynamic Scope of prompt One of the original motivations \nfor introducing the notion of a con\u00adtrol delimiter is that it provides an explicit top-level for its \nsubex\u00adpression [8]. It is therefore clear that the original .. C -tp which has a constant corresponding \nto the top-level continuation needs to be extended by making the top-level continuation a variable. In \nthis section, we explain why this variable cannot be a statically-scoped variable. Consider a possible \nembedding of the .C # expression #M in a gen\u00aderalisation of .. C -tp where the constant tp is replaced \nby a class of regular statically-scoped continuation variables { tp,tpI ,... }: (# M). = C -(.tp. tp \nM.) (A M). = C -(. . tp M.) The embedding uses a single continuation variable tp to denote the current \ntop-level continuation: a prompt expression rebinds this variable, and an A-expression invokes it. For \nsimple examples, this has the correct semantics but as soon as things get more compli\u00adcated we run into \nproblems. EXAMPLE 2. (Static prompt vs. Dynamic prompt) Consider the term #(#(. . A (. . 3)) (. . A 4)) \nwhich reduces as follows using the .C # reductions: . #((. . A (. . 3)) (. . A 4)) . #A (. . 3). (. . \n3) Using the suggested embedding, the corresponding .. C -tp term is: C -(.tp. tp ((C -(.tpI . tpI (. \n. C -(. . tpI (. . 3))))) (. . C -(. . tp 4)))) where we have a-renamed one of the occurrences of the \nstatically\u00adscoped variable tp. Then, if we adopt the reduction rules of the original .. C -tp -calculus, \ntreating tp as a regular continuation variable, we have: . CL -,\u00df C -(.tp. tp (C -(.tpI .tpI (C -(. . \ntpI 3))))) .C -C -(.tp. tp (C -(.tpI . tpI 3))) idem .C -C -(.tp. tp 3) idem -3 .Celim which is inconsistent \nwith the result given in .C #. The source of the inconsistency is the a-renaming step. Indeed, in the \noriginal .C # term, the .rst occurrence of A is statically associ\u00adated with the second occurrence of \n#. However, after one reduction step this occurrence of A is actually associated with the .rst occur\u00adrence \nof #. In .C #, when a control operation is evaluated, the evalu\u00adation refers to the dynamically-closest \noccurrence of a prompt.We formalise this idea in the next section. INTERMEZZO 3. The approach of using \nstatic scope for delimiters has been explored further by Thielecke [39] and Kameyama [24]. Thielecke \nconsiders several variations of control operators with dif\u00adferent scope rules. Using his notation, we \nhave #M = here M and A M = go M. He presents a system with static scope fs and shows that it corresponds \nto classical logic. Note that \u00df-reduction is not fully de.nable in his system: it has only a single here/go \npair, so that the renaming of static here/go bindings that may be necessary to avoid a capture of go \nis not expressible. Kameyama also develops a type system and a semantics for a static variant of shift \nand reset and proves type soundness. His type system formalises the fact that one needs to maintain a \nsequence of top-level continuation variables in the judgements. Indeed, an expression might be evaluated \nin the scope of several occurrences of the prompt, each represented by a statically-scoped (a-renamed) \ncontinuation variable.   5 The .. C tp -Calculus: Syntax and Semantics - t To maintain the proper semantics \nof functional continuations, a prompt should be mapped to a use of C-but with the receiver being a dynamic \n.-abstraction. We formalise this idea using an extension of .. -called the .C . -tp-calculus. C tp t \n5.1 Syntax x,a,v, f ,c . Vars k . StaticKVars DynKVars = { t tp }M,N . Terms ::= x | .x.M | MN | C tp. \nJ) -(.k.J) | C -(.tV . Values ::= x | .x.M J . Jumps ::= tp M kM | t Figure 10. Syntax of .. C -tpt As \nthe syntax in Figure 10 shows, we have two distinct uses of C-: one for regular statically-scoped continuation \nvariables and one for the unique dynamically-scoped continuation variable t tp. We introduce a new abbreviation \nthat is just like A-M except that it refers to the special dynamic variable t tp: AA-M = . C -(. .tp \nM) t(Abbrev. 5) The anonymous variable ranges only over regular variables and static continuation variables \nbut not over the dynamic variable. Similarly, the notions of free and bound variables only apply to the \nregular variables and the static continuation variables but not the dynamic variable. (# M). = C -(.ttp. \nttp M.) (C M). = C -(.k.ttp (M. (.x.throw k x))) (A M). = AA-M. Figure 11. Embedding of .C # into .. \nC -t(interesting clauses) tp The embedding of .C # in .. C -twe aim for is given in Figure 11. The tp \nembedding of a prompt-expression is similar to what we attempted in the last section but modi.ed to take \nthe dynamic nature of the prompt into account. The embeddings of C and A are just like the ones from \nFigure 6 except that they refer to t tp instead of tp. 5.2 Reductions In order to de.ne the semantics \nof .. -tp we .rst need an understand- C t ing of the semantics of dynamic scope in the absence of control \noperators [28]. A dynamic abstraction (.xt.M) is generally like a regular function in the sense that \nwhen it is called with a value V , the formal parameter tx is bound to V . But: DS1 The association between \ntx and V established when a function is called lasts exactly as long as the evaluation of the body of \nthe function. In particular, the association is disregarded when the function returns, and this happens \neven if the func\u00adtion returns something like (. ....tx...) which contains an oc\u00adcurrence of tx: no closure \nis built and the occurrence of tx in the return value is allowed to escape. DS2 The association between \ntx and V introduced by one function may capture occurrences of tx that escape from other func\u00adtions. \nFor example, if we have two dynamic functions f and g with f directly or indirectly calling g, then during \nthe evalua\u00adtion of the body of f , occurrences of tx that are returned in the result of g will be captured. \nTurning this example around, the occurrences of tx that escape from g are bound by the closest association \nfound up the dynamic chain of calls. In the presence of control operators, the situation is more compli\u00adcated \nbecause the evaluation of the body of a function may abort or throw to a continuation instead of returning, \nand capturing a con\u00adtinuation inside the body of a function allows one to re-enter (and hence re-evaluate) \nthe body of the function more than once. Despite the additional complications, the reduction rules of \n.. C -t tp in Figure 12 look essentially like the reduction rules of the .. C -tp \u00adcalculus. We discuss \nthese rules informally here and defer the cor\u00adrectness argument until the next section. The .rst group \nof re\u00adductions is a copy of the corresponding reductions in .. C -tp with occasional dynamic annotations. \nAs implied by DS2, the meta\u00adoperation of substitution must allow for the capture of t tp. The sub\u00adstitution \noperations M [V /x ] and J [k (MN)/kM ] do not rename t tp but are otherwise standard. For example, if \nV =(. .C-(. .tp y)) t then: (.y.C -(.tt ] tp. tp (xy))) [V /x I t t = .y.C -(.t-(. . tp y)) yI)) tp. \ntp ((. .C which captures tThe second group of rules arises be\u00ad tp but not y. cause C--abstractions come \nin two .avors, so we essentially need to consider every rule that is applicable to expressions of the \nform C -(.k.J) and modify it, if appropriate, to apply to expressions of the form C -(.tWe only modify \nand include three rules: two tp.J). idem rules which look as usual, and the rule C-which explicitly elimI \nallows occurrences of t tp in V to escape as suggested by DS1 above. The other rules are not needed to \nsimulate the semantics of .C #.  5.3 Properties of .. C tp Reductions - t We have two semantics for \n.C #: one given by the reduction rules of Figure 9 and one given by the embedding in .. -tand the reduction \nC tp rules in Figure 12. We need to verify that the two semantics are con\u00adsistent. A simple way to perform \nthis veri.cation would be to check that the reduction rules on one side can be simulated by the reduc\u00adtion \nrules on the other side, but this very strong correspondence does not hold in our case. What does hold \nis a correspondence up to operational equivalence. Given a reduction relation X, and two terms M and \nN, possibly con\u00adtaining free variables, we say M .XN if for every context P which binds all the free \nvariables of M and N, P[M]. XV iff P[N]. XV . For example, any two terms that are convertible using the \nreduction relation are operationally equivalent. Two non-convertible terms may still be equivalent if \nno sequence of reductions in any context can invalidate their equivalence. An example of this kind is \nthe equivalence (.x.x)(yz) .C # (yz). To show that the two semantics are consistent up to operational \nequivalence, we need to consider the following two cases. If we evaluate a .C #-program using the original \nsemantics and that eval\u00aduation produces an answer V , then the embedding of the program in .. C -ttp \nshould be operationally equivalent to the embedding of V . Similarly, if the evaluation of a .C #-program \nis erroneous or di\u00ad \u00dfv : C -L : C -R : C -idemI : C -idem : C -elim : (.x.M)V (C -(.k.J)) N V (C -(.k.J)) \nC -(.k.kII (C -(.kI .J))) C -(.k.ttp (C -(.kI .J))) C -(.k.kM) . . . . . . M [V /x ] C -(.kI .J [kI (MN)/kM \n]) C -(.kI .J [kI (VM)/kM ]) C -(.k.J [kII/kI]) C -(.k.J [ttp/kI ]) M where k . FV(M) C -idemttp I : \nC -idemttp : C -elimI : C -(.ttp. k (C -(.kI .J))) C -(.ttp. ttp (C -(.kI .J))) C -(.ttp. ttp V ) . . \n. C -(.ttp. J [k/kI]) C -(.ttp. J [ttp/kI ]) V even if ttp . V Figure 12. Reductions of call-by-value \n..  C -tpt C # M. verges in the original semantics, then it remains unde.ned after the 1. For all .C \n#-terms M, we have M embedding. Turning the implication around, if evaluating a .C #\u00adprogram by embedding \nit in .. C -tptand using the reduction rules of Figure 12 produces a value V , then the original program \nis opera\u00adtionally equivalent to the mapping of V back to .C #. The interesting clauses of this mapping \nare de.ned as follows: (C -(.k.J)) = C (.k.J ) (C -(.tpt.J)) = # J (tp Mt) = A M The only non-trivial \nclause is the .rst one where we silently allow continuation variables to occur in .C #. The problem as \nwe shall see is that continuations variables are special in .. C -tptand the translation loses information \nabout their special status. PROPOSITION 3. LetM be a closed .C #-term: If M. .C #V then M. C -tptV . \n. If M.. .. V then M C # V .  C -tpt The proof of the .rst clause reduces to checking that embedding \nboth sides of every .C #-reduction produces semantically-equivalent terms in .. C -tpt. For some of the \ncases, like the reduction #v, the embedded terms are related by a corresponding reduction in .. C -tptand \nhence are obviously semantically-equivalent. For the Cidem case, the embedded left-hand side does not \nreduce to the embedded right-hand side, but both can reduce to a common term, and hence are again semantically-equivalent. \nThe lifting rules CL are CR in\u00adtroduce a complication: proving the equivalence of the embedded terms \nrequires using the following equivalence: (.x.throw k x) M C -tptthrow k M even when M is not a value. \nThis happens because in contrast to the regular substitution operation, structural substitutions can \nre\u00adplace arbitrary jumps (kM) by (k (VM)) even when M is not a value. The mismatch re.ects more the design \nchoices of .C # and .. C -tptrather than an inconsistency. Indeed it would be possible to design a variant \nof .C # in which one could throw a term M to a continuation instead of a value, and it would be possible \nto design a variant of .. C -tptwhere all arguments to jumps are restricted to be val\u00adues. In general, \nrequiring that all jump arguments be values forces one to evaluate the argument to the jump in some continuation \nand then erasing this continuation, instead of the equivalent but more ef.cient choice of .rst erasing \nthe continuation and then evaluating the argument to the jump [14]. The proof of the second clause reduces \nto proving: 2. For every .. C -tpt-reduction M . N, we have M C # N . The proof of the .rst statement \nis straightforward. Note however that proving that C M is equivalent to (C M). requires using Ctop which \nis not a reduction rule but otherwise a valid operational equivalence. When attempting to prove the second \nstatement, we encounter a problem related to free continuation variables. Even though pro\u00adgrams are closed \nterms, reductions can happen anywhere including under binders and hence it is possible for a .. C -tpt-reduction \nto ma\u00adnipulate an open term. In particular, consider C-where the idemtI tp continuation variable k is \nfree. The right-hand side maps to the .C #\u00adterm (#J[k/kI] ) but the left-hand side is equivalent to the \n.C #-term (#J[(.x.A (kx))/kI] ). Since the variable k is not special in .C # it could, as far as the \n.C #-theory is concerned, be substituted with 5 and hence it is de.nitely not the case that one can assume \nthat k and (.x.A (kx)) are operationally equivalent. This assumption would be correct if we could somehow \nguarantee that k will be substituted by a continuation. In a complete program, this is clearly the case \nas the left-hand side must occur in a context ...(C-(.k....0...)... which binds k to a continuation variable. \nWe just need to make this information explicit in the statement of the proposition [34, Lemma 19]: 2 \n. Let M . N be a .. C -tpt-reduction, and let k1,...,kn be the free continuation variables in M, then \nwe have the equivalence C (.k1 ...C (.kn.M )) C # C (.k1 ...C (.kn.N )). The proof of the modi.ed clause \nproceeds by cases. For the reduc\u00ad - tion Celim we use the fact that even though Celim is not a reduction \nof .C #, it is a valid equivalence. Two of the .. C -tpt-reductions refer to substitutions using tptin \nisolation. These occurrences are mapped to .x.A x in .C # and we use the equivalence ((.x.A x) M) C # \nA M with M not necessarily a value as appropriate. Finally, the reduc\u00adtions CL and CR require the following \nequivalences in .C # where k is a continuation variable and M may not be a value: (.x.k (Vx)) M C # k \n(VM) (.x.k (xN)) M C # k (MN) These again allow one to jump with a non-value. All the re\u00adquired .C # \nequivalences are known to be valid [34, 25].  6 The .. C tp -Calculus: Types -t There are several natural \ntype (and effect) systems for .. C -tptthat have appeared in the literature of control operators and \nprompts in one form or another. We investigate three of these systems and reason about their properties. \nThe .rst system has no effect annotations which we show are essential for strong normalisation. 6.1 System \nI: Fixed Answer Type Even though the status of the top-level continuation changes from a constant to \na dynamic variable, the type system of .. C -tp in Figure 7 is essentially a sound type system for .. \nC -tpt. This type system can be explained on the .C # side as an extension of Grif.n s type system where \nthe judgements have an additional type T on the right-hand side. This is identical to Murthy s type system \n[30] and the type system one gets when de.ning the control operations on top of a continuation monad \nwith a .xed answer type T [40]. In all these systems, the rule for typing prompt is: G f M : T ;T # G \nf #M : T ;T and the type of A is T . A, which show that the control opera\u00adtors can only be used in contexts \nthat agree with the top-level type. Despite this restriction, these types may be adequate for some ap\u00adplications \n[12] but logically they are unacceptable as they are not strong enough to guarantee strong normalisation. \nEXAMPLE 4. (Loss of SN) Let T =(int . int) . int be the .xed top-level type, then we can calculate the \nfollowing types for the given expressions: g :: int . T = . .. .0 f :: T = .x. (# (g (x 0))) x s :: int \n. int = . .(A f ) e :: int = fs Despite being well-typed, e goes into an in.nite loop: fs . (# (g (A \nf ))) s . (# f ) s . fs One can con.rm this behaviour using Filinski s ML library [12] which provides \nshift and reset on top of a continuation monad with a .xed answer type by running the transliteration \nof our term: let val g = fn _ => fn _ => 0 valf=fnx=>reset(fn()=> g(x0))x in f (fn _ => shift (fn _ \n=> f )) end  6.2 System II: Dynamic Scope as Effects The requirement that all occurrences of tpt(or \nequivalently, all oc\u00adcurrences of the prompt) are typed with the same .xed top-level type T is overly \nrestrictive. Each introduction of tptcan be given a different type as shown in rule RAAtptin Figure 13: \nif tptis intro\u00adduced in a context expecting a value of type A, then it can be called with arguments of \ntype A. In other words, a new top-level type is introduced for the typing of J. Thus, a judgement G f \nM : A;T can be read as term M returns a value of type A or requires its enclosing prompt to be of type \nT . On the .C # side, this corresponds to the following rule: G f M : A;A # G f #M : A;T This modi.cation \nis unsound by itself as it changes the type of tptwithout taking into account that it is dynamically \nbound. Simply adding RAAtptto the type system of Figure 7 produces a type system for the static variant \nof prompts: the term considered in Example 2 which evaluates to (. .3) when prompts are dynamic and to \n3 when prompts are static would be given the type int. b . BaseType = {.,... }A,B,T . TypeExp ::= b \n| A .TB G . Contexts ::= \u00b7| G,x : A | G,k : A .T . G,x : A f M : B;T Ax .iG,x : A f x : A;T G f .x.M \n:A .TB;T I G f M :A .TB;T G f MI :A;T .eG f MMI : B;T G,k : A .T ..f J :. ;T G f C -(.k.J) : A;T RAA \nG f J :. ;A RAAtpt G f C -(.tpt. J) : A;T G,k : A .T ..f M : A;T .k G f M : T ;T .tpte e G f t G,k : \nA .T ..f kM :. ;T tpM :. ;T Figure 13. A type-and-effect system of .. C -tpt Therefore, in addition to \nhaving the rule RAAtpt, we also need to modify the system to take into account that tptis a dynamic vari\u00adable. \nA possible modi.cation is to repeat what must be done for other dynamically-bound entities like exceptions \n[17], and to add an effect annotation on every arrow type to pass around the type of tpt. Using the system \nwith dynamic effect annotations, the term in Ex\u00adample 2 has type A .B int which is consistent with the \nvalue . .3. Also the term .x. x + A \"Hello\" discussed in Section 3.3 has the type int .string int with \nthe string constraint correctly moved to when the function is called. PROPOSITION 4. Subject reduction: \ngiven .. C -tptterms M and N if G f M : A;T and M . N then G f N : A;T. On the .C # side, the corresponding \ntype-and-effect system (which we do not present) addresses the loss of strong normalisation dis\u00adcussed \nin Example 4. The effect annotations impose the following recursive constraint T =(int .T int) .T int. \nIn other words, for the terms to typecheck, we must allow recursive type de.nitions. This is a situation \nsimilar to the one described by Lillibridge [26] where unchecked exceptions can be used to violate strong \nnormalisation. More generally, we can prove that under the type-and-effect sys\u00adtem of Figure 13, typed \n.. C -tpt-terms are strongly normalising. (See Proposition 11.) INTERMEZZO 5. In the approach discussed \nabove, different oc\u00adcurrences of the symbol # in a program may have different types. Gunter et al. [16] \ntake the (quite natural) position that occurrences of # with different types should have different names. \nEach name still has a .xed type but that type is not constrained to be the same as the top-level, nor \nis it constrained to be related to the types of the other names. This proposal shares with the type-and-effect \nsystem of Figure 13 that different occurrences of prompts can have differ\u00adent types and that the type \nof the prompt must be propagated to the control operator. However, it is closer in design to the system \nwith a .xed answer type as all calls to a prompt of a given name must have the same type. Moreover, since \nthe type system has no effect annotations, Example 4 still typechecks and loops, and well-typed control \noperations may refer to non-existent prompts.  6.3 Understanding the Dynamic Annotations This section \npresents an analysis of the effect annotations. We write \u00acT for the type of a continuation variable expecting \nan argument of type T , leaving for Section 7.1 the question of how to concretely represent this type \nin our language of types. It is standard to embed type systems with effects into regular type systems \nusing a monadic transformation. Since our effect annota\u00adtions have to do with tptwhich is a dynamic variable, \na .rst guess would be to use the environment-passing transformation used to explain dynamic scope [28]. \nAt the level of types, the environment\u00adpassing transformation (written *) maps A .TB to A*.\u00acT *.B* , \nwhich means that every function is passed the (unique) environ\u00adment binding as an additional argument. \nJudgements G fA;T are mapped to G* ,\u00acT *fA* which means that every expression must be typed in the context \nof its environment. Writing the translation for the pure fragment is easy, but when it comes to C-, the \ntranslation of type rule RAA would produce a continuation whose input type is A*.\u00acT *, because continuations \nalso need the environment. But as the rule RAA shows, the input type of the continuation corresponds \nto the return type of the expression that captures it! In other words, expressions that might capture \ncontinuations must return both their value and the environment variable. Thus, our environment-passing \nembedding becomes a store-passing transformation. A second interpretation of the annotations would be \nusing excep\u00adtions: each prompt installs an exception handler, and calls to tptthrow exceptions to the \ndynamically-closest handler. Indeed, ex\u00adceptions can be simulated with ordinary dynamic variables [28] \nand with dynamic continuation variables [16]. According to the standard monadic interpretation of exceptions \n[27], this leads to a transformation mapping A .TB to A*. B*.T *, which means that every function may \nreturn a value or throw an exception to its prompt. Judgements G fA;T are mapped to G*fA*.T * and have \na similar interpretation. When writing such a translation in a gen\u00aderal setting [38, 37, 33], one is \nfaced with a choice: should a use of a control operator capture the current exception handler or not? \nIn our setting, the question is: if a continuation is captured under some prompt, and later invoked under \nanother prompt, should calls to tptrefer to the .rst prompt or the second? It is clear that our semantics \nrequires the second choice. Therefore, our semantics is consistent with the SML/NJ control operators \ncapture and escape [36]. In combination with exceptions, these control operators can simulate state [38, \nFig. 12] which means that our embedding also becomes a store-passing transformation. The above discussion \nsuggests the following interpretation: func\u00adtions A .TB are mapped to A*.\u00acT *.B*.\u00acT * and judgements \nG f A;T are mapped to G* ,\u00acT *f A*.\u00acT * . This interpretation is a standard store-passing one, which \nis consistent with Filinski s observation that shift and reset can be implemented using contin\u00aduations \nand state [12, 13]. The entire analysis is also consistent with the fact that in classical logic, the \nfollowing formulae are all equivalent: A .\u00acT .B ( ttp as an environment) = A .B .T ( ttp as an exception) \n= A .\u00acT .B .\u00acT ( ttp as a state)  6.4 System III: State as Effects b .BaseType = {.,... }A,B,T,U .TypeExp \n::= b |AU .TB G .Contexts ::= \u00b7|G,x : A |G,k : A .T . G,x : A;U fM : B;T Ax .iG,x : A;T fx : A;T G;T \nIf.x.M :AU .TB;T I G;U1 fM :AU2 .T1 B;T2 G;T1 fN :A;U1 .eG;U2 fMN : B;T2 G,k : A .U ..fJ :. ;T G;U fC \n-(.k.J) : A;T RAA G fJ :. ;A RAAtpt G;T fC -(.tpt. J) : A;T G,k : A .U . ;U fM : A;T G;U fM : U;T .k \n.tpte e G f t G,k : A .U ..fkM :. ;T tpM :. ;T Figure 14. Another type-and-effect system of .. C -tpt \nOur type-and-effect system for .. C -tptin Figure 13, which was mo\u00adtivated by the understanding of tptas \na dynamic variable, is sound but too restrictive. As the analysis in the previous section shows, tptcan \nalso be understood as a state parameter and this understanding leads to a different, more expressive, \ntype-and-effect system, which maintains the type of t tp before and after each computation. This generalisation \ngives the type-and-effect system of Figure 14, which is essentially identical to the one developed by \nDanvy and Filinski as early as 1989 [5]. In the cases of jumps and continuations, the judgements and \ntypes of the new type system are the same as before. When typing terms, the judgements have the form \nG;U f M : A;T with T and U de\u00adscribing the top-level continuation before and after the evaluation of \nthe term M respectively. For terms without C-, we can show by induction that the two formulae T and U \nare the same. For terms of the form C -(.k.J), the formula U is the type of the top-level con\u00adtinuation \nwhen k is invoked. Implication has two effects AU .TB with T describing the top-level continuation before \nthe call and U describing the top-level continuation after the call. These changes make the typing of \napplications sensitive to the order of evaluation of the function and argument: the rule .e assumes the \nfunction is evaluated before the argument. The new system is sound. PROPOSITION 5. Subject reduction: \ngiven .C . -tptterms M and N, if G;U fM : A;T and M .N then G;U fN : A;T. Let Cdf be the operation of \nchanging each arrow A .TB into AT .TB in the single-effect formula C. Let Gdf be the extension of this \noperation to G. The new type-and-effect system generalises the previous system. PROPOSITION 6. If G f \nM : A;T (resp G fJ :. ;T) in Figure 13 then Gdf ;Tdf fM : Adf ;Tdf (resp Gdf fJ :. ;Tdf ) in Figure 14. \nThe added expressiveness of the type system is illustrated with the embedding of # (1 + S(.c. 2 == c \n3)) which evaluates as follows: C -(.tpt. tpt(1 + C -(.k. tpt(2 == C -(.tpt. k 3))))) . C -(.tpt. tpt(C \n-(.k. tpt(2 == C -(.tpt. k (1 + 3)))))) . C -(.tpt. tpt(2 == C -(.tpt. tpt(1 + 3))))  . C -(.tpt. tpt(2 \n== 4)) . false This term is rejected by the system in Figure 13 but accepted in the system of Figure \n14. The .rst occurrence of k is delimited by the outermost occurrence of tptwhich is of type int, but \nwhen k is invoked, the context is delimited by a type bool.  7 The ..- C -Calculus - We show that the \ndual connective of implication, namely subtrac\u00adtion (written A -B) arises as a natural type for carrying \naround the type of the top-level continuation, and formally introduce the ..- C -\u00adcalculus. 7.1 Subtraction \nOur analysis of Section 6.3 together with our understanding of the type system of Figure 14 suggest we \ninterpret the more general ef\u00adfect annotations as follows: (AU .TB)* = A*.\u00acT *.B*.\u00acU* (G;U fA;T)* = G* \n,\u00acT *fA*.\u00acU* This is possible, but it can be re.ned as we discuss next. First, the type of a continuation \nvariable is really of the form T * .... While this type can be injected into T*.. as shown in Section \n3.3, doing so loses important information by injecting the special continuations into the domain of regular \nfunctions. Second, the formula A .\u00acT is classically the same as \u00ac(\u00acA .T )= \u00ac(A . T ), i.e., it represents \nthe dual of a function type. This sub\u00adtractive type A-T has been previously studied by Rauszer [32] and \nCrolard [2], and has been integrated by Curien and Herbelin [4] in their study of the duality between \nthe producers of values (which are regular terms) and the consumers of values (which are contexts or \ncontinuations). In many cases, the dual of a function type ap\u00adpears as a technical formality. Here it \narises as the natural type for pairing a term and a continuation and we prefer to use it as a more abstract \nrepresentation of this information. Indeed in an intuition\u00adistic setting where continuations are not \n.rst-class values, it would still make sense to use the type A -T and in that case the type would not \nbe equivalent to A .\u00acT [3]. Dually, the types A .B and \u00acA .B are classically (but not intuitionistically) \nequivalent, and we generally prefer to describe functions using the type A .B which does not rely on \nthe presence of .rst-class continuations. b* = b (AU .TB)* =(A*-T *) .(B*-U*) (\u00b7)* = \u00b7 (G,x : A)* = G* \n,x : A* (G,k : A .U . )* = G* ,k : A*-U* ... Figure 15. Interpreting the effect annotations The actual \ninterpretation of effects we use in Figure 15 incorporates both concerns. The interpretation shows that \na continuation k has type A -T .... Understanding A -T as the type A .\u00acT means that, as Danvy and Filinski \nexplain, every functional continuation must be given a value and another continuation (called the meta\u00adcontinuation \nin their original article [6] and referring to the top-level continuation as we explain). The type A \n-T is also equivalent to \u00ac(\u00acT .\u00acA) and with that view, a functional continuation is more like a continuation \ntransformer, which is an idea closely related to Queinnec and Moreau s formalisation of functional continuations \nas the difference between two continuations [29].  7.2 Syntax, Semantics, and Type System x,a, v, f \n.Vars k,tp .KVars M,N .Terms ::= x |.x.M |MN |C -(.k.J) | (M,kE) |let (x,k)= M in M V .Values ::= x |.x.M \n|(V,kE) J .Jumps ::= kM F .ElemCtxt ::= 0 M |V 0 | (0,kE) |let (x,k)= 0 in M E .EvCtxt ::= 0 |E[F] Figure \n16. Syntax of ..- C  - We formalise the ..--calculus by extending .. with subtraction CC tp and removing \nthe special constant tp since we are maintaining the top-level continuation using the subtractive type. \nThe resulting cal\u00adculus is a call-by-value variant of Crolard s extension of the .\u00b5\u00adcalculus with subtraction \n[2]. The syntax is given in Figure 16. Terms include two new forms that introduce and eliminate the subtractive \ntype. As expected from the equivalence A -T = A .\u00acT, the introduction form (M,kE) is the pairing of a \nterm and a continuation. The continuation is not a simple variable k however: it is a more general jump \ncontext (kE) where E is an evaluation context accumulated by the reduction rules of Figure 17 during \nevaluation. Evaluation contexts E are de.ned using nestings of elementary contexts F ending with a hole. \nThis formulation simpli.es the presentation of reduction rules: for ex\u00adample, instead of having individual \nrules which lift C-across each - elementary context as in the cases of CL -and CR before, we express \n-all the lifting rules using the single rule C lift. The elimination form let (x,k)= M in MI takes apart \na subtractive value M as follows. When the term M evaluates to something of the shape (V,kIE), the jump \ncontext kIE is bound to k and V is bound to x, and the evaluation proceeds with MI. The two reduction \nbase and Subv rules Subv step express this semantics one elementary context at a time. For example, we \nhave the following reduction sequence: let (x,k)=(V,kI (F1[F2[F30]])) in throw k x . let (x,k)=(V,kI \n(F1[F20])) in throw k (F3[x]) . let (x,k)=(V,kI (F10)) in throw k (F2[F3[x]]) . let (x,k)=(V,kI 0) \nin throw k (F1[F2[F3[x]]]) . throw kI (F1[F2[F3[V ]]])  To help readability, we use the following abbreviations: \n.(x,k).M = ..v.let (x,k)= v in M (Abbrev. 6) join M = . let (x,k)= M in throw k x (Abbrev. 7) bindkM \nin N = . let ( f , k)= M in fN (Abbrev. 8) In the .rst abbreviation v is a fresh variable. The operator \njoin abbreviates the common pattern where the elimination form of the subtractive value immediately throws \nthe value to the jump context. The operator bind is similar to the monadic operator of the same name. \nBoth M and N are expected to be terms that evaluate to subtractive values with N containing free occurrences \nof k and f is a fresh variable: the effects of M are performed to produce a subtractive value which is \nbound to ( f ,k) and then f is applied to N. \u00dfv : (.x.M)V . M[V /x] - C F[C -(.k.J)] . C -(.k.J [k (F[M])/kM; \nk (F[E])/kE]) lift : - CC -(.k.kM) . M where k . FV(M) elim : --(.k.kII (C -(.kI -(.k.J [kII/kI]) CC \n.J))) . C idem : base Subv let (x,k)=(V,kI0) in M . M[kI/k][V /x] step Subv let (x,k)=(V,kI(E[F])) in \nM . let (x,k)=(V,kIE) in M[k (F[M])/kM; k (F[E])/kE] Figure 17. Reductions of call-by-value ..- C - The \ntyping rules for the complete language are in Figure 18. The system is completely standard with no effect \nannotations and not even a global parameter T . To type the introduction rule of subtrac\u00adtion, we need \nto type evaluation contexts E with rules essentially identical to the rules for typing terms. We use \nthe notation G,0 : B f kE :. to denote any judgement of the form G,x : B f k(E[x]) :. up to the name \nx which is a fresh variable. b . BaseType = {.,... }A,B,C,T,U . TypeExp ::= b | A . B | A - B G . Contexts \n::= \u00b7| G,x : A | G,k : A ... G,x : A f M : B Ax .iG,x : A f x : A G f .x.M :A . B G f M :A . B G f MI \n:A .eG f MMI : B G,k : A ...f J :. G,k : A ...f M : A RAA .k e G f C -(.k.J) : A G,k : A ...f kM :. G \nf M : A G,0 : B f kE :. -i G f (M,kE) : A -B G f M : A -C G,x : A,k : C ...f MI : B -e G f let (x,k)= \nM in MI : B Figure 18. Type system of ..- C - Using standard proof techniques, we get PROPOSITION 7. \n1. Subject reduction: Given ..- C -terms M and N if G f M : A and M . N then G f N : A. 2. Typed ..- \nC -terms are strongly normalising.   8 Embeddings in ..- C - We show that the interpretation of effect \nannotations using the sub\u00adtractive type is correct. First, we embed the terms of .. -t\u00ad in ..- C tp C \nand show that the embedding respects the semantics of .. C -tptand hence the semantics of .C #. Second, \nwe embed .. C -tpt-judgements in ..- C --judgements and check that the embedding is type-preserving. \n8.1 Embedding .. and .C # terms in ..- -t- C tp C We .rst consider the embedding of .. C -tptterms in \nFigure 19. The embedding of terms and jumps is parameterised by a single fresh statically-scoped continuation \nname tp in ..- C -which occurs free in the right-hand side. The dynamic variable tptof .. C -tptis eliminated \nin the translation which arranges for tp to always refer to the current top-level continuation. The translation \nof a value has no free oc\u00adcurrences of the continuation variable used in the embedding: the translation \nof every .-expression introduces a new binding for tp which is used in the translation of its body. More \nprecisely, every function takes a subtractive value as an argument which speci.es the original argument \nand the top-level continuation resulting from the evaluation of the function and the argument. Because \ntrans\u00adlated values have no free occurrences of tp, it is easy to verify that M[V /x]tp = Mtp[V +/x]. \nThe main dif.culty in de.ning the embedding of terms and jumps is to correctly propagate tp. A value \nV is embedded as a subtractive value whose jump context is the current top-level continuation. In the \nembedding of MN, the occurrences of tp in Ntp are bound by the bindtp, while the occurrences of tp in \nMtp are free. These relationships mimic the facts that the actual binding for a call to tptin N is the \none active when M returns its result, whereas the actual binding for a call to tptin M is the one at \nthe time of evaluating MN. For the embedding of C-(.k.J), we note that because all the right\u00adhand sides \nof the embedding return terms of the subtractive type, a continuation k in .. C -tptis translated to \na continuation which expects a subtractive value as its argument. Hence, jumps to k return not only a \nregular result but also transfer the current binding of the top-level continuation to the context surrounding \nC-(.k.J). V tp (MN)tp (C -(.k.J))tp (C -(.ttp.J))tp =(V + ,tp 0) = bindtp Mtp in Ntp = C -(.k.Jtp) =(C \n-(.tp.Jtp),tp 0) x+ (.x.M)+ = = x .(x,tp).Mtp (kM)tp (ttp M)tp = = kMtp tp (join Mtp) Figure 19. Embedding \nof .. C -tptC -terms  terms in ..- The two most interesting clauses are the ones involving tpt.For the \nembedding of C-(.tpt.J), we return a subtractive term with the current top-level continuation tp as the \njump context and a com\u00adputation which introduces a fresh tp thus simulating the rebind\u00ading of the top-level \ncontinuation in J. Because of the context in which C -(.tp...) occurs in the right-hand side it is clear \nthat tp does not expect a subtractive value as its argument. Thus, the argu\u00adment passed to a top-level \njump is evaluated to produce a value and a jump context, which are consumed before returning to tp. In \nthe special case, where we jump to the top-level with a value, we have (tp Vt)tp . tp V + . Combining \nthe embedding from .C # to .. C -tpt(Figure 6) with the em\u00ad + x= x (.x.M)+ = .(x,tp).Mtp Vtp =(V + ,tp) \n(MN)tp = bindtp Mtp in Ntp (C M)tp = C -(.k. tp (join Mtp (bindtpI in (.(x,tp).throw k (x,tp 0) ,tpI \n0)))) (# M)tp =(C -(.tp. tp (join Mtp)),tp 0) Figure 20. Embedding of .C # terms in ..- C -terms bedding \nwe just de.ned, produces a direct embedding from .C # into ..- C -shown in Figure 20. The translation \nof C M is the most com\u00adplicated: the continuation k is .rst captured and then we jump to the top-level \nwith a computation that .rst evaluates M. Once M produces a value f and perhaps a new top-level continuation \ntpI , we apply f to a subtractive value consisting of the rei.ed contin\u00aduation and tpI . When the rei.ed \ncontinuation is invoked on an ar\u00adgument P, it is given the value and top-level continuation resulting \nfrom the evaluation of P which it passes to k aborting its context. Given the equivalence of C and S, \nit is easy to calculate that the embedding of S differs only in the details of the rei.ed continuation \nwhich becomes: .(x,tp).C -(.tpII .k (x,tpII (0,tp0))) Thus instead of ignoring the top-level continuation \ntpII at the call site like in the case of C , this continuation composes the top-level continuations, \n.rst returning to tp and then returning to tpII . EXAMPLE 6. (Embedding in ..- C ) If the top-level continuation \n- is tp, the embedding of the .C # term (y (# x)) which corresponds to the .. C tp term (y (C tp. t -t-(.ttp \nx))) is: (y (C -(.tpt. t. -(.tpt. ttp x)))tp y ((C tp x))tp) . y ((C -(.tpI .tpI x),tp 0)) The current \ntop-level continuation is saved using the subtraction introduction and a new top-level continuation is \nused for receiving the value of x. The embedding of .. -tinto ..- is sound in the sense that embed\u00ad - \nC tp C ding a .. C -tptC \u00ad reduction yields a reduction sequence in ..- . This does not imply however \nthat there is any relationship between .C # reduc\u00adtions and ..- C -reductions under the combined embedding \nof Fig\u00adure 20 because the intermediate Proposition 3 only provides sound\u00adness up to operational equivalence. \nThe notation . =1 indicates a reduction sequence of at least one step. PROPOSITION 8. A reduction M . \nNin .. C -tptimplies a sequence of reductions Mtp. =1Ntp in ..- C -for any fresh continuation vari\u00adable \ntp. The theory ..- -is richer than .. -t, so that the translation is not CC tpcomplete. Indeed, the dynamically-bound \ncontinuation tptis turned into an ordinary statically-bound continuation: the limitations we imposed \non lifting C-(.tpt...) in Section 5.2 can no longer be en\u00adforced. For instance, the term in Example 6 \ncan be further reduced as follows: y ((C -(tpI .tpI x),tp 0)) - C lift . y (C -(tpI .tpI (x,tp 0))) - \nC lift . C -(tpI .tpI (y (x,tp 0))) The lift reductions have moved the prompt while maintaining the proper \nreferences to the top-level continuation. This move has no counterpart in either .C # or .. -t.In .. \n-tsuch a lifting would cause C tpC tp the dynamically-bound top-level continuation tptto be incorrectly \ncaptured; in ..- C -, the top-level continuation is statically-bound so that it is enough to rely on \na-conversion to have a safe lifting rule for prompt. Pulling the lifting rule for prompt back from ..- \nC -to .. C -tptis non trivial, if ever possible. 8.2 Embedding .. C tp Judgements -t To reason about \ntype-safety we present the embedding of .. C -tptjudgements into ..- C -. We present it for the more \ngeneral system of Figure 14 since the less general system of Figure 13 comes by re\u00adquiring both annotations \nto be the same. In the translation, the type of the dynamically-bound prompt is the type of the fresh \nvariable tp used for the translation and the type of the prompt returned by the main expression (if any) \nis made explicit thanks to the subtraction connective: (G;B f M : A;C)tp = G* ,tp : C* ...f Mtp : A*- \nB* (G f J :. ;C)tp = G* ,tp : C* ...f Jtp :. , .. eff Let us write .. -teffeq -tand ..- for the type \nsystems on Fig\u00ad - C tp C tp C ures 13, 14 and 18 respectively. For tp a fresh continuation variable, \nthe translation above is sound. PROPOSITION 9. (i) If G;U f M : A;Tin .. -teff then (G;U f M : A;T )tp \nin ..- , - C tp C (ii) If G f J :. ;Tin .. C -tpteff C -. then (G f J :. ;T )tp in ..- We can also consider \nthe extension from Section 6.1 of the type system of Figure 7: let .. C -tpt.xed be the system of Figure \n7 with tp changed into the dynamic continuation variable tptthat can be abstracted by the rule G f J \n:. ;T RAAtptG;T f C -(.tpt. J) : T ;T Let AT be the operation of adding twice the same atomic effect \nT on the occurrences of . in the effect-free formula A. Let GT be the extension of this operation to \nan effect-free G. We have: If G f M : A;Tin .. .xed PROPOSITION 10. Let T be atomic. -t C tp then GT \n;T f M : AT ;Tin .. C -tpteff . Hence (GT ;T f M : AT ;T )tp in ..- -. C Collecting the previous results \nwith Proposition 7 and 8, we have: PROPOSITION 11. (i) If G;U f M : A;Tin .. -teff or G f M : A;Tin .. \n-teffeq then M C tp C tp is strongly normalising. (ii) If G f M : A;Tin .. C -tpt.xed and T is atomic \nthen M is strongly normalising. Especially, the last item says that we cannot enforce strong normal\u00adisation \nas soon as the top-level type is not atomic. Indeed, if T is non atomic then we have to add the annotation \nT on the arrows of T itself. This requires a de.nition by .xpoint and the resulting recursive type can \nbe used to type a .xpoint combinator as shown in Example 4.  9 Other Control Operators We have focused \nexclusively on functional continuations obtained with shift (or C ) and reset. We brie.y review and classify \nsome of the other control operators in the literature and discuss them based on our work. 9.1 A Short \nHistory As we have seen, early proposals for functional continuations [10, 8, 5] had only a single control \ndelimiter. The operation like shift for capturing the functional continuation implicitly refers to the \nmost recent occurrence of this delimiter. The limitations of the single control delimiter however became \nquickly apparent, and later proposals generalised the single de\u00adlimiter by allowing hierarchies of prompts \nand control operators like resetn and shiftn [6, 35]. At about the same time, a differ\u00adent proposal spawn \nallowed new prompts to be generated dynam\u00adically [21, 20]. In this system, the base of each functional \ncontin\u00aduation is rooted at a different prompt. The action of creating the prompt returns a specialised \ncontrol operator for accessing occur\u00adrences of this particular prompt; this specialised control operator \ncan then be used for capturing (and aborting) the particular func\u00adtional continuation rooted at the newly \ngenerated prompt (and only that one). This is more expressive and convenient than either sin\u00adgle prompts \nor hierarchies of prompts and allows arbitrary nesting and composition of continuation-based abstractions. \nA later pro\u00adposal by Gunter et. al. [16] separated the operation for creating new prompts from the control \noperator using that prompt. 9.2 Prompts and Extent The issues related to hierarchies of prompts or the \ndynamic gener\u00adation of new names for prompts, appear orthogonal to our analy\u00adsis. Indeed the presence \nof multiple prompts does not change the fundamental point about the dynamic behaviour of each individual \nprompt. However, our analysis fundamentally relies on a subtle issue related to the extent of prompts \n[29]. More precisely, there is no question that the prompt delimits the part of the context that a control \nop\u00aderator gets to capture, but given that constraint there are still four choices to consider with very \ndifferent semantics [7]: E.[# (E.[F1 M])] . E.[M (.x.E.[x])] E.[# (E.[F2 M])] . E.[# (M (.x.E.[x]))] \nE.[# (E.[F3 M])] . E.[M (.x.# (E.[x]))] E.[# (E.[F4 M])] . E.[# (M (.x.# (E.[x])))] All four variants \nhave been proposed in the literature: F1 is like cupto [16]; F2 is Felleisen s F operator [10]; F3 is \nlike a spawn controller [21]; and F4 is shift [6]. It turns out that the inclusion of the prompt in the \nrei.ed continua\u00adtion (variants F3 and F4) simpli.es the semantics considerably. For example, when a continuation \ncaptured by F3 or F4 is invoked, the included prompt can be used to provide the required top-level con\u00adtext \nfor that invocation. In the case of F1 or F2, there is no included prompt; so when the continuation is \ninvoked, we must search for the prompt required to denote the top-level. In general, the prompt can be \nlocated arbitrarily deep in the calling context. Since the representation of contexts as functional continuations \ndoes not sup\u00adport operations for searching for prompts, Felleisen et al. [11] developed a special model \nbased on an algebra of contexts which supports the required operations. In a recent investigation of \ncon\u00adtrol operators for functional continuations, Dybvig et al. [7] show however that it is possible to \nuse standard continuation semantics to explain all the four variants of operators above: the trick is \nto augment the model with a state variable containing a sequence of continuations and prompts. They in \nfact present an implementa\u00adtion in Haskell that we believe can be adapting as the basis for an embedding \nin a variant (or extension) of ..- C -. Acknowledgements We thank Olivier Danvy, Matthias Felleisen, \nYukiyoshi Kameyama, and Hayo Thielecke for the discussions and help they provided in understanding their \nresults. We would also like to thank the ICFP reviewers who provided corrections and extensive comments \non the presentation. 10 References [1] Z. M. Ariola and H. Herbelin. Minimal classical logic and control \noperators. In Proceedings of the 30th Interna\u00adtional Colloquium on Automata, Languages and Program\u00adming \n(ICALP 03), volume 2719 of LNCS, pages 128 136, Eindhoven, The Netherlands, June 30 -July 4, 2003. Springer-Verlag, \n[2] T. Crolard. Subtractive logic. Theor. Comput. Sci., 254(1\u00ad2):151 185, 2001. [3] T. Crolard. A formulae-as-types \ninterpretation of subtractive logic. Journal of Logic and Computation (Special issue on Modalities in \nConstructive Logics and Type Theories), 2004. To appear. [4] P.-L. Curien and H. Herbelin. The duality \nof computation. In Proceedings of the 5th International Conference on Func\u00adtional Programming, pages \n233 243, 2000. [5] O. Danvy and A. Filinski. A functional abstraction of typed contexts. Technical Report \n89/12, DIKU, University of Copenhagen, Copenhagen, Denmark, 1989. [6] O. Danvy and A. Filinski. Abstracting \ncontrol. In Proceed\u00adings of the 1990 ACM Conference on LISP and Functional Programming, Nice, pages 151 \n160, New York, NY, 1990. ACM. [7] R. K. Dybvig, S. Peyton-Jones, E. Moggi, A. Sabry, and O. Waddell. \nMonadic functional subcontinuations. Unpub\u00adlished manuscript, 2004. [8] M. Felleisen. The theory and \npractice of .rst-class prompts. In Proceedings of the 15th ACM Symposium on Principles of Programming \nLanguages (POPL 88), pages 180 190, Jan 1988. [9] M. Felleisen. On the expressive power of programming \nlan\u00adguages. In N. Jones, editor, ESOP 90 3rd European Sympo\u00adsium on Programming, Copenhagen, Denmark, \nvolume 432, pages 134 151. Springer-Verlag, New York, N.Y., 1990. [10] M. Felleisen, D. Friedman, and \nE. Kohlbecker. A syntactic theory of sequential control. Theoretical Computer Science, 52(3):205 237, \n1987. [11] M. Felleisen, M. Wand, D. P. Friedman, and B. F. Duba. Ab\u00adstract continuations: A mathematical \nsemantics for handling full functional jumps. In Conference on LISP and Functional Programming, Snowbird, \nUtah, pages 52 62. ACM, 1988. [12] A. Filinski. Representing monads. In Proceedings of the 21st ACM SIGPLAN-SIGACT \nSymp. on Principles of Program\u00adming Languages (POPL 94) , Portland, OR, USA, 17 21 Jan. 1994, pages 446 \n457, New York, 1994. ACM Press. [13] A. Filinski. Representing layered monads. In Proceedings of the \n26th ACM SIGPLAN-SIGACT Symp. on Principles of Pro\u00adgramming Languages (POPL 99), San Antonio, Texas, \npages 175 188. ACM Press, 1999. [14] S. E. Ganz, D. P. Friedman, and M. Wand. Trampolined style. In Proceedings \nof the 4th ACM SIGPLAN international conference on Functional programming, pages 18 27. ACM Press, 1999. \n[15] T. G. Grif.n. The formulae-as-types notion of control. In Pro\u00adceedings of the 17th Annual ACM Symp. \non Principles of Pro\u00adgramming Languages, POPL 90, S an Francisco, CA, USA, 17 19 Jan 1990, pages 47 57, \nNew York, 1990. ACM Press. [16] C. A. Gunter, D. R\u00b4emy, and J. G. Riecke. A generalization of exceptions \nand control in ML-like languages. In Func\u00adtional Programming &#38; Computer Architecture, New York, 1995. \nACM Press. [17] J. Guzm\u00b4an and A. Su\u00b4arez. An extended type system for excep\u00adtions. In Record of the \n5th ACM SIGPLAN workshop on ML and its Applications, June 1994. Also appears as Research Report 2265, \nINRIA, BP 105 -78153 Le Chesnay Cedex, France. [18] C. T. Haynes. Logic continuations. In Proceedings \nof the 3th International Conference on Logic Programming, volume 225 of LNCS, pages 671 685, Berlin, \nJuly 1986. Springer-Verlag. [19] C. T. Haynes, D. Friedman, and M. Wand. Obtaining corou\u00adtines from continuations. \nJournal of Computer Languages, 11:143 153, 1986. [20] R. Hieb, K. Dybvig, and C. W. Anderson, III. Subcontinua\u00adtions. \nLisp and Symbolic Computation, 7(1):83 110, 1994. [21] R. Hieb and R. K. Dybvig. Continuations and Concurrency. \nIn PPoPP 90, Symposium on Principles and Practice of Parallel Programming, volume 25(3) of SIGPLAN NOTICES, \npages 128 136, Seattle, Washington, March 14 16, 1990. ACM Press. [22] W. Howard. The formulae-as-types \nnotion of construction. In J. R. Hindley and J. P. Seldin, editors, To H. B. Curry: Es\u00adsays in Combinatory \nLogic, Lambda Calculus and Formalism, pages 479 490. Academic Press, 1980. [23] Y. Kameyama. A type-theoretic \nstudy on partial continua\u00adtions. In IFIP TCS, pages 489 504, 2000. [24] Y. Kameyama. Towards logical \nunderstanding of delimited continuations. In Proceedings of the Third ACM SIGPLAN Workshop on Continuations \n(CW 01), 2001. [25] Y. Kameyama and M. Hasegawa. A sound and complete ax\u00adiomatization of delimited continuations. \nIn Proc. of 8th ACM SIGPLAN Int. Conf. on Functional Programming, ICFP 03, Uppsala, Sweden, 25 29 Aug. \n2003, volume 38(9) of SIG-PLAN Notices, pages 177 188. ACM Press, New York, 2003. [26] M. Lillibridge. \nUnchecked exceptions can be strictly more powerful than call/cc. Higher-Order and Symbolic Computa\u00adtion, \n12(1):75 104, Apr. 1999. [27] E. Moggi. Computational lambda-calculus and monads. In Proceedings of the \nFourth Annual Symposium on Logic in computer science, pages 14 23. IEEE Press, 1989. [28] L. Moreau. \nA syntactic theory of dynamic binding. Higher Order Symbol. Comput., 11(3):233 279, 1998. [29] L. Moreau \nand C. Queinnec. Partial Continuations as the Dif\u00adference of Continuations. A Duumvirate of Control Opera\u00adtors. \nIn International Conference on Programming Language Implementation and Logic Programming (PLILP 94), \nnum\u00adber 844 in LNCS pages 182 197, Madrid, Spain, Sept. 1994. Springer-Verlag. [30] C. Murthy. Control \noperators, hierarchies, and pseudo\u00adclassical type systems: A-translation at work. In ACM work\u00adshop on \nContinuations, pages 49 71, 1992. [31] M. Parigot. Lambda-mu-calculus: An algorithmic interpreta\u00adtion \nof classical natural deduction. In Proceedings of Inter\u00adnational Conference on Logic Programming and \nAutomated Reasoning (LPAR 92), St. Petersburg, Russia, pages 190 201. Springer-Verlag, 1992. [32] C. \nRauszer. Semi-boolean algebras and their application to intuitionistic logic with dual connectives. Fundamenta \nMath\u00adematicae, 83:219 249, 1974. [33] J. G. Riecke and H. Thielecke. Typed exceptions and continu\u00adations \ncannot macro-express each other. In Proceedings of the 26th International Colloquium on Automata, Languages \nand Programming (ICALP), volume 1644 of LNCS, pages 635 644, Berlin, 1999. Springer-Verlag. [34] A. Sabry \nand M. Felleisen. Reasoning about programs in continuation-passing style. Lisp Symb. Comput., 6(3-4):289 \n360, 1993. [35] D. Sitaram and M. Felleisen. Control delimiters and their hi\u00aderarchies. Lisp and Symbolic \nComputation, 3(1):67 99, 1990. [36] The SML/NJ library. Available from http://smlnj.org/. [37] H. Thielecke. \nOn exceptions versus continuations in the pres\u00adence of state. In Proceedings of the 9th European Symposium \nOn Programming (ESOP), volume 1782 of LNCS, pages 397 411, Berlin, 2000. Springer-Verlag. [38] H. Thielecke. \nContrasting exceptions and continuations. Version available from http://www.cs.bham.ac.uk/ hxt/ research/exncontjournal.pdf, \n2001. [39] H. Thielecke. Comparing control constructs by double\u00adbarrelled CPS. Higher-order and Symbolic \nComputation, 15(2/3):119 136, 2002. [40] P. Wadler. Monads and composable continuations. Lisp and Symbolic \nComputation, 7(1):39 56, Jan. 1994. [41] M. Wand. Continuation-based multiprocessing revisited. Higher-Order \nand Symbolic Computation, 12(3):285 299, Oct. 1999. Reprinted from the proceedings of the 1990 Lisp Conference, \nwith a foreword.   \n\t\t\t", "proc_id": "1016850", "abstract": "There is a correspondence between classical logic and programming language calculi with first-class continuations. With the addition of control delimiters (prompts), the continuations become composable and the calculi are believed to become more expressive. We formalise that the addition of prompts corresponds to the addition of a single dynamically-scoped variable modelling the special top-level continuation. From a type perspective, the dynamically-scoped variable requires effect annotations. From a logic perspective, the effect annotations can be understood in a standard logic extended with the dual of implication, namely subtraction.", "authors": [{"name": "Zena M. Ariola", "author_profile_id": "81100218587", "affiliation": "University of Oregon", "person_id": "P309510", "email_address": "", "orcid_id": ""}, {"name": "Hugo Herbelin", "author_profile_id": "81100052794", "affiliation": "INRIA-Futurs", "person_id": "PP43115626", "email_address": "", "orcid_id": ""}, {"name": "Amr Sabry", "author_profile_id": "81100016804", "affiliation": "Indiana University, Bloomington, IN", "person_id": "P16266", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1016850.1016860", "year": "2004", "article_id": "1016860", "conference": "ICFP", "title": "A type-theoretic foundation of continuations and prompts", "url": "http://dl.acm.org/citation.cfm?id=1016860"}