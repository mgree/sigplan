{"article_publication_date": "09-19-2004", "fulltext": "\n The C--Compiler Infrastructure Norman Ramsey Simon L. Peyton Jones Harvard University Microsoft Research \nC--is a new kind of compiler infrastructure: one whose pri\u00admary goal is to help you build a quality implementation \nof the language of your choice on the machine of your choice. Many compiler infrastructures support multiple \nmachines, but only C-\u00adis designed from the beginning to support multiple front ends for multiple programming \nlanguages. The key insight driving C--is that to support such language fea\u00adtures as garbage collection, \nexception dispatch, and concurrency, it is not enough for an infrastructure just to translate programs \ninto target-machine code the infrastructure must also support the run\u00adtime system. C--provides this support \nthrough a unique run-time interface, which reveals to the run-time system the important de\u00adcisions made \nin the compiler s back end. C--also provides a compile-time interface. For ease of use with multiple \nclients, this interface is not an API but a language with an ASCII syntax. Using an ASCII syntax makes \nthe interface independent of the programming language used to implement the client, but making the C--compile-time \ninterface a language also provides other bene.ts: it is much easier to debug a program than to debug \na sequence of API calls, and we have better formal tools for specifying the proper use and semantics \nof a language than for specifying the use and semantics of an API. A client of our system emits code \nin the C--language, which our compiler then translates to native machine code. This na\u00adtive machine code \nruns together with the client s run-time system, which makes calls into the C--run-time interface. Using \nC--, a client can divide work between compiler and run-time system much as it would if using a custom \ncode generator. For example, a client that implements garbage collection might generate C--code to test \nfor heap exhaustion, to advance an allocation pointer, and to initialize the .elds of a newly allocated \nobject. But that same client would probably put the garbage collector in its run-time sys\u00adtem, where \nit would use the C--run-time interface to walk each activation on the stack and to get access to the \nvalues of local C-\u00advariables. The C--interfaces hide many details of the target machine, in\u00adcluding the \nnumber and kinds of machine registers and the names and capabilities of machine instructions. The interfaces \nalso hide many compiler algorithms, which can then be reused by multiple clients. These algorithms are \nwell understood but dif.cult to im\u00adplement; they include register allocation, instruction scheduling, \npeephole optimization, and many scalar and loop optimizations. Despite this hiding, the C--interfaces \nare resolutely low-level: Copyright is held by the author/owner(s). ICFP 04, September 19 21, 2004, Snowbird, \nUtah, USA. ACM 1-58113-905-5/04/0009. they are much more like an assembly language than like the JVM \nor .NET frameworks. For example, a client targeting C--has full control over the representation of high-level \ntypes such as strings, records, arrays, objects, functions, and so on. Our long-term goals for C--are \nto provide a reusable, optimiz\u00ading back end that will support many useful optimizations on many target \nmachines. By paying careful attention to how C--is actu\u00adally used by clients, we hope to make our compiler \ninfrastructure easier to use than C while producing code that is almost as good as what one would get \nfrom a custom code generator. Norman Ramsey graduated from Princeton University in 1983 with a degree \nin physics. He eventually switched to computing, in which .eld he earned the PhD from Princeton in 1993. \nAfter six years at Bellcore, Purdue, and the University of Virginia, he came to Harvard, where he is \nnow Associate Professor of Computer Sci\u00adence in the Division of Engineering and Applied Sciences. His \nmain research interest is how to build reusable, retar\u00adgetable programming-language infrastructure: compilers, \nassem\u00adblers, linkers, and debuggers. In his work on retargeting, he has pioneered the use of declarative \nmachine descriptions, which say only what the machine does and do so in terms that are indepen\u00addent of \nparticular implementations or tools. His SLED descrip\u00adtion language has been reused for applications \nranging from binary translation to proof-carrying code. He is also interested in language design and \nin programming technique. He especially enjoys functional programming because of the many opportunities \nto realize a design in a form that is at once clean, elegant, and executable. Simon Peyton Jones graduated \nfrom Trinity College Cambridge in 1980. After two years in industry, he spent seven years as a lec\u00adturer \nat University College London and nine years as a professor at Glasgow University before moving to Microsoft \nResearch in 1998. His main research interest is in functional programming lan\u00adguages, their implementation, \nand their application. He has led a succession of research projects focused around the design and im\u00adplementation \nof production-quality functional-language systems for both uniprocessors and parallel machines. He was \na key con\u00adtributor to the design of the now-standard functional language Haskell, and he is the lead \ndesigner of the widely-used Glasgow Haskell Compiler. He has written two textbooks about the imple\u00admentation \nof functional languages. He is also interested in language design, rich type systems, soft\u00adware component \narchitectures, compiler technology, code genera\u00adtion, runtime systems, virtual machines, garbage collection, \nand so on. He is particularly motivated by direct use of principled theory to practical language design \nand implementation.  \n\t\t\t", "proc_id": "1016850", "abstract": "", "authors": [{"name": "Norman Ramsey", "author_profile_id": "81100300481", "affiliation": "Harvard University", "person_id": "PP14110628", "email_address": "", "orcid_id": ""}, {"name": "Simon L. Peyton Jones", "author_profile_id": "81100271851", "affiliation": "Microsoft Research", "person_id": "PP14102537", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1016850.1016851", "year": "2004", "article_id": "1016851", "conference": "ICFP", "title": "The C&#8212;compiler infrastructure", "url": "http://dl.acm.org/citation.cfm?id=1016851"}