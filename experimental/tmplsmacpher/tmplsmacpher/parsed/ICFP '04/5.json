{"article_publication_date": "09-19-2004", "fulltext": "\n Regular Expression Patterns Niklas Broberg Andreas Farre Josef Svenningsson d00nibro@dtek.chalmers.se \nd00farre@dtek.chalmers.se josefs@cs.chalmers.se Chalmers University of Technology Abstract We extend \nHaskell with regular expression patterns. Regular ex\u00adpression patterns provide means for matching and \nextracting data which goes well beyond ordinary pattern matching as found in Haskell. It has proven useful \nfor string manipulation and for pro\u00adcessing structured data such as XML. Regular expression patterns \ncan be used with arbitrary lists, and work seamlessly together with ordinary pattern matching in Haskell. \nOur extension is lightweight, it is little more than syntactic sugar. We present a semantics and a type \nsystem, and show how to imple\u00adment it as a preprocessor to Haskell. Categories and Subject Descriptors \nD.3.2 [Language Classi.cations]: Applicative (functional) lan\u00adguages; D.3.3 [Language Constructs and \nFeatures]: Patterns General Terms Languages  Keywords Regular expressions, pattern matching, Haskell \n1 Introduction Pattern matching as found in many functional languages is a nice feature. It allows for \nclear and succint de.nitions of functions by cases and works very naturally together with algebraic data \ntypes. But sometimes ordinary pattern matching is not enough. A distinct feature of this form of pattern \nmatching is that it only examines the outermost constructors of a data type. While this allows for ef.cient \nimplementations it is also a rather limited construct for analysing and retrieving data. Permission to \nmake digital or hard copies of all or part of this work for personal or classroom use is granted without \nfee provided that copies are not made or distributed for pro.t or commercial advantage and that copies \nbear this notice and the full citation on the .rst page. To copy otherwise, to republish, to post on \nservers or to redistribute to lists, requires prior speci.c permission and/or a fee. ICFP 04, September \n19 21, 2004, Snowbird, Utah, USA. Copyright 2004 ACM 1-58113-905-5/04/0009 ...$5.00 A well-known example \nof a construct that provides deeper and more complex retrievals are regular expressions for strings. \nWhile this is not a very common feature among programming languages it is one of the key constructs that \nhave made Perl so popular. Regular expressions are ideal for various forms of string manipulation, text \nextraction etc, however, they remain a very domain speci.c and ad\u00adhoc construct targeted only for one \nparticular data structure, namely strings. On another axis we .nd the recent trend in XML centric lan\u00adguages. \nThe .rst attempts at such languages used the ordinary pat\u00adtern matching facility of functional languages \nto analyze XML frag\u00adments [MS99]. This was found to be too restrictive, so in order to be able to express \nmore sophisticated patterns and transformations on XML fragments the notion of regular expression patterns \nwere invented. Examples of languages including this feature are XDuce [HP03] and CDuce [BCF03]. While \nthis is a great boost for the XML programmer, in the case of XDuce it only works for XML data and not \nfor any other data. Furthermore those pattern match\u00ading constructs are closely tied to rather sophisticated \ntype systems which makes them somewhat heavyweight. In this paper we extend Haskell with regular expression \npatterns. Our extension has the following advantages: Our proposal is lightweight. It is hardly more \nthan syntactic sugar. Most notably it does not require any complex additions to the type system.  It \nworks for arbitrary lists. It is a general construct and not tied to a speci.c data type for elements. \nBut it should be noted that it works in particular for strings since strings are just lists of characters \nin Haskell.  It .ts seamlessly with the ordinary pattern matching facility found in Haskell.  In this \npaper we give a detailed semantics and type system of reg\u00adular expression patterns. The extension has \nbeen implemented as a preprocessor to Haskell, and we sketch the implementation While we have chosen \nto focus on Haskell in this paper there are very little Haskell speci.c details. We are quite con.dent \nthat our proposal could be adapted to any similar functional language. In recent years a number of papers \nhave been devoted to de\u00adveloping ef.cient pattern matching and ef.cient regular matching [Fri04, HM03, \nLev03]. This is not the concern of this paper. Al\u00adthough ef.ciency is an important consideration we focus \nonly on language design. Another issue that we do not address is the question of overlap\u00adping and exhaustive \npatterns. We are con.dent that the existing techniques developed for XML centric languages will do the \njob nicely [HVP00]. Note also that in general it is undecidable to check whether patterns are overlapping \nor non-exhaustive in Haskell be\u00adcause of guards, so in our setting it is something of a non-issue. 2 \nRegular expression patterns by example 2.1 Ordinary pattern matching Assume that we have the following \ndatatype representing an entry in an address book. data Contact = Person Name [ContactMode] data ContactMode \n= Tel TelNr We can assume that the types Name and TelNr are type synonyms for String. The reason for \nnot inlining TelNr in Contact is be\u00adcause we will later want to add other means of contact, e.g. email \naddresses, to our address book. Now consider two different functions that extract information from a \ncontact; firstTel will return the .rst TelNr in the list of contact modes associated with a contact. \nlastTel will analogously return the last associated TelNr. The .rst is easy to write using simple pattern \nmatching on a contact: firstTel :: Contact -> TelNr firstTel (Person _ (Tel nr : _)) = nr firstTel \n(Person _ []) = error \"No Tel\" The second function, although its functionality is very similar to firstTel, \ncannot be written in the same simple way. We must instead resort to recursion and an auxiliary function \nto step through the list until we reach the end. lastTel :: Contact -> TelNr lastTel (Person _ nrs) \n= aux nrs where aux [] = error \"No Tel\" aux [Tel nr] = nr aux (_:nrs) = aux nrs Although the two \nfunctions have very similar functionality, only one of them can be written using direct pattern matching. \nWhy is this so? The answer lies, of course, in the list datatype. A (non\u00adempty) list has a head and a \ntail, so extracting the .rst element is easy. To get to the last element however, we must recursively \nlook at the tail for its last element. In other words, we must .rst match on the structure of the list, \nbefore being able to look at the elements. Haskell has a construct for matching directly on the elements \nof a list, but only for .xed-size lists. If we know that a contact never has more than three phone numbers, \nwe could write lastTel as (we will ignore the erroneous case from now on) lastTel (Person _ [Tel nr]) \n= nr lastTel (Person _ [_, Tel nr] = nr lastTel (Person _ [_, _, Tel nr] = nr Clearly this is not \na very good solution. Even for this very small task we must write far more than we are comfortable with, \nand for larger lists or more complex datatypes this approach quickly becomes infeasible. What we need \nis a way of saying match a list containing a Tel, preceded by any number of other elements . This is \nwhere regular expression patterns enter the picture. 2.2 Regular expression patterns Mathematically \na regular expression de.nes a regular language, where language in this context means a (possibly in.nite) \nset of words, and each word is a sequence of elements taken from some alphabet. We can use a regular \nexpression as a validator and try to match an arbitrary word against it to .nd out if the word belongs \nto that regular language or not. The basic regular expression operators are repetition, concatenation \nand choice. Concatenation is straight\u00adforward, ab means a followed by b. Choice (a|b) means either a \nor b. Repetition a* means zero or more occurrences of a. Repetition can be de.ned using choice and recursion \nas a*= e|aa* where e denotes the empty sequence. As an example, consider the regular expression e = a \n*|b*. The language de.ned by e, denoted L(e),is the set of all words consisting of only a s or only b \ns, including the empty word. We have that aa .L(e), bbb .L(e),but ab ./L(e).In other words, aa and bbb \nboth match the regular expression e,but ab doesn t. This notion of treating a regular expression as a \nvalidator is very similar to the concept of pattern matching in Haskell. We take a Haskell value (a word) \nand a pattern (a regular expression) and try to match them, getting a yes or no as the result. Combining \nthese two concepts is straight-forward, yielding what we call regular ex\u00adpression patterns. As noted, \na regular expression can be matched against a sequence of elements from some alphabet. Lifting this idea \ninto Haskell, a regular expression pattern can be matched against a list of elements of some datatype. \nWhen we speak of a sequence, we mean a sequence of elements in the abstract sense. In contrast, when \nwe speak of a list, we mean the list datatype that is used to encode sequences in Haskell. Returning \nto our lastTel function, we can now easily write it with a single pattern match by using a repetition \nregular expression pat\u00adtern: lastTel (Person _ [_*, Tel nr]) = nr We write concatenation using commas \nas with ordinary Haskell lists, and we denote repetition with *. As we can see from the exam\u00adple, regular \nexpression patterns are actually more .exible than bare regular expressions. A regular expression is \nbuilt from elements of some alphabet, the same alphabet that the words it may match are built from. A \nregular expression pattern on the other hand is built from patterns over elements of some datatype, allowing \nus to use constructs like wildcards and pattern variables. We use the term regular expression pattern \nboth for the subpatterns (repetition, choice etc) and for a top-level list pattern that contains the \nformer. It should be clear from the context which we are referring to. 2.3 Repetition and Ambiguities \nLet us see what else we can do with regular expression patterns. First, as promised, we extend our datatype \nwith email addresses. data Contact = Person Name [ContactMode] data ContactMode = Tel TelNr | Email \nEAddr If we only have ordinary pattern matching we cannot even write firstTel without resorting to recursion \nand auxiliary functions. firstTel (Person _ cmodes) = aux cmodes where aux (Tel nr : _) = nr aux (_ : \ncmodes) = aux cmodes Using a regular expression pattern, we can write it in one go: firstTel (Person \n_ [(Email _)*, Tel nr, _*]) = nr The straight-forward intuition of the pattern above is that the .rst \nTel in the list is preceded by zero or more Emails(butno Tels), and any number of other elements may \nfollow it. We can easily write lastTel in a similar way as lastTel (Person _ [_*, Tel nr, (Email _)*]) \n= nr But seeing these two de.nitions leads to an interesting question: What happens if we write the \nfunction someTel :: Contact -> TelNr someTel (Person _ [_*, Tel nr, _*]) = nr i.e. where the Tel in \nquestion may both be preceded and suc\u00adceeded by other Tels? Clearly this pattern is ambiguous, since \nif we match it to e.g. Person \"Niklas\" [Tel 12345, Tel 23456, Tel 34567] we can derive a match for either \nof the three TelNrsto be bound to nr, by letting the .rst *match either 0, 1 or 2 Tels. To disambiguate \nsuch issues, we adopt the policy that a repetition pat\u00adtern will always match as few elements as possible \nwhile still letting the whole pattern match the given list. In standard terminology, our repetition regular \npatterns are non-greedy. This policy means that someTel above will be exactly the same as our firstTel \nfunction, since the .rst * will now try to match as few elements as possible. In some cases though, such \nas lastTel, we want the greedy behav\u00adior. To this end we let the programmer specify if a repetition pattern \nshould be greedy by adding an exclamation mark (!) to it, e.g. in the following de.nition of lastTel: \nlastTel (Person [_*!, Tel nr, _*]) = nr  2.4 Choice patterns Now that we ve seen the power of repetition \npatterns, we turn our attention to choice patterns. Assume that we want a function allTels that returns \na list of all telephone numbers associated with a contact. Without regular expression patterns we must \nonce more resort to recursion and auxiliary functions. allTels :: Contact -> [TelNr] allTels (Person \n_ cmodes) = aux cmodes where aux [] = [] aux (Tel nr : cmodes) = nr : aux cmodes aux (_ : cmodes) = aux \ncmodes Using a combination of repetition and choice, we can write it as allTels (Person _ [ (Tel nr \n| _)* ]) = nr The intuition here is that each element in the list of contact modes is either a Tel or \nsomething else ( ). Every time that we encounter a Tel, we should include the associated TelNr in the \nresult. As the example shows we can achieve this accumulation of TelNrs with a single pattern variable. \nSince the intuition of a repetition pattern is that its subpattern, i.e. the pattern it encloses, should \nbe matched zero or more times, the same must be true for any pattern variables inside such a pattern. \nFor each repetition, such a variable will match a new value. Clearly the only sensible thing to do is \nto let that variable bind to a list of all those matched values. This treatment of variables breaks one \naspect of Haskell s linearity property that the occurrence of a variable in a pattern will bind that \nvariable to exactly one value of the type that it matches. We will therefore call such a variable non-linear. \nA non-linear variable will be bound to a list of values that it matches, in the order that they were \nmatched (i.e. the order in which they appeared in the matched list). When we speak of a non-linear binding, \nwe mean a binding of a non-linear variable to a list of values. We will also use the terms non-linear \ncontext to mean a context in which linear variables cannot appear, and non-linear patterns, by which \nwe mean patterns whose subpatterns will always be matched in a non-linear context.  By the example \nabove we see that a repetition pattern is a non\u00adlinear pattern, and consequently that the variable nr \nappears in a non-linear context. Similarly a choice pattern is also non-linear. If we remove the repetition \nfrom the regular expression pattern in allTels we get the pattern [Tel nr| ] for matching a list of ex\u00adactly \none element. If that element is a Tel we will have a value to bind to nr, but if it is an Email we have \nnone! Thus we still can\u00adnot guarantee that a variable gets one value; in this case nr will be bound to \na list with zero or one element. The function allTels shows how regular expression patterns can be used \nfor .ltering a list based on pattern matching. We can go one step further and do partitioning, e.g. allTelsAndEmails \n:: Contact -> ([TelNr],[EAddr]) allTelsAndEmails (Person _ [(Tel nr | Email eaddr)* ]) = (nr, eaddr) \n A choice pattern can also be ambiguous if any of its subpatterns overlap, as in sillyAllTels :: Contact \n-> ([TelNr],[TelNr]) sillyAllTels (Person _ [ (Tel nr | Tel mr | _)* ]) = (nr, mr) To disambiguate this \nwe adopt a .rst-match policy, much like that of Haskell pattern matching. Thus we .rst check if the .rst \nsub\u00adpattern matches, and consider the k:th subpattern only if no pattern i < k matches. Note that we \nallow choice patterns to contain more than two subpatterns. Choice patterns are right associative so \nfor example [(Telnr|Telmr| )*] is parenthesised like [ (Telnr|(Telmr| ))*]. Another interesting thing \nabout choice patterns is that we allow a variable to appear in both subpat\u00adterns assuming that it binds \nto values of the same type. For instance, if our datatype for modes of contact was de.ned as data ContactMode \n= Home TelNr | Work TelNr we could de.ne allTels as allTels (Person _ [(Home nr | Work nr)*]) = nr \nVariables in choice patterns are still non-linear even if they appear in all subpatterns, so the function \nsingleTel (Person _ [(Home nr | Work nr)]) = nr will have the type Contact -> [TelNr]. 2.5 Subsequences \nand option patterns Regular expressions allow grouping of elements and subexpres\u00adsions using parentheses. \nFor example, the regular expression e = (ba)* will match the words ba, baba etc. To add this feature \nto our regular expression patterns we need to introduce some new syntax, since using ordinary parentheses \nin Haskell will denote tuples, as in  wrongEveryOther [(_,b)*] = b We (somewhat arbitrarily) choose \nto denote subsequences with (/ and /), so a correct function that picks out every other element from \na list can be written as everyOther :: [a] -> [a] everyOther [(/_, b/)*] = b There s a problem with \nthe above de.nition though; it works for lists of even length only. Surely we want everyOther to work \nfor any list. To achieve this we could add another declaration to the one above like everyOther [(/_, \nb/)*, _] = b to catch the cases where the list is of odd length too. But couldn t we write these two \ncases as a single pattern? Indeed we can, using a choice pattern everyOther [(/_, b/)*, ((/ /) | _)] \n where (/ /) denotes the empty subsequence, e. However, this pat\u00adtern is so common that regular expressions \nde.ne a separate oper\u00adator, ?, to denote optional regular expressions. The de.nition of ? is e? = e|e, \nand by lifting this to regular expression patterns we can write everyOther more compactly as everyOther \n[(/_, b/)*, _?] = b Obviously, optional patterns are non-linear since they can be de\u00ad.ned in terms of \nchoice patterns which are non-linear. Just as for a repetition pattern, an optional pattern is non-greedy \nby default. We also de.ne greedy optional patterns by ?! in analogy with greedy repetition patterns. \n 2.6 Non-empty repetition patterns There is one more operator to discuss, namely + that is used to de\u00adnote \nnon-empty repetition. For instance we might require all con\u00adtacts to have at least one mode of contact \nregistered, either a tele\u00adphone number or an email, otherwise it is an error. To enforce this we may \nwant to de.ne allTelsAndEmails from above as allTelsAndEmails (Person _ [(Tel nr | Email eaddr) ,(Tel \nnrs | Email eaddrs)*]) = (nr ++ nrs, eaddr:eaddrs) Using + we can de.ne this more compactly as allTelsAndEmails \n(Person _ [(Tel nr | Email eaddr)+]) = (nr, eaddr) Modulo variables bound, p+ = pp*. It is non-linear \nand non\u00adgreedy just like *, and there is a greedy counterpart +!. 2.7 Variable bindings and their types \nSince we can use any Haskell pattern inside regular expression pat\u00adterns, we can in particular use pattern \nvariables to extract values from the list that we match against, as we have seen in various ex\u00adamples \nalready. Haskell also de.nes a way to explicitly bind values to a variable using the @ operator. E.g. \nin the declaration allCModes :: Contact -> [ContactMode] allCModes (Person _ all@[(Tel _ | Email _)+]) \n= all the variable all will be bound to the (non-empty) list of ContactModes associated with a contact. \nThis is a very useful fea\u00adture to have for regular expression patterns as well, for instance we may want \nto write a function that picks the .rst two elements from a list as twoFirst :: [a] -> [a] twoFirst \n[a@(/_, _/), _*] = a However, adding this feature raises some interesting questions. Firstly, what will \nthe type of a variable bound to a regular expres\u00adsion pattern be? For a subsequence it seems fairly obvious \nthat it will have a list type, but what about repetitions, choices and op\u00adtional patterns? To this issue \nthere is no obvious right answer, one way might be to let a variable be bound to all elements matched \nby the subpattern in analogy with implicitly bound variables. We have chosen a slightly different approach \nin which we assign different types to patterns to mirror the intuition behind them. Subsequences and \nrepetition patterns will both have list types since they represent sequences. There s a difference between \nthem though; a subsequence is just what the name implies, a subsection of the original sequence. Thus \na variable bound to it will always have the same type as the input list, i.e. a list of elements. A rep\u00adetition \npattern on the other hand is a repetition of some subpattern, and so it will have the type of a list \nof that subpattern. For choice patterns we make use of Haskell s built-in Either type de.ned as data \nEither a b = Left a | Right b By using this type we can allow the left and right subpatterns of a choice \npattern to have different types, for instance singleCMode :: [ContactMode] -> Either ContactMode ContactMode \nsingleCMode [a@(Tel _ | Email _)] = a maybeSingleTel :: [ContactMode] -> Either ContactMode [ContactMode] \nmaybeSingleTel [a@(Tel _ | _*)] = a Similarly for optional patterns we use another built-in Haskell \ntype: data Maybe a = Nothing | Just a so if we write a function singleOrNoTel [(Email _)*,a@(Tel _)?,(Email \n_)*] = a it will have the type [ContactMode] -> Maybe ContactMode. One way to think about this is to \nsee the regular expression pattern operators as special data constructors. In an analogy with ordinary \nHaskell, we don t expect a to have the same type in the two uses a@(Just ) and (Just a@ ). Nor do we \nexpect the a in a@( ?) to have the same type as the a in (a@ )?. The second issue concerns linear vs. \nnon-linear binding. We have already seen that implicit bindings, i.e bindings that arise from the use \nof ordinary pattern variables, are context dependent; in linear context they get the ordinary types, \nwhereas in non-linear context they get list types. This context dependence unfortunately makes it easy \nfor the programmer to make mistakes, since it isn t clear just by looking at a variable in the pattern \nwhat type it will have. We cannot do anything about implicit bindings, but we can avoid the same problem \nfor explicit binding. Therefore we let the ordinary @ operator signify linear explicit binding, the only \nkind available in ordinary Haskell. For non-linear explicit binding we introduce a new operator @: (read \nas cons or accumulating as ). The former may not appear in non-linear context, whereas the latter may \nappear anywhere inside a regular expression pattern. Their differences are shown by the following examples: \n  [a@(Tel _) , _*] => a :: ContactMode [a@(Tel _)* , _*] => a :: [ContactMode] [(Tel a@_) , _*] => \na :: TelNr [(Tel a@_)* , _*] => Not allowed! [(Tel a@:_)*, _*] => a :: [TelNr] We can de.ne the semantics \nof implicit bindings in terms of ex\u00adplicit bindings. In linear context we have that a pattern variable \na is equivalent to the pattern a@ . This can be seen in the example [(Tel a), *] which is clearly equivalent \nto [(Tel a@ ), *]. In non-linear context, a is equivalent to a@: , as in the examples [(Tel a)*, *] and \n[(Tel a@: )*, *]. 2.8 Further examples Now that we ve seen all the basic building blocks that our regular \nexpression patterns consist of, let us put them to some real use. Traditionally regular expressions have \nbeen used in programming languages for text matching purposes, and certainly our regular ex\u00adpression \npatterns are well suited for this task. As an example, as\u00adsume we have a speci.cation of a simple options \n.le. An option has a name and a value, written on a single row, where name and value are separated with \na colon and a whitespace. Different options are written on different lines. Here are the contents of \na sample options .le: author: Niklas Broberg author: Andreas Farre author: Josef Svenningsson title: \nRegular Expression Patterns submitted: ICFP 2004 A simple parser for such option .les can be written \nusing a regular expression pattern as parseOptionFile :: String -> [(String,String)] parseOptionFile \n[(/ names@:_*, : , , vals@:_*, \\n /)*] = zip names vals where zip is a function that takes two lists \nand groups the elements pair-wise. XML processing is another area that greatly bene.ts from regu\u00adlar \nexpressions, since proper pattern matching on XML fragments requires ... matching of regular expressions \n[MvV01]. Indeed sev\u00aderal recent XML-centric languages (XDuce, CDuce) include regu\u00adlar expressions as \npart of their pattern matching facilities. As an example we encode XML in Haskell using a simple datatype \ndata XML = Tag String [XML] | PCDATA String An XML fragment is either a Tag, e.g. <P> ... </P>, which \nhas a name (a String) and a list of XML children, or it is PCDATA (XML lingo for a string inside tags). \nThis model is of course extremely simpli.ed, we ve left out anything that will not directly add any\u00adthing \nto our example, most notably XML attributes. Now assume that we have a simple XML email format, where \na sample email message in this format might look like:     <MSG> <FROM>d00nibro@dtek.chalmers.se</FROM> \n<RCPTS> <TO>d00farre@dtek.chalmers.se</TO> <TO>josefs@cs.chalmers.se</TO> </RCPTS> <SUBJECT>Regular \nExpression Patterns</SUBJECT> <BODY> <P>Regular expression patterns are useful</P> </BODY> </MSG> which \nwould be encoded in our XML datatype as Tag \"MSG\" [ Tag \"FROM\" [PCDATA \"d00nibro@dtek.chalmers.se\"], \nTag \"RCPTS\" [ Tag \"TO\" [PCDATA \"d00farre@dtek.chalmers.se\"], Tag \"TO\" [PCDATA \"josefs@cs.chalmers.se\"] \n], Tag \"SUBJECT\" [PCDATA \"Regular Expression Patterns\"], Tag \"BODY\" [ Tag \"P\" [PCDATA \"Regular expression \npatterns are useful\"] ] ] We can write a function to convert messages from this XML format into the \nstandard RFC822 format using regular expression patterns: xmlToRfc822 :: XML -> String xmlToRfc822 (Tag \n\"MSG\" [ Tag \"FROM\" [PCDATA from], Tag \"RCPTS\" [ (Tag \"TO\" [PCDATA tos])+ ], Tag \"SUBJECT\" [PCDATA subject], \nTag \"BODY\" [ (Tag \"P\" [PCDATA paras])* ] ]) = concat [\"From: \", from, crlf, \"To: \", concat (intersperse \n\", \" tos), crlf, \"Subject: \", subject, crlf, crlf, concat (intersperse crlf paras), crlf] where crlf \n= \"\\r\\n\"  3 Syntax The previous section has gone over all of regular expression pat\u00adterns by example. \nThis section starts the formal treatment by giving a grammar for the syntax, which can be seen in .gure \n1. We re\u00adfer to the nonterminal for Haskell s ordinary patterns as pattern and extend it with a new production \nfor regular expression patterns. The concrete syntax is quite close to that of e.g. Perl [Perl] or CDuce \n[BCF03] with the notable exception that we have non\u00adgreedy patterns as default. An extra exclamation \nmark indicates greediness. pattern . ... | [ regpat1 ...regpatn ] regpat . pattern | regpat * [ ! ] | \nregpat + [ ! ] | regpat ? [ ! ] | regpat | regpat | (/ regpat1 ...regpatn /) | ( regpat ) | var @ regpat \n| var @: regpat Figure 1. Regular expression pattern syntax Ordinary Haskell patterns are regular expressions \npatterns. The op\u00aderators are repetition (*), non-empty repetition (+) and option (?). Furthermore there \nare choice patterns indicated by a vertical bar and subsequences are enclosed in subsequence brackets. \nRegular expression patterns can be enclosed in parenthesis. The last two productions are for linear and \nnon-linear variable bindings. Pre\u00adcendence of the operators is as follows: *, +, ?, *!, +! and ?! binds \nstrongest. They are followed by choice patterns which are also right associative. Lastly we have @ and \n@: which bind weak\u00adest. All constructs in regular expression patterns bind stronger than constructor \napplication.  4 Semantics In this section we turn to the formal semantics for regular expres\u00adsion patterns. \nOur semantics divides natually into two parts; one for linear and one for non-linear patterns. The reason \nfor this division is that variable bindings are treated differently. 4.1 Structure of semantics We give \nthe semantics as an all-match semantics. This leads to pos\u00adsibly ambiguous matches, the same list can \nbe matched in many dif\u00adferent ways. Since this may affect how variables are bound to their values we \nneed to disambiguate our rules. We follow the approach taken by Hosoya and Pierce [HP03] and introduce \nan ordering on the rules indicating which rule will have precedence when several rules can match. The \norder is given by numbers in the name of the rules, where lower numbers have higher precedence. Intuitively \nthis means that when building the derivation tree for a match, one must always try to use the rule with \nthe highest precedence .rst, and choose the other rule only if choosing the .rst rule cannot lead to \na match. Before we begin with the semantics we will de.ne some concepts which will be used in our explanation \nof the semantics. We will use sets of variable bindings to map variables to values. A variable binding \nis denoted x In repetition patterns we will need to .v. merge sets of variable bindings with overlapping \ndomains. We use to this end and de.ne it as follows: {x1 .v1,...,xn.vn}{x1.vs1,...,xn.vsn}= {x1 + vsn} \n.v1 + vs1,...,xn.vn When giving a semantics for subsequence patterns we will use a type indexed function \n.atten to merge lists of values. It is de.ned as follows: flattenT (v)=[v] flatten[t]([])=[] flatten[t](v,vs)= \nflattent(v)++flatten[t](vs) flattenMaybet(Nothing)=[] flattenMaybet(Just v)= flattent(v) flattenEither \nt1t2 (Le ft v)= flattent1 (v) flattenEither t1t2 (Right v)= flattent2 (v) We will refer to the set of \nbound variables in a pattern p as  4.2 Semantics for linear patterns The semantics for linear regular \nexpression patterns can be found in .gure 2. Due to space reasons we only give a few of the rules as \nwe explain below. The judgement for matching linear patterns is denoted l .lp . v;\u00df;l'. It should read \nas l is matched by a pattern p yielding a value v, a set of variable bindings \u00df, and a remainder list \nl' . l and l' range over Haskell lists, where l is the list we wish to match and l' is a (possibly empty) \nsuf.x of l that wasn t matched. First of all we have a rule HM-REGPAT that extends Haskell s pat\u00adtern \nmatching semantics, denoted .h, with regular expression pat\u00adterns. It does so by performing a linear \nmatch. l .l (/p1 ...pn/).l;\u00df;[] l .h [p1 ...pn].\u00df Here we require that the remainder list is empty i.e. \nthat the whole input list is succesfully matched. This requirement together with the ordering on the \nrules determines which derivation must be chosen. The base rule, LM-BASE, is that where the pattern to \nmatch is a normal Haskell pattern. In this case we piggy-back on Haskell s normal mechanism for binding \nvariables from patterns. e .h p .\u00df e : l .l p .e;\u00df;l Apart from ordinary Haskell patterns there are two \nways that we can bind variables to values at toplevel, given by the rules LM-AS and LM-ACCAS. The @ operator \nsimply binds the variable to a value, whereas the @: operator binds the variable to a list containing \nthe value. The behavior of @: clearly makes more sense in a non-linear context, where the number of bound \nvalues may vary, but since it is harmless to do so we have chosen to allow it to appear in linear contexts \nas well. For subsequences we simply match each pattern in the sequence in order, as stated by the rule \nLM-SEQ. The values produced after matching are concatenated and the resulting disjoint sets of variable \nbindings are merged. The value yielded by matching a subsequence should always be a list of elements, \nso before we can concatenate the values of the sub-matches we need to .atten these values to simple lists. \nHere we need to use the typing relation on patterns de.ned in section 5. The typing relation is de.ned \nrelative to some base type T that during the actual matching will be instantiated to the type of the \nelements in the matching list. Matching a non-linear pattern in a linear context is identical to matching \nit in a non-linear context. This is exempli.ed by the rule LM-SEQ .i = flattent(vi),pi : t LM-STAR LM-BASE \ne .h p .\u00df e : l .l p .e;\u00df;l LM-AS l1 .l p .v1;\u00df1;l2 l1 .l x@p .v1;{x .v1}.\u00df1;l2 LM-ACCAS l1 .l p .v1;\u00df1;l2 \nl1 .l x@: p .v1;{x .[v1]}.\u00df1;l2 l1 .l p1 .v1;\u00df1;l2 ... ln .l pn .vn;\u00dfn;lf l1 . p * .v,\u00df,l2 l1 .l (/p1 \n...pn/) ..1 + ...+ .n;\u00df1 .\u00b7\u00b7\u00b7.\u00dfn;lf l1 .lp *.v;\u00df,l2 l .l (/p1 ...pn/) .l;\u00df;[] HM-REGPAT l .h [p1 ...pn] \n.\u00df Figure 2. Semantics for linear regular expression patterns LM-STAR. The rules for the rest of the \noperators are similar and are left out due to space restrictions.  4.3 Semantics for non-linear patterns \nThe relation for matching in a non-linear context, denoted l . p . v;\u00df;l ' (the only difference in syntax \nis that we drop the subscript on .), is similar to the relation for linear contexts. It differs in two \ncrucial aspects, namely variable bindings and that we handle non\u00adlinear patterns. The rules can be found \nin .gure 3. Thebaserule M-BASEisonceagainthatwherethepatterntomatch is an ordinary Haskell pattern. Since \nthe matching now takes place in a non-linear context, the values of variables being bound while matching \nthis pattern are put into lists instead of just being bound outright. Binding variables explicitly in \na non-linear context can only be done using the @: (accumulating as) operator that binds its variable \nargument to a list of the value matching its pattern argu\u00adment, as shown in the rule M-ACCUMAS. The rule \nfor matching a subsequence, M-SEQ, is identical to LM-SEQ except that subpatterns in the sequence are \nalso matched in a non-linear context. The rules for a repetition pattern, M-STAR1 and M-STAR2, give a \nnon-greedy semantics to the operator by giving the rule for not matching higher precedence than the rule \nfor actually matching the subpattern. The .rst rule simply doesn t try to match anything, whereas the \nsecond rule matches the given subpattern p once and then recurses to obtain more matches. The value obtained \nfrom matching p is then prepended to the result values of the recursive second premise. Similarly the \nvalues of bound values are prepended to the bindings from the recursive call. To get a greedy semantics \nin the rules M-GSTAR1 and M-GSTAR2 we simply swap the order of the rules to give precedence to preforming \na match. The non-empty repetition pattern operator p+ is de.ned as p+ = pp *, similarly its greedy counterpart \np+! = pp *!, and the rules M-PLUS and M-GPLUS can easily be derived from these facts. The rules M-OPT1 \nand M-OPT2 for optional patterns are very sim\u00adilar to the rules for repeating patterns, only that no \nrecursion to obtain more matches is done. The values returned by an optional pattern are of the Haskell \nMaybe type for optional values. For choice regular expression patterns we return values of the Haskell \nEither type to indicate which choice was taken. In the rules M-CHOICE1and M-CHOICE2wegiveprecedenceformatch\u00ading \nthe left pattern. Furthermore all variables occuring only in the branch not taken are assigned empty \nlists.  5 Well-formed regular expression patterns We now turn our attention to the static semantics \nof regular ex\u00adpression patterns. We will refer to the static semantics as well\u00adformedness of regular \nexpression patterns. There are two reasons why we need a static semantics. The .rst reason concerns where \nand how a variable is bound in a pattern. In ordinary patterns a variable may appear only once, with \nthe notable exception for or-patterns found in Ocaml and SML/NJ. In these lan\u00adguages all alternatives \nmust bind exactly the same set of variables. We have similar yet more liberal restrictions on variable \nbindings. Bound variables must not necessarily be bound in all alternatives in a choice pattern. The \nsecond reason is that we need to ensure that the types of the bound variables are correct. The same variable \nshould in particular have the same type for all its occurrences in a choice pattern. To express the well-formedness \nof a regular expression pattern we use the judgment . .lp which says that a (linear) regular expres\u00adsion \npattern p is well-formed in the typing context .. The typing context . gives types to the variables bound \nin the pattern. When checking the validity of patterns in a non-linear context we use the judgment . \n. p which is similar to the judgment for linear patterns. We will also refer to the well-formedness of \npatterns in Haskell, using the judgment . .hp. We refer to Fax\u00b4en s paper for a static semantics of Haskell \npatterns [Fax02]. We require that . .hp can only be derived if p binds exactly the variables in the typing \ncon\u00adtext .. Finally we will need a notion of types for regular expression patterns. We use the judgment \np :: t to say that the pattern p has the type t. Checking the well-formedness of a regular expression \npattern as an ordinary pattern in the host language is done using the following rule. Is is noteworthy \nthat we split the typing context. All the typing contexts .i must bind different names. We use this to \nenforce that a variable may only be bound once. .1 .lp1 ... .n .l pn .i n. j = 0/ .ij.i .j = .1 ....n \n.h [p1 ...pn] The rules for establishing well-formedness of linear patterns can be found in .gure 4. \nIn this section we only present the rules for non\u00adgreedy operators as the rules for greedy counterparts \nare exactly the same. The only interesting thing to note about the rules for *, + and ? is the fact that \nwhen checking their subpatterns we are in a non\u00adlinear context and therefore use the corresponding judgment \nfor the premises. The rule for sequences is reminiscent of that for regular expression patterns in the \ncontext of ordinary patterns explained above. e .h p.\u00df l1 . p .v1;\u00df1;l2 M-BASE s= {x .[v]|x .v .\u00df} M-ACCAS \ne : l .p.e;s;ll1 .x@:p .v1;{x .[v1]}.\u00df1;l2 l1 . p1 .v1;\u00df1;l2 ... ln . pn .vn;\u00dfn;lf M-SEQ .i = flattent(vi),vi \n:: t l1 .(/p1 ...pn/) ..1 + ...+ .n;\u00df1 .\u00b7\u00b7\u00b7.\u00dfn;lf l1 . p .v1;\u00df1;l2 l2 . p *.v2;\u00df2;l3 M-STAR1 \u00df= {x .[]|x \n.vars(p)} M-STAR2 l . p *.[];\u00df;ll1 . p *.v1: v2;\u00df1 \u00df2;l3 l1 . p .v1;\u00df1;l2 l2 . p *! .v2;\u00df2;l3 M-GSTAR1 \nM-GSTAR2 \u00df= {x .[]|x .vars(p)} l1 . p *! .v1: v2;\u00df1 \u00df2;l3 l . p *! .[];\u00df;l l1 . p .v1,\u00df1,l2 l2 . p *.v2,\u00df2,l3 \nl1 . p .v1,\u00df1,l2 l2 . p *! .v2;\u00df2;l3 M-PLUS M-GPLUS l1 . p+ .v1: v2,\u00df1 \u00df2,l3 l1 . p+! .v1: v2,\u00df1 \u00df2,l3 \nl1 . p .v1,\u00df1,l2 M-OPT1 \u00df= {x .[]|x .vars(p)} M-OPT2 l . p? .Nothing,\u00df,ll1 . p? .(Just v1),\u00df1,l2 l1 . \np .v1,\u00df1,l2 M-GOPT1 M-GOPT2 \u00df= {x .[]|x .vars(p)} l1 . p?! .(Just v1),\u00df1,l2 l . p?! .Nothing,\u00df,l l1 . \np1 .v1;\u00df;l2 M-CHOICE1 s= \u00df.{x .[]|x .vars(p2)}\\vars(p1)) l1 .(p1|p2) .(Le ft v1);s;l2 l1 . p2 .v1;\u00df1;l2 \n M-CHOICE2 \u00df= \u00df1 .{x .[]|x .vars(p1)}\\vars(p2)) l1 .(p1|p2) .(Right v1);\u00df;l2 Figure 3. Semantics for \nnon-linear regular expression patterns .. p .. p .1 . p .2 .q .. p .= .1 ..2 ..lp * ..lp+ ..lp|q ..lp? \n.1 . p1 ... .n . pn .i n.j 0.ij.i .j = /= .1 ....n .l (/p1 ...pn/) p :: t..lp p :: t..lp ..h hpat .,x \n:: t.lx@p .,x :: [t] .lx@:p ..l hpat Figure 4. Wellformed linear regular expression patterns The variable \nbinding rules are interesting to contrast against each others. As -patterns are well-formed if the variable \nis bound to a pattern with the same type as the variable. Accumulating as \u00adpatterns on the other hand \nmay match several times so the type of the variable must be a list. In .gure 5 we present the rules for \nestablishing the well-formedness of non-linear patterns. Most of the rules carry over straightfor\u00adwardly \nfrom those for linear patterns. It should be noted though that the rule for ordinary patterns rebuilds \nthe typing context so that all variables have list types. Figure 6 gives the typing rules for regular \nexpression patterns. The intuition behind these rules is that a pattern has a type which re\u00ad.ects the \nways it can match. For example a pattern which can match many times has a list type, hence variables \nbound to * and + pat\u00adterns get list types. Choice patterns can match one of two things .. p .. p .1 . \np .2 .q .= .1 ..2 .. p* .. p+ .. p|q .. p .1 . p1 ... .n . pn .i n.j 0.ij.i .j = /= .. p? .1 ....n .(/p1 \n...pn/) p :: t.. p .'.h hpat .= {x :: [t]|x :: t..'} .,x :: [t] .x@:p ..hpat Figure 5. Wellformed regular \nexpression patterns p :: t p :: t p :: tq :: t' p :: t p * :: [t] p+ :: [t] p|q :: Either tt' p?:: Maybe \nt p1 :: t1 ... pn :: tn p :: t p :: t (/p1 ...pn/) :: [T ] x@p :: t x@:p :: t hpat :: T Figure 6. Typing \nrules for regular expression patterns which is captured by the Either type of Haskell. A sequence pat\u00adtern \nmatches yields a sequence and hence it also has a list type. Variable binding patterns don t affect the \ntyping. The last typing rule for ordinary patterns in the underlying language is more sur\u00adprising, since \nit refers to a speci.c type T. This means that the typ\u00ading rules should be interpreted in a context where \nwe are matching on a list of type [T], i.e. T is the type of the elements of the list.  6 Implementation \nWe currently have an implementation of our regular expression pat\u00adtern system that works as a preprocessor \nfor GHC. It takes a source code .le possibly containing regular expression patterns and trans\u00adlates it \ninto semantically equivalent vanilla Haskell code. It also comes with a matching engine, which we implement \nas a simple parser monad. The preprocessor does not check any types, instead we rely on GHC s type checker \nto catch type errors. 6.1 Matching engine The datatype for a matching parser, which we from now on will \nrefer to as a matcher, looks like data Matcher e a = Matcher ([e] -> [(a,[e])]) It is essentially a \nfunction that takes an input list, conducts a match, and returns a list of results. Each result will \nconsist of a value, a set of values for bound variables, and a remainder list. All of this is read directly \nfrom our semantic rules. Since different variables will be bound to values of different types, we need \nto model the set of bindings as a tuple, with each entry corresponding to the value(s) for one speci.c \nvariable. As is cus\u00adtomary, we let the remainder list be the state of the matcher monad, so that it is \nimplicitly threaded through a series of matches. The individual matcher functions then need to return \na value for future bindings, and a tuple with values for variables. To account for our all-match semantics \nthe parser generates a list of results at each step. At places where we need to branch we can use the \n+++ operator which lets us proceed with two different matchers. We de.ne +++ as (+++) :: Matcher e a \n-> Matcher e a -> Matcher e a (Matcher f) +++ (Matcher g) = Matcher (\\es -> let aes1 = f es aes2 = g \nes in aes1 ++ aes2) As we can see from the de.nition +++ is left-biased, i.e. any results from its left \noperand will end up before any results from its right operand in the list of results. This allows us \nto de.ne a function that conducts the full matching by, as de.ned by our .rst-match policy, selecting \nthe .rst result in this list of results for which the matcher has reached the end of the input list (i.e. \nthe remainder list is empty). This function, called runMatch, corresponds to the rule HM-REGPAT from \n.gure 2, and is de.ned as runMatch :: Match e a -> [e] -> Maybe a runMatch (Matcher f) es = let allps \n= f es allMatches = filter (null . snd) allps in case allMatches of [] -> Nothing (((_, vars),_):_) \n-> Just vars  6.2 Translation The basic idea behind translating a regular expression pattern into vanilla \nHaskell is to generate a matcher for each subpattern, all the way down to ordinary Haskell patterns, \nand then combine these to form a top-level matcher corresponding to the whole of the pattern. 6.2.1 Base \npatterns The base case is when the pattern in question is an ordinary Haskell pattern. First we must \ngenerate a function that actually takes an element from the input list and tries to match it to the given \npattern. For example, if the pattern in question is Tel nr, the corresponding function would look like \nmatch0 :: CMode -> Maybe TelNr match0 e = case e of Tel nr -> Just (nr) _ -> Nothing No type signatures \nare actually generated, we just supply them here to simplify understanding. To avoid overly long signatures \nwe ab\u00adbreviate ContactMode with CMode in our examples. What the function returns if the match succeeds \nis a tuple contain\u00ading the values of bound variables. The function above works in linear context since \nwe return the bound variable as is. If we in\u00adstead wanted a function to work in non-linear context, we \nwould wrap the values in lists, like match0 :: CMode -> Maybe [TelNr] match0 e = case e of Tel nr -> \nJust ([nr]) _ -> Nothing We also need to lift a generated matching function into the matcher monad. \nThis lifting works identically regardless of what the pat\u00adtern is, so we have a function in the matcher \nengine that does this, de.ned as baseMatch :: (e -> Maybe a) -> Matcher e (e,a) baseMatch matcher = \ndo e <-getElement case matcher e of Nothing -> mfail Just b -> do discard return (e, b) The functions \nused by baseMatch are inherent to our matcher monad. getElement retreives the head of the input list, \ndiscard drops the head of the input list, and mfail is a matcher that always returns an empty list of \nresults. We now need to generate a matcher by applying baseMatch to our generated function, i.e. match1 \n:: Matcher CMode (CMode, TelNr) match1 = baseMatch match0 The type states that match1 is a matcher \nfor a list of CModes. The value matched is a CMode, and the only variable bound is of type TelNr. The \nnumbers 0 and 1 in the names of these functions signify that each name is fresh, i.e. these numbers could \nbe any positive integers, but no two functions share the same integer. For Haskell patterns that are \nguaranteed to always match, i.e. pat\u00adtern variables and wildcards ( ), we can simplify these steps. For \na wildcard, what we need to generate is the matcher match0 :: Matcher e (e, ()) match0 = baseMatch (\\_ \n-> Just ()) meaning we will always match, and no variables are bound. The only difference for a pattern \nvariable is that the variable in question is also bound, e.g. for the pattern a we get match0 :: Matcher \ne (e, e) match0 = baseMatch (\\a -> Just (a)) Once again the shown function works in linear context, \nin non\u00adlinear context we would wrap the returned a in a list. 6.2.2 Repetition All regular expression \npatterns have one or more subpatterns, and the .rst step when translating a regular expression pattern \nwill be to translate these subpatterns. For a repetition pattern, p*, we would .rst translate the subpattern \np into some matcher function matchX. According to the rules M-STAR1 and M-STAR2, a matcher for a repetition \npattern should if possible continue without trying to match anything, otherwise it should match one element \nand then re\u00adcursively match the repetition pattern again. This behavior is com\u00admon to all repetition \npatterns so we de.ne it as a function in the matching engine: manyMatch :: Match e a -> Match e [a] \nmanyMatch matcher = (return []) +++ (do a <-matcher as <-manyMatch matcher return (a:as)) The problem \nwith this de.nition is that manyMatch returns a list in which each element is the result of one step \nof the recursion. We need to unpack this list so that we instead return a tuple, in which each entry \nis a list of results for a speci.c variable binding. We cannot do this generically since the number of \nbound variables, and thus the size of the tuple, will vary. Therefore we must supply an appropriate unzipping \nfunction that works for the correct number of variables. The exact function to use can be determined \nby the preprocessor, that has the necessary meta-information on what vari\u00adables are bound. Note that \nall variables inside the repetition will be non-linear, so the result of matching a variable in each \nstep of the recursion will be a list of values. If we only unzip to get a list of such results for each \nvariable, what we would really get is a list of lists of values. Thus to get a list of values we should \nalso let the unzipping function concatenate the results for each variable in the resulting tuple. Inside \nmanyMatchthe unpacking will be done in two steps. The .rst is to simply unzip the list into two lists, \none containing all values (vi from the rules), the other containing all values of bound variables. In \nthe second step we need to apply the supplied unzipping-and\u00adconcatenating function to the latter list \nto get the variable values proper. This new improved manyMatch will thus look like manyMatch :: Matcher \ne (a,b) -> ([b] -> c) -> Matcher e ([a], c) manyMatch matcher unzipper = do res <-mMatch matcher \nlet (vals, vars) = unzip res vs = unzipper vars return (vals, vs) where mMatch is our old de.nition \nof manyMatch. As an example, we show the translation of the pattern (Tel nr)*. The .rst step is to translate \nthe subpattern Tel a, which we have already seen how to do. The new function that we generate will then \nlook like match2 :: Matcher CMode ([CMode],[TelNr]) match2 = manyMatch match1 unzip1 assuming the matcher \nfor the subpattern is called match1. The function unzip1 here is simply the concat function, since there \nis only one variable bound. To account for the greedy version of a repetition pattern, *!, we simply \n.ip the arguments to +++ in manyMatch, which will give a higher priority to the case when we actually \nmatch an element. Non-empty repetition patterns, +, are very similar to ordinary rep\u00adetition patterns, \nthe only difference is of course that we make an initial match before starting the recursion, as shown \nin neManyMatch :: Matcher e (a,b) -> ([b] -> c) -> Matcher e ([a], c) neManyMatch matcher unzipper \n= do res1 <-matcher res <-mMatch matcher let (vals, vars) = unzip (res1:res) vs = unzipper vars \nreturn (vals, vs)  6.2.3 Choice and Optional patterns Choice patterns are slightly trickier to handle \nbecause of the way variables are bound. As we saw in the rules M-CHOICE1 and M-CHOICE2, any variables \nappearing in the other branch than the one being matched should be bound to empty lists. This is very \ndif.cult to handle generically since we need access to the meta-information of variable names. Thus we \ninstead generate the full code for the choice pattern during translation. As an example we translate \nthe pattern (Tel nr | Email eaddr). We start by translating the subpatterns, resulting in two functions \nthat we assume are named match1 and match2. The code generated for the choice pattern will be match3 \n:: Matcher CMode (Either CMode CMode, ([TelNr],[EAddr])) match3 = (do (val, (a)) <-match1 return (Left \nval, (a, []))) +++ (do (val, (b)) <-match2 return (Right val, ([], b))) where we have tagged the \nresult value of the pattern match with the respective constructors from the Either type. The story is \nvery similar for optional patterns, but this time all vari\u00adables should be bound to empty lists if no \nmatch is done. For the pattern (Tel nr)? we get match4 :: Matcher CMode (Maybe CMode, [TelNr]) match4 \n= (return (Nothing, [])) +++ (do (val, (a)) <-match1 return (Just val, a)) For a greedy optional pattern \nwe would simply switch the argu\u00adments to +++, just as for repetition patterns. 6.2.4 Subsequences The \ntrickiest pattern to implement is subsequence, due to the need for .attening. As we saw in section 5, \n.attening is done based on the type of a subpattern (with respect to some base type for ele\u00adments in \nthe input list), which means that the preprocessor must keep track of these types in order to insert \nthe proper .attening func\u00adtions. For a pattern (/ (Tel nr)?, (Email eaddr)* /) we get the following translation, \nassuming the two subpatterns are trans\u00adlated into matcher functions match1 and match2 respectively: match5 \n:: Matcher CMode ([CMode], ([TelNr],[EAddr])) match5 = do (v1, (a)) <-match1 (v2, (b)) <-match2 let \nv1f = maybe [] (\\v -> [v]) v1 v2f = concatMap (\\v -> [v]) v2 return (v1f ++ v2f, (a,b)) The value \nv1 is the result of match1, i.e. the matcher for (Tel nr)?, so it will have type Maybe CMode. To .atten \nit we use the built-in Haskell function maybe that takes two arguments, one that is a default value to \nreturn if it encounters a Nothing (in this case []), the other a function to apply to a value held by \na Just (in this case the .attening function for a value of the base type). Similarly v2 comes from match2, \nso its type will be [CMode]. We .atten it using the built-in function concatMap that takes a function, \napplies is to all elements of a list, and then concatenates the results. 6.2.5 Variable bindings Finally \nwe turn to the explicit binding operators. Binding a variable to a value in our matcher means to add \nthat value to the result tu\u00adple. Since an explicitly bound variable syntactically appears to the left \nof any variables in its subpattern, we add the value in the left\u00admost position in the tuple, i.e. before \nthose bound in the subpattern. Thus we know that the values in the result of the top-level matcher should \nbe bound to variables from left to right in the order they appear in the pattern. As an example consider \nthe pattern a@(Tel nr | Email eaddr). We .rst translate the subpattern (Tel nr | Email eaddr) into a \nmatcher match1. The matcher generated for the variable binding will then be match2 :: Matcher CMode (Either \nCMode CMode, (Either CMode CMode,[TelNr],[Eaddr])) match2 = do (val, (nr, eaddr)) <-match1 return (val, \n(val, nr, eaddr)) If we had instead used non-linear binding, i.e. a@:(Tel nr | Email eaddr), we would \nget a list for the returned value, i.e. match2 :: Matcher CMode (Either CMode CMode, ([Either CMode CMode],[TelNr],[Eaddr])) \nmatch2 = do (val, (nr, eaddr)) <-match1 return (val, ([val], nr, eaddr))  6.3 Matching Now we know \nhow to translate a regular expression pattern into a top-level matcher function, what is left is to insert \nand invoke the generated matcher at the right place to preserve the pattern match\u00ading semantics. To this \nend we use Haskell pattern guards [EPJ00] that allow us to evaluate a function and pattern match on the \nresult as part of the original pattern match. The function that we so wish to evaluate is runMatch applied \nto our generated top-level matcher and the input list that we wish to match. For our matcher functions \nto be in scope we add them to the where clause of the declaration that the regular expression pattern \nappears in. To show a complete example of the translation of a function declaration we revisit our function \nallTels de.ned as allTels (Person _ [(Tel nr | _)*]) = nr since it contains several different features \nof regular expression pat\u00adterns. The translated version of this function will look like allTels (Person \n_ arg0) | Just (nr) <-runMatch match5 arg0 = nr where match0 e = case e of Tel nr -> Just ([nr]) \n_ -> Nothing match1 = baseMatch match0 match2 = baseMatch (\\_ -> Just ()) match3 = (do (val, (nr)) \n<-match1 return (Left val, (nr))) +++ (do (val, ()) <-match2 return (Right val, ([]))) match4 = \nmanyMatch match3 unzip1 match5 = do (v1, (nr)) <-match4 let v1f = concatMap (either (\\v -> [v]) (\\v \n-> [v])) v1 return (v1f, (nr)) The functions match0 and match1 together correspond to the pat\u00adtern \n(Tel nr). Note the list around the returned variable nr sig\u00adnaling that the pattern is matched in a non-linear \ncontext. match2 corresponds to the pattern . Combining these two into a choice patterns yields (Telnr| \n), which is translated to match3.On top of that we add a repetition, which gives us match4 when trans\u00adlated. \nFinally since the top-level pattern should be matched as a subsequence, as seen in the rule HM-REGPAT, \nwe translate it into match5. The actual matching is done in the pattern guard that ap\u00adplies runMatch \nto the matcher and the input list. The latter is held by an automatically generated fresh variable, in \nthis case arg0.It is also interesting to note that the actual binding of variables to values does not \nhappen until runMatch is evaluated. Any mention of vari\u00adable names in the matcher functions, e.g. nr \nin match0, are only there as mnemonic aids to a human reader. We could change all such names to freshly \ngenerated variable names without changing any semantics. In Haskell, patterns can appear in numerous \nplaces such as func\u00adtion declarations, case expressions, let expressions, statements etc. Translating \nregular expression patterns into vanilla Haskell is slightly different depending on just where the pattern \nappears. The generated matchers will be identical in all cases, but the placement of them and of the \nevaluation may differ. We will not go through these differences in detail, but our implementation handles \nall cases correctly. Irrefutable (lazy) patterns also require special care, and we have yet to implement \nsupport for them in full.  7 Related Work Pattern matching is a well-known and much studied feature \nof func\u00adtional languages [Aug85, Wad87, Mar92, Mar94]. It provides the startingpoint for the work presented \nin this paper. Regular expressions have been used in programming for a long time, mostly for text matching \npurposes. Perl s support for regu\u00adlar expressions is probably one of the most well-known [Perl], but \nmost mainstream languages, including Haskell, have some library support for regular expression text matching. \nRegular expressions in such libraries are themselves encoded as strings. Matching them means taking two \nstrings, where one encodes a regular expression, and match them to each other. This is in some sense \nvery low\u00adlevel when compared to our regular expression patterns since there are no guarantees that regular \nexpressions encoded as strings are well-formed, and there is no direct way to bind variables to values \nduring a match. Yet another drawback is of course that such regular expressions work on strings only, \nwhereas our regular expression patterns work over lists of any datatype.  The recent trend in XML-centric \nlanguages has led to several new languages with support for regular expression pattern matching such \nas XMLambda [MS99], XDuce [HP03] and CDuce [BCF03]. Most similar to ours is probably CDuce, a general \npurpose XML\u00adcentric programming language. The main focus in this language is its regular expression types \nwhich are used to validate XML doc\u00aduments. Borrowing from XDuce they also have regular expression patterns \nwhich are tightly coupled with the type system. This al\u00adlows for very precise type information to be \npropagated in the right hand side of a pattern. The main difference with our work is the close connection \nwith the type system. Our extension is little more than just syntactic sugar which makes it very easy \nto implement. Another recently developed language that features regular expres\u00adsion patterns is Scala \n[Scala]. Scala is a multi paradigm language supporting both object oriented and functional programming. \nIts regular expression facility is rather similar to ours but differs at the following points. Firstly, \nthere is only one variable binding con\u00adstruct which has a context dependent behaviour. Secondly, Scala \nhas non-greedy operators just as we do but have no greedy coun\u00adterparts. This can make some patterns \nawkward to express. Scala s regular expression patterns work for arbitrary sequences. There has been \nsome work in extending Haskell with the full power of XDuce, called XHaskell [LS04]. This work focuses \non .tting the type system of XDuce into Haskell and encoding it using Haskell s class system. They also \nhave regular expression patterns but these are intimately coupled with regular expression types and do \nnot work together with ordinary pattern matching. 8 Future Work There are several areas where our regular \nexpression patterns ex\u00adtension can be improved. It is not obvious that our implementation using a monadic \nparser is the most ef.cient approach, on the con\u00adtrary. There has been lots of work on ef.cient matching \nof regular expressions and it is likely that some of these techniques could be used with our system to \nmake it more ef.cient. We will need to devise and implement a type checking algorithm for our regular \nexpression patterns on top of Haskell\u00b4s type check\u00ading mechanism. Being able to type check our regular \nexpression patterns before translating them into vanilla Haskell, as opposed to our current implementation \nthat .rst translates and then lets a Haskell type checker do the work, would, if nothing else, lead to \nmuch improved error messages. 9 Acknowledgement We would like to thank our shepherd Erik Meijer for his \nmany sug\u00adgestions which improved the paper enormously. Thanks also to Karol Ostrovsky and David Sands \nwho gave valueable feedback on draft versions of this paper. The participants of the Multi Meeting provided \ninsightful comments when we presented the material in this paper. Lastly thanks to the anonymous referees \nfor their com\u00adments. 10 References [Aug85] Lennart Augustsson. Compiling Pattern Matching. In Functional \nProgramming and Computer Architecture, 1985. [BCF03] V. Benzaken, G. Castagna, and A. Frisch. CDuce: \nAn XML-Centric General-Purpose Language. In Proceed\u00adings of the ACM International Conference on Functional \nProgramming, 2003. [EPJ00] Martin Erwig and Simon Peyton Jones. Pattern Guards and Transformational Patterns. \nIn Haskell Workshop, 2000. [Fax02] Karl-Filip Fax\u00b4en. A Static Semantics for Haskell. Jour\u00adnal of Functional \nProgramming, 12(4 5), 2002. [Fri04] A. Frisch. Regular Tree Language Recognition with Static Information. \nIn 3rd IFIP International Conference on Theoretical Computer Science, 2004. [HM03] Haruo Hosoya and Makoto \nMurata. Boolean Operations and Inclusion Test for Attribute-Element Constraints. In Eighth International \nConference on Implementation and Application of Automata, volume 2759 of Lecture Notes in Computer Science, \npages 201 212. Springer-Verlag, 2003. [HP03] Haruo Hosoya and Benjamin C. Pierce. XDuce: A Typed XML \nProcessing Language. ACM Transactions on Inter\u00ad net Technology, 2(3):117 148, 2003. [HVP00] Haruo Hosoya, \nJerome Vouillon, and Benjamin C. Pierce. Regular Expression Types for XML. In Proceed\u00adings of the ACM \nInternational Conference on Functional Programming, 2000. [Lev03] Michael Y. Levin. Compiling Regular \nPatterns. In Pro\u00adceedings of the ACM International Conference on Func\u00adtional Programming, pages 65 78, \n2003. [LS04] Kenny Zhuo Ming Lu and Martin Sulzmann. XHaskell: Regular Expression Types for Haskell. \nhttp://www.comp.nus.edu.sg/ sulzmann/, 2004. [Mar92] Luc Maranget. Compiling Lazy Pattern Matching. In \nProc. of the 1992 conference on Lisp and Functional Programming. ACM Press, 1992. [Mar94] Luc Maranget. \nTwo Techniques for Compiling Lazy Pat\u00adtern Matching. Research report 2385, INRIA, 1994. [MS99] Erik Meijer \nand Mark Shields. XM.: A Functional Lan\u00adguage for Constructing and Manipulating XML Docu\u00adments. (Draft), \n1999. [MvV01] Erik Meijer and Danny van Velzen. Haskell Server Pages. In Graham Hutton, editor, Electronic \nNotes in Theoretical Computer Science, volume 41. Elsevier, 2001. [Perl] www.perl.org. [Scala] Martin \nOdersky et.al. The Scala Programming Lan\u00adguage. http://scala.ep..ch/. [Wad87] Philip Wadler. The Implementation \nof Functional Pro\u00adgramming Languages, chapter Ef.cient Compilation of Pattern Matching. Prentice Hall, \n1987.   \n\t\t\t", "proc_id": "1016850", "abstract": "We extend Haskell with <i>regular expression patterns</i>. Regular expression patterns provide means for matching and extracting data which goes well beyond ordinary pattern matching as found in Haskell. It has proven useful for string manipulation and for processing structured data such as XML. Regular expression patterns can be used with arbitrary lists, and work seamlessly together with ordinary pattern matching in Haskell. Our extension is lightweight, it is little more than syntactic sugar. We present a semantics and a type system, and show how to implement it as a preprocessor to Haskell.", "authors": [{"name": "Niklas Broberg", "author_profile_id": "81100020443", "affiliation": "Chalmers University of Technology", "person_id": "P209179", "email_address": "", "orcid_id": ""}, {"name": "Andreas Farre", "author_profile_id": "81100186555", "affiliation": "Chalmers University of Technology", "person_id": "P693057", "email_address": "", "orcid_id": ""}, {"name": "Josef Svenningsson", "author_profile_id": "81100424031", "affiliation": "Chalmers University of Technology", "person_id": "P394766", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1016850.1016863", "year": "2004", "article_id": "1016863", "conference": "ICFP", "title": "Regular expression patterns", "url": "http://dl.acm.org/citation.cfm?id=1016863"}