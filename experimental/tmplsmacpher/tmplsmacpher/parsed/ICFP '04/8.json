{"article_publication_date": "09-19-2004", "fulltext": "\n Monadic Regions * Matthew Fluet Cornell University Department of Computer Science Ithaca, NY 14853 \n.uet@cs.cornell.edu Abstract Region-based type systems provide programmer control over mem\u00adory management \nwithout sacri.cing type-safety. However, the type systems for region-based languages, such as the ML-Kit \nor Cy\u00adclone, are relatively complicated, so proving their soundness is non\u00adtrivial. This paper shows \nthat the complication is in principle un\u00adnecessary. In particular, we show that plain old parametric \npolymor\u00adphism, as found in Haskell, is all that is needed. We substantiate this claim by giving a type-and \nmeaning-preserving translation from a region-based language based on core Cyclone to a monadic variant \nof System F with region primitives whose types and operations are inspired by (and generalize) the ST \nmonad. Categories and Subject Descriptors: D.3.1 [Programming Lan\u00adguages]: Formal De.nitions and Theory \n Semantics; D.3.3 [Pro\u00adgramming Languages]: Language Constructs and Features; F.3.2 [Logics and Meanings \nof Programs]: Semantics of Programming Languages. General Terms: Languages, Theory. Keywords: effect, \nmonad, parametric polymorphism, region, region-based memory management, type system.  Background Tofte \nand Talpin introduced a new technique for type-safe memory management based on regions [26, 27]. In their \ncalculus, regions are areas of memory holding heap allocated data. Regions are in\u00adtroduced and eliminated \nwith a lexically-scoped construct: letregion . in e and thus have last-in-.rst-out (LIFO) lifetimes following \nthe block structure of the program. In the example above, a region corre\u00ad * Supported in part by National \nScience Foundation Grants 0204193 and 9875536, AFOSR Grants F49620-03-1-0156 and F49620-01-1-0298, and \nONR Grant N00014\u00ad01-1-0968. The views and conclusions contained herein are those of the authors and should \nnot be interpreted as necessarily representing the of.cial policies or endorse\u00adments, either expressed \nor implied, of these organizations or the U.S. Government. Permission to make digital or hard copies \nof all or part of this work for personal or classroom use is granted without fee provided that copies \nare not made or distributed for pro.t or commercial advantage and that copies bear this notice and the \nfull citation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. ICFP 04, September 19 21, 2004, Snowbird, Utah, \nUSA. Copyright 2004 ACM 1-58113-905-5/04/0009 ...$5.00 Greg Morrisett Harvard University Division of \nEngineering and Applied Science Cambridge, MA 02138 greg@eecs.harvard.edu sponding to . is created upon \nentering the expression; for the du\u00adration of the expression, data can be allocated into the region; \nafter evaluating e to a value, all of the data allocated within the region are reclaimed and the value \nis returned. The operations for mem\u00adory management (create region, reclaim region, and allocate object \nin region) can be implemented in constant time and thus regions provide a compelling alternative to garbage \ncollection. The key contribution of Tofte and Talpin s framework (hereafter referred to as TT) was a \ntype-and-effects system that ensures the safety of this allocation and deallocation scheme. The types \nof al\u00adlocated data objects are augmented with the region in which they live. For example the type: ((int,.1) \n\u00d7 (int, .2),.1) describes pairs of integers where the pair and .rst component live in region .1 and the \nsecond component lives in region .2. Region polymorphism makes it possible to abstract over the regions \na computation manipulates. Furthermore, function types include an effect which records the set of regions \nthat must still be allocated in order to ensure that the computation is safe to run. In general, any \noperation that needs to dereference a pointer into a region will require that region to be live. For \nexample, a function fst that takes in a pair of integers and returns the .rst component without examining \nit could have a type of the form: {.3} fst :: ..1, .2,.3.((int,.1) \u00d7 (int,.2),.3) - -. (int, .1) Such \na function is polymorphic over regions .1, .2, and .3 so the caller can effectively re-use the function \nregardless of where the data were allocated. However, the effect {.3} on the arrow indi\u00adcates that whatever \nregion instantiates .3 needs to still be allocated when fst is called. In principle, neither of the other \nregions needs to be live across the call since the function does not examine the integer values. A unique \nfeature of this scheme is that evaluation can lead to values with dangling pointers: a pointer to data \nin some region that has been reclaimed. Consider for example the following program: letregion .a in let \ng = letregion .b in let p =(3 at .a,4 at .b) at .a in .z:unit.fst [.a,.b, .a] p in g () The pair p and \nits .rst component are allocated in the outer region .a whereas p s second component is allocated in \nan inner region .b. The closure bound to g is a thunk that calls fst on p. Note that the region .b is \ndeallocated before the thunk is run, and thus g s closure contains a dangling pointer to an object that \nis never dereferenced. The TT system is strong enough to show that the code is safe. Variations on the \nTT typing discipline have been used in a number of projects. The ML-Kit compiler [25] used automatic \nregion infer\u00adence to translate SML into a region-based language instead of re\u00adlying upon traditional \ngarbage collection. In contrast, the Cyclone Safe-C language [8] exposes regions and region allocation \nto the programmer. Furthermore, the type-and-effects system of Cyclone extends that of TT with a form \nof region subtyping pointers into older regions can be safely treated as pointers into younger regions. \nThis extra degree of polymorphism is crucial for minimizing the lifetimes of objects, as they would otherwise \nbe constrained to live in the same region. The type-and-effect systems of TT and Cyclone are relatively \ncom\u00adplicated. At the type level, they introduce new kinds for regions and effects. Effects are meant \nto be treated as sets of regions, so standard term equality no longer suf.ces for type checking. Fi\u00adnally, \nthe typing rule for letregion is extremely subtle because of the interplay of dangling pointers and effects. \nIndeed, over the past few years, a number of papers have been published at\u00adtempting to simplify or at \nleast clarify the soundness of the con\u00adstruct [5, 2, 10, 3, 4, 11]. All of these problems are ampli.ed \nin Cyclone because of region subtyping where the meta-theory is con\u00adsiderably more complicated [9]. \n1.1 Overview The goal of this work is to .nd a simpler account of region-based type systems. In particular, \nour goal is to explain the type soundness of a Cyclone-like language via translation to a language with \nonly parametric polymorphism, such as System F [20, 7]. Our work was inspired by the ST monad of Launchbury \nand Peyton Jones [15, 14] which is used to encapsulate a stateful computa\u00adtion within a pure functional \nlanguage such as Haskell. Indeed, the runST primitive turns out to be a good approximation of letregion \n. Unfortunately, runST is not suf.cient to encode region-based lan\u00adguages since there is no support for \nnested stores. In particular, a nested application of runST cannot allocate or touch data in an outer \nstore. An extension to ST that admits a limited form of nested stores was proposed by Launchbury and \nSabry [16] but, as we dis\u00adcuss in Section 2, it does not provide enough .exibility to encode the region \npolymorphism of TT or Cyclone. In this paper, we consider a monad family, called RGN, which does provide \nthe necessary power to encode region calculi and back this claim by giving a translation from a core-Cyclone \ncalculus to a monadic version of System F which we call FRGN . The central element of the translation \nis the presence of terms that witness re\u00adgion subtyping. These terms provide the evidence needed to safely \nshift computations from one store to another. We believe that this translation sheds new light on both \nregion calculi as well as Haskell s ST monad. In particular, it shows that the notion of re\u00adgion subtyping \nis in some sense central for supporting nested stores. The remainder of this paper is structured as follows. \nIn the follow\u00ading section, we examine more closely why the ST monad and its variants are insuf.cient \nfor encoding region-based languages. This motivates the design for FRGN, which is presented more formally \nin Section 3. In Section 4 we present a source language that captures the key aspects of TT and Cyclone-like \nregion calculi. Then, in Section 5 we show how this language can be translated to FRGN in a meaning-preserving \nfashion, thereby establishing our claim that parametric polymorphism is suf.cient for encoding the type-and\u00adeffects \nsystems of region calculi. In Section 6, we consider related work and in Section 7 we summarize and note \nsome directions for future work. Due to space limitations, the proofs of the theorems presented here \ncan be found in a companion technical report [6]. 2 From ST to RGN Launchbury and Peyton Jones [15, 14] \nintroduced the ST monad to encapsulate stateful computations within the pure functional lan\u00adguage Haskell. \nThree key insights give rise to a safe and ef.cient implementation of stateful computations. First, a \nstateful compu\u00adtation is represented as a store transformer, a description of com\u00admands to be applied \nto an initial store to yield a .nal store. Second, the store can not be duplicated, because the state \ntype is opaque and all primitive store transformers use the store in a single-threaded manner; hence, \na stateful computation can update the store in place. Third, parametric polymorphism can be used to safely \nencapsulate and run a stateful computation. The types and operations associated with the ST monad are \nthe following: t ::= ... | ST ts ta | STRef ts ta returnST :: .s..a.a . ST sa thenST :: .s..a..b.ST sa \n. (a . ST sb) . ST sb newSTRef :: .s..a.a . ST s (STRef sa) readSTRef :: .s..a.STRef sa . ST sa writeSTRef \n:: .s..a.STRef sa . a . ST s () runST :: .a.(.s.ST sa) . a The type ST sa is the type of computations \nwhich transform a store indexed by s and deliver a value of type a. The type STRef sa is the type of \nreferences allocated from a store indexed by s and containing a value of type a. The operations returnST \nand thenST are the unit and bind oper\u00adations of the ST monad. The former yields the trivial store trans\u00adformer \nthat delivers its argument without affecting the store. The latter composes store transformers in sequence, \npassing the result and .nal store of the .rst computation to the second; notice that the two computations \nmust manipulate stores indexed by the same type. The next three operations are primitive store transformers \nthat op\u00aderate on the store. newSTRef takes an initial value and yields a store transformer, which, when \napplied to a store, allocates a fresh reference, and delivers the reference and the store augmented with \nthe reference mapping to the initial value. Similarly, readSTRef and writeSTRef yield computations that \nquery and update the map\u00adpings of references to values in the current store. Note that all of these operations \nrequire the store index types of ST and STRef to be equal. As an example, here is a function (in Haskell \nsyntax, using the do notation, which implicitly invokes thenST) yielding a computation that pairs the \ncontents of two references into a new reference: pair :: .s..a..b.STRef sa . STRef sb . ST s (STRef s \n(a,b)) pair vw =doa <-readSTRef v b <-readSTRef w newSTRef (a,b) Finally, the operation runST encapsulates \na stateful computation. To do so, it takes a store transformer as its argument, applies it to an initial \nempty store, and returns the result while discarding the .nal store. Note that to apply runST, we instantiate \na with the type of the result to be returned, and then supply a store transformer, which is polymorphic \nin the store index type. The effect of this universal quanti.cation is that the store transformer makes \nno as\u00adsumptions about the initial store (e.g., the existence of pre-allocated references). Furthermore, \nthe instantiation of the type variable a oc\u00adcurs outside the scope of the type variable s; this prevents \nthe store transformer from delivering a value whose type mentions s. Thus, references or computations \ndepending on the .nal store cannot es\u00adcape beyond the encapsulation of runST. All of these observations \ncan be carried over to the region case, where we interpret stores as regions. We introduce the type RGN \nra as the type of computations which transform a region indexed by r and deliver a value of type a. Likewise, \nthe type RGNVar ra is the type of (immutable) variables allocated in a region indexed by r and containing \na value of type a. Each of the operations in the ST monad has an analogue in the RGN monad: returnRGN \n:: .r..a.a . RGN ra thenRGN :: .r..a..b.RGN ra . (a . RGN rb) . RGN rb newRGNVar :: .r..a.a . RGN r (RGNVar \nra) readRGNVar :: .r..a.RGNVar ra . RGN ra runRGN :: .a.(.r.RGN ra) . a Does this suf.ce to encode region-based \nlanguages, where runRGN corresponds to letregion? In short, it does not. In a region-based language, \nit is critical to allocate variables in and read variables from an outer region while in the scope of \nan inner region. For example, an essential idiom in region-based languages is to enter a letregion in \nwhich temporary data is allocated, while reading input and allocating output data from an outer region; \nupon leaving the letregion, the temporary data is reclaimed, but the input and output data are still \navailable. Unfortunately, this idiom cannot be accommodated in the frame\u00adwork presented thus far. For \nexample, the following term, where we think of the STRefs bound to a as an input, b as a temporary, and \nc as an output, does not type check: runST (do a <-newSTRef 1 c <-runST (do v <-readSTRef a b <-newSTRef \n2 newSTRef v) readSTRef c) The error arises from the fact that the inner and the outer runST each require \ntheir argument to generalize over the store index type; this forces a to have the type STRef s1 Int and \nreadSTRef a to have the type ST s2 Int, but this is incompatible with the type of readSTRef, which requires \nthe store index types to be equal. A similar problem arises with newSTRef v and readSTRef c. Launchbury \nand Sabry [16] argue that the principle behind runST can be generalized to provide nested scope. They \nintroduce two additional operations blockST :: .s..a.(.r.ST (s,r) a) . ST sa importSTRef :: .s..r..a.STRef \nsa . STRef (s,r) a where blockST encapsulates a nested scope and importSTRef ex\u00adplicitly allows references \nfrom an enclosing scope to be manipu\u00adlated by the inner scope. Similarly, Peyton Jones1 suggests intro\u00adducing \nthe constant liftST :: .s..r..a.ST sa . ST (s,r) a 1private communication in lieu of importSTRef, with \nthe same intention of importing com\u00adputations from an outer scope into the inner scope. In essence, liftST \nencodes the stack of stores using a tuple type for the index on the ST monad. We can rewrite our example \nusing blockST and liftST: runST (do a <-newSTRef 1 c <-blockST (do v <-liftST (readSTRef a) b <-newSTRef \n2 liftST (newSTRef v)) readSTRef c) (Note that blockST and importSTRef are not suf.cient; we would also \nneed an exportSTRef operation.) Should we adopt blockST and liftST in the RGN monad as letRGN and liftRGN? \nAt .rst glance, doing so would appear to provide suf\u00ad.cient expressiveness to encode region-based languages. \nHowever, another critical aspect of region-based languages is region polymor\u00adphism. For example, consider \na generalization of the pair function above, where each of the two input variables are allocated in differ\u00adent \nregions, the output variable is to be allocated in a third region, and the result computation is to be \nindexed by a fourth region; such a function would have the type: gpair :: .r1..a..r2..b..r3..r4. RGNVar \nr1 a . RGNVar r2 b . RGN r4 (RGNVar r3 (a,b)) However, there is no way to write gpair with liftRGN terms \nthat will result in suf.cient polymorphism over regions. For example, if we write gpair vw= liftRGN (do \na <-readRGNVar v b <-liftRGN (readRGNVar w) liftRGN (liftRGN (newRGNVar (a,b))) ) then we produce a function \nwith the type: gpair :: .r1..a..r2..b..r3..r4. RGNVar ((r1, r2), r3) a . RGNVar (r1, r2) b . RGN (((r1, \nr2), r3), r4)(RGNVar r1 (a, b)) The problem is that the explicit connection between the outer and inner \nregions in the product type enforces a total order on regions, which leaks into the types of region allocated \nvalues. The function above only works when the four regions are consecutive and the output variable is \nallocated in the outermost region, the input vari\u00adables are allocated in the next two regions, and the \ncomputation is indexed by the innermost region. However, the order of the regions should not matter. \nThe only requirement is that if the .nal computation (indexed by r4) is ever run, then each of the regions \nr1, r2, and r3 must be live. To put it another way, the three regions are older than (i.e., subtypes \nof) region r4. Hence, we adopt a simple solution, one that enables the translation given in Section 5, \nwhereby we abstract the liftRGN applications and pass evidence that witnesses the region subtyping. gpair \n:: .r1..a..r2..b..r3..r4. (.c.RGN r1 c . RGN r4 c) . (.c.RGN r2 c . RGN r4 c) . (.c.RGN r3 c . RGN r4 \nc) . RGNVar r1 a . RGNVar r2 b . RGN r4 (RGNVar r3 (a,b)) gpair ev1ev2ev3v w=do a<-ev1 (readRGNVar v) \nb <-ev2 (readRGNVar w) ev3 (newRGNVar (a,b)) While this evidence can be assembled from liftRGN terms, \nwe .nd that the key notion is subtyping on regions and evidence that wit\u00ad i . Z a,\u00df,r,s . TVarsFRGN f \n,x . VarsFRGN Types t ::= int | bool | t1 . t2 | t1 \u00d7\u00b7\u00b7\u00b7\u00d7 tn | a |.a.t |RGN tr ta | RGNVar tr ta Terms \ne ::= i | e1 t e2 | e1 &#38;#169; e3 | tt | . | if eb then et else ef | x | .x : t.e | e1 e2 | .a.e | \ne [t] | (e1,..., en) | selie | let x = e1 in e2 | .r | . Values v ::= i | tt | . | x | .x : t.e | .a.e \n| (v1,..., vn) | .r | . RGN monad constants .r ::= runRGN . ::= letRGN | returnRGN | thenRGN |newRGNVar \n| readRGNVar | .xRGNVar t : t =.\u00df.RGN t\u00df . RGN t \u00df runRGN :: .a.(.r.RGN r a) . a letRGN :: .r..a.(.s.r \n: s . RGN s a) . RGN r a returnRGN :: .r..a.a . RGN r a thenRGN :: .r..a..\u00df.RGN r a . (a . RGN r \u00df) \n. RGN r \u00df newRGNVar :: .r..a.a . RGN r (RGNVar r a) readRGNVar :: .r..a.RGNVar r a . RGN r a .xRGNVar \n:: .r..a.(RGNVar r a . a) . RGN r (RGNVar r a) Figure 1. Surface syntax of FRGN nesses the subtyping. \nThe product type used in blockST is one way of connecting the outer and inner stores, but all the magic \nhap\u00adpens with liftST. Therefore, we adopt an approach that fuses the two operations into letRGN: r : \ns =.b.RGN rb . RGN sb letRGN :: .r..a.(.s.r : s . RGN sa) . RGN ra The argument to letRGN is given the \nevidence that the outer (older) region is a subtype of the new region, which it can use in the re\u00adgion \ncomputation. The same parametricity argument that applied to runST applies here: variables and computations \nfrom the inner region cannot escape beyond the encapsulation of letRGN. We no longer need a product type \nconnecting the outer and inner regions, as this relationship is given by the witness function. We note \nthat much of the development in this paper could be pur\u00adsued using letRGN and liftRGN with types analogous \nto blockST and liftST (i.e., using a product type) and appropriately assembling evidence from liftRGN \nterms. However, we have adopted the ap\u00adproach given above for a number of reasons. First, the types are \nsmaller than under the alternative scheme. Looking forward to Sec\u00adtion 5, we trade the number of terms \nin scope for the size of the types in scope. Second, one is encouraged to write region poly\u00admorphic functions \nwith the fused letRGN, whereas one can write region constrained functions with liftRGN. Third, letRGN \nmakes it clear that the only witness functions are those that arise from enter\u00ading a new region. Finally, \nalthough we have made the type r : s a synonym for a witness function, we can imagine a scheme in which \nthis primitive evidence is abstract and we provide additional opera\u00adtions for combining evidence and \noperations for taking evidence to functions for importing RGN computations or RGNVar variables. l . Locs \nr . RNames s . SNames Region placeholders . ::= r | Stack placeholders s ::= s |. Types, terms, values, \nRGN monad constants t ::= ... | s.. e ::= ... |(l)s.. | .r | .r | . | . . ::= ... | witnessRGN s..1 s..2 \n.r,. ::= partially applied constants .r,. ::= fully applied constants v ::= ... |(l)s.. | .r | . | . \n Regions R ::= {l1 . v1,...,ln . vn} Region stacks / Stacks S ::= \u00b7| S, r . R (ordered domain) Figure \n2. Operational semantics of FRGN (I)  3 The FRGN Calculus The language FRGN is an extension of System \nF [20, 7] (also re\u00adferred to as the polymorphic lambda calculus), adding the types and operations from \nthe RGN monad. As described in the previ\u00adous section, the design of FRGN takes inspiration from the work \non monadic state [15, 14, 16, 1, 23, 19]. Figure 1 presents the syntax of surface programs in FRGN (that \nis, excluding intermediate terms that appear in the operational se\u00admantics). In the following sections, \nwe expand upon the discussion in Section 2 to explain and motivate the design of FRGN . 3.1 Types and \nterms Types in FRGN include all those found in System F: the primitive types int and bool, function and \nproduct types, and type abstrac\u00adtions. The RGN tr ta and RGNVar tr ta types were introduced in the previous \nsection. Although the remainder of this paper will never require a region index to be represented by \nanything other than a type variable, we choose to allow an arbitrary type in the .rst argument of the \nRGN monad type constructor. We can thus interpret RGN as a primitive type constructor, without any special \nrestrictions that may not be expressible in a practical programming language. Furthermore, in an operational \nsemantics not based on type-erasure, type variables used as region indices will be instantiated with \nregion types. As with types, terms in FRGN include all those found in System F; constants, arithmetic \nand boolean operations, function abstraction and application, tuple introduction and elimination, and \ntype ab\u00adstraction and instantiation are all completely standard. We let .r and . range over the syntactic \nclass of monadic opera\u00adtions, given as constants with polymorphic types in a call-by-value interpretation \nof FRGN . Each of the constants has been described earlier, except .xRGNVar, which provides a means of \nallocating recursive structures. We discuss this monadic operation in more detail below. e . v v [sr] \n. . \u00b7, r . {};. .. \u00b7, r . R ;v (standard call-by-value operational semantics for System F) s fresh runRGN \n[ta] v . v [s /sr][./s] S; . .. S ;v r1 . dom(S) r2 ./dom(S) v [sr2](witnessRGN sr1 sr2) . . S; .1 \n. .2 .. S ;v ,r2 . R2;v .. S ;v1 v2 v1 S ; .2 S,r2 . {};. .. S S;returnRGN [sr][ta] v .. S;vS; thenRGN \n[sr][ta][tb] .1 v2 S;letRGN [sr1][ta] v .. S [s /sr2] .. S ; v /sr2]; v [s S = S1, r1 . R1, S2,r2 . \nR2,S3 S;. .. S ;vr . dom(S) l ./dom(S(r)) r . dom(S) l . dom(S(r)) v = S(r,l) S; witnessRGN sr1 sr2 [ta] \n. .. S ; vS; newRGNVar [sr][ta] v .. S;v .. S{(r, l) . v}; (l)sr S;readRGNVar [sr][ta] (l)sr r . dom(S) \nl ./dom(S(r)) . v vf (l)sr S; .xRGNVar [sr][ta] vf . S{(r,l) . v},(l)sr Figure 3. Operational semantics \nof FRGN (II) 3.2 Type system We adopt the standard type system for System F; the only typing judgement \nof interest is .; G fexp e : t meaning that term e has type t where . records the free type variables, \nand G records the free value variables and their types. The polymorphic types for each of the monadic \noperations are given in Figure 1, repeating those presented in Section 2. Finally, we note that the (derived) \ntyping rule for .xRGNVar [tr][ta] f requires that the function f has the type RGNVar tr ta . ta. This \nis a pure function, not a monadic computation. Hence, it is safe to use the variable where the allocated \nvalue is to be stored, because no computation (hence, no reading of region variables) can occur during \nthe evaluation of the application of f to the variable. On the other hand, f can return a computation \nthat reads the variable, since this computation cannot be run until after the knot has been tied. 3.3 \nOperational semantics and soundness Figures 2 and 3 gives a large-step operational semantics in terms \nof a run-time stack of regions. Regions are mappings of locations to values, while stacks are (ordered) \nmaps of region names to regions. Two mutually inductive judgements (one for pure expressions and one \nfor monadic commands) de.ne the semantics; the judgement for monadic commands takes a stack of regions \nand returns a modi\u00ad.ed stack and a .nal result. Deallocation of a region is modeled by replacing all \noccurrences of the region name with the dead region ; the rule for readRGNVar does not apply to a location \nindexed by . The rule for runRGN chooses a fresh stack name s to distinguish computations encapsulated \nby this runRGN from computations en\u00adcapsulated by other runRGNs. While the large-step semantics suf.ces \nto describe the complete ex\u00adecution of a program, it cannot describe non-terminating executions or failed \nexecutions. To do so, we adopt a natural transition seman\u00adtics [28, 24], which provides a notion of attempted \nor partial exe\u00adcution. The key idea is to model program execution as a sequence of partial derivation \ntrees, which may or may not converge to a complete derivation. We can give a syntactic proof that the \ntype system is sound with respect to the operational semantics: THEOREM 1 (FRGN TYPE SOUNDNESS). If \u00b7;\u00b7fexp \ne : t, then any execution of e either terminates with a value v (such that \u00b7; \u00b7fexp v : t) or diverges. \n  4 Region Calculi Our goal is to show that FRGN is suf.cient for encoding the region typing mechanisms \nof complicated languages such as Cyclone that include special purpose typing features for checking regions \nand effects. In our technical report, we have constructed a core model for Cyclone, called the Bounded \nRegion Calculus (BRC), and have shown how it can be compiled in a meaning-preserving fashion to FRGN \n. The translation is broken into two steps: we .rst translate BRC to a restricted form that is called \nthe Single Effect Calculus (SEC). This translation encodes computational effects, which are sets of regions, \ninto a single region coupled with a set of subtyping constraints. We then give a direct translation from \nSEC to FRGN . Subtyping in both BRC and SEC derives from the fact that a LIFO stack of regions imposes \na partial order on live (allocated) regions. Regions lower on the stack outlive regions higher on the \nstack. Hence, we consider a region to be a subtype of all the regions that it outlives. In this section, \nwe only brie.y discuss the Bounded Region Calcu\u00adlus but present the Single Effect Calculus in detail. \nIn the follow\u00ading section, we give the complete translation from SEC to FRGN , which is considerably \nmore involved, and discuss the highlights of the proof of correctness. 4.1 The Bounded Region Calculus \nThe Bounded Region Calculus is adapted from the region calculus described by Henglein, Makholm, and Niss \n[11]. BRC is a direct\u00adstyle, call-by-value language with a type-and-effects system similar to the original \nTofte-Talpin region calculus. To keep things simple, the language does not include effect polymorphism, \nbut this can be simulated (see below). To accommodate Cyclone-like languages, BRC includes a form of \nbounded region subtyping. Thus, the type structure for BRC is as follows: Region variables . . RVarsBRC \nPlaces . ::= . | ... Effects . ::= {.1,...,.n} Types t ::= bool | (\u00b5,.) . .t Boxed types \u00b5 ::= int | \nt1 . t2 | t1 \u00d7 t2 | .. > . . - A region is associated with every type that requires heap allocated storage; \nwe assume that integers, pairs, function closures, and re\u00adgion abstractions do so, while booleans do \nnot. The type (\u00b5,.) pairs together a boxed type (a type requiring heap allocated storage) and a place \n(a region); we interpret (\u00b5, .) as the type of values of boxed type \u00b5 allocated in region .. At the source-level, \nplaces range over region variables (RVarsBRC), but in the dynamic semantics, we also have places corresponding \nto concrete region names and a distin\u00adguished constant representing a deallocated region. Effects . are \n.nite sets of places. In the function and region\u00adabstraction types, the effect . denotes a latent effect: \nthose regions read from or written to when a function is called. In a region\u00adabstraction type .. > . \n. .t, the effect . serves as a lower bound on the lifetime of the region .. That is, the abstraction \ncan only be instantiated by a region . that has been pushed on the stack more re\u00adcently than those regions \nin . . Within the body of the abstraction, we may safely assume that . is outlived by all of the regions \nin . . Put another way, if . is live, then all of the regions in . must be live. A translation from BRC \nto FRGN must accomplish a number of objectives: (1) eliminate region subtyping (through explicit coer\u00adcions), \n(2) sequence computations using the monadic constructs, and (3) encode effects using a single type for \nthe index of the RGN monad. In order to simplify the translation to FRGN and its proof of correctness, \nwe factor out this third objective by .rst sketching a translation to a simpli.ed language, the Single \nEffect Calculus.  4.2 The Single Effect Calculus The Single Effect Calculus is a restricted form of \nBRC where la\u00adtent effects consist of a single place instead of a set of places. It is straightforward \nto translate from the full BRC language to SEC by leveraging the bounded subtyping. At the type level, \nthis transla\u00adtion expands each type with a latent effect into a region abstraction bounded by that effect. \nFor example, the translation of arrow types is as follows: .. T[(t1 -. t2, .)] =(.. > .. - .(T[t1] . \nT[t2], .), .) We have replaced the set of places . with a single region variable .. However, we constrain \n. so that its liveness implies the liveness of all of the places in .. Because the translation is so \nsimple, we do not present the details of BRC here, though its full details, together with the translation \nto SEC are given in the report [6]. Instead, we concentrate on the formal de.nition of SEC and its translation \nto FRGN . Figure 4 presents the syntax of surface programs in the Single Effect Calculus (that is, excluding \nintermediate terms that appear in the operational semantics). Figure 5 present a type system for this \nexternal language. The technical report [6] gives a large-step operational semantics in terms of a run-time \nstore; the semantics is completely standard for a region-based language. In the following i . Z ., . \n. RVarsSEC where H . RVarsSEC f ,x . VarsSEC Places .,. ::= . Effects . ::= {.1,...,.n}Types t ::= bool \n| (\u00b5,.) Boxed types . \u00b5 ::= int | t1 -.t . t2 | t1 \u00d7 t2 | .. > .. Terms e ::= i at . | e1 t e2 at . | \ne1 &#38;#169; e2 |tt | . | if eb then et else ef | . x | .x : t. e at . | e1 e2 |(e1, e2) at . | fst \ne | snd e | . letregion . in e | .. > .. u at . | e [.] .x f : t.u Abstractions .. u ::= .x : t. e at \n. | .. > .. u at . Values v ::= tt | . | x Figure 4. Surface syntax of SEC sections, we explain and motivate \nthe main constructs and typing rules of SEC. 4.2.1 Types and terms The type structure of SEC is the \nsame as that of BRC except that latent effects . are restricted to a single place. As a convention, we \nwill use . to represent places that correspond to such effects. As in the original region calculus, terms \nyielding heap allocated values have a region annotation at ., which indicates the region in which the \nvalue is to be allocated. New regions are introduced (and implicitly created and destroyed) by the letregion \n. in e term. The region variable . is bound within e, and values may be read from or allocated in the \nregion . while evaluating e. The term .. > .. .u at . introduces a region abstraction (allocated in the \nregion .), where the term u is polymorphic in the region ..2 As explained previously, region abstractions \nmake use of bounded quanti.cation; the intention is that . is an upper bound on the set of regions .. \nThe term e [.] eliminates a region abstraction; opera\u00adtionally, it substitutes the place . for the region \nvariable . in u and evaluates the resulting term. Finally, we include a .xed-point term, .x f : t.u. \nSince we intend SEC to obey a call-by-value evaluation semantics, we limit the body of a .xed-point to \nabstractions. As an example, consider the following term to compute a factorial 2Limiting the body of \na region abstraction to abstractions en\u00adsures that an erasure function that removes region annotations \nand produces a .-calculus term is meaning preserving.  (in which we elide the type annotation on fact): \n.x fact. . f (..i > {}. . f (..o > {}. . f (..b >{. f ,.i,.o}. .b (.n : (int,.i). if letregion . in n \n= (1 at .) then 1 at .o else letregion .i in (letregion .o in (fact [.i ][.o ][.o ] (letregion . in n \n- (1 at .) at .i ))) * n at .o ) at .f ) at . f ) at .f ) at . f The function fact is parameterized by \nthree regions: .i is the region in which the input integer is allocated, .o is the region in which the \noutput integer is to be allocated, and .b is a region that bounds the latent effect of the function. \n(Region .f is assumed to be bound in an outer context and holds the closure.) We see that the bounds \non .i and .o indicate that they are not constrained to be outlived by any other regions. On the other \nhand, the bound on .b indicates that . f , .i, and .o must outlive .b. Hence, .b suf.ces to bound the \neffects within the body of the function, in which we expect regions .f (at the recursive call) and .i \nto be read from and region .o to be allocated in. Note that the regions passed to the recursive call \nof fact satisfy the bounds, as .o outlives . f (through .i and .b), .i is allocated before (and deallocated \nafter) .o , and .o clearly outlives itself.  4.2.2 Type system The typing rules for SEC appear in Figure \n5. Region contexts . are ordered lists of region variables bounded by effect sets. Value contexts G are \nordered lists of variables and types. We summarize the main typing judgements in the following table: \nJudgement Meaning . fbtype \u00b5 Boxed type \u00b5 is well-formed. . ftype t Type t is well-formed. . frr . > \n. If region . is live, then region . is live. (Alt.: region . outlives region ..) . fre . > . If region \n. is live, then all regions in . are live. (Alt.: all regions in . outlive region ..) .;G fexp e : t,. \nTerm e has type t and effects bounded by region .. fprog e ok Program e is well-typed. Previous formulations \nof region calculi (including BRC) make use of a judgement of the form .; G fexp e : t,., where . indicates \nthe set of regions that may be affected by the evaluation of e. SEC simply replaces . with a single region \n. that bounds the effects in .. In practice, and as suggested by the typing rules, . usually corresponds \nto the most recently allocated region (also referred to as the top or current region). We start by noting \nthat the typing rules for the judgements . frr . > . and . fre . > . simply formalize the re.exive, transitive \nclosure of the syntactic constraints in ., each of which asserts a particular outlived by relation between \na region variable and an effect set. The key judgement in region calculi is the typing rule for letregion \n. in e: . ftype t fctxt .; G; . .,. >{.};G fexp e : t,. .; G fexp letregion . in e : t, . Note that the \n(implicit) antecedent . ./dom(.) and the (explicit) judgements . ftype t and fctxt .; G;. ensure that \n. does not appear in the result type or the types of the value environment. This new region is clearly \nrelated to the current region . it is outlived by the old current region and becomes the new current \nregion for the evaluation of e. These facts are captured by the .nal antecedent .,. >{.};G fexp e : t,.. \nIt is worth comparing the treatment of latent effects in the Single Effect Calculus with their treatment \nin previous formulations of region calculi. In previous work, the typing rule for application appears \nas follows: .; G fexp e1: (t1 -..;G fexp e2: t2,.2 . t2, .), .1 .;G fexp e1 e2: t2,. . .1 . .2 .{.} In \nSEC, the composite effect . . .1 . .2 .{.} is witnessed by a single effect . that subsumes the effect \nof the entire expression. We interpret . as an upper bound on the composite effect; hence, . is an upper \nbound on each of the effect sets .1 and .2, which explains why . is used in the antecedents that type-check \nthe sub\u00adexpressions e1 and e2. In order to execute the application, the oper\u00adational semantics must read \nthe function out of the region .; there\u00adfore, we require . to outlive the current region . by the antecedent \n. frr . > .. Finally, we require the latent single effect . , which is an upper bound on the set of regions \naffected by executing the func\u00adtion, to outlive the current region, which ensures that . is also an up\u00adper \nbound on the set of regions affected by executing the function. The typing rule for region application \nrequires that we be able to show that the formal region parameter . is outlived by all of the regions \nin the region abstraction bound .. Finally, the rule for top-level surface programs requires that an \nex\u00adpression evaluate to a boolean value in the context of distinguished region H that remains live throughout \nthe execution of the program. It also serves as the single effect that bounds the effects of the entire \nprogram.  5 The Translation In this section we present a type-and meaning-preserving transla\u00adtion from \nthe Single Effect Calculus to FRGN. Many of the key com\u00adponents of the translation should be obvious, \nbut we walk through the translation in stages, as there are some subtleties that require explanation. \nWe start with a few preliminaries. Technically, we assume injec\u00adtions from source variables RVarsSEC \nand VarsSEC to target vari\u00adables TVarsFRGN and VarsFRGN respectively, but freely use vari\u00adables from \nsource objects in target objects. We further assume one additional injection from the set RVarsSEC to \nthe set VarsFRGN , writ\u00adten w., that will denote the witnesses for the region .. The translation is a \ntyped call-by-value monad translation, similar to the standard translation given by Sabry and Wadler \n[22]. The translation is given by a number of functions: T[\u00b7] translates into types, D[\u00b7] translates \ninto type contexts, G[\u00b7] translates into value contexts, and E[\u00b7] translates into expressions. Technically, \nthere are separate functions for each syntactic class in the source calculus, but we elide this detail \nas it is always clear from context. Figure 6 shows the translation of types and contexts. As expected, \nthe type (\u00b5, .) is translated to the type RGNVar . T[\u00b5], whereby region allocated values in the source \nare also region allocated in the target. The interesting cases are function and region abstraction types. \nFunctions with effects bounded by the region . are trans\u00adTranslations yielding types (from boxed types, \ntypes, and witnesses) T[int = int T[bool = bool T[t1 \u00d7 t2 = T t1 \u00d7 T[t2] T[(\u00b5, .)] = RGNVar . T[\u00b5]. \nT[t1 -. t2] = T[ t1] . RGN . T[t1] T[.. > .. .t] = ...T[. > .] . RGN . T[t] T[. > . = . : . = .\u00df.RGN \n.\u00df . RGN .\u00df T[. >{.1,..., .n}] = \u00b7\u00b7\u00b7 T[. > .1] \u00d7\u00d7 T[. > .n] Translations yielding type contexts (from \nregion contexts) = \u00b7 D[\u00b7 = D[.,. > .] D[.],. Translations yielding value contexts (from region contexts \nand value contexts) = \u00b7 = \u00b7 G[\u00b7 G[\u00b7 == G[., . > .] G[.],w. : T[. > .] G[G,x : t] G[G],x : T[t] LEMMA \n1 (TRANSLATION PRESERVES TYPES (TYPES AND CONTEXTS)). If frctxt ., then frctxt D[.]. If . fbtype \u00b5, \nthen D[.] ftype T[\u00b5].  If . ftype t, then D[.] ftype T[t].  If . fvctxt G, then D[.] fvctxt G[.] ,G[G]. \n Figure 6. Translation from the Single Effect Calculus to FRGN (Types and Contexts) lated into pure functions \nthat yield computations in the RGN monad indexed by ., whereas region abstractions are translated into \ntype abstractions. The target calculus makes witness functions explicit, whereas in the source calculus \nsuch coercions are implied by > re\u00adlated regions. Hence, we translate . >{.1,...,.n} to an n-tuple of \n3 functions, each witnessing a coercion from RGN .i to RGN .. We extend the type translation to contexts \nin the obvious way. In addition to translating region variables to type variables and trans\u00adlating the \ntypes of variables in value contexts, we have an additional translation from region contexts to value \ncontexts. As explained above, witness functions are explicit values in the target calculus. Hence, our \ntranslation maintains the invariant that whenever a re\u00adgion variable . > . is in scope in the source \ncalculus, the variable w., of type T[. > .], is in scope in the target calculus and holds the witness \nfunctions that coerce to region .. Figure 7 shows the translation of witness terms. The .rst three translations \nmap the re.exive, transitive closure of the syntactic constraints in a source . into an appropriate coercion \nfunction. The .nal translation collects a set of coercion functions into a tuple; such a term is suitable \nas an argument to the translation of a region abstraction. Figure 8 shows only the translation of key \nterms, as the cases for the other terms are straightforward. In order to make the translation easier \nto read, we introduce the following notation, reminiscent of Haskell s do notation: bind f : ta . e1;e2 \n= thenRGN [tr][ta][tb] e1 (. f : ta.e2) where tr and tb are inferred from context. The translation of \nan integer constant is a canonical example of al\u00adlocation in the target calculus. The allocation is accomplished \nby 3Note that we treat {.1,...,.n} as a list with .xed order and not as a set, so we can realize the \nwitness with an ordered tuple. the newRGNVar command, applied to the appropriate value. How\u00adever, the \nresulting computation has type RGN . (RGNVar . int), whereas the source typing judgement requires the \ncomputation to be expressed relative to the region .. We coerce the computation using a witness function, \nwhose existence is implied by the judgement . frr . > .. Allocation of a function closure proceeds in \nexactly the same manner. Function application, while notationally heavy, is simple. The bind sequences \nevaluating the function to a vari\u00adable, reading the variable, evaluating the argument, and applying the \nfunction to the argument. The translation of letregion . in e is pleasantly direct. As described above, \nwe introduce . and w. through .-and .-abstractions. The coercion function is supplied by the letRGN command \nwhen the computation is executed. The translation of region abstraction is similar to the translation \nof functions. Once again, witness functions are .-bound in accordance to the invariants described above. \nDuring the translation of region applications, the appropriate tuple of witness functions (constructed \nby E[. fre .2 > .]) is supplied as an argument. Figure 9 shows the translation of programs. The entire \nregion com\u00adputation is encapsulated and run by the runRGN expression. We bind wH to an empty tuple, which \ncorresponds to the absence of any coercions to the region H . 5.1 Translation Properties In each .gure, \nwe have indicated the particular type preservation lemma implied by each component of the translation. \nThe proofs are by (mutual) induction on the structure of the typing judgements. Furthermore, the translation \nis meaning preserving, with respect to the operational semantics of SEC and FRGN . The essence of this \nproof relies on a coherence lemma stating that the translation of Translations yielding expressions (from \nwitness derivations) frctxt . E.(.)= {.1,..., .i,...,.n} = .\u00df..k : RGN .i \u00df.(seliw.)[\u00df] k [] . frr . \n> .i [ . fplace . ] E= .\u00df..k : RGN .\u00df.k . frr . > . [ . frr . frr  E. > .. > . ] = .\u00df..k : RGN .\u00df.E[. \nfrr . > . ] [\u00df](E[. frr . > . ] [\u00df] k). frr . > . frctxt . i.1...n  E. frr . > .i =(E[. fre . > .1],...,E[. \nfrr . > .n]) [] . fre . >{.1,...,.n} LEMMA 2 (TRANSLATION PRESERVES TYPES (WITNESES)).  If . frr . > \n. , then D[.];G[.] fexp E[. frr . > . ] : T[. > . ].  If . frr . > ., then D[.];G[.] fexp E[. fre . \n> .] : T[. > .].  Figure 7. Translation from the Single Effect Calculus to FRGN (witnesses) witnesses \nyields functions that are operationally equivalent to the identify function: LEMMA 5 (COHERENCE). Suppose \nfstack S : S and \u00b7; S frr r > ri. * Let S[fstack S : S] =(S* ,S *) and E[\u00b7;S frr r > ri] = ew. * If \u00b7; \n\u00b7; S *fexp .* : RGN s ri ta and S*;.*.. S * ;v, * then e* w [ta] .*. . and S*;. .. S * ;v. The judgement \nfstack S : S asserts that S is well-formed with stack type S; in the presence of allocated variables, \nthe other typing judgements are augmented with the stack type to assign types to locations. The translation \nS[\u00b7] simply extends term and type trans\u00adlation to stacks and stack types. Coherence is used throughout \nthe proof of correctness to show that every evaluation derivation for the source can be simulated by \na derivation involving the translation of the source: LEMMA 6. Suppose fstack S : S, \u00b7; \u00b7;S fexp e : \nt,r ,and S;e . S ;v, and there exists S such that fstack S : S and S fcval v : t. * Let S[fstack S : \nS] =(S* , S*) and E[\u00b7; \u00b7;S fexp e : t,r ] = e. Then e*. .* and S*;.*.. S * ; v * , where * S[fstack S \n: S ] =(S * , S *) and E[S fcval v : t] = v. A simple application of this result shows that the when \na source program evaluates to a value, then encapsulating and running its translation also evaluates \nto the value: THEOREM 2 (TRANSLATION CORRECTNESS). * Suppose fprog e ok and e .prog v . Let E[fprog e \nok] = e. * Then e*. v * , where E[\u00b7fcval v : bool] = v. Full details of this development are given in \nthe report [6]. Related Work The work in this paper draws heavily from two lines of research. The .rst \nis the work done in type-safe region-based memory man\u00adagement, introduced by Tofte and Talpin [26, 27]. \nOur Single Ef\u00adfect Calculus draws inspiration from the Capability Calculus [5] and Cyclone [9], where \nthe outlives relationship between regions is recognized as an important component. The work of Banerjee, \nHeintze, and Riecke [2] deserves special mention. They show how to translate the Tofte-Talpin region \ncal\u00adculus into an extension of the polymorphic .-calculus called F#. A new type operator # is used as \na mechanism to hide and reveal the structure of types. Capabilities to allocate and read values from \na region are explicitly passed as polymorphic functions of types .a.a . (a#.) and .a.(a#.) . a; however, \nregions have no run\u00adtime signi.cance in F# and there is no notion of deallocation upon exiting a region. \nThe equality theory of types in F# is nontrivial, due to the treatment of #; in contrast, type equality \non FRGN types is purely syntactic. Furthermore, their proof of soundness is based on denotational techniques, \nwhereas ours are based on syntactic tech\u00adniques which tend to scale more easily to other linguistic features. \nFinally, it is worth noting that there is almost certainly a connec\u00adtion between the F# lift and seq \nexpressions and the monadic return and bind operations, although it is not mentioned or explored in the \npaper. The second line of research on which we draw is the work done in monadic encapsulation of effects \n[17, 18, 21, 15, 29, 14, 16, 22, 1, 12, 23, 19, 30]. The majority of this work has focused on effects \narising from reading and writing mutable state, which we reviewed in Section 2. While recent work [29, \n19, 30] has considered more general combinations of effects and monads, no work has examined the combination \nof regions and monads. Finally, we note that Wadler and Thiemann [30] advocate marry\u00ad s ing effects and \nmonads by translating a type t1 -. t2 to the type T[t1] . Ts T[t2], where Tst represents a computation \nthat yields a value of type t and has effects delimited by (the set) s. As with the work of Banerjee \net. al. described above, this intro\u00adduces a nontrivial theory of equality (and subtyping) on types; the \ntypes Tst and Tst are equal so long as s and s are (encodings of) equivalent sets. 7 Conclusions and \nFuture Work We have given a type-and meaning-preserving translation from the Single Effect Calculus to \nFRGN . The translation provides a more modular account of the soundness of region-based languages such \nas Cyclone that incorporate region subtyping. The key insight is Translations yielding expressions (from \nexpression derivations) fctxt .;G; . E[ . fplace .. frr . > . ] = E[. frr . > .] (newRGNVar [.][T[int]] \ni) .;G fexp i at . : (int,.),. fctxt .; G; . E[ x . dom(G) G(x)= t ] = returnRGN [.][T[t]] x .;G fexp \nx : t, . .;G,x : t1 fexp e : t2,. . fplace .. frr . > . = E.[ l] . .;G fexp .x : t1. . e at . : (t1 \n-. t2,.),. (t1 -. t2, .)](newRGNVar [.][T-. t2 E[. frr . > .] [T[.][t1 .]](.x : T[t1].E[.; G,x : t1 \nfexp e : t2,. ])) . .;G fexp e1: (t1 -. t2,.1),.. frr . > .1 E.[ .;G fexp e2: t1,.. frr . > . l] =  \n.;G fexp e1 e2: t2,. [.][.] bind f : T(t1 -. t2, .1). E.;G fexp e1: (t1 -. t2,.1),.; [.][.][.] bind g \n: Tt1 -. t2. E[. frr . > .1] [Tt1 -. t2](readRGNVar [.1][Tt1 -. t2] f ); bind a : T[t1] . E[.;G fexp \ne2: t1,.]; let z = ga in E[. frr . > . ] [T[t2]] z where f ,g,a,z fresh . ftype t fctxt .;G;. E[ ., . \n>{.};G fexp e : t,. = letRGN [.][T[t]](....w. : T[. >{.}]. .;G fexp letregion . in e : t,. ] E[., . >{.}; \nG fexp e : t, .]) ., . > .; G fexp u : t,. . fplace .. frr . > . = E[] . .;G fexp .. > .. u at . : \n(.. > .. .t, .), . E[.; S frr . > .] [T[(.. > .. .t,.)]] (newRGNVar [.][T[.. > .. .t]](....w. : T[. \n> .].E[.,. > .; G fexp u : t,. ])) .;G fexp e1: (.. > .. .t,.1),.. frr . > .1 . fplace .2 . fre .2 > \n.. frr . > . [.2/.]= E[] .; G fexp e1 [.2] : t[.2/.],. bind f : T[(.. > .. .t,.1)] . E[.;G fexp e : \n(.. > .. .t,.1),.]; bind g : T[.. > .. .t] . E[. frr . > .1] [T[.. > .. .t]](readRGNVar [.1][T[.. > .. \n.t]] f ); let z = g [.2] E[. fre .2 > .] in E[. frr . > . [.2/.]] T[t[.2/.]] z where f ,g, z fresh LEMMA \n3 (TRANSLATION PRESERVES TYPES (EXPRESSIONS)). If .;G fexp e : t,., then D[.];G[.] , G[G] fexp E[.; G \nfexp e : t,.] : RGN . T[t]. Figure 8. Translation from the Single Effect Calculus to FRGN (Expressions) \nTranslations yielding terms (programs) E[ \u00b7,H > {};\u00b7fexp e : bool, H ] = runRGN [T[bool]](.H .let wH \n= () in E[\u00b7,H > {};\u00b7fexp e : bool,H ]) fprog e ok LEMMA 4 (TRANSLATION PRESERVES TYPES (FROM PROGRAM \nDERIVATIONS)). If fprog e ok, then \u00b7;\u00b7fexp E[\u00b7,H > {};\u00b7fexp e : bool,H ] : T[bool]. Figure 9. Translation \nfrom the Single Effect Calculus to FRGN (Programs) that traditional effects can be encoded using bounded \nregion sub\u00adtyping, and the subtyping can be eliminated by a coercion-based interpretation. Furthermore, \nthe ideas behind the ST monad can be used to achieve encapsulation using only parametric polymorphism. \nA simple extension [6] incorporates region handles run-time values holding the data necessary to allocate \nvalues within a re\u00adgion. Region indices (types) and region handles (values) are distin\u00adguished in order \nto maintain a phase distinction between compile\u00adtime and run-time expressions and to more accurately \nre.ect the implementation of regions in languages like Cyclone. Region in\u00addices, like other types, have \nno run-time signi.cance and may be erased from compiled code. In contrast, region handles are neces\u00adsary \nat run-time to allocate values within a region. There are numerous directions for future work. One idea \nis to pro\u00advide the RGN monad to Haskell programmers and to try to leverage type classes so that witnesses \ncan be passed implicitly, thereby re\u00adducing the notational overhead of programming with nested stores. \nWhile a direct encoding of subtyping leads to undecidable and over\u00adlapping instances, the use of type-indexed \nproducts [13] may pro\u00advide a partial solution, at the expense of reintroducing a product type (see comments \nat the end of Section 2). Obviously, a language that incorporates subtyping directly, such as F=, would \nsimplify the encoding. Finally, as is well known, Tofte and Talpin s original region cal\u00adculus can lead \nto inef.cient memory usage for some programs. In practice, additional mechanisms are required to achieve \ngood space utilization. Cyclone incorporates a number of these enhancements, including unique pointers \nand dynamic regions, and it remains to be seen whether these features can also be encoded into a simpler \nsetting.    Acknowledgements A preliminary version of this work appeared in the informal Pro\u00adceedings \nof the 2nd Workshop on Semantics, Program Analysis, and Computing Environments for Memory Management \n(SPACE 04). Thanks to Oleg Kiselyov for suggestions on using Haskell type classes to pass witnesses. \n References [1] Z. Ariola and A. Sabry. Correctness of monadic state: An imperative call\u00adby-need calculus. \nIn Proceedings of the 25th ACM SIGPLAN-SIGACT Sympo\u00adsium on Principles of Programming Languages (POPL \n98), pages 62 74. ACM Press, 1998. [2] A. Banerjee, N. Heintze, and J. Riecke. Region analysis and the \npolymorphic lambda calculus. In Proceedings of the 14th IEEE Symposium on Logic in Computer Science (LCS \n99), pages 88 97. IEEE Computer Society Press, 1999. [3] C. Calcagno. Strati.ed operational semantics \nfor safety and correctness of the region calculus. In Proceedings of the 28th ACM SIGPLAN-SIGACT Sympo\u00adsium \non Principles of Programming Languages (POPL 01), pages 155 165. ACM Press, 2001. [4] C. Calcagno, S. \nHelsen, and P. Thiemann. Syntactic type soundness results for the region calculus. Information and Computation, \n173(2):199 332, Mar. 2002. [5] K. Crary, D. Walker, and G. Morrisett. Typed memory management in a cal\u00adculus \nof capabilities. In Proceedings of the 26th ACM SIGPLAN-SIGACT Sym\u00adposium on Principles of Programming \nLanguages (POPL 99), pages 262 275. ACM Press, 1999. [6] M. Fluet. Monadic regions: Formal type soundness \nand correctness. Technical Report TR2004-1936, Department of Computer Science, Cornell University, Apr. \n2004. [7] J.-Y. Girard, P. Taylor, and Y. Lafont. Proofs and Types. Cambridge University Press, 1989. \n[8] D. Grossman, G. Morrisett, T. Jim, M. Hicks, Y. Wang, and J. Cheney. Region\u00adbased memory management \nin Cyclone. In Proceedings of the ACM SIGPLAN Conference on Programming Language Design and Implementation \n(PLDI 02), pages 282 293. ACM Press, 2002. [9] D. Grossman, G. Morrisett, Y. Wang, T. Jim, M. Hicks, \nand J. Cheney. For\u00admal type soundness for Cyclone s region system. Technical Report 2001-1856, Department \nof Computer Science, Cornell University, Nov. 2001. [10] S. Helsen and P. Thiemann. Syntactic type soundness \nfor the region calculus. In Proceedings of the 4th International Workshop on Higher Order Operational \nTechniques in Semantics (HOOTS 00), volume 41 of Electronic Notes in Theo\u00adretical Computer Science, pages \n1 19. Elsevier Science Publishers, Sept. 2000. [11] F. Henglein, H. Makholm, and H. Niss. Effect types \nand region-based memory management. In B. Pierce, editor, Advanced Topics in Types and Programming Languages, \nchapter 5. MIT Press, 2004. In preparation. [12] R. Kieburtz. Taming effects with monadic typing. In \nProceedings of the 3rd ACM SIGPLAN International Conference on Functional Programming (ICFP 98), pages \n51 62. ACM Press, 1998. [13] O. Kiselyov, R. L\u00a8ammel, and K. Schupke. Strongly typed heterogeneous col\u00adlections, \n5 June 2004. Submitted to the Haskell Workshop 2004. [14] J. Launchbury and S. Peyton Jones. Lazy functional \nstate threads. In Proceed\u00adings of the ACM SIGPLAN Conference on Programming Language Design and Implementation \n(PLDI 94), pages 24 35. ACM Press, 1994. [15] J. Launchbury and S. Peyton Jones. State in Haskell. Lisp \nand Symbolic Com\u00adputation, 8(4):293 341, 1995. [16] J. Launchbury and A. Sabry. Monadic state: Axiomatization \nand type safety. In Proceedings of the 2nd ACM SIGPLAN International Conference on Functional Programming \n(ICFP 97), pages 227 237. ACM Press, 1997. [17] E. Moggi. Computational lambda calculus and monads. In \nProceedings of the 4th IEEE Symposium on Logic in Computer Science (LCS 89), pages 14 23, 1989. [18] \nE. Moggi. Notions of computation and monads. Information and Computation, 93(1):55 92, Jan. 1991. [19] \nE. Moggi and A. Sabry. Monadic encapsulation of effects: a revised approach (extended version). Journal \nof Functional Programming, 11(6):591 627, Nov. 2001. [20] J. Reynolds. Towards a theory of type structure. \nIn Programming Symposium, volume 19 of Lecture Notes in Computer Science, pages 408 425. Springer-Verlag, \nApr. 1974. [21] J. Riecke and R. Viswanathan. Isolating side effects in sequential languages. In Proceedings \nof the 22nd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (POPL 95), pages 1 12. \nACM Press, 1995. [22] A. Sabry and P. Wadler. A re.ection on call-by-value. ACM Transactions on Programming \nLanguages and Systems, 19(6):916 941, Nov. 1997. [23] M. Semmelroth and A. Sabry. Monadic encapsulation \nin ML. In Proceedings of the 4th ACM SIGPLAN International Conference on Functional Programming (ICFP \n99), pages 8 17. ACM Press, 1999. [24] G. Smith and D. Volpano. A sound polymorphic type system for a \ndialect of C. Science of Computer Programming, 32(1-3):49 72, 1998. [25] M. Tofte, L. Birkedal, M. Elsman, \nN. Hallenberg, T. H. Olesen, , and P. Sestoft. Programming with regions in the ML Kit (for version 4). \nTechnical report, IT University of Copenhagen, Apr. 2002. [26] M. Tofte and J.-P. Talpin. Implementation \nof the typed call-by-value .-calculus using a stack of regions. In Proceedings of the 21st ACM SIGPLAN-SIGACT \nSymposium on Principles of Programming Languages (POPL 94), pages 188 201. ACM Press, 1994. [27] M. Tofte \nand J.-P. Talpin. Region-based memory management. Information and Computation, 132(2):109 176, Feb. 1997. \n[28] D. Volpano and G. Smith. Eliminating covert .ows with minimum typings. In Proceedings of the 10th \nIEEE Computer Security Foundations Workshop (CFSW 97), pages 156 168. IEEE Computer Society Press, 1997. \n[29] P. Wadler. The marriage of effects and monads. In Proceedings of the 3rd ACM SIGPLAN International \nConference on Functional Programming (ICFP 98), pages 63 74. ACM Press, 1995. [30] P. Wadler and P. Thiemann. \nThe marriage of effects and monads. Transactions on Computational Logic, 4(1):1 32, 2003.  \n\t\t\t", "proc_id": "1016850", "abstract": "Region-based type systems provide programmer control over memory management without sacrificing type-safety. However, the type systems for region-based languages, such as the ML-Kit or Cyclone, are relatively complicated, so proving their soundness is non-trivial. This paper shows that the complication is in principle unnecessary. In particular, we show that plain old parametric polymorphism, as found in Haskell, is all that is needed. We substantiate this claim by giving a type- and meaning-preserving translation from a region-based language based on core Cyclone to a monadic variant of System F with region primitives whose types and operations are inspired by (and generalize) the ST monad.", "authors": [{"name": "Matthew Fluet", "author_profile_id": "81100181338", "affiliation": "Cornell University, Ithaca, NY", "person_id": "PP17009813", "email_address": "", "orcid_id": ""}, {"name": "Greg Morrisett", "author_profile_id": "81339518683", "affiliation": "Harvard University, Cambridge, MA", "person_id": "PP43136279", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1016850.1016867", "year": "2004", "article_id": "1016867", "conference": "ICFP", "title": "Monadic regions", "url": "http://dl.acm.org/citation.cfm?id=1016867"}