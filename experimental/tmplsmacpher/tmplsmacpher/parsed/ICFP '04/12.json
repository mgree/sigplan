{"article_publication_date": "09-19-2004", "fulltext": "\n Numbering Matters: First-Order Canonical Forms for Second-Order Recursive Types Nadji Gauthier Franc\u00b8ois \nPottier INRIA INRIA Nadji.Gauthier@inria.fr Francois.Pottier@inria.fr Abstract We study a type system \nequipped with universal types and equire\u00adcursive types, which we refer to as F\u00b5. We show that type equality \nmay be decided in time O(n log n), an improvement over the previ\u00adous known bound of O(n2). In fact, we \nshow that two more general problems, namely entailment of type equations and type uni.ca\u00adtion, may be \ndecided in time O(nlog n), a new result. To achieve this bound, we associate, with every F\u00b5 type, a .rst-order \ncanoni\u00adcal form, which may be computed in time O(nlogn). By exploiting this notion, we reduce all three \nproblems to equality and uni.ca\u00adtion of .rst-order recursive terms, for which ef.cient algorithms are \nknown.  Categories and Subject Descriptors D.3.3 [Programming Languages]: Language Constructs and Fea\u00adtures \nPolymorphism; Recursion General Terms Algorithms, Theory  Keywords Recursive types, polymorphism, equality, \nuni.cation 1 Introduction During the last decade, the programming language community spent a great deal \nof effort studying object-oriented programming languages and devising object encodings [3, 7, 15, 12, \n16]. A typ\u00adical object encoding is a type-preserving translation of a surface object-oriented language \ninto a typed .-calculus. Such an encod\u00ading may serve two purposes. First, it explains object-oriented \npro\u00adgramming in terms of standard type-theoretic concepts. Second, it may be put to effective use as \nthe front-end of a type-preserving Permission to make digital or hard copies of all or part of this work \nfor personal or classroom use is granted without fee provided that copies are not made or distributed \nfor pro.t or commercial advantage and that copies bear this notice and the full citation on the .rst \npage. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior \nspeci.c permission and/or a fee. ICFP 04, September 19 21, 2004, Snowbird, Utah, USA. Copyright 2004 \nACM 1-58113-905-5/04/0009 ...$5.00 compiler, whose back-end is then purely concerned with typed .\u00adcalculus. \nThis requires, however, the target language of the encod\u00ading to have decidable typechecking and, if possible, \nto admit an ef.cient typechecking procedure. Because object orientation is complex, the target languages \nof most object encodings are rich .-calculi. They typically incorporate some or all of the following \nfeatures: .rst-class universal and existential types; recursive types; type operators; subtyping and \nbounded quanti.cation. In the present paper, we focus on the com\u00adbination of the .rst two: the object \nof our study is F\u00b5, an extension of Girard and Reynolds system F with recursive types. The ques\u00adtion \nwe are interested in is, does F\u00b5 have decidable and ef.cient typechecking? Before addressing such a question, \nwe must state it more precisely, because F\u00b5 comes in two .avors, whose typechecking problems are quite \ndifferent: one extends F with isorecursive types, while the other extends it with equirecursive types \n[1, 10]. In an extension of F with isorecursive types, two new typing rules are added to the type system, \nwhich direct the typechecker to fold or unfold a recursive type. (These rules usually allow folding and \nun\u00adfolding only at the root of the type. Allowing them to take place un\u00adder a context requires either \nadding coercions special constructs that generate no code to the programming language, as proposed by \nAbadi and Fiore [1], or de.ning more complex typing rules for folding and unfolding, perhaps along the \nlines suggested by Collins and Shao [5].) The de.nition of type equality is the same as in F: that is, \nno new axioms are added to deal with recursive types. Thus, typechecking isorecursive F\u00b5 is no more dif.cult \nthan typechecking F. In an extension of F with equirecursive types, on the other hand, there are no new \ntyping rules. Instead, type equality is extended so that comparing two types amounts to comparing their \nin.nite unfoldings. Thus, typing derivations are less verbose. Folding and unfolding naturally take place \nnot only at the root of a type, but also under a context. However, it is now more dif.cult to determine \nwhether two types are equal. Thus, a more precise statement of the question is: does equirecur\u00adsive F\u00b5 \nhave decidable and ef.cient typechecking? Perhaps surpris\u00adingly, the problem has received little attention \nin the literature. As suggested above, the key issue is to decide whether two types are equal. It appears \nto have been only recently studied. Colazzo and Ghelli [4] show that the more general problem of deciding \nsubtyp\u00ading in Kernel Fun is decidable. Glew [13] studies type equality in F\u00b5 and proves that its complexity \nis bounded by O(n2), where n is t := a (variable) ||| a \u00b5a.TTt \u00b5a..a.t (atom) (type constructor application) \n(universal type) Figure 1. Types in F\u00b5 .\u00b5a.TT .TT}T {a t}Tt = \u00b5a {a'.\u00b5a't't' a = \u00b5a a a = \u00b5a a \u00b5a.TTt \n= \u00b5a \u00b5a'.TTt' {a .\u00b5a'..a.t'}t' .\u00b5a..a.t}t = \u00b5a {a' \u00b5a..a.t = \u00b5a \u00b5a'..a.t' Figure 2. Type equality in \nF\u00b5 the size of the types at hand. In the present paper, we improve upon Glew s result by giving a decision \nalgorithm whose complexity is O(n log n). We are in fact able to settle a more general question: does \nan exten\u00adsion of equirecursive F\u00b5 with guarded algebraic data types,inthe style of Xi et al. [22], have \ndecidable typechecking? Such a type system is not of purely theoretical interest: for instance, it could \nbe a component of a type-preserving compiler whose front-end im\u00adplements a typical object encoding, requiring \nuniversal types and recursive types, and whose back-end performs defunctionalization in the style of \n[18], requiring guarded algebraic data types. The key issue is then to decide whether two F\u00b5 types are \nequal under a num\u00adber of equality hypotheses, that is, to decide whether a conjunction of type equations \nentails another type equation. To the best of our knowledge, this issue has never been studied before. \nIn the present paper, we show that it can be decided in time O(nlogn), where n is the size of the input \nproblem. Our solution to the entailment problem is via a reduction to the uni\u00ad.cation problem. That is, \nwe are able to determine whether two F\u00b5 types are uni.able in time O(nlogn). This result could have impli\u00adcations \nin the area of (partial) type inference for F\u00b5. It may also be used to implement hash-consing of second-order \nrecursive types, a technique that so far has been studied for .rst-order recursive types only [6]. In \nfact, our algorithm for unifying F\u00b5 types has already found an initially unexpected application. We discovered, \nduring a conversa\u00adtion with Jacques Garrigue, that OCaml s type inferencer requires such an algorithm, \nbecause object types may be recursive and may contain polymorphic methods. Upon close examination, the \nuni.\u00adcation algorithm that has been employed by the OCaml compiler for several years was found to be \nunsound. It should soon be re\u00adplaced with a version of the one described in this paper [Garrigue, personal \ncommunication].  2 Types and type equality in F\u00b5 In this section, we de.ne the problem and highlight \nsome of its subtleties. We explain how the decision problems for type equality in F and F\u00b5 have been \ndealt with in the literature, and give an outline of our solution. 2.1 De.nition The syntax of types \nin our version of F\u00b5 appears in Figure 1. For the sake of clarity, we distinguish variables a,\u00df,.,..., \nwhich are bound by \u00b5,and atoms a,b,c,d,..., which are bound by .. Variables and atoms are drawn from \ntwo disjoint, denumerable sets. The free variables fv(t) and the free atoms fa(t) of a type t are de.ned \nin the usual way. We identify types modulo a-equivalence of variables and atoms. A type is atom-closed \nif and only if it has no free atoms. We let T range over an arbitrary set of type constructors, each \nof which is equipped with a nonnegative integer arity. In the nota\u00adtion TTt, the length of the vector \nof typesTt is implicitly assumed to match the arity of T . In several examples, we employ the type constructor \n., of arity 2, whose applications are written in.x. Following common practice, we combine the \u00b5 quanti.er \n(which forms recursive types) with type constructor applications and with the .quanti.er. By not making \nt := \u00b5a.t a production of the gram\u00admar, we disallow meaningless types such as \u00b5a.a. For the sake of readability, \nwe write TTt for \u00b5a.TTt when a does not appear free in Tt,and .a.t for \u00b5a..a.t when a does not appear \nfree in t. In standard presentations of F\u00b5, the distinction between variables and atoms is not made. \nAs a result, a standard F\u00b5 type must undergo a simple translation step in order to .t our formalism. \nThe transla\u00adtion is straightforward: universally bound type variables become atoms, while \u00b5-bound and \nfree type variables remain variables. For instance, the standard F\u00b5 type \u00b5a.\u00df ..\u00df.a .\u00df .. is written \n\u00b5a.\u00df ..b.a .b .. in this paper. It is important to remark that the image of a standard F\u00b5 type under \nthis translation is atom-closed by construction. For this reason, the input of the decision problems \nstudied in this paper, such as equality and uni.ability, is restricted to consist of atom-closed types. \nAlso, two types are considered uni.able if and only if they admit an atom\u00adclosed uni.er. Note, however, \nthat the subterms of an atom-closed type are not in general atom-closed. It is also worth noting that, \nunder this translation, the images of the standard types t and .a.t may differ at arbitrarily deep locations. \nFor instance, the image of a .a is a .a, while the image of .a.a .a is .a.a .a. Thus, in standard F or \nF\u00b5, constructing .a.t given t requires constant time, whereas, in our formalism, constructing a representation \nof .a.t given a representation of t is not a constant time operation. A substitution is a total mapping \nof variables to types. The domain of . is the set of variables a where a and .(a) differ. We write {a \n.t} for the substitution that maps a to t and is the identity elsewhere. A substitution may be viewed \nas a total mapping of types to types, in the usual, capture-avoiding, manner. Types are .nite terms with \nbinders. As a result, mathematical equal\u00adity of types, which we write =, incorporates a-equivalence of \nvari\u00adables and atoms, but does not treat \u00b5 binders in a special way. In or\u00adder to obtain an equirecursive \n.avor of F\u00b5, one must de.ne a more permissive notion of type equality, incorporating folding and un\u00adfolding \nof recursive types. This new equivalence relation, which we write = \u00b5a, is coinductively de.ned by the \nrules in Figure 2. The de.nition of = \u00b5a is entirely standard. (For background reading on recursive types \nand coinduction, we refer the reader to [1, 2, 10].) Relations are extended to vectors in a pointwise \nmanner, so that Tt = \u00b5a Tt' means that, for every index i,the i-th components of the .a .a  . .  a \n.b .= \u00b5a a .b .. aa .a . a Figure 3. Subtleties of type equality vectorsTt and Tt ' are in the relation \n= \u00b5a. The effect of the last rule is to unfold the outermost \u00b5 binders, exposing a pair of universal \ntypes, whose bodies are then compared. For the sake of simplic\u00adity, the rule requires the universal quanti.ers \non either side of the equality to share a common naming convention, that is, to bind the same atom a. \nBecause types are identi.ed modulo a-equivalence of atoms, this does not incur any loss of generality: \nit is possible to formulate an equivalent rule, where this requirement is removed, and where the premise \nincorporates an explicit renaming of atoms. It is straightforward to establish the following facts: substitution \npreserves equality; equality preserves free atoms; substitution pre\u00adserves or increases free atoms. Lemma \n2.1 t = \u00b5a t' implies .t = \u00b5a .t' . . Lemma 2.2 t = \u00b5a t' implies fa(t)=fa(t'). . Lemma 2.3 fa(t).fa(.t). \n.  2.2 Some subtleties of type equality Although the de.nition of = \u00b5a is simple, one must proceed with \ncaution: it is easy to form misleading intuitions about it. Part of its subtlety is illustrated in Figure \n3, which contains graphi\u00adcal representations of the types t1 =\u00b5\u00df..a.a ..b.a .\u00df and t2 =.a.a .\u00b5\u00df..b.a \n..a.a .\u00df. (This example is adapted from [13].) These types are not in the relation = \u00b5a, even though \none might believe, at .rst sight, that their in.nite unfoldings coin\u00adcide. Let us have a closer look. \nAn unfolding of t2 is .a.a ..b.a ..c.a .\u00b5\u00df..b.a ..a.a .\u00df. Starting from the left, examine the third universal \nquanti.er: is this what you expected? Here is what happened. Because the atom a ap\u00adpears free in the \nterm \u00b5\u00df..b.a ..a.a .\u00df, and because \u00df appears inside the scope of a .a quanti.er in the term .b.a ..a.a \n.\u00df, computing a correct unfolding requires an a-conversion step, so as to avoid capture. Here, the innermost \n.a quanti.er in t2 was changed into .c, which explains the result. Computing an unfolding of t1 is more \nstraightforward. Indeed, since t1 is atom-closed, there is no danger of capture. We .nd .a.a ..b.a .\u00b5\u00df..a.a \n..b.a .\u00df, which, by a-equivalence, may be written .a.a ..b.a .\u00b5\u00df..c.a ..b.c .\u00df. Let us now place the \nunfoldings of t1 and t2 next to each other: .a.a ..b.a .\u00b5\u00df..c.a ..b.c .\u00df .a.a ..b.a ..c.a .\u00b5\u00df..b.a ..a.a \n.\u00df It is now clear that these types are not in the relation = \u00b5a. Indeed, starting from the left and \nuntil the fourth universal quanti.er, these types offer a common structure. However, at that point, the \nformer exhibits an occurrence of the atom c, whereas the latter exhibits an occurrence of a. In short, \nthe (incorrect) intuition that t1 and t2 are related by = \u00b5a stems from the mental use of a capturing \nsubstitution. By na\u00a8ively unrolling the loop in t2, we bring an occurrence of the atom a into the scope \nof the innermost .a quanti.er, within which it initially did not lie: indeed, the scope of a .quanti.er \ndoes not extend through a reverse edge. This fact is obvious when examining syntactic rep\u00adresentations \nof types for instance, in \u00b5\u00df.a ..a.\u00df, the scope of .a is \u00df alone, and does not include the occurrence \nof a to its left, which is free but is perhaps less so when thinking in terms of graphs. 2.3 Deciding \ntype equality: the state of the art The above example illustrates some of the dif.culties that arise \nwhen comparing two types for equality. First, one must really com\u00adpare the in.nite unfoldings of the \ntypes at hand. Second, renamings of atoms are involved, for two reasons: (i) unfolding recursive types \ninvolves capture-avoiding substitutions, and (ii) comparing two uni\u00adversal types requires ensuring that \nthe bound atoms match. The decision problem for type equality has been investigated by Glew [13]. He \nencodes types as ad hoc automata, which may also be viewed as graphs somewhat analogous to those found \nin Fig\u00adure 3, and gives an algorithm that decides type equality. Roughly speaking, Glew s algorithm checks \nfor the existence of a bisimula\u00adtion relating two automata. In terms of graphs, this process could be \ndescribed as follows. The two graphs are traversed synchronously. When reaching two nodes labeled with \nuniversal quanti.ers, say .a and .b, one keeps track of the correspondence between the atoms a and b, \nso that, when later reaching two leaf nodes labeled with the atoms a and b, they are (correctly) viewed \nas related. Glew uses partial bijections to keep track of this correspondence. Because both the number \nof partial bijections that may be constructed and the number of pairs of nodes that may be visited are \n.nite, the al\u00adgorithm terminates. However, the number of partial bijections is in fact exponential in \nn, where n is the size of the input problem. For\u00adtunately, thanks to a more clever abrupt termination \ncriterion, Glew is able to achieve time complexity O(n2). It is worth recalling that, in system F (that \nis, in the absence of re\u00adcursive types), types can be compared in time O(n), provided they are represented \nusing a De Bruijn encoding. The cost of converting a nameful representation into a De Bruijn encoding \nis O(nlog n), assuming some .avor of balanced trees is used to map atoms to in\u00adteger indices. (The expected \ncost can be brought down to O(n)by using hash tables instead of balanced trees.) This approach is used \nin many typecheckers for F; see, for instance, [17, Chapter 25]. In the presence of equirecursive types, \nhowever, De Bruijn indices become more dif.cult to manipulate. For instance, successive un\u00adfoldings of \na type may cause an ever-growing sequence of indices to appear, leading to an in.nite, irregular .rst-order \nterm: see [13, Section 3.1]. To the best of our knowledge, the practical use of a De Bruijn encoding \nin such a setting has never been investigated. Glew does consider in.nite trees that contain De Bruijn \nindices, but only as a mathematical model, as opposed to an implementation scheme. To sum up, the current \nstate of the art is as follows: although type equality has worst-case time complexity O(n log n) in F, \nthe best known algorithm for F\u00b5 runs in time O(n2). Why such a gap? Should equirecursive types really \nbe so expensive? In the follow\u00ading, we answer in the negative.  2.4 Our approach The strength of the \nclassic De Bruijn encoding lies in the fact that it provides .rst-order canonical forms of types: two \nF types are equal, up to a-equivalence of atoms, if and only if their De Bruijn encodings, which are \n.rst-order terms, are syntactically equal. We propose to proceed in a similar manner: to every F\u00b5 type, \nwe associate a .rst-order recursive term, where atoms are replaced with suitable natural integers. The \nstructure of the input type, including its \u00b5 binders, is preserved, so that the encoding s output may \nin fact be viewed as an in.nite,but regular, .rst-order tree. The key trick is to choose the numbering \nof atoms in such a way that the encoding is canonical: we prove that two F\u00b5 types are related by = \u00b5a \nif and only if their encodings, viewed as regular .rst-order trees, are equal. The manner in which we \nnumber atoms appears to be original, and is unrelated to De Bruijn s scheme. We prove that, by using \nappropriate data structures, the time com\u00adplexity of computing a type sencodingis O(n log n). Furthermore, \na standard .rst-order uni.cation algorithm such as Huet s [14] al\u00adlows testing two recursive .rst-order \nterms for equality in time O(na(n)). There follows that type equality in F\u00b5 has time com\u00adplexity O(n \nlog n). The problem of determining whether two F\u00b5 types are uni.able is addressed in the same manner: \nit is reduced, via the encoding, to uni.cation of .rst-order recursive terms.  2.5 Related work Colazzo \nand Ghelli [4] study the decision problem for the subtyping relationship in an extension of Kernel Fun \nwith equirecursive types, and .nd it to be decidable. This implies that type equality in F\u00b5 is decidable \nas well. The time complexity of their algorithm appears to be unknown. Glew s work [13] was mentioned \nabove. He studies type equality in F\u00b5 and gives an algorithm whose time complexity is quadratic. The \nproblem of determining whether two F\u00b5 types are uni.able may be turned, in a very simple manner, into \na nominal uni.cation prob\u00adlem [21], provided nominal uni.cation is extended with support for recursive \nterms, which appears straightforward. However, neither we nor Urban [personal communication] are currently \nable to for\u00admulate a nominal uni.cation algorithm whose time complexity is less than O(n2). We solve \nthe uni.cation problem for F\u00b5 types, which we refer to as second-order recursive types and which Glew \nrefers to as second-order trees. Yet, the present paper has nothing to do with second-order uni.cation \n[8]. Here, we are interested in uni.cation modulo = \u00b5a, that is, modulo a-equivalence of atoms and folding \ns := a (variable) | a (atom) | \u00b5a.(a)TTs (term constructor application) | \u00b5a.(a). s (idem) Figure 4. \nFirst-order recursive terms a = \u00b5 a a = \u00b5 a {a . \u00b5a.(a)TTs}Ts = \u00b5 {a'. \u00b5a' .(a)TTs'}Ts' \u00b5a.(a) TTs = \n\u00b5\u00b5a' .(a)TTs' {a . \u00b5a.(a). s}s = \u00b5 {a'. \u00b5a' .(a). s'}s' \u00b5a.(a). s = \u00b5\u00b5a' .(a). s' Figure 5. Equality \nof .rst-order recursive terms and unfolding of recursive types. Second-order (or higher-order) uni.cation \nconsists in unifying simply-typed .-terms modulo \u00df.\u00adequivalence, and is undecidable.  3 A .rst-order \nencoding of F\u00b5 types In this section, we encode second-order recursive types (types for short) into a \nparticular class of .rst-order recursive terms (terms for short). 3.1 First-order recursive terms We \n.rst de.ne the target space of the encoding, that is, the syntax of the .rst-order terms s that we use \nto encode types. It appears in Figure 4. As before, terms include variables and atoms, and variables \nmay be \u00b5-bound at a constructor application node. The essential difference with respect to the syntax \nof types, which was given in Figure 1, lies in the treatment of atoms. Here, applications of the constructors \nT and . are annotated with an atom (a),but do not bind it: that is, a occurs free in both \u00b5a.(a)TTs and \n\u00b5a.(a). s. As a result, atoms are never bound: all of the atoms that occur in a .rst-order term s occur \nfree in s. The constructor . no longer plays a special role: it is simply a unary term constructor. We \nequip terms with a notion of equality, written = \u00b5, whose coin\u00adductive de.nition appears in Figure 5. \nIt is the standard notion of equality for .rst-order recursive terms: it only accounts for a\u00adequivalence \nof variables and for folding and unfolding of \u00b5 binders. In other words, two terms are related by = \u00b5 \nif and only if their in.nite unfoldings, which are regular trees, coincide. In the third and fourth rules \nin Figure 5, the same atom (a) must appear on ei\u00adther side of the equality: since atoms are never bound, \nno implicit a-conversion step is allowed. To complete the de.nition of terms, we must be more speci.c \nabout the nature of atoms. Here is why. In the type .a.a, the atom a is bound: this type may also be \nwritten .b.b. However, at the level of terms, atoms are free, so they are observable: if a and b are \ndistinct atoms, then the terms (a). aand (b). b are distinct. As a result, our encoding, whose purpose \nis to produce canonical forms, must be able to perform a deterministic choice between the two. If atoms \nwere interchangeable for all purposes, as is usually the case, such a choice would be impossible [9, \nRemark 4.6]. Thus, we must impose some more structure on the set of atoms. N(.,a)=a N(.,a)=a N(.,\u00b5a.TTt)=\u00b5a.(a)TN(. \n.{a .a},Tt) if a =max fa(.(\u00b5a.TTt)) N(.,\u00b5a..(a +1).t)=\u00b5a.(a). N(. .{a .a},t) if a =max fa(.(\u00b5a..(a +1).t)) \nN(t)=N(id,t) Figure 6. The encoding It is convenient to identify atoms with natural integers, so that \natoms are totally ordered and have a successor function. From here on, we adopt this convention. At the \nlevel of types, this decision has no impact: because types are identi.ed modulo a-equivalence of atoms, \nand because, at the end of the day, we are only interested in atom-closed types, atoms are still used \nas interchangeable names. At the level of terms, atoms are never bound, so their identity is ob\u00adservable, \nand they really are numbers. In other words, the purpose of our encoding is to map names to numbers. \n 3.2 The encoding We are now ready to present the encoding. Let us recall that it is a function N of \ntypes to terms, and that we intend it to de.ne canonical forms, that is, we intend t = \u00b5a t' to be equivalent \nto N(t)=\u00b5N(t'). The de.nition of the encoding appears in Figure 6. We .rst de\u00ad.ne a function N of two \nparameters, namely, a substitution . and a type t. The substitution . is used to associate information \nwith \u00b5-bound variables. It is initially empty: we de.ne N(t)as a short\u00adhand for N(id,t), where id is \nthe identity substitution. When t is nonrecursive, the parameter . is irrelevant and may be ignored. \nWe recommend doing so upon .rst reading of the equations in Figure 6. To begin, note that the encoding \nis structure-preserving: every vari\u00adable is mapped to itself, every atom is mapped to an atom, and ev\u00adery \nconstructor application is mapped to an application of the same constructor. In other words, the sole \neffect of the encoding is to .x the numbering of atoms. One might wonder how it is possible for the encoding \nto impose a numbering of atoms, since the second equation in Figure 6 seems to state that every atom \nis mapped to itself. The truth is, it only states that an atom is mapped to itself if it appears at the \nroot of the type. More generally, it is possible to check that every atom that occurs free in the original \ntype is mapped to itself by the encoding. Such a fact is, however, of little value, because, in the end, \nwe are interested in atom-closed types, which have no free atoms. So, the key question is, how does the \nencoding deal with bound atoms? To answer this question, let us examine the encoding of universal types, \nwhich bind atoms. Because the encoding must be canoni\u00adcal, = \u00b5a-equivalent types must be mapped to = \n\u00b5-equivalent terms. For instance, the types t1 =\u00b5a..a.a . c .a and t2 =.b.b . c .\u00b5a..a.a .c .a, which \nare = \u00b5a-equivalent, must receive = \u00b5 \u00adequivalent encodings. This requires agreeing on a common name \nd for the atom that is bound at their root. By a-conversion, t1 and t2 may be written \u00b5a..d.d .c .a and \n.d.d .c .\u00b5a..a.a .c . a, respectively, where d is any atom other than c, since c occurs free in t1 and \nt2 and must not be captured. In order to choose d .a (0).    . (1). .c .b (1). (0). .. (2). (1). \n  acb 121 Figure 7. A type and its encoding in a deterministic manner, we let d be the successor of \nc. Because atoms are natural integers, this de.nition makes sense. ' In the general case, when encoding \na universal type .a .t, we re\u00ad quire the bound atom a' to be the successor of the greatest atom ' that \noccurs free in .a .t. In other words, we require a' to be a +1, ' where a is max fa(.a .t). (By convention, \nmax .is0.) Ifa' does not meet this requirement, then an a-conversion step must be per\u00ad ' formed. Because, \nby construction, a+1 does not occur free in .a .t, such a step must be possible, which means that, in \nspite of this re\u00adquirement, the encoding remains a total function. Also, it is impor\u00adtant to keep in \nmind that, if two types t and t' are related by = \u00b5a, then their sets of free atoms must coincide, so \nthe atoms max fa(t) and max fa(t')must coincide as well. This is key to proving that the encoding maps \n= \u00b5a-equivalent types to = \u00b5-equivalent terms. To sum up the idea exposed in the previous paragraph, \nhere is a simpli.ed version of the fourth equation in Figure 6, which makes sense when types are nonrecursive. \nThen, \u00b5 binders disappear, and the substitution . is suppressed: N(.(a +1).t)=(a). N(t) if a =max fa(.(a \n+1).t) The effect of the side condition is to determine the value of a. For readers who .nd its apparently \ncircular formulation mysteri\u00adous, here is an equivalent version where the required a-conversion step \nis made explicit: N(.b.t)=(a). N({b .a +1}t) if a =max fa(.b.t) In short, to encode .b.t, one computes \nthe greatest atom a that occurs free in .b.t, renames b to a +1in t, and proceeds with the encoding of \n(the renamed version of) t. To complete our explanation of the fourth equation in Figure 6, we must describe \nthe machinery that deals with recursive types. As pointed out earlier, the encoding is structure-preserving: \nevery \u00b5 binder and every variable is kept unchanged. There is only one subtlety: when computing the set \nof free atoms at a certain node in the input type, one must account for the free atoms contributed by \nthe reverse edges that point back above that node. Consider, for instance, the type .a.t, where t stands \nfor \u00b5a.a ..b.b .a.(A graphic representation appears in Figure 8.) Strictly speaking, we have fa(.b.b \n.a)=., so b can safely be renamed to any atom, including a. However, an unfolding of t is a ..b.b .t, \nwhere b cannot be renamed to a, because fa(.b.b .t)is {a}. We claim that it is necessary to rename b \nin a manner that is correct not only with respect to t, but also with respect to all of its unfoldings. \n(We come back to this point in \u00a75.) For this reason, when computing the free atoms of .b.b .a, one should \nnot view a as a leaf that has no free atoms. Instead, one should follow the reverse edge from a to t, \nand, since fa(t)is {a}, consider that a contributes the free atom .a (0) .   . (1) .  a .b1 (1) . \n . (2) . b2 Figure 8. A type and its encoding a. By proceeding in such a manner, one is lead to renaming \nb to the successor of a, a choice that is safe with respect to all unfoldings of t. Technically, this \nidea is implemented as follows. When examining the node t = \u00b5a...., we evaluate max fa(t), yielding a. \nThen, we create the substitution . = {a .a}, so as to record the fact that every occurrence of a stands \nfor a type whose greatest free atom is a. (One could equivalently de.ne . as {a .t}; see Lemma 4.1.) \nUpon reaching the node .b....,we compute maxfa(.(.b.b .a)), which due to the presence of . is a, and \nconclude that b should be renamed to the successor of a. This explains the role of . in the de.nition \nof N. The third equation in Figure 6 is analogous to the fourth one. Be\u00adcause nodes of the form \u00b5a.TTt \ndo not bind atoms, no a-conversion takes place. We simply update . as above. Example Figure 7 depicts \nthe type t = \u00b5a..a.(.c.a . c) . .b.b .a and its image through N. Here is how the latter is com\u00adputed. \nBecause t has no free atoms, its root node is annotated with (0), and the atom a is renamed to 1. (In \nparticular, observe that the right-hand term s leftmost leaf is 1.) Then, one moves down to the next \nnode, an arrow constructor. Its only free atom is a, that is, 1, so it is annotated with (1), and one \nmoves down to its children, which are respectively labelled .c and .b. As for the former, the greatest \nfree atom of .c.a .c is a, that is, 1, so the . node is annotated with (1), and c is renamed to 2. As \nfor the latter, there are no free atoms below this node (the reverse edge does not contribute any, because \nt is atom-closed), so it is labeled with (0), and b is renamed to 1. . Example Figure 8 depicts the type \nt = .a.\u00b5a.a ..b.b .a and its image through N. Here is how the latter is computed. As in the previous \nexample, t is atom-closed, so its root node is labeled (0), the atom a is renamed to 1, and the topmost \narrow node is labeled (1). Let us now consider the arrow s right child, a . node. Its greatest free atom \nis a, which is contributed by the reverse edge. As a result, the . node is annotated with (1), and b \nis renamed to 2. .  4 Correctness of the encoding w.r.t. equality When computing the greatest free \natom of some type, replacing a subtree with its own greatest free atom does not affect the end result. \nLemma 4.1 Ifais max fa(.t'),then max fa(.{a . t'}t) and max fa(.{a .a}t) coincide. . The encoding commutes \nwith substitutions of types for type vari\u00adables. This is a key property. Lemma 4.2 If a is max fa(.t'), \nthen N(.,{a . t'}t) is {a . N(.,t')}(N(. .{a .a},t)). . Proof. Assume a = maxfa(.t') (1). The proof \nis by structural in\u00adduction on t. The result is immediate when t is avariableoran atom. We omit the case \nwhere t is the application of a type con\u00adstructor T , because it is subsumed by the last case, where \nt is a universal type. Thus, we focus on the last case. We may assume a .fv(t) (2), since the result \nis otherwise immediate. Let b stand for max fa(.{a . t'}t). By Lemma 2.3, we have b = max fa({a . t'}t) \n(3). By Lemma 2.3 again, (3) implies b = max fa(t), whence b + 1 .. fa(t) (4). Furthermore, we let the \nreader check that (3) and (2) imply b = max fa(t'), whence b + 1 .. fa(t') (5). Last, by Lemma 4.1 and \nby (1), we have b = max fa(.{a .a}t) (6). Because t is a universal type, and by (4), we may write t under \nthe form \u00b5\u00df..(b + 1).t1(7), where \u00df .. = a (8)and \u00df .fv(t') (9) hold. Then, thanks to (9), (8), and (5), \n{a .t'}t is \u00b5\u00df..(b + 1).{a . t'}t1(10). Let .' stand for . .{\u00df .b}. By (9), we have .t' = .'t', which \ntogether with (1) implies a = maxfa(.'t') (11). Also by (9), we have N(.' ,t')= N(.,t') (12), and \u00df ..fv(N(.,t')) \n(13). We may now proceed as follows: = N(.,{a .t' }t) N(.,\u00b5\u00df..(b + 1).{a .t' }t1) by (10) = \u00b5\u00df.(b). N(.' \n,{a .t' }t1) by de.nition of b and .' = \u00b5\u00df.(b). .{a .N(.' ,t')}(N(.' .{a .a},t1)) by (11) and by the \ninduction hypothesis = {a .N(.,t')}(\u00b5\u00df.(b). N(.' .{a .a},t1)) by (12), (8), and (13) = {a .N(.,t')}(N(. \n.{a .a},t)) by (7), (6), (8), and by de.nition of .' . We now reach the main theorem: Theorem 4.3 Let \n. be arbitrary. Then, t = \u00b5a t' is equivalent to N(.,t)=\u00b5N(.,t'). . Proof. We .rst prove the left to \nright implication. The proof of the right to left implication, which is analogous, is omitted so as to \nconserve space. Throughout, . is arbitrary and .xed. Let R be the relation between terms de.ned by N(.,t) \nRN(.,t') if and only if t = \u00b5a t'. Our goal is to prove that R is a subset of = \u00b5. By the coinduction \nprinciple, it suf.ces to prove that R is consistent [10] with respect to the rules in Figure 5, that \nis, to establish R .E\u00b5R, where E\u00b5 is the monotone function from relations to relations implicitly associated \nwith the rules in Figure 5. Thus, let t = \u00b5a t' (1). Our goal is to prove that the pair (N(.,t),N(.,t')) \nmay be deduced, via one of the rules in Figure 5, from pairs that are members of R. We reason by cases \non the structure of t and t'. The cases where t and t' are variables or atoms are immediate. The case \nwhere they are applications of a type constructor T is subsumed by the last case, where they are universal \ntypes. Thus, we focus on the last case. Let a stand for max fa(.t) (2). By Lemma 2.3, we have a = max \nfa(t), whence a + 1 ..fa(t) (3). By (1) and by Lemmas 2.1 and 2.2, we also have a = max fa(.t') (4) and \na + 1 ..fa(t') (5). By (3) and (5), we may write t and t'under the form \u00b5a..(a + 1).t1 and \u00b5a..(a + 1).t' \n1, respectively. By de.nition of = \u00b5a, we then have {a .t}t1 = \u00b5a {a .t'}t' (6). By de.nition of N and \n1 by (2), N(.,t) is \u00b5a.(a). N(. .{a .a},t1). Similarly, N(.,t') is \u00b5a.(a). N(. .{a .a},t' 1). Thus, by \napplying the last rule in Figure 5, the goal becomes to prove that the terms {a . N(.,t)}(N(. .{a . a},t1)) \nand {a . N(.,t')}(N(. .{a . a},t' 1)) are related by R. By (2), (4), and Lemma 4.2, these terms are precisely \nN(.,{a .t}t1) and N(.,{a .t'}t' 1). By (6) and by de.nition of R, they are related by R. . As an immediate \ncorollary, we obtain: Theorem 4.4 t = \u00b5a t' is equivalent to N(t)=\u00b5N(t'). . Theorem 4.4 yields a new \ndecision procedure for type equality in F\u00b5. Indeed, whether two .rst-order recursive terms are related \nby = \u00b5 may be decided in time O(na(n)), using a standard .rst-order uni.cation algorithm, such as Huet \ns [14]. Thus, in order to obtain an ef.cient decision procedure for = \u00b5a, there only remains to .nd an \nef.cient method for computing N. This is the topic of \u00a77.  5 Correctness of the encoding w.r.t. uni.ability \nWe have shown that the encoding allows reducing the equality prob\u00adlem from the second order to the .rst \norder. We would now like to generalize this result to the problem of uni.cation. We begin with a few \nde.nitions. A (type) substitution . is atom\u00adclosed if and only if every type in its image is atom-closed. \nAn atom-closed substitution . uni.es t and t' if and only if .t = \u00b5a .t' holds. t and t' are uni.able \nif and only if some atom-closed substitution . uni.es them. A (term) substitution . uni.es s and s' if \nand only if .s = \u00b5 .s' holds. s and s' are uni.able if and only if some substitution . uni.es them. A \nkey property, which follows directly from Lemma 4.2, is the following: if t' is atom-closed, then N({a \n. t'}t) is {a . N(t')}N(t). More generally, the encoding commutes with atom\u00adclosed substitutions, as \nstated by the following lemma. We write N(.) for the image of . through the encoding, de.ned as the sub\u00adstitution \nthat maps every variable a to the term N(.a), and lifted to a function of terms to terms in the standard \nway. (It must not be confused with N .., a function from types to terms.) Lemma 5.1 If . and t are atom-closed, \nthen N(.)(N(t)) is N(.t). . This lemma is the main reason why it is meaningful to attempt to unify encodings \nof types. It immediately allows proving the .rst result of this section: Theorem 5.2 Let t and t' be \natom-closed. If . uni.es t and t' , then N(.) uni.es N(t) and N(t'). . Proof. Let t and t' be atom-closed. \nAssume . uni.es t and t'.By de.nition, . is assumed to be atom-closed, and .t = \u00b5a .t' holds. Then, we \nhave N(.)(N(t)) = N(.t) by Lemma 5.1 = \u00b5N(.t') by Theorem 4.3 = N(.)(N(t')) by Lemma 5.1 . In words, \nif two types are uni.able, then so are their encodings. Q(a)= a Q(a)= a Q(\u00b5a.(a)TTs)= \u00b5a.TQ(Ts) Q(\u00b5a.(a). \ns)= \u00b5a..(a + 1).Q(s) Figure 9. The decoding Now, we would like to prove a converse of this theorem, \nthat is, to deduce second-order uni.ability from .rst-order uni.ability. Let s look at a few examples, \nto help develop an intuition. Suppose we wish to know if .a.a .\u00df and .a.a ..b.b are uni.able. Encoding \nthese types yields a .rst-order uni.cation problem: (1)(1) (0). (1 .\u00df)=? (0). (1 .(0). 1), whose most \ngeneral uni.er is {\u00df . (0). 1}. Applying a de\u00adcoding to this term substitution, we obtain the type substitution \n{\u00df ..b.b}, wich uni.es the initial problem, and is indeed its most general uni.er. The decoding Q, which \nwe have alluded to above, is de.ned in Figure 9. Its de.nition is extremely simple. Atoms and variables \nare preserved. At constructor application nodes, the annotation (a) is erased. At . nodes, a universal \nquanti.er is re-introduced, with the convention that the bound atom is a + 1. The next lemma states that \nthe decoding Q is indeed the inverse of the encoding. Lemma 5.3 Q(N(t)) is t. . If . is a term substitution, \nwe de.ne its image through the decoding Q(.) as the type substitution that maps a variable a to Q(.a).It \nis lifted to a function of types to types in the standard way. (Again, it must not be confused with Q \n.., a function from terms to types.) The last example was extremely simple. Unfortunately, things do \nnot always work out so easily: two non-uni.able types may have uni.able encodings. Consider, for example, \nthe unsatis.able prob\u00adlem .a.a .\u00df =? .a.a .a. Its image through the encoding is (1)(1) (0). (1 .\u00df)=? \n(0). (1 .1), whose most general uni.er is {\u00df .1}. Applying Q to this term substitution, we obtain {\u00df \n.1}, a type substitution that is not atom\u00adclosed, and that does not solve the original uni.cation problem. \nThis example suggests that a .rst-order uni.er is no good unless its image through Q is atom-closed. \nLet us call atom-friendly a term, or term substitution, whose image through Q is atom-closed. We will \neventually prove that the existence of an atom-friendly .rst-order uni.er does imply that of a second-order \nuni.er. However, this intuitive result hides a technical dif.culty: the de\u00adcoding Q does not preserve \nequality, that is, s = \u00b5 s' does not im\u00adply Q(s)=\u00b5a Q(s'). Consider, for example, the terms and types \nin Figure 10. The term s at upper left is such that the decoding of an unfolding of s (lower right) is \nnot = \u00b5a-equivalent to the decoding of s (upper right). The problem is that a valid .rst-order unfolding \nstep may, due to capture, correspond to an invalid second-order un\u00adfolding step. In other words, the \nimage through Q of a .rst-order uni.er is not necessarily a second-order uni.er! It is worth noting that, \nfor terms that lie in the image of N, the decoding does preserve equality. This is a consequence of Theorem \n4.4 and Lemma 5.3. Thus, the term s at upper left in Fig\u00adure 10 is not in the image of N. Indeed, it \nis not the encoding of (0) . .a  (1) . . Q 1 (0) . -. a .a (1) .. 1a = \u00b5 . = \u00b5a (0) . .a (1) .. \n Q 1 (0) . -. a .a (1) ..   1 (1) . a .  1 (0) . a .a (1) .. 1a Figure 10. Term unfolding versus \ntype unfolding a > 0 ta(.Ts) =a . .{a .a}fTs wf . fa wf . fawf . f\u00b5a.(a)TTs wf ta(.s) =a + 1 . .{a .a}fs \nwf . f\u00b5a.(a). s wf Figure 11. Well-formed terms the type t that appears left in Figure 8, even though \nt is Qs.The presence of the reverse edge is the reason why b was numbered 2, instead of 1, in Figure \n8, and it is also the cause of the problem in Figure 10. This is not fortuitous: the encoding was designed \nto avoid producing problematic terms such as s. In the following, we identify a subset of the terms where \nQ does preserve equality. We refer to these terms as cycle-friendly.Fur\u00adthermore, we prove that every \nterm is related by = \u00b5 to some cycle\u00adfriendly term. This allows us to argue that, if a .rst-order uni.ca\u00adtion \nproblem admits a uni.er, then it admits a cycle-friendly uni.er, which does give rise, through Q, to \na second-order uni.er. We now give the formal de.nitions and lemmas required to carry out the development \noutlined in the previous paragraphs. The end of this section is quite technical. Upon .rst reading, the \nreader might wish to skim through it and devote particular attention only to Theorems 5.18 and 5.19. \nThe top atom ta(s) of a term s is de.ned as follows: the top atom of a variable a is 0; the top atom \nof the terms a, \u00b5a.(a)TTs,and \u00b5a.(a). s is a. a ..domC a ..Ta a =Ta C fa cfr C fa cfr C;(a, a);(Ta,Ta) \nfa cfr C;(a, a) fTs cfr C; (a, a) fs cfr C f\u00b5a.(a)TTs cfr C f\u00b5a.(a). s cfr Figure 12. Cycle-friendly \nterms We continue with a notion of well-formedness for .rst-order terms, whose de.nition appears in \nFigure 11. (The substitution . is omit\u00adted in a judgement when it is the identity.) The interest of this \nnotion lies in the following lemma: when a term is well-formed, its top atom is an upper bound for the \natoms that occur free in its decoding. Lemma 5.4 fs wf implies max fa(Qs) =ta(s). . If s is well-formed, \nthen its atoms are required to be positive. Thus, if s is well-formed and has a null top atom, then no \natom can be free in Q(s). Well-formedness is a local property: it imposes constraints between the atom \ncarried by a node and those carried by its children. For this reason, it is preserved by several basic \noperations, such as unfolding and uni.cation. Lemma 5.5 s = \u00b5 s' and fs wf imply fs' wf. . Lemma 5.6 \nIf s and s' are well-formed, then so is their most gen\u00aderal uni.er, provided it exists. . Well-formedness \nleads to a generalized version of Lemma 5.3: Lemma 5.7 If . is well-formed and atom-friendly, then Q(.)(t) \nis Q(.(N(t))). . The de.nition of cycle-friendliness appears in Figure 12. The con\u00adtext C is a list of \ncouples (a, a). It is omitted in a judgement when it is empty. In words, a term is cycle-friendly if \nand only if, when\u00adever a reverse edge links a leaf a to some inner node \u00b5a.(a) ...,the atoms that lie \non the direct path from that node down to the leaf are greater than or equal to a. For instance, the \nterm at upper left in Figure 10 is not cycle-friendly, because its reverse edge points to a node labeled \n(1) and there is a node labeled (0) on the path down to the origin of the reverse edge. All terms that \nlie in the image of N are well-formed and cycle\u00adfriendly. Furthermore, under some conditions, these notions \nare preserved by substitution. Lemma 5.8 If t is atom-closed, then f N(t) wf and f N(t) cfr hold. . Lemma \n5.9 If . and s are well-formed and cycle-friendly, then so is .s. . We prove some auxiliary lemmas, by \ninduction: Lemma 5.10 (a, a);Ta,Ta f s cfr and a ..Ta and a . fv(s) imply a =Ta. . Lemma 5.11 (a, ta(s));Ta,Ta \nfs0 cfr and fs wf and a ..Ta imply {a .Q(s)}(Q(s0)) = Q({a .s}s0). . Lemma 5.12 C fs cfr and fv(s)nTa \n= .imply (Ta,Ta);C fs cfr.. (0) . (0) .  (1) . (1) . n \u00b7 1 (0) . -. 1 (0) .   (1) . (1) . 1 1 (1) \n. 1 Figure 14. Normalization example Lemma 5.13 f s cfr and f s' cfr imply f{a . s'} s cfr. . As claimed \nearlier, for terms that are (well-formed and) cycle\u00adfriendly, Q preserves equality. The proof is by coinduction, \nusing the previous lemmas. Lemma 5.14 Assume s and s' are well-formed and cycle-friendly. Then, s = \u00b5 \ns' implies Q(s)=\u00b5a Q(s' ). . A normalization function that maps an arbitrary term s to a = \u00b5 \u00adequivalent, \ncycle-friendly term [sDis de.ned in Figure 13. (Again, the context C is omitted when empty.) The idea \nbehind this de.\u00adnition is quite simple: the term is viewed as a graph and traversed until a friendly \ncycle is encountered. The .rst rule is the stopping criterion, which checks if we can add a reverse edge \nto a previously seen node without breaking cycle-friendliness. The other rules sim\u00adply explore and unfold \nthe term, while recording in the context the names of the encountered nodes. An example is given in Figure \n14, which shows the normalized version of the troublesome term of Figure 10. This de.nition is by well-founded \ninduction on a nonobvious order\u00ading. A proof is required to ensure that the de.nition is in fact valid. \nLemma 5.15 For every C and every s, [C, sDis well-de.ned. . As announced above, the properties of normalization \nare as follows. The .rst lemma is proved by induction, the second by coinduction. Lemma 5.16 f [sDcfr. \n. Lemma 5.17 [sD= \u00b5 s. . At last, we are ready to prove our second result: Theorem 5.18 Let t and t' \nbe atom-closed. If . is atom-friendly and uni.es N(t) and N(t' ), then t and t' are uni.able. . Proof. \nLet . be atom-friendly and satisfy .(N(t)) =\u00b5 .(N(t' )). We may assume, without loss of generality, that \n. is in fact the most general uni.er of N(t) and N(t' ): indeed, if some uni.er is atom-friendly, then \nthe most general uni.er must be atom-friendly as well. By Lemma 5.8, both N(t) and N(t' ) are well-formed \nand cycle\u00adfriendly. Thus, by Lemma 5.6, . is well-formed. Thanks to Lem\u00admas 5.16, 5.17, and 5.5, we may \nassume, without loss of generality, that . is also cycle-friendly. Then, by Lemma 5.9, .(N(t)) and .(N(t' \n)) are well-formed and cycle-friendly. We now check that Theorems 5.2 and 5.18 may be summed up as follows: \n Q(.) uni.es t and t' : Q(.)(t)= Q(.(N(t))) by Lemma 5.7 = \u00b5a = Q(.(N(t' ))) Q(.)(t' ) by Lemma 5.14 \nby Lemma 5.7 . Theorem 5.19 Let t and t' be atom-closed. t and t' are uni.able if and only if N(t) and \nN(t' ) are uni.able and their most general uni.er is atom-friendly. . Theorem 5.19 yields a decision \nprocedure for uni.ability of F\u00b5 types: to determine whether two types are uni.able, one encodes them, \nin time O(nlogn) (see \u00a77), uni.es them using a standard .rst\u00adorder recursive uni.cation algorithm, in \ntime O(na(n)), and checks that the most general uni.er is atom-friendly. By construction, the most general \nuni.er, if it exists, is well-formed. As a result, by Lemma 5.4, checking that it is atom-friendly amounts \nto checking that the top atom of every term in its image is zero. This check may be performed in time \nO(n). Thus, the time complexity of the overall process is O(n log n). In general, constructing the most \ngeneral uni.er of the original uni\u00ad.cation problem requires invoking the normalization function [ \u00b7D, \nwhose time complexity we have not yet assessed. 6 Correctness of the encoding w.r.t. entailment The \nentailment problem for type equations consists in deciding, given t,t' ,a,\u00df, whether, for every atom-closed \nsubstitution ., .t = \u00b5a .t' implies .a = \u00b5a .\u00df. When this property holds, we write t = t'|= a = \u00df. The \nentailment problem for equations between .rst-order terms, written s = s'|= a = \u00df,is de.ned analogously. \nBy exploiting the theory developed in \u00a75, it is not dif.cult to prove that the former may be reduced \nto the latter: Theorem 6.1 t = t'|= a = \u00df is equivalent to N(t)= N(t' ) |= a = \u00df. . The entailment problem, \nat the .rst order, may be decided in time O(na(n)), by exploiting the following property: s = s'|= a \n= \u00df holds if and only if either s and s' are non-uni.able or their most general uni.er . satis.es .a \n= \u00b5 .\u00df. As a result, the entailment problem, at the second order, may be decided in time O(nlog n), where \nO(n log n) is the cost of the encoding (see \u00a77). 7 Implementing the encoding The de.nition of N (Figure \n6) is a nice speci.cation of the encod\u00ading, but does not suggest an ef.cient implementation. Indeed, \nit suggests traversing the source type t, and, at every node t' , (i) com\u00adputing the greatest atom a \nthat occurs free in t' , taking reverse edges into account, and (ii) if an atom is bound here, renaming \nit to a + 1 throughout t' . The time required by this process is quadratic in the size of t. Fortunately, \nby proceeding in a more clever manner, it is possible to achieve a better complexity bound. This is the \ntopic of the present section. We .rst give a lower-level, but equivalent, de.nition of N. Then, we brie.y \ndescribe the data structures required to implement it ef.ciently. In order of applicability : [C,sD= \na if .a,s0 (s =a .s = \u00b5 s0) . C =(C ' ;a,s0;(Ta,Ts)) . ta(s0)= ta(Ts) [C,aD = a [C,aD= a if a ..domC \n= [C,sD if C =(C ' ;a,s;(Ta,Ts))and a ..Ta [C,sD= \u00b5a.(a)T [C;(a, s),TsD if s =\u00b5a.(a)TTs [C,sD= \u00b5a.(a). \n[C; (a, s), s' Dif s =\u00b5a.(a). s' Figure 13. Turning a term into a = \u00b5-equivalent, cycle-friendly term \n. := a | a | [p,n, n ']\u00b5a.(a)TT. | [p,n, n ']\u00b5a.(a). . Figure 15. Intermediate data structure 7.1 A \nlower-level de.nition of the encoding According to the de.nition of N, we need to compute, for each sub\u00adtree \nt, the atom maxfa .t, where . depends on the context above t and maps variables to atoms. In short, . \nrepresents the contribu\u00adtion of the reverse edges whose source node lies inside t and whose end node \nlies above t. A key idea is then to exploit the following identity: max fa(.t)=max {max fa t,max {.a/ \na . fv(t)}} In words, one may separately compute the greatest atom that ap\u00adpears free in t, on the one \nhand, and the contribution of the reverse edges that leave t, on the other hand. This suggests splitting \nthe encoding process into two distinct, con\u00adsecutive phases. The .rst phase annotates every node with \nthe great\u00adest atom that appears free below it, computed in a bottom-up man\u00adner. The second phase then \nexamines each node in a top-down fash\u00adion. Using the information gathered by the .rst phase, it is able \nto compute the contribution of the reverse edges, to assign the node its de.nitive name, and to propagate \nthis renaming information to\u00adwards its children. The two passes are de.ned in Figure 16. We now explain \nthem. 7.1.1 First pass The .rst pass is represented by the function fp. It accepts a 5\u00adtuple of the \nform (l,A, R,n, t) and returns a 4-tuple of the form (A, R,n, .). The input-output parameters A, R, and \nn may be im\u00adplemented using global, mutable variables. The .rst pass performs a depth-.rst traversal \nof t, the type to be encoded. Reverse edges are not traversed. Every atom or vari\u00adable encountered along \nthe way is numbered sequentially; we refer to these numbers as positions. The variable n, an integer \ncounter, holds the next unassigned position. After an atom a is found at po\u00adsition n, the association \nn . a is recorded. The variable A,apartial mapping of positions to atoms, is used for this purpose. After \na variable a is found at position n, the association a . n is recorded. The variable R, a relation between \nvariables and positions, is used for this purpose.  Upon entering a node t, the next unassigned position, \nthat is, the current value of n, is recorded; let us refer to it as n0. When later leaving the node, \nthe atoms that occur (free or bound) in t are ex\u00adactly the atoms whose position (as recorded in A) is \ngreater than or equal to n0. This is a start, but we need to determine the atoms that occur free in t. \nTo this end, we require bound atoms to satisfy a certain property, which one might think of as a reverse \nDe Bruijn numbering: the atom bound at a . node must be the node s level, where the level of a nodeisde.ned \nas the number of . nodes that lie on the path from the root to that node. Of course, the machine representation \nof the type that must be encoded may not satisfy this property, so it is renamed, on the .y, as part \nof the .rst pass. The parameter l is used to hold the current level. The last equation in the de.nition \nof fp has .l.t in its left-hand side, which means that whatever atom was bound here is renamed to l on \nthe .y. We now come back to the problem of determining the atoms that occur free under a node t. If the \nnode s level is l, then, by the above property, the free atoms of t are the atoms that occur in t and \nthat are less than l, that is, the atoms whose position is greater than or equal to n0 and that are less \nthan l. Thus, the greatest free atom under t may be written max{a/ (p . a). A.a < l . p = n0}. This explains \nwhy this expression appears in the third and last de.ning equations for fp. The .rst pass produces an \nannotated .rst-order term ., whose syn\u00adtactic category is de.ned in Figure 15. This grammar is reminis\u00adcent \nof that of Figure 4. In particular, every non-leaf node carries an annotation (a), which records the \ngreatest atom that appears free under that node. In preparation for the second pass, every node that \nbinds a variable a also records the positions p where a occurs. In other words, these are the origins \nof the reverse edges that lead to the present node. (In Figure 16, we write (a . p)for the relation that \ncontains (a . p)for every p . p.) Last, every non-leaf node ' records the positions n and n that delimit \nits subtree: the variables that occur in its subtree have positions in the interval [n, n '). 7.1.2 \nSecond pass The second pass is represented by the function sp. It accepts a 4\u00adtuple (l,F,f,.) and returns \na .rst-order term s. The parameter l plays the same role as in the .rst pass. The parameter f is a renam\u00ading \nof atoms. It explicitly records the a-conversion steps which, in the original de.nition of N, were implicit. \nRecall that we must compute, at each node, the maximum of (i) the greatest atom that occurs free in the \nsubtree rooted at this node, and (ii) the greatest atom contributed by the reverse edges that leave this \nsubtree.  fp(l,A,R,n,a)=(A,R .(a .n),n +1,a) fp(l,A,R,n,a)=(A .(n .a),R,n +1,a) fp(l,A0,R0,n0,\u00b5a.T t1 \n...tk)=(Ak,R ' ,nk,[p,n0,nk]\u00b5a.(a)T .1 ....k) a ..dom(R0) if (Ai,Ri,ni,.i)=fp(l,Ai-1,Ri-1,ni-1,ti) for \ni .{1,...,k}and R '.(a . p)=Rk a ..dom(R ') and a =max {a /(p .a).Ak .a < l .p =n0}fp(l,A0,R0,n0,\u00b5a..l.t)=(A1,R \n' ,n1,[p,n0,n1]\u00b5a.(a). .) a ..dom(R0) if (A1,R1,n1,.)=fp(l +1,A0,R0,n0,t) and R '.(a . p)=R1 a ..dom(R \n') and a =max {a /(p .a).A1 .a <l .p =n0} sp(l,F,f,a)=a sp(l,F,f,a)=f(a) sp(l,F,f,[p,n,n ']\u00b5a.(a)TT.)=\u00b5a.(b)T \nsp(l,F .(p .b),f,T.) if b =max ({f(a)}.{b /(p .b).F .n = p <n '}) sp(l,F,f,[p,n,n ']\u00b5a.(a). .)=\u00b5a.(b). \nsp(l +1,F .(p .b),f .{l .b +1},.) if b =max ({f(a)}.{b /(p .b).F .n = p <n '}) Nalg(t)=sp(1,0/,id,p4(fp(1,0/,0/ \n,0,t))) Figure 16. The .rst and second passes of the encoding algorithm As for the former, max fa(t)was \ncomputed during the .rst pass, tuple.) As desired, Nalg provides a correct implementation of the and \nrecorded as the atom (a)carried by the node. There is, how-encoding N. This is stated by the following \ntheorem, whose proof ever, a subtlety: since we are applying the renaming f,onthe .y, is omitted: to \nthe term at hand, we really wish to compute max fa(ft). Fortu\u00adnately, it is possible to prove that f \nis increasing on fa(t). (In other Theorem 7.1 N(t)=Nalg(t). . words, l,l '.fa(t)and l <l ' imply f(l)<f(l \n'). This holds mainly because, by construction, f(l ')is at least max{fa(ft)\\f(l ')}+1.)  7.3 Complexity \nAs a result, max fa(ft)is f(max fa(t)), that is, f(a). This explains why f(a)appears in the third and \nlast de.ning equations for sp. We have divided the encoding task in two passes, each of which consists \nof a tree traversal. Let n measure the size of the input typeAs for the latter, we maintain a structure \nF that plays almost the t. One may check that the size of the term . produced by the .rst same role as \n. in Figure 6, but, instead of mapping variables to pass is bounded by O(n), even though some nodes are \nannotated atoms, maps positions (of said variables) to atoms. Consider a node with lists of positions \np. This is because every position p . p rep\u00adthat was annotated, during the .rst pass, with the interval \n[n,n '). resents a distinct variable occurrence in t. Similarly, the size of theEvery variable that appears \nfree in the subtree rooted at this node data structures R, A,and F is bounded by O(n). appears at a position \nin the interval [n,n '). Thus, the greatest atom contributed by the free variables of this subtree (that \nis, by the re- Then, in order to show that the time complexity of the encoding is verse edges that leave \nthis subtree) is max {b /(p,b).F .n = p < O(n log n), we must check that the amount of work performed \nat n '}. This explains why this expression appears in the third and last each node, during each pass, \nis bounded by O(logn). de.ning equations for sp. By inspection of Figure 16, the non-constant time operations \nper-The previous two paragraphs explain the de.nition of b in the third formed at a node are: renaming \noperations (implicit in the .rst pass,and last de.ning equations for sp. Once b is known, the node is \nwhere the reverse De Bruijn numbering property is enforced, andde.nitively annotated with (b). If an \natom is bound at this node explicit in the second pass, where the renaming f is constructed(then, it \nmust be l, the node s level), it must be de.nitively renamed and applied), and interactions with the \ndata structures R, A,and F. to b +1, which explains why f is composed with {l .b +1}in the We study them \nbelow. last de.ning equation for sp. The renaming operations, which consist in applying a renaming \ntoLast, once the current node has been annotated with b, we know that an atom or extending a renaming \nwith a new binding, may be im\u00adthe reverse edges whose endpoint is this node should be viewed as plemented \nin time O(log n)using some .avor of balanced trees. In contributing b to the greatest free atom computation. \nIf the variable the second pass, they may in fact be implemented in time O(1)andbound at the current \nnode is a, then the origins of these edges are the in linear space, using an array. Indeed, the elements \nof the domain(free) occurrences of a in the subtree rooted at this node, whose po\u00adof f are levels, and \nthe maximum level, which is bounded by thesitions have been determined during the .rst pass, and recorded \nas depth of the tree, can easily be computed ahead of time. p. Thus, before moving on to the current \nnode s children, we update F with the mapping (p .b), which stands for {(p .b)/p . p}. Concerning R, \nthe required operations are inserting a new binding, and retrieving and removing all bindings associated \nwith a given 7.2 Correctness variable. Provided variables carry an integer identi.er, a map of integers \nto integer lists, implemented using balanced trees, again Composing the .rst and second passes yields \na mapping Nalg of does the job in time O(log n). types to terms, whose de.nition appears in Figure 16. \n(There, p4 stands for the function that projects the fourth component out of a Concerning A, the required \noperations are inserting a new bind\u00ading and, given n0 and l, computing max {a /(p . a). A . a < l . p \n= n0}. The latter may in fact be decomposed into two simpler operations, namely, given A and l, extracting \nthe subset {(p . a)/(p . a). A . a < l} and, given A and n0, computing max {a /(p . a). A . p = n0}. \nTo implement these operations ef\u00ad.ciently, one can use a binary trie where keys are atoms, with an additional \ninvariant: each node of the trie records the maximum po\u00adsition that occurs in a node below it. Subset \nextraction then simply amounts to truncating the domain of the trie, while taking care to maintain the \nadditional invariant. The last operation amounts to a binary search, where no backtracking is required, \nthanks to the ad\u00additional invariant. All three operations may be implemented to run in time O(log n). \n       Concerning F, the required operations are inserting a binding, and, given n and n ', computing \nmax {b /(p . b). F .n = p <n '}.One can use the same data structure as in the previous paragraph, except \nthe keys are now positions, and each node holds the maximum atom that occurs below it. The last operation \nabove can be implemented ' by truncating F along n and n and reading the maximum atom at the root of \nthe resulting trie, again in time O(log n). Thus, we have proved: Theorem 7.2 If t has size n, then Nalg(t) \nmay be computed in space O(n)and time O(nlogn). . An OCaml implementation is available online [11]. \n  8 Conclusion Our results are intended as a .rst step towards promoting the use of equirecursive types \nin type-preserving compilers. So far, most type-preserving compilers for object-oriented languages seem \nto have relied on isorecursive types, because their metatheory was bet\u00adter understood; see, for instance, \n[15]. We do believe, however, that equirecursive types are more powerful and more elegant, and should \nbe preferred, provided appropriate decision algorithms are available. It is worth noting that our results \nstill hold when rows [19, 20] are added to the syntax of types. The de.nition of the encoding N requires \nno change. The key point is that the equational theory of rows is compatible with the notion of free \natoms, on which the encoding relies: that is, the laws fa(l1: t1;l2: t2;t)=fa(l2: t2;l1: t1;t)and fa(l \n: t;.t)=fa(.t)hold. So, the reduction to .rst-order recursive terms is identical. There only remains \nto use (standard) algorithms for comparing or unifying .rst-order recursive terms in the presence of \nrows. This is an important point, since many object encodings exploit rows; see, for instance, [15]. \nThe most natural direction for future research is to move from F\u00b5 to F\u00b5 ., since higher kinds and type \noperators are heavily used in many object encodings. In particular, we believe that there are nat\u00adural \nobject encodings where the \u00b5 quanti.er is used at higher kinds, as opposed to only at the base kind .. \nHowever, the unrestricted combination of type operators and recursive types is problematic, since it \ngives rise to (i) types whose in.nite unfoldings are not reg\u00adular and (ii) types that do not even have \nweak head normal forms. Thus, identifying a suitable restriction of equirecursive F. that has \u00b5 decidable \ntype equality is an attractive problem.  9 References [1] Mart\u00b4in Abadi and Marcelo P. Fiore. Syntactic \nconsiderations on recur\u00adsive types. In IEEE Symposium on Logic in Computer Science (LICS), pages 242 \n252, July 1996. [2] Michael Brandt and Fritz Henglein. Coinductive axiomatization of recursive type equality \nand subtyping. Fundamenta Informatic\u00e6, 33:309 338, 1998. [3] Kim B. Bruce, Luca Cardelli, and Benjamin \nC. Pierce. Comparing object encodings. Information and Computation, 155(1/2):108 133, November 1999. \n[4] Dario Colazzo and Giorgio Ghelli. Subtyping recursive types in Ker\u00adnel Fun. In IEEE Symposium on \nLogic in Computer Science (LICS), pages 137 146, July 1999. [5] Gregory D. Collins and Zhong Shao. Intensional \nanalysis of higher\u00adkinded recursive types. Technical Report YALEU/DCS/TR-1240, Yale University, 2002. \n[6] Jeffrey Considine. Ef.cient hash-consing of recursive types. Techni\u00adcal Report 2000-006, Boston University, \nJanuary 2000. [7] Karl Crary. Simple, ef.cient object encoding using intersection types. Technical Report \nCMU-CS-99-100, Carnegie Mellon Univer\u00adsity, 1999. [8] Gilles Dowek. Higher-order uni.cation and matching. \nIn J. Alan Robinson and Andrei Voronkov, editors, Handbook of Automated Rea\u00adsoning, pages 1009 1062. \nElsevier Science, 2001. [9] Murdoch J. Gabbay and Andrew M. Pitts. A new approach to abstract syntax \nwith variable binding. Formal Aspects of Computing, 13(3 5):341 363, July 2002. [10] Vladimir Gapeyev, \nMichael Levin, and Benjamin Pierce. Recursive subtyping revealed. Journal of Functional Programming, \n12(6):511 548, 2003. [11] Nadji Gauthier. Implementation of N. http://caml.inria.fr/ gauthier/naming.tar.gz, \nApril 2004. [12] Neal Glew. An ef.cient class and object encoding. In ACM Con\u00adference on Object-Oriented \nProgramming, Systems, Languages, and Applications (OOPSLA), pages 311 324, October 2000. [13] Neal Glew. \nA theory of second-order trees. In European Symposium on Programming (ESOP), volume 2305 of Lecture Notes \nin Computer Science, pages 147 161. Springer Verlag, April 2002. [14] G\u00b4esolution d \u00b4 erard Huet. R\u00b4equations \ndans des langages d ordre 1, 2, ..., .. PhD thesis, Universit\u00b4 e Paris 7, September 1976. [15] Christopher \nLeague, Zhong Shao, and Valery Trifonov. Represent\u00ading Java classes in a typed intermediate language. \nIn ACM Interna\u00adtional Conference on Functional Programming (ICFP),pages183 196, September 1999. [16] \nChristopher League, Zhong Shao, and Valery Trifonov. Type\u00adpreserving compilation of Featherweight Java. \nACM Transactions on Programming Languages and Systems, 24(2):112 152, March 2002. [17] Benjamin C. Pierce. \nTypes and Programming Languages. MIT Press, 2002. [18] Franc\u00b8ois Pottier and Nadji Gauthier. Polymorphic \ntyped defunctional\u00adization. In ACM Symposium on Principles of Programming Languages (POPL), pages 89 \n98, January 2004. [19] Didier R\u00b4 emy. Projective ML. In ACM Symposium on Lisp and Func\u00adtional Programming \n(LFP), pages 66 75, 1992. [20] Didier R\u00b4Type inference for records in a natural extension of emy. ML. \nIn Carl A. Gunter and John C. Mitchell, editors, Theoretical As\u00adpects Of Object-Oriented Programming. \nTypes, Semantics and Lan\u00adguage Design. MIT Press, 1994. [21] Christian Urban, Andrew Pitts, and Murdoch \nGabbay. Nominal uni.\u00adcation. In Computer Science Logic, volume 2803 of Lecture Notes in Computer Science, \npages 513 527. Springer Verlag, August 2003. [22] Hongwei Xi, Chiyan Chen, and Gang Chen. Guarded recursive \ndatatype constructors. In ACM Symposium on Principles of Program\u00adming Languages (POPL), January 2003. \n \n\t\t\t", "proc_id": "1016850", "abstract": "We study a type system equipped with universal types and equire-cursive types, which we refer to as F<inf>&#856;</inf>. We show that type equality may be decided in time O(<i>n</i>log <i>n</i>), an improvement over the previous known bound of O(<i>n</i><sup>2</sup> ). In fact, we show that two more general problems, namely entailment of type equations and type unification, may be decided in time O(<i>n</i>log <i>n</i>), a new result. To achieve this bound, we associate, with every F<inf>&#856;</inf> type, a <i>first-order canonical form</i>, which may be computed in time O(<i>n</i>log<i>n</i>). By exploiting this notion, we reduce all three problems to equality and unification of <i>first-order</i> recursive terms, for which efficient algorithms are known.", "authors": [{"name": "Nadji Gauthier", "author_profile_id": "81100275732", "affiliation": "INRIA", "person_id": "P653512", "email_address": "", "orcid_id": ""}, {"name": "Fran&#231;ois Pottier", "author_profile_id": "81100490085", "affiliation": "INRIA", "person_id": "PP14171513", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1016850.1016872", "year": "2004", "article_id": "1016872", "conference": "ICFP", "title": "Numbering matters: first-order canonical forms for second-order recursive types", "url": "http://dl.acm.org/citation.cfm?id=1016872"}