{"article_publication_date": "09-19-2004", "fulltext": "\n Slideshow: Functional Presentations Robert Bruce Findler Matthew Flatt University of Chicago University \nof Utah robby@cs.uchicago.edu m.att@cs.utah.edu Abstract Among slide-presentation systems, the dominant \napplication offers essentially no abstraction capability. Slideshow, an extension of PLT Scheme, represents \nour effort over the last several years to build an abstraction-friendly slide system. We show how functional \nprogramming is well suited to the task of slide creation, we re\u00adport on the programming abstractions \nthat we have developed for slides, and we describe our solutions to practical problems in ren\u00addering \nslides. We also describe a prototype extension to DrScheme that supports a mixture of programmatic and \nWYSIWYG slide cre\u00adation. Categories and Subject Descriptors H.4.1 [Information Systems Applications]: \nOf.ce Automation; I.7.2 [Document and Text Processing]: Document Preparation  General Terms Languages \n 1 Abstraction-Friendly Applications Strand a computer scientist at an airport, and the poor soul would \nprobably survive for days with only a network-connected computer and .ve applications: an e-mail client, \na web browser, a general\u00adpurpose text editor, a typesetting system, and a slide-presentation application. \nMore speci.cally, while most any mail client or browser would satisfy the stranded scientist, probably \nonly Emacs or vi would do for editing, LATEX for typesetting, and Microsoft PowerPointTM for preparing \nslides. The typical business traveler would more likely insist on Microsoft WordTM for both text editing \nand typesetting. In part, computer scientists may prefer Emacs and LATEX because text editing has little \nto do with typesetting, and these different tasks are best handled by different, specialized applications. \nMore importantly, tools such as Emacs, vi, and LATEX are programmable. Through the power Permission to \nmake digital or hard copies of all or part of this work for personal or classroom use is granted without \nfee provided that copies are not made or distributed for pro.t or commercial advantage and that copies \nbear this notice and the full citation on the .rst page. To copy otherwise, to republish, to post on \nservers or to redistribute to lists, requires prior speci.c permission and/or a fee. ICFP 04, September \n19 21, 2004, Snowbird, Utah, USA. Copyright 2004 ACM 1-58113-905-5/04/0009 ...$5.00 of programming abstractions, \na skilled user of these tools becomes even more ef.cient and effective. Shockingly, many computer scientists \ngive up the power of ab\u00adstraction when faced with the task of preparing slides for a talk. PowerPoint \nis famously easy to learn and use, it produces results that are aesthetically pleasing to most audience \nmembers, and it enables users to produce generic slides in minutes. Like most GUI\u00ad/WYSIWYG-oriented applications, \nhowever, PowerPoint does not lend itself easily to extension and abstraction. PowerPoint provides certain \npre-de.ned abstractions the background, the default font and color, etc. but no ability to create new \nabstractions. Among those who refuse to work without abstraction, many retreat to a web browser (because \nHTML is easy to generate programmat\u00adically) or the various extension of TEX (plus a DVI/PostScript/PDF \nviewer). Usually, the results are not as aesthetically pleasing as PowerPoint slides, and not as .nely \ntuned to the problems of pro\u00adjecting images onto a screen. Moreover, novice users of TEX-based systems \ntend to produce slides with far too many words and far too few pictures, due to the text bias of their \ntool. Meanwhile, as a programming language, TEX leaves much to be desired. Slideshow, a part of the PLT \nScheme application suite [10], .lls the gap left by abstraction-poor slide presentation systems. First \nand foremost, Slideshow is an embedded DSL for picture generation, but it also provides direct support \nfor step-wise animation, bullet\u00adstyle text, slide navigation, image scaling (to .t different display \nand projector types), cross-platform consistency (Windows, Mac OS, and Unix/X), and PostScript output \n(for ease of distribution). Functional programming naturally supports the de.nition of picture combinators, \nand it enables slide creators to create new abstractions that meet their speci.c needs. In this paper, \nwe mainly demonstrate how Slideshow as a pro\u00adgramming language supports abstraction, but slide creators \ncan also bene.t from a measured dose of WYSIWYG slide construction. WYSIWYG tools should be part of the \nslide language s program\u00adming environment, analogous to GUI builders for desktop appli\u00adcations. We therefore \nreport on experimental extensions of the DrScheme programming environment that support interactive slide \nconstruction along with language-based abstraction. Section 2 describes Slideshow s primitives for picture \ngeneration, and Section 3 shows how we build on these operations to ad\u00address common slide-construction \ntasks. Section 4 brie.y addresses practical issues for rendering slides on different media and op\u00aderating \nsystems. Section 5 describes our prototype extension of DrScheme. 2 Picture Combinators A pict is the \nbasic building block for pictures in Slideshow. Roughly, a pict consists of a bounding box and a procedure \nfor drawing relative to the box. Ultimately, a slide is represented as a single pict to be drawn on the \nscreen. As a running example, suppose that we wish to illustrate graph searching to novice programmers, \nshowing how a graph of people is traversed to .nd the name of a person who lives in a particular city. \nThe illustration will contain boxes labeled with names and lo\u00adcations, directed connections among the \nboxes, an arrow indicating the starting box, and a cloud that stands in place of many unspeci\u00ad.ed boxes \nand connections. 2.1 Pict Basics To create the basic elements of the graph, we can use rectangle and \ncloud. The rectangle and cloud functions take the height and width of the new pict. (rectangle 20 10) \n (cloud 30 20)  To label the boxes with the names of people, we need picts for text. The text function \ntakes a string, a font class, and a font size, and it produces a pict for the text. (text \"Angua\" roman \n10)  To get a labeled box, we need to combine a text pict with a rectangle pict. The cc-superimpose \nfunction stacks pictures on top of each other to create a new picture. (cc-superimpose (rectangle 50 \n20) (text \"Angua\" roman 10))  The cc part of the name cc-superimpose indicates that the picts are centered \nhorizontally and vertically as they are stacked. If, in\u00adstead, we want the label in the top-left of the \nrectangle, we can use lt-superimpose. (lt-superimpose (rectangle 50 20) (text \"Angua\" roman 10))  To \nillustrate distances, our boxes need to contain both a person s name and home. We could put a name in \nthe top-left of a rectangle and the home in the bottom left, but we d prefer to center both to\u00adgether. \nThe vl-append function stacks picts vertically, instead of on top of each other. (cc-superimpose (rectangle \n50 30) (vl-append (text \"Angua\" roman 10) (text \"\u00a8 roman Uberwald\" 10)))  The l in vl-append means that \nthe picts are left-aligned as they are stacked. We could right-align the picts with vr-append, or center \nthem with vc-append. If we want to pre.x the boxed .elds with Name: and Home: labels, we can use hb-append. \n(cc-superimpose (rectangle 80 30) (vl-append (hb-append (text \"Name: \" roman 10) (text \"Angua\" roman \n10)) (hb-append (text \"Home: \" roman 10) (text \"\u00a8 roman Uberwald\" 10))))  Naturally, the b in hb-append \nmeans that the picts are bottom-aligned as they are stacked horizontally, and hc-append and ht-append \ncenter-and top-align pictures. In addition, hbl-append aligns text on baselines, which is useful when \npicts contain text in different fonts or sizes. (cc-superimpose (rectangle 80 30) (vl-append (hbl-append \n(text \"Name: \" roman 6) (text \"Angua\" roman 10)) (hbl-append (text \"Home: \" roman 6) (text \"\u00a8 roman \n Uberwald\" 10))))  More precisely, hbl-append aligns text using the bottom baseline in each pict, in \ncase one pict is a vertical combination of other text picts. The htl-append function aligns text using \ntop baselines. 2.2 Pict Abstractions Since we need to create several people in the graph, we should \nab\u00adstract the box construction into a function. (define (person name home ) (cc-superimpose (rectangle \n80 30) (vl-append (hbl-append (text \"Name: \" roman 6) (text name roman 10)) (hbl-append (text \"Home: \n\" roman 6) (text home roman 10)))))  One obvious problem with this implementation is the hard-wired \nsize of the rectangle. It should grow to match the size of the labels, plus a small amount of padding. \nTo create a pict whose size depends on another pict s size, we can use pict-width and pict-height. (define \n(person name home ) (let ([content (vl-append (hbl-append (text \"Name: \" roman 6) (text name roman 10)) \n(hbl-append (text \"Home: \" roman 6) (text home roman 10)))]) (cc-superimpose (rectangle (+ 10 (pict-width \ncontent )) (+ 10 (pict-height content ))) content ))) (define angua (person \"Angua\" \"Uberwald\")) \u00a8 \n(define brutha (person \"Brutha\" \"Omnia\"))  At this point, we can create several people, plus the cloud \nand start\u00ading arrow, and combine them in a picture. If we just use vc-append and hc-append to combine \nthe people, the layout will look too regular. We can use inset to wrap varying, extra space around some \npeople; the inset takes a pict and either one argument for an amount of space to add around the pict, \ntwo arguments for separate horizontal and vertical space, or four arguments for separate left, top, right, \nand bottom space. We can also use a blank pict to put extra space between the people. (define angua+brutha \n(vr-append (inset angua 10 10 10 0) (blank 0 18) brutha )) (define colon (person \"Sgt. Colon\" \"Ankh-Morpork\")) \n(define detritus (person \"Detritus\" \"\u00a8Uberwald\")) (define others (cloud 40 25)) (define people (hc-append \n angua+brutha (blank 20 0) (inset (vl-append colon (blank 0 24) (inset detritus 10 0 0 0)) 020 00) (blank \n20 0) others ))   2.3 Finding Picts To add an arrow from Angua to Brutha, we could insert an arrow \npict into the vr-append sequence, but adding an arrow from Brutha to Sgt. Colon is not so straightforward \nwith stacking operations. Slideshow provides a more general way to extend a pict, which is based on .nding \nthe relative location of sub-picts. Each pict has an identity (in the sense of Scheme s eq? ), and all \npict-combining op\u00aderations preserve that identity internally. To locate a sub-pict within an aggregate \npict, Slideshow provides a family of operations begin\u00adning with find-. The suf.x of a find-operation \nindicates which corner or edge of the sub-pict to .nd; it is a combination of l, c, or r (i.e., left, \ncenter, or right) with t, tl, c, or bl, b (i.e., top, top baseline, center, bot\u00adtom baseline, or bottom). \nThe results of a find-operation are the coordinates of the found corner/edge relative to the aggregate \npict. A find-operation is often combined with place-over, which takes a pict, horizontal and vertical \noffsets, and a picture to place on top of the .rst pict. For example, we can create a connect\u00ading arrow \nwith arrow-line (which takes horizontal and vertical displacements, plus the size of the arrowhead) and \nplace it onto people . (let-values ([(ax ay ) (find-cb people angua )] [(bx by ) (find-ct people brutha \n)]) (place-over people ax (- (pict-height people ) ay ) (arrow-line (- bx ax )(- by ay ) 10)))  Since \nwe need to create many people, we abstract the connection code. Different connections will connect to \ndifferent parts of of the source and destination people, so our conn function accepts the relevant find-procedures \nas arguments. (define (conn main from find-from to find-to ) (let-values ([(ax ay )(find-from main from \n)] [(bx by )(find-to main to )]) (place-over main ax (- (pict-height main ) ay ) (arrow-line (- bx ax \n)(- by ay ) 10))))  (define graph (let* ([p (conn people people find-lt angua find-lt)] [p (conn p angua \nfind-cb brutha find-ct)] [p (conn p brutha find-rt colon find-lb)] [p (conn p brutha find-rc detritus \nfind-lc )] [p (conn p detritus find-ct colon find-cb)] [p (conn p colon find-rc others find-lc )]) p \n))  2.4 Colors and Line Widths The graph pict so far corresponds to the initial slide in our demon\u00adstration. \nTo illustrate depth-.rst search, we need to highlight arrows in the picture as the algorithm traverses \nlinks. We might implement this highlighting using the find-operations, re-drawing arrows to add color. \nMore simply, we can parameterize our existing code to add highlighting. For example, we can generalize \nconn to accept a highlighting/dimming function that gives the arrow a color. (define (hconn main from \nfind-from to find-to hi/dim ) (let-values ([(ax ay )(find-from main from )] [(bx by )(find-to main to \n)]) (place-over main ax (- (pict-height main ) ay ) (hi/dim (arrow-line (- bx ax )(- by ay ) 10))))) \n (define (dim p ) (colorize p \"gray\")) (define (hilite p ) (colorize p \"red\")) (hconn angua+brutha angua \nfind-cb brutha find-ct hilite )  In general, a pict is constructed to use certain default attributes, \nsuch as the width for lines and the color for drawing. The colorize operation overrides the default color \n(but it does not affect picts where the default is already overridden). For arrows, a color change is \na good start, but it does not ade\u00adquately highlight a thin arrow (especially for readers of this paper \nwho printed the colorized PS/PDF on a black-and-white printer). We can change hilite further to adjust \nthe line width. (define (hilite p ) (linewidth 2 (colorize p \"red\"))) (hconn angua+brutha angua find-cb \nbrutha find-ct hilite )  Finally, we assemble the connection additions into a function, and parameterize \nit over the highlighting function for each arrow. By calling add-lines with different arguments, we can \ngenerate a sequence of pictures to use in a sequences of slides that illustrate how a search algorithm \ntraverses links. (define (add-lines p ih abh bch bdh dch coh ) (let* ([p (hconn p p find-lt angua find-lt \nih )] [p (hconn p angua find-cb brutha find-ct abh )] [p (hconn p brutha find-rt colon find-lb bch )] \n[p (hconn p brutha find-rc detritus find-lc bdh )] [p (hconn p detritus find-ct colon find-cb dch )] \n[p (hconn p colon find-rc others find-lc coh )]) p )) (define graph2 (add-lines people hilite hilite \ndim dim dim dim )) (define graph3 (add-lines people hilite hilite hilite dim dim dim ))   2.5 Functional \nPicts and Identity The colorize and linewidth operations are functional, so they produce a new pict \nrather than modifying an existing pict. The func\u00adtional nature of picts means that they can be used multiple \ntimes in constructing an image. For example, we can add a shadow to peo\u00adple by creating a gray version \nthat is behind and below the black version. (lt-superimpose (inset (colorize angua \"gray\") 3 3 0 0) angua \n)  In the resulting pict, however, a find-operation for angua is am\u00adbiguous; it might .nd the black \ninstance, or it might .nd the gray instance. The launder primitive takes a pict and produces one that \nis drawn the same its its input, but with no find-able sub-picts. By using launder, we can provide a \nshadow for the graph without interfering with the way that connecting lines are drawn. (define (add-shadow \np ) (lt-superimpose (inset (colorize (launder p ) \"gray\") 3 3 0 0) p )) (hconn (add-shadow angua+brutha \n) angua find-cb brutha find-ct hilite ) The complement of launder is ghost. The ghost function creates \na pict with the dimensions and sub-pict locations of a given pict, but with no drawing. For example, \nif we want just the arrows of the graph without the people, we can ghost out the people . This operation \nmight be used, for example, to increase the default width of the arrow lines without affecting the default \nwidth of the person\u00adbox lines. (lt-superimpose people (linewidth 1 ; affects arrows, not boxes (add-lines \n(ghost people ) hilite hilite hilite dim dim dim )))  2.6 More Abstractions The graph example illustrates \nall of the properties of a pict: it has a bounding box, upper and lower baselines for text alignment, \nsub\u00adpict locations, and a drawing procedure. In general, a drawing ab\u00adstraction may require additional \nproperties, and they can be imple\u00admented as a new abstraction that encapsulates picts. In particular, \ninstead of manually highlighting links to create graph2 and graph3 , we would prefer to represent the \n.gure as an actual graph of records, and then implement depth-.rst search to highlight certain links. \nWe therefore replace add-lines with a graph de.nition and search function. To implement the graph, we \n.rst de.ne record types for nodes and edges. (define-struct node (p edges )) (define-struct edge (from \nfind-from to find-to )) The declaration of node introduces the constructor make-node and the selectors \nnode-p (for the node s picture) and node-edges (for the node s outgoing edges). The declaration of edge \nsimilarly in\u00adtroduces the constructor make-edge and selectors node-from , etc. In addition to its start \nand end nodes, an edge includes find-from and find-to .elds for drawing the edge with hconn . Using the \nnew record constructors and PLT Scheme s shared ex\u00adtension of letrec, we can de.ne the graph of people. \n(define nodes (shared ([i (make-node people (list (make-edge i find-lt a find-lt)))] [a (make-node angua \n(list (make-edge a find-cb b find-ct)))] [b (make-node brutha (list (make-edge b find-rt c find-lb) (make-edge \nb find-rc d find-lc )))] [c (make-node colon (list (make-edge c find-rc o find-lc )))] [d (make-node \ndetritus (list (make-edge d find-ct c find-cb)))] [o (make-node others (list))]) i )) The following search \nfunction takes the current stack of edges, a list of previously visited edges (to avoid cycles), a target \nperson to .nd, an initial value for the search s result, and a fold-like proce\u00addure for accumulating \nthe result with each traversal of an edge. (define (search edges seen target v traverse ) (if (null? \nedges ) (let* ([e (car edges )] [next-v (traverse e v )] [new (remove* (append seen edges ) (node-edges \n(edge-to e )))]) (if (eq? target (node-p (edge-to e ))) next-v (search (append new (cdr edges )) (cons \ne seen ) target next-v traverse ))))) Using search , we can now de.ne graph by adding a gray connec\u00adtion \nto people each time that we traverse an edge while exploring the entire graph. (define (line-adder h \n) (lambda (ep ) (hconn p (node-p (edge-from e )) (edge-find-from e ) (node-p (edge-to e )) (edge-find-to \ne ) h ))) (define graph (search (node-edges nodes ) (list) #f people (line-adder dim )))  We can then \ncreate graph3 by searching for colon , re-adding con\u00adnections along the way in highlight mode. (define \ngraph3 (search (node-edges nodes ) (list) colon graph (line-adder hilite )))   2.7 Direct Drawing and \nScaling Many pictures can be implemented purely with the functions de\u00adscribed so far. For cases when \nthe programmer wants direct access to the underlying drawing toolbox, Slideshow provides a dc con\u00adstructor \n(where dc stands for drawing context ). The dc function takes an arbitrary drawing procedure and bounding-box \nattributes. When the pict must be rendered, the drawing procedure is called with a target drawing context \nand offset. For example, a triangle pict constructor can be implemented us\u00ading the primitive draw-line \nmethod of a drawing context. (define (triangle wh ) (dc (lambda (dest x y ) (let ([mid-x (+ x (/ w 2))] \n[far-x (+ xw )] [far-y (+ yh )]) (send dest draw-line x far-y mid-x y ) (send dest draw-line far-x far-y \nmid-x y ) (send dest draw-line far-x far-y x far-y ))) wh 0 0)) (triangle 20 10)  The primitive drawing \ncontext is highly stateful, with attributes such as the current drawing color and drawing scale. Not \nsur\u00adprisingly, slides that are implemented by directly managing this state are prone to error, which \nis why we have constructed the pict abstraction. Nevertheless, the state components show up in the pict \nabstraction in terms of attribute defaults, such as the draw\u00ading color or width of a drawn line. In particular, \nthe linewidth and colorize operators change the line width and color of a pict produced by triangle. \nOne further aspect of the drawing context that can be controlled externally is the drawing scale. The \nscale operator scales a pict to make it bigger or smaller. (Inde\u00adpendent horizontal and vertical scales \nenable squashing and stretch\u00ading, as well.) Like color and line widths, scaling is implemented by adjusting \nthe scale of the underlying drawing context, so that scale affects picts generated by dc, as well as \nany other pict. (scale graph 0.4 0.2)  Although the underlying drawing context includes a current font \nas part of its state, a pict s font cannot be changed externally, unlike the pict s scale, color, or \nline width. Changing a pict s font would mean changing the font of sub-picts, which would in turn would \ncause the bounding box of each sub-pict to change in a complex way, thus invalidating computations based \non the sub-pict boxes. We discuss this design constraint further in Section 6. 2.8 Pict Primitives \nOverall, the following may be considered the primitives for Slideshow picts: dc the main constructor \nof picts.  scale, linewidth, and colorize property-adjusting op\u00aderations.  inset, lift, and drop \n bounding-box adjustments (where lift and drop adjust the top and bottom baselines).  place-over, launder, \nand ghost combination opera\u00adtors.  find-lt sub-pict .nder.  All other pict operations can be implemented \nin terms of the above operations. (For historical reasons, the actual primitives are less tidy than this \nset, but Slideshow continues to evolve toward an im\u00adplementation with this set as the true primitives.) \n 3 From Pictures to Slides Picture-construction primitives are half of the story for Slideshow. The \nother half is a library of pict operations that support common slide tasks and that cooperate with a \nslide-display system. Com\u00admon tasks include creating a slide with a title, creating text with a default \nfont, breaking lines of text, bulletizing lists, and staging the content of a multi-step slide. Cooperating \nwith the display system means correlating titles with a slide-selection dialog and enabling clickable \nelements within interactive slides. 3.1 Generating Slides Abstractly, a slide presentation is a sequence \nof picts. Thus, a pre\u00adsentation could be represented as a list of picts, and a Slideshow program could \nbe any program that generates such a list. We have opted instead for a more imperative design at the \nslide level: a Slideshow program calls a slide function (or variants of slide) to register each individual \nslide s content.1 (slide (scale graph 3)) ; scale to fill the slide  We choose imperative registration \nthrough slide because a slide presentation is most easily written as a sequence of interleaved def\u00adinitions \nand expressions, much like the examples in Section 2. A programmer could thread a list through the sequence, \nbut such a threading is awkward to read and maintain. The picts that are reg\u00ad 1We illustrate the effect \nof slide by showing a framed, scaled version of the resulting slide s pict. istered for slides remain \npurely functional (i.e., they cannot be mu\u00adtated), so a small amount of imperative programming causes \nlittle problem in practice. Furthermore, we usually write slide at the top-level, interspersed with de.nitions, \nso each use of slide feels more declarative than imperative. The slide/title function is similar to slide, \nexcept that it takes an extra string argument. The string is used as the slide s name, and it is also \nused to generate a title pict that is placed above the supplied content picts. The title pict uses a \nstandard (con.gurable) font and is separated from the slide content by a standard amount. (slide/title \n\"Depth-First Search\" (scale graph 3))  In principle, the slide and slide/title functions simply register \na slide, and programmers could build more elaborate abstractions in terms of these functions. In practice, \nprogrammers will prefer to use the more elaborate abstractions, and part of Slideshow s job is to provide \nthe most useful of such abstractions. Thus, Slideshow allocates the relatively short names slide, slide/title, \netc. to functions that provide additional functionality. The most simplest such addition is that each \nslide function takes any number of picts, and it concatenates them with vc-append us\u00ading a separation \nof gap-size (which is 24). The slide function then ct-superimposes the appended picts with a blank pict \nrep\u00adresenting the screen (minus a small border). The slide/center function is like slide, except that \nit centers the slide content with respect to the screen. The slide/title/center accepts a title and also \ncenters the slide. (slide/title/center \"Depth-First Search\" (scale graph 3) (text \"An example graph\" \nswiss 32))  The set of pre-de.ned slide layouts includes only the layouts that we have found to be most \nuseful. Programmers can easily create other layouts by implementing functions that call slide. 3.2 Managing \nText In the spirit of providing short names for particularly useful ab\u00adstractions, Slideshow provides \nthe function t for creating a text pict with a standard font and size (which defaults to sans-serif, \n32 units high). Thus, the label for the earlier example could have been im\u00adplemented as (t \"An example \ngraph\") instead of (text \"An example graph\" swiss 32). The bt function is similar to t, except that it \nmakes the text bold, and it makes its text italic. For typesetting an entire sentence, which might be \ntoo long to .t on a single line and might require multiple fonts, Slideshow provides a para function. \nThe para function takes a width and a sequence of strings and picts, and it arranges the text and picts \nas a paragraph that is bounded by the given width. In the process, para may break strings on word boundaries. \nThe page-para function is like para, but with a built-in width that corresponds to the screen s width \n(mi\u00adnus the margin). (slide/title \"Depth-First Search\" (scale graph3 3) (page-para \"For\" (bt \"depth-first \nsearch\") \",\" \"follow a single\" \"branch at each node,\" \"and backtrack only when a branch fails\"))  The \nitem function is similar to para, except that it adds a bullet to the left of the paragraph. In parallel \nto page-para and para, the page-item function is like item, but with a built-in width that corresponds \nto the screen s width. (slide/title \"Breadth-First Search\" (scale graph3 3) (page-para \"For\" (bt \"breadth-first \nsearch\") \":\") (page-item \"Check the immediate node\") (page-item \"If not found, queue the node s neighbors,\" \n \"and try the first node in the queue\"))  Note that, given a bullet pict, item is easily implemented \nin terms of para. (define (item w . picts ) (htl-append bullet (blank (/ gap-size 2) 0) (apply para (- \nw (pict-width bullet) (/ gap-size 2)) picts ))) Just as Slideshow provides many slide variants, it also \nprovides many para and item variants, including variants for right-justi.ed or centered paragraphs and \nbulleted sub-lists. The page-para* function, for example, typesets a paragraph like page-para, but allows \nthe result to be more narrow than the screen, so that it gets centered. 3.3 Staging Slides In Section \n2.4, we showed how to abstract a pict-constructing ex\u00adpression to support incremental changes to a pict. \nThis technique can be used to implement any kind of staged slide, where parts of the screen are revealed \nor modi.ed in a sequence of slides. In some cases, a sequence of staged slides can be generated auto\u00admatically. \nFor example, we can use slide/center in a traversal with search to generate a sequence of slides that \nillustrates depth\u00ad.rst search. (search (node-edges nodes ) (list) #f graph (compose (lambda (x ) (slide/center \n(scale x 3)) x ) (line-adder hilite )))  Few slide sequences are so automatic, however. To facilitate \nman\u00adual sequences, Slideshow provides a with-steps form that names each step in the sequence. Expressions \nin the body of with-steps can test whether the current step is before a particular step, af\u00adter a particular \nstep, or between two steps (inclusive or exclusive) to determine how to generate a slide. For example, \nwe can use with-steps to generate a slide sequence with commentary that is speci.c to our sample graph \nof people. (with-steps (a b c etc ) ; step names to use in the body (slide/center (scale (add-lines people \nhilite (if (after? b ) hilite dim ) (if (after? c ) hilite dim ) (if (after? etc ) hilite dim ) (if (after? \netc ) hilite dim ) (if (after? etc ) hilite dim )) 3) (if (after? etc ) (page-para \"And so on\") (page-para \n\"Check \" (cond  [(only? a ) \"Angua\"] [(only? b ) \"Brutha\"] [(only? c ) \"Sgt. Colon\"])))))  Much like \ntext and hbl-append for typesetting paragraphs, with-steps is too primitive for staging bullets or lines \nof text on a slide. For example, when posing a question to students, an answer may be revealed only after \nthe students have a chance to think about the question. To support this simple kind of staging, the slide \nfunction (and all its variants) treats the symbol next specially when it appears in the argument sequence. \nAll of the picts before next are .rst used to generate a slide, and then the picts before next plus the \narguments after next are passed back into slide to generate more slides. (slide/title \"Depth-First Search\" \n(scale graph3 3) (colorize (page-para* \"Colon in Ankh-Morpork?\") \"red\") next (colorize (page-para* \"Yes, \nso we re done\") \"blue\"))  Besides simple linear staging with next, the slide function sup\u00adports staging \nwith alternatives that are later abandoned. The alts symbol triggers this mode of staging. The argument \nfollowing alts must be a list of lists, instead of a single pict. Each of the lists is appended individually \nonto the preceding list of pict to gen\u00aderate a slide. The .nal list is further appended onto the remaining \narguments (after the list of lists). The next and alts symbols can be mixed freely. (slide/title \"Breadth-First \nSearch\" (scale graph2 3) (page-para \"From Brutha\") alts (list (list (page-item \"Try Detritus\") next (page-item \n\"No...\")) (list (page-item \"Try Sgt. Colon\") next (page-item \"Yes!\"))) next (page-para \"So we find Sgt. \nColon in Ankh-Morpork\"))  3.4 Adjusting Slide Defaults As we noted in Section 2.7, the font used by \na pict cannot be changed after the pict is created, because the pict s size depends on its font. At .rst \nglance, this constraint might limit the use func\u00adtions like para, which do not accept a font speci.cation \nand implic\u00aditly use t. Slideshow makes para and other functions more useful through implicit parameters \nfor t. In particular, the font used by t (and bt and it) is determined by the current-main-font pa\u00adrameter, \nand the size is determined by the current-font-size parameter. A parameter s value can be set during \npict creation us\u00ading the parameterize form. For example, if we want to typeset a paragraph as italics, \nwe can use parameterize while constructing a pict with page-para*. (slide/center (scale graph3 3) (parameterize \n([current-main-font (italic . swiss)]) (page-para* \"Remember links that we have traversed,\" \"and don \nt follow them again later\")))  Slideshow provides several other parameters to control slide de\u00adfaults, \nsuch as the current-slide-assembler parameter. It con\u00adtrols the overall style of a slide, including the \nbackground and the layout of titles, and it is typically set once per presentation. 3.5 Display Interaction \n In addition to creating pictures for the screen, slide presenters must sometimes interact more directly \nwith the display system: A slide author might wish to attach a commentary to slides, for the bene.t \nof the speaker or for those viewing the slides after the talk. Slideshow provides a comment constructor \nthat takes a commentary string and produces an object that can be supplied to slide. When the slide function \n.nds a comment object, it accumulates the comment into the slide s overall commentary (instead of generating \nan image). The Slideshow viewer displays a slide s commentary on demand in a separate window.  For presentations \nthat involve demos, the speaker might like hyperlinks on certain slides to start the demos. Slideshow \npro\u00advides a clickback operator that takes a pict and a procedure of no arguments; the result is a pict \nthat displays like the given one, but that also responds to mouse clicks by calling the pro\u00adcedure. (In \nthis case, we exploit the fact that slide generation and slide presentation execute on the same virtual \nmachine.)  Although many animations can be implemented as multiple slides that the speaker advances \nmanually, other animations should be entirely automatic. Currently, Slideshow provides only minimal support \nfor such animations, though an impera\u00adtive scroll-transition function that registers a scroll ani\u00admation \nover the previously registered slide. (This feature has been used mainly to animate an algebraic reduction, \nmaking the expression movements easier to follow.) In the future, the pict abstraction might be enriched \nto support more interesting kinds of animation.   4 Rendering Slides Slideshow is designed to produce \nconsistent results with any pro\u00adjector resolution, as well as when generating PostScript versions of \nslides. The main challenges for consistency concern pict scal\u00ading and font selection, as discussed in \nthe following sections. We also comment on Slideshow s ability to condense staged slides for printing, \nand to pre-render slides to minimize delays during a pre\u00adsentation. 4.1 Scaling Since 1024x768 displays \nare most common, Slideshow de.nes a single slide to be a pict that is 1024x768 units. The default border \nleaves a 984x728 region for slide content. These units do not nec\u00adessarily correspond to pixels, however. \nDepending on the display at presentation time, the pict is scaled (e.g., by a factor of 25/32 for an \n800x600 display). If the display aspect is not 4:3, then scaling is limited by either the display s width \nor height to preserve the pict s original 4:3 aspect, and unused screen space is painted black. Slideshow \ndoes not use a special .le format for slide presentations. Instead, a Slideshow presentation is a program, \nand pict layouts are computed every time the presentation is started. Consequently, the target screen \nresolution is known at the time when slides are built. This information can be used, for example, to \nscale bitmap images to match the display s pixels, instead of units in the virtual 1024x768 space. Information \nabout the display is also useful for font selection. 4.2 Fonts Fonts are not consistently available \n(or even consistently named) across operating systems. To avoid platform dependencies, Slideshow presentations \ntypically rely on PLT Scheme s mapping of platform-speci.c fonts through portable family symbols, such \nas roman (a serif font), swiss (a sans-serif font, usually Hel\u00advetica), modern (a .xed-width font), and \nsymbol (a font with Greek characters and other symbols). PLT Scheme users control the family-to-font \nmapping, so a Slideshow programmer can assume that the user has selected reasonable fonts. Alternately, \na program\u00admer can always name a speci.c font, though at the risk of making the presentation unportable. \nSince speci.c fonts vary across platforms, displays, and users, the speci.c layout of picts in a Slideshow \npresentation can vary, due to different bounding boxes for text picts. Nevertheless, as long as a programmer \nuses pict-width and pict-height instead of hard-wiring text sizes, slides display correctly despite font \nvaria\u00adtions. This portability depends on computing pict layouts at display time, instead of computing \nlayouts in advance and distributing pre\u00adconstructed picts. Text scaling leads to additional challenges. \nFor many displays, a font effectively exists only at certain sizes; if a pict is scaled such that its \nactual font size would fall between existing sizes, the un\u00adderlying display engine must substitute a \nslightly larger or smaller font. Consequently, a simple scaling of the bounding box (in the 1024x768 \nspace) does not accurately re.ect the size of the text as it is drawn, leading to overlapping text or \nunattractive gaps. To compensate for text-scaling problems, Slideshow determines the expected scaling \nof slides (based on the current display size) before generating picts. It then uses the expected scale \nto gen\u00aderate a bounding box for text picts that will be accurate after scaling. Occasionally, the predicted \nscale is incorrect because the programmer uses the scale operation in addition to the implicit scale \nfor the target display, but this problem is rare. When neces\u00adsary, the programmer can correct the scale \nprediction by using the scale/improve-new-text form and creating text picts within the dynamic extent \nof this form. 4.3 Printing Slides A drawing context in PLT Scheme is either a bitmap display (possi\u00adbly \noffscreen) or a PostScript stream. Thus, printing a Slideshow presentation is as simple as rendering \nthe slides to a PostScript drawing context instead of a bitmap context. Slideshow provides a condense \nmode for collapsing staged slides. Collapse mode automatically ignores next annotations; a pro\u00adgrammer \ncan use next! instead of next to force separate slides in condense mode. In contrast, alts annotations \ncannot be ig\u00adnored, because each alternative can show different information. A Slideshow programmer can \nindicate that intermediate alternatives should be skipped in condense mode by using alts~ instead of \nalts. Slideshow synchronizes page numbering in condensed slides with slide numbering in a normal presentation. \nIn other words, when slide skips a next annotation, it also increments the slide num\u00adber. As a result, \na condense slide s number is actually a range, indi\u00adcating the range of normal slides covered by the \ncondensed slide. Programmers can use the condense? and printing? predicates to further customize slide \nrendering for condense mode and printing. A skip-slides! function allows the programmer to increment \nthe slide count directly. 4.4 Pre-rendering Slides To avoid screen .icker when advancing slides in \nan interactive pre\u00adsentation, Slideshow renders each slide in an offscreen bitmap, and then copies the \nbitmap to the screen. The time required to render a slide is rarely noticeable, but since a programmer \ncan create arbitrary complex picts or write arbitrarily complex code that uses the drawing context directly, \nthe rendering delay for some slides can be noticeable. To ensure instantaneous response in the common \ncase, Slideshow pre-renders the next slide in the presentation sequence while the speaker dwells on the \ncurrent slide. (If the speaker requests a slide change within half a second, the slide is not pre-rendered, \nbecause the speaker may be stepping backward through slides.)  5 Environment Support Slideshow programs \ncan be implemented using the DrScheme pro\u00adgramming environment [4], since Slideshow is an extension of \nPLT Scheme. All of DrScheme s programming tools work as usual, in\u00adcluding the on-the-.y syntax colorer, \nthe syntax checker, the de\u00adbugger, and the static analyzer. Non-textual syntax can be used in a Slideshow \nprogram, such as a test-case boxes, comment boxes, or XML boxes (which support literal XML without concern \nfor es\u00adcape characters) [2]. More importantly, we can use DrScheme s extension interface to add new tools \nto DrScheme that speci.cally support slide creation. Figure 1 shows two screen dumps for one such tool. \nThe tool keeps track of picts that are generated during the run of a Slideshow pro\u00adgram, and then allows \na programmer to move the mouse over an in\u00addividual expression to see the pict(s) generated the expression. \nThe black rectangles indicate mouseable positions. In the .rst screen dump, the mouse is over the content \nvariable in node , and on the right, the four result pictures are shown one for each call to node when \nthe program is executed. In the second screen dump, the mouse is over the rectangle call, so four rectangles \nare shown to the right, and the size of each rectangle matches the size of each corresponding content \npict. Moving the mouse over one of the calls to code would show a single pict, which is the boxed-content \nresult of the call. (The cc-superimpose call in code is in tail po\u00adsition. To avoid turning loops into \ndeep recursion, our prototype tool ignores tail expressions.) Screen dumps for non-textual slide syntax \nappear in Figure 2. The value for the nodes de.nition is expressed using a pict box, as in\u00addicated by \nthe icon in the top-right of the box. For the .rst screen dump, inside the pict box are .ve purple Scheme \nboxes, as indi\u00adcated by the comma (suggestive of unquote) in the top-right. Each Scheme box escapes from \npict mode back into Scheme. The pro\u00adgrammer created each Scheme box, dragged it into place relative to \nother Scheme boxes, and then entered a Scheme expression into each box. When the pict box is evaluated, \nthe expressions within Scheme boxes are evaluated to obtain sub-picts, and these sub-picts are combined \nusing the relative positions of Scheme boxes in the overall pict box. Thus, the pict box in the screen \ndump implements the node layout that we created with vr-append and hc-append in Section 2.2, and interactive \nplacement seems more natural in this case than pro\u00adgrammatic stacking. For a full WYSIWYG treatment, \nthe program\u00admer needs to see the pict results for each Scheme box, rather than the Scheme code. The second \nscreen dump in Figure 2 shows the same tool and program in preview mode, which uses results for the Scheme \nboxes (from a recent execution) to show a preview of the pict result. The Sgt. Colon box is highlighted \nbecause the pro\u00adgrammer has just moved it, using preview mode to pick a better arrangement. These slide-speci.c \ntools have yet to evolve beyond the experimen\u00adtal stage, but they illustrate how a programming environment \ncan provide WYSIWIG-style tools that complement the language s ab\u00adstraction capabilities. 6 Slideshow \nDesign and Related Work Slideshow s pict language is by no means the .rst language de\u00adsigned for generating \npictures, and its picture constructors are sim\u00adilar to those of Henderson s functional pictures [6], \nMLgraph [1], Pictures [5], FPIC [8], pic [9], MetaPost [7], and many other sys\u00adtems. Unlike pic and MetaPost \n(but like MLgraph, etc.), Slideshow builds on a general-purpose programming language, so it can sup\u00adport \nmodular development, it allows programmers to write main\u00adtainable code, libraries, and tests, and it \nis supported by a program\u00adming environment. MLgraph, Pictures, and FPIC provide a richer set of transformation \noperations (mainly because they all build on PostScript), while Slideshow provides a richer set of text-formatting \noperations. Also, Slideshow s combination of find-, ghost, and launder operations seems unique. The primary \ndifference between Slideshow and other functional-picture languages, though, is that Slideshow has been \nre.ned through practice to meet the speci.c needs of slide creators. In the IDEAL [13] picture language, \nprogrammers de.ne pic\u00adtures by describing constraints, such as arrow X s endpoint is at\u00adtached to box \nY s right edge. In Slideshow, the programmer ef\u00adfectively writes a constraint solver manually, using \nfunctions like pict-width ands find-lt. We have opted for the more direct functional style, instead of \na constraint-based language, because we .nd that many patterns of constraints are easily covered by basic \ncombinators (such as vl-append), and other patterns of constraints (like adding lines to connecting node) \nare easily abstracted into new functions. Our choice of direct computation, instead of using constraints, \naf\u00adfects the kinds of properties that can be adjusted from outside a pict. As noted in Section 2.7, a \npict s font cannot be changed ex\u00adternally, because changing the font would invalidate computations based \non the pict s bounding box. In a constraint-based system, or where all primitive pict-combination operations \nare encapsulated in operations like vc-append, then invalidated computations can be re-executed. With \nmore general combinations using place-over, however, the offsets are computed by arbitrary Scheme code, \nso that automatic re-calculation is not generally possible. Functional reac\u00adtive programming [3] might \nbe the right solution to this problem, and we intend to explore this possibility in future work. Mean\u00adwhile, \nSlideshow s current trade-off (.exible place-over versus in.exible fonts) has worked well in practice. \nIf a pict needs to be Figure 1. Mousing over expressions to see resulting picts Figure 2. A pict box \ncontaining Scheme boxes parameterized by its font, we simply use functional abstraction or parameterize. \nCountless packages exist for describing slides with an HTML-like notation. Such packages typically concentrate \non arranging text, and pictures are imported from other sources. Countless additional packages exists \nfor creating slides with LATEX, including foiltex and Prosper [14]. With these packages, LATEX remains \nwell adapted for presenting math formulae and blocks of text, but not for con\u00adstructing pictures, and \nnot for implementing and maintaining ab\u00adstractions. Like Slideshow, Skribe [11, 12] builds on Scheme \nto support doc\u00adument creation, but Skribe targets mainly the creation of articles, books, and web pages. \nSince Skribe includes a LATEX-output en\u00adgine, it could be used to build slides through LATEX-based packages \nby adding appropriate bindings. Unlike Slideshow, most slide-presentation systems (including all LATEX-based, \nPostScript-based, and PDF-based systems) treat the slide viewer as an external tool. Separating the viewer \nfrom the slide-generation language makes display-speci.c customization more dif.cult, and it inhibits \nthe sort of integration with a program\u00adming environment that we advocate. An integrated viewer, mean\u00adwhile, \ncan easily support executable code that is embedded within slides. Embedded code is particularly useful \nin a presentation about programming or about a software system, since an eval hyperlink can be inserted \ninto any slide. More generally, Slideshow gives the presentation creator access to the complete PLT Scheme \nGUI tool\u00adbox, so practically anything is possible at presentation time. 7 Conclusion In only the last \nfew years, laptop-projected slides have become the standard vehicle for delivering talks, and tools other \nthan Power-Point are still catching up. We offer Slideshow as a remedy to PowerPoint s lack of abstraction, \nHTML s lack of .exibility, and LATEX s lack of maintainability. More generally, we believe that the time \nis ripe for a functional approach to slide construction, so we have reported on the constructs that we \nhave found to work best. Programmatic construction of pictures and slides is probably not for everyone \n(even with powerful programming-environment tools). For various reasons, many people will prefer to create \npictures and slides in PowerPoint and without signi.cant abstraction, no matter how nice the language \nof picture construction. For the authors tastes and purposes, however, programmatic con\u00adstruction works \nwell, and we believe that it appeals to many pro\u00adgrammers. In our slides, with proper code abstraction, \nwe can quickly experiment with different con.gurations of a picture, add slide-by-slide animation, and \nevolve ever more general libraries to use in constructing talks. Many tasks can be automated entirely, \nsuch as typesetting code and animating reduction sequences. All of the .gures in this paper are generated \nby Slideshow s pict library, using exactly the code as shown.2 In fact, like many other picture languages, \nSlideshow began as a system for generating .g\u00adures for papers, and the core pict language works equally \nwell on 2We re-de.ned the slide operations to produce boxed picts, we scaled a few picts to save space, \nand we used Slideshow ver\u00adsion 299.10, which includes minor improvements compared to the version 207 \ndistribution. paper and on slides. A picture language alone is not enough, how\u00adever; most of our effort \nbehind Slideshow was in .nding appropriate constructs for describing, staging, and rendering slides. \nFor further information on using Slideshow and for sample slide sets (including slides for conference \ntalks and slides for two courses), see the following web page: http://www.plt-scheme.org/software/slideshow/ \n 8 References [1] E. Chailloux, G. Cousineau, and A. Su\u00b4The MLgraph arez. System, 1997. [2] J. Clements, \nM. Felleisen, R. B. Findler, M. Flatt, and S. Kr\u00adishnamurthi. Fostering little languages. Dr. Dobb s \nJournal, pages 16 24, Mar. 2004. [3] C. Elliott and P. Hudak. Functional reactive animation. In Proc. \nACM International Conference on Functional Program\u00adming, pages 263 273, 1997. [4] R. B. Findler, C. Flanagan, \nM. Flatt, S. Krishnamurthi, and M. Felleisen. DrScheme: A pedagogic programming envi\u00adronment for Scheme. \nIn Proc. International Symposium on Programming Languages: Implementations, Logics, and Pro\u00adgrams, pages \n369 388, Sept. 1997. [5] S. Finne and S. Peyton Jones. Pictures: A simple structured graphics model. \nIn Proc. Glasgow Functional Programming Workshop, July 1995. [6] P. Henderson. Functional geometry. In \nProc. ACM Confer\u00adence on Lisp and Functional Programming, pages 179 187, 1982. [7] J. D. Hobby. A user \ns manual for MetaPost. Computer science technical report, AT&#38;T Bell Laboratories, 1992. CSTR-162. \n[8] S. N. Kamin and D. Hyatt. A special-purpose languae for picture-drawing. In Proc. USENIX Conference \non Domain-Speci.c Languages, pages 297 310, Oct. 1997. [9] B. W. Kernighan. PIC a graphics language \nfor typesetting, user manual. Computer science technical report, AT&#38;T Bell Laboratories, 1991. CSTR-116. \n [10] PLT. PLT Scheme. www.plt-scheme.org. [11] M. Seranno and E. Gallesio. Skribe Home Page. http://www.inria.fr/mimosa/fp/Skribe. \n[12] M. Seranno and E. Gallesio. This is Scribe! In Proc. Work\u00adshop on Scheme and Functional Programming, \npages 31 40, Oct. 2002. [13] C. J. Van Wyk. IDEAL user s manual. Computer science technical report, AT&#38;T \nBell Laboratories, 1981. CSTR-103. [14] T. Van Zandt. Prosper. prosper.sourceforge.net.  \n\t\t\t", "proc_id": "1016850", "abstract": "Among slide-presentation systems, the dominant application offers essentially no abstraction capability. Slideshow, an extension of PLT Scheme, represents our effort over the last several years to build an abstraction-friendly slide system. We show how functional programming is well suited to the task of slide creation, we report on the programming abstractions that we have developed for slides, and we describe our solutions to practical problems in rendering slides. We also describe a prototype extension to DrScheme that supports a mixture of programmatic and WYSIWYG slide creation.", "authors": [{"name": "Robert Bruce Findler", "author_profile_id": "81100028925", "affiliation": "University of Chicago", "person_id": "PP14022884", "email_address": "", "orcid_id": ""}, {"name": "Matthew Flatt", "author_profile_id": "81100490544", "affiliation": "University of Utah", "person_id": "PP39045354", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1016850.1016880", "year": "2004", "article_id": "1016880", "conference": "ICFP", "title": "Slideshow: functional presentations", "url": "http://dl.acm.org/citation.cfm?id=1016880"}