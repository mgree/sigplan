{"article_publication_date": "09-19-2004", "fulltext": "\n Types for Path Correctness of XML Queries Dario Colazzo Giorgio Ghelli Paolo Manghi Carlo Sartiani Dipartimento \ndi Informatica -Universit` a di Pisa Via Buonarroti 2, Pisa, Italy {colazzo,ghelli,manghi,sartiani}@di.unipi.it \nAbstract If a subexpression in a query will never contribute data to the query answer, this should be \nregarded as an error. This principle has been recently accepted into mainstream XML query languages, \nbut was still waiting for a complete treatment. We provide here a precise de.nition for this class of \nerrors, and de.ne a type system that is sound and complete, in its search for such errors, for a core \nlan\u00adguage, under mild restrictions on the use of recursion in type de.\u00adnitions. In the process, we describe \na dichotomy among existential and universal type systems, which is useful to understand some un\u00adusual \nfeatures of our type system. Categories and Subject Descriptors: H.2.3 [Database Manage\u00adment]: Languages-Query \nLanguages General Terms: Languages, Theory, Algorithms, Veri.cation Keywords: Type Correctness, XML Queries, \nXML Types. 1 Introduction A type system for a query language usually ful.lls two different aims: computing \na type for the query result (result analysis), and .agging parts of the query that do not match the structure \nof the data (correctness analysis), such as the use of a .eld name that is not present in the database \nschema. Result analysis and correct\u00adness analysis are inseparable in traditional languages, where er\u00adrors \nprevent result generation. Query languages for semistructured data (SSD) and XML are different, since \nwrong paths just gener\u00adate empty pieces of result. For these languages, the type systems proposed up \nto now only analyze the result type, disregarding, to a large extent, the navigation-correctness problem \n[6, 16, 3]. This situation is now beginning to evolve. In our paper [10], we presented a .rst notion \nof error, which was a stepping stone toward the one we propose here, based on the intuition that a query \nis cor\u00adrect if it may match some data. Along a similar line, the most recent versions of XQuery (starting \nfrom the August 2003 Working Draft) state that it is a static error for any expression other than the \nempty\u00adsequence expression to have the empty type. Since a static error\u00adchecking system is only a tool \ntoward an error-prevention aim, we start by de.ning which error we are trying to prevent (Section 3). \nThe notion of correctness we de.ne is existential, which means that a piece of code is correct if there \nexists at least one valid instance of its free variables such that an undesirable condition (result empti\u00adness, \nin our case) is avoided. This is in sharp contrast with the uni\u00adversal (or conservative) notions of correctness \nfound in program\u00adming languages, where a piece of code is correct if an undesired event is avoided under \nevery valid instantiation of its free variables. This quanti.cation switch has deep consequences on the \nnature of the theory that one develops, as we will discuss in the paper. Once we have de.ned the error, \nwe de.ne the type rules aimed to prevent it. Our type system is based on a couple of technical tools, \nthe collections of locations of wrong subqueries (Section 4.2) and type-splitting (Section 5). We prove \nthat, at the price of a mild re\u00adstriction on the use of recursion, our type system infers types that \nprovide both an upper and a lower bound for the actual values re\u00adturned by a query, and captures all \nand only the navigation-errors in the query. The completeness result is of course lost if the language \nis gener\u00adalized to a realistic one, but is still interesting, because soundness results alone do not \ndiscriminate an interesting type-system from one that is completely trivial. Our type system, although \ndesigned to deal with an existential no\u00adtion of correctness, can be used to check universal notions of \ncor\u00adrectness at the same time. We base our analysis on a tiny language, \u00b5XQ, based on the UnQL, Lorel, \nStruQL, XML-QL, Quilt, XQuery (and others) tradition [7, 1, 13, 6]. 2 \u00b5XQ \u00b5XQ is a minimal query language \nmanipulating forests of ordered trees. It has been designed to be the minimal core of XQuery-like languages, \nsimilarly to .-calculus for functional languages, hence we choose not to include features such as the \nwhere clause, node identity, document order, recursive functions. In Section 7 we dis\u00adcuss how to extend \nthis work to those features. \u00b5XQ term and query grammar is shown below. There f and t de\u00adnote respectively \nforests and trees, and l ranges over a set of labels L. Furthermore, b denotes a leaf value of a base \ntype B, forest con\u00adcatenation , is associative, and (), f = f ,() = f . Permission to make digital or \nhard copies of all or part of this work for personal or classroom use is granted without fee provided \nthat copies are not made or distributed for pro.t or commercial advantage and that copies bear this notice \nand the full citation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. ICFP 04, September 19 21, 2004, Snowbird, Utah, \nUSA. Copyright 2004 ACM 1-58113-905-5/04/0009 ...$5.00 A typical \u00b5XQ query consists of a binding section \n(let/for), where variables are bound, and a return clause that builds the results. Variables can be either \nfor-variables or let-variables. for\u00advariables (x,y, z) are bound to trees t (items) by a for binder. \nlet\u00advariables (x,y,z) are bound to forests f by a let binder. This dis\u00adtinction simpli.es the formal \ntreatment, but is not crucial to our approach. Forests f ::= () | t | f , f Trees t ::= b | l[ f ] Queries \nQ ::= () | b | l[Q] | Q,Q | x | x | x child :: l | x dos :: l | for x in Q return Q | let x ::= Q return \nQ In the examples we will also use the XPath-like clauses Q/l and Q//l, de.ned as: Q / l = for x in Q \nreturn x child :: l Q // l = for x in Q return x dos :: l The semantics [Q]. of a query Q w.r.t. a substitution \n. is de.ned in Table 2.1; . maps every for-variable x free in Q to a tree, and ev\u00adery free let-variable \nx to a forest. [let x ::= Q1 return Q2]. eval\u00aduates Q2 in . extended with the binding x .[Q1].. .t.trees( \nf ) A(t), where trees( f ) returns the sequence of trees of f , is de.ned as the forest A(t1),...,A(tn) \nif f = t1,...,tn, hence is () when f = (). childr(t) returns the list of all children of a tree l[ f \n] (it is unde\u00ad.ned over B), dos( f ) returns the list of all descendants-or-self of all trees in a forest \nf . f :: l selects all trees in f whose root is labeled l. We will need the operation (Q)|\u00df, which, for \nany query Q and loca\u00ad tion \u00df, locates the corresponding subquery. The location \u00df is just a path of 0 \ns and 1 s, and the function (Q)|\u00df follows \u00df in a walk down the syntax tree of Q. DEFINITION 1 ((Q)|\u00df:). \n(Q)|\u00df denotes the subterm of the query Q located by the location \u00df, which is a sequence of 0 s and 1 \ns: t (Q)|e = Q t (l[Q])|0.\u00df =(Q)|\u00df t (Q0, Q1)|i.\u00df =(Qi)|\u00df i .{0, 1} t (for x in Q0 return Q1)|i.\u00df =(Qi)|\u00df \ni .{0, 1} t (let x ::= Q0 return Q1)|i.\u00df =(Qi)|\u00df i .{0, 1} t (Q)|\u00df = . otherwise We also de.ne Locs(Q)= \n{\u00df | (Q)|\u00df =.}.  3 Query Correctness W3C states that a subquery is wrong when its type is empty but \nthe query is different from () [12]. We have .rst to explain why we cannot just adopt this as the de.nition \nof navigation-incorrectness.1 If a type system is used to identify a class of errors, the error must \nbe de.ned .rst (e.g., a core-dump is an error), then the type rules must be introduced, and .nally the \nadherence of the type-system .ndings with the semantic errors must be evaluated. A notion of error that \ndepends on the type rules under de.nition prevents the investiga\u00adtion of this fundamental adherence question. \nFor this reason, we start the investigation with the de.nition of a notion of navigation\u00adcorrectness \nthat only depends on the language semantics, namely, on the semantics of a subquery to be empty, rather \nthan on its type to be empty. 1Actually, W3C documents do not advertise this statement as a notion of \nerror, but only as a type rule. In this section we propose our notion, and show that it is pragmat\u00adically \nacceptable, i.e. it is quite strict (stricter variants would rule out some common jargon) but it is not \ntoo strict (every non-correct query really has a problem). The next sections will show how this notion \nis technically acceptable, in the sense that it is possible to design a type system that matches it very \nprecisely. Assume the existence of two variables $contacts and $mobilecontacts (we use here $ to identify \nvariables) with types: $contacts : (data[phone[...] | mobile[...]])+ $mobilecontacts : (data[mobile[...]])+ \nwhere | is a union type operator (i.e., either-or), and + indicates an arbitrary, non-empty, repetition, \nand consider the following queries: Q1:$contacts/fone Q2:$contacts/phone, $contacts/mobile Q3:$contacts/phone \nQ4:$contacts/fone,$contacts/mobile Q5: for $c in $contacts return ($c/phone,$c/mobile) Q6: for $c in \n($contacts, $mobilecontacts) return ($c/phone,$c/mobile) Q1 is wrong, since it cannot match the data, \nwhile Q2 is correct, since it perfectly matches the schema, i.e. the query surely matches data conforming \nto the given schema. Such queries lead to the sim\u00adplest de.nition of correctness: a query is correct \nif it always .nds some data, for every substitution of its free variables that is valid, i.e. coherent \nwith the known structural information. Q3, however, shows that this view is over-restrictive: the query \nis completely rea\u00adsonable, but it may not match any data, in case we only have mo\u00adbiles in the current \ndatabase instance. This query is typical enough to convince us that, in this context, we have to opt \nfor an existen\u00adtial notion of correctness: a query is correct if there exists a valid schema instance \nthat is matched by the query. This is the notion we studied in [10], under the name weak correctness \n. Q4 is troublesome. It is clearly wrong, since the .rst path cannot match the data, however the whole \nquery can return a non-empty result, hence the whole query does match some valid schema in\u00adstance, and \nis hence weak-correct . The point is that the non-matching subquery does not generate, ac\u00adcording to \n\u00b5XQ semantics, a no-match-found error which propa\u00adgates up from $contacts/fone to the whole result. Moreover, \nwe would not want such behavior, otherwise the subqueries of the good query Q2 would raise and propagate \nthat error as well, for example when no $mobile is in the database. In a programming language with error \npropagation we can say that something goes wrong iff the whole program returns error . Here, instead, \nwe have to talk about the result of every subquery. We hence arrive at the following notion of correctness \n(where non-() means syntactically different from () ): DEFINITION 2. Foreach-Exist (FE) Query Correctness: \nA query Q is correct w.r.t. a set of valid substitutions R if, for each non-() subquery Q' in Q, there \nexists . . R such that, when Q is evaluated under .,Q' evaluates to a non-empty sequence. As desired, \nunder this characterization, Q2 and Q3 above are correct, while Q1 and Q4 are not. Query Q6, which corresponds \nto a typical XQuery jargon, is correct as well, if we apply the existential quanti.cation to the bindings \nof the variables bound by for: at least one binding for $c exists (under a valid substitution for $contacts \nand $mobilecontacts) that makes $c/phone productive. Q5 is cor\u00adrect a fortiori. Table 2.1. \u00b5XQ semantics \nb]. ()]. x child :: l].[ x dos :: l]. dos(b) dos(l[ f ]) t = b t= () t = childr([x].) :: l t = dos([x].):: \nl t= () t = l[ f ],dos( f ) x]. t = .(x) x]. Q1, Q2]. t = [Q1].,[Q2]. [ l[Q]]. let x ::= Q1 return Q2]. \nt = [Q2].,x.[Q1].[ for x in Q1 return Q2]. t = .t.trees([Q1].)[Q2].,x.t childr(b) t = . b:: l childr(l[ \nf ]) t = f l[ f ]:: l t = .(x) t = l[[Q].] t= () t = l[ f ] dos(()) t= () ():: l t= () dos( f , f ') \nt = dos( f ),dos( f ') ( f , f '):: l t = f :: l, f ' :: l m[ f ]:: l t= () m = l Once one accepts that \ncorrectness, in this context, has to be exis\u00adtentially quanti.ed on substitutions and universally on \nsubqueries, there is still space to consider a last variation, the exists-foreach version, where the \nquanti.cation order is exchanged: REMARK 1. Exist-Foreach (EF) Query Correctness: A query Q is correct \nw.r.t. a set of valid substitutions R if there exists . . R such that, for each non-() subquery Q ' in \nQ, when Q is evaluated under .,Q ' evaluates to a non-empty sequence. While FE-correctness only requires \nthat each subquery makes sense w.r.t. a different substitution, this stricter version requires the exis\u00adtence \nof at least one database that exploits every subquery. This variation is equivalent to FE-correctness \non queries Q1-Q4, but it differs on queries Q5-Q6. In these queries, there exists no single substitution \nfor $c that makes both $c/phone and $c/mobile pro\u00adductive at the same time. Since Q5 and Q6 are sensible \nqueries, and correspond to XQuery usage patterns, we conclude that the exist\u00adforeach version of correctness \nwould be too strict for our purposes. So, we have shown that our notion rules out some wrong queries \nand that its most natural immediate strengthening is too strict. Hence, we have shown that our notion \nis maximally strict . We have now to show that our notion is arguably not too strict, since it only .ags \nqueries that really have a problem. This is simple: by de.nition, if a query Q is not FE-correct, a non-() \nsubquery Q ' exists, such that for all . . R , Q ' evaluates to an empty sequence. Hence, we have a non-() \npiece of code that is equivalent to (), and warning the programmer makes obviously sense. To formalize \nFE-correctness we de.ne Ext(., Q, \u00df), the set of all valid substitutions that will be used to evaluate \nthe subquery (Q)|\u00df when Q is evaluated under .. These substitutions correspond to . extended with the \nbindings introduced by each traversed let or for. Ext(., Q, \u00df) is not just a singleton since each subquery \nin the scope of a for x in Q0 is evaluated once for each tree in [Q0].. Since [Q0]. may be the empty \nforest, Ext(., Q, \u00df) may be empty as well. DEFINITION 3. Substitution Extension t Ext(., Q, e)= {.} Ext(., \nlet x ::= Q0 return Q1, 1.\u00df) t = Ext((.,x .[Q0].), Q1, \u00df) Ext(., for x in Q0 return Q1, 1.\u00df) t S = t.trees([Q0].) \nExt((., x.t), Q1, \u00df) otherwise: (Q)|i = .. Ext(., Q, i.\u00df) t = Ext(., (Q)|i, \u00df) FE-correctness can be \nformally captured in terms of substitution extension. A non-() subquery (Q)|\u00df is correct if there exist \n. . R and .'. Ext(\u00df, Q, .) such that [(Q)|\u00df].' = (). Indeed, if such a substitution cannot be found, \n(Q)|\u00df is useless to the whole query, and is hence incorrect. We .rst de.ne the set CriticalLocs(Q) of \nthe locations of Q where we will look for pieces of wrong code. CriticalLocs(Q) t = {\u00df | ((Q)|\u00df =(x child \n:: l) . (Q)|\u00df =(x dos :: l))}. {\u00df.0 | (Q)|\u00df = for x in Q0 return Q1} CriticalLocs(Q) does not coincide \nwith Locs(Q) because, at least, all locations that reach a subquery that is () must not be tested for \nnon-emptiness. But we can also observe that a let subquery evalu\u00adates to () if and only if the return \nsubquery does, hence, once we have indicated that the return subquery has a problem, the same information \nabout the whole let subquery is redundant. A similar consideration holds for a Q0,Q1 subquery: once the \nsubqueries Q0 and Q1 have been checked, any information about the fact that the whole Q0, Q1 evaluates \nto () is redundant. After a complete analy\u00adsis, one realizes that only errors located in subqueries from \nwhich the programmer explicitly started a child/dos navigation or a for iteration should be considered. \nWe can now formalize query correctness. DEFINITION 4. Correctness of Q w.r.t. R : Let R be a set of sub\u00adstitutions \nfor the free variables of a query Q. Q is correct w.r.t. R iff: .\u00df.CriticalLocs(Q). ...R . ..'.Ext(., \nQ, \u00df). [(Q)|\u00df].' = () Dually, Q has an error at path \u00df.CriticalLocs(Q) iff: .. .R . ..'.Ext(., Q, \u00df). \n[(Q)|\u00df].' = () (Observe that Ext(., Q, \u00df)= 0/ implies that Q has an error at \u00df.) While this notion of \n(navigation-)correctness is existential, one may still extend \u00b5XQ with other operations that more naturally \nlead to a universal notion of correctness, as happens with operations that modify persistent data. In \nthis context, a piece of code would be correct if it were navigation-correct for at least one substitution \nand update-correct for every substitution.  4 Type System 4.1 Type Environments and Types We adopt, \nessentially, XDuce s type language [14]. Types and type environments are de.ned as follows: Types T ::= \n() empty forest type Environments E |||||| ::= B T,T T | T l[T ] T * X () base type product type union \ntype element type repetition type type variable | X =T, E An element type with empty content l[()] will \nalways be abbrevi\u00adated as l[]. A type environment E is a sequence of type de.nitions of the form X = \nT where no type variable is bound to two types; E(X) denotes the type bound to X by E. We restrict to \nl[]-guarded type environments, that are environments where only l[]-guarded vertical recursion is allowed, \nas in X = l[X |()] for example; we forbid equations like X = X | () and X = X,Y . The lack of horizontal \nrecursion is counterbalanced by the presence of the Kleene star operator *. This restriction is canonical, \nand makes the type language as expressive as regular tree languages [15, 11], hence expressive enough \nto capture the essence of DTD and XML Schema [15, 18, 17]. Type semantics is standard: []E is the minimal \nfunction from types to sets of forests that satis.es the following monotone equations (the function is \nwell-de.ned by Knaster-Tarski theorem): t [()]E = {()} t = {b} B]E t '' ' T,T ]E = { f , f | f .[T ]E \n, f '.[T ]E }'' t T | T = ]E [T ]E . [T ]E t l[T ]]E = {l[ f ] | f .[T ]E } t = {(), f1,..., fn | n = \n0, T *]E fi .[T ]E } t = [ X]E [E(X)]E An environment E is well-formed only if it is l[]-guarded and \nde\u00ad.nes type with non-empty semantics, i.e. empty-type de.nitions like X = l[X] are not allowed. This \ncondition admits an easy syn\u00adtactic test (see [9] for details). The non-emptiness condition is not essential, \nbut simpli.es the type rules. In a nutshell, if x : T , and T may be empty, then x : T . for y in x return \nQ may be incorrect just because T is empty, and the type rules would have to check this. A type T is \nwell-formed in an environment E if every variable in T is de.ned in E. 4.2 Analysis of for and Locator \nSets The type assignments for the free variables of a query are de.ned by means of variable environments \nG of the form: Variable Environments G ::= () | x : T,G | x : T,G A variable environment G is well-formed, \nw.r.t. an environment E, if no variable is de.ned twice, if every type is well-formed in E, and if every \nfor-variable x is associated to a tree type (l[T '] or B). Our type rules (Table 4.1) are based on judgments \nof the form: judgments J ::= E; G .\u00df Q : (T ; S) |E; G .\u00df x in T . Q : (T ; S) In E; G .\u00df Q : (T ; S), \nthe type T is the result type of Q, and de.nes an upper bound for the actual set of values for Q; the \nrole of S and \u00df will be discussed shortly. To analyze for x in Q1 return Q2, we compute a type T1 for \nQ1 (Table 4.1, rule TYPEFOR) and use the judgment E; G .\u00df x in T1 . Q2: (T2; ) to compute the type of \nQ2 through a case-analysis on the type T1 (rules (TYPEIN. . .)). By rule (TYPE-INELSPLITTING), case-analysis \nstops when a tree type l[T ] is met, therefore l[]-guardedness of E implies that recursive type\u00advariables \ndo not make case-analysis loop forever. Rule (TYPE-INELSPLITTING), and rule (TYPELETSPLITTING), use the \nfunc\u00adtion SplitE (T ), to be discussed later. For now, we simply de.ne SplitE (T )= {T }. Our typing \njudgments also return an error set S, which contains a set of locations with shape \u00df.a, such that, for \neach a, the sub\u00adquery of Q at a is not FE-correct. This is a sharp departure from the traditional approach, \nwhere the result of error-checking is just a boolean. We believe booleans are not enough, in a system \nthat com\u00adbines case-analysis with subquery quanti.cation. Consider, for ex\u00adample, the following queries \nover $contacts : (data[phone[...]] |data[mobile[...]])+. Q5: for $c in $contacts return ($c/phone,$c/mobile) \nQ7: for $c in $contacts return ($c/fone,$c/mobile) Because of universal quanti.cation on subqueries (De.nition \n4), a query (Q,Q ') is FE-incorrect iff either Q or Q ' is. Be\u00adcause of existential quanti.cation on \nsubstitutions, a query for y in x return Q is FE-incorrect iff Q is incorrect for every binding of y. \nHence, a case-analysis-based type checking algorithm would compute the error-checking function ErrG(Q) \nas follows: Err$c:(T1|T2)(Q7) V = T .{T1 ,T2 }(Err$c:T ($c/fone) . Err$c:T ($c/mobile)) As expected, \nQ7 is deemed wrong because for every Ti at least one of $c/fone and $c/mobile is wrong. Unfortunately, \nthe cor\u00adrect query Q5 is deemed wrong as well: since each of the sub\u00adcases data[phone[...]] and data[mobile[...]] \nmakes one of the sub\u00adqueries incorrect, the external conjunction returns true. Err$c:(T1 |T2)(Q5) V = \nT .{T1,T2}(Err$c:T ($c/phone) . Err$c:T ($c/mobile)) The problem cannot be solved by playing with the \nboolean op\u00aderators, since they exactly correspond to the quanti.cations in the de.nition of FE-correctness. \nHowever, we can generalize booleans to sets of locations, and use the following equations, where ErrLeaf(Q) \nreturns the location of Q when Q is wrong. Err$c:(T1 |T2 )(Q5) T = T .{T1,T2} ({ErrLeaf$c:T ($c/phone)}.{ErrLeaf$c:T \n($c/mobile)}) Err$c:(T1 |T2 )(Q7) T = T .{T1,T2} ({ErrLeaf$c:T ($c/fone)}.{ErrLeaf$c:T ($c/mobile)}) \nThis time Err(Q5) is the intersection of two different singletons of locations, hence is empty. This \ncorresponds to the fact that no subquery is always returning an empty result, hence no subquery is incorrect. \nHowever, Err(Q7) is the intersection of two sets that both contain the location of $c/fone. This signi.es \nthat, for every well\u00adtyped substitution for $c, the subquery $c/fone is always empty, hence the subquery \nis incorrect. The type rules are listed in Tables 4.1 and 4.2. We describe them by referring to the example. \nRule (TYPEFOR) starts the case-analysis, as previously discussed, propagates the error set S1, and adds \nan error \u00df.0 if the type of Q1 only contains the empty forest (\u00df is a current-location parameter propagated \nand updated by the rules). It uses the auxiliary judg\u00adment T ~E (), which checks whether [T ]E = [()]E \n, and is de.ned below.2 Rules (TYPEINUNION) and (TYPEINCONC) perform the case analysis, and only put \nin S those locations that are wrong in both branches. Rule (TYPEINELSPLITTING) stops the case-analysis, \ninserts the assumption x : m[T ] in G, and falls back to standard type-checking (recall that we assumed \nSplitE (T )= {T }). At this point, rule (TYPECHILD) is applied. It requires the type of x to be a tree \ntype ' m[T '], uses E . T :: l . U (de.ned below) to restrict the content ' type T to the tree types \nwith structure l[], and puts an error lo\u00adcation \u00df in S iff the restricted type U is equivalent to the \ntype () (which is an easy test). Rule (TYPEDOS) is similar, but, instead of using the content type T \n', it extracts all the node types {U1,...,Un}that are reachable from T , using the function TreesE (T \n) de.ned be\u00ad '' low, and de.nes a new type U =(U1 | ... | Un)*. U is the type of any forest that only \ncontains nodes whose type is one of the Ui s, hence is an appropriate type for the forest of all descendants \nof a ' tree of type T . The type of x dos :: l is obtained by restricting U to the tree types with structure \nl[]. Rule (TYPELETSPLITTING) is standard, since we are assuming that SplitE (T )= {T }. We will later \nrelax this assumption. We now de.ne the auxiliary function TreesE (T ), the predicate T ~E (), and the \nauxiliary judgments E . T :: l . U. DEFINITION 5. Subtrees Type Extraction: For any E well-formed and \nT such that E . T Def, we de.ne TreesE (T ) as follows (well\u00adde.ned by Knaster-Tarski Th.): t TreesE \n(()) = 0/ t TreesE (B)= {B} t TreesE (l[T ]) = {l[T ]}. TreesE (T ) t TreesE (T,U)= TreesE (T ) . TreesE \n(U) t TreesE (T *)= TreesE (T ) t TreesE (T | U)= TreesE (T ) . TreesE (U) t TreesE (X)= TreesE (E(X)) \nDEFINITION 6. Empty-Forest-Type Checking: For any well\u00adformed environment E and type T well-formed in \nE, we de.ne T ~E () as the minimal function (assuming false < true) that respects the following set of \nequations, well-de.ned by Knaster\u00ad 2The type () is not to be confused with the empty type. It is a singleton \ntype, which only contains the empty forest. Tarski theorem: () ~E () t = true l[T ] ~E () t = false B \n~E () t = false T,U ~E () t = T ~E () .U ~E () T * ~E () t = T ~E () T | U ~E () X ~E () t = t = T ~E \n() .U ~E () E(X) ~E () Correctness of this de.nition is proved by the following theorem. LEMMA 1 (EMPTY-FOREST-TYPE \nCHECKING). For any well-formed environment E and type T well-formed in E: T ~E () . [T ]E = {()} The \njudgment E . T :: l . U is de.ned by the rules in Table 4.2. LEMMA 2 (TERMINATION OF TYPE FILTERING). \nFor any la\u00adbell,typeenvironmentEwell-formedandtypesT andU,theback\u00adward application of the type rules \nto E . T :: l . U terminates. LEMMA 3 (TYPE FILTERING CHECKING). For any label l, well-formed type environment \nE and type T well-formed in E: E . T :: l . U . [U]E = { f :: l | f . [T ]E }  4.3 Properties of the \nType System We provisionally assumed that SplitE (T )= {T }, which results in a completely standard (TYPELET) \nrule. This is suf.cient to obtain the canonical soundness property (Theorem 4): types are upper bounds \nfor the set of all possible results. (This implies that this type system can be used to check universal \nnotions of correctness, though we will not exemplify this fact here.) DEFINITION 7. R (E,G): For any \nwell-formed type environment E and G well-formed in E, we de.ne the set of valid substitutions as R (E,G)= \n{. | . . f . . . (. : T . G . f . [T ]E )} where . is either a for-variable or a let-variable. THEOREM \n4 (UPPER BOUND). For any well-formed environment E, G well-formed in E, and well-formed Q: E; G .\u00df Q \n: (U; ) . . .R (E,G) . [Q]. . [U]E The next property one expects is some form of well typed terms never \ngo wrong property, that speci.es that every run-time error is detected by the type system. But in this \ncontext we believe that one should .rst look for the opposite implication we will never bother you with \na false alarm . We expect that a type system based on our proposal would be used as an auxiliary tool \nin a programming envi\u00adronment based on a commercial language, and that the programmer would be allowed \nto ignore its error messages. As a consequence, most programmers would just ignore all the error messages, \nif there is the doubt that they do not correspond to real errors, but are just a .gment of the type rules. \nHence we believe that, in this context, the essential sound\u00adness property of error-checking is that expressed \nby Theorem 5, which goes the other way around with respect to the standard progress+subject reduction \ncombination. Table 4.1. Query Type Rules (TYPEEMPTY) WF(E; G .\u00df () : ((); 0/)) E; G .\u00df () : ((); 0/) \n(TYPEVARLET) x : T . G WF(E; G .\u00df x : (T ; 0/ )) E; G .\u00df x : (T ; 0/) (TYPEELEM) E; G .\u00df.0 Q : (T ; S) \nE; G .\u00df l[Q] : (l[T ]; S) (TYPELETSPLITTING) E; G .\u00df.0 Q1: (T1; S) SplitE (T1)= {A1,...,An}E; G, x : \nAi .\u00df.1 Q2: (Ui; Si) T E; G .\u00df let x := Q1 return Q2: (U1 | ... | Un; S . Si) i=1...n (TYPEINEMPTY) \nWF(E; G .\u00df x in () . Q : ((); \u00df.CriticalLocs(Q))) E; G .\u00df x in () . Q : ((); \u00df.CriticalLocs(Q)) (TYPEINELSPLITTING) \nSplitE (m[T ]) = {A1,...,An} E; G, x : Ai .\u00df Q : (Ui; Si) T E; G .\u00df x in m[T ] . Q : (U1 | ... | Un; \nSi) i=1...n (TYPEINCONC) E; G .\u00df x in T . Q : (T ' ; S1) E; G .\u00df x in U . Q : (U' ; S2) ' E; G .\u00df x in \nT,U . Q : (T ,U' ; S1 n S2) (TYPEINVAR) E(X)= T E; G .\u00df x in T . Q : (U; S) E; G .\u00df x in X . Q : (U; \nS) (TYPECHILDNOMATCH) WF(E; G .\u00df x child :: l : (U; S)) x : T . G . T = B E; G .\u00df x child :: l : ((); \n\u00df) (TYPECHILD) WF(E; G .\u00df x child :: l : (U; S)) x : T . G . T = m[T '] E . T ' :: l . U S = if U ~E \n() then {\u00df} else 0/ E; G .\u00df x child :: l : (U; S) (TYPEATOMIC) WF(E; G .\u00df b : (B; 0/)) E; G .\u00df b : (B; \n0/ ) (TYPEVARFOR) x : T . G WF(E; G .\u00df x : (T ; 0/)) E; G .\u00df x : (T ; 0/) (TYPEFOREST) E; G .\u00df.0 Q1: \n(T1; S1) E; G .\u00df.1 Q2: (T2; S2) E; G .\u00df Q1,Q2: (T1, T2; S1 . S2) (TYPEFOR) E; G .\u00df.0 Q1: (T1; S1) E; \nG .\u00df x in T1 . Q2: (T2; S2) S = if T1 ~E () then {\u00df.0} else 0/ E; G .\u00df for x in Q1 return Q2: (T2; S1 \n. S2 . S) (TYPEINATOMIC) E; G, x : B .\u00df Q : (U; S) E; G .\u00df x in B . Q : (U; S) (TYPEINUNION) ' E; G \n.\u00df x in T1 . Q : (T1; S1) ' E; G .\u00df x in T2 . Q : (T2; S2) '' E; G .\u00df x in T1 | T2 . Q : (T1 | T2; S1 \nn S2) (TYPEINSTAR) E; G .\u00df x in T . Q : (U; S) E; G .\u00df x in T *. Q : (U*; S) (TYPEDOSNOMATCH) WF(E; G \n.\u00df x child :: l : (U; S)) x : T . G . T = B E; G .\u00df x dos :: l : ((); \u00df) (TYPEDOS) WF(E; G .\u00df x dos :: \nl : (U; S)) x : T . G . T = m[T '] {U1,...,Un} = TreesE (m[T ']) U' =(U1 | ... | Un)* E . U' :: l . U \nS = if U ~E () then {\u00df} else 0/ E; G .\u00df x dos :: l : (U; S) Table 4.2. Filter Type Rules (MATCH) E . \nl[T ] :: l . l[T ] (FORESTFILT) '' E . T :: l . TE . U :: l . U '' E . T,U :: l . T ,U (UNIONFILT) '' \nE . T :: l . TE . U :: l . U ' E . T | U :: l . T '| U (NOMATCHFILT) T = B . T = m[T '] E . T :: l . \n() (STARFILT) E . T :: l . U E . T * :: l . U* (VARFILT) E . E(X) :: l . U E . X :: l . U THEOREM 5. \n(Soundness of Existential Error-Checking) For any well-formed environment E, G well-formed in E, and \nquery Q: E; G .\u00df Q : (U; S) . \u00df.a . S . . Q has an error at a w.r.t. R (E,G)  4.4 Existential vs. Universal \nError-Checking It is now time to cite some standard theorems that one may expect to hold, and which do \nnot. Recall query $contacts/phone from Section 3, and observe that it stops be\u00ading correct if one substitutes \n$contacts with a query, or a term, of type (data[mobile[...]])+, although this is a subtype of the original \ntype. This means that the canonical subsumption and substitution properties fail for this type system. \nPROPERTY 1 (SUBSUMPTION). In a type system that only checks a universally quanti.ed notion of correctness, \nif T '= T isa ' subtype relation such that T '= T . [T ]E . [T ]E, then E; G .e Q : (U; 0/) . (x : T \n) .G . . E; G .e Q1: (T ' ; 0/) . T '= T (where Q : ( ; 0/ ) means that Q has no static type error) implies \nE; G .e Q{x . Q1} : (U ' ; 0/) . U '= U PROPERTY 2 (WELL-TYPED SUBSTITUTION). In a type sys\u00adtem that \nchecks a universally quanti.ed notion of correctness, E; G .e Q : (U; 0/ ), ..R (E,G), and [ f ]. = .(x) \n(where f is a term of the subgrammar () | b | l[ f ] | f , f ' ) implies E; G .e Q{x . f } : (U; 0/). \nSubsumption and substitution are consequences of the universal na\u00adture of the errors one looks for in \ntraditional type system. There, every instantiation of a variable with a type-correct value is guar\u00adanteed \nnot to fail, hence, if we substitute the variable with a type\u00adcorrect expression, no error will arise. \nSubsumption derives from the universal nature of the checked er\u00adrors as well: if no value in a type creates \nproblems, a smaller type creates no problem a fortiori. Substitution and subsumption are so deeply ingrained \nin the tech\u00adniques we use to design type systems and to prove their properties, that their failure implies \nthat nothing should be taken for granted. For example, the fact that a type is just an upper bound of \nthe set of values returned by a query (Theorem 4) creates no problem in a system that enjoys subsumption: \nwhatever can be proved using this upper-approximation would be true a fortiori if one used a better approximation \n(i.e., a subtype). On the other hand, with an existen\u00adtial notion of error, when types become smaller, \nmore errors appear, hence an upper-bound approximation is going to mask some prob\u00adlems. In the end, we \nhave been able to design a framework where the pieces .t together, but some unusual features will show \nup. The fact that our notion of soundness of error-checking (Theorem 5) goes the other way round with \nrespect to canonical type systems is a .rst example. 4.5 Combining Universal and Existential The machinery \nwe presented can be actually used to check both existential and universal notions of correctness. To \nthis aim, the inferred type can be used in the standard way, so that a universally\u00adwrong subexpression \nwill not match any type rule. For example, we may have an integer + operator and the following rule. \n(TYPE+) E; G .\u00df.0 Q : (Int; S) E; G .\u00df.1 Q ' : (Int; S') E; G .\u00df Q + Q ' : (Int; S . S') If either Q \nor Q ' has a type that is different from Int, the expression will not type-check, nor will it type-check \nif one of them has a type Int | T . In such a system, the Upper Bound Theorem would imply the tra\u00additional \nError-Soundness theorem, going the other way round with respect to Theorem 5. THEOREM 6. (Soundness of \nUniversal Error-Checking) For any well-formed environment E, G well-formed in E, and well-formed Q: E; \nG .\u00df Q : (U; ) . . Q has no universal-error w.r.t. R (E,G)  5 Type-Splitting 5.1 Motivation and De.nition \nWe provisionally assumed that SplitE (T )= {T }. This simple def\u00adinition is enough to obtain soundness \nof type checking and error\u00adchecking. These are the canonical properties that are proved for any type \nsystem, but they are not very informative: any system that associates the universal type to any expression, \nand never .nds any existential error, enjoys them as well.3 For the core-language \u00b5XQ, we can actually \naim for a much stronger property: a type system that is complete, in a sense to be made precise later, \nand that is able to catch every FE-error. (No other proposed type system enjoys this property of completeness \nover the core .) Our provisional type system is not up to this aim. It is not precise enough when, for \nexample, there are variables that occur more than once (non-linear variables) and with a union type. \nFor example, consider the (arti.cial) type X = data[mobile[]*| phone[]*], and the query x/mobile,x/phone. \nWhen x has type X, this query yields either a sequence of elements mobile[] or a sequence of elements \nphone[]. Instead, as in XQuery, our type system infers a type (mobile[]*, phone[]*), which also con\u00adtains \nsequences with both mobile[] and phone[] elements. Our provisional type system does not guarantee completeness \nof error-checking either. For example, consider the type Y = c[a[] | b[]] and the query: Q8 = for x in \ny/a return y/b where y is of type Y . (This code returns a sequence of y/b iff y has a child a, and returns \n() otherwise.) The query is FE-incorrect, as there is no substitution that makes the subquery y/b yield \na not\u00adempty result: if y is of type c[a[]] then y/b cannot return any tree, and if y is of type c[b[]] \nthen y/a is empty, hence y/b will not be evaluated at all. Nevertheless, our provisional type system \nvalidates 3In the traditional view, soundness means: well-typed programs never go wrong. This is enjoyed \nby any type system that consider every program as ill-typed, since it .nds every universal error in every \nprogram. the query as correct. This is because the two uses of y are deemed acceptable by exploiting \ntwo separate, and incompatible, branches of the union type of y. (Similar phenomena happen in all related \ntype systems we are aware of, including the XQuery type system.) We solve these problems by de.ning a \ntype system that, when a variable with a union type is introduced, performs a case-analysis on the different \ncases of the union, even when the union type oper\u00adator is hidden inside the type (as in c[a[] | b[]]). \nIn our setting, this amounts to de.ning a non-trivial version of the Split() function. We will prove \nthat the resulting type system detects all FE-errors, and infers a type that provides both an upper and \na lower bound for the set of all possible query results (Theorem 14). Of course, the existence of any \nkind of correct and complete static analysis also shows that the language is, in some sense, poor. Speci.cally, \nour result relies on a monotonicity property of \u00b5XQ (Lemma 10) that would not hold in most realistic \nextensions of the language. Still, the existence of a core where the analysis is com\u00adplete is an important \nresult, because it formally measures the quality of the match between our notion of error and our type \nsystem. The error-complete approach is based on enumerating the branches of the union types of typed \nvariables (splitting the type), performing an independent analysis for each branch, and combining the \nresults. The amount of splitting is governed by the function SplitE (T ) (Def\u00adinition 8), which rewrites \nT to a set {T1,...,Tn} such that T1 | ... | Tn is equivalent to T . Essentially, SplitE (T ) rewrites \nT in order to make | be the outermost type operator. For example, type c[a[] | b[]] is split into {c[a[]], \nc[b[]]}, and the query Q8 presented above is an\u00adalyzed once with y : c[a[]] and once with y : c[b[]]. \nThe subquery (Q8)|1 is (correctly) .agged as wrong, since the location 1 is in the error set of both \nruns of the analysis. By splitting a type more and more .nely, a more precise type analy\u00adsis can be obtained, \nat the price of a more expensive type-checking process, since the rest of the query is checked once for \nevery addend generated by splitting. Our key result is the fact that splitting can be stopped in front \nof *\u00adtypes (SplitE (T *)= {T *}), and still the new type system enjoys the completeness properties formalized \nby Theorem 16 below. Hence, for example: SplitE ((data[phone[...] | mobile[...]])*) = {(data[phone[...] \n| mobile[...]])*} SplitE (phone[...] | mobile[...]) = {phone[...]; mobile[...]} SplitE (a[(b[],c[]) | \n(d[],e[])]) = {a[b[], c[]]; a[d[],e[]]}. The de.nition of SplitE (T ) is non-trivial because of recursive \ntype variables. Consider the type Y = a[Y ] | b[Y ] | () and a type assump\u00adtion y : Y . Every time we \nunfold Y , new instances of | appear, which have to be pulled out by SplitE (T ), and which generate \nnew cases to analyze. We would like to unfold Y just once, and to analyze the query just three times, \ntrying y : a[Y ], y : b[Y ] and y : (). But, con\u00adsider the following generalization of Q8, where (/a)n \nstands for n consecutive occurrences of /a: Qn = for x in y(/a)n /a return y(/a)n /b To catch the error, \nY must be unfolded n + 1 times. This means that we cannot decide how deeply Y has to be unfolded before \nlooking at the query under consideration. A more complex type system, where unfolding depends on the \nquery, may be worth studying. However, we claim that a simpler solution is acceptable in practice, based \non a mild restriction on the use of recursion. We restrict to environments E, namely *-guarded environments, \nfor which recursion is guarded by a * type construc\u00adtor, hence ruling out the Y type above (see [9] for \ndetails). Under this restriction, error-completeness is obtained by unfolding recur\u00adsion until * is met, \nand pulling out only the union type construc\u00adtors that are found outside the * (De.nition 8). Hence, \nwe have to prove that an assumption like y : (c[a[X] | b[X]])*, where union types are guarded by *, does \nnot need to be split any further. Splitting was needed, for query Q8, to detect a situation where the \ncorrectness of (Q8)|1 depended on the existence of two mutually incompatible paths c/a and c/b inside \nthe type of y. The key observation is the fact that these paths are not incompatible when y has type \nc[(a[] | b[])*], since c[a[], b[]] is a legitimate value for y. The non-existence of incompatible paths \nin types where union is guarded by * is formalized in Lemma 12, and Theorem 16 shows that this property \nis enough to guarantee error-completeness. We claim that our restriction is mild . Indeed, it is respected \nby all the schemas reported in the W3C document XML query use cases [8]. DEFINITION 8. SplitE (T ):IfE \nis *-guarded, then: SplitE (()) t = {()} SplitE (B) t = {B} SplitE (U*) t = {U*} SplitE (X) t = SplitE \n(E(X)) SplitE (T | U) t = SplitE (T ) . SplitE (U) SplitE (l[T ]) t = {l[A] | A . SplitE (T )} SplitE \n(T,U) t = t = {(A,B) | A . SplitE (T ) . B . SplitE (U)} SplitE (T ) is well-de.ned by Knaster-Tarski \ntheorem. If E is *\u00adguarded, SplitE (T ) can be computed by a standard top-down recur\u00adsive implementation \nof the de.nition above: *-guardedness of E implies that the * case will break any potential in.nite loop \ndue to the recursive de.nition of a type variable. Splitting preserves type semantics. LEMMA 7. For each \n*-guarded environment E and type T de.ned in E: S = [T ]EA.SplitE (T )[A]E 5.2 Simulation and Query \nMonotonicity To characterize the precision of the type system, we de.ne now a ' pre-order relation on \nforests f . f , forest simulation. This pre\u00adorder compares forests as if they were sets of trees instead \nof se\u00adquences, so that, for example, a[],a[] . a[] and a[],b[] . b[],a[], but ' implies path inclusion, \nso that if a/b isa pathof f and f . f , ' then a/b is a path of f as well. Simulation has the property \nthat, if a query is correct when run with y = f and f . f ', then the ' query is correct when run with \ny = f . Simulation allows us to formally specify that our type inference technique is precise up-to\u00adsimulation \n, and is a key tool in our proof of error-completeness. DEFINITION 9. Forest Simulation f . f ' : Simulation \nf . f ' is the smallest relation on forests that respects the following conditions: b . b l[ f1] . l[ \nf2] . f1 . f2 ' f . f ..t . trees( f ). .t '. trees( f '). t . t ' LEMMA 8. For each f and f ' : ' ( \nf . f . f = ()) . f ' = () Lemma 10 states that \u00b5XQ queries are monotone with respect to . extended to \nsubstitutions in the obvious way: . . .'.def .x . dom(.). .(x) . .'(x). We are not talking here about \nthe usual (trivial) set-of-values mono\u00adtonicity property, that states that, if the set of values that \nthe variable $x is allowed to range over increases, then the set of values that can be assumed by the \nquery result increases as well. We are stating here a much stronger property that speci.es that queries \nare mono\u00adtone with respect to a pre-order that is de.ned on values (forests, in this case), something \nsimilar to strictness properties for functional languages. This strong property is not needed in order \nto prove soundness results, but is crucial for completeness. Query monotonicity depends on monotonicity \nof axis steps. LEMMA 9 (MONOTONICITY OF AXIS STEPS). '' . f , f . f . f . f :: l . f ' :: l, dos( f ) \n. dos( f '), childr( f ) . childr( f ') LEMMA 10 (QUERY MONOTONICITY). .Q,.,.' . . . .' . [Q]. . [Q].' \nQuery monotonicity implies monotonicity of substitution exten\u00adsion. LEMMA 11 (EXTENSION MONOTONICITY). \nFor any well-formed query Q and pair of substitutions .1 and .2 such that FV (Q) . dom(.1)= dom(.2) and \n.1 . .2, .\u00df . Locs(Q). ..'. Ext(.1, Q, \u00df). ..'' . Ext(.2, Q, \u00df). .'. .'' Finally, Lemma 12 shows that, \nafter splitting, all the types we get are closed for .nite .-upper-bounds. Very informally, this captures \nthe notion of no mutual exclusion among paths, and implies that, if we use substitutions based on different \nfi s in different branches of a typing proof, we can then combine all these branches, because one upper-bound \nof those fi-based substitutions exists that is ac\u00adceptable as well. (You do not .nd this lemma in the \ncanonical type papers, because it is strictly related with the existential interpreta\u00adtion of typing.) \nThis is the key lemma that allows us to prove that this type system is complete , i.e. that, if a type \nU is inferred for a query Q, every element of U is actually a possible result for Q, modulo . (Theorem \n14). The combination of soundness and com\u00adpleteness of type inference gives us a soundness-and-completeness \nproperty for error-checking as well: our type system discovers all and only the FE-errors of the analyzed \nquery (Theorem 15 and The\u00adorem 16). LEMMA 12. For any type A de.ned in a *-guarded environment E, if \nSplitE (A)= {A} then, . f1,..., fn . [A]E . . f . [A]E . fi . fi = 1...n 5.3 Soundness and Completeness \nof TypeInference and Error Checking The system enjoys soundness and completeness of type inference and \nerror-checking. The full proofs can be found in [9]. THEOREM 13 (UPPER BOUND). For each query Q, well-formed \nE, and G well-formed in E: E; G .\u00df Q : (U; ) . . . R (E, G) . [Q]. . [U]E We can .nally prove that, when \nE is *-guarded, type inference is complete up-to-simulation, and error-checking is complete. THEOREM \n14 (LOWER BOUND). For each query Q, *-guarded E, and G well-formed in E: E; G .\u00df Q : (U; ) .. f . [U]E \n. .. . R (E,G). f . [Q]. THEOREM 15 (SOUNDNESS OF ERROR-CHECKING). For each query Q, *-guarded E, and \nG well-formed in E: E; G .\u00df Q : ( ; S) . . (\u00df.a . S . Q has an error at a w.r.t. R (E,G)) THEOREM 16 \n(COMPLETENESS OF ERROR-CHECKING). For each query Q, *-guarded E, and G well-formed in E: E; G .\u00df Q : \n( ; S) . . (Q has an error at a w.r.t. R (E,G) . \u00df.a . S) 5.4 The Cost of Case-Analysis Our type system \nuses case-analysis to type-check for-iteration, and to examine the alternative types generated by type-splitting \nwhen new variables are inserted into the environment. This case-analysis approach is not the only possibility \nto type-check for x in Q1 return Q2. XQuery, for example, promotes the type of Q1 to a quanti.ed disjunction \nof tree types [12], and then ana\u00adlyzes Q2 just once, associating x with the disjunctive type. While this \nmakes type checking more ef.cient, it makes it far less precise. For example, if x is a variable of type \nr[a[],b[],c[]], the subquery y of for y in x/ * return y (where * matches any label) would be analyzed \nonce under the assumption y : (a[] | b[] | c[])+, because y may assume one of the a[], b[], c[] types \n(hence the a[] | b[] | c[]) and y will be evaluated more than once (hence the +). The query will then \nhave type (a[] | b[] | c[])+, and thus, its use in a context where the type a[],b[],c[] is expected, \nwould raise a static error. While this can be mitigated by the use of some dynamic typing, we think that \na type system where record types are treated with a greater preci\u00adsion is de.nitely worth studying. (In \nour type system, the query is assigned its exact type a[], b[],c[].) Our techniques are, in principle, \nquite expensive: the natural imple\u00admentation of nested case-analysis is a nested loop, whose execution \ntime is exponential with the nesting level. However, we have examined many queries and always found that \nthey can be type-checked without nested case-analysis, thanks to their adherence to some restrictions \non the shape of the query and of the involved types. In this section we describe these conditions, and \nexplain why they make type-checking feasible. We start with for-iteration case-analysis, assuming that \nno type\u00adsplitting takes place. We say that a type is label-deterministic iff, in its syntax tree, it \nis never the case that, after expanding recursive types with their de.nitions, two subterms l[T] and \nl[U] are found with the same label l but two different content-types T and U. Label-deterministic types \nare extremely common; every type de.ned by a DTD is label\u00addeterministic. In a nutshell, assuming that \nno type-splitting takes place, the follow\u00ading query still requires an exponential time to be type-checked, \nbe\u00adcause the subquery that starts with for $x2 has to be type-checked twice, once under the assumption \n$x1:a1[T1], and once under the assumption $x1:b1[U1], and every other $xi duplicates the needed time \nas well: for $x1 in ( a1[...], b1[...] ) ... for $xn in ( an[...], bn[...] ) return ($x1,...,$xn) However, \nif the type of $x1 only had one tree type at the top level, for example if it were a1[T1], or a1[T1]*, \nor a1[T1] |(a1[T1],a1[T1]), then the subquery could only be type-checked once, under the assumption $x1:a1[T1], \nhence this variable would not contribute to the exponential grow of type-checking complex\u00ad ity.4 Hence, \nthe following query can be type-checked ef.ciently, if all the free variables have label-deterministic \ntypes, and if the .nal ex\u00adpression E is either for-free or has in turn the same shape: for $x1 in $y1/a//b/c \n... for $xn in $yn/c/*/e return E($x1,...,$xn) Intuitively, the type of $y1/a//b/c is a combination of \ninstances of a unique type c[T] using | , , , and * : the c[] comes from the .nal step /c of the path, \nand every c is associated with the same T since the type of $y1 is label-deterministic. Hence, the rest \nof the query can be type-checked just once, under the assumption $x1:c[T]. The type of $y1/a//b/c can \nbe ef.ciently computed as well. Every $yi with i > 1 may be either a free variable or it may be $xj with \nj < i, hence we also have to observe that all the $xi s are associated with label-deterministic types. \nThis class of queries is formally de.ned in [9]. This class is big enough to include most of the queries \npresented in [8]. If a query is out of this class because it contains just a couple of exotic it\u00aderations, \nthe performance of the type-checking algorithm degrades gracefully. Of course, if the query systematically \ndiffers from that query, and is deeply nested, type checking becomes unfeasible. for-iteration. By analyzing \nthe types used in [8] and other reposi\u00adtories over the Web, we have veri.ed that, in the vast majority \nof cases, whenever union is used to specify an element-content, then union is *-guarded. Therefore, in \nthese cases, type-splitting be\u00adhaves as the identity mapping, i.e. types are not split. For example, \nconsider the following DTD that we borrow from [8]: <!DOCTYPE report [ <!ELEMENT report (section*)> <!ELEMENT \nsection (title, content)> <!ELEMENT title (#PCDATA )> 4In the third case (a1[T1] | (a1[T1],a1[T1])), \nthe trivial al\u00adgorithm would actually type-check the subquery three times under the same assumption $x1:a1[T1], \nbut this can be easily amended using standard memoization techniques. <!ELEMENT content (#PCDATA | anesthesia \n| prep | incision | action | observation)*> <!ELEMENT anesthesia (#PCDATA)> <!ELEMENT prep ( (#PCDATA \n| action)* )> <!ELEMENT incision ( (#PCDATA | geography | instrument)* )> <!ELEMENT action ( (#PCDATA \n| instrument )* )> <!ELEMENT observation (#PCDATA)> <!ELEMENT geography (#PCDATA)> <!ELEMENT instrument \n(#PCDATA)> ]> In this DTD, union is intensively used to specify element-contents. However, it is always \n*-guarded. Hence, each element type reached by case-analysis is never actually split, since SplitE (m[(T \n)*]) = m[(T )*]. Actually, we have found a few schemas where union is not *-guarded. We report here the \nonly such example from [8]. <!ELEMENT bib (book* )> <!ELEMENT book (title, (author+ |editor+ ), publisher, \nprice )> <!ATTLIST book year CDATA #REQUIRED > <!ELEMENT author (last, first )> <!ELEMENT editor(last, \nfirst, affiliation )> <!ELEMENT title (#PCDATA )> <!ELEMENT last (#PCDATA )> <!ELEMENT first (#PCDATA \n)> <!ELEMENT affiliation (#PCDATA )> <!ELEMENT publisher (#PCDATA )> <!ELEMENT price (#PCDATA )> The \nunion (author+ | editor+ ) is not *-guarded, but its two immediate components author+ and editor+ are. \nBy looking at repositories of schemas over the Web we have veri.ed that when union is not *-guarded then \nit either involves a few *-guarded types (as above) or types that contain a very small number of nested \ntypes. Hence, splitting always produces very few types. An example of types with low degree of nesting \nof not *-guarded types is given by the following DTD, which describes time stamps used in Unix systems \nmanagement. <!ELEMENT TimeStamp (DateTime | (Seconds, Microseconds?))> <!ELEMENT DateTime (#PCDATA)> \n<!ELEMENT Seconds (#PCDATA)> <!ELEMENT Microseconds (#PCDATA)> The other cases we have found of not *-guarded \nuse of union types are not far from this one. All of them feature a very low degree of nesting. We suspect \nthat, in general, deeply nested not *-guarded unions are dif.cult to work with in practice, hence are \navoided by schema designers. We plan further investigations about the patterns, in types and queries, \nthat we have discovered, since several applications may pro.t from these regularities.  6 Related Work \nOur Previous Work The work we presented in [10] was a .rst step toward the system we have here. In that \nwork we compared the universal and existential notions of correctness, but the notions of weak and strong \ncorrectness we proposed were, respectively, too weak and too strong. Weak correctness accepted queries \nsuch as Q4:$contacts/fone, $contacts/mobile from Section 3, while strong correctness refused queries \nlike Q3:$contacts/phone. XDuce XDuce [14] is a typed, functional, Turing complete pro\u00adgramming language. \nIt is based on an ML-like pattern language that implements a one-match semantics, i.e. every pattern, \ninstead of collecting every matched piece of data (as in standard query lan\u00adguages), only binds the .rst \nmatch. XDuce is nearer to a program\u00adming language than to a query language, but we consider it here since \nit is an example of typed language for XML that explicitly provides a notion of type correctness. XDuce \nsupports a universal notion of correctness for patterns: functions are correct if and only if their bodies \nspecify a matching pattern (a function case) for all possible alternatives described by the input type. \nAs discussed in the paper, we believe that this notion of correctness, although well suited for a programming \nlanguage, is too restrictive for an XML query language. CDuce CDuce [4] is a language that derives from \nXDuce but adopts a more sophisticated type system, featuring function types, intersec\u00adtion, and negation \ntypes. CDuce is not specialized for XML, but the typical XDuce idioms can be easily encoded. CDuce performs \nso\u00adphisticated correctness analysis, but it adopts the same universally\u00adquanti.ed de.nition of correctness \nas XDuce: type checking en\u00adsures that if a function is well typed then every possible input value is \nmatched by at least a branch pattern in the function body. We are working with the CDuce team to extend \nour approach to that lan\u00adguage and the derived query language CQL [5], and the preliminary results are \nvery promising. XQuery XQuery type inference [12] recursively infers a type for every subexpression, \nstarting from the types known for the input variables. As we discussed in Section 4, it does not perform \ntype case-analysis, which makes type inference faster, but makes the in\u00adferred types less precise. Very \nrecently, a new rule has been added to XQuery type system that states that it is a static error for any \nexpression other than the empty-sequence expression to have the empty type. This new rule is not suf.cient \nto achieve error-checking completeness, because of the minor precision of XQuery type infer\u00adence. If \nthe system were extended with union-types case-analysis in order to have a higher precision, then the \nerror-reporting approach should be extended with some technique related to our locations-set approach. \nIn the previous versions of the standard, no navigation-error\u00adchecking was performed. As we stated in \nthe introduction, even in absence of explicit navigation-error-checking, the inferred type can point \nout the presence of navigation-problems, but with some limits. When no match is possible for a subquery, \nthe type sys\u00adtem will typically (but not always) assign an empty-sequence type to that subquery. This \nempty-sequence type may become the .\u00adnal type of the query, hence telling the programmer that something \nwent wrong. But if the subquery is inside an element constructor that accepts empty content, or is combined \nwith an expression with a non-empty type as in error,Q , then the .nal type of the query will not be \nan empty-sequence, and the error may be completely hidden. k-pebbles proposal Dan Suciu et al. develop \na formal framework for the de.nition of result analysis tools[16, 2]. These papers de\u00ad.ne some upper \nbounds to what can be accomplished by result type analysis. Our results do not contradict these, since \nwe study here a language that is weaker than k-pebbles automata. 7 \u00b5XQ and XQuery \u00b5XQ, although inspired \nby XQuery, omits many important features, which we brie.y discuss here. We did not consider a where clause \nin our version of the FLWOR construct. In the presence of where, the identi.cation of navigation\u00aderrors \nwith constant emptiness of a subquery becomes questionable. Consider the following query. for $x ina[] \nwhere Condition return $x This query is always empty if, and only if, the expression Condition is always \nfalse. Hence, we have an FE-error iff Condition is always false. Such a notion of type error sounds heretic, \nbut it should not be discarded too lightly. For a programmer, knowing that a condi\u00adtion is uniformly \nfalse is as useful as knowing that a subquery is always empty. Its undecidability in realistic languages \nis not really a problem, since any type-checking algorithm is approximate in a real language. For an \nalternative de.nition, let us de.ne, for each query Q, where-drop(Q) as the query obtained by removing \nall where clauses from Q. A less heretic notion of type-error can now be de.ned, by changing Q ' into \nwhere-drop(Q ') in our de.nition (from Section 3): REMARK 2. Where-dropping FE-Query Correctness: A query \nQ is correct w.r.t. a set of valid substitutions R if, for each non-() subquery Q ' in Q, there exists \n. . R such that, when Q is evaluated under ., where-drop(Q ') evaluates to a non-empty sequence. Since \nany Q ' appearing in the where condition is a subquery of Q, this de.nition does not ignore where clauses \naltogether. It checks that no navigation-error is hidden inside a where clause, but, when the correctness \nof the whole FLWR expression is considered, the .ltering action of the where clause is ignored. While \nwe are more attracted by the where-dropping notion of cor\u00adrectness, the relationship between the two \nalternatives is subtle, and we believe it is worth investigating. An if then else construct would raise \nsimilar issues. The presence of a where (or if then else) clause would have another important (and orthogonal) \neffect on the type system: the language would lose monotonicity. Consider the following query: for $x \nin a[] where not empty($y) return $x When the value of $y grows from an empty to a non-empty se\u00adquence, \nthe semantics of the query goes down from non-empty to empty. Hence, Lemma 10 stops holding, and we lose \nsemi\u00adcompleteness of type-inference (Theorem 14) and completeness of error-checking (Theorem 16). This \nis not really a problem. We did not de.ne a complete system over the monotone core because we hoped to \nextend completeness to a realistic language; indeed, no complete semantic analysis can be decidable on \na Turing-complete language. Completeness over the core is important because it is a formal way to measure \nthe precision of the type system. We ignored issues related to document order , such as the fact that \nany path expression, in XQuery, returns its result in document order. If the type of the expression has \nthe shape (T1 | ... | Tn)*, where all the Ti s are tree types, the type does not change when the sequence \nis re-ordered. Otherwise, let us use UpperTreesE (T ) to denote the set of the tree types of the trees \nthat can be found at the top level of a forest of type T : UpperTreesE (T )= t {U | T .EU, U is a tree \ntype, e ' '' ' ''} and not exist e ,l, e . e = e .l.e the type T of a path expression can be weakened \nto its supertype (U1 | ... | Un)*, where {U1,...,Un} = UpperTreesE (T ), without compromising Theorems \n13, 14, and 16. This supertype does not carry any information on the order of the trees. We ignore reverse \naxis (parent, ancestor. . . ). The current version of XQuery assigns trivial types to these axes, and \nwe can do nothing better unless we change some of our fundamental assumptions. We ignore node identity \nand the issue of reference vs. copy semantics, because they have very little effect on the type system. \nWe ignore the issue of prede.ned functions, (recursive) function de.nition and invocation, and validation, \nbecause we think that they may be dealt with using standard techniques. To sum up, we do not expect problems \nin the extension of our tech\u00adniques to a full-scale language, although this will have to be care\u00adfully \nstudied. The resulting system will be sound but not complete, which is the only property one can aim \nto when a complete lan\u00adguage is treated. However, it would still be the only type system which is complete \non the core language, and the only type system which has been consciously designed to deal with both \nexistential and universal errors, and, speci.cally, to deal with navigation er\u00adrors. 8 Conclusions and \nFuture Work We have presented a type system that performs both result analysis and navigation-correctness \nanalysis for a minimal query language for tree-shaped data. We have .rst given a precise de.nition of \nnavigation-errors, and discussed its merits in relation with some possible alternatives. We introduced \na .rst type system, which is sound and quite precise. We then introduced a more expensive type system \nthat, when ap\u00adplied to schemas that satisfy a mild restriction on the alternation between * and recursion, \nperforms a correct and complete error\u00adchecking. This type system validates the claim that our notion \nof navigation-error is both meaningful for the programmer and amenable to machine-checking. We de.ned \nthe notions of universal and existential correctness, and de.ned a framework that can be used to check \nboth families of er\u00adrors. Since our type system is based on extensive use of case-analysis, we want now \nto study techniques that help reducing the overall computational complexity. Our key result, the fact \nthe no splitting is needed below a *, is already signi.cant, since most subqueries have a type T *, but \nwe believe that in many other situations type\u00adsplitting can be either avoided or performed lazily, hence \nmaking our type-system ef.ciently implementable over realistic programs and schemas. 9 Acknowledgments \nThe CDuce team (V\u00b4 eronique Benzaken, Giuseppe Castagna, and Alain Frisch) contributed to this work with \nuseful comments about type-splitting. A discussion with Phil Wadler was deeply in.uential for reaching \nour de.nition of query correctness. 10 References [1] S. Abiteboul, D. Quass, J. McHugh, J. Widom, and \nJ. Wiener. The Lorel Query Language for Semistuctured Data. Journal of Digital Libraries, 1(1), pages \n68 88, April 1997. [2] N. Alon, T. Milo, F. Neven, D. Suciu, and V. Vianu. Type\u00adchecking XML Views of \nRelational Databases. In Proceed\u00adings of the 16th Annual IEEE Symposium on Logic in Com\u00adputer Science, \n16-19 June 2001, Boston, Massachusetts, USA, Proceedings. IEEE Computer Society, 2001, pages 421 430, \n2001. [3] N. Alon, T. Milo, F. Neven, D. Suciu, and V. Vianu. XML with Data Values: Typechecking Revisited. \nIn Proceedings of the Twentieth ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems, \nMay 21-23, 2001, Santa Barbara, California, USA, 2001. [4] V. Benzaken, G. Castagna, and A. Frisch. CDuce: \nan XML-centric general-purpose language. In Proceedings of the eighth ACM SIGPLAN international conference \non Func\u00adtional programming, pages 51 63. ACM Press, 2003. [5] V. Benzaken, G. Castagna, and C. Miachon. \nCQL: a Pattern\u00adbased Query Language for XML. In Proceedings of 20th Bases de Donn\u00b4ees Avanc\u00b4ees (BDA) \n(2004), 2004. [6] S. Boag, D. Chamberlin, M. F. Fernandez, D. Florescu, J. Ro\u00adbie, and J. Sim\u00b4 eon. XQuery \n1.0: An XML Query Language. Technical report, World Wide Web Consortium, May 2003. W3C Working Draft. \n[7] P. Buneman, S. Davidson, and D. Suciu. Programming con\u00adstructs for unstructured data. In Proceedings \nof 5th Interna\u00adtional Workshop on Database Programming Languages, Gub\u00adbio, Italy, September 1995. [8] \nD. Chamberlin, P. Fankhauser, D. Florescu, M. Marchiori, and J. Robie. XML Query Use Cases. Technical \nreport, World Wide Web Consortium, Nov 2003. W3C Working Draft. [9] D. Colazzo. Path Correctness for \nXML Queries: Characteri\u00adzation and Static Type Checking. PhD thesis, Dipartimento di Informatica, Universit`a \ndi Pisa, 2004. [10] D. Colazzo, G. Ghelli, P. Manghi, and C. Sartiani. Types For Correctness of Queries \nOver Semistructured Data. In Proceedings of the Fifth International Workshop on the Web and Databases \n(WebDB 2002), Madison, Wisconsin, June 6-7, 2002, 2002. [11] H. Comon, M. Dauchet, R. Gilleron, F. Jacquemard, \nD. Lugiez, S. Tison, and M. Tommasi. Tree Au\u00adtomata Techniques and Applications. Available on: http://www.grappa.univ-lille3.fr/tata, \n1997. re\u00adlease October, 1rst 2002. [12] D. Draper, P. Fankhauser, M. Fernandez, A. Malhotra, K. Rose, \nM. Rys, J. Sim\u00b4eon, and P. Wadler. XQuery 1.0 and XPath 2.0 Formal Semantics. Technical report, World \nWide Web Consortium, Aug. 2003. W3C Working Draft. [13] M. Fernandez, D. Florescu, A. Levy, and D. Suciu. \nA query language for a Web-site management system. SIG-MOD Record (ACM Special Interest Group on Management \nof Data), 26(3):4 11, September 1997. [14] H. Hosoya and B. C. Pierce. XDuce: An XML Processing Language, \n1999. Preliminary Report. [15] D. Lee, M. Mani, and M. Murata. Reasoning about XML Schema Languages using \nFormal Language Theory. Techni\u00adcal report, IBM Almaden Research, 2000. Technical Report -IBM Almaden \nResearch. [16] T. Milo, D. Suciu, and V. Vianu. Typechecking for XML Transformers. In Proceedings of \nthe nineteenth ACM SIGMOD-SIGACT-SIGART symposium on Principles of database systems, pages 11 22. ACM \nPress, 2000. [17] H. S. Thompson, D. Beech, M. Maloney, and N. Mendelsohn. XML Schema Part 1: Structures. \nTechnical report, World Wide Web Consortium, May 2002. W3C Recommendation. [18] F. Yergeau, T. Bray, \nJ. Paoli, C. M. Sperberg-McQueen, and E. Maler. Extensible Markup Language (XML) 1.0 (Third Edition). \nTechnical report, World Wide Web Consortium, Feb 2004. W3C Recommendation.   \n\t\t\t", "proc_id": "1016850", "abstract": "If a subexpression in a query will never contribute data to the query answer, this should be regarded as an error. This principle has been recently accepted into mainstream XML query languages, but was still waiting for a complete treatment. We provide here a precise definition for this class of errors, and define a type system that is sound and complete, in its search for such errors, for a core language, under mild restrictions on the use of recursion in type definitions. In the process, we describe a dichotomy among <i>existential</i> and <i>universal</i> type systems, which is useful to understand some unusual features of our type system.", "authors": [{"name": "Dario Colazzo", "author_profile_id": "81100036913", "affiliation": "Universit&#224; di Pisa, Pisa, Italy", "person_id": "PP31024274", "email_address": "", "orcid_id": ""}, {"name": "Giorgio Ghelli", "author_profile_id": "81100261191", "affiliation": "Universit&#224; di Pisa, Pisa, Italy", "person_id": "PP39034962", "email_address": "", "orcid_id": ""}, {"name": "Paolo Manghi", "author_profile_id": "81100311584", "affiliation": "Universit&#224; di Pisa, Pisa, Italy", "person_id": "P345326", "email_address": "", "orcid_id": ""}, {"name": "Carlo Sartiani", "author_profile_id": "81100593565", "affiliation": "Universit&#224; di Pisa, Pisa, Italy", "person_id": "P345320", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1016850.1016869", "year": "2004", "article_id": "1016869", "conference": "ICFP", "title": "Types for path correctness of XML queries", "url": "http://dl.acm.org/citation.cfm?id=1016869"}