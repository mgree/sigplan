{"article_publication_date": "09-19-2004", "fulltext": "\n Scrap More Boilerplate: Re.ection, Zips, and Generalised Casts Ralf L\u00a8 Simon Peyton Jones ammel Vrije \nUniversiteit &#38; CWI, Amsterdam Microsoft Research, Cambridge Abstract Writing boilerplate code is \na royal pain. Generic programming promises to alleviate this pain by allowing the programmer to write \na generic recipe for boilerplate code, and use that recipe in many places. In earlier work we introduced \nthe Scrap your boilerplate approach to generic programming, which exploits Haskell s exist\u00ading type-class \nmechanism to support generic transformations and queries. This paper completes the picture. We add a \nfew extra introspec\u00adtive or re.ective facilities, that together support a rich variety of serialisation \nand de-serialisation. We also show how to perform generic zips , which at .rst appear to be somewhat \ntricky in our framework. Lastly, we generalise the ability to over-ride a generic function with a type-speci.c \none. All of this can be supported in Haskell with independently-useful extensions: higher-rank types \nand type-safe cast. The GHC imple\u00admentation of Haskell readily derives the required type classes for \nuser-de.ned data types. Categories and Subject Descriptors D.2.13 [Software Engineering]: Reusable Software; \nD.1.1 [Programming Techniques]: Functional Programming; D.3.1 [Programming Languages]: Formal De.nitions \nand Theory General Terms Design, Languages  Keywords Generic programming, re.ection, zippers, type \ncast 1 Introduction It is common to .nd that large slabs of a program consist of boil\u00aderplate code, \nwhich conceals by its bulk a smaller amount of in\u00adteresting code. So-called generic programming techniques \nallow Permission to make digital or hard copies of all or part of this work for personal or classroom \nuse is granted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page. To copy otherwise, to republish, \nto post on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. ICFP \n04, September 19 21, 2004, Snowbird, Utah, USA. Copyright 2004 ACM 1-58113-905-5/04/0009 ...$5.00 programmers \nto automate this boilerplate , allowing effort to be focused on the interesting parts of the program. \nIn our earlier paper, Scrap your boilerplate [16], we described a new technique for generic programming, \nbuilding on the type\u00adclass facilities in Haskell, together with two fairly modest exten\u00adsions (Section \n2). Our approach has several attractive properties: it allows the programmer to over-ride the generic \nalgorithm at ex\u00adactly the desired places; it supports arbitrary, mutually-recursive data types; it is \nan open-world approach, in which it is easy to add new data types; it works without inef.cient conversion \nto some intermediate universal data type; and it does not require compile\u00adtime specialisation of boilerplate \ncode. The main application in our earlier paper was traversals and queries over rich data structures, \nsuch as syntax trees or terms that represent XML documents. However, that paper did not show how to imple\u00adment \nsome of the best-known applications of generic programming, such as printing and serialisation, reading \nand de-serialisation, and generic equality. These functions all require a certain sort of type introspection, \nor re.ection. In this paper we extend our earlier work, making the following new contributions: We show \nhow to support a general form of type re.ection, which allows us to de.ne generic show and read functions \nas well as similar functions (Sections 3 and 4).  These classical generic functions rely on a new re.ection \nAPI, supported on a per-data-type basis (Section 5). Once de.ned, this API allows other generic re.ective \nfunctions to be de\u00ad.ned, such as test-data generators (Section 5.4).  Functions like generic equality \nrequire us to zip together two data structures, rather than simply to traverse one. We describe how zipping \ncan be accommodated in the existing framework (Section 6).  A strength of the Scrap your boilerplate \napproach is that it it easy to extend a generic function to behave differently on particular, speci.ed \ntypes. So far it has not been clear how to extend a generic function for particular type constructors. \nIn Section 7 we explain why this ability is very useful, and show how to generalise our existing type-safe \ncast operator so that we can indeed express such generic function extension.  Everything we describe \nhas been implemented in GHC, and many examples are available online at the boilerplate web site [17]. \nNo new extensions to Haskell 98 are required, beyond the two already described in Scrap your boilerplate, \nnamely (a) rank-2 types, and (b) type-safe cast. The latter is generalised, however, in Section 7.2. \n 2 Background To set the scene for this paper, we begin with a brief overview of the Scrap your boilerplate \napproach to generic programming. Sup\u00adpose that we want to write a function that computes the size of \nan arbitrary data structure. The basic algorithm is for each node, add the sizes of the children, and \nadd 1 for the node itself . Here is the entire code for gsize: gsize :: Data a => a -> Int gsize t = \n1 + sum (gmapQ gsize t) The type for gsize says that it works over any type a, provided a is a data type \n that is, that it is an instance of the class Data1 The de.nition of gsize refers to the operation gmapQ, \nwhich is a method of the Data class: class Typeable a => Data a where ...other methods of class Data... \ngmapQ :: (forall b. Data b => b -> r) -> a -> [r] (The class Typeable serves for nominal type cast as \nneeded for the accommodation of type-speci.c cases in generic functions. We will discuss this class in \nSection 7, but it can be ignored for now.) The idea is that (gmapQ f t) applies the polymorphic function \nf to each of the immediate children of the data structure t. Each of these applications yields a result \nof type r, and gmapQ returns a list of all these results. Here are the concrete de.nitions of gmapQ at \ntypes Maybe, list, and Int respectively: instance Data a => Data (Maybe a) where gmapQ f Nothing = [] \n gmapQ f (Just v) = [f v] instance Data a => Data [a] where gmapQf[] =[] gmapQ f (x:xs) = [f x, f \nxs] instance Data Int where gmapQ f i = [] --An Int has no children! Notice that gmapQ applies f only \nto the immediate children of its argument. In the second instance declaration above, f is applied to \nx and xs, resulting in a list of exactly two elements, regardless of how long the tail xs is. Notice \ntoo that, in this same declaration, f is applied to arguments of different types (x has a different type \nto xs), and that is why the argument to gmapQ must be a polymorphic function. So gmapQ must have a higher-rank \ntype that is, one with a forall to the left of a function arrow an independently-useful extension to \nHaskell [20]. It should now be clear how gsize works for term t whose type is an instance of the class \nData. The call (gmapQ gsize t) applies gsize to each of t s immediate children, yielding a list of sizes. \nThe standard function sum :: [Int] -> Int sums this list, and then we add 1. The class Data plays a central \nrole in this paper. Our earlier paper placed three generic mapping operations in class Data: the opera\u00adtion \ngmapQ for generic queries, as illustrated above, and the opera\u00adtions gmapT for transformations, and gmapM \nfor monadic transfor\u00admations. In fact, all such forms of mapping can be derived from a single operator \ngfoldl for generic folding, as we also described in the earlier paper. The instances of Data are easy \nto de.ne, as we saw for the operation gmapQ above. The de.nition of gfoldl is equally simple. In fact, \nthe instances are so easy and regular that a compiler can do the job, and GHC indeed does so, when instructed \nby a so-called deriving clause. For example data Tree a = Leaf a | Node (Tree a) (Tree a) deriving( Eq, \nTypeable, Data ) 1Note: in our earlier paper [16] the class now called Data was called Term . The deriving( \nEq ) part is standard Haskell 98, and in\u00adstructs the compiler to generate an instance declaration for \ninstance Eq a => Eq (Tree a). GHC extends this by support\u00ading deriving for the classes Typeable and Data \nas well. While the operation gfoldl is suf.cient for transformations and queries, it is not enough for \nother applications of generic program\u00adming, as we shall shortly see. Much of the rest of the paper .lls \nout the Data class with a few further, carefully-chosen operations. 3 Generic show and friends We will \nnow consider generic functions that take any data value whatsoever, and render it in some way. For instance, \na generic show operation is a generic function that renders terms as text, and hence it is of the following \ntype: gshow :: Data a => a -> String That is, gshow is supposed to take any data value (i.e. any instance \nof class Data), and to display it as a string. The generic function gshow has many variants. For example, \nwe might want to perform binary serialisation with data2bits, where we turn a datum into a string of \nZeros and Ones (Sections 3.2 and 3.3). We might also want to translate a datum into a rose tree with \ndata2tree, where the nodes store constructor names (Section 3.4). data2bits :: Data a => a -> [Bit] \n data2tree :: Data a => a -> Tree String A generalisation of data2tree can perform type erasure for XML. \n3.1 Data to text We can almost do gshow already, because it is very like gsize2: gshow t = \"(\" ++ concat \n(intersperse \" \" (gmapQ gshow t) ++ \")\"  Of course, this function only outputs parentheses! gshow [True,False] \n= \"(() (() ()))\"  We need to provide a way to get the name of the constructor used to build a data value. \nIt is natural to make this into a new operation of the class Data: class Typeable a => Data a where ... \ntoConstr :: a -> Constr  Rather than delivering the constructor name as a string, toConstr returns a \nvalue of an abstract data type Constr, which offers the function showConstr (among others Section 5): \nshowConstr :: Constr -> String Given this extra function we can write a working version of gshow: gshow \n:: Data a => a -> String gshow t = \"(\" ++ showConstr (toConstr t) ++ concat (intersperse \" \" (gmapQ \ngshow t)) ++ \")\"  We have made use of an intermediate data type Constr so that, as well as supporting \nshowConstr, we can also offer straightforward extensions such as .xity: constrFixity :: Constr -> Fixity \nThe type Fixity encodes the .xity and precedence of the construc\u00adtor, and we can use that to write a \nmore sophisticated version of gshow that displays constructors in in.x position, with minimum parenthesisation. \n2The standard function concat :: [[a]] -> [a] concate\u00adnates the elements of a list of lists, while intersperse \n:: a -> [a] -> [a] inserts its .rst argument between each pair of ele\u00adments in its second argument. Built-in \ndata types, such as Int, are also instances of the Dataclass, so (toConstr (3::Int)) is a value of type \nConstr. Applying showConstr to this value yields the string representation of the in\u00adteger value 3. \n 3.2 Binary serialisation Our next application is binary serialisation, in which we want to encode a \ndata value as a bit-string of minimum length: data Bit = Zero | One data2bits :: Data a => a -> [Bit] \n Rather than outputting the constructor name as a wasteful string, the obvious thing to do is to output \na binary representation of its constructor index, so we need another function over Constr: constrIndex \n:: Constr -> ConIndex type ConIndex = Int --Starts at 1; 0 for undefined But how many bits should be \noutput, to distinguish the construc\u00adtor from other constructors of the same data type? To answer this \nquestion requires information about the entire data type, and hence a new function, dataTypeOf: class \nTypeable a => Data a where ... toConstr :: a -> Constr dataTypeOf :: a -> DataType We note that dataTypeOf \nnever ever examines its argument; it only uses its argument as a proxy to look-up information about its \ndata type.3 The abstract data type DataType offers the operation maxConstrIndex (among others): maxConstrIndex \n:: DataType -> ConIndex Using these functions, we are in a position to write data2bits: data2bits :: \nData a => a -> [Bit] data2bits t = encodeCon (dataTypeOf t) (toConstr t) ++ concat (gmapQ data2bits \nt) --The encoder for constructors encodeCon :: DataType -> Constr -> [Bit] encodeCon ty con = natToBin \n(max-1) (idx-1) where max = maxConstrIndex ty idx = constrIndex con Here we have assumed a simple \nencoder for natural numbers natToBin :: Int -> Int -> [Bit] where (natToBin m x) returns a binary representation \nof x in the narrowest .eld that can represent m.  3.3 Fancy serialisation One could easily imagine more \nsophisticated serialisers for data values. For example, one might want to use adaptive arithmetic coding \nto reduce the number of bits required for common construc\u00adtors [23, 18]. To do this requires the serialiser \nto carry along the encoder state, and to update this state whenever emitting a new constructor. So the \nfancy encoder will have this signature, which simply adds a state to encodeCon s signature: data State \n--Abstract initState :: State encodeCon :: DataType -> Constr -> State -> (State, [Bit]) Now we just \nneed to modify the plumbing in data2bits. At .rst blush, doing so looks tricky, because gmapQ knows nothing \nabout passing a state, but we can use a standard trick by making gmapQ 3One could instead use a phantom \ntype for proxies, to make explicit that dataTypeOf does not care about values of type a, i.e.: data Proxy \na = Proxy dataTypeOf :: Proxy a -> DataType return a list of functions of type [State -> (State,[Bit])]: \ndata2bits :: Data a => a -> [Bit] data2bits t = snd (show_bin t initState) show_bin :: Data a => a -> \nState -> (State, [Bit]) show_bin t st = (st2, con_bits ++ args_bits) where (st1, con_bits) = encodeCon \n(dataTypeOf t) (toConstr t) st (st2, args_bits) = foldr do_arg (st1,[]) enc_args enc_args :: [State \n-> (State,[Bit])] enc_args = gmapQ show_bin t do_arg fn (st,bits) = (st , bits ++ bits) where (st , \nbits ) = fn st  Notice that the call to gmapQ partially applies show_bin to the chil\u00addren of the constructor, \nreturning a list of state transformers. These are composed together by the foldr do_arg. Of course, the \nap\u00adpending of bit-strings is not ef.cient, but that is easily avoided by using any O(1)-append representation \nof bit-strings (see e.g. [9]). A more elegant approach would instead present the encoder in a monadic \nway: data EncM a --The encoder monad instance Monad EncM where ... runEnc :: EncM () -> [Bit] emitCon \n:: DataType -> Constr -> EncM ()  The monad EncM carries (a) the sequence of bits produced so far and \n(b) any accumulating state required by the encoding technol\u00adogy, such as State above. The function emitCon \nadds a suitable encoding of the constructor to the accumulating output, and updates the state. The function \nrunEnc runs its argument computation start\u00ading with a suitable initial state, and returns the accumulated \noutput at the end. All the plumbing is now abstracted, leaving a rather compact de.nition: data2bits \n:: Data a => a -> [Bit] data2bits t = runEnc (emit t) emit :: Data a => a -> EncM () emit t = do { emitCon \n(dataTypeOf t) (toConstr t) ; sequence_ (gmapQ emit t) }  Here, the standard monad function sequence_ \n:: Monad m => [m a] -> m () is used to compose the list computations produced by gmapQ emit. 3.4 Type \nerasure The rendering operations so far are all forms of serialisation. We can also render terms as trees, \nwhere we preserve the overall shape of the terms, but erase the heterogeneous types. For instance, we \ncan easily turn a datum into a rose tree of the following kind: data Tree a = Tree a [Tree a]  The rendering \noperation is easily de.ned as follows: data2tree :: Data a => a -> Tree String data2tree x = Tree (showConstr \n(toConstr x)) (gmapQ data2tree x)  Rendering data values as rose trees is the essence of type erasure \nfor XML. Dually, producing data values from rose trees is the essence of type validation for XML. Generic \nfunctions for XML type era\u00adsure and type validation would necessarily re.ect various technical\u00adities \nof an XML binding for Haskell [21, 2]. So we omit the tedious XML-line of scenarios here.  4 Generic \nread and friends Our rendering functions are all generic consumers: they consume a data structure and \nproduce a .xed type (String or [Bit]). (Generic traversals that query a term, are also consumers.) The \ninverse task, of parsing or de-serialisation, requires generic produc\u00aders, that consume a .xed type and \nproduce a data structure. It is far from obvious how to achieve this goal. The nub of the problem is \nthis. We are sure to need a new mem\u00adber of the Data class, fromConstr, that is a kind of inverse of toConstr. \nBut what is its type? The obvious thing to try is to reverse the argument and result of toConstr: class \nTypeable a => Data a where ... toConstr :: a -> Constr fromConstr :: Constr -> a --NB: not yet correct! \n But simply knowing the constructor alone does not give enough information to build a value: we need \nto know what the children of the constructor are, too. But we can t pass the children as arguments to \nfromConstr, because then the type of fromConstr would vary, just as constructor types vary. We note that \nthe type Constr -> a could be used as is, if fromConstr returned a term constructor .lled by bottoms \n( . ). A subsequent application of gmapT could still .ll in the sub-terms properly. However, this is \nsomething of a hack. Firstly, the bot\u00adtoms imply dependence on laziness. Secondly, the approach fails \ncompletely for strict data types. So we seek another solution. The solution we adopt is to pass a generic \nfunction to fromConstr that generates the children. To this end, we employ a monad to provide input for \ngeneration of children: fromConstrM :: (Monad m, Data a) => (forall b. Data b => m b) -> Constr -> m \na We will .rst demonstrate fromConstrM, and then de.ne it. 4.1 Text to data Here is the code for a \ngeneric read, where we ignore the need to consume spaces and match parentheses: gread :: Data a => String \n-> Maybe a gread input = runDec input readM readM :: Data a => DecM a readM = do { constr <-parseConstr \n??? --to be completed ; fromConstrM readM constr } The two lines of readM carry out the following steps: \n1. Parse a Constr from the front of the input. This time we employ a parser monad, DecM, with the following \nsignature: data DecM a --The decoder monad instance Monad DecM where ... runDec :: String -> DecM a -> \na parseConstr :: DataType -> DecM Constr The monad carries (a) the as-yet-unconsumed input, and (b) any \nstate needed by the decoding technology. The function parseConstr parses a constructor from the front \nof the input, updates the state, and returns the parsed constructor. It needs the DataType argument so \nthat it knows how many bits to parse, or what the valid constructor names are. (This argument still needs \nto be .lled in for ??? above.) 2. Use fromConstrM to call readM successively to parse each child of the \nconstructor, and construct the results into a value built with the constructor identi.ed in step 1. \nThe function runDecruns the decoder on a particular input, discard\u00ading the .nal state and unconsumed \ninput, and returning the result. In case the monadic presentation seems rather abstract, we brie.y sketch \none possible implementation of the DecM monad. A parser of type DecM a is represented by a function that \ntakes a string and returns a depleted string together with the parsed value, wrapped in a Maybe to express \nthe possibility of a parse error: newtype DecM a = D (String -> Maybe (String, a)) The type DecM can \nbe made an instance of Monad in the standard way (see [10], for example). It remains to de.ne the parser \nfor constructors. We employ a new function, dataTypeConstrs, that returns a list of all the constructors \nof a data type. We try to match each constructor with the beginning of the input, where we ignore the \nissue of constructors with overlapping pre.xes: parseConstr :: DataType -> DecM Constr parseConstr ty \n= D (\\s -> match s (dataTypeConstrs ty)) where match :: String -> [Constr] -> Maybe (String, Constr) \n match _ [] = Nothing match input (con:cons) | take (length s) input == s = Just (drop (length s) \ninput, con) | otherwise = match input cons where s = showConstr con  The same code for gread, with \na different implementation of DecM and a different type for runDec, would serve equally well to read \nthe binary structures produced by data2bits. 4.2 De.ning fromConstrM The function fromConstrM can be \neasily de.ned as a new mem\u00adber of the Data class, with the type given above. Its instances are extremely \nsimple; for example: instance Data a => Data [a] where fromConstrM f con = case constrIndex con of \n 1 -> return [] 2 -> do { a <-f; as <-f; return (a:as) }  However, just as gmapQ, gmapT and gmapM are \nall instances of the highly parametric gfoldl operation, so we can de.ne fromConstrMas an instance of \nthe dual of gfoldl a highly para\u00admetric operation for unfolding. This operation, gunfold needs to be \nadded to the Data class: class Typeable a => Data a where ... gunfold :: (forall b r. Data b =>c (b \n->r) -> cr) -> (forall r. r -> c r) -> Constr -> c a  The two polymorphically typed arguments serve \nfor building non\u00adempty vs. empty constructor applications. In this manner, gunfold really dualises gfoldl, \nwhich takes two similar arguments for the traversal of constructor applications. The operations gunfold \nand gfoldl also share the use of a type constructor parameter c in their result types, which is key to \ntheir highly parametric quality. The instances of gunfold are even simpler than those for fromConstrM, \nas we shall see in Section 5.1. The operation fromConstrM is easily derived as follows: fromConstrM f \n= gunfold k z where k c = do { c <-c; b <-f; return (c b) } z = return Here, the argument z in (gunfold \nk z) turns the empty construc\u00adtor application into a monadic computation, while k unfolds one child, \nand combines it with the rest.  4.3 Getting hold of the data type In the generic parser we have thus-far \nshown, we left open the ques\u00adtion of how to get the DataType corresponding to the result type, to pass \nto parseConstr, the ??? in readM. The dif.culty is that dataTypeOf needs an argument of the result type, \nbut we have not yet built the result value. This problem is easily solved, by a technique that we frequently \nencounter in type-class-based generic programming. Here is the code for readM without ??? : readM :: \nData a => DecM a readM = read_help where read_help = do { let ty = dataTypeOf (unDec read_help) \n; constr <-parseConstr ty ; fromConstrM readM constr } unDec :: DecM a -> a unDec = undefined Here, \nunDec s type signature maps the type DecM a to a as de\u00adsired. Notice the recursion here, where read_help \nis used in its own right-hand side. But recall that dataTypeOf is not interested in the value of its \nargument, but only in its type; the lazy argument (unDec read_help) simply explains to the compiler what \nData dictionary to pass to dataTypeOf. Rather than using an auxiliary unDecfunction, there is a more \ndirect way to express the type of dataTypeOf s argument. That is, we can use lexically-scoped type variables, \nwhich is an independently useful Haskell extension. We rewrite readM as follows: readM :: Data a => DecM \na readM = read_help where read_help :: DecM a = do { let ty = dataTypeOf (undefined::a) ; constr \n<-parseConstr ty ; fromConstrM readM constr } The de.nition read_help :: DecM a = ... states that read_help \nshould have the (monomorphic) type DecM a, for some type a, and furthermore brings the type variable \na into scope, with the same scope as read_help itself. The argu\u00adment to dataTypeOf, namely (undefined::a), \nis constrained to have the same type a, because the type variable a is in scope. A scoped type variable \nis only introduced by a type signature directly attached to a pattern (e.g., read_help :: DecM a). In \ncontrast, a separate type signature, such as read_help :: Data a => DecM a is short for read_help :: \nforall a. Data a => DecM a and does not introduce any scoping of type variables. However, we stress \nthat, although convenient, lexically-scoped type variables are not required to support the Scrap your \nboilerplate approach to generic programming, as we illustrated with the initial de.nition of read_help. \n 5 Type re.ection the full story The previous two sections have introduced, in a piecemeal fashion, \nthree new operations in the Data class. In this section we sum\u00admarise these extensions. The three new \noperations are these: class Typeable a => Data a where ... dataTypeOf :: a -> DataType toConstr :: a \n-> Constr gunfold :: (forall b r. Data b => c (b -> r) -> c r) -> (forall r. r -> c r) -> Constr -> \nca  Every instance of dataTypeOf is expected to be non-strict i.e. does not evaluate its argument. \nBy contrast, toConstr must be strict at least for multi-constructor types since it gives a result that \ndepends on the constructor with which the argument is built. The function dataTypeOf offers a facility \ncommonly known as re\u00ad.ection . Given a type or rather a lazy value that serves as a proxy for a type \n it returns a data structure (DataType) that describes the structure of the type. The data types DataType \nand Constr are abstract: data DataType --Abstract, instance of Eq data Constr --Abstract, instance of \nEq  The following sections give the observers and constructors for DataType and Constr. 5.1 Algebraic \ndata types We will .rst consider algebraic data types, although the API is de\u00ad.ned such that it readily \ncovers primitive types as well, as we will explain in the next section. These are the observers for DataType: \ndataTypeName :: DataType -> String dataTypeConstrs :: DataType -> [Constr] maxConstrIndex :: DataType \n-> ConIndex indexConstr :: DataType -> ConIndex -> Constr type ConIndex = Int --Starts at 1  These functions \nshould be suggestive, just by their names and types. For example, indexConstr takes a constructor index \nand a DataType, and returns the corresponding Constr. These are the observers for Constr: constrType \n:: Constr -> DataType showConstr :: Constr -> String constrIndex :: Constr -> ConIndex constrFixity :: \nConstr -> Fixity constrFields :: Constr -> [String] data Fixity = ... --Details omitted  (The name of \nshowConstr is chosen for its allusion to Haskell s well-known showfunction.) We have already mentioned \nall of these observers in earlier sections, except constrType which returns the constructor s DataType, \nand constrFields which returns the list of the constructor s .eld labels (or [] if it has none). Values \nof types DataType and Constr are constructed as follows: mkDataType :: String -> [Constr] -> DataType \nmkConstr :: DataType -> String -> [String]  -> Fixity -> Constr The function readConstr parses a given \nstring into a constructor; it returns Nothing if the string does not refer to a valid constructor: readConstr \n:: DataType -> String -> Maybe Constr  When the programmer de.nes a new data type, and wants to use \nit in generic programs, it must be made an instance of Data. GHC will derive these instance if a deriving \nclause is used, but there is no magic here the instances are easy to de.ne manually if desired. For \nexample, here is the instance for Maybe: instance Data a => Data (Maybe a) where ... --gfoldl as before \ndataTypeOf _ = maybeType toConstr (Just _) = justCon toConstr Nothing = nothingCon gunfold k z con = \n case constrIndex con of 1 -> z Nothing --no children 2 -> k (z Just) --one child, hence one k justCon, \nnothingCon :: Constr nothingCon = mkConstr maybeType \"Nothing\" [] NoFixity justCon = mkConstr maybeType \n\"Just\" [] NoFixity maybeType :: DataType maybeType = mkDataType \"Prelude.Maybe\" [nothingCon, justCon] \n Notice that the constructors mention the data type and vice versa, so that starting from either one \ncan get to the other. Furthermore, this mutual recursion allows mkDataType to perform the assignment \nof constructor indices: the fact that Nothing has index 1 is speci.ed by its position in the list passed \nto mkDataType.  5.2 Primitive types Some of Haskell s built-in types need special treatment. Many built-in \ntypes are explicitly speci.ed by the language to be alge\u00adbraic data types, and these cause no problem. \nFor example, the boolean type is speci.ed like this: data Bool = False | True There are a few types, \nhowever, primitive types, that cannot be described in this way: Int, Integer, Float, Double, and Char. \n(GHC happens to implement some of these as algebraic data types, some with unboxed components, but that \nshould not be revealed to the programmer.) Furthermore, GHC adds several others, such as Word8, Word16, \nand so on. How should the re.ection functions, dataTypeOf, toConstr, and so on, behave on primitive types? \nOne possibility would be to support dataTypeOf for primitive types, but not toConstr and fromConstr. \nThat has the disadvantage that every generic function would need to de.ne special cases for all primitive \ntypes. While there are only a .xed number of such types, it would still be tire\u00adsome, so we offer a little \nadditional support. We elaborate Constr so that it can represent a value of primitive types. Then, toConstr \nconstructs such speci.c representations. While Constr is opaque, we provide an observer constrRep to \nget access to constructor representations: constrRep :: Constr -> ConstrRep data ConstrRep = AlgConstr \nConIndex --Algebraic data type | IntConstr Integer --Primitive type (ints) | FloatConstr Double --Primitive \ntype (floats) | StringConstr String --Primitive type (strings) The constructors from an algebraic data \ntype have an AlgConstr representation, whose ConIndex distinguishes the constructors of the type. A Constr \nresulting from an Int or Integer value will have an IntConstr representation, e.g.: constrRep (toConstr \n(1::Int)) == IntConstr 1 The same IntConstr representation is used for GHC s data types Word8, Int8, \nWord16, Int16, and others. The FloatConstr rep\u00adresentation is used for Float and Double, while StringConstr \nis used for anything else that does not .t one of these more ef.cient representations. We note that Chars \nare represented as Integers, and Strings are represented as lists of Integers. There is a parallel re.nement \nof DataType: dataTypeRep :: DataType -> DataRep data DataRep = AlgRep [Constr] --Algebraic data type \n | IntRep --Primitive type (ints) | FloatRep --Primitive type (floats) | StringRep --Primitive type \n(strings)  There are dedicated constructors as well: mkIntType :: String -> DataType mkFloatType :: \nString -> DataType mkStringType :: String -> DataType mkIntConstr :: DataType -> Integer -> Constr mkFloatConstr \n:: DataType -> Double -> Constr mkStringConstr :: DataType -> String -> Constr  The observers constrType, \nshowConstrand readConstrall work for primitive-type Constrs. All that said, the Data instance for a primitive \ntype, such as Int, looks like this: instance Data Int where gfoldl kz c = zc gunfold k z c = case constrRep \nc of IntConstr x -> z (fromIntegral x) _ -> error \"gunfold\" toConstr x = mkIntConstr intType (fromIntegral \nx) intType = mkIntType \"Prelude.Int\"  5.3 Non-representable data types Lastly, it is convenient to \ngive Datainstances even for types that are not strictly data types, such as function types or monadic \nIO types. Otherwise deriving ( Data ) would fail for a data type that had even one constructor with a \nfunctional argument type, so the user would instead have to write the Data instance by hand. Instead, \nwe make all such types into vacuous instances of Data. Traversal will safely cease for values of such \ntypes. However, values of these types can not be read and shown. For example, the instance for (->) is \nde.ned as follows: instance (Data a, Data b) => Data (a -> b) where gfoldlkzc =zc gunfold _ _ _ = error \n\"gunfold\" toConstr _ = error \"toConstr\" dataTypeOf _ = mkNoRepType \"Prelude.(->)\" Here we assume a trivial \nconstructor for non-representable types: mkNoRepType :: String -> DataType To this end, the data type \nDataRep provides a dedicated alternative: data DataRep = ... --As before | NoRep --Non-representable \ntypes Some of GHC s extended repertoire of types, notably Ptr, fall into this group of non-representable \ntypes. 5.4 Application: test-data generation As a further illustration of the usefulness of dataTypeOf, \nwe present a simple generic function that enumerates the data struc\u00adtures of any user de.ned type. (The \nutility of generic programming for test-data generation has also been observed elsewhere [14].) Such \ntest-data generation is useful for stress testing, differential testing, behavioural testing, and so \non. For instance, we can use systematic test-data generation as a plug-in for QuickCheck [3]. Suppose \nwe start with the following data types, which constitute the abstract syntax for a small language: data \nProg = Prog Dec Stat data Dec = Nodec | Ondec Id Type | Manydecs Dec Dec dataId =A|B data Type = Int \n| Bool data Stat = Noop | Assign Id Exp | Seq Stat Stat data Exp = Zero | Succ Exp  We want to de.ne \na generic function that generates all terms of a given .nite depth. For instance: > genUpTo 3 :: [Prog] \n[Prog Nodec Noop, Prog Nodec (Assign A Zero), Prog Nodec (Assign B Zero), Prog Nodec (Seq Noop Noop), \nProg (Ondec A Int) Noop, Prog (Ondec A Int) (Assign A Zero), Prog (Ondec A Int) (Assign B Zero), Prog \n(Ondec A Int) (Seq Noop Noop), ... ] Here is the code for genUpTo: genUpTo :: Data a => Int -> [a] \ngenUpTo 0 = [] genUpTo d = result where --Recurse per possible constructor result = concat (map recurse \ncons) --Retrieve constructors of the requested type cons :: [Constr] cons = dataTypeConstrs (dataTypeOf \n(head result)) --Find all terms headed by a specific Constr recurse :: Data a => Constr -> [a] recurse \n= fromConstrM (genUpTo (d-1)) The non-trivial case (d > 0) begins by .nding cons, the list of all the \nconstructors of the result type. Then it maps recurseover cons to generate, for each Constr, the list \nof all terms of given depth with that constructor at the root. In turn, recurse works by using fromConstrM \nto run genUpTo for each child. Here we take advan\u00adtage of the fact that Haskell s list type is a monad, \nto produce a result list that consists of all combinations of the lists returned by the recursive calls. \nThe reason that we bind result in the where-clause is so that we can mention it in the type-proxy argument \nto dataTypeOf, namely (head result) see Section 4.3. Notice that we have not taken account of the possibility \nof primi\u00adtive types in the data type indeed, dataTypeConstrs will fail if given a primitive DataType. \nThere is a genuine question here: what value should we return for (say) an Int node? One very sim\u00adple \npossibility is to return zero, and this is readily accommodated by using dataRep instead of dataTypeConstrs: \ncons = case dataTypeRep ty of AlgRep cons -> cons IntRep -> [mkIntConstr ty 0] FloatRep -> [mkIntConstr \nty 0] StringRep -> [mkStringConstr ty \"foo\"] where ty = dataTypeOf (head result) We might also pass \naround a random-number generator to select primitive values from a .nite list of candidates. We can also \nre\u00ad.ne the illustrated approach to accommodate other coverage crite\u00adria [15]. We can also incorporate \npredicates into term generation so that only terms are built that meet some side conditions in the sense \nof attribute grammars [6]. Type re.ection makes all manner of clever test-data generators possible. \n 6 Generic zippers In our earlier paper, all our generic functions consumed a single data structure. \nSome generic functions, such as equality or com\u00adparison, consume two data structures at once. In this \nsection we discuss how to program such zip-like functions. The overall idea is to de.ne such functions \nas curried higher-order generic functions that consume position after position. 6.1 Curried queries \nConsider .rst the standard functions map and zipWith: map :: (b->c) -> [b] -> [c] zipWith :: (a->b->c) \n-> [a] -> [b] -> [c] By analogy, we can attempt to de.ne gzipWithQ a two\u00adargument version of gmapQ thus. \nThe types compare as follows: gmapQ :: Data a => (forall b. Data b => b -> r) -> a ->[r] gzipWithQ \n:: (Data a1, Data a2) => (forall b1 b2. (Data b1, Data b2) =>b1 ->b2 -> r) -> a1 ->a2 -> [r]  The original \nfunction, (gmapQ f t), takes a polymorphic function f that it applies to each immediate child of t, and \nreturns a list of the results. The new function, (gzipWithQ f t1 t2) takes a polymorphic function f that \nit applies to corresponding pairs of the immediate children of t1 and t2, again returning a list of the \nresults. For generality, we do not constrain a1 and a2 to have the same outermost type constructor, an \nissue to which we return in Section 6.5. We can gain extra insight into these types by using some type \nab\u00adbreviations. We de.ne the type synonym GenericQ as follows: type GenericQ r = forall a. Data a => \na -> r That is, a value of type GenericQ ris a generic query function that takes a value of any type \nin class Data and returns a value of type r. Haskell 98 does not support type synonyms that contain forall \ns, but GHC does as part of the higher-rank types extension. Such ex\u00adtended type synonyms are entirely \noptional: they make types more perspicuous, but play no fundamental role. Now we can write the type of \ngmapQ as follows: gmapQ :: GenericQ r -> GenericQ [r] We have taken advantage of the type-isomorphism \n'a.s1 -s2 . s1 -'a.s2 (where a .r s1) to rewrite gmapQ s type as follows: gmapQ :: (forall b. Data b \n=> b -> r)  -> (forall a. Data a => a -> [r]) Applying GenericQ, we obtain GenericQ r -> GenericQ [r]. \nSo gmapQ thereby stands revealed as a generic-query transformer. The type of gzipWithQ is even more interesting: \ngzipWithQ :: GenericQ (GenericQ r) -> GenericQ (GenericQ [r]) The argument to gzipWithQis a generic query \nthat returns a generic query. This is ordinary currying: when the function is applied to the .rst data \nstructure, it returns a function that should be applied to the second data structure. Then gzipWithQ \nis a transformer for such curried queries. Its implementation will be given in Section 6.3. 6.2 Generic \ncomparison Given gzipWithQ, it is easy to de.ne a generic equality function: geq :: GenericQ (GenericQ \nBool) geq x y = toConstr x == toConstr y &#38;&#38; and (gzipWithQ geq x y) That is, geq x y checks that \nx and y are built with the same con\u00adstructor and, if so, zips together the children of x and y with geq \nto give a list of Booleans, and takes the conjunction of these results with and :: [Bool] -> Bool. That \nis the entire code for generic equality. Generic comparison (returning LT, EQ, or GT) is equally easy \nto de.ne. We have called the function geq , rather than geq, because it has a type that is more polymorphic \nthan we really want. If we spell out the GenericQ synonyms we obtain: geq :: (Data a1, Data a2) => a1 \n-> a2 -> Bool  But we do not expect to take equality between values of different types, a1and a2, even \nif both do lie in class Data! The real function we want is this: geq :: Data a => a -> a -> Bool geq \n= geq Why can t we give this signature to the original de.nition of geq ? Because if we did, the call \n(gzipWithQ geq x y) would be ill-typed, because gzipWithQ requires a function that is indepen\u00addently \npolymorphic in its two arguments. That, of course, just begs the question of whether gzipWithQ could \nbe less polymorphic, to which we return in Section 6.5. First, however, we describe the implementation \nof gzipWithQ.  6.3 Implementing gzipWithQ How can we implement gzipWithQ? At .rst it seems dif.cult, \nbe\u00adcause we must simultaneously traverse two unknown data struc\u00adtures, but the gmap combinators are parametric \nin just one type. The solution lies in the type of gzipWithQ, however: we seek a generic query that returns \na generic query. So we can evaluate (gzipWithQ f t1 t2) in two steps, thus: gzipWithQ f t1 t2 --NB: not \nyet correct! = gApplyQ (gmapQ f t1) t2 Step 1: use the ordinary gmapQ to apply f to all the children \nof t1, yielding a list of generic queries. Step 2: use an operation gApplyQ to apply the queries in the \npro\u00ad duced list to the corresponding children of t2. Each of these steps requires a little work. First, \nin step 1, what is the type of the list (gmapQ f t1)? It should be a list of generic queries, each of \nwhich is a polymorphic function. But GHC s sup\u00adport for higher-rank type still maintains predicativity. \nWhat this means is that while we can pass a polymorphic function as an argu\u00adment, we cannot make a list \nof polymorphic functions. Since that really is what we want to do here, we can achieve the desired result \nby wrapping the queries in a data type, thus: newtype GQ r = GQ (GenericQ r) gzipWithQ f t1 t2 = gApplyQ \n(gmapQ (\\x -> GQ (f x)) t1) t2 Now the call to gmapQ has the result type [GQ r], which is .ne. The use \nof the constructor GQ serves as a hint to the type inference engine to perform generalisation at this \npoint; there is no run-time cost to its use. Step 2 is a little harder. A brutal approach would be to \nadd gApplyQ directly to the class Data. As usual, the instances would be very simple, as we illustrate \nfor lists: class Typeable a => Data a where ... gApplyQ :: [GQ r] -> a -> [r] instance Typeable a => \nData [a] where ... gApplyQ [GQ q1, GQ q2] (x:xs) = [q1 x, q2 xs] gApplyQ [] [] = [] But we can t go \non adding new functions to Data, and this one seems very speci.c to queries, so we might anticipate that \nthere will be others yet to come. Fortunately, gApplyQ can be de.ned in terms of the generic fold\u00ading \noperation gfoldl from our original paper, as we now show. To implement gApplyQ, we want to perform a \nfold on immediate sub\u00adterms while using an accumulator of type ([GQ r], [r]). Again, for lists, the combination \nof such accumulation and folding or map\u00adping is a common idiom (cf. mapAccumL in module Data.List). For \neach child we consume an element from the list of queries (com\u00adponent [GQ r]), while producing an element \nof the list of results (component [r]). So we want a combining function k like this: k :: Data c => ([GQ \nr], [r]) -> c -> ([GQ r], [r]) k (GQ q : qs, rs) child = (qs, q child : rs)  Here c is the type of \nthe child. The function k simply takes the accumulator, and a child, and produces a new accumulator. \n(The results accumulate in reverse order, but we can .x that up at the end using reverse, or we use the \nnormal higher-order trick for accumulation.) We can perform this fold using gfoldl, or rather a trivial \ninstance thereof gfoldlQ: gApplyQ :: Data a => [GQ r] -> a -> [r] gApplyQ qs t = reverse (snd (gfoldlQ \nk z t)) where k (GQ q : qs, rs) child = (qs, q child : rs) z = (qs, [])  The folding function, gfoldlQ \nhas this type4: gfoldlQ :: (r -> GenericQ r) -> r -> GenericQ r The de.nition of gfoldlQ employs a type \nconstructor R to mediate between the highly parametric type of gfoldland the more speci.c type of gfoldlQ: \nnewtype R r x = R { unR :: r } gfoldlQ k z t = unR (gfoldl k z t) where z _ = R z --replacement of constructor \nk (R r) c = R (k r c) --fold step for child c 6.4 Generic zipped transformations We have focused our \nattention on generic zipped queries, but all the same ideas work for generic zipped transformations, \nboth monadic and non-monadic. For example, we can proceed for the latter as follows. We introduce a type \nsynonym, GenericT, to encapsulate the idea of a generic transformer: type GenericT = forall a. Data a \n=> a -> a Then gmapT, from our earlier paper, appears as a generic trans\u00adformer transformer; its natural \ngeneralisation, gzipWithT, is a curried-transformer transformer: gmapT :: GenericT -> GenericT  gzipWithT \n:: GenericQ GenericT -> GenericQ GenericT The type GenericQ GenericT is a curried two-argument generic \ntransformation: it takes a data structure and returns a function that takes a data structure and returns \na data structure. We leave its im\u00adplementation as an exercise for the reader, along with similar code \nfor gzipWithM. Programmers .nd these operations in the generics library [17] that comes with GHC. 6.5 \nMis-matched types or constructors At the end of Section 6.2, we raised the question of whether gzipWithQ \ncould not have the less-polymorphic type: gzipWithQ :: (Data a) => (forall b. (Data b) => b -> b -> r) \n-> a -> a -> [r]  Then we could de.ne geq directly in terms of gzipWithQ , rather than detouring via \ngeq . One dif.culty is that gzipWithQ is now not polymorphic enough for some purposes: for example, it \nwould not allow us to zip together a list of booleans with a list of integers. But beyond that, an implementation \nof gzipWithQ is problematic. Let us try to use the same de.nition as for gzipWithQ: gzipWithQ f t1 t2 \n--Not right yet!  = gApplyQ (gmapQ (\\x -> GQ (f x)) t1) t2 The trouble is that gApplyQ requires a list \nof polymorphic queries as its argument, and for good reason: there is no way to ensure statically that \neach query in the list given to gApplyQis applied to an argument that has the same type as the child \nfrom which the query was built. Alas, in gzipWithQ the query (f x) is monomorphic, 4Exercise for the \nreader: de.ne gmapQusing gfoldlQ. Hint: use the same technique as you use to de.ne map in terms of foldl. \nbecause f s two arguments have the same type. However, we can turn the monomorphic query (f x) into a \npolymorphic one, albeit inelegantly, by using a dynamic type test: we simply replace the call (f x) by \nthe following expression: (error \"gzipWithQ failure\" extQ f x) The function extQ (described in our earlier \npaper, and reviewed here in Section 7.1) over-rides a polymorphic query (that always fails) with the \nmonomorphic query (f x). Returning to the operation gzipWithQ, we can easily specialise gzipWithQ at \nmore speci.c types, just as we specialised geq to geq. For example, here is how to specialise it to list \narguments: gzipWithQL :: (Data a1, Data a2) => (forall b1,b2. (Data b1, Data b2) => b1 -> b2 -> r) \n-> [a1] -> [a2] -> [r] gzipWithQL = gzipWithQ A related question is this: what does gzipWithQ do when \nthe con\u00adstructors of the two structures do not match? Most of the time this question does not arise. \nFor instance, in the generic equality func\u00adtion of Section 6.2 we ensured that the structures had the \nsame con\u00adstructor before zipping them together. But the gzipWithQ imple\u00admentation of Section 6.3 is perfectly \nwilling to zip together differ\u00adent constructors: it gives a pattern-match failure if the second argu\u00adment \nhas more children than the .rst, and ignores excess children of the second argument. We could also de.ne \ngzipWithQ such that it gives a pattern-match failure if the two constructors differ. Either way, it is \nno big deal.  7 Generic function extension One of the strengths of the Scrap your boilerplate approach \nto generic programming, is that it is very easy to extend, or over-ride, the behaviour of a generic function \nat particular types. To this end, we employ nominal type-safe cast, as opposed to more structural notions \nin other approaches. For example, recall the function gshow from Section 3: gshow :: Data a => a -> String \nWhen gshow is applied to a value of type String we would like to over-ride its default behaviour. For \nexample, (gshow \"foo\") should return the string \"\\\"foo\\\"\" rather than the string \"(: f (: o (: o [])))\", \nwhich is what gshow will give by default, since a String is just a list of characters. The key idea is \nto provide a type-safe cast operation, whose real\u00adisation formed a key part of our earlier paper; we \nreview it in Sec\u00adtion 7.1. However, further experience with generic programming reveals two distinct \nshortcomings, which we tackle in this section: The type of type-safe cast is not general enough for \nsome situations. We show why it should be generalised, and how, in Section 7.2.  Type-safe cast works \non types but not on type constructors. This limitation is important as we show in Section 7.3, where \nwe also describe how the restriction can be lifted.  We use the term generic function extension for \nthe accommo\u00addation of type-speci.c cases. We do not use the term specialisa\u00adtion to avoid any confusion \nwith compile-time specialisation of generic functions in other approaches. Our approach uses .xed code \nand run-time type tests. As a separate matter, however, our dynamic code can, if desired, be specialised \nlike any other type\u00adclass-overloaded function, to produce type-test-free residual code. 7.1 Monomorphic \nfunction extension In our earlier paper [16], we described a function extQ that can ex\u00adtend (or, over-ride) \na fully-generic query with a type-speci.c query. This allows us to re.ne gshow as follows: gshow :: Data \na => a -> String gshow = gshow_help extQ showString gshow_help :: Data a => a -> String gshow_help \nt = \"(\" ++ concat (intersperse \" \" (gmapQ gshow t)) ++ \")\" showString :: String -> String showString \ns = \"\\\"\" ++ concat (map escape s) ++ \"\\\"\" where escape \\n = \"\\\\n\" ...etc... escape other_char = [other_char] \n Here, the type-speci.c showString over-rides the fully-generic gshow_help to make the combined function \ngshow. Notice the mutual recursion between gshow and gshow_help. The function extQ is de.ned in the generics \nlibrary as follows: extQ :: (Typeable a, Typeable b) => (a-> r) ->(b ->r) -> (a-> r) extQ fn spec_fn \narg = case cast arg of Just arg -> spec_fn arg Nothing -> fn arg  The function (gshow_help extQ showString) \nbehaves like the monomorphic showStringif given a String, and like the poly\u00admorphic function gshow_help \notherwise. To this end, extQ uses a type-safe cast operator, which is regarded as a primitive of the \nfol\u00adlowing type: cast :: (Typeable a, Typeable b) => a -> Maybe b If the cast from a to b succeeds, one \nobtains a datum of the form Just ..., and Nothing otherwise. The constraints on the argu\u00adment and result \ntype of cast highlight that cast is not a parametri\u00adcally polymorphic function. We rather require the \ntypes a and b to be instances of the class Typeable, a superclass of Data:5 class Typeable a where typeOf \n:: a -> TypeRep Given a typeable value v, the expression (typeOf v) computes the type representation \n(TypeRep) of v. Like dataTypeOf, typeOf never inspects its argument. Type representations admit equality, \nwhich is required to coincide with nominal type equivalence. One speci.c implementation of type-safe \ncast is then to trivially guard an unsafe coercion by type equivalence. This and other approaches to \ncasting are discussed at length in [16]. In what follows, we are merely interested in generalising the \ntype of cast. 7.2 Generalising cast The scheme that we used for extending generic queries is speci.c \nto queries. It cannot be reused as is for generic transformations: extT :: (Typeable a, Typeable b) \n=> (a-> a) ->(b ->b) -> (a-> a) extT fn spec_fn arg = case cast arg of --WRONG Just arg -> spec_fn \narg Nothing -> fn arg  The trouble is that the result of spec_fn arg has a different type than the \ncall fn arg. Hence, extT must be de.ned in a different style than extQ. One option is to cast the function \nspec_fn rather than the argument arg: 5We use two separate classes Data and Typeable to encourage well-bounded \npolymorphism. That is, the class Typeable supports nominal type representations, just enough to do cast \nand dynamics. The class Data is about structure of terms and data types. extT fn spec_fn arg = case \ncast spec_fn of --RIGHT Just spec_fn -> spec_fn arg Nothing -> fn arg This time, the cast compares \nthe type of spec_fn with that of fn, and uses the former when the type matches. The only infelicity is \nthat we thereby compare the representations of the types a->a and b->b, when all we really want to do \nis compare the representations of the types a and b. This infelicity becomes more serious when we move \nto monadic transforms: extM:: (??? ) =>(a -> ma) -> (b-> m b)-> (a-> m a) extM fn spec_fn arg = case \ncast spec_fn of Just spec_fn -> spec_fn arg Nothing -> fn arg Now, we need to construct the representation \nof a -> m a, and hence ma must be Typeable too! So the (...???...) must be .lled in thus: extM :: (Typeable \na, Typeable b, Typeable (m a), Typeable (m b)) => (a-> m a)-> (b ->m b) ->(a ->m a) Notice the Typeable \nconstraints on (m a) and (m b), which should not be required. The type of cast is too speci.c. The prim\u00aditive \nthat we really want is gcast generalised cast: gcast :: (Typeable a, Typeable b) => c a -> Maybe (c \nb) Here cis an arbitrary type constructor. By replacing castby gcast in extT and extM, and instantiating \nc to .a.a->a, and .a.a -> m a respectively, we can achieve the desired effect. But wait! Haskell does \nnot support higher-order uni.cation, so how can we instantiate c to these type-level functions? We resort \nto the standard technique, which uses a newtype to explain to the type engine which instantiation is \nrequired. Here is extM: extM :: (Typeable a, Typeable b) => (a-> m a)-> (b ->m b) ->(a ->m a) extM \nfn spec_fn arg = case gcast (M spec_fn) g of Just (M spec_fn ) -> spec_fn arg Nothing -> fn arg newtypeMm \na = M(a -> ma) Here, (M spec_fn) has type (M m a), and that .ts the type of gcast by instantiating c \nto Mm. We can rewrite extQ and extT to use gcast, in exactly the same way: extQ fn spec_fn arg = case \ngcast (Q spec_fn) g of Just (Q spec_fn ) -> spec_fn arg Nothing -> fn arg newtypeQr a = Q(a -> r) \n extT fn spec_fn arg = case gcast (T spec_fn) g of Just (T spec_fn ) -> spec_fn arg Nothing -> fn \narg newtypeTa = T (a-> a) As with cast before, gcast is best regarded as a built-in primitive, but \nin fact gcast replaces cast. Our implementation of cast, dis\u00adcussed at length in [16], can be adopted \ndirectly for gcast. The only difference is that gcast neglects the type constructor c in the test for \ntype equivalence [17]. This generalisation, from cast to gcast, is not a new idea. Weirich [22] uses \nthe same generalisation, from cast to cast in her case, albeit using structural rather than nominal type \nequality. We used a very similar pattern in our earlier paper, when we generalised gmapQ, gmapT and gmapM \nto produce the function gfoldl [16].  7.3 Polymorphic function extension The function extQ allows us \nto extend a generic function at a particular monomorphic type, but not at a polymorphic type. For example, \nas it stands gshow will print lists in pre.x form \"(: 1 (: 2 : []))\". How could we print lists in dist.x \nnota\u00adtion, thus \"[1,2]\"? Our raw material must be a list-speci.c, but still element-generic function \nthat prints lists in dist.x notation: gshowList :: Data b => [b] -> String gshowList xs = \"[\" ++ intersperse \n\",\" (map gshow xs) ++ \"]\"  Now we need to extend gshow_help with gshowList but extQ has the wrong type. \nInstead, we need a higher-kinded version of extQ, which we call extQ1: extQ1 :: (Typeable a, Typeable1 \nt) => (a-> r) -> (forallb.Data b=> t b-> r) -> (a-> r) gshow :: Data a => a -> String gshow = gshow_help \nextQ showString extQ1 showList  Here, extQ1 is quanti.ed over a type constructor t of kind *->*, and \nhence we need a new type class Typeable1: Haskell sadly lacks kind polymorphism! (This would require \na non-trivial lan\u00adguage extension.) We discuss Typeable1 in Section 7.4. To de.ne extQ1we can follow \nexactly the same pattern as for extQ, above, but using a different cast operator: extQ1 fn spec_fn arg \n = case dataCast1 (Q spec_fn) of Just (Q spec_fn ) -> spec_fn arg Nothing -> fn arg newtypeQr a = \nQ(a -> r)  Here, we need (another) new cast operator, dataCast1. Its type is practically forced by the \nde.nition of extQ1: dataCast1 :: (Typeable1 s, Data a) => (forall b. Data b => c (s b)) -> Maybe (c a) \n It is absolutely necessary to have the Data constraint in the argu\u00adment to dataCast1. For example, \nthis will not work at all: bogusDataCast1 :: (Typeable1 s, Typeable a) => (forall b. c (s b)) -> Maybe \n(c a)  It will not work because the argument is required to be completely polymorphic in b, and our \ndesired arguments, such as showList are not; they need the Data constraint. That is why the Data appears \nin the name dataCast1. How, then are we to implement dataCast1? We split the imple\u00admentation into two \nparts. The .rst part performs the type test (Sec\u00adtion 7.4), while the second instantiates the argument \nto dataCast1 (Section 7.5). 7.4 Generalising castagain First, the type test. We need a primitive castoperator, \ngcast1, that matches the type constructor of the argument, rather than the type. Here is its type along \nwith that of gcast for comparison: gcast1 :: (Typeable1 s, Typeable1 t) --New =>c (s a)-> Maybe(c (t \na)) gcast :: (Typeable a, Typeable b) --For comparison => ca -> Maybe(c b)  The role of c is unchanged. \nThe difference is that gcast1 com\u00adpares the type constructors s and t, instead of the types a and b. \nAs with our previous generalisation, from cast to gcast, the Typeable constraints concern only the differences \nbetween the two types whose common shape is (c ( a)). The implementation of gcast1 follows the same trivial \nscheme as before [16, 17]. The new class Typeable1 is parameterised over type constructors, and allows \nus to extract a representation of the type constructor: class Typeable1 s where typeOf1 :: s a -> TypeRep \n instance Typeable1 [] where typeOf1 _ = mkTyCon \"Prelude.List\" instance Typeable1 Maybe where typeOf1 \n_ = mkTyCon \"Prelude.Maybe\" The operation mkTyCon constructs type representations that corre\u00adspond to \ntype constructors. There is a single Typeable instance for all types with an outermost type constructors \nof kind *->*: instance (Typeable1 s, Typeable a) => Typeable (s a) where typeOf x = typeOf1 x mkAppTy \ntypeOf (undefined :: a) (Notice the use of a scoped type variable here. Also, generic in\u00adstances are \nnot Haskell 98 compliant. One could instead use one instance per type constructor of kind *->*.) The \nfunction mkAppTy applies a type-constructor representation to an argument-type rep\u00adresentation. In the \nabsence of kind polymorphism, we sadly need a distinct Typeable class for each kind of type constructor. \nFor example, for binary type constructors we have: class Typeable2 s where typeOf2 :: s a b -> TypeRep \n instance (Typeable2 s, Typeable a) => Typeable1 (s a) where typeOf1 x = typeOf2 x mkAppTy typeOf (undefined \n:: a) One might worry about the proliferation of Typeable classes, but in practice this is not a problem. \nFirst, we are primarily interested in type constructors whose arguments are themselves of kind *, be\u00adcause \nthe Data class only makes sense for types. Second, the arity of type constructors is seldom large.  \n7.5 Implementing dataCast1 Our goal is to implement dataCast1 using gcast1: dataCast1 :: (Typeable1 s, \nData a) => (forall b. Data b => c (s b)) -> Maybe (c a) gcast1 :: (Typeable1 s, Typeable1 t) =>c (s \na)-> Maybe(c (t a)) There appear to be two dif.culties. First, dataCast1 must work over any type (c \na), whereas gcast1 is restricted to types of form (c (t a)). Second, dataCast1 is given a polymorphic \nar\u00adgument which it must instantiate by applying it to a dictionary for Data a. Both these dif.culties \ncan, indeed must, be met by making dataCast1 into a member of the Data class itself: class Typeable a \n=> Data a where ... dataCast1 :: Typeable1 s => (forall a. Data a => c (s b)) -> Maybe (c a) Now \nin each instance declaration we have available precisely the necessary Data dictionary to instantiate \nthe argument. All dataCast1 has to do is to instantiate f, and pass the instantiated version on to gcast1 \nto perform the type test, yielding the follow\u00ading, mysteriously simple implementation: instance Data \na => Data [a] where ... dataCast1 f = gcast1 f  The instances of dataCast1for type constructors of \nkind other than *->* returns Nothing, because the type is not of the required form. instance Data Int \nwhere ... dataCast1 f = Nothing  Just as we need a family of Typeable classes, so we need a family \nof dataCast operators with an annoying but unavoidable limit. 7.6 Generic function extension summary \nAlthough this section has been long and rather abstract, the con\u00adcrete results are simple to use. We \nhave been able to generalise extQ, extT, extM (and any other variants you care to think of) so that they \nhandle polymorphic as well as monomorphic cases. The new operators are easy to use see the de.nition \nof gshow in Sec\u00adtion 7.3 and are built on an interesting and independently-useful generalisation of \nthe Typeableclass. All the instances for Dataand Typeable are generated automatically by the compiler, \nand need never be seen by the user.  8 Related work The position of the Scrap your boilerplate approach \nwithin the generic programming .eld was described in the original paper. Hence, we will focus on related \nwork regarding the new contribu\u00adtions of the present paper: type re.ection (Section 5), zipping com\u00adbinators \n(Section 6), and generic function extension (Section 7). Our type re.ection is a form of introspection, \ni.e., the structure of types can be observed, including names of constructors, .elds, and types. In addition, \nterms can be constructed. This is similar to the re.ection API of a language like Java, where attributes \nand method signatures can be observed, and objects can be constructed from class names. The sum-of-products \napproach to generic program\u00adming abstracts from everything except type structure. In the pure sum-of-products \nsetup, one cannot de.ne generic read and show functions. There are non-trivial re.nements, which enrich \ninduc\u00adtion on type structure with cases for constructor applications and labelled components [7, 4, 8]. \nIn our approach, re.ective infor\u00admation travels silently with the Data dictionaries that go with any \ndata value. This is consistent with the aspiration of our approach to de.ne generic functions without \nreference to a universal repre\u00adsentation, and without compile-time specialisation. Altenkirch and McBride \ns generic programming with dependent types [1] suggests that re.ective data can also be represented as \ntypes, which is more typeful than our approach. Zipping is a well-known generic operation [12, 4, 13]. \nOur de\u00advelopment shows that zippers can be de.ned generically as cur\u00adried folds, while taking advantage \nof higher-order generic func\u00adtions. De.ning zippers by pattern matching on two parameters in\u00adstead, would \nrequire a non-trivial language extension. In the sum\u00adof-product approach, zippers perform polymorphic \npattern match\u00ading on the two incoming data structures simultaneously. To this end, the generic function \nis driven by the type structure of a shared type constructor, which implies dependently polymorphic argument \ntypes [12, 4]. Altenkirch and McBride s generic programming with dependent types [1] indicates that argument \ntype dependencies as in zipping can be captured accordingly with dependent types if this is intended. \nTheir approach also employs a highly paramet\u00adric fold operator that is readily general for multi-parameter \ntraver\u00adsal. The pattern calculus (formerly called constructor calculus) by Barry Jay [13], de.nes zipping-like \noperations by simultaneous pat\u00adtern matching on two arbitrary constructor applications. Like in our zippers, \nthe argument types are independently polymorphic. Customisation of generic functions for speci.c types \nis an obvious desideratum. In Generic Haskell, generic function de.nitions can involve some sort of ad-hoc \nor default cases [7, 5, 4, 19]. Our ap\u00adproach narrows down generic function extension to the very simple \nconstruct of a nominal type cast [16]. However, our original paper facilitated generic function extension \nwith only monomorphic cases as a heritage of our focus on term traversal. The new development of Section \n7 generalised from monomorphic to polymorphic cases in generic function extension. This generality of \ngeneric function extension is also accommodated by Generic Haskell, but rather at a static level relying \non a dedicated top-level declaration form for generic functions. By contrast, our generic function extension \nfa\u00adcilitates higher-order generic functions. In a very recent paper [8], Hinze captures essential idioms \nof Generic Haskell in a Haskell 98-based model, which requires ab\u00adsolutely no extensions. Nevertheless, \nthe approach is quite gen\u00aderal. For instance, it allows one to de.ne generic functions that are indexed \nby type constructors. This work shares our aspiration of lightweightness as opposed to the substantial \nlanguage extension of Generic Haskell [7, 5, 4, 19]. Hinze s lightweight approach does not support some \naspects of our system. Notably, Hinze s generic functions are not higher-order; and generic functions \noperate on a representation type. Furthermore, the approach exhibits a limita\u00adtion related to generic \nfunction extension: the class for generics would need to be adapted for each new type or type constructor \nthat requires a speci.c case. 9 Conclusion We have completed the Scrap your boilerplate approach to generic \nprogramming in Haskell, which combines the following attributes: Lightweight: the approach requires two \nindependently-useful lan\u00adguage extensions to Haskell 98 (higher-rank types and type\u00adsafe cast), after \nwhich everything can be implemented as a library. A third extension, extending the deriving clause to \nhandle Data and Typeable is more speci.c to our approach, but this code-generation feature is very non-invasive. \nGeneral: the approach handles regular data types, nested data types, mutually-recursive data types, type \nconstructor param\u00adeterised in additional types; and it handles single and multi\u00adparameter term traversal, \nas well as term building. Versatile: the approach supports higher-order generic program\u00adming, reusable \nde.nitions of traversal strategies, and over\u00adriding of generic functions at speci.ed types. There is \nno closed world assumption regarding user-de.ned data types. Direct: generic functions are directly de.ned \non Haskell data types without detouring to a uniform representation type such as sums-of-products. Also, \nHaskell s nominal type equiva\u00adlence is faithfully supported, as opposed to more structurally\u00adde.ned generic \nfunctions. Well integrated and supported: everything we describe is imple\u00admented in GHC and supported \nby a Haskell generics library. Acknowledgements. We gratefully acknowledge very helpful com\u00adments and \nsuggestions by four anonymous ICFP 2004 referees as well as by Olaf Chitil, Andres L\u00a8oh, and Simon Marlow. \n 10 References [1] T. Altenkirch and C. McBride. Generic programming within depen\u00addently typed programming. \nIn Generic Programming, 2003. Proceed\u00adings of the IFIP TC2 Working Conference on Generic Programming, \nSchloss Dagstuhl, July 2002. [2] F. Atanassow, D. Clarke, and J. Jeuring. UUXML: A Type-Preserving XML \nSchema-Haskell Data Binding. In B. Jayaraman, editor, Practi\u00adcal Aspects of Declarative Languages: 6th \nInternational Symposium, PADL 2004, Dallas, TX, USA, June 18-19, 2004. Proceedings, volume 3057 of LNCS, \npages 71 85. Springer-Verlag, May 2004. [3] K. Claessen and J. Hughes. QuickCheck: a lightweight tool \nfor ran\u00addom testing of Haskell programs. In ICFP00 [11], pages 268 279. [4] D. Clarke, J. Jeuring, and \nA. L\u00a8oh. The Generic Haskell User s Guide, 2002. Version 1.23 Beryl release. [5] D. Clarke and A. L\u00a8oh. \nGeneric Haskell, Speci.cally. In J. Gibbons and J. Jeuring, editors, Proc. of the IFIP TC2 Working Conference \non Generic Programming. Kluwer Academic Publishers, 2003. [6] J. Harm and R. L\u00a8ammel. Two-dimensional \nApproximation Coverage. Informatica, 24(3):355 369, 2000. [7] R. Hinze. A generic programming extension \nfor Haskell. In Proc. 3rd Haskell Workshop, Paris, France, 1999. Technical report of Univer\u00adsiteit Utrecht, \nUU-CS-1999-28. [8] R. Hinze. Generics for the masses. In these proceedings, 2004. [9] R. Hughes. A novel \nrepresentation of lists and its application to the function reverse. Information Processing Letters, \n22, 1986. [10] G. Hutton and E. Meijer. Functional pearl: Monadic parsing in Haskell. Journal of Functional \nProgramming, 8(4):437 444, July 1998. [11] ACM SIGPLAN International Conference on Functional Program\u00adming \n(ICFP 00), Montreal, Sept. 2000. ACM. [12] P. Jansson and J. Jeuring. PolyLib A library of polytypic \nfunctions. In R. Backhouse and T. Sheard, editors, Proc. of Workshop on Generic Programming, WGP 98, \nMarstrand, Sweden. Dept. of Comp. Science, Chalmers Univ. of Techn. and G\u00a8oteborg Univ., June 1998. [13] \nC. B. Jay. The pattern calculus. http://www-staff.it.uts.edu. au/ cbj/Publications/pattern_calculus.ps, \n2003. (accepted for publication by ACM TOPLAS.). [14] P. W. M. Koopman, A. Alimarine, J. Tretmans, and \nM. J. Plasmei\u00adjer. Gast: Generic Automated Software Testing. In R. Pena and T. Arts, editors, Implementation \nof Functional Languages, 14th In\u00adternational Workshop, IFL 2002, Madrid, Spain, September 16-18, 2002, \nRevised Selected Papers, volume 2670 of LNCS, pages 84 100. Springer-Verlag, 2003. [15] R. L\u00a8ammel and \nJ. Harm. Test case characterisation by regular path expressions. In E. Brinksma and J. Tretmans, editors, \nProc. Formal Approaches to Testing of Software (FATES 01), Notes Series NS-01\u00ad4, pages 109 124. BRICS, \nAug. 2001. [16] R. L\u00a8ammel and S. Peyton Jones. Scrap your boilerplate: a practi\u00adcal design pattern for \ngeneric programming. ACM SIGPLAN Notices, 38(3):26 37, Mar. 2003. Proceedings of the ACM SIGPLAN Work\u00adshop \non Types in Language Design and Implementation (TLDI 2003). [17] The Scrap your boilerplate web site: \nexamples, browsable li\u00adbrary, papers, background, 2003 2004. http://www.cs.vu.nl/ boilerplate/. [18] \nD. Lelewer and D. Hirschberg. Data compression. ACM Computing Surveys, 19(3):261 296, Sept. 1987. [19] \nA. L\u00a8oh, D. Clarke, and J. Jeuring. Dependency-style Generic Haskell. In C. Norris and J. J. B. Fenwick, \neditors, Proceedings of the Eighth ACM SIGPLAN International Conference on Functional Program\u00adming (ICFP-03), \nvolume 38, 9 of ACM SIGPLAN Notices, pages 141 152, New York, Aug. 25 29 2003. ACM Press. [20] S. Peyton \nJones and M. Shields. Practical type inference for higher\u00adrank types. Unpublished manuscript, 2004. [21] \nM. Wallace and C. Runciman. Haskell and XML: Generic combi\u00adnators or type-based translation. In ACM SIGPLAN \nInternational Conference on Functional Programming (ICFP 99), pages 148 159, Paris, Sept. 1999. ACM. \n[22] S. Weirich. Type-safe cast. In ICFP00 [11], pages 58 67. [23] I. Witten, R. Neal, and J. Cleary. \nArithmetic coding for data compres\u00adsion. CACM, 30(6):520 540, June 1987.  \n\t\t\t", "proc_id": "1016850", "abstract": "Writing boilerplate code is a royal pain. Generic programming promises to alleviate this pain by allowing the programmer to write a generic \"recipe\" for boilerplate code, and use that recipe in many places. In earlier work we introduced the \"Scrap your boilerplate\" approach to generic programming, which exploits Haskell's existing type-class mechanism to support generic transformations and queries.This paper completes the picture. We add a few extra \"introspective\" or \"reflective\" facilities, that together support a rich variety of serialisation and de-serialisation. We also show how to perform generic \"zips\", which at first appear to be somewhat tricky in our framework. Lastly, we generalise the ability to over-ride a generic function with a type-specific one.All of this can be supported in Haskell with independently-useful extensions: higher-rank types and type-safe cast. The GHC implementation of Haskell readily derives the required type classes for user-defined data types.", "authors": [{"name": "Ralf L&#228;mmel", "author_profile_id": "81100095823", "affiliation": "Vrije Universiteit & CWI, Amsterdam", "person_id": "PP18000329", "email_address": "", "orcid_id": ""}, {"name": "Simon Peyton Jones", "author_profile_id": "81100271851", "affiliation": "Microsoft Research, Cambridge", "person_id": "PP43121273", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1016850.1016883", "year": "2004", "article_id": "1016883", "conference": "ICFP", "title": "Scrap more boilerplate: reflection, zips, and generalised casts", "url": "http://dl.acm.org/citation.cfm?id=1016883"}