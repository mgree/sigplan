{"article_publication_date": "09-19-2004", "fulltext": "\n Generics for the Masses Ralf Hinze Institut f\u00a8ur Informatik III Universit\u00a8at Bonn R\u00a8omerstra\u00dfe 164, \n53117 Bonn, Germany ralf@informatik.uni-bonn.de ABSTRACT A generic function is a function that can be \ninstantiated on many data types to obtain data type speci.c functionality. Examples of generic functions \nare the functions that can be derived in Haskell, such as show, read ,and . The recent years have seen \na number of proposals that support the de.\u00adnition of generic functions. Some of the proposals de.ne new \nlanguages, some de.ne extensions to existing languages. As a common characteristic none of the proposals \ncan be made to work within Haskell 98: they all require something extra, either a more sophisticated \ntype system or an additional language construct. The purpose of this pearl is to show that one can, in \nfact, program generically within Haskell 98 obviating to some extent the need for fancy type systems \nor separate tools. Haskell s type classes are at the heart of this approach: they ensure that generic \nfunctions can be de.ned succinctly and, in particular, that they can be used painlessly.  Categories \nand Subject Descriptors D.3.3 [Programming Languages]: Language Constructs and Features General Terms \nLanguages Keywords Generic programming, type classes, Haskell 98 1. INTRODUCTION A type system is like \na suit of armour: it shields against the modern dangers of illegal instructions and memory vio\u00adlations, \nbut it also restricts .exibility. The lack of .exibility is particularly vexing when it comes to implementing \nfunda\u00admental operations such as showing a value or comparing two values. In a statically typed language \nsuch as Haskell 98 [11] Permission to make digital or hard copies of all or part of this work for personal \nor classroom use is granted without fee provided that copies are not made or distributed for pro.t or \ncommercial advantage and that copies bear this notice and the full citation on the .rst page. To copy \notherwise, to republish, to post on servers or to redistribute to lists, requires prior speci.c permission \nand/or a fee. ICFP 04, September 19 21, 2004, Snowbird, Utah, USA. Copyright 2004 ACM 1-58113-905-5/04/0009 \n...$5.00. it is simply not possible to de.ne an equality test that works for all types. Polymorphism \ndoes not help: equality is not a polymorphic function since it must inspect its arguments. Static typing \ndictates that equality becomes a family of func\u00adtions containing a tailor-made instance of equality for \neach type of interest. Rather annoyingly, all these instances have to be programmed. More than a decade \nago the designers of Haskell noticed and partially addressed this problem. By attaching a so\u00adcalled deriving \nform to a data type declaration the program\u00admer can instruct the compiler to generate an instance of \nequality for the new type.1 In fact, the deriving mechanism is not restricted to equality: parsers, pretty \nprinters and several other functions are derivable, as well. These func\u00adtions have to become known as \ndata-generic or polytypic functions, functions that work for a whole family of types. Unfortunately, \nHaskell s deriving mechanism is closed: the programmer cannot introduce new generic functions. The recent \nyears have seen a number of proposals [9, 7, 2] that support exactly this, the de.nition of generic functions. \nSome of the proposals de.ne new languages, some de.ne ex\u00adtensions to existing languages. As a common \ncharacteristic none of the proposals can be made to work within Haskell 98: they all require something \nextra, either a more sophisticated type system or an additional language construct. The purpose of this \npearl is to show that one can, in fact, program generically within Haskell 98 obviating to some ex\u00adtent \nthe need for fancy type systems or separate tools. The proposed approach is extremely light-weight; each \nimple\u00admentation of generics we will introduce two major ones and a few variations consists roughly of \ntwo dozen lines of Haskell code. The reader is cordially invited to play with the material. The source \ncode can be found at http://www.ralf-hinze.de/masses.tar.bz2 We have also included several exercises \nto support digestion of the material and to stimulate further experiments. 2. GENERIC FUNCTIONS ON TYPES \nThis section discusses the .rst implementation of generics. Sections 2.1 and 2.2 introduce the approach \nfrom a user s perspective, Section 2.3 details the implementation, and Sec\u00ad 1Actually, in Haskell 1.0 \nthe compiler would always gener\u00adate an instance of equality. A deriving form was used to restrict the \ninstances generated to those mentioned in the form. To avoid the generation of instances altogether, \nthe programmer had to supply an empty deriving clause. tion 2.4 takes a look at various extensions, some \nobvious and some perhaps less so. 2.1 De.ning a generic function Let us tackle a concrete problem. Suppose \nwe want to encode elements of various data types as bit strings imple\u00admenting a simple form of data compression. \nFor simplicity, we represent a bit string by a list of bits. type Bin =[Bit ] data Bit = 0 | 1 deriving \n(Show) bits :: (Enum a) . Int . a. Bin We assume a function bits that encodes an element of an enumeration \ntype using the speci.ed number of bits. We seek to generalize bits toafunction showBin that works for \narbitrary types. Here is a simple interactive session that illustrates the use of showBin (note that \ncharacters consume 7 bits and integers 16 bits). Main showBin 3 [1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0 ] Main \nshowBin [3,5] [1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0 ] Main showBin \n\"Lisa\" [1,0,0,1,1,0,0,1,1,1,0,0,1,0,1,1, 1,1,1,0,0,1,1,1,1,1,0,0,0,0,1,1,0 ] Astringoflength n, for instance, \nis encoded in 8 * n +1 bits. Implementing showBin so that it works for arbitrary data types seems like \na hard nut to crack. Fortunately, generic programming comes to the rescue. The good news is that it su.ces \nto de.ne showBin for primitive types and for three elementary types: the one-element type, the binary \nsum, and the binary product. data Unit = Unit data Plus a\u00df= Inl a| Inr \u00df data Pair a\u00df= Pair{outl :: a,outr \n:: \u00df} Why these types? Well, Haskell s construct for de.ning new types, the data declaration, introduces \na type that is iso\u00admorphic to a sum of products. Thus, if we know how to compress sums and products, \nwe can compress elements of an arbitrary data type. More generally, we can handle a type s if we can \nhandle some representation type t that is isomorphic to s. The details of the representation type are \nlargely irrelevant. When programming a generic func\u00adtion it su.ces to know the two mappings that witness \nthe isomorphism. data Iso a\u00df= Iso{fromData :: \u00df. a,toData :: a. \u00df} Turning to the implementation of showBin,we.rst \nhave to provide the signature of the generic function. Rather unusually, we specify the type using a \nnewtype declaration. newtype ShowBin a= ShowBin{appShowBin :: a. Bin } An element of ShowBin s is an \ninstance of showBin that encodes values of type s as bit strings. We know that showBin itself cannot \nbe a genuine polymorphic function of type a . Bin. Data compression does not work for arbitrary types, \nbut only for types that are representable. Representable means that the type can be represented by acertain \nvalue. For the moment, it su.ces to know that a type representation is simply an overloaded value called \nrep. The generic compression function is then given by the following simple, yet slightly mysterious \nde.nition. showBin :: (Rep a) . a. Bin showBin = appShowBin rep Loosely speaking, we apply the generic \nfunction to the type representation rep. Of course, this is not the whole story. The code above de.nes \nonly a convenient shortcut. The actual de.nition of showBin is provided by an instance dec\u00adlaration, \nbut you should read it instead as just a generic de.nition. instance Generic ShowBin where unit = ShowBin \n(.x . []) plus = ShowBin (.x . case x of Inl l . 0 : showBin l Inr r . 1 : showBin r) pair = ShowBin \n(.x . showBin (outl x) + showBin (outr x)) datatype iso = ShowBin (.x . showBin (fromData iso x)) char \n= ShowBin (.x . bits 7 x) int = ShowBin (.x . bits 16 x) The class Generic has six member functions \ncorresponding to the elementary types, Unit, Plus,and Pair,and to a small selection of primitive types, \nChar and Int.The member function datatype, which slightly breaks ranks, deals with arbitrary data types. \nEach method binding de.nes the in\u00adstance of the generic function for the corresponding type. Let us consider \neach case in turn. To encode the single element of the type Unit no bits are required (read: the in\u00adstance \nof showBin for the Unit type is .x . []). To encode an element of a sum type, we emit one bit for the \nconstruc\u00adtor followed by the encoding of its argument. The encoding of a pair is given by the concatenation \nof the component s encodings. To encode an element of an arbitrary data type, we .rst convert the element \ninto a sum of products, which is then encoded. Finally, characters and integers are encoded using the \nfunction bits. That s it, at least, as far as the generic function is con\u00adcerned. Before we can actually \ncompress data to strings of bits, we .rst have to turn the types of the to-be-compressed values into \nrepresentable types, which is what we will do next. Exercise 1. Implement a generic version of Haskell \ns com\u00adparison function compare :: (Rep a) . a. a. Ordering. Follow the scheme above: .rst turn the signature \ninto a newtype declaration, then de.ne compare, and .nally pro\u00advide an instance of Generic. . Exercise \n2. Implement a function readBin :: (Rep a) . Bin . a that decodes a bit string that was encoded by showBin. \n. 2.2 De.ning a new type A generic function such as showBin can only be instanti\u00adated to a representable \ntype. By default, only the elemen\u00adtary types, Unit, Plus,and Pair, and the primitive types Char and Int \nare representable. So, whenever we de.ne a new data type and we intend to use a generic function on that \ntype, we have to do a little bit of extra work. As an example, consider the data type of binary leaf \ntrees. data Tree a= Leaf a| Fork (Tree a)(Tree a) We have to show that this type is representable. To \nthis end we exhibit an isomorphic type built from representable type constructors. We call this type \nthe structure type of Tree. instance (Rep a) . Rep (Tree a) where rep = datatype (Iso fromTree toTree) \nThe main work goes into de.ning two mappings, fromTree and toTree, which certify that Tree aand its structure \ntype Plus a(Pair (Tree a)(Tree a)) are indeed isomorphic.2 fromTree :: Tree a. Plus a(Pair (Tree a)(Tree \na)) fromTree (Leaf x )= Inl x fromTree (Fork l r)= Inr (Pair l r) toTree :: Plus a(Pair (Tree a)(Tree \na)) . Tree a toTree (Inl x)= Leaf x toTree (Inr (Pair l r)) = Fork l r Perhaps surprisingly, the structure \ntype may contain the original type. This is valid and, in fact, the standard ap\u00adproach for recursive \ntypes since the original type becomes representable by virtue of the instance declaration. Oh, wonders \nof recursion! As a second example, here is the encoding of Haskell s list data type. instance (Rep a) \n. Rep [a] where rep = datatype (Iso fromList toList) fromList :: [a] . Plus Unit (Pair a[a]) fromList \n[] = Inl Unit fromList (x : xs) = Inr (Pair x xs) toList :: Plus Unit (Pair a[a]) . [a] toList (Inl Unit) \n= [ ] toList (Inr (Pair x xs)) = x : xs The Unit type is used for encoding constructors with no arguments. \nIf a data type has more than two alternatives, or if a constructor has more than two arguments, we have \nto nest the binary type constructors Plus and Pair accordingly. Actually, we are more .exible than this: \nwe can map the new type to any other type as long as the target type is an instance of Rep. Exercise \n3. Turn the following types into instances of Rep. data Shrub a\u00df= Tip a| Node (Shrub a\u00df) \u00df(Shrub a\u00df) \ndata Rose a = Branch a[Rose a] . 2.3 Implementation The implementation of light-weight generics is surpris\u00adingly \nconcise: apart from declaring the two classes, Generic and Rep, we only provide a handful of instance \ndeclarations. To begin with, the class Generic accommodates the di.erent instances of a generic function. \nclass Generic g where unit :: gUnit plus :: (Rep a,Rep \u00df) . g (Plus a\u00df) pair :: (Rep a,Rep \u00df) . g (Pair \na\u00df) datatype :: (Rep a) . Iso a\u00df. g \u00df char :: g Char int :: gInt 2Strictly speaking, the type Tree a \nand its structure type Plus a (Pair (Tree a)(Tree a)) are not isomorphic in Haskell since Plus is a lifted \nsum. We simply ignore this complication here. The class abstracts over the type constructor g,the type \nof a generic function. This is why unit has type gUnit.In the case of Plus and Pair the corresponding \nmethod has an additional context that constrains the type arguments of Plus and Pair to representable \ntypes. This context is neces\u00adsary so that a generic function can recurse on the component types. In fact, \nthe context allows us to call any generic func\u00adtion, so that we can easily de.ne mutually recursive generic \nfunctions. We will see an example of this in the next section. Now, what does it mean for a type to be \nrepresentable? For our purposes, this simply means that we can instantiate a generic function to that \ntype. So an intriguing choice is to identify type representations with generic functions. class Rep awhere \nrep :: (Generic g) . g a Note that the type variable g is implicitly universally quan\u00adti.ed: the type \nrepresentation must work for all instances of g. This is quite a strong requirement. How can we possibly \nde.ne an instance of g? The answer is simple, yet mind\u00adboggling: we have to use the methods of class \nGeneric.Re\u00adcall that unit has type (Generic g) . gUnit.Thus, we can turn Unit into an instance of Rep. \ninstance Rep Unit where rep = unit instance (Rep a,Rep \u00df) . Rep (Plus a\u00df) where rep = plus instance (Rep \na,Rep \u00df) . Rep (Pair a\u00df) where rep = pair instance Rep Char where rep = char instance Rep Int where rep \n= int Strange as the instance declarations may seem, each has a logical explanation. A type is representable \nif we can instan\u00adtiate a generic function to that type. But the class Generic just contains the instances \nof generic functions. Thus, each method of Generic with the notable exception of datatype gives rise \nto an instance declaration. We have seen in Sec\u00adtion 2.2 that the method datatype is used to make an \narbi\u00adtrary type an instance of Rep. The procedure described in Section 2.2 is, in fact, dictated by the \ntype of datatype:we have to provide an isomorphic data type which in turn is representable. Thetypeof \nrep,namely, (Rep a,Generic g) . g a is quite remarkable. In a sense, rep can beseen as themother of all \ngeneric functions. This de-mysti.es the de.nition of showBin in Section 2.1: the application appShowBin \nrep implicitly instantiates rep s type to (Rep a) . ShowBin a, which the .eld selector appShowBin subsequently \nturns to (Rep a) . a . Bin. Note that the classes Generic and Rep are mutually recursive: each class \nlists the other one in amethod context. 2.4 Extensions 2.4.1 Additional type cases The class Generic \ncan be seen as implementing a case analysis on types. Each method corresponds to a case branch. Types \nnot listed as class methods are handled completely generically. However, this is not always what is wanted. \nAs an example, recall that the encoding of a list of length n takes n + 1 bits plus the space for the \nencoding of the ele\u00adments. A better method is to .rst encode the length of the list and then to concatenate \nthe encodings of the elements. In order to treat the list type as a separate case, we have to add a new \nmethod to the class Generic. class Generic g where ... list :: (Rep a) . g [a] list = datatype (Iso fromList \ntoList) instance (Rep a) . Rep [a] where rep = list So, the bad news is that we have to change a class \nde.ni\u00adtion (which suggests that Generic is not a good candidate for inclusion into a library). The good \nnews is that by supplying a default de.nition for list this change does not a.ect any of the instance \ndeclarations: all the generic functions work exactly as before. The new ShowBin instance overrides the \ndefault de.nition. instance Generic ShowBin where ... list = ShowBin (.x . bits 16 (length x) + concatMap \nshowBin x) The technique relies on Haskell s concept of default class methods: only if the instance does \nnot provide a binding for the list method, then the default class method is used. Exercise 4. Adopt readBin \nto the new encoding of lists. . 2.4.2 A default type case Using the same technique we can also implement \na default or catch-all type case. class Generic g where ... default :: (Rep a) . g a unit = default plus \n= default pair = default char = default int = default Now, the generic programmer can either de.ne unit, \nplus, pair , char, int or simply default (in addition to datatype).3 A default type case is useful for \nsaying treat all the type cases not explicitly listed in the following way . We will see an example application \nin Section 2.4.4. 2.4.3 Accessing constructor names So far, the structure type captures solely the structure \nof a data type, hence its name. However, in Haskell there is more toadatatype thanthis: a data constructor \nhas a unique name, an arity, possibly a .xity, and possibly named .elds. We are free to add all this \ninformation to the structure type. There are, in fact, several ways to accomplish this: we discuss one \nalternative in the sequel, Exercise 5 sketches a second one. 3Unfortunately, if we specify all the type \ncases except default, we get a compiler warning saying that there is no explicit method nor default method \nfor default. To record the properties of a data constructor we use the data type Constr (we con.ne ourselves \nto name and arity). type Name = String type Arity = Int data Constr a= Constr {name :: Name, arity :: \nArity, arg :: a} As an example, here is a suitable rede.nition of fromTree and toTree. type Tree. a= \nPlus (Constr a) (Constr (Pair (Tree a)(Tree a))) fromTree :: Tree a. Tree. a fromTree (Leaf x )= Inl \n(Constr \"Leaf\" 1 x) fromTree (Fork lr)= Inr (Constr \"Fork\" 2(Pair l r)) toTree :: Tree. a . Tree a toTree \n(Inl (Constr n a x)) = Leaf x toTree (Inr (Constr n a (Pair l r))) = Fork lr Note that, for reasons of \ne.ciency, toTree simply discards the additional Constr wrapper. So strictly, the two func\u00adtions do not \nde.ne an isomorphism. This is not a problem, however, as long as we do not cheat with the constructor \nnames. It remains to introduce a new type case for constructors and to add Constr to the league of representable \ntypes. class Generic g where ... constr :: (Rep a) . g (Constr a) constr = datatype (Iso arg wrap) where \nwrap a = Constr \"\" (-1) a instance (Rep a) . Rep (Constr a) where rep = constr Note that arg, which is \nused in the default method for constr , is a .eld selector of the data type Constr . Figure 1 displays \na simple pretty printer, based on Wadler s prettier printing library [13], that puts the additional infor\u00admation \nto good use. The plus case discards the constructors Inl and Inr as they are not needed for showing a \nvalue. The constr case signals the start of a constructed value. If the constructor is nullary, its string \nrepresentation is emitted. Otherwise, the constructor name is printed followed by a space followed by \nthe representation of its arguments. The pair case applies if a constructor has more than one compo\u00adnent. \nIn this case the components are separated by a space. Finally, list takes care of printing lists using \nstandard list syntax: comma-separated elements between square brack\u00adets. The approach above works well \nfor pretty printing but, unfortunately, fails for parsing. The problem is that the constructor names \nare attached to a value.Consequently, this information is not available when parsing a string. The important \npoint is that parsing produces (not consumes) a value, and yet it requires access to the constructor \nname. An alternative approach, discussed in the exercise below, is to attach the information to the type \n(well, to the type representation). newtype Pretty a= Pretty{ appPretty :: a . Doc } pretty :: (Rep a) \n. a. Doc pretty = appPretty rep instance Generic Pretty where unit = Pretty (.x . empty) plus = Pretty \n(.x . case x of Inl l . pretty l Inr r . pretty r) pair = Pretty (.x . pretty (outl x) o line o pretty \n(outr x)) datatype iso = Pretty (.x . pretty (fromData iso x)) char = Pretty (.x . prettyChar x) int \n= Pretty (.x . prettyInt x) list = Pretty (.x . prettyl pretty x) constr = Pretty (.x . let s = text \n(name x) in if arity x 0 then s else group (nest 1( text \"(\" o s o line o pretty (arg x) o text \")\"))) \nprettyl :: (a. Doc) . ([a] . Doc) prettyl p [] = text \"[]\" prettyl p (a : as)= group (nest 1(text \"[\" \no pa o rest as)) where rest [] = text \"]\" rest (x : xs)= text \",\" o line o px o rest xs Figure 1: A generic \nprettier printer Exercise 5. Augment the datatype method by an additional argument datatype :: (Rep a) \n. DataDescr . Iso a\u00df . g \u00df that records information about the data type and its con\u00adstructors. Re-implement \nthe pretty printer using this mod\u00adi.cation instead of the constr case. . Exercise 6. Use the extension \nof the previous exercise and a parser library of your choice to implement a generic parser analogous \nto Haskell s read method. . 2.4.4 Mutual recursion In Haskell, the Show class takes care of pretty printing. \nThe class is very carefully crafted so that strings, which are lists of characters, are shown in double \nquotes, rather than between square brackets. It is instructive to re-program this behaviour as the new \ncode requires all three extensions introduced above. Basically, we have to implement a nested case analysis \non types. The outer type case checks whether we have a list type; the inner type case checks whether \nthe type argument of the list type constructor is Char. In our setting, a nested type case can be encoded \nusing a pair of mutually recursive generic functions. The .rst realizes the outer type case. instance \nGeneric Pretty where ... list = Pretty (.x . prettyList x) The instance declaration is the same as before, \nexcept that the list method dispatches to the second function which cor\u00adresponds to the inner type case. \nnewtype PrettyList a = PrettyList { appPrettyList :: [a] . Doc } prettyList :: (Rep a) . [a] . Doc prettyList \n= appPrettyList rep instance Generic PrettyList where char = PrettyList (.x . prettyString x) datatype \niso = PrettyList (.x . prettyl prettyd x) where prettyd = pretty \u00b7 fromData iso list = default default \n= PrettyList (.x . prettyl pretty x) The PrettyList instance makes use of a default type case which implements \nthe original behaviour (comma-separated elements between square brackets). The datatype method is similar \nto default except that the list elements are .rst converted to the structure type. Note that the list \nmethod must be explicitly set to default because it has the wrong default class method (datatype (Iso \nfromList toList)instead of default). Finally, the char method takes care of printing strings in double \nquotes.  3. GENERIC FUNCTIONS ON TYPE CONSTRUCTORS Let us now turn to the second implementation of \ngener\u00adics, which will increase .exibility at the cost of automation. Note that we re-use the class and \nmethod names even though the types of the class methods are slightly di.erent. 3.1 De.ning a generic \nfunction The generic functions introduced in the last section ab\u00adstract over a type. For instance, showBin \ngeneralizes func\u00adtions of type Char . Bin, String . Bin, [[Int ]] . Bin to a single generic function \nof type (Rep a) . a . Bin A generic function may also abstract over a type constructor. Take, as an example, \na function that counts the number of elements contained in a data structure. Such a function generalizes \nfunctions of type [a] . Int, Tree a . Int, [Rose a] . Int to a single generic function of type (FRep \n.) . .a . Int The class context makes explicit that counting elements does not work for arbitrary type \nconstructors, but only for rep\u00adresentable ones. When type constructors come into play, typings often \nbe\u00adcome ambiguous. Imagine applying a generic size function to a data structure of type [Rose Int ]. \nShall we count the number of rose trees in the list, or the number of integers in the list of rose trees? \nBecause of this inherent ambiguity, the second implementation of generics will be more explicit about \ntypes and type representations. The following imple\u00admentation of a generic counter illustrates the point. \nnewtype Count a= Count{appCount :: a . Int } instance Generic Count where unit = Count (.x . 0) plus \na b = Count (.x . case x of Inl l . appCount a l Inr r . appCount b r) pair a b = Count (.x . appCount \na (outl x) + appCount b (outr x)) datatype iso a = Count (.x . appCount a (fromData iso x)) char = \nCount (.x . 0) int = Count (.x . 0) The new version of the class Generic has the same mem\u00adber functions \nas before, but with slightly di.erent typings: the cases corresponding to type constructors, plus, pair \nand datatype, now take explicit type arguments, a and b,which are passed to the recursive calls. Of course, \nwe do not pass types as arguments, but rather type representations. Though the class is a bit di.erent, \nwe are still able to de.ne all the generic functions we have seen before. In par\u00adticular, we can apply \nappCount to rep to obtain a generic function of type (Rep a) . a . Int. However, the re\u00adsult is not interesting \nat all: the function always returns 0 (provided its argument is fully de.ned). Instead, we ap\u00adply appCount \nto frep, the generic representation of a type constructor. size :: (FRep .) . .a . Int size = appCount \n(frep (Count (.x . 1))) Since frep represents a type constructor, it takes an addi\u00adtional argument, which \nspeci.es the action of size on the base type a: the function .x . 1 makes precise that each element of \ntype a counts as 1. Interestingly, this is not the only option. If we pass the identity to frep,then \nwe get a generic sum function. sum :: (FRep .) . .Int . Int sum = appCount (frep (Count (.x . x))) Two \ngeneric functions for the price of one! When size and sum are applied to some value, Haskell s type inferencer \ndetermines the particular instance of the type constructor .. Wehavenoted before that there are, in general, \nseveral possible alternatives for ..If we are not happy with Haskell s choice, we can always specify \nthe type explicitly. Main let xss =[[i * j | j . [i ..9]] | i . [0 ..9]] Main size xss 10 Main let a \n= Count (.x . 1) Main appCount (list (list a)) xss 55 Main appCount (list a) xss 10 Main appCount a xss \n1 By default, size calculates the size of the outer list, not the total number of elements. For the latter \nbehaviour, we must pass an explicit type representation to appCount.This is something which is not possible \nwith the .rst implemen\u00adtation of generics. Exercise 7. Generalize size and sum so that they work for \narbitrary numeric types. size :: (FRep .,Num .) . .a. . sum :: (FRep .,Num .) . .. . . . Exercise 8. \nThe function reducer whose signature is given below generalizes Haskell s foldr function (reducer swaps \nthe second and the third argument). newtype Reducer \u00dfa = Reducer {appReducer :: a . \u00df . \u00df} instance Generic \n(Reducer \u00df) where ... reducer :: (FRep .) . (a. \u00df . \u00df) . (.a. \u00df . \u00df) reducer f = appReducer (frep (Reducer \nf )) Fill in the missing details. Use reducer to de.ne a function that .attens a data structure into \na list of elements. De.ne sum in terms of reducer . . 3.2 Introducing a new type As before, we have \nto do a bit of extra work when we de.ne a new data type. The main di.erence to Section 2.2 is that we \nmust explicitly de.ne the structure type: the method datatype now expects the structure type as its second \nargu\u00adment. At .rst sight, providing this information seems to be a lot less elegant, but it turns out \nto be fairly advantageous. Reconsider the data type Tree. Since it is a type construc\u00adtor rather than \na type, we .rst de.ne a type constructor representation . tree :: (Generic g) . g a. g (Tree a) tree \na = datatype (Iso fromTree toTree) (a . tree a . tree a) The operators . and . are convenient shortcuts \nfor plus and pair . in.xr 3 . in.xr 2 . a . b = plus a b a . b = pair a b The type constructor Tree can \nbe seen as a function that takes types to types. Likewise, tree is a function that takes type representations \nto type representations. The structure type a . tree a . tree a makes explicit, that Tree is a binary \nsum, that the .rst constructor takes a single argument of type a, and that the second constructor takes \ntwo arguments of type Tree a.Using tree we can now provide suitable instances of Rep and FRep. instance \n(Rep a) . Rep (Tree a) where rep = tree rep instance FRep Tree where frep = tree The last declaration \nshows that tree is just the Tree instance of frep. 3.3 Implementation The implementation of Generic \nand Rep re.ects the change from implicit to explicit type arguments: the implicit argu\u00adments in the form \nof a context (Rep a) . are replaced by explicit arguments of the form g a . . class Generic g where unit \n:: gUnit plus :: g a. g \u00df . g (Plus a\u00df) pair :: g a. g \u00df . g (Pair a\u00df) datatype :: Iso a\u00df . g a . g \u00df \nchar :: g Char int :: gInt class Rep a where rep :: (Generic g) . g a instance Rep Unit where rep = \nunit instance (Rep a,Rep \u00df) . Rep (Plus a\u00df) where rep = rep . rep instance (Rep a,Rep \u00df) . Rep (Pair \na\u00df) where rep = rep . rep instance Rep Char where rep = char instance Rep Int where rep = int Furthermore, \nwe introduce a class that accommodates the mother of all type constructor representations . class FRep \n. where frep :: (Generic g) . g a. g (.a) Exercise 9. The .rst implementation of generics used im\u00adplicit, \nthe second explicit type arguments. Does it make sense to combine both? class Generic g where unit :: \ngUnit plus :: (Rep a,Rep \u00df) . g a . g \u00df . g (Plus a\u00df) ... . Exercise 10. Some generic functions require \nabstraction over two type parameters. class Generic g where unit :: g Unit Unit plus :: g a1 a2 . g \u00df1 \n\u00df2 . g (Plus a1 \u00df1)(Plus a2 \u00df2) ... class Rep awhere rep :: (Generic g) . g aa Implement a generic \nmapping function using this interface (generalizing Haskell s fmap). . 3.4 Extensions 3.4.1 Accessing \nconstructor names Passing type representations explicitly pays o. when it comes to adding information \nabout constructors. In Sec\u00adtion 2.4.3 we had to introduce a new type Constr to record the name and the \narity of the constructor. Now, we can simply add the information to the type representation. class Generic \ng where ... constr :: Name . Arity . g a . g a Since the additional type case constr name arity has \ntype g a . g a, the representation of values is not a.ected. This is a huge advantage as it means that \nthis extension works both for pretty printing and parsing. In particular, it su.ces to adapt the de.nition \nof tree and colleagues; the implementation of the mappings fromTree and toTree is not a.ected. tree :: \n(Generic g) . g a. g (Tree a) tree a = datatype (Iso fromTree toTree)( constr \"Leaf\" 1 a . constr \"Fork\" \n2(tree a . tree a)) The new de.nition of tree is a true transliteration of the data type declaration. \n 3.4.2 Mutual recursion Being explicit about type representations is a bit of a pain when it comes to \nprogramming mutually recursive generic functions. With the .rst implementation mutual recursion was easy: \nthe method context (Rep a) . allowed us to call any generic function. Now, we are less .exible: the explicit \ng a argument corresponds to the immediate recursive call. So, to implement mutual recursion we have to \ntuple the functions involved. newtype Pretty a= Pretty{appPretty :: a. Doc, appPrettyList :: [a] . Doc \n} The following exercise asks you to re-implement the prettier printer using this record type. Exercise \n11. Re-implement the generic prettier printer of Section 2.4.4 using tupling. Try, in particular, to \nsimulate default type cases. .  4. STOCK TAKING We have presented two implementations of generics. \nThe .rst one in Section 2 is slightly easier to use (mutually re\u00adcursive de.nitions are straightforward) \nbut more restricted (generic functions on type constructors are not supported). The second one in Section \n3 is very .exible (supports generic functions on both types and type constructors) but slightly more \ndi.cult to use (mutual recursion requires tupling). The two approaches only di.er in the way type represen\u00adtations \nare passed around: the .rst implementation passes them implicitly via Rep a contexts, the second passes \nthem explicitly as arguments of type g a. Being explicit has one further advantage besides greater expressiveness: \nwe can change the representation of types without changing the rep\u00adresentation of the underlying values. \nThis is jolly useful for adding information about data constructors. The class-based implementation of \ngenerics is surprisingly expressive: we can de.ne all the generic functions presented, for instance, \nin [4]. It has, however, also its limitations. Using the class Generic we can only de.ne functions that \nabstract over one type parameter. In order to implement functions that abstract over two type arguments \nsuch as map, we need an additional type class (see Exercise 10). In fact, we need one separate class \nfor each arity. This has the unfortunate consequence that there isn t a single type representation, which \nis awkward for implementing dynamic values. Furthermore, we cannot de.ne generic functions that involve \ngeneric types [8], types that are de.ned by induction on the structure of types. 5. WHERE TO GO FROM \nHERE Got interested in generic programming? There is quite a wealth of material on the subject. For a \nstart, we rec\u00adommend studying the tutorials [1, 7, 6]. Further reading includes [9, 3]. The particular \nimplementation described in this pearl is inspired by Weirich s paper [14]. Weirich gives an implemen\u00adtation \nin Haskell augmented by rank-2 types. The essence of this pearl is that Haskell s class system can be \nused to avoid higher-order ranks. If you are willing to go beyond Haskell 98, then there is a lot more \nto discover. Using rank-2 types we can implement higher-order generic functions. This extension is vital \nfor implementing generic traversals [12, 5, 10]. Using existential types we can combine generic functions \nwith dynamic values [2, 5]. Dynamic type checking is indispensable for programs that interact with the \nenvironment. Acknowledgements I am grateful to Jeremy Gibbons, Fermin Reig, Stephanie Weirich, and the \nanonymous referees for pointing out several typos and for valuable suggestions regarding grammar and \npresentation. 6. REFERENCES [1] Roland Backhouse, Patrik Jansson, Johan Jeuring, and Lambert Meertens. \nGeneric Programming An Introduction . In S. Doaitse Swierstra, Pedro R. Henriques, and Jose N. Oliveira, \neditors, 3rd International Summer School on Advanced Functional Programming, Braga, Portugal, volume \n1608 of Lecture Notes in Computer Science, pages 28 115. Springer-Verlag, Berlin, 1999. [2] James Cheney \nand Ralf Hinze. A lightweight implementation of generics and dynamics. In Manuel M.T. Chakravarty, editor, \nProceedings of the 2002 ACM SIGPLAN Haskell Workshop, pages 90 104. ACM Press, October 2002. [3] Ralf \nHinze. A new approach to generic functional programming. In Thomas W. Reps, editor, Proceedings of the \n27th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (POPL 00), Boston, Massachusetts, \nJanuary 19-21, pages 119 132, January 2000. [4] Ralf Hinze. Polytypic values possess polykinded types. \nScience of Computer Programming, 43:129 159, 2002. [5] Ralf Hinze. Fun with phantom types. In Jeremy \nGibbons and Oege de Moor, editors, The Fun of Programming, pages 245 262. Palgrave Macmillan, 2003. ISBN \n1-4039-0772-2 hardback, ISBN 0-333-99285-7 paperback. [6] Ralf Hinze and Johan Jeuring. Generic Haskell: \nApplications. In Roland Backhouse and Jeremy Gibbons, editors, Generic Programming: Advanced Lectures, \nvolume 2793 of Lecture Notes in Computer Science. Springer-Verlag, 2003. [7] Ralf Hinze and Johan Jeuring. \nGeneric Haskell: Practice and theory. In Roland Backhouse and Jeremy Gibbons, editors, Generic Programming: \nAdvanced Lectures, volume 2793 of Lecture Notes in Computer Science. Springer-Verlag, 2003. [8] Ralf \nHinze, Johan Jeuring, and Andres L\u00a8oh. Type-indexed data types. Science of Computer Programming, 51:117 \n151, 2004. [9] Patrik Jansson and Johan Jeuring. PolyP a polytypic programming language extension. In \n Conference Record 24th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (POPL 97), \nParis, France, pages 470 482. ACM Press, January 1997. [10] Ralf L\u00a8ammel and Simon Peyton Jones. Scrap \nmore boilerplate: re.ection, zips, and generalised casts. In Kathleen Fisher, editor, Proceedings of \nthe 2004 International Conference on Functional Programming, Snowbird, Utah, September 19 22, 2004, September \n2004. [11] Simon Peyton Jones. Haskell 98 Language and Libraries. Cambridge University Press, 2003. [12] \nSimon Peyton Jones and Ralf L\u00a8ammel. Scrap your boilerplate: a practical approach to generic programming. \nIn Proceedings of the ACM SIGPLAN Workshop on Types in Language Design and Implementation (TLDI 2003), \nNew Orleans,January 2003. [13] Philip Wadler. A prettier printer. In Jeremy Gibbons and OegedeMoor, editors, \nThe Fun of Programming, Cornerstones of Computing, pages 223 243. Palgrave Macmillan Publishers Ltd, \nMarch 2003. [14] Stephanie Weirich. Higher-order intensional type analysis in type-erasure semantics. \nAvailable from http://www.cis.upenn.edu/~sweirich/papers/ erasure/erasure-paper-july03.pdf, 2003.  \n\t\t\t", "proc_id": "1016850", "abstract": "A generic function is a function that can be instantiated on many data types to obtain data type specific functionality. Examples of generic functions are the functions that can be derived in Haskell, such as <i>show</i>, <i>read</i>, and '=='. The recent years have seen a number of proposals that support the definition of generic functions. Some of the proposals define new languages, some define extensions to existing languages. As a common characteristic none of the proposals can be made to work within Haskell 98: they all require something extra, either a more sophisticated type system or an additional language construct. The purpose of this pearl is to show that one can, in fact, program generically within Haskell 98 obviating to some extent the need for fancy type systems or separate tools. Haskell's type classes are at the heart of this approach: they ensure that generic functions can be defined succinctly and, in particular, that they can be used painlessly.", "authors": [{"name": "Ralf Hinze", "author_profile_id": "81332504302", "affiliation": "Universit&#228;t Bonn, Bonn, Germany", "person_id": "PP43126402", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1016850.1016882", "year": "2004", "article_id": "1016882", "conference": "ICFP", "title": "Generics for the masses", "url": "http://dl.acm.org/citation.cfm?id=1016882"}