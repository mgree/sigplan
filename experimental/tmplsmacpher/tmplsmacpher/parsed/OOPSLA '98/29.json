{"article_publication_date": "10-01-1998", "fulltext": "\n 26 February 1999This paper replaces the preliminary version erroneously published in the OOPSLA '98 \nprint proceedings. Constraint-Based Polymorphism in Cecil: Towards a Practical and Static Type System \n Vassily Litvinov Department of Computer Science and Engineering University of Washington, Box 352350 \nSeattle, Washington 98195-2350 USA (+1-206) 543-3368 vass@cs.washington.edu Abstract We present a static \ntype system for object-oriented languages which strives to provide static typechecking without resorting \nto dynamic type casts, restricting what code the programmer can write, or being too verbose or dif.cult \nto use in practice. The type system supports bounded parametric polymorphism where the bounds on type \nvariables can be expressed using general recursive subtype or signature constraints, with F-bounded polymorphism \nand covariant type parameters being special cases. We implemented this type system in the Cecil language \nand used it to successfully typecheck a 100,000-line Cecil program, the Vortex optimizing compiler. Our \nexperience was very good: dynamically-typed code needed very little rewriting. We also observed several \ncommon programming situations that presented a challenge for our type system. We discuss these situations \nand ways to typecheck them statically. Keywords Language design, static type systems, F-bounded polymorphism, \nwhere clauses, type constraints, type inference, binary methods, Cecil.  1 Introduction Permission to \nmake digital or hard copies of all or part of this work for personal or classroom use is granted without \nfee provided that copies are not made or distributed for profit or commercial advantage, and that copies \nbear this notice and the full citation on the first page. To copy otherwise, to republish, to post on \nservers, or to redistribute to lists, requires prior specific permission and/or a fee. OOPSLA '98 10/98 \nVancouver, B.C.Copyright 1998 ACM 1-58113-005-8/98/0010 . . .$5.00 Static typechecking offers several \nadvantages to programmers, including early and possibly complete detection of some kinds of programming \nerrors, support for other static reasoning about programs by both people and machines, and potentially \neasier or more effective implementation. However, if the type system is too simple or restrictive, static \ntypechecking can require unnecessary duplication of code, force code to be written in unnatural styles, \nand disallow some useful programming constructions; the programmer is often forced to insert explicit \ntype casts to work around limitations in the type system, losing static checking and its bene.ts and \nincurring extra run-time cost if the casts are checked. If the type system is too verbose or unwieldy, \nthe high overhead of writing type annotations makes it more dif.cult to use in practice and harder to \nlearn. We are developing a type system for object-oriented languages whose goals are to provide the bene.ts \nof static typechecking, reduce as much as possible the associated problems of decreased .exibility and \nconvenience, and be useful in practice for large programs. Our type system has the following salient \ncharacteristics: it supports bounded parametric polymorphism;  the bounds on type parameters can be \nexpressed using a mixture of recursive isa and method constraints, supporting both F-bounded polymorphism \n[Canning et al. 89] and Theta-style where clauses [Day et al. 95, Liskov et al. 94] as special cases; \n the type system supports many advanced language features, including multi-methods, independent inheritance \nand subtyping, mutable and immutable state, and .rst-class functions;  it provides automatic inference \nof type parameters and syntactic sugars to increase convenience for practical use; and  it typechecks \ncode only once, not for each use or in each  subclass. We have implemented this type system in the Cecil \nlanguage [Chambers 92, Chambers 93a]. We have used it to successfully typecheck a 100,000-line Cecil \nprogram, the Vortex optimizing compiler system [Dean et al. 96]. One outcome of this experiment is a \ncollection of typechecking situations which we observed frequently throughout the program and which could \nnot be typechecked without at least some advanced features of the type system. We discuss some of these \nsituations and ways to typecheck them. Although the presentation is done in the context of a Cecil\u00adlike \nlanguage, similar issues arise in, and our results also apply to, other object-oriented languages, including \nProgram P ::= CD VD E Constrained-Decl CD::= CX : D Context CX::= forall a where C Constraint C ::= T1 \nisa T2 | method m [Tp](Ta):Tr Declaration D ::= ClassD | IsaD | MethD | FieldD Class Decl ClassD::= \nrole class c[a] Subclass Decl IsaD::= c1[T1] isa c2[T2] Method Decl MethD::= role method m[a](v:T):Tr \n{B} Field Decl FieldD::= .eld m[](v:T):Tr Role role ::= abstractopt Type T ::= c[T] | .(T):Tr | a Block \nB ::= VD E Var Decl VD ::= var v:T Expression E ::= v | v := E | new c[T] | m [Tp](Ea) | .(v:T):Tr { \nB } | apply(E. E) | E Variable v Class c Type Variable a Message m Notation: the vertical bar separates \nalternatives; the overbar, as in T, indicates a sequence of zero or more elements separated by commas \nor semicolons; the opt subscript indicates an optional construct. Square brackets, curly braces, and \nparentheses are among the literal tokens, as are boldfaced keywords. Figure 1: Syntax of Mini-Cecil In \nour code examples we sometimes use the following modifications to this syntax: omit empty constructs, \ne.g., empty type parameter lists [], contexts with no type variables, and empty sets of constraints; \n combine a class declaration and a subclass declaration, as in class Intisa Num;  combine a variable \ndeclaration and an assignment, as in var x:Int:=5;  write message sends with two arguments using the \ninfix notation, as in x+y;  to avoid repeating the same forall clause for a series of declarations, \nwe write it once and enclose the declarations in braces; this has the same semantics as writing the forall \nclause for each of these declaration.  we assume that an if expression, if E1 then E2 else E3, is defined. \nHowever, it could be programmed with lambda expressions. We write m[T](:T1 ,..., :Tn) . Tr to indicate \nthat a message send with arguments of given (static) types passes typechecker and its  result has type \nTr. To indicate that the send does not typecheck statically, we write TYPE ERROR for Tr. In some cases \nwe indent declarations of operations defined for a class solely to improve readability. Figure 2: Notational \nconventions Smalltalk [Goldberg &#38; Robson 83] and Java [Gosling et al. 96]. The next section of the \npaper presents informally our host language and the type system. Section 3 reports on our experiment \nand presents an evaluation of our type system. In particular, it contains a discussion of the programming \nsituations and how they could be typechecked. Section 4 compares our work to other type systems. Section \n5 discusses future work and concludes. Appendix A gives a more formal speci.cation of the type system. \nAppendix B speci.es the syntactic sugars discussed in Section 3.  2 Informal Description of the Type \nSystem This section describes informally our type system. We begin with a brief description of the host \nlanguage, then proceed to describe aspects of the type system, in increasing levels of sophistication. \nA more formal de.nition of our type system is given in Appendix A. We de.ne a simpli.ed version of Cecil, \ncalled Mini-Cecil, for use in presenting our type system and giving examples. For the purposes of clarity \nof presentation and to concentrate on the polymorphic aspects of our type system, we simplify the language \nsigni.cantly by omitting the features of Cecil that are orthogonal to our focus.1 Figures 1 and 2 specify \nthe syntax of Mini-Cecil and some conventions we follow. The reader unfamiliar with Cecil may wish to \nignore at .rst its parametric features: the type parameter lists [T] of classes and methods and the forall-where \nclauses of declarations, and return back to them as they are encountered in the text. 2.1 Monomorphic \nHost Language This subsection provides background by describing the monomorphic core of Mini-Cecil ignoring \nits polymorphic features; a version of this monomorphic language and the issues involved in typechecking \nit have been discussed previously [Chambers &#38; Leavens 94, Chambers &#38; Leavens 95]. A Mini-Cecil \nprogram is a collection of declarations followed by an expression to evaluate. The class c 1 Omitted \nfeatures include a classless object model, predicate objects [Chambers 93b], distinct objects vs. types, \ninheritance vs. subtyping, and specialized vs. unspecialized formals, initialized variable and field \ndeclarations, initialization of fields as part of object creation, immutable variables and fields, invocation \nof function objects via messages, nested declarations other than variables, modules and encapsulation, \nanalogues of Smalltalk s superand non-local return constructs [Goldberg &#38; Robson 83], and mixed dynamically \nand statically typed code. declaration introduces a new class named c which may be instantiated at run-time \nby new expressions; abstract classes are marked with the abstract keyword and may not be instantiated. \nThe subclass links are declared with the c1 isa c2 declarations (multiple superclasses are allowed). \nThe method and .eld declarations add methods and mutable instance variables to classes. The var v:T declaration \ndeclares a new mutable variable named v holding values of type T. The declarations may refer to each \nother; their order is insigni.cant. Mini-Cecil is based on multiple dispatching; multi\u00admethods generalize \nprocedures, singly-dispatched methods, and overloaded functions, and can resolve classic challenges such \nas the binary methods problem [Bruce et al. 95a]. The declaration method m(v1:c1, ..., vn:cn):Tr { B \n} declares a multi-method m which applies to instances of classes c1, ..., cn or their subclasses; classes \nc1, ..., cn are called method s specializers.2 Upon a message send at runtime, the selection of the method \nto be invoked is performed according to the following method lookup rule. First, all applicable methods \nwith the given name that are applicable to the actuals are collected. Second, the most speci.c of them \nis selected (method speci.city is determined by argument-wise subclassing between specializers3). If \nno method is applicable, a message not understood error is generated. If there is no single most speci.c \nmethod, it is an ambiguous method error (for example, if a class inherits con.icting methods from two \nsuperclasses and does not resolve the ambiguity explicitly). Method lookup is de.ned more formally in \n[Chambers &#38; Leavens 94]; we give a simple example at the end of this subsection. Field declarations \nintroduce new mutable instance variables, accessed solely through automatically generated get and set \naccessor methods. A .eld declaration .eld m(v:c):Tf declares a .eld m with contents of type Tf in the \nclass c and all its subclasses, and also introduces the get accessor method, method m(v:c):Tf, and the \nset accessor method, method set_m(v:c, new_value:Tf):Void (the type Voidindicates that the method returns \nno value). The get accessor returns the contents of the .eld m in object v and the set accessor updates \nthe contents to new_value. Accessor methods are treated the same as the user-de.ned methods by the method \nlookup rule. 2 The full rule states, in addition, that if a formal of a method has the form v:.(T1, ..., \nTn):Tresult , it applies to any function object .(v1:T1 ', ..., vn:Tn '):Tresult ' { B } with the same \nnumber of arguments. If a formal has the form v:a, its applicability is determined by the upper bound(s) \non a;if a is unbounded, it applies to all objects. (Upper bounds are determined by isa constraints, as \ndiscussed in Section 2.4.) 3 The specificity rule is different in some other OO languages, for example, \nCLOS. The choice of the particular rule is orthogonal to our type system work, and our results apply \nto languages with other choices as well. Mini-Cecil has standard expressions for variable reference v, \nassignment v := E, and statement sequencing E1; ...; En . The new-expression new c creates an instance \nof the class c. The message send expression m(E1,...,En) sends the m message to its n arguments. The \nlambda expression .(v1:T1,...,vn:Tn):Tr{B} creates a lexically-nested .rst-class function object with \nthe body B, taking n arguments named v1,...,vn of types T1,...,Tn and returning a value of type Tr. The \napply-expression apply(E.,E1,...,En) invokes its .rst argument, which must be a function object created \nby a lambda expression, passing in the remaining arguments. A function object is an instance of the corresponding \nprede.ned function class, .(T1,...,Tn):Tr. The example in Figure 3 illustrates these declarations and \nexpressions with a simple Point/ ColorPoint hierarchy and an equal_point multi-method. Since ColorPoint \nis a subclass of Point, instances of both classes can be intermixed as arguments when sending the equal_point \nmessage. Of the two equal_point methods, the one de.ned on ColorPoints is more speci.c. It applies and \nis invoked if both arguments of a message send are instances of ColorPoint at run-time; otherwise, the \nmethod de.ned on Points is invoked.  2.2 Typechecking the Monomorphic Core Classes and types are parallel \nin Mini-Cecil; subclasses are subtypes.4 In addition to de.ning a class, a class declaration also de.nes \na type, or abstract interface, with the same name as the class; all instances of the class conform to \nthis type. An isa declaration de.nes both inheritance of code and subtyping. Mini-Cecil provides subsumption, \ni.e., a value of a subtype can always be used where a value of a supertype is expected. Similarly to \nclass declarations, every declaration method m(v1:T1, ..., vn:Tn):Tr { B } (including .eld accessors) \nalso de.nes a method signature which is a guarantee that any send of message m to values of types T1, \n..., Tn will be successful, i.e., method lookup will always succeed. (The signature is said to cover \nsuch message send.) Moreover, the invoked method will return a value of type Tr , if it returns at all. \nMethods marked with the abstract keyword have their sole purpose to specify such signatures; this is \nuseful, for example, for specifying an operation on an abstract class which must be implemented by all \nof its non\u00adabstract subclasses. Abstract methods cannot be invoked at run-time, so their bodies will \nalways be empty. We will write method m(v1:T1, ..., vn:Tn):Tr omitting the body to indicate that the \ndeclaration is used to mean the method signature. While in a singly-dispatched language the interface \nof a class is determined by the methods it contains, in Mini-Cecil all 4 This simplification from the \nfull Cecil language does not lead to a significant loss in expressiveness, due to other advanced features \nof the language. class Point; field x(p:Point):Num; field y(p:Point):Num; method area(p:Point):Num { \n x(p) * y(p) } method equal_point(p1:Point, p2:Point):Bool { (x(p1) = x(p2)) and (y(p1) = y(p2)) } method \nnew_point(x0:Num, y0:Num):Point { var result:Point := new Point; set_x(result, x0); set_y(result, y0); \nresult } class ColorPoint isa Point; field color(p:ColorPoint):Color; --introduces xand set_xmethods \n--introduces yand set_ymethods --uses get accessors xand y --uses set accessors set_xand set_y --introduces \ncolorand set_colormethods method equal_point(p1:ColorPoint, p2:ColorPoint):Bool { (x(p1) = x(p2)) and \n(y(p1) = y(p2)) and (color(p1) = color(p2)) } method new_color_point(x0:Num, y0:Num, c0:Color):ColorPoint \n{ ... similar to new_point ... } Figure 3: A Point/ColorPointexample the method signatures in the program \ncollectively de.ne the interfaces of all the classes. Mini-Cecil de.nes the least-upper-bound and greatest\u00adlower-bound \ntypes, written lub(T1, ..., Tn) and glb(T1, ..., Tn), with the following standard semantics. The least \nupper bound of unrelated types is their supertype that is more precise than any of their common ancestors. \nThe greatest lower bound of unrelated types is their subtype that is more general than any of their common \ndescendants. For two types T1 and T2 such that T1 is a subtype of T2, lub(T1, T2)is T2 and glb(T1, T2)is \nT1. The least-upper\u00adbound types enhance the expressiveness of the type system by allowing type annotations \nto be more precise. For example, given unrelated subclasses of Num: Int, Float, and Rational, the type \nlub(Integer,Rational)is more speci.c than Numbecause it does not include Float. The greatest-lower-bound \ntypes are used in the formal rule for typechecking message sends (discussed below); they also increase \nthe expressiveness of the type system. For example, if the type of a variable is glb(Table,Sequence), \nit can hold values of any common subclasses of these two classes, such as Vector, that may be created \nin the future. Typechecking of the monomorphic core of Mini-Cecil divides into two components: client-side \ntypechecking and implementation-side typechecking. Client-side typechecking checks correctness of expressions \n( clients ) against the subclass declarations and method signatures. The following checks are performed. \nIn an assignment, the type of the right-hand side must be a subtype of the type of the variable being \nassigned. The type of the body of a method or a function object must be a subtype of its declared return \ntype. The type of a new c expression is c; the type of a function object .(v1:T1,...,vn:Tn):Tr{B}is .(T1,...,Tn):Tr. \nAn .(T1,...,Tn):Tr and the types of E1,...,En are subtypes of T1,...,Tn ; the type of the apply expression \nis Tr . The most interesting case is the message send, m(E1,...,En). Assume the arguments have types \nT1,...,Tn. The send expression is type-correct if there exists a method signature method m(T1',...,Tn'):Tr' \nthat covers this send, i.e., each of its Ti' is a supertype of the corresponding Ti . The type of the \nsend expression is the glb of the return types Tr' of all covering signatures. The use of glb types here \nallows us to avoid introducing restrictions such as requiring at most one covering signature. Implementation-side \ntypechecking veri.es that the method signatures and subclass declarations of the program are properly \nimplemented through non-abstract method and .eld declarations. A method signature method m(T1,...,Tn):Tr \nis properly implemented if for any non-abstract subclasses c1, ..., cn of classes T1, ..., Tn, the method \nlookup will successfully .nd the method to be invoked upon the message send m(c1,...,cn), that method \ns arguments are supertypes of T1, ..., Tn, and its result type is a subtype of Tr.5 (An ef.cient algorithm \nto achieve the effect of this enumeration-based speci.cation has been described previously [Chambers \n&#38; Leavens 94, Chambers &#38; Leavens 95].) Client-side typechecking and implementation-side typechecking \ntogether assure the overall type-safety of the program.  2.3 Polymorphic Declarations Parametric polymorphism \nis widely accepted in functional and OO programming and is important for .exible and static typechecking. \nIt allows the programmer to de.ne classes 5 The general rule states that for polymorphic signatures, \nwhere Ti may be a type variable, all legal instantiations (defined below) must be properly implemented. \napply(E.,E1,...,En) expression is type-correct if E. has type forall T: class RArray[T] --class RArrayis \nparameterized with T forall T: RArray[T] isa Collection[T] forall T: method fetch(a:RArray[T], index:Int):T \n{ ... } var my_array:RArray[Num] := new RArray[Num]; --explicit instantiation of class RArray var result:Num \n:= fetch(my_array, 5); --implicit instantiation of method fetch Figure 4: A read-only array example \nand methods that work the same way for a variety of types of their components. For example, indexing \nan array or computing its length can be done independently of the type of array elements. Printing a \ncollection by iterating over its elements and printing each of them does not require the knowledge of \nthe element type. Mini-Cecil supports parametric polymorphism by allowing any declaration (except for \nvariable declarations) to be parameterized with type variables.A forall a1,...,an pre.x introduces type \nvariables a1, ..., an in the declaration that it pre.xes, where they may be used as regular types. To \nuse a polymorphic declaration, it must be instantiated by providing instantiating types for each type \nvariable. Type variables are formals and instantiating types are actuals of a parameterized declaration. \nFigure 4 shows a read-only array class RArray which is parameterized with type variable Tintended to \ndenote the type of the array elements. In our code examples Tand S usually name type variables. A type \nparameter may be explicit if the corresponding instantiating type is to be explicitly provided by clients \nof the declaration, or implicit if it is to be inferred automatically by the typechecker. A polymorphic \nclass or method declaration speci.es which parameters are explicit by listing the corresponding type \nvariables in brackets following the name of the declared entity. For example, in Figure 4 the RArray \nclass is explicitly parameterized and requires all clients to provide instantiating types, as in RArray[Num]. \nMethod fetch, in contrast, is parameterized implicitly; in fetch(my_array,5) the instantiating type for \nTis inferred to be Num. Inference allows the programmer to avoid writing the often obvious instantiating \ntypes; it is a key feature of our type system. It is described in more details in Section 2.6.  2.4 \nBounded Polymorphism Parametric polymorphism is not expressive enough without the ability to impose restrictions \non instantiating types. A parameterized sorted tree should be instantiated only for elements whose type \nsupports a comparison operation. A matrix multiplication method may require that matrix elements be numbers, \nor at least support addition and multiplication. Mini-Cecil supports bounded polymorphism by allowing \nconstraints on type variables in the where clause of the forall pre.x. A constraint may state that one \ntype is a subtype of another (in particular, that one class is a subclass of another), or that a particular \nmethod is implemented for arguments of given types (in other words, that a certain method signature is \ndeclared or can be derived). We will call them isa and method constraints, respectively. Constraints \nrestrict how polymorphic declarations can be instantiated. An instantiation of a declaration is legal \nonly if the instantiated constraints in the declaration s where clause are satis.ed. This is described \nin more detail in Section 2.6; here we offer two simple examples. Figure 5 gives an example of an isa \nconstraint Tisa Printablethat speci.ed which instantiations of Collection are subclasses of Printable(and \nthus implement the print method), namely, the instantiations with Titself a subclass of Printable.6 Figure \n6 gives an alternative way to de.ne printable collections. The method constraint method print(T):Voiddeclares \nthat method printis de.ned only for collections whose elements de.ne it, too. The version based on the \nmethod constraint is more compact in this case because it avoids declaring explicitly which classes are \nsubclasses of Printable. In effect, method constraints express a kind of structural subtype relations \nwhich are inferred automatically based on the operations the types provide. Isa constraints require by\u00adname \nsubtyping, i.e., that the subclass relationship be declared explicitly by the programmer. This works \nbetter in situations when multiple operations are associated with one class, or when a class carries \nsome implied semantics which is not expressed directly by its operations (for example, bags which allow \nmultiple occurrences of an elements vs. sets which don t). Our type system does not limit the programmer \nto one approach; both kinds of constraints are supported equally. The constraints are part of the interface \nbetween the declaration and its clients; they allow the programmer to specify additional information \nabout the declaration s type variables. Constraints of a method declaration, for example, are used when \ntypechecking its body; constraints of an isa declaration specify which instances of the two classes are \nin the subclass relation. Each declaration is typechecked only once, under the assumptions given by its \nconstraints. When the declaration is used, i.e., instantiated, all that s necessary to check is that \nthe constraints are satis.ed. 6 Here Printable is an upper bound on type variable T.Ifa method s formal \nhas the form v:T, it applies to the same objects as T s upper bound, which in this case is Printable. \n abstract class Printable; abstract method print(p:Printable):Void; forall T: class Collection[T]; \nforall T where T isa Printable: Collection[T] isa Printable; forall T where T isa Printable: method \nprint(a:Collection[T]):Void { print(\"[\"); do(a, .(e:T){ print(e) }); print(\"]\") } String isa Printable; \n var my_coll:Collection[String];  --printmust be implemented by all non-abstract --subclasses of Printable \n--collections of printable things are themselves--printable; must implement print --doinvokes its function \nargument --on each element of the collection a --for example, Stringisa Printable --assuming it implements \nprint... print(my_coll); --... so it is legal to instantiate print(a:Collection[T]) --with Stringfor \nT Figure 5: An example of polymorphic declarations with an isa constraint forall T where method print(T):Void: \n method print(a:Collection[T]):Void { print(\"[\"); do(a, .(e:T){ print(e) }); --doinvokes its function \nargument print(\"]\") } --on each element of the collection a method print(a:String):Void { ... }  var \nmy_coll:Collection[String]; print(my_coll); --it is legal to instantiate print(a:Collection[T]) --with \nStringfor T because Stringimplements print Figure 6: An alternative way of defining printable collections, \nusing a method constraint 2.5 Recursive Constraints and F-bounded Polymorphism Sometimes in a situation \nlike Point/ColorPoint in Figure 3 one would like the two classes not be subtypes so that they are not \nintermixable as arguments to equal_point; still, inheritance of code between them is desired. The equal_point \nmethod in this situation is called a binary method. F-bounded quanti.cation [Canning et al. 89] offers \na way to typecheck this situation statically. To allow this solution to be expressed, Mini-Cecil provides \nrecursive constraints; the code is shown in Figure 7. The new helper classes, PointFand ColorPointF, \nnow have the code to be inherited (.elds xand yand method areain our example). These classes are parameterized \nand the constraints on their type variables are recursive: a type variable appears both on the left-hand \nside and as part of the right-hand side of an isa constraint. The peculiar way in which the Pointand \nColorPoint classes are de.ned as subclasses of PointF and ColorPointF is how F\u00adbounded quanti.cation \nensures statically that Points and ColorPoints are not intermixable as arguments to equal_point. Binary \nmethods and F-bounded quanti.cation occur frequently in Vortex code. In Section 3 we consider them again, \ngive a larger example, and propose a simpler notation.  2.6 Constraint Solving and Type Inference Method \nand isa constraints and inference of instantiating types are essential for the expressive power of Mini-Cecil \ns type system. This subsection describes informally how constraints are solved and how inference is performed \nas part of constraint solving; the formal de.nition is given in Appendix A. Constraint solving arises \nin the following situations. To typecheck a message send m[T1 ',...,Tm '](E1,...,En) where T1,...,Tn \nare the types of E1,...,En, the method constraint method m[T1 ',...,Tm '] (T1,...,Tnis solved. is a fresh \ntype ):Tresult Here Tresult variable and can be instantiated with some type. The type of the message \nsend is the most speci.c type that Tresult can take on while the method constraint can still be solved. \nTo check that S1 is a subtype of S2, the isa constraint S1 isa S2 is solved. Finally, whenever a declaration \nwith a where clause is instantiated, the instantiated constraints from its where clause must be solved. \nGiven a set-to-be-solved of constraints (initially one constraint, as just described), solving them is \nperformed according to the following rules. One constraint at a time is forall Pt where Pt isa PointF[Pt]: \n{ class PointF[Pt]; field x(p:PointF[Pt]):Num; field y(p:PointF[Pt]):Num;  method area(p:PointF[Pt]):Num \n{ x(p) * y(p) } method equal_point(p1:PointF[Pt], p2:PointF[Pt]):Bool { (x(p1) = x(p2)) and (y(p1) = \ny(p2)) } } class Point isa PointF[Point];  forall CPt where CPt isa ColorPointF[CPt]: { class ColorPointF[CPt] \nisa PointF[CPt]; field color(p:ColorPointF[CPt]):Color; method equal_point(p1:ColorPointF[CPt], p2:ColorPointF[CPt]):Bool \n{ (x(p1) = x(p2)) and (y(p1) = y(p2)) and (color(p1) = color(p2)) } } class ColorPoint isa ColorPointF[ColorPoint]; \narea(:Point). Num equal_point(:Point,:Point). Bool area(:ColorPoint). Num equal_point(:Point,:ColorPoint). \nTYPE ERROR Figure 7: An alternative Point/ColorPointexample with Points and ColorPoints not intermixable \nas arguments to equal_point picked and removed from the set-to-be-solved.A matching constraint is produced \nfrom the program declarations, if possible, otherwise constraint solving fails. Two constraints match \nif they have the same structure (e.g., both are method constraints for the same message name and number \nof arguments) and the types in the corresponding positions are the same; fresh type variables may be \ninstantiated with types during matching. While producing the matching constraint, new constraints to \nbe solved may arise, in which case they are added to the set-to-be-solved. Constraint solving succeeds \nwhen the set-to-be-solved becomes empty. The matching constraint can be produced either by taking a constraint \nor declaration available in the program, or by combining other constraints produced from the program \ndeclarations. More speci.cally, A polymorphic isa or method declaration present in the program can be \ninstantiated by substituting types or fresh type variables for the type variables in its forall clause; \nthe constraints in its where clause, if any, need to be solved. A special case, a declaration with an \nempty forall clause, is treated as an available constraint itself. (The bodies of method declarations \nare ignored when producing constraints.)  When typechecking the body of a polymorphic declaration, the \nconstraints in its where clause are available.  7 Here we assume that constraints are picked non-deterministically. \nTo achieve this effect, the deterministic typechecker may need to perform some search. Constraints can \nbe combined based on the standard properties of subtyping, such as transitivity, and of method signatures, \nsuch as contravariance. For example, if the program contains declarations method =(Num,Num):Booland Intisa \nNum, they can be combined to yield the available constraint method =(Int,Num):Bool. Matching of types \nand substitutions of types for fresh type variables is performed as needed. Inference of instantiating \ntypes is the part of constraint solving whereby the typechecker decides how to instantiate declarations, \ni.e., what types to substitute for type variables. Intuitively, when typechecking a message send, the \ntypechecker tries to .nd the best instantiations of declarations involved in solving the method constraint, \ni.e., the instantiations that lead to the most precise result type. When checking whether a type is a \nsubtype of another, the typechecker only needs to prove that some appropriate instantiations exist. Consider, \nfor example, typechecking the message send print(my_coll) in Figure 5, where my_coll has type Collection[String]. \nTo check this send, the typechecker needs to solve the constraint method print(Collection[String]):Tresult \nwhere Tresult is a fresh type variable; this is the .rst constraint in the set-to-be\u00adsolved. A matching \nconstraint can be produced by instantiating the declaration forall T... method print (Collection[T]):Void... \nTwo substitutions need to take place to achieve matching: Voidfor Tresult and Stringfor T. Also, the \ndeclaration s instantiated isa constraint Stringisa Printable is added to the set-to-be-solved. This \ntime, the program already contains an exactly matching declaration. No more constraints are added to \nthe set-to-be\u00adsolved, so constraint solving is complete. The instantiating type String was automatically \ninferred for the type variable Tof the polymorphic method declaration. This is by no means a description \nof a deterministic algorithm. We have implemented a prototype typechecker which aims at computing a conservative \napproximation to the formal rules presented in this paper, that is, it may report an error in some cases \nwhich are type-correct according to the rules (this doesn t happen in the Vortex code, however). Our \nfuture work includes formalizing a decidable approximation to our type system (currently we are uncertain \nwhether typechecking is decidable). Discussion of the deterministic typechecking algorithm is beyond \nthe scope of this paper.  3 Evaluation of the Type System We have implemented our type system in the \nCecil language. We gained practical experience using the type system and evaluated it by applying it \nto the Vortex optimizing compiler, a 100,000-line Cecil program which includes the typechecker. The next \nsubsection reports on this experiment and offers some general observations. One outcome of our experiment \nis a set of typechecking situations which we observed frequently throughout the program and which could \nnot be typechecked without at least some advanced features of our type system. Sections 3.2 to 3.9 discuss \nsuch common situations related to parameterization and recursively-de.ned types. The goal of this discussion \nis two-fold: We hope this collection of situations will offer a point of comparison for expressiveness \nof type systems. For example, it may be helpful for evaluating various proposals for introducing genericity \nin Java. Most of these situations have been discussed before; here we bring them together.  Taken together, \nthese situations present a challenge for existing type systems. We offer solutions based on Mini-Cecil, \nsometimes as alternatives or extensions to solutions known before which we .nd unsatisfactory or insuf.cient \nfor large evolving programs.  3.1 Experimental Methodology and General Observations Vortex was originally \ndeveloped with only dynamic typechecking; static type declarations were optional and unchecked, although \ndevelopers were informally encouraged to write code that would potentially typecheck statically. In our \nexperiment, we .rst ensured that all variables and interfaces had declared types, and then ran our typechecker. \nOf course, several thousand static type errors were reported in the .rst run, and we spent roughly a \nperson\u00admonth of half-time effort in adjusting the type declarations. Very little code (other than type \ndeclarations) needed to be rewritten. Client-side typechecking is reasonably fast, taking about 7.5 minutes \nto typecheck all of Vortex on an UltraSPARC-1/170 workstation (that is about 240 lines/sec). Our implementation-side \ntypechecker is missing several important but known optimizations [Chambers &#38; Leavens 94, Chambers \n&#38; Leavens 95] and so is slow. Because Vortex had already been heavily tested, the typechecker only \nidenti.ed few bugs in the program. It did point out some suspect code that could break after some otherwise \nlegal and desirable future program evolution. For a new interprocedural analysis framework implemented \nafter the typechecker was stable and available to other Vortex developers, the typechecker discovered \nmany errors statically and assisted in carefully reasoning about the interfaces, all prior to de.ning \nany instantiations of the framework and running the code. Since then, the typechecker has been run routinely \nby some Vortex developers. Their experience is that after the code passes the typechecker, it usually \nworks, whereas without static typechecking, several bugs would typically surface during the .rst few \nruns of newly written code. Very few cases did not typecheck statically. In 65,322 static occurrences \nof the message send expression and 6,834 static variable assignments, 579 static type errors remained; \ndynamic typechecking is used in these cases. We believe that if the same code were written in another \nlanguage, such as Java or C++, type casts would have to be used signi.cantly more often. Parameterization \nhas been a common practice in our code. Out of 1,654 classes in Vortex, 210 classes have 1 type parameter, \n48 classes have 2, 6 classes have 3, and 2 classes have 4 type parameters. Vortex includes 1,963 isa \ndeclarations, 385 of which are polymorphic, and 14,635 method declarations, 2,444 of which are polymorphic. \nLeast-upper-bound and greatest-lower-bound types occur 250 and 85 times, respectively, in the source \ncode; more arise as part of constraint solving. We feel that the semantics offered by parameterization, \nF-bounded quanti.cation, and method constraints is often desirable. In the remainder of this section \nwe show how well these features work in several common but challenging programming situations. Having \nadopted these features, however, we encountered a further problem: the straightforward notation for them \nis too verbose for rich class hierarchies and is dif.cult to maintain during program evolution. Inference \nof instantiating types greatly helps in some cases but not others. The solution we propose is to use \nsyntactic sugars, without resorting to a different semantics such as matching [Bruce et al. 97] or virtual \ntypes [Madsen &#38; M\u00f8ller-Pedersen 89]. The remainder of this section describes these situations and \nour solutions. In our presentation we attempt to highlight what needs to be handled by a practical type \n classes class inheritance mutually-recursive subtype and with classes inheritance relation fields \nrelation  Figure 8: Keys to graphics for typechecking situations class MethodNode[ T defaults_to MethodDecl]; \nfield decl(n:MethodNode[ T]):T; class FieldAccessorNode[ T defaults_to FieldDecl]; FieldAccessorNode[ \nT] isa MethodNode[T] decl(:MethodNode). MethodDecl --default values of Tare used decl(:FieldAccessorNode). \nFieldDecl Figure 9: Narrowing type of field in a subclass system, in a way independent of a particular \nsystem or language. We give a verbal description and example code written in Mini-Cecil; the syntactic \nsugars are introduced informally here and more formally in Appendix B. The symbols used in pictorial \nrepresentations of the situations are listed in Figure 8.  3.2 Narrowing the Field Type in a Subclass \nConsider a subclass that needs to narrow the type of a .eld it inherits from a superclass. For example, \na compiler for Mini-Cecil may de.ne a MethodNode class to represent methods internally; it may have a \ndecl .eld that points to the corresponding method declaration of class MethodDecl. A subclass FieldAccessorNode \nof MethodNode would represent .eld accessor methods and have its decl .eld point to a FieldDecl, a subclass \nof MethodDecl (Figure 9). The problem here is that if the .eld is mutable, FieldAccessorNode is no longer \na subtype of MethodNode. However, we still would like the subclass to inherit the code from the superclass. \nThe solution that we adopt is to parameterize the classes MethodNodeand FieldAccessorNode by the type \nof their decl.eld (this solution was proposed, for example, in [Graver 89]). Now, FieldAccessorNodeis \na subtype of MethodNode, provided they are instantiated with the same type. It turns out that this solution \ndoes not work well for evolving programs: adding a type parameter to MethodNode causes proliferation \nof instantiation type annotations throughout existing code, which is undesirable. To address this problem \nwe suggest specifying the default instantiating type in the class (or another parameterized) declaration. \nThe type speci.ed in the defaults_to clause will be used as the instantiating type whenever the latter \nis omitted in a reference to a class. Figure 9 also illustrates another syntactic convenience. Instead \nof introducing a type variable in the forall clause, this syntactic sugar allows us to just use it in \nthe declaration, provided it is preceded with a backquote. Another solution may be to separate inheritance \nfrom subtyping, so that FieldAccessorNodeis not a subtype of MethodNode. In this case, however, some \nother relation between inheriting classes needs to be maintained to ensure that the code is type-correct \nwhen inherited (for example, matching in LOOM [Bruce et al. 97]). Our solution does not require introducing \nyet another relation between classes.  3.3 Binary Methods Consider an operation that takes two arguments \nwhich both must be of the same class. When such operation is inherited by a subclass, it takes two arguments \nof that subclass; two different subclasses are not allowed to be intermixed as arguments to the operation. \nFor example, consider the class Ordered de.ning a greater-than operation, >, with two subclasses, Num \nand String, so that > is allowed to be invokedontwo Numsortwo Strings, butnota Numand a String. Such \noperations are called binary methods [Bruce et al. 95a] and were part of the motivation for F-bounded \npolymorphism [Canning et al. 89]. It is also desirable to allow the class Num to have subclasses, e.g., \nInt and Float, which are intermixable as arguments to >.Yet another desirable capability is for the class \nOrdered to inherit methods from a superclass, e.g., method != from class Comparable, which, in turn, \nmay have other non\u00adintermixable subclasses (for example, classes providing the equality operation, =, \nbut not >); see Figure 10. We have seen a binary method earlier: the equal_point method in the Point/ColorPoint \nexample in Figure 7. The F-bounded solution described there requires a somewhat involved and verbose \nnotation which has been the main argument against F-bounded polymorphism; we propose syntactic sugars \nas a solution. First, we introduce the notion of a framework. A class declared with the framework keyword, \ne.g., Ordered, will be given a type parameter in the desugaring; the code will look similar to that for \nColorPointFin Figure 7. We will say that the non-intermixable subclasses of a framework  abstract framework \nComparable; abstract method =(x:$Comparable, y:$Comparable):Bool; method !=(x:$Comparable, y:$Comparable):Bool \n{ not(x = y) } abstract framework Ordered narrows Comparable; abstract method >(x:$Ordered, y:$Ordered):Bool; \nclass Num instantiates Ordered; method >(x:Num, y:Num):Bool { ... } --also implements = class Int isa \nNum; --Numhas subclasses class Float isa Num; class String instantiates Ordered; method >(x:String, \ny:String):Bool { ... } --also implements = !=(:Int,:Float). Bool --works similarly for =or > !=(:String,:String). \nBool !=(:String,:Int). TYPE ERROR Figure 10: Binary methods class instantiate it; they are declared with \nthe instantiates keyword. The ColorPoint class in Figure 7 would instantiate the ColorPointF framework. \nFinally, binary methods can be inherited by a framework which is declared to narrow another framework \nwith the keyword narrow. The ColorPointF framework in Figure 7 would narrow the PointF framework. The \ndifference between ordinary and framework classes is that frameworks declare binary and other methods \nwhich can be inherited by their non\u00adintermixable instantiations, such as Numand String, while methods \nde.ned on an ordinary class are not binary, as they will accept all subclasses, such as Int and Float,in \nany combination. To allow convenient references to frameworks we introduce the $ syntactic sugar as follows. \nWhen a framework s name preceded by $ occurs in a declaration, that framework s F-bounding forall...where \nclause is added to the declaration, and the framework s name is replaced in the desugaring with the corresponding \nF-bounded type variable. For example, the declarations of abstract framework Comparable and method = \nin Figure 10 would be desugared into: forall T isa Comparable[T]: abstract class Comparable[T]; forall \nT isa Comparable[T]: abstract method =(x:T,y:T):Bool;8 In Vortex, 30 classes are framework-style; 21 \nof them are narrowings of others. The framework classes have 179 immediate instantiating classes; 62 \nof them have no subclasses, while the subclasses (including indirect or conditional subclasses) of the \nothers make up about 2/3 of all classes in Vortex. There are 30 binary methods in Vortex. 8 Here Comparable[T] \nis an upper bound of T, so both formals of the method are applicable to instances of any subclasses of \nComparable. Even though the framework and narrows keywords desugar into class and isa declarations, they \ncould be seen as introducing a new relation between classes. Because of the complexity and verbosity \nof the desugaring, we believe that introducing these sugars is desirable.  3.4 Max-like Methods Consider \nan instantiation of a framework with a rich hierarchy of subclasses; the framework de.nes a method such \nthat the more precise the argument types, the more precise the method s result type is expected. We want \nto de.ne this method once for the framework and then inherit it through sub-frameworks and their instantiations. \nFor example, we may want to de.ne method max for the Ordered framework and then apply it to all subclasses \nof Num, an instantiation of Ordered; applying max to two Floats (or its subclasses) should give us back \na Float (Figure 11). There are 45 max-like methods in Vortex, including .elds whose types are narrowed \nin subclasses. The problem here is that F-bounded polymorphism would tell us that the result type of \nsuch application is Num, which is less precise than Float. We propose to make the parameters of frameworks \ncontravariant by providing the following declaration in the desugaring: forall T1,T2 where T1 isa T2 \n: Ordered[T2] isa Ordered[T1]; The reader is invited to verify that with this declaration, the desugared \nmethod max can be instantiated with Float for $Ordered, and that without it such instantiation would \nbe illegal. Vortex has 6 framework classes with a contravariant type parameter.  3.5 Frameworks as Ordinary \nClasses In some cases it is desired to use a class with binary methods, declared as a framework, as a \nusual non-abstract class without instantiating it as we have done in the previous situations. For example, \nin Figure 7 we would like to avoid using the helper classes introduced in addition to Point/  abstract \nframework Ordered; abstract method >(x:$Ordered, y:$Ordered):Bool; method max(x:$Ordered, y:$Ordered):$Ordered \n{ if x>y then x else y } class Num instantiates Ordered; method >(x:Num, y:Num):Bool { ... } class Int \nisa Num; class Float isa Num; class Single_Float isa Float; class Double_Float isa Float; max(:Int,:Int). \nInt max(:Single_Float,:Double_Float). Float Figure 11: Max-like methods framework List; field next(l:$List):$List; \n--this field will be narrowed in subtypes --use Listas an ordinary class field data(l:List):SomeType; \nvar my_List:List := new List; ... class GreenList isa List; my_List := new GreenList; --OK since Greenlistis \na subclass framework DLList narrows List; field prev(dl:$DLList):$DLList; var my_DLList:DLList := new \nDLList; my_List := my_DLList; --static TYPE ERROR  Figure 12: Using frameworks as ordinary classes ColorPoint. \nSimilarly, we would like to have a linked List class and a doubly-linked list class, DLList, so that \nthe type of the nextpointer is more speci.c in the DLList class. This situation is similar to binary \nmethods (in particular, DLLists cannot be mixed with Lists), so the two classes can be declared as frameworks \n(Figure 12). To enable using List and DLList as usual classes, we propose to take their .xpoints, similar \nto recursive types in [Canning et al. 89]. We write a .xpoint as class List[$List defaults_to List] to \nindicate that a reference to List without an explicit instantiating type causes the instantiating type \nto be List(again, the .xpoint). We do not explore .xpoints/recursive types here; they are discussed, \nfor example, in [Amadio &#38; Cardelli 91]. Note that we would still like to have subclasses of List(such \nas GreenList)or DLList that are freely mixable as arguments to methods (e.g., the set accessor set_nextfor \n.eld next). Our approach requires some changes in the existing code when Listacquires a sub-framework \nDLListif that had not been anticipated. Type substitution in [Palsberg &#38; Schwartzbach 90, Palsberg \n&#38; Schwartzbach 94] achieves this automatically in simple cases. However, it may modify type annotations \nthat the programmer did not intend to and which may be hard to .nd.  3.6 Mutually-recursive Families \nof Classes Consider several classes mutually referring to each other. Moreover, they need to be narrowed \nin parallel, creating an inheriting family of mutually-referential classes. Also, the classes of the \ninheriting family cannot be mixed with the classes of their parent family as arguments to methods. In \nother words, the frameworks, their sub-frameworks and instantiations may consist of several classes, \nnot just one. The situations discussed above also need to be handled in any combination. The Subject-Observer \ndesign pattern [Gamma et al. 95] is one example where this is desired (Figure 13). In Vortex, 2 classes \nform a mutually-referential family; since our experiment, such families have been used more often. We \npropose to generalize the solutions described above correspondingly, to allow frameworks with multiple \nclasses. The desugaring rules presented in Appendix B re.ect this.  3.7 Covariance of Classes with Read-only \nAccess to Their Components Often it is desirable to use a collection class without knowing precisely \nthe type of its elements and assuming a less precise element type instead. This is safe if the access \nis read-only, i.e., the elements are only retrieved, not stored. For example, an array of Floats can \nbe read as an array of Nums; an immutable pair of a string and a character list can be used as  class \nEvent; --for simplicity assume all events are of this class framework Subject, Observer; field observers(s:$Subject):Array[$Observer]; \nmethod notify(o:$Observer,s:$Subject,e:Event):Void {...} method notifyObservers(s:$Subject,e:Event):Void \n{ --doiterates over elements of observers(s) do(observers(s), .(e:$Observer){ notify(o,s,e) }) } framework \nWindowSubject, WindowObserver narrows Subject, Observer; notify(:Observer,:Subject,:Event). Void notify(:WindowObserver,:WindowSubject,:Event). \nVoid notify(:Observer,:WindowSubject,:Event). TYPE ERROR observers(:WindowSubject). Array[WindowObserver] \nFigure 13: Mutually-recursive classes a pair of collections. To handle this, the immutable collection \nclass is usually declared covariant in the type(s) of its components. In Vortex, 25 classes have a covariant \ntype parameter. (Languages such as Java or Eiffel apply this approach to mutable collections, which is \nstatically unsound and requires runtime checks.) Covariant type parameters can be easily expressed in \nMini-Cecil with a constrained isa declaration, as in the following example (which refers to the RArray \nclass de.ned in Figure 4): forall T,S where T isa S: RArray[T] isa RArray[S]; var a:RArray[Num] := (1, \n2, 3); --OK  3.8 Conditional Subtyping In some cases, not all instantiations of a parameterized class \nare subtypes of another class. For example, in Figure 5 we de.ned a class Printablewhose subtypes are \nallowed as arguments to method print. Given a collection, it is a subtype of Printableonly if its elements \nare subtypes of Printable themselves. This situation can be easily expressed in Mini-Cecil with a constrained \nisa declaration: forall T where T isa Printable: Collection[T] isa Printable; print(:Collection[String]). \nVoid print(:Collection[NonPrintable]). TYPE ERROR 3.9 Structural vs. By-name Subtyping Structural and \nby-name subtyping are useful in different programming situations. By-name subtyping, which requires that \nthe subtype relation be declared by the programmer, is more appropriate, for example, when the class \nname carries some implied semantics which is not expressed directly by its operations. Consider two classes, \npartially_orderedand totally_ordered, which both have a >=method; if >=(x,y) is false, we can infer that \n<(y,x) is true only if both arguments are of a subclass of totally_ordered. By-name subtyping, e.g., \nreferred to in an isa constraint Tisa partially_ordered, allows the programmer to express this (implicit) \nsemantics, whereas structural subtyping, e.g., in the method constraint method >=(T,T):Bool, does not. \nStructural subtyping, which is inferred by the typechecker based on the operations provided by the types, \nis convenient when the name(s) of operation(s) are assumed to convey semantics unambiguously. Consider \na pretty\u00adprinting method on collections, say, forall Elm where -- ?? method collection_pp (c:Collection[Elm]):Void \n{ ... } which invokes the pretty_print method on each collection element. To typecheck the collection_pp \nmethod, it is suf.cient to specify the structural constraint method pretty_print(Elm):Void in its where \nclause; there is no need to de.ne a new pretty_printableclass as would be necessary for the by-name constraint \nElmisa pretty_printable. Also, structural subtyping works better for evolving programs. When the collection_ppmethod \nis written, there is no need to add new subclass declarations for the classes (to be used as collection \nelements) that de.ne already (or will de.ne in the future) the pretty_print method. Such subclass declarations \nwould be necessary under the by-name subtyping style. Structural constraints are also convenient to express \na certain kind of relation between types. Consider the following simpli.ed example: forall Src,Dest where \nSrc isa IntCollection, method copy_empty_mutable(Src):Dest : method copy(src:Src):Dest { var dest:Dest \n := copy_empty_mutable(src); ... add all elements of srcto dest... ... (here we need destto be mutable) \n... dest } The type of the method s result is de.ned as the result of invoking copy_empty_mutable on \nthe method s argument. Here copy_empty_mutable takes an integer collection and creates an empty mutable \ncollection of a similar kind; its result has a different type, for example, if the argument is an immutable \ncollection. This relation between the argument and result types of copyis naturally described with a \nmethod constraint; expressing it with isa constraints would be rather tedious. In Vortex code method \nconstraints were used much less often than isa constraints: in 3,095 polymorphic class, isa, and method \ndeclarations there were 714 isa constraints, including 613 F-bounding constraints, and only 17 method \nconstraints (all 17 in method declarations). We believe that this happened partially because isa constraints \nwere introduced in Cecil much earlier and they are more concise under the current syntax. Method constraints \nhave been used more often since our experiment.  4 Related Work This section discusses related polymorphic \ntype systems and alternative ways to address the situations described in Section 3. For space reasons, \nthis discussion is concise; a more detailed comparison appears in [Litvinov &#38; Chambers 98]. As a \ngeneral comment, we have focused on expressiveness and convenience of our type system, whereas most of \nthe work discussed here includes proofs of soundness and/or decidability of typechecking. Analysis of \nthese important properties is one direction of our future work. We start with languages based on F-bounded \npolymorphism. Pizza, an extension to Java, provides an analogue of Mini-Cecil s isa constraint on polymorphic \nclass and method declarations and performs inference of instantiating parameters [Odersky &#38; Wadler \n97]. Agesen, Freund, and Mitchell propose a similar extension to Java which also offers parameterization \nof a class by its superclass [Agesen et al. 97]; we don t provide this feature. Neither system provides \nmethod constraints or allows covariant type parameters or conditional subtyping which we argued are important. \nBoth systems are likely to face the verbosity problems discussed in Sections 3 when used to achieve static \ntypechecking of rich class hierarchies. Haskell s type classes can be viewed as a kind of F-bounded polymorphism \n[Wadler &#38; Blott 89]. Haskell performs type inference which makes using the type system less burdensome. \nHowever, it does not provide subtype polymorphism; for example, it disallows lists of mixed integers \nand .oats. ML= is a powerful polymorphic object\u00adoriented language supporting multi-methods and, contrary \nto our system, parameterization over uninstantiated polymorphic classes [Bourdoncle &#38; Merz 97]. It \nseparates classes into independent sets (called constructor classes ) with all classes in such a set \nhaving the same number of type parameters and same co-/contra-variance property of each parameter; no \nsubtyping is possible between two classes from different sets. The expressiveness of such type system \nis quite limited. Some languages provide only restricted forms of F\u00adbounded polymorphism. In TOOPLE [Bruce \net al. 93] and Strongtalk [Bracha &#38; Griswold 93], a special type SelfType is de.ned automatically \nby the system and is used for argument or result types of binary methods. PolyTOIL [Bruce et al. 95b] \nand LOOM [Bruce et al. 97] provide a similar facility but are based on matching. These systems provide \nconvenient support for writing frameworks but do not allow narrowing frameworks and instantiating frameworks \nwith mixable subclasses (as in examples in Section 3.3) in the same framework hierarchy; they provide \nno support for mutually-recursive families of classes. A proposal for an extension to Pizza by Bruce, \nOdersky, and Wadler [Bruce et al. 98] provides a convenient way to handle some situations in Section \n3 including mutually-recursive families but not covariant type parameters or max-like methods. However, \nlike LOOM, it relies on exact types for part of its expressiveness, which disallows subtype polymorphism \nand thus limits extensibility of programs. Theta [Day et al. 95, Liskov et al. 94] and the similar proposed \nextension to Java [Myers et al. 97] support method signature constraints called where clauses, but don \nt support isa constraints, covariant type parameters, or conditional subtyping. Strongtalk is based on \nstructural subtyping, i.e., subtyping between protocol types which are collections of signatures and \ncan be viewed equivalent to signature constraints; it does not provide constrained polymorphism. Strongtalk \nachieves the effect of by-name subtyping by using brands; a later version of Strongtalk appears to drop \nstructural subtyping and brands in favor of explicit by-name subtyping [Bracha 96]. Structural and by\u00adname \nsubtyping are both valuable and are provided in Mini-Cecil. Recursively constrained types [Eifrig et \nal. 95] are based on structural subtyping. In contrast to our system, the constraints are inferred automatically \nand thus may be more precise and more .exible than programmer-de.ned constraints. Their approach is to \ncheck that the system of constraints for the program is consistent, rather than .nding solutions to them; \nif they are not consistent, it is dif.cult to narrow the problem to particular expressions that are not \ntype-correct. In C++ [Stroustrup 91] and Modula-3 [SRC] constraints on type parameters cannot be speci.ed. \nInstead, parameterized declarations are checked at each instantiation. This results in great .exibility \nand simplicity in writing and using parameterized declarations, but loses the often useful ability to \ncheck declarations separately from their clients and to document, in a machine-checkable way, the assumptions \nabout the declarations parameters. Eiffel [Meyer 92] supports covariant overriding of methods and .elds \nin subclasses and parameterized classes with parameters automatically considered covariant. Beta [Madsen \n&#38; M\u00f8ller-Pedersen 89, Madsen et al. 93] provides a similar mechanism with virtual types; an extension \nto Java with virtual types has also been proposed [Thorup 97]. These languages provide very convenient \nnotation for the situations discussed in Section 3, but give up on static checking; Beta and the extension \nto Java provide run-time checks instead. Virtual types require creation of a subclass in place of instantiation \nof a polymorphic declaration in a language with type parameters; this seems to be an unnecessary burden \non the programmer. Torgersen achieves static typechecking for virtual types [Torgersen 98]. His code \nto express the typechecking situations in Section 3 looks quite similar to ours. He also notes the need \nfor syntactic sugars to make code more concise in case of large class hierarchies. The recent work on \nlocal type inference in an extension of F= [Pierce &#38; Turner 98], especially the local type argument \nsynthesis, is very similar to our inference of instantiating types: they address a similar problem and \nuse a similar inference algorithm. Their setting is different from ours: they work within an impredicative \ntype system whereas ours is essentially predicative. In contrast with their system, we handle F-bounded \nquanti.cation, signature constraints, by-name subtyping, and overloading (with multiple dispatch). An \nearlier work on type inference in F= [Cardelli 93] presents a faster algorithm which is more restrictive \nin some cases due to asymmetric treatment of method arguments. 5 Conclusions and Future Work We have \ndeveloped a polymorphic type system that uses systems of mutually recursive subtype and signature constraints \nto limit allowed type parameters. The type system supports this constrained polymorphism uniformly for \nall declarations in the system (except for variable declarations). This powerful, orthogonal treatment \nof polymorphism enables our type system to subsume F\u00adbounded quanti.cation and Theta-style whereclauses, \nand to provide other desirable features, like covariant or contravariant type parameters of polymorphic \ndeclarations or conditional subtyping. Our type system supports other advanced features such as multi-methods \nand function objects. We implemented this type system as part of the Cecil language, and used it to statically \ntypecheck a 100,00-line Cecil program, the Vortex optimizing compiler system originally developed under \na dynamically typed regime. Our experience with this type system has been very good: code has needed \nlittle or no rewriting to adapt to the requirements of the type system. We encountered many situations \nin Vortex which required the advanced features of the type system to statically check successfully; these \nexperiences with real code rather than toy examples provide empirical justi.cation for the relative complexity \nof our approach. We presented several challenging typechecking situations which occurred frequently in \nour code and so needed to be supported by the type system; we also offered solutions to these situations. \nWe hope this discussion and our other results will be helpful for designers of other languages, for example, \nJava. Our type system is not a completed work, but rather an ongoing project. We are planning to extend \nthe language and type system with the syntactic sugars proposed in Section 3. We are working on a proof \nof type soundness which is not expected to be problematic. We have not addressed the issues of data hiding \nand separate typechecking which are challenging in the presence of multi-methods and other advanced language \nfeatures; a solution in the context of a monomorphic subset of Cecil has been offered, for example, in \n[Chambers &#38; Leavens 94, Chambers &#38; Leavens 95]. Finding an ef.cient yet powerful deterministic \ntypechecking algorithm is another challenge. We are looking for ways to provide a conservative but decidable \napproximation for our type system, possibly including some restrictions on type constraints of polymorphic \ndeclarations. Our positive empirical experience using the type system strongly suggests that this point \nin the type system design space is worth pursuing. Acknowledgments We thank other members of the Cecil \nresearch project for their help in evaluating this and previous designs for Cecil s polymorphic type \nsystem. Craig Chambers made Vortex typecheck, observed the typechecking situations and offered solutions. \nDave Grove, Mike Ernst and Jonathan Aldrich provided feedback on earlier versions of this paper. We thank \nthe anonymous referees for comments which helped improve the presentation of the paper and for bringing \nto our attention the work on local type inference. This research is supported in part by an NSF grant \n(number CCR-9503741), an NSF Young Investigator Award (number CCR-9457767), and gifts from Sun Microsystems, \nIBM, Xerox PARC, Object Technology International, Edison Design Group, and Pure Software. References \n[Agesen et al. 97] Ole Agesen, Stephen N. Freund, and John C. Mitchell. Adding Type Parameterization \nto the Java Language. In Proceedings OOPSLA 97, Atlanta, GA, October 1997. [Amadio &#38; Cardelli 91] \nRoberto M. Amadio and Luca Cardelli. Subtyping Recursive Types. In Conference Record of the Eighteenth \nAnnual ACM Symposium on Principles of Programming Languages, pages 104 118, January 1991. [Bourdoncle \n&#38; Merz 97] Fran\u00e7ois Bourdoncle and Stephan Merz. Type Checking Higher-Order Polymorphic Multi-Methods. \nIn Conference Record of the 24th ACM SIG-PLAN-SIGACT Symposium on Principles of Program\u00adming Languages, \npages 302 315, January 1997. [Bracha &#38; Griswold 93] Gilad Bracha and David Griswold. Strongtalk: \nTypechecking Smalltalk in a Production Envi\u00adronment. In Proceedings OOPSLA 93, pages 215 230, October \n1993. Published as ACM SIGPLAN Notices, vol\u00adume 28, number 10. [Bracha 96] Gilad Bracha. The Strongtalk \nType System for Smalltalk, 1996. OOPSLA 96 Workshop on Extending the Smalltalk Language, available from \nhttp://ja\u00adva.sun.com/people/gbracha/nwst.html. [Bruce et al. 93] Kim B. Bruce, Jon Crabtree, Thomas P. \nMurtagh, Robert van Gent, Allyn Dimock, and Robert Muller. Safe and decidable type checking in an object-ori\u00adented \nlanguage. In Proceedings OOPSLA 93, pages 29 46, October 1993. Published as ACM SIGPLAN Notices, volume \n28, number 10. [Bruce et al. 95a] Kim Bruce, Luca Cardelli, Giuseppe Cast\u00adagna, The Hopkins Objects Group, \nGary T. Leavens, and Benjamin Pierce. On Binary Methods. Theory and Prac\u00adtice of Object Systems, 1(3):217 \n238, 1995. [Bruce et al. 95b] Kim B. Bruce, Angela Schuett, and Robert van Gent. PolyToil: A Type-Safe \nPolymorphic Object-Oriented Language. In Proceedings ECOOP 95, Aarhus, Denmark, August 1995. Springer-Verlag. \n[Bruce et al. 97] Kim B. Bruce, Adrian Fiech, and Leaf Pe\u00adtersen. Subtyping is not a good Match for object-orient\u00aded \nlanguages. In Proceedings ECOOP 97. Springer-Verlag, June 1997. [Bruce et al. 98] Kim B. Bruce, Martin \nOdersky, and Philip Wadler. A Statically Safe Alternative to Virtual Types. In Proceedings ECOOP 98, \nBrussels, Belgium, July 1998. Springer-Verlag. [Canning et al. 89] Peter S. Canning, William R. Cook, \nWalter L. Hill, John C. Mitchell, and Walter G. Olthoff. F-Bounded Polymorphism for Object-Oriented Program\u00adming. \nIn Proceedings of the Fourth International Confer\u00adence on Functional Programming Languages and Computer \nArchitecture FPCA 89, pages 273 280. ACM, September 1989. [Cardelli 93] Luca Cardelli. An implementation \nof Fsub. Research Report 97, Digital Equipment Corporation Sys\u00adtems Research Center, 1993. [Chambers \n&#38; Leavens 94] Craig Chambers and Gary T. Leavens. Typechecking and Modules for Multi-Methods. In \nProceedings OOPSLA 94, pages 1 15, Portland, OR, October 1994. [Chambers &#38; Leavens 95] Craig Chambers \nand Gary Leav\u00adens. Typechecking and Modules for Multi-Methods. ACM Transactions on Programming Languages \nand Systems, 17(9), November 1995. [Chambers 92] Craig Chambers. Object-Oriented Multi-Methods in Cecil. \nIn O. Lehrmann Madsen, editor, Pro\u00adceedings ECOOP 92, LNCS 615, pages 33 56, Utrecht, The Netherlands, \nJune 1992. Springer-Verlag. [Chambers 93a] Craig Chambers. The Cecil Language: Specification and Rationale. \nTechnical Report UW-CSE\u00ad93-03-05, Department of Computer Science and Engineer\u00ading. University of Washington, \nMarch 1993. [Chambers 93b] Craig Chambers. Predicate Classes. In O. Nierstrasz, editor, Proceedings ECOOP \n93, LNCS 707, pages 268 296, Kaiserslautern, Germany, July 1993. Springer-Verlag. [Day et al. 95] Mark \nDay, Robert Gruber, Barbara Liskov, and Andrew C. Myers. Subtypes vs. Where Clauses: Con\u00adstraining Parametric \nPolymorphism. In OOPSLA 95 Con\u00adference Proceedings, pages 156 168, Austin, TX, October 1995. [Dean et \nal. 96] Jeffrey Dean, Greg DeFouw, Dave Grove, Vassily Litvinov, and Craig Chambers. Vortex: An Opti\u00admizing \nCompiler for Object-Oriented Languages. In OOPSLA 96 Conference Proceedings, San Jose, CA, Oc\u00adtober 1996. \n[Eifrig et al. 95] Jonathan Eifrig, Scott Smith, and Valery Trifonov. Sound Polymorphic Type Inference \nfor Objects. In OOPSLA 95 Conference Proceedings, pages 169 184, Austin, TX, October 1995. [Gamma et \nal. 95] Erich Gamma, Richard Helm, Ralph E. Johnson, and John Vlissides. Design Patterns. Addison-Wesley, \nReading, MA, 1995. [Goldberg &#38; Robson 83] Adele Goldberg and David Rob\u00adson. Smalltalk-80: The Language \nand its Implementation. Addison-Wesley, Reading, MA, 1983. [Gosling et al. 96] James Gosling, Bill Joy, \nand Guy Steele. The Java Language Specification. Addison-Wesley, Reading, MA, 1996. [Graver 89] Justin \nO. Graver. Type-Checking and Type-In\u00adference for Object-Oriented Programming Languages. Ph.D. thesis, \nUniversity of Illinois, 1989. [Liskov et al. 94] Barbara Liskov, Dorothy Curtis, Mark Day, Sanjay Ghemawhat, \nRobert Gruber, Paul Johnson, and Andrew C. Myers. Theta Reference Manual. Techni\u00adcal Report Programming \nMethodology Group Memo 88, MIT Laboratory for Computer Science, February 1994. [Litvinov &#38; Chambers \n98] Vassily Litvinov and Craig Chambers. Constraint-Based Polymorphism in Cecil. Technical Report UW-CSE-98-01-01, \nDepartment of Computer Science, University of Washington, January 1998. Available from http://www.cs.washington.edu/re\u00adsearch/projects/cecil/www/Papers/papers.html. \n[Madsen &#38; M\u00f8ller-Pedersen 89] Ole Lehrmann Madsen and Birger M\u00f8ller-Pedersen. Virtual Classes: A \nPowerful Mechanism in Object-Oriented Programming. In Pro\u00adceedings OOPSLA 89, pages 397 406, October \n1989. Published as ACM SIGPLAN Notices, volume 24, num\u00adber 10. [Madsen et al. 93] Ole Lehrmann Madsen, \nBirger M\u00f8ller-Pedersen, and Krysten Nygaard. Object-Oriented Pro\u00adgramming in the Beta Programming Language. \nAddison-Wesley, Reading, MA, 1993. [Meyer 92] Bertrand Meyer. Eiffel: the language. Prentice-Hall, 1992. \n[Myers et al. 97] Andrew C. Myers, Joseph A. Bank, and Barbara Liskov. Parameterized Types for Java. \nIn Confer\u00adence Record of the 24th ACM SIGPLAN-SIGACT Sympo\u00adsium on Principles of Programming Languages, \npages 132 145, January 1997. [Odersky &#38; Wadler 97] Martin Odersky and Philip Wadler. Pizza into Java: \nTranslating Theory into Practice. In Con\u00adference Record of the 24th ACM SIGPLAN-SIGACT Sym\u00adposium on \nPrinciples of Programming Languages, pages 146 159, January 1997. [Palsberg &#38; Schwartzbach 90] Jens \nPalsberg and Michael I. Schwartzbach. Type Substitution for Object-Oriented Pro\u00adgramming. In Proceedings \nOOPSLA/ECOOP 90, pages 151 160, October 1990. Published as ACM SIGPLAN Notices, volume 25, number 10. \n[Palsberg &#38; Schwartzbach 94] Jens Palsberg and Michael I. Schwartzbach. Object-Oriented Type Systems. \nJohn Wiley &#38; Sons, 1994. [Pierce &#38; Turner 98] Benjamin C. Pierce and David N. Turner. Local Type \nInference. In Conference Record of the 25th ACM SIGPLAN-SIGACT Symposium on Princi\u00adples of Programming \nLanguages, pages 252 265, January 1998. [SRC] DEC SRC Modula-3 Implementation. Digital Equip\u00adment Corporation \nSystems Research Center. http:// www.research.digital.com/SRC/modula-3/html/home.ht\u00adml. [Stroustrup 91] \nBjarne Stroustrup. The C++ Programming Language (second edition). Addison-Wesley, Reading, MA, 1991. \n[Thorup 97] Kresten Krab Thorup. Genericity in Java with Virtual Types. In Proceedings ECOOP 97, Jyvaskyla, \nFinland, June 1997. Springer-Verlag. [Torgersen 98] Mads Torgersen. Virtual types are statically safe. \nIn 5th Workshop on Foundations of Object-Oriented Languages, January 1998. [Wadler &#38; Blott 89] Philip \nWadler and Stephen Blott. How to Make ad-hoc Polymorphism Less ad-hoc.In Confer\u00adence Record of the Sixteenth \nAnnual ACM Symposium on Principles of Programming Languages, pages 60 76, Jan\u00aduary 1989.  Appendix A \nFormal Description of Type System Typechecking a Mini-Cecil program proceeds in the following stages: \n the top-level type environment is created based on the program s top-level declarations,  client-side \ntypechecking is performed, and  implementation-side typechecking is performed. These steps in turn involve \nchecking whether instantiations are legal and whether systems of constraints hold. These .ve components \nare discussed in the following subsections. This section serves as a non-deterministic speci.cation of \nthe behavior of the typechecker, not as a deterministic, executable algorithm for typechecking. We have \nimplemented a deterministic algorithm; it is incomplete but is capable of handling all the Cecil code \nwe have. Formalizing and improving this algorithm is future work. Throughout the rules we use the overbar \nnotation as follows. If A = A1, ..., An, B = B1, ..., Bn, C is a single element, and . is a binary operator, \nthen A .B= A1 .B1, ..., An .Bn and C .B = C .B1, ..., C .Bn . A.1 Constructing Top-Level Type Environment \nAll typechecking is performed in the context of a typechecking environment, ., which is a collection \nof declarations in the scope. Environment . ::= CD VD For a given program P = CD VD E, its top-level \nenvironment .P is formed from the global declarations as follows: .P = CD VD ..accessors(P) ..prede.ned \n.(P) contains, for each .eld declaration forall a accessorswhere C: .eld m[](v:T):Tr in P, two accessor \nmethod declarations forall a where C: method m[](v:T):Tr and forall a where C: method set_m[](v:T, vnew:Tr):Void. \n.prede.ned contains the initial declarations required by the language, including class Voidand the standard \ncontravariance rules for function types (for all values of n:) forall a1,...,an,ar,\u00df1,...,\u00dfn,\u00dfwhere \u00df1 \nisa r a1,..., \u00dfisa an, aisa \u00df: n rr .(a1,...,a):aisa .(\u00df1,...,\u00df):\u00df nr nr For typechecking each constrained \ndeclaration CD = forall awhere C: D, a local environment .CD is created as follows: .CD = .P .C ..(CD) \nvarsHere constraints C are considered to be constrained declarations with empty contexts. .(CD) is empty \nfor all vars declarations except methods, when it contains a declaration var v:T for each formal v:T; \nfor uniformity with variables we consider formals to be mutable in Mini-Cecil. The operation .1 ..2 computes \nthe union of .1 and .2, except that variable declarations in .2 shadow declarations of variables with \nthe same names in .1. The typechecker veri.es that .P contains a unique class declaration for every class \nmentioned in the program, and that type variables are only used within constrained declarations that \nde.ne them in their contexts. It also veri.es that all syntactic occurrences of named types in the program \nare legal instantiations of the corresponding type declarations; such occurrences in the top-level variable \ndeclarations and expression are veri.ed under .P while occurrences in a constrained declaration CD are \nveri.ed under .CD.  A.2 Checking Constraints Our typechecking rules depend on testing whether the following \nkinds of constraints hold, i.e., are provable: isa T1 isa T2 holds = T1 =sub T2 method constraint method \nm[Tp](Ta):Tr holds A constraint holds either if it is a legal instantiation of a declaration present \nin the environment, or if it can be derived from other constraints which hold. Figure 14 formalizes CD \n.. .|-CD . D .|-D holds .|-T =sub Void .|-T =sub T .|-T1 =sub T2 .|-T2 =sub T3 .|-T1 =sub T3 .|-S =sub \nlub(S, T) .|-glb(S, T) =sub S .|-T =sub S .|-lub(T) =sub S .|-S =sub T .|-S =sub glb(T) .|-method m[Tp](S):Tr \nholds .|-S'=sub S .|-Tr =sub Tr ' .|-method m[Tp](S'):Tr 'holds .|-method m[Tp](S1 ... S' i ... Sn):Tr \nholds .|-method m[Tp](S1 ... S'' i ... Sn):Tr holds      .|-method m[Tp](S1 ... lub(S' i, S'' i) \n... Sn):Tr holds Figure 14: Typechecking constraints .' = . .D [a:= T] .'|-C1 [a:= T] holds ... .'|-Cn \n[a:= T] holds        .|-forall awhere C1, ..., Cn : D . D [a:= T] Figure 15: Typechecking instantiations \nthese rules. The rules for deriving isa and method constraints are mostly conventional; the rules involving \nlub and glb types illustrate how such types can be used.  A.3 Checking Instantiations A constrained \ndeclaration CD can be instantiated to a declaration D by substituting types for type variables in its \ncontext. Such instantiation is legal, written as .|-CD . D, if the constraints in the context of CD (if \nany) hold upon the substitution. Figure 15 gives the formal rule. (The notation D [a:= T] replaces all \nreferences to ai in D with Ti.) When checking whether a constraint holds, the instantiation being checked \nmay be assumed, to support inductively de.ned constraints. A.4 Client-Side Typechecking Client-side \ntypechecking is performed on the program s top\u00adlevel expression under .P and on the body of each method \ndeclaration CD under .CD, using the rules in Figure 16. The rules are mostly conventional, except that \nsubclassing (=sub) and message typechecking rules rely on constraint testing, and class instantiation \nveri.es that it is a legal instantiation. We also include the standard subsumption rule and the complementary \nrule that if several types can be inferred for an expression, the glb of them can also be inferred. \nA.5 Implementation-Side Typechecking Implementation-side typechecking ensures that all method signatures \nare completely and consistently implemented. The criterion given in Figure 17 enumerates all legal instantiations \nof all signatures and tuples of instantiations of concrete classes that subclass signature arguments. \nFor each combination it checks that a similar send at run-time will be successful and that there exists \nan instantiation of the target method whose result type agrees with the type the typechecker may infer \nfor this send. The method lookup process is abstracted in the MethodLookup helper function, derived from \nthe underlying dynamic semantics and not formalized here. For a .eld accessor, it is checked that the \nmethod signatures corresponding to the get-and set\u00adaccessors provide a consistent view of the type of \nthe .eld s contents. (Note that this speci.cation is not directly executable, as it enumerates an in.nite \nnumber of possible instantiations. It is, however, a compact speci.cation of the behavior of the typechecker.) \n  Appendix B Syntactic Sugars This appendix de.nes syntactic sugars used in Section 3. We give examples \nof desugarings in Figure 18. B = VD E .'= . VD .'|-E : T   .|-B : T . .'= . var v1:T1 ... var vn:Tn \n.'|-B : Tr      .|- .(v1:T1, ..., vn:Tn):Tr { B } : .(T1,...,Tn):Tr . . . var v : T .. .|-E.: .(S):Tr \n.|-E : S .|-v : T .|-apply(E.E) : Tr var v : T .. .|-E1 : T1 .|-E2 : T2 .|-E : T .|-E1 ; E2 : T2 .|-v \n:= E : Void .|-c names a non-abstract class .|-c[Tp] is a legal instantiation   .|-E : T1 .|-T1 =sub \nT2   .|-E : T2 .|-new c[Tp] : c[Tp] .|-E : T1 , ..., .|-E : Tn .|-E : S .|-method m[Tp](S):Tr holds \n    .|-E : glb(T1, ..., Tn) .|-m [Tp](E) : Tr Figure 16: Typechecking expressions  .method declarations \nMethDpoly..P .tuples of non-abstract class declarations ClassDpoly..P s.t. length(ClassDpoly)= number \nof args(MethDpoly) .instantiations MethD, ClassD s.t. .P |-MethDpoly . MethD, .P |-ClassDpoly . ClassD \nlet MethD = method m[Tp](S1, ..., Sn):Tr, ClassDi = class ci[Tci], i = 1...n in .P |-ci[Tci] =sub Si, \ni = 1...n . send-properly-implemented(m[Tp], (c1[Tc1], ..., cn[Tcn])) send-properly-implemented(m[Tp], \n(c1[Tc1], ..., cn[Tcn])) = if MethodLookup(m[Tp], (c1[Tc1], ..., cn[Tcn])) fails then report error, otherwise \nlet MethDpoly = MethodLookup(m[Tp], (c1, ..., cn)) in let Tresult be the most speci.c type s.t. .P |-method \nm[Tp](c1[Tc1], ..., cn[Tcn]):Tresult holds in exists-satisfactory-method-instantiation(MethDpoly, Tp, \n(c1[Tc1], ..., cn[Tcn]), Tresult) and (MethD is a get accessor method . set-accessor-signatures-consistent(m[Tp], \n(c1[Tc1], ..., cn[Tcn]), Tresult)) exists-satisfactory-method-instantiation(MethDpoly, Tp, (c1[Tc1], \n..., cn[Tcn]), Tresult) = .instantiation MethD = method m[Tinst-p](v:S):Tinst-r { B } s.t. .P |-MethDpoly \n. MethD and Tp = Tinst-p and .P |-ci[Tci] =sub Si , i = 1...n and .P |-Tinst-r =sub Tresult set-accessor-signatures-consistent(m[], \n(c[Tc ]), Tresult) = .Tnewval, Tr . .P |-method set_m[](c[Tc], Tnewval):Tr holds ..P |-Tnewval =sub \nTresult Figure 17: Typechecking implementations Syntactic Sugar Desugaring class MethodNode[ T defaults_to \nMethodDecl]; ... new MethodNode ... forall T: class MethodNode[T]; ... new MethodNode[MethodDecl] ... \nframework C1,C2; forall $C1,$C2 where $C1isaC1[$C1,$C2],$C2isaC2[$C1,$C2]: class C1[$C1 defaults_to C1, \n$C2 defaults_to C2]; forall $C1,$C2 where ... same as above ... : class C2[$C1 defaults_to C1, $C2 defaults_to \nC2]; forall $C1a,$C2a,$C1b,$C2b where $C1a isa $C1b, $C1a isa $C1b, $C1b isa C1[$C1b,$C2b], $C2bisaC2[$C1b,$C2b] \n: C1[$C1b,$C2b] isa C1[$C1a,$C2a]; --Similarly for class C2 framework C1,C2 narrows D1,D2; --Same declarations \nas for desugaring of framework C1,C2 forall $C1,$C2 where $C1 isa C1[$C1,$C2], $C2 isa C2[$C1,$C2] : \nC1[$C1,$C2] isa D1[$C1,$C2]; --Similarly for C2and D2 class C instantiates D; class C; C isa D[C]; --example \nof sugar for $ forall Sub,Obs where field Sub isa Subject[Sub,Obs], Obs isa Observer[Sub,Obs] : observers(s:$Subject) \nfield observers(s:$Subject):Array[$Observer]; :Array[$Observer]; Figure 18: Examples of desugarings \n T : this must appear in the header of a declaration where a type is expected; it is desugared by adding \nthe identi.er T to the forall clause of the declaration if it is not there. That is, this implicitly \ndeclares a type variable for this declaration. Tdefaults_to T1: Tmust be a type variable. Whenever the \ndeclaration containing the defaults_to clause is instantiated and the instantiating type for T is not \nspeci.ed, T1is used. framework C1,...,Ck : this is desugared into k declarations of classes with F-bounded \ntype variables. If the framework is declared abstract, then so are the classes. Fixed-points (via the \ndefaults_to clauses) and contravariance are also declared in the desugared version. framework C1,...,Ck \nnarrows D1,...,Dk :in addition to the desugaring for framework C1,...,Ck, subclass declarations between \nCiand Diare also generated. class C instantiates D : D must be declared in a declaration framework D \n(possibly with a narrows clause). Class C has no F-bounded type variables and is declared a subclass \nof D, instantiating its F-bounded type variable with C. It is possible to introduce a sugar for a framework \nto instantiate another framework in a similar way. $C : the program must contain a declaration framework \nC1,...,Ck, where C is one of C1,...,Ck (possibly k=1). The type variables $C1,...,$Ckare added to the \nforall clause of the declaration where $C appears, along with their bounds as in the desugaring of the \nframework declaration. (Thus, all occurrences of $C1,...,$Ck in a declaration refer to mutually related \ntype variables.)  \n\t\t\t", "proc_id": "286936", "abstract": "We present a static type system for object-oriented languages which strives to provide static typechecking without resorting to dynamic \"type casts,\" restricting what code the programmer can write, or being too verbose or difficult to use in practice. The type system supports bounded parametric polymorphism where the bounds on type variables can be expressed using general recursive subtype or signature constraints, with F-bounded polymorphism and covariant type parameters being special cases.We implemented this type system in the Cecil language and used it to successfully typecheck a 100,000-line Cecil program, the Vortex optimizing compiler. Our experience was very good: dynamically-typed code needed very little rewriting. We also observed several common programming situations that presented a challenge for our type system. We discuss these situations and ways to typecheck them statically.", "authors": [{"name": "Vassily Litvinov", "author_profile_id": "81100612632", "affiliation": "Department of Computer Science and Engineering, University of Washington, Box 352350, Seattle, Washington", "person_id": "PP31049952", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/286936.286979", "year": "1998", "article_id": "286979", "conference": "OOPSLA", "title": "Contraint-based polymorphism in Cecil: towards a practical and static type system", "url": "http://dl.acm.org/citation.cfm?id=286979"}