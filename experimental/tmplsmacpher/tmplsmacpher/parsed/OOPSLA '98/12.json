{"article_publication_date": "10-01-1998", "fulltext": "\n A Lambda Calculus of Objects with Self-Inflicted Extension Pietro Di Gianantonio Furio Honsell Luigi \nLiquori Dip. di Matematica ed Informatica Dip. di Matematica ed Informatica Dip. di Matematica ed Informatica \nUniversita di Udine Universita di Udine Universita di Udine I-33100 Udine, Italy I-33100 Udine, Italy \nI-33100 Udine, Italy digianantonioQdimi.uniud.it honsellQdimi.uniud.it liquoriOdimi.uniud.it Abstract \nIn this paper we investigate, in the context of functional prototype-based languages, objects which might \nextend them-selves upon receiving a message. The possibility for an ob-ject of extending its own self \n, referred to by Cardelli, as a self-inflicted operation, is novel in the context of typed object-based \nlanguages. We present a sound type system for this calculus which guarantees that evaluating a well-typed \nexpression will never yield a message-not-found run-time error. We give several examples which illustrate \nthe increased expressive power of our system with respect to ex- isting calculi of objects. The new type \nsystem allows also for a flexible width-subtyping, still permitting sound method override, and a limited \nform of object extension. The re-sulting calculus appears to be a good starting point for a rigorous \nmathematical analysis of class-based languages. 1 Introduction An untyped lambda calculus extended with \nobject primi-tives, together with a sound type assignment system, were introduced by Fisher, Honsell, \nand Mitchell [IS], as a solid foundation for functional typed object-oriented languages. In this system, \ncalled the Lambda Calculus of Objects (Xobj), objects are untyped, and a new object may be created by \nmodifying or extending an existing prototype. The new ob-ject thereby inherits properties from the original \none in a controlled manner. Objects can be viewed as lists of pairs (method name, method body) where \nthe method body is (or reduces to) a lambda abstraction whose first formal param-eter is always self \n(or this in c++, Java). The type assignment system of XObj is set up so as to prevent the unfortunate \nmessage-not-found run-time error. Types of methods are allowed to be specialized to the type of the inheriting \nobjects. This feature, usually referred to as Mytype method specialization , reinterprets the symbol \nself in the type of the inheriting object. This high muta-bility of method bodies is accommodated in \nthe type system via an implicit form of higher-order polymorphism, inspired by the the work of Wand on \nextensible records [25]. krnllssron to make dlglfal or hard copwzs of all or part of this work for personal \nor Classroom use IS granted wthout fee provided that copes are not made or distributed for proflt or \ncommercial advan~ tWf-and that copes bear this notice and the full c~tatmn on the first page. 10 COPY \notherwIse, to republish, to post on servers or to redlstrrbure to lets. requms pr,or specific perm,ss,on \nand/or a tee. OOPSLA 98 10198 Vancouver, B.C. 0 1998 ACM l-58113.005-8/98/0010...$5.00 The calculus XObj \nhas spurred an intense research in type assignment systems for object calculi. Several calculi inspired \nby X0bj, which accommodate various extra fea-tures such as incomplete objects, subtyping, encapsulation, \nimperative features, have appeared in the literature in recent years (see e.g. [18, 7, 15, 5, 4, 19, \n61). Independently, Abadi and Cardelli have introduced, with the same foundational spirit, the Object \nCalculus [l]. This is a calculus of typed objects and allows for a natural treatment of subtyping and \nhence of code reuse. The essential differences between XObj and the Object Calculus of Abadi and Cardelli, \nare that objects in the latter calculus are typed and have a fixed size, while objects, in XQbj, are \nuntyped, and can be extended, thereby changing dynamically their shape. More specifically, XObj supports \ntwo operations which may change the shape of an object: method addition and method override. One of the \nmost powerful features of the typing system is to allow for the typing of method bodies in objects which \ncan modify their own self. Cardelli referred to this capability of a method of operating directly on \nits own self as a self-inflicted operation [12]. Example 1.1 Consider the method set-x belonging to a \npoint object point with an x field: point g (x = Xself.1, set-x = Xself .Xv.(self t x = Xself .v), . \n. . ). When we send set-x to point with an argument 3, written as point e set-x (3), then we produce \nas a result a new object where the x field has been set (i.e. overridden) to 3. Notice the self-inflicted \noperation of object override (i.e. t) performed by the method set-x. However, in all the type systems \nfor lambda calculi of objects, both those derived from XObj, and those derived from the Object Calculus, \nthe type system prevents the pos- sibility for a method to self-inflict an extension to the host object. \nWe feel that this is an unpleasant limitation if the message-passing paradigm is to be taken in full \ngenerality. Moreover, in XUbj, this limitation appears arbitrary, given that the operational semantics \nsupports without difficulty self-inflicted extension methods. There are plenty of situations, both in \nprogramming, and in real life, where it would be convenient to have objects which modify their interface \nupon an execution of a message. Consider for instance the following situations: in typed class-based \nlanguages we can modify the struc- ture of the class only statically. If we need to add a new method \nto an instance of a class we are forced to re-compile the class and to make the modification need-lessly \navailable to all the class-instances, thereby wast-ing memory. If a class had a self-extension method, \nonly the instances of the class which have dynami-cally executed this method would allocate new memory \nwithout the need of any re-compilation. many sub-class declarations could be easily explained away if \nsuitable self-extension methods in the parent class were available; down-casting could be smoothly implementable \non ob- jects with self-extension methods. For example, the following type expression could be made to \ntype-check: col-point + equal (point (; add-set-co1 (black)), where add-set-co1 is a self-extension method \nof poi- int, and equal is the name of the standard binary equality method; an alternative principled \nexplanation of the SmallTalk- 80 class methods addinstancevariable and addclass- variable could be given \nnaturally using self-extension; the process of learning could be easily modeled using an object which \ncan react to the teacher s message by extending its capability of performing, in the future, a new task \nin response to a new request from the envi- ronment (an old dog could appear to learn new tricks if in \nhis youth he had been taught a self-extension trick); the process of vaccination against the virus X \ncan be viewed as the act of extending the capability of the immune system of producing, in the future, \na new kind of K-antibodies upon receiving the message that an X-infection is in progress; The objective \nof this paper is that of introducing XObj+, a lambda calculus of objects in the style of XObj, together \nwith a type assignment system. The type assignment sys-tem allows self-inflicted object extension still \ncatching stat-ically the message-not-found run-time error. This system can be further extended to accommodate \nother subtyping features. By way of example we present a width-subtyping relation, that permits sound \nmethod override and a limited form of object extension. Self-inflicted Extension. To enable the XObj+ \ncalculus to perform self-inflicted exten-sions, two modifications of the system in [16] are necessary. \nThe first is, in effect, a simplification of the original syntax of the language. The second is much \nmore substantial and it involves the type discipline. As far as the syntax of the language is concerned, \nwe are forced to unify into a single operator, denoted by t , the two original object operators of XObj, \ni.e. object extension (H) and object override (t). This is due to the fact that, when iterating the execution \nof a self-extension method, only the first time we have a genuine object extension, the second time we \nhave just a simple object override. Example 1.2 Consider the method add-set-co1 ofpoint, that adds and \nsets a co1 field: point e (add-set-co1 = Xself .Xv. (self f co1 = v), ) . . . . When we send add-set-co1 \nto point with argument white, i.e. point ti add-set-col(white), then we produce as a result a new object \ncol-point where the co1 field has been added to point and set to white. If we send twice add-set-co1 \nto point with an argument black, i.e. col-point + add-set-co1 (black) then, since the field co1 is already \npresent in col-point, the field co1 is now overridden with black. As far as types are concerned, we add \ntwo new kinds of types, namely rem, which can be seen as the seman-tic counterpart of the syntactic (er \nfm = ez) one, and pro t.((R Q R )), which is a generalization of the original class t.R in [16] (R is \na row which contains all methods and related types present in the object-type class t.R). If the type \npro t.((R a R )) is assigned to an object e, then e can respond to all the methods listed in R. The list \nR , sometimes referred to as the reservation part of the object-type, represents the methods that can \nbe added to e either by ordinary object-extension, or by a method in R which performs a self-inflicted \nextension. Example 1.3 Consider an object e which is assigned the type pro t.((m : t+-n a n : int)). \nThen e t= m produces the eflect of adding the field n to the interface of e, and of updating the type \nof e to pro t.((m : t,n : inta)). The list of reserved methods in an object-type is cru- cial to enforce \nthe consistency of the type assignment sys-tem. Consider for instance an object containing two meth-ods, \naddn-1, and addn-2, say, each of them self-inflicting the extension of a new method n. The type assignment \nsys-tem has to carry enough information so as to enforce that the same type will be assigned to n whatever \nself-inflicted extension has been executed. The typing system that we introduce ensures that we can always \ndynamically add new fresh methods for pro-types, thus leaving intact the original philosophy of rapid \nproto-typing, peculiar to object calculi. In order to model specialization of inherited methods, we use \nthe notion of matching or type extension, originally introduced by Bruce [ll], and later applied to the \nObject Calculus [l] and to XObj 131. At the price of a little more mathematical overhead, we could have \nused also the implicit higher-order polymorphism of [16]. Object Subsumption. As it is well-known, see \ne.g. [l, 171, the introduction of a sub- sumption relation over object-types makes the type system unsound. \nIn particular, width-subtyping clashes with object extension, and depth-subtyping clashes with object \noverride. In fact on pro-types no subtyping is possible. In order to ac-commodate subtyping, we add another \nkind of object-type, viz. obj t.((R a R )), which behaves like prot.((R a R )) ex-cept that it can be \nassigned to objects that can be extended only by methods in R . On obj-types a (covariant) width-subtyping \nis permitted. IThe pro and obj terminology is borrowed from Fisher and Mitchell [18, 191. 167 This paper \nis organized as follows. In Section 2 we intro- duce the calculus XObj+; we present both a Small-Step \nreduction relation and an input/output, viz Big-Step , op-erational semantics. Some intuitive examples \nare given, in order to illustrate the idea of a self-inflicted object exten-sion. In Section 3 we introduce \nthe type system for XObj+. The intended meaning of the most interesting rules is dis- cussed in detail. \nIn Section 4 we show how our type system is compatible with a width-subtyping relation. A collection \nof example are presented in Section 2.2. In Section 6 we state our soundness result, namely that every \nclosed and well-typed expression will not produce wrong results. In Section 7, we outline a possible \napplication of our type sys-tern to the Object Calculus, in the style of [20]. Section 8 discuss related \nand future work. The complete set of type assignment rules appears in the Appendix. Acknowledgment The \nauthors are grateful to Martin Abadi, Mariangiola Deza-ni-Ciancaglini and the anonymous referees for \ntheir useful comments on this work. 2 The Lambda Calculus of Objects In this section, we present the \nLambda Calculus of Objects XObj+. The terms are defined in by the following abstract grammar: ]I where \nc is a meta-variable ranging over a set of constants, x is a meta-variable ranging over a set of variables \nand m is a meta-variable ranging over a set of methods names. As usual, terms that differ only in the \nnames of bound variables are identified. The intended meaning of the object terms is the following: () \nstands for the empty object; e + m stands for the result of sending the message m to the object e; (el \ntm = ez) stands for extending/overriding the ob-ject el with a method m whose body is e2. The auxiliary \noperation SeZ(el,m,ez) searches the body of the m method within the object el, being el a prototype of \ne2. This func-tion is peculiar to the operational semantics and, in practice, could be made not to be \navailable to the programmer. This operation Sel, introduced in [al, 2, 71, provides a more di-rect dynamic \nmethod lookup than the bookkeeping reductions used in the original paper [16]. As we said in the introduction, \nthe main difference be-tween the syntax of XObj+ and that of XObj ([lS]) lies in the use of a single \noperator t , for building an object from an existing prototype. If the object el contains m, then t denotes \nan object override, otherwise -+ denotes an object extension. 2.1 Operational Semantics In this section, \nwe define the evaluation of the terms of XObj+. We present two operational semantics. The first is given \nin terms of reduction rules (Small-Step), while the second is an input/output relation (Big-Step). (Beta) \n(Axa) e2 7 [ez/x]el (Select) e (: m 3 Sel(e,m, e) (Success) Sel((el tm= ez),m,e) 7 e2e (Next) Sel((eltn \n= ez),m,e) 7 Sel(el,m,e) m#n Figure 1: Reduction Semantics (Small-Step) Reduction Semantics. The core \nof the Small-Step reduction is given by the reduc- tion rules of Figure 2.1. The evaluation relation \n1 is then taken to be the symmetric, reflexive, transitive and contex-tual closure of 7. In addition \nto the standard (Beta) rule for lambda cal-culus, the main operation on objects is method invocation, \nwhose reduction is defined by the (Select) rule. Sending a message m to an object e containing a method \nm reduces to Sel(e,m, e), where the arguments of Sel have the following intuitive meanings (in reverse \norder): l (3rd -arg) is the receiver (or recipient) of the message; 0 (2nd -arg) is the message we want \nto send to the receiver of the message; l (lgt-arg) is (or reduces to) a proper sub-object of the receiver \nof the message. By looking at the last two rewriting rules, one may note that the Sel function scans \nthe recipient of the message until it finds the definition of the method we want to use. When it finds \nthe body of the method, it applies this body to the recipient of the message. Notice how the Sel func-tion \ncarries over, in its search, the original receiver of the message. Using standard techniques in term \nrewriting systems we have: Proposition 2.1 The 7 reduction is Church-Rosser. Big-Step Operational Semantics. \nWe define an operational semantics by means of a natural proof deduction system &#38; la Plotkin [22], \nwhich maps ev-ery input term (i.e. a closed term) to its output (i.e. a value). This semantics enforces \na lazy evaluation strategy over terms. It is worth noticing that this semantics is de-terministic and \nhence it specifies the behavior of a possible interpreter for XObj+. The set of values is defined as \nfollows: obj ::= (eltm=e2) 1 () V ::= c 1 obj ( Xx.e The deduction rules are presented in Figure 2.1. \nThe Big-Step operational semantics is sound with respect to the Small-Step reduction in the following \nsense: -(Big-Value) vuv el 4 Xx.e; [e2/x]e{ U v (Big-Beta) ele2Uv e U obj Sel(obj, m,obj) J,l v - (Big-Select) \ne+mljv e2 obj .lJ v (Big-Success) Sel((ei tm = es),m,obj) JJ II el JJ obj Sel (obj , m, obj) Jl v m#n \n(Big-Next) Sel((ei t n = ez),m,obj) JJ v Figure 2: Input/Output Semantics (Big-Step) Proposition 2.2 \n(Soundness of J,L) If e J.L v, then e % v. Proof: By induction on the structure of the derivation of \neuv. We conjecture also the following: Conjecture 2.3 (Completeness of 4) If e%v, then there exists \nv such that e JJ v . 2.2 A Collection of Examples Let (ml=el,...,mk=ek) be syntactic sugar for (...(()+ml \n=el)... f-mk =ek), for k >_ 1. In the next examples we shows three objects, each of one performing, \nrespectively: l one self-inflicted extension; s two (nested) self-inflicted extensions; a a self-inflicted \nextension on the fly. Example 2.1 Consider the object self-ext defined as fol-lows: self -ext 2 (addn \n= Xself.(self tn = h.1)). If we send the message adda to self-ext, then we have the following computation: \nself ..ext (I; addn 3 Sel(self -ext, addn, self -ext) 7 (Xself .(self t n = Xs.1)) self -ext 7 (self-ext \nt n = Xs.l), i.e. the method n has been added to self -ext. On the other hand, if we send the message \naddn twice to self-ext, in-stead, the method n is only overridden with the same body; hence we obtain \nan object which is operationally equivalent to the previous one. Example 2.2 Consider the object inner-ext \ndefined as fol- lows: inner-ext 2 (addmn = Xself.(self tm = k..(s tn = Xs .l))). If we send the message \naddmn to inner-ext, then we ob-tain: inner-ext + addmn% (inner-ext -+ m = Xs.(s t n = Xs .i)), i.e. the \nmethod m has been added to self-ext. On the other hand, if we send first the message addmn, and then \nm to inner-ext., we obtain the addition of both methods m and n: (inner-ext + add-mn) -+ m% (addmn = \nXself .(self tm = Xs.(s t n = Xs .l)) m = Xself.(self tn = Xs .l) n = Xself.1) Example 2.3 Consider the \nobject f ly-ext defined as follows: fly-ext 2 (f = Xself .Xp.p ti n, get-f = Xself.(self -+ f)(self \n4-n = Xs.1)). Zf we send the message get-f to fly-ext, then we have the following computation: fly-ext \n(I get-f 7 Sel(fly-ext,get-f,fly..ext) 7 (Xself.(self * f)(self f n = Xs.1)) fly-ext 7 (fly-ext -+= f)(fly-ext \ntn = Xs.1) 7 Sel(fly-ext,f,fly-ext) (fly-ext tn = Xs.1) S (Xself .Xp.p * n) fly-ext (fly-ext t n = &#38;.I) \n% (fly-ext -+-n = Xs.1) + n s I, i.e. the following steps are performed: 1. the method get-f calls the \nmethod f with actual pa-rameter the object itself augmented with the n method; 2. the f method takes \nas input the host object augmented with the n method, and sends to this object the message n which simply \nreturns the integer 1.  3 The Type System In this section, we will introduce the syntax of types, to-gether \nwith the most interesting type rules. In the sake of simplicity, we prefer to first present of the type \nsystem with-out the rules related with object subsumption (they will be discussed in Section 4). The \ncomplete syntax and set of rules can be found in the Appendix. 3.1 Types The type expressions are described \nby the following gram-mar: L 1 t 10 + T 1 prot.((RoR )) (a+m where u and r are meta-variables ranging \nover types, L is a meta-variable over constant types, R, and R are meta-variables ranging over rows, \nand IE is a metavariable ranging over the unique kind of types, i.e. T. A row is an unordered set of \npairs (method label, method type). Object-types in the form pro t.((RaR )) are called pro-types, here \npro is a binder for the type-variable t. As in [16], we may consider object-types as a form of recursively-defined \ntypes. In this paper we will freely use a-conversion of type-variables bound by pro. The intended meaning \nof an object-type: pro t.((ml : u1 . . . mh : uh dmh+l : Uh+l . .mk : Uk)), is the following: l ml,. \n,mh are the methods that can be invoked; we say that these methods belong to the interface part of the \nobject-type. Therefore, the object-type pro t.((ml : ml . .mh : uhd)) is the counterpart of the object-type \nclass t.((mr : ur . . .mh : uh)) of (161. l mh+l,..., mk are methods that cannot be invoked; they are \nreserved, i.e. they belong to the reservation part of the object-type. We can extend an object e with \na new method m having type u only if it is possible to assign to e an object-type of the form pro t.((R \na R ,m : u)). As we remarked in the introduction, this reservation mechanism is crucial to guarantee \nthe consistency of the type system. The operator +-is used to add new methods to an object-type; essentially \nit is the type counterpart of the operator f . 3.2 Contexts and Judgments The contexts have the following \nshape: Our type assignment system uses judgments of the fol-lowing shapes: rook, rta:T, rt-e:u, rbfl<#r, \nrkuaTT The intended meaning of the first three judgments is the nat- ural one: well-formed contexts \nand types, and assignment of u to an expression e. The intended meaning of the judgment I? l- u <# T \nis that u is the type of a possible extension of an object having type 7. As in [ll, 31, this judgment \nformalizes the notion of method-specialization (or protocol-extension), i.e. the capa-bility to inherit \nthe type of the methods of the prototype. The judgment I F u 5 r expresses a limited form of type-conversion \nwhich amounts to simplify occurrences of +. A formal system, instead of simple rewriting rules, is needed \nsince bounded type-variables can occur into the reduction. The type rules for well-formed contexts are \nstandard and need no comment. 3.3 Well-formed Types Rules In the following we will indicate with M(ml \n: UI . . .mh : uh) theset {mr...mh}. The (Type-ProR) rule r, t <#pro t.((aR)) F (T : T m @M(R) r F pro \nt.((aR,m : u)) : T asserts that the object-type pro t.((aR,m : u)) is well-formed if the object-type \npro t.((aR)) is well-formed, and the type (T is well-formed under the hypothesis that t is an object-type \ncontaining the methods in M(R). Since a may contain subexpression of form t+-n, with n E M(R), we need \nto introduce in the context the hypothesis t <#pro t.((aR)). The (Type-Pror.) rule r E pro t.((aR, R \n)) : T r k pro t.((R a R )) : T asserts that methods (with related types) can be moved from the reservation \nto the interface part of an object-type with-out affecting the well-formedness of the object-type itself. \nThe (Type-Extend) rule r E r<#prot.((aR,m: a)) rl--r+m:T asserts that, in order to apply +m to an object-type \nr, the type r needs to contain the method m. 3.4 Matching Type Rules The most interesting rules for \nmethod-specialization are (Match-Inherit), (Match-Book-Pro), (Match-RedL), and (Match-RedR). The (Match-Inherit) \nrule I l-r+m:T rkr+-m<#7 asserts that a type r incremented with a method m is a specialization of the \noriginal type r. This rule captures the essence of protocol-extension. Note that r can be a type- variable \ndeclared in the context r. The (Match-Book-Pro) rule r k pro t.((R a R )) : T rl-prot.((RaR ,m:u)):T \nl? F prot.((Ra R ,m: u)) <#prot.((Ra R )) asserts that an object-type with less reserved methods can \nbe specialized to an object-type with more reserved meth-ods. The (Match-RedL), and (Match-RedR) rules \nare sim- ple: two equivalent types can be considered as being one the specialization of the other. The \nremaining rules are the usual rules for reflexivity, transitivity, and contextual closure with respect \nto +. 3.5 Type Reduction Rules The type-reduction rules allow to transform an object-type in an equivalent, \nbut syntactically simpler, type. In this sub- section, we discuss the rules (Red-Over), and (Red-Ext). \nThe (Red-Over) rule I br<#prot.((R,m:craR )) asserts that, if in a type r the method m is already present \nin the interface part, then the type r+m can be simplified to 7. The type reduction judgment, instead \nof a single set of rewriting rules, is necessary precisely because, in this rule, the type r can be also \na type variable t. The (Red-Ext) rule r l- prot.((Ra R ,m: o)) : T rt-prot.((RaR ,m:a))+-mt%prot.((R,m:uaR \n)) asserts that an object-type r, where the method m is re-served, incremented with the method m, reduces \nto an object- type where the method m is shifted to the interface part. The remaining rules enforce the \ncontextual closure of type 4. 3.6 Type Rules for Terms The set of type rules for lambda terms are self-explanatory \nand hence they need no further justification. The (Empty) rule assigns to an empty object an empty pro-type. \nThe (Pre-Extend) rule It-e: prot.((RaR )) l?l-prot.((RaR ,m:u)):T J? I- e : pro t.((R a R ,m : 0)) asserts \nthat an object having type pro t.((R a R )) can be considered also as an object having type pro t.((R \na R ,m : u)). This rule has to be used in conjunction with the rule (Object); it ensures that we can \ndynamically add fresh meth- ods. This rule cannot be applied when e is the variable self. In fact, as \nexplained in Remark 3.1, the type of self can only be a type variable. This fact is crucial for the soundness \nof the type system. The (Object) rule rl-el:7 rFr<#prot.((RaR ,m:u)) ~,t<#7+-m~ez:t-+a rt-(eltm=ezj:r+m \n can be applied in the following cases: 1. when the object er has type e.g. pro t.((R,m : u a R )). In \nthis case the method m is already present in the object er, and the body of m is overridden with a new \nmethod body; 2. when the object er has type pro t.((R a R ,m : u)) (or, by a previous application of \nthe (Pre-Extend) rule, pro t.((R a R ))). In this case the object el is extended with the (fresh) method \nm; 3. when r is a type variable t. In this case er can be the variable self and there is a self-inflicted \nextension.  The bound for t is the same as the final type for the object (er tm = ez); this guarantees \nthat the method m special- izes its type for every future extension of (er -+m = ez). Remark 3.1 By inspecting \nthe (Object) rules one can see why the type of self is always a type variable. In fact the body e2 of \nthe new added method needs to have type t + u. Therefore, if ez reduces to a value, this valve needs \nto be a lambda abstraction in the form Xse1f.e;. It follows that in assigning type to e; we must use \na context containing the hypothesis self : t. Since no subsumption rule is available the only type we \ncan deduce for self is t. The (Send) rule rte:T rl-r<#prot.((R,m:uaR )) r t- e em : u[T/t] is the standard \nrule one can expect in a type system based on matching. We require that the method we are invoking is \npresent in the interface part of the recipient of the message. The (Select) is the following: rt-eel \n:T rte2:p l? t- r<#prot.((R,m: uaR )) rkp-+ r I- Sel(er,m, ez) : u[p/t] The leftmost two conditions \nin this rule ensure that method m is in the interface part of the object er, while the other two conditions \nensure that er is a prototype of ez. The (RedL) and (RedR) states a form of type conversion. if an object \ncan be typed with u, then it can be typed also with a type r equivalent to u. 4 Adding Object Subsumption \nIn this section we propose an extension of the type assign-ment system for XObj+ to accommodate width-subtyping. \nIt is well known that adding a subsumption rule over terms, that is the rule (Subszlme) rl-e:u rt-u<#r \nrl-e:7 clearly increases the set of expressions which are typable in the type system. Unfortunately, \nthis rule is unsound in the presence of object extension; in fact, we could (by subsump- tion) first \nhide a method in an object, and then add it again with a type incompatible with the previous one, see \n[l, 171. Therefore, in order to include subsumption rules in our type assignment system, we need to introduce \nanother kind of object-types, namely obj t.((Ra R )), The main difference between the pro-types and \nthe obj- types consists in the fact that the (Pre-Extend) rule cannot be applied when an object has type \nob j t (( Ra R )), it follows that the type obj t.((RaR )) permits extensions of an object only with \nrespect to the method names listed in the reserva- tion part R . This approach to subsumption is reminiscent \nof the one in [18, 201. We also define a sub-kind of the kind T of types, termed Rgd, whose intended \nmeaning is the subset of the rigid, i.e. non-extensible types. Therefore, the new syntax of types and \nkinds is : u,r ::= . . . ] obj t.((Ra R )) lc ::= T 1 Rgd. The subset of rigid types contains the obj-types \nand is closed under the arrow constructor. In order to axiomatize this we introduce a new form of judgment \nI I- u : Rgd. The intuitive typing rules related with this judgment are pre- sented in the Appendix. \nThe (Subsume) rule is valid only when the type in the conclusion is rigid. It is important to point out \nthat, by so doing, we do not need to introduce another partial order on types, i.e. an ordinary subtyp-ing \nrelation, to deal with subsumption. By introducing the sub-kind of rigid types, we make the matching \nrelation com-patible with subsumption, and hence we can make it play the role of the width-subtyping \nrelation. This is in sharp contrast with the uses of matching proposed so far in lit-erature ([ll, 10, \n31). Hence we can suggestively say that in our type assignment system matching is a relation on types \ncompatible with a limited subsumption rule . 4.1 Extra Rules for Subsumption Extra rules for the obj-types \nare necessary. Most of these rules are simply a rephrasing of the rules presented so far, replacing the \nbinder pro by the binder obj. The most important new rules are (Type-Obj), and (Promote). The (Type-Obj) \nrule r t pro t.((R 4 R )) : T t covariant in R, R r t- obj t.((RaR )) : T asserts that subsumption is \nunsound for methods having t in contravariant position with respect to the arrow type con-structor. Therefore, \nthe variable t is forced to occurs only covariantly in the methods of R, and R . Hence, binary methods \nare lost. This is, unfortunately, a common price to pay in order to have a fully static type system with \nsubtyp-ing (see [8, 13, 141). The (Promote) rule r t obj t.((R a R )) : T r I- pro t.((R a R )) <# obj \nt.((R a R )) promotes a fully-specializable pro-type into a limitedly specializable obj-type. When the \nmethods in R are added to the object assigned to an ob j-type, the object in question becomes jIxed, \nas in the Object Calculus. 5 A Collection of Examples In this section, we give the types of the examples \npresented so far in Subsection 2.2 together with some other (hopefully) motivating examples. The objects \nself -ext, inner-ext, and f ly-ext, of Ex- amples 2.1 and 2.2 and 2.3 can be given the following types: \nself-ext : prot.((addn: t+-non : int)), inner-ext : pro t.((addmn : tern a m : ten, n : int)) fly-ext \n: prot.((f : t+--n,get-f : (ten) + int an: int)). A possible derivation for self-ext is presented in \nFigure 5. Example 5.1 This example shows how class declaration can be simulated in the lambda calculus \nof object and how us-ing the self-inflicted extension we can factorize in a single declaration the definition \nof a hierarchy of classes. Let the method add-set-co1 be defined as in Example 1.2, and let us consider \nthe simple class definition of PointClass: PointClass (new = Xs.(x = Xself .l, add-set-co1 = . . .)). \nThe object PointClass can be used to create instances of both points and colored points, by using the \nexpressions: PointClass (Inew and (PointClass e new) + add-set-col. Example 5.2 (Subsumption 1) This \nexample shows how sub- sumption can interact with object extension. Let: P 22 obj t.((x : int a co1 \n: boolj) CP a obj t.((x : int, co1 : boola)) g 2 Xp.(p f co1 = Xs.white) and point and col-point of \ntype P and CP, respectively. By the type assignment rules we have: Et CP<#P &#38; t g : P -+ CP E t- \ng (col-point) : CP E I- (Xf .f (point) + co1 == f (col-point) + col) g : boo1 Notice that the object: \n(Af .f (point) + co1 == f (col-point) * col) would not be typable without the subsumption rules. Example \n5.3 (Subsumption 2) This example shows how a self- inflicted extension can interact with object subsumption. \nLet: P % obj t.((x : inta)) 0 a (copy-x = Xself .Xp.(self t x = Xs.p X= x)) By the type assignment rules \nwe have: E I- 0 : pro t.((copy-x : P -+ (t+x) ax : int)) E t- 0 G copy-x (col-point) : e, E F 0 S= copyx \n(col-point) * copy-x (point) : <, where E 6? pro t.((x : int, copy-x : P + ta)). The object: o e copy-x(point) \n+ copy-x(col-point) would not be typable without the subsumption rules. Example 5.4 (Downcasting) The \nself-inflicted extension per-mits to perform explicit downcasting simply by method call-ing. A simple \nexample is the following: let point and a col-point be objects with equal methods (checking the val-ues \nof x, and x, col, respectively) and a self-extension method add-set-co1 method, as presented in Example \n1.2. E t- point : prot.R and E k col-point : prot.R , where R and R are, respectively ((x : int, equal \n: t --F bool, add-set-co1 : t+cola co1 : bool)) ((x : int, equal : t -+ bool, add-set-co1 : t, co1 : \nboola)). The following judgments are derivable: E t- col-point + equal : pro t.R -+ boo1 E I- point \n+ add-set-co1 : pro t.R+-co1 typp pro t.R E t col-point -+ equal(point += add-set-col) : bool. r2 t \ns : 2, r2 + v <# pro t .(( an : int)) rg,d : 2u E 1 : int (Oh) rz t (s t n = Xs .l) : v+-n (Abs) rl \nt Xs.(s t n = Xs .l) : (v -+ (v+n)) &#38;t():T* &#38;tT<#T (Oh) E /- (add-n = Xs.(s t n = Xs .l)) : \nr+addn E t T+addn % pro t.((addn : t+n an : int)) (Red) E I- (addn = xs.(s tn = Xs .l)) : prot.((addn \n: tenan : int)) where 7 = prot.((aaddn: t+n,n: int)), r1 E v<#T+-addn, rz -rl,s : V, and r3 E rz,w<#v+n, \nand the judgment (*) is derivable by two applications of the rule (Pre-Extend). Figure 3: A derivation \nfor self-ext 6 Soundness of the Type System Lemma 6.4 If I I-m E M(r) and r t r q u, then r t m E M(U). \nIn this section we prove the crucial property of our type system, i.e. Theorem 6.11, the subject reduction \ntheorem. Proof: By structural induction on the derivation of l? t First we need a series of technical \nlemmata which can be r tz u. The induction hypothesis needs to be appliedproved by complex albeit standard \ninductive arguments. As only in the case of rule (Red-Inherit). When consideringa corollary of the Theorem \n6.11, we shall derive the funda- the rules (Red-Over), (Red-Ext), and (Red-Inherit) one mental result \nof the paper: i.e. the type soundness of our needs to apply Lemma 6.3. 0 typing discipline. Since every \nreduction step eliminates one occurrence of Lemma6.5 ~ffkU<#T,OrrkU%T, thenI tu:T, the operator +-, \nand since there are no critical pairs, it and I t r : T. follows that: Proof: By structural induction \non the derivations of I E Proposition 6.1 The type-reduction l? t u t% r is Church- U<#T Or r k U % T. \nIn order to deal with the ruleRosser and Strongly Normalizing. (RedyInherit), one needs to apply Lemma \n6.4. 0 In the following we will first consider proof the subject Lemma 6.6 Zf r, t <#~.,l? I- A, and \nr I-u <#T, then reduction theorem for the plain type assignment system not r,t+bu,rJ t .4. containing \nsubtyping. In the statement of the following properties and theo- Proof: The proof is immediate. 0 rems, \nwe will denote by A either ok, or u : T, or u <# T, or u typF T, or e : u. Lemma 6.7 (Substitution) (i) \nIf I , t <#r, I I- A, and r t u <#T, then I?, P[u/t] t A[u/t]. Lemma 6.2 (i) If I t A, then I? t- ok; \n(ii) Zf l?,x : u,r F e : 7, and I? t-e : CT, then (ii) if r, t <#T, I? k ok, then r k 7 : T. r, r t \ne[e /x] : 7. Proof: By structural induction on the derivation of judg- Proof: Both points can be easily \nproved by structural in-ment r,t<#T,r k A for point (i) or J?,x : u,r' t-e : T for duction on the derivation \nof judgments. 0 point (ii). 0 In the sequel, we make use of the following abbreviations: Lemma 6.8 (i) \nIf r t pro t.((RaR ))-+nl . . . +nk %8 r E m E M(r) stands for r F r<#prot.((aR,m : u)), pro t.((R a \nR ))+--n; . en;, then m : u E R , R for some R, u. if and only if there exists u such that: m : u E R,R \n l l?tuty~urstandsforrt-a tT a ,andI t-and I?, t <#pro t.((R a R ))+-nl . . . +nk t-u tY=P a ; type u' \n-+ a\", for some a . Here t% is the transitive tug= (ii) If r t pro t.((R 4 R ))+-nl . . . +nk closure \nof typp. pro t.((R a R ))+n\\ . -+-I&#38;, and m : u E R , R then there exists u such that: m : u E R,R \nand Lemma 6.3 If r I- m E M(T+-n), then I? b m E M(T). type r,t<#prot.((RaR ))~-nl...~nk Fu = u . Proof: \nBy inspection on the derivation of Proof: Both points can be proved by structural induction on the derivation. \nTo deal with the transitive closure of the r k T+--n<#prot.((aR,m : a)). cl matching relation, it is \nnecessary to use Lemma 6.6. 0 Lemma 6.9 Zfl? k ~<#prot.((aR,m: a)), and Definition 6.13 Define the set \nof wrong terms as follows: It-r<#prot.((aR ,m:o )), thenr,t<#r+otgecr . wrong ::= Sel(( ),m, e) 1 SeZ((Xz.e),m, \ne ) ] SeZ(c,m, e) Proof: The lemma follows immediately from Lemmas 6.8, and 6.7 (the second lemma is \nneeded when 7 is in the form t-+-al.. . +-nk). 0 Lemma 6.10 Ifr t-e : 7, then I? I- 7 : T. Proof: By \nstructural induction on the derivation of l? k e : 7, using Lemma 6.7. 0 Finally, using the above lemmata \nwe can establish: Theorem 6.11 (Subject Reduction) Zf r k e : o, and e 7 e , then I? t- e : u. Proof: \nWe proof that the type is preserved by each of the four reduction rules. In the case of the (Beta) rule \nthe proof follows easily by the Substitution Lemma. In the case of the (Select) rule the proof is immediate. \nIn the case of the (SUCC) rule one need to consider the derivation of the judgment: I t Sel((ei +--m \n= es),m, e) : o. This judgment must be derived by an application of the (Select) rule (in case followed \nby several application of the (Pre-Extend) and (Red) rules). We have therefore: r t- SeE((e1 Cm = es),m,e) \n: a[p/t], r i- (el tm = es) : 7, r t- 7 <#pro t.((R,m : u a R )), I be:p,andI kp<#r. The judgment I b \n(ei tm = es) : r must be derived by an application of the (Object) rule (in case followed by several \napplication of the (Pre-Extend) and (Red) rules). We have therefore: r t (ei tm = es) : r +m, I k ei \n: r , r l- r <#prot.((R a R ,m : &#38;I)), and I , t <#r +m k es : t -+ a . It follows that r E r +m<# \nr+m and from this, by transitivity of the matching relation, (Red-Ext) and (Match-Redn) rules: l? k r \n+m<#prot.((R ,m : o a R )). By the Lemma 6.9 one can derived that l?, t <# r t-o ge a , It follow that: \nl?, t <#p b es : t + o and by the Substitution Lemma we can easily conclude the proof. In the case of \nthe (Next) rules one need to follows a similar pattern. 0 The proof of subject reduction for the type \nassignment sys- tem with subtyping follows a similar pattern. All the auxil- iary lemmata are valid in \nthe type assignment system with subtyping, and the respective proofs can be straightforwardly extended. \nMoreover we have: Lemma 6.12 Zf I? I- 7 <# obj t.((aR,m : g)), and (I I-r<#obj t.((aR ,m: a )) VI? l- \nr<#prot.((aR ,m : a ))), thenr,t<#7kutPd. In proving the Subject Reduction Theorem, one need to consider \nthe case where, in the derivation of the typing judg-ment, there are applications of the (Subszlme) rule. \nIn this case it is sufficient to observe that after the application of a (Subsume) rule no further application \nof the (Pre-Extend) rule is possible. We conclude this section by showing the type soundness the- orem; \nthis will guarantee that every closed and well typed expression will not produce the message-not-found \nrun-time error. This error arises whenever we search a message m into an expression that does not reduce \nto an object which has the method m in its interface. By a direct inspection of the typing rules for \nterms, one can immediately see that that wrong cannot be typed. Hence, type soundness follows as a corollary \nof the subject reduction theorem, i.e.: Corollary 6.14 (Type Soundness) Zf E E e : 7, then e qC[wrong], \nwhere C[ ] is a generic context in X0bj+ i.e. a term with an hole inside it. 7 Plug n-Play in the \nObject Calculus In [20] we are presented with a first-order extension of the Object Calculus of Abadi \nand Cardelli ([l]) that supports method extension in presence of object subsumption. We conjecture that, \nwith a little effort, the type system of XObj+ could be adapted to the extended Object Calculus, of course \ntaking into account that objects are set of pairs instead of lists in X%j+. In order to adapt the type \nsystem of XUbj+ to the extended Object Calculus we need to: l remove the (Select) rule; l add the following \n(Object) rule in order to build an object from scratch: Let r z pro t.((R a R )): r,t<#r,S:tkei:ai m; \n: u; E R ViEI I k (IQ = ~(3; : t <# T)ei) I : pro t.((R a R )) l modify the (Object) rule as follows: \nrkel:r I l-r<#prot.((RaR ,m:a)) r,t<#r+-m,s:tkeez:a r I- el.mtC(s :t<#~+m)e~ : 7+m 8 Related and Future \nWorks Several calculi proposed in literature combine object exten-sion with objects subsumption ([24, \n18, 20, 4, 231). In [24], it is presented a calculus where it is possible to first subsume (forget) an \nobject component, and then re-add it again with a type which may be incompatible with the forgotten one. \nIn order to guarantee the soundness of the type system, method dictionaries are used inside objects, \nwhich link correctly method names and method bodies. Approaches to subsumption similar to the one presented \nin this work can be found in [18, 20,4, 231, In [20], an exten- sion of the Object Calculus is presented. \nRoughly speaking we can say that pro-types and obj-types in this article cor-respond to diamond-types \nand saturated-types in [20]. Similar ideas can be found in [23], although the type system there presented \npermits also a form of self-inflicted exten-sion. However, in that type system, a method m performing \na self-inflicted extension needs to return a rigid object whose Typed Syntax. e ::= s ( (III; = <(s; \n: t <# T)G) iC ( ~.III ( cl.lll f S(S : t <# 7)~ Operational Semantics. Let e e (Ill; = c(si : t <#r \n)ei)*eI (Sending) e.mj 7 ej{t?/Sj} (j E 4 (Object) e.mj +-- q(S1 : t <#T+-mj)d 7 (llli = <(S, : t <#T+-lllj)e;,lllj \n= C(Sj : t <#TXmj)d)'E'-tj' (j E I) Figure 4: Typed Syntax and Small-Step Semantics for the Extended \nObject Calculus type is fixed in the declaration of the body of m. AS a con- sequence the following expressions \nare not typable in that system: ((point f neum = .) e add-set-col) -+ nevm ((point X= add-set-col( t \nnewm = . . .) Another type system for the Lambda Calculus of Objects is presented in [4]. This type \nsystem uses a refined notion of subtyping that allows to type also binary methods. Interesting directions \nfor our future work are the follow- ing. The type system of XObj+ is not decidable. This problem can \nbe solved by developing an explicitly type-d version of XUbj+. In view of practical applications, it \nis also crucial to investigate the introduction of imperative features in our calculus. Finally we would \nlike to find an equational theory dealing with the objects of XObj+, and to study possible representation \nof our typing discipline in the framework theory of F <: (see [9]). References [l] M. Abadi and L. Cardelli. \nA Theory of Objects. Springer-Verlag, 1996. [2] G. Belle. Some Remarks on Lambda Calculus of Ob- jects. \nTechnical report, Dipartimento di Matematica ed Informatica, Universita di Udine, 1994. [3] V. Bono and \nM. Bugliesi. Matching Constraints for the Lambda Calculus of Objects. In Proc. of TLCA, volume 1210 of \nLecture Notes in Computer Science, pages 46- 62. Springer-Verlag, 1997. [4] V. Bono, M. Bugliesi, M. \nDezani-Ciancaglini, and L. Liquori. Subtyping Constraint for Incomplete Ob-jects. In Proc. of TAPSOFT/CAAP, \nvolume 1214 of Lecture Notes in Computer Science, pages 465-477. Springer-Verlag, 1997. [5] V. Bono, \nM. Bugliesi, and L. Liquori. A Lambda Cal-culus of Incomplete Objects. In Proc. of MFCS, volume 1113 \nof Lecture Notes in Computer Science, pages 218- 229. Springer-Verlag, 1996. [6] V. Bono and K. Fisher. \nAn Imperative. First-Order Calculus with Object Extension. In Proc. of ECOOP, Lecture Notes in Computer \nScience. Springer-Verlag, 1998. To appear. [7] V. Bono and L. Liquori. A Subtyping for the Fisher-Honsell-Mitchell \nLambda Calculus of Objects. In Proc. of CSL, volume 933 of Lecture Notes in Computer Sci-ence, pages \n16-30. Springer-Verlag, 1995. [8] K. Bruce, L. Cardelli, G. Castagna, The Hopkins Ob-ject Group, G. Leavens, \nand B. Pierce. On Binary Methods. Theory and Practice of Object Systems, l(3), 1996. [9] K. Bruce, L \nCardelli, and C. B. Pierce. Comparing Object Encoding. In Proc. of TACS, Lecture Notes in Computer Science. \nSpringer-Verlag, 1997. [lo] K. Bruce, L. Petersen, and A. Fiech. Subtyping Is Not a Good Match for Object-Oriented \nLanguages. In Proc. of ECOOP, volume 1241 of Lecture Notes in Computer Science, pages 104-127. Springer-Verlag, \n1997. [ll] K.B. Bruce. A Paradigmatic Object-Oriented Pro-gramming Language: Design, Static Typing and \nSe-mantics. Journal of Functional Programming, 4(2):127-206, 1994. [12] L. Cardelli. A Language with \nDistributed Scope. Com-puting System, 8(1):27-59, 1995. [13] G. Castagna. Covariance and contravariance: \nconflict without a cause. ACM Bansactions on Programming Languages and Systems, 17(3):431-447, 1995. \n[14] G. Castagna. Object-Oriented Programming: A Unified Foundation. Progress in Theoretical Computer \nScience. Birkauser, Boston, 1996. [15] K. Fisher. Type System for Object-Oriented Progmm-ming Languages. \nPhD thesis, University of Stanford, August 1996. [16] K. Fisher, F. Honsell, and J. C. Mitchell. A Lambda \nCalculus of Objects and Method Specialization. Nordic Journal of Computing, 1(1):3-37, 1994. [17] K. \nFisher and J. C. Michell. Notes on Typed Object-Oriented Programming. In Proc. of TACS, volume 789 of \nLecture Notes in Computer Science, pages 844-885. Springer-Verlag, 1994. [18] K. Fisher and J. C. Mitchell. \nA Delegation-based Ob-ject Calculus with Subtyping. In Proc. of FCT, volume 965 of Lecture Notes in Computer \nScience, pages 42-61. Springer-Verlag, 1995. [19] K. Fisher and J. C. Mitchell. On the relationship be-tween \nclasses, objects, and data abstraction. Theory and Practice of Object Systems, 1998. To appear. [20] \nL. Liquori. An Extended Theory of Primitive Objects: First Order System. In Proc. of ECOOP, volume 1241 \nof Lecture Notes in Computer Science, pages 146-169. Springer-Verlag, 1997. [21] P. Paladin. Teoremi \ndi Congruenza per Lambda-Calcoli Orientati agli Oggetti. Master s thesis, Dipartimento di Matematica \ned Informatica, Universita di Udine, 1993. In Italian. 175 PI Gordon Plotkin. A Structural Approach \nto Operational Matching Rules Semantics. Technical Report DAIMI FN-19, Com- puter Science Department, \nAarhus University, Den- I kr+-m:T mark, 1981. (Match-Znherit) rtr+m<#7 P31 D. RCmy. From classes to objects \nvia subtyping. In Proc. of European Symposium 1381 of lncs. springer, 1998. on Programming, volume (Match-Book-Pro) \nrt-prot.((RaR )) :T I I-prot.((RaR ,m:u)):T P41 J.G. Riecke and C. Stone. Privacy Electronic proceedings \nof FOOL-98, via Subsumption. 1998. In r Fprot.((RaR ,m:u))<#prot.((RaR )) 1251 M. Wand. Complete Type \nInference for Simple Objects. In Proc. of LZCS, pages 37-44. IEEE Press, 1987. rbat pF7 rku<#7 (Match-RedL) \nA The Type Assignment Rules rkTtTO r~u<#r (Match-RedR) Well-formed Contexts z (Cant--E) r, t c#~, r t- \n0k (Match-Var) r,t<#a,r t-t-+0 rl-u:T x$dom(r) l?,x:u~ok (Cont-x) rEu<#7 rbr<#p rku<#p (Match-Trans) \nI t-o:T t $! dam(r) r,t<#abok (Cont-t) r o T rt-g<#a (Match-Refl) Well-formed Types ri-7<#7- I t-r \n+m:T r r F ok I- pro t.((a)) : T (Type-Prq )) ) r t- 7+-m<# 7 +!-m (Match-Extend) Type-Reduction Rules \nr, t <#Pro t.((W t- u : T m G M(R) (Type-ProR) r t pro t.((oR,m : a)) : T rl-r<#prot.((R,m:uaR )) (Red-Over) \nr k pro t.((aR, R )) : T ri-T+mt Pe7 I bpprot.((RaR )): T (Type-ProL) (Red-Ext) I? t pro t.((R a R ,m \n: a)) : T r k r<#prot.((aR,m: a)) (Type-Extend-Pro) r k prot.((RaR ,m: a))+-m % prot.((R,m: uaR )) rl-r+-m:T \n(Red-Pro) r, t c#~, r t- 0k r,t<gu,r t-t :T (Type-Var) I ,t<#prot.((RaR ))ku%u J?t-prot.((R,m:uaR )) \nwprot.((R,m:u aR )) lYku:T rl-r:T rl-u+r:T (Type-Arrow) I kr+-m:T rt-rt FTj (Red-Znherit) r E ok r F \nr+m tvp( r ++m (Type-Const) rl-LZT rt-ut p:!d rl-r:T (Red-Arrows,) B The Extra Rules for Subsumption \nrt--%+ rl-u:T (Red-Arrown) rku+7t3u++ Type Rules for Lambda Terms r I-ok -(Const) rtC:L r,x: u,rl t \n0k War) r,x:u,r'i-xa:u r,a::uk-e:7-CAbsI r t Xx.e : u -+ 7 rtel:u-+r rl-e2:7 (APP~) r k ele2 :7 Type \nRules for Object Terms rk ok (Empty) r I- ( ) : pro t.((a)) (Pre-Extend) r t- e : prot.((Ra R )) II I-prot.((RaR \n,m:u)):T I? k e : prot.((Ra R ,m: u)) VI-eel:7 I t-T<#prot.((RaR ,m:u)) J?,t<#r+-mFez:t+u (Object) \nr~(eI-+m=e2):7+-m rke:r rt-r<#prot.((R,m:uaR )) (Send) r t-e -e= m : u[T/t] rt-el:r rl-e2:p rF7<#prot.((R,m:uaR \n)) r-t-p+7 (Select) r I-Sel(e1, m, e2) : u[p/t] l?t-e:u rt-utyPp7. (R&#38;jrt--e:7- ITI--e:u rk7qu (RedR) \nr/-e:7 Extra Well-formed Types (Type-Oh) I t-prot.((RaR )) :T t covariant in R, R r k obj t.((R a R \n)) : T r t- 7 <# obj t.((aR,m : u)) (Type-Extend-Obj) I l-r+-m:T Extra Matching Rules I l-objt.((RaR \n)):T (Promote) r b pro t.((R a R )) + obj t.((R a R )) (Match-Book-Obj) I k obj t.((R a R )) : T I t-obj \nt.((Ra R ,m : a)) : T r F obj t.((RaR ,m: u))<#objt.((RaR )) rkd<#u rkr7+k7' (Match-Arrow) rku+7<#d+7' \nExtra Type-Reduction Rules I I-r<#objt.((R,m:uaR )) (Red-Over ) rl-r+m%r (Red-Ext ) r I-obj t.((Ra R \n,m : u)) : T I? I- obj t.((Ra R ,m : a))+-m 3 obj t.((R,m : u a R )) (Red-Obj) I ,t<#prot.((R,m:uaR ))t-u%u \nr I- obj t.((R,m : u a R )) t% obj t.((R,m: u a R )) New Type Rules for Expressions rt--e:u rku<#7. I? \nt- r : Rgd (Subsume) rl--e:r ri-el:7 rFT<#objt.((RaR ,m:u)) l?,tc#r+-mt-e2:t-+u (New-Object) r I-(el4-m \n= e2): 7+-m (New-Send) rbe:r I? t T <# obj t.((R,m : u a R )) r k e *m: u[7/t] (New-Select) rt-el:7 \nrl-e2:p rl-T<#objt.((R,m:uaR )) rkp-+ r I- Sel(el,m, e2) : u[p/t] Rules for Fixed Types r I-ok (Rgd-Const) \nI? k L : Rgd r i-obj t.((Ra R )) : T (Rgd-Obj) I? I- obj t.((R a R )) : Rgd r I-r : Rgd rFr+m:T (Rgd-E&#38;end) \nI l-7+-m: Rgd rl-u:Rgd (Rgd-Var) r,t<+bu,rr l-t : Rgd rt-u:Rgd rt-T:Rgd (Rgd-Arrow) rl-uar:Rgd  \n\t\t\t", "proc_id": "286936", "abstract": "In this paper we investigate, in the context of <i>functional prototype-based languages</i>, objects which might extend themselves upon receiving a message. The possibility for an object of extending its own \"self\", referred to by Cardelli, as a <i>self-inflicted</i> operation, is novel in the context of typed object-based languages. We present a sound type system for this calculus which guarantees that evaluating a well-typed expression will never yield a message-not-found run-time error. We give several examples which illustrate the increased expressive power of our system with respect to existing calculi of objects. The new type system allows also for a flexible <i>width-subtyping</i>, still permitting sound method override, and a limited form of object extension. The resulting calculus appears to be a good starting point for a rigorous mathematical analysis of class-based languages.", "authors": [{"name": "Pietro Di Gianantonio", "author_profile_id": "81100362011", "affiliation": "Dip. di Matematica ed Informatica Universit&#224; di Udine I-33100 Udine, Italy", "person_id": "PP14168063", "email_address": "", "orcid_id": ""}, {"name": "Furio Honsell", "author_profile_id": "81100524270", "affiliation": "Dip. di Matematica ed Informatica Universit&#224; di Udine I-33100 Udine, Italy", "person_id": "P87374", "email_address": "", "orcid_id": ""}, {"name": "Luigi Liquori", "author_profile_id": "81100343771", "affiliation": "Dip. di Matematica ed Informatica Universit&#224; di Udine I-33100 Udine, Italy", "person_id": "P174267", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/286936.286955", "year": "1998", "article_id": "286955", "conference": "OOPSLA", "title": "A lambda calculus of objects with self-inflicted extension", "url": "http://dl.acm.org/citation.cfm?id=286955"}