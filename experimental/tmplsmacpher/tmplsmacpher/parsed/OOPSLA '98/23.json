{"article_publication_date": "10-01-1998", "fulltext": "\n Lightweight Object-Oriented Shared Variables for Distributed Applications on the Internet Jacob Harris \nVivek Sarkar Massachusetts Institute of Technology IBM T. J. Watson Research Center Email: harris,j@mit.edu \nEmail: vivek@watson.ibm.com Abstract This paper describes a lightweight yet powerful approach for writing \ndistributed applications using shared variables. Our approach, called SHAREHOLDER, is inspired by the \nflexible and intuitive model of information access common to the World Wide Web. The distributed applications \ntargeted by our approach all share a weak consistency model and loose transaction semantics, similar \nto a user s model of accessing email, bulletin boards, chat rooms, etc. on the Internet. The SHAREHOLDER \ninfrastructure has several advantages. Its highly object-oriented view of shared variables simplifies \ntheir initialization and configuration. A shared variable s distribution mechanism is specified through \nan associated configuration object, and the programmer does not need to write any extra code to implement \nthe sharing mechanism. These configuration objects can be initialized at run-time, allowing tremendous \nflexibility in dynamic control of dis-tribution of shared variables. Finally, the programmer can treat \nshared variables and local variables interchangeably, thus simplifying conversion of a serial application \ninto a distributed application. Subject areas: world wide web, distributed and parallel systems, persistence, \nlanguage design and implementation. 1 Introduction The last few years have seen an explosive increase \nin the growth of the Internet and the number of networked com-puters worldwide. Despite the increasing \nconnectivity of computers, distributed applications are still somewhat dif-ficult for the typical programmer \nto create. This is largely because most distributed applications communicate through the most basic approach \nof message passzng. Such message passing systems are efficient, but their lack of abstraction makes it \ndifficult to write programs and to reuse code across multiple distributed applications. Two notable approaches \nthat have more abstraction than message passing are remote method invocation (RMI) [12] and distributed \nshared memory (DSM) [9, 5, 21. Unfortunately, the extra level of abstraction in these approaches is usually \naccompanied by extra runtime Permlsslon 10 make dlgllal or hard copies of all or part of fh~s work for \npersonal or classroom use IS granted wlthoul lee prowded that copes are not made or dtstrlbuted for proflt \nor commerual advan- tage and that COPES bear fhls nottce and the full c~tat, on the fws, page 1 copy \ntherwse, 10 republish. 1 post on servers or , redlstrlbute lo IISIS. reqwes prtor specific perm~won and/or \na fee OOPSLA 98 lo/98 Vancouver, B:C. 0 1998 ACM 1-581 13.005.8/98/0010...$5.00 overhead and additional \nAPI s (application programming interfaces) that impose an extra level of programming com-plexity. JavaSpaces \n[ll] is a recent approach that builds upon past work on RMI and on Linda-style [4] concurrent systems. \nJavaSpaces allows the programmer to create and use multi-ple virtual spaces , each of which can be used \nas a persis-tent shared networked store by a heterogeneous collection of distributed applications. The \nheterogeneity is one of the key differences between JavaSpaces and DSM models; sharing in a DSM only \noccurs among multiple threads/processes that are homogeneous i.e., that belong to the same ap-plication. \nOther important characteristics of JavaSpaces include its strong typing, its support for template match-ing/lookup \nin a space, and its transaction mechanism that can support multi-space updates using a two-phase com-mit \nmodel. Though JavaSpaces can simplify the problem of writing transaction-based distributed applications, \nthis simplification comes at the cost of a reasonably heavyweight mechanism. In addition, management \nof multiple spaces imposes an extra level of complexity in writing distributed applications. In this \npaper, we address the problem of making the mechanism for using shared variables as lightweight and flex-ible \nas possible. The inspiration for our research is the World Wide Web, in which large volumes of information \nare shared very effectively on a daily basis with a weak consistency model and a loose transaction semantics \nthat are understood intuitively rather than formally. For example, a set of web pages may be updated \nasynchronously on multiple servers and reloaded by multiple clients, without any requirement that the \nreload operations obey a strong consistency model such as sequential consistency. Instead, the clients \nwork with a very weak consistency model in which a reload operation is only guaranteed to return a more \nrecent value than (or the same value as) a previous reload of the same web page. Similarly, multiple \nemail messages sent from the same source may reach their destinations out of order; in fact, it is possible \nfor an email message to fail and not reach its destination at all. Web users communicate daily via email, \nbulletin boards, chat rooms, etc. without depending on a strong transaction semantics or on a strong \nnotion of atomic update of multiple resources. Instead, web users work with a very loose transaction \nsemantics based on notifications of failed operations and/or acknowledgments of successful operations. \nThe high reliability of email transmissions in practice has made this an effective model for day-to-day \ncollaboration. Now, imagine support for a similar level of information access and sharing among comput,er \nprograms! Our goal is to enable an application to harvest information from and interact with a variet,y \nof remote sources as simply and efficiently as possiblr. The programmer should not have to rewrite his \ncode significantly to handle sharing and rc-mote access. or hardwire the mechanics of sharing into his \napplication code. Our solution is to create a middleware infrastructure for shared variables on the Internet, \nt,hat is extremely lightweight This middleware infrast,ructure is called SHAHEHOI,I)E:H, and has been \nimplemented as a small library (approximately 3,000 lines of code) written in .Java [8]. The SHAREHOLDER \ninfrastructure is highly object oriented; the user creates a shared variable by declaring it to be of \na type (class) that derives from a basic SharedVar type definition declared in the SHAHEHOLI~ER library. \nAll operat,ions for sharing are inherited from this base class and can even be overrid-den by programmer \nfor customized behavior. In addition, SHAREHOLL)I:K builds on the refiection and object serializa-tion \nmechanisms of Java in several places, and avoids bur-dening the programmer with additional interfaces \nto support rcflcction and serialization in the middleware. The key advantages of the SIIAREHOLDEH infrastructure \nare as follows. It allows the programmer to use shared vari-ables and local variables interchangeably \nin code, thus sim-plifying conversion of a serial application into a distributed application. The distribution \ninformation for a shared vari-able is stored in a configtrratl.on object for the variable. Con-figuration \nobjects can be initialized at run-time thus al-lowing tremendous flexibility in determining the sharing \nof an application s variables at runtime. For example, it is possible to run the same program with many \ndifferent con-figurations. Configuration objects also promote modular-ity by decoupling distribution \nlogic and application logic in writing a program. SHAREHOLDER configurations are ver-satile, and can \nallow shared variables to read data not only from specialized server programs but also from information \nsources as simple as remote home pages. Finally, the system allows communication through shared variables \nto be built upon a variety of communication protocols (e.g., sockets, datagrams, http, email). The rest \nof the paper is organized as follows. Sect,ion 2 outlines the SHAREHOLDER programming model from the \nuser s point of view. As illustration, section 3 discusses three example distributed applications that \nhave been written us-ing the SIIAREHOLDER system. Section 4 contains details of the design and implementation. \nSection 5 discusses related work, and section 6 contains our conclusions. 2 The SI~AREHOLIXK Programming \nmodel The following sections outline the SHAREHOLI)ER program-ming model from the user s point of view. \nSection 2.1 dc-scribes how shnrcd variables can be created. Sect,ion 2.2 describes how c:onfig~mtl.ons \ncan be associat,ed with shared variables. Section 2.3 summarizes the user s view of the prozq used in \nthe SIMZF:HOLDER infrastructure. 2.1 Shared Variables Shared variables are th(a basic building blocks \nof any dis-tributed application in the SHARE;HOI,DER infrastructure. The user creates a shared variable \nby declaring it to be of a type (class) that derives from the SharedVar type declared in the S~~AREHOI,DF,R \nlibrary. The primary benefit of this approach is that type checking and inheritance properties (constructors, \netc.) can be used t,o ensure that shared vari-ables are properly initialized and only shared variables \nare shared. In addition, class inheritance avoids the need for adding new keywords/modifiers to the base: \nprogramming language, and hence avoids the need for modifying existing compilers. If this inheritance \nrequirement poses a problem due to the single inheritance restriction in Java, an alterna- tive approach \nis for the programmer to declared a shared variable as a class that implements a special SharedVar interface \ndefined in SI-IARE:HOI,I)RR. For convenience, we will assume the inheritance approach in the rest of \nthis paper. Each shared variable inherits several useful methods from the SharedVar class. The reload0 \nmethod can be called by the program to reload the contents of the shared variable from its home location. \nAs discussed later in section 2.2, this home location can refer to a variety of possible sources, depending \non the configuration. For example, it may be a location in local memory, or on a remote web page, or \non a remote server that acts as a repository for shared variables. The update0 method is called to write \nthe new local value of the shared variable to the home location and subsequently to any other applications \nthat are sharing the variable (we refer to these applications as subscribem of the shared vari-able). \nThese updates can occur asynchronously in general; a programmer should be aware that the value of a shared \nvariable can change at any time after an update0 method is performed by any subscriber. Hence, shared \nvariables must always be declared with the volatile modifier in Java, so as to ensure that they are not \nincorrectly optimized by a Java compiler 181. The update0 method is also declared as synchronized t,o \nensure that the update value does not get partially corrupted by some other local thread in the application \nwhile the update 0 method is running. The reload0 and update0 methods can be called in either blocking \nor non-blocking invocations. Using a block-ing invocation allows the programmer t,o halt execution in \na threat1 until the operation has completed i.e., until the latest value has been reloaded or an update \nhas been received and acknowledged by the server. Blocking on a reload acts as a guarantee that further \ncomputation continues only with the most recent value from the server. Likewise, blocking on an update \ncan guarantee that further code is executed only after the update has successfully been transmitted to \nthe server. In the absence of blocking, it is possible that a pair of reload/update operations issued \nfrom the same thread might be performed out of order at the server. However, there are situations in \nwhich blocking invoca-tions may be undesirable. For example, loss of connectivity can cause a blocking \ninvocation to hang and never return. As an alternative, the SHAREHOLDER system allows the pro-grammer \nto make a non-blocking invocation which waits for at most a limited period of time. Non-blocking invocations \nwill never hang indefinitely, but they do not guarantee that the operation has completed successfully \nwhen execution resumes. With these two basic operations (reload and update), the programmer has all that \nis needed to read and write a shared variable. As a convenience, SIIAREHOLDER also provides an event-based \nmechanism for reporting when changes to a shared variable occur. Similar to the event handling mech-anism \nin Java .JDK 1.1, t,his framework allows any type to register as a listener to shared variable events \n(described by the SharedVarEvent class). When such an event is thrown (e.g., after a shared variable \ns local value is modified by a reload operation or by a remote update operation), a corresponding helper \nm&#38;hod in the listener is called. This Web Server Push Media Application Abstraction Barrier Figure \n1: Different possible server connections for a proxy mechanism allows applications to be informed of \nchanges to variables without having to continuously reload variables to see if they have changed. This \nis especially useful for appli- cations that display shared variables in graphical interfaces that only \nneed to be updated when a change occurs. Finally, it is worth noting that since SHAREHOLDER does not \nsupport locks and transactions, applications that rely on strong locking and transaction semantics will \nneed to use a more heavyweight middleware (such as JavaSpaces) for the locking and transaction operations \nin the application. 2.2 Configurations Configurations are the means by which a programmer speci-fies \nthe distribution of shared variables in a program. Unlike shared variable declarations, a configuration \nis associated with an individual object rather than with an entire class. While multiple objects of the \nsame class may share the same configuration, it is also possible for different objects of the same class \nto have different configurations. Each shared variable object stores its configuration in an ObjectConfig \nfield after initialization. Variables are not allowed to modify their configuration after initialization. \nHowever, a configu-ration can be viewed by objects of other classes. A configuration contains all the \nnecessary information about how a variable is shared. Each shared variable in SHAREHOLDER is assumed \nto have a single home location, specified by the variable s configuration e.g., the home loca-tion may \nbe a web page, an entry stored at a remote server, or may be local. Local instances of the variable in \napplica-tions can be thought of as locally cached versions of the home location. In the case of an object \nwhose internal fields are loaded from remote web pages, the configuration includes the URLs of all the \nremote pages. In the instance where an object is stored on a remote server, the configuration consists \nof a special URL with a path name to identify the variable on the remote server. A degenerate configuration \nfor an object can also state that the variable is unshared , in which case only a local copy is maintained \nof the variable. Currently, the SHAREHOLDER system requires the pro-grammer to create the configuration \nfor an object and then pass it as a parameter to the constructor for the class. How-ever, a future goal \nof SHAREHOLDER is to allow variables to retrieve their associated configuration from an external configuration \nfile at runtime. The use of an external config-uration file would decouple the sharing behavior at runtime \nfrom the program text, making it more convenient to run the same application with different networked \nbehaviors by passing it different configuration files at startup. 2.3 The Proxy The Proxy is the subsystem \nthat handles all of the details of sharing automatically for the programmer. The proxy is executed as \na separate thread from the application on the client and server nodes. It contains library routines that \nimplement the reload0 and update0 method calls invoked on shared variables. The proxy also contains code \nfor communicating with other proxies and for maintaining a central repository server for shared variables. \nThe use of a proxy enables a shared variable to be initialized from a variety of sources, as illustrated \nin figure 1. In general, we see that a client application s proxy can harvest information from read-only \nsources such as remote web pages and push media, as well as have full interaction with another proxy \nacting as a server. Since the proxy runs in a separate thread, a Proxy ob-ject only needs to be created \nonce at the startup of the application. The application should then pass a reference to this proxy to \nall of its shared variables constructors. This is necessary because several of the inherited methods \nfrom SharedVar use the proxy to function. In turn, the helper methods of the proxy use a shared object \ns configuration to work correctly. The proxy thread runs until the main program thread terminates. In \nthe case where we want to implement servers which use the SHAREHOLDER system, we want to keep the server \napplication from terminating. This is efficiently accomplished through joining on the proxy s server \nthread. To enable such joins on the proxy, the pro-grammer is provided with a joinServer method. 3 Examples \nPerhaps the best introduction to the simplicity and flexi-bility of our framework is through examples. \nSections 3.1, 3.2, and 3.3 discuss three simple example distributed ap-plications that have been written \nusing the SHAREHOLDER system. 3.1 Extracting information from a home page The first example application \nshows the simplest usage of the SHAREHOLDER framework. This StockPrinter appli-cation is a program that \nperiodically reloads stock quote Figure 2: The StockPrinter example program import Sh,aredVar. *; public \nclass StockQuote extends SharedVaT { private String name; private float quote; public StockQuote( ObjectConjTg \nobjconf, Proxy proxy, String name) { super(objConf, proxy); this.name = name; this.qu0t.e = -1; > public \nString getName { return name; } public float getQuote.0 { return quote; } Figure 3: Pseudocode for StockQuote \nclass information from remote web pages, and updates a display as shown in figure 2. The shared variable \nused in this appli-cation is quotes, an array of StockQuote objects. As shown in figure 3, the StockQuote \nclass extends the SharedVar class. (All program text specific to SHAREHOLDER is shown in italics in figure \n3 and in all later figures that contain code fragments). Figure 4 contains the definitions of the StockqueryThread \nand StockPrinter classes, which make up the rest of the ap-plication. The StockqueryThread periodically \nreloads a list of stocks (represented by an array of StockQuote objects), and then displays the quote \nvalues. The only SHAREHOLDER primitive used in this class is the reload0 method. The StockPrinter class \ninitializes and executes the pro-gram. The creation of a proxy object and multiple con-figuration objects \nin this class illustrates how such objects are created at startup and provided to the constructors for \nthe shared variables. The configuration for each element of StockQuotes identifies the home page from \nwhich the infor-mation is to be retrieved. For simplicity, this mechanism currently looks for special \nHTML tags in the home page that look something like <vartag name=AAPL value=26.3>. This is similar to \nthe convention used by the Java applet param tag. The configuration specifies the vartag to use by appending \nan identifier (e.g., AAPL) to the end of the URL for the home page. The proxy then uses this locator \nto search for a vartag with a matching name to get the value for the field. This mechanism for extracting \ninformation is simple and effective. Furthermore, such tags are not displayed by browsers since they \nare nonstandard HTML, which allows designers to embed information for use by shared applica-tions without \nhaving to modify the look of a page. public class StockQueryThread extends Thread { private volatile \nStockQuote quotes Cl ; private int sleeplength; private StockDisplay display; public StockQueryThread(StockQuoteC1 \nquotes, int sleeplength) { this.quotes = quotes; this.sleepLength = sleeplength; // display creation \ncode.. . I public void run0 { while (true) { StringBuffer quoteText = new StringBufferO; for (int i=O; \ni < quotes.length; i++) { quotes[i].reload(); quoteText.append(quotes[i] .getNameO+ : + quotes[iI .getQuoteO \n+ \\n ) ; 1 display.setText(quoteText.toStringO); sleep(sleepLength); 111)  public class StockPrinter \n{ public static void main(String[] argv) { volatile StockQuote quotes[] = nev StockQuote[argv.lengthl; \nProxy proxy = new Proxy(); for (int i=O; i < quotes.length; i++) { Config nameconfig = nezu Config( local \n, Config.READ); Config valueConfig = new Config( http://www.mit.edu/^harrisj/stock-test.html + argv[i], \nConfig. READ); ObjectConjig objconj = new ObjectConfig(); objConf.setFieldConfig( name , nameconfig); \nobjConf.setFieldConfig( quote , valueconfig); quotesCi1 = new StockQuote( objconf, proxy, argvCi1); \n StockQueryThread sqt = new StockQueryThread(quotes, 6000); sqt.st.art.0; 11 Figure 4: Pseudocode for \nStockQueryThread and Stock-Printer classes Figure 5: The SimpleMessage chat program  3.2 A Simple Chat \nsystem The SimpleMessage program is a simple application for al-lowing multiple users to chat over the \nInternet. The chat design allows multiple clients to join in or leave a chat hosted by a central server \nat any time, logging the chat as shown in figure 5. Like an electronic bulletin board, this chat program \ndoes not guarantee that messages are recorded by clients in the chronological order they were received \nat, the server or even that a given client eventually sees all of the messages sent by other clients \nin a chat. The SharedMessage class shown in figure 6 is the type for the central shared variable used \nin the communication. It contains a String message, and a reference to a graphical display (which is \ndeclared as transient [8] to indicate that it should not be shared over the network). As in the previous \nexample, the reload0 method is used to refresh the value of a shared variable. In addition, the call \nto update 0 posts messages to the server and shares it with other clients. Note that this class implements \nthe SharedVarListener interface z.e., it uses the SharedVarEvent mechanism to detect when the value of \nthe shared variable has changed. Figure 7 contains the pseudocode for the SimpleMessage and MessageServer \nclasses. The MessageServer acts as a central repository for the SharedMessage variable. This means that \nit is responsible for updating a locally stored copy of the variable and communicating this change to \nall other participating clients. However, as can be seen in fig-ure 7, this functionality is completely \nhandled within the Proxy abstraction. The client program merely has to create a Proxy server thread and \nthen join on it. The SimpleMessage class is the program s top level. This class creates the proxy and \nsets the configuration for the shared variahle. Unlike the previous example, the confign-ration here \nis set for the entire object (not, individual fields of the object), and the protocol used for communication \ncan be different from http e.g., sockets, datagrams, or even email may be used as communication protocols \nby the Proxy. (In figure 12, we will see an example of a configuration that selects sockets as its underlying \ncommunication protocol.)  3.3 A Voting System This section describes a voting application that is an-other \nexample of how the SIIAKEHOI,DMK model can be used to create networked programs without much effort. \nThis simple voting system allows multiple networked clients to select votes from a list of choices provided \nby the server. Votes arc not anonymous; instead, each client is provided with tallies of the votes and \na list of the clients that voted for each choice. These tallies are updated and propagated by the server \nwhenever a vote is cast by any client. Each client is allowed only one vote, but they can change their \nvote public class SharedMessage extmds SharedVar implements ShnredVarListener { private String message; \ntransient private ChatFrame cf; public SharedMessagec ObjectConfig config, Prozy prozy) { super(config, \nproxy); message = null; > public void postMessage(String message) { this.message = message; update(); \nSystem.out.println(\"Message posted\"); 1 public String g&#38;Message0 { return this.message; } public \nvoid reloadMessage { relond(); } public void shared VarlJpdated(Shared VarEvent evt) { if ((evt.getSource() \n== this) @U (cj != null)) cj.append(message); 1 i Figure 6: Pseudocode for SharedMessage class public \nclass SimpleMessage { public static void main(String args[]) { volatile SharedMessage sm; // code for \nreading in source and ident from command line. Proxy proxy = new l+oxy(); Config con,j = new Config(source, \nConfig.REA D I Config. WRITE); OhjectCon.fig objConj = neu, ObjectConfig(conf);  sm = new SharedMessage( \nobjConj, proxy); // creation of the ChatFrame display... 1 1 public class MessageServer { public static \nvoid main(String args[]) { Proxy proxy = new Proxy(); System.out.println(\"Ready for connections!\"); proxy.joznServer(); \n11 Figure 7: Pseudocode for SimpleMessage and MessageServer classes Figure 8: The VoteClient application \nimport Shared Var. *; public synchronized class VoteRecord extends SharedVar { String voterName; int \nvotechoice; public class VoteServerThraad extends Thread implements SharedVarListener { public VoteRecord( \nObjectConfig objconf, Proxy proxy) { volatile VoteTally tally; super(objConf, proxy); volatile VoteRecord \nrecord; this.voterName = null; this.voteChoice = -1; Proxy proxy; > public VoteServerThread(String[] \nchoices) { public void makeVote(String voterName, int votechoice) { proxy = new Proxy(); this.voterName \n= voterName; this.voteChoice = votechoice; Config tallyconfig = this.update(); new Config( local:tally \n,Config.READI Config. WRITE); ObjectConfig objconj = new ObjectConfig(tallyConJig); 1 tally = nev VoteTally( \nobjconf, proxy, choices); public String getName { return voterName; 1 Confis recordconfig = new Config( \nlocal:vote ,Config.READ); public int getChoice { return votechoice; } objconf = new ObjectConfig(recordConfig); \nrecord = nev VoteRecord( objconf, proxy); 1 record.addSharedVarListener(this); 1 Figure 9: Pseudocode \nfor VoteRecord class public void run0 { proxy.joinServer(); 1 public class VoteTally extends SharedVar \n{ // internal tables for storing choices and votes... public void sharedVarUpdated(ShoredVarEvent e) \n{ if (e.getSource() == record) { public VoteTally( ObjectConfig config, Proxy proxy) { tally.addVote(record.getName(), \nrecord.getChoice()); super(config, proxy); tally.update(); // remaining initialization code... I 1 1 \n1 public VoteTally( ObjectConjig objjconf, Proxy proxy, StringCl choices) { // similar to previous constructor... \nFigure 11: Pseudocode for VoteServer and VoteClient 1 application public void addVote(String name, int \nvote) { // stores a vote that has been cast. 1 1 public class VoteClient Figure 10: Pseudocode for VoteTally \nclass extends Frame implements ActionListener. SharedVarListener private volatile VoteTally tally; during \nthe process. A sample display is shown in figure 8. private volatile VoteRecord record; Furthermore, \nclient applications are able to enter and exit at private String name; any point during the voting process \nand should still be able to cast votes and view results. One interesting difference public VoteClient(String \nname) { this.name = name; from the previous example is that this application uses two Proxy proxy = new \nProxy(); different shared variable types (VoteRecord and VoteTally, Conjig tallyConfig = one for each \ndirection of communication between the client new Config( socket://localhost/tally , Config.READ); and \nserver. ObjectConfig objconf = new ObjectConfig(tallyConfig);The VoteRecord class (shown in figure 9) \ncontains the tally = new VoteTally( objconf, proxy); basic information associated with a vote (i.e., \nthe voter s tally.addSharedVarListener(this); name and choice). A shared variable of this type is used \nby tally.reload(); the client application to send a vote to the server by calling Config recordconfig \n= the variable s update0 method. new Config( socket://localhost/vote , Config. WRITE); objconf = new \nObjectConfig(recordConfig); The VoteTally class (shown in figure 10) serves as a record = nev VoteRecord( \nobjconf, proxy); repository for the voting results and statistics. As a shared 1 variable, it is used \nfor communicating voting results from the server to clients. This tally is sent to all subscribing clients \n public void sharedVarUpdated(SharedVarEvent evt) {whenever the server receives a new vote. Though this \nmight // update the display to rejlect appear to be excessive communication, this data structure // the \nresults in the VoteTally.... is not too large to transmit and allows any client to join in I the middle \nof the voting process. 1 The VoteServerThread class (shown in figure 11) is a simple top level program \nthat reads in a list of choices from a file and starts a server thread that listens for and handles Figure \n12: Pseudocode for VoteServer and VoteClient votes from clients. Again, the proxy keeps tracks of the \nsub-application scribers and broadcasts updates to the VoteTally object. All the server does is to detect \nwhen new votes are received and update its tally. The server uses the same SharedVarEvent mechanism as \nprevious examples to listen for updates to its VoteRecord variable. It then uses this vote information \nto update its tally and thus propagate it outwards to the clients. The final component of the system \nis a graphical client application that displays voting information and allows the user to cast or change \nhis vote (the VoteClient class in figure ??). This application monitors changes to its shared VoteTally \nobject with the event listening mechanism; when changes are detected, it updates its display accordingly. \nThe client sends votes to the server through the update mecha-nism in the VoteRecords .makeVote 0 method. \nAs an effect of the update mechanism, all of the other clients involved in the voting process will received \nupdated values for their VoteRecord objects when this client casts its vote. The class is synchronized \nto make any operations on the local VoteRecord atomic in order to avoid potential multithread-ing data \nraces in the local application. We expect a non-propagating update operation to be provided as an option \nin future versions of SHAREHOLDER. This class also provides an example of how a configu-ration s privileges \ncan enforce the access of an object. In this example, the configurations ensure that the applications \nfollow the communications model of the program i.e., the VoteRecord is written only by the client, and \nthe VoteTally is written by the server. Any attempt by the application to perform an illegal read or \nwrite will generate an exception. 4 Details of the SHAREHOLDER System A complete application in the SHAREHOLDER \nsystem con-sists of three modular components -.-the application code, configuration objects, and the \nprozy. The application code is a networked application containing shared variables written by the programmer. \nConfiguration objects represent config-uration information associated at runtime with the shared variables \nin the application code. These objects may be constructed by the programmer or by an application user; \nthe decoupling between application code and configuration objects makes it practical for these two components \nto be implemented by different people. Finally, the proxy is a component provided by the SHAREHOLDER \nlibrary for han-dling all the communication details of sharing variables. 4.1 The Application The main \ngoal of the SHAREHOLDER system is to allow programmers to easily adapt non-networked code to use shared \nvariables with networked models of information ac-cess. Thus, the real challenge has been to create a \nsystem that is flexible enough to use for a variety of applications, but is also simple enough to require \nminimal changes to stand-alone programming styles. We feel that the programming interface described in \nsection 2 achieves this goal within in a simple and extensible object oriented framework. This section \ndoes not repeat the basic descriptions of how the programmer uses the SHAREHOLDER framework; instead \nit describes the system design and implementation details. Each shared variable has two associated methods \nfor reading and writing its contents -reload0 and update(). Furthermore, in the case of reloads, there \nare two basic models, called piecemeal and wholesale, of how reload can be used to load the value at \nthe variable s home location into the local copy. The piecemeal model is for shared foo value: 3 sub: \nA,C,D   UPDATE-VALUE 4 fO0 value: 3 sub: A,C,D Figure 13: An example of the update mechanism (sub \n= list of subscribers). objects whose component fields are loaded individually from various sources. \nA good example of this is the StockQuote in the first example program (section 3.1). Because it is used \nto load components from read only sources (web pages, etc.), this piecemeal mechanism is currently only \nallowed for reloading shared fields that are read but never updated by the application over the network. \nThe wholesale model is for loading entire objects from remote servers. Wholesale reload is made possible \nthrough communication between proxies, and can be seen in the other two examples (sections 3.2 and 3.3). \nIn both these examples, we have full interaction between clients and the server as illustrated in figure \n1. For full interaction, the clients and servers have the same logical structure based on the use of \nproxies; in fact the same node may act both as a client and as a server. Regardless of the reload model, \nit is always true that the reload returns the value of the object at the server when the reload request \nwas received. The update0 method sends the contents of a shared variable to the server proxy that is \nthe home location for the shared variable. Upon receiving the update, this server then propagates the \nnew value outward to other clients. Figure 13 is a graphical depiction of this process. At the first \nstep, a client which is a subscriber for the shared variable posts an update to the variable s source. \nThis update is then propagated by the server proxy out to the other subscribers in step 2. When a new \nclient B posts an update in step 3, it is both added to the list of subscribers for the variable and \nthe new value is propagated out to the other subscribers in step 4. When a client proxy receives an updated \nvalue for a shared variable from the server, it asynchronously up-dates the values of its local variable. \nSuch updates to local variables can happen at any time during execution; correct programs using shared \nvariables should take into account that their values may change at any time. Therefore, shared variable \ndeclarations are required to be marked volatile to indicate that the variable s value may change suddenly \nand should not be optimized by the compiler. As mentioned in the Introduction, multiple updates -whether \nfrom dif-ferent applications or the same client program -are not guaranteed to be received in any particular \nchronological order (unless blocking invocations of update0 are used). Furthermore, because of changing \nnetwork conditions, there is also no upper bound on the time when an update is received at the server \nor subsequently by any subscriber for the shared variable; indeed, there is no guarantee that it is even \nreceived at all. Also, while it is possible for clients to know if their variable update has reached \nthe server or an error has occurred in transmission, there is no way for a client. to know if anot,her \nclient has received any particular update. Since reloads and updates can take potentially a long time \nto complete, both operations are implemented to run in separate threads. In a nonblocking invocation, \nthe pro-grammer is allowed to specify a maximum time limit to block on waiting for the command to complete \nsuccessfully; if that limit is exceeded, the caller continues execution even though the reload or update \noperation may not have completed. A blocking invocation forces the caller to wait indefinitely for a \nreload/update to complete. Although this could potentially result in applications hanging due to networking \nproblems, this may be useful in certain cases. For instance, blocking on a reload acts as a guarantee \nthat further computation continues only with the most recent value from the server. Likewise, blocking \non an update can guarantee that fur-ther code is executed only after the update has success-fully been \ntransmitted to the server. Using such blocking invocations allows programmers to support loose memory \ncoherency within their applications. Regardless of whether an update is blocking or non-blocking, any \nmodification to the local value of a shared variable is performed within a synchronized method (in Java) \nin the local proxy. This en-sures that updates are atomic with respect to local threads. In addition \nto reload and update, SHAREHOLDER sys-tem also supports an event notification framework for re-porting \nwhen shared variables have changed. Any object which wishes to act as a listener must implement the Shared-VarListener \ninterface. This interface specifies several defined listener methods. SharedVarListener objects can then \nreg-ister themselves as listeners for events in any shared vari-able. When an event occurs, the appropriate \nevent handling method inside the listener is called. Examples of such event handling were seen in the \nChat and Vote example programs in sections 3.2 and 3.3. Currently there is only one event type, VAR-UPDATED, \nwhich is triggered when the internal value of a shared variable is changed (whether as a result of a \nreload or update). This framework can easily be extended to support other event types in the future e.g., \nnotification of a successful asynchronous update. 4.2 Configuration Objects The configuration objects \nare the second aspect of a dis-tributed application in the SHAREHOLDER system. As de-scribed earlier, \nthe configuration information associated with a SharedVar object specifies the sharing behavior of the \nvari-able at runtime. The first case (wholesale) is for situations where we wish to share the entire \nvariable, and thus want to specify a single configuration for the entire object. In the case where we \nreload the fields of a shared object individ-ually, we would want the piecemeal configuration described \nby the latter case. The information required for a configuration object is rather simple. Examples of \nconfiguration objects can be seen in the code fragments in section 3. Each configuration is made up of \ntwo parts ~~ the source used for retrieving the object s information and the privileges the object is \ngranted with that information source. The source is a pseudoUnL We call it a pseudoURL. because the source \ncan specify strings that are not valid URLs hut follow the same stylistic conven- SharedVar Figure 18: \nThe Proxy Communication Layers which declares the source to use for both reloads and up-dates. This source \ncontains the protocol and machine to use for operations. Some examples of current protocols and potential \nfuture extensions are provided in figures 14 and 15. The privileges in a configuration specify what operations \nare allowed for the object; currently, this just specifies whether a SharedVar can be reloaded or updated, \nbut this could be extended in the future.  4.3 The Proxy Last but not least, there is the Proxy. The \nSHAREHOLDER system requires that a single proxy thread must exist on each node/system that a distributed \napplication runs on. The proxy is a library component which hides all of the details of network programming \nand shared variables behind an abstraction layer. Components of the systems contained within the proxy \ninclude the core operations for all of the SharedVar methods as well as structures for communication \nbetween proxies. Figures 16 and 17 present examples of messages which can be received by server and client \nproxies. For a more flexible and scalable design, the proxy uses an abstract communication layer which \ncan be implemented on top of any particular protocol, resulting in a two-tier communication framework \nas shown in figure 18. On the top level, communication between proxies can be viewed as an exchange of \nProxyMessage objects. These message ob-jects contain basic information used for any communication between \nproxies (i.e., the source and destination proxies, a message type, shared variable identifier, and optional \nshared variable value). At this level, all inter-proxy communication is one-way and connectionless; that \nis, ProxyMessages sent are not guaranteed to be received at their destination in any particular order, \nor even at all. This allows the proxy to thus use connectionless and/or one-way protocols (as well as \nmore reliable connection-based ones) for its underlying message transport. tion. Furthermore, like real \nURLs, the pseudoURL string specifies both a mechanism (e.g., http, ftp, email) and a location (e.g.,www.mit.edu/people/harrisj/) \nfor retrieving information. http socket local email retrieve a read-only communicate with indicates \nthat the communicate with individual field value from a special tag located in the source document. a \nremote proxy server using sockets variable is either strictly local or possibly shared but residing on \nthe local a remote proxy server via email (e.g., using SMTP and conventional Unix machine. mail handling) \nFigure 14: Communication mechanisms currently supported ftP mailto regexp receiving and posting serialized \na write only mechanism where users for updates. a read only mechanism where I page. representations of \nshared vars from ftp servers applications could mail textual descriptions of shared variable contents \na specified regular expression could be used to find a field s value on a to web I Figure 15: Potential \nfuture extensions to the communications mechanisms Type Components Meaning Subscribe name adds the source \nproxy as a subscriber for the named shared variable Unsubscribe name removes the source proxy from the \nlist of subscribers for a the named variable Create ID name, value If there is no entry associated with \nthe name in the server s directory, create an entry with the given name and value. Otherwise, if the \nvariable associated with the name is the same type, add the source proxy as a listener. The behavior \nfor when the types differ is currently undefined. Remove ID name Remove the entry associated with the \nname from the directory. The server is currently not obliged to notify any subscribers of such an action. \nReload name Request the latest value of the named variable from the proxy. If the requesting source is \nnot a subscriber for the named variable, it is added to the list. If the named entry does not exist in \nthe directory, the behavior is currently undefined. Update name, value Indicates an update for the named \nvariable. If there is an entry associated with the name with the same type, the server updates the value \nof the variable, adds the message source as a subscriber, and notifies all other subscribers of the new \nvalue with the update-value messages. If there is no entry associated with the name in the server, creates \na new entry and adds the source as a subscriber. If the named entry has a different type, the behavior \nis currently undefined. Figure 16: Proxy messages received by the server. Type Components Meaning Reload \nValue name, value The reply to a reload request. Contains the name used to request the object and the \nlatest value of the variable. Update Value name, value Indicates that a new value for the named entry \nhas been received at the message source. Triggers an automatic update in the value of the local SharedVar \nassociated with the name. If there is a type mismatch between the received value and the local version, \nthe behavior is currentlv undefined. Figure 17: Proxy messages received by the client program.  Client \nServer Application Proxy Proxy I ServerThread ServerThread I 1 SharedVar. reload ( 1 Proxy.reloadVar(...) \nClIentThread -I ProxyReloadThread Figure 19: The Proxy s Reload Mechanism The lower tier of the proxy \ns communications uses vari-proxy is initialized in a client program, the client proxy ous threads for \ntransmitting and receiving messages in the creates an entry in its own local directory -containing supported \nprotocols (e.g., sockets, datagrams, email, etc.). a pointer to the local variable and the variable s \nidentifier At startup, the Proxy creates a ProxyServerThread which -before sending a SUBSCRIBEor CREATE-ID \nmessage to the listens for incoming messages. These messages are then remote server. These two message \ntypes serve largely similar translated into higher-level ProxyMessage objects which can purposes of notifying \nthe server that the client wishes to be then be handled by more general methods inside the proxy. added \nas a subscriber for the shared variable, but they differ Similarly, outgoing messages begin as ProxyMessage \nobjects in how they act when there is no variable associated with and are translated appropriately before \nbeing sent out via a the requested identifier at the server (see figure 16 for more particular communication \nmechanism. The SHAREHOLDER details). When that server receives this message, it adds the system uses \nobject serialization for sending shared variables client as a subscriber and creates an entry for the \nvariable contained in ProxyMessage objects. As a result, any fields associated with the identifier if \nnecessary. Similarly, when that should not be shared should be declared transient. a variable is no longer \nused and is finalized by the garbage The final part of the lower-level communication system con-collector, \nthe client proxy notifies the server that it is no tains the VarDirectory structure which contains pointers \nto longer a subscriber by sending a UNSUBSCRIREor REMOVE-ID all SharedVars hosted at the server proxy \nas well as their message as appropriate to the remote proxy which notifies subscribers. This information \nis used by the server to prop-the server that it can remove the client as a subscriber. The agate client \nupdates outwards to other subscribers. Clients REMOVE-ID message is meant to provide future support for \nalso use this structure as a pointer to local cached copies of remote clients using a server to remove \nobjects no longer shared variables, but such variables in their directories have being shared by any \nclients, but its usage is currently unde-no subscribers. Subscriptions in the directory have no preset \nfined. expiration times, but are instead verified with every update; When the client application requests \na reload of a shared when a client reloads or updates a variable it is added as a variable, the client \nproxy sends a RELOAD request for the subscriber if necessary. Furthermore, whenever the proxy variable \nto the remote server. This invocation may then encounters an error while sending a message to a client, \nthe block until a reply is received from the server through a client is removed from the list of subscribers. \nIn this way, RELOAD-VALUE message (issues pertinent to blocking were the list of subscribers stored at \nthe server roughly reflects discussed in section 4.1). This blocking for the reload is the actual shared \nusage of the variable. accomplished through joining on a ReloadWaitThread which The life cycle of a typical \nshared variable demonstrates waits for the reply to the reload from the server. This how these messages \nare used by the proxy. When a variable received value is then used to update the local copy of the whose \nconfiguration specifies that it is hosted on a remote shared variable which was to be reloaded. This \nentire mech- anism is presented graphically in figure 19. 2Using the Java Serialization API in JDK 1.1. \n Client A Server SharedVar.update(, Proxy.updateVarO A/Cl$mtThread VarDirectorv SharedVar.updaeeObjectValueO \nnotify&#38;bscribers Client C \\ ClientThreaQ. I I UPDATE-VALUE '--------- message ProxyServerThread VarDirectory \n Figure 20: The Proxy s Similarly, an application call to update0 triggers the client proxy to send an \nUPDATE message to the server proxy. The server updates its directory variable with the contents of the \nmessage and propagates this new value out to all of the other subscribers within UPDATE-VALUE messages. \nThese clients then update their local copies of the shared variable in turn. The process for this is \nillustrated in figure 20. When new values for variables are received, the shared variable s contents \nare updated asynchronously. This seem-ingly simple goal presents some interesting problems in an object-oriented \nsystem. We might like to directly replace the contents of the shared variable s address in local memory \nwith the newer value; however, this is impossible in modern object oriented languages which allow classes \nto contain protected fields. Instead, it is necessary for shared variables to implement a method called \nupdateObjectValue which recursively copies the fields from the new value over. This function basically \nexists as a back door into the object s internals for the Proxy s update mechanism. This method can be \ninherited from the SharedVar class, but it works only in cases where all internal fields are public. \nOtherwise, it must be inserted into shared variable class definitions manually by the programmer. Fortunately, \nthere is a generic version of updateObjectValue0 which uses the Java Reflec-tion API (part of Java JDK \n1.1) to determine all the internal fields of a variable3. This function can easily be added by programmers \nor could be automatically inserted into classes by a customized compiler. As a silver lining, this approach \ndoes provide the means for a sophisticated programmer to 31t may not be necessary to declare all fields \npublic in JDK 1.2 if it is possible to override security for java.lang.reflect.FieId objects. Update \nMechanism customize the way his shared variables are updated. 5 Related Work As was mentioned in the \nIntroduction, message passing is the most basic approach for writing distributed applica-tions. However, \nthe lack of abstraction associated with message passing makes it difficult to write simple programs and \nto reuse code across multiple distributed applications. Distributed Shared Memory (DSM) systems pioneered \nthe metaphor of shared memory for homogeneous distributed applications. Through scalable topologies and \nefficient im-plementations, some notable recent implementations (Munin [5] and TreadMarks [2]) have even \napproached the speed of raw message-passing systems for certain applications [6]. Java RMI [12] is another \nrecent system for simplify-ing the writing of distributed applications. An object ori-ented version of \nRemote Procedure Calls (RPC), RMI allows the programmer to call certain methods of remote objects across \nthe network. This basically allows the programmer to think of network applications as procedure calls; \nthe un-derlying system translates this into the network communi-cation. Despite this abstraction, the \nRMI programmer still has to do a fair amount of low-level programming when writ-ing a distributed application, \nsuch as implementing stubs and redefining objects appropriately to use RMI. A handful of other collaborative \nsystems have been built with Java, but these either modify low-level mechanisms (e.g., [l] uses modified \nAWT events) or depend on specialized high level components (e.g., [7] provides client and server tools \nfor hablets written in Java). JavaSpaces Ill], a system built on top of RMI, is prob- ably the closest \nsystem to SHAREHOLDER in design and motivation. Both systems create an abstraction of a virtual networked \nstore (similar to the shared memory of DSM) which multiple applications can use; the programmer is able \nto write networked code in terms of reads and writes on this shared space. Unlike conventional DSM implementations, \nboth systems also are designed for the sharing of object oriented structures and provide a notification \nmechanism for reporting object changes [lo]. Despite these similarities, there are some important dif- \nferences between JavaSpaces and the SHAREHOLDER sys- tem, largely stemming from a difference in metaphor. \nJava- Spaces is built upon a metaphor of a space as a non-indexed persistent networked store that acts \nas the inter-mediary in the exchange of objects between applications. Under this approach, objects are \nretrieved from the space using templates of specified values and/or wildcard values for an object s fields. \nIt is possible for several objects to match a read0 with a given template, and a write0 to the space \nonly adds a new object to the space; it does not ever overwrite an object. In order to remove an object, \nan application can use the take0 method to read and remove objects from the space. In order for takes \nand writes to be atomic, JavaSpaces also provides a transaction mechanism that can support multi-space \nupdates using a two-phase commit model. In contrast, the SHAREHOLDER system is based loosely on the metaphor \nof a shared memory. Under this system, there is only a single space which is a table of shared variables \nindexed by unique string identifiers. There can only be one variable associated with a given identifier \nin the space. A read or write operation only accesses the value of a single variable in this space. Furthermore, \nunder this metaphor, this table entry in the space is the location for the shared variable. Ultimately, \nSHAREHOLDER is a more lightweight and flexible system than JavaSpaces. We conclude this section with \na discussion of two exam-ples to better illustrate the differences between the Java-Spaces approach and \nthe SHAREHOLDER approach. The first example (presented in figure 21) is a translation to JavaSpaces of \nthe Simple Chat program from section 3.2 (figures 6 and 7). In this code, there is no MessageServer class, \nsince the clients just use the JavaSpaces server. In order to emulate the behavior of updateo, a client \nmust first take the SharedMessage object before writing to the space. This would be encapsulated in a \ntransaction to make it atomic, but that has not been included for brevity. Also, note the usage of an \nextra element called channel in the SharedMessage class. This is similar in function to the iden-tifier \nused in the SharedVar configuration, allowing multiple channels of communication to exist on the same \nserver. The second example (presented in figures 22 and 23) is a translation to JavaSpaces of the Voting \napplication from section 3.3 (figures 9, 10 and 12). Unlike the previous exam-ple, there is a server \nwhich uses the Space. In this system, the clients cast votes by placing VoteRecords into the JavaS-pace. \nThe Space then notifies the server which removes the votes and replaces its tally object with a combined \ntake and write. The server retrieves votes by querying the space for matches for each choice, creating \nsome extra overhead. The clients in turn wait for notification of updated tallies being placed into the \nSpace and uses the new value to update their displays. We believe that both these examples illustrate \nthe extra Ievel of programming complexity required for JavaSpaces import java.rmi. *; import net.jini.euent. \n*; import net.jini.transaction. *; public class SharedMessage extends BasicEntry implements RemoteEuentListener \n{ transient private JavaSpace space; private String channel; private String message; transient private \nChatFrame cf; private transient EventRegistration eventReg; public SharedMessage( JavaSpace space, String \nchannel) { message = null; this.channel = channel; this.space = space; this.eventReg = space.notify(y(this, \nnull, this, Lease.FOREVER, null); 1 public void postMessage(String message) { this.message = message; \nSharedMessage template = new SharedMessage(); space.takeIfExists(templote, null, 0); space.write(this, \nnull, 0); I public String g&#38;Message0 { return this.message; ) public void reloadMessage { SharedMessage \ntemplate = new SharedMessage(this.space, this.channel); SharedMessage reload Val = (SharedMessage) space.read(template, \nnull, timeout); this.message = reload Val.message; 1 public void notify(RemoteEvent evt) throws UnknovnEventException, \nRemoteException { if (evt.getlD() == this.eventReg.getlD()) { reloadMessage(); if (cf != null) cf.append(this.message); \nI I public class SimpleMessage { public static void main(String args[l) { SharedMessage sm; JavaSpace \nspace = getSpace(); sm = new SharedMessagec space, argsC01) ; ChatFrame cf = new ChatFrame(sm, ident); \nsm.setChatFrame(cf); 11 Figure 21: JavaSpaces Pseudocode for the Simple Chat Program import joua.rmd.*; \nimport net.jini.event.*;  public class VoteRecord extends BasicEntry { String voterName; Integer votechoice; \ntransient JavaSpace space; public VoteRecord( JavaSpace space) { this.voterName = null; this.voteChoice \n= new Integerc-1); this.space = space; 1 private static VoteRecord template0 { return new VoteRecordO; \n} public void makeVote(String voterName, int votechoice) { this.voterName = voterName; this.voteChoice \n= new Integer(voteChoice); VoteRecord template = this.template(); space.takeIfExists(template, null, \n0); space.write(this, null, Lease.FOREVER); I public String getName { return voterName; } public int \ngetChoice { return votechoice;} 1 public class VoteTally extends BasicEntry { private VoteTally { // \ncode removed for brevity } public VoteTally(StringC1 choices) { // removed for brevity } public static \nVoteTally template0 { return new VoteTallyO; } public void addVote(String name, int vote) { //removed \nfor brevity } I Figure 22: JavaSpaces Pseudocode for the Voting Program public class VoteServerThread \nextends Thread implements RemoteEventListener { VoteTally tally; JavaSpace space; EventRegistration eventfleg; \n public VoteServerThread(String[] choices) { if (choices == null) tally = new VoteTallyO; else tally \n= new VoteTally(choices); this.space = getSpace(); 1 public void run0 { space.write(tally); eventReg \n= space.notify(VoteRecord.template(), null, this, Lease.FOREVER, null); // code for joining goes here. \n1 publzc void notify(RemoteEvent evt) { if (e.getID() == eventReg.getID()) ( VoteRecord template = VoteRecord. \ntemplate(); while (true) { VoteRecord record = (VoteRecord) space.take(template, null, 0); if (record \n!= null) tally.addVote(record.getName(), record.getChoice()); else break; 1 space.take(VoteTally.template(), \nnull, 0); space.write(tally, null, 0); 111 public class VoteClient extends Frame implements ActionListener, \nRemoteEventListener { private VoteRecord record; private String name; private JavaSpace space; private \nEventRegistration eventReg; public VoteClient(String name, int port) { this.name = name; this.space \n= getSpace(); record = new VoteRecord(space); eventReg = space.notify(VoteTally.template(), null, this, \nLease.FOREVER, null); // ALL THE GUI CREATION CODE FOLLOWS ) public void notify(RemoteEvent evt) { if \n(evt.getID() != eventReg.getID()) { return; } VoteTally tally = (Vo oteTally) space.read(VoteTally.template(), \nnull, 0); if (tally == null) { return; } // update display with tally 11 Figure 23: JavaSpaces Pseudocode \nfor the Voting Program, part 2 (compared to SHAREHOLDER). For instance, a JavaSpaces Shared memory computing \non networks of worksta- implementation has to be aware of specific spaces , of when tions. to perform \ntake operations, and of when to check for a null www.cs.rice.edu/ willy/TreadMarks/overview.html. return \nvalue from a take operation. [31 Luca Cardelli and Rowan Davies. Service Combinators for Web Computing. \nProceedings of the First Usenix 6 Conclusions and Future Work Conference on Domain Specific Language, \n1997. In this paper, we have described the SHAREHOLDER system Nicholas Carrier0 and David Gelertner. \nLinda in WI which is an extremely lightweight infrastructure for support-Context. Communications of \nthe ACM, 32(4):444--458, ing shared variables on the Internet. The SHAREHOLDER April 1989. system has \nbeen implemented as a small library written in Java, and has been tested on a small set of distributed \n[51 John B. Carter. Design of the munin distributed shared applications. The SHAREHOLDER system has several \nadvan-memory system. Journal of Parallel and Distributed tages. Its highly object-oriented view of shared \nvariables Computing, 1995. simplifies their initialization and configuration. A shared John B. Carter, \nDilip Khandekar, and Linus Kamb. variable s distribution mechanism is specified through an P-4 Distributed \nshared memory: Where we are and whereassociated configuration object, and the programmer does we should \nbe headed. In Proceedings of the Fifthnot need to write any extra code to implement the sharing Workshop \non Hot Topics in Operating Systems, pagesmechanism. The programmer s view of shared variables is 119-122, \nMay 1995. simple -there are just two basic operations for shared variables, reload and update. Finally, \nthe programmer can National Center for Supercomputing Applications. Ha- PI treat shared variables and \nlocal variables interchangeably, banero. thus simplifying conversion of a serial application into a \nhttp://www.ncsa.uiuc.edu/SDG/Software/Habanero/.distributed application. Some possible directions for \nfuture work in extending James Gosling, Bill Joy, and Guy Steele. The Java PI the SHAREHOLDER system \nare as follows. The VarDirectory Language Specification. Addison-Wesley, Reading, MA, used by a proxy \nfor tracking subscribers should use a more 1996. refined naming scheme for shared variable that includes \nthe PI Satish Kumar Nandigama, Priscilla McAndrews, and variable s name and its type/class, so as to \navoid trouble-some cases where a client attempts to reload or update Dr. Daniel A. Menasce. Welcome to \nthe distributed tutorial module. a shared variable of a different type stored at the server. shared memory \nhttp://cne.gmu.edu/modules/dsm/index.html. For improved performance on a machine running multiple applications, \nthe proxy s functionality could be split into two Java Systems East PI components -a thin stub associated \nwith each application (part of JavaSoft). Distributed events specification. and a single central proxy \ndaemon for the machine. The http://chatsubo.javasoft.com/specs/ev.ps. use of configuration objects can \nbe further simplified by creating builder/wizard tools that allow easy selection of Pll Java Systems \nEast (part of JavaSoft). Javaspaces. configuration objects from some common choices, and that http://chatsubo.javasoft.com/specs/js.ps. \nalso allow configurations to be dynamically loaded from a configuration file or perhaps even from a shared \nvariable! PI Inc. Sun Mi-Configuration objects can be made more flexible by allowing crosystems. Java \nRemote Method Invocation (RMI). alternative (backup) URLs to be specified for use if the http://java.sun.com/products/jdk/rmi/index.html. \nprimary URL is not responding. The reload and update commands can be extended with extra parameters that \nare appropriate for information access on the web e.g., timeouts based on access time or data transfer \nlimits as in [3], authen- tication parameters, etc. Finally, it should be possible to further reduce \nthe specialized code related to shared variable access that has to be hand-inserted by the programmer \n(e.g., code for the creation of the proxy and configuration objects) by using mixins or subject-oriented \nprogramming, but doing so would require a Java runtime system that can perform the richer kinds of dynamic \ndispatch required by such systems. References [l] H. Abdel-Wahab, B. Kvande, 0. Kim, and J.P. Favreau. \nAn internet collaborative environment for sharing java applications. In 5th IEEE Computer Society Workshop \non Future Trends of Distributed Computing Systems (FTDCS 97), 1997. [2] Cristiana Amza, Alan L. Cox, \nSandhya Dwarkardas, Pete Keleher, Honghui Lu, Ramakrishnan Rajamony, Weimin Yu, and Willy Zwaenepoel. \nTreadmarks:  \n\t\t\t", "proc_id": "286936", "abstract": "This paper describes a lightweight yet powerful approach for writing distributed applications using shared variables. Our approach, called S<sc>HARE</sc>H<sc>OLDER</sc>, is inspired by the flexible and intuitive model of information access common to the World Wide Web. The distributed applications targeted by our approach all share a weak consistency model and loose transaction semantics, similar to a user's model of accessing email, bulletin boards, chat rooms, etc. on the Internet. The S<sc>HARE</sc>H<sc>OLDER</sc> infrastructure has several advantages. Its highly object-oriented view of shared variables simplifies their initialization and configuration. A shared variable's distribution mechanism is specified through an associated configuration object, and the programmer does not need to write any extra code to implement the sharing mechanism. These configuration objects can be initialized at run-time, allowing tremendous flexibility in dynamic control of distribution of shared variables. Finally, the programmer can treat shared variables and local variables interchangeably, thus simplifying conversion of a serial application into a distributed application.", "authors": [{"name": "Jacob Harris", "author_profile_id": "81100117066", "affiliation": "Massachusetts Institute of Technology", "person_id": "P130824", "email_address": "", "orcid_id": ""}, {"name": "Vivek Sarkar", "author_profile_id": "81100597290", "affiliation": "IBM T. J. Watson Research Center", "person_id": "PP14206121", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/286936.286969", "year": "1998", "article_id": "286969", "conference": "OOPSLA", "title": "Lightweight object-oriented shared variables for distributed applications on the Internet", "url": "http://dl.acm.org/citation.cfm?id=286969"}