{"article_publication_date": "10-01-1998", "fulltext": "\n Adaptive Plug-and-Play Components for Evolutionary Software Development Mira Mezini and Karl Lieberherr \nCollege of Computer Science, Northeastern University, Boston, MA 02115-9959 e-mail: {mira,lieber}@ccs.neu.edu \nAbstract In several works on design methodologies, design pat- terns, and programming language design, \nthe need for program entities that capture the patterns of collabora- tion between several classes has \nbeen recognized. The idea is that in general the unit of reuse is not a single class, but a slice of \nbehavior affecting a set of collaborat- ing classes. The absence of large-scale components for expressing \nthese collaborations makes object-oriented programs more difficult to maintain and reuse, because functionality \nis spread over several methods and it be-comes difficult to get the big picture . In this pa-per, we \npropose Adaptive Plug and Play Components to serve this need. These components are designed such that \nthey not only facilitate the construction of complex software by making the collaborations explicit, \nbut they do so in a manner that supports the evolutionary nature of both structure and behavior. 1 Introduction \nThis paper describes an approach to generic, compos-able components that encapsulate collaborations be-tween \nobjects, providing a linguistic construct for ex-pressing design segments found in collaboration-based \n (role-based) designs [S, 28, 241. The term collaboration-based design [l, 9, 231 describes a methodology \nfor de- composing object-oriented applications into a set of classes and a set of collaborations. Collaborations \nexpress dis- tinct and (relatively independent) aspects of an appli- cation which may involve several \nparticipants, or roles. Each application class may play different roles in differ- ent collaborations, \nwhere each role embodies a separate aspect of the class behavior. P=mMSlOn tO make dlgltal or hard CDPI~S \nof all o, part 0, th,s work for Personal Or CkSWO I Se IS granted wthout fee prowded that COPles are \nnot made or dlstnbuted ior prot~t 01 CO,THTI~~~,~I advan. tag= and that copies bear this otlce and the \nfull ~,tat,c,n on the ,,rS, page. 70 COPY otherwse. to repubkh. to post on servers o, to redmibute to \nMs. reqwes prior speclflc P~WWSIC,~ and/or a fee. OOPSLA 98 lo/98 Vancouver. KC 0 1998 ACM l-58113.005.8/98/0010...$5.00 \n In this way, collaboration-based designs represent object-oriented applications in two different ways: \nin terms of participants or classes that are involved, and in terms of the tasks or concerns of the design, \nas il- lustrated in Fig. 1. This twofold representation results in more comprehensive and reusable designs \n[l, 9, 231. For the same reason, several other design methodolo-gies support collaboration diagrams as \none of their most important artifacts which facilitate understanding the overall behavior of high-level \nsystem operations result-ing from the use-cases [4]. Figure 1: Collaboration-Based Decomposition However, \nas also indicated in several other works [7,8, 28,241, object-oriented languages lack appropriate language \nconstructs for expressing collaboration-based designs. This causes the clarity of the designs to get \nlost in the control flow of several small methods scat-tered around the class hierarchy, when mapped \ninto code. The aim of our work is to bridge this gap be- tween design and implementation. We propose \na new component construct that: (a) explicitly captures a slice of behavior (a specific task) that affects \nseveral classes, (b) is complementary to the existing object-oriented  models in the sense that it \ndoes not substitute classes but rather complements them, and (c) supports a decomposition granularity \nthat lies be- tween the granularity supported by classes and package modules. The motivation behind (a) \nis that the unit of reuse is generally not the class, but a slice of behavior af- fecting several classes. \nThe idea is that single methods often only make sense in a larger context, and are dif- ficult to reuse \nindividually. This is actually the core of the object-oriented application framework technology. However, \nframeworks are described by means of pro- gramming languages. As a result, they suffer from prob- lems \nthat are due to the lack of language constructs for clearly expressing patterns of collaborations [9, \n12, 191. This is supported by studies conducted by Wilde et al. [30] which observe that object-oriented \ntechnology can be a burden to the maintainer because function- ality is often spread over several methods \nwhich must all be traced to get the big picture . Similar results have recently been reported by a series \nof studies on real-life object-oriented systems by Lauesen [14]. He observes that object-oriented technology \nhas not met its expectations when applied to real business applica-tions and argues that this is partly \ndue to the fact that there is no natural place where to put higher-level sys-tem operations which affect \nseveral objects. He justifies his claim based partly on the experience of companies which did not succeed \nwith large 00 systems until they put control flow and higher-level system operations out-side class behavior: \nif built into the classes involved, it was impossible to get an overview of the control flow. It was \nlike reading a road map through a soda straw P41. The rationale behind (b) is that both classes and modules \nare essential language constructs for program- ming software systems [27]. The construct we are propos- \ning does not substitute classes; it is a higher-level con-struct that complements classes in expressing \ncollabora-tions rather than isolated behaviors. As stated in [28], it is the symbiosis of the two views, \nparticipant-based versus task-based, that gives the collaboration-based de-sign its power. The participant \nview captures conven-tional notions of object-oriented design -classes are a perfect construct to map \nthe participant view from de- sign into code. The collaboration view captures cross-cutting aspects of \ndesigns; without it, the relationships across objects are lost. The requirement stated in (c) follows \nfrom the fact that classes are too small while package-like modules &#38; la Oberon [31] are too big \nprogram building blocks. The class construct is a perfect vehicle to implement variations of an abstract \ndata type. What is needed, however, is a mechanism to built higher-level program entities that capture \nthe collaboration of classes. On the other hand, package-like modules are important to master complexity \nand are often used as a unit for sep- arate compilation and dynamic loading, but they are only syntactic \nin nature and have no direct significance at run-time. The new linguistic constructs proposed in this \npaper are called Adaptive Plug and Play Components (AP-PCs for short). The name stems from two features \nin their design. First, APPCs are called adaptive be-cause they are designed to express collaborations \nthat can be matched against a whole family of applications (class graphs). Collaborations are written \nto an ab-stract class graph that is made a formal parameter of an APPC, called the interface class graph. \nThe inter-face class graph defines the view of the collaboration to a true class graph. By letting each \ncomponent de-fine a view (interface) to the true class graph, and by programming to that interface, we \nachieve a big win in reusability; to reuse the component, one needs only wrap the interface around another \nclass graph and the component should work in that setting too. Some prop- erties that must be fulfilled \nin order for the wrapping of the interface to work have been defined. Second, APPCs are attributed as \nplug and play components because they have been designed to sup-port flexible white/black-box compositions \nthat allow to incrementally evolve existing collaborations, respec-tively to create higher-level collaborations \nout of simpler ones, while keeping the ingredients in the composition loosely coupled for better reuse. \nThe remainder of the paper is organized as follows. Section 2 justifies the need for the adaptive and \nplug and play features in the design of the intended compo-nent construct. Section 3 presents APPCs and \nshows how they actually provide the intended features. Some implementation issues are considered in Section \n4. Re- lated proposals are discussed in Section 5. Section 6 concludes the paper and outlines areas of \nfuture work. 2 Requirements on the Design of Collabo-rative Components In order to outline and justify \nsome requirements on the design of a language construct for explicitly expressing collaborations, we \nelaborate an example originally pre-sented in a more simple form in Holland s thesis [9]. The example \noriginated from an application system genera- tor developed at IBM for the domain of order processing \nsystems. The goal of this application generator was to encode a generic design for order entry systems \nthat could be subsequently customized to produce applica-tions meeting a customer s specific needs. Customer \ns specific requirements were recorded using a question- naire. The installation guide supplied with the \nques-tionnaire described the options and the consequences associated with questions on the questionnaire. \n We start the discussion with a simplified version of the pricing component of such an application genera-tor. \nFig. 2 and 3 provide a partial specification of the functionality of this component by a partial class \ndi- agram and a simplified collaboration diagram for the main operation, price(). Although the design \npresented in these two diagrams is fairly simple, complexity was still a problem with the pricing component \nin the ap-plication generator [9]; it s functionality was described in nearly twenty pages of the installation \nguide. The complexity resulted from numerous (and arbi-trary) pricing schemes in use in industry and \nfrom the representation of these schemes in the system. The price of an order depends on several factors, \nsuch as the type of the customer (government, educational), the type of payment (regular, cash, etc.), \nthe time of the year (high versus low demand season), whether cost-plus, or discounting applies, whether \nprior negotiated prices are involved, whether extra charges for the items apply such as taxes, deposits \nor surcharges, etc. For the purpose of this paper, we consider two examples of pricing schemes presented \nin [9]: 1. Regular Pricing: each product has a base price which can be discounted depending on the number \nof the units ordered. 2. Negotiated Pricing: a customer may have nego- tiated certain prices and discounts \nfor particular items.  Given this short introduction of our running exam-ple, let us now consider some \nrequirements on the design of a construct for expressing collaborative behavior that are illustrated \nby the example. First, collaborative behavior should, in general, be reusable with a range of concrete \napplications, i.e., con- crete class graphs. Recall that the design for the pricing collaboration specified \nin Fig. 2 and 3 is part of the de- sign of an application generator. As such, the design is actually \nnot bound to any particular application. The design specifies only minimal requirements on the con-crete \napplications to which this generic collaboration may be attached. Concerning the structural aspects of \nthe application it states that there should be classes in the application that play the roles of the \nparticipants in Fig. 2, and these classes should directly or indirectly be connected according to the \nconnection pattern be-tween the participants in the class diagram of Fig. 2. With regard to the behavioral \naspects, the design only mentions some operations expected in the interface of the participants and the \ncontrol flow among these op- erations to realize the collaboration. Given an actual application, the \ngeneric design of the pricing component in Fig. 2 and 3 needs to be mapped to the concrete class structure. \nBy rnapping we mean assigning the responsibility for playing particular roles in the generic collaboration \nto particular classes in the concrete application and mapping paths in the generic design into concrete \nassociation paths in the concrete class diagram. The collaborative behavior in the col-laboration diagram \nin Fig. 3 will carry over. Second, even within the same application, it should be possible to reuse the \nsame collaboration multiple times with different objects playing different roles. For instance, given \na concrete application, the participant- to-class assignment for the pricing collaboration may differ \nfrom one pricing scheme to the other. For il-lustration, assume a hypothetical application for order \nprocessing that has a Product and a Customer class. In this case, the role of the PricerParty would be \nplayed by both Product and Customer depending on the pricing scheme. Product has the information needed \nwhen the regular pricing scheme is applied, while the Customer is the knowledge expert when the negotiated \npricing scheme is applied. The example considered so far is not special in the requirement to write collaborative \ncomponents that can be applied to a family of class graphs. In general, reusing collaborative components \nwith a class graph is useful for supporting any kind of polytypic function (al-gorithm) [lo] on data \nstructures. These are functions (algorithms) that apply to a range of data structures. A very simple \nexample would be counting all instances of type x that are part of the structure representing a type \ny. Even if we consider operations that apply only to a certain data type, there might, be several possible \nrepresentations of the data type, and it is desirable to have algorithms adaptable to concrete representations. \nIn the remainder of the paper, we refer to the re-quirement for reusing collaborations with both a fam- \nily of class graphs and with several class-to-participant, mappings for the same class graph, as the \nrequirement, for supporting structure-generic components. Let us now state some requirements on the com-position \nmechanisms for collaborative behavior, using the term composition for both white-box and black-box composition. \nThat is, we intend to support both (a) in- crementally evolving collaborative behavior, i.e., being able \nto define new collaborative behavior by incremen- tally refining the definitions of existing collabora.tions \n(white-box composition), and (b) creating higher-level collaborative behavior by making use of existing \ncollab-orations (black-box composition). The main goal in the design of these compositions is to maximize \nreuse. PricerParty float basicPrice(ItemParty item); float discount(ItemParty Item, int qty, Customer \ncustomer); custome$ 1 item 7 ItemParty float additonalCharges(float uniPrice, int qty); Figure 2: \nClass Diagram for the Pricing Component price0 I 4 basicprice = pricer.basicPrice(item); discount = \npricer.discount(item, qty, customer); unitPrice = basicprice - (discount * basicprice); quoteprice= \nunitPrice + item.additionalCharges(unitPrice, qty); return quoteprice;] 1: basicPrice(item) addcharges= \naddcharge + ch.cost(qty, unitprice, itemInst)) Figure 3: Collaboration Diagram for the Pricing Component \nLet us first consider white-box composition. One can The height of the reduction is determined based \non the envisage several refinements of the pricing functionality recorded buying profile of the customer. \nWe call this considered so far (independent of the pricing schemes second pricing policy FrequentCustomerPricing. \nin use). Two of them are considered here. A first ex-Both AgingPricing and FrequentCustomerPricing also \nample, called AgingPricing, is a pricing policy in which embody a collaboration among LineltemParty, \nItemParty, certain items get a reduction on their calculated price PricerParty, ChargerParty, and Customer. \nFor instance, based on the period of time they have been in stock calculating the (reduced) price remains \nthe responsibil- and on some characteristics of the items, e.g., whether ity of the LineltemParty. This \ncalculation is based on they are of certain brands. Another scenario is to have the height of reduction, \ncomputing which would be the reduction on certain items for frequent customers that responsibility of \nItemParty and Customer in AgingPricing are identified by a frequent customer advantage card. and FrequentCustomerPricing, \nrespectively. The collab-orations for AgingPricing and FrequentCustomerPricing represent refinements \nof Pricing, in the sense that, the role of each participant in each of them can be expressed as a refinement \nof the role of the same participant in Pricing. For instance, calculating the price in the Ag-ingpricing \npolicy is a refinement of the way price is cal- culated with the standard pricing policy. The discussion \nabove indicates inheritance-like re-lationships, now at the level of collaborations between several classes \nrather than at the level of single classes. These relationships are schematically shown in Fig. 4, with \nellipses representing collaborations, and arrows rep-resenting refinement relationships between collabora-tions \nwithout any commitment to the composition mech-anism that would express these relationships at the im- \nplementation level. Figure 4: Refinement Collaborations Several other variations of the basic pricing \nfunction-ality can be specified. In addition, one can think of fur- ther refining AgingPricing and/or \nFrequentCustomerPric-ing or combining them into a composed variation, say AgingAndFrequentCustomerPricing, \nto apply both reduc- tions at the same time. The existence of a variety of other possible variations \nof the pricing functionality is presented in Fig. 4 by the unnamed ellipses. Concrete applications may \nnot need all available variations of the pricing collaboration. Furthermore, a single application may \nneed several variations of Pricing, e.g., both Ag-ingpricing and FrequentCustomerPricing and/or combi-nations \nof variations, e.g., AgingAndFrequentCustomer-Pricing. This analogy of the refinement, relationships \namong collaborations and inheritance among classes indicates that it is desirable to support a white-box \ncomposition mechanism similar to inheritance for components that would enable to reuse the definition \nof Pricing in defin- ing the collaborations for AgingPricing and FrequentCus-tomerpricing. If we consider \nstandard object-oriented mechanisms for behavior variations, we could naturally think of using application \nframeworks for realizing the refinement relationships between collaborations. The participants in the \ncollaborations would be implemented as classes; roles from are added to these participants by subclassing. \nIf a framework was used in our example, base classes in the framework would implement the elements of \na concrete application and their role in the base Pricing collaboration. For instance, suppose that in \nan ap-plication ConcreteLineltem is the class that will play the LineltemParty role. The contribution \nof Concrete-Lineltem in the Pricing collaboration would then be im- plemented as a subclass of ConcreteLineltem, \nsay Pric-ingConcreteLineltem. In order to accommodate possible future refinements, the pricing functionality \nwould be implemented as a template method in PricingConcrete-Lineltem, i.e., it would invoke other methods \nthat are left unimplemented in PricingConcreteLineltem. These abstract methods would then be implemented \nin sub-classes of PricingConcreteLineltem that implement the roles played by ConcreteLineltem in the \nrefinement col-laborations, e.g., AgingPricingConcreteLineltem or Fre-quentCustomerPricingConcreteLineltem. \nHolland [8], as well as VanHilst and Notkin [28], in- vestigate several problems with a framework based \nso- lution for composing collaborations. The main problem is the implicit commitment to a particular \ncomposition structure. For instance, PricingConcreteLineltem must statically bind a concrete implementation \nof Lineltem- Party as its parent class (ConcreteLineltem in this case) even though the same Pricing collaboration \ncould equally be reused for other implementations of LineltemParty. As pointed out in [ll], reusing \nthe edifice that ties the components together is usually possible only by copy- ing and editing it. Another \nproblem with the frame-work based composition results from naming issues that might raise when an application \ncombines more than one refinement of the framework (e.g., conflicts may oc- cur in AgingAndFrequentCustomerConcreteLineltem). \nIn a more general context, several works [18, 201 show that inheritance does not provide an effective \ncom-position mechanism when a considerable number of be- havior variations exist and can be arranged \nin several different combinations for creating more complex varia-tions. These works motivate the need \nfor more flexible mechanisms for composing class-defined behavior, using variants of mixin-classes [2]. \nMixin-classes also called abstract subclasses, define behavior that will eventually inherit from a superclass \n-the behavior defined in a mixin-class is expressed in terms of a super parameter. This parameter, however, \nis not bound to any concrete superclass when the mixin is defined. The discussion above indicates that \nsimilar techniques are relevant also at the level of whole collaborations. The construct we intend to \ndesign for explicitly ex-pressing collaborations should have a mixin flavor in the sense t,hat when defined \na collaboration makes as few assumptions as possible about other collaborations it, is going to be combined \nwith in an actual applica-tion. Furthermore, while we want to support white-box reuse of the collaboration \ndefinitions, the composition mechanism should be designed such that, it maintains the encapsulation and \nindependence of collaborations when involved in compositions with other components. The aim is to avoid \nname conflicts and allow simulta-neous execution of several collaborations even if these may share a \ncommon parent . The requirement for loose coupling holds also for the black-box composition. As already \nmentioned above, is should be possible to create higher-level collaborations that make use of the functionality \nprovided by other collaborations. A simple scenario for illustrating this kind of composition in our \nrunning example is the To-tal collaboration, whose functionality is schematically presented in Fig. 5. \nCalculating the total of an order involves a simple collaboration between an OrderParty object and the \nLineltemParty objects contained in it: the total of an order is the sum of the price of each line item \nconta,ined in it. Again, the design presented in Fig. 5 is expressed in terms of an abstract class graph. \nFurthermore, the only assumption it makes about the behavior of the participant,s is that whatever class \nis going to play the LineltemParty role in a concrete application, this class is responsible for calculating \nthe price. However, the de- sign does not make any commitment as what concrete pricing scheme, or pricing \npolicy is in use. As a conse-quence of the loose coupling, the design can be reused with a variety of \npricing schemes and policies. By re-quiring that the mechanism for black-box composition of collaborative \ncomponents should allow for loose cou- pling among collaborations, i.e., that one collaboration uses \nanother collaboration without explicitly mention-ing it, in its implementation, we simply aim at preserving \nthis fea,ture of the design at the implementation level. In the remainder of the paper, we will refer \nto the requirements we posed on the omposition mechanisms uniformly as the decoupled behavioral composition \nre-quirement. After having outlined and justified the re-quirements in detail, below we briefly summarize \ntheir meaning and implications. R1: structure-generic. Generic specification of the collaboration with \nre- spect to the class structure it will be applied to should be enabled. This serves two purposes: (a) \nallow the same component to be used with a fam- ily of class graphs, and (b) allow a collaborative component \nto be matched against several places in the same class graph, i.e., with different class-to- participant \nmappings for the same class structure. l R2: decoupled behavioral composition Flexible composition mechanisms \nare needed to support reusing the definition of existing compo-nents to build more complex collaborations. \nThis implies: (a) loose coupling among collaborations in the sense that their definitions do not make \nexplicit commitments to a particular structure of composition, and (b) maintaining the encapsula-tion \nand independence of collaborations when in- volved in white-box compositions with other com-ponents. \nThe aim is to facilitate reusing the same components with several compositions. 3 Adaptive Plug and Play \nComponents An Adaptive Plug and Play Component is a language construct for expressing collaborative behavior \nthat in-volves a set of participants (classes) in an object-oriented application domain. It extends the \nstandard object-oriented model, while being orthogonal to it, and is de- signed to satisfy the requirements \n(RI and R2) listed above: l In achieving structural genericity we borrow and further develop the Adaptive \nProgramming [16, 171 technology for decoupling structure from behavior. l In achieving decoupled behavioral \ncomposition we partly reuse ideas from RONDO [20] and partly ap-ply the technique of programming to interfaces. \nBecause of its importance for understanding APPCs, in the following key ideas behind Adaptive Programming \nwill be first briefly outlined. 3.1 Adaptive Programming One of the key elements of adaptive programming \nis the concept of a traversal strategy graph, also called traver-sal strategy, or strategy for short, \n[22, 171. The emergence of traversal strategies is the result of the Law of Demeter (LoD) [15] which \nsays that a method should only talk to its direct friends : the argument objects, the part objects and \nthe newly created objects. If you do not fol- low LoD, you get methods that contain too many details \nabout the object structure and are for this reason brittle with regard to structural changes. If you \nfollow LoD, the situation is better but you get many small meth-ods that refer to the details of the \nobject structure. To solve this trade-off and build more maintainable sys-tems, Adaptive Programming \n[16] introduces traversal strategy graphs which are use-case based abstractions of class graphs. int \ntotal = 0; . . . while (items.hasElements()) ( lineItem := items.next(); total += lineItem.price(); \nFigure 5: Partial Class Diagram and Collaboration Diagram for the Total Component Strategies have their \norigin in automata theory ap-plied to structural architectures. Strategy graphs con-sist of nodes and \nedges. They describe the overall topol-ogy of a group of collaborating classes. The nodes are the cornerstones \nof the topology and the edges describe that certain connections must exist. The details of those connections \nat the class graph level are left unspecified. The edges may also have constraints assigned. An edge \n(A, B) without constraint means A. any*. B and an edge (A,B) with a constraint C means a. (any, satisfying \nC) * . B. A regular expression like A. any*. B for a class graph means to take all paths from class A \nto class B and to view them as a group of collaborating classes. Thus, trategies add a third layer of \nabstraction to the usual two level object model of object graphs and class graphs. A third layer is needed \nbecause class graphs serve several purposes, and for each purpose only a part of the class graph is really \nimportant; the rest is just noise. With strategies we can focus on the important part and filter out \nthe noise. As mentioned earlier, it has been observed that following the control flow in an object-oriented \nprogram is like reading a road map with a soda straw [14]. Strategies help to solve this problem by expressing \nan important part of the control flow, namely the object navigation part, at a high level of ab- straction \nin a localized manner and not spread through many classes. The compilation problem for strategies is \nas follows: given a strategy S and a class graph G, generate a pro- gram in some object-oriented language \nwhich will per-form the correct traversals (specified by S) in the object graphs defined by G. A strategy \ngraph defines a %tan- dard traversal (depth-first, ordering specified by class graph) of object graphs. \nWhile the details of an efficient algorithm are non-trivial [22, 17, 211 the basic idea is to adapt the \nintersection algorithm for non-deterministic finite automata (NDFA). Both the strategy S and the class \ngraph G can be viewed as NDFAs for which we want to compute the intersection resulting in a third NDFA \nTG, called a traversal graph. Conceptually, to traverse an object graph 0, we need to compute the intersection \nof an NDFA corresponding to 0 and the NDFA TG. In the implementation we do something similar to the simulation \nof an NDFA to avoid the ex-ponential state explosion problem of expansion into a DFA. How can we write \nprograms using strategies? First, it should be noted that one of the key features of adap- tive programming \nstyle is the separation of structure from behavior specification. The structural aspect of an application \nis specified by a textual form of the ap- plication s UML class diagram. The specification of the behavior \nconsists of a set of traversal strategies and a set of tasks to be performed on the nodes encoun-tered \nduring the traversals. The behavior specified in this way is less brittle with respect to changes in \nthe structure of the application than behavior written in a standard object-oriented style. This is because \nthe be- havior specification is based on strategy graphs, rather than detailed class graphs. For this \nreason adaptive programs are also called strwkre-shy. Let us illustrate this brief introduction with \nthe sim- ple order processing application for hardware products written in Demeter/Javal [25, 161 style, \npresented in Fig. 6. Appl.cd is the textual representation of the ap- plication s (simplified) class \ndiagram, a graphical repre-sentation of which is also drawn in Fig. 7 (a) for clarity reasons. There \nis one equation in Appl.cd for each class in Fig. 6. The right hand side of the equation for a class \nC lists all adjacent classes of C in the class dia- gram, C,, along with the name of the link connecting \nC with C,. Thus, Quote = <prod> HWProduct . . . has to be read as, in the class diagram, there is an \nassociation named prod connecting classes Quote and HWProduct . In the second part of Fig. 6, Appl.beh \nlays down the behavior of the application. Note that there are no attribute (instance variable) declarations \nin AppLbeh, Demeter/.Java is the embodiment of Adaptive Programming in Java. Appl.cd Quote = <prod> \nHWProduct <quantity> int <cust> Customer. HWProduct = <price> float <salePrice> float <taxes> ListOf(Tax) \n<discountTable> DiscountTable. Tax = <percent> float <taxKind> String. Customer = <name> String. AppLbeb \n class HWProduct { float salePrice {return saleprice;}; float saleDiscount(int qty, Customer c) {return \n0; }; float regPrice0 {return price;}; float regDiscount(int qty. Customer c) {return discountTable.lookUp(qty);}; \nVector allTaxes { Vector all; to Tax { init {all = new VectorO; } at Tax {all.addElement((Object)taxKind);} \nreturn {return all;} } }  1 class Tax { float taxCharge(int qty, float unitprice, HWProduct p) {return \nunitPrice * percent/lOD};} class Quote { int quantity0 {return quantity; } } class Customer { float negProdPrice(HWProduct \np) { . . . }; float negProdDiscount(HWProduct p, int qty, Customer c) { . }; 1 class Main { static public \nvoid main(String args[]) throws Exception { Quote aQuote = Quote.parse(System.in); float 1: = aQuote.allTaxesO; \nSystem.out.println(\"Taxes\" + r); 1 Figure 6: Application Specification (4 (b) / HWPrnduct n..,,, b \nprod oricelssues J DiscountTable Figure 7: Application Class Diagram since the specification of the \nstructure is taken out of the classes and defined separately in Appl.cd. Classes in Appl.beh look pretty \nmuch like classes in a Java pro- gram. The only exception is the method allTaxes in HWProduct, which \nreturns a collection of all different kinds of taxes that apply for a HWProduct object. all-Taxes is \nan example of the so-called adaptive methods in Demeter/Java [16]. The method allTaxes involves traversing \npart of the object graph(s) that are defined by the class graph represented by Appl.cd. This travers-ing \nis specified in a succinct way in Appl.beh by means of the strategy specification to Tax . This definition \nhas to be read as starting from a HWProduct object, follow the links that lead to all its Tax subparts, \nand once at a Tax object, add the string describing the kind of the Tax object to the vector all . The \ndefinition includes no further details about the in- termediate nodes involved and the behavior performed \nat the intermediate nodes, since they only contribute traversal behavior passing the responsibility down \nto Tax. As the result of this succinct specification, the implementation of allTaxes can be reused without \nmod-ifications for the slightly modified class structure pre-sented in Fig 7 (b). This modification is \nrepresentative for the category of structural changes that might be per- formed to an application as \npart of a perfective mainte-nance process. This illustrates why adaptive programs are called structure-shy. \n3.2 Defining Structure-Generic Collabora- tive Behavior So far, we explained structure-shy behavior and \nnext we discuss structure-generic behavior. Being structure-shy is only a special case of being structure-generic. \nObviously, assumptions about the shape of the appli-cation s structure are made in a more robust manner \nin adaptive programs as compared to standard object-oriented programs, due to using strategy graphs rather \nthan embodying the exact shape of the class graph in the behavior implementation. However, the strategies \nare still written to a concrete class graph. This damages their adaptability. For instance, the program \nin AppLbeh in Fig. 6, can- not be reused with a class graph that names classes in a different way. In \ngeneral, if an adaptive program con-tains n strategies sl, sz, . . . . sn, written to the class graph \nC,, updating of C, to C , may require the updating of n strategies to make them select the right paths \nin C ,. This might reveal a lot of representation information. To remedy this situation the APPC construct \nuses the traversal strategy graph technology at a higher level of abstraction. An APPC is written to \na interface class graph rather than to a concrete class graph. An APPC has two parts: a interface class \ngraph and a behavior definition part. This is reflected in the syntactic struc-ture of APPCs in the grammar \nof Fig. 8l. The interface class graph of an APPC (ICG for short), declares the type of class graphs the \nAPPC can be used with. This type declaration consists itself of two sub-parts. The Structural-Interface \ndeclares (a) the par-ticipants in the collaboration, and (b) the pattern of their relationships, pretty \nmuch the same way the struc- ture of an application is specified in a structure-shy This is only a partial \ngrammar for the APPCs. A full-fledged grammar is left out, of the scope of this paper and can be retrieved \nfrom [3] adaptive program. In contrast to the class graph specifi- cation of a structure-shy adaptive \nprogram whose nodes and edges are concrete classes and link names in an a,pplication, the structural \ninterface of an APPC is de- clared by using formal names for both nodes and edges, called class-valued \nand link-valued variables, respectively. The Behavioral-Interface part of a ICG declares the signatures \nof operations that are required to be pro- vided by the participants in the collaboration. These operations \nare used (invoked) in the definition of the collaboration (Behavior-Definition part of the APPC), The \nbehavioral interface is organized as a collection of interface declarations, in general one interface \nfor each participant. Note that as with the structural interface, method names in the behavioral interface, \nare not con-crete method names of a particular application -. they are formal names, called method-valued \nvariables. Summarizing, the ICG of an APPC can be thought of as the textual specification of the UML \nclass diagram of an abstract application. The Behavior-Definition part of an APPC re-sembles an object-oriented \nprogram. The main part of it consists of behavior definitions (Participant-Behavioral-Entry in Fig. 8) \nfor all participants that play an active role in the collaboration, in general one for each of them. \nAs it can be noticed from the grammar in Fig. 8, a participant behavior definition resembles a class \nin an object-oriented program, in that it contains attribute and method definitions. In general, a participant \nbehav-ior definition is expected to be much more lightweight than a class, in the sense that it defines \nfewer behavior than a class generally does, This is because a partici- pant behavioral entry defines \nonly one role among sev-eral possible played by a class. Participant behavior is written to the ICG: \nmethods in a participant definition may invoke messages required in the interface of other participants \nalong links in the ICG. As with adaptive programming, participant roles may also be defined in terms \nof traversal strategies graphs and behaviors to be performed at their nodes. Traversal strategies used \nin an APPC are, however, specified to the interface class graph of the APPC rather than to a concrete \nclass graph. Furthermore, besides the partici- pant behavioral entries, the behavior definition part \nof an APPC may also define some auxiliary objects that are used in the definitions of the participants \n(called Workspace in Fig. 8). Similar to a Java program, an APPC also has a dis- tinguished method that \nserves as an entry point for invoking the collaboration defined by the APPC. An APPC is a slice of an \nadaptive program, implement-ing only one coherent design segment involving inter- APPCDef inition = \nInterface-Class-Graph Behavior-Definition Interface-Class-Graph Structural-Interface Behavioral-Interface \n= Structural-Interface Class-Graph-Specification = Behavioral-Interface = {Participant-Type}* Participant-Type \n0 Participant-Name { {Method-Signature}* } Method-Signature = Return-Type Method-Nama({Argument-Type \nArgument }*); Behavior-Definition = Workspace {Participant-Behavioral-Entry}* Workspace = {Class-Definition}* \nParticipant-Behavioral-Entry = {Variable-Definition}* {Method-Definition}* Method-Definition E Plain-Method-Definition \n) Inlined-Adaptive-Method-Definition Inlined-Adaptive-Method-Definition = {Variable-Declaration}* Traversal-Behavior-Specification \nTraversal-Behavior-Specification = [Init-Method] {At-Node-Behavior-Definition}+ [Return-Method] Figure \n8: Syntactic Structure of APPCs object collaborations. APPCs serve as the linguistic counterpart of design \nlevel collaboration diagrams for high-level, system operations extracted from use cases. The main method \nof an APPC then corresponds to the method defined by the collaboration diagram. It is part of the definition \nof one of the participants and lays down the overall flow of control of the collaboration, by eventually \ninitializing the workspace, invoking methods defined in the same or other participant behavioral en-tries, \nand returning a value. For illustration, an APPC that models the pricing component introduced in section \n2 is presented in Fig. 9. Comparing Fig. 9 with Fig. 2 and Fig. 3, it becomes clear that design artifacts \nare mapped to the elements of the APPC in a straightforward way. The interface class graph of the APPC \ncodifies the partial class dia- gram in Fig. 2. It states that there are five participants in the collaboration: \nLineltemParty, ItemParty, Charg-erParty, PricerParty and Customer. Also, it is assumed that there is \na way to get from e.g., LineltemPatty to ItemParty denoted by <item> in the scope of the APPC, etc. On \nthe other side, the behavior definition part is a codification of the collaboration diagram in Fig. 3. \nThe only active participant in the APPC in Fig. 9 is LineltemParty, whose behavioral entry contains the \nmain entry of the collaboration, price(). The other participants contribute passively by providing services \nto the LineltemParty role. LineltemParty is a client of the expected interface of PricerParty: price0 \ninvokes ba-sicPrice() and discount0 on its assumed pricer subpart. These operations are declared in the \nexpected interface for PricerParty, which means that in any concrete ap-plication to work with the APPC, \nwhatever class will be assigned to play the PricerParty role must provide implementations for these operations. \nIn addition to the main entry, an auxiliary method, additionalcharges, is defined to calculate additional \ncharges to be added to the computed price. Based on the collab- oration diagram in Fig. 3, calculating \ncharges involves the direct participation of ChargerParty with its cost functionality; besides that, \ncalculating the additional charges, involves the indirect participation of ItemParty. ItemParty only \ncontributes traversal behavior by pass- ing the responsibility for calculating additionalcharges to ChargerParty. \nThis flow of control is expressed within the definition of additionalcharges by means of a traver- sal \nstrategy. The computation of additionalcharges is itself a (mini) collaboration which is nested within \nPricing. This col-laboration has a slightly different flavor: it happens during a traversal of some part \nof the object structure. We call such collaborations, traversal driven. They are modeled after a generalized \nform of adaptive methods of Demeter/Java. While in this particular example, the traversal driven collaboration \nhappens to be inlined in a non-traversal driven collaboration, in general they may exist as first-class \nAPPCs. The participants in a traver- sal driven APPC and the partial control flow among them are specified \nby means of a strategy graph - from LineltemParty via itemlnst: ItemParty to ChargerParty . In addition, \na set of tasks to be performed at each node of the strategy graph are specified. Only impor-tant tasks \nare mentioned, i.e., those that contribute non-traversal behavior to the overall task (a single task \nto be performed when at ChargerParty, in this case). Given a concrete class graph and the strategy, the \ncode for performing the traversal and for executing the spec- ified tasks at each node will be generated. \nThis makes the definition of additionalcharges adaptive to several different structures of concrete paths \nconnecting what-ever classes will play the LineltemParty, ItemParty and ChargerParty roles in a concrete \napplication. As indicated both by the grammar for Inlined-Adaptive-Methods in Fig. 8 and the definition \nof additionalcharges in Fig. 9, the specification of traversal driven collab-orations differs in two \nways from the specification of 'PC Pricing { Interface Class Graph: // structural interface LineItemParty \n= <item> ItemParty <pricer> PricerParty <customer> Customer ItemParty = <charges> ListOf(ChargerParty) \n// behavioral interface LineItemParty { int quantityo;} PricerParty { float basicPrice(ItemParty item); \n float discount(ItemParty item, int qty, Customer customer); } ChargerParty { float cost(int qty, float \nunitP, ItemParty item);} Behavior Definition: LineItemParty { main-entry float price(){ float basicprice, \nunitprice; int discount, qty; qty = this.quantity(); basicprice = pricer.basicPrice(item); discount \n= pricsr.discount(item, qty, customer); unitPrice = basicprice -(discount * basicprice); return (unitprice \n+ additionalCharges(unitPrice, qty)); } private float additionalCharges(f1oa.t unitP, int qty) { float \ntotal; from LineItemParty via itemInst: ItemParty to ChargerParty { init {total = 0; } at ChargerParty \n{total += costcqty, unitP, itemInst); } } return {total;} } Figure 9: The Pricing APPC %orma; collaborations. \nFirst, they have distinguished methods for initializing their working space (init) as well as for returning \ntheir result (return). Second, traversal driven collaborations do not have a main entry method. Both \nthese differences are due to the fact that these col- laborations are driven by the (generated) traversal \ncode -this is their main entry. Recall that initializing the workspace and returning a value was inlined \nin the dis- tinguished main entry of the non-traversal driven col-laborations. With the traversal driven \ncollaborations, however, the main entry is not explicit. That is why we need to put the code for initializing \nthe workspace and for returning the result of the collaboration in dis- tinguished methods, that are \nknown to the generated traversal code and are called in the appropriate place during the traversal. Besides \ncontrol flow, a strategy graph may also spec- ify how data should be propagated during a traversal. An \ninstance name associated with a strategy node is an indication that during the traversal of the object \ngraph, instances of that node should be passed further down as parameters of the traversal method. In \nthe strategy used in additionalcharges in Fig. 9, itemlnst associated with ItemParty indicates that each \ntime the traversal reaches an object of type ItemParty, this object will be passed down the traversal \nof the remaining object struc-t,ure still to be traversed. In this way, the implementa- t,ion of the \ntask to be performed at a ChargerParty, cp, can access the ItemParty instance, itemlnst, containing CP. \n 3.3 Instantiating Collaborative Behavior An APPC specifies an abstract collaboration. In order to turn \nit into executable code, a concrete application must be provided that implements the interface class \ngraph of the APPC. Binding an application, appl, to the ICG of an APPC, appc, is also referred to as \ninstan- tiating the APPC with the application and denoted by the operation ::+. The first issue in instantiating \nan APPC with an ap- plication is to map ingredients in the APPC s interface class graph, i.e., (a) participant \nnames, (b) their as-sumed relations, and (c) assumed operation names, to corresponding elements in the \napplication, i.e., classes, paths, and operation names, respectively. While (a) and (c) are realized \nby simple name maps, (b) requires, in the general case, explicit mapping of edges in the ICG to strategies \nover the CCG. Given a participant-to-class name map, N, and as-suming that the CCG is a valid implementation \nof ICG (see the ICG-CCG conformance definition below), there is always a default mapping of edges in \nICG to paths in CCG. For any edge e = (VI, VZ) in ICG, the default mapping is the set of paths in CCG \nfrom N(vl) to N(v~), denoted as Paths[CCG](N(ul), N(Q)). Based on the ICG-CCG conformance definition \nbelow, this path set is not empty. There might be, however, cases where the default mapping of ICG edges \nto CCG paths does not suffice. For instance, in dense class graphs we might want to reduce the cardinality \nof the default path set, or, in general, we may want some fancy mappings other than those provided per \ndefault. In these cases, the programmer can explicitly map ICG edges to concrete traversal strategies \nover the CCG. To illustrate the mapping process, in Fig. 10, we ap- ply the Pricing APPC to the concrete \napplication that was presented in Fig. 6 (denoted by HWAppl in Fig. lo), for modeling two pricing schemes, \nRegular and Negoti- ated, discussed in Sec. 2. The regular scheme implies that the role of PricerParty \nis played by the class that models the products being ordered, HWProduct in our case. On the other side, \napplying the negotiated scheme means that the PricerParty role is played by the class that models customers, \nCustomer in our case. HWAppl::+ {float regularPrice = Pricing with { LineItemParty = Quote; PriceParty \n= HWProduct {basicprice = ragPrice; discount = regDiscount}; ItemParty = HWProduct; ChargerParty = Tax \n{cost = taxcharge};} } HWAppl::+ {float negotiatedPrice = Pricing with { LineItemParty = Quote; PriceParty \n= Customer {basicprice = negProdPrice; discount = negProdDiscount}; ItemParty = HWProduct ; ChargerParty \n= Tax {cost = taxcharge};}} Figure 10: Instantiating the Pricing Collaboration Consequently, the APPC \nneeds to be applied twice, each time with a different mapping of roles to classes and method-valued variables \nto actual operation names. Note that in both cases, mapping participant to class names is sufficient \nfor generating paths in the applica- tion that correspond to edges in the APPC. No actual strategies \nare required for realizing this mapping; there is a single mapping from relations between the partic- \nipants in the generic collaboration to relationships be- tween the corresponding classes in the application. \nOnce a mapping of an ICG to a CCG is given, it should be checked whether the CCG does actually im-plement \n(we also say conform to, or specialize) the ICG. Conformance checking includes (a) checking whether the \nrelation pattern between the participants specified in ICG can be matched by the relations between cor-responding \nclasses in CCG, and (b) checking signature compatibility among the assumed operations in the APPC and \nthe corresponding implementation methods in the application. For (a), we require the following to hold \n. Definition: CCG-ICG conformance Given node-labeled graphs G1 =(Vl,El) and G2 =(Vz,Ez) and a name map \nN: Vz + VI, G1 conforms to G2 u V e = (e,, et) E El, 3 p E Paths[G2](N(e,), N(et)) The intuition is that \neach edge of the ICG defines a path in the class graph. This means that the inter-face matches the class \ngraph in terms of paths; we can embed the paths in the ICG in the paths in the class graph. We use the \nconformance concept in two stages. At the adaptive level we check that the ICG conforms to each strategy \n(graph) specified in the be-havior definition part of an APPC. At the instantiation level we check that \nthe concrete class graph conforms to the interface class graph. Assuming that an application, appl, conforms \nto the interface of an APPC, appc, conceptually, the result of instantiating appc with appl is an enhanced \napplica-tion gained by adding the participant behavioral de&#38; nitions of appc onto the corresponding \nclasses in appl. The implementation of the added methods is automati- cally generated from the behavior \ndefinition part of the APPC by (a) replacing participant names with the class names they are mapped to, \n(b) replacing edges from the APPC with the concrete paths they are expanded by in the class structure, \nand (c) replacing formal method names in the APPC code with the application s method names they are mapped \nto. In addition, traversal code as well as code for calling role implementations during traversals will \nbe generated, if there are traversal strat-egy specifications involved in the implementation of the APPC. \nFor giving the reader an intuition of what an APPC instantiation produces, pseudo-generated code for \nthe instantiations in Fig. 10 is given in Fig. 11. The pseudo- generated code indicates that the generator \nengine would map collaborations down to objects; there is one class The condition can be checked in polynomial \ntime. Further details of this checking are out of the scope of this paper. generated for each pricing \nscheme instantiated in Fig. 10, RegularPrice and NegotiatedPrice. Furthermore, a method for each scheme, \nregularPrice(), respectively negotiated-Price0 is added onto the application class Quote. These methods \nsimply create a collaboration object and del- egate the responsibility to it. They are inserted in Quote \nbecause Quote is mapped to LineltemParty participant where the main method of the collaboration was de-fined. \nThe generated methods can be invoked by other collaborations that build on top of Pricing, as it will \nbe illustrated in the following section. class quote { // . . . as before . . . public float regularPrice \n{ RegularPrice rp = new RegularPricecqty, this); return rp.priceO; } public float negotiatedPrice { . \n. . } class RegularPrice { public RegularPrice(int quantity, Duote hst) { host = hst; qty = quantity; \nprod = pricer = host.getProduct(); cust = host.getCustomerO; } public float price0 { float basicprice, \nquoteprice, unitPrice; basicprice = pricer.regPriceO; int disc = pricer.regDiscount(prod, qty, cust); \nunitPrice = basicprice -(disc * basicprice); return (unitprice + additionalCharges(unitPrice, qty); private \nfloat additionalCharges(float unitprice, int qty) { float total = 0; Enumeration taxes = pricer.getTaxes(); \nwhile (taxes.hasElementsO) { Tax tax = taxes.nextElement(); total += tax.taxCharge(unitPrice, qty); } \n> private Quote host; private int qty; private HWProduct pricer; private HWProduct prod; private Cust \ncustomer; 1 class NegotiatedPrice { . . . ) Figure 11: Pseudo-Code Generated for Regular Pricing This \nimplementation is rather naive. First, it as-sumes that the application is available in source code and \nthat recompilation can be performed at any time, both unrealistic and undesirable assumptions in many \nreal situations. Second, putting collaborations in a sin- gle class in the generated code is against \nthe object-oriented spirit. However, while this is the approach currently taken, it should be noticed \nthat the way AP- PCs are mapped down to object-oriented code is an implementation detail that has nothing \nto do with the concept. We are already working on a better generator engine in Java organizing the collaborations \nin separate Java packages. Apart of the few implementation details discussed above, at the conceptual \nlevel, the sample instantia-tions above demonstrates how the APPC construct al-lows us to write collaborative \nsoftware that (a) adapts itself to the concrete shape of particular applications, and that (b) can be \nreused with different participant-to-class mappings over the same application. In other words, it illustrates \nthat APPCs satisfy RI.  3.4 Composing Collaborative Behavior As indicated in Sec. 2, we give APPCs \na mixin [2] flavor, in order to allow for more flexible white-box composi-tion. A mixin-flavored APPC \ndefines collaborative be-havior in terms of a super component which is, however, not bound at component \ndefinition time. The super-component parameter will be bound later, at compo-nent composition time. Consider, \nfor instance, how both special pricing poli-cies, AgingPricing and FrequentCustomerPricing discussed \nin Sec. 2, can be defined as deltas to the Pricing APPC. Both policies share the same refinement pattern: \nfirst, the price is calculated and then a reduction on that price is computed based on a certain criteria \nthat is specific for each policy. This common pattern is factored out in the SpecialPricing APPC in Fig. \n12 which is specified to be a modification of Pricing. Both AgingPricing and FrequentCustomerPricing \nfurther modify SpecialPricing, each implementing reducedprice in a specific way. The modifies relationship \nbetween APPCs resembles the inheritance relationship between classes. A modi- fication APPC inherits \nthe interface and behavior def-inition of the APPC it modifies, while refining the be- havior definition \nby making super calls. So far, the su-per parameter of a modification APPC resembles the super parameter \nof Smalltalk/Java subclasses. There is, however, an important difference: in contrast to in- heritance, \nthe modifies relationship does not imply any composition structure between APPC. Declaring that SpecialPricing \nmodifies Pricing does not mean that the super parameter in the definition of SpecialPricing is fixed \nto Pricing. The super parameter will be rather bound at composition time. That is, the modifies relation \ndoes not compose the APPCs. The composition is a separate operation that is explicitly applied to the \nAPPCs after they have been defined. In the following, this operation is denoted by +. It is non- commutative, \nsince the order of applying the operation establishes the bindings of the super parameters of the APPCs \ninvolved. The super parameter of the compo- APPC SpecialPricing modifies Pricing { Behavior-Definition: \nLineItemParty { public float price0 { float calcPrice = super.priceO; return reducadPrice(calcPrice1; \n} protected float reducedPrice(float calcPrice); } 1 APPC AgingPricing modifies SpecialPricing { Interface-Class-Graph: \n//more behavioral interface ItemParty {Time stockTime(); Time stockTimeLimit0; } Behavior Definition: \nLineItemParty { protected float reducedPrice(float calcprice) { float newPrice = calcprice; if (item.stockTime()>item.stockTimeLimit()) \n{ newPrice = newPrice -(newPrice * 0.1); } return newPrice; } } > APPC FrequentCustomerPricing modifies \nSpecialPricing { Interface-Class-Graph: //more behavioral interface Customer {boolean frequento; BuyHistory \ngetBuyHistory0;) Behavior Definition: LineItemParty { protected float reducedPrice(float calcPrice) { \nfloat newPrice = calcprice; if (customer.frequentO) { BuyHistory hist = customer.getBuyHistoryO; float \nfreqRed = item.frequentReduct(hist.1; newPrice = newPrice + freqRed; } return newPrice; } } ItemParty \n{ float frequentReduct(BuyHistory hist) { // given hist calculate reduction } } I Figure 12: Refining \nthe Pricing Collaboration nent on the left hand side of the operation is bound to the component on the \nright hand side. Dispite this difference in the semantics, we have preferred to use the Java/Smalltalk \nkeyword, super, in the definition of modification APPCs, for the intuition related to it. For illustration, \ntwo different compositions of the pricing APPCs from Fig. 12, AgingPolicy and AgingAnd-FrequentCustomerPolicy \nare given in Fig. 13. Both com-positions contain an AgingDelta = AgingPricing + Spe-cialpricing. However, \nthe meaning of the super-call in the SpecialPricing part of AgingDelta is different in each case: in \nAgingPolicy it denotes Pricing, while in Agin-gAndFrequentCustomerPolicy it denotes the SpecialPric-ing \npart of FrequentCustomerDelta. With standard in-heritance, the meaning of super in SpecialPricing would \nhave been fixed to Pricing at definition time. With com-position time binding, we are given more flexibility \nin reusing APPCs with different compositions. This composition time binding of super has the fla- vor \nof super binding with the mixin-based inheritance. However, the semantics of composing mixin-flavored \nAP-PCs differs from that of composing mixins, as well. While not binding their super parameter at definition \ntime, mixin-flavored APPCs declare their expected spe-cialization interface at that time, via the modifies \nrela-tion, a feature that mixins do not have. This declara-tion makes it possible to write the collaboration \nin the refinement APPC to the interface of the base APPC (and possible extensions of it). More importantly, \nthe declaration of the specialization interface controls the scope of the definitions from individual \nAPPCs within a composition, as outlined in the rules below. Let A be an APPC and Al and A2 be modifications \nof it. Let A, = Al + A2 + A. The modifies relation imposes the following: 1. Let m be a method implemented \nin A, Al, and A*. The implementations of m in both Al and A2 refine the implementation in A (by making \nsuper calls). The definition of m in A, consists then of the chain of definitions in Al, A*, and A, i.e., \nwhen m is invoked all three definitions are executed in the order mentioned above. This is because m \nis in the specialization interface of A, the common parent component for both Al and AZ. Thus, it is \nnatural to require that both refinements are valid and should be executed. 2. Let m be implemented in \nAl and AZ, but not in A. Since Al and Az assume the specialization inter-face of A and not that of each \nother, and since A does not have m in its specialization interface, both definitions of m in Al and A2 \nshould be invisible to the other component. A, has two definitions of m and the invocation of m on A, \nreturns, in general, a wrapper object containing both results.  To illustrate the meaning of these rules \nand their role in maintaining the encapsulation of individual AP-PCs involved in a white-box composition, \nassume A, = AgingAndFrequentCustomerPolicy, i.e., Al = AgingDelta, A2 = FrequentCustomerDelta, and A \n= Pricing. Assume that after the application has been enhanced with the AgingAndFrequentCustomerPoIicy \ncollaboration price0 gets invoked on a LineltemParty object. the chain of method executions resulting \nfrom this invocation will be as fol- lows. Based on rule 1, all three implementations of price get successively \nexecuted since price is in the special-ization interface of Pricing and is refined in both Ag-ingDelta \nand FrequentCustomerDelta. The implementa-tion of price in AgingDelta will be executed first. The super \ncall in AgingDelta::price() invokes FrequentCus-tomerDelta::price. The latter will invoke the implemen- \nAgingPolicy = AgingDelta + Pricing * modifies AgingDelta = AgingPridng + SpedalPridng + super b invokes \nI A@n@dta / MW dlc~ / v Agingi)dts. FrequentCustomerDdta AgingAndFbquentCustomerPollcy = AgIngDelta \n+ FkequentCustomerDelta + Prldng FrequentCustomerDelta = FkequentCustomerPrldng + SpecialRidng Figure \n13: White-Box tation of price in Pricing. After Pricing::price() returns, FrequentCustomerDelta::price() \ninvokes reducedprice. Although, there are two implementations of reduced-Price in the definition of the \nreceiver, the implemen-tation of FrequentCustomerDelta has visibility only for its own definition (rule \n2), i.e., only the frequent cus-tomer reduction will be executed. After the execu-tion of FrequentCustomerDelta::price() \nreturns, the ex-ecution of AgingDelta::price() resumes by executing its own implementation of reducedprice. \nAlthough present within the definition of the same object, the definitions of reducedprice do not collide \ndue to their well-defined scopes established by the modifies relationships between AgingDelta, FrequentCustomerDelta, \nand Pricing. The same definitions would collide in a framework-based im-plementation, since there are \nno scoping boundaries be-tween the definitions of different classes involved in the definition of an \nobject. Thus, the white-box composition supported by AP- PCs satisfies the Rz requirement we posed in \nSec. 2. Composition-time binding of super keeps the coupling of APPCs loose: there are no commitments \nto a par- ticular composition structure in the implementation of a modification APPC. This is in contrast \nto the frame- work based composition we discussed in Sec. 2. While borrowing this feature from mixins, \nAPPCs are more Composition of APPCs disciplined with regard to scope issues, due to their definition-time \ndeclarations of the modification relation-ships. This maintains the encapsulation of the AP-PCs when \nthey get involved in a white-box composition and avoids name conflicts problems we indicated for the \nframework based approach. Let us now consider how APPCs are composed into higher-level collaborations \nout being strongly coupled pled black-box composition in the proposed design. fine collaborative behavior \nto a concrete class graph. in a black-box manner with-to each other. Loosely cou-is automatically supported \nThis is because APPCs de-to an interface, rather than As already discussed, the behavior definition part \nof an APPC uses operations declared in the behavioral part of its interface without committing to a particular \nimplementation of these op- erations. The actual implementation, which is bound to the interface operations \nat APPC instantiation time, may be one generated by instantiating another APPC. It is at this point that \nthe APPC that uses the opera- tion gets composed with the APPC that generates the implementation; the \ncomposition is uncoupled since the implementation of the client APPC does not explicitly mention the \nsupplier APPC. Consider for illustration the Total APPC in Fig. 14 which is defined as a collaboration \nbetween two partic-ipants: an OrderParty and a set of LineltemParty con-tained in it. The collaboration \nhappens during travers-ing from an OrderParty to all LineltemParty objects con-tained in it (collaboration \ndriven APPC). Once at a LineltemParty, the result of invoking price is added to the total calculated \nso far. APPCTotal { Interface-Class-Graph: OrderParty = <customer> Customer <lineItems> SetOf(LineItemParty) \nLineItemParty { float price0; } Behavior-Definition: float total; from OrderParty to LineItemParty { \ninit {total = 0 }; at LineItemParty {total += price();} return { total }; } } Figure 14: Defining the \nTotal Collaboration Total merely assumes that LineltemParty provides an price operation without committing \nto any particular implementation of it. Even the name of the actual method that eventually will serve \nas the implementa-tion of price in whatever class will play the LineltemParty role in a concrete application \nmay be different. Given the definition of Total in Fig. 14, we can now create col- laborations for computing \nthe total regular, negotiated, aging, or frequent customer price, by simply plugging in the method generated \nby the respective component as the implementation for price in the interface of Total. For illustration, \ninstantiating the Total APPC for a reg- ular pricing scheme is given in Fig. 15. We assume that the example \napplication we have used so far (Fig. 6) has an additional class called Order for modeling orders of \nhardware products. In Fig. 15, the regularprice method which was added to Quote by the instantiation \nof Pric-ing in Fig. 10 is bound to the operation price assumed in the interface of LineltemParty. In \nthis way, the example illustrates how APPCs can serve as building blocks for higher-level collaborations. \nHWAppl ::+ {float totalbg = Total with { OrderParty = Order; LineItemParty = Quote {price = regularprice}; \n} ) Figure 15: Instantiating Total 4 Implementation Issues So far, for the most part, APPCs are simulated \nin Deme- ter/Java; a code generator translates high-level descrip-tions of collaborative behavior from \nAPPCs into stan-dard object-oriented implementations based on visitor objects [5]. In abstract terms, \nthe workings of the gen- erator for the case where no white-box compositions of APPCs are involved is \ndescribed by the following steps: l Create a visitor class for the component(s) being instantiated. Different \nvisitor classes will be cre- ated for different instantiations of the same com- ponent with different \nmappings of participants to concrete classes. For instance, there will be dif- ferent visitor classes \ncreated for different pricing schemes of the running example. l If link-valued paths are used in the \ndefinition of a component, replace them with the corresponding concrete paths in the graph resulting \nfrom apply-ing the concrete strategies to the concrete class structure. Generate the needed code to traverse \nthe paths in all nodes involved in the paths. l Generate code in the application class structure for \nthe main entry method of the APPCs. This is re- sponsible for initiating the collaboration by creat- \ning and passing the responsibility to the appropri- ate visitors (recall negotiatedprice and regularprice \ngenerated in Quote in the sample generated code in Fig. 11). Furthermore, code for traversing the object \nstructure, and delegating the responsibil-ity to the created visitors during the traversal is also generated \nin the application class structure for traversal driven APPCs. As far as the above functionality is \nconcerned, the existing generator technology of Demeter/Java [25, 161 can be reused with some small modifications \nto arrange for the fact that APPCs are more generic than Deme-ter/Java software (visitors) as well as \nfor syntactic mod-ifications associated with the introduction of APPCs. As mentioned in conjunction with \nthe presentation of strategies, polynomial compilation algorithms exist for Adaptive Programming. They \nare at the core of Deme- ter/Java and are thus simply reused in the implementa- tion of APPCs. Details \nabout compilation of strategies can be found in [22, 17, 211. The question remains how to realize the \nflexible com-ponent composition mechanism discussed above. As mentioned earlier, the mixin-like composition \nof AP-PCs is inspired by a similar composition of classes in the RONDO model [20]. Unfortunately, there \nare no such mechanisms in Java that could be immediately ap-plied to compose the visitor classes generated \nfrom the individual APPCs. We have worked around the prob- lem within the same visitor-based framework \ndescribed above. When compositions are involved, issues related to maintaining the control flow among \nthe visitors gen-erated by the individual APPCs need to be considered. We assign the responsibility of \nmaintaining the con-trol flow among the individual APPCs in a composi- tion to a visitor-composer object. \nThis is an instance of the predefined class Visitor-Composer and it is cre-ated and initialized with \nthe visitors to be composed. A Visitor-Composer maintains a list of visitors to be ex- ecuted one after \nthe other as well as their relations. The composer object plays the role of a script object for connecting \nthe elementary components. The struc-ture of the script is derived from the composition state-ments. \nIn other words, the composer object in the case of our example will encode the relationships illustrated \nin Fig. 13. While composer objects are created individ- ually for each composition statement, the functional-ity \nfor interpreting the script they encapsulate is im- plemented in the predefined class VisitorComposer. \nIt should be noticed that composers do not have them- selves any application functionality. They simply \nknow how to control the flow among other visitors, given the structure of their composition. The implementation \nissues discussed in this section can be summarized as follows. Instead of letting the programmer figure \nout how to use the visitor pattern for expressing collaborative behavior and then encode the pattern \nseveral times (e.g., for several pricing schemes), we let the generator do the work. The primary mo-tivation \nbehind this is actually not necessarily to ease the work of the programmer. The main goal is rather the \nresulting increase of adaptability, reusability, under-standability, and the decrease of maintenance \ncosts. Note that mapping APPCs down to visitor objects is an implementation detail. It is rather a compro-mise \nthat allows us an easy reuse of the existing Deme-ter/Java technology. Visitor objects has been preferred \nover parameterized classes as in some related approaches [28, 241, even though visitor objects might \nbe less effi- cient than inlining code. This is because by mapping collaborations down to visitor objects, \ninstead of inlin- ing code, they can be shared by several parts of a class structure. More importantly, \nthe same visitor classes can be shared to create different compositions. The ad- vantages are twofold: \nboth code explosion and name conflicts, characteristic for template based approaches, are avoided. As \nalready indicated, the implementation sketched here is rather naive. It assumes that the source code \nof the application is available and lack an object-oriented organization of the generated code. However, \nthis is only a first implementation and we are currently work-ing on an enhanced implementation translating \nAPPCs to Java packages. In this implementation, the applica- tion and the code generated for the APPCs \nwill be put in different packages with the latter importing from the former. In this implementation, \nthe mini-language for instantiating APPCs plays the role of a module linking language. 5 Related Work \n The Visitor pattern was proposed in [5] as an idiom for expressing collaborative behavior in standard \nobject-oriented models. The essence of the pattern consists in encapsulating a task to be performed on \nan ob-ject structure within a visitor object. The interface of the visitor object consists of a set of \noperations -one for each class in the basic class structure to be vis- ited. In order to allow for future \nvisits, classes in the basic structure implement an accept operation. The ac-cept operation of a class \nC, expects a visitor object as a parameter and sends a message to this visitor to in-voke the visitor \ns method for C, generally named visitC. There are several problems with applying the visitor pattern \nfor coding collaborative-based designs: 1. As noted in [5, 25, 201, the pattern is applicable only when \nthe base class structure to be visited does not change and when there are not very many additions of \nnew concrete element classes. 2. Visitors make strong commitments to the particu- lar class structure \nthey are supposed to visit. This unnecessarily hinders the reuse of collaborative be-haviors that might \nbe generic enough to be applied to a range of different class structures. 3. Variations in visiting \nbehavior are not properly supported, because the mechanism for supporting variations is inheritance, \nwhich performs rather poorly when a great number of variations of a ba- sic functionality (or combinations \nof those) are to be supported [20].  Other approaches, such as the work by VanHilst and Notkin [28], \nand the work by Smaragdakis and Batory [24], similarly recognize the need for constructs to sup- port \ncollaboration-based design, and show how to use existing language mechanisms such as template classes \nfor this purpose. In [28], roles of classes are imple-mented by means of template classes, where the \nsu-perclass is made a parameter of the role, as illustrated below: template <class Super> class Role \n:public Super{. . . role implementation... }; In addition to the superclass, a role (template class) \nis also parameterized with the other roles, played by other classes within the same collaboration. For \nin-stance, the role of the class Kz in the collaboration Cd in Fig. 1 would be expressed as follows: \ntemplate <class RoleSuper, class K1,4, class Ks,~> class K~,J: public Role&#38;per {... role implementation \nusing K1,4 and KS,* . . }; This approach has a scalability problem [24]. Com-posing the template classes \nresults in long and com-plicated template instantiation statements even for rel- atively small examples. \nThere is no syntax for the collaboration entity. This is implicitly encoded in the parameter-relationships \nbetween the roles of the classes contributing to the same collaboration. The program-mer has to explicitly \nkeep track of the collaborations in which a class participates. For instance, the K1,4 in Fig. 1 must \nbe explicitly parameterized with K1,2 - there is no way the programmer can ignore the fact that KI is \nnot involved in Cs. As indicated in [24], the length of parameterization expressions increases exponentially \nwith the number of different roles for a class. In the mix&#38;-layers approach, these problems are taken \ninto account by implementing collaborations as mixins (outer mixins) that encapsulate other mixins (inner \nmixins). An outer mixin is called a mixin layer. The super-parameter is specified at the level of a mixin- \nlayer (collaboration). By explicitly representing col-laborations as mixin layers and by defining the \nsuper- parameter at the level of collaborations, this approach provides for a much better organization \nof the code and addresses the scalability problems of the work by Van- Hilst and Notkin. In [24], a possible \nrealization of the general concept of a mixin layer by using C++ param-eterized inheritance and nested \nclasses is presented. A mixin-layer is conceptually similar to a visitor class. However, mixin-layers \nare reusable and inter-changeable, which is not true for visitor classes. A sin- gle layer can be used \nin several different compositions and is, to an extent, isolated from other layers. How-ever, more complex \ncombinations of collaborations that contain more than one refinement of the same base col- laboration \nare not considered in [24]. As stated by Hol- land [9], neither inheritance nor parameterization fully \nsupport the desired features of a composition mecha- nism listed in Sec. 2. Furtherm ore, mix&#38;layers \nare not structure-generic. Both the solution based on the visitor pattern and the solutions based on \ntemplate classes are only idioms to be used to be used to resolve certain non-functional forces. However, \npatterns and idioms are cover-ups and not principal solutions to the problems they cover. The principal \nsolution implies turning idioms into language features. Concerning the expression of collaborative be- \nhavior, the principal solution is the design of large-scale components, such as APPCs, that directly \nsupport cod- ing the collaborations captured by use cases, collabora- tion diagrams and other similar \nartifacts available dur- ing analysis and design in many design methodologies. Holland also proposes \na language construct for ex-pressing collaborations called Contracts [9]. Both Con-tracts and APPCs aim \nat making the collaboration pat-terns between classes involved in an application explicit by means of \nhigher-level constructs that go beyond classes APPCs and Contracts are themselves the building blocks \nof an application. Given a partly implemented applica-tion, with a given structure and some low-level \nbehavior for accessing this structure, Contracts and APPCs fill it with additional behavior. Like APPCs, \ncontracts make explicit (a) classes involved in a collaboration, and (b) the subset of instance variables, \nmethod interfaces and implementations provided by each class for this collab-oration. However, APPCs \nare superior as compared to Con- tracts. First, due to the use of interface class graphs, APPCs provide \nan elegant and effective way for specify- ing the collaboration pattern of a task, which is missing in \ncontracts. As a result, the definition of a collab-oration as well as the instantiation of it for concrete \napplications is more elegant and succinct. More impor- tantly, in contrast to contracts APPCs are structure-shy. \nSecond, the composition mechanism used with APPCs is more powerful. Holland uses frameworks as the basic \ncomposition mechanism combined with lenses to avoid name conflicts when conflicting collaborations are \ninvolved in the same application. Lenses are meta- objects that keep track of the current active collabo-ration \namong conflicting collaborations. Before each collaboration is executed, an appropriately initialized \nlense-object needs to be enabled. After a collaboration is executed, the current lense-object must be \ndisabled to allow the execution of other collaborations. In this way, only one collaboration can execute \nat a time. More im- portantly, as indicated in [28], using frameworks makes contracts less reusable. \nRelated to APPCs is the work on Subject-Oriented Programming (SOP) [6]. A subject is a collection of \nclass fragments whose class graph models its domain in its own subjective way. Subject composition com-bines \nsubjects to produce new higher-level subjects. A subject has an affinity to APPCs. While a subject deals \nwith class fragments, an APPC deals with class-valued variables which are mapped later onto class frag- \nments automatically generating the necessary glue code. While a subject has to deal with all involved \nclass frag- ments explicitly, an APPC only talks about the im-portant class-valued variables. After the \nmapping to classes, code will be generated automatically for the less important classes based on the \ninformation in the traversal strategies and the class graph. We believe that traversal strategies simplify \nthe composition rules for SOP and that composition of APPCs can benefit from the composition ideas already \ndeveloped for SOP. Furthermore, the work presented here is related to the ongoing research on Aspect-Oriented \nProgramming (AOP) [13]. Aspect-oriented programs are specified by collaborating building blocks, each \none addressing a dif- ferent concern of the application. The main goal is to minimize dependencies between \nthe building blocks, so that modifications in one building block has a minimum impact on the other building \nblocks. APPCs seem to be useful building blocks for aspect-oriented program-ming within the object-oriented \nparadigm, since they are designed to support minimizing tangling between class collaborations and between \nclass collaborations and class graphs. The importance of supporting collaboration diagrams beyond the \ndesign phase has been recognized also by companies specializing in software development tools. Structure \nBuilder from Tendril Inc. (www.tendril.com), supports turning interaction diagrams into executable code, \nhowever in a non-adaptive way. Structure Builder also facilitates object transportation in a similar \nway as APPCs. Finally, component technologies such as Corba, COM and JavaBeans offer good facilities \nto describe compo-nents but there is not much help in making the collabo- rations explicit or for making \nindependent components adaptable to a range of applications and for composing them together in complex \nways. Conclusions In this paper, we proposed components for express-ing collaborative behavior in object-oriented \nprograms, called Adaptive Plug and Play Components (APPC). Adaptability is achieved by making the class \ngraph of applications a formal parameter of the APPCs. The col- laborations are written to this formal \nparameter rather than to a concrete application. On the other hand, AP-PCs are components with a mixin \nflavor, in that they define collaborative behavior in terms of parent com-ponents that are left unbound \nat component definition time. In this way, APPCs do not make any implicit commitment to a particular \nstructure of composition, resulting in better reuse. We demonstrated the benefits of APPCs by means of \na simple example. However, we are confident that sim-ilar results can be reported for more complex applica-tions. \nOur confidence is supported by the fact that AP-PCs were born within the well-developed Demeter/Java \ntechnology. The results with Demeter/Java have been very encouraging in several commercial projects (see \n131). We expect that the enhancements provided by APPCs will lead to even larger productivity. The design \nof the APPCs is only the first step in a research path we intend to follow. First, as already indicated, \nwe are working on separate compilation of APPCs, which requires some considerations on how to organize \ncode generation for APPCs. In a more general context, design tradeoffs in the implementation of an adaptive \nsoftware engineering system will be an area of future work. It is of interest to investigate the design \nof a package facility for APPCs collecting several APPCs, e.g., encoding collaboration diagrams from \nthe same use case. These APPC packages can be mapped down to modules of the underlying languages (e.g., \nJava Pack- ages). Another interesting area of future work is to de- velop a methodology for translating \nuse cases from the analysis to APPC packages and evaluate the adaptive software engineering system in \nreal applications. Acknowledgements Thanks go to the Demeter Seminar participants, espe-cially M. Wand, \nD. Orleans, J. Ovlinger, G. Hulten and L. Bland0 for being a sounding board for the ideas pre- sented \nin the paper, and to Y. Smaragdakis for his feed- back both on strategies and his work with D. Batory \non mixin layers and their relationship to APPCs. Es-pecially, D. Orleans and J. Ovlinger provided valuable \nideas that went into this paper. This work has been partially supported by the De- fense Advanced Projects \nAgency (DARPA), and Rome Laboratory, under agreement number F30602-96-2-0239. The views and conclusions \nherein are those of the au-thors and should not be interpreted as necessarily rep-resenting the official \npolicies or endorsements, either ex-pressed or implied, of the Defense Advanced Research Projects Agency, \nRome Laboratory or the U.S. Govern- ment . References [l] K. Beck and W. Cunningham. A Laboratory for \nTeaching Object-Oriented Thinking. In Proceedings of OOPSLA 89, ACM SIGPLAN Notices, Vol. 24, No. 10, \npp. 1-6, 1989. [2] G. Bracha and W. Cook. Mixin-Based Inheritance. In Proceedings of OOPSLA-ECOOP 90, \nACM SIG-PLAN Notices, Vol. 25, No. 10, pp. 303-311, 1990. [3] Demeter Research Group. Online Material \non Adaptive Programming, Demeter/Java, and AP-PCs. http://www.ccs.neu.edu/research/demeter/ WIM. Fowler. \nUML distilled. Prentice Hall, 1997 PI E. Gamma, R. Helm, R. Johnson, and J. Vlis-sides. Design patterns. \nElements of Reusable Object- Oriented Software. Addison-Wesley, 1994. W. Harrison and H. Ossher Subject-Oriented \nPro-gramming (A Critique of Pure Objects). In Proceed- ings of OOPSLA 93, ACM SIGPLAN Notices, Vol. 28, \nNo. 10, pp. 411-428, 1993. R. Helm, I. Holland, and D. Gangopadhyay Con- [71 tracts: Specifying Behavioral \nCompositions in Object-Oriented Systems. In Proceedings of OOP- SLA 90, ACM SIGPLAN Notices, Vol. 25, \nNo. 10, pp. 303-311, 1990. I. Holland. Specifying Reusable Components Using Bl Contracts. In Proceedings \nof ECOOP 93, LNCS 615, pp. 287--308, 1992. PI I. Holland. The Design and Representation of Object-Oriented \nComponents. PhD Thesis, North-eastern University, 1993. [lo] P. Jansson and J. Jeuring. Polyp -a Polytypic \nProgramming Language Extension. In Proceedings of ACM Symposium on Principles of Programming Languages, \npp. 470-482, Jan. 1997. [ll] R. Johnson and B. Foote. Designing Reusable Classes. In Journal of Object-Oriented \nProgram-ming, l(2), pp. 22-35, June/July 1988. [12] R. Johnson. Frameworks = (Components + Pat-terns). \nIn Communications of ACM, Vol. 40, No. 10. 1997 [13] Kiczales G., Lamping J., Mendhekar A, Maeda C., \nLopes C. V., Loingtier J. M., Irwin J. Aspect-Oriented Programming. Invited Talk. In Proceedings of ECOOP \n97, LNCS 1241, pp. 220-243, 1997. [14] S. Lauesen. Real-Life Object-Oriented Systems. IEEE Software, \npages 76-83, March/April 1998. [15] K. J. Lieberherr and I. Holland. Assuring Good Style for Object-Oriented \nPrograms. IEEE Soft- ware, pages 38-48, Septe mber 1989. [16] K. J. Lieberherr and D. Orleans. Preventive \n Program Maintenance in Demeter/Java (Research Demonstration) In Proceedings of the ICSE, 1997, pp. 604-605, \nACM [17] K. J. Lieberherr and B. Patt-Shamir. Traversals of Object Structures: Specification and Efficient \nim-plementation. TR NU-CCS-97-15, College of Com- puter Science, Northeastern University, 1997. [18] \nM. Mezini. Dynamic Object Evolution Without Name Collisions. In Proceedings of ECOOP 97, LNCS 1241, pp. \n190-219, 1997. [19] M. Mezini. Maintaining the Consistency of Class Libraries During their Evolution. \nIn Proceedings of OOPSLA 9 7, Sigplan Notices Vol. 29, No. 10, pp.l-- 22, 1997. [20] M. Mezini. Variation-Oriented \nProgramming Be-yond Classes and Inheritance PhD Thesis, Univer-sity of Siegen, Germany, 1997. [21] J. \nPalsberg, B. Patt-Shamir, and K. Lieberherr. A New Approach to Compiling Adaptive Programs. Science of \nComputer Programming, 29(3):303-326, 1997. [22] J. Palsberg, C. Xiao, and K. Lieberherr. Efficient Implementation \nof Adaptive Software. ACM Trans-actions on Programming Languages and Systems, 17(2):264-292, Mar. 1995. \n[23] T. Reenskaug et al. OORASS: Seamless Support for the Creation and Maintenance of Object Ori-ented \nSystems. In Journal of Object-Oriented Pro-gramming, Oct. 1992. [24] Y. Smaragdakis and D. Batory. Implementing \nLay-ered Designs with Mixin-Layers. In Proceedings of ECOOP 98. To appear. [25] L. M. Seiter. Design \nPatterns for Managing Evolu-tion. Ph.D. Thesis, Northeastern University, 1996. [26] P. Steyaert, W. Codenie, \nT D Hondt, K. De Hondt, C. Lucas, and M. Van Limberghen. Nested Mixin-Methods in Agora. In Proceedings \nof ECOOP 93, LNCS 707, pp. 197-219, Springer-Verlag, 1993.  [27] C. A. Szyperski. Import is not Inheritance \n-Why We Need Both: Modules and Classes. In Proceed-ings of ECOOP 92, LNCS 615, pp. 19-32, Springer- Verlag, \n1992. [28] M. VanHilst and D. Notkin Using Role Iomponents to Implement Collaboration-Based Designs. \nIn Pro- ceedings of OOPSLA 96, ACM SIGPLAN Notices, Vol. 28, No. 10, 1996. [29] M. VanHilst. Role-Oriented \nProgramming for Soft- ware Evolution. PhD thesis, University of Washing- ton, 1997. [30] N. Wilde, P. \nMatthews and R. Huitt. Maintaining Object-Oriented Software. In IEEE Software, 10(l), pp. 75-80, Jan. \n1993. [31] N. Wirth and J. Gutknecht. The Oberon System. In Software-Practice and Experience, Vol. 19, \nNo. 9, Sept. 1989. \n\t\t\t", "proc_id": "286936", "abstract": "In several works on design methodologies, design patterns, and programming language design, the need for program entities that capture the patterns of collaboration between several classes has been recognized. The idea is that in general the unit of reuse is not a single class, but a slice of behavior affecting a set of collaborating classes. The absence of large-scale components for expressing these collaborations makes object-oriented programs more difficult to maintain and reuse, because functionality is spread over several methods and it becomes difficult to get the \"big picture\". In this paper, we propose <i>Adaptive Plug and Play Components</i> to serve this need. These components are designed such that they not only facilitate the construction of complex software by making the collaborations explicit, but they do so in a manner that supports the evolutionary nature of both structure and behavior.", "authors": [{"name": "Mira Mezini", "author_profile_id": "81100583946", "affiliation": "College of Computer Science, Northeastern University, Boston, MA", "person_id": "P201627", "email_address": "", "orcid_id": ""}, {"name": "Karl Lieberherr", "author_profile_id": "81452617626", "affiliation": "College of Computer Science, Northeastern University, Boston, MA", "person_id": "PP40026940", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/286936.286950", "year": "1998", "article_id": "286950", "conference": "OOPSLA", "title": "Adaptive plug-and-play components for evolutionary software development", "url": "http://dl.acm.org/citation.cfm?id=286950"}