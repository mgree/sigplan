{"article_publication_date": "10-01-1998", "fulltext": "\n Logical Observable Entities Jonathan G. Rossie Jr. North Carolina State University jrossie@csc.ncsu.edu \nAbstract We show how finite-state machines can standardize the protocol used by a component object to \nnotify other interested objects of its state changes, resulting in a more effective use of static types \nto constrain both parties, and a more efficient dissemination of infor- mation. The enhanced component \nspecification is called a logical observable entity, or LOE. We address two key issues in effectively \napplying such a strategy: how to extend subtyping to consider the state machines, and how to ensure some \nkind of compliance be-tween the state-machine specification and its implementation. This leads to an \nunusual subtyping predicate for LOEs on the one hand, and a prototype code generation strategy on the \nother. 1 Introduction When a component object is developed in isolation from its clients, it cannot send \nmessages directly to objects in the client systems since it does not know their actual class names. Instead, \na level of indirection must be employed, usually by having the compo- nent specify an abstract type for \nthe receivers of its messages. The clients, in order to receive messages from the component, must then \nimplement this abstract type, instantiate it, and register the result- ing object with the component \nat run time. Often, in fact, the client may register several such receivers with a given component, possi- \nbly with different behaviors. Perhaps the best-known example of this framework is the Model/View/Controller \nparadigm for developing object-oriented graphical user interfaces [ 181. In this paradigm, objects in \nthe model-objects that represent elements of the application domain-are developed without regard for \na specific view li-brary, but are responsible for notifying view objects whenever they change in an interesting \nway. The solution, naturally, is for view objects to register with the model objects that concern them. \nIn the design patterns community, this pattern of object interac- tion is known as the Observer pattern \n[ 131, where the anonymous Perm,ss,on to make d,g,tal o, hard copses of ail o, pa,, of this work for \npersonal or classroom use IS gramed without lee prowded that copses are not made or dastributed for proflt \nor commercial advan-tage and that cop,es bear this nowe and the full c,tat,on on the ilrst page -io copy \notherwse. to republish. to post on .ser ers or to redlstrlbute to ksts. requwes pnor specific permission \nand/or a fee. OOPSLA 98 10198 Vancouver, B.C. 0 1998 ACM 1-581 13.005.8/98/0010...$5.00 Figure 1: Class \ndiagram for a component and its observers. receivers of notifications are called observers and the components \nthey observe are called subjects. Figure 1 shows a UML [33] class diagram for such a system. A Component \ninstance holds pointers to any number of Observer instances. Since Observer is abstract, a client creates \ninstances of type Observer by instantiating the concrete classes ClientObl , which are not directly known \nto the component. 1 .l Notification Protocols The most typical implementation of this pattern involves \na single abstract type Observer which has a single method notify). Each subject maintains a list of these \nobservers, and notifies them of any interesting events. In fact, Sun s Java 1.1 API distribution includes \nlibrary definitions for an interface Observer and a class Observable which provide the core for such \nan implementation. While this approach has the benefit of simplicity, it raises sev- eral difficulties. \nChiefly, it leaves the details of the protocol com-pletely unspecified in the code: a subject may send \nnotify messages for any reason, or not at all; code inspection of an observer cannot reveal whether or \nnot it performs an adequate case analysis to de- termine the meaning of the notification. In practice, \nthe safest way to apply this method is for the subject to fire a notification when-ever it sets an instance \nvariable, and for the observers to respond to such a notification by querying the subject for the values \nof all of its fields. There is no high level of description that captures the logical nature of the physical \nstate change; rather, it is simply a change in the value of a field. Apart from its overemphasis on the \nvalues of fields, this approach bombards the subject with suites of queries for every notification it \nsends, which is far from economical. A far superior approach can be found in the Java 1.1 AWT event system. \nEach user interface component is a subject that can reg- ister several distinct kinds of observers, called \nlisteners, for dif- ferent classes of events. Events, such as mouse actions or key- board interrupts, \noccurring in the user interface components cause those components to send notifications to the appropriate \nset of ob- servers. This allows observers to choose which kinds of events they wish to observe, eliminating \nmuch unnecessary communication be-tween the subjects and their observers. This greatly simplifies the \nobserver implementations, since their case analysis is pared down to the kinds of events that actually \nconcern them. Moreover, each category of observer implementation declares itself as such by im- plementing \na special observer interface for that category, such as MouseListener or KeyListener. Each of these customized \nobserver interfaces declares a suite of methods whose names, such as mouse- Pressed or mousef?eeleased, \nmake it quite clear what the notification means, which further simplifies the coding of observers by \nmaking their case analyses explicit in the method signatures. The strength of this approach derives from \nits use of the type system to document the notification protocol. The events are ab- stracted into high-level \ncategories, and these are further decom- posed into specific, detailed messages that can be sent to the \nob- servers. If an observer chooses to ignore certain of these messages, this choice is explicitly documented \nin the code as an empty method body. And on the other side, the AWT widgets are carefully hand crafted, \nwe assume, so that they actually fulfill their obligation to send the appropriate notifications when \nevents occur. Since the benefits of such a design are manifest, the question is how this level of sophistication \ncan be used more routinely. Clearly, such a hand- crafted design cannot be abstracted into a simple library \nfor general use. 1.2 State Machines The entire observer paradigm is chiefly concerned with notifying \nobservers of changes in state. But what is a change of state, ex- actly? There are two distinct ways \nof viewing the state of an ob- ject. The study of automata and grammars tells us that a stack, or pushdown \nautomaton, cannot be encoded as a finite-state machine. And yet, at a higher level, a stack has just \ntwo states: empty, and non-empty. In fact, this higher level of abstraction seems more sig- nificant \nto users of the object, since it tells how the object can be used: an empty stack cannot process a pop \nrequest, but a non-empty stack can. We call this higher level the logical state machine for the object. \nIf we were to define an observable stack, what would be a rea- sonable notification protocol? Put differently, \nwhat notifications would the observer want to receive? We derive the following list of notifications \nfrom the logical state machine: l stack was empty, but just pushed an item l stack was non-empty, and \njust pushed a new item l stack just popped an item, but is not empty l stack just popped last item, is \nempty Such a suite of detailed notifications keeps the observers ap- prised of the high-level behavioral \nchanges (that is, transitions between empty and non-empty states), as well as the low-level changes (a \npush occurred, but didn t change the high-level state). Given a specification of the logical states of \nan object, we pro- pose to generate just such a detailed notification protocol. More-over, we can generate \nthe state machine implementation, which gives us the opportunity to automate the firing of notifications \nas the state machine processes transitions. Thus, we manage both ends of the observer contract: the observer \ns type is generated, establishing its contract and making its case analysis explicit; and the subject \nis generated, ensuring that it fires notifications exactly when it is supposed to.  1.3 Paper Outline \nThe remainder of this paper is as follows. In Section 2 we introduce LOEs without subtyping. In Section \n3, we review related work in subtyping and show why LOEs require a new approach. In Section 4 we develop \nan informal notion of LOE substitutability; Section 5 then presents the formal definition of substitutability, \nand a proof that it allows only safe substitutions. Section 6 briefly explains our compilation strategy \nfor LOEs. Finally, Section 7 surveys related work, and Section 8 presents some conclusions and discussion \nof future work. 2 Logical Observable Entities The most direct way to understand an LOE is to construct \none. In this section, we develop an LOE to describe a lightbulb. In this discussion, and throughout this \npaper, we use a somewhat graphical notation to define LOEs. We begin by listing the states and methods \nfor the entity, and then draw its transition diagram. Let us say that a bulb can be either good (usable) \nor blown (burnt out), and that in the good state it can process a consume command, which causes it to \nconsume a pulse of energy. (We as- sume a datatype, Pulse.) Also, in either state the bulb may be asked \nfor its resistance using a getResistance query. In principle, it should also support numerous other queries, \nbut they would be handled in much the same way. public interface Bulb-Observer { public void good-consume-goodNotify( \nBulb subject ); public void good-consume-blownNotify( Bulb subject ); 1 Figure 2: The generated observer \ntype for a Bulb LOE. We distinguish between queries and commands because only commands can cause state \nchanges and notifications. Conse-quently, queries don t appear in the generated observer interfaces, \nwhile commands do. (Ironically, some authors refer to queries as observers [20].) Our quick analysis \nof the lightbulb object can be summarized in the following dictionary, which also provides useful abbreviations: \nBulb consume(o:Pulse) We now specify the dynamic availability of methods using a finite state machine. \nAs we discuss in Section 7, this is closely re-lated to the use of guards or enabled sets in synchronization \ncode for concurrent objects [22, 23,401. An important difference is that these techniques tend to partition \nthe methods dynamically, accord-ing to the values of boolean expressions involving instance vari- ables. \nInstead, we simply partition the methods according to the logical states we have defined, and allow individual \nimplementa-tions to resolve whatever nondeterminism we introduce. The transition diagram for our Bulb \nLOE is shown below. The good state is shown with a double circle to indicate that it is the initial state. \nFor the getResistance query, we have introduced re-flexive edges on both states. For the consume command, \nwe allow a reflexive transition in the state @ , and an alternative transition @+@, which indicates that \nreceiving a pulse may cause a bulb to burn out. TT P c We can now consider how this specification may \nbe used to generate a notification protocol. Our prototype code generator for coding LOEs in Java, which \nis called LOLA, would generate essen- tially the observer type shown in Figure 2. Implementations of \nthis interface, when registered with a Bulb implementation, will receive notifications whenever a consume \ncommand is processed; the exact method called tells us whether or not the bulb was blown as a result. \nIn addition to this observer interface, a number of classes and interfaces are generated for the subject. \nIn particular, a state ma- chine is implemented that screens messages for the Bulb implemen- tation, \nforwarding messages only if they are valid for the current state. (In a concurrent context, a queuing \ndiscipline would be more appropriate.) Also, the state machine processes transition requests from the \nBulb implementation, allowing only transitions defined in the LOE specification, and sending notifications \nwhenever it suc- ceeds. Moreover, since the state machine sends the notifications, a Bulb cannot change \nits logical state without firing a notification. Thus, Bulb implementors are protected against invalid \nmessage se- quences on one hand, while Bulb clients are protected against un- expected or covert transitions \non the other. The LOLA system is sketched more fully in Section 6. But first we must consider a question \nthat becomes the source of much of the expressive power of the LOE paradigm: What does it mean for one \nLOE to be a subtype of another? 3 Afferent and Efferent Types In this section we introduce the core problem \nin defining subtypes of LOEs, which leads us to a distinction we refer to as afferent and efferent types. \nWe begin with a very brief overview of related type theory. Statically-typed object-oriented languages \nsupport a notion of subtyping in which the assertion C is a subtype of C means that an object of class \nC can be substituted where an object of type C was expected, and it will not result in an object being \nsent a message it does not understand. Designing type systems that are both expres- sive and provably \nsafe requires some care. The exploration of such type systems for object-oriented languages has been \na continuing area of interest [ 1,3,4, 5, 8, 12,301. An intuitive basis for subtyping in object-oriented \nsystems is given by Wegner and Zdonik [42]: An instance of a subtype can always be used in any context \nin which an instance of a supertype was expected. While static type systems can protect against some \nviolations of this principle, they admit subtypes that disregard se- mantic constraints of the superclass \nand thus violate the spirit of substitutability. For example, substituting a queue where a stack was \nexpected may cause disastrous results. To enforce semantic restrictions of this kind, some languages \nhave been extended with semantic specifications that can be checked before subtypes are ad- mitted. In \nEiffel, for example, pre- and post-conditions may be specified for methods, and subclasses may neither \nstrengthen the preconditions nor weaken the postconditions of methods they over- ride [24]. Leavens, \nLiskov and others have referred to such ex- tended notions of subtyping as behavioral subtyping [ 11, \n19, 201. By adding a state machine to an ordinary class definition, an LOE provides a form of semantic \nspecification that can form the basis for behavioral subtyping. The state machine specifies the dy- namic \navailability of services offered by the LOE, and a subtype must somehow conform to the supertype s state \nmachine. For ex- CircuitPart states 0 open SuperObserver C closed queties r getResistance() : Ohms K \ncommands SUbObSWVS~ P consume(p:Pulse) Figure 3: Afferent and efferent subtyping: The Sub must be able \nto accept the messages ml sent by a Super controller (ufirent). as well as any additional messages rn2 \nsent by a Sub controller; and it must be able to send the appropriate notifications TZI expected by a \nSuper observer (efferent), as well as the notifications n2 expected by its own observer. In general, \nnr and nz differ. ample, a bounded stack cannot be substituted for an unbounded stack, since a context \nthat expects an unbounded stack would be surprised when a push operation is rejected as invalid in a \nfull state. In fact, several authors have offered definitions of subtyping that account, in some way, \nfor the dynamic availability of services that a logical state machine represents [7, 15, 27, 31, 32, \n341. A common foundation among most of these approaches is the notion of traces, which are the sequences \nof messages that a machine can legally receive. A subtype must be able to accept at least the traces \nof its supertype. All of these approaches essentially extend the notion of the availability of services \nto include sequencing restrictions. This im- portant extension of subtyping is still only part of the \npicture, how- ever. It defines substitutability in terms of the messages the objects can accept, but \ndoes not consider the notifications the objects will send to their observers. Observers may wish to observe \ninstances of a particular LOE or its sub-LOEs. In this case, the sub-LOE must be capable of simulating \nthe notifications that would have been sent by the super-LOE. The difference is that now we are interested \nin what we call the efferent aspects of the object, whereas earlier sub- typing restrictions, even those \ndealing with state machines, were concerned only with what we call ufferent aspects. Figure 3 illustrates \nthese distinct facets of subtyping. An object, shown at center, is an instance of Sub, which is a sub-LOE \nof Super. Afferent subtyping (how other objects can afSect the LOE) ensures that this object can respond \nto the same messages, ml, as an in- stance of Super. Efferent subtyping (the effect of the LOE process- \ning a message) ensures that this object can be observed by an object that will never know it is observing \nanything but instances of Super. Our goal is to define substitutability so that a sub-LOE cannot make \ntransitions that lack interpretations in terms of the super-LOE S state machine. Thus, in addition to \naccepting the same traces, the sub- LOE must support a compatible notification protocol. 4 Circuits and \nSubstitutability This section develops an informal notion of LOEs and LOE substi- tutability by exploring \nan extended example concerning electrical Figure 4: Preliminary (incomplete) LOE specification for Circuit-Part. \nconsume(p:Pulse) Figure 5: LOE specification for Switch. circuits. A circuit comprises any number of \ncircuit parts, each of which has a resistance and has the potential to conduct (and con- sume) electrical \nenergy. A circuit part with infinite resistance is said to be open, and cannot conduct electricity. All \nother circuit parts are closed. As in Section 2, we view energy as occurring in discrete pulses. Sometimes, \nconsuming a pulse causes a closed circuit to open, as when a fuse blows. From this initial specification \nwe can begin to derive an abstract LOE called CircuitPart. Our first attempt is shown in Figure 4. A \nCircuitPart (or CP) has two states: open and closed. Each state is double-circled to indicate that it \nmay be a start state. The machine is nondeterministic, since consuming a pulse may lead to a closed state \nor an open state. There is no specification of how to close a circuit, since there is no general procedure \nfor doing so. Based on this abstract LOE, we now try to define a concrete variant: Switch, shown in Figure \n5. A Switch (or S) has two states which clearly map to the states of a CP. The two LOEs differ in three \nways: First, @ is not a start state of S. This should be all right, since starting in @ is consistent \nwith CP. Second, S has no edge w . Again, CP declares only that p may transition to @ , so it is consistent \nnot to do so. Third, S provides two new tran- sitions: M C , for closing the switch, and w, for opening \nit. These new edges present no problem in terms of afferent subtyping, but are inconsistent with efferent \nsubtyping. Consider: an observer defined for CP has no notion of an edge from @ to @ , so it assumes \nthere can be no such transition. Similarly, it believes the only way to get to @ is by consuming a pulse. \nThe usefulness of LOEs derives partly from an observer s knowledge of which transitions are possible, \nso we do not wish to allow arbitrary undeclared transitions. Rather, we introduce the Socket { exrend.7CircultPart} \nstates Figure 6: LOE specification for CircuitPart. A CircuitPart may start in either of its states, \nand we may ask for the resistance in either state. The closed state responds to an energy pulse either \nby re- maining closed or by opening (in the case of a blown fuse, e.g.). We also allow that concrete \nCircuitParts might define commands that close or open the circuit; these are supported by the two events, \nel and e2, respectively. SwitchObserver Figure 7: Closing a Switch: the SwitchObserver is notified that \nthe close command succeeded, whereas the CircuitPsrtObserver is merely told of the transition as an el \nevent. Both are accurate for the state machine, but the SwitchObserver has more information. notion of \nevents in LOE state machines. Figure 6 shows the cor- rected CircuitPart, in which events have been added \nbetween @ and @ . These events play a role similar to late-binding; they are placeholders for commands \nlater defined in sub-LOEs. Events are a purely efferent feature of LOEs: a CP cannot be sent the mes- \nsage el, but a CP can tell its observers that a transition @%@ occurred. Figure 7 shows how a CP observer \nand an S observer re- ceive different notifications when a switch is closed. Each observer then views \nthe circuit part as closed, but understands the transition in its own way. For a more interesting CircuitPart \nwe now consider Sockets, as shown in Figure 8. This definition is, at first sight, quite different from \nthe state machine for CP: the state names are different, and there are more of them. There are also several \nnew commands, queries, and events. But this, too, is a sub-LOE of CircuitPart. The two states @ and @ \ncorrespond to the @ state of CP, while @ corresponds to @ The queries and commands accepted by each state \ninclude those defined in the corresponding CP states. In addition, the edges M and M E mstantiate the \nevents declared in CP. Figure 9 shows how events support efferent subtyping by providing a vocabulary \nfor CP observers to learn about such transitions; the two observers receive notifications appropriate \nto their understand- ing of the object. Their views of the object are equivalent in some e-4 openi&#38;() \n Figure 8: LOE specification for Socket, a sub-LOE of CircuitPart. A Socket has three states: empty (the \ninitial state) and b/own corre-spond to an open circuit; good corresponds to a closed circuit and supports \nthe consume command. In states blown and good there is a bulb present in the socket; in state empty the \nsocket is empty. An empty socket can be filled by the screw/n command, but since the bulb may be good \nor bad the resulting state may be either good or blown. A filled circuit can be made empty by the unscrew \ncommand, or its bulb may be disclosed by the get&#38;lb query. Two events are declared to support Bulbs \nthat spontaneously open and close, such as a switchable bulb. sense, but the Socket observer sees a greater \nlevel of detail, as if through a microscope. But what about the edges M and M ? These exemplify a special \nkind of extension, since both of these edges connect states that actually correspond to the same state \nin CP. Be-cause the transitions are reflexive with respect to CP, a CP observer never needs to know that \nthey have occurred. Hence, they are safe additions and simply generate no notifications to CP observers. \nFinally, the Socket inserts its own events to support the notion of a bulb that can open and close itself \n(perhaps the bulb is really a switch, threaded to fit in the socket). These new events are inoffen- sive \nbecause each has a corresponding event in CP. SocketObserver ClrcuitP.wtObserver Socket (b) CircuitPertController \nSocketObserver Figure 9: Screwing-in (a) or burning-out (b) a lightbulb. Observers receive customized \nnotifications. In summary, a sub-LOE must choose its start states from among those of its super. For \neach state of the sub-LOE, there must be a corresponding state in the super such that the new state accepts \nall of the commands and queries of the original, but may also define new commands and queries. Transitions \nin the sub-LOE must map to transitions in the super, unless they are novel commands whose transitions \nare reflexive with respect to the super. 5 Formal Substitutability From our experience defining earlier \ncompilers based on ad hoc notions of substitutability, we found it helpful to formalize the sub- stitutability \nrelation and prove its sufficiency in preserving both afferent and efferent consistency. The goal is \nto provide a rigor- ous foundation for accepting declarations of sub-LOEs-and subse-quently generating \nJava subtypes-only when they can be proved to be safely substitutable. We begin by formalizing LOEs; \nthen we characterize the substitutability relation, and prove its sufficiency. 5.1 Preliminaries Suppose \nA and B are finite sets, with a E A and b E B. Then A x B is the product comprising all sets of ordered \npairs of ele- ments of A and elements of B, where each pair has the form (a, b). Similarly, A -+ B denotes \nthe space of all functions mapping el- ements of A to elements of B, where each mapping has the form \na +-+ b. Let p be an element of A + B. Then dom(cp) denotes the domain of p, which is the set of all \na E A such that (a I+ b) E p. If dom(cp) = A then we say p is total. If (a H b) E cp, we may write cp(a) \nto denote b. As a special case, if cp(a) = cp(a ) im- plies a = a for all a, a 6 dom(cp), then we say \ncp is an injection. Finally, 2A denotes the powerset (the set of all subsets) of A. In general, upper-case \nroman letters (except L) denote finite sets and their products, while small greek letters denote functions. \nWe assume the existence of three infinite input alphabets--C,, C,, and X,---from which the names of queries, \ncommands and events are drawn, respectively. Without loss of generality, we assume these alphabets to \nbe disjoint. 5.2 Encoding LOEs We give a symbolic encoding for LOE specifications by extending a nondeterministic, \nfinite-state automaton with extra information about queries, commands, and events, and by changing the \nstart state to a set of initial states and omitting the final states. Definition 1 (LOE). An LOE L is \na 6-tuple (S, y, 6, E, 77, I), with finite states S, query assignment y E S + 2 s) transition function \nb E (S x C,) -+ (2 \\fl), eventpairs E G S x S, event assignment 17 E E --t C,, and nonempty set of initial \nstates I c 5 . The assignmentfunctions y and q are total, and 77 is an injection. The query assignment \ny gives the set of queries accepted by a given state, while the event assignment 17 gives the name of \na given event edge (~1~32) E E. The transition function 6 gives the nonempty set of possible following \nstates when a given state s receives a command c; the set of commands accepted by a given state s is \n{c 1 (s,c) E dam(b)}, which we may write simply as Cmds(L, s). For example, the Socket LOE from Figure \n8 is encoded as ( S ={G, B, El, Y ={G I-+ {r, g), B * {r, 91, E ++ (~11, 6 -{(G,d I-+ {G, B), (G, 4 * \n{El, (B, 4 r-) {El, (E, 3) t-+ tG, BlJ> E ={(B, G), (G, B)), q -{(B,G) ++ el, (G,B) ++ a), I=(E) ) Henceforth, \nL and L always refer to proper LOEs. We write S or S to refer to the states of L or L respectively, and \nsimilarly refer to other elements of the tuples.  5.3 Simulation: Subtyping for LOEs For one LOE, L, \nto be substitutable for another, L , it must exhibit logical-observable behavior consistent with that \nof L . We formal- ize this consistency by defining a simulation assignment, which maps states of L into \nstates of L . We then show that simulation assignments are sufficient to ensure a formal notion of consistent \nobservable behavior. Unlike the inferred substitutability relation defined by Nier- strasz [27], every \nsubtyping relationship among LOEs is explicitly declared by the programmer. Our subtyping relation is \nbased on declared mappings from states in the sub-LOE to states in the super. This is because it is easy \nto construct examples in which we can in- fer more than one such mapping that results in safe substitutability, \nand whichever mapping we choose will result in different efferent behavior. Thus, to avoid arbitrary \nresolution of these ambiguities, we require a declaration of a sub-LOE to define the simulation map- \nping explicitly. Definition 2 (simulation assignment). Let L and L be LOEs. A simulation assignment from \nL to L is a totalfwtction u E S + S such that (1) Vs E I, (T(S) E I ; and (a) V(sl, ~2) E E, either \n (a) a(sl) = ~~(32)~ or (b) (a(sl),o(sz)) E E ; and  (3) vs E s,  (4 Y(S) 2 r (ds)), and (b) Cmds(L, \ns) 2 Cmds(L ,u(s)), and fc) Vc E Cmds(L , a(s)),Vs, E S(s, c), O(G) E 6 (o(s),c), and Cd) Vc E (Cmds(L, \ns) \\ Cmds(L ,a(s))),Vs, E S(s,c), either (9 ~(3,) = o(s), or Oil (u(s),a(s,)) E E . Rationale: (1) L \nmust start in a state that maps to one of the start states of L . (a) If L were allowed to declare events \nbetween arbitrary states, it would be possible to make a transition in L that has no counterpart in L \n. Hence, L may declare events only if they are reflexive wrt L or mimic existing events in L . (3) If \na state s of L simulates a state a(s) of L , then a client of L may expect to be able to send it any \nqueries in y(c(s)) and any commands in Cmds(L , u(s)). Moreover, the client can reasonably expect to \nknow which states might follow a suc- cessful command, so L may not transition to arbitrary states on \ncommands in Cmds(L , u(s)). Of course, L may define other commands for its state s, but these either \nmust be re- flexive wrt L or they must correspond to events in L . (That s why there is a notion of events: \nto accommodate irreflexive transitions on novel commands.)  We now define a simulation as the binding \nof a simulation as-signment between two LOEs. Definition 3 (simulation). A simulation is a triple (L, \nu, L ) in which u is a simulation assignment from L fo L . An example simulation is the following one \nbetween Socket and CircuitPart: (Socket, {G ti C, B ti 0, E ti 0}, CircuitPart)  5.4 Unsurprising Observable \nBehavior If the definition of simulation assignments is sufficient, then an L client observing an LOE \nL will never be surprised by the observable behavior of the L subject. Afferent consistency is easily \ncharacterized by comparing the queries and commands available in a given state. But how do we characterize \nformally the observation of transitions an LOE might make from a given state? An LOE in a given state \ncan change its state in two ways: through the execution of a command or the signaling of an event. So \nwe define two kinds of formal transi- tions: command transitions cmd(sl, c, sz), and event transitions \nevt(sl, e, 32). Additionally, there is an empty transition A. Definition 4 (LOE-state). An LOE-slate \nof an LOE L is a pair Les, provided s is a state of L. The notation (L.91) ot +-+ L-s2 indicates that \nan LOE-state L.81 transitions to La32 by the transition t. We now define the legal transitions on a \ngiven LOE-state, and their resulting states. Definition 5 (transition). Let L be an LOE and let L*sl \nbe an LOE-state of L. A transition t of Las1 is defined to be one of: (I) A, in which case (L.sl)ot -+ \nL*sl; (a) cmd(sl,c, SZ), where c E Cmds(L, SI) and s2 E b(sl, c), in which case (L*sl)ot * L*sz; or \n (3) evt(s1,e,s2), where (~1,s~) E E and ~((~1,s~)) = e, in which case (L.sl)ot +-+L.32.  This captures \nour intuitive notion both of the legal transitions for an LOE-state, and of the LOE-state that would \nresult from the transition. A transition of L*s is not, in general, a transition of L/V(S). For example, \nSocket. E allows a transition cmd( E, s, G) that is in- valid for the corresponding state CircuitParbO. \nHence, we derive from u a transition assignment 7. mapping transitions of L+s to transitions of L v(s). \nDefinition 6 (transition assignment). Let L and L be LOEs and let u be a simulation assignment from L \nto L . The transition as-signment r. is defined as T,(h) ii A 7c(evt(sl,e,s2)) e A if(u(31), u(s2)) 6 \nE otherwise ev44sl), 7dk7(31), 432))), 432)) { ~o(cmd(s1,c,s2)) k A ifc @ Cmds(L , u(sl)) A u(sl) = ~(52) \ncmd(u(sl), c, 432) ifc E Cmds(L , U(SI)) evt(u(si), q((u(si), 432))), 432)) otherwise  5.5 Formal Sufficiency \nSuppose the observer has its own copy of a state machine corre- sponding to L , and every time it notices \na state t in L, it forces a corresponding transition r,,(t) in its state machine. There are two conditions \nwe would want: (1) the observer would never receive a nonsensical transition, and (2) by applying the \ncorresponding tran- sitions, the observer s machine would always be in a state L/V(S) whenever the LOE \nis in state L.s. While the second condition depends upon the first, it is pos- sible to maintain the \nfirst condition while failing the second. For example, condition (1) is trivially satisfied if we never \nsend any notifications, but this rarely satisfies condition (2). We now show that if we formally link \ntwo machines as sug- gested above, the simulation assignment u and its derived transition assignment \n7a are sufficient to ensure these two properties. Definition 7 (simulation state). A simulation state \nis a tuple (L.s, a, L .s ), where (L, u, L ) is a simulation, L*s and L .s are LOE-states, and u(s) = \ns . Theorem 1 (sufficiency). Let (L*sl, u, L .si) be a simulation state, where L 2 (S, y, 6, E, 7, I) \nand L 2 (S , y , b , E , q , I ), with ~1, sg E S and s;, s; E S . Then for every transition t of L.Sl, \n(1) r, (1) is a transition of L .s:, and (2) if (L.sl) o t --+ L.SZ and (L .s<)o~~(t) + L .s:, then \n(L.52, u, L .si) is a simulation.  ProoJ Let t be a transition of L.sl such that (L.sl)ot + L.sz. Then \nit is sufficient to show that (L .si)o~~(t) + L es , and that sh = u(sa). Proof by cases oft, following \nthe definition of 7: (1) t E A: Then To(t) = A, so sz = ~1 and s; = s: = a(sl) = u(e). (2) t c evt(sl,e,sz) \n: If (u(sl),a(sz)) @ E : then To(t) = A, so s; = s;; and by (rule 2 of Def. 2), u(s~) = u(s~), so ~(52) \n= s;. Otherwise T,(t) = evt(u(sl), v((Q(s~), u(sz))), u(sz)), which is a transition of L ss; because, \nby (rule 2 of Def. 2), (u(sl), a(sz)) E E ; so s; = u(s2). (3) t E cmd(sl,e,s2) : If c $! Cmds(L ,u(sl)) \nand u(sl) = ~(92) then T,,(t) = A, so si = s;; and u(sz) = s; since u(s~) = u(s2). Otherwise, if c E \nCm&#38;&#38; , u(s~)) then Tb(t) = cmd(u(sl), c, I, which is a transition of L .s: because, by (rule \n3c of Def. 2), u(sg) E ~ (u(s~),c); so sh = a(.~). Otherwise T,,(t) = evt(u(sl), o((u(sl), u(sz))), u(sz)), \nwhich is a transition of L .s: because, by (rule 3(d)ii of Def. 2), (u(s~),u(sz)) E E ; so s 2 = u(sz). \n cl Thus, we have defined a substitutability predicate that supports our full notion of safe substitution. \nWe use this as a formal basis for an algorithm that determines whether or not our compiler will ac-cept \na declaration of a sub-LOE. A simulation-checking algorithm is straightforward, and we have coded one \nas part of the compiler described below. 6 Java LOEs: A Prototype In this section we describe, briefly, \na compiler that generates a suite of Java classes and interfaces for each LOE specification. In par- \nticular, the state machine and the notification system are imple- mented in these generated files. The \nactual implementations of an LOE s methods are not generated, but an interface is generated that Figure \n10: Java types generated for a Socket LOE. NZ3lIl.Z Kind Description Socket-Observer interface what the \nobserver implements Socket class what the clients see Socket-SubjectSocket-Machine class class what sends \nthe notilications what manages the state Socket-lmpl interface what the implementor implements SocketMach \ninterface what the implementor sees specifies the methods needed from an implementation. These im- plementations \nare hand coded, and are plugged into the generated framework at run time. The design of this compiler \nis driven by the need to enforce the specified state transitions of the LOE. This is achieved by us- \ning a layered architecture, in which the generated types and classes form a barrier between the LOE implementations \nand their clients and observers. We refer to this as the logical-observable layered architecture, or \nLOLA. Efficiency of message dispatch was not a concern at this stage, which should be evident from the \nfollowing description. A crucial concern in the LOLA design has been that program- mers must never need \nto edit a generated file. This encourages pro- grammers to edit the LOE specifications directly and regenerate \nthe files, thus keeping the design document-the LOE specification- consistent with the code. In practice, \nthis development cycle has worked well: as new generations of LOE files are created, hand- written code \nneeds to be updated to handle the changes. But be- cause the protocols are so well documented in the \nstatic types, these stale dependencies tend to turn up as static type errors, which pin- point the required \nchanges. As described in Section 2, LOLA generates a suite of classes and interfaces for each LOE. The \nSocket LOE from Figure 8 generates the suite of classes and interfaces shown in Figure 10. We begin with \nan overview of these classes and interfaces. The first type generated is the observer, which is the chief \nmo- tivation for the entire system. Instead of sending a bland notifica- tion, notify(Object o) to its \nobservers, an LOE automatically sends it a specialized message such as emptyscrewln..good(Socket s), \nwhich gives the observer a great deal more information without increasing dataflow. LOLA also defines \nseveral classes with some interesting behavior, the most important of which are the core class (Socket, \nfor example) and the state machine. State machines have two distinct interfaces: one for receiv- ing \ncommands and queries from the outside, and one for receiv- ing transition requests from the implementation. \nEvery Socket object is an instance of the class Socket, which is generated by LOLA. Its constructor must \nreceive an implementation of the inter- face Socketlmpl, which is provided by an actual implementor of \nthe Socket LOE. The Socket constructor creates a state machine, gives the state machine the pointer to \nthe implementation, and keeps for itself a pointer to the state machine s external interface. Whenever \na controller sends a command or query to the Socket instance, it for- 7. closing ) w CircuitPart Observer \nt 6. evt(open,closing,closed) Socket cl Subject 8. screwIn/good Socket Observer t 5. cmd(cmyty,screwIn,good) \n2. screwIn 1. screwln A Socket Controller 3. scretxh, 4. goto-good Figure 11: Screwing-in a lightbulb. \nThis figure shows the internal messages used to process a request to screw-in a lightbulb. wards the \nmessage to the state machine. If the state machine deter- mines that the message is valid for the current \nstate, it enables some subset of its transitions and passes control to the implementation. The implementation \nsees the inner interface of the state machine, which provides a complete set of transition requests, \nonly some of which are enabled when the implementation receives control. The implementation has several \npossible ways of exiting: l It may return normally; if it is a query, this is the expected behavior; \nif it is a command, a normal return denotes failure, which simply means that no transition occurs and \nno notilica- tions are sent. l It may execute one of the enabled transitions, which returns control to \nthe state machine, effects the transition, and causes the necessary notifications to be sent to observers. \nl It may execute a disabled transition, which raises an excep- tion. l It may throw some kind of exception, \nwhich has the usual result. Figure 11 shows the normal scenario for a successful command. A Socket controller \nsends a screw/n message (I) to a Socket object which is in its empty state. The Socket object forwards \nthe message (2) to its state machine, which enables the transitions gotoblown and gofogood, and forwards \nthe message (3) to the actual implementa- tion. The implementation executes its method for screwing-in \na bulb, and signals success by calling the state machine s method goto-good (4). The state machine determines \nthat the transition cmd(empty,screwIn,good) has occurred, and tells the subjects (5,6) to notify their \nrespective observers (7,8). In this case, there are two observers: one Socket observer, and one CircuitPart \nobserver. Each receives the appropriate notification, completing the command. The intermediate layer \nprovided by LOLA prevents implemen- tations from receiving messages in the wrong state. This simplifies \nthe implementor s code by eliminating the tests it would usually have to make. It also ensures a uniform \nresponse to messages re- ceived in the wrong state, which is a clear software-engineering benefit. LOLA \nalso automates the registering and unregistering of observers, the generation of detailed notifications, \nand the cus- tomization of notifications to different kinds of observers. This is a far greater level \nof sophistication than we could ever expect from most hand-coded versions of the Observer or State design \npatterns u31. From the other side, clients can be relatively sure that an imple- mentation will behave \nreasonably, at least with respect to its state machine. Certainly, a pathological implementation might \nnever make transitions, might diverge, might throw unexpected excep- tions, or might signal empty/.Scf8w/n/good \nwhen it screws-in a bad bulb. The list is long, but at least we know that it will not make un- expected \ntransitions, which eliminates a significant class of errors. 7 Related Work Our ~0~s build on a body \nof work in which substitutability rela-tions are defined for languages that use finite-state machines \nin the specification of processes or objects. The two significant threads both come from concurrency \nresearch, where finite-state machines are frequently used to manage the complexity of coordinating dis-tributed \nprocesses. The first thread is centered on Harel s statecharts: a compos- able, visual formalism for \ndescribing state machines for software designs [14, 161. Created for use in designing reactive systems \n[ 171, statecharts were soon being applied in object-oriented analy- sis and design as well [7, 1.51. \nIn fact, something like statecharts have been present in many of the leading methodologies for OOA and \nOOD [33, 37, 391. A special notion of subtyping has been de- veloped for classes enhanced with statecharts \n[7]: the subtype is expected to accept the same sequences of messages (traces) as its supertype. Design \npatterns and implementation strategies have also been proposed for coding such classes [9, 131. Some \nauthors have addressed the particular challenges of inheriting the state-machine implementation code \n[ 15,381, a problem remarkably similar to the so-called inheritance anomaly in concurrent object-oriented \nlan-guages [22,23]. The second thread arises directly from issues in object-oriented concurrency. Nierstrasz \ns regular types [27] use logical finite-state machines (or regular expressions) as the basis for an extended \nno- tion of types for active objects. Starting with distributed objects in the spirit of actors [2], \nNierstrasz uses logical states to describe the dynamic availability of the object s methods. This is \na kind of behavioral subtyping in which the logical states play the role of a partial specification. \nSubtypes in his system are, again, defined in terms of traces. From these two threads there has developed \na small research community seeking to reconcile these notions of behavioral sub-typing with the more \ntraditional notions of substitutability among concurrent processes. There, substitutability is generally \ndescribed in terms of bisimulation, and has a much stronger sense than subtyping; it essentially means \ncomplete observable equivalence [6, 10, 251. The recent efforts at synthesis begin with either stat- \necharts [21, 411, regular types [31], or both [34], and offer trans- lations of those ideas into labelled \ntransition systems or the A- calculus [26]. None of these researchers has addressed anything like the \nprob- lem of efferent types described here. But despite the differences, this is all related work in \nthe sense that it all seeks to explain the role of finite-state machines in the type structure of a programming \nlanguage. Using a trace semantics for subtypes, Puntigam [32] has even developed a static type discipline \nfor determining whether a program in his calculus ever allows messages to be sent to objects that are \nin the wrong state to accept them. This type of claim is presently beyond what we can do with LOEs, but \nis certainly a re- search goal. Conclusion This paper is an introduction to logical observable entities, \nwhich combine class declarations with state-machine specifications to generate a standardized and explicit \nnotification protocol for ob- servable objects. This architecture provides an expressive and self- documenting \nvehicle for defining classes of observable objects. Because LOEs are like class definitions in many regards, \nit is unacceptable to rule-out subtyping among LOES. Doing so would make hierarchies like our CircuiPartexample \nimpossible. But it is equally unacceptable to simply rely on Java s subtyping, disregard- ing the state-machine \nspecification. Doing so would undermine our notification protocol. Hence, we have devised a customized \nnotion of behavioral subtyping that allows sub-LOEs to be defined only when they respect the specification \nof their super-LOE. We have developed a notion of sufficiency for substitutability and proved our relation \nto be sufficient. Our interest was never simply to describe LOEs, but to offer a code-generation strategy \nfor implementing them. Because an LOE gives method types but not their implementations, our com- piler \nneeds to allow actual implementations of the methods to be attached to the generated classes. The compiler \nwe describe gen- erates a state machine implementation that is responsible both for protecting clients \nfrom implementations that make illegal transi-tions, and for preventing clients from invoking methods \nthat are undefined in the current state. Since we generate unique observer types for each LOE, and since \nour state machine generates the notifications for these ob- servers, we are able to offer a novel solution \nto the problem of how to provide observers detailed information without shipping more data: The observers \nimplement distinct methods for each state tran- sition the LOE might make, and the LOE signals each transition \nas it occurs. Without extended dialogs and without shipping any ex- tra data, the LOE keeps its observers \ntightly synchronized with its activities and its current state. Future Work The current LOE compiler \nis only a prototype; we expect to define a more robust version for public use. In particular, efficient \nimple- mentations have been developed for inheritance of synchronization code in concurrent object-oriented \nlanguages, and these appear to apply well to LOEs. Also, the state machine specifications should be expanded \nto include the full expressive power of statecharts, in- cluding and-states, or-states, and composable \nstatecharts. Because subtyping among LOEs must be explicitly declared, multiple type inheritance is not \ncurrently supported. In fact, ex- tending LOEs with a declared form of multiple inheritance raises interesting \nproblems for implementations of LOEs: not unhke the C++ style of multiple inheritance (which we discuss \nelsewhere as subobject-based inheritance [35,36]), an LOE would need to main- tain subjects for each \nof its inheritance paths. We are currently ex-ploring efficient implementations and intuitive semantics \nfor such a feature. We also seek to clarify the interaction of our substitutability relation with the \ndynamic semantics of the language. To explore these relationships, we are developing &#38;loise, a formally-defined \nlanguage of LOEs. One of our goals for Eloise is to try to define the static types so that they prevent \nmessages from being sent objects in the wrong state to accept them. At least one version of Eloise is \nalso intended to explore concurrent LOES. Acknowledgments Thanks to the anonymous reviewers for many \nhelpful suggestions. Thanks to Dan Friedman, Steve Ganz, Erik Hilsdale and Jonathan Sobel for their careful \nreadings and comments. Thanks to Kurt Zimmerman for forcing me to make LOLA usable (and for using it). \nAnd thanks to Vicki Jones for very many helpful conversations. References [1] Martin Abadi and Luca Cardelli. \nA Theory of Objects. Springer-Verlag, 1996. [2] Gul Agha. Actors: A Model of Concurrent Computation in \nDistributed Systems. MIT Press, Cambridge, Mass, 1986. [3] Kim B. Bruce, Angela Schuett, and Robert van \nGent. Poly-TOIL: A type-safe polymorphic object-oriented language. In W. Olthoff, editor, Proceedings \nof the 9th European Confer- ence on Object-Oriented Programming (ECOOP 95), pages 27-51. LNCS 952, Springer-Verlag, \nAugust 1995. [4] Luca Cardelli. A semantics of multiple inheritance. Infor-mation and Computation, 76(2/3):138-164, \nFebruary/March 1988. [5] Luca Cardelli and Peter Wegner. On understanding types, data abstraction, and \npolymorphism. Computing Surveys, 17(4):471-522, 1985. [6] Rance Cleaveland, Joachim Parrow, and Bernhard \nSteffen. The concurrency workbench: A semantics based tool for the verification of concurrent systems. \nACM Transactions on Programming Languages and Systems, 15( 1):36-72, 1993. [7] Derek Coleman, Fiona Hayes, \nand Stephen Bear. Introduc-ing Objectcharts, or How to use statecharts in object-oriented design. IEEE \nTransactions on Software Engineering (TSE), 18(1):9-18, January 1992. [8] William R. Cook, Walter L. \nHill, and Peter S. Canning. In-heritance is not subtyping. In Conference Record of the 17th Annual ACM \nSymposium on Principles of Programming Lan-guages, January 1990. [9] Stephen R. Davis. C++ objects that \nchange their type. The Journal of Object-Oriented Programming, pages 27-32, July/August 1992. [lo] Rocco \nde Nicola. Extensional equivalences for transition sys- tems. Acta Informatica, 24(2):21 l-237, 1987. \n[ 1 l] Krishna Kishore Dhara and Gary T. Leavens. Forcing behav- ioral subtyping through specification \ninheritance. Technical Report TR #95-2Oc, Department of Computer Science, Iowa State University, 1995. \nRevised, 1997. [12] Kathleen Fisher and John C. Mitchell. The development of type systems for object-oriented \nlanguages. Theory and Prac- tice of Object Systems, l(3): 189-220, 1995. [ 131 Erich Gamma, Richard Helm, \nRalph Johnson, and John Vlis- sides. Design Patterns : Elements of Reusable Object-Oriented Software. \nAddison-Wesley, 1994. [14] David Harel. Statecharts: A visual formalism for complex systems. Science \nof Computer Programming, pages 23 l-274, August 1987. [ 151 David Hare1 and Eran Gery. Executable object \nmodeling with statecharts. IEEE Computer, 30(7):31-42, July 1997. [16] David Hare1 and Amnon Naamad. \nThe STATEMATE se-mantics of statecharts. ACM Transactions on Software Engi- neering and Methodology (TOSEM), \n5(4):293-333, October 1996. [ 171 David Hare1 and Amir Pnueli. On the development of reactive systems. \nIn Krzysztof R. Apt, editor, Logics and Models of Concurrent Systems, volume F13 of NATO ASI Series, \npages 477-498. Springer-Verlag, New York, 1985. [ 181 Glenn E. Krasner and Stephen T. Pope. A cookbook \nfor using the model/view/controller user interface paradigm in Smalltalk-80. Journal of Object Oriented \nProgramming, 1(3):26-49, 1988. [ 191 Barbara Liskov. Data abstraction and hierarchy. ACM SIG- PLAN Notices, \n23(5), 1988. OOPSLA 87 Addendum to Pro- ceedings: keynote address. [20] Barbara Liskov and Jeannette \nM. Wing. A behavioral notion of subtyping. ACM Transactions on Programming Languages and Systems, 16(6):181 \nl-1841, 1994. [21] Andrea Maggiolo-Schettini, Adrian0 Peron, and Simone Tini. Equivalences of statecharts. \nIn Ugo Montanari and Vladimir0 Sassone, editors, CONCUR 96: Concurrency Theory, 7th International Conference. \nLNCS 1119, Springer-Verlag, Au-gust 1996. [22] Satoshi Matsuoka, Kenjiro Taura, and Akinori Yonezawa. \nHighly efficient and encapsulated re-use of synchronization code in concurrent object-oriented languages. \nIn Paepcke [29], pages 109-126. [23] Satoshi Matsuoka and Akinori Yonezawa. Analysis of in- heritance \nanomaly in object-oriented concurrent program-ming languages. In Gul Agha, Peter Wegner, and Aki- nori \nYonezawa, editors, Reseaarch Directions in Concurrent Object-Oriented Programming, pages 107-150. MIT \nPress, 1993. [24] Bertrand Meyer. Object-Oriented Software Construction. Prentice Hall, 1988. [25] Robin \nMilner. Communication and Concurrency. Prentice-Hall, 1989. [26] Robin Milner, Joachim Parrow, and David \nWalker. A calculus of mobile processes. (Parts I and II). Information and Com- putation, 100: l-77, 1992. \n[27] Oscar Nierstrasz. Regular types for active objects. In Paepcke [29], pages l-15. [28) Tenth Annual \nConference on Object-Oriented Programming Systems, Languages, and Applications (OOPSLA 95). ACM SIGPLAN \nNotices 30( 1). October 1995. [29] Andreas Paepcke, editor. Eighth Annual Conference on Object-Oriented \nProgramming Systems, Languages, and Ap- plications (OOPSLA 93). ACM SIGPLAN Notices 28(l), October 1993. \n[30] Benjamin C. Pierce and David N. Turner. Simple type-theoretic foundations for object-oriented programming. \nJour-nal of Functional Programming, 4(2):207-247, April 1994. [31] Franz Puntigam. Types for active objects \nbased on trace se- mantics In Proceedings, FMOODS 96, March 1996. [32] Franz Puntigam. Types that reflect \nchanges of object usability. In Proceedings of the Joint Modular Languages Conference (JMLC 97). LNCS \n1204, Springer-Verlag, March 1997. [33] Rational Software Corporation, Cupertino, California. Uni-fied \nModeling Language, Version 1. I Document Set, Septem- ber 1997. [34] Antonio Ravara and Vasco Vasconcelos. \nBehavioral types for a calculus of concurrent objects. In Proceedings, Euro- Par 97, pages 445-561. LNCS \n1300, Springer-Verlag, 1997. [35] Jonathan Cl. Rossie Jr. and Daniel P. Friedman. An algebraic semantics \nof subobjects. In OOPSLA 95 [28], pages 187- 199. [36] Jonathan G. Rossie Jr., Daniel P. Friedman, and \nMitchell Wand. Modeling subobject-based inheritance. In Proceed- ings of the 10th European Conference \non Object-Oriented Programming (ECOOP 96), pages 248-274. LNCS 1098, Springer-Verlag, July 1996. [37] \nJ. Rumbaugh, M. Blaha, W. Premerlani, F. Eddy, and W. Lorenson. Object-Oriented Modeling and Design. \nPren-tice Hall, Englewood Cliffs, New Jersey, 1991. [38] Aamod Sane and Roy Campbell. Object-oriented \nstate ma- chines: Subclassing, composition, delegation, and genericity. In OOPSLA 95 [28], pages 17-32. \n[39] Sally Shlaer and Stephen J. Mellor. Object Lifecycles: Mod-eling the World in States. Yourdon Press \nComputing Series. Yourdon Press (Prentice Hall, Englewood Cliffs, New Jersey), 1992. [40] Chris Tomlinson \nand Vineet Singh. Inheritance and syn- chronization with enabled sets. In Norman Meyrowitz, ed-itor, \nConference on Object-Oriented Programming Systems, Languages, andApplications (OOPSLA 89), pages 103-I \n12. ACM SIGPLAN Notices 24(l), October 1989. [41] Andrew C. Uselton and Scott A. Smolka. A process-algebraic \nsemantics for statecharts via state refinement. In Proceedings of PROCOMET 94, pages 267-286. Elsevier/North \nHolland, 1994. [42] Peter Wegner and Stanley B. Zdonik. Inheritance as an incre- mental modification \nmechanism or what like is and isn t like. In Stein Gjessing and Kirsten Nygaard, editors, European Conference \non Object-Oriented Programming (ECOOP 88), pages 55-77. LNCS 322, Springer-Verlag. August 1988.  \n\t\t\t", "proc_id": "286936", "abstract": "We show how finite-state machines can standardize the protocol used by a component object to notify other interested objects of its state changes, resulting in a more effective use of static types to constrain both parties, and a more efficient dissemination of information. The enhanced component specification is called a <i>logical observable entity</i>, or LOE. We address two key issues in effectively applying such a strategy: how to extend subtyping to consider the state machines, and how to ensure some kind of compliance between the state-machine specification and its implementation. This leads to an unusual subtyping predicate for LOEs on the one hand, and a prototype code generation strategy on the other.", "authors": [{"name": "Jonathan G. Rossie", "author_profile_id": "81100635526", "affiliation": "North Carolina State University", "person_id": "P147423", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/286936.286954", "year": "1998", "article_id": "286954", "conference": "OOPSLA", "title": "Logical observable entities", "url": "http://dl.acm.org/citation.cfm?id=286954"}