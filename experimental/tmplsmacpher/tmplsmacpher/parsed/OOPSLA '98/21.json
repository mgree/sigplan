{"article_publication_date": "10-01-1998", "fulltext": "\n Visualizing Dynamic Software System Information through High-level Models Robert J. Walker and Gail \nC. Murphy Department of Computer Science University of British Columbia 201-2366 Main Mall Vancouver, \nBC, Canada V6T 124 {walker, murphy)@cs.ubc.ca ABSTRACT Dynamic information collected as a software system \nexecutes can help software engineers perform some tasks on a system more effectively. To interpret the \nsizable amount of data gen- erated from a system s execution, engineers require tool sup- port. We have \ndeveloped an off-line, flexible approach for vi- sualizing the operation of an object-oriented system \nat the ar- chitectural level. This approach complements and extends cx- istingprofilingand visualization \napproaches available to engi- neers attempting to utilize dynamic information. In this paper, we describe \nthe technique and discuss preliminary qualitative studies into its usefulness and usability. These studies \nwere undertaken in the context ofperformance tuning tasks. Keywords Software visualization, programming \nenvironments, software structure, program comprehension, execution trace, pcrfor- mance. 1 INTRODUCTION \nEffective performance of many software engineering tasks re- quires knowledge of how the system works. \nGaining the de- sired knowledge by studying or statically analyzing the source code can be difficult. \nStatic analysis, for instance, can help a software engineer determine if two classes can interact, but \nit does not help the engineer determine how many objects of a class might exist at run-time, nor how \nmany method calls might occur between particular objects. Determining answers to these questions requires \nan investigation of dynamic in-formation collected as the software system executes. This Permlsslon to \nmake digital or hard copnes of all or part of this work for personal or classroom use IS granted wthoui \nfee prowded that copws are not made or dlstnbuted for profd or commerce1 advan tage and that copes bear \nthe notlce and the full cltatlon on the first page lo copy otherww, to republish. to post on servers \nor ,o redlstrabute to Itsts. requres pnor speclflc perm,ss~on and/or a fee OOPSLA 98 lo/98 Vancouver. \nB.C. 0 1998 ACM 1.58113.005.8/98/0010...$5.00 Bjorn Freeman-Benson, Darin Wright, Darin Swanson, and \nJeremy Isaak Object Technology International, Inc. 301-506 Fort St. Victoria, BC, Canada VST 1X3 (bnfb, \nDarin-Wright, Darin-Swanson}@oti.com jeremyi@,unixg.ubc.ca dynamic information helps bridge the dichotomy \nbetween the code structure as hierarchies of classes and the execution structure as networks of objects \n[l, p. 3261. Software engineers require tool support to effectively ac-cess and interpret dynamic system \ninformation, because the quantity, level of detail and complex structure of this infor- mation would \notherwise by ovcrwhehning. In creating a tool to help an engineer access this information, two goals \nmust bc paramount: the tool must be usable and it must be useful for the task it is designed to address. \nUsability is defined in terms of practicality and simplicity of interface; usefulness is defined in terms \nof casing the performance or completion of a task of importance, especially in comparison to alternative \nmethods. Many tools have been developed to provide engineers ac- ccss to dynamic information. Profilers, \nfor instance, provide numerical summaries of dynamic information, such as the length of time spent executing \na method. This information can be helpful when trying to tackle some system performance problems. Other \ntasks, however, such as verifying that objects are interacting appropriately according to defined roles \n[6], requires additional structural information. The usefulness of profilers for these types of task \ndegrades because the relevant dynamic information is not evident from a summary numeric value produced \non a per method or per class basis. When structural dynamic information is needed, an engi- necr may \nattempt to use an object-level visualizer (e.g., [ 1, 6, 71). These visualizers provide such displays \nas the interac- tions between objects (or classes) and the number of objects created of each class. When \nthe task requires views involving many classes in a large system, the usability of these tools de- grades, \nas they tend to display complex interactions between multipleobjects in a haze ofcxtraneous, overlain \ninformation. In part to overcome this complexity problem, Sefika ct ul. introduced an architectural-oriented \nvisualization ap-proach [ 141 that allows an engineer to investigate the opcr- ation of the system at \nboth coarse- and fine-grained Icvels. Some of the design choices made in their approach limit its applicability. \nTheir approach is on-line, limiting its useful- ness for some kinds of tasks. Their approach requires \nhard- wired instrument classes to be attached to the system, limiting its flexibility and reducing its \nusability. We have developed an off-line, flexible approach for visu- alizing the operation of an object-oriented \nsystem at an archi- tectural level. Our approach abstracts two fundamental pieces of dynamic information: \nthe number ofobjccts involved in the execution, and the interactions between the objects. WC visu- alize \nthese two pieces of information in terms of a high-level view of the system that is selected by the engineer \nas useful for the task being performed. To represent the informationcollected across a system s cx- ecution, \nWC use a sequence of eels. Each ccl displays ab- stracted dynamic information representing both a particular \npoint in the system s execution, and the history of the execu- tion to that point. The integration of \ncurrent and histori- cal information is intended to case the interpretation of the display by the engineer. \nUsing our prototype, a software en- gineer can navigate both forwards and backwards through the eels \ncomprising views on the execution. Our approach complements and extends existing ap-proaches to accessing \ndynamic system information. Our approach l allows an unfamiliar system to be studied without alter-ation \nof source code, l permits lightweight changes to the abstraction used for condensing the dynamic information, \nl supplies a visualization independent of the speed of exe- cution of the system being studied, and l \nallows a user to investigate the abstracted information in a detailed manner by supporting both forwards \nand back- wards navigation across the visualizations. To investigate the usefulness and usability of \nthe approach, we have performed preliminary, qualitative studies of the use of the technique to aid performance-tuning \ntasks on Smalltalk programs. These studies show that the technique can help software engineers make better \nuse of dynamic system infor- mation when performing tasks such as performance enhance- ment. We begin \nin Section 2 by describing our visualization tech-nique; Section 3 discusses the creation of a visualization. \nIn Section 4, we discuss our initial evaluation efforts intended to assess the usability and usefulness \nof the approach. In Sec- tion 5, we consider the design choices we made in our vi-sualization technique. \nSection 6 describes related work and Section 7 concludes with a description of directions for future \nwork. 2 VISUALIZATION TECHNIQUE Our visualization technique abstracts information that has been previously \ncollected during a system s execution and uses concepts from the field of computer animation to display \nthat information to a user. We begin the description of our technique by focusing on the visualization \nitself, and then de- scribe how a software engineer can construct such a visualiza- tion. Figures I through4 \nshow different views within a visualiza- tion produced during one of our case studies that was inves- \ntigating a performance problem in a reverse engineering pro-gram (Section 4. I). The two windows in Figures \nI and 2 each provide one view-a ccl showing events that occurred within a particular interval of the \nsystem s execution, defined as a set of II events where II is adjustable. The view in Figure 3 shows \na summary view of all events occurring in the trace, and Fig- ure 4 gives a detailed, textual view of \nsome of the information within the summary view. Sections 2.1, 2.2, and 2.3 describe these views in more \ndetail. Full details ofthc running example we use arc provided in Section 4.1. Our prototype permits \na software engineer to easily switch from a particular ccl to the summary view. A user may also move \nthrough the scquencc of eels sequentially or via random access; animation controls. such as play, stop, \nstep forward and step backward, allow a user to review the execution trace and pause or return to points \nof interest. We discuss the navi- gation capabilities of our visualization in Section 2.3. 2.1 Cels A \nccl consists of a canvas upon which are drawn a set of wid- gets. These widgets consist of l boxes, each \nrepresenting a set of objects abstracted within the high-level model (Section 3.2) defined by the engineer, \nl a directed hyperarc bctwecn and through boxes, some of the l a set of directed arcs between pairs of \nboxes, each of which indicates that a method on an object in the dcsti- nation box has been invoked from \na method on an object in the source box, l a bar-chart style of histogram associated with each box, indicating \nthe ages of and garbage collection information about the objects associated with that box, l annotations \nand bars within each box, and l annotations associated with each directed arc. Each box drawn identically \nwithin each ccl represents a particular abstract entity specified by the engineer, and thus, does not \nchange through the animation. The grey rectangles in Figures 1 through 3 labelled Clustering, SimFunc, \nModule-sAndSuch, and Rest are boxes corresponding to abstract enti- tics of the same names. Two of these \nentities, Clustering and SimFunc, each correspond to a class in the rcvcrse engincer- ing tool source; \nthe other two entities represent collections of classes. Stack Clustering -Rest Figure 1: A window showing \nan example ccl in the visualization technique. Figure 2: A window showing the next ccl after that in \nFigure 1 for the same system and execution trace. Figure 3: A window showing the Summary View for the \nsame system and execution trace as shown in Figures 1 and 2. Figure 4: A pop-up window produced by clicking \non the Al- location Pattern histogram for the Clustering entity of Fig- ure 3. The path of the hypcrarc \nreprcscnts the call stack at the end of the current interval being displayed. In Figure 1, the cur- rent \ncall stack only travels between the Clustering and Rest boxes-the hyperarc is marked in red (shown as \na dashed black line herein); in Figure 2, the call stack has extended to SimFunc as well. The set of \ndirected arcs represents the total set of calls be- tween boxes up to the current interval: they arc \ndisplayed in blue (shown as solid black herein). Bccausc the total number of pairs of boxes is manageable, \nthis set does not obscure the rest of the ccl significantly. Multiple instances of interaction between \ntwo boxes are shown as a number annotating the di- rected arc. The same two arcs are shown in Figures \nI and 2 from Clustering to Rest, with 123 calls, and from Rest to Sim-Func, with 122 calls. Object creation, \nage, and destruction are a particular focus within the visualization. Each box is annotated with numbers \nand bars indicating the total number of objects that map to the box that have been allocated and deallocated \nuntil the current interval. The length of a bar for a given box is proportional to the maximum number \nof objects represented by that box over the course of the visualization. The Clustering box of Figure \n1 shows that a total of 1127 objects associated with it had been created to this point in the execution, \nand that 1037 of these had been garbage collected. The histogram associated with each box shows this \ninfor- mation as well, but in a more refined form. An object that was created in the interval being displayed \nhas survived for a single interval; stepping ahead one ccl, if it still exists, the object has survived \nfor two intervals, and so on. The kth bin of the histogram shows the total number of objects mapped to \nthe box that are of age k; to limit the number of bins in the histogram, any objects older than some \nthreshold age 7 arc shown in the rightmost bin of the histogram. The histogram attached to the Clustering \nbox in Figure 1 indicates that all of its 1127 objects were created relatively far in the past, more \nthan 10 intervals before the one being shown here. Colour is used to differentiate those objects that \nstill ex- ist from those that have been garbage collected; each bar of the histogram is divided into \na lower, green part (marked in a vertical-line pattern herein) for the living objects and an up- per, \nred part (marked in an diagonal-line pattern herein) for the deleted objects. In Figure 1, the upper \npart of the bar in Clus- tering s histogram shows that roughly 80% of the old objects have been deallocated. \nYellow (shown as light grey herein) is used both within the box annotations and within histograms to \nindicate a change that just occurred during the interval. More specifically, it is used to show objects \nthat have just been cre- ated or deleted. In Figure 2, which shows the interval immedi- ately after that \nof Figure 1, an additional 324 objects had just been allocated that were related to Clustering. This \nallocation is shown both by the yellow (light grey) portion of the upper bar, and the yellow (light grey) \nbar in the first bin of the his- togram. No complex graph layout algorithms are currently used to produce \nthe views. The drawing package used in the proto- type supports interactive rearrangement of the widgets \nby its user. Each ccl is intended to represent a combination of informa- tion not present in its predecessor \n(in terms of the original ex-ecution) and a summary-to-date of the information in its pre- decessors \nand itself. The new information is difficult to inter- pret in isolation; the context provided by the \nsummary-to-date eases this interpretation. See Section 5.3 for further discus- sion.  2.2 Summary View \n In addition to the individual eels, a summary view is provided to display the overall execution of the \nsystem being studied. This view shows the same boxes, directed arcs, arc annota- tions, and box annotations \nas the final ccl of the animated view. In addition, it displays two histograms per box; these are different \nfrom the histograms in the animated view. One, the allocation pattern, shows the entire execution trace \ndi- vided into a set of ten equal-length intervals; if the trace con- sists of 107r events then each \ninterval consists of 71 contiguous events. The height of each bar represents the number of ob- jects \nallocated in that interval that map to that box. The other histogram, the deallocation age, shows the \nage of every ob- ject associated with the box when the object was garbage col- lected; if an object had \nnot been garbage collected when trac- ing ended, it is displayed in the rightmost bar. For example in \nFigure 3. Clustering s deallocation-age histogram shows that most of its objects were deallocated at \na very young age while the rest still existed when tracing stopped-this is the case for all ofthe boxes \nin this example except ModuJesAnd- Such, whose associated objects were always deallocated at a young \nage. Clustering s allocation pattern is fairly uniform, showing only a slight increase in allocations \nhalfway through execution; on the other hand, SimFunc stopped allocating ob- jects after the halfway \npoint. 2.3 Navigating the Visualization There are three forms of interaction with the visualization: \nview selection, animation contt-01, and detail querying. View selection simply entails choosing between \na sum- mary view, or the detailed, ccl-based view. It would be rea- sonable to allow multiple, simultaneous \nviews, both summary and ccl-based, but this is not provided by the current imple-mentation. However, \nthe off-line nature of this technique (Section 3.1) allows multiple instances of the tool to be run simultaneously. \nAnimation control is provided by several buttons, a slider, and the textual entry of particular values. \nThe buttons are Step Backwards and Forwards (by step-size number of eels), Play, and Stop. The slider \nis used for random access to a ccl in a drag-and-drop fashion. Textual entry is used to specify step- \nand interval sizes, and animation speed; altering the step size allows the engineer to move through the \nanimation more quickly by not showing some ccl+-this allows the animation to proceed more quickly when \nthe redisplay rate of the graphics software and hardware is slower than the desired rate of animation. \nBy default, an interval ends upon an event that caused a frame to be added or removed from the execution \nstack; these events include making or returning from a method call, and generally, each object allocation \nor deallocation. This gran- ularity is generally too fine to be usable-with tens of thou- sands of method \ncalls occurring and similar numbers of ob- jects being created and destroyed, not much changes between \ntwo adjacent eels, and histograms tend to have empty bins ex- cept for the rightmost. Therefore, we allow \nthe engineer to re- set the interval size; a size of ten, for example, indicates that each ccl should \nrepresent the changes to the system produced by ten events. Detail querying allows the engineer to connect \nobserva- tions made via the abstract visualization to the actual classes, object allocations and deallocations, \nand method calls that are being abstracted. This is done by clicking on the appropriate widget for which \ndetails are sought. Arcs, hyperarcs, and his- tograms can be clicked on in this way; all cause a textual \ndia- log window to pop-up (Figure 4). This pop-up window contains a list of the dynamic entities that \nwere associated with the widget of interest. For exam- ple, the pop-up for an arc contains a list of \nall the calls be- tween the boxes connected by that arc; the pop-up for the al- location/deallocation \nhistogram of the animated view gives a list of the objects that mapped to that box, when they were created, \nhow old they were when garbage collected, and what method caused them to be created. Selection of an \nentry within these pop-up windows could be used to automatically position the view in a textual code \nbrowser in a future version of the tool. 3 CONSTRUCTING THE VISUALIZATION A software engineer employs \na four-stage process when using our visualization technique (Figure 5). 1. Data is collected from the \nexecution of the system being studied, and is stored to disk. 2. The software engineer designs a high-level \nmodel of the system as a set of abstract entities that are selected to in- vestigate the structural aspects \nof interest. For example, in Figure 5, utilities and database are specified as en- tities. 3. The engineer \ndescribes a mapping between the raw dy- namic information collected and the abstract entities. Figure \n5, for instance, shows that any dynamic informa- tion whose identifier begins with foo (such as objects \nwhose class name starts with fool ) is to be mapped to the utilities entity. This mapping is applied \nto the raw information collected by the tool, producing an abstract visualization of the dynamic data. \n 4. The software engineer interacts with the visualization, and interprets it to investigate the dynamic \nbehaviour of the system.  The process is deliberately divided into multiple stages to increase its usability. \nRather than having to complete the en- tire process every time any change is required for the task of \ndiscovery, iteration can occur over any suffix of the pro- cess. For example, the software engineer might \nbegin with any extremely coarse view of the program, knowing very lit- tle about its performance; after \ninteracting with the resulting visualization and gaining a partial understanding of the stud- ied system \ns operation, the software engineer need only alter the high-level model and corresponding mapping to \ngenerate a new visualization-there is no need to re-collect the identi- cal dynamic information. This \nprocess is based on the work of Murphy et ul. [ 121. We compare our visualization technique to this previous \nwork in Section 6. 3.1 Stage 1: Gathering Dynamic Information Dynamic system information is collected \nfor every method call, object creation, and object deletion performed by the sys- tem being investigated. \nIn other words, trace information is collected. This information currently consists of an ordered list \nof: l the class of the object calling the method or having the object created, and l the class of the \nobject and method being called or retum- ing from, or the class of ob.ject being created or deleted. \n Since the tool currently uses complete tract information, the complete call stack for any given moment \ncan be recon- structed. Stage 1 Stage 2 foo* --> utilities Stage 3 Stage 4 Figure 5: The process. Because \nour implementation is in Smalltalk, this informa- tion is collected by instrumenting the Smalltalk virtual \nma-chine (VM) to log these events as they occur. There is nothing inherent in the tool in its USC of \nSmalltalk; it could be as eas- ily implemented in any language in which the execution was instrumented \nto collect the required infonnation. Because a software engineer often needs to understand dy- namic \nproblems that only occur after significant initialization of the studied system, the collection of the \ntract information needs to be performed only during portions of the execution. This eliminates extraneous \ninformation not of interest, and speeds up the process of collection. In our implementation, VM methods \nare available to dynamically activate and dcac- tivate tracing. We used these methods to collect data \nfor Fig- ures 1 through 4 that included only the main iteration loop of the algorithm, excluding execution \npertaining to initialization and the output of results. 3.2 Stage 2: Choosing a High-level View The \nsoftware engineer typically begins an investigation with some idea of the static structure of the system \nbeing studied. Even when this is not the case, the naming conventions and organization of the source \ncode itself often allow some guess as to the system s structure. The engineer chooses a high-level structural \nview to use as the basis for visualization by stating the names of the abstract entities. These entities \nmay correspond to actual system com- ponents, be aggregates or subdivisions thereof, or have little connection \nto reality. In Figures 1 through 4, for instance, the investigator chose two entities representing specific \nclasses in the program (Clustering and SimFunc), and two entities rep- resenting collections of classes \n(Rest and ModufesAndSucb). 3.3 Stage 3: Specifying a Mapping For the tool to indicate the dynamic interactions \nbetween the abstract entities, it needs to have a map relating dynamic sys- tem entities to the abstract \nones. A map indicates that specific system entities, such as objects of a given class or methods matching \na particular pattern, are to be represented by a spe- cific abstract entity (and thus, by a box in the \nvisualization). An engineer states this mapping using a declarative mapping language. To be usable, a \nmapping language must allow an engineer to easily express the relationships between entities. The mapping \nlanguage s constructs are based on the stan- dard Smalltalk notion of structural hierarchy: methods are \ngrouped into classes, classes into categories, categories into subapplications, and subapplications into \napplications. A map consists of an ordered set of entries, each of which has three parts: a name indicating \nthe level of the Smalltalk structural hi- erarchy being mapped, a regular expression indicating the set \nof names to map for the particular structural hierarchy level being mapped, and the name of the abstract \nentity to which these dynamic system entities are to be mapped. Methods are provided for mapping a class \nregular cx-pression plus method regular expression simultaneously, and subapplication, class, category, \nand method simultaneously. For example, say the engineer has defined an abstract entity named f oo, and \nevery message foo passed to classes named *bar* within the subapplications dog* should be mapped there; \nthis would be indicated by a map entry: matchingSubApplication: Idog*' class: '*bar*' category: I*' method: \n'fool mapTo: 'foe'. The example in Figures 1 through 4 used the following map: matchingclass: 'ArchClusteringAnalysis' \nmapTo: 'Clustering' matchingclass: 'ArchModuleGroup' mapTo: 'ModulesAndSuch' matchingclass: 'ArchProcedure' \nmapTo: 'ModulesAndSuch' matchingclass: 'ArchSymbol' mapTo: 'ModulesAndSuch' matchingclass: 'ArchSimFunc' \nmapTo: 'SimFunc' matchingSubApplication: 'Schwanke*' mapTo: 'Rest' Because we are interested in visualizing \nthe interactions between system components, the tool takes note both of the method being called and the \nmethod being executed when it was called. The same set of map entries is used to map both; the visualization \nitself will differentiate between incom- ing and outgoing calls. Individual objects are also mapped in \nthis way. Because it is often important where an object was created, we track ob- jects not simply based \non their class, but also in terms of the call stack that was present when it was created. Such an object \nwill typically be mapped to a particular abstract entity through the mechanism described above; the object \nis treated as be- longing to that abstract entity and is represented through its visualization (i.e., \nthrough its representation as a box). The mapping possesses two important properties: it is pal-- tial \nand it is ordered. The ordering means that each system entity is mapped to a single abstract entity, \nthe first one for which the map entry is a valid match. The mapping is par- tial because a software engineer \ndoes not need to express the structure of the entire system before investigating it. If a sys- tem entity \nfails to match every entry in the map, it is not rep- resented in the resulting visualization. This feature \nboth de- creases the overhead for the tool and removes unwanted in-formation from the visualization. \nIf the engineer wants every dynamic entity to appear in the visualization, a final entry in the map of \nthe form: matchingAnythi.ng: I*' mapTo: 'default' will act as a default abstract entity for all dynamic \nentities that fall through the other map entries. 4 EVALUATION Three fundamental questions that must \nbe answered about any software visualization arc: . Is the technique useful to software engineers trying \nto perfonn a task on a system? . Is the technique usable by software engineers? . For what kinds of software \nengineering tasks is the visu- alization helpful? Evaluating a technique against each of these questions \nre- quires a number of careful, in-depth studies. These studies are warranted only after an initial determination \nof the coarse- grained utility of a technique. In this paper, we report on re- sults from ourpreliminary \ninvestigations into the utility of our visualization technique. In our preliminary investigations, we \nchose to fix the kind of software engineering task studied to be performance tun- ing. This task was \nchosen because it is heavily reliant on dy- namic system information and because it tends to be delc- \ngated to expert developers. A visualization technique that can aid a non-expert developer in tackling \nperformance prob- lems would thus be beneficial in increasing the use of dynamic system information by \nengineers, which was one of our initial goals. We also chose to focus on the usefulness of the technique, \nrather than its usability. This decision was reasonable because the main features of the technique affecting \nits usability have been investigated in other related domains. The iterative se- lection of the high-level \nentities and designation of the map- ping by the software, for instance, are also characteristic of the \nsoftware reflexion model approach from which this visu- alization technique is derived. Users of the \nsoftware reflex- ion model approach have not had difficulties performing these steps [IO, II]. Our preliminary \nstudies, then, focus on investigating the usefulness of the visualization. We report on two case stud- \nies. The first case study (Section 4.1) discusses the use of the visualization technique by one of the \nauthors to determine why a Smalltalk implementation of a reverse engineering al- gorithm [ 131 was running \nslower than expected. In this sce- nario, we focus on the differences in information provided by the \nvisualization technique compared to a profiler. In the sec- ond case study (Section 4.2) we had both \nan expert and a non- expert Smalltalk developer use the visualization to attempt to discover the cause \nof a performance problem with the visu- alization technique itself. We report on both qualitative and \nquantitative data collected about the use of the visualization. 4.1 Case Study #l A hierarchical agglomerative \nreverse engineering algorithm attempts to automatically cluster entities, such as procedures in a C program, \ncomprising a software system into subsystems (modules) based on a similarity function. One of the authors \nwanted to determine why a Smalltalk implementation of a par- ticular algorithm [ 131 executed significantly \nmore slowly than a C++ implementation. The algorithm starts by placing each procedure in a separate module. \nIt then iteratively computes the similarity function between each possible pair of modules; in each iteration, \nthe most similar pair of modules is combined. The algorithm ter-minates when a specified number of modules \nare left or when no modules are similar enough to be combined. The performance investigator had knowledge \nof the design of each program, but had not implemented either program. To examine the performance of \nthe Smalltalk implementation, the investigator first used the IBM VisualAge for Smalltalk execution profiler. \nWith this tool, a user can either sample or trace the execution of an application, and then view col- \nlected statistics, such as the amount of execution time spent in particular methods or the number of \ngarbage collection scav-enges. After perusing several of these views, the investiga- tor determined about \n16% of the execution time was spent inmethodsofthe ArchClusteringAnalysis class that contains the main \niteration loop, 5.5% was spent in methods of the ArchCache class that acts as a cache for already com- \nputed similarity values, and 4.6% was spent in computing new similarity values. This result was not surprising. \nThe infor- mation confirmed the investigator s understanding of how the program works, but did not provide \nany hints as to whether the performance could be enhanced. The investigator next applied the visualization \ntech- nique, choosing a high-level model consisting of four entities. One entity, Clustering, represented \nthe ArchClusteringAnalysis class. Another, SimFunc, represented the class that had methods for computing \nthe sim- ilarity function. A third, ModulesAndSuch, represented the functions and modules whose similarity \nwas to be compared, and a fourth, Rest, represented all other classes comprising the program. The mapping \nassociated the appropriate classes (and sub-applications) with these boxes. The investigator collected \ntrace information for the main iteration loop of the program and then began interacting with the visualization. \nPlaying through the abstracted information, the investigator noted the large number of objects (over \n4500) associated with the SimFunc entity. The investigator viewed the summary and queried it for the \nobjects associated with SimFunc s box. The object list contained many Set and Me thodCon text objects \n(Figure 4). These results confirmed that the cost of computing the similarity between two modules was \nhigh and should be minimized. Returning to a play through the vi- sualization, the investigator noted \nthat the ratio of calls from Clustering to Rest and from Rest to SimFunc was lower than expected. Prior \ninvestigation had shown that the majority of the calls between Clustering and Rest were due to calls \non the ArchCache object; calls from Rest to SimFunc represent new computations of similarity. This insight \nled the investi- gator to study the ArchCache class. The investigator found that the key value used to \nstore and access similarity values in the cache was not causing as many hits as it could. A slight modification \nto the formation of keys resulted in an increase of just over 25% in the speed of the program. The visualization \ntechnique aided this performance-tuning task by presenting information that caused the investigator to \nask, and answer, the right questions about the implementa- tion. Insight into structural interactions \nin the system helped the investigator narrow in on the algorithmic problem. The in- vestigator made use \nof the both the interaction and object al- location and deallocation information, the summary view, and \nthe ability to play, and re-play, through the traced execution. 4.2 Case Study #2 In the second case \nstudy, the tool was used to investigate its own performance problems; specifically, due to a structural \ndesign flaw, it was faster to step forward than to step back- ward in the visualization tool. This flaw \ncentered on the fact that the implementor had chosen to generate eels on the fly and often used simple \nlinked lists to hold the required information for the arc annotations; as a result, adding to these lists \nvia the method A better design for the program would have been to hide the cache behind the ArchSimFunc \ninterface. addInteractionsFrom:to:between: system for an hour, the participant decided that the likeliest \nwas fast, but removing from the lists via removeInteractionsFrom:to:between: required a linear-order \nsearch through each list. The imple- mentor of the tool had discovered this flaw and informed the experimenters \nof its existence and its cause. To prepare for the studies, the experimenters gathered a tract consisting \nof stepping forwards and backwards in the visualization tooL2 An initial high-level model and mapping \nwere also prepared for the participants as the short study peri- ods were intended to focus on the visualization \nitself, rather than the process of creating a visualization. The high-level model was very simple, and \ncan be seen in the visualization shown in Figure 6; the classes used by the tool all had names that began \nwith a two- or three-letter prefix, and thus were mapped to abstract entities with these prefixes as \nnames. In a separate session each, a previously collected trace was given to two experimental participants: \nan expert at solv- ing performance problems in Smalltalk applications, and a non-expert in solving performance \nproblems in any language. Each participant was given an introduction to the tool and a short training \nsession in which each had the opportunity to USC the tool on a toy problem. Then, the symptom of the \nflaw in the tool was explained, and the parameters and interaction that we had traced were described. \nEach was asked to detcr- mine three or fewer points of interest within the source code for the tool that \nthey saw as being good candidates for more detailed analysis; they were also asked to answer a set of \nques- tions periodically in regards to their perceptions of the tool and progress in their task. We audio-taped \nthese question and answer sessions. We also captured automatically a log of the participants navigation \npattcm through the visualization us-ing instrumentation built into the prototype. 4.2.1 The Expert Participant \nThe expert participant began with a ten-minute inspection of the summary view: the Gp box was seen to \nhave the most objects allocated, and most of these were immediately deal-located. Querying the attendant \nAllocation Pattern histogram showed that many of these objects were of the classes Point, MethodContext, \nand BlockContext. The animated view was then used, both in step forward and backward mode and in play \nmode, to examine the range ofcels where many of these objects were being allocated; a repetitive call \npattern was observed between the Gp and Cdf boxes. The arcs and hyperarcs between these boxes were queried \nfor de- tails, and the methods involved in this pattern were found by the participant. A separate code \nbrowser was then used to in- vestigate the details causing this behaviour. After studying the The visualizationtool \nhad to berm on a different, prc-existing execution trace. A toy example was used for this purpose,but \nchoice ofinput was not a factor in the tool s symptoms. The second participant actually received a trace \nofonlya step backwards. cause was in the methods l removeInteractionsFrom:to:between:,and l addInteractionsFrom:to:between:. \n The participant noted the similarity of code in these two meth- ods. This observation made sense because \nthe fundamental problem was due to the data structure. The participant was thus able to indicate a useful \npoint to continue the investiga- tion, as had been requested at the start of the study. The expert participant \nliked two features of the tool in par- ticular: l the summary view, although the participant stated: \nin this case [the effect] was slightly obvious [in the sum- mary view]-it may not be so obvious in other \ncases ; and l the animation of the hypcrarc resulting from pressing play , because of the way one can \nwatch how things go into loops or circles or watch the communication back and forth between different \nthings, or specific things. The expert participant felt the tool lacked two desirable fea- tures: integration \nbetween it and a traditional code browser, so one could, for example, select a method in a pop-up detail \nwindow and have the code browser display that method; and the lack of ability to view a detailed stack \ndump, com- parable to that available from a Smalltalk debugger, par- ticularly so that the parameter \ntypes being passed could be seen (this cannot be seen from the static code because Smalltalk is dynamically \ntyped). The actual values being passed were deemed desired in some instances. Code browser integration \nis a desired feature that has not yet been implemented; the tool has been designed to accom- modate this \nchange. The tool did allow the participant to nar- row the search to particular points of interest that \ncould then be investigated via a debugger or similar means. The desire for greater, integrated information \nfrom the tool is understand- able, but runs contrary to its design philosophy of comple- menting existing \ntechniques-it is not intended to supercede the use of a debugger. This desire also highlights the tension \nbetween off-line and on-line approaches to accessing dynamic information. 4.2.2 The Non-Expert Participant \nThe non-expert participant made extensive USC of both the ob- ject histograms and the allocation/deallocation \nbars in the de- tailed view to investigate the performance problem. Specif-ically, the participant would \nfind eels in which object deal- location was not keeping pace with object allocation (i.e., Figure 6: \nCase study #2 visualization. the green bar--shown herein via a vertical-line pattern-was longer than \nthe red bar-shown herein via an diagonal-line pattern-within a box) and would then step forward to see \nwhen objects were being allocated. Queries on the associated histograms were then used to determine the \nclasses of the al- located objects. Less frequently, the participant would inves- tigate the calls involved \nwith the allocations. For the first forty minutes, the participant worked solely with the visualization \ntool. After that, the participant be-gan to use the Smalltalk code browsers to study the asso- ciated \ncode. After approximately an hour with the tool, the participant had identified two methods, including \nthe removeInteractionsFrom method, as a point in the code at which to continue the investigation. This \ndetermina- tion was based, in part, on noticing a correlation between an increase in message sends between \nthe Gp and Cg boxes and the number of objects allocated by Cg. Similar to the case of the expert participant \nthen, the non-expert found the correct area of code to investigate, which was the task that had been \nposed. The non-expert found the deallocation age histograms and the ability to determine the correlation \nbetween abstract in- formation to method and object names by clicking on his- tograms and interactions \nin the visualization particularly help-ful. However, the non-expert indicated a desire for different \ndisplays of this information, finding the screen with all the methods [was] too cluttered . Similar to \nthe expert, the non- expert desired more integration with other Smalltalk tools, such as the code browser. \nFor instance, the participant wanted to be able to select a call from a list of interactions and visit \nthat call site in the code. During an interview part of the way through the study pe- riod, the participant \nnoted that it was difficult to attack the task because of a lack of knowledge of what could cause perfor- \nmance problems. The visualization tool provided some clue as to how to proceed because of its emphasis \non particular dy- namic information. The applicability of the dynamic informa- tion chosen for other \ntasks requires further research. 5 DISCUSSION Key features of our technique include off-line operation, \na navigable visualization of the collected data, eels based on a running summary, and the use of a declarative \nmapping to abstract fine-grained information about a system s execution. We discuss each of these features \nand our use of trace infor- mation. 5.1 Off-line Operation Using an on-line visualization technique can \nbe a slow, unidi- rectional procedure. Taking the technique off-line and sepa- rating the visualization \nfrom the system execution can achieve two benefits. First, it allows the information to be preprocessed \nas a whole prior to visualization, enabling the generation of sum- mary information about the entire \nexecution. For the perfor- mance tuning tasks described in the case studies, summary in- formation was \nused to provide clues about which parts of the system to investigate as potential sources of the problem. \nAf- ter accessing summary information, the users returned to in- vestigate detailed parts of the execution. \n Second, it allows any partial trace of an execution to be rc- viewed without having to re-run the entire \nexecution, This re- view capability permits the visualization to be navigable in a way that is not possible \nfor an on-lint technique. Not only may the trace be replayed from any arbitrary point, but also it may \nbe played backwards, or at a rate that is independent of the speed of the original execution of the system \nbeing stud- ied.  5.2 Navigable Visualization One advantage of an off-line visualization approach is \nthe navigation capability provided to the software engineer. The user can unfold the execution in a forward, \nplay , mode, but then can perform detailed investigations of particular parts of the execution by moving \nthe visualization both forward and backward. In our current prototype, we do not associate any information \nabout the actual execution time with the off-line navigation. Each step forward or backward in our visualiza- \ntion takes time proportional to the display time of the next ccl, rather than representing the length \nof time required by an asso- ciated method call, allocation or garbage collection. For some tasks, including \nperformance tuning, it would sometimes be helpful to have steps between eels represent the system run- \nning time. 5.3 Running Summary We believe that separately displaying individual events, or small groups \nof contiguous events, makes for an insufficient visualization of a systetn execution because of a lack \nof con- nection to the greater context of that execution. Some sort of summary information is also needed. \nWC considered two means of providing such summary in- formation: a single summary picture, such as that \nin Figure 3, and a set of pictures showing the change to the state of the system over individual intervals \nof its execution ( delta in-formation), which is not provided by our tool. But neither alone would be \nsufficient to illustrate the dynamic nature of the information we arc attempting to visualize. The sum-mary \npicture clearly does not contain any temporal ordering of events-it is difficult to look at one and mentally \nrccon-struct the sequence of events that produced it. Furthermore, this summary alone cannot contain \nenough detail about the cx- ecution to be useful without becoming so cluttered that it is rendered unusable. \nDelta pictures address the concern of visu- alization of the temporal nature of the information; however, \nit is difficult to understand the relationship between a delta picture and the execution in toto. To \nreach a compromise be- tween these alternatives, we chose to provide a running sum-mary of the execution \nwithin the individual eels. This im- plicitly provides the temporal component of the summary in- formation \nwhile maintaining context for the delta information within a tel. Two other alternatives to maintain \ncontext are possible. In the first, we could begin with a summary view such as that provided by our tool. \nBut rather than being a single, static picture, it could also be divided into a sequence of eels each \nof which would show the same summary infonnation while highlighting in a different colour, say, the information \nthat was changed or added over the reprcscnted interval, such as the di- rccted arcs that were traversed, \nor the subset of objects that were deallocated. The second alternative is similar, but in- stead of highlighting \nonly the information that is different for that interval, a running summary of all the information that \nhad changed from the start of execution of the system to the current interval would be highlighted. Both \ncan suffer from the fact that a complete summary view can quickly become too detailed, leading to information \noverload. However, both these schemes could be used to complement the delta plus running-summary combination \ncurrently used in our eels; we have not yet investigated this possibility. 5.4 Mapping Objects Each \nccl maps objects to abstraction units. Associating an ob- ject with an abstraction unit using our declarative \nmapping ap- proach requires a means of naming objects. We chose to name--more precisely, identify--an \nobject based on where it is created in the code: a software engineer identifies objects mapping to a \nparticular abstraction unit by describing a part of the call stack that exists when one of the objects \nis created. This approach has the advantage that an engineer can identify collections of objects by perusing \nthe source code and describ- ing the locations where relevant allocations occur. Another possible choice \nwould be to name objects based on their class. However, this approach to naming would not allow objects \nof the same class to be mapped to different abstraction units, lim- iting the ability of the engineer \nto differentiate distinct uses of classes. Currently, the mapping provided by the engineer is applied \nuniformly to all dynamic information collected as the system executes. A ratnification of this decision \nis that once an ob- jcct is associated with an abstraction unit, it remains associ- ated with that unit \nfor the duration of the visualization. Some-times. though, it may be useful to modify the association \nof objects to abstraction units over the course of the execution. For instance, if an object is created \nin one subsystem, but is then immediately passed as an argument to another subsys- tem, it may bc useful \nto capture the migration of the object. Supporting this migration would require not only a means to allow \nthe engineer to describe when and how the migration would occur, but also would require updates to the \nuse of his- tograms for object allocationand deallocation. Further under- standing of how this capability \nmight help in the performance of tasks is required before support is added. 5.5 Dynamic Information \nOur current prototype visualizes trace information collected about a system s execution. Trace information \nhas the ben- efit that it is complete: all object interactions, allocations, and deallocations are included \nin the trace. Complete infor- mation is easy for the engineer to reason about. However, trace information \nhas the often cited problem of being volu- minous [9,2,8]. Tracing even small pieces of a system s exe- \ncution can result in a huge amounts of data. Although we have been able to successfully use trace data \nto investigate some performance problems, the use of trace information limits the flexibility and usability \nof our current prototype. We plan to investigate the USC of sampled information as a basis for our prototype \nto overcome some of these limitations. 6 RELATED WORK De Pauw et al. have developed a number of visualizations \nto describe the execution of an object-oriented system, includ- ing inter-class call cluster diagrams, \ninter-class call matrices, a histogram of instances, and an allocation matrix [ 11. All of these visualizations \nshow fine-grained execution informa- tion about individual classes and objects. The utility of these \nvisualizations degrades as the size, measured in the number of classes, of a system grows. Several other \nsimilar object-and class-level visualization approaches have been developed [z;., [6,5]); these techniques \nshare the same scalabilityprob- Lange and Nakamura in the Program Explorer tool allow the developer to \nintegrate, off-line, static and dynamic infor- mation about a program to aid comprehension activities \n[7,8]. For instance, they show how this combination of information can help a developer find and investigate \ninstances of design patterns in a system. The visualizations they produce are also at a fine-grained \nlevel. Vlissides et al. use a different notion of pattern, which they refer to as execution patterns, \nto help developers investigate the large amount of fine-grained cxe-cution information available about \na system [3]. Specifically, they allow a developer to query an on-line animation for pat- terns appearing \nin a dynamic execution stream. In both the Program Explorer and execution pattern approaches, the de- \nveloper must apply detailed knowledge about a system to for- mulate appropriate queries. Jerding et al. \nhave applied the information mural approach to create a scalable visualization of fine-grained program \nevents [4]. The result, an execution mural, places classes vertically on the screen and uses single pixel \nvertical bars, with various colouring approaches, to indicate calls between classes. The interactions \noccurring in the system are then shown across the screen. Using this approach, thousands of interactions \noccurring between objects can be visualized on one screen. The authors extend these ideas to a Pattern \nMu- ral that provides an information mural display of automati- cally detected common occurring sequences \nof calls (patterns) in the execution. Although this approach may help a devel- opcr find unexpected patterns, \nor verify existing patterns in the code, it still visualizes only fine-grained informationabout the system. \nThe approach taken by Sefika et al. differs in allowing a dc- veloper to utilize coarse-grained system \ninformation to pro- duct visualizations [ 141. Using their technique, a developer may introduce various \nabstractions into the system instrumen- tation process, including subsystem, framework and pattem- level \nabstractions. The abstractions can then be used as a ba- sis for several visualizations including affinity \nand ternary dia- grams. The coarser-grained visualizations produced with this technique make it easier \nfor developers to investigate inter-component interactions in large systems than previous ap-proaches. \nSome of the design decisions Sefika et al. made in devel- oping their technique limit its flexibility. \nChoosing an on-line approach permits a link between the speed shown in the vi- sualization and the execution \nspeed. However, as we have discussed, an on-line approach limits the modes of investi- gation available \nto an engineer. Choosing an approach that hard-wires the abstractions of interest into the instrumentation \nprocess provides an effective data gathering mechanism; how- ever, it decreases the usability of the \ntechnique by making it more difficult for an engineer to apply it to a new system. WC have been able \nto easily apply our technique to different sys-tems because of the separation in our process between \ndata gathering and visualization. Our visualization technique builds on the softwarereflexion model technique \ndeveloped by Murphy et al. [ 12, lo]. The re- flexion model technique helps an engineer access both static \nand dynamic information about a system by enabling a com- parison between a posited high-level model \nand a model rep- resenting information extracted from either the static source or from a system s execution. \nSimilar to our visualization tech-nique, the software reflexion model depends on a declarative mapping \nlanguage. Our visualization technique extends the reflexion model work in three fundamental ways: by \napplying the abstraction approach across discrete intervals of the exe- cution with animation controls, \nby providing support to map dynamic entities rather than only static entities, and by map- ping memory \naspects of an execution in addition to interac- tions. Our visualization technique also uses the running \nsum-mary model rather than the complete summary model used in the reflexion model approach. 7 SUMMARY \nAND FUTURE WORK Condensing dynamic information collected during a system s execution in terms of abstractions \nthat represent coarse sys- tem structure, such as frameworks and subsystems, can help software engineers \ninvestigate the behaviour of a system. We have developed a visualization technique that allows engi-neers \nto flexibly define the coarse structure of interest, and to flexibly navigate through the resulting abstracted \nviews of the system s execution. Our approach complements and extends existing visualization techniques. \nOur preliminary investigations into the usefulness and us- ability of the visualization indicate it shows \npromise for en- hancing a software engineer s ability to utilize dynamic infor- mation when performing \ntasks on a system. To date, we have focused on the use of dynamic information to aid one partic- ular \nsoftware engineering task-performance tuning. We in- tend to continue our investigations into the utility \nof the en- tire technique through more extensive case studies on a wider range of tasks on larger systems. \nAlthough there is evidence elsewhere [ 10, 1 l] that the iterative mapping approach is us- able for static \ninformation, our further studies will investigate if this remains true for dynamic information. ACKNOWLEDGMENTS \nThis work was funded by a British Columbia Advanced Sys- tems Institute Industrial Partnership Program \ngrant, by OTI, Inc., and by an NSERC research grant. We thank Edith Law for participating in the case \nstudy, and we thank the anony- mous reviewers for their comments. REFERENCES [II W. De Pauw, R. Helm, \nD. Kimelman, and J. Vlissides. Visualizing the behavior of object-oriented systems. In Proceedings of \nthe 1993 ACM Conference on Ohject- Oriented Programming, Systems, Languages, and Ap- plications (OOPSLA \n93), pp. 326337, 1993. W. De Pauw, D. Kimelman, and J. Vlissides. Model-ing object-oriented program execution. \nIn Proceedings of the 8th European Conference on Object-oriented Pro- gramming (ECOOP 94), pp. 163-182, \n1994. PI [31 W. De Pauw, D. Lorenz, J. Vlissides, and M. Wegman. Execution patterns in object-oriented \nvisualization. In Proceedings of the 4th USENIX Conference on Object- Oriented Technologies and Systems, \npp. 219-234,1998. [41 D. Jerding, J. T. Stasko, and T. Ball. Visualizing inter-actions in program executions. \nIn Proceedings of the 19th International Conference on Softwure Engineering, pp. 360-370,1997. [51 K. \nKoskimies and H. Mossenbock. Scene: Using sce-nario diagrams and active text for illustrating object- \n [61 [71 PI [91 [lOI [Ill [I21 [I31 [I41 oriented programs. In Proceedings of the 18th Inter national \nConference on Software Engineering, pp. 366 375,1996. C. Laffra and A. Malhotra. Hotwire-a visual debugger \nfor C++. In Proceedings ofthe USENIX C+ + Technical Conference, pp. 109-122, 1994. D. B. Lange and Y. \nNakamura. Interactive visualization of design patterns can help in framework understanding. In Proceedings \nqf the 1995 ACM Conference on Object- oriented Programming, Systems, Languages, and Appli- cations (OOPSLA \n9S), pp. 342-357, 1995. D. B. Lange and Y. Nakamura. Object-oriented program tracing and visualization. \nComputer, 30(5):63-70, May 1997. J. R. Larus. Efficient program tracing. Computer, 26(5):52-61, May 1993. \nG. C. Murphy. Lightweight Structural Summarization as an Aid to Software Evolution. Ph.D. Dissertation, \nDe-partment of Computer Science and Engineering, Univer-sity of Washington, 1996. G. C. Murphy and D. \nNotkin. Reengineering with re-flexion models: A case study. Computer, 30(8):29-36, August 1997. G. C. \nMurphy, D. Notkin, and K. Sullivan. Software re- flexion models: Bridging the gap between source and \nhigh-level models. In Proceedings of the ACM SIG-SOFT Symposium on the Foundations of Software En- gineering, \npp. 18-28, 1995. R. Schwanke. An intelligent tool for re-engineering soft-ware modularity. In Proceedings \nof the 13th Interna- tional Conference on Software Engineering, pp. 83-92. 1991. M. Sefika, A. Sane, \nand R. H. Campbell. Architecture-oriented visualization. In Proceedings ofthe I996 ACM Conference on \nObject-oriented Programming, Systems, Languages, and Applications (OOPSLA 96), pp. 38% 405, 1996.  \n  \n\t\t\t", "proc_id": "286936", "abstract": "Dynamic information collected as a software system executes can help software engineers perform some tasks on a system more effectively. To interpret the sizable amount of data generated from a system's execution, engineers require tool support. We have developed an off-line, flexible approach for visualizing the operation of an object-oriented system at the architectural level. This approach complements and extends existing profiling and visualization approaches available to engineers attempting to utilize dynamic information. In this paper, we describe the technique and discuss preliminary qualitative studies into its usefulness and usability. These studies were undertaken in the context of performance tuning tasks.", "authors": [{"name": "Robert J. Walker", "author_profile_id": "81350587870", "affiliation": "Department of Computer Science, University of British Columbia, 201-2366 Main Mall, Vancouver, BC, Canada V6T 1Z4", "person_id": "PP42051773", "email_address": "", "orcid_id": ""}, {"name": "Gail C. Murphy", "author_profile_id": "81336491450", "affiliation": "Department of Computer Science, University of British Columbia, 201-2366 Main Mall, Vancouver, BC, Canada V6T 1Z4", "person_id": "PP42052542", "email_address": "", "orcid_id": ""}, {"name": "Bjorn Freeman-Benson", "author_profile_id": "81100123282", "affiliation": "Object Technology International, Inc., 301-506 Fort St., Victoria, BC, Canada V8T 1X3", "person_id": "P30954", "email_address": "", "orcid_id": ""}, {"name": "Darin Wright", "author_profile_id": "81100660225", "affiliation": "Object Technology International, Inc., 301-506 Fort St., Victoria, BC, Canada V8T 1X3", "person_id": "P59852", "email_address": "", "orcid_id": ""}, {"name": "Darin Swanson", "author_profile_id": "81100070973", "affiliation": "Object Technology International, Inc., 301-506 Fort St., Victoria, BC, Canada V8T 1X3", "person_id": "P59851", "email_address": "", "orcid_id": ""}, {"name": "Jeremy Isaak", "author_profile_id": "81342498261", "affiliation": "Object Technology International, Inc., 301-506 Fort St., Victoria, BC, Canada V8T 1X3", "person_id": "P138756", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/286936.286966", "year": "1998", "article_id": "286966", "conference": "OOPSLA", "title": "Visualizing dynamic software system information through high-level models", "url": "http://dl.acm.org/citation.cfm?id=286966"}