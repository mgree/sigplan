{"article_publication_date": "10-01-1998", "fulltext": "\n Data groups: Specifying the modification of extended state K. Rustan M. Leino Compaq Systems Research \nCenter 130 Lytton Ave., Palo Alto, CA 94301, U.S.A. www.research.digital.com/SRC/people/Rustan-Leino \nrustan@pa.dec.com Abstract This paper explores the interpretation of specifications in the context of \nan object-oriented programming language with subclassing and method overrides. In particular, the paper \nconsiders annotations for describing what variables a method may change and the interpretation of these \nannotations. The paper shows that there is a problem to be solved in the spec- ification of methods whose \noverrides may modify additional state introduced in subclasses. As a solution to this prob- lem, the \npaper introduces data groups, which enable mod- ular checking and rather naturally capture a programmer \ns design decisions. 0 Introduction Specifications help in the documentation of computer pro- grams. Ideally, \nspecifications can be used by a mechanical program analyzer to check the body of a method against its \nspecification, attempting to find errors. The Extended Static Checkers for Modula-3 [DLNS98, L.N98b, \nDet961 and for Java [ESC], which work on object-oriented programs, are examples of such program checkers. \nThis paper concerns the spectication of methods. A method specification is a contract between the implemen- \ntation of a method and its callers. As such, it includes a precondition, which documents what a caller \nmust establish before invoking the method. Consequently, the implemen- tation can assume the precondition \non entry to the method body. A method specification also includes a postcondition, which documents what \nthe implementation must establish on exit. Consequently, the caller can assume the postcondi- tion upon \nreturn from the method invocation. When reason- ing about method implementations and calls, only the \ncon- tract given by the specification is used. That is, one does Permlssnn to make dlgttal or hard copies \nof all or part of this work for personal or classroom use ,s granted wlthout fee prowded that copes are \nnot made or distributed lor proflt or commercial advan- tage and that copnes bear the notice and the \nfull c~tat~o on the first page. la copy otherwse. to republwh, to post on servers or to redlstnbute to \nIwts, reqwres prwr specific perm~sston and/or a fee. OOPSLA 98 lo/98 Vancouver, B.C. 0 1998 ACM l-581 \n13.005.8/98/0010...$5.00 not use the code in a method s callers when reasoning about the method implementation, \nand one does not use the imple- mentation when reasoning about the calls. To be useful to the caller, \nit is important that the postcon- dition of a method detail what variables the method does not change. \nBut since the scope of the caller can include vari- ables that are not visible in the scope where the \nmethod is declared and specified, it is not possible to explicitly list all unchanged variables in the \nmethod s postcondition. Instead, the annotation language must include some form of syntactic shorthand \n( sugar ) whose interpretation as part of the post- condition is a function of the scope in which it \nis interpreted. A nice construct for this is the modifies clause, which lists those variables that the \nmethod is allowed to modify, thereby specifying that the method does not modify any other vari- ables \n[GH93]. For example, suppose that the specification of a method m occurs in a scope where two variables, \nx and y , are visible, and that the specification includes the modifies CIaUse modifies x If m is called \nfrom a scope where, additionally, a variable z is visible, then the caller s interpretation ( desugaring \n) of the specification says that the call may possibly modify x , but leaves both y and z unchanged. \nThe fact that a modifies clause is interpreted differently in different scopes raises a concern about \nmodular sound-nem &#38;ei95]. For the purpose of this paper, modular sound- ness means that the implementation, \nwhich is checked to meet the specification as interpreted in the scope contain- ing the method body, \nactually lives up to a caller s expecta- tions, which are based on the specification as interpreted in \nthe scope of the call. A consequence of modular soundness is that one can check a class even in the absence \nof its future clients and subclasses. This paper explores the interpretation of specifications in the \ncontext of an object-oriented programming language with subclassing and method overrides, for example \nlike Java. In particular, I consider annotations for describing what a method may change and the interpretation \nof these annota- tions. I show that there is a problem to be solved in the specification of methods whose \noverrides may modify addi- tional state introduced in subclasses. As a solution to this problem, I introduce \ndata groups, which adhere to modular soundness and rather naturally capture a programmer s de- sign decisions. \nFor simplicity, I restrict my attention to the operations on only one object, the implicit self parameter. \nNeverthe- less, because of inheritance and method overriding, the im- plementations of the methods of \nthis object may be found in superclassesand subclasses of the class being checked. 1 Extending the state \nof a superclass To illustrate the problem, I introduce a simplified example of a computer arcade game--an \nexcellent application of object- oriented programming indeed. The design centers around sprites. A sprite \nis a game ob- ject that appears somewhere on the screen. In this simple example, every sprite has a position, \na color, and methods to update these. The main program, which I will not show, essentially consists of \na loop that performs one iteration per video frame. Each iteration works in two phases. The fist phase \ninvokes the update method on each sprite, which up- dates the sprite s position, color, and other attributes. \nThe second phase invokes the draw method on each sprite, which renders the sprite on the screen. Here \nis the declaration of class Sprite, in which the methods have been annotated with modifies clauses: classSprite \n{ int x, y; void updatePosition /* modifies x, y */ ( 1 int col; void updateColor() I* modifies co1 *I \nI 1 void update ( ) I* modifies x, y, co1 *I { updatePosition(); updateColor( ); } void draw0 /* modifies \n(nothing) */ ( 1 1 The default update method invokes the updatePosition and updatecolor methods, whose \ndefault implementations do nothing. Any of these methods can be overridden in Sprite subclasses. For \nexample, a moving sprite that never changes colors would override the updateposition method, a stationary \nsprite whose color changes over time would override the updatecolor method, and a sprite that adds further \nattributes that need to be updated overrides the update method and possibly also the updatePos it ion \nand updateColor methods. Since the specitications I have given in the example show only modifies clauses, \nchecking that an implementation meets its specification comes down to checking that it mod- ifies only \nthose variables that it is permitted to modify. The implementations of the updatePosition, updatecolor, \nand draw methods are no-ops, so they trivially satisfy their specifications. The update method invokes \nthe other two update methods, whose modifies clauses say they may mod- ify x, y, and co1 . So update \nin effect modifies x, y, and col, and this is exactly what its specification allows. We conclude that \nthe methods in class Sprite meet their spec- ifications. Let us now consider a subclass Hero of Sprite, \nrep-resenting the hero of the game. The hero can move about, and hence the Hero class provides its own \nimplementation of the updateposition method by overriding this method. The next position of the hero \nis calculated from the hero s velocity and acceleration, which are represented as instance variables. \nThe Hero class is declared as follows: class Hero extends Sprite { int dx, dy; int ddx, ddy; void updatePosition() \n{ x += dx + ddx/2; y += dy + ddy/2; dx += ddx; dy += ddy; 1 . . . 1 The Hero implementation of updatePosition \nincreases x and y by appropriate amounts (Ad = vo . t + l/z . a - t2 where r = 1). In addition, it updates \nthe velocity according to the current acceleration. (Omitted from this example is the update of acceleration, \nwhich is computed according to the game player s joystick movements.) It seems natural to update the \nvelocity in the method that calculates the new position, but the specilication of updatePosition (given \nin class Sprite) allows only x and y to be modified, not dx and dy which are not even defined in class \nSprite. (If the update of dx and dy instead took place in method update, there would still be a problem, \nsince the modifies clause of update also does not include these variables.) As evidenced in this example, \nthe reason for overriding a method is not just to change what the method does algorith- micly, but also \nto change what data the method updates. In fact, the main reason for designing a subclass is to introduce \nsubclass-specific variables, and it is the uses and updates of such variables that necessitate being \nable to override meth- ods. For example, class Sprite was designed with the in- tention that subclasses \nbe able to add sprite attributes and update these in appropriate methods. So how does one in a superclass \nwrite the specification of a method such that sub- classes can extend the superclass s state (that is, \nintroduce additional variables) and override the method to modify this extended state? 2 Three straw \nman proposals In this section, I discuss three proposals that I often hear suggested for solving the \nproblem of specifying the modifi- cation of extended state. I show that these proposals don t work. This \nis what it means for a proposal to work: l the proposal must provide a way to annotate classes like Sprite \nand Hero such that the desired method implementations in these classes will meet their speci- fications, \n0 the interpretation of specifications must be useful to callers (for example, specifications should \nnot all be treated as can do anything whatsoever ), l the annotations should not be unnecessarily tedious \nto write down, and 0 the proposal must adhere to modular soundness. Here is the first proposal: Straw \nman 0. A subclass can refine the specification of a method when it overrides it. That is, a subclass \ncan weaken the precondition of the method in the super- class (that is, say that the overridden method \nimple- mentation will work in more situations) and sfrengfhen the postcondition (that is, be more specific \nabout the effect of the method). It is well known that this proposal is sound. However, it doesn t solve \nthe problem at hand. To strengthen the post- condition means to be more precise about the final values \nof variables. This is just the opposite of what we d like- we d like the new postcondition to allow more \nvariables to be modified, that is, to put no restrictions at all on the final values of these variables. \nStated differently, while shrinking the list in the modifies clause is sound, enlarging it is what we \nwant when specifying a subclass s method overrides. Another straw man proposal is the following: Straw \nman 1. Let m be a method declared and specified in a class T . An implementation of m is allowed to modify \nthose variables listed in the modifies clause of m , plus any variable declared in any proper subtype \nof T . Although sound, this straw man is too liberal about the mod- ification of variables in subclasses. \nIn fact, a subclass loses the advantage of modifies clauses with this proposal. To il- lustrate, I will \nshow an example that builds on class Sprite. Consider a class of monsters with a strength attribute. \nRather than storing this attribute as an instance variable in every monster object, suppose a class Monster \nhas a method that returns the value of the strength attribute. Thus, differ- ent Monster subclasses can \ndecide on their own represen- tation of the strength attribute. For example, if the strength of a class \nof monsters is constant, the method can return that constant, without taking up any per-object storage. \nThis de- sign trades quick access of an attribute for flexibility in how the attribute is represented. \nThe following declaration shows class Monster, which uses the strength attribute in updating the sprite \nposition. class Monster extends Sprite { int getStrength /* modifies (nothing) */ ( return 100; } void \nupdatePosition { if (getStrength < 10) ( x+=2; } else { x+=4; 11 1 A particular Monster subclass is \nAgingMonster, which adds an age attribute and overrides the draw method so as to render the monster dilferently \naccording to its strength-to- age ratio. classAgingMonster extends Monster { int age; . . . void draw( \n) { int bitmapID; if (age == 0) [ bitmapID = MONSTERINFANT; 1 eh I int s = getStrength( ); int relativestrength \n= s/age; if (relat ivestrength -z 5) ( bitmapID = MONSTER-WIMPY; } elsif (relativestrength -C IO) ( bitmapID \n= MONSTERNORMAL; 1 eke I bitmapID = MONSTERSTRONG; 1 I Bitmap.Draw(x, y, bitmapID); 1 1 The name Bitmap.Draw \ndenotes some procedure that can draw a bitmap given a screen coordinate and an ID. The correctness of \nthe AgingMonster implementation of draw relies on the fact that the call to getstrength does not modify \nage. In particulsr, if getstrength were to set age to 0, then the computation of relativestrength would \nresult in a division-by-zero error. The getstrength method is specified with an empty modifies clause, \nbut Straw Man 1 gives implementations of getstrength permission to modify age, since age is declared \nin a proper subclass of Monster. Thus, the interpreted specification for method getstrength is not strong \nenough for one to conclude that methoddraw will execute correctly. There is a workaround. If a class \nis allowed to refine the specifications of methods declared in superclasses, class AgingMonster can strengthen \nthe postcondition of method getstrength with agepre == age,,,t. But this would quickly get annoying, \nbecause programmers would then some- times rely on the absence of age in the modifies clause to conclude \nthat age is not changed, and sometimes rely on an . . explicit postcondmon age,, == agepost to conclude \nthe same thing. Even worse, strengthening the specification of all methods declared in a superclass whenever \na class intro- duces new variables would quickly grow to be an unaccept- ably tedious chore. The next \nstraw man proposal seeks to alleviate this chore by making the mentioned postcondition strengthening \nthe default interpretation, and providing a new specification con- struct also-modifies that can override \nthe default interpreta- tion: Straw man 2. Let m be a method declared and specified in a class T. An \nimplementation of m in a subclass U of T is allowed to modify those variables listed in the modifies \nclause of m as given in class T, plus any variable declared in any also-modifies clause for m as given \nin some superclass of U . This straw man seems to solve the problem for the Hero example: One would simply \nannotate the updatePosition override with also-modifies dx, dy This would give the updatePosition implementation \nin Hero permission to modify not just x and y (as granted by the original specification of updatePosition \nin Sprite), but also the variables dx and dy . (One could also add ddx and ddy to the also-modifies clause, \nif desired.) Let us consider how Straw Man 2 stands up to modu- lar soundness. Suppose that the game \nuses one hero object throughout many game levels. As a new level starts, the pro- gram will call a method \nsta.rtNewLevel on the hero object. This method resets certain attributes of the hero object while leaving \nother attributes unchanged, preparing it to begin the new level. To this end, suppose class Hero contains \nthe fol- lowing method declaration and specification, where the key- word ensures is used to express \na given postcondition: void startNewLevel() P modifies x, y, col, dx, dy, ddx, ddy ensuresdxpost == 0 \nA dypost == 0 */ (dx = 0; dy= 0; update( ); 1 The given implementation of startNewLeve1 contains an error: \nThe invocation of update results in a call to the update implementation in class Sprite, whose invocation \n 147 of updatePosition in turn results in a call to the imple- mentation of updatePosition given in class \nHero (be- cause of dynamic method dispatch). This implementation of updatePosition modifies the dx and \ndy variables. Thus, executions of startNewLeve1 may well end with non-zero values for dx and dy , so \nthe implementation of method startNewLeve1 does not meet its specification. Unfortunately, the methodology \nproposed by Straw Man 2 does not allow one to catch the error in sta.rtNewLevel . The problem is that \neven though the interpretation of the specification of updatePosition in class Hero reveals that dx and \ndy may be modified (since the also-modifies anno- tation of updatePosition in class Hero lists these \nvari- ables), the update method is not overridden in Hero and thus gets its specification solely from \nthe one given in class Sprite. Hence, the interpretation of the specification of update shows dx and \ndy as being unchanged, so a pro- gram checker will not find anything wrong with the imple- mentation \nof startNewLeve1. Note that the implementations in class Sprite do meet their specifications under Straw \nMan 2. For example, the interpretation of the specification of updatePosition in class Sprite includes \nonly x and y, both of which are al- lowed to be modifled also by the implementation of update. Hence, \nthere is no error for the checker to report in class Sprite either. In conclusion, Straw Man 2 seems \npretty good at first, but since it allows the specifications of different methods (in the example, updatePosition \nand update) to be extended in different ways (by having different also-modifies clauses, or none at all), \nthe proposal does not adhere to modular sound- ness. The proposal in the next section provides annotations \nfor data rather than for methods, the effect of which is to make specification extensions apply in a \nuniform manner. 3 Data groups In this section, I explain my proposal and demonstrate how it solves the \nproblems with the examples shown previously. In Section 4, I show how a program checker can enforce the \nproposal, and in Section 5, I argue that my proposal is sound. The idea is to introduce data groups, \nwhich represent sets of variables. A data group is declared in a class, just like an instance variable \nis. The declaration of an instance variable is annotated with the names of the data groups to which the \nvariable belongs. Data groups can be nested, that is, a group can be declared as a member of another \ngroup. A data group can be listed in a modifies clause, where it represents the set of all members of \nthe group. Using dam groups, the declaration of Sprite can be written as: void startNewLevel() /* modifies \nattributes class Sprite ( r group attributes; *I p group position member-of attributes; *I int x /* \nmember-of position *!; int y /* member-of position *!; void updatePosition() I* modifies position */ \n I I p group color member-of attributes; *I int co1 P member-of color *!; void updateColor() I* modifies \ncolor *I  I 1 void update ( ) /* modties attributes *I ( updatePosition( ); updateColor( ); } P group \ndrawstate; */ void draw() /* modifies drawState *I t 1 1 This version of class Sprite declares four \ndata groups, at- tributes, position, color, and drawstate, and de- clares position and color tobemembersof \nattributes, x and y tobemembersof position,and co1 tobeamem- ber of color. Class Sprite does not declare \nany members of group drawState. Since updatePosition is dcclarcd with the spccifica- tion modifies position, \nan implementation of this method is allowed to modify x and y. In addition, an implementa- tion of this \nmethod is allowed to modify any variables de- clared in Sprite subclasses to hc members of position. \nAn implementation of updatePosition is not allowed to call method updatecolor, for example, since color \nis not a member of posit ion. By introducing a data group drawState and listing it in the modifies clause \nof method draw, implementations of draw in Sprite subclasses are given a way to modify instance variables \n(in particular, to modify variables that are introduced as members of drawstate). The following illustrates \nhow one can use data groups to annotate class Hero : classHero extends Sprite { int dx I* member-of position \n*!; int dy I* member-of position */; int ddx P member-of position *!; int ddy /* member-of position *!; \nvoid updatePosition() { x += dx + ddx/2; y += dy + ddy/2; dx += ddx; dy += ddy; I ensuresdxpost == 0 \nA dypost == 0 *I ( dx = 0; dy = 0; update( ); 1 1 The override of updatePosition gets its permission \nto modify dx and dy from the fact that these variables are members of the data group posit ion. This \nsolves the prob- lem of how to specify updatePosition inclass Sprite so that a subclass like Hero can \nmodify the state it introduces. With data groups, the error in startNewLeve1 is de- tected. Since dx \nand dy are members of position, which in turn is a member of attributes, a program checker will know \nthat dx and dy may be modified as a result of invok- ing update. Since the specification of update says \nnoth- ing further about the final values of dx and dy , one cannot conclude that they remain 0 after \nthe call. As for the AgingMonster example, the data groups pro- posal does allow one to infer that no \ndivision-by-zero er- ror is incurred in the evaluation of s/age: The guarding if else statement guarantees \nthat age is non-zero before the call to getstrength, and since age is not modified by getstrength, whose \nmodifies clause is empty, age re-mains non-zero on return from getstrength. I will give two more examples \nthat illustrate the use of data groups. First, note that the members of two groups are allowed to overlap, \nthat is, that a variable is allowed to be a member of several groups. For example, if a Sprite subclass \ndeclares a variable int k I* member-of position, drawState *!; then k can be modified by any of the methods \nupdate, updatePosition, and draw. Second, I give another example to illustrate that it is use- ful to \nallow groups to contain other groups. Suppose a sub- class of Sprite, Centipede, introduces a legs attribute. \nClass Centipede declares a data group legs and a method updateLegs with license to modify legs, which \nimplies the license to modify the members of legs. By declaring legs as a member of attributes, the update \nmethod gets permission to call method updateLegs : classCentipede extends Sprite ( I* group legs member-of \nattributes; *I int legcount P member-of legs *I; void updateLegs( ) p modifies legs *I {legCount=...; \n} void update() ( updatePosition( ); updateColor( ); updateLegs( ); Enforcing the data groups proposal \n This section describes more precisely how a program checker handles data groups. For every data group \ng, the checker introduces a new variable gResidue . This so-called residue variable is used to represent \nthose of g s members that are not in scope-in a modular program, there is always a possibility of a future \nsubclass introducing a new variable as a member of a previ- ously declared group. To interpret a modifies \nclause modifies w the checker lirst replaces w with the variables in the down-ward closure of w , For \nany set of variables and data groups w , the downward closure of w , written down(w), is defined as the \nsmallest superset of w such that for any group g in down(w), gResidue and the variables and groups declared \nwith member-of g are also in down(w). For example, computing the downward closure of the modifies list \nattributes in class Hero as shown in Sec- tion 3 yields attributes, attributesResidue, position, positionResidue, \nx, y, dx, dy, ddx, ddy, color, colorResidue, co1 Thus, in that class, modifies attributes is interpreted \nas modifies attributesResidue, positionResidue, x, y, dx, dy, ddx, ddy, colorResidue, co1  By handling \ndata groups in the way described, the Hero implementation of method startNewLeve1, for example, is allowed \nto modify dx and dy and is allowed to call method update (but the assignments to dx and dy must take \nplace @ter the call to update in order to establish the specified postcondition of startNewLeve1). The \nimplementation of startNewLeve1 would also be allowed to call, for example, updateposition directly. \nBut the checker would com-plain if startNewLeve1 called draw, because the call to draw would be treated \nas modifying the residue variable drawStateResidue, and that variable is not in the down- ward closure \nof attributes. 5 Soundness The key to making the data groups proposal sound is that it is always known \nto which groups a given variable or group be- longs, and that residue variables are used to represent \nmem- bers of the group that are not in scope. The data groups proposal is, in fact, a variation of the \nuse of abstract vari- ables and dependencies in my thesis [L&#38;95]. I will explain the relation between \nthe two approaches in this section, and relegate the proof of soundness to that for dependencies in my \nthesis. A data group is like an abstract variable. An abstract variable (also called a specification \nvariable) is a fictitious variable introduced for the purpose of writing specifications. The value of \nan abstract variable is represented in terms of program variables and other abstract variables. In some \nscopes, it is not possible, nor desirable, to specify the repre- sentation of an abstract variable because \nnot all of the vari- ables of the representation are visible. This tends to happen often in object-oriented \nprograms, where the representation is often subclass-specific. However, if the abstract variable and \nsome of the variables of the representation are visible in a scope, then the fact that there is a dependency \nbetween these variables must be known to a program checker in or- der to achieve modular soundness. Consequently, \nan anno- tation language that admits abstract variables must also in- clude some construct by which one \ncan explicitly declare the dependency of an abstract variable on a variable that is part of its representation. \nFor example, if position were an abstract variable, then dependsposition on x would declare that variable \nx is part of the representation of position. My thesis introduced such dependency dec- larations. The \ncorresponding notion in this paper is the an- notation that declares that x is a member of the data group \nposition: int x P member-of position */; Using dependencies, one can give a precise definition of what \nthe occurrence of an abstract variable in a modifies clause means. For dependencies like the ones shown \nhere, this interpretation is the same as that defined for data groups above: the downward closure. My \nthesis contains a proof that the use of dependencies in this way adheres to modular soundness, provided \nthe pro- gram meets two requirements and provided the interpreta- tion includes residue variables. The \ntwo requirements, called the visibility and authenticity requirements, together state es- sentially that \na dependency declaration depends a on c should be placed near the declaration of c, that is, so that \nevery scope that includes the declaration of c also includes the dependency declaration. Because the \nmember-of anno- tation is made part of the declaration of the variable whose group membership it declares, \nthe two requirements are au- tomatically satisfied. There is one other difference between data groups \nand abstract variables with dependencies. Suppose an abstract variable a depends on a variable c , and \nthat the downward closure of the modifies clause of a method includes c but not a. The interpretation \nof such a modifies clause says that c may be modified, but only in such ways as to not change the abstract \nvalue of a lLei951. This is called a side effect constraint on a. But with data groups, it would be meaningless \nto use side effect constraints, since data groups don t have values. Thus, if variable c is a member \nof a data group a and the down- ward closure of a method m includes c but not a, then the modifies clause \ndoes not constrain the implementation of m in how c is changed. Violations of modular soundness re- sult \nfrom the deficiency that the different interpretations of a specification in different scopes are inconsistent. \nSo by re- moving side effect constraints in all scopes, modular sound- ness is preserved. From our experience \nwith writing specifications for ex- tended static checking, we have found it useful to introduce an abstract \nvariable conventionally called state [LN98a]. This variable is declared to depend on variables represent- \ning the state of a class or module. The state variable is used in many modifies clauses, but not in pre- \nand postcon- ditions. Furthermore, state is never given an exact defini- tion in terms of its dependencies. \nThus, the type of state is never important, so we declared its type to be any, where any is a new keyword \nthat we added to the annotation lan- guage. The data groups proposal grew from a feeling that it was \na mistake to apply the side effect constraint on variables like state whose type is any-after all, the \nexact value of such a variable is never defined and thus cannot be relied on by any part of the program. \nBy changing the checking metbod- ology to not apply side effect constraints on variables of type any, \none arrives at the interpretation of data groups presented in this paper. As a final note on modular \nsoundness, I mention without going into details that the absence of side effect constraints makes the \nauthenticity requirement unnecessary. This means that it would be sound to declare the members of a data \ngroup at the time the group is declared, rather than declaring, at the time a variable is declared, of \nwhich groups the variable is a member. For example, instead of writing P group g; */ . . . int x /* member-of \ng */; one could write bit x; . . . P group g contains x, . . . ; */ Using contains in this way adheres \nto modular soundness (but declaring a group with both a contains and a member- of phrase does not). However, \nwhile introducing a group containing previously declared variables is sound and may occasionally be convenient, \nit does not solve the problem described in this paper. 6 Concluding remarks In summary, this paper has \nintroduced data groups as a natu- ral way to document object-oriented programs. Data groups represent \nsets of variables and can be listed in the modties clauses that document what methods are allowed to \nmod- ify. The license to modify a data group implies the license to modify the members of the data group \nas defined by the downward closure rule. Since data groups are closely related to the use of ab- stract \nvariables and dependencies [Lei95], they adhere to the useful property of modular soundness, which implies \nthat one can check a program one class at a time, without need- ing global program information. Although \nthe literature has dealt extensively with data abstraction and refinement, in- cluding Hoare s famous \n1972 paper [Hoa72], it seems that only my thesis and my work with Nelson lLN98a] have ad- dressed the \nproblem of having abstract variables in modifies clauses in a way that modem object-oriented programs \ntend to use them. The use of data groups shown in this paper corresponds to static, as opposed to dynamic, \ndependencies. Dynamic de- pendencies arise when one class is implemented in terms of another. Achieving \nsoundness with dynamic dependencies is more difficult than the case for static dependencies [LN98a, DLN981. \nData groups can be combined with abstract variables and dependencies. This is useful if one is interested \nin the ab- stract values of some attributes and in the representation func- tions defining these abstract \nvalues. A related methodological approach to structuring the in- stance variables and methods of a class \nis method groups, first described by Lamping [Lam931 and developed further by Stata [Sta97]. Method groups \nand data groups both pro- vide ways to organize and think about the variables declared in classes. Other \nthan that, methods groups and data groups have different aims. The aim of method groups is to allow the \nvariables declared in a superclass to be used in a different way in a subclass, a feature achieved by \nthe following disci- pline: The variables and methods of a class are partitioned into method groups. \nA variable x in a method group A is al- lowed to be modified directly only by the methods in group A; \nmethods in other groups can modify x only via calls to methods in group A. If a designer of a subclass \nchooses to replace a variable or method of a method group, all vari- ables and methods of the method \ngroup must be replaced. The use of method groups can complement the use of data groups, whose aim is \nto address not how variables are used but rather the more fundamental question of which variables are \nallowed to be changed by which methods. If one wants to write specifications in terms of abstract values \nand allow subclasses to change the representation functions of these abstract values, then one can combine \ndata groups, abstract variables, and dependencies with method groups. A related approach to specifying \nin a superclass what a subclass method override is allowed to modify is using re- gion promises [CBS98]. \nThese are used in reasoning about software transformations. In contrast to data groups, the sets of variables \nincluded in different regions are required to be disjoint. This restriction facilitates reasoning about \nwhen two method calls can be commuted, but burdens the pro- grammer with having to invent a partition \non the class vari- ables, which isn t always as natural. The region promises are used in both modifies \nclauses and so-called reads clauses, which specify which variables a method is allowed to read. Although \nnot explored in this paper, it seems that data groups may be as useful in reads clauses as they are in \nmodifies clauses. A complementary technique for finding errors in pro- grams is explored by Jackson \nin his Aspect system [Jac95]. To give a crude comparison, Aspect features annotations with which one \nspecifies what a method must modify, whereas the modifies clauses considered in this paper specify what \na method is allowed to modify. To specify what a method must modify, one uses aspects, which are abstract \nentities that can be declared to have dependences, consisting of vari- ables and other dependences. Such \naspects are analogous to data groups. There are many specification languages for documenting object-oriented \nsoftware, including Larch/C++ [Lea961 and the specification languages surveyed by Lana and Haughton lLH941. \nThese specification languages do not, however, es- tablish a formal connection between specifications \nand ac- tual code. Without such a connection, one cannot build a programming tool for finding errors \nin implementations, As soon as one becomes interested in checking a method im- plementation against a \nspecification that is useful to callers, one becomes concerned with what the implementation is al- lowed \nto modify. Add subclassing to the stew and one faces the problem described in this paper. To motivate \ndata groups in this paper, I spoke informally about the semantics of the example code. There are sev- \neral Hoare-like logics and axiomatic semantics of object- oriented programs that define the semantics \nformally [Lea89, AdB94, Nau94, AL97, Lei97, PHM98, Lei98a]. Four of these lAL97, Lei97, PHM98, Lei98a] \ndeal with programs where objects are references to mutable data fields (instance variables) and method \ninvocations are dynamically dispatched. However, except for Ecstatic lLei971, these logics have fo- cused \nmore on the axiomatization of language features and object types than on the desugaring of useful specification \nconstructs. In the grand scheme of annotating object-oriented pro- grams in ways that not only help programmers, \nbut that also can be used by program analyzers, this paper has touched only on the modification of extended \nstate. Though they sometimes seem like a nuisance in the specification of pro- grams, modifies clauses \nare what give a checker precision across procedure boundaries. Vandevoorde has also found modifies clauses \nto be useful in improving program perfor- mance [ Van94]. Other important method annotations include \npre- and post- conditions, of which useful variations have also been stud- ied [Jongl, LB97J. As for \nannotating data, object invari- ants lMey88, LW94, LH94, Lea961 is a concept useful to programmers and \namenable as annotations accepted by a program checker. Like the modification of extended state, achieving \nmodular soundness with object invariants is an is- sue [LS97]. Acknowledgements Raymie Stata, Greg Nelson, \nMark Lilhbridge, and Martin Abadi made useful comments on a draft of this paper. The paper has also benefited \nfrom the workshop on Foundations of Object-Oriented Languages [Lei98b]. References lAdB941 Pierre America \nand Frank de Boer. Reason-ing about dynamically evolving process struc- tures. Formal Aspects of Computing, \n6(3):269- 316,1994. [AL971 Martin Abadi and K. Rustan M. Leino. A logic of object-oriented programs. \nIn Michel Bidoit and Max Dauchet, editors, Theory and Practice of Software Development: Proceedings I \nTAP- SOFT 97, 7th International Joint Conference CAAPIFASE, volume 1214 of Lecture Notes in Computer \nScience, pages 682-696. Springer, April 1997. [CBS981 Edwin C. Chan, John T. Boyland, and William L. \nScherlis. Promises: Limited speci- fications for analysis and manipulation. In Pro-ceedings of the IEEE \nInternational Conference on SofIware Engineering (ICSE 98), pages 167- 176.IEEE Computer Society, April \n1998. [Det96] David L. Detlefs. An overview of the Extended Static Checking system. In Proceedings of \nThe First Workshop on Formal Methods in Software Practice, pages l-9. ACM SIGSOFI , January 1996. [DLN98] \nDavid L. Detlefs, K. Rustan M. Leino, and Greg Nelson. Wrestling with rep exposure. Research Report 156, \nCompaq Systems Research Center, 1998. [DLNS98] David L. Dedefs, K. Rustan M. Leino, Greg Nel- son, and \nJames B. Saxe. Extended static check- ing. Research Report 159, Compaq Systems Re- search Center, 1998. \nTo appear. mc1 Extended Static Checking home page, Compaq Systems Research Center. Gn the Web at www.research.digital.com/SRC/esc \n/Esc.html. [GH93] John V. Guttag and James J. Homing, editors. Larch: Languages and Tools for Formal \nSpec- ification. Texts and Monographs in Computer Science. Springer-Verlag, 1993. With Stephen J. Garland, \nKevin D. Jones, And&#38; Modet, and Jeannette M. Wing. [Hoa72] C. A. R. Hoare. Proof of correctness of \ndata representations.Acta Informatica, 1(4):271-81, 1972. [Sac951 Daniel Jackson. Aspect: Detecting bugs \nwith ab- stract dependences. ACM Transactions on Soft- ware Engineering and Methodology, 4(2): 109-145, \nApril 1995. [Jon911 H. B. M. Jonkers. Upgrading the pre- and post- condition technique. In S. Prehn and \nW. J. Toetenel, editors, VDM 91 Formal Software De- velopment Methods, 4th International Sympo-sium of \nVDM Europe, Volume I: Conference Proceedings, volume 551 of Lecture Notes in Computer Science, pages \n428-456. Springer- Verlag, October 1991. [Lam931 John Lamping. Typing the specialization inter- face. \nACM SIGPLAN Notices, 28(10):201-214, October 1993. OOPSLA 93 conference pro- ceedings. LB971 Gary T. \nLeavens and Albert L. Baker. Enhancing the pre- and postcondition technique for more expressive specifications. \nTechnical Report TR #97-19, Department of Computer Science, Iowa State University, September 1997. [Lea891 \n[Lea961 IL&#38;951 B&#38;97] lLei98al fLei98bl IUW lLN98al lLN98bl Gary Todd Leavens. VerifLng Object-Oriented \nPrograms that Use Subtypes. PhD thesis, MIT Laboratory for Computer Science, Febru- ary 1989. Available \nas Technical Report MIT/LCS/TR-439. Gary T. Leavens. An overview of Larch/C++: Behavioral specifications \nfor C+t modules. In Haim Kilov and William Harvey, editors, Spec-ification of Behavioral Semantics in \nObject-Oriented Information Modeling, chapter 8, pages 121-142. Kluwer Academic Publishers, 1996. K. \nRustan M. Leino. Toward Reliable Modu-lar Programs. PhD thesis, California Institute of Technology, 1995. \nAvailable as Technical Re- port Caltech-CS-TR-95-03. K. Rustan M. Leino. Ecstatic: An object- oriented \nprogramming language with an ax- iomatic semantics. In The Fourth Interna-tional Workshop on Foundations \nof Object-Oriented Languages, January 1997. Proceed- ings available from www.cs.indiana.edu /hyplan/pierce/fool/. \nK. Rustan M. Leino. Recursive object types in a logic of eject-oriented programs. In Chris Han- kin, \neditor, Programming Languages and Sys- tems: 7th European Symposium on Program- ming, ESOP 98, volume \n1381 of Lecture Notes in Computer Science. Springer, April 1998. K. Rustan M. Leino. Specifying the modifi- \ncation of extended state. In The Fifth Inter-national Workshop on Foundations of Object- Oriented Languages, \nJanuary 1998. Proceed- ingsavailable from www.pauillac.inria .fr/Nremy/fool/program.html. Kevin Lano \nand Howard Haughton, editors. Object-Oriented Specification Case Studies. The Object-Oriented Series. \nPrentice Hall, 1994. K. Rustan M. Leino and Greg Nelson. Ab-straction and specification revisited. Internal \nmanuscript KRML 7 1, Digital Equipment Cor- poration Systems Research Center. To appear as Compaq SRC \nResearch Report 160,1998. K. Rustan M. Leino and Greg Nelson. An ex- tended static checker for Modula-3. \nIn Kai Koskimies, editor, Compiler Construction; Pro-ceedings of the 7th International Conference, CC \n98, volume 1383 of Lecture Notes in Com- puter Science, pages 302-305. Springer, March 1998. [LS97] \nK. Rustan M. Leino and Raymie Stata. Check- ing object invariants. Technical Note 1997- 007, Digital \nEquipment Corporation Systems Research Center, April 1997. &#38;W94] Barbara H. Liskov and Jeannette \nM. Wing. A behavioral notion of subtyping. ACM Transac- tions on Programming Languages and Systems, 16(6):1811-1841,November \n1994. [Mey88] Bertrand Meyer. Object-oriented Software Con- struction. Series in Computer Science. Prentice- \nHall International, New York, 1988. [Nau94] David A. Naumann. Predicate transformer se- mantics of an \nOberon-like language. In E.- R. Olderog, editor, Proceedings of the IFIP WG2.lIWG2.2lWG2.3 Working Conference \non Programming Concepts, Methods, and Calculi, pages 467487. Elsevier, June 1994. [pHM98] Amd Poetzsch-Heffter \nand Peter Mthler. Logical foundations for typed object-oriented languages. In David Gries and WiIlem-Paul \nde Roever, editors, Programming Concepts and Methods, PROCOMET 98, pages 404423. Chapman &#38; Hall, \n1998. [Sta971 Raymie Stata. Modularity in the presence of subclassing. Research Report 145, Digital Equipment \nCorporation Systems Research Cen- ter, April 1997. [Van941 Mark T. Vandevoorde. Exploiting Specifica- \ntions to Improve Program Performance. PhD thesis, Massachusetts Institute of Technology, February 1994. \nAvailable as Technical Report MIT/LCS/TR-598. \n\t\t\t", "proc_id": "286936", "abstract": "This paper explores the interpretation of specifications in the context of an object-oriented programming language with subclassing and method overrides. In particular, the paper considers annotations for describing what variables a method may change and the interpretation of these annotations. The paper shows that there is a problem to be solved in the specification of methods whose overrides may modify additional state introduced in subclasses. As a solution to this problem, the paper introduces <i>data groups</i>, which enable modular checking and rather naturally capture a programmer's design decisions.", "authors": [{"name": "K. Rustan M. Leino", "author_profile_id": "81100225265", "affiliation": "Compaq Systems Research Center, 130 Lytton Ave., Palo Alto, CA", "person_id": "PP31086410", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/286936.286953", "year": "1998", "article_id": "286953", "conference": "OOPSLA", "title": "Data groups: specifying the modification of extended state", "url": "http://dl.acm.org/citation.cfm?id=286953"}