{"article_publication_date": "10-01-1998", "fulltext": "\n Multiple Dispatch as Gary T. Leavens Department of Computer Science, Iowa State University, 229 Atanasoff \nHall, Ames, Iowa, 50011 USA leavens@cs.iastate.edu +I 515 294-1580 ABSTRACT Many popular object-oriented \nprogramming languages, such as C++, Smalltalk-80, Java, and Eiffel, do not support multiple dispatch. \nYet without multiple dispatch, programmers find it difficult to express binary methods and design patterns \nsuch as the visitor pattern. We describe a new, simple, and orthogonal way to add multimethods to single-dispatch \nobject-oriented languages, without affecting existing code. The new mechanism also clarifies many differences \nbetween single and multiple dispatch. Keywords Multiple dispatch, multimethods, generic functions, typing, \nsingle dispatch, binary methods, semantics, language design, Tuple. 1 INTRODUCTION Single dispatch, as \nfound in C++ [Stroustrup 971, Java [Arnold &#38; Gosling 98, Gosling et al. 961, Smalltalk- [Goldberg \n&#38; Robson 831, and Eiffel [Meyer 92, Meyer 971, selects a method using the dynamic class of one object, \nthe message s receiver. Multiple dispatch, as found in CLOS [Chapter 28, Steele 901 [Paepcke 931, Dylan \n[Shalit 97, Feinberg et al. 971, and Cecil [Chambers 92, Chambers 951, generalizes this idea, selecting \na method based on the dynamic class of any subset of the message s arguments. Multiple dispatch is in \nmany ways more expressive and flexible than single dispatch in object-oriented (00) programming [Bobrow \net al. 86, Chambers 92, Castagna 97, Moon 861. In this paper we propose a new, simple, and orthogonal \nway of adding multiple dispatch to existing languages with single dispatch. The idea is to add tuples \nas primitive expressions and to allow messages to be sent to tuples. Selecting a method based on the \ndynamic classes of the elements of the Pe mtSslon 10 make dlgltal or hard copnes of all o, part of ,h,s \nwp,k for Personal 01 ClaSSrOOm US62 IS granted wIthout fee provided that CoP es are not made Or dlstrlbuted \nfor proflt or commercial adVan. %Je and that CpPleS bear fhls notxx and the full citation on the flrg \npage 10 COPY pthewse. lo republish. to post on serve,~ or to red strlbute fo IMS. WCIUES prmr spectflc \npermissaon and/or a fee OOPSLA 98 lo/98 Vancouver. B.C. 0 1998 ACMl-591 13-005-8/98/oo1o...$5.oo Dispatch \non Tuples Todd D. Millstein Department of Computer Science and Engineering, University of Washington, \nBox 352350, Seattle, WA 98 195-2350 USA todd@cs.washington.edu +1 206 543-5118  tuple gives multiple \ndispatch. To illustrate the idea, we have designed a simple class-based 00 language called Tuple*. While \nperhaps not as elegant as a language built directly with multiple dispatch, we claim the following advantages \nfor our mechanism: 1. It can be added to existing single dispatch languages, such as C++ and Java, without \naffecting either (a) the semantics or (b) the typing of existing programs written in these languages. \n 2. It retains the encapsulation mechanisms of single-dispatch languages. 3. It is simple enough to \nbe easily understood and remembered, we believe, by programmers familiar with standard single dispatch. \n 4. It is more uniform than previous approaches of incorporating multiple dispatch within a single-dispatching \nframework.  To argue for the first two claims, we present the semantics of the language in two layers. \nThe first layer is a small, class- based single-dispatching language, SDCore, of no interest in itself. \nThe second layer, Tuple proper, includes SDCore and adds multiple dispatch by allowing messages to be \nsent to tuples. Our support for the third claim is the simplicity of the mechanism itself. If, even now, \nyou think the idea of sending messages to tuples is clearly equivalent to multiple dispatch, then you \nagree. To support the fourth claim, we argue below that our mechanism has advantages over others that \nsolve the same problem of incorporating multiple dispatch into existing single-dispatching languages. \nThe rest of this paper is organized as follows. In Section 2 we describe the single-dispatching core \nof Tuple; this is needed only to show how our mechanism can be added to such a language. In Section 3 \nwe describe the additions to the single- dispatching core that make up our mechanism and support our \nfirst three claims. Section 4 supports the fourth claim by comparison with related work. In Section 5 \nwe offer * With apologiesto Bruce et al., whose TOOPLE language [Bruce et ul. 931 is pronounced the same \nway. class Point { fields (xval:int, yval:int) method x0 :int { xval ) method y0 :int { yval } method \ndistanceFrom(l:Line):int ( . . . 1 I class ColorPoint inherits Point { fields (colorval:Color) method \ncolor():Color ( colorval } 1 Figure I: The classes Point and Colorpoint. some conclusions. In Appendix \nA we give the concrete syntax of Tuple, and in Appendix B we give the language s formal typing rules. \n2 SDCORE, THE SINGLE-DISPATCHING CORE OF TUPLE In this section, we introduce the syntax and semantics \nof SDCore by example. 2.1 Syntax and Semantics The single-dispatching core of Tuple is a class-based \nlanguage that is similar in spirit to conventional 00 languages like C++ and Java. Integer and boolean \nvalues, along with standard operations on these values, are built into the language. Figure 1 illustrates \nSDCore with the well- known PointKolorPoint example. The Point class contains two fields, representing \nan x and y coordinate respectively. Each point instance contains its own values for these fields, supplied \nwhen the instance is created. For example, the expression new PO int ( 3 , 4 ) returns a fresh point \ninstance with xval and yval set to 3 and 4 respectively. The Point class also contains methods for retrieving \nthe values of these two fields and for calculating the distance from the point to some line. (We assume \nthe Line class is defined elsewhere.) For ease of presentation, SDCore s encapsulation model is extremely \nsimple. An instance s fields are only accessible in methods where the instance is the receiver argument. \nAn instance may contain inherited fields, which this rule allows to be accessed directly; this is similar \nto the protected notion in C++ and Java. The Colorpoint class is a simple subclass of the Point class, \naugmenting that definition with a colorval field and a method to retrieve the color. (We assume that \na class Color is defined elsewhere.) The ColorPoint class inherits all of the Point class s fields and \nmethods. To create an instance of a subclass, one gives initial values for inherited lields first and \nthen the fields declared in the subclass. For example, one would write new ColorPoint (3, 5, red). As \nusual, subclasses can also override inherited methods. To simplify the language, SDCore has only single \ninheritance. (However, multiple inheritance causes no problems with respect to the new ideas we are advocating.) \nWe use a standard syntax for message sends. For example, if pl is an instance of Point or a subclass, \nthen the expression pl .distanceFrom(ln2) invokes the instance s distanceFrom method with the argument \nln2. Within the method body, the keyword self refers to the receiver of the message, in this case pl. \nDynamic dispatching is used to determine which method to invoke. In particular, the receiver s class \nis first checked for a method implementation of the right name and number of arguments. If no such method \nexists, then that class s immediate superclass is checked, and so on up the inheritance hierarchy until \na valid implementation is found (or none is found and a message-not-understood error occurs). For simplicity, \nand to ease theoretical analysis, we have not included assignment and mutation in SDCore. Again, these \ncould be easily added. 2.2 Type Checking for SDCore An overview of the static type system for SDCore \nis included here for completeness. The details (see Appendix B) are intended to be completely standard. \nFor ease of presentation SDCore s type system is simpler than that found in more realistic languages, \nas this is peripheral to our contributions. There are four kinds of type attributes. The types int and \nboo1 are the types of the built-in integer and boolean values, respectively. The function type (T,,...,T,,)+T,+I \nis the type of functions that accept as input n argument values of types T,, . . . . T, respectively \nand return a result of type T,,+,. The cluss type, CN, where CN is a class name, is the type of instances \nof the class CN. Types are related by a simple subtyping relation. The types int and boo1 are only subtypes \nof themselves. The ordinary contravariant subtyping rule is used for function types [Cardelli 881. A \nclass type CN] is a subtype of another class type Clv, if the class CNI is a subclass of the class Clu,. \nTo ensure the safety of this rule, the type system checks that, for every method name m in class CN1, \nm s type in CNz is a supertypc of m s type in CN,.* Classes that do not meet this check will be flagged \nas errors. Thus every subclass that passes the type checker implements a subtype of its superclass. To \nstatically check a message send expressionof the form EO.I(E,,...,E,J, we check that the static type \nof E, is a subtype of a class type CN whose associated class contains a method I of type (T,,...,T,,)-+T,,+,, \nwhere the types of the expressions E, ,..., E, are subtypes of the T, ,..., T,, * Unlike C++ and Java, \nSDCore does not allow static overloading of method names. However, since we add multiple dispatch to \nSDCoreby a separate mechanism, and since dynamic dispatch can be seen as dynamic overloading, there is \nlittle reason to do so. respectively; in this case, EO.I(E,,...,E,,) has type T,,+,. For example, pl.distanceFrom \n(ln2) has type int, assuming that pl has type Point and ln2 has type Line. 2.3 Problems with Single \nDispatching Single dispatching does not easily support some programming idioms. The best-known problem \nof this sort is the hinary method problem [Bruce et al. 951. For example, consider adding an equality \ntest to the Point and tugle class (pl:Point, p2:Point) I method equalO:bool( pl.xO = p2.xo and ~1.~0 \n= p2.YO I 1 tugle class (cpl:ColorPoint, cp2:ColorPoint) { method equal0 :boo1 ( (cpl.xO = cp2.xo and \ncpl.yO = cp2.y()) and (cpl.color(), cp2.color()).equal() } I ColorPoint classes above as follows. (For \nsimplicity, in SDCore we have not included super, which would allow ColorPoint's equal method to call \nPoint's equal method.) class Point ( . . . method equal(p:Point) :bool ( xval = p.x() and yval = p.yO \n} I class ColorPoint inherits Point { . . . method equal(p:ColorPoint):bool a type error in SDCore { \n(xval = p.x() and yval = p-y()) and colorval.equal(p.colorO) } I As is well-known, this makes it impossible \nfor Colorpointto be considered asubtype of Point [Cook et al. 901. In other words, Colorpoint instances \ncannot be safely used wherever a Point is expected, so polymorphism on the point hierarchy is lost. (For \nthis reason the example is ill-typed in SDCore.) The problem is semantic, and not a fault of the SDCore \ntype system. It stems from the asymmetry in the treatment of the two Point instances being tested for \nequality. In particular, one instance is the message receiver and is thereby dynamically dispatched upon, \nwhile the other is an ordinary argument to the message and plays no role in method selection [Castagna \n951. Multiple dispatch avoids this asymmetry by dynamically dispatching based on the run- time class \nof both arguments. A more general problem is the visitor design pattern [Pages 33 I-344, Gamma et al. \n9.51. This pattern consists of a hierarchy of classes, typically representing the elements of a structure. \nIn order to define new operations on these elements without modifying the element classes, a separate \nhierarchy of visitors is created, one per operation. The code to invoke when a visit occurs is dependent \nboth on which visitor and which element is used. Multimethods easily express the required semantics [Section \n7, Baumgartner et al. 961, while a singly-dispatched implementation must rely on unwieldy simulations \nof multiple dispatching. Figure 2: Two tuple classes holding methods for testing equality of points. \n 3 TUPLE, THE MULTIPLE-DISPATCHING EXTENSION OF SDCORE Tuple extends SDCore with tuple expressions, tuple \nclasses, tuple types, and the ability to declare and send messages to tuples, which gives multiple dispatch. \nNothing in the semantics or typing of SDCore is changed by this extension. 3.1 Syntax and Semantics In \nTuple the expression (E, , , E,,) creates a tuple of size n with components vI,...,vn, where each vi \nis the value of the corresponding expression Ei.* Figure 2 shows how one would solve the PointKolorPoint \nproblem in Tuple. Rather than defining equal methods withinthe Point and ColorPointclasses,wecreatetwo \nnew tuple classes for the methods. In the first tuple class, a tuple of two Point instances is the receiver. \nThe names pl and p2 can be used within all methods of the tuple class to refer to the tuple components. \nHowever, tuple classes are client code and as such have no privileged access to the fields of such components. \nThe second tuple class is similar, defining equality for a tuple of two ColorPoint instances. (We assume \nthat there is a tuple class for the tuple (Color, Color) with an equal method.) There can be more than \none tuple class for a given tuple of classes.t Since no changes are made to the Point or ColorPoint classes \nwhen adding equal methods to tuple classes, the subtype relationship between ColorPoint and Point is \nunchanged. That is, by adding the equal method to a tuple class instead of to the original classes of \nFigure 1, ColorPoint remainsasafesubtypeof Point. The syntax for sending a message to a tuple is analogous \nto that for sending a message to an instance. For example, (pl,p2) .equal() sends the message equalo\" \nto the tuple (pl, p2), which will invoke one of the two * As in ML [Milner et (I/ 901, we do not allow \ntuples of length one. This prevents ambiguity in the syntax and semantics.For example. an expression \nsuch as (x) g ( y) is interpreted as a message sent to an instance, not to a tuple. Tuples have either \nzero, or two or more elements. We allow the built-in types int and boolean to appear as components of \na tuple class as well. Conceptually, one can think of corresponding built-in classes int and boolean, \neach of which has no non-trivial subclasses or superclasses. equal methods. Just as method lookup in \nSDCore relies on the dynamic class of the receiver, method lookup in Tuple relies on the dynamic classes \nof the tuple components. Therefore, the appropriate equal method is selected from either the (Point, \nPoint) or the (ColorPoint, ColorPo int) tuple class based on the dynamic classes of pl and p2. In particular, \nthe method from the (ColorPoint,ColorPoint) tuple class is only invoked if both arguments are ColorPoint \ninstances at run-time. The use of- dynamic classes distinguishes multiple dispatch from static overloading \n(as found, for example, in Ada 83 [Ada 831). The semantics of sending messages to tuples, multiple dispatch, \nis similar to that in Cecil [Chambers 951. Consider the expression (E ,,..., E,).I(E,+ ,,..., E,,), where \neach Ej has value v~, and where C,,i is the minimal dynamic class of v,. A method in a tuple class (C,,...,C,) \nis applicable to this expression if the method is named I, if for each l<iln the dynamic class Cd,; is \na subclass of C,, and if the method takes m-n additional arguments. (The classes of the additional arguments \nare not involved in determining applicability, but their number dots matter.) Among the applicable methods \n(from various tuple classes), a unique most-specific method is chosen. A method M, in a tuple class (C,,,,...,C,,,) \nis more .spec( fic than a method M, in a tuple class (C,,,,...,C,,,,) if for each Ili<n, C, ; is a subclass \nof C2,;. (The other arguments in the methods are not involved in determining specificity.) If no applicable \nmethods exist, a message-not-understood error occurs. If there are applicable methods but no most- specific \none, a message-ambiguous error occurs. Algorithms for efficiently implementing multiple dispatch exist \n(see, e.g., [Kiczales &#38; Rodriguez 931). This semantics immediately justifies part l(a) of our claim \nfor the orthogonality of the multiple dispatch mechanism. An SDCore expression cannot send a message \nto a tuplc. Furthermore, the semantics of message sends has two cases: one t-or sending messages to instances \nand one for sending messages to tuplcs. Hence the meaning of an expression in SDCorc is unaffected by \nthe presence of multiple dispatch. The semantics for tuple classes also justifies our second claim. That \nis, since tuplc classes have no special privileges to access the fields of their component instances, \nthe encapsulation properties of classes are unaffected. However, because of this property, Tuple, like \nother multimethod languages, does not solve the privileged access aspect of the binary methods problem \n[Bruce et ul. 951. It may be that a mechanism such as C++ friendship grants would solve most of this \nin practice. We avoided giving methods in tuple classes default privileged access to the fields of the \ninstances in a tuple because that would violate information hiding. In particular, any client could access \nthe fields of instances of a class C simply by creating a tuple class with C as a component. tugle class \n(p:Point, out:Terminal) { method { print0 :O --prints Points to the lerminal . . . 1 t tuple class (p:Point, \n0ut:Printer) ( method ( print0 :(I-- prints Points to the printer . . 1 1 tuple class (cp:ColorPoint, \nmethod 0ut:ColorPrinter) print0 :O { ( -- print ColorPoints to the printer in color . . . I 1 Figure \n3: Multimethods in tuple classes for printing. The unit tuple type, (), is like C s void type.  3.2 \nMultiple Dispatch is not just for Binary Methods Multimethods are useful in many common situations other \nthan binary methods [Chambers 92, Baumgarter et al. 961. In particular, any time the piece of code to \ninvoke depends on more than one argument to the message, a multimethod easily provides the desired semantics. \nFor example, suppose one wants to print points to output devices. Consider a class Output with three \nsubclasses: Terminal, an ordinary Printer, and a ColorPrinter. We assume that Colorprinter is a subclass \nof Printer. Printing a point to the terminal requires different code than printing a point to either \nkind of printer. In addition, color printing requires different code than black-and-white printing. Figure \n3 shows how this situation is programmed in Tuple. In this example, there is no binary method problem. \nIn particular, the addition of print methods to the Point and ColorPoint classes will not upset the fact \nthat ColorPoint is a subtype of Point. The problem is that we need to invoke the appropriate method based \non both whether the first argument is a Point or ColorPoint and whether the second argument is a Terminal, \nPrinter, or Colorprinter. In a singly-dispatched language, an unnatural work-around such as Ingalls s \ndouble dispatching technique [Ingalls 86, Bruce er al. 951 is required to encode the desired behavior. \n 3.3 Tuples vs. Classes The ability to express multiple dispatching via dispatching on tuples is not \neasy to simulate in a single-dispatching language, as is well-known [Bruce et al. 951. The Ingalls double-dispatching \ntechnique mentioned above is a faithful simulation but often requires exponentially (in the size of the \ntuple) more methods than a multimethod-based solution. A second attempt to simulate multiple dispatch \nin single- dispatching languages is based on product classes [Section 3.2, Bruce eral. 951. This simulation \nis not faithful, as it loses dynamic dispatch. However, it is instructive to look at how this simulation \nfails, since it reveals the essential capability that Tuple adds to SDCore. Consider the following classes \nin SDCore (adapted from the Bruce ef al. paper). class TwoPoints ( fields(pl:Point, p2:Point) method \nequal () I pl.xO = p2.xo and ~1.~0 = ~2.~0 I j class TwoColorPoints { fields(cpl:ColorPoint, cp2:ColorPoint) \nmethod equal0 { (cpl.xO = cp2.xo and cpl.y() = cp2.y()) and (new TwoColors( cpl.color0, cp2.color())).equal() \n) With these classes, one could create instances that simulate tuples via the new expression of SDCore. \nFor example, an instance that simulates a tuple containing two Point instances is created by the expression \nnew TwoPoints(my-pl,my-p2). However, this loses dynamic dispatching. The problem is that the new expression \nrequires the name of the associated class to be given statically. In particular, when the following message \nsend expression is executed (new TwoPoints(mygl,myq2)) .equal() the method in the class TwoPoints will \nalways be invoked, even if both my-p1 and my-p2 denote ColorPoint instances at run-time. By contrast, \na tuple expression does not statically determine what tuple classes are applicable. This is because messages \nsent to tuples use the dynamic classes of the values in the tuple instead of the static classes of the \nexpressions used to construct the tuple. For example, even if the static classes of my-p1 and my-p2 areboth \nPoint, if myql and my-p:! denote ColorPoint instances, then the message send expression (my-p1 , my-p2 \n) . equal ( ) will invoke the method in the tuple class for (ColorPoint, ColorPoint) given in Figure \n2. Hence sending messages to tuples is not static overloading but dynamic overloading. It is precisely \nmultiple dispatch. Of course, one can also simulate multiple dispatch by using a variant of the typecase \nstatement to determine the dynamic types of the arguments and then dispatching appropriately. (For example, \nin Java one can use the getclass method provided by the class Object.) However, writing such code by \nhand will be more error-prone than automatic dispatch by the language. Such dispatch code will also need \nto be duplicated in each method that requires multiple dispatch, causing code maintenance problems. Every \ntime a new class enters the system, the dispatch code will need to be appropriately rewritten in each \nof these places, while in Tuple no existing code need be modified. Further problems can arise if the \nintent of the dispatch code (to do dispatch) is not clear to maintenance programmers. By contrast, when \nwriting tuple classes it is clear that multiple dispatch is desired. The semantics of Tuple ensures that \neach dispatch is handled consistently, and the static type system ensures that this dispatching is complete \nand unambiguous. 3.4 Type Checking for Tuple We add to the type attributes of SDCore product types of \nthe form (TI,...,T,); these are the types of tuples containing elements of types T, ,..., T,,. A product \ntype (T, ,..., T, ) is a subtype of (T,,...,T,) when each 7 : is a subtype of T;. Because of the multiple \ndispatching involved, type checking messages sent to tuples is a bit more complex than checking messages \nsent to instances (see Appendix B for the formal typing rules). We divide the additions to SDCore s type \nsystem into client-side and implementation-side rules [Chambers &#38; Leavens 951. The client-side rules \ncheck messages sent to tuples, while the implementation-side rules check tuple class declarations and \ntheir methods. The aim of these rules is to ensure statically that at run-time no type mismatches occur \nand that no message-not-understood or message-ambiguous error will occur in the execution of messages \nsent to tuples. The client-side rule is the analog of the method application rule for ordinary classes \ndescribed above. In particular, given an application (E, ,..., &#38;) . I (E,, ,,..., E,) we ensure that \nthere is some tuple class for the product type (T,,...,T,) such that the static type of (E, ,..., E, \n) is a subtype of (T, ,..., T,). Further, that tuple class must contain a method implementation named \nI with m-n additional arguments such that the static types of F -n+,,...,E,, are subtypes of the method \ns additional argument types. Because the rule explicitly checks for the existence of an appropriate method \nimplementation, this eliminates the possibility of message- not-understood errors. However, the generalization \nto multiple dispatching can easily cause method-lookup ambiguities. For example, consider again the PointKolorPoint \nexample from Section 2. Suppose that, rather than defining equality for the tuple classes (Point,Point) \nand (ColorPoint,ColorPoint ),we had defined equality instead for the tuple classes (Point, Color-Point) \nand (ColorPoint, Point) According to the client-side rule given above,an equal message sent totwo ColorPoint \nexpressions is legal, since there exists a tuple class of the right type that contains an appropriate \nmethod implementation. The problem is that there exist two such tuple classes, and neither is more specific \nthan the other. Therefore, at run-time such a method invocation will cause a method-ambiguous error to \noccur. Our solution is based on prior work on type checking for multimethods [Castagna et al. 92, Castagna \n951. For each pair of tuple classes (T ,,..., T,,) and (T, ,..., T,, ) that have a method named I that \naccepts k additional arguments, we check two conditions. The first check ensures nzonotonicity [Castagna \net ~1. 92, Castagna 95, Goguen 6t Meseguer 87, Reynolds SO]. Let (S, ,..., S,)+U and (S, ,..., Sk )-+U \nbe the types of the methods named I in the tuple classes (TI,...,~ ,,) and (T, ,..., T, ). respectively. \nSuppose that (T, ,..., T,) is a subtype of (T, ,..., T, ). Then (S, ,..., S,)-+U must be a subtype of \n(SI ,...,Sk )-+U . By the contravariant rule for function types, this means that for eachj, Sj must bc \na subtype of Sj, and I/ must be a subtype of I/ . The second check ensures that the two methods are not \nambiguous. We define two types S and T to be r&#38;ted if either S subtypes T or vice versa. In this \ncase, rtzin(S,T) denotes the one of S and T that subtypes the other. It must be the case that (TI ,..., \nT,,) and (T, ,..., T, ) are not the same tuple. Further, if for each j, Tj and T/ are related, then there \nmust be a tuple class (min(T,,T, ),...,rrh(T,,,T, )) that has a method named I with k additional arguments. \nThe existence of this method is necessary and sufficient to disambiguate between the two methods being \nchecked. The type rules for tuple classes and message sends to tuples validate part (b) of our first \nclaim. That is, Tuple s extensions to the SDCore type system are orthogonal. The typing rules in Tuple \nare a superset of the typing rules in SDCore. Hence, if an SDCore program or expression has type T, it \nwill also have type Tin Tuple.  3.5 Discussion In Tuple we chose a by-name typing discipline, whereby \nthere is a one-to-one correspondence between classes and types. This unification of classes with types \nand subclasses with subtypes allows for a very simple static type system. It also rctlects the common \npractice in popular object-oriented languages. Indeed, this approach is a variant of that used by C++ \nand Java. (Java s interfaces allow a form of separation of types and classes.) Although the type system \nis simplistic, the addition of multimethods to the language greatly increases its expressiveness, allowing \nsafe covariant overriding while preserving the equivalence between subclassing and subtyping. There are \nseveral other ways in which we could design the type system. For example, a purely structural subtyping \nparadigm could be used, with classes being assigned to record types based on the types of their methods. \nAnother possibility would be to maintain by-name typing but keep this typing and the associated subtyping \nrelation completely orthogonal to the class and inheritance mechanisms. This is the approach taken in \nCecil [Chambers 951. We ruled out these designs for the sake of clarity and simplicity. Another design \nchoice is whether to dispatch on classes or on types. In Tuple, this choice does not arise because of \nthe strong correlation between classes and types. In particular, the Tuple dispatching semantics can \nbe viewed equivalently as dispatching on classes or on types. However, in the two alternate designs presented \nabove, the dispatching semantics could be designed either way. Although both options are feasible, it \nis conceptually simpler to dispatch on classes, as this nicely generalizes the single-dispatching semantics \nand keeps the dynamic semantics of the language completely independent of the static type system. The \nnames of the tuple formals in a tuple class are, in a sense, a generalization of self for a tuple. They \nalso allow a very simple form of the pattern matching found in functional languages such as ML [Milner \net al. 901. Having the tuple formals be bound to the elements of the tuple allows Tuplc, like ML, to \ninclude tuple values without needing to build into the language primitive operations to extract the components \nof a tuple. It is interesting to speculate about the advantages that might be obtained by adding algebraic \ndatatypes and more extensive pattern-matching features to object-oriented languages (see also [Bourdoncle \n&#38; Merz 97, Ernst et ~11. 981). 4 RELATED WORK In this section we discuss two kinds of related work. \nThe first concerns generic-function languages; while these do not solve the problem we address in this \npaper, using such a language is a way to obtain multiple dispatch. The second, more closely-related work, \naddresses the same problem that we do: how to add support for multiple dispatch to languages with single \ndispatch. An inspirational idea for our work is the technique for avoiding binary methods by using product \nclasses described by Bruce et al. [Section 3.2, Bruce et al. 951. We discussed this in detail in Section \n3.3 above. Another source of inspiration for this work was Castagna s paper on covariance and contravariance \n[Castagna 951. This makes clear the key idea that covariance is used for all arguments that are involved \nin method lookup and contravariance for all arguments that are not involved in lookup. In Tuple these \ntwo sets of arguments are cleanly separated, since in a tuple class the arguments in the tuple are used \nin method lookup, and any additional arguments are not used in method lookup. The covariance and contravariance \nconditions are reflected in the type rules for Tuple by the monotonicity condition. 4.1 Generic-Function \nLanguages Our approach provides a subset of the expressiveness of CLOS, Dylan, and Cecil multimethods, \nwhich are based on generic functions. Methods in tuple classes do not allow generic functions to have \nmethods that dynamically dispatch on different subsets of their arguments. That is, in Tuple the arguments \nthat may be dynamically dispatched upon must be decided on in advance, since the distinction is made \nby client code when sending messages to tuples. In CLOS, Dylan, and Cecil, this information is not visible \nto clients. On the other hand, a Tuple programmer can hide this information by always including all \narguments as part of the tuple in a tuple class. (This suggests that a usef ul syntactic sugar for Tuple \nmight be to usef(E/ ,..., E,,) as sugar for (El ,..., E,,).&#38;) when n is at least 2.) Second, gcncric \nfunction languages are more uniform, since they only have one dispatching mechanism and can treat single \ndispatching as a degenerate case of multiple dispatching rather than differentiating between them. Although \nWC believe that these advantages make CLOS-style multimethods a better design for a new language the \napproach illustrated by Tuple has some key advantages for adapting existing singly-dispatched languages \nto multimcthods. First, our design can be used by languages like C++ and Java simply by adding tuple \nexpressions, tuplc types, tuple classes, and the ability to send messages to tuples. As we have shown, \nexisting code need not be modified and will execute and type check as before. This is in contrast to \nthe generic function model, which causes a major shift in the way programs are structured. Second, our \nmodel maintains class-based encapsulation, keeping the semantics of objects as self-interpreting records. \nThe generic function model gives this up and must base encapsulation on scoping constructs, such as packages \n[Chapter 11, Steele 901 or local declarations [Chambers &#38; Leavens 971. 4.2 Encapsulated and Parasitic \nMultimethods Encapsulated multimethods [Section 4.2.2, Bruce et ml. 951 [Section 3.1. I I, Castagna 971 \nare similar in spirit to our work in their attempt to integrate multimethods into existing singly-dispatched \nlanguages. The following example uses this technique to program equality tests for points in an extension \nto SDCore. class Point { . . . method equal(p:Point) :bool { xval = p.xO and yval = p.y() } 1 class ColorPoint \ninherits Point { . . . method equal(p:Point) :bool { xval = p.xO and yval = p.y() } method equal(p:ColorPoint):bool \nc (xval = p.xO and yval = p.y()) and colorval.equal(p.color()) ) } With cncapsulatcd multi-methods, \neach message send results in two dispatches (in general). The first is the usual dispatch on the class \nof the receiving instance (messages cannot be sent to tuples). This dispatch is followed by a second, \nmultimethod dispatch, to select a multimethod from within the class found by the first dispatch. In the \nexample above, the message pl . equal (p2 ) first finds the dynamic class of the object denoted by pl. \nIfpl denotes a Colorpoint, then a second multimethod dispatch is used to select between the two multimethods \nfor equal in the class ColorPoint.. In essence, the first dispatch selects a generic function formed \nfrom the multimethods in the class of the receiver, and the second dispatch is the usual generic function \ndispatch on the remaining arguments in the message. One seeming advantage of encapsulated multimethods \nis that they have access to the private data of the receiver object, whereas in Tuple, a method in a \ntuple class has no privileged access to any of the elements in the tuple. In languages like C++ and Java, \nwhere private data of the instances of a class are accessible by any method in the class, this privileged \naccess will bc useful for binary methods. However, this advantage is illusory for multimcthods in general, \nas no special access is granted to private data of classes other than that of the receiver. This means \nthat access must be provided to all clients, in the form of accessor methods, or that some other mechanism, \nsuch as C++ friendship grants, must provide such access to the other arguments private data. Two problems \nwith encapsulated multimethods arise because the multimethod dispatch is preceded by a standard dispatch \nto a class. The first problem is the common need to duplicate methods or to use stub methods that simply \nforward the message to a more appropriate method. For example, since Colorpoint overrides the equal generic \nfunction in Point, it must duplicate the equal method declared within the Point class. As observed in \nthe Bruce et al. paper, this is akin to the Ingalls technique for multiple polymorphism [Ingalls 861. \nParasitic multimethods [Boyland &#38; Castagna 971, a variant of encapsulated multimethods, remove this \ndisadvantage by allowing parasitic methods to be inherited. The second problem caused by the two dispatches \nis that existing classes sometimes need to bc modified when new subclasses arc added to the system. For \nexample, in order to program special behavior for the equality method accepting one Point and one Colorpoint \n(in that order), it is necessary to modify the Point class, adding the new encapsulated multimethod. \nThis kind of change to existing code is not needed in Tuple, as the programmer simply creates a new tuplc \nclass. Indeed, Tuple even allows more than one tuple class with the same tuple of component classes, \nallowing new multimethods that dispatch on the same tuple as existing multimethods to enter the system \nwithout requiring the modification of existing code. Encapsulated and parasitic multimethods have an \nadvantage in terms of modularity over both generic-function languages and Tuplc. The modularity problem \nof generic-function languages, noted by Cook ]Cook 901, is that independently- developed program modules, \neach of which is free of the possibility of message-rnmbi~uo~~s errors, may cause nzessaXe-ctmbj~uoL1.s \nerrors at run-time. For example, consider defining the method equal in three modules: module A defines \nit in a tuplc class (Point, Point), module B in a tuple class (Point, ColorPoint), and module C in a \ntuple class (ColorPoint, Point). By themselves these do not cause any possibility of message- ambiguous \nerrors, and a program that uses either A and B or A and C will type check. However, a program that includes \nall three modules may have message-ambiguous errors, since a message sent to a tuplc of two ColorPoint \ninstances will not be able to find a unique most-specific method. Therefore, a link-time check is necessary \nto ensure type safety. Research is underway to resolve this problem for generic function languages [Chambers \n&#38; Leavens 951, which would also resolve it for Tuple. However, to date no completely satisfactory \nsolution has emerged. The design choices of encapsulated and parasitic multimethods were largely motivated \nby the goal of avoiding this loss of modularity. Encapsulated multimethods do not sulfer from this problem \nbecause they essentially define generic functions within classes, and each class must override such a \ngeneric function as a whole. (However, this causes the duplication described above.) Parasitic multimethods \ndo not have this problem because they use textual ordering within a class to resolve ambiguities in the \ninheritance ordering. However, this ordering is hard to understand and reason about. In particular, if \nthere is no single, most-specific parasite for a function call, control of the call gets passed among \nthe applicable parasites in a manner dependent on both the specificity and the textual ordering of the \nparasites, and determining at which parasite this ping-ponging of control terminates is difficult. Boyland \nand Castagna also say that, compared with their textual ordering, ordering methods by specificity as \nwe do in Tuple is very intuitive and clear [Page 73, Boyland dt Castagna 971. Finally, they note that \ntextual ordering causes a small run-time penalty in dispatching, since the dispatch takes linear instead \nof logarithmic time, on the average. CONCLUSIONS The key contribution of this work is that it describes \na simple, orthogonal way to add multiple dispatch to existing single-dispatch languages. We showed that \nthe introduction of tuples, tuple types, tuple classes for the declaration of multimethods, and the ability \nto send messages to tuples is orthogonal to the base language. This is true in both execution and typing. \nAll that tuple classes do is allow the programmer to group several multimethods together and send a tuple \na message using multimethod dispatching rules. Since existing code in single-dispatching languages cannot \nsend messages to tuples, its execution is unaffected by this new capability. Hence our mechanism provides \nan extra layer, superimposed on top of a singly-dispatched core. Design decisions in this core do not \naffect the role or functionality otituples and tuple classes. Tuple also compares well against related \nattempts to add multiple dispatch to singly-dispatched languages. We have shown that Tuplc s uniform \ndispatching semantics avoids several problems with these approaches, notably the need to plan ahead for \nmultimethods or be forced to modify existing code as new classes enter the system. On the other hand, \nthis uniformity also causes Tuple to suffer from the modularity problem of generic-function languages, \nwhich currently precludes the important software engineering benefits of separate type checking. The \nTuple language itself is simply a vehicle for illustrating the idea of multiple dispatching via dispatching \non tuples. Although it would complicate the theoretical analysis of the mechanism, C++ or Java could \nbe used as the singly-dispatched core language. ACKNOWLEDGMENTS Thanks to John Boyland for discussion \nand clarification about parasitic multimethods. Thanks to the anonymous referees for helpful comments. \nThanks to Olga Antropova, John Boyland, Giuseppe Castagna, Sevtap Karakoy, Clyde Ruby, and R. C. Sekar \nfor comments on an earlier draft. Thanks to Craig Chambers for many discussions about multimethods. Thanks \nto Olga Antropova for the syntactic sugar idea mentioned in Section 4.1. Thanks to Vassily Litvinov for \npointing us to [Baumgartner et al. 961 and to Craig Kaplan for an idea for an example. Leavens s work \nwas supported in part by NSF Grants CCR 9593168 and CCR-9803843. REFERENCES [Ada 831 American National \nStandards Institute. Reference Manual for the Ada Programming Language. ANSIIMIL- STD I81 5A, February, \n1983. [Amadio &#38; Cardelli 931 Roberto M. Amadio and L. Cardelli. Subtyping recursive types. ACM Transactions \non Programming Languages und Systems, 15(4):575-63 1, 1993. [Arnold &#38; Gosling 981 Ken Arnold and \nJames Gosling. The Juvu Programming Language. Second Edition, Addison-Wesley, Reading, Mass., 1998. [Baumgartner \net al. 961 Gerald Baumgartner, Konstantin Laufer, Vincent F. Russo. On the Interaction of Object- Oriented \nDesign patterns and Programming Languages. Technical Report CSD-TR-96-020, Department of Computer Science, \nPurdue University, February 1996. [Bobrow et ul. 861 Daniel G. Bobrow, Kenneth Kahn, George Kiczales, \nLarry Masinter, Mark Stefik, and Frank Zdybel. CommonLoops: Merging Lisp and Object-Oriented Programming. \nIn Norman Meyrowitz (editor), OOPSLA X6 Conference Proceedings, Portland, Oregon, September 1986, volume \n21, number 1 I of ACM SIGPLAN Notices, pp. 17-29. ACM, New York, November, 1986. [Bourdoncle &#38; Merz \n971 Franc;ois Bourdoncle and Stephan McrL. Type Checking Higher-Order Polymorphic Multi-Methods. Conference \nRecord of POPL 97: The 24th ACM SIGPLAN-SIGACT Symposium on Principles of Progrumming Languages, Paris, \nFrance, pp. 302-3 15. ACM, New York, January 1997. [Boyland &#38; Castagna 971 John Boyland and Giuseppe \nCastagna. Parasitic Methods: An Implementation of Multi-Methods for Java. Proceedings of the ACM SIGPLAN \nConference on Object-Oriented Programming Systems, Languages and Applications (OOPSLA 97). Volume 32, \nnumber 10 of ACM SIGPLAN Notices, pp. 66- 76. ACM, New York, November 1997. [Chambers &#38; Leavens 97) \nCraig Chambers and Gary T. Leavens. BeCecil, A Core Object-Oriented Language with Block Structure and \nMultimethods: Semantics and Typing. Department of Computer Science, Iowa State University, TR #96-17a, \nApril 1997. ftp:// ftp.cs.iastate.edu/pub/techreports/TR96-17/TR.ps.Z; the appendix sections only are \nin ftp://ftp.cs.iastate.edu/pub/ techreports/TR96- 17/appendix.ps.Z. [Bruce etal. 931 Kim B. Bruce and \nJon Crabtree and Thomas P. Murtagh and Robert van Gent and Allyn Dimock and Robert Muller. Safe and decidable \ntype checking in an object-oriented language. In Andreas Paepcke (editor), OOPSLA 93 Conference Proceedings. \nVolume 28, number IO of ACM SIGPLAN Notices, pp. 29-46. ACM, New York, October, 1993. [Bruce et al. 951 \nKim Bruce, Luca Cardelli, Giuseppe Castagna, The Hopkins Object Group, Gary T. Leavens, and Benjamin \nPierce. On Binary Methods. Theory and Practice ofobject Systems, 1(3):221-242, 1995. [Cardelli 881 Luca \nCardelli. A Semantics of Multiple Inheritance. Information and Computation, 76(2/3):138-164, February/March, \n1988. An earlier version appeared in the 1984 Semantics of Data Types Symposium, LNCS 173, pp. 5 I-66, \nSpringer-Verlag, 1984. [Castagna et al. 921 Giuseppe Castagna, Giorgio Ghelli, and Giuseppe Longo. A \nCalculus for Overloaded Functions with Subtyping. In Proceedings of the 1992 ACM Conference on Lisp and \nFunctional Programming, San Francisco, June, 1992, pp. 182-192, volume 5, number I of LISP Pointers. \nACM, New York, January-March, 1992. [Castagna 951 Giuseppe Castagna. Covariance and contravariance: conflict \nwithout a cause. ACM Transactions on Programming Languages and Systems, 17(3):43 l-447, 1995. See also \n[Chapter 5, Castagna 971. [Castagna 971 Giuseppe Castagna. Object-Oriented Programming A Unified Foundation. \nBirkhtiuser, Boston, 1997. [Chambers 921 Craig Chambers. Object-Oriented Multi-Methods in Cecil. In 0. \nLehrmann-Madsen, editor, ECOOP 92 Conference Proceedings, Utrecht, the Netherlands, June/July, 1992, \nvolume 615 of Lecture Notes in Computer Science, pp. 33-56. Springer-Verlag, Berlin, 1992. [Chambers \n951 Craig Chambers. The Cecil Language: Specification and Rationale: Version 2.0. Department of Computer \nScience and Engineering, University of Washington, December, 1995. http:// www.cs.washington.edu/researcNprojects/cecil/www/ \nPapers/Cecil-spec.html [Chambers &#38; Leavens 951 Craig Chambers and Gary T. Leavens. Typechecking and \nModules for Multi-Methods. ACM Transactions on Programming Languages and Systems, 17(6):805-843. November, \n1995. [Cook et al. 901 William Cook, Walter L. Hill, and Peter S. Canning. Inheritance is not Subtyping. \nIn Conference Record of the Seventeenth Annual ACM Symposium on Principles of Programming Languages, \nSan Francisco, California, pp 125- 135. ACM, New York, 1990. [Cook 901 William Cook. Object-Oriented \nProgramming versus Abstract Data Types. In J.W. de Bakker, W.P. de Roever, and G. Rozenberg, editors, \nFoundations qf Object-Oriented Languages, REX School/Workshop Proceedings, Noordwijkerhout, the Netherlands, \nMay/June, 1990, volume 489 of Lecture Notes in Computer Science, pp. 15 1 - 178. Springer-Verlag, New \nYork, 199 1. [Ernst et al. 981 Michael D. Ernst, Craig Kaplan, and Craig Chambers. Predicate Dispatching: \nA Unified Theory of Dispatch. To appear in ECOOP 98, the 12th European Conference on Object-Oriented \nProgramming, Brussels, Belgium, July, 1998. Also http:llwww.cs.washington.edu/ research/projects/cecil/wwww/wwwlPaperslgud.html. \n[Feinberg et al. 971 Neal Feinberg, Sonya E. Keene, Robert 0. Mathews, and P. Tucker Withington. The \nDylan Programming Book. Addison-Wesley Longman, Reading, Mass., 1997. [Gamma et al. 951 Erich Gamma and \nRichard Helm and Ralph Johnson and John Vlissides. Design Patterns: Elements of Reusable Object-Oriented \nSoftware. Addison- Wesley, Reading, Mass., 1995. [Goguen &#38; Meseguer 871 Joseph A. Goguen and Jose \nMeseguer. Order-Sorted Algebra Solves the Constructor- Selector, Multiple Representation and Coercion \nProblems. In Symposium on Logic in Computer Science, Ithaca, NY, pp. 18-29. IEEE Press, NY, June, 1987. \n[Goldberg &#38; Robson 831 Adele Goldberg and David Robson. Smalltalk-80: The Language and its Implementation. \nAddison-Wesley, Reading, Mass., 1983. [Gosling et al. 961 James Gosling, Bill Joy, Guy Steele, Guy L. \nSteele. The Java Language Specification. Addison-Wesley, Reading, Mass., 1996. [Ingalls 861 D. H. H. \nIngalls. A Simple Technique for Handling Multiple Polymorphism. In Norman Meyrowitz, editor, OOPSLA 86 \nConference Proceedings, Portland, Oregon, November; 1986, volume 21, number 11 of ACM SIGPLAN Notices, \npp. 347-349. ACM, New York, October, 1986. [Kiczales &#38; Rodriguez 931 Gregor Kiczales and Luis H. \nRodriguez Jr. Efficient Method Dispatch in PCL. In [Paepcke 931, Chapter 14. [Meyer 921 Bertrand Meyer. \nEifSel: The Language. Prentice Hall, New York, 1992. [Meyer 971 Bertrand Meyer. Object-Oriented Software \nConstruction. Second Edition, Prentice Hall, New York, 1997. [Milner et al. 901 Robin Milner, Mads Tofte, \nand Robert Harper. The Definition of Standard ML. MIT Press, Cambridge, MA, 1990. [Moon 861 David A. \nMoon. Object-Oriented Programming with Flavors. In Norman Meyrowitz (editor), OOPSLA 86 Conference Proceedings, \nPortlund, Oregon, September 1986, volume 2 1, number 1 I of ACM SIGPLAN Notices, pp. l-8. ACM, New York, \nNovember, 1986. [Paepcke 931 Andreas Paepcke. Object-Oriented Programming: The CLOS Perspective. MIT \nPress, 1993. E ::= Expression new CN(ES) ) E.MN E 1 TUP self ) I I <built-in operations on ints and bools> \nES ::= Expression-List E, 1 E. Es TUP ::= Tuple o I (77-3 TES : := Tuple-Expression-List E,, E, 1 E, \nES CN I:= Class-Name I MN ::= Method-Name I . .= I . . Identifier ^ . . strings oj alphanumerics, starting \nwith an alphabetic [Reynolds 801 John C. Reynolds. Using Category Theory to Design Implicit Conversions \nand Generic Operators. In Neil D. Jones (editor), Semantics-Directed Compiler Generation, Proceedings \nof a Workshop, Aarhus, Denmark, pp. 21 l-258. Volume 94 of Lecture Notes in Computer Science, Springer-Verlag, \nNY, 1980. [Schmidt 941 David A. Schmidt. The Structure of Typed Programming Languages. MIT Press, Cambridge, \nMass., 1994. [Shalit 971 Andrew Shalit. The Dylan Reference Manual: The Definitive Guide to the New Object-Oriented \nDynamic Language. Addison-Wesley, Reading, Mass., 1997. [Steele 901 Guy L. Steele Jr. Common Lisp: The \nLanguage (second edition). Digital Press, Bedford, MA, 1990. [Stroustrup 971 Bjarne Stroustrup. The C++ \nProgramming Language: Third Edition. Addison-Wesley, Reading, Mass., 1997. APPENDIX A FORMAL SYNTAX The \nfollowing is the concrete syntax for Tuple. The italic font notations to the right are the names of the \nsyntactic domains. PROG : : = Program RD.7 E RD.7 ::= Recursive-Declaration-SeqD ) D RDS Ll ::= Declaration \ntuple class TF { MS } I class I, { fields FMS 1 class I, inherits I, { fields FMS) F : := Formals 0 I \n(FS) FS ::= Formal-List I:T ) I:T, E-S TF . . _= Tuple- Formals 0 I (TFS) TFS : := Tuple-Formal-List \nI,:T1, Iz: T, I I:T. TFS ..- T ._-Type int 1 boo1 I PI T,-+T2 ) CN P : := Product-Type 0 I (7-7.S) \n 7-n ::= Tuple-Type-List T,, T, 1 T. T 7.S MS ::= Method-List M ) MMS M : := Method method I F : T { \nE } APPENDIX B FORMAL TYPING RULES B.l Type attributes For type checking, we extend the type attributes \nfound in the concrete syntax to a larger domain, which we also call Type, as follows. (The symbols P, \nCN, and FS mean the same syntactic domains as above, but we interpret the Ts that occur in product types \nand formals as meaning the domain Type below.) . .= T . . Type int 1 boo1 1 P I T,+T ) CN I T exg ) \nk dec I c cls f t tup ::= (1 1 (FS) TypeEnv i : : = (p, cs, ts) TypeContext CS . . ClassEnv . .= P \nc : := (F. p, CN) Classlnfo ts ::= [I I ITIS T&#38;es TIS : : = TuplelnfoRelationships (P, T) 1 (P, T) \n, TIS t ::= (F, p) TupleClasslnfo Following Schmidt [Schmidt 941, type attributes of the form T exp stand \nfor expressions that return type T. Type attributes of the form k dec stand for declarations that have \nthe effect of making a context k. Type attributes of the form c cls record information, c, about a class; \nthese are used as the types of classes (as opposed to their instances). Type attributes of the form t \ntup record information, t, about a tuple class. The domains TypeEnv and ClassEnv are regarded as finite \nfunctions from identifiers to types; hence we make sure that there is at most one association for a given \nidentifier in its domain. Similarly we regard the domain Tuples as a finite relation between product \ntypes and type attributes of the form t tup. B.2 Preliminary definitions and functions We define the \nfollowing helper functions on finite functions, relations, and lists of formals: dom( { It:Tt ,..., I,:Tn}) \n= {It ,..., I,) range( { It:T, ,..., I,:T,)) = (Tt ,..., T,) The function + denotes a shadowing union \nof two relations (or functions), favoring the second one: r, + r2 = ( (XJ) I (x,y) E r2 or [(x,y) E rt \nand x P dom(r2)1)  The function + is also extended to a shadowing union of two TypeContexts, favoring \nthe second: (p,,C .s,,t.s,) + (p2,cs2,ts2) = (p, + p2, CSI + cs2, ts/ u ts2) We define the following \nhelper functions on the domain Clusslnfo: jield-types((l,:T) ,..., I,:T,,), p, I ) = (T, ,..., T,,) meth-env(F, \np, I ) = p We define the helper function meth-env also on the domain TupleClasslnjb: meth-env(F, p) = \np We define a helper function on the syntax of methods: nnme(method I F : T { E )) = I We define a helper \nfunction on types: length(T) = if 3 n 3 T, . . . 3 T,,. (n 2 0 and T = (TI ,..., T,,)) then n else 1 \nWe define a helper function on pairs of types: nzin(S,T,cs) = if cs t- S 5 T then S else T We define \na helper function to check the disjointness of a list of identifiers: disjoint(l,,..., I,) = # i.V j. \n(1 5 i I n and 1 5 j 2 n andl;=Ij)*(i=j)  8.3 Type Checking Rules Besides T, we also use S, I/, and \nV for types. Recall that P is used for product types. B.3.1 Type Checking Programs kO+k k RDS: k dec, \nk,+k t- impl-side-type-check, ko+ktE:Texp where kO = Iprogram (O,Vop:(OsI l,Top) ~1~1, 11) /-RDSE: Texp \nFigure B-I : Rule of the form t Program : Type. The class name Top is used to avoid special cases that \nwould result from some classes not having a superclass. B.3.2 Type Checking Recursive Declaration Sequences \n A recursive declaration sequence allows mutual recursion among its declarations. k + (k, + k2) 1 D : \nk, dec, k + (k, + k2) t RDS : k2 dec where (p,,csI,tsl) = kl, tp2,cs2,ts2)= k2, [rdsl k /- D; RDS : \n(kl + k2) dec donz(p,) n dom(p2) = 11, dom(csl) n dom(cs2) = (1 Figure B-2: Rule of the form TypeContext \nb Recursive-Declaration-Sequence : TypeContext dec. 8.3.3 Type Checking Declarations where m 2 0, n 2 \n0, k + kurKs I- MI : S,+T,, . . . . k + krrrgs I-- M,, : S,+T,, disjoint(l,,...,l,,), [tuple-dec] k \nt tuple class (II:U~,...,I,,,:U,,) { M, . . . M, } : kctrgs= ((l,:U,,...,l,,.U,l,( 1-1 11, (O,O,{((U,,...,U,,),((~,:UI,...,f,,:U,),p)tup))}) \ndec p = ( MNl:SI-+T ,,..., MN,l: S,l-+T,) vi. 1 IiInaMNi=name(M;) k t class 1 inherits Top { fields \n(I,:U, ,..., I,:U,,,) MI . . . M,, ) : k dec [class-dec] where m 2 0, n 2 0 k t-class I ( fields (I,:lJ, \n,...,I,,:lJ,,,) Ml M, 1 : k dec where m 2 0, n 2 0, 12 0, i 2 0, . ..) (f:c cls) E cs, @,c.W + ({(selfJll,( \nI,{ I) + kflds I-M,, : S,,+-T,,, p = meth-env(c), (I,,,:V] ,..., I,,l:VJ =jields(c), cs t s,,l)-+T,,l, \n5 s,(l, +Gt(l, J . . . . disjoint(I,, ,..., Ic,pll ,..., I,,,), [class-inh-cs t Sn(;)*Tn(;) 5 Sn(i, +Tn(i, \nt kf2ds= (ir,,,:v,,...,l,,,:v,),( )>I 1) + dec] ((I,:u] ,..., I,:U,),{ I,{ I>, (p,cs,ts) t class I inherits \nI ( V j. I 5 j 5 n 3 MNj = name(Mj), fields (I,:CJ, ,..., I,,,:U,) Ml . . . M,, ) p=p + {MN,:S,+T ,,..., \nMN,,: S,-+T,,), : ({>, {I:(&#38;.,:V I,..., l,,,:vl,I,:u I,..., 1,,:u,),p,~)c1&#38; n:( l,.., n)+( l,.., \nn}, n is a permutation, iI> dec dj. 1 I jSi ti (MN,(j,:S,(j, ~T,(j, ) E p , V j. i <j< n + MN,(j) P dam@ \n) Figure B-3: Rules of the form TypeContext t Declaration : TypeContext dec. 8.3.4 Type Checking Methods \n k + t((f,,T,),...,(I,,,T,)l,( I,{ )I I-E: Texp where n 2 0, [method] disjoint(l,,...,l,) k t method \nI (I,:T, ,..., I,:T,J : T ( E ) : (T, ,..., T,J+T Figure B-4: Rule of the form TypeContext k Method : \nType. 8.3.5 Type Checking Expressions (p,cs,ts) t El : Tl exp, . . . . (p,cs,t.s) t E,, : T,, exp where \nn 2 0, [new1 @,cs,ts) t new CN (El ,..., E,) : CN exp (CN,c) E cs, field-types(c) = (Tl,...,T,J [app-ret] \n(p,cs,ts) t- E0 : lo exp, (p,cs,ts) 1 E : S exp (p,cs,ts) t E,.MN E: Texp where (1,:~ cls) E cs, (MN:S+T) \nE meth-env(cs) law-prod1 (p,cs,ts) I-- E. : (Tl ,..., T,) exp, @.cs,ts) I- E : S exp (p,cs,ts) t Eo. \nMN E : T exp where n 2 0, n f I, ((TI,...,Tn), t tup) E ts, (MN:S-+T) E meth-env(t) k t E, : T, exp, \n. . . . k t E, : T,, exp [tuple] where n 2 0, pz # I k t (El ,..., EJ : (TI ,... , T,,) exp [self] (p,cs,ts) \n1 self : T exp where (self:T) E p WI (p,cs,ts) t I : T exp where (I:T) E p [sub- (p,cs,ts) t E : S exp, \ncs t S 5 T - sumption] @,cs,ts) t E : T exp Figure B-S: Rules of the form TypeContext j-- Expression \n: Type. We omit rules for the built-in operators on integers and booleans. B.3.6 Subtyping Rules [sub-eq] \ncstTlT cstSlT, cstTTIU [sub-trans] csts<u [ sub-CN] cs t CN ICN2 where (CN:(F,p,CN2) cls) E cs cs t \nS, I T,, . . . . cs t S,,2 T,, [sub- where n 2 0. n # 1 prod1 cs t (S ,,..., S,) I (T],...,T,J cs t T, \nI S,, cs t S, 2 T2 [sub-fun] cs t S,-+S2 I T,+Tz Figure B-6: Subtyping rules of the form Classes t Type \nI Type. 6.3.7 Implementation-side Type Checking Rules where n 2 0, in 2 0, @,cs,ts) k impl-check MN,, \n. . . . (p,cs,ts) t-- impl-check MN,, (tl,...,t,} = runge(ts),[impl-all] (MN,,...,MN,] = @,cs,ts) k impl-side-type-check \ni=l..m dom(meth-env(t,)) cs /-- (P,,Tt) is-monotonic-in [(Pl,Tj),...,(P,,T,)], . . . . cs k (P,, T,J \nis-monotonic-in [(Pt,Tt) ,..., (P,T,J], where n 2 0, (p,cs,ts) t (P,,T,) unambiguous-with-each [(Pz,T~),...,(P,,T,,)I) \n[(PI T,) _,, (p = [impl- T )I 8 11 n n.for MN, method] [(en 1 (Rttup) E ts . ..( and (MN:T) E meth-em(t)] \n(p,cs,ts) b (P,.,,Tn.t) unambiguous-with-each [(P,,,TJ for MN @,cs,ts) t impl-check MN where n 2 0, \ncs t-- T,-+T2 I T,,,-+T,,,, . . . . cs t T,--+T, I T,J-+T~,,~ {T,,,~T,,,,...,T,,,jT,,,} = [is-monoJ (Ti,,~Ti,2ICStPIPi \ncs 1 (P.Tl+Tz) is-monotonic-in s and (Pi,Ti,,+Tj,J E s and length(Tt,t) = length(Tt)) @,cs,ts) t- (P,T) \nunambiguous-with (P,,Tt) for MN, . ..) [ unam- (p,cs,ts) k (P,T) unambiguous-with (P,,T,) for MN biguous-where \nr~ 2 0 each] (p,cs,ts) k (P,T) unambiguous-with-each I(P,,T,),...,(P,,T,)] for MN where n 2 0, m 2 0, \nP f P , P = (TI ,..., T,), P = (Tj ,..., T, ), (n = m and length(S) = length(f) 1 Ij<n=+ [unam-@,cs,ts) \nb (P,S+T) unambiguous-with (P ,S +f) for MN and(Vj. cs f- (Tj Tj ) are-related)) biguous-] * (((min(PI,P, \n,cs) ,..., min(P,,P, ,cs)), t tup) E IS and (3 S .3y. (length(f) = length(S) and (MN:S +?) E meth-em(t))) \nrelated-l] cs /- (ST) are-rekuted cstTlS related-21 cs f- (ST) are-related Figure B-7: Rules for checking \nthe implementation-side type safety of a program. We use list notation [...I and list comprehensions \n(as in Haskell) in some of these rules.    \n\t\t\t", "proc_id": "286936", "abstract": "Many popular object-oriented programming languages, such as C++, Smalltalk-80, Java, and Eiffel, do not support multiple dispatch. Yet without multiple dispatch, programmers find it difficult to express binary methods and design patterns such as the \"visitor\" pattern. We describe a new, simple, and orthogonal way to add multimethods to single-dispatch object-oriented languages, without affecting existing code. The new mechanism also clarifies many differences between single and multiple dispatch.", "authors": [{"name": "Gary T. Leavens", "author_profile_id": "81452614743", "affiliation": "Department of Computer Science, Iowa State University, 229 Atanasoff Hall, Ames, Iowa", "person_id": "P94154", "email_address": "", "orcid_id": ""}, {"name": "Todd D. Millstein", "author_profile_id": "81100018064", "affiliation": "Department of Computer Science and Engineering, University of Washington, Box 352350, Seattle, WA", "person_id": "P283206", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/286936.286977", "year": "1998", "article_id": "286977", "conference": "OOPSLA", "title": "Multiple dispatch as dispatch on Tuples", "url": "http://dl.acm.org/citation.cfm?id=286977"}