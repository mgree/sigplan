{"article_publication_date": "10-01-1998", "fulltext": "\n What is Java Binary Compatibility , Sophia Drossopoulou, David Wragg, Susan Eisenbach Department of \nComputing Imperial College sd(dpw,se)@doc.ac.ac.uk Abstract Separate compilation allows the decomposition \nofpro-grams into units that may be compiled separately, and linked into an executable. Traditionally, \nseparate com-pilation was equivalent to the compilation of all units t,ogether, and modification and \nre-compilation of one unit, required re-compilation of all importing units. Java suggests a more flexible \nframework, in which the linker checks the integrity of the binaries to be com- bined. Certain source \ncode modifications, such as addi- tion of methods to classes, are defined as binary compat-ible. The \nlanguage description guarantees that binaries of types (i.e. classes or interfaces) modified in binary \ncompatible ways may be re-compiled and linked with the binaries of types that imported and were compiled \nusing the earlier versions of the modified types. However, this is not always the case: some of the changes \nconsidered by Java as binary compatible do raot guarantee successful linking and execution. In this paper \nwe study the concepts around binary compatibil-ity. We suggest a formalization of the requirement of \nsafe linking and execution without re-compilation, in-vestigate alternatives, demonstrate several of \nits prop- erties, and propose a more restricted definition of binary compatible changes. Finally, we \nprove for a substantial subset of Java, that this restricted definition guarantees error-free linking \nand execution. 1 Introduction Module systems 119, 181, introduced in the seventies, support the decomposition \nof large programs into small, more manageable units (modules, classes, clusters, pack- ages). Traditionally, \nseparate compilation [3] allowed Permlsslon to make dIgItal or hard copses of all or part of this work \nfor personal or classroom use 1s granted without fee prowded that copes are not made or distributed for \nprofit or commercial advan- tage and that copws bear thts not,ce and the full cntat+on on the first page \n70 copy otherww. to republish. to post on servers or to redistribute to lost% requws prwx speclflc permission \nand/or a lee. OOPSLA 98 10198 Vancouver. B.C. 0 1998 ACM l-581 13.005.8/98/0010...$5.00 these units \nto be compiled one at a time using only the signature (i.e. type) information from imported units. The \nobject code of such separately compiled units would be combined by a linker into an executable. If each \nunit were compiled after any unit it imported, each unit com-piled successfully, and all units were present, \nthen link-ing would be successful. The compiler had to check that units respected imported units signatures, \nwhereas the linker had to reconcile external references, and to check the order of compilation, typically \nusing time stamps in the object code. Therefore, separate compilation was equivalent to the compilation \nof all units together. Because of the intended support for loading and exe- cuting remotely produced \ncode, Java has a different ap-proach to separate compilation and linking. As before, classes may be compiled \nseparately -even ondiffer-ent machines, and the compiler has to check that units respect imported units \nsignatures. Also, if each unit compiles successfully, and it is compiled after any unit, it imported, \nthen linking will be successful. However, the remit of the linker has been extended: Not, only does it \nhave to resolve external references, it also has to ensure that, binaries are structurally correct (vcrifi-cation), \nand that they respect the types of entities they import from other binaries (resolution). In the traditional \napproach, when the signature of a unit is modified and re-compiled, all importing units have to be re-compiled \nas well. In Java however, re-compilation of importing units cannot always be en-forced. It, is the task \nof the linker to ensure that the binaries respect each others exported signatures, inde-pendently of \nthe order of compilation. Certain source code modifications, such as adding a method to a class, are \ndefined as binary compatible [S]. The Java language description does not require the re-compilation of \nunits importing units which were modified in binary compat-ible ways, and claims that successful linking \nand cxecu- tion of the altered program is guaranteed. Not only do binary compatible changes not require \nre-compilation of other classes, but such re-compilations *may not be possible: a binary compatible change \nto the source code for one class may cause the source code of other classes no longer to be type correct. \nYet the guar- antee of successful linking and execution still holds since only the binaries are consulted \nduring these steps. In particular, it is possible to link successfully and ex- ecute binaries corresponding \nto type-incorrect source code. Separate compilation is no longer equivalent to compilation of all units \ntogether. This is a deliberate feature and constitutes a crucial ingredient of the Java approach [ll]. \nIt allows the mod- ification (usually through extension) of libraries, with- out requiring re-compilation \nof software using these li- braries. Binary compatibility is a powerful but immature lan-guage feature; \nalthough supported in previous forms by some language implementations, Java is the first case we know \nof where it is explicitly described in the language definition. We feel that its exact meaning and proper- \nties are not fully understood. This is unfortunate, since [5, 41 demonstrate that loopholes in the definition \nand implementation of binary compatibility provide oppor-tunities to break Java security. The Java language \nspecification [lo] devotes a whole chapter to binary compatibility, giving examples, and pointing out \npossible interplay of features. However, it does not give an exact definition, and uses the term binary \ncompatibility in two senses. It lists the changes considered to be binary compatible, e.g. on p.237: \n...a list of some important binary compatible changes that ,Java supports: re-implementing existing methods, \n. . . . adding new fields to an existirrg class or interface, . . . . adding a class, >> and describes \nthe guarantee of such changes, p.240: A change to a type is binary compatible with pre-existing binaries \nif pre-existing bina- ries that previously linked without error will continue to link without error. \n So, from the Java description we have modifications guarantee list of binary no re-compilation, compatible \nchanges ==+ linking without errors, safe execution There is no appropriate precedent for a terminology \nin this area: Corresponding to the guarantee we define link compatible changes as source code modifications \nfor which all types (i.e. classes and interfaces) that success-fully linked with the original binaries \nwill also success- fully link with the binaries obtained after modification and re-compilation. Safe \nchanges are those changes that can be proven to preserve the guarantee; they include most changes listed \nin [lo] e.g. adding instance variables to classes, modifying method bodies. They do not in-clude the \naddition of methods to interfaces, because, as we shall see, this does not preserve the property of linking \nwithout errors: I I modifications auarantee list of binary no re-compilation, compatible changes ==+ \nlinking without errors, I I formalized as safe execution I formalized as I -1 -1 1 list of safe changes \n* link compatibility Based on the above formalization we were able to dis- tinguish nuances in the concept \nof binary compatibility, and to formulate and prove composability properties: l The definition of link \ncompatibility allows appli-cation of the term to binaries that are not stand-alone. This is a common \nsituation for libraries importing further libraries. l We argue that the exact definition of link com-patibility \nshould cater for the possibility of linking with further, yet unknown binaries, i.e. it should say: A \nchange is binary compatible with pre-existing binaries if any further pre-existing bina-ries that link \nwithout error with the former pre-existing binaries continue to do so after the change to the former \npre-existing binaries. l We show that applying a sequence of link compat-ible changes to a binary preserves \nall the linking capabilities of the original binary. l We show that link compatible changes applied to \ndifferent, but possibly mutually dependent bina-ries, preserve all the linking capabilities of the orig- \ninal program consisting of the original binaries. This caters for the case where programmers de-velop \ndifferent interdependent libraries, and says that binary compatible changes do not alter the linking \ncapabilities of the overall system. l We demonstrate that two consecutive link compat-ible changes usually \ncannot be folded into one; and that two different link compatible changes applied to the same binary \nusually cannot be reconciled. We build on some of our previous work formalizing the semantics of Java \n[6, 71, but we could have used any formalization that gives meaning to type checking and distinguishes \nsource code from compiled code, e.g. [17]. The remainder of this paper is organized as follows: In section \n2 we examine the motivation and some sub- tleties of binary compatibility, and demonstrate these in terms \nof examples. In section 3 we summarize the formalization from ]7] needed for the current discus- sion. \nIn sect,ion 4 we formalize compilation and link- ing of fragments. In sections 5-6 we define link com- \npatibility, prove its composition properties, define safe changes and prove that they are link compatible. \nIn appendix A we justify our approach and discuss alter- natives. Finally, in section 7 we draw conclusions \nand outline further work. 2 Binary compatibility in Java The motivation for the concept of binary compatibility \nin Java is the intention to support large scale re-use of software available on the Internet [ll]. In \nparticular, Java avoids the fragile baseclass prob- lem, found, in rnost C++ implementations, where an \ninstance variable (data member) access is compiled into an offset from the beginning of the object, fixed \nat compile-time. If new instance variables are added and the class is re-compiled, then offsets may change, \nand object code previously compiled using the original defl-nition of the class may not execute safely \ntogether with the object code of the modified class: Similar problems arise with virtual function calls. \nThe term fragile base class problem is also used in a wider sense, to describe the problems arising in \nseparately developed systems using inheritance for code reuse [13]. C++ development environments usually \nattempt to compensate by automatically re-compiling all files im- porting the modified class. Although \nJava develop-ment environments do the same, there are realistic cases where this strategy would be too \nrestrictive. For in-stance, if one developed a local program P, which im-ported a library Ll, the source \nfor L1 was not available, Ll imported library L2, and L2 was modified, then re-compilation of Li would \nnot be possible. Any further development of P would therefore be impossible. In comrast, Java prornises \nthat if the modification to L2 were binary compatible, then the binaries of the modified L2, the original \nLl and the current P can be linked without, error. This is possible, because Java binaries carry more \ntype information than object code usually does. Interestingly, it is possible to modify types in binary \nincompatible ways, and to still be able to link without errors with the binaries of some importing types. \nStill, other binaries will exist, which linked without errors 1st phase class Student { int grade; ) \nclass CStudent extends Student { } class Lab C CStudent guy; void f (>I guy.grade=lOO; ) 3 2nd phase \nclass CStudentextends Student { char grade ; 3 3rd phase class Marker ( CStudent guy; void g(>( guy.grade= \nA ; ) 3 Figure 1: Students and computing students -code with the type, but no longer link without errors \nwith the binary of the modified type. 2.1 An example The example from figure 1 demonstrates some of \nthe issues connected with binary compatibility. It consists of three phases. In the first phase we create \nthe classes Student, CStudent, and Lab. For simplicity we ignore the issue of access restrictions (e.g. \nprivate, public, import). The class CStudent inherits the instance variable grade of type int. In the \nclass Lab, the field guy, of class CStudent, is assigned the grade 1. This program is well- formed, and \ncan be compiled, producing three binary files Student. class, CStudent . class and Lab. class. In the \nsecond phase we add the field grade of type char to class CStudent, and re-compile CStudent, producing \nCStudent . class. In the third phase we define a new class, Marker. In the body of its method go, we \nas- sign the grade A to guy. The class Marker is type correct, and thus it can be compiled to produce \nthe file Marker. class. The two changes, i.e. the addition of field grade in class CStudent, and the \ncreation of class Marker, are binary compatible changes. So, the corresponding bina-ries, i.e. Student. \nclass, CStudent . class, Lab. class and Marker. class, can safely be linked together. The sources are \nnot type correct any more. An at-tempt to re-compile the class Lab would flag a type er-ror for the assignment \nguy. grade=lOO, since the expres- sion guy. grade now refers to the field in class CStudent which is \nof type char. Also, the compiled form of the expression guy .grade in the binary Lab. class refers to \nan integer, whereas the compiled form of the same 1st phase interface I ( void methl() ; 1 class C implements \nI ( void methi()C... ) ) class D ( void meth3() { I an1 = new CO; 1 It 2nd phase interface I { void \nmethl(> ; void meth2() ; 1 3rd phase class D { void meth3 (> { I an1 = new CO ; anI.meth20 ; ) ) Figure \n2: Adding a method to an interface expression in the binary Marker. class refers to a char- acter. The \ntwo compiled forms exist at the same time, and refer to different fields of a CStudent object. An implementation \nof Java has to reflect this in the code produced; in our formalization in section 3 we describe this \nin terms of different Java,, intermediate code. Sim- ilar situations can arise for method calls. 2.2 \nA problem with binary compatibility The example in figure 2 demonstrates that the list of binary compatible \nchanges given in [lo] is too permis-sive and so fails to fulfil the guarantee. In particular, it considers \nthe addition of methods to interfaces to be a binary compatible change, and as a result it does not prevent \nvalues of a particular interface type referring to objects of classes which do not fully implement that \ninterface. This problem is known to JavaSoft [16]. In the first phase consider compiling interface I, \nand classes C, D. Compilation will be successful. In the sec-ond phase method meth2() is added to interface \nI, and I is re-compiled. This is listed as a binary compat-ible change [lo]. In the third phase, code \ninvoking an1 .meth2 (> is added to the body of meth3 in class D and then D is re-compiled. Since the \nnew method body is type correct, this is a binary compatible change as well, [IO]. A, ccording to the \nguarantee of binary com-patibility, the binaries for I , C and D should link and run successfully. But \nthey cannot, as there is no imple- mentation of meth2(). Thus, although addition of methods to interfaces \nis listed as a binary compatible change in [lo], it does not uphold the promise of safe linking and execution. \n1st phase r St = Studentext Object { grade : int } r cs = CStudent ext Student { >  rlab = Lab ext \nObject { guy : CStudent, f :--+ void } 2nd phase r CS = Student ext Student { grade : char } 3rd phase \np = Marker ext Object { guy : CStudent, g :+ void } Figure 3: Environment for computing students 3 Formalization \nof the Java semantics This section summarizes material from [7] needed for the formalization of separate \ncompilation and binary compatibility. In [7] we describe the semantics of a sub- stantial subset of Java \nencompassing primitive types, classes, interfaces, inheritance, fields, methods, inter-faces, shadowing, \ndynamic method binding, the value null, arrays, exceptions and exception handling. We distinguish between \nthree languages: Java, is our subset of Java, Javase is an enriched version of Java, contain-ing compile-time \ninformation necessary for execution, Java, is an extension of Javase supporting run-time con-structs \nsuch as addresses. Java > Java, c Javase c Java, wP Java,. -1 4 -1 -1 Type = Type = Type Zwdn Type We \ngive type systems for Java,, Java,, and Java,. The two latter are slight modifications of the former. \nWe prove that a well-typed Java, term retains its type when transformed to the corresponding Java,, or \nJavar term. The operational semantics, --+r, describes the execu-tion of Java, terms for a particular \nJava,, program p. We prove a subject reduction theorem, stating that execution of Java, terms preserves \ntypes up to sub-classes/subinterfaces. In the remainder of this section we discuss these concepts in \nmore depth. A Java, program consists of an environment, usu-ally denoted by a I , and Java, body, usually \ndenoted by a p. The syntax of environments can be found in appendix B, that of Java, bodies can be found \nin ap- pendix C. The first phase of the computing students ex-ample corresponds to environment Pt l? \nI lab, as given in figure 3, and body pst p plab, as given in figure 4. The order of declarations and \ndefinitions is not sig-nificant, therefore l? !? = I I , and p p = p p. The sets cm cl(~), it, and Vr(I \n) contain the names of all classes, interfaces or variables declared in environ- 1st phase st ment, \nF or program p respectively. The set D(-) is the Pse = cgrst rcs rlab, pst] union of the previous sets. \nFor example, D(P Plab) = n(I Ilab) = {CStudent, Lab}. The assertion I f T swdn T indicates that in \nenvi- ronment l?, type T widens to type T , i.e. values of type T can be assigned to variables of type \nT without any run-time checks. 1st phase st = Student ext Object { } P cs = CStudent ext Student { } \n P Plab = Lab ext Object { f is{ guy.grade = 100; } } 2nd phase CSI = CStudent ext Student { } = p P \n3rd phase = Marker ext Object P { g is{ guy.grade = A ; } } Figure 4: Java, class bodies for computing \nstudents We indicate by I? t 0 that the declarations in en-vironment lY are well-formed, e.g. that every \nidentifier has a unique declaration, that fields are unique in a class, etc. Provided that, I? t 0, Java, \nterms can be type checked in terms of a type inference system, part of which appears in appendix D. The \nassertion I? t t : T signifies that term t has type T for environment I?; the assertion I? t- p 0 signifies \nthat program body p is well- typed in environment F, i.e. the class bodies contain type correct function \nbodies which return values of the expected types. The assertion I? t- p @ signifies that p is complete, \ni.e. that it is well-typed and contains a class body for each class in I . To support execution of method \ncalls and field ac-cess, Java, is enriched with type information. The en-riched language is called Java,,; \nenriching is performed by the mapping C, which can be understood as an ab- straction of compilation from \nJava source code to binary code. Only type correct terms are mapped, i.e. C{I?, t) is defined only iff \nthere exists a type T with I t t : T. Furthermore, if F t t : T, and I? I l- 0 (i.e. I does not affect \nI), then II t- t : T and C{l?, tl=C(FI , tj. The syntax of Java,, is an extension of the Java, syntax \nand is given in appendix E. The Java,, version of the students class bodies is given in figure 5. In \npse lab the field access guy. grade has been enriched by the class from which grade is inher- ited, and \nis compiled to guy [Student] . grade, whereas in P?, it is compiled to guy[CStudent] .grade. <Java,,, \nterms also have types, indicated by assertions F kse t : T. For a Java,, program body p, I? t-,, p 0 \nmeans that p is well-typed, whereas I b,p GV signifies = Student ext Object { } Pcs = c(rst r-rlab, pcs] \n se = CStudent ext Student { } lab = c(pt pa Flab, plab] Pse = Lab ext Object { f is{ guy[Student].grade \n= 100 } } 2nd phase cd _ qpt rcs Flab, pcs ] Pse - = CStudent ext Student { } = pzz 3rd phase = cgrst \nrcs rlab rm, pq P% = Marker ext Object { g is{ guy[CStudent].grade = A } } Figure 5: Java,, class bodies \nfor computing students that p is well-typed and complete. The type system for Java,, is identical to \nthat of Java, except for the two cases where the Java,, syntax differs from that of Java,; these appear \nin appendix F. When type checking Java,, field access expressions, the parent class contain- ing the \nfield declaration is taken into account. Similarly, the statically determined argument types are taken \ninto account when type checking Java,, method calls. These properties of the Java,, types reflect, at \na higher level, checks performed by the byte-code verifier [15, 121, and are crucial for proving the \nlemmas in section 5. The following lemma says that C preserves types: Lemma 1 For types T, T Java, term \nt: r!-t:T ----r rb, c&#38;t] : T Java, is an extension of Javase describing run-time terms, such as addresses, \nor null-values in field access or method calls. For Java,, program body p, Java, terms are executed according \nto rewrite system tip. The subject reduction theorem proven in [7] (and similarly in [17, 141) states \nthat for any well-typed, non-ground JavaT term and any Java,, body p with b,p @, there exists a rewrite \nstep which either terminates, or produces a new, well-typed Java, term, or contains an exception. The \nexception may be a language defined ex-ception, such as divide-by-zero, null-pointer-access etc, or any \nof the user-defined exceptions, but not one of the linker exceptions. In particular, because the sub-ject \nreduction theorem ensures the existence of a rewrite step, it also guarantees that all required method \nbodies and fields will be present. Absence of fields or method bodies is the kind of thing that would \nthrow a linker exception [12]. The subject reduction theorem thus suggests that the assertion F b,p @ \nmeans that p is a complete suc-cessfully linked Javase program body. The assertion I? t;,,p @ can be \nestablished by proving that r 6, p 0 and that Cl(p) = Cl(r). The latter requirement is usu- ally a last \nstep and is straightforward to establish. How-ever, the requirement r t-,, p 0 is not that easy; in gen- \neral it requires full type checking. Therefore, we consider the preservation of the prop- erty I? t,, \np 0 to be an appropriate approximation of the guarantee of binary compatibility. For notational convenience, \nwe use the notation b,(I , p) 0 as a syn- onym for l? b, p 0. 4 Concatenating and compiling fragments \nWe shall call a pair F = (I , p), a fragment, where r is an environment and p is one or more class bodies. \nIf p is a Java, body then F will be a Java, fragment, other-wise it will be a Java,, fragment. Fragments \nconsist of the declaration and body of one or more classes; they represent parts of programs, or libraries, \nand they need not be self-contained. In this section we introduce operators to describe concatenation \nand compilation of fragments. In some cases we expect the constituent environments and bod- ies to be \ndisjoint, as defined in: Definition 1 For environments I?, I? and bodies p, p : l r, I ure disjoint \n#D(r) n D(P) = 0. l p, p nre disjoint iff D(p) n D(p ) = 0. l (r,p) and (I?,p ) are disjoint, Zfl r, \n!? and p, p are disjoint. For example, I? and I? are disjoint, whereas Yes and r PCs are not. The parts \nof well formed environments or programs are disjoint, e.g. I I t 0 implies that r, I are disjoint. The \noperator - o - represents concatenation of frag- ments through juxtaposition, without performing any \nchecks. Definition 2 For fragments F = (I ,p), F' = (I ,p ): 0 FoF'= (rrf,pp') Concatenation is associative \nand commutative. If F and F are disjoint, then t F 0 and I- F' 0 implies l-FoF' 0. Also, t-FoF' 0 implies \nthat F and F' are disjoint. The operator -a -describes updating the first ar-gument by the declarations/bodies \nfrom the second, whereby any class or interface in both will be taken from the second: Definition 3 For \nenvironments I , I and bodies p, p frugments F = (I ,p), F' = (l?,p ): r. rl uml ,Papl @C(r',P') I \n r. r' Figure 6: (r. I , , p. pl) @&#38; (r , p ) r63 rf = rorf, where r. such that r = r. rl, D(rl) \nc D(l?), and ITo, r disjoint. P @ P' = POP', where po such that p=popl, D(pl) G D(p ), and PO, p disjoint. \n F CB F = (r @ r , p (33 p ) Updating is associative but not commutative. For dis- joint fragments F, \nF updating is equivalent to concate- nation, and also Fo(F $ F ) = (FoF ) $ F. The operation c{F, F ] \ndescribes the compilation of a fragment F in the context of F, i.e. compilation using the environment \nprovided by both F and F'. Definition 4 For fragment F = (lY,p), und Java, frag- ment F' = (r ,p ) : \nl C(F,F ] = (r ,C(r @ r ,p ]) Thus, c((rst rc=,pstp=S),(rcS',pcs')~ l (rcs',p;;') = cg(rstrcs,P~~P~~),(rcs',pc~')~. \nThe operation F@,F' describes the efSect of the com-pilation of a Java8 fragment F on an existing Java,, \nfrag-ment F. The original Java,, fragment F is updated by the compilation of F' in the context of F. \nDefinition 5 For Java,, fragment F, and JUVJU, frag- ment F': . F $,F' = F @C(F,F'] SO,(rvyp;\",p;;) \nG~,(I-',~cs') = (rvcs',p;;p;s,'). Figure 6 describes the compilation of the Java, frag-ment (I?, p ) \ninto existing Java,, fragment (rO rl, p. pi). The ensuing environment, I? @ r , consists of l? and ro, \nthe part, of r which is not superseded by I?. The new program body, p @ C(JY @ I?, p ], consists of the \ncompi- lation of p in the new environment and po, the part of p which is not superseded by p . In general, \nC(F, F]@,F # C(F @ F , F @ F ]. The left hand side represents separate compilation of fragments whereas \nthe right hand side represents compilation of all fragments together. As we mentioned earlier, in Java \nthese are different, and it, is possible for the first to be defined, and the latter to be undefined. \nBecause the arguments of _ ~3~ - come from differ-ent, domains, the concepts of commutativity and asso-ciativity \ndo not apply. We shall use ac implicitly in a left-associative manner. For fragments Fo, F=(I ,p), F \n=(r ,p ), such that 22(r) = Z?(I ) and p = p , the equality (Fo @F ) Bi,(r , E) = (Fo &#38;i F )@,(r \n, p ) holds, where E describes the empty environrnent or program body. The second phase of the students \nexample compiles (r- , PCS) into (rst r= rl=b, pi , p; , pt; ), giving: (rst rcs rlab, p:; p;: pfb) ec \n(rcs , pcs) =- (rst r-P, p;; p;; p;;b) $c (r- , E) = (rst rcs rlab, p; , p;; p;;b) In the third phase \nwe compile the new fragment (I? , pm) int,o the result of the previous change, giving: (rat r- Pb, p; \n, p;; p;;b) f3c (ry pm) = (rst r- rlab rm, p;; p;; p;;b cgrst r-rlab r-m, pm]) = (r-t r- rlab rm, p;; \np;; P;;~P;,) The following lemma, used to prove lemma 5, de- scribes the result of compiling fragment \nF into FoF . If C{F , F ] is defined, i e compilation of F does not need information frorn F, then F \nremains unaffected, and is not taken into account for compilation of F . If F and F are disjoint, then \nF remains unaffected but may be taken into account for compilation of F . Lemma 2 For fragmen,ts F, F \n, F , with F and F disjoint: l C{F , F ] defined --r (FoF ) CEI~F = Fo(F BC F ) l F and F disjoint ==+ \n(FoF ) @, F = Fo(F @ C{FoF , F ]) 5 Link compatibility The tcrrn link compatibility aims to capture \nthe guar- antee given by binary compatibility. It restricts source code modifications in terms of the \nproperties of the re-sulting compilation. As we argued in section 3, well- formedness, expressed by the \nassertion kS-,,F0, should be preserved throughout binary compatible changes. We consider F a link compatible \nchange of a fragment F, if all fragments Fo that successfully linked with F continue to do so after compilation \nof F into F. Definition 6 A Java, fragment F , is a link compatible change of a ,Javu,, fragment F, iff \nFor a11 Fo disjotint with F : heFoOF 0 -----r. b,(FooF) @,F 0 For example, (I? , pc ) is a link compatible \nchange of (rst rcs rlab, p , , p ,: P:;~), and (I? , E) is a link com-patible change of (l? I Flab, \npi , p; , ptp). In section 6 we discuss how to prove such statements. Originally we had defined as link \ncompatible changes F those guaranteeing that b,,F 0 ==+ ks-,,F $,F 0, but this definition turned out \nto be too weak, c.f. ap-pendix A where we discuss alternatives. The require-ment 6, (Fo OF) 83, F 0 ensures \nsuccessful compilation of F in the context of both Fo and F. It is weaker than asking beFoo (F ac F ) \n0, because it, is possible for (FooF) eB, F to be defined and for F CB, F not to be. This subtlety is \ndeliberate. It allows F to be consid- ered a link compatible change for a library F, which imports other \nlibraries, and which cannot be compiled in isolation, i.e. for which beF 0 does not hold. Such a library \ncan only be compiled in the presence of one or more further libraries, represented by the fragment Fo, \nwith which t,,FooF 0 holds. Therefore, the fragment F does not need to contain all the type information \nnecessary to type check F ; it only needs to contain enough inforrnation to ensure type correct compilation \nof F in the context of all appropri- ate fragments Fo. Thus, F acts as a kind of filter for Fo, by requiring \nthat heFo OF 0. Consider, for example: rc = class C ext Object {f :-+ int}, rD = class D ext C {f :-+ \nint}, r D = class D ext C {f :-+ int,x : char}, The fragment (rD , 6) is a link compatible change of \n(rC rD,e), of (l?,e), and of (rD,E). The latter holds, because any I 0 with PO rD t- 0 also satisfies \nlYo rD t- 0. Our original intuition was, for F a link compatible change of F, that F need only contain \nthe definitions or declarations modified by F . This was incorrect, because in general these do not hold \nsufficient information to en- sure type correctness in the context of all appropriate fragments Fo. For \nexample, consider the environments: r* = class A ext Object {f :-+ int}, r* = class A ext Object {f :+ \nchar}, rB = class B ext A { }, rB = class B ext A {f :-+ int} The fragment (rB , E) is a link compatible \nchange of (I?* I , c), and of (I *, E), but it is not a link compatible change of (rB, E) Namely, t-s-,,(I \n* , E) o ( IYB, E) 0 holds, but r* rB t- 0 does not! And so, it is not the case that be ((r* ,4 0 (rB, \n4) ec (rB ,4 0. 5.1 Properties of link compatible changes We now discuss and prove the following five \nproperties of link compatible changes: Preservation over larger fragments: link com-patibilit,y is preserved \nby larger fragments. Preservation over sequences: a sequence of link compatible changes preserves well-formedness \nas shown in figure 7. Preservation over libraries: several link corn-patible chmges when applied to different \nfragments preserve well formedncss as shown in figures 8, 9. Lack of diamond property: for two different \nlink compatible changes applied to the same frag- ment, there does not necessarily exist a further link \ncompatibk change reconciling the two -as shown in figure 11. Lack of folding property: in general, two \nlink compatible changes cannot, be folded into one link compatible change-- as shown in figure 10. These \nproperties are crucial in delineating the exact na-ture of binary compatibility. In fact, we have been \ndis- cussing with thr Java language developers whether a di- amond property and the preservation over \nlibraries are satisfied by binary compatibility, and to what extent these properties should be satisfied \n[16]. Thus, a major cont,ribution of this paper lies, we believe, in formulat- ing and distinguishing \nthese properties. The preservation over larger fragments automatically establishes link compatibility \nfor all fragments that con-tain a smaller fragment for which this property has already been established. \nThe preservation over se-quences guarantees t,hat link compatible steps may be combined, and preserve \nt,he linking capabilities ~ pro-vided that each step is a link compatible change of the result of the \napplication of all previous modifications. The preservation over sequences is not surprising, but the \nfact that it is satisfied demonstrates that the defi- nition is appropriate. The lack of folding and \ndiamond properties restrict the ways in which link compatible changes may be com- bined. The lack of \ndiamond property means that pro-grammers may not apply independent link compatible changes to the sume \nfragment and expect the linking capabilities to be preserved. However, the preservation over libraries \nallows programmers to apply independent link compatible changes and expect the linking capabil-ities \nto be preserved, as long as they were working on dijyercnt fragments. In particular, it mrans t,hat vari- \n011s libraries may be modified separately, each in link compatibile ways, and still preserve their linking \ncapa-bilities. This holds, even if these libraries should import r~a.c:hot,her. Next, we formulate a,nd \nprove these properties. Preservation over larger fragments A link compat-ible change of a given fragment \nis also a link compatible change of any larger fragment: Lemma 3 For fragments F, F , F , where F and \nF are disjoint: F is a link cofmpatible change of F ----I. F is a link compatible change of F oF  Preservation \nover sequences As outlined in figure 7, a sequence of link compatible steps, Fi , Fi,, applied to fragment \nF preserves the linking capabilities of F. In order to establish that a step is link compatible, we need \nto know the effect of all prior st,eps, thus we require that Fi+, is link compatible for FooF @, Fi... \n@, F:. Fo F F = FooF CD, F , I Fl Figure 7: Preservation over sequences Lemma 4 For Java,, fragments \nF, Fo, a sequence of Java, fragments Fi, FL, Fo disjoint Fi, if l for all i, 1 5 i 5 n: Fi defined ===+ \nF{+l link compatible chnge of Fi where Fi = F()oF@,F ,... BB,Fi then l t,,Foo~ 0 ==+ t,,(FooF) CEI,Fi... \nCH,F:, 0 Proof by induction on k; using that F =Fo o F and F +l=F mn,Fg, prove that b,F 0 for all k. \nAlso, F = (FOoF) @,F\\... BCF ,. 0 Preservation over libraries Link compatible modifi-cations Fi applied \nto fragments Fi which are parts of a program F o F1 o . . . o F,,, preserve the linking ca.pabil-ities \nof that program, provided that, t,he modifications are link compatible for the particular fragments only \n- i.r. require Fi is a link compatible change of Fi, which is stronger than requiring F: to be a link \ncompatible thnge of Fi . ..F.,. F 0 FL o Fz! . . . 0 Fn . . F o F: o F; . . . 0 F; Figure 8: Preservation \nover libraries where FL = FI, @ C{FOF~O...F~-,OF~...OF~,F&#38;] In contrast to preservation over sequences, \nwe do not need to know the effect of another modification in or-der to establish that F: is a link compatible \nchange of F,. However, we may take another modification into account when applying a modification. We \ndistinguish the following two cases: 1) The application of a mod- ifica.tion takes into account the effect \nof t,he previous modifications, thus FI, is transformed to FL, where Fi = FI, 83 C{FOF~O...F , -,oF~...oF,,F~]; \nas described in figure 8. 2) The application of a modification does not take into account the effect \nof any other modifications and compiles in t,he original context,, i.e. FI, is trans- formed to Fi, where \nFz = FI, @ C{ Fo Fl . . . o FnrFk.; as described in figure 9. F 0 FL o Fa 0 Fn F o F: o F; . . o F; \nFigure 9: Preservation over libraries where Fi = FI, 83 C{FOF~...OF,,F~~] The first case represents the \nsituation where pro-grammers make changes to the particular fragments that belong to them, but, are aware \nof each other s ac-tions. The second case corresponds to the sit,uation where programmers take a snapshot \nof each other s work, and then go on to work on their own fragments unaware of each other s activity. \nIn both cases, when all modi- fied fragments are put together, the resulting program F o Fy . ..o Fz \npreserves the linking capabilities of the original program. The order of the fragments is imrna- terial \nfor the current lernma. Lemma 5 For Java,, fragments F, Fi, F,,, <Java, fragments F ,, . . . FL, where \nF: disjoindfrorn Fk, from FL and from F for all i # k, i, kc {l...r~}, if l Fi is a link compatible change \nof Fi for 1 5 i 5 n l ~,FoFro...oF, 0 then l t-,, F o F: . ..o F; 0 where Fi = F~ 69 C{FOF~O...F~-~OF~...OF,,F~] \n l 6, F o F , . ..o F; 0 where Fi = FI, $ c{ Fo Fr . . . 0 F,, FL]  Proof Because be F o Fio . o F, \n0, we know that Fi are disjoint from FI, and from F, for i # k. 1st Part Define F = F OF: o . ..F . oFk+l... \noFTL, where FL = Fk CBC~FOF: O...F~_~OF~...OF,,F;~. To show that h,F 0. For all k # j, if F , and Fy \nare defined, then FL is disjoint from Fy , from F>, from Fj and from F. Show by induction on k that Fi \nand Fk are defined, and that b,F 0. The case where k = 0 follows from the assumptions of the lemma. For \nthe induction step (k+l+k++): by induction hypothesis beFk+ 0 by definition of F +l b,FoFy~...Fi~Fk+l...oF, \n0 0 commutative ~-,,(FoF~o...FLoF~+~...oF~)oF~+I 0 link compatible change of Fk+l %+1 ~e((F~F~~...F;~Fk+2...~Fn)~Fk+l) \n@cF;,.l 0 lemma 2 Fy disj. from Fi , Fl for 1 5 i # 1 5 k Fldisj.fromFjforl<l#j<n ~,(FoF~o...F~oF~+~...oF,)oF,++I \nCR C{FOF~O...F~OF~+~...OF,OF~+,,F~+~] 0 definition of Fi+, I-&#38;FoF~o...F~oF~+~...oF~)oF~+~ definition \nof Fk+ &#38;eFk+2 0. Therefore, Fa+, is defined and keFktl 0 holds. 2nd Part similar to and easier than \n1st part,. q Lack of folding property The concepts of transitivity and reflexivity are not applicable \nto the link compati-bility relationship, because its domain and range do not match. Instead, one might \nconsider the following fold-ing property , outlined in figure 10: For disjoint, F , , Fk, if Fi is a \nlink compatible change of F, and Fb is a link compatible change of (FeoF) ecFi, then F , 1~ Fb is a link \ncompatible change of Fs OF, and (FooF) @,F: Bi3,F;. = (FooF) Bc (F , @F;) FooFFooF Figure 10: Lack of \nfolding property Such a property does not hold. As a counter-example, consider Java,, fragment corresponding \nto Student and CStudent, i.e. F = (Pt P, pSt p ). First, the class Lab is compiled, i.e. F , = (l?rab, \nprab). Then, the modified cla.ss CStudent is cornpiled, i.e. Fh = (P , p ). Both changes are link compatible \nchanges, yet the change formed by nai vely composing the two steps, i.e. com-piling Lab a&#38; CStudent \ninto the original program, is not a link compatible change, since the Java, class body of Lab is not, \nwell-t,yped in an environment featuring the class declaration from CStudent . Lack of diamond property \nFor certain F , and FL, link compatible changes of F, there do not exist frag-ments Fi and F(, , such \nthat Fi, Fk disjoint with F , , Fk, and Fi is a link compatible change of F CH,F{, and F&#38; is a link \ncompatible change of F CH, Fk, and F acFi 63, Fi= F cB, F; (13, F; For example, Fi might be introducing \na method f wit,11 signature int -+ int into a class C, and Fb intro- ducing another method f wit,h signature \nint + char into the same class C. The lack of diamond property does not contradict the preservation over \nlibraries, be-cause there we required the modifications to be applied to disjoint fragments. 5.2 Type \npreserving changes In the previous section we established the power of link compatibility, and argued \nthat it models the guaran-tee by binary compatibility. However, we have not dis-cussed yet how to prove \nthat, a particular modification is link compatible. FooF  J\\ (FooF) @c F , (F. OF) 8, F; FooF J\\ (FooF)@cF: \n(FooF) Bc Fk \\ / (FooF) ec Fi ec Fk = (FooF) sic Fk tf3, Fk Figure 11: Lack of diamond property In this \nsection we introduce type preserving changes, and prove that type preserving changes are link com-patible. \nIn section 6 we shall introduce safe changes, which correspond to those changes suggested in the Java \nspecification, which apply to Java,, and can be demon- strated to ensure link compatibility, and we shall \nprove that safe changes are type preserving. Thus, we have: modifications guarantee list of type link \nsafe ==+ preserving ==+ compatible changes changes changes A type preserving change of an environment \nl? pre- serves the types of all Java,, expressions e given by l? and context environments l?s. Definition \n7 An environment r is a type preserving change of environment r iff for all r. disjoint with I , for \nall Java,, expressions e, types T: r. r t-,, e : T =+ r. r e rf be e : T For example, consider r*, \nI?* 7rB 7rB as introduced in the beginning of section 5. Then the environment rB is a type preserving \nchange of r* rB, and of l?*, but it is not a type preserving change of rB. It holds that l?* r*, x : \nrB t- x[].f () : char, but it does not hold that r* r* B rB , x : rB E x[].f () : char. In fact, it does \nnot even hold that I?* rB @ rB t- 0. Notice, that I? might be incomplete in t,he above def- inition , \ni.e. it might not satisfy r t 0, and it might not have a type for the expression e. The requirement that \nr. !2 k,-,, e : T ==$ r. l? $ I? t,, e : T is strictly stronger than lY t,, e : T ----r I? @ I l-se e \n: T. For example, lYB vacuously satisfies the rcquirernent I * Fzz-,,e : T ===+ r* $ rB tse e : T, since \nno expres- sion satisfies I * h, e : T. We expect for r with I t- 0, the requirement I? t,, e : T ----r. \nI $ I b, e : T to be equivalent with To I? 6, e : T ==+ r. r @ I h,, e : T. Notice also, that, a type \npreserving change of of an environment does not preserve the types of Java, terms. So, I? I? , guy : \nCStudent l- gyy.grade : int, whereas (Pt I?, guy : CStudent) @ 1 t- guy.grade : char. As with link compatibility, \nin general, if I? is a type preserving change of a smaller environment r, then it is also a type preserving \nchange of the larger environment  r r/f. The following lemma describes how type preserv-ing changes \nof environments combined with type cor-rect compilations of class bodies produce link compati-ble modifications. \nThe second requirement,, asking that r. r t 0 ==+ r0 r CE r t p 0, allows US to consider modifications \nwhich need a context, ro for their com-pilation. Thus we can have libraries which are not st,and alone. \nThat requirement could be replaced by the stronger requirement that, r @ I t- p 0. The third requirement \nensures that a new class body will be pro- vided for any class in I , i.e. whose declaration is mod- \nified. Lemma 6 For environments r, I , Java,, program body p, ,Jaua, program hody p , 2f 0 r is tigx \npreserain,g change of r 0 vrO dkj. kthr : row0 ==3 rOrf3r kp 0 therl (I?, p ) is a linlc compatible \nchange of (r , p) Proof through careful application of the definitions and type checking rules. Let US \ncall F = (r,p), F = (I , p ). Take any Java,, fragment Fo = (roe, POO), such that Fo disjoint from F \n, and b,FooF 0. To show that b-,,(FooF) acF 0. Because l-se~o OF 0, it also holds that roe and IY are \ndisjoint, and, because of the requirements of the lernma, P I- p 0, where I = roe r a-, r . Therefore, \nP b 0. It remains to prove that I? h, p 0, where p/f = cgrypoop 6f3 pq. Take any Java,, class body cBody \nfrom p . Let C be the name of the class to which cBody belongs. 1st Case: C E Cl(p ). Then there exists \na Java, class body cBody , such that p = cBody p:, and that c p , cBody 1 -cBody. Because r E p 0, we \nalso have that I? t- cBody 0, and with lemma 1, we also get that I he cBody 0. 2nd Case: C $! Cl(p ), \ntherefore cBody stems from poo or p. Because roe r &#38; poop 0, it also holds that lYoo I h, cBody 0. \nBecause Cl(P) &#38; Cl($), we also have that C $ Cl@ ). Therefore, C has the same def- inition in I 00 \nIY and in roe I? 63 I? . Take any method body mBody from cBody; because cBody is type correct, through \napplication of the type rule for class bodies, we obtain: roe I , this : C b$-,, mBody : T1 x . ..T. \n+ T, where T1 x . ..T. + T is a signature of m in class C in the environment roe I?, and where mBody \nhas the form mBody = m is XXI : Tl...Xx, : T,.{stmts}. Applying the type rules for method bodies, we \nobtain: I 00 I?, this : C, zI : T1, . ..zn : T, be stmts[zl/xl, . . . . z,/x,] : T, where Zl, . . . z, \nare fresh identifiers in stmts and in J?oo I . From definition 7, it follows that roe (I? @ I?), this \n: C,wl : T1, . ..w. : T, t,, stmts[wl/xl, . ..w.,/x,] : T, where we renamed ~1, . . . z, to ~1, w, in \norder to avoid any name clashes. Therefore, applying the Java,, type rule for method bodies, we obtain \nthat, roe r CH I?, this : C k se mBody : T1 x . ..T. + T, and because the definition of C in roe r is \nidentical to that, in roe r tf) I , we have that all method bodies in cBody satisfy their signature in \nroe r $ I?. SO, it holds that roe r $ I b, cBody 0. Therefore, roe I? $ I be cBody 0 for any cBody in \np . This, finally, gives that he(J? ,p ) 0. 0 From lemma 6 we see that link compatibility requires the \nenvironment modification to be a type preserving change of the original environment, and the Javas pro- \ngram body modification to be type correct in the new environment. The latter requirement is very easy \nto establish, and corresponds to a successful local compi-lation step. This confirms that reimplementing \nmethod bodies is a binay compatible change , [lo]. However, the first requirement from lemma 6, namely \ntype preservation, is not obviously straightforward to establish, since it requires that for all possible \nenGron-ments I oo, the two environments should give the same types to all Java,, expressions. In the \nnext section we consider restricted modifica-tions to the environment which imply type preservation. \n6 Safe changes Safe changes are those of the changes described in [lo], which apply to the language Java,, \nand can be demon- strated to preserve the guarantees of binary compatibil-ity. In particular, they do \nnot include the addition of instance methods to interfaces, which was demonstrated to be problematic \nin section 2. The safe changes are: l no change at all l adding a new class C or interface I t,o a program, \nas long as the name of the new type is not the same as that of any existing type; changing the direct \nsuper-class of a class C, as long as all direct or indirect, super-classes continue to be direct or indirect \nsuper-classes; changing the direct, super-interfaces of an interface I, as long as all direct or indirect \nsuper-interfaces continue to be direct or indirect super-interfaces; adding a field to a class C; adding \na method to a class C; and are formalized in definition 8. R.emember that cha,nging method bodies, or \nthe names (but not the types) of the formal parameters of a method, are already considered link compatible \nchanges because of lemma 3; t,herefore these changes do not need to be defined as safe changes. Definition \n8 An environment I is a a safe change of another environment I?, ifs: l for all I70 disjoint with I?: \n  r. r t 0 --r ror CD r t 0 and one of the following holds: 0 r =E l l? = C ext C' imp1 I1,...I, { \nfDcls, mDcls} and c g cqr) 0 r = I ext I I,...&#38;, { mDcls } and I $Zt(I') 0 l? = C ext C imp1 I 1, \n. ..I., { fDcls, mDcls } l? = C ext C imp1 Ii, . ..I., { fDcls, mDcls }, rr and r t- c Lo&#38; c l I \n= C ext C imp1 Ii,...Ik { fDcls, mDcls } l? = C ext C imp1 I1,...I, { fDcls, mDcls }, l?i ViE{i...n}3j \nE{l...k} : I l- 1: &#38;,dn Ii 0 r = C ext C imp1 I1,...I, {VI : T1, . ..v. : T,,, v,+l : Tn+l, mDcls} \nI = C ext C imp1 II,...&#38; {vl : Tr, . ..v. : T,, mDcls}, rr 0 r = C ext C imp1 I1,...I, {fDcls, \nml : MT1, . . . m, : MTn,mn+l : MT,+i} r = C ext C imp1 IX, . ..I. {fDcls, ml : MT1, m, : MT,}, I r \nR.emember that the order of declarations is not signifi-cant, t,herefore I? = rr , C ext C ..., only \nmeans that IY contains such a declaration of class C. The requirement r. r t 0 ==$ r&#38; ~1 f k 0, which \nensures preserva-tion of well formedness of the environment in all appro- priate contexts ro, could be \nreplaced by the stronger requirernent lY l t- 0, which corresponds to requiring succesful compilation \nin the context of l?. The original requirement, r. r k 0 ==+ ror $ r t- 0, is trivially satisfied by \nthe first five cases of definition 8. In the sixth case, which describes the addition a new field, v,+l, \nto a class, this field must have a different name than any of the other fields in the class, i.e. v,,+~ \n# vi for 1 5 i < n. The seventh case describes the addi-tion of an instance method m,+l to a class. The \nnew method, m,+r , may not override any of the methods al-ready in C; if mn+r overrides any method inherited \nby C from any of its superclasses, then it must have the same result type as the overriden method. This \nmeans, that either one of the superclasses of C must contain a method with identifier m,+r and signature \nMT,+1 , or all of the superclasses of C must be present in l?. The following lemma says that safe changes \nare type preserving. Lemma 7 Given environments I , I , if I? is a safe change of I , then r is a type \npreserving change of I . Proof Take any r , safe change of I?. To show that I? is type preserving change \nof of r. For any environment Fe disjoint from I , any Java,, ex-pression eo, and type To, r. l? b-,, \neo : To implies that r. J? t- 0, which implies that r0 and r are disjoint. Take any environment l?e disjoint \nfrom I . Show for any T, T that PO r t T iwdn T implies that  r. r a rf t- T lwdn T , using structural \ninduction on the proof of r. r I- T iwdn T . Show for any class C, that if C has in environment l?e l? \na declaration of a field v with type T, then class C also has in environment r0 !Z @ I a declaration \nof field v with type T. Similarly, if class C inherits from another class C in environment rc l? a declaration \nof a field v with type T, then class C also inherits from the class C in environment r. r @ I a declaration \nof field v with type T. These field declarations must be unique. Any methods declared or inherited by \ninterface I in environ- ment I?0 I , are also declared or inherited by interface I in environment I?0 \nl? @ l?. Finally, for any method with identifier m with argument type AT and result type T declared or \ninherited by class C in environment I 0 I , there exists a method with identifier m with argument type \nAT and result type T declared or inherited by class C in environment r. r @ r . Then show, by structural \ninduction on the proof, that l a lY t,, e : T implies r0 r @ I b, e : T. For the cases where e is a variable, \nan instance method call, or an instance variable access one has to apply case analysis on the contents \nof I?, according to definition 8. 0  In the computing students example Yes adds an in- stance variable \nto a class, therefore it is a safe change of I , and so with lemma 7, I is a type preserving change \nof P. Because type preservation automatically applies to larger environments, I? is a type preserv-ing \nchange of l? l?. With lemma 6, (I ,p ,z) is a link compatible change of (I? F , pS,i p ,:). Similarly, \nI adds a class to environment l? I? I lab, therefore it, is a safe change; and so, the pair (Im,pm) \nis a link compatible change of (FSt Its Flab, p; , pi; ptEb). 7 Conclusions and further work The contributions \nof this pa.per are: l We suggest a terminology and formal framework with which to describe the effects \nand properties of binary compatibility. l We define safe changes, a subset of the binary com-patible \nchanges listed in the language specification, and prove for a substantial subset of Java, that safe changes \nguarantee successful linking without re-compilation. l We identify as the characteristic property of \nsafe changes that, they preserve the types of the en-riched Java se expressions. l We have investigated \nthe properties of combina- tions of binary compatible modifications. We expect that better formalizations \nwill be found; in-deed the formulation suggested in this paper is the re-sult, of many discussions and \niterations over previous approaches (201, and we continue work in this direc-tion. Some of the outstanding \nquestions are described in chapter A. Concepts for binary compatibility as proposed in [8] influenced \nthe Java language design. Ours is the only formalization for a concrete language and proof of cor- rectness \nwe know of. In [2] fragments consisting of a sig- nature and a body are used to describe linkable units, \nand linking consists of a type checking and a substitu- tion phase. Our formalism distinguishes between \nsource code and compiled code, mainly because in Java sepa- rat,e compilation is not equivalent to compilation \nof all parts together, a fact already pointed out but not pur-sued in [2]. We shall extend Java, to encompass \na larger sub-set of *Java, and extend safe binary compatibility to in- clude access restrictions, static \nvariables and methods, etc. Further work includes refining the description of separate compilation to \nconsider compilation in partial environments, rather than in the environment for the whole program. For \nthe computing students, e.g, , some classes do not, need to be compiled in the complete en-vironment, \nbecause C (l? Fcs Ilab, pst 1 = C{l?, ~ 1. It would be interesting to recast some of this work in terms \nof a formal description of the Java byte-code and byte-code verifier (such as [15, 91). The fact, that \nsepa-rate compilation of the types is not equivalent to compi- lation of all types together can be seen \nas another case of lack of full abstraction property in language translation, which, as shown in [I] \nmay lead to loss of protection. It remains to investigate how far problems with binary compatibility \ncan be understood in these terms. Finally, a more dista,nt and ambitious task remains the formalization \nof the dynamic linker/loader, and an approach to the associated security issues. Acknowledgements We \nacknowledge the financial support, from the EP-SRC (Grant Refs: GR/L 76709 and GR./K 73282). We are grateful \nto Guy Steele for valuable feedback, to Gabrielle Sinnadurai, David von Oheimb and to the anonymous ECOOP \nand OOPSLA referees, and most, par- ticularly to one of them, for useful and detailed sugges-tions on \nthe presentation. References Martin Abadi. Protection in Programming Lan-guage Translations. In ICALP \n98 Proceedings. Springer Verlag, 1998. to appear, also available at: http://gatekeeper.dec.com/pub/DEC/SRC \n/research-resports/abstracts/src-rr-154.html. L. Cardelli. Program Fragments, Linking, and Modularization. \nIn POPL 97 Proceedings, January 1997. M. Dausmann, S. Drossopoulou, G. Persch, and G. Winterstein. A \nSeparate Compilation System for Ada. In Proc. GI Tagung: Werkzeuge der Pro-grammiertechnik. Springer \nVerlag Lecture Notes in Computer Science, 1981. Drew Dean. The Security of Static Typing with Dynamic \nLinking. In Fourth ACM Conference on Computer and Communication Security, 1997. R.e- vised version Tech \nReport number SRI CSL 9704. Drew Dean, Edwa.rd W. Felten, and Dan S. Wal- lath. Java Security: From HotJava \nto Netscape and Beyond. In Proceedings of the i996 IEEE Sympo-sium on Security and Privecy, pages 190-200, \nMay 1996. Sophia Drossopoulou and Susan Eisenbach. Java is type safe -probably. In Proceedings of the \nEuro-pean Corbference on Object-Orie~nted Programming, June 1997. 171 Sophia Drossopoulou and Susan Eisenbach. \nTo-wards an Operational Semantics and a Proof of Type Soundness for Java. In Jim Alvez Foss, editor, \nFormal Syntax and Semantics of Java. Springer Verlag Lecture Notes in Computer Sci-ence, 1998. to appear, \navailable at http://www-dse.doc.ic.ac.uk/projects/slurp/. Ira Forman, Michael Conner, Scott Danforth, \nand Larry Raper. Release-to-Release Binary Compati-bility in SOM. In OOPSLA 95 Proceedings, 1995. Allen \nGoldberg. A Specification of Java Load- PI ing and Bytecode Verification. Technical report, Kestrel \nInstitute, December 1997. James Gosling, Bill Joy, and Guy Steele. The Java 1101 Language Spec$catl;on. \nAddison-Wesley, August 1996. James Gosling and H. McGilton. The Java 1111 Language Environment A White \nPaper, http:// java.sun.com/docs/white/langenv, 1996. Tim Lindholm and Frank Yellin. The Java Virtual \n 11 4 Machine. Addison-Wesley, 1997. [I31 Lconid Mikhajlov and Emil Sekerinski. A study of the fragile \nbase class problem. In ECOOP 98 Proceedings. Springer Verlag, 1998. to appear. [I41 Tobias Nipkow and \nDavid von Oheimb. Javaeight is type-safe ---definitely. In POPL 98 Proceedings, January 1998. [I51 Raymie \nStata and Martin Abadi. A Type System For Java Bytecode Subroutines. In POPL 98 Pro-ceedings, January \n1998. Guy Steele. Private Communication, January 1161 1998. I171 Donald Syme. Proving Java Type Sound. \nTechnical Report 427, Cambridge University, June 1997. to appear in Formal Syntax and Semantics of Javatm, \nedited by Jim Alves Foss, Springer, LNCS. US Department, of Defense. Reference Manual for 1181 the Ada \nProgramming Language, 1983. ANSI/MIL- STD-1815 A. 1191 Niklaus Wirth. Programming 171 Mod&#38;-Z. Springer-Verlag, \n1982. PO1 David Wragg, Sophia Drossopoulou, and Susan Eisenbach. Java binary compatibility is almost \ncor-rect. Technical Report 3198, Imperial College De-partment of Computing, February 1998. available \nat http://www-dse.doc.ic.ac.uk/projects/slurp/. Appendix A Modelling link compatibility In this section \nwe discuss the concept of link compati-bility, analyze and justify our approach, and give alter- native \ndefinitions. As we said earlier, link compatibil-ity was introduced to capture the guarantee of binary \ncompatibility. Consider again the description from the Java language specification: A change to a type \nis binury compatible with (equivalently, does not brealc compatibility with) pre-existing binaries if \npre-existing binaries that previously linked without error will co n- tinue to link without error. A.1 \nThe issues Five issues arose when considering the formalization of the above description: l representation \nof binaries ; l representation of change ; l the extent of the role of the pre-existing binaries; l the \nnumber of pre-existing binaries involved; l representation of linking and linking without er-ror ; which \nwe shall discuss in some detail. The representation of binaries In most current Java implementations \nbinaries are Java byte-code pro-grams (i.e. . class files) However, this does not have to be so; indeed, \nany code satisfying the requirements out-lined in ch 13.1 of the Java specification may be used. Furthermore, \nthe byte-code is at a different level of ab- straction from most programmers view of Java. There-fore, \nwe represent (binaries as Java,, bodies. Java,, has the advantage of having a type system, and of contain- \ning all necessary information for execution. The representation of change Since Java programs are represented \nby environment and body pairs, change consists of a new environment and body. Should the body of the \nchange be a Java,, or a Java, body ? We chose to have Java8 bodies, because this models more accurately \nsource code modifications as introduced by a programmer, and also expresses the fact that binary compatible \nchanges allow parts of a program to have been compiled with different versions of the environ-ment . \nThe extent of the role of the pre-existing binaries In how far is the context Fo crucial for t,he compilation \nof the modification F ? Do we allow the modifications to depend on contexts? Our answer is yes, because \nwe want to model modifications to libraries that are not stand-alone. This is why in definition 6 we \nrequire t,,FoOF 0 ===+ b,(FsoF) C&#38;F 0 as opposed to the stronger requirement t,,FoOF 0 d t,,FoO(F~,F \n) 0. The number of pre-existing binaries involved The term pre-existing binaries is used twice in the \nquote from before, but it is not necessarily clear, how many different pre-existing binaries are involved. \nEither one set is involved, meaning: A change is binary compatible with pre-existing binaries if these \npre-existing binaries link with-out error and continue to do so after the change. or, two sets are involved, \nmeaning: A change is binary compatible with pre-existing binaries if any further pre-existing binaries \nthat link without error with the former pre-existing binaries continue to do so after the change to the \nformer pre-existing binaries. We have chosen the second interpretation, and distin- guish F, the binaries \nbeing modified, from Fs, the con- text binaries that, linked without error with F. In definition 6 the \nmodifications F are considered link compatible for F, iff for all contexts Fe, such that F and Fe linked \nwithout error, the effect of F onto F will link with Fs without error. However, in section A.2 we shall \ndiscuss the repercussions of considering one set of pre-existing binaries. The representation of linking \n, and of linking without error Linking is described in some detail in 12.3 of [lo], as a process taking \nplace after loading, and consisting of verification, preparation and resolution of symbolic references. \nVerification ensures that a binary is structurally correct; for the byte-code it is described in some \ndetail in [12] and also in [15].. Preparation in-volves creation of stat,ic fields and their initialization \nto default values. Resolution involves checking sym-bolic references (containing type information) to \nmeth- ods and fields of other classes and replacing them by more direct references [lo]. A formal description \nof the linker requires the de-velopment of more formal apparatus, e.g. [9]. However, for the purposes \nof the current investigation, we do not need a complete description of the linking process, be- cause \nwe clearly are not interested in the outcome of the linker, we are only interested in the possible errors \nreported by it. All checks performed during verification and resolution correspond to checking type correctness \nof JavaS, terms. Thus, we claim for JavaL,, fragments Fi , F2, that if h,Fi 0, then the code corresponding \nto Fi would pass the verifier checks, and if t-SCFioFz @, then all sym-bolic references in the code corresponding \nto Fi and Fs would be successfully resolved. Therefore, the require- ment b,,FioF2 0 together with the \nrequirements that all declared classes have a class body, adequately rep-resents linking without error \n. In section A.2 we shall discuss the repercussions of an alternative representa-tion of linking without \nerrors through run-time safety, a property whereby program execution will never raise linker-related \nexceptions c.$ definition 10.  A.2 Alternative definitions The approach described in the main body of \nthis pa-per represents a certain stance on the issues identified above, one which we have found to be \nthe most reason-able and fruitful. Naturally we have given some con- sideration to other possibilities, \nand in this section we compare three alternatives to definition 6, which cor-respond to different answers \nto the last two of the five issues. We consider the representation of linking without error either through \ntype-safety of the program, or though the run-time safety, For the number of pre-existing binaries, we \nconsider the cases where either one or two sets are taken into account. This produces the following four \nalternatives: pre-existing two one binaries linking without error We link weak link safe compatible compatible \n run-time global link local link safe compatible compatible Definition 9 describes a variation of link \ncompatibil-ity where we consider a modification F with respect to some specific pre-exiting binaries \nF only, and require the result to link without error: Definition 9 A Java, fragment F is a weak link \ncom-patible change of a Java,, fragment F, Zff F F@,F 0 This definition would allow the removal of a \nmethod from a class, provided that that method were not called inside any of the method bodies in F. \nTherefore, this definition is appropriate only in cases where we have an exact knowledge of the classes \nwhich we want to link with the modified classes. For well-formed fragments link compatibility implies \nweak link compatibility. Lemma 8 If a Java, fraymend F is a link compatible change of a Java,, fragment \nF, and k F 0, then F is a weals li71k compatible change of F. We shall now consider an alternative representation \nof links without error , in terms of the run-time be-havio?Lr of the resulting program, whereby we call \na Java,, program run-time safe if its execution does not cause the exceptions that would be detected \nby a linker (i.e. absence of a method body, or absence of a field). We call linker exceptions those exceptions \nthat could be raised by resolution; these are AbstractMethodError, IllegalAccessError, InstantiationError, \netc. In other words, execution of a run-time safe program may terminate, or may halt or because of a \npredefined or user defined exception, but not because an appropriate body or field was absent. Definition \n10 A Java,, fragment F = (I ,p) is run-t,ime safe iff, for all terms t, states u, with execution of p \nleads to configuration (t , CJ): l t = throw Li, C(Li) = <<...BE -----r E is not a linlcer exception,. \n The subject reduction theorem implies that type safety and completeness guarantee run-time safety. \nConjecture 1 If h,F @, then F is run-time safe. Our next attempt at a formal definition of the guar- \nantee of binary compatibility will be in terms of run- time safety. In definition 11 we only consider \none set of pre-existing binaries, whereas in definition 12 we consider two. Definition 11 A Java, fragment \nF is a local link com-patible change of a Java,, fragment F, i,fl F aH, F is run-time safe Therefore, \nprovided that F BC F is run-time safe, F is a local link compatible change, even if C-,,F 63, F 0 did \nnot hold! Thus local link compatibility seems to guarantee no more than what is required. The above definition \nwould allow the addition of a method to an interface, provided that this method was never called from \nF; this corresponds to the second phase from our example in section 2.2. However, we see no practical \nway of en-suring that a change satisfies the local link compatible change property. More importantly, \nafter a local link compatible change and a locally type correct compi-lation run-time safety is not guaranteed \nany more, as demonstrated by the third phase of the example from section 2.2. Therefore, a type correct \ncompilation cannot be con- sidered a local link compatible step, and a type-correct compilation of a \nnew fragment F does not guarantee run-time safety, unless the original fragment F was type correct: Conjecture \n2 If a Java, fragment F is weak link com-patible change of a Java,, fragment F, then F is a local link \ncompatible change of F. The opposite direction of the implication does not hold. For example, the addition \nof a method to an interface, although a local link compatible change, does not al-ways create a type \ncorrect fragment and therefore is not not weak link compatible. The requirement of local link compatibility \nis weak, because it cannot guarantee much after subsequent lo-cally type correct compilations. In the \nnext definition we require the property of run-time safety to be pre- served in all appropriate contexts, \nand by subsequent locally type-correct compilations of class bodies. Definition 12 A Java, fragment F \nis a global link compatible change of a Java,, fragment F, iff for all Java, fragments F , Java,, bodies \np , Java,, fragment F = (~,p ), where Fo disjoint from F , F : FooF is run-time safe (FooF) CBc F CBc \nF is run-time safe (or is undefined). Thus, the addition of a method to an interface is not a global \nlink compatible change even if this method were not called in F, Fo or F , as it may be called in a subsequent \nmodification F . Global link compatible changes are local link compatible changes. Lemma 9 If a Java, \nfragment F is global linlc compati-ble change of a Java,, fragment F, then F is a local linlc compatible \nchange of F. It seems to us that global link compatibility is the weakest possible description of the \nguarantee of binary compatibility. It remains open, in how far global link compatibility is equivalent \nto link compatibility, and if it is not, whether there are useful cases covered by one but not the other. \nThe following diagram summarizes the relationship between the four definitions given in this section: \nlink weak link compatible compatible if b,F 0 ? ? global link , local link compatible compatible if F \nrun-time safe B The syntax of environments Env :I= [ StandardEnv ; ] De&#38; Standard&#38;w ::= Exception \next Object...NullPE ext Exception...; ..- DdS ..-Decl; Deck 1 E - ..- Decl ..-ClassId ext ClassName \nimp1 (InterfName)* ..- Var Type ..-Simple Type 1 Array Type ..- Simple Type ..-PrimType 1ClassName 1 \nInterfaceName ..- Array Type ..-SimpleTypeC 1 1 Array Typed 1 InterfaceName Prim Type ..-boo1 1 char \n1 int 1 . ..- Type ..- VarType I void I nil {(VarId : VarType)* (MethId : MethType)*It InterfId ext InterfName*((MethId \n: lMethType)*I I VarId : VarType Meth Type ..- ArgType --+ (VarType 1void) ..- ArgTwe ..-[ VarType (x \nVarType)*] C The syntax of Java, ..- ProgramBody ..-( ClassBody )* ..-  ClassBody ..-ClassId ext ClassName \n{( MethBody )*I ..- MethBody ..-MethId is (A ParId : VarType.) {Stmts ; return [Expr] 1 ..- Stmts ..-Stmt \nI Stmts ; Stmt ..- stmt ..-if Expr then Stmts else Stmts Var = Expr I Expr I throw Expr try Stmts (catch \nClassName Id Stmts)* finally Stmts try Stmts (CatchClassName Id Stmts)+ ..- Expr ..-Value I Var I Expr.MethName \n( Expr*) (C Expr I)+( C I)* ..- Var ..-Name I Var.VarName I VarCExprl I this ..- Value ..-PrimValue I \nnull ..- Prim Value ..-intvalue I charvalue I byte Value I ... D Some of the Java, type checking rules \n rt0 i is integer, c is character, x is identifier r k null:nil, r ktrue:bool, I'l-false:bool, r k i \n: int, J?k c :char, r t-x : I-(X) c{r,zJ =Z if z is integer, character, identifier, null, true, or false \nrFv:T r k e : T' I-t-T' <win T r k v:= e:void I? k return:void cc v := e] = cgr, V] := c{r, e] C(r, \nreturn] =return r k e: boo1 r k stmts:void r k stmt :T r I-stmts' :T' IY t-stmts ; stmt :T C{r,stmts \n; stmt] =C(r,stmts] ;C{r,stmt] r k if e then stmts else stmts':void qr. if ethen stmts else stmts'] = \nif C{I?,e] then C{r,stmts) else C{r,stmts'] r t- v :T[] r k ei : Ti iE{l...n},n 2 1 r F e : int MostSpec(r,m, \nT1, T2 x . . . x Tn) = {(T, MT)} r t-v[e] : T r k ef.m(ep...e,) : Res(MT) CC +I1 = W, 4[W, 41 C{r,el.m(ez...e,)l \n= C{r,el~.[Args(MT)]m(C{r,e2j...C{r,en~) mBody=m is xxi : T1...Xx, : T,,{stmts} xi #this iE{l...n} l7kv:T \nFDec(I , I? t- v.f cgrlv.fj T,f) = (C,T') : T' = cgr,v~.[c]f zl, . . . . z, are new variables in I? r,zl \n: Tl...zn : T, t- stmts' : T' r t T' &#38;,,dn T r FmBody:Ti x . ..X T, -+ T C(I',mBody) = mis xxi :T1...Xx, \n:T,.{C(l?,stmts)} n>O,k>O,mLO,rtrO r(C) = C ext C' imp1 I1...I,{vl : T1...vk :Tk,ml : MTl...ml : MT1} \ncBody = C ext C' {mBodyl,...mBodyl}, stmts'= stmts[zl/xl,...,z,/xn] r(this)= Undef mBodyi =mi is mPrsStsi \niE{l...l} r,this:CFmBodyi:MTi iE{l...l} rt cBody 0 C{r,cBodyj = C ext C' {C(r,mBodylj...C{r,mBodyl~} \n npo p = p1p2 ==+ Cl(p1)n Cl(p2) = 0 n L 0, p = cBodyl,...cBody, t (r,d 0 cBOdyi = Ci ext . ..{...} \nfor iE{ l...n} rt CBodyi 0 iE{l...n} cl(r) = cqp) rtpo rtpo cgqpl =c{r,th' 1s :C,cBodyll...C(r,this \n:C,cBody,j up49 E Altering the syntax of Java, to obtain Javase syntax Expr ::= Ezpr.[ArgType]MethName(Ezpr*) \nreplacesExpr.MethName(Ezpr*) I Stmts Var ::= . Var.[ClassName]VarName replaces Var.VarName I F Some \nof the Java,, type checking rules rt,,v:T l? I-,, ei :T!, iE{l...n},n 2 0 r t T swdn c r t Ti &#38;jn \nTi iE{2...n} FDec(I , c, f) = ( c, T') FirstFit(r,m,T:,T2 x . . . x T,) = {(T,MT)} r t&#38; v.[C]f : \nT' r 6, el.[Tz x . . . x T, ]m(e2...e,) : Res(MT)  \n\t\t\t", "proc_id": "286936", "abstract": "Separate compilation allows the decomposition of programs into units that may be compiled separately, and linked into an executable. Traditionally, separate compilation was equivalent to the compilation of all units together, and modification and re-compilation of one unit required re-compilation of all importing units.Java suggests a more flexible framework, in which the linker checks the integrity of the binaries to be combined. Certain source code modifications, such as addition of methods to classes, are defined as <i>binary compatible</i>. The language description guarantees that binaries of types (<i>i.e</i>. classes or interfaces) modified in binary compatible ways may be re-compiled and linked with the binaries of types that imported and were compiled using the earlier versions of the modified types.However, this is not always the case: some of the changes considered by Java as binary compatible do <i>not</i> guarantee successful linking and execution. In this paper we study the concepts around binary compatibility. We suggest a formalization of the requirement of safe linking and execution without re-compilation, investigate alternatives, demonstrate several of its properties, and propose a more restricted definition of binary compatible changes. Finally, we prove for a substantial subset of Java, that this restricted definition guarantees error-free linking and execution.", "authors": [{"name": "Sophia Drossopoulou", "author_profile_id": "81100331741", "affiliation": "Department of Computing, Imperial College", "person_id": "PP39075778", "email_address": "", "orcid_id": ""}, {"name": "David Wragg", "author_profile_id": "81100036002", "affiliation": "Department of Computing, Imperial College", "person_id": "P64444", "email_address": "", "orcid_id": ""}, {"name": "Susan Eisenbach", "author_profile_id": "81100428501", "affiliation": "Department of Computing, Imperial College", "person_id": "PP31041876", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/286936.286974", "year": "1998", "article_id": "286974", "conference": "OOPSLA", "title": "What is Java binary compatibility?", "url": "http://dl.acm.org/citation.cfm?id=286974"}