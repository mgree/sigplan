{"article_publication_date": "10-01-1998", "fulltext": "\n JRes: A Resource Accounting Interface for Java Grzegorz Czajkowski and Thorsten von Eicken Department \nof Computer Science Cornell University Ithaca, NY 14853 USA +I 607255 5951 (grzes,tve}@cs.comell.edu \n ABSTRACT With the spread of the Internet the computing model on server systems is undergoing several \nimportant changes. Recent research ideas concerning dynamic operating system extensibility are finding \ntheir way into the commercial domain, resulting in designs of extensible databases and Web servers. In \naddition, both ordinary users and service providers must deal with untrusted downloadable executable \ncode of unknown origin and intentions. Across the board, Java has emerged as the language of choice \nfor Internet-oriented software. We argue that, in order to realize its full potential in applications \ndealing with untrusted code, Java needs a flexible resource accounting interface. The design and prototype \nimplementation of such an interface -JRes -is presented in this paper. The interface allows to account \nfor heap memory, CPU time, and network resources consumed by individual threads or groups of threads. \nJRes allows limits to be set on resources available to threads and it can invoke callbacks when these \nlimits are exceeded. The JRes prototype described in this paper is implemented on top of standard Java \nvirtual machines and requires only a small amount of native code. Keywords Java, resource management, \nextensible systems. INTRODUCTION The spreading use of active content on the Internet makes the use of \nuntrusted code a fact of life for connected users as well as for providers of Internet-based services. \nOn the client side, downloadable executable content, like Java applets [2] and Active X technology [ll], \nserves to increase the attractiveness of Web pages. On the server side, dynamic server extensibility \npromises full customizability of various tasks, from information Perm,ss,on ,o make dlg,tal or hard \ncopties of all or part of thbs work for personal or classroom use IS granted wthout fee prowded that \ncopes are not made or distributed for proflt or commercial advan-tage and that copes bear this not,ce \nand the full c,tat,on on the first page. lo copy otherwse, to republish. to post on servers or to redistribute \nto ksts, requres pnor specific permess~on and/or a fee. OOPSLA 98 lo/98 Vancouver. B.C. 0 1998 ACM l-581 \n13.0058/98/0010...$5.00 retrieval to accessing proprietary databases to dynamically uploading services. \nThese tasks can be accomplished via a concept of .rer.vZets [23] -untrusted code executed on the server. \nThe programming language Java is currently a premier tool for implementing such uploadable content. Despite \nthe attention and publicity given to Java, most notably to its security features, there are still areas \nwhere Java either cannot be applied or applying the language is cumbersome and requires non-portable \nnative code support. The language has been extended in various ways and its performance has been continuously \nimproving. However, the current definition of Java (version 1.2) does not have an interface for resource \nmanagement. The application domains that would benefit from providing such an interface as a standard \nand integral part of the language specification include both well known paradigms, such as application-controlled \nload balancing and preventing some denial-of-service attacks, as well as emerging concepts, such as extensible \nservers. Not addressing the issue of resource management may in fact be an adequate decision when designing \na plain programming language. This is not so in the case of Java, which is both a language and a runtime \nenvironment and includes many features of an extensible operating system (a Java-enabled browser is in \nessence an operating system running applets). Server-side environments running untrusted code are being \ndeveloped and may well become common [20,23]. The fact that Java provides neither a model nor mechanisms \nfor controlling resource consumption of applications (apart from changing thread priorities) is a problem \nin all these systems for two reasons: malicious code cannot be prevented from using too many resources \nand code cannot be charged for the resources it is consuming. Both issues represent a significant obstacle \nto deploying commercial extensible servers. Some ad-hoc resource controlling solutions are possible in \nJava. For example, using native code it is possible to monitor CPU time consumed by each thread. Such \napproaches tie an otherwise portable Java environment to an underlying operating system, which results \nin loss of portability and maintenance problems. Enforcing appropriate resource consumption patterns \nis also possible for applications where one has full control over the sources and can make the code behave \n. However, in the case of untrusted and unknown code, like applets and servlets, no assumptions can be \nmade about resource consumption. In this paper we propose JRes - a Java interface which allows per-thread \naccounting of heap memory, CPU time, and the number of bytes sent and received. In addition to tracking \nresource consumption, applications can be informed when new threads are created. JRes provides mechanisms \nfor setting limits on the resources available to particular threads and associate overuse callbacks to \nbe invoked whenever any such resource limit is exceeded. Although the interface is simple, it is flexible \nenough to support a variety of resource consumption enforcement policies. For instance, a policy which \nensures that no thread gets more than 100 milliseconds of CPU time out of every second is easily expressible, \nas will be shown later. Similarly, a few lines of code suffice to create a policy in which no thread \ngroup can send more than 2MB of data, or a policy in which the combined size of all alive objects allocated \nby threads belonging to a particular thread group does not exceed 1 MB. Although the design of JRes is \ngeneral and the system can be used for any Java application, its main intended usage is for extensible \nenvironments, like Web browsers or extensible Internet servers. Such environments would use JRes to control \nresources consumed by their extensions. The contribution of this paper is twofold. First, it motivates \nconsidering incorporating a resource management interface in the language specification of Java and any \nother language of similar aspirations and scope. By describing several possible applications of JRes \nwe aim at making a convincing argument that future extensions of Java with resource management support \nshould provide at least the functionality included in JRes. The second goal is to demonstrate that although \nit was possible to implement JRes in its current form without modifying the underlying JVM, it comes \nat a price of certain functionality limitations and performance overheads. The lessons learned in the \ncourse of developing JRes can be important guidelines in future work on resource management infrastructure \nfor Java, possibly through changing the implementation of JVMs. Although the JRes project is carried \nout in the context of Java, it is applicable to other languages with features similar to Java. To date \nwe are not aware of any other work providing the functionality of JRes in a general purpose programming \nlanguage. The rest of the paper is structured as follows. The next section motivates extending Java with \nresource management capabilities. This is followed by a description of the JRes interface and a presentation \nof selected implementation and performance details. The JRes limitations are discussed next. The following \ntwo sections discuss related work, the current status of the system and planned future directions. The \nlast section summarizes the paper. MOTIVATING APPLICATIONS Several motivating examples are described \nbelow in order to clarify why it is crucial that Java (and any other language of similar scope) provide \na resource management interface. Such an interface should at least allow the resources consumed by applications \n(be it applets or servlets) to be monitored and limits on the consumption of particular resources to \nbe enforced. The first group of applications that can readily benefit from JRes are extensible, Java-based \nInternet servers, which allow service extensions to be uploaded by clients to the server. Consider image \nprocessing services created for profit by an independent developer. An architecture of an extensible \nWeb server makes it possible for the developer to upload the code of the service. This makes the service \navailable to a large group of potential users. Clients access the services either via a standard Web \nbrowser interface or, in case of more sophisticated or special demands, are able to upload their own \ncode accessing the image-rendering services. The J-Server, a practical application of the J-Kernel, is \nan example of a dynamically extensible Web server [20], adequate for implementing such scenarios. Both \nthe system core and the uploaded code execute in a single Java Virtual Machine (JVM). Constructing a \nserver as a single JVM has two considerable advantages. First, the performance of cross-domain calls \nbetween the core and extensions is much better than when relying on traditional OS protection mechanisms \n(e.g. separate processes encapsulating extensions and the core). Second, the security restrictions under \nwhich bytecode is run can be finely controlled and Java provides adequate mechanisms for extensibility \nand implementing protection domains [20,15]. While the issues of dynamic extensibility and protection \nare well understood in the context of Java, the lack of support for resource accounting has two serious \nconsequences. First, in a single-address space environment described above, it is difficult to identify \nservlets that consume too many resources. Malicious servlets can easily mount denial-of-service attacks, \nthat is, attacks aimed at preventing other applications from being able to use resources. Second, one \nof the main incentives behind attractive, high quality, extensible Internet servers is the revenue they \nmay potentially bring. Lack of support for resource accounting leaves only one alternative for billing \nusers: flat, undifferentiated fees. Although in principle flat rates are not bad, typically there needs \nto be several levels of them and a way to force clients to use up only as much resources as purchased. \nThe second motivating example is the technology of extensible database servers. The functionality of \nsuch systems can be augmented by user-defined functions (UDFs) [14]. For example, consider a database \nof stock market data that is accessible through a Web site. A potential user is any investor with a Web \nbrowser, a credit card, and an investment formula InvestVal. The following SQL query would then find \ntechnology stocks of interest to the user: SELECT * FROM Stocks S WHERE S.type = \"tech\" and InvestVal(S.history) \n> 5 Here, Inves tval is a user-defined function. It should be possible (and relatively straightforward) \nfor a large number of such users in a Web environment to create their own UDFs and use them within queries. \nThe motivation for facilitating such database extensions is the next generation of database systems that \nwill be deployed over the Web [ 141. In such applications, a large number of physically distributed end-users \nworking on diverse platforms interact with the database through their Web browsers. Because of the large \nsize and diversity of the user community, the utility of UDFs increases. Java is ideally suited for the \nimplementation of such extensible databases because of its security and portability features as long \nas the resource management concerns are resolved. Active Networks [7] is yet another example of an extensible \nenvironment for which portability and safety features of Java are desirable. The goal of Active Networks \nis to associate executable content with network packets and execute such programs on hosts and routers \nof the Internet. This can result in easier management of networks. However, using standard Java-based \nenvironments as an infrastructure for implementing Active Networks is possible only when the programs \nare trusted because malicious network programs can simply consume enough resources to halt routers, for \ninstance. Extending Java with resource management facilities is very desirable in this context. The final \nmotivation for JRes is preventing denial-of-service attacks aimed at Web browsers. A typical form of \na denial-of-service attack mounted by an applet is when the applet is consuming excessive amounts of \nresources and thereby prevents other applications on the local host from performing as expected. In severe \ncases, a hostile applet can completely take over a particular resource and crash other applications as \nwell as prevent new applications from being started. It is important to point out that applets may hog \nresources not only because of malicious intentions, but also because of programming errors. Although \ndenial-of-service attacks are classified as proper security attacks, to date this issue has not been \naddressed by Java implementations. THE PROPOSED INTERFACE The purpose of JRes is to add resource accounting \nand limiting facilities to Java. The main motivation is the creation of portable and extensible Web environments. \nThis motivation is reflected in the design of JRes. One part of the interface is accessible to both trusted \nand untrusted code; this part of JRes allows extensions to learn about resource limits and usage. The \npurpose of the other part of JRes, requiring authenticating the caller as a trusted system component, \nis to manage and enforce resource limits. This part is designed to be used only by privileged system \nmodules, e.g. by a resource controlling part of an enhanced Web browser. Through JRes, the trusted core \nof Java-based environments can (i) be informed of all new thread creations, (ii) state an upper limit \non memory used by all live objects allocated by a particular thread or thread group, (iii) limit how \nmany bytes of data a thread can send and receive, (iv) limit how much CPU time a thread can consume, \nand (v) register overuse callbacks, that is, actions to be executed whenever any of the limits is exceeded. \nThe JRes interface is presented in Figure 1. It consists of two Java interfaces, one exception and the \nclass ResourceManager. Except for initializeo, ah presented methods of ResourceManager deal with threads \nand each of them has a counterpart method (not shown) managing resources on a per thread group basis. \nDespite the fact that the interface is simple, it is flexible enough to build rather complex and diverse \nresource management policies, as will be discussed later. The ResourceManager class defines constants \nidentifying resources and exports six public methods. The first one, initialize(cookie), handles an authenticating \nobject (a cookie; it can be any object) to the resource accounting subsystem and initializes it. The \npurpose of the cookie is to ensure that only one party can have privileged access to the resource management \nsubsystem. This prevents untrusted code from interfering with the resource management policies of a given \nsystem. For instance, a browser would call initialize (cookie), before any applets are loaded. Since \napplets cannot get hold of cookie, they cannot call certain method of ResourceManager. For instance, \napplets could not be able to grant themselves more resources than granted by the browser. The next method \npresented in Figure I, setThreadRegistrationCallback(cookie, tcallback), hands an object implementing \nthe ThreadRegistrationCallback interface to the resource management subsystem. The effect of this operation \nis that whenever a new Java thread t is created, tCallback.threadRegistrationNotificati on ( t ) will \nbe invoked. This callback is meant to work in conjunction with the method se tLimi t (cookie, public \ninterface ThreadRegistrationCallback { public void threadRegistrationNotification(Thread t); public \ninterface OveruseCallback I public void resourceUseExceeded(int resType, Thread t, int resvalue); public \nclass ResourceOverusedException extends RuntimeException I ResourceOverusedException(int resType, long \nlimitingvalue, long usedvalue); public final class ResourceManager I public static final int RES-CPU; \npublic static final int RES-MEM; public static final int RES-NET-RECV; public static final int RES-NET-SEND; \n public static boolean initializecobject cookie); public static boolean setThreadRegistrationCallback(Object \ncookie, ThreadRegistationCallback tcallback); public static boolean setLimit(Object cookie, int resType, \nThread t, long limit, OveruseCallback ocallback); public static boolean clearLimit(Object cookie, int \nresType, Thread t); public static long getResourceUsage(int resType, Thread t); public static long getResourceLimit(int \nresType, Thread t); Figure 1. The JRes interface. resType, t, limit, ocallback), which can A particular \nresource management policy may choose to be invoked each time a new thread creation is detected throw \nthe exception ResourceOveruseException and has the effect of setting a limit of 1 imi t units of a as \nan action taken against applications using too many resource resType for a thread t. Whenever this limit \nis resources. The arguments to the constructor specify the exceeded by the thread t, the method type \nof resource, the allowed value and the value actually resourceUseExceeded(resType, t, used. This information \ncan be retrieved from a caught resvalue) willbeinvoked on the object ocallback exception. (note that \nocallback must implement the The values in which resource limits are expressed and OveruseCallback interface). \nThe parameter usage values are reported are as follows: memory and resvalue passed to the callback provides \ninformation network are expressed in bytes and CPU time in about current resource consumption. Resource \nlimits are milliseconds. cleared by invoking clearLimit(cookie, JRes allows for exact pre-accounting \nfor memory and resType, t). network resources -that is, an overuse callback is generated before a thread \ncan execute an action leading to The method getResourceUsage(resType, t) exceeding a limit. This is especially \ndesirable whenqueries the resource management subsystem about dealing with memory, since once it is allocated \nit cannot resource usage of a particular thread t; be reclaimed unless the offending thread is killed \nandgetResourceLimit(resType, t) canbeusedto there are no other references to the new objects. However, \nquery resource limits. No caller authentication via a in the current implementation enforcing CPU limits \niscookie is necessary in order to invoke get methods, done by a periodic polling thread, which results \nin awhich makes it possible for untrusted code to monitor its certain small and configurable delay in \nreaction time . resource consumption and limits. public class Example { public static void main(String[l \nargs) { Object cookie = new Object();-Initialization. The cookie will ResourceManager.initialize(cookie); \nbe used later for authentication. ResPolicy erp = new ResPolic ResourceManager. // Start the co 1 A new \ninstance 1 whenever a new thread is created. class ResPolicy resources. implements ThreadRegistrationCallback, \nOveruseCallback { private Object ck; ResPolicy(Object cookie) { ck = cookie; 1 Set a limit of almost \n3MB of heap memory available to this new thread t ResourceManager&#38;tLimits(ck, Resources.RES-CPU, \nt, 100, this); I This method (not defined here) returns Set a limit of 1 OOms of CPU time. true only \nif using the network by the thread has been paid for. Prevent the thread from using the network. if \n(!paidForNetwork(t)) I -1 ResourceManager.setLimits(ck, RESOURCE-NET-SEND, t, 0, this); ResourceManager.setLimits(ck, \nRESOURCE-NET-RECV, t, 0, this); 1 I Invoked by JRes whenever a resource limit is exceeded. switch (resType) \nbreak: case RESOURCE-CPU:  ((EarlyWarning) t).cpuExceeded(value) * lowerPriority( esourceManager. Type, \nt, value + 100, this); break; case RESOURCE-NET-SEND: Add another I OOms to case RESOURCE-NET-RECV: the \nthread s CPU limit. String msg = \"This thread has not paid for network resources\"; throw new ResourceOverusedException(msg); \n1 If the offending thread is trying to use the network, I an appropriate JRes exception is thrown. \n, Figure 2. Example resource management policy using the JRes interface. 25 Example Use of JRes Figure \n2 shows a resource consumption limiting policy taking advantage of the proposed interface. The code can \nbe thought of as a resource management module of an extensible server or a Web browser. After being initialized, \nthe code is informed of every thread creation and sets resource limits for newly created threads. Whenever \nany limit is exceeded, resourceUseExceeded 0 iscalledandenforcesthat a thread cannot have more than 3MB \nof memory allocated to objects this thread created, at any given point of time; it can use only 100 ms \nof CPU time out of every wall-clock second; and can use network resources only if thread s owner paid \nfor this. The actual resource policies for real servers will naturally be more complex and will most \nlikely operate on thread groups, but will use the same mechanisms as in this simplified example. The \nfirst four lines of main ( ) install a custom resource management policy. Specifically, an object of \ntype ResPolicy is registered with the resource management subsystem. This object will be receiving the \nupcalls generated by new thread creations, handled by the method threadRegistrationNotification() and \nthe upcalls caused by exceeding resource limits, handled by themethod resourceUseExceeded0. Consider \nthe method resourceUseExceeded0. If any thread exceeds heap memory limits (the first case statement) \na method is invoked to terminate the offending thread in an application-specific way. If any thread attempts \nto send or receive data without having paid for being able to use the network (the last case statement) \nan exception is being generated. The notion of paying is not defined here and is very system-specific; \nin our example, a thread t has not paid for network resources if a call to a method paidForNetwork (t) \nreturns false. Regardless of the caller s catching this exception or not, the attempt to use the network \nis unsuccessful. JRes can be used to implement periodic limits on resources, as demonstrated in handling \nexceeding a limit on CPU (the second case statement). The code detects threads that consume more than \n100 milliseconds of CPU time during one-second periods. Initially, each new thread is granted 1OOms of \nCPU time. Each time a thread exceeds its current CPU time limit, the check is made over what period it \nhappened. If the thread received more than 100 milliseconds of CPU time during a second of a wall-clock, \nthe example policy decides to lower the priority of the thread. Regardless whether the thread exceeds \nthe limit or not, the new limit is set, equal to the current usage plus 100ms. This effectively implements \nthe policy that every thread that receives more that 100 milliseconds of CPU time during a second of \na wall-clock time is detected and lowered in priority. In this particular extensible server, some threads \nmay implement an interface EarlyWarning. If the CPU limit has been exceeded by such a thread, the cpuExceeded \n( ) method of this interface is invoked and the thread is informed of the overuse. Smart threads may \nchoose to respond to such a warning by trying to consume less CPU (if it makes sense) to avoid lowering \nof their priorities. JRes and the Execution of Applications The example from Figure 2 demonstrates how \nextensible environments may use JRes to control resources available to applications. It is important \nto stress that applications do not have to be aware of this fact. In other words, any valid Java program \nis able to run in an environment that uses JRes. However, applications (servlets, applets, database extensions, \netc) may be affected if they exceed their resource limits. Therefore, applications can call getResourceUsage0 \nor getResourceLimit0 to learn about their current resource consumption and limits. As will be described \nin the next section, the bytecode of applications needs to be rewritten before it can be run with JRes. \nThis is done automatically and, apart from influencing the performance, cannot be detected by rewritten \nJava programs. JRes in the Context of the Java Architecture Figure 3 shows how the notion of resource \nmanager fits into the Java architecture. Providing the JRes functionality is an important enhancement \nto the language. It can be viewed in the context of two core notions of Java: the class loader and the \nsecurity manager. The function of the class loader is to load new classes into the system; the security \nmanager controls access to resources such as files and network connections, using class loaders to detect \nuntrusted classes. The notion of resource manager gives Java programs control over computational resources. \nIMPLEMENTATION AND PERFORMANCE OF JRES This section contains a discussion of specific implementation \nissues and performance implications. This is followed by a presentation of selected perfomrance data. \nThe experimental setup, to which some implementation details and all performance results refer, consists \nof a 300 MHz Pentium II PC with 128 MB of RAM. Microsoft s Visual J++ version 1.1 was used, with the \nJava SDK 2.0; this environment uses a just-in-time compiler. CPU accounting and accounting for memory \nused by allocated arrays requires native code support, that is, a small set of routines written in C \nand called from within a Java program as native methods. All other features of JRes are accomplished \nthrough bytecode rewriting, that is, inserting appropriate bytecode instructions at selected places in \noriginal classes in order to maintain information about resource consumption. Rewriting Java Bytecode \nfor JRes Java is a good environment for load-time code transformations. Java has a number of properties \nwhich Standard JVM JRes extension Applications define class loaders -specific ways of loading classes \n-separating untrusted code from trusted code Applications define security policies -different levels \nof trust Applications define resource policies -different levels of resource privileges -monitoring behavior \nof extensions 1 Figure 3. Extending the JVM with resource managing facilities. assist load-time transformation: \n(i) classes retain enough symbolic information to enable members to be inserted or renamed, (ii) the \nJVM is a stack machine, which allows simple code fragments to be inserted into methods, and most importantly, \n(iii) the JVM uses a user-extensible class loader to locate and add new classes on demand. The class \nloader s method loadclass ( ) is called by the JVM whenever it encounters a reference to a class not \nyet loaded. Typical class loaders implement loadclass ( ) by searching for the class file (possibly accross \nthe network) and then calling def ineClass(), which converts an array of bytes into an instance of java. \nlang.Class. This instance of Class is verified to ensure that the class is semantically valid and that \nall operations are used with appropriate types before is ready for execution [9]. In JRes, classes can \nbe either rewritten during class loading or off-line, which avoids runtime performance overheads. On-line \nbytecode rewriting occurs in loadclass 0 before calling defineclass 0. After the rewriting is complete, \nthe resulting byte array is passed to an invocation of def ineClass () and the resulting Class object \nis passed to the JVM, just as if it were the original code. The JVM core does not even know that any \nchanges were made. The current implementation of JRes uses a bytecode rewriting tool developed in the \nJ-Kernel project 1201. Thread Registration The core component of the current implementation of JRes is \nthread registration. Its goal is to store information about all threads that are or were active in the \nsystem. The module responsible for maintaining this information is contacted whenever a user program \nsets or clears a resource limit of a particular thread and whenever new resource consumption information \nbecomes available. Another responsibility of the thread registration module is to generate upcalls for \nnewly created threads. This happens if such upcalls have been registered by ResourceManager.setThreadRegistrationC \nallback0. Thread registration is accomplished via injecting a few bytecode instructions at the beginning \nof every run ( ) method of classes implementing the Runnable interface (only objects implementing this \ninterface can be run as threads in Java). When a new thread is started, its run0 method is invoked. This \nresults in first registering the thread and then executing the original code. Invoking a particular run \n( ) method more than once or directly (e.g. not a starting method of a thread) is properly handled. \nAccounting for Network Resources JRes tracks the amount of data transferred by a thread. Implementing \nthis was relatively straightforward. There are only a few native methods in classes belonging the java \n.net package which can access the network directly. The methods arc either private or protected and are \nlocated in non-public classes. This means that they cannot be called by any code outside of j ava . net. \nThus, the only action necessary to account for network usage was to rewrite the java.net package. The \nrewriting ensures that whenever one of these native, network-using methods is called, an appropriate \ninformation is recorded and a callback informing of exceeding resource limits is generated, if necessary. \nA simple ping-pong progam was run between two computers connected by Fast Ethernet in order to estimate \nthe overhead of JRes-instrumented bytecode. The round- trip time increased by about one percent (for \nmessages larger than 50 KB) to 4.5% (for very small message sizes). This result is encouraging and made \nus resign from further experimenting with an alternative approach to tracking network usage, such as \nnative code on top of sockets layer. Accounting for CPU Time In the current implementation of JRes, CPU \ntime is accounted for through a mixture of bytccode rewriting and native code. During thread registration \na native code routine is invoked in order to create an operating-system level handle to the new thread. \nThis handle is used later to query the system for information on the CPU time usage by the thread. As \na part of the CPU accounting module startup, a new thread is created. This thread wakes up periodically \nand, using the stored thread handles, queries the operating system for CPU consumption. When necessary, \nappropriate overuse callbacks are generated. Except for the overhead of waking up the polling thread \nand querying the OS, there are no other runtime overheads. In principle, gauging per-thread consumption \nof CPU time can be accomplished via bytecode rewriting. Inserting appropriate instructions at well-chosen \npoints of methods can result in statistical information on per-thread CPU usage. We did not experiment \nwith this approach, because the resulting execution time seems to be prohibitive when a reasonable degree \nof accuracy is to be achieved. Accounting for Heap Memory The goal of memory accounting is to know, at \nany point of program s execution, how much memory is used by objects allocated by each thread. This is \naccomplished by bytecode rewriting. Constructors of non-array objects are modified to record information \nabout the allocating thread and tinalizers are either modified or generated so that JRes can detect when \nthe garbage collector frees an object. The code of every method is changed such that appropriate bytecodc \nis inserted whenever an object allocating instruction occurs in the original method code. When an object \nor an array is allocated, a method invocation is inserted just before the allocating instruction. The \nmethod will increment a counter by the new object s or array s size and verify that the memory limit \nhas not been exceeded. If the limit is exceeded, the overuse callback is invoked. When an array allocation \ninstruction is encountered, code computing the number of entries in the array is inserted into the original \nbytecode. Computing the number of entries takes advantage of the fact that at runtime, just before an \narray is allocated, the size of every dimension is stored on top of the operand stack. In the case of \nmultidimensional arrays these stack entries must be multiplied out. An additional JRes method call is \ninserted after an array allocation bytecode instruction. The reason for doing so is to obtain a weak \npointer to the newly allocated array; this pointer is used to detect deallocation of the array. Weak \npointers are available in Java native code interfaces; their role is to reference objects without preventing \ntheir deallocation. If the referenced object is deallocated, every weak pointer referencing this object \nis changed to null. JRes stores weak pointers to all arrays allocated by a thread in a per-thread vector. \nWhenever an object allocation causes a thread to exceed its memory limit, the thread s list of weak pointers \nis scanned and sizes of all recently garbage-collected arrays (i.e. arrays whose corresponding weak pointers \nhave become null) are subtracted from the thread s memory usage counter. Figures 4 and 5 contain an example \nof a rewritten class. Figure 4 shows the source of an original class and the effect of transformations \nshown as source-to-source transformations. Figure 5 shows the actual effect of the rewriting on the bytecode. \nIt is important to note two things before analyzing the code. First, the numbers 0 and 1, used in calls \nto internal JRes methods, are identifiers for the classes Foo and j ava . lang . Ob j ect, respectively. \nThese numbers are generated during bytecode rewriting. Second, the virtual machine of Java is a stack \nmachine; in particular, methods expect their arguments on the stack (not in registers). The signatures \nof methods are shown in the bytecode in Figure 5. The figure gives a general idea of the increase in \ncode size due to memory accounting transformations. The increase is proportional to the number of object \nand array allocations in the original code. Methods which do not allocate memory will not change during \nbytecode transformations. Performance of Memory Accounting and Usage Limiting Four diverse Java applications \nwere run in order to evaluate the overheads of JRes memory accounting. The test suite consists of (i) \nrunning JavaCC, a parser generator from SunTcst [33], on a C++ grammar; (ii) Accounting for Network Resources \nJRes tracks the amount of data transferred by a thread. Implementing this was relatively straightforward. \nThere are only a few native methods in classes belonging the j ava. net package which can access the \nnetwork directly. The methods arc either private or protected and are located in non-public classes. \nThis means that they cannot be called by any code outside of j ava . net. Thus, the only action necessary \nto account for network usage was to rewrite the java.net package. The rewriting ensures that whenever \none of these native, network-using methods is called, an appropriate information is recorded and a callback \ninforming of exceeding resource limits is generated, if necessary. A simple ping-pong progam was run \nbetween two computers connected by Fast Ethernet in order to estimate the overhead of JRes-instrumented \nbytecode. The round- trip time increased by about one percent (for messages larger than 50 KB) to 4.5% \n(for very small message sizes). This result is encouraging and made us resign from further experimenting \nwith an alternative approach to tracking network usage, such as native code on top of sockets layer. \nAccounting for CPU Time In the current implementation of JRes, CPU time is accounted for through a mixture \nof bytecodc rewriting and native code. During thread registration a native code routine is invoked in \norder to create an operating-system level handle to the new thread. This handle is used later to query \nthe system for information on the CPU time usage by the thread. As a part of the CPU accounting module \nstartup, a new thread is created. This thread wakes up periodically and, using the stored thread handles, \nqueries the operating system for CPU consumption. When necessary, appropriate overuse callbacks are generated. \nExcept for the overhead of waking up the polling thread and querying the OS, there are no other runtimc \noverheads. In principle, gauging per-thread consumption of CPU time can be accomplished via bytecode \nrewriting. Inserting appropriate instructions at well-chosen points of methods can result in statistical \ninformation on per-thread CPU usage. We did not experiment with this approach, because the resulting \nexecution time seems to be prohibitive when a reasonable degree of accuracy is to be achieved. Accounting \nfor Heap Memory The goal of memory accounting is to know, at any point of program s execution, how much \nmemory is used by objects allocated by each thread. This is accomplished by bytecode rewriting. Constructors \nof non-array objects are modified to record information about the allocating thread and finalizers are \ntither modified or generated so that JRes can detect when the garbage collector frees an object. The \ncode of every method is changed such that appropriate bytecode is inserted whenever an object allocating \ninstruction occurs in the original method code. When an object or an array is allocated, a method invocation \nis inserted just before the allocating instruction. The method will increment a counter by the new object \ns or array s size and verify that the memory limit has not been exceeded. If the limit is exceeded, the \noveruse callback is invoked. When an array allocation instruction is encountered, code computing the \nnumber of entries in the array is inserted into the original bytecode. Computing the number of entries \ntakes advantage of the fact that at runtime, just before an array is allocated, the size of every dimension \nis stored on top of the operand stack. In the case of multidimensional arrays these stack entries must \nbe multiplied out. An additional JRes method call is inserted after an array allocation bytecode instruction. \nThe reason for doing so is to obtain a weak pointer to the newly allocated array; this pointer is used \nto detect deallocation of the array. Weak pointers are available in Java native code interfaces; their \nrole is to reference objects without preventing their deallocation. If the referenced object is deallocated, \nevery weak pointer referencing this object is changed to null. JRes stores weak pointers to all arrays \nallocated by a thread in a per-thread vector. Whenever an object allocation causes a thread to exceed \nits memory limit, the thread s list of weak pointers is scanned and sizes of all recently garbage-collected \narrays (i.e. arrays whose corresponding weak pointers have become null) are subtracted from the thread \ns memory usage counter. Figures 4 and 5 contain an example of a rewritten class. Figure 4 shows the source \nof an original class and the effect of transformations shown as source-to-source transformations. Figure \n5 shows the actual effect of the rewriting on the bytecode. It is important to note two things before \nanalyzing the code. First, the numbers 0 and 1, used in calls to internal JRes methods, are identifiers \nfor the classes FOO and j ava . lang . Ob j ect, respectively. These numbers are generated during bytecode \nrewriting. Second, the virtual machine of Java is a stack machine; in particular, methods expect their \narguments on the stack (not in registers). The signatures of methods are shown in the bytecode in Figure \n5. The figure gives a general idea of the increase in code size due to memory accounting transformations. \nThe increase is proportional to the number of object and array allocations in the original code. Methods \nwhich do not allocate memory will not change during bytecode transformations. Performance of Memory Accounting \nand Usage Limiting Four diverse Java applications were run in order to evaluate the overheads of JRes \nmemory accounting. The test suite consists of (i) running JavaCC, a parser generator from SunTest [33], \non a C++ grammar; (ii) FooO { aload-// push reference from local 0 invokespecial java/lang/Object.<init>() \n// invoke superclass constructor aload-// push reference from local 0 invokestatic java/lang/Thread.currentThread() \nputfield Foo.allocator // allocator = Thread.currentThread() return L void bar0 I int locall; int local2, \nlocal3; iconst-0 // push 0 onto stack istore-// pop int from stack into local2 iconst-l // push 1 onto \nstack; 1 is a code of class java.lang.Object invokestatic jres/MM.objAlloc(int) new java/lang/Object \ninvokespecial java/lang/Object.<init>() // constructor bipush 7 // push 7 onto stack iconst-0 // push \n0 onto stack; 0 is a code of class Foo istore-// pop int from stack into local3 dw // duplicate top stack \nword istore-// pop int from stack into local2 dw // duplicate top stack word iload-// push int from \nlocal2 invokestatic jres/MM.beforeArrayAlloc(java/lang/Object , int) anewarray Foo // push a reference \nto a new array of Foo dw // duplicate top stack word iload-// push int from local2 invokestatic jres/MM.afterArrayAlloc(java/lang/Object \nI int ) astore-l // pop reference into local1 aload-// push reference from local1 iconst-0 // push 0 \nonto stack aconst-null // push null object reference aastore // pop reference into array return 1 public \nvoid finalize0 I aload-//push reference from local 0 getfield Foo.allocator // push contents of field \nFoo.allocator iconst-0 // push 0 onto stack; 0 is a code of class Foo invokestatic jres/MM.deleteObject(java/lang/Thread \n, int ) return Figure 5. Bytecode resulting from transforming class Foo from Figure 4 so that it cooperates \nwith JRes memory accounting. The underlined instructions are present both in the original class Foo and \nin the rewritten one; all the other instructions were generated in the process of bytecode rewriting. \nThe original bytecode of Foo.class was generated with j avac from JDK 1.1.1. 20.0% 18.0% 16.0% 14.0% \n12.0% 0 Checking limits 10.0% H Accounting Null finalizer 8.0% 6.0% 4.0% 2.0% 0.0% Ja\\mCC Lisp Caffeine \nMark Jigsaw Figure 6. Overheads of accounting for memory and memory limiting. means that the cost of \nrewriting is not included in the very few object allocation instructions. The costs grow overheads reported \nin Figure 6. However, as discussed with the total number of bytecode instructions and the below, there \nare important cases in which bytecode number of object and array creations. rewriting has to happen on-line. \n It is not clear what the overheads of other bytecode The Classes column reports the number of classes \nrewriting systems [7,27] are. In the environments JRes is rewritten for a particular run of the program \n(e.g. our test primarily aimed at, it may be necessary to rewrite classes execution of Jigsaw needed \n47 classes, but the whole on-the-fly -for instance, in extensible Web servers. server code has many more \nclasses). The last column in Thus, rewriting will enter the critical path between the the table shows \nthe time taken to rewrite these classes. remote client issuing the request and obtaining the results. \nWith our current rewriting system, the costs of rewriting Fortunately extensions are likely to be small. \nFor instance, classes are substantial, even on the programs that contain it took about 2.4 seconds to \nrewrite all 134 example Runtime statistics Compile-time statistics Program Bytecode Object Array Bytecode \nObject Array Classes Rewrite instructions creations creations instructions creations creations time (s) \n JavaCC 134763243 85750 10749 154113 1885 193 62 15.3 Lisp 73620868 288842 0 5429 155 0 40 2.5 Caffeine \n14108912 1011 10 1801 38 5 13 0.6 Jigsaw 1830860 6775 1079 30919 598 98 47 1.9 Table 1. Runtime and compile-time \nstatistics of the benchmark programs. applet classes from the JDK 1.1.1 distribution. The average size \nof these classes is 350 bytecode instructions. In systems where an extension can be reused after being \nloaded the rewriting time will be amortized over all executions of this extension. DISCUSSION The resource \naccounting interface presented in this paper significantly enhances the functionality of dynamically \nextensible Internet-oriented environments that subsume the functionality of an operating system for uploaded \nextensions. JRes enables the construction of such environments with the capability of tracking resource \nusage of extensions. The interface is small, simple, and allows for building complex policies on top \nof it. JRes can be used to control access to resources other than CPU, heap memory and the network. For \ninstance, thread creation callbacks can impose limits on the number of threads a particular thread group \n(and its child thread groups) can create. Although not included in the standard interface of JRes, the \nsystem can be extended to limit the number of objects of a certain type alive in the system at any given \npoint of time. For instance, the number of windows opened by applets or the number of JDBC queries created \nby user defined functions in an extensible database can be controlled in this way. JRes has several limitations. \nOne of them is that the actions taken because of exceeding a resource limit are restricted by what Java \nallows. For instance, it is possible to lower a thread s priority but it is impossible to change the \nthread scheduling algorithm. Having full control over the scheduler would allow us to provide resource \nguarantees as well, in addition to enforcing resource limits as JRes currently does. Performance overheads \nof memory accounting are directly linked to the fact that JRes is not part of the JVM. For instance, \nbeing able to tap into the memory allocator and garbage collector would make it unnecessary to rewrite \nbytecode, which would certainly cut the overheads dramatically. The decision not to modify the JVM was \ndictated by two reasons. First, JRes is now a Java library with a small native component, and as such \ncan be easily ported to most virtual machines. Second, not tying JRes into a JVM implementation allows \nfor fast experimentation with various ideas. Ultimately, however, we would like to incorporate the functionality \nof JRes into an industry-strength JVM . Another limitation of JRes is that it does not handle the sharing \nof ob.jects by threads well. Consider a scenario in which a thread A creates a large object 0 and hands \nit off to a thread B. Thread A exits but 0 cannot be garbage collected and is not counted into B s memory \nconsumption. This problem does not exist in environments where it is possible to identify cooperating \nthreads and ensure that no data is shared between such groups of threads. In fact, this constraint is \nnot as severe as it may appear. For instance, applet security rules ensure that applets cannot access \nthreads in other thread groups. Another example of architecture where it is easy to define and identify \ncollections of cooperating threads is the J- Kernel [20]. An important decision made in the J-Kernel \ndesign was to disallow object sharing between protection domains. Similar designs can be expected in \nfiture designs of extensible Java-based environments. RELATED WORK JRes is related to several research \nareas: resource accounting and enforcing resource limits in traditional and extensible operating systems, \nsafe language technologies, and binary code transformations. In this section we summarize the most important \nwork from these areas influencing our research. Operating Systems Enforcing resource limits has long \nbeen a responsibility of operating systems. For instance, many UNIX shells export the limit command, \nwhich sets resource limitations for the current shell and its child processes. Among others, available \nCPU time and maximum sizes of data segment, stack segment, and virtual memory can be set. Enforcing resource \nlimits in traditional operating systems is coarse-grained in that the unit of control is an entire process. \nThe enforcement relies on kemel-controlled process scheduling and hardware support for detecting memory \noveruse. Single address space operating systems take advantage of the radical address space increase \navailable to operating systems and applications with the appearance of 64-bit architectures. An early \nexample of a 64-bit operating system is Opal [6]. Opal provides coarse-grained allocation and reclamation \nof resources (a set of memory pages, for instance), similar to that used in conventional operating systems. \nThe basic storage management mechanism is explicit reference counting, which applications and support \nfacilities use to allocate and release untyped storage in coarse units. A mechanism of resource groups \nis provided as the basis for a resource control policy, e.q. quotas or billing, to encourage or require \nusers and their applications to limit resource consumption. Each time an application wants to obtain \nrights to use a particular resouce, it has to pass its own resource group capability as a hidden argument \non system calls. Another example of a single-address-space operating system is Mungi [21]. An interesting \nfeature of that system is that it uses an economics-based model to manage backing store management. Applications \nobtain bank accounts from which rent is collected for the storage occupied by objects. Rent automatically \nincreases as available storage runs low, forcing users to release unneeded storage. Bank accounts receive \nregular income . In addition, a taxation system is used to prevent the excessive buildup of funds by \ninactive applications. The architecture of the SPIN extensible operating system allows applications to \nsafely change the operating system s interface and implementation [4]. SPIN and its extensions are written \nin Modula-3 and rely on a certifying compiler to guarantee the safety of extensions. The CPU consumption \nof untrusted extensions can be limited by introducing a time-out. Another example of an extensible operating \nsystem concerned with constraining resources consumed by extensions is the VINO kernel [32]. VINO uses \nsoftware fault isolation as its safety mechanism and a lightweight transaction system to cope with resource \nhoarding. Timeouts are associated with time-constrained resources. If an extension holds such a resource \nfor too long, it is terminated. The transactional support is used to restore the system to a consistent \nstate after aborting an extension. The main objective of extensible operating systems is to allow new \nservices to be added to the kernel and for core services to be modified. Their built-in and hard-coded \nsupport for resource management is adequate for an operating system. In contrast, the main motivation \nbehind JRes is building extensible, safe and efficient Internet environments implemented entirely in \na safe language, such as Java. An extension may be an entire application and various billing, accounting \nand enforcing policies may have to be effective at the same time. Programming Language Approaches Except \nfor the ability to manipulate thread priorities and invoke garbage collection, Java programmers are not \ngiven any interface to control resource usage of programs. Several extensions to Java attempt to alleviate \nthis problem, but none of them shares the goals of JRes. For instance, the Java Web Server [23] provides \nan administrator interface which allows to view resource usage in a coarse-grained manner, e.g. the number \nof running threads can be displayed. PERC (a real-time implementation of Java) [30] provides an API for \nobtaining guaranteed execution time and assuring resource availability. While the goal of real-time systems \nis to ensure that applications obtain at least as many resources as necessary, the goal of JRes is to \nensure that programs do not exceed their resource limits. A very recent specialized programming language \nPLAN [ 161 aims at providing infrastructure for programming Active Networks. PLAN is a strictly functional \nlanguage based on a dialect of ML. The programs replace packet headers (which are viewed as dumb programs) \nand are executed on Internet hosts and routers. In order to protect network availability PLAN programs \nmust use a bounded amount of space and time on active routers and bandwidth in the network. This is enforced \nby the language runtime system. JRes is similar to PLAN in that it limits resources consumed by programs. \nThe main difference is that PLAN pre-computes resources available to programs based on the length of \nthe program. The claim is that resources for an Active Networks program associated with a packet should \nbe bounded by a linear function of the size of the packet s header. Another approach to constraining \nresource consumption uses the ideas underlying Proof Carrying Code (PCC) [29]. PCC associates a proof \nof certain safety prop&#38;es with a program. The program may contain some runtime checks necessary to \nallow a proof to be generated (for instance, a proof that no array access exceeds array bounds). After \ndownloading, the proof is verified against the program, which is executed only if the verification is \nsuccessful. In principle, proofs can be constructed guaranteeing that no more than a certain amount of \nmemory will be allocated or that no tnore that a specified number of instructions will be executed. However, \nthe feasibility of this approach is still unknown. Currently the size of such resource-constraining proofs \nexceeds the size of the original code by an order of magnitude. This is a serious problem in extensible \nWeb environments since upload time is on the time-critical path. Binary Rewriting Code instrumentation \nthrough rewriting of binaries has been used for various purposes: emulation, tracing and debugging, profiling \nand optimization. Tools and toolkits such as Epoxie [38], Pixie [34] and QPT [25] are designed to rewrite \nprograms so that the modified code generates address traces and instruction counts. Generating address \nand instruction traces is handled by ATUM [ 11, which allows for detailed post-mortem tracing. Emulation \nof other architectures is the domain of the PROTEUS [5] and Shade [g] binary rewriting tools. The well-known \nPurify [ 171 software testing tool detects memory leaks and access errors using binary rewriting techniques \nas well. Another class of tools employing binary rewriting techniques consists of tools editing executable \ncode. The tools offer a library of routines for modifying executable files so that users can design their \nown binary rewriting strategies. Examples include OM [36], ATOM [35], EEL [26] and recently Etch [ 131. \nA detailed summary of binary code rewriting tools and techniques can be found in [27]. The importance \nof Java bytecode transformation has been recognized by other research groups recently. For instance, \nseveral recent projects rely on bytecode rewriting to provide increased levels of security [20,38]. Publications \non BIT [27] and JOIE [7] utilities contain a detailed list of issues that riced to be solved when designing \nsuch bytecode rewriting tools. Overheads reported in [27] are evidence that Java bytecode rewriting is \nextremely performance sensitive. CURRENT STATUS AND FUTURE WORK The system described in this paper is \noperational and consists of two packages and one native library. Currently it requires Microsoft s JVM \nbut we plan to port it to Sun s JDK as well. JRes has been used to alleviate the problem of denial-of- \nservice attacks targeted at browsers. The interface provides enough infrastructure to define a simple \npolicy preventing applets from using more heap memory, CPU time and network resources than a user specifies \nin a configuration file. As a practical demonstration of usefulness of JRes, the classes implementing \nJRes and the class implementing the resource consumption policy were added to the core classes of JVM \nexecuting inside Microsoft Internet Explorer. The result is an enhanced browser in which applets are \nprevented from mounting denial-of-service attacks through monopolizing the use of any of the three mentioned \nresources. In addition to being an enabling technology for a class of software systems, JRes is being \nused to understand resource management for an emerging model of Internet computing [I. The main characteristics \nof this model are high code mobility and large numbers of anonymous users, which result in different \nkind of resource demands made by applications than in traditional operating system environments. Efficient \nuse of distributed computational resources becomes a must if the model is to be useful. JRes provides \nan experimental infrastructure to research these issues. The design and implementation of JRes demonstrate \nthat many interesting and useful resource management functions can be added to Java without modifying \nthe JVM, although certainly we would like to incorporate JRes into the implementation of the JVM. Currently \nwe are working on incorporating JRes into the Jaguar extensible database [14] and the J-Kernel [20]. \nAnother topic of current work is the transfer of object ownership. SUMMARY This paper presents JRes - \nan interface extending Java with resource accounting and limiting capabilities. The main motivation behind \nJRes is facilitating the creation of extensible Internet environments, onto which untrusted code can \nbe uploaded. Currently Java lacks resource management support, which is a severe shortcoming when building \nsuch environments. JRes addresses this problem with a small interface that is flexible enough to allow \ncomplex resource management policies to be built. The implementation uses a combination of bytecode rewriting \nand native code to add resource management to off-the- shelf Java virtual machines. The performance overheads \nare small in the case of accounting for CPU time and network resources. On a set of four well-known Java \napplications memory accounting resulted in overheads between 0.5- 18%. The current implementation of \nJRes did not require modifications of the Java Virtual Machine. The discussion of the usefulness of the \ninterface and its limitations and sources of performance overheads presented in this paper can be important \nwhen adding a functionality of JRes to an industry-strength implementation of the JVM. ACKNOWLEDGEMENTS \nThe authors are grateful to Chi-Chao Chang, Chris Hawblitzel, Li Gong, Greg Morrisett, and Praveen Seshadri \nfor for comments and discussions. This research is funded by DARPA IT0 contract ONR-NO00 14-92-J- 1866, \nNSF contract CDA-9024600, a Sloan Foundation fellowship, and Intel Corp. hardware donations. REFERENCES \n1. Aganval, A, Sites, R, and Horowitz, M.. ATUM: A New Technique for Capturing Address Traces Using Microcode. \nProc. 13th International Symposium on Computer Architecture, June 1986. 2. Arnold, K and Gosling, J. \nThe Java Programming Language. Addison-Wesley. 3. Bershad, B, Savage, S and Pardyak P. Protection is \na Software Issue. Fifth Workshop on Hot Topics in Operating Systems, Orcas Island, WA, May 1995. 4. \nBershad, B, Savage, S, Pardyak, P, Sirer, E, Fiuczynski, M, Becker, D, Eggers, S, and Chambers, C. Extensibility, \nSafety and Performance in the SPIN Operating System. 15 ACM Symposium on Operating Systems Principles, \nCopper Mountain, CO, December 1995. 5. Brewer, E, Dellarocas, C, Colbrook, A and Weihl, W. PROTEUS: \nA High-Performance Parallel-Architecture Simulator. Massachusetts Institute of Technology technical report \nMIT/LCS/TR-5 16, 1991. 6. Chase, J, Levy, H, Feeley, M and Lazowska, E. Sharing and Protection in a \nSingle Address Space Operating System. In ACM Transactions on Computer Systems, May 1994. 7. Clark, \nD and Tennenhouse, D. Architectural Considerations for a New Generation of Protocols Proc. SIGCOMM Symposium \non Communications Architectures and Protocols, Philadelphia, PA, September 1990. 8. Cmelik, R and Keppel, \nD. Shade: A Fast Znstruction- Set Simulator for Execution Profiling. Proc. ACM SIGMETRICS Conference \non Measurement and Modeling of Computer Systems, May 1994. 9. Cohen, G, Chase, J, and Kaminsky, D. Automatic \nProgram Transformation with JOIE. Proc. USENIX Annual Conference, New Orleans, LA, June 1998.  IO. Czajkowski, \nG, Chang, C-C, Hawblitze, C, Hu, D and von Eicken, T. Resource Management for Extensible Internet Servers. \nProc. of 11. Denning, A. ActiveX Controls Inside Out. Microsoft Press, 1997. 12. Engler, D, Kaashoek, \nF, and O Toole, J. Exokernel. An Operating System Architecture for Application-Level Resource Management. \nProc. ACM  Symposium on Operating Systems Principles, Copper Mountain, CO, December 1995. 13. Etch.http://memsys.cs.washington.edu/memsyslhtml/ \netch.html.  14. Godfrey, M , Mayr, T, Seshadri P, and von Eicken, T. Secure and Portable Database Extensibility. \nProc. ACM SIGMOD International Conference on Management of Data, SIGMOD Record, v01 27, Issue 2, June \n1998. 15. Gong, L and Schemers, R. Implementing Protection Domains in the Java Development Kit 1.2. \nInternet Society Symposium on Network and Distributed System Security, San Diego, CA, March 1998. 16. \nGosling, J, Joy, B, and Steele, G. The Java language specification. Addison-Wesley, 1996. 17. Hastings, \nR and Joyce, B. PurzB: Fast Detection of Memory Leaks and Access Errors. Proc. Winter USENIX Conference, \nJanuary 1992. 18. Graham, S, Kessler, P and Marshall K. An Execution Prqjiler for Modular Programs. \nSoftware Practice and Experience, pages 671-685, vol 13, 1983. 19. Hicks, M, Kakkar, P, Moore, J, Gunter, \nC, and Nettles, S. PLAN: A Programming Language for Active Networks. Submitted to ACM SIGPLAN Conference \non Programming Language Design and Implementation, 1998.  20 Hawblitzel, C, Chang, C-C, Czajkowski, \nG, Hu, D, and von Eicken, T. Implementing Multiple Protection Domains in Java. In Proceedings of USENIX \nAnnual Conference, New Orleans, LA, June 1998. 21 Heiser, G, Lam, F and Russel, S. Resource Management \nin the Mungi Single-Address-Space Operating System. In Proceedings of the 21 Australasian Computer Science \nConference, Perth, Australia, February, 1998. 22 Jackson, J and McClelan, A. Java By Example. SunSoft \nPress, April 1996. 23. Java Web Server Home Page. http://jserv.javasoft.comlproducts/webserver/index.ht \nml. 24. Jigsaw Overview. http:l/www.w3c.orglJigsaw.  25 Larus, J and Ball, T. Rewriting Executable \nFiles to Measure Program Behavior. Software, Practice and Experience, ~0124, no. 2, February 1994 26 \nLarus, J and Schnarr, E. EEL: Machine-Indenepdent Executable Editing. Proc. SIGPLAN Conference on Programming \nLanguage Design and Implementation, June 1995. 28. Lindholm, T and Ycllin, F. The Java Virtual Machine \nSpecljication. Addison-Wesley, 1996. 29. Necula, G. ProqfX ur~ing (b&#38;. In Proceedings of the 24 \nh Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages. Paris, France, January \n1997. 30. Nilsen, K. Issues in the Design and lnll)lcmrrztution qf Reul-Time Java. Java Dcvelopcr s \nJournal, 1996, 31. Pendragon Software. Caffeine Mark 3.0. http:liwww.pcndragon-software.comipendragonicm3iindex.html. \n 32. Seltzer, M, Endo, Y, Small, C, and Smith. K. Dealing with Disuster: Surviving Misbehoved Kernel \nExtensions. Proceedings of the Second Symposium on Operating System Design and lmplcmentation, Seattle, \nWA, November 1996. 33. Sirer, E, Fiuczynski, M, and Pardyak, P. Writing an Opemting System with Modula-3. \nFirst Workshop on Compiler Support for System Software, Tucson, AZ, February 1996. 34. Smith, M. Tracing \nwith Pixie. Memo from Center for Integrated Systems, Stanford University, April 199 1.  3.5 Srivastava, \nA and Eustace, A. ATOM A System ,fi)t Building Customized Progrum Anulysis Tools. Proc. of the SIGPLAN \n94 Conference on Programming Language Design and Implementation, June 1994. 36. Srivastava, A and Wall, \nD. A Practical System ,f;lr Intermodule Code Optimization ut Link-Time. Journal of Programming Languages, \nvol 1, no 1, March 1993. 37. SunTest. JavaCC -Java Parser Generator. http:llwww.sun.com/suntest/JavaCC. \n 38. Wall, D. systems jbr Late Code modijicution. In Robert Giegcrich and Susan L. Graham, eds., Code \nGeneration -Concepts, Tools, Techniques, Springer- Verlag, 1992. 39. Wallach, D, Balfanz, D, Dean, D, \nand Fclten, E. Extensible Securily Architectures jbr Java 16 ACM Symposium on Operating Systems Principles, \np. 116-128, Saint-Malo, France. October 1997.  27. Lee, H and Zom, B. BIT: A Tool for Instrumenting \nJava Bytecodes. In Proceedings of the USENIX Symposium on Internet Technologies and Systems, Monterey, \nCA, December 1997.  \n\t\t\t", "proc_id": "286936", "abstract": "With the spread of the Internet the computing model on server systems is undergoing several important changes. Recent research ideas concerning dynamic operating system extensibility are finding their way into the commercial domain, resulting in designs of extensible databases and Web servers. In addition, both ordinary users and service providers must deal with untrusted downloadable executable code of unknown origin and intentions.Across the board, Java has emerged as the language of choice for Internet-oriented software. We argue that, in order to realize its full potential in applications dealing with untrusted code, Java needs a flexible resource accounting interface. The design and prototype implementation of such an interface --- JRes --- is presented in this paper. The interface allows to account for heap memory, CPU time, and network resources consumed by individual threads or groups of threads. JRes allows limits to be set on resources available to threads and it can invoke callbacks when these limits are exceeded. The JRes prototype described in this paper is implemented on top of standard Java virtual machines and requires only a small amount of native code.", "authors": [{"name": "Grzegorz Czajkowski", "author_profile_id": "81100400752", "affiliation": "Department of Computer Science, Cornell University, Ithaca, NY", "person_id": "P100088", "email_address": "", "orcid_id": ""}, {"name": "Thorsten von Eicken", "author_profile_id": "81100057880", "affiliation": "Department of Computer Science, Cornell University, Ithaca, NY", "person_id": "P281990", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/286936.286944", "year": "1998", "article_id": "286944", "conference": "OOPSLA", "title": "JRes: a resource accounting interface for Java", "url": "http://dl.acm.org/citation.cfm?id=286944"}