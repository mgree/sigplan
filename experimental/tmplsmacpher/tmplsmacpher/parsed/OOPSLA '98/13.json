{"article_publication_date": "10-01-1998", "fulltext": "\n The New Crop of JavaTM Virtual Machines Lars Bak John Duimovich Jesse Fang Sun Microsystems Inc. Object \nTechnology MicroComputer Research Labs Java Software International Inc. Intel Corp MS UCUP 02-302 2670 \nQueensview Drive RN6-35 2525 Mariani Ave. Ottawa, Ontario 2200 Mission College Blvd. Cupertino, CA 95014 \nCanada K2B 8Kl Santa Clara, CA 95052-8 119 (408) 863-3 115 (613) 820-1201 ext 251 (408)765-587 1 lars.bak@sun.com \nJohn-Duimovich@oti.com jfang@gomez.sc.intel.com Scott Meyer Oracle Corporation 500 Oracle Parkway Box \n659409 Redwood Shores, CA 94065 (650) 506-0987 smeyer@us.oracle.com INTRODUCTION David Ungar I want to \nuse the Java Programming Language. But, will the new Java Viial Machines be any good? And how will they \ndo it, anyway? After all. although the Java language simpli- fies my task as a programmer, it complicates \nthe task of the implementors. Features like objects, garbage collection, exceptions, native methods, \nmultithreading, portable byte- codes can be hard to implement well. Tbispanelwill bring together the \ncreators (not the managers or the marketers) of next-generation JVMs from Intel. Ora- cle, OTVIBM, and \nSun. There, each will explain how his system is unique, why each path was chosen and how suc- cessfnl \neach system has been in achieving its goals, Then, we wiIl give the audience a chance to goad the panelists \ninto a bit of friendly debate. when the smoke clears, we will have reconnoitered some of the unknown \nterritory of the new Java Virtual Machines. SUN S HO-I-SPOT JAVA VlFiTUAL MACHINE Lars Bak Java HotSpotTM \nis the next-generation Java virtual machine from Sun Microsystems Inc. It achieves fast startup and high \nperformance by combii on-the-fly adaptive optimi- zations, fast thread synchronization, and generational \ngar- David Ungar (moderator) Sun Microsystems Laboratories MS MTV 29- 117 901 San Antonio Rd. Palo Alto, \nCA 94303 (650) 336-2618 david.ungar@sun.com bage collection. The Java HotSpot virtual machine is designed \nfor systems ranging from network computers up to SMP semers. The system is scheduled for release at the \nend of 1998. We believe this strategy gives us a very flexible Java virtual machine that provides better \nperformance than systems rely- ing on static or JIT compilation for the following reasons: . Hot spot \ndetection: The system profiles tbe executing program and only triggers compilation on perfor- mance-critical \nmethods. This selective compilation gives the compiler more time to generate better code. l Aggressive \nmethod inlining: The system uses the gathered protile information to predict which metb- ads should be \ninlined. If the predictions fail. com- piled code is removed and the methods are recompiled. The component \nlist for HotSpot: l Fast interpreter. l SSA-based optimizing compiler. l Dynamic deoptimization (converting \ncompiled frames into interpreted frames). . Accurate, incremental generational garbage collec- tor. l \nFast block-structumd synchronization. At the panel session, we will give a live demonstration of HotSpot \ns performance and responsiveness. In addition, we will validate our claims by presenting an extensive \nset of benchmark numbers. Adaptive optimizations rock! OTI S VISUALAGE FOR JAVA VIRTUAL MACHINE John \nDuimovich The VisualAge for Java Vial Machine is designed to host au integrated development environment \n(IDE) with an incremental compiler, integrated debugger, visual builder tools and team support. The key \ngoals for our virtual machine are: 1. Full JDK compatibility 2. Support advanced IDE features (hot method \nreplace- ment, multiple virtual machines, shared class files, debugger support).  The issues: 1. Full \nJDK compatibility. The IDE is used by develop- ers who will run their programs on many diverse tar- gets \n(other virtual machines, other platforms). The challenge here is defining what compatibility means (i.e. \nis JCK compliance good enough?) or whether bug compatible is required also. 2. Multiple Virtual Machines \nexecuting in a single address space. This feature allows development of cli- ent/server type applications \nwhere the developer can debug both sides of an application from a single IDE. We also use this feature \nto execute some of the tools (including third party tools) in the IDE which execute as individual Java \nprograms. This feature costs some performance due to indirections (for stat- ics) and for class initialization \nguards. 3. Class files shared between separate JVMs. The class loader used by the IDE, understands how \nto find and share the classes being developed within the IDE. The code for these classes are shared between \nmultiple virtual machines. This saves memory by sharing com- mon code (including JIT code) and also allows \na sim- pler implementation for features like method replacement. 4. Incremental method and class replacement \nin active/ running virtual machines. The virtual machine sup- ports individual method replacement in \na class even when the class has been initialized and the code is executing in a virtual machine. At the \nvirtual machine level, this means that the JJT requires the ability to flush cached information and code \nwhen notified of method changes by the class loader.  5. Interactive Debugger support for: a) debugging \nmultiple virtual machines from a single debugger b) code snippet execution in the context of the debugged \nthread c) hot fix method replacement d) friendly exception handling. 6. Other implementation details: \na> Garbage collection is Generation Scavenger for new objects and mark/sweep/compact for full gar- bage \ncollection. b> Execution is mixed interpreted and JIT code with JlT being used for frequently called \ncode. INTECS JAVA VIRTUAL MACHINE Jesse Fang The Java language is designed to be platform independent, \nbut Java Virtual Machine implementation depends on hard- ware platform with respect to the performance. \nCompiler and software tool research group at Intel MicroComputer Research Lab focuses on the JVM machine-dependent \nimplementation issues and study the architectme/microar- chitecture features on Intel hardware. The goals \nof Intel JVM project are: 1. Make JVM implementation with the best performance on Intel architecture \n 2. Focus on special issues in JVM implementation for different market segments such as small footprint \nfor low-end and scalability for SMF server 3. The JVM is OS-independent  Some interesting areas in \nour research are listed below as examples: 1. Optimal Java language stack frame implementation on Intel \narchitecture 2. Best iA instruction sequences for synchronization such as monitor-entry and monitor-exit \n 3. Best implementation for various garbage collection especially incremental generational GC and write \nbar- rier 4. Hardware support for dynamic optimization JJT or Java compiler  What we found is that \nthe performance of JVM can be improved siguificantly if it takes full advantage of hardware architecture/microarchirchitecture \nfeatures. We would like to share the experience with you in the panel discussion. ORACLE S AUFIORA JAVA \nVIRTUAL MACHINE Scott Meyer Oracle s Aurora project is a Java Virtual Machine which is designed to be \nembedded in the RDBMS, in the same address space used to execute SQL queries so that Java code can call \nSQL and SQL can call Java code with no system IO or synchronization overhead. The Aurora project VM is \nscheduled to ship with Oracle 8.1. At the VM level, the goals of the Aurora project are: 1. Extreme scalability: \nTens of thousands of simulta- neous users rumring on a single database instance. 2. Tight integration \nwith the existing RDBMS engine so that Java becomes a first-class citizen in the RDBMS 3. Transparency: \nJava code must run the same on client and server. 4. Portability: The RDBMS is currently ported to some \n60 platforms 5. Safety: Programs running in the BDBMS can t dead- lock or crash.  The salient details \nof our implementation are: 1. A clean embedding interface that defmes the interac- tion between the environment \n(the KDBMS) and the Aurora VM . 2. A memory manager optimized for throughput and compliant with the \nexisting memory hierarchy (call, session, global) of the RDBMS. Java language static class variables \nare given session duration. At the end of an RDBMS call, the transitive closure of objects referenced \nby static variables are moved into session space so that they will be available to the next call. 3. \nA low-level meta-object system which abstracts out things like field alignments and pointers so that \nthe same object may be given different in-memory repre- sentations at the same time. The low-level meta-object \nsystem is built by a Scheme code generator rather than hand-coded. 4. A class loader which uses shared \nmemory to store all immutable class data (everything but static variables). Classes may be shared by \nthe entire database instance. 5. A Java class-to-C compiler instead of a JIT. Compila- tion through \nC appeared to be the only way to satisfy both the portability and performance constraints that we have. \n 6. Polled threading (only one thread at a time runs) which uses native threads and asynchronous IO (if \navailable). This approach yields portable thread  semantics. Our thread implementation is really just \nfor JDK compatibility. In practice we expect users to use the RDBMS as a service loop rather than coding \nservers using Java language threads. The RDBMS server loop has demonstrated scalability roughly two orders \nof magnitude greater (50,000 users) than any Java-thread based architecture that we know of. 7. Deadlock \nand limbo detection. CONCLUSION David Ungar Bach of these new Java Vial Machines follows its own path \nto Java Nirvana. Sun s and Intel s both soup-up perfor- mance, one by adaptive optimization, the other \nby a close coupling to the underlying architecture. Which works bet- ter? OTI s virtual machine caters \nto the programmer, provid- ing features designed to slash application development time. How much time \ndoes it save when, for example, changing a method compared to the other virtual machines? How much performance \n(if any) does it sacrifice for its advanced IDE support? Oracle s system melds Java programs to its data- \nbase. Jntemstingly, it eschews a JlT in favor of compilation to C. Do compiled programs run faster than \nin the other vir- tual machines? How long does it take to alter a method if it has to be recompiled to \nC? Thanks to our panelists talents and efforts, we will have a rare chance to travel four paths at once \nand compare the journeys. We have been promised at least one live demo and perhaps others will be possible, \ntoo. Our panel presents the opportu- nity for a rare form of audience participation: if any attend- ees \nwould like to challenge our panelists JavaTM Virtual Machines with their own test programs or benchmarks, \nplease contact me. If your program nms quickly, perhaps we can arrange a live test. If not, perhaps we \ncau nm them in advance and report on the results. I cannot promise any- thing-1 do not know if our panelists \nwill be able to accom- modate-but let s give it a try. THE PANELISTS Lam Bak received the MS degree in \ncomputer science from Aarhus University in 1988. As one of the founders of Mjolner Informatics, he partici- \npated in the design and implementation of the Beta MjSmer system. In 1991, he joined the Self group at \nSun Microsys- tems Laboratories. During his time there, he developed a programming environment for Self \nand added several enhancements to the virtual machine. In 1994, he joined Longview Technologies LLC, \nwhere he designed and implemented high performance virtual machines for both Smalltalk and the Java language. \nLong- view was acquired by Sun Microsystems, Inc. in 1997. Lars is presently Senior Staff Engineer at \nSun Microsystems Inc. where he is technical lead in the HotSpot group. John Duimovich, BSc McGill University, \nMCS Carleton University, is the CT0 of Object Technology International, and heads the VM team at CHJ \nfor both Smalltalk and Java Vi Machines used in IBM s VisualAge family of prod- ucts. Research interests \ninch&#38;. garbage collection and multiprocessor systems. JesseFang is manager of compiler and software \ntools research group at Intel s MicroComputer Research Labs. Before join Intel, he was working at Hewlett-Packard \nLabo- ratories. Before that, he was working at Convex Computer Corp. and Concurrent Computer Corp. His \nresearch inter- ests include computer architecture, compilers and system software design. Fang received \na Ph.D in computer science from the University of Nebraska, Lincoln. Scott Meyer, Principle Member of \nTechnical St&#38;, has been part of the Aurora project since the beginning and was responsible for the \nInterpreter, threading and exceptions, call-in (from SQL), and code generation machinery. David Ungar \ndeveloped Generation Scavenging, designed and evaluated a RISC architecture for Smalltalk. and co-led \nthe Self project, which created a language design. imple- mentation, programmin g environment, and user \ninterface a prototype-based pure object-oriented language. His current interests include analytical modeling \nof adaptive compila- tion and preemptive debugging for complex virtual machines. He holds a Ph.D. in \ncomputer science from UC Berkeley, has taught at Stanford University, and presently works at Sun Microsystems, \nInc. \n\t\t\t", "proc_id": "286936", "abstract": "", "authors": [{"name": "Lars Bak", "author_profile_id": "81100301673", "affiliation": "Sun Microsystems Inc. Java Software, MS UCUP 02-302, 2525 Mariani Ave., Cupetino, CA", "person_id": "PP311296900", "email_address": "", "orcid_id": ""}, {"name": "John Duimovich", "author_profile_id": "81100404195", "affiliation": "Object Technology, International Inc., 2670 Queensview Drive, Ottawa, Ontario, Canada K2B 8K1", "person_id": "P143632", "email_address": "", "orcid_id": ""}, {"name": "Jesse Fang", "author_profile_id": "81100350392", "affiliation": "MicroComputer Research Labs, Intel Corp, RN6-352200 Mission College Blvd., Santa Clara, CA", "person_id": "PP14125497", "email_address": "", "orcid_id": ""}, {"name": "Scott Meyer", "author_profile_id": "81538077856", "affiliation": "Oracle Corporation, 500 Oracle Parkway, Box 659409, Redwood Shores, CA", "person_id": "P261022", "email_address": "", "orcid_id": ""}, {"name": "David Ungar", "author_profile_id": "81100365263", "affiliation": "Sun Microsystems Laboratories, MS MTV 29-117, 901 San Antonio Rd., Palo Alto, CA", "person_id": "P64183", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/286936.286956", "year": "1998", "article_id": "286956", "conference": "OOPSLA", "title": "The new crop of Java virtual machines (panel)", "url": "http://dl.acm.org/citation.cfm?id=286956"}