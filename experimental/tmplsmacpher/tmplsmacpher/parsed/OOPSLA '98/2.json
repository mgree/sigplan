{"article_publication_date": "10-01-1998", "fulltext": "\n Dynamic Class Loading in the JavaTM Virtual Machine Sheng Liang Gilad Bracha Sun Microsystems Inc. \n901 San Antonio Road, CUPO2-302 Palo Alto, CA 94303 {sheng.liang,gilad.bracha}@eng.sun.com Abstract \nClass loaders are a powerful mechanism for dynamically loading software components on the Java platform. \nThey are unusual in supporting all of the following features: laziness, type-q? linkage, user-defined \nextensibility, and multiple communicating namespaces. We present the notion of class loaders and demonstrate \nsome of their interesting uses. In addition, we discuss how to maintain type safety in the presence of \nuser-defined dynamic class loading. 1 Introduction In this paper, we investigate an important feature \nof the Java virtual machine: dynamic class loading. This is the underlying mechanism that provides much \nof the power of the Java platform: the ability to install software components at nmtime. An example of \na component is an applet that is downloaded into a web browser. While many other systems 1161 1131 also \nsupport some form of dynamic loading and linking, the Java platform is the only system we know of that \nincorporates all of the following features: 1. Lazy loading. Classes are loaded on demand. Class loading \nis delayed as long as possible, reducing mem-ory usage and improving system response time. 2. Type-s@ \nlinkage. Dynamic class loading must not violate the type safety of the Java virtual machine. Dynamic \nloading must not require additional run-time checks in order to guarantee type safety. Additional link-time \nchecks are acceptable, because these checks are performed only once. 3. User-denable class loading policy. \nClass loaders are first- class objects. Programmers have complete control of dynamic class loading. A \nuser-defined class loader can,  Permossmn to make dlgital or hard copses 01 all or parf of this work \nfor personal or classroom use IS granted wthout lee prouded that copies are not made or distributed for \nprofIt or commercial advan- tage and that coptes bear this notIce and the full cltatlo 0 the first page \nlo copy otherwise, to republtsh. to post on Servers or to redlstnbute to hsts. requres pnor spec111c \npermlss~o and/or a fee OOPSLA 98 lo/98 Vancouver, B.C. B 1998 ACM 1.58113.005.9/98/0010...55.00 for \nexample, specify the remote location from which the classes are loaded, or assign appropriate security \nattributes to classes loaded from a particular source. 4. Multiple namespaces. Class loaders provide \nseparate namespaces for different software components. For example, the HotjavaTM browser loads applets \nfrom different sources into separate class loaders. These applets may contain classes of the same name, \nbut the classes are treated as distinct types by the Java virtual machine. In contrast, existing dynamic \nlinking mechanisms do not support all of these features. Although most operating systems support some \nform of dynamic linked libraries, such mechanisms are targeted toward C/C++ code, and are not type-safe. \nDynamic languages such as Lisp 1131, Smalltalk [6], and Self [21] achieve type safety through additional \nrun-time checks, not link-time checks. The main contribution of this paper is to provide the first in-depth \ndescription of class loaders, a novel concept introduced by the Java platform. Class loaders existed \nin the first version of the Java Development Kit (JDK 1.0). The original purpose was to enable applet \nclass loading in the Hotjava browser. Since that time, the use of class loaders has been extended to \nhandle a wider range of software components such as server-side components (servlets) [ll], extensions \n[lo] to the Java platform, and JavaBeans [8] components. Despite the increasingly important role of class \nloaders, the underlying mechanism has not been adequately described in the literature. A further contribution \nof this paper is to present a solution to the long-standing type safety problem [20] with class loaders. \nEarly versions (1.0 and 1.1) of the JDK contained a serious flaw in class loader implementation. Improperly \nwritten class loaders could defeat the type safety guarantee of the Java virtual machine. Note that the \ntype safety problem did not impose any immediate security risks, because untrusted code (such as a downloaded \napplet) was not allowed to create class loaders. Nonetheless, application programmers who had the need \nto write custom class loaders could compromise type safety inadvertently. Although the issue had been \nknown for some time, it remained an open problem in the research community whether a satisfactory solution \nexists. For example, earlier discussions centered around whether the lack of type safety was a fundamental \nlimitation of user-definable class loaders, and whether we would have to limit the power of class loaders, \ngive up lazy class loading, or introduce additional dynamic type-checking at runtime. The solution we \npresent in this paper, which has been implemented in JDK 1.2, solves the type safety problem while preserving \nall of the other desirable features of class loaders. We assume the reader has basic knowledge of the \nJava programming language [71. The remainder of this paper is organized as follows: We first give a more \ndetailed introduction to class loaders. Applications of class loaders are discussed in section 3. Section \n4 describes the type safety problems that may arise due to the use of class loaders, and their solutions. \nSection 5 relates our work to other research. Finally, we present our conclusions in section 6. class \nClassLoader { public Class loadClass(String name); protected final Class defineClass(String name, byten \nbuf, int off, int len); protected final Class findLoadedClass(String name); protected final Class findSystemClass(String \nname); Figure 1: The ClassLoader class Applet class loaders Application class loader T , / \\ 2 Class \nLoaders The purpose of class loaders is to support dynamic loading of software components on the Java \nplatform. The unit of software distribution is a class!. Classes are distributed us-ing a machine-independent, \nstandard, binary representation known as the classfileformat [15]. The representation of an individual \nclass is referred to as a class FZe. Class files are produced by Java compilers, and can be loaded into \nany Java virtual machine. A class file does not have to be stored in an actual file; it could be stored \nin a memory buffer, or obtained from a network stream. The Java virtual machine executes the byte code \nstored in class files. Byte code sequences, however, are only part of what the virtual machine needs \nto execute a program. A class file also contains symbolic references to fields, methods, and names of \nother classes. Consider, for example, a class C declared as follows: class C { void f() { D d = new DO; \n 1 1  The class file representing C contains a symbolic reference to class D. Symbolic references are \nresolvedat link time to actual class types. Class types are reified first-class objects in the Java virtual \nmachine. A class type is represented in user code as an object of class java.lang.Class. In order to \nresolve a symbolic reference to a class, the Java virtual machine must load the class file and create \nthe class type. 2.1 Overview of Class Loading The Java virtual machine uses class loaders to load class \nfiles and create class objects. Class loaders are ordinary objects that can be defined in Java code. \nThey are instances of subclasses of the class ClassLoader, shown in Figure 1. Throughout this paper, \nwe use the term class generically to denote both classes and interfaces . System classes System class \nloader (e.g., java.lang.String) Figure 2: Class loaders in a web browser We have omitted the methods \nthat are not directly relevant to this presentation. The ClassLoader.loadClass method takes a class name \nas argument, and returns a Class object that is the run-time representation of a class type. The methods \ndefineclass, findLoadedClass and findSystemClass will be described later. In the above example, assume \nthat C is loaded by the class loader L. L is referred to as C s defining loader. The Java virtual machine \nwill use L to load classes referenced by C. Before the virtual machine allocates an object of class D, \nit must resolve the reference to D. If D has not yet been loaded, the virtual machine will invoke the \nloadClass method of C s class loader, L, to load D: L.loadClass( D ) Once D has been loaded, the virtual \nmachine can resolve the reference and create an object of class D. 2.2 Multiple Class Loaders A Java \napplication may use several different kinds of class loaders to manage various software components. For \nexam- ple, Figure 2 shows how a web browser written in Java may use class loaders. This example illustrates \nthe use of two types of class loaders: user-defined class loaders and the system class loader supplied \nby the Java virtual machine. User-defined class loaders can be used to create classes that originate \nfrom user-defined sources. For example, the browser application We use the notation X.m to refer to an \ninstance method m defined in class X, although this is not legal syntax in the Java programming language. \ncreates class loaders for downloaded applets. We use a separate class loader for the web browser application \nitself. All system classes (such as java.lang.String) are loaded into the system class loader. The system \nclass loader is supported directly by the Java virtual machine. The arrows in the figure indicate the \ndelegationrelation-ship between class loaders. A class loader Lr can ask another loader I17 to load a \nclass C on its behalf. In such a case, L1 delegates C to /,>. For example, applet and application class \nloaders delegate all system classes to the system class loader. As a result, all system classes are shared \namong the applets and the application. This is desirable because type safety would be violated if, for \nexample, applet and system code had a different notion of what the type java.lang.String was. Delegating \nclass loaders allow us to maintain namespace separation while still sharing a common set of classes. \nIn the Java virtual machine, a class type is uniquely determined by the combination of the class name \nand class loader. Applet and application class loaders delegate to the system class loader. This guarantees \nthat all system class types, such as java.lang String, are unique. On the other hand, a class named C \nloaded in applet 1 is considered a different type from a class named C in applet 2. Although these two \nclasses have? the same name, they are defined by different class loaders. In fact, these two classes \ncan be completely unrelated. For example, they may have different methods or fields. Classes from one \napplet cannot interfere with classes in another, because applets are loaded in separate class load- ers. \nThis is crucial in guaranteeing Java platform security. Likewise, because the browser resides in a separate \nclass loader, applets cannot access the classes used to implement the browser. Applets are only allowed \nto access the standard Java API exposed in the system classes. The Java virtual machine starts up by \ncreating the appli- cation class loader and using it to load the initial browser class. Application execution \nstarts in the public class method void main(String[]) of the initial class. The invocation of this method \ndrives all further execution. Execution of instruc- tions may cause loading of additional classes. In \nthis application, the browser also creates additional class loaders for downloaded applets. The garbage \ncollector unloads applet classes that are no longer referenced. Each class object contains a reference \nto its defining loader; each class loader refers to all the classes it defines. This means that, from \nthe garbage collector s point of view, classes are strongly connected with their defining loader. Classes \nare unloaded when their defining loader is garbage-collected.  2.3 An Example We now walk through the \nimplementation of a simple class loader. As noted earlier, all user-defined class loader classes are \nsubclasses of ClassLoader. Subclasses of ClassLoader can override the definition of loadClass, thus providing \na user- defined loading policy. Here is a class loader that looks up classes in a given directory: class \nMyClassLoader extends ClassLoader { private directory; public MyClassLoader(String dir) { directory = \ndir; 1 public synchronized Class loadClass(String name) { Class c = findLoadedClass(name); if (c != \nnull) return c; try { c = findSystemClass(name); return c; } catch (ClassNotFoundException e) { // keep \nlooking byte0 data = getClassData(directory, name); return defineClass(name, data, 0, data.length()); \n} catch (IOException e) { throw new ClassNotFoundException(); byte0 getClassData( . ..) { . . } // omitted \nfor brevity > The public constructor MyClassLoader() simply records the directory name. In the definition \nof loadclass, we use the findLoadedClass method to check whether the class has already been loaded. (Section \n4.1 will give a more precise de-scription of the findLoadedClass method.) If findLoadedClass returns \nn uI I, the class has not yet been loaded. We then dele- gate to the system class loader by calling findSystemC1as.s. \nIf the class we are trying to load is not a system class, we call a helper method getClassData to read \nin the class file. After we have read in the class file, we pass it to the defineclass method. The defineclass \nmethod constructs the run-time representation of the class from the class file. Note that the loadClass \nmethod synchronizes on the class loader object so that multiple threads may not load the same class at \nthe same time. 2.4 A Class s Initiating and Defining Loaders When one class loader delegates to another \nclass loader, the class loader that initiates the loading is not necessarily the same loader that completes \nthe loading and defines the class. Consider the following code segment: MyClassLoader cl = new MyClassLoader( \n/foe/bar ); Class stringclass = cl.loadClass( java.lang.String ); Instances of the MyClassLoader class \ndelegate the load-ing of java.lang.String to the system loader. Consequently, java.lang.String is defined \nby the system loader, even though loading was initiated by cl. Definition 2.1 Let C be the result 4 L.defineClass(). \nL is the defining loader OfC, or equivalently, L defines C. Definition 2.2 Let C be the result @ L.loadClass(). \nL is an initiating loader qf C, or equivalently, L initiates loading of C. old ..+Zi--] Server c3 *<fk- \nFigure 3: Class Server redirects to a new version of Service class In the Java virtual machine, every \nclass C is permanently associated with its defining loader. It is C s defining loader that initiates \nthe loading of any class referenced by C. 3 Applications of Class Loaders In this section, we give a \nfew examples that demonstrate the power of class loaders. 3.1 Reloading Classes It is often desirable \nto upgrade software components in a long-running application such as a server. The upgrade must not require \nthe application to shut down and restart. On the Java platform, this ability translates to reloading \na subset of the classes already loaded in a running virtual machine. It corresponds to the schema evolution \n[3] problem, which could be rather difficult to solve in general. Here are some of the difficulties: \nl There may be live objects that are instances of a class we want to reload. These objects must be migrated \nto conform to the schema of the new class. For example, if the new version of the class contains a different \nset of instance fields, we must somehow map the existing set of instance field values to fields in the \nnew version of the class. Similarly, we may have to map the static field values to a different set of \nstatic fields in the reloaded version of the class. The application may be executing a method that be-longs \nto a class we want to reload. We do not address these problems in this paper. Instead, we show how it \nis sometimes possible to bypass them using class loaders. By organizing software components in separate \nclass loaders, programmers can often avoid dealing with schema evolution. Instead, new classes are loaded \nby a separate loader. Figure 3 illustrates how a Server class can dynamically redirect the service requests \nto a new version of the Service class. The key technique is to load the server class, old service class, \nand new service class into separate class loaders. For example, we can define Server using the MyClassLoader \nclass introduced in the last section. class Server { private Object service; public void updateService(String \nlocation) { MyClassLoader cl = new MyClassLoader(location); Class c = cl.loadClass( Service ); service \n= c.newlnstance(); 1 publicvoid processRequest (...) { Class c = service.getClass(); Method m = c.getMethod( \nrun , . ..). m.invoke(service, . ..). 1 1 The Server.processRequest method redirects all incoming requests \nto a Service object stored in a private field. It uses the Java Core Reflection API [9] to invoke the \nrun method on the service object. In addition, the Server.updateService method allows a new version of \nthe Service class to be dynamically loaded, replacing the existing service object. Callers of updateservice \nsupply the the location of the new class files. Further requests will be redirected to the new object \nreferenced to by service. To make reloading possible, the Server class must not directly refer to the \nService class: class Server { private Service service; // This is wrong! public void updateService(String \nlocation) { MyClassLoader cl = new MyClassLoader(location); Class c = cl.loadClass( Service ); service \n= (Service)c.newlnstance(); > > Once the Server class resolves the symbolic reference to a Service \nclass, it will contain a hard link to that class type. An already-resolved reference cannot be changed. \nThe type conversion in the last line of the Server.updateService method will fail for new versions of \nService returned from the class loader. Reflection allows the Server class to use the Service class without \na direct reference. Alternatively, Server and Service classes can share a common interface or superclass: \nclass Server { private Servicelnterface service; // use an interface public void updateService(String \nlocation) { MyClassLoader cl = new MyClassLoader(location); Class c = cl.loadClass( Service ); service \n= (Servicelnterface)c.newlnstance(); I public void processRequest (,..) { service.run(...); 1 1 Dispatching \nthrough an interface is typically more effi-cient than reflection. The interface type itself must not \nbe reloaded, because the Server class can refer to only one Ser-vicelnterface type. The getServiceClass \nmethod must return a class that implements the same Servicelnterface every time. After we call the updateservice \nmethod, all future requests will be processed by the new Service class. The old Service class, however, \nmay not have finished processing some of the earlier requests. Thus two Service classes may coexist for \na while, until all uses of the old class are complete, all references to the old class are dropped, and \nthe old class is unloaded.  3.2 Instrumenting Class Files A class loader can instrument the class file \nbefore making the defineclass call. For example, in the MyClassLoader example, we can insert a call to \nchange the contents of the class file: class MyClassLoader extends ClassLoader { public synchronized \nClass loadClass(String name) { byten data = getClassData(directory, name); bytea newdata = instrumentClassFile(data); \nreturn defineClass(name, newdata, 0, newdata.length()); An instrumented class file must be valid according \nto the Java virtual machine specification 1151. The virtual machine will apply all the usual checks (such \nas running the byte code verifier) to the instrumented class file. As long as the class file format is \nobeyed, the programmer has a great deal of freedom in modifying the class file. For example, the instrumented \nclass file may contain new byte code instructions in existing methods, new fields, or new methods. It \nis also possible to delete existing methods, but the resulting class file might not link with other classes. \nThe instrumented class file must define a class of the same name as the original class file. The loadClass \nmethod should return a class object whose name matches the name passed in as the argument. (Section 4.1 \nexplains how this rule is enforced by the virtual machine.) A class loader can only instrument the classes \nit defines, not the classes delegated to other loaders. All user-defined class loaders should first delegate \nto the system class loader, thus system classes cannot be instrumented through class loaders. User-defined \nclass loaders cannot bypass this re-striction by trying to define system classes themselves. If, for \nexample, a class loader defines its own String class, it cannot pass an object of that class to a Java \nAPI that expects a standard String object. The virtual machine will catch and report these type errors \n(see section 4 for details). Class file instrumentation is useful in many circum-stances. For example, \nan instrumented class file may contain profiling hooks that count how many times a certain method is \nexecuted. Resource allocation may be monitored and controlled by substituting references to certain classes \nwith references to resource-conscious versions of those classes 1191. A class loader may be used to implement \nparameter-ized classes, expanding and tailoring the code in a class file for each distinct invocation \nof a parametric type [l]. 4 Maintaining Type-safe Linkage The examples presented so far have demonstrated \nthe use-fulness of multiple delegating class loaders. As we will see, however, ensuring type-safe linkage \nin the presence of class loaders requires special care. The Java programming language relies on name-based \nstatic typing. At compile time, each static class type corresponds to a class name. At runtime, class \nloaders introduce multiple namespaces. A run-time class type is determined not by its name alone, but \nby a pair: its class name and its defining class loader. Hence, namespaces introduced by user-defined \nclass loaders may be inconsistent with the namespace managed by the Java compiler, jeopardizing type \nsafety. 4.1 Temporal Namespace Consistency The loadclass method may return different class types for \na given name at different times. To maintain type safety, the virtual machine must be able to consistently \nobtain the same class type for a given class name and loader. Consider, for example, the two references \nto class X in the following code: class C { void f(X x) { } void g() { f(new X0); ) >  If C s class \nloader were to map the two occurrences of X into different class types, the type safety of the method \ncall to f inside g would be compromised. The virtual machine cannot trust any user-defined load-Class \nmethod to consistently return the same type for a given name. Instead, it internally maintains a loaded \nclass cache. The loaded class cache maps class names and initiating loaders to class types. After the \nvirtual machine obtains a class from the loadclass method, it performs the following operations: The \nreal name of the class is checked against the name passed to the loadClass method. An error is raised \nif loadClass returns a class that does not have the requested name. If the name matches, the resulting \nclass is cached in the loaded class cache. The virtual machine never invokes the loadClass method with \nthe same name on the same class loader more than once. The ClassLoader.findLoadedClass method introduced \nin section 2 performs a lookup in the loaded class cache. 4.2 Namespace Consistency among Delegating \nLoaders We now describe the type safety problems that can arise with delegating class loaders. The problem \nhas been known for some time. The first published account was given by Vijay Saraswat 1201. Notation \n4.1 We will represent a class type using the notation (C, Ld)L , where C denotes the name qf the class, \nLd denotes the class s d@ning loader, and Li denotes the loader that initiated class loading. When we \ndo not care about the defining loader, we use a simplrjied notation CL to denote that Li is the initiating \nloader of C. When we do not care about the initiating loader, we use the simplfied notation (C, Ld) to \ndenote that C is defined by Ld. Note that if L1 delegates C to Lz, then CL1 = CL2. We will now give an \nexample that demonstrates the type safety problem. In order to make clear which class loaders are involved, \nwe use the above notation where class names would ordinarily appear, class (C, L1) { void f() { (Spoofed, \nLI)~~ x = (Delegated, L~)~l.g(); 1 1 class (Delegated, Lz) { (Spoofed, 152)~~ g() { } 1 C is defined \nby L1. As a result, L1 is used to initiate the loading of the classes Spoofed and Delegated referenced \ninside C.f. 1,1 defines Spoofed. However, L1 delegates the loading of Delegated to Lz, which then defines \nDelegated. Because Delegated is defined by Lz, De1egated.g will use Lz to initiate the loading of Spoofed. \nAs it happens, Lz defines a different type Spoofed. C expects an instance of (Spoofed, L1 ) to be returned \nby De1egated.g. However, De1egated.g actually returns an instance of (Spoofed, Ll), which is a completely \ndifferent class. This is an inconsistency between the namespaces of L1 and Lz. If this inconsistency \ngoes undetected, it allows one type to be forged as another type using delegating class loaders. To see \na how this type safety problem can lead to undesirable behaviors, suppose the two versions of Spoofed \nare defined as follows: class (Spoofed, LI) { public int secret-value; public into forged-pointer; I \nclass (Spoofed, L-J) ( private int secret-value; private int forged-pointer; ) Class (C, L1) is now \nable to reveal a private field of an instance of (Spoofed, L2) and forge a pointer from an integer value: \nclass (C, L1) { void f() { (Spoofed, LI)~ x = (Delegated, Lz)~ .g(); System.out.println( secret value \n= + x.secret-value); System.out.println( stolen content = + x.forged-pointer[O]); 1 1 Wecanaccesstheprivatefieldsecret-valueina \n(Spoofed, 15~) instance because the field is declared to be public in (Spoofed,L~). We are also able \nto forge an integer field in the (Spoofed, Lp) instance as an integer array, and deref-erence a pointer \nthat is forged from the integer. The underlying cause of the type-safety problem was the virtual machine \ns failure to take into account that a class type is determined by both the class name and the defining \nloader. Instead, the virtual machine relied on the Java programming language notion of using class names \nalone as types during type checking. The problem has since been corrected, as described below. 4.2.1 \nSolution A straightforward solution to the type-safety problem is to uniformly use both the class s name \nand its defining loader to represent a class type in the Java virtual machine. The only way to determine \nthe defining loader, however, is to actually load the class through the initiating loader. In the example \nin the previous section, before we can determine whether C.f s call to De1egated.g is type-safe, we must \nfirst load Spoofed in both L1 and Lz, and see whether we obtain the same defining loader. The shortcoming \nof this approach is that it sacrifices lazy class loading. Our solution preserves the type safety of \nthe straightfor- ward approach, but avoids eager class loading. The key idea is to maintain a set of \nloader constraints that are dynamically updated as class loading takes place. In the above example, instead \nof loading Spoofed in L1 and Lz, we simply record a constraint that Spoofed 1 = SpoofedL2. If Spoofed \nis later loaded by L, or L%,we will need to verify that the existing set of loader constraints will not \nbe violated. What if the constraint SpoofedL1 = SpoofedL2 is intro- duced after Spoofed is loaded by \nboth L1 and Lz? It is too late to impose the constraint and undo previous class loading. We must therefore \ntake both the loaded class cache and loader constraint set into account at the same time, We need to \nmaintain the invariant: Each entry in the loaded class cache satisfies all the loader constraints. The \ninvariant is maintained as follows: Every time a new entry is about to be added to the loaded class cache, \nwe verify that none of the existing loader constraints will be violated. If the new entry cannot be added \nto the loaded class cache without violating one of the existing loader constraints, class loading fails. \nEvery time a new loader constraint is added, we verify that all loaded classes in the cache satisfy the \nnew constraint. If a new loader constraint cannot be satisfied by all loaded classes, the operation that \ntriggered the addition of the new loader constraint fails. Let us see how these checks can be applied \nto the previous example. The first line of the C.f method causes the virtual machine to generate the \nconstraint SpoofedL1 = SpoofedL2. If L1 and L2 have already loaded the Spoofed class when we generate \nthis constraint, an exception will immediately be raised in the program. Otherwise, the constraint will \nbe suc- cessfully recorded. Assuming De1egated.g loads SpoofedL2 first, an exception will be raised when \nC.f tries to load SpoofedL1 later on. 4.2.2 Constraint Rules We now state the rules for generating constraints. \nThese correspond to situations when one class type may be referred to by another class. When two such \nclasses are defined in different loaders, there are opportunities for inconsistencies across namespaces. \nl If (C, L1) references a field: T fieldname; declared in class (0, Lz), then we generate the con-straint: \nTL =TL2 . If (C, L1) references a method: To methodname(TI , . . . , Tn); declared in class (D, Lz), \nthen we generate the con straints: TL =TL2o ,...,Tfi =TkZ. 0 l If (C, LI) overrides a method: To methodname(TI \n, , T,); declared in class (0, L2), then we generate the con-straints: ,-L = TLZ TLl = TL2 0 0 1.. > \nn n . The constraint set {TL1 = TLz,TLz = TL3} indicates that T must be loaded as the same class type \nin L1 and Lz, and in Lz and Ls . Even if, during the execution of the program, T is never loaded by Lz, \ndistinct versions of T could not be loaded by L1 and L,. If the loaderconsh.aintsareviolated,ajava.lang.LinkageError \nexception will be thrown. Loader constraints are removed from the constraint set when the corresponding \nclass loader is garbage-collected. 4.2.3 Alternate Solutions Saraswat 1201 has suggested another approach \nto maintaining type safety in the presence of delegating class loaders. That proposal differs from ours \nin that it suggests that method overriding should also be based upon dynamic types rather than static \n(name-based) types. Saraswat s idea is appealing, in that it uses the dynamic concept of type uniformly \nfrom link time onwards. The following code illustrates the differences between his model and ours: class \n(Super, LI) { void f(Spoofed x) {...codel...) 1 class (Sub, Lz) extends (Super, 151) Lz { void f(Spoofed \nx) {...code2...} 1 class Main { public static void main(String[ args) { Spoofed sl = new Spoofed(); \nSub sub = new Sub(); Superduper = sub; duper.f(sl); 1 1  Assume that L1 and L2 define different versions \nof Spoofed. Saraswat considers the f methods in Super and Sub to have different type signatures: Super.f \ntakes an argument of type (Spoofed, L1) whereas Sub.f takes an argument of type (Spoofed, Lz). A s a \nconsequence, Sub.f is not considered to override Super.f in this model. In our model, if Main is loaded \nby Lz, a linkage error results at the point where f is called. The behavior in Saraswat s model is very \nsimilar: a NoSuchMethodError results. The difference in approach becomes apparent when Main is loaded \nby L1. In our model, when Main is loaded by L1, the call to f would invoke code2. A linkage error would \nbe raised when code2 attempted to access any fields or methods of Spoofed. In Saraswat s model the call \nto f executes code1 (that is, code2 does not override code0 We believe it is better to fail in this case \nthan to silently run code that was not meant to be executed. A programmer s expectation when writing \nthe classes Super and Sub above is that Sub.f does override Super.f, in accordance with the semantics \nof the Java programming language. These expectations are violated in Saraswat s proposal. Saraswat also \nsuggests a modification to the class loader API that would allow the virtual machine to determine the \nrun-time type of a symbolic reference without actually loading it. This is necessary in order to implement \nhis proposal without the penalty of excessive class loading. We believe it would be worth exploring this \nidea independently of the other aspects of Saraswat s proposal. Other proposals have also focused on \nchanging the pro- tocol of the ClassLoader class, or subdividing its functionality among several classes. \nSuch changes typically reduce the expressive power of class loaders. 5 Related Work Class loaders can \nbe thought of as a reflective hook into the system s loading mechanism. Reflective systems in other object-oriented \nlanguages [6, 141 have provided users the opportunity to modify various aspects of system behavior. One \ncould use such mechanisms to provide user-extensible class loading; however, we are not aware of any \nsuch experiments. Some Lisp dialects (171 and some functional languages [2] have a notion of first-class \nenvironments, which support multiple namespaces similar to those discussed in this paper. Dean [5] 141 \nhas discussed the problem of type safety in class loaders from a theoretical perspective. He suggests \na deep link between class loading and dynamic scoping. Jensen et al. [12] recently proposed a formalization \nof dynamic class loading in the Java virtual machine. Among other findings, the formal approach confirmed \nthe type safety problem with class loaders. Roskind [18] has put in place link-time checks to ensure \nclass loader type safety in Netscape s Java virtual machine implementation. The checks he implemented \nare more eager and strict than ours. The Oberon/F system [16] (now renamed Component Pascal) allows dynamic \nloading and type-safe linkage of modules. However, the dynamic loading mechanism is not under user control, \nnor does it provide multiple namespaces. Dynamically linked libraries have been supported by many operating \nsystems. These mechanisms typically do not provide type-safe linkage. Conclusions We have presented \nthe notion of class loaders in the Java platform. Class loaders combine four desirable features: lazy \nloading, type-safe linkage, multiple namespaces, and user extensibility. Type safety, in particular, \nrequires special attention. We have shown how to preserve type safety without restricting the power of \nclass loaders. Class loaders are a simple yet powerful mechanism that has proven to be extremely valuable \nin managing software components. Acknowledgements The authors wish to thank Drew Dean, Jim Roskind, and \nVijay Saraswat for focusing our attention on the type safety problem, and for many valuable exchanges. \nWe owe a debt to David Connelly, Li Gong, Benjamin Renaud, Roland Schemers, Bill Shannon, and many of \nour other colleagues at Sun Java Software for countless discus-sions on security and class loaders. Arthur \nvan Hoff first conceived of class loaders. Bill Maddox, Marianne Mueller, Nicholas Sterling, David Stoutamire, \nand the anonymous reviewers for OOPSLA 98 suggested numerous improvements to this paper. Finally, we \nthank James Gosling for creating the Java programming language. References [l] Ole Agesen, Stephen N. \nFreund, and John C. Mitchell. Adding type parameterization to the Java language. In Proc. of the ACM \nCo@ on Object-Oriented Program- ming, Systems, Languages and Applications, pages 49-65, October 1997. \n[2] Andrew W. Appel and David B. MacQueen. Standard ML of New Jersey. In J. Maluszyliski and M. Wirsing, \neditors, Programming Language implementation and Logic Programming,pages 1-13. Springer-Verlag, August \n1991. Lecture Notes in Computer Science 528. [3] Gilles Barbedette. Schema modifications in the LISP \n02 persistent object-oriented language. In European Cor@renceon Object-Oriented Programming, pages 77-96, \nJuly 1991. [4] Drew Dean, 1997. Private communication [5] Drew Dean. The security of static typing with \ndynamic linking. In Fourth ACM Conference on Computer and Communications Security, pages 18-27, April \n1997. [6] A. Goldberg and D. Robson. Smalltalk-80: the Language and Its Implementation. Addison-Wesley, \n1983. [71 James Gosling, Bill Joy, and Guy Steele. The lava Language Spec@cation. Addison-Wesley, Reading, \nMas-sachusetts, 1996. [8] JavaSoft, Sun Microsystems, Inc. JavaBeans Components API@ Java,1997. JDK 1.1 \ndocumentation, available at http://java.sun.com/products/jdk/l.l/docs/guide/beans. [9] JavaSoft, Sun \nMicrosystems, Inc. RtffIection, 1997. JDK 1.1 documentation, available at http://java.sun.com/products/jdk/l.l/docs/guide/reflection. \n [lOI JavaSoft, Sun Microsystems, Inc. The lava Extensions Framework, 1998. JDK 1.2 documentation, available \nat http://java.sun.com/products/jdk/l.2/docs/guide/extens;ons. [ll] JavaSoft, Sun Microsystems, Inc. \nServlet, 1998. JDK 1.2 documentation, available at http://java,sun,com/products/jdk/l,2/docs/ext/servlet. \n[121 Thomas Jensen, Daniel Le Metayer, and Tommy Thorn. Security and dynamic class loading in Java: A \nformali- sation. In Proceedings #IEEE International Col-tference on Computer Languages, Chicago, Illinois, \npages 4-15, May 1998. [131 Sonya E. Keene. Object-Oriented Programming in Common Lisp. Addison-Wesley, \n1989. 1141 Gregor Kiczales, Jim des Rivieres, and Daniel G. Bobrow. The Art ofthe Metaobject Protocol. \nMIT Press, Cambridge, Massachusetts, 1991. [15] TimLindholm and FrankYellin. TheJaua Virtual Machine \nSpecification.Addison-Wesley, Reading, Massachusetts, 1996. I161 Oberon Microsystems, Inc. Component \nPas-cal Language Report, 1997. Available at http:/www.oberon.ch/docu/language-report.html. [17] Jonathan \nA. Rees, Norman I. Adams, and James R. Meehan. The T Manual, Fourth Edition. Department of Computer Science, \nYale University, January 1984. [18] Jim Roskind, 1997. Private communication. [19] Vijay Saraswat. Matrix \ndesign notes. http://www.research.att.com/ vj/matrix.html. [20] Vijay Saraswat. Java is not type-safe. \navailable at http://www.research.att.com/ vj/bug.html, 1997. [21] David Ungar and Randall Smith. SELF: \nThe power of simplicity. In Proc. qf the ACM Co@ on Object-Oriented Programming, Systems, Languages and \nApplications, Octo-ber 1987.   \n\t\t\t", "proc_id": "286936", "abstract": "<i>Class loaders</i> are a powerful mechanism for dynamically loading software components on the Java platform. They are unusual in supporting all of the following features: <i>laziness, type-safe linkage, user-defined extensibility</i>, and <i>multiple communicating namespaces</i>.We present the notion of class loaders and demonstrate some of their interesting uses. In addition, we discuss how to maintain type safety in the presence of user-defined dynamic class loading.", "authors": [{"name": "Sheng Liang", "author_profile_id": "81423595437", "affiliation": "Sun Microsystems Inc., 901 San Antonio Road, CUPO2-302, Palo Alto, CA", "person_id": "PP31084619", "email_address": "", "orcid_id": ""}, {"name": "Gilad Bracha", "author_profile_id": "81100534214", "affiliation": "Sun Microsystems Inc., 901 San Antonio Road, CUPO2-302, Palo Alto, CA", "person_id": "P97520", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/286936.286945", "year": "1998", "article_id": "286945", "conference": "OOPSLA", "title": "Dynamic class loading in the Java virtual machine", "url": "http://dl.acm.org/citation.cfm?id=286945"}