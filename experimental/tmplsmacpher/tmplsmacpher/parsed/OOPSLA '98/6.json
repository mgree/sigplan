{"article_publication_date": "10-01-1998", "fulltext": "\n Safe Metaclass Programming Noury M. N. Bouraqadi-Saidani Thomas Ledoux Fred Rivard Noury.Bouraqadi@emn.fr \nThomas.LedouxOemn.fr FredRivard@oti.com ficole des Mines de Nantes Ikole des Mines de Nantes I?kole des \nMines &#38; OTI Inc. Nantes BP 20722 BP 20722 BP 20722 44307 Nantes -FRANCE 44307 Nantes -FRANCE 44307 \nNantes -FRANCE Abstract In a system where classes are treated as first class objects, classes are defined \nas instances of other classes called metaclasses. An important benefit of using metaclasses is the ability \nto assign properties to classes (e.g. being abstract, being final, trac-ing particular messages, supporting \nmultiple in-heritance), independently from the base-level code. However, when both inheritance and instantiation \nare explicitly and simultaneously involved, commu-nication between classes and their instances raises \nthe metaclass compatibility issue. Some languages (such as SMALLTALK) address this issue but do not easily \nallow the assignment of specific properties to classes. In contrast, other languages (such as CLOS) allow \nthe assignment of specific properties to classes but do not tackle the compatibility issue well. In this \npaper, we describe a new model of meta- level organization, called the compatibility model, which overcomes \nthis difficulty. It allows safe metaclass programming since it makes it possible to assign specific properties \nto classes while ensuring metaclass compatibility. Therefore, we can take advantage of the expressive \npower of metaclasses to build reliable software. We extend this com-patibility model in order to enable \nsafe reuse and composition of class specific properties. This ex-tension is implemented in NEO~LASSTALK, \na fully reflective SMALLTALK. Keywords: Metaclasses, compatibility, class specific properties, class \nproperty propagation. Permission to make dlgital or hard copes of all or pan of thes work for personal \nor classroom use IS granted wthout fee prowded that copes are not made or dtstrfbuted for profrt or commercial \nadvan- tage and that copes bear this no,,ce and the full c,tat,on on the first page. 70 copy otherwse. \nto republish. to post on servers or to redastrlbute to lets. requwes prior specific perm~s~on and/or \na fee. OOPSLA 98 lo/98 Vancouver. 9.C @ 1999 ACM l-581 13.005.9/99/0010...$5.00 1 Introduction It has \nbeen shown that programming with metaclasses is of great benefit [KAJ+93][Zim96] [BGL98]. An interesting \nuse of metaclasses is the assignment of specific properties to classes. For ex- ample, a class can be \nabstract, have a unique in-stance, trace messages received by its instances, define pre-post conditions \non its methods, forbid redefinition of some particular methods.. . These properties can be implemented \nusing metaclasses, allowing thereby the customization of the classes behavior [LC96]. From an architectural \npoint of view, using meta- classes organizes applications into abstraction lev-els. Each level describes \nand controls the level immediately below to which it is causally con-nected [Mae87]. Reified classes \ncommunicate with other objects including their own instances. Thus, classes can send messages to their \ninstances and instances can send messages to their classes. Such message sending is named inter-level \ncommunica-tion [MMC95]. However, careless inheritance at one level may break inter-level communication \nresulting in an is- sue called the compatibility issue [BSLR96]. We have identified two symmetrical kinds \nof compati- bility issues. The first one is the upward compatibil- ity issue, which was named metaclass \ncompatibility by Nicolas Graube [Gra89], and the second one is the downward compatibility issue. Both \nkinds of compatibility issues are important impediments to metaclass programming that one should always \nbe aware of. *Funded by IBM Global Services -FRANCE *Since the lJL July 1998: Object Technology Internatmnal \nInc. 2670 Queensview Drive, Ottawa, Ontario, CANADA K2B 8Kl Currently, none of the existing languages \ndeal- ing with metaclasses allow the assignment of spe- cific properties to classes while ensuring compat-ibility. \nCLOS [KdRBSl] allows one to assign any property to classes, but it does not ensure compati- bility. On \nthe other hand, both SOM [SOM93] and SMALLTALK [GR83] add ress the compatibility is-sue but they introduce \na class property propagation problem. Indeed, a property assigned to a class is automatically propagated \nto its subclasses. There- fore, in SOM and SMALLTALK, a class cannot have a specific property. For example, \nwhen assigning the abstractness property to a given SMALLTALK class, subclasses become abstract too [BC89]. \nIt follows that users face a dilemma: using a language that allows the assignment of specific class proper- \nties without ensuring compatibility, or using a lan- guage that ensures compatibility but suffers from \nthe class property propagation problem. In this paper, we present a model -the com-patibility model - \nwhich allows safe metaclass pro- gramming, i.e. it makes it possible to assign spe- cific properties \nto classes without compromising compatibility. In addition to ensuring compatibil-ity, the compatibility \nmodel avoids class property propagation: a class can be assigned specific prop- erties without any side-effect \non its subclasses. We implemented the compatibility model in NEOCLASSTALK, a SMALLTALK extension which \nintroduces many features including explicit meta-classes [Riv96]. Our experiments [Led98][Riv97] showed \nthat the compatibility model allows pro-grammers to fully take advantage of the expressive power of metaclasses. \nThis effort has resulted (i) in a tool that permits a programmer unfamiliar with metaclasses to transparently \ndeal with class spe- cific properties, and (ii) in an approach allowing reuse and composition of class \nproperties. This paper is organized as follows. Section 2 presents the compatibility issue. We give some \nex- amples to show its significance. Section 3 shows how existing programming languages address the compatibility \nissue, and how they deal with the property propagation problem. Section 4 describes our solut,ion and \nillustrates it with an example. In section 5, we deal with reuse and composition of class specific properties \nwithin the compatibility model. Then, we sketch out the use of the com-patibility model for both base-level \nand meta-level programmers. The last section contains a conclud- ing summary. 2 Inter-level communication \nand compati-bility We define inter-level communication as any mes-sage sending between classes and their \ninstances (see Figure 1). Indeed, class objects can interact, with other objects by sending and receiving \nmes-sages. In particular, an instance can send a mes- sage to its class and a class can send a message \nto some of its instances. We use SMALLTALK as an example to illustrate this issue . Class level Instance \nlevel ------) MessageSending Figure 1: Inter-level communication Two methods allow inter-level communication \nin SMALLTALK: new and class. When one of them is used, the involved objects belong to different lev-els \nof abstraction2: l An object receiving the class message returns its class. Then, the class method makes \nit pos- sible to go one level up. The following two instance methods -excerpted from Visual Works SMALLTALK \n--include message send- ing to the receiver s class. * message name is sent to the class: Object>>printOn: \naStream  GI: f=! self class 3. * message dayslnyear: is sent to the class:  Date>dayslnYear Answer \nthe number of days in the year represented by the receiver. t self class dayslnyear: self year We use \nthe SMALLTALK syntax and terminology throughout this paper. St&#38;x measures we made over a Visual Works \nSMALLTALK image show that inter-level communication is very frequent. 25% of classes include instance \nmethods referencing the class and 24% of metaclasses define methods referencing an instance. l A class \nreceiving the new message returns a new instance. Therefore, the new method makes it possible to go one \nlevel down. The following two class methods include message sending to the newly created instances. * \nmessage at:put: is sent to a new instance: ArrayedCollection class>>with: anobject 1 newCollection 1 \nnewCollection := self new: 1. newCollection at: 1 put: anobject. tnewCollection * message on: is sent \nto a new instance: Browser class>openOn: anorganizer self openOn: (self new on: anorganizer) with-TextState: \nnil Thus, inter-level communication in SMALLTALK is materialized by sending the messages new and class. \nOther languages where classes are reified (such as CLOS and SOM) also allow similar mes-sage sending. \nSince these inter-level communication messages are embedded in methods, they are inherited when-ever \nmethods are inherited. Ensuring compatibiEity means making sure that these methods will not in- duce \nany failure in subclasses, i.e. all sent messages will always be understood. We have identified two kinds \nof compatibility: upward compatibilit$ and downward compatibility. MetaA 0 MetaB 1 Figure 2: Compatibility \nneed to be ensured at a higher level 2.1 Upward compatibility Suppose A implements a method i-foo that \nsends the c-bar message to the class of the receiver (see Figure 2). B is a subclass of A. When i-foo \nis sent to an instance of B, the B class receives the c-bar message. In order to avoid any failure, B \nshould understand the c-bar message (i.e. MetaB should implement or inherit a method c-bar). 3Nicolas \nGraube named this issue metaclass compatib~laty[Gra89]. Definition of upward compatibility: Let B be \na subclass of the class A, MetaB the metaclass of B, and MetaA the metaclass of A. Upward compatibility \nis ensured for MetaB and MetaA if: every possible message that does not lead to an error for any instance \nof A, will not lead to an error for any instance of B. 2.2 Downward compatibility Suppose MetaA implements \na method c-foo that sends the i-bar message to a newly created instance (see Figure 3). MetaB is created \nas a subclass of MetaA. When c-foo is sent to B (an instance of MetaB), B wi 11create an instance which \nwill receive the i-bar message. In order to avoid any failure, instances of B should understand the i-bar \nmes-sage (i.e. B should implement or inherit the i-bar method). Met;$ too7 MetaB MetaA>>c-foo + self \nnew i-bar t A <i-bar> + inheritance -instantiation t-7 B l Figure 3: Compatibility need to be ensured \nat a lower level Definition of downward compatibility: Let MetaB be a subclass of the metaclass MetaA. \nDownward compatibility is ensured for two classes B instance of MetaB and A instance of MetaA i@: every \npossible message that does not lead to an error for A, will not lead to an error for B. 3 Existing models \nWe will now show why none of the known mod-els allow the assignment of specific properties to classes \nwhile ensuring compatibility. 3.1 CLOS When (re)defining a class in CLOS, the validate-superclass generic \nfunction is called, before the di- rect superclasses are stored [KdRBSl]. As a de- fault, validate-superclass \nreturns true if the meta-class of the new class is the same as the metaclass of the superclass4, i.e. \nclasses and their subclasses must have the same metaclass. Therefore, incom-patibilities are avoided \nbut metaclass programming is very constrained. MetaA Figure 4: By default in CLOS, subclasses must share \nthe same metaclass as their superclass Figure 4 shows a hierarchy of two classes that illustrates the \nCLOS default compatibility manage- ment policy. Since class B inherits from A, B and A must have the \nsame metaclass. In order to allow the definition of classes with different behaviors, programmers usually \nredefine the validate-superclass method to make it always return true. Thus, CLOS programmers can have \ntotal freedom to use a specific metaclass for each class. So, they can assign specific properties to \nclasses, but the trade-off is that they need to be always aware of the compatibility issue. 3.2 SOM \nSOM is an IBM CORBA compliant prod-uct which is based on a metaclass architecture [DF94b]. The SOM kernel \nfollows the OBJVLISP model [Coi87]. SOM metaclasses are explicit and can have many instances. Therefore, \nusers have complete freedom to organize their metaclass hier- archies. 3.2.1 Compatibility issue in SOM \nSOM encourages the definition and the use of ex- plicit metaclasses by introducing a unique con-cept \nnamed derived metaclasses which deals with the upward compatibility issue [DF94ai At compile-time, SOM \nautomat;-;liy determines an 41n fact I+ Aso returns true if the superclass is the class named t, or if \nthe metaclass of one argument is standard-class and the metaclass of the other IS funcallable-standard-class. \nappropriate metaclass that ensures upward com-patibility. If needed, SOM automatically creates a new \nmetaclass named a derived metaclass to ensure upward compatibility. A>>i-foe MetaB - t self m c-bar Derived \nMe ah-c class: B; I t parent2 A; metaclass: UetaB; ___- d inheritance -instantiation Figure 5: SOM \nensures upward compatibility using derived metaclasses Suppose that we want to create a class B, in-stance \nof MetaB and subclass of A. SOM will de-tect an upward compatibility problem, since MetaB does not inherit \nfrom the metaclass of A (MetaA). Therefore, SOM automatically creates a derived metaclass (Derived), \nusing multiple inheritance in order to support all necessary class methods and variables5. Figure 5 shows \nthe resulting construc-tion. When an instance of B receives i-foo, it goes one level higher and sends \nc-bar to the B class. B understands the c-bar message since its metaclass (i.e. Derived) is a derived \nmetaclass which inherits from both MetaB and MetaA. L Figure 6: SOM downward compatibility failure example \nSOM does not provide any policy or mechanism to handle downward compatibility. Suppose that MetaB is \ncreated as a subclass of MetaA (see Fig-ure 6). The c-foo method which is inherit,04 ?,j MetaB sends \nthe i-bar message I,O a new instance. When the B class receives the c-foo message, a run- time error \nwill occur because its instances do not understand the i-bar message. The semantics of derived metaclasses \nguarantees that the declared met&#38;ass takes precedence in the resolution of multiple inheritance ambiguities \n(i.e. MetaB before MetaA). Besides, it ensures the instance variables of the class are correctly imtialized \nby the use of a complex mechanism. 3.2.2 Class property propagation in SOM SOM does not allow the assignment \nof a property to a given class, without making its subclasses be assigned the same property. We name \nthis defect the class property propagation problem. In the fol- lowing example, we illustrate how derived \nmeta-classes implicitly cause undesirable propagation of class properties. SoleInstance hDcrived class: \nB: parent: A; Released e metaclass: SoleInstance; p-!sF] t t A-B Figure 7: Class property propagation \nin SOM Suppose that the A class of Figure 7 is a released class, i.e. it should not be modified any more. \nThis property is useful in multi-programmer de-velopment environments for versionning purposes. In order \nto avoid any change, A is an instance of the Released metaclass. Let B a class that has a unique instance: \nf3 is an instance of the Soleln-stance metaclass. But as B is a subclass of A, SOM creates B as instance \nof an automatically created derived metaclass which inherits from both Soleln-stance and Released. Thus, \nas soon as B is created, it is automatically locked and acts like a released class. So, we cannot define \nany new method on it!  3.3 Smalltalk- In SMALLTALK, metaclasses are partially hidden and automatically \ncreated by the system. Each metaclass is non-sharable and strongly coupled with its sole instance. So, \nthe metaclass hierarchy is parallel to the class hierarchy and is implicitly generated when classes are \ncreated. 3.3.1 Compatibility issue in Smalltalk- Using parallel inheritance hierarchies, the SMALL-TALK \nmodel ensures both upward and downward compatibility. Indeed, any code dealing with new A ClaSs>>C-foe \nA class<-B class <c-too> tself -i-bar <c-bar> A>>i-foe fself clas&#38;c-bar t t A<lt%7= B[q inheritance \n-t instantiation - <I-bar> Figure 8: SMALLTALK ensures both upward and downward compatibilities When \none creates the B class, a subclass of A (see Figure 8), SMALLTALK automatically gener-ates the metaclass \nof B ( B clasC6), as a subclass of A class , the metaclass of A. Suppose A imple-ments a method i-foo \nthat sends c-bar to the class of the receiver. If i-foo is sent to an instance of B, the B class receives \nthe c-bar message. Thanks to the parallel hierarchies, the B class understands the c-bar message, and \nupward compatibility is en- sured. In a similar manner, downward compatibil-ity is ensured thanks to \nthe parallel hierarchy. 3.3.2 Class property propagation in Small-talk-80 Since metaclasses are automatically \nand implicitly managed by the system, SMALLTALK drastically reduces the opportunity to change class behaviors, \nmaking metaclass programming anecdotal . As with SOM, SMALLTALK does not allow the assign-ment of a property \nto a class without propagating it to its subclasses. A class v B class A class>>new <new> self error: \n1 am Abstract t t I I [+ In en ante -t h t instantiation A-B J Figure 9: Class property propagation \nin SMALLTALK In Figure 9, the A class is abstract since its sub- classes must implement some methods \nto complete the instance behavior. B is a concrete class as it im- plements the whole set of these methods. \nSuppose or class methods, is inherited and works properly. The name of a SMALLTALK metaclass is the name \nof Its unique Instance postfixed by the word class . that we want to enforce the property of abstract- \nness of A. In order to forbid instantiating A, we de-fine the class method A class>>new which raises \nan error. Unfortunately, B class inherits the method new from A class . As a result, attempting to cre- \nate an instance of B raises an error7! 4 The compatibility model Among the previous models, only the \nSMALLTALK one with its parallel hierarchies ensures full com-patibility. However, it does not allow the \nassign- ment of specific properties to classes. On the other hand, only the CLOS model allows the as-signment \nof specific properties to classes. Unfor-tunately, it does not ensure compatibility. We be- lieve that \nthese two goals can both be achieved by a new model which makes a clear separation between compatibility \nand class specific properties. A class G-B class % 4 Abstract + A cla8s>>new Abstract + A class i <new> \n Figure 10: Avoiding the propagation of abstractness We illustrate this idea of separation of concerns \nby refactoring the example of Figure 9. We create a new metaclass named Abstract + A class as a subclass \nof A class (see Figure 10). The A class is redefined as an instance of this new metaclass. As Abstract \n+ A class redefines the new method to raise an error, A cannot have any instance. How-ever, since B class \nis not a subclass of Abstract + A class , the B class remains concrete. The gen- eralization of this \nscheme is our solution, named the compatibility model. In the remainder of this paper, names of meta- \nclasses defining some class property are denoted with the concatenation of the property name, the + \nsymbol and the superclass name. For exam-ple, Abstract + A class is a subclass of A class  This example \nis deliberately simple, and one could avoid this problem by redefining new in B class . But, this solution \nis a kind of inheritance anomaly [MY931 that increases maintenance costs. that defines the property of \nabstractness named Abstract. 4.1 Description of the compatibility model The compatibility model extends \nthe SMALLTALK model by separating two concerns: compatibility and specific class properties. A metaclass \nhierar-chy parallel to the class hierarchy ensures both up-ward and downward compatibility like in SMALL-TALK. \nAn extra metaclass layer is introduced in order to locally assign any property to classes. Classes are \ninstances of metaclasses belonging to this layer. So, the compatibility model is based on two layers \nof metaclasses, each one addressing a unique concern: Compatibility concern: This issue is addressed \nby the metaclasses organized in a hierarchy parallel to the class hierarchy. We name such metaclasses: \ncompatibility metaclasses. They define all the behavior that must be propa- gated to all (sub)classes. \nAll class methods which send messages to instances should be defined in these metaclasses. Besides, all \nmes- sages sent to classes by their instances should be defined in these metaclasses too. Specific class \nproperties concern: This issue is addressed by metaclasses that define the class specific properties. \nWe name such meta- classes: property metaclasses. A class with a specific property is instance of a prop-erty \nmetaclass which inherits from the corre-sponding compatibility metaclass. The prop-erty metaclass is \nnot joined to other property metaclasses, since it defines a property specific to the class. Figure 11 \nshows the compatibility model ap-plied to a hierarchy consisting of two classes: A and B. They are respectively \ninstances of the AProp-erty + AClass and BProperty + BClass meta-classes. AProperty + AClass defines \nproperties specific to class A, while BProperty + BClass de-fines properties specific to class B. As \nAProperty + AClass and BProperty + BClass are not ,joined Compatibility metaclasses are surrounded with \na dashed line and property metaclasses are drawn inside a grey shape. AClass>>c-foe +sslf PUL i-bar Figure \n11: The compatibility model by any link, class property propagation does not occur. Thus, A and B can \nhave distinct properties. Since AProperty + AClass and BProperty + BClass are subclasses of the AClass \nand BClass metaclasses, both upward and downward compat-ibility are guaranteed. Suppose that A defines \ntwo instance methods i-foo and i-bar. The i-foo method sends the c-bar message to the class of the receiver. \nThe i-bar method is sent to a new instance by the c- foo method. Because the AClass and BClass meta-class \nhierarchy is parallel to the A and B class hier- archy, inter-level communication failure is avoided. \n 4.2 Example: Refactoring the Smalltalk-80 Boolean hierarchy The Boolean hierarchy of SMALLTALK~ is de-picted \nin Figure 12. Boolean is an abstract class which defines a protocol shared by True and False. True and \nFalse are concrete classes that cannot have more than one instance. These prop- erties (i.e. abstractness \nand having a sole instance) are implicit in SMALLTALK. Using the compati-bility model, we refactor the \nBoolean hierarchy to emphasize them. We first create Boolean class , which is a com- patibility metaclass. \nThe second step consists of creating the property metaclass Abstract + i300lean class , which enforces \nthe Boolean class to be abstract. Finally, we build the Boolean class by instantiating the Abstract + \nBoolean class meta-class. To refactor the False class, we first create the False class metaclass, as \na subclass of Boolean We prefer this academic example to emphasize our ideas rather than a more complex \nexample which should require a more detailed presentation. <L True class Boolean classL False class t \nt ! Figure 12: The Boolean hierarchy of SMALLTALK class to ensure the compatibility. The second step \nconsists of creating the property metaclass Soleln-stance + False class , which enforces the False class \nto have at most one instance. At last, we create the False class by instantiating the Solelnstance + \nFalse class metaclass. The True class is refactored in the same way. The result of rebuilding the whole \nhierarchy of Boolean is shown in Figure 13. Figure 13: The Boolean hierarchy aft,er refact,oring 5 Reuse \nand composition within the com-patibility model We have experimented the compatibility model in NEOCLASSTALK'~ \n[Riv97], a fully reflective SMALLTALK. We quickly faced the need of class property reuse and composition. \nIndeed, unrelated classes belonging to different hierarchies ca.n have the same properties, and a given \nclass can have many properties In the previous section, both the True class and the False class have \nthe same property: having a unique instance. Besides, we assigned only one property to each class of \nthe Boolean hierarchy NEOCLASSTALK and all related papers cm be downloaded from http //www.emn.fr/cs/object/tools/neoclasstalk/neoclasst~k.~~tml \nBut, a class need to be assigned many properties. For example, the False class must not only have a unique \ninstance, but it also should not be sub- classed (such a class is final in JAVA terminology). So, we \nhave to reuse and compose these class prop- erties with respect to our compatibility model. In this section, \nwe propose an extension of our compatibility model that deals with reuse and com- position of class properties. \nAny language where classes are treated as regular objects may integrate our extended compatibility model. \nNEOCLASS-TALK has been used as a first experimentation plat-form. 5.1 Reuse of class properties In SMALLTALK, \nsince metaclasses behave in a dif- ferent way than classes, they are defined as in- stances of a particular \nclass, a meta-metaclass, called Metaclass. Metaclass defines the behavior of all metaclasses in SMALLTALK. \nFor example, the name of a metaclass is the name of its sole instance postfixed by the word class . Metaclass>>name \nfthisclass name, class We take advantage of this concept of meta-metaclasses to reuse class properties. \nSince meta- classes implementing different properties have dif- ferent behaviors, we need one meta-metaclass \nfor each class property. Property metaclasses defining the same class property are instances of the same \nmeta-metaclass. When a property metaclass is created, the meta- metaclass initializes it with the definition \nof the corresponding class property. Thus, the code (instance variables, methods, . . . ) correspond-ing \nto the definition of the class property, is automatically generated. Reuse is achieved by cre- ating \nproperty metaclasses defining the same class property as instances of the same meta-metaclass, i.e. they \nare initialized with the same class prop- erty definition (an example of such an initialization is given \nin section 5.4.2). The root of the meta-metaclass hierarchy named PropertyMetaclass describes the default \nstructure and behavior of property metaclasses. For exam-ple, the name of a property metaclass is built \nfrom the property name and the superclass name: PropertyMetaclass>name tself class name, + , self superclass \nname In the refactored Boolean hierarchy of section 4.2, both Solelnstance + False class and Soleln-stance \n+ True class define the property of having a unique instance. Reuse is achieved by defining both Solelnstance \n+ False class and Solelnstance + True class as instances of Solelnstance, a, sub-class of PropertyMetaclass \n(see Figure 14). Figure 14: Reuse properties in the Boolean hierarchy  5.2 Composition of class properties \nSince a given class can have many properties, the model must support the composition of class prop- erties. \nWe chose to use many property metaclasses organized in a single inheritance hierarchy, where each metaclass \nimplements one specific class prop- erty. ,~__ __ __________~~~.~.~~~~.. ~~~...~~~~ i Boolean classy \nFalse class ; ._____ _______._ -----K * _--- K Boolean<-F&#38;e * inheritance -+ instantiation Figure \n15: Assigning two properties to False To illustrate this idea, we modify the in-stantiation link for \nthe False class (see Fig- ure 15). We define two property metaclasses, one for each property. The first \nproperty meta-class is Solelnstance + False class , which inher-its from the compatibility metaclass \nFalse class . The second one is Final + Solelnstance + False class , which is the class of False. It \nis defined as a subclass of Solelnstance + False class . The re-sulting scheme respects the compatibility \nmodel: it allows the assignment of two specific properties to the False class and still ensures compa,tibility. \n5.2.1 Conflict management The solution of the property metaclasses compo- sition issue is not trivial. \nIndeed, it is necessary to deal with conflicts that arise when composing different property metaclasses. \nWhen using inher- itance to compose property metaclasses, two kinds of conflicts can arise: name confhts \nand value con- flicts [DHH+95]. Name conflicts happen when orthogonal prop-erty metaclasses define instance \nvariables or meth- ods which have the same name. Two property metaclasses are orthogonal when they define \nun-related class properties. Name conflicts for both instance variables and methods are avoided by adapting \nthe definition of a new property meta-class according to its superclasses. For exam-ple, although the \ntwo property metaclasses Sole-Instance + False class and Solelnstance + True class define the same property \nfor their respective instances (classes False and True), they may use dif- ferent instance variable names \nor method names. Value conflicts happen when non-orthogonal property metaclasses define methods which \nhave the same name. Most of these conflicts are avoided by making the property metaclass hierarchy act \nas a cooperation chain, i.e. a property metaclass ex-plicitly refer to the overridden methods defined \nin its superclasses l1 . Therefore, each property meta-class acts like a mixin [BC90]. In NEOCLASSTALK, \nas in SMALLTALK, this is achwved usmg the pseudo-variable super. 5.2.2 Example of cooperation between \nproperty metaclasses Suppose that we want to assign two specific prop-erties to the False class of Figure \n16: (i) tracing all messages (Trace) and (ii) having breakpoints on particular methods (Breakpoint). \nThese two properties deal with the message handling which is based in NEOCLASSTALK on the technique of \nthe method wrappers described in [Duc98] and [BFJR98]. Th e executeMethod:receiver:arguments: method \nis the entry point to handle mes-sages in NEO~LASSTALK, i.e. customizing exe-cuteMethod:receiver:arguments: \nallows a specializa- tion of the message sending12. Thus, when the ob- ject false receives a message, \nthe class False receives the message executeMethod:receiver:arguments:. PropertyMetaclass Figure 16: \nComposition of non-orthogonal properties According to the inheritance hierarchy, (1) the trace is first \ndone, then (2), by the use of super, the breakpoint is performed, and (3) a regular method application \nis finally executed (again cadled using super). l (3) StandardClass>executeMethod: method receiver: ret \narguments: args l (2) Breakpoint-i-False class>>executeMethod: method receiver: ret arguments: args method \nselector == stopSelector iffrue: [self halt: Breakpoint for , stopSelector]. tsuper executeMethod: method \nreceiver: ret argu-ments: args A default executeMethod:receiver:argumentr: method is prowded by StandardClass \n(the root of all metaclasses in NEOCLASSTALK) which just applies the method on the receiver with the \narguments. Figure 17: The Extended Compatibility Model l (1) Trace+BreakPoint+False class>>executeMethod: \nmethod receiver: ret arguments: args self transcript show: method selector; cr. fsuper executeMethod: \nmethod receiver: ret argu- ments: args  5.3 The extended compatibility model Generalizing previous \nexamples allows us to define the extended compatibility model (see Figure 17) which enables reusing and \ncomposing class prop- erties. Each property metaclass defines the in-stance variables and methods involved \nin a unique property. Property metaclasses specific to a given class are organized in a single hierarchy. \nThe root of this hierarchy is a subclass of a compatibility metaclass13. Each property metaclass is an \nin-stance of a meta-metaclass which describes a spe- cific class property, allowing its reuse. Metaclass \ncreation, composition and deletion are managed automatically with respect to the ex- tended compatibility \nmodel. Each time a new class is created, a new compatibility metaclass is auto- matically created. This \ncan be done in the same wa.y that SMALLTALK builds its parallel metaclass hierarchy. The assignment of \na property to this class results in the insertion of a new metaclass into its property metaclass hierarchy. \nThis inser- ISThis single hierarchy may be compared to an explicit lineariza-tion of property metaclasses \ncomposed using mu%&#38;?inheritance [DHHM94]. tion is made in two steps14: 1. first, the new property \nmetaclass becomes a subclass of the last metaclass of the property metaclass hierarchy;  2. then, the \nclass becomes instance of this new property metaclass.  NEOCLASSTALK provides protocols for dynami- \ncally changing the class of an object (changeclass:) and the superclass of a class (superclass:) [Riv97]. \nThus, the implementation of these two steps is im- mediate in NEO~LASSTALK, and is provided by the composeWithPropertiesOf: \nmethod. PropertyMetaclass>>composeWithPropertiesOf: aClass self superclass: aClass class. aClass changeclass: \nself.  5.4 Programming within the extended compatibility model We distinguish two kinds of programmers: \n(i) base level programmers who implement appli-cations using the language and development tools, and \n(ii) meta level programmers for whom the language itself is the application. 14The removal of a property \nmetaclass is done in a symmetrical way. 5.4.1 Base Level Programming To make our model easy to use for \na base-level programmer , the NEOCLASSTALK programming environment includes a tool that allows one to \nas-sign different properties to a given class using a SMALLTALK-like browser (see Figure 18). These properties \ncan be added and removed at run-time. The metaclass level is automatically built accord-ing to the selection \nof the base-level programmer . Figure 18: Specific properties assigned to a class using a browser 5.4.2 \nMeta Level Programming In order to introduce new class properties, meta-level programmers must create \na subclass of the PropertyMetaclass meta-metaclass. This new meta- metaclass stores the instance variables \nand the methods that should be defined by its instances (property metaclasses). When this new meta-metaclass \nis instantiated, the previous instance variables are added to the resulting property meta-class and the \nmethods are compiled15 at initializa- tion timer6. For example, the evaluation of the following ex-pression \ncreates a property metaclass -instance of 15A faster solution consists of doing the compilation only \nonce, resulting in proto-methods [Riv97]. Thus, when the property meta-class gets initialized, proto-methods \nare copied into the method dictionary of the property metaclass, allowing a fast instantiation of meta-metaclasses. \nThis assumes that mitialization is part of the creation pro-cess, which is true in almost every language \nThis is traditmnnally achieved in SMALLTALK by the redefimtion of new into super new initialize [SKT96]. \nthe meta-metaclass Trace -that assigns the trace property to the True class. Trace new composeWithPropertiesOf: \nTrue In order to achieve the trace, messages must be captured and then logged in a text col-lector. \nTherefore, property metaclasses in-stances of Trace must define an instance vari-able (named transcript) \ncorresponding to a text collector and a method that handles messages. Message handling is achieved using \nthe ex-ecuteMethod:receiver:arguments: method which source code was already presented in 5.2.2. These \ndefinitions are generated when the property meta-classes are initialized, i.e. using the initialize method \nof the Trace meta-metaclass: Trace>>initialize super initialize. self instanceVariableNames: transcript \n. self generateExecuteMethodReceiverArguments. 6 Conclusion Considering classes as first class objects \norganizes applications in different abstraction levels, which inevitably raises upward and downward compat-ibility \nissues. Existing solutions addressing the compatibility issues (such as SMALLTALK) do not allow the assignment \nof specific properties to a given class without propagating them to its sub-classes. The compatibility \nmodel proposed in this paper addresses the compatibility issue and allows the as- signment of specific \nproperties to classes without propagating them to subclasses. This is achieved thanks to the separation \nof the two involved con-cerns: compatibility and class properties. Upward and downward compatibilities \nare ensured using the compatibility metaclass hierarchy that is par- allel to the class hierarchy. The \nproperty meta-classes, allowing the assignment of specific proper-ties to classes, are subclasses of \nthese compatibil- ity metaclasses. Therefore, we can take advantage of the expressive power of metaclasses \nto define, reuse and compose class properties in a environ- ment which supports safe metaclass programming. \nClass properties improve readability, reusabil-ity and quality of code by increasing separation of concerns \n[HL95] [Lie961 [KLM+97]. Indeed, they allow a better organization of class libraries and frameworks for \ndesigning reliable software. We are strongly convinced that our compatibility model enables separation \nof concerns based on the meta- class paradigm. Therefore, it promotes building reliable software which \nis easy to reuse and main- tain. Acknowledgments The authors are grateful to Mathias Braux, Pierre Cointe, \nStephane Ducasse, Nick Edgar, Philippe Mulet, Jacques Noye, Nicolas Revault, and Mario Siidholt for their \nvaluable comments and sugges- tions. Special thanks to the anonymous referees who provided detailed and \nthought-provoking com-ments. References [BC89] Jean-Pierre Briot and Pierre Cointe. Programming with \nExplicit Meta-classes in Smalltalk. In Proceedings of OOPSLA 89, pages 419-431, New Or- leans, Louisiana, \nUSA, October 1989. ACM. [BC90] Gilad Bracha and William Cook. Mixin-based Inheritance. In Proceed-ings \nof ECCOP/OOPSLA 90, Ottawa, Canada, pages 303-311, October 1990. [BFJR98] John Brant, Brian Foote, Ralph \nE. Johnson, and Donald Roberts. Wrap-pers to the Rescue. In Proceedings of ECOOP 98, July 1998. [BGL98] \nJean-Pierre Briot, Rachid Guerraoui, and Klaus-Peter Liihr. Concurrency and Distribution in Object Oriented \nProgramming. ACA4 Computer Sur-Ileys, 1998. to appear. [BSLR96] Noury Bouraqadi-Saadani, Thomas Ledoux, \nand Fred Rivard. Metaclass Composability. In ECOOP 96 work-shop : NComposability Issues in Object Orientation \n, Linz, Austria, July 1996. [Coi87] [DF94a] [DF94b] [DHH+95] [DHHM94] [Duc98] [GR83] [Gra89] [HL95] Pierre \nCointe. Metaclasses are First Class: the ObjVlisp Model. In Pro-ceedings of OOPSLA 87, pages 156--167, \nOrlando, Florida, USA, October 1987. ACM. Scott Danforth and Ira R. Forman. De-rived Metaclasses in SOM. \nIn Proceed- ings of TOOLS EUROPE 94, pages 63-73, Versailles, France, 1994. Scott Danforth and Ira R. \nForman. Re-flections on Metaclass Programming in SOM. In Proceedings of OOPSLA 94, pages 440-452, October \n1994. Roland Ducournau, Michel Habib, Marianne Huchard, Marie-Laure Mug-nier, and Amedeo Napoli. Le point \nsur l heritage multiple. Techniques et Sciences Informatique, 14(3):309-345, 1995. (In french). Roland \nDucournau, Michel Habib, Marianne Huchard, and Ma,rie-Laure Mugnier. Proposal for a Mono-tonic Multiple \nInheritance Lineariza-tion. In Proceedings of OOPSLA 94, pages 164-175, Portland, Oregon, Oc-tober 1994. \nStephane Ducasse. Evaluating Mes-sage Passing Control Techniques in Smalltalk. Journal of Object-Oriented \nProgramming, 1998. to appear. A. Goldberg and D. Robson. Smalltalk- SO, The language and its implementa- \ntion. Addison Wesley, Readings, Mas-sachusetts, 1983. Nicolas Graube. Metaclass Compati-bility. In Proceedings \nof OOPSLA 89, pages 305-315, New Orleans, Lou-siana, October 1989. Walter L. Hiirsch and Cristina Videira \nLopes. Separation of Concerns. Tech-nical Report NU-CCS-95-03, College of Computer Science, Northeastern \nUni-versity, Boston, MA, February 1995. [KAJ+93] [KdRBSl] [KLM+971 [LC96] [Led981 [Lie961 [Mae871 Gregor \nKiczales, J. Michael Ash-ley, Luis H. Rodriguez Jr., Amin Vahdat , and Daniel G. Bobrow. Object-Oriented \nProgramming: The CLOS Perspective edited by Andreas Papeke, chapter Metaobject Proto-cols: Why We Want \nThem and What Else They Can Do, pages 101-118. The MIT Press, Cambridge, Mas-sachusetts, 1993. Gregor \nKiczales, Jim des Rivikres, and Daniel G. Bobrow. The Art of the Metaobject Protocol. MIT Press, 1991. \nGregor Kiczales, John Lamping, Anurag Mendhekar, Chris Maeda, Cristina Lopes, Jean-Marc Lo-ingtier, and \nJohn Irwin. Aspect-Oriented Programming. In Mehmet Akgit and Satoshi Matsuoka, editors, ECOOP 97, number \n1241 in LNCS, pages 220-242. Springer-Verlag, June 1997. Thomas Ledoux and Pierre Cointe. Explicit Metaclasses \nAs a Tool for Im- proving the Design of Class Libraries. In Proceedings of ISOTAS 96, LNCS 1049, pages \n38-55, Kanazawa, Japan, March 1996. Springer-Verlag. Thomas Ledoux. Reflection and Dis- tributed Systems \n: an Experiment with CORBA and Smalltalk. PhD the-sis, Universite de Nantes, March 1998. (In french. \nReflexion dans les systemes repartis : application 8 CORBA et Smalltalk). Karl J. Lieberherr. Adaptive \nObject-Oriented Software: The Demeter Method with Propagation Patterns. PWS Publishing Company, Boston, \n1996. ISBN 0-534-94602-X. Pattie Maes. Concepts and Ex-periments in Computational Reflec-tion. In Proceedings \nof OOPSLA 87, pages 147-155, Orlando, Florida, 1987. ACM. [MMC95]    [MY 931 [Riv96] [Riv97] [SKT96] \n[SOM93] [Zim96] Philippe Mulet, Jacques Malenfant, and Pierre Cointe. Towards a Method- ology for Explicit \nComposition of MetaObjects. In Proceedings of OOP- SLA 95, pages 316-330, Austin, Texas, October 1995. \nSatoshi Matsuoka and Aki-nori Yonezawa. Research Directions in Concurrent Object-Oriented Program-ming, \nchapter Analysis of inheritance anomaly in object-oriented concurrent programming languages. MIT Press, \n1993. Fred Rivard. A New Smalltalk Ker- nel Allowing Both Explicit and Im- plicit Metalclass Programming. \nOOP-SLA 96, Workshop : Extending the Smalltalk Language, October 1996. Fred Rivard. Object Behavioral \nEvo-lution Within Class Based Reflective Languages. PhD thesis, Universite de Nantes, June 1997. (In \nfrench. Evo-lution du Comportement des Objets dans les Langages 8. Classes Rkflexifs). Suzanne Skublicks, \nEdward J. Klimas, and David A. Thomas. Smalltalk with Style. Prentice Hall, 1996. IBM. SOMobjects Developer \nToolkit Users Guide release 2.0, second edi-tion, June 1993. Chris Zimmermann, editor. Advances in Object-Oriented \nMetalevel Architec-tures and Reflection. CRC Press, 1996.  \n\t\t\t", "proc_id": "286936", "abstract": "In a system where classes are treated as first class objects, classes are defined as instances of other classes called <i>metaclasses</i>. An important benefit of using metaclasses is the ability to assign <i>properties</i> to classes (e.g. being abstract, being final, tracing particular messages, supporting multiple inheritance), independently from the base-level code. However, when both inheritance and instantiation are explicitly and simultaneously involved, communication between classes and their instances raises the <i>metaclass compatibility</i> issue. Some languages (such as S<sc>MALLTALK</sc>) address this issue but do not easily allow the assignment of specific properties to classes. In contrast, other languages (such as CLOS) allow the assignment of specific properties to classes but do not tackle the compatibility issue well.In this paper, we describe a new model of metalevel organization, called <i>the compatibility model</i>, which overcomes this difficulty. It allows <i>safe metaclass programming</i> since it makes it possible to assign specific properties to classes while ensuring metaclass compatibility. Therefore, we can take advantage of the expressive power of metaclasses to build reliable software. We extend this compatibility model in order to enable safe reuse and composition of class specific properties. This extension is implemented in N<sc>EOCLASSTALK</sc>, a fully reflective S<sc>MALLTALK</sc>.", "authors": [{"name": "Noury M. N. Bouraqadi-Sa&#226;dani", "author_profile_id": "81100018873", "affiliation": "&#201;cole des Mines de Nantes, BP 20722, 44307 Nantes - FRANCE", "person_id": "P210417", "email_address": "", "orcid_id": ""}, {"name": "Thomas Ledoux", "author_profile_id": "81100397440", "affiliation": "&#201;cole des Mines de Nantes, BP 20722, 44307 Nantes - FRANCE", "person_id": "PP31086356", "email_address": "", "orcid_id": ""}, {"name": "Fred Rivard", "author_profile_id": "81100103416", "affiliation": "&#201;cole des Mines & OTI Inc. Nantes, BP 20722, 44307 Nantes - FRANCE and Object Technology International Inc. 2670 Queensview Drive, Ottawa, Ontario, CANADA K2B 8K1", "person_id": "P86696", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/286936.286949", "year": "1998", "article_id": "286949", "conference": "OOPSLA", "title": "Safe metaclass programming", "url": "http://dl.acm.org/citation.cfm?id=286949"}