{"article_publication_date": "10-01-1998", "fulltext": "\n Parametric Polymorphism for JavaTM: A Reflective Solution * Jose H. Solorzano and Suad Ala@ Computer \nScience Department Wichita State University Wichita, KS 67260-0083, USA {jhsolorz,alagic}@cs.twsu.edu \nAbstract A number of inadequacies of existing implementation tech- niques for extending JavaTM with parametric \npolymorphism are revealed. Homogeneous translations are the most space- efficient but they are not compatible \nwith reflection, some models of persistence, and multiple dispatch. Heterogeneous translations, on the \nother hand, can potentially produce large amounts of redundant information. Implementation techniques \nthat address these concerns are developed. In languages that support run-time reflection, an adequate \nim- plementation of parametric, bounded and F-bounded poly- morphism is shown to require (reflective) \nrun-time support. In Java, extensions to the core classes are needed. This is in spite of the fact that \nparametric polymorphism is intended to be managed statically. Category: Research d Experience. Subject \nareas: Language design and implementation, Re- flection, Persistence. 1 Introduction Parametric polymorphism \nallows developers of object-oriented applications to declare generic classes, which can later be instantiated \nin order to fulfill specific requirements. Type parameterization has been used in C++ [29], Eiffel [22, \n231, ADA [30], and other languages. The feature is by no means only relevant to object orientation [21]. \nIn this introductory section we briefly explain the no-tions of parametric polymorphism (universal type \nquantifi-cation), bounded parametric polymorphism (bounded type *This material is based upon work supported \nin part by the U.S. Army Research Office under grant no. DAAH04-96-l-0192. Permlsson to make dqtal or \nhard copies of all or part of this work for personal or classroom use IS granted wthout fee prowded that \ncopses are not made 01 distributed for proftt or commercial advan-tage and that copies bear thts notice \nand the full atat~pn on the ftrst page lo copy othervase. to republish. to post on servers or to redlstr,bute \nto 11~1s. vxtutres pnor specific permlssnn and/of a fee. OOPSLA 98 lo/98 Vancouver. 13.C 0 1998 ACM l-581 \n13.005.8/98/0010...$5.00 quantification or constraint genericity in Eiffel [22, 23]), and F-bounded polymorphism \n(recursively bounded type quan- tification) [12, 5, 11. The examples that we will use throughout this \npaper are based on familiar generic classes representing collections and ordered collections. In illustration \n1.1, the generic class Collection has one formal type parameter T which stands for any type (universal \ntype quantification). This simple form of parametric polymorphism is supported by C++ [29] through templates. \nIllustration 1.1 (Generic Class) public class Collection(T) c . . . public boolean exists (T aElement); \npublic void addElement (T aElement); public void removeElement (T aElement); 1 In a type system which \nhas a root class Object as in Java, the situation of illustration 1.1 can be interpreted as if the upper \nbound of T were Object. In illustration 1.2, on the other hand, class OrdCollection has a formal type \nparameter T whose upper bound is Ord (bounded type quan-tification). Illustration 1.2 (Bounded Type Quant$cation) \npublic interface Ord t . . . public boolean lassThan (Object a0bj); public class OrdCollection<T implements \nOrd> extends Collection<T> : ... Note that method lessThan in illustration 1.2 takes one argument whose \ncompile-time type is Object. Using the type Object often leads to dynamic type checking. A more sophisticated \nform of bounded parametric polymorphism does not have this problem. In class OrderedCollection, shown \nin illustration 1.3, the upper bound is generically and re-cursively specified as Ordered<T>. Such a \nspecification of OrderedCollection can be done in a language that supports F-bounded polymorphism. The \nspecification simply means that instances of OrderedCollection contain only elements that can be compared \nwith elements of the same type. Illustration 1.3 (F-bounded Polymorphism) public interface Ordered<T> \nc . . . public boolean lessThan (T aobject); 1 public class OrderedCollection<T implements OrderedCT>> \nextends Collection<T> : **. These more sophisticated notions of parametric polymor-phism are obviously \njustified by some very pragmatic sit-uations [6]. However, they come with a price. Bounded (and thus \nF-bounded) type quantification may lead to un-decidable type checking [27]. They have additional practical \nlimitations to be discussed in section 5. Generic classes have to be instantiated before they are used. \nIn illustration 1.4 we show how instantiations are carried out. We say that OrderedCollection<Employee> \nis a class instantiated from a generic class OrderedCollection. In this case, Employee is an actual type \nparameter in the instantiation of OrderedCollection. Illustration 1.4 (Instantiation of Generic Classes) \npublic class Employee extends Person implements Ordered<Employee> c . . . public Employee (String aName, \nfloat asalary); public String getName0; public float getSalary0; public boolean lessThan (Employee aEmployee); \n1 OrderedCollection<Employee> empCollec = new OrderedCollection<Fmployee>(); empCollec.addElement ( \nnew Employee ( Jones , 50000.0)); Employee anEmployee = empCollec.getFirstElementO; // No type cast Several \nproposals exist for extending Java with paramet-ric polymorphism [lo, 26, 41. However, all of these propos- \nals have a common problem: they overlook the need to make the implementation techniques for parametric \npolymorphism compatible with Java Core Reflection. According to the terminology suggested in [26] there \nare two general kinds of implementation (or translation) tech-niques for parametric polymorphism: homogeneous \nand het-erogeneous. l A homogeneous translation produces generic code, shared by all instantiated classes. \nIn the generic class, every formal type parameter is replaced by the corre-sponding upper bound. l A \nheterogeneous translation produces specific code for each instantiated class. The fact that a homogeneous \ntranslation uses the bound type in place of the actual type parameter does not affect the correct performance \nof the Java Virtual Machine. This is because Java is based on single dispatch. In addition, this representation \ndoes not affect the correct performance of static type checking. Homogeneous translations are clearly \nmore space-efficient than heterogeneous translations, but they suffer from seri-ous limitations. The \nmain problem with homogeneous trans-lations is that the run-time information about classes and parameter \ntypes is incorrect, and in some cases unavailable. This is particularly relevant in languages that, like \nJava, support typed reflection. Heterogeneous translations, on the other hand, provide correct run-time \ninformation about instantiated classes, but information about generic classes and formal parameter types \nis unavailable. Moreover, we do not, think it is acceptable to allow the kind of unnecessary redundancy \nof code pro-duced by heterogeneous translations. Furthermore, there are some situations that neither \nheterogeneous nor homoge-neous translations can handle very well. In this paper we present a reflective \nsolution for imple-menting parametric, bounded and even F-bounded paramet-ric polymorphism. This solution \ndoes not have the problems of the earlier proposed implementation techniques. This, in particular, applies \nto reflective capabilities. Although our analysis applies to the Java technology, our proposal is gen- \nerally applicable. The rest of this paper is organized as follows. We first suggest a number of criteria \nfor evaluating techniques for implementing parametric polymorphism in section 2. In section 3 we indicate \nthat the support for run-time reflec-tion has crucial implications on the implementation tech-niques \nfor parametric polymorphism. In section 4 we ex-plain why some models of persistence are not compatible \nwith homogeneous translations. In section 5 we discuss as-pects of parametric polymorphism that may be \nproblematic in implementing bounded and F-bounded parametric poly-morphism. Known techniques and their \nlimitations are con- sidered in section 6. In section 7 we explore alternative solu-tions baaed on combining \nhomogeneous and heterogeneous translations. In section 8 we establish our main result to-gether with \nthe associated implementation techniques. We show that a proper reflective run-time support is in fact \nrequired for an adequate implementation of bounded and F-bounded polymorphism. Finally, our conclusions \nare pre- sented in section 9. 2 Evaluation Criteria As we will see, there are many plausible techniques \nfor im- plementing parametric polymorphism. Each technique can be evaluated against various criteria. \nSpecific criteria that we consider important are the following. 1. According to functionality: l Parametric \npolymorphism: (Actual) instantiation parameters can be of any type. l Bounded parametric polymorphism: \nEach actual type parameter has a non-generic upper bound. l F-bounded parametric polymorphism: The type \nof an actual parameter has a bound that may be generically and recursively defined. 2. From the perspective \nof instantiation (as sug- gested in [26]): a Homogeneous: Generic code for all instantiated classes. \nl Heterogeneous: Specific code for each instantiated class. 3. From the perspective of compiler and \nlinker de- sign: l Textual substitution: The source code of generic classes must be available. It is \nused as a kind of template or macro definition. l Code substitution: The source code of generic classes \nis not necessarily available to the compiler. The underlying information about generic classes is obtained \nfrom low-level code (e.g. a class file) that was previously produced by the compiler. l Persistent substitution: \nNot even low-level code (in the form of class files) is available to the com-piler. Only class objects \nin the persistent store are available to the compiler. 4. System support: l Static: Only the compiler \nis aware of parametric polymorphism (always required). l Semi-dynamic: The compiler and the loader are \naware of parametric polymorphism. l Dynamic: Not only the loader, but the run-time system in general \nis designed with parametric poly- morphism in mind (see section 8). 5. From the perspective of memory \nusage: Extensive secondary storage: Additional code (a class file) is produced for every instantiation. \nExtensive primary storage: Complete instantiated class objects are produced for every instantiation. \nModerate primary storage: Inherited, alias, or in- stantiated class objects are produced for each in- \nstantiation (see section 7). Space eficient: No objects or files corresponding to instantiated classes \nare produced. 6. Additional criteria : In relation to instantiation parameters: Whether actual type \nparameters are available at run time (see section 4). Reflective: The reflective information available \nat. run-time is complete and correct. Multiple dispatch: Support for multiple or cus- tomized dispatch \nis possible. Affects performance: An additional level of lookup for methods is required. Flexible: Constructors \nof formal type parameters may be invoked, and static fields can be part of the generic class and the \ninstantiated classes. Evidently, there is considerable overlap between these different sets of criteria. \nIn fact, it is demonstrably im-possible to produce techniques for all combinations of these criteria. \nThe results of our evaluation of known and introduced techniques for the implementation of parametric \npolymor-phism are summarized in table 8.1. These techniques and the meaning of each criteria will be \ndiscussed in more detail in the sections that follow. 3 Reflective Type Parameterization Java Core Reflection \n(JCR) [17] is a Java feature introduced with the JDK version 1.1. It allows programs to obtain (at run-time) \ninformation about the class of an object. In addi- tion to class Object and class Class, JCR includes \nclasses Method, Field and Constructor, which are part of package java.lang.reflect. So it is possible, \nfor example, to ob- tain at run-time the class of an object, its name, and its components (methods and \nfields). Moreover, methods and constructors discovered at run-time can be invoked using JCR. Since classes \ncan be generated and loaded at run-time, Java Core Reflection is a very useful feature with interesting \napplications. In this paper we propose an additional requirement for parametric polymorphism. In essence, \nparametric polymor-phism should not affect the behavior of the rejIective capabil-ities of a system. \nAs noted, a homogeneous translation is not compatible with reflection. This is because: . The precise \nnames of instantiated classes are not avail-able at run-time. The actual type parameters of an instantiation \nare un- known. There are no instantiated class objects. Information about the fields and methods of generic \nclasses is also incorrect: bound types are reported instead of formal type pa- rameters. Invocation of \na generic method with bound arguments is allowed (e.g. invoking method addElement of class Collection<Employee> \nwith an argument of type String using JCR would not result in an exception). Not only that; complete \nsupport for reflection would mean that it is possible to obtain information about whether a class is \ngeneric, instantiated from a generic, or even whether it is a formal type parameter. To the best of our \nknowl-edge, none of these capabilities exist in current systems. A heterogeneous translation might allow \na rudimentary imple-mentation of some of these capabilities, but true reflective support would require \na redesign of the run-time system and the core language classes. In section 8 we give an outline of a \ndesign that addresses these issues. 4 Considerations Related to Persistence In persistent systems, there \nare two kinds of objects: tran-sient objects (destroyed when the program terminates) and persistent objects \n(that outlive program execution). In an orthogonally persistent system [2, 71, objects of any class are \nallowed to persist. When persistence by reachability is im- plemented, objects must persist if they are \nreferred to by an-other persistent object. Hence, all of the components (direct and indirect) of a complex \npersistent object are promoted to persistence as well. A user can also make an object persistent by giving \nit a name. Named objects are sometimes referred to as persistent roots. Naming is necessary to allow \nretrieval of objects from Java Development Kit, Sun Microsystems, Inc. the persistent store across program \nsessions. In a high-level model of persistence, users are not concerned about files, or about storing \nand retrieving complex objects (which requires pointer swizzling and de-swizzling). Some models of persistence \nprovide a flat name-space for objects, and various methods to retrieve objects from the store, to name \nthem, to remove them, etc. Such is the case of PJama [3], which extends the Java technology with orthogonal \nand transitive persistence without any changes to the language. PJama requires an extension of the Java \nVirtual Machine in order to properly manage the persistent store [la]. This does not affect the correct \nperformance of the usual Java classes. Most of the functionality of PJama is provided by the PJStore \ninterface. A simplified form of the PJStore interface is shown in illustration 4.1. The model of persistence \nof PJama suffers from the same kind of problem parametric polymorphism hopes to solve: it requires explicit \ntype casts in situations where dynamic type checking is -in most cases -unnecessary. This is evident \nfrom illustration 4.1. Method getpRoot returns an object whose compile-time type is Object. The compiler \ncannot make any assumptions about the run-time type of the returned object. Unfortunately, parametric \npolymorphism does not provide a satisfactory solution to this problem. Illustration 4.1 (Simplijied \nPJStore Interface) public interface PJStore I . . . public void newPRoot(String aName, Object a0bj) ; \npublic Object getPRoot(String ahlame); public void discardPRoot(String ahlame);  An essential component \nof a sophisticated model of per- sistence is complex name space management. Languages such as Napier88 \n[24], OzC [25, 91, JavaSPIN [19], and MyT [a], have complex name space management facilities. Some of \nthese languages allow references to the names of persistent objects in the same way as any other vari-able \nname. This is not only natural and preferable, but it is also a consequence of orthogonality. If these \nnames are not declared with a compile-time type in the source code, a homogeneous translation for parametric \npolymor-phism can be shown to be insufficient. This is because the compiler must be aware of the precise \ntype of a persistent object (e.g. Collection<Employee>), not just its generic type. Clearly, under a \nhomogeneous translation the com-piler would only be able to find out about generic class names (i.e. \nthe names of generic classes that exist in the persistent store). Another consideration related to persistence \nis that the inherent reflective nature of the object-oriented paradigm leads to the view that classes \nare in fact objects. Although this has been typical of untyped languages [14], Java core reflective capabilities \nare based on the same view applied to a typed object-oriented language. Due to persistence by reachability, \nthe class of a persis-tent object must exist in the persistent store. This has im- portant implications \non heterogeneous translations. Persis-tent instantiated classes increase the chances of there being considerable \namounts of redundant information. Formerly known as PJava. Note that in Java there are class objects \nand class files. In a persistent system, class objects may be placed in the persistent store. The existence \nof both persistent class files and persistent class objects is by itself a redundancy, which is accepted \nin PJama in order to make it compatible with Java. There are additional indirect correlations between \npara- metric polymorphism and persistence. Persistent collections, for example, can be used as part of \nan object-oriented database. The benefits of using parametric polymorphism to define collection classes \nis well known.  5 Additional Considerations Heterogeneous translations appear to be functionally supe- \nrior to homogeneous ones, since homogeneous translations are simply incorrect with respect to reflection. \nHeterogeneous translations do have problems of their own. Instantiated classes are almost identical to \nthe generic class. They only differ in the actual type parameters; oth- erwise, the underlying code is \nthe same. This redundancy can be serious, particularly in large persistent systems. If classes can persist, \nthe number of redundant instantiated classes might increase considerably with time. Some limitations \nof implementation techniques for para- metric polymorphism have been reported elsewhere [4]. Con- sider, \nfor example, static fields. These are intended to be class components. In other words, every instantiated \nclass is expected to have its own static fields. With a homogeneous translation, there is only one (generic) \nclass object shared by all instantiated classes. Consequently, static fields could be shared by many \nclasses. This seems to make homogeneous translations unacceptable. Consider, nevertheless, a case in \nwhich it might make sense to expect a static field to be shared by all instanti-ated classes. For example, \nif we had a static field named MaxNumberOfElements in chss Collection, it seems more reasonable to have \nonly one copy of such a field. This means that heterogeneous translations may also be viewed as inade- \nquate with respect to static fields in some situations. In fact, the whole idea of whether static fields \nare class components or not becomes problematic when parametric polymorphism is considered. A possible \nsolution to this dilemma is outlined in section 8.1. Both bounded and F-bounded polymorphism are conser- \nvative, as are typing techniques in general. Unless a type is declared to extend or implement the bound, \nit will be re-jected by the compiler as the actual type parameter, This is in spite of the fact that \na much more complex structural type analysis could reveal that the type is in fact equipped with the \nappropriate methods. This issue is comparable to the issues involved in name versus structural type equiva-lence. \nConsider, for example, illustration 1.2. We are not allowed to instantiate OrdCollection with String \nas the ac-tual type parameter, even though strings do have a method named lessThan (in Java). An implementation \nof parametric polymorphism that is based on textual substitution (see section 6.1), on the other hand, \ndoes not necessarily have this problem. This is be- cause the compiler is not required to check whether \nthe ac-tual type parameter is bounded by Ord, but instead whether there is structural equivalence between \nthe actual parameter types and the formal parameter types. Type safety is not compromised. Type checking \nis just delayed, since checks that are normally performed while compiling a generic class would be performed \nlater, during its expansion (or textual substitution). It is also possible to define an ordered collec- \ntion that takes elements of type String vrithout parametric polymorphism. The fact that constructors \nare usually not inherited in object oriented languages presents an additional problem for bounded parametric \npolymorphism. Whether the compiler should make assumptions about the constructors of an ac- tual type \nparameter, based on the constructors of the upper bound, is unclear and problematic. Consider illustration \n5.1. Neither of the two constructor invocations can be guaran- teed to be correct after an instantiation. \nFurthermore, any of the two could be correct. Again, this kind of problem is not necessarily present \nwith textual substitution. Illustration 5.1 (Constructors of Formal Type Parameters) public class PersonCollection<T \nextends Person> t . . . public void a-method0 c // Which of these statements is incorrect? T person1 \n= new T( LJonesJJ); T person2 = new T( Smith , 50000); ) Heterogeneous translations might be able to \nsupport in-vocations to constructors of formal type parameters, as sug- gested in [4], but this necessarily \nrequires a dynamic check. For homogeneous translations the problem is more serious: constructors of formal \ntype parameters cannot be invoked, since the generic class is unaware of any instantiation pa-rameters. \nAnother limitation of homogeneous translations is that they cannot properly handle multiple dispatch. \nThe kind of dynamic overload resolution required in multiple dispatch is clearly implausible if different \n(instantiated) classes are in-distinguishable at run time. This limitation is not currently relevant \nto the Java language, but it is worth mentioning. 6 Known Techniques and their Limitations In this section \nwe consider several well known techniques for implementing parametric polymorphism, and their inherent \nlimitations. 6.1 Textual Substitution (TS) The usual implementation of parametric polymorphism in C++ \n[29] is simple. It treats declarations of generic classes as templates or macros. Whenever an instantiation \nof a generic class is needed, the compiler replaces formal type parameters with actual types, effectively \ndeclaring the in- stantiated class. This technique is called textual substitu-tion, and it requires the \nsource code of generic classes to be available (usually in header files) during the compilation of clients. \nTextual substitution is one of many possible varia-tions of heterogeneous translations. In C++, a desirable \nsoftware methodology is to place class interfaces in header files and implementation of meth- ods in \nseparate files. This enforces the information hiding principle. However, this discipline presents a problem \nfor textual substitution. In order to carry out a textual substi- tution, both the interface and the \nimplementation are nec- essary, at least when formal type parameters are involved. This either requires \nthe implementation to be placed in the header file, or the existence of reference from the header file \nto the implementation file. It is not clear how that could actually be achieved in C++. Using textual \nsubstitution to implement parametric poly- morphism in Java seems implausible. This is because the source \ncode of classes is not required to be available. Fur- thermore, Java currently lacks a mechanism for \nincluding header files. As hinted in section 5, textual substitution can lead to an implementation of \nparametric polymorphism that is more flexible than either bounded or F-bounded parametric polymorphism. \nFor example, it would be possible to imple- ment an ordered collection whose elements are only required \nto have a method named lessThan, as opposed to an up-per bound Ord. The compiler only performs complete \ntype checking whenever an instantiation is encountered. Even though the philosophy underlying the design \nof the Java language is contrary to textual substitution, it would be relevant to determine whether a \nsimple and flexible form of parametric polymorphism based on structural equivalence of classes (as opposed \nto name equivalence) could be applied to Java extensions. In any case, the kind of compiler behavior \nrequired during an instantiation based on structural equiv-alence raises some concerns about algorithmic \ncomplexity, readability, and decidability. 6.2 A Homogeneous Translation (HM) A homogeneous translation \nhas been implemented in Pizza [26], a superset of the Java language that supports bounded and even F-bounded \nparametric polymorphism. This implemen-tation technique is referred to as HA4 in this paper. We now provide \na brief description of how generic classes and their clients can be compiled in order to implement a \nhomogeneous translation. Although generic classes can be clients of other generic classes, for simplicity \nwe assume that they are disjoint. Compilation of a generic class: Formal type param-eters are assumed \nto be their corresponding bound types. Type checking proceeds as usual based on this assumption. Additionally, \ninformation about the for-mal type parameters is hidden in the class file in a way that does not affect \nthe run-time system. Compilation of client classes: It proceeds as usual, ex-cept when a reference to \nan instantiated class (e.g. Collection<Employee>) is found, or when an object whose compile-time type \nis an instantiated class must be type checked. In such cases, the compiler must in-terpret the generic \nclass file (e.g. Collection.class ) that corresponds to the generic class. Where a formal type parameter \noccurs (e.g. T), the compiler should make the necessary adjustments to interpret it as the actual type \n(e.g. Employee). Since the instantiation arguments are always available in the source code (in a language \nsuch as Pizza), finding out about the ac-tual type parameters is not a problem. As far as the Java Virtual \nMachine is concerned, the name of the in- stantiated class will simply be the name of the generic class. \nThat is, all instantiated classes and the generic class appear to be the same. As indicated earlier, \nthe main problem of homogeneous translations is that they provide incomplete and incorrect reflective \ninformation about instantiated classes. A valid concern is whether a homogeneous translation is able \nto properly deal with F-bounded polymorphism, as formal type parameters are replaced by the corresponding \nupper bounds in the code of generic classes. When the bound type is generic, like in OrderedCollection, \nthe formal type parameters will be replaced by the generic parts of the up- per bounds. For example, \nin OrderedCollection, references to the formal type parameter T would be replaced by the generic class \nOrdered. Even though Ordered is generic, re-call that the run-time system would acknowledge the ex-istence \nof a class whose name is exactly Ordered (and is oblivious about Ordered<Employee>) when a homogeneous \ntranslation is implemented. 6.3 A Heterogeneous Translation (HT) A straight-forward heterogeneous translation \nconsists of pro- ducing a class file every time a new instantiation is encoun- tered. This type of implementation \nhas been reported in [26] as part of the Pizza language, even though the current distri-bution appears \nto only support a homogeneous translation. This file-based heterogeneous translation will be referred \nto as HT. Some of its implementation details follow. l Compilation of a generic class: The class files \npro-duced by the compiler do not have to be valid in this case. Except for that, compilation of generic \nclasses can proceed as in HM. l Compilation of client classes: Whenever a reference to an instantiated \nclass is found, the compiler produces an additional class file (e.g. Collection$Employee$.class with \nactual type parameters instead of formals. This instantiated class file must be valid, so that the vir-tual \nmachine can interpret it. Unlike HM, the com-piler must generate code that instructs the virtual ma-chine \nto load instantiated classes. Generic class files are never loaded. The main shortcoming of this implementation, \nas with all other heterogeneous translations, is the fact that redundant information is produced. In \nthis case, a considerable number of nearly-identical files with strange (and long) names might be created \nby the compiler. 6.4 Load-Time Instantiation (LI) The proposal found in [4], which we will refer to \nas LI, is sim- ple and attractive. Only one class file is produced for each generic class. An extended \nclass file format is used to en-code type constraints. The class loader is extended to parse the names \nof instantiated classes, to locate the correspond- ing generic class, and to make the appropriate replacements \nrequired to produce class instantiations. In essence, LI is a heterogeneous translation that does not \nproduce extra class files. This heterogeneous form of load-time instantiation does, however, require \nan extension to the class loader, which can be viewed as an extension to the run-time system. Moreover, \nit can produce many nearly-identical class objects. The main difference between producing class objects \nand producing class files is that class objects are usually transient, while ) 1 Collection.class Figure \n6.1: With heterogeneous load-time instantiation, the loader creates class objects for each instantiated \nclass. class files persist. But this is not necessarily the case when a persistent store is available. \nCompilation of a generic class: It can proceed as in HM. However, class files do not have to be valid. \nIn [4] it is suggested that the format of class files be ex-tended. This would apply to future versions \nof Java. But it is also possible to create valid Java class files (possibly abstract) as in HM or MyT \n[8]. Compilation of client classes: It is essentially the same as in HT. Class loading: The Java class \nloader may be requested to load instantiated classes. This means that the class loader has to be extended \nto parse and interpret the special names of instantiated classes. When such a name is detected, and if \nthe instantiated class was not previously loaded, the class loader proceeds as follows. 1. Read the generic \nclass file (e.g. LLCollection.class ). 2. Replace formal type parameters with actuals in the memory \nimage of the generic class file. 3. Create a class object for the modified class file image, and give \nit the appropriate instantiated name.  Note that no class objects are created for generic classes. \nIt is also possible to implement a homogeneous transla-tion by extending the class loader. This homogeneous \nform of load-time instantiation is not particularly relevant, since HM implements the same functionality \nwithout extending the class loader.  7 Toward a Solution: Inheritance and Alias Classes (IH &#38; AC) \nClearly, our goal is to come up with an implementation that addresses the major limiting factors, i.e. \nan implementation that does not produce large amounts of redundant informa-tion, and that at least provides \ninstantiated class names at run time; preferably one that is reflective. By this we mean that complete \nand correct type information about classes, fields, methods and constructors should be available at run \ntime. A first step toward this goal is instantiation through in-heritance. This is a technique we introduced \nin a separate paper that describes the implementation of the declarative language MyT [8], and we will \nrefer to it as IH. The tech-nique requires an extension of the class loader, like LI, but the size of \nthe instantiated class objects is minimal. This is because these class objects are inherited from the \ngeneric class, which contains all of the necessary functionality. ZH basically amounts time instantiation. \ngiven next. to S a pseudo-homogeneous ome of its implementation form of load- details are . Compilation \nof a generic class: It can proceed as in HM or LI. The class files generated by the compiler should \nbe valid to make the class loader easier to im- plement. The class files produced by the compiler of \nMyT are valid and marked abstract. l Compilation of client classes: It can proceed essen-tially as in \nLI, with a minor difference due to the particular model of persistence described in section 4. When a \npersistent name without a declared compile-time type (or a type cast) is encountered, the compiler must \nfind out what its precise type is. The compiler obtains the type information for the object from the \npersistent store. This operation is equivalent to in-voking obj .getClass() .getName(). If the class \nof an object is instantiated from a generic, the name of the instantiated class will contain the actual \ntype param-eters necessary to perform the usual type checks. l Class loading: The Java class loader is \nextended to handle requests of generic instantiations as in LI. But even though IH produces a separate \nclass object for every instantiated class, these class objects are nearly empty subclasses of the generic \nclass (see figure 7.2). Note that LIdoes not produce class objects for generic classes. IH does. What \ndoes IH solve? For one, unlike HM, it provides correct instantiated class names at run-time. This can \nbe an important consideration for some models of persistence (see section 4). Second, it provides more \ncomplete reflective information, since it allows users to obtain the actual type parameters at run-time, \nalthough in a rudimentary manner. Third, its memory usage is considerably smaller than that of HT or \nLI. Nevertheless, IH introduces a few problems that HM does not have: l Incorrect reflective information \nabout the parent of an instantiated class may be given as a result. This seems to be a minor shortcoming \nthat can be over-come by implementing a rudimentary replacement for getsuperclass in Class. l Java Core \nReflection reports that all generic classes are abstract. (If generic class files are not marked abstract, \nthis problem is solved but users are then allowed to create objects whose type is generic). l The run-time \nsystem may be burdened by an addi-tional level of lookup for methods (due to inheritance). I I Collection.class \n Figure 7.2: Under a pseudo-homogeneous technique, such as IH, the class loader creates nearly-empty \nextended classes by inheritance or aliasing. Contrast with figure 6.1. Alternatively, we could use a \nconstruct we refer to as an alias class. An alias class is very much like a nearly-empty inherited class. \nHowever, it has run-time system support. A technique that relies on alias classes will be referred to \nas AC. This technique solves one of the problems introduced by Ii3 since AC has run-time support, Java \nCore Reflection can report the correct parent class. Optimized treatment of alias classes by the run-time \nsystem also seems plausible. The only advantage of IH over AC is that it can be cur- rently implemented \nwithout modifications to the Java Vir-tual Machine or to the core Java classes. In any case, both IH \nand AC still do not solve the problem of providing com-plete and correct reflective support. This is \nbecause bound types are reported in place of actual type parameters in method and field signatures. \n8 A Reflective Solution Further developments along the lines of alias classes lead to an implementation \ntechnique that is satisfactory with re-spect to our goals: correctness of type information available \nat run-time, compactness, and reliability. The two techniques introduced in this section solve nearly \nall of the difficulties of all of the previous techniques by re-lying on run-time and in fact reflective \nsupport of bounded and F-bounded parametric polymorphism. They have the crucial advantage of being compatible \nwith Java core reflec- tive capabilities. Implementing these techniques requires modest exten-sions to \nthe Java Virtual Machine, the usual extensions of the standard class loader, and extensions of the Java \nCore Reflection classes. Like all implementation techniques ex-tending Java with type parameterization, \nour reflective tech-niques naturally require a new compiler for the extended language as well. The format \nof class files requires a minor addition: a flag (e.g. ACC-GENERIC) that marks generic class files. The \nJava Virtual Machine interpreter itself does not require major changes, but the native support must be \nextended to handle the changes to the core classes. We are currently implementing only IH, which is the \nba- sis for all of the other implementation techniques introduced in this paper. As indicated earlier, \nIH only requires extend-ing the compiler and the class loader. Implementing the re-flective techniques \nwe introduce in this section, on the other hand, would effectively constitute an effort aimed at devel-oping \na more advanced version of the Java system. 8.1 Extended Java Core Reflection (RF) Our first reflective \ntechnique, which we will refer to as RF, requires the run-time system to be aware of parametric poly-morphism. \nExtensions to the core Java classes are also needed. The details of what we mean by this can be better \nunderstood by looking at our proposed extensions to Java Core Reflection, which follow. In addition to \nthe usual kinds of classes supported by Java, i.e. abstract, interface, primitive and array, our sug-gested \nextension adds the following kinds: l Generic: Much like an abstract class; there cannot be objects whose \ntype is a generic class. Only generic classes can extend generic classes. l Instantiated: Like an alias \nclass, this is a nearly empty class that has a reference to a generic class. It may con- tain all static \nfields corresponding to the instantiated class. l Formal Parameter: Also a nearly empty class. It has \na reference to the corresponding bound type, and pos-sibly to its generic class. Illustration 8.1 (Proposed \nExtensions to JCR) public class Class < // Usual methods: public boolean isInterface0; public boolean \nisAbstract0; public String getName0; public Method getDeclaredMethod (String aName, Class [I aParemTypes) \n; . . . // RF general methods: public boolean isGeneric(); public boolean isInstantiated0; public boolean \nisFormalParameter0; // RF methods for instantiated classes: public Class getGeneric ; public ClassC] \ngetActualParameters0; // RF methods for formal type parameters: public Class getUpperBound0; public \nint getPositionOfFormal0;  // RF methods for generic classes: public Class[] getFormalParameters0; Class \ninstantiate (ClassC] aArg) ; ) As to the name of formal type parameter classes, they must either be unique \n(e.g. Collection%T), or they must be managed internally. In other words, formal type parameters would \nnot be available through invocations to Class. f orName or ClassLoader. loadclass. The same goes for \nformal in-stantiations, such as Ordered<T> in figure 8.3. Clearly, not only Class has to be extended \nto implement RF. Some of the usual methods of classes Method, Field and Constructor have to be extended \nas well. In addition, the native class loader must also be modified to properly deal with the new kinds \nof classes. Illustration 8.2 (Extension to class Method) public class Method c // Usual methods: public \nString getName(); public Class getReturnType0; public Object invoke (Object aRecv, Class[l aParams); \n// [. . .I New RF method: public Method getActualSignature (Class[] aAct); 1 This implementation technique \nsolves problems that nei-ther homogeneous nor heterogeneous translations can deal with. Recall that in \nsection 5 we mentioned that in some cases we might want static fields to belong to the generic class; \nin some other situations we may want them to be part of each instantiated class. A possible solution \ncompatible with this implementation technique is the following: allow field declarations whose attributes \nare specified as generic static. It just so happens that the word generic is a key- word in the Java \nlanguage, so this addition would not affect backward compatibility. Illustration 8.3 (Extension to a \nmethod of Class) public class Class f . . . public Method getDeclaredMethod (String aName, Class 11 aParamTypes) \nc if (isInstantiated C // Assume single dispatch Method pMethod = getGeneric0. getDeclaredMethod(aName, \naparameters); return pMethod.getActualSignature ( getActualParameters0); ) else // Other cases : ..* \n The intention is clear. Through complete run-time sup-port of parametric polymorphism, we end up with \nan imple- mentation technique that does not have the problems of the previous techniques. It provides \ncorrect reflective informa-tion, as intended by Java Core Reflection, and it does not produce redundant \nclass objects or class files. 8.2 Generic Code Sharing (RS) The shortcoming of RF is that it adds additional \nlevels of lookup for methods: from instantiated to generic classes, and from formal parameter types to \nbound types. A technique that would not be as complete with respect to reflective type information, but \nmore compact and faster, is one where there are no class objects corresponding to for- mal type parameters. \nWe will refer to it as RS. In RS, the run-time system is aware of only two new kinds of classes: instantiated \nclasses and generic classes. Instantiated classes contain instantiated method and field signatures. Generic \nclasses essentially become repositories of shared code. In other words, methods of different classes \nContains au of the I I OrderedCollectiomclass Figure 8.3: RF is based on run-time support of three new \nkinds of classes: generic, formal and instantiated. This reflective technique also introduces several \nrelations between classes. Abbrev. Description Source Memory Perform. Actuals Mult. disp. Reflection \nTS Textual Substitution ++ + + ++ HM Homogeneous + +++ ++ HT Heterogeneous + ++ + + ++ LI Load-time instantiation \n+ ++ + + ++ IH Inst. by inheritance + ++ + + + AC Inst. by class aliasing + ++ + + + RF Reflect. technique \n1 + ++ + ++ + ++++ RS Reflect. technique 2 + ++ ++ ++ + +++ Table 8.1: Evaluation of implementation \ntechniques for parametric polymorphism. instantiated from the same generic have actual (instanti-9 Conclusions \nated) signatures; but corresponding methods refer to the same generic code. The implementation techniques \nfor parametric, bounded and RS is very much like AC or IH. The difference is that F-bounded polymorphism \nwe have considered are meant to instantiated classes are not really empty. They contain be used to develop \nextensions to the Java programming lan-method and field signatures with actual types. But they guage. \nNevertheless, our observations are general enough do not contain code. to be applicable to other typed, \npersistent and reflective The reflective information about generic classes is not object-oriented languages. \nentirely correct in RS. Bound types are reported instead of One of the results of this paper is that \nheterogeneous formal type parameters. However, it could be argued that translations are inherently more \ncorrect than homogeneous information about generic classes should not be available ones in languages \nthat support run-time reflection, sophisti-at run-time. In other words, only the information about cated \nmodels of persistence, or multiple dispatch. However, instantiated classes is available through reflection. \nheterogeneous translations can create redundant informa- There is some room for debate on the availability \nof cor- tion. This may be serious in some persistent systems. Fur-rect and complete information about \ngeneric class objects. thermore, there are situations that neither homogeneous nor For example, compiler \ndevelopers may eventually argue that heterogeneous translations can handle very well. this information \nis needed in order to compile client classes. Unlike all other approaches, the solutions we propose This \nmay be a problem in persistent systems where class files in this paper offer correct reflective support \nas intended by have become obsolete, and all of the information about com-Java Core Reflection. This \nis the main contribution of our piled classes is obtained from class objects. An alternative implementation \ntechniques, in addition to the fact that they is to simply say that generic classes are not really classes; \nsolve the problems of previously suggested techniques. they are shared method tables that contain additional \ninfor-The first reflective technique we have developed solves mation about the location of formal type \nparameters. nearly all of the inadequacies of the previous techniques. This technique makes the run-time \nsystem aware of three new kinds of classes: generic, instantiated and formal. An issue that must be considered \nis whether information about generic classes should be available to users at run time. It seems that \ninformation about formal type parameters should be managed internally. The second technique is similar. \nThe main difference is that in the second technique there are no class objects cor-responding to formal \ntype parameters. Generic classes basi- cally become repositories of shared code with bound types in place \nof formal type parameters. Instantiated classes contain instantiated method and field signatures. This \nimplementa-tion is suitable when users are not allowed to make run-time inquiries about generic classes. \nIn other situations, the first technique is more complete with respect to the reflective capabilities \nof Java. The two reflective techniques presented in this paper ef-fectively acknowledge the fact that \ngeneric classes are type functions and not types (classes). Because of that, generic classes have a separate \nrepresentation, which is in fact differ- ent from the representation of classes. On the formal side, \nit is well known that viewing type functions as types leads to a set-theoretic paradox [28]. Our result \nis that the situation is not much different on the implementation side. Generic classes are not classes, \nbut rather class functions. Because of this, they must have a separate representation. This is probably \nmore evident in our second reflective technique, where generic classes can be better viewed as shared \nmethod repositories. Our results also show that contrary to the common be-lief that parametric, bounded \nand F-bounded polymorphism can be handled statically, proper run-time support is in fact required in \nsystems that provide reflective capabilities. Amidst all the existing proposals for extending Java with \nparametric polymorphism, our contribution is to point out that the correct performance of reflective \ncapabilities have been overlooked. It is hard to believe that any extension of Java with parametric polymorphism \nwould be acceptable unless it supports Java core reflective capabilities. Our hope is that the techniques \nand issues discussed in this paper are seriously taken into consideration in future versions of Java, \nif and when the language is officially extended with parametric polymorphism. References [II M. Abadi \nand L. Card&#38;i. ceedings of ECOOP 96, Springer-Verlag, Vol. 1098, M. Atkinson, F. Bancilhon, Zdonik. \nThe Object-Oriented 121 On Subtyping and Matching. In Pro-Lecture Notes in Computer Science, pp. 145-167, \n1996. D. Dewitt, K. Dittrich, D. and S. Database System Manifesto. In Pro- ceedings of the First Object-Oriented \nand Deductive Database Conference, Kyoto, pp. 223-240, 1989. M. P. Atkinson and L. Daynes and M. J. Jordan \nand T. Print&#38;s and S. Spence. An Orthogonally Persistent Java. ACM SIGMOD Record, 25(4), pp. 68-75, \n1996. 0. Agesen, S. N. Freud, J. C. Mitchell. Adding Type Parame- terization to the JavaTM Language. \nProceedings of OOPSLA 97, pp. 49-65, 1997. [41 S. AlagiC. F-bounded Polymorphism for Database Programming \nLanguages. In Proceedings of the 2nd East-West Database Work-shop, Workshops in Computing, Springer-Verlag, \npp. 125-137, 1994. [51 S. AlagiC. The ODMG Object Model: Does it Make Sense? In kl Proceedings of the \nOOPSLA Conference, pp. 253-270, ACM, 1997. M. Atkinson and R. Morrison. Orthogonally Persistent Object \nSystems. VLDB Journal, 4, 1995, pp. 319-401. [71 [B] S. AlagiC, 3. H. Solorzano, D. Gitchell. Orthogonal \nto the Java Im-perative. In Proceedings of ECOOP 98, Lecture Notes in Con-puter Science, 1998 (to appear). \n19) F. Bancilhon, C. Delobel, and P. Kanellakis (Eds.) Buildmg an Object-Oriented Database System: The \nStory of 02, Morgan Kauffman, 1992. [lo] J. A. Bank, B. Liskov, and A. C. Myers. Parameterized Types \nand Java. Technical Memorandum MIT LCS TM-553, Laboratory for Computer Science, Massachusetts Institute \nof Technology. [ll] K. Bruce, A. Schuett and R. van Gent. PolyTOIL: a Type-Safe Polymorphic Object Oriented \nLanguage. In Proceedings of ECOOP 95, Lecture Notes in Computer Science, Springer-Verlag, Vol. 952, pp. \n27-51, 1996. [12] P. Canning, W. Cook, W. Hill, J. Mitchell, and W. Olthoff. F-bounded Quantification \nfor Object-Oriented Programming. In Functional Prog. and Computer Architecture, pp. 273-280, 1989. [13] \nW. R. Cook. A proposal for Making Eiffel Type Safe. The Com-puter Journal, 4, 1989, pp. 305-311. [14] \nJ. Ferber. Computational Reflection in Class-Based Object-Oriented Languages. In Proceedings of the OOPSLA \n89 Con-ference, ACM, pp. 317-26, 1989. [15] J. Gosling and B. Joy and G. Steele. The JavaTM Language \nSpecification, Addison-Wesley, 1996. [16] D. H. H. Ingalls. A Simple Technique for Handling Multiple \nPoly-morphism. In Proceedings of OOPSLA 86, ACM, pp. 347-349, 1986. [17] Java Core Reflection, JDK 1.1, \nSun Microsystems, Inc., http://java.sun.com. [18] M. Jordan. Early Experiences with Persistent JavaTM. \nIn Pro-ceedings of the First Int. Workshop on Persistence and Java, SUN Microsystems Laboratories, 1996. \n[19] A. Kaplan, G. A. Myrestrand, J. V. E. Ridgway and J. C. Wile-den. Our SPIN on Persistent JavaTM: \nThe Java SPIN Approach. Technical Report, University of Massachusetts, Amherst, Com-puter Science, Number \nUM-CS-1996-090, December 1996. [20] T. Lindholm and F. Yellin. The Java Virtual Machine Specifi-cation. \nAddison-Wesley, 1996. [Zl] R. Milner. A Theory of Type Polymorphism in Programming. Journal of Comp. \nSyst. Sm., Vol. 17, pp. 348-375, 1977. [22] B. Meyer. Eiflel: the Language, Prentice-Hall, 1992. [23] \nB. Meyer. Object-Oriented Software Construction, Prentice-Hall, 1997. [24] R. Morrison, A. L. Brown, \nR.C.H Connor and A. Dearle. Napier88 Reference Manual. Universities of Glasgow and St. An-drew Technical \nReport PPRR-77-89, 1989. [25] 02 Technology. 02 C Reference Manual, Release 4.6, November 1996. (261 \nM. Odersky and P. Wadler. Pizza into Java: Translating Theory into Practice. Conference Record of POPL \n97: The 24th Svmpo-sium on Principles of Programming Languages, ACM, 1967, bp. 146-159. [27] B. C. Pierce. \nBounded Quantification is Undecidable. In Pro-ceedings of the POPL Conference, pp. 305-315, ACM, 1993. \n[28] J. C. Reynolds. Polymorphism is not Set-Theoretic. In Proceed- ings Intl. Symp. on the Semantics \nof June 1984, Lecture Notes in Computer 145-156, Springer-Verlag, 1984. [29] B. Stroustrup. The Wesley, \n1993. Cf+ Programming [30] US Department of Defense. gramming Language, 1980. Reference Data Types, \npp. 27-29, Science, Vol. 173, pp. Language, Addison-Manual for the Ada Pro-   \n\t\t\t", "proc_id": "286936", "abstract": "A number of inadequacies of existing implementation techniques for extending Java&amp;trade; with parametric polymorphism are revealed. Homogeneous translations are the most space-efficient but they are not compatible with reflection, some models of persistence, and multiple dispatch. Heterogeneous translations, on the other hand, can potentially produce large amounts of redundant information. Implementation techniques that address these concerns are developed. In languages that support run-time reflection, an adequate implementation of parametric, bounded and F-bounded polymorphism is shown to require (reflective) run-time support. In Java, extensions to the core classes are needed. This is in spite of the fact that parametric polymorphism is intended to be managed <i>statically</i>.", "authors": [{"name": "Jose H. Solorzano", "author_profile_id": "81100106335", "affiliation": "Computer Science Department, Wichita State University, Wichita, KS", "person_id": "P148572", "email_address": "", "orcid_id": ""}, {"name": "Suad Alagi&#263;", "author_profile_id": "81100420201", "affiliation": "Computer Science Department, Wichita State University, Wichita, KS", "person_id": "P270877", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/286936.286959", "year": "1998", "article_id": "286959", "conference": "OOPSLA", "title": "Parametric polymorphism for Java: a reflective solution", "url": "http://dl.acm.org/citation.cfm?id=286959"}