{"article_publication_date": "10-01-1998", "fulltext": "\n Role Model Based Framework Design and Integration Dirk Riehle UBS AG, Ubilab P.O. Box CH-8098 Ziirich \n++41 12342702,++41 12364671 Dirk.Riehle @ubs.com or riehle @acm.org http://www.ubs.comlubilab ABSTRACT \nToday, any large object-oriented software system is built using frameworks. Yet, designing frameworks \nand defining their interaction with clients remains a difficult task. A pri- mary reason is that today \ns dominant modeling concept, the class, is not well suited to describe the complexity of object collaborations \nas it emerges in framework design and inte- gration. We use role modeling to overcome the problems and \nlimitations of class-based modeling. Using role models, the design of a framework and its use by clients \ncan be de- scribed succinctly and with much better separation of con- cerns than with classes. Using \nrole objects, frameworks can be integrated into use-contexts that have not been foreseen by their original \ndesigners. Keywords Frameworks, design methods, design patterns INTRODUCTION Frameworks are a central \nconcept of large-scale object- oriented software development. They promise increased productivity, shorter \ndevelopment times, and higher quality of applications [9, 10, 5, 61. Many examples show that these goals \ncan be reached, but even more examples show that they can be missed easily as well [ 19, 3 11. Obviously, \nframework-based development of object-oriented systems is not yet a mature discipline. In particular, \nthere is no coher- ent theory for the design of object-oriented frameworks and their integration into \ndifferent use-contexts. A primary reason for today s problems with designing and integrating frameworks \nis the dominant use of class-based modeling. Classes are excellent means for describing con-cepts and \nabstractions from an application domain, but they fail to adequately describe object collaboration behavior. \nWork on specifying and composing object collaborations, most prominently [ 141, has addressed these issues, \nbut has not yet provided us with concepts and methods that specifi- cally deal with framework design \nand integration. All ap-proaches we know of ignore the intermediate framework ~e~~~sslon to make dlgttal \n01 hard copses of all or part of this work to, Personal or ClaSSrOOm use IS granted wthout fee prowded \nthat COPleS are not made or distributed for proflt or commercial advan~ tage and that COPES bear this \nnotice and the full cltatlpn on the first page 10 COPY otherww, to republish. to post on sewers or to \nm-ktdxm to hsts. requtres pm spwf~c perm~ssbon .WKU,X a fee. OOPSLA 98 10/98 Vancouver. B c 0 1998 ACM \n1-581 13.005.8/98/0010.. $5.00 Thomas Gross Departement Informatik, ETH Ziirich CH-8092 Ziirich School \nof Computer Science Carnegie Mellon University Pittsburgh, PA 152 13  level and directly jump from simple \nmodels to large-scale components and systems. When designing a framework, developers must clarify which \nresponsibilities an object has, on which use-contexts these responsibilities depend, and how the object \ncombines the different responsibilities. They must further define the collaborative behavior of objects, \nwhich includes the differ- ent purposes of an object collaboration, and how they are composed. When defining \nhow clients may interact with a framework, developers must clarify what a framework of-fers to them, \nand how they may make use of it. This in-cludes not only the services offered by a framework, but also \nthe requirements it puts on its context before it can be used. In this paper, we analyze the problems \nof class and object collaboration complexity and their impact on framework design and integration. We \nintroduce a role modeling ap-proach to describe object-oriented designs. We then focus on how role modeling \nsupports the design and integration of object-oriented frameworks. We discuss how role models address \ndifferent aspects of frameworks and framework extensions, and how role models are used to define client \ninteraction with frameworks. The idea of role modeling is not new. The OOram method- ology developed \nby Reenskaug et al. [24] presents a general approach to modeling objects and object collaborations using \nroles and role models. However, OOram s focus is on objects; it does not provide modeling concepts that \nspecifi- cally address and support framework design and integra- tion. In this paper, we build on the \nrole modeling founda-tion developed by prior research and explore framework design and integration based \non role modeling. Section 2 describes a pertinent set of framework design and integration problems that \nare addressed in this paper. Sec- tion 3 describes the role modeling metamodel, which forms the foundation \nof our approach. Section 4 and Section 5 describe framework design and integration concepts, re-spectively, \nbased on the role modeling approach. Section 6 analyzes different aspects of the approach and discusses \nhow far they help overcome the problems described in Sec- tion 2. Section 7 describes related work and \nSection 8 con- cludes the paper. PROBLEMS IN FRAMEWORK DESIGN AND INTEGRATION Framework design involves \ndefinition and description of the static and the dynamic aspects of a framework. A framework designer \nor a client who aims to understand the structure and dynamics of a framework (described by a set of abstract \nclasses) must address a number of issues: . Clrlss complexity. To understand the purpose of a class, \nit is essential to understand how this class interacts with its clients. Every non-trivial class has \na number of clients that use their instances for different purposes. Thus, a framework design methodology \nmust provide means for describing interactive behavior of instances of a class as viewed from a particular \nuse-context. An unstructured class interface, which hides the different ways of using the class, does \nnot provide a way to identify its use in a spe- cific context. . Object collaboration. To understand \nhow a framework works, one needs to understand how its objects collabo- rate at runtime ( no object is \nan island [4]). Under-standing collaboration behavior is important both for us-ing the framework as well \nas extending it. Thus, a frame- work design methodology must provide means for de-scribing the collaboration \nbehavior of instances of the framework classes. . Separation of collcenls. Object collaborations them-selves \nmay become complex and may serve many differ- ent purposes. These different purposes should be kept separate \nto ease understanding and to increase reuse. A framework design methodology must therefore provide a \nway to specify single-purpose collaborative behavior, as well as a way to compose these collaboration \nspecifica-tions. . Reusable models and patterns. To reuse experience and foster productivity, it is important \nto be able to reuse existing models and apply patterns. The description of these reusable models and \npatterns must blend well with the framework design mechanisms to make the gap be- twecn the pattern or \nreusable model and its application as small as possible. Framework integration deals with the description \nof how clients make use of a framework by means of use-relationships. This is to be distinguished from \nframework extension, which deals with extending a framework by means of inheritance. . Client corfstruints. \nOnly in a trivial case may a client of a framework use it without fulfilling any requirements. More frequently, \nthe framework imposes constraints on how it is to be used and requires specific behavior and capabilities \nfrom its clients (e.g., to observe protocols or to provide callback hooks). A framework integration methodology \nmust allow the framework designer to ex- press such constraints. . Unanticipated use-contexts. Sometimes, \na framework must be prepared for extension into unforeseen contexts, e.g., because client requirements \ncannot be determined in advance. The ability of a framework to be extended in such a case is crucial \nfor its successful reuse. Thus, a framework integration methodology must provide con-cepts that let frameworks \nbe used or extended even in un- anticipated use-contexts. For many of the problems listed above, individual \nsolutions exist. Specifying object collaborations has gained much interest over the last years, and role \nmodeling is probably the most promising approach [14, 24, 31. Role objects are an important concept for \nframework integration [6, 71. Yet, a coherent methodology that combines these approaches for framework \ndesign and integration is missing. ROLE MODELING We use role modeling as an enabling technology for framework \ndesign and integration. Role modeling helps address the aforementioned problems, but has not yet been \napplied in a methodological way to the large-scale devel- opment of object-oriented systems using frameworks. \nThis section informally describes a metamodel for role model based software (micro) design to prepare \nthe ground for our discussion of role model based framework (macro) design. The presentation of the concepts \nin this paper focuses on the design level of software systems (interface architecture) and ignores the \nimplementation level and its code structures (implementation and code architecture). Roles and role models \nare not first class programming language constructs, so that a gap between design and implementation \narises that needs to be bridged by any given implementation anew. How to do so is largely independent \nof the design level. Role and role type A role type describes the view one object holds of another object. \nA role type is a type, so it can be described using an appropriate type specification mechanism. An object, \nwhich conforms to a given role type, acts according to the type specification. One also says that the \nobject plays a role specified by a role type. At any given time, an object may act according to several \ndifferent role types. Thus, different clients may have differ- ent distinct views on an object. Also, \ndifferent objects may provide behavior specified by a common role type. As an example, consider a drawing \neditor framework, and a class Figure, which is the superclass of all classes of graphical objects derived \nfrom the framework. It defines a set of role types comprising, among others, the role types Figure, Child, \nand Subject. These role types define different behavioral aspects of a graphical figure object, i.e., \nan in- stance (of a subclass) of Figure. . Role type Figure describes the regular drawing func-tionality \nof a graphical figure object (e.g., operations draw, hide). An oval depicts a role type, A rectangle \ndepicts a class, with the role model in which it is with its role type set defined by defined set below \nin a small font. the role types put on top of it. An arrow depicts A star depicts A line depicts a directed \nuse- an unlimited a bidirectional relationship. cardinal@ use-relationship. Figure 1: The class Figure \nand its role types. . Role type Child describes the functionality of being a child object in an object \nhierarchy (e.g., operations get- Parent, setparent). . Role type Subject describes the functionality \nof being observed for state changes by objects depending on the figure object (e.g., operations register, \nunregister, notify). Figure 1 depicts the example design and introduces part of the graphical notation \nused in the paper. In Figure 1, role types are qualified by a role model printed in a smaller font under \nthe role type name. A role model defines a namespace for the role types that it defines, so that the \nrole type Figure from the FigureHierarchy role model is fully qualified as FigureHierarchy.Figure, thereby \ndistin-guishing it from the class Figure. Every role type is unique. To avoid name conflicts, we qualify \nrole types using a RoleModeLRoleType dot notation, e.g., FigureHierar-chy.Client and GraphicsClient, \nwhen necessary. Object and class An objecr represents a phenomenon from an application domain, technical \nor non-technical. A class is the abstrac- tion from several similar objects, called its instances. A \nclass and defines a set of role types, the role type set, ac- cording to which its instances may play \nroles. The class specifies how these role types are combined in its instances. The set of role types \nof a class fully determines the roles an instance may play at runtime. The union of all operations defined \nby the role types constitutes the class interface, and the composition of all role types constitutes \nthe type of the class. A subclass inherits the role type set of its superclass. We never had to use multiple \ninheritance at the design level (we use multiple inheritance in the implementation to reuse code). One \nreason why multiple inheritance is not used at the design level is that role types provide a satisfactory \nso-lution for those situations that might otherwise have led to the use of multiple inheritance. We have \ntherefore restricted subclassing to single inheritance only. Standard substitut- ability rules can be \napplied, because a class specification can stand on its own, with the role types being resolved in the \nclass interface and abstract state model. We view role types and classes as complementary modeling concepts. \nThe purpose of a class is to represent a domain abstraction, both its intrinsic properties and its behavior- \noriented properties. The intrinsic properties are modeled using an abstract state space model, and the \nbehavior-oriented properties are modeled by the role types of the class. Please note that we thereby \nmaintain classes as mod- eling concepts, and do not restrict them solely to imple- mentation. Role model \nA role model is the description of a (possibly infinite) set of object collaborations using role types. \nIt focuses on a single purpose of object collaboration: a role model does not try to encompass all possible \naspects of a given object collabora- tion. In a role model, each role type specifies the behavior of \none particular object with respect to the model s purpose. The role types relate to each other using \nstandard object relationships like association and aggregation. A role model is, much like a traditional \nclass diagram, a constraining specification for a set of valid runtime object collaborations. The difference \nbetween a role model based specification and a class-based specification stems from the modeling concepts \ninvolved. With role models, objects in an object collaboration, which conforms to a role model, are known \nto behave as specified by the role types of the roles they are playing. However, a single role type specifies \nonly part of an object s overall behavior. In contrast, using class diagrams, objects in a collaboration \nare known to be of particular classes. Such an assertion is more restrictive, because a class already \ncombines several different collabo-ration aspects (role types) and does not distinguish the dif- ferent \npurposes of the various collaboration arrangements. Between two role types, an arrow with a white arrowhead \ndepicts a role-implied role constraint value. Between two role types, a line with a block at each end \n(H) depicts a role- prohibited value. Between two role types, an arrow with a white arrowhead at both \nends depicts a role- equivalent value (not shown). If no role constraint value is given for a pair of \nrole types, the default role-dontcare value is assumed. Figure 2: The Figure Hierarchy role model. Figure \n2 shows the Figure Hierarchy role model, which describes how figure objects play roles to maintain an \nob- ject hierarchy (object tree). An object playing a role speci- fied by role type Parent may maintain \nseveral objects play- ing a role specified by role type Child. Or, somewhat shorter (though less precise): \nAn object playing the Parent role may maintain several objects, each playing the Child role. If the context \nis clear, it can expressed even more suc- cinctly: A Parent object maintains several Child objects. Both \nobjects playing the Parent or Child roles are also ob- jects playing the Figure role (this does not indicate \nan in- heritance relationship but a role constraint, see below). An object playing the Root role also \nalways the Parent role. A Root object represents the root of the object hierarchy and provides special \nmanagement functionality. Next to the usual object relationship descriptions, role types also relate \ndirectly to each other to constrain how objects may play several roles at once within the scope of a \ngiven role model. E.g., a role may require another role, or a role may prohibit another role. They are \nmost conveniently ex-pressed as a role relationship matrix [27]. Let R be the set of all role types from \na given role model. Then, for every pair (A, B) of role types A and B from R, exactly one role constraint \nvalue is defined. A role con-straint value is one of the following: role-dontcare, role-implied, role-equivalent, \nor role-prohibited. . For a role type pair (A, B), a role-dontcnre value states that there are no constraints \non an object playing any of the roles defined by the role types A and B. . For a role type pair (A, B), \na role-implied value states that an object playing a role defined by role type A must always be able \nto play a role defined by role type B (but not necessarily the other way). . For a role type pair (A, \nB), a role-equivalent value states that the role-implied constraint holds for (A, B) as well as for (B, \nA). (I.e., both roles are always available together.) . For a role type pair (A, B), a role-prohibited \nvalue states that an object playing a role defined by role type A never plays a role defined by role \ntype B and vice versa. Role constraints are constraints on object collaborations. Role constraints are \nalways scoped by the role model, for which they have been defined. Role constraints have conse- quences \non how role types are statically assigned to classes (see next subsection). These role constraints, in \nparticular the role-implied con-straint, should not be confused with the inheritance concept, which is \na relationship type that applies to classes only. The white-headed arrows in Figure 2 represent role-implied \nconstraints, not class inheritance relationships. While the role-implied constraint suggests equivalence \nwith the class inheritance concept, the analogy immediately breaks down with the role-equivalent value, \nfor which no similar class relationship type exists, as inheritance is typically consid-ered to be non-circular. \nRole models can be composed. A role model composition is a role model in which the individual role models \nappear unchanged, but whose role types relate to each other using any of the aforementioned constraints. \nThe role constraints specify constraints on how roles defined by role types from the different role models \ncome together in the composition. They do not specify the actual type compositions, which are only carried \nout in the context of classes and class models (see below). Figure 3 depicts the example of a role model \ncomposition where the Figure Observer role model is composed with the Figure Hierarchy role model of \nFigure 2. The connection between the two role models is established by the role- equivalent constraint \nbetween the Figure role type of the Figure Hierarchy role model (i.e., FigureHierarchy.Figure) s$zi%!%J------~~J \n Figure 3: A composed role model. and the Subject role type of the Figure Observer role model (i.e., \nFigureObserver.Subject). Role models provide excellent separation of concerns due to their focus on one \nparticular collaboration purpose, while traditional class diagrams necessarily intertwine all different \nobject collaboration aspects. When composing role models, several aspects of object collaborations can \nbe specified without prematurely committing to a class structure that might turn out to be too rigid \nlater on. Class model A clnss model is a set of classes that relate to each other with any one of the \nfollowing ways. First, classes may relate to each other using class inheritance. Second, classes may \nrelate to each other by descriptions of the object relation- ships defined by role types in their role \ntype sets. Classes combine role types, and class models combine role models. Classes combine several \nrole types from different role models. Within a class model, some (or all) of the role types of the involved \nrole models are assigned to the role type sets of the classes. Thereby, the role models (and their role \nconstraints) are resolved in the class model. Role types in a role model may be left dangling for further \ncomposition, but of each role model, at least one role type needs to be in the role type set of a class. \nOtherwise it would not be connected with the class model. Figure 4 shows a (partial) class model that \nmight be used in the design of a graphical editor for UML-based object-oriented designs. The graphical \neditor application provides abstractions for Figure objects, which are maintained in an object hierarchy. \nNext to three general classes (Figure, CompositeFigure, RootFigure), the editor class model con- tains \ntwo classes (RectangleFigure, ClassFigure) considered specific to the UML editor. The class model can \nbe ex- tended with further classes like TextFigure and Associa- tionFigure. The design has many aspects. \nSeveral role models express different aspects of runtime object collaborations. The class model shows \nhow the role types of the role models and their constraints have been resolved so that the role constraints \nare maintained. The Figure Hierarchy role model describes how figure ob-jects are maintained in an object \nhierarchy so that compos- ite figures may contain figures, which in turn may be com- posite figures that \ncontain further figures, etc. The Figure Chain role model describes how objects forward client re-quests \nup the hierarchy, until a request is handled. The Fig- ure Observer role model describes how clients \nregister in- terest in state changes of a given figure object and are noti- fied about them. The Internal \nFigure Observer (abbreviated as Int. Fig. Observer) role model describes how a Parent object observes \nits Child objects to react to state changes that might affect its own state. The class model resolves \nthe static aspects of the role con- straints of the role model compositions. E.g., Figure 3 de- fines \na role-equivalent constraint between the role types FigureHierarchy.Figure and FigureObserver.Subject. \nThus, class Figure defines both role types as elements of its role type set, because the two role types \nmust always be avail- able together. A role-equivalent constraint between two role types A and B always \nrequires that a class maintains both role types in its role type set, or that one of the role types is \nalways provided by every concrete subclass of a class that defines the other role type. Another example \nof a role- equivalent constraint is (FigureHierarchy.Parent, IntFigOb-server.Observer), which we haven \nt defined as an explicit role model composition, but which is directly resolved in the class model of \nFigure 4. Role-implied constraints provide more freedom in assigning role types to classes by using class \ninheritance. Both Fig-ureHierarchy.Parent and FigureHierarchy.Child imply Fig- ureHierarchy.Figure, but \nthese implications have been re- solved differently. Child and Figure are provided by the same class \nFigure, while Parent is only introduced in the subclass CompositeFigure. Assigning Child and Figure to \nthe same class in a class model is a stricter specification than required by the original role model. \nIt is a convenient one, because it makes the class model simpler than it would have been had every role-implied \nconstraint lead to a sub- A line with a while arrowhead between classes indicates an inheritance relationship. \n Figure 4: A (partial) class model for figures for a UML editor. class of it own. (This would have lead \nto many more classes and multiple inheritance diamond structures.) The conse-quence of this decision \nis that an invalid object configura- tion, namely a Root object playing the Child role, cannot be caught \nby static type checking anymore. Role-dontcare and role-prohibited constraints provide no constraints \nin assigning role types to classes. Role-prohibited constraints provide no constraints, because they \nare scoped by their role model. As an example, consider the instantiation of the Observer pattern as, \ne.g., in Smalltalk s class Object (change/update mechanism). The instantiation of the Observer pattern \nas a role model might specify a role-prohibited constraint (Observer, Subject) so that an object might \nnot be allowed to observe itself. However, an object may well play the Observer role in one context, \nand the Subject role in another context as needed, e.g., in a noti- fication chain of observers. This \nis a valid object configu- ration, because the Observer and Subject role, while being played by the same \nobject, are being played in different contexts, and not the same (the object is not observing it-self). \nA role-prohibited constraint constrains the runtime object collaboration, but not the class model. Framework \nA framework is a class model, together with an integration role type set, and a builds-on class set. \nA framework covers one particular domain or a significant aspect thereof. It is a coherent unit of reuse, \nboth by use-relationships and by extension through subclassing. (Please note that we solely focus on \nthe design level, and ignore that frameworks typi- cally provide reusable implementations as well.) The \nintegration role type set determines how the framework is to be used by use-relationship based clients. \nIt contains those role types of the class model, which have not been assigned to classes, and which must \nbe defined by client classes so that their instances can make use of objects from the framework at runtime. \nAn element of an integration role type set is called an integration role type. A role model, which provides \nan integration role type, is called an inte- gration role model. The builds-on class set specifies the \nclasses of frameworks the current framework builds on. To build on another framework, the current framework \nassigns some or all of the role types from the other framework s integration role type set to its classes. \nThe builds-on class set comprises those classes of other frameworks that define role types from role \nmodels, in which integration role types are in- volved that are used by the current framework. Figure \n5 shows the Figure framework of the example. The integration role type set of the framework contains \nthe role types FigureHierarchy.Client, FigureObserver.Observer, and FigureHierarchy.RootClient. The builds-on \nclass set contains the single class Graphics from a Graphics framework, which provides Figure objects \nwith functionality to draw them on a device-independent graphics context. Classes of a specific framework \nare re- The box around the framework classes is just a convenient grouping to illustrate that they belong \ntogether (i.e., Ihey belong to the same package). Figure 5: The Figure framework. ferred to using a \nFramework.Class dot notation to qualify class names (e.g., GraphicsGraphics). Figure 6 illustrates the \nGraphics framework. The integration role type set of the Graphics framework comprises the role types \nGraphics.Client, Clipping.Client, Polylining.Client, Texting.Client, and Imaging.Client. The classes \nGraphicsImage, GraphicsFont, and Graph- ics.Polygon are used by application-specific subclasses of the \nFigure framework and are therefore not part of the Fig- ure framework s builds-on class set (see section \non frame- work design). However, they are part of the builds-on class set of the application-specific \nextension of the framework. The builds-on class set of the Graphics framework is empty since it is implemented \nusing the native API of an underly- ing window system. System model A system model is a class model. \nIt may be the composition of an arbitrarily large set of frameworks (and framework extensions, see section \non framework design). FRAMEWORK DESIGN We now show how the basic role modeling metamodel is used in the \ndesign of object-oriented frameworks and how it helps address the problems described in the section on \nproblems in frameworks design and integration. General characteristics Frameworks have been characterized \nas being black-box or white-box (or both) [16]. These attributes indicate the in- tended usage of a framework. \nA black-box framework is expected to work out of the box: a client (object) can use the framework by \ninstantiating classes and composing the instances to suit its needs. A white-box framework requires clients \nto supply new subclasses first, before objects can be created and composed. Many frameworks combine both \ncharacteristics by providing readily usable classes as well as abstract classes that are subclassed to \nprovide application- specific classes. These characteristics apply to the given framework defini-tion \nof the metamodel section as well. The Figure frame-work is a white-box framework: Figure, CompositeFigure, \nand RootFigure are abstract classes that need to be sub- classed for application-specific classes. Figure \n4 shows such a (partial) extension for an UML diagram editor. The Graphics framework is primarily a black-box \nframe-work that clients make direct use of without having lo pro-vide new subclasses. The object transport \nservice frame- Figure 6: The Graphics framework. work, which we described using role models [23], is \na black-box framework. Framework design Frameworks are designed by defining and composing role models \nand assigning role types to classes. We have found that design patterns are not only of occa-sional use \nwhen defining role models and designing frame- works, but of central importance. The application (i.e., \nthe instantiation) of a design pattern yields a role model. We have described a catalog of object-oriented \ndesign patterns using role models [26], and illustrated their use in the de- sign of frameworks [23]. \nDesign patterns are ubiquitous in the design of frameworks. In [23], we discuss a large framework, which \nprovides 12 classes and 19 role models, all of which arc pattern appli- cations. We call this effect \na high pattern density. Almost every non-trivial role model we have seen that goes beyond a simple binary \nclient/service role model, e.g., a ternary or an nary role model, can be identified as a pattern instance. \nFurther case studies, presented in 1291, support this finding with more statistical data. When composing \nrole models, the role constraints must be observed. Finally, the integration role type set and the builds-on \nclass set need to be determined. The metamodel section illustrates this procedure. Framework extension \nFrameworks are extended to provide application-specific classes by subclassing. Every abstract class \nof the class model of a framework can be used as a superclass for an application-specific class. Extending \na framework is done by providing a new subclass, which adds some role types to the role type set inherited \nfrom the superclass. A subclass that does not introduce new role types does not exist on the design-level, \nbecause it represents only a new implementa- tion of an already known class. Thus, afrnnrecvork extensiorr \nclass is a class that is a sub- class of a framework class or of another framework exten-sion class. \nThe set of framework extension classes of a par- ticular application is called the framework extension \nclass set. To provide application-specific functionality, an extension class typically makes use of further \nframeworks. Figure 7 shows how the RectangleFigure class of the UML-editor extension of the Figure framework \nmakes use of the Polylining role model of the Graphics framework. To do so, the RectangleFigure class \ndefines the Polylining.Client role type for its instances. A second example is how the Class- Figure \nclass defines the Texting.Client role type for its in- stances in order to make use of the Texting role \nmodel of the Graphics framework. Thus, a framework extension class Xient np*fipun 3 Figure 7: Coupling \nof Figure and RectangleFigure with Graphics. is one of several means for integrating frameworks (see \nsection on framework integration). Like a framework, a framework extension defines an inte- gration role \ntype set, which lists the new role types it pro- vides to clients, and a builds-on class set, which lists \nthe classes the framework extension depends on. FRAMEWORK INTEGRATION This section discusses how clients \nbuild upon existing frameworks. We first discuss the most frequent case, where a framework defines its \nintegration points using a fixed in- tegration role type set. We then discuss how to deal with new and \nunforeseen clients that need to dynamically attach new roles types to a framework, based on new and unfore- \nseen requirements. Direct coupling Frameworks are integrated into a larger context by that context making \nuse of the framework. Making use of a framework means making use of classes from the frame- work or a \ngiven framework extension. To use a class, a cli- ent class defines for its role type set one or more \nrole types, which stem from role models in which this class is involved in. Thus, a role model acts as \nthe bridge Oetweerl aframe- work and its clients. Role models act as the bridge between a client and \na framework, because they define the roles the client and the framework objects must play in order to \nwork together properly. They define both the services offered by a frame- work, as well as the requirements \na client has to fulfill to successfully use these services. The extent to which the requirements are \nmade explicit depends on the chosen specification mechanism. A client of a framework may be any class, \nindependently of whether it stands alone as some initial application class, or whether it is a framework \nclass or a framework extension class. It must only fulfill the constraints set up by role mod- els of \nthe role types from the integration role type set of the framework. Figure 7 provides an example: the \nFigure and Rectangle- Figure classes of the Figure framework use the Graphics and Polygon classes of \nthe Graphics framework. The first part of the integration is on the framework level: class Fig- ure uses \nclass Graphics via the Graphics role model. The second part of the integration is on the framework extension \nlevel (from the client, i.e., the Figure framework, point of view): class RectangleFigure, an extension \nclass of the Fig- ure framework, uses class Graphics via the Polylining role model. The integration takes \nplace using the Graphics and Figure 8: Integration of Figure framework for tiny editor application. \nPolylining role model, respectively, and by assigning role types from these role models to the framework \nclasses. As a second example, consider how clients make use of the Figure framework. We consider two \ndifferent types of cli- ents, a TinyEditor client class, which takes on most of the responsibility of \nhandling figures itself, and a UmlEditor client class, which represents a more sophisticated UML editor \napplication. The tiny editor application provides a TinyEditor class, which allows users to work with \nsome basic figures, e.g., circles and rectangles. It takes on the responsibilities of creating and handling \nthese figures, as well as placing them into a concrete implementation of a generic RootFigure instance, \nwhich acts as the containing picture object. Han- dling figures takes place by using the Figure Hierarchy \nrole model as well as role models that are specific to the figure subclasses, e.g., CircleFigure and \nRectangleFigure. Crea-tion and initialization of figure objects takes also place us- ing these subclass \nspecific role models (which is a simpli- fying assumption: complex initialization protocols should be \nrole models of their own). Figure 8 shows how the TinyEditor class collects all the relevant role types \nin its role type set. In contrast, a more realistic UML editor application factors the different functionality \ninto different objects, which take on different roles. Figure 9 depicts parts of its design. The application \nextends the Figure framework with classes like PolygonFigure, ClassFigure, and ClassDiagram. An in-stance \nof ClassDiagram is understood here as a visually editable view on the underlying system being modeled. \nWe use one design aspect to illustrate the flexibility of role modeling for integrating frameworks: Class \nUmlEditor delegates the handling of figures (creation, moving, resiz-ing, etc.) to Tool objects (based \non the Strategy pattern [ 121). For every different type of operation, there is one Tool subclass. Its \ninstances are used to carry out the re- spective figure handling operation they implement. Some of these \noperations can be carried out using the FigureHierar- chy.Figure role type, some need subclass specific \nrole mod- els, e.g., role model PolygonFigure for manipulation of polygons. Integration takes place both \non the framework and frame- work extension level. On the framework level, both classes UmlEditor and \nTool, as well as specific Tool subclasses, put the FigureHierarchy.Client role into their role type set. \nOn the framework extension level, subclasses like Polygon- Figure and ClassDiagram introduce new role \nmodels. The client role types of these role models are taken on by differ- ent classes, e.g., UmlEditor, \nas well as specific Tool sub-classes. -----~--- r I!/  Figure 9: Integration of Figure framework for \nUML editor application. We call this integration mechanism direct coupling, be-cause a framework and \nits extensions define precisely how they may be integrated. This is done by client classes put- ting \nrole types from integration role models into their role type set. This direct way of integrating frameworks \nis by far the most frequently used one. Role objects The framework integration mechanism just described \nis based on a statically defined set of integration role types offered by the key abstractions of a framework. \nThus, a framework anticipates its use-contexts and defines a fixed set of integration points in the form \nof integration role mod- els and role types. However, in large systems, new clients may require new role \nmodels for integration with a frame- work on which they want to build. If these role models have not \nbeen anticipated, the respective role types are not avail- able, and integration cannot be carried out. \nTo overcome this problem, means to dynamically attach role types to a framework s key abstractions as \nrequired by new clients are needed. The primary example used to illustrate this problem is the class \nPerson and its different roles in different contexts, as found, e.g., in the banking and insurance business \ndomain. Here, full application suites depend on specific roles of Person, which may be as diverse as \nCustomer, Guarantor, Investor, Patient, MedicalDoctor, Employee, and Manager. \\ Client he&#38;r IhvrW \n Figure 10: Composition of role models from different frameworks. Figure 11: The Person class and two \nof its clients. Figure 10 shows a set of simplified role models and their composition using role constraints. \nEach role model stems from a different framework. The Person and Customer role types may stem from frameworks \nof general interest, but the Retail, Debitor, and Investor role types come from more specific applications \nthat typically are not available on every desktop. In Figure 10, each role-implied constraint (A, B) \nexpresses that an object must provide role type B if it wants to pro- vide role type A. E.g., Customer.Customer \nrequires Per- son.Person, and InvestorInvestor requires cus-tomer.Customer. (A person that plays the \ninvestor role must also always be able to play the customer role, which is its precondition, as defined \nin the banking domain.) Figure 11 shows class Person with two selected role types Customer and Employee, \nboth of which are used together with the Person role type by different clients. The classes CustomerView \nand EmployeeView represent clients from a Customer Handling and Employee Handling framework, which may \nbe used together or which may be kept separate. Each client framework introduces its specific role models, \nsome role types of which need to be attached to the Person class of the Person framework. If all role \ntypes are known in advance, they could be di- rectly attached to class Person. However, this would make \nclass Person a very heavyweight abstraction, and in a given application, only a fraction of the role \ntypes might actually be needed. Moreover, not all role models may be known in advance, and new ones might \nbe added during system evo- lution when new requirements come up. Thus, one must provide means to dynamically \nattach role types to class Person. In systems that do not provide adequate means to change class definitions \nat runtime, role objects can be used to at- tach new role types to some key abstraction. We illustrate \nthe importance of role objects for framework integration in [6] and discuss its implementation in [7]. \nHere, we show how role objects fit into a general role modeling approach. A role object is an object \nthat represents one specific role of a core object to its clients. The role object wraps the central \ncore object. The core object maintains its role objects for the different clients it is used by. The \ncore object is an in- stance of a class, which provides the core functionality. Each role object is an \ninstance of a class that provides one particular role type. The core object allows for the dynamic creation \nand deletion of role objects at configuration and runtime so that new and unforeseen role types can be \nat-tached to it on demand. The core object represents the ob- ject conglomerate and makes it appear as \none logical object. It provides means for state integration, even if the logical state is spread over \nseveral physically distinct objects. Figure 12 shows how the Person framework provides means for dynamically \nattaching new role types as subclasses of a predefined PersonRole class. The framework itself, pro-viding \nextended role functionality, can be described well using the basic role modeling concepts. ---(Z) I-.-... \n--.. -_-.-.-^ ,._-.---__ - .~~.-.-.---..-i---____--.-^^..--.--,.--~---1--1-11- Figure 12: Part of the \nPerson, Customer and Employee framework. The Person class, as well as every subclass of PersonRole, provides \na role type for client integration based on its pri- mary purpose (i.e., providing the Person, Customer, \nor Em- ployee role type). In addition, the Person class provides the Trader role type of the Role Trader \nrole model, which lets clients request a specific role object from a given Person object. A role object \nis always an instance of a subclass of PersonRole. The PersonRole class provides the Person- Role.Role \nrole type, which lets clients physically navigate the object structure, e.g., access the wrapped core \nobject. Every role object interacts with the core object to maintain a consistent overall state. In the \nconcrete framework of Fig- ure 12, this integration is carried out by maintaining a gen- erically accessible \nlist of attribute objects in the core (Prop- erty List pattern [26]), and by notifying role objects about \nattribute changes using the Observer pattern [ 121. We make PersonRole a subclass of Person rather than \nan unrelated class, because it best resolves the role-implied constraints between the role types illustrated \nin Figure 10. For a client class of Customer, it guarantees that not only the role type Customer.Customer \nis available, but also Per- son.Person. A client object typically plays several client roles from different \nrole models, between which it can con- veniently switch if all role types are directly accessible. The \nimplementation of a Customer role object typically directly implements the Customer role type functionality \nand dele- gates the Person role type functionality to the core object it wraps. DISCUSSION We have designed \nour role modeling metamodel in such a way that it solves the problems described in the beginning. This \nsection discusses whether the metamodel and the con- cepts based on it fulfill this purpose. Class complexity \nThe complexity problem of class interfaces is resolved eas- ily by role modeling. By virtue of the role \ntype set of a class, an explicit separation of instance collaboration con-cerns is achieved, which cannot \nbe provided by a single class interface. A role type defines precisely how an in-stance of a class interacts \nin a given context (and through the role model, it defines what behavior it requires from that context \nto be operational). Thus, our role modeling approach provides a sound design- level basis to programming \nlanguage level concepts like Smalltalk method categories [ 131, Objective-C protocols [8], and Java multiple \ninterfaces [2]. Object collaboration and separation of concerns As noted, much of the design-level framework \ncomplexity stems from the complexity of object collaborations. Role modeling addresses both problems \nof properly specifying object collaborations and breaking them up into manage-able pieces by means of \nrole models. A role model de- scribes one particular object collaboration concern. By composing role \nmodels, multiple purpose object collabora- tions can be described succinctly. As already illustrated \nby Reenskaug [24], role modeling significantly increases intellectual manageability of object collaborations. \nThis is achieved by the clear separation of concerns of the different object collaboration aspects as \nindividual role models. Reusable models and patterns Many object-oriented design patterns can be described \nwell using role modeling [25, 28, 2.31. In particular object col- laboration patterns can be described \nmuch better with role modeling than with classes. [26] contains role model based descriptions of a large \nnumber of commonly known pat-terns. Reconsider the framework example of Figure 5. The Figure Hierarchy \nrole model is an instance of the Composite pat- tern, the Figure Chain role model is an instance of the \nChain of Responsibility pattern, the Figure Observer role model is an instance of the Observer pattern, \nand the Inter- nal Figure Observer role model is another instance of the Observer pattern. The application \nof a pattern leads to a (hopefully) reusable role model. As already demonstrated, role models can be \nreused (composed) quite naturally. In comparison to this, class hierarchies are much more difficult to \ncompose, as Ossher and Harrison show [21]. Therefore, role modeling as described in this paper helps \nboth to better define reus-able models as well as to close the gap between design pat- terns and a concrete \nframework design. Client constraints By providing role models as an explicit bridge between a framework \nand its clients, the requirements of a framework on its context are clarified. Such an integration role \nmodel does not only specify what a framework provides, but also what it requires from its clients. Role \ntypes are a better means for specifying these require- ments than classes, because classes are too restrictive. \nRe-quiring from a client class to inherit from a framework pro- vided class to use the framework is more \nrestrictive than specifying that the client class must provide a specific set of role types. Using role \ntypes rather than classes as con- straints on the context lets clients define their own classes without \ninheriting possibly unwanted and inadequate bag- gage. Unanticipated use-contexts The use of role objects \nis an excellent means for attaching new and unforeseen role types to classes of a framework that do not \nprovide these role types right from the begin- ning. It solves the problem of a certain set of unanticipated \nrequirements a context might pose on an already existing framework. Role objects incur a cost, though: \nthey need to be prepared for. Thus, what must be anticipated is a par- ticular type of unanticipated \nrequirements, namely the need to tie in new role models into an existing framework to make it useful \nfor clients. Some programming languages, e.g., CLOS [22], and some programming systems, e.g., IBM Smalltalk \n[ 151, provide means to dynamically attach new functionality to classes, but this is usually not available \nin most mainstream pro- gramming language definitions, e.g., C++, Java, and Smalltalk. Role objects provide \na means to cope with this problem on a programming language independent level. RELATED WORK Role models \nplay a central role in the OOram methodology [24] and in Andersen s dissertation [3]. Both present a \nmetamodel for conceptual modeling of object systems using roles and role models, in a style that is similar \nto the pres- entation of our metamodel summary in the metamodel sec- tion. Reenskaug and Andersen address \nlarge-scale software systems, but they only hint at frameworks as design artifacts on a level of scale \nbetween classes and large-scale compo- nents. They only discuss composed role models, with a system being \nviewed as the composition of a set of role models, and omit the intermediate framework level as dis- \ncussed in this paper. Our approach uses role models as a means to design and integrate frameworks. We \nconsider frameworks to be im- portant concepts of large-scale object-oriented system de- velopment. In \npractice, frameworks are an important asset of many large-scale developments, and numerous groups have \nrecognized the value of frameworks. We thereby ad- dress an issue that has not been addressed by Reenskaug \nand Andersen. Frameworks are not just composed role models, but cohesive design artifacts, with well-defined \nintegration points and ways of extending them. In addition, we have identified novel concepts like role \nconstraints and role objects in the context of role modeling, which are con- cepts that help solve open \nproblems in role model based systems modeling. More related work on object collaboration specification \nand composition exists. To all, our primary critique applies: The work directly proceeds from the simple \nmodel level to the large-scale component and system level, without much con- sideration for an intermediate \nframework level. D Souza and Wills are working on a new UML-based methodology [32, 33, 341, which is \nsimilar to OOram in many respects, even though it does not use the concepts of role and role model. Rather, \nthey use the concepts of inter- face and framework. However, they seem to use these con-cepts equivalently \nto Reenskaug s use of the role and role model concepts. Their definition of framework is different from \nthe one we are using, and from what we know about their methodology, they do not provide an explicit \napproach to the design and integration on the framework level, as understood here, and as is the focus \nof this paper. The work on CRC [4, 371 recognizes the importance of managing collaboration complexity. \nHowever, the approach use classes as the primary modeling concept and therefore falls short to address \nthe problems illustrated in the section on problems in framework design and integration. Contracts are \nbehavioral specifications that can be com- posed to derive class models similar to ours [ 141. Composi- \ntion filters are an approach to separating object concerns [I] that also focuses on factoring behavioral \naspects within a single object or component. VanHilst presents a composi- tion methodology for collaboration \nbased designs based on role-model alike design fragments [36]. Harrison and Ossher have defined sub.ject-oriented \npro-gramming, which deals with integrating different but related system models and implementations to \nbuild a whole sys- tem [20]. A subject is a design artifact of typically several classes and their implementation \nthat can be composed by means of class composilion operators. The need to separate the different views \non a design artifact has gained more attention through the work on viewpoints [ 111. Here, different \nways of specifying and using context- specific views on design artifacts are being explored. A pertinent \nissue of role modeling is separations of con-cerns, which has received much attention recently. Most \nprominently, aspect-oriented programming [ 171 tries to describe systems as compositions of aspects. \nHowever, as- pects are functional and behavioral aspects of objects or components and are different from \nrole types (or role mod- els). Rito Silva presents a domain specific methodology for the development \nof concurrent systems [30]. This methodology uses class-based modeling, and with it comes all the com- \nplexity of class composition, as described by Ossher and Harrison [2 I]. In summary, different approaches \nand methodologies have addressed the problems of separation of concerns, but none of them has been extended \nto cover the design and integra- tion of ob.ject-oriented frameworks on a general level. However, this \narea is the core theme of this paper, which reflects our observation that frameworks are a key compo- \nnent of the design of modern object-oriented systems. CONCLUSIONS Modern object-oriented systems are \nbuilt from frameworks, which have been shown to be an important means of object- oriented software system \nconstruction. Yet, the design of frameworks and their use by clients to develop applications poses a \nnumber of difficult problems in terms of intellectual manageability, specification, and evolution. Many \nof these problems can be attributed to the sole use of classes as the primary modeling concept. An exclusive \nfocus on classes causes a number of problems in object-oriented fyamework design and integration. To \novercome these problems, we develop an approach to framework design that is based on role mod&#38;. Role \nmod- els for framework design build on role models for object design. The use of role models for the \ndesign and integra- tion of a framework makes clear the intent of the interaction (between objects and \nbetween the framework and its cli- ents). Therefore role model based framework design pro- vides designers \nand users of a framework with a way to deal with class and object collaboration complexity, proper modeling \nof separate concerns, the definition of constraints on the use-context of frameworks, and framework use \nafter new requirements are introduced. The design of a framework can be composed from a num-ber of role \nmodels, each of which may be a pattern instance. Some of the role models serve as integration role models \nthat define how clients of the framework are to USC it. Ef- fectively, these integration role models \nbridge the gap be-tween a framework and its clients, and make explicit what is expected from clients \nthat want to work with the frame- work. Finally, role objects show how frameworks can be integrated into \nunforeseen use-contexts that emerge when requirements change or are extended. Our experience with this \napproach in several real-world case studies indicates that the presented concepts signifi- cantly help \nwith framework design and integration. Role model based framework design provides advantages in ad- dressing \nthe core areas of framework design: managing the collaboration complexity inherent in non-trivial frame-works, \ndescription of how a framework is to be used (by clients), and devising a structure that allows a framework \nto work in unanticipated use-contexts. Given the importance of frameworks for the efficient construction \nof large-scale applications, we expect that role model based design will play an important role in the \nconstruction of future framc- works. ACKNOWLEDGEMENTS We would like to thank Hans Wegener and the anonymous \nreviewers for their comments on the paper. REFERENCES Lodewijk Bergmans and Sinan Vural. An Object-Oriented \nLanguage-Database Integration Model: The Composition-Filters Approach. In Proceeditgs of rhr 1992 Europearl \nConference on Object-Oriented Pro-grumming (ECOOP 92). Springer-Verlag, 1992. Page 372-395. Ken Arnold \nand James Gosling. The Javn Progrclmmir~g Language. Addison-Wesley, 1996. Egil P. Andersen. Conceptual \nModelitzg of 0bjec.t.s. Ph.D. Thesis. Oslo, Norway: University of Oslo, 1997. Kent Beck and Ward Cunningham. \nA Laboratory fol Teaching Object-Oriented Thinking. In Proceedings of the 1989 Conference OH Object-Oriented \nProgramming Systems, Languages, and Applications (OOPSLA 89). ACM Press, 1989. Page l-6. 5. William \nBerg, Marshall Cline, and Mike Girou. Les-sons Learned from the OS/400 00 Project. Communi-cations of \nthe ACM 38, 10 (October 1995): 54-64. 6. Dirk Bgumer, Guido Gryczan, Rolf Knoll, Carola Li- lienthal, \nDirk Riehle, and Heinz Ziillighoven. Frame-work Development for Large Systems. Communica-tions ofthe \nACM 40, 10 (October 1997). Page 52-59. 7. Dirk BBumer, Dirk Riehle, Wolf Siberski, and Martina Wulf. \nRole Object. In Proceedings of the 1997 Con- ference on Pattern Languages of Programming (PLOP 97). Washington \nUniversity Department of Computer Science, Technical Report WUCS-97-34, 1997. Paper 2.1, IO pages 8. \nBrad J. Cox. Object-Oriented Programming: An Evolu- tionary Approach. Addison-Wesley, 1987. 9. Sean \nCotter, with Mike Potel. Inside Taligerlt Technol-ogy. Addison-Wesley, 1995.  lO.Mohamed E. Fayad and \nWei-Tek Tsai (editors). Special Issue on Object-Oriented Experiences. Communications of the ACM 38, 10 \n(October 1995). I 1. Anthony Finkelstein. Relating Viewpoints: A Preface to Viewpoints 96. In Proceedings \nof the 1996 Inter- national Workshop on Multiple Perspectives in Soft-ware Development. ACM Press, 1996. \nPage 157. 12.Erich Gamma. Richard Helm, Ralph Johnson, and John Vlissides. Design Patterns-Elements of \nReusable Ob- ject-oriented Software. Addison-Wesley, 1995. 13.Adele Goldberg and David Robson. Smalltalk-80-The \nLanguage. Addison-Wesley, 1989. 14.Richard Helm, Ian M. Holland and Dipayan Gangopad- hyay. Contracts: \nSpecifying Behavioral Compositions in Object-Oriented Systems. In Proceedings of the 1990 Conference \non Object-Oriented Programming Systems, Languages and Applications (OOPSLA 90). ACM Press, 1990. Page \n169- 180. 15.International Business Machines Corporation. IBM Smalltalk User s Guide, Version 3, Release \n0. Interna- tional Business Machines Corporation, 1995. 16.Ralph E. Johnson and Brian Foote. Designing \nReusable Classes. Journal of Object-Oriented Programming 1, 2 (June/July 1988). Page 22-35. 17.Gregor \nKiczales, John Lamping, Anurag Mendhekar, Chris Maeda, Cristina Lopes, Jean-Marc Loingtier, and John \nIrwin. Aspect-Oriented Programming. In Pro-ceedings of the 1997 European Conference on Object- Oriented \nProgramming (ECOOP 97). Springer Verlag, 1997. Page 220-242. 18.Karl J. Lieberherr. Adaptive Object-Oriented \nSoftware. Boston, MA: PWS Publishing Company, 1995. 19.Simon Moser and Oscar Nierstrasz. The Effect of \nOb- ject-oriented Frameworks on Developer Productivity. Computer 29,9 (September 1996): 45-5 1, 20. William \nHarrison and Harold Ossher. Subject-Oriented Programming (A Critique of Pure Objects). In Pro-ceedings \nof the 1993 Conference on Object-Oriented Programming Systems, Languages and Applications (OOPSLA 93). \nACM-Press, 1993. Page 4 1 l-428. 21.Harold Ossher and William Harrison. Combination of Inheritance Hierarchies. \nIn Proceedings of the 1992 Conference on Object-Oriented Programming Systems, Languages and Applications \n(OOPSLA 92). ACM Press, 1992. Page 25-40. 22.Andreas Paepcke. Object-Oriented Programming-The CLOS Perspective. \nMIT Press, 1993. 23.Dirk Riehle, Roger Brudermann, Thomas Gross, and Kai-Uwe Mltzel. Pattern Density \nand Role Modeling of an Object Transport Service. ACM Computing Sur-veys 30,4 (December 1998). To appear. \n24.Trygve Reenskaug, with Per Wold and Odd Arild Le-hne. Working with Objects. Greenwich: Manning, 1996. \n25.Dirk Riehle. Describing and Composing Patterns Using Role Diagrams. In Proceedings of the 1996 Ubilab \nConference, Ziirich. Edited by Kai-Uwe Mtitzel and Hans-Peter Frei. Konstanz, Germany: Universitgtsverlag \nKonstanz, 1996. Page 137-152. Originally published in Proceedings of the 1st International Conference \non Object-Orientation in Russia (WOON 96). Edited by Alexander V. Smolyaninov and Alexei S. Shestialtynov. \nSt. Petersburg, Russia: Electrotechnical University, 1996. Page 169-178. 26.Dirk Riehle. A Role-Based \nDesign Pattern Catalog oj Atomic and Composite Patterns Structured by Patter11 Purpose. Ubilab Technical \nReport 97.1. I. Ziirich, Swit-zerland: Union Bank of Switzerland, 1997. Also avail-able from www.riehle.org. \n27. Dirk Riehle. Composite Design Patterns. In Proceed- irlgs of the I997 Conference on Object-Oriented \nPro-gramming Systems, Languages and Applications (OOPSLA 97). ACM Press, 1997. Page 218-228. 28. Dirk \nRiehle. Bureaucracy. In Pattern Languages oj Program Design 3. Edited by Robert C. Martin, Dirk Riehle, \nand Frank Buschmann. Addison-Wesley, 1998. Page 163-186.  29.Dirk Riehle. Framework Design and Integration: \nA Role Model Based Approach. Work in progress. 30.Antonio Rito Silva. Framework, Design Patterns, and \nPattern Language for Object Concurrency. In Pro-ceedings of the 1997 international Conference on Par- \nallel and Distributed Processing Techniques and Appli- cations (PDPTA 97). 3 1. Sieve Sparks, Kevin Benner, \nand Chris Faris. Manag- ing Object-Oriented Framework Reuse. Computer 29, 9 (September 1996): 52-61. \n32. Desmond D Souza. Collaborations: Beyond Subtypes. Journal of Object-Orierlted Programming (January \n1997): 61-66. 33.Desmond D Souza. Types and Classes: A Language- Independent View. Journal of Object-Oriented \nPro-gmmmirzg (March/April 1997): IO- 13. 34.Desmond D Souza. Frameworks in Java and Cataly- sis. Journal \nof Object-Orietrted Progrnmmirlg (May 1997): 59-62. 3.5.Rational Software Corporation et al. I/ML. VI./ \nSeman-tics. Santa Clara, CA: Rational Software Corporation, 1997. 36.Michael VanHilst and David Notkin. \nUsing Role Com- ponents to Implement Collaboration-Based Designs. In Proceedings of the 1996 Conference \non Object-Oriented Progmmmi~lg Systems, Languages, and Appli- cations (OOPSLA 96). ACM Press, 1996. Page \n359- 369. 37.Rebecca Wirfs-Brock, Brian Wilkerson, Lauren Wiener. Design&#38;y Object-Orierlted Software. \nPrentice Hall, 1990.  \n\t\t\t", "proc_id": "286936", "abstract": "Today, any large object-oriented software system is built using frameworks. Yet, designing frameworks and defining their interaction with clients remains a difficult task. A primary reason is that today's dominant modeling concept, the class, is not well suited to describe the complexity of object collaborations as it emerges in framework design and integration. We use role modeling to overcome the problems and limitations of class-based modeling. Using role models, the design of a framework and its use by clients can be described succinctly and with much better separation of concerns than with classes. Using role objects, frameworks can be integrated into use-contexts that have not been foreseen by their original designers.", "authors": [{"name": "Dirk Riehle", "author_profile_id": "81339524672", "affiliation": "UBS AG, Ubilab, P.O. Box CH-8098 Z&#252;rich", "person_id": "PP43136343", "email_address": "", "orcid_id": ""}, {"name": "Thomas Gross", "author_profile_id": "81332502168", "affiliation": "Departement Informatik, ETH Z&#252;rich, CH-8092 Z&#252;rich, School of Computer Science, Carnegie Mellon University, Pittsburgh, PA", "person_id": "PP39072664", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/286936.286951", "year": "1998", "article_id": "286951", "conference": "OOPSLA", "title": "Role model based framework design and integration", "url": "http://dl.acm.org/citation.cfm?id=286951"}