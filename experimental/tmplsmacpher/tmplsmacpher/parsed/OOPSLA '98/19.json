{"article_publication_date": "10-01-1998", "fulltext": "\n System Support for Object Groups* Rachid Guerraoui, Pascal Felber, Benoit Garbinato and Karim Mazouni \n1 Computer Science Department, Swiss Federal Institute of Technology, CH-1015, Lausanne, Switzerland \n Abstract This paper draws several observations from our experiences in building support for object groups. \nThese observations actually go beyond our experiences and may apply to many other developments of object \nbased distributed systems. Our first experience aimed at building support for Smalltalk object replication \nusing the Isis process group toolkit. It was quite easy to achieve group transparency but we were confronted \nwith a strong mismatch between the rigidity of the process group model and the flexible na-ture of object \ninteractions. Consequently, we decided to build our own object oriented protocol framework, specifi-cally \ndedicated to support object groups (instead of using a process group toolkit). We built our framework \nin such a way that basic distributed protocols, such as failure de-tection and multicasts, are considered \nas first class entities, directly accessible to the programmers. To achieve flexible and dynamic protocol \ncomposition, we had to go beyond inheritance and objectify distributed algorithms. Our second experience \nconsisted in building a CORBA service aimed at managing group of objects written on dif- ferent languages \nand running on different platforms. This experience revealed a mismatch between the asynchrony of group \nprotocols and the synchrony of standard CORBA in-teraction mechanisms, which limited the portability \nof our CORBA object group service. We restricted the impact of this mismatch by encapsulating asynchrony \nissues inside a specific messaging sub-service. We dissect the cost of object group transparency in our \nvarious implementations, and we point out the recurrent sources of overheads, namely message indirection, \nmarshal-ing/unmarshaling and strong consistency. 1 Introduction By encapsulating a set of entities that \ncooperate to achieve some common goal, the group abstraction has proven to Supported by OFES under contract \nnumber 96.0454, as part of the ESPRIT project OpenDREAMS II (project 25262). +&#38;went affiliation: \nUnion Bank of Switzerland, Zurich. fk~~ss~on to make dlgltal or hard copes of all LIT pan of this work \nfor PerSonai or ClaSSrOOm use IS granted wIthout fee prwded that cCWeS are not made or dlstrabuted for \nproflt or commercial advan- tage and that KJPES bear this ncmce and the full c,tat,on on the f,rsi page \nTo COPY otherwse. to republish. to post on sewers or to redlstnbute to lists. requres pnor specific permws~on \nand/or a fee OOPSLA 98 10198 Vancouver, B.C. Q 1998 ACM 1.58113005.8/98/0010...$5.00 be very convenient \nfor distributed programming, particu-larly for achieving continuous availability (fault-tolerance) through \nreplication. Although the group abstraction is intu- itive, the underlying techniques required to implement \ngroup communication and group membership pose difficult prob-lems. Most of the papers dedicated to object \ngroups mainly describe specific techniques to integrate object group sup-ports in particular systems, \ne.g., Psync [35], Amoeba [44], Emerald [6], Arjuna [32], and CORBA [33, 10, 11. The mo-tivations and \nlimitations of various design and implementa- tion choices are however rarely discussed. The aim of this \npaper is to discuss, through two expe-riences, general issues on (1) how to build system support for \nobject groups and (2) how to build such support using standard object mechanisms. 1.1 Objectives The \nexperiences we describe in this paper had two common objectives: Object group protocols. The first objective \nwas to build a library of distributed protocols that support object replication through the use of group \nmechanisms (group membership and group communication). The aim here was to ensure object continuous availability \nand pre-serve replica consistency despite concurrency and fail- ures. We considered a distributed system \nmodel where nodes (machines) may crash and recover but do not behave maliciously. When a node crashes, \nall its pro- cesses stop performing actions. Group transparency. Another major objective was to provide \nthe ability to transparently plug a group proto-col underneath object invocations, within an applica-tion \nthat was written without fault-tolerance in mind. This group transparency feature means that one can \nview a group of replicas as a single object. The main difference is the ability for the group to tolerate \nfail-ures. An experimented programmer should however be capable of changing the default group protocol \nwith one that better suits the application semantics (e.g., use passive replication instead of active \nreplication [23]), or even build her/his own group protocol. Experiences Our first experience (1992-1996) \nstarted in the context of the GARF project, financed by the Swiss National Science Foundation (SPP IF \n5003-034344) and resulted in the devel- opment of two prototype systems, GARF i and Bast 2, both providing \nsupport for Smalltalk object groups. Our second experience (1995-1998) was performed in the context of \nthe European Esprit projects OpenDREAMS (project 20843) and OpenDREAMS II (project 25262), and resulted \nin the development of a CORBA Object Group Service. 1. Smalltalk object groups. We started in the first \nexperi-ence by building support for Smalltalk object replica-tion using the Isis group toolkit [5]. We \nimplemented a full prototype, named GARF and illustrated its use by replicating a distributed diary manager \napplication in a local area network [15, 16, 241. The reflective fa-cilities of Smalltalk made it easy \nto build a simple two-level mailer/encapsulator model that separates replica- tion aspects from application \nfunctional features. Re-lying on an underlying process group communication toolkit revealed however a \nfundamental mismatch be-tween the semantics of process groups and object groups. Roughly speaking, process \ngroup toolkits (such as Isis) usually assume a large grain client/server model, whereas object based \nprograms are usually made of fine grain dynamic entities that alternatively play the roles of client \nand server. The mismatch posed several problems such as mixed scheduling, duplicated invoca-tions and \ngroup proliferation. In a first step, we limited the effect of the mismatch by building a specific adap-tor \nto interface Smalltalk objects and Isis processes, but we had to make strong assumptions on the nature \nof the target applications (e.g., no multi-server request atomicity). In a second step, we gave up Isis \nand we built (from scratch) our own open object oriented dis-tributed protocol framework, named Bast, \nspecifically adapted to support object groups. Bast is open in the sense that distributed protocols such \nas failure detec-tion and multicast are considered as first class enti- ties directly accessible to the \nprogrammer, and it is a framework in the sense that most of those protocols can be customised simply \nby implementing call-backs. We implemented Bast in Smalltalk, first using inheri-tance as the only structuring \nmechanism and later by objectifying distributed algorithms through the Strat-egy Design Pattern [14] \nto promote flexible group pro-tocol composition. 2. CORBA object groups. The second experience aimed \nat supporting CORBA object groups [37], in a lan-guage independent manner. The goal was to support the \ncoexistence of groups of objects written in different languages and even within the same group, of objects \nwritten in different languages. We designed and imple- mented a CORBA Object Group Service (OGS) along \nthe lines of other CORBA services, such as the Ob-ject nansaction Service and the Event Service [38]. \nWe reused our Smalltalk experience in OGS by re-lying on a mailer/encapsulator communication model to \nachieve separation of concerns and an object ori-ented distributed protocol framework to support ob-ject \ngroups. OGS was first implemented in C++ us-ing Orbix [28] and was shown to be very effective  GARF \nis the French acronym for G&#38;dration Automatique d Applications RCsistantes out Fates. 21n the Egyptian \nmythology, East is a cat-goddess. in supporting object replication in a language inde-pendent manner. \nWe later ported OGS on Visibro-ker [43]. Although OGS was specified following the OMG guidelines and \nour target Object Request Bro-kers (Orbix and VisiBroker) are widely considered as CORBA compliant, it \nwas not possible to fully port OGS code from one ORB to another. We thus ended up with slightly different \nimplementations of OGS for Orbix and Visibroker. The reason of this limited porta-bility is the mismatch \nbetween the asynchrony of group protocols and the synchrony of CORBA basic mecha-nisms. Indeed, most \nof distributed protocols underly-ing object groups are asynchronous, whereas CORBA mainly provide synchronous \nObject Remote Procedure Calls. Full asynchrony is not guaranteed by the CORBA specification 2.1, and \nalthough some form of asynchrony can be obtained on specific ORB imple-mentations using event handling \nor multi-threading, none of these solutions is fully portable. We restricted the impact of the mismatch \nby encapsulating asyn-chrony issues inside a specific messaging sub-service, which is the only non-portable \ncomponent of OGS. Interestingly, in all (non-optimised) implementations that came out of our projects, \nfull group transparency introduces an overhead factor of around 10, when compared with a re- mote invocation \nof a single object. This overhead can be viewed as the price to pay for encapsulating plurality [6]. \nWe dissect this overhead by separating the various underly-ing costs: (1) the cost of message indirection \n(i.e., invoca-tion transparency), (2) the cost of marshaling (i.e., argument transparency), and (3) the \ncost of the total order multicast protocol (i.e., behaviour transparency).  1.3 Lessons The aim of this \npaper is not to describe the architectures or the implementations of the systems that resulted from our \nexperiences, namely GARF, Bast and OGS. Several papers have been published on these systems ([15, 16, \n24, 11, 19, 131). Our objective here is rather to point out general ob-servations that we drew from building \nthose systems. Even though our experiences were mainly directed towards the use of groups for providing \ncontinuous availability (fault-tolerance) through object replication, we believe that the observations \nwe point out apply also to other usages of groups, such as load balancing, on-line software life cycle \nand cooperative work. In fact, we believe that most of those observations concern general developments \nof object based distributed systems. The mismatch between process groups and object groups applies not \nonly to Isis, but to all process group toolkits we know about (see [40] for a survey on these toolkits). \nSeparating distributed protocols from the algorithms that implement them within two inheritance hierar-chies \nis a nice principle to achieve flexible and dynamic composition. This principle is worth considering \nin any distributed system of which components exhibit com-plex dependencies. The difficulty of implementing \nreliable distributed pro-tocols using standard remote object interaction applies not only to CORBA, but \nalso to other middleware such as Java RMI [25] or Microsoft DCOM [7]. 4. The mailer/encapsulator model \nwe used to separate the concerns of replication from other application as-pects can be viewed as a pragmatic \nreflective model for general object based distributed computing. 5. The conclusions we drew about the \nunderlying costs of group transparency and the major role of marshaling overhead, would apply to many \nother reliable object based distributed systems.   1.4 Roadmap The rest of the paper is organised as \nfollows. Section 2 discusses the mismatch between object groups and process groups. Section 3 poses the \nproblem of group protocol com-position and sketches the solution we adopted in our im-plementations. \nSection 4 discusses the mismatch between the asynchronous semantics of group protocols and syn-chronous \nstandard CORBA invocations. Section 5 describes the mailer/encapsulator model we used to separate the \ncon-cerns, and the way we implemented it in Smalltalk and CORBA. Section 6 presents some performance \nmeaSures of our implementations and dissects the cost of object group transparency. Section 7 concludes \nthe paper through some pragmatic considerations. 2 Object groups vs. process groups This section recalls \nthe background of our first experience and presents a major problem we faced, namely the mis-match between \nobject groups and process groups. We then describe the way we limited the impact of the mismatch by building \nan object adaptor on top of Isis and we point out alternative solutions. 2.1 Background The two best \nknown replication strategies are active and passive replication [23]. With active replication, all copies \nof the replicated object handle each request and return a reply. Active replication has the advantage \nthat it does not require any specific treatment if a replica crashes (as long as enough replicas are \noperational). To ensure replica consis-tency, a total order multicast protocol is used to ensure that \nall replicas receive concurrent requests in the same order (Figure la). With passive replication, only \none replica (gen-erally called the primary) executes the request and updates the other replicas (Figure \nlb). A reliable protocol is used by the primary to update the state of the other replicas and a group \nmembership protocol is used if a replica crashes or recovers. As shown in [23], both replication strategies \nhave their pros and cons and a system that is intended for programming general replicated applications \nshould support both strategies. Our first experience consisted in building support for Smalltalk object \nreplication. We decided to provide a de- fault active replication behaviour and to enable the pro-grammer \nto use passive replication instead when desired. While both replication strategies are intuitive, the \ndistributed protocols (e.g., total order multicast and group \\ 1 machine 1 \\ \\ \\ I \\ , \\ I \\ macbin 3 \n\\ / &#38;?-UP 1, \\ NC-0(a) Acllva Replkalion \\ machine3 \\ / \\ (b) PaulveReplkW~~n \\\\,,,0 Figure 1: Active \nand passive replication membership) required to implement them are quite com- plex [23]. Instead of building \nthose protocols from scratch, we decided to rely on an existing distributed toolkit, namely Isis, which \nat the time of our experience (1992), was the only widely known system offering reliable group protocols. \nIn the following, we point out several effects of the mis-match between the semantics of Smalltalk object \ngroups and Isis process groups. We faced the mismatch when experi-menting the use of our first prototype \n(named GARF [15]) through a replicated distributed diary manager application. RoughIy speaking, each \nmember of our group had a (repli- cated) diary used to store the list of meetings to which the member \nparticipates (the application is detailed in [15]).  2.2 The mismatch Group proliferation Mapping every \nobject group (i.e., group of object replicas) to a group of processes is a natural way to directly reuse, \nat the object level, the group mechanisms provided by process group toolkits (Isis in our case). In particular, \nprocess group toolkits provide support for creating groups, naming groups, maintaining group membership \ninformation and multicast-ing messages to group members with various delivery guar-antees. The direct \nmapping (one object group corresponds to one process group 3.) had however two important conse-quences \non our implementation. 1. Ouerlapphg groups. Since objects are usually light-weight entities and several \nobjects reside within the same process, we came out with the situation where several lsis process groups \nwere created, even when those groups were actually gathering the same set of processes (the groups overlapped). \nIn our distributed diary manager application for instance, we created a replica of each diary, on every \nmachine of our local network. As a result, several Isis process groups were created: one for each diary. \nAll groups were actually gathering the same set of processes (i.e., the set of Isis processes of our \nnetwork). This is conveyed by Fig- ure 2 for a scenario with three objects replicated on the same machines: \nmachine I and machine 2. Three Isis process groups are created for the same processes, namely process \n1 and process 2. Every Isis group of processes introduces specific bandwidth and process-ing overhead \ndue to the group internal management for group membership and message ordering. In fact, a single group \ngathering process 1 and process .2 would have been sufficient. 2. Super-groups. The total order multicast \nprimitive pro-vided by Isis ensures strong server replica consistency in a pure client-server interaction \n(Figure la). Roughly speaking, this primitive guarantees request atomicity with respect to concurrency \nand failures. There are situations however where the client object needs to interact with several servers \nin an atomic way. In our distributed diary manager application for instance, scheduling a meeting requires \nthe interaction with several replicated diaries: a meeting is scheduled if the date is free for all involved \npersons. Hence, scheduling a meeting implies an atomic update to several diaries.  An alternative mapping \nis diSCUSSed in Sect.2.3 Figure 2: Group proliferation When every diary is replicated, a meeting implies \nan atomic activity that involves several replicated objects. The only way to ensure such a transactional \nkind of atomicity is to create, for every multi-server request, a super-group that contains all replicated \ndiaries 4. Fig- ure 3 shows a scenario involving two replicated objects. The required semantics is indeed \nensured but with a considerable overhead due to the management of big temporary super-groups. Request \nduplication When a client invokes an actively replicated server, each replica of the server receives \nthe invocation, performs the requested operation and returns a reply. There is no coor-dination among \nthe replicas which behave as if they were independent entities. Active replication is straightforwardly \nsupported with a total order multicast primitive when the replicated server plays indeed the strict role \nof a server. This is not always the case in an object based application as ob- jects may alternatively \nplay the roles of client and server. If a replicated object plays the role of a client for another server, \nthe scenario above will come out with duplicated re-quests, As shown in Figure 4, request 2 is sent twice \nto ev-ery replica of the second replicated object. This introduces a considerable overhead and can even \ncause inconsistencies with non-idempotent operations. Although more subtle, this problem actually occurs \nalso with passive replication. The primary of the first replicated object may issue the request and then \ncrashes and when a new primary is elected, the latter can in turn issue another request. We had thus \nto add, on top of Isis, a specific mecha-nism to filter every invocation from a replica in order to dis- \ncard duplicated requests. The filtering mechanism required a specific distributed synchronisation protocol \nbetween the replicas to ensure that exactly one request is issued by the replicated object, even in the \ncase of failures. The mecha-nism, based on symmetric proxies, is detailed and illustrated on the replicated \ndiary manager in [34]. 4Due to the possibility of deadlocks, a locking based solution does not guarantee \ncontinuous availability. Total Order MUlthSt / I / I : f I I I \\ \\ \\ \\ \\ \\ \\ \\  Figu .re 3: A super-group \nis created for a multi-server request \\,replicated object,U-\\,~plicaled object 5 Figure 4: Duplicated \nrequests Figure 5: Separating processes Mixed scheduling Isis distributed protocols heavily rely on \nasynchronous com-munication. This is crucial for distributed protocols such as failure detection and \ngroup membership. To support asyn-chrony, Isis relies on its own multi-threading model. Sim-ilarly, Smalltalk \nheavily depends on its multi-threading fa-cilities (e.g., to run the GUI). The coexistence of the two \ndifferent threading models had two important influences on our implementation. 1. There was no way of \ncontrolling the concurrency be-tween Smalltalk and Isis threads within the same Unix process. We had \nthus to separate the Smalltalk appli-cation from the Isis protocols within two different Unix processes \n(in every machine). We placed a specific syn-chronisation adaptor between every Isis process and its \nassociated Smalltalk process (Figure 5). 2. Some of Isis distributed protocols provide ordering guar-antees \nfor messages exchanged between the processes. For instance, the Isis total order multicast protocol en-sures \nthat all messages sent to a group of processes g, are delivered in the same order by the members of g \nto the associated Smalltalk processes. This however does not guarantee any ordering between concurrent \nobject invocations inside Smalltalk processes, because of Smalltalk multi-threading. We had thus to explic-itly \nprovide a strong serialisation mechanism between the Isis and Smalltalk processes (Figure 5) in order \nto maintain the message ordering determined by Isis protocols. The serialisation mechanism does not pass \na request to the Smalltalk process unless the reply to the previous request has been obtained.  2.3 \nAlternatives The mismatch between process groups and object groups is not specifically related to Isis. \nAll process group communi-cation toolkits we know about (e.g., Totem and Horus [40]) were inspired by \nIsis and would pose the same problems. Both the object adaptor we had to add on top of process groups \nand the restriction we made about replicated objects (there is no multi-server request atomicity) would \nhave been necessary. At UCSB for instance, Narasimhan, Moser and Melliar-Smith had to design a similar \nadaptor, named Eter-nal [36], on top of their Totem process group communication system to support object \nreplication. The same approach was followed by Maffeis (in the Electra system) to support CORBA object \nreplication with Isis and Horus [33]. Several designers of process group communication toolk-its have \nrecognised the mismatch between object groups and process groups. For instance, some experiments with \nthe notion of light-weight group have recently been done in Ho- rus [41]. A light-weight process group \nis mapped onto an object group, and several light-weight groups are mapped onto one single process group, \namortising the cost of many membership changes (Section 2.2.1). This indeed limits the impact of the \nmismatch (namely overlapping groups) but does not solve all the problems we have faced (e.g., mixed scheduling, \nrequest duplication). Several researchers (e.g., [9]) have argued that group communication toolkits are \nnot adequate to support object replication and that transactional systems provide the ideal support. \nIndeed, transactions can ensure the consistency of multiple replicas despite concurrency and failures. \nNever-theless, existing transactional systems rely on the so-called 2PC protocol [2], which might on \none hand block all repli-cas accessed by a transaction if the transaction coordinator crashes, and on \nthe other hand abort a transaction if a single replica crashes [22]. In the Arjuna project for instance \n[42], which aimed at supporting object replication using trans-actions, Little and Shrivastava had to \nadd group commu-nication to their basic transactional kernel [32]. Hence, unlike [9], we do not claim \nthat group communication prim-itives are useless and that one should better use transactions. We rather \nclaim that, to support object groups, group com-munication primitives must be build with object semantics \nin mind. A transactional mechanism should however be inte- grated within group communication to support \nmulti-server request atomicity. 3 Composing group protocols This section discusses the issue of composing \ndistributed protocols in an object oriented framework. We had to deal with that issue in a later stage \nof our first experience, when we decided to build, from scratch, a protocol framework to support Smalltalk \nobject replication (instead of relying on a process group toolkit, i.e., Isis). We named that framework \nEast. We first summarise below the main characteristics of Bast. Then we discuss the problem we faced \nwhen rely-ing on inheritance as the only mechanism to structure dis-tributed protocols. Finally we describe \nhow we by-passed that problem by separating protocols from the algorithms that implement them (i.e., \nby objectifying the algorithms). 3.1 Background To support Smalltalk object replication (without the \nneed for an underlying process group system), we built, also in Smalltalk, the Bast object oriented distributed \nprotocol framework. In Bast, we provided group protocols at the object level, together with support for \nmulti-server atom-icity, request filtering, and Smalltalk integrated scheduling. Besides circumventing \nthe mismatch between object groups and process groups semantics, we wanted to promote flexi-ble group \nprotocol composition in order to experiment with various replication implementations. cl868 RMPObjeet \nclass FDObJect class RMCOblect class GMObject Figure 6: Bast basic protocols We built Bast as an open \nobject oriented protocol frame-zuorlc: Bast protocols are designed as object classes, and structured \nin a way that a system programmer can cus-tomise them by sub-classing existing protocols and imple-menting \ncall-backs (see [17] for various examples). In con-trast to group communication toolkits we know about \n(e.g., Isis), we did not consider group membership to be a basic protocol on which all replicated applications \nmust rely. We rather considered lower level abstractions such as consensus and failure detection to be \nfist class citizens as well, directly accessible to the programmer. As a consequence, Bast does not impose \nany reliable distributed programming paradigm. A non-blocking atomic commitment protocol is straightfor- \nwardly built using the Bast consensus protocol, and one can mix within the same application, group communication \nwith transactions [21, 171. Figure 6 presents some of the low level protocols of Bast and their dependencies. \n 3.2 Structuring protocols with inheritance Reliable distributed protocols are often challenging to build \nbecause of their complex dependency relationships. As shown in Figure 6, the group membership protocol \nis built on top of consensus and failure detection protocols. Consensus is itself based on failure detection, \nreliable multicast, and reli- able (point-to-point) communication. In our first implementation of Bast \n[17], we relied on in- heritance as the only mechanism for structuring distributed protocols. Every protocol \nis represented by a class that in-herits from all protocol classes on which it depends. By sub-classing \nappropriate protocol classes and implementing their call-back operations according to the desired seman-tics, \nprogrammers have the ability to tailor protocols to their needs. However, inheritance alone is not sufficient \nas far as protocol composition goes, as it does not allow us to easily implement a new algorithm for \nsome existing protocol and to use it in whatever protocol class we want. To illustrate this problem, \nconsider Figure 6 and suppose some protocol programmer wants to change the failure de-tection algorithm \non which consensus and reliable multicast depend, while leaving it unchanged for group membership. This \nindeed makes sense as the optimal failure detection mechanism for group membership is not the same as \nfor con- sensus and reliable multicast. In a group membership pro-tocol, a replica that is suspected \nis excluded from a group, which is an expensive operation. One should better make sure that the replica \nis not just slow (and falsely suspected). Hence, even after a long t,ime-out period, before a suspicion \nis indeed raised, it makes sense to first confirm that sus-picion by contacting several replicas (e.g., \na majority) and checking the validity of the suspicion. On the contrary, in consensus or reliable multicast, \nsuspecting a replica leads to electing a new leader or forwarding missing messages, which can be desirable \nto fastly terminate the protocols. In this case, a simple heartbeat protocol (every replica periodically \nsends an I am alive message to all) based on a short time-out period failure detection is sufficient. \n With inheritance alone as a code reuse mechanism, one has to implement the new failure detection algorithm \nboth in class CSSObject and class RMCObject, hampering optimal code reuse. Assembling the various protocol \nlayers through multiple inheritance can be viewed as an appealing alternative: each class would implement \nonly one protocol, while accessing all required underlying protocols through abstract operations. The \nlatter would then be provided by other protocol classes through multiple inheritance. With this design \n(sometimes called mtiins), protocol classes would all be abstract. The drawback with this approach is \nthat classes are not more ready-to-use components: before being able to actually cre-ate a protocol object, \none has to build a new class deriving from all the necessary protocol classes. Furthermore, be-cause \nprotocol layers are assembled through sub-classing, it is very difficult to compose them at runtime. \n 3.3 Objectifying the algorithms To achieve flexible protocol composition, we objectified dis-tributed \nalgorithms, i.e., we separated protocol layers from their implementations (i.e., the algorithms), themselves \nma-nipulated as first-class objects. As we show in [18], objecti- fying distributed algorithms comes \ndown to recursively ap-ply the Strategy design pattern introduced by Gamma et al. [14]. Following the \nterminology of [14], a protocol is a context and an algorithm is a strategy. This approach makes protocol \ncomposition very flexible and even possible at run time. Protocol dependencies are expressed only at \nthe specification level, through subclass relationships. The algorithms are structured in a separate \ninheritance hierar-chy. This can lead to choose/build the algorithm that is best adapted to every protocol. \nBack to the failure detection ex-ample above, one can have a majority based failure detector algorithm \nwith for the group membership protocol, and a simpler failure detection algorithm (with a short time-out \nvalue) for the consensus and reliable multicast protocols. Although applied in a different context, this \napproach is similar to the one followed in the design of the CONDUIT+ framework of network protocols \n[26], and the z-Kernel li-brary of communication protocols [39]. 4 Asynchronous protocols vs. synchronous \ninvocations Our Bast framework enabled us to experiment with vari-ous group protocols and algorithms. \nThe main limitation of Bast however is its restriction to single-language object groups, namely Smalltalk. \nWe decided to reuse the expe-rience gained from Smalltalk object replication and build support for general \nCORBA object replication. In the fol-lowing we recall the context of our CORBA experience, then we discuss \nthe difficulty we faced in building (reliable) group communication protocols using standard CORBA commu-nications, \nnamely the mismatch between the asynchrony of group protocols and the synchrony of standard remote CORBA \nobject invocations. We describe the way we dealt with that mismatch and we discuss alternative approaches. \n4.1 Background The Common Object Request Broker Architecture (CORBA), proposed by the Object Management \nGroup (OMG) [37], is a middleware specification that defines the basic mecha-nisms for remote object \ninvocation through an Object Re-quest Broker (ORB), as well as a set of services for object management, \ne.g., Persistence Service, Event Service, and !i runsaction Service [38]. The basic ORB specification \ndoes not contain any aspect related to fault-tolerance and the only CORBA service which offers some degree \nof reliability is the l%ansaction Service. However, as pointed out in Sec- tion 2, the protocols underlying \nthat service preserve con-sistent long-term data by using recovery mechanisms upon failures, but do not \nensure continuous availability 5. Our objective consisted in building support for CORBA object groups \nfollowing the OMG guidelines, i.e., we added group support as a new CORBA service, besides existing CORBA \nservices and without requiring any modification to the ORB specification. This approach follows the de-sign \nof the other functionalities that have been added to CORBA through services, such as persistence and \ntransac-tions. These services were specified in CORBA IDL and were adopted as CORBA standards. With this \nobjective in mind and after our first experience with Smalltalk object replication, we designed a set \nof IDL interfaces to describe our Object Group Service (OGS), itself designed as a set of sub-services \n(Figure 7). We implemented it in C++ us-ing two commercial off-the-shelf ORBS that comply with the CORBA \n2.1 specification: Orbix and Visibroker. Although we strictly followed the OMG guidelines in ser- vice \ndesign and implementation, it was not possible to obtain a fully portable code for OGS (from Orbix to \nVisibroker). The major reason was that distributed group protocols, such as failure detection and group \nmembership, are inherently asynchronous and, as we discuss below, there is no standard- ised CORBA support \nfor (reliable) asynchronous communi-cation. 4.2 The mismatch In the CORBA specification, remote object \ninvocations are by default synchronous. A client invokes operations on a lo- OMG explicitly requires \nthe use of the 2PC protocol, which is known to be non-fault-tolerant [2]. In fact, the OMG is currently \nissuing a Request For Proposal concerning fault-tolerant CORBA. We will come back to that in the last \nsection of this paper. Figure 7: OGS and its components as CORBA services cal stub, which marshals arguments, \nsends requests over the network, awaits a response, and returns it to the client. The client application \ncode is blocked on the request until com-pletion. This communication mechanism is sometimes called Object \nRemote Procedure Call (ORPC). It is inspired by the well known RPC paradigm [3], and is also the basic \ncommu-nication paradigm of distributed middleware like DCOM [7] or Java RMI [25]. ORPC extends distributed \ncomputing in a straightforward manner from non-distributed object invoca-tion and hence greatly eases \ndistributed application develop-ment. However, there are many situations in which ORPC is not sufficient, \nincluding the programming of reliable dis-tributed protocols such aa failure detection and consensus, \nat the heart of our protocol framework. CORBA specification allows to declare operations using the oneway \nIDL keyword. This keyword identifies an oper- ation as flowing exclusively in one direction, i.e., the \nopera- tion does not return any value. The CORBA specification also provides a send now -receive latter \ninvocation style, called deferred synchronozls invocations, through two basic operations: send and get-response. \nThe problem with these types of invocations is that their semantics are (intentionally) too vague in \nthe specification. More precisely, the only guarantee provided is that the re-quested operation is performed \nat most once and the re-quester never synchronises with the completion, if any, of the request [37]. \nThis, in fact, does not even prevent a compliant ORB to discard the invocation message without sending \nit. Furthermore, the specification does not enforce request-only operation to be non-blocking. Nothing \nindeed states that the client will not wait for the server to acknowledge the reception of the message \nthat transports the remote invoca-tion; thus, a remote call can block forever at the transport level, \nwhich can block in turn the application. This situation can typically occur in case of a link failure, \nif the network is congested, or if the server is extremely busy. For instance, an Internet Inter-ORB \nProtocol (IIOP) invocation can block the entire process on a oneway call just because a TCP/IP Figure \n8: The Messaging Service buffer fills up. Although the ORB at the client side could detect a possible \ndeadlock when performing an IIOP call, this behaviour is not guaranteed by the CORBA standard. As a consequence, \nin order to avoid having OGS rely on unreliable communication mechanisms, we decided to base our implementations \non neither of the above mentioned mechanisms and we used multi-threading instead.  4.3 Multi-threading \nA natural way to provide asynchronous communication on top of synchronous invocation is to use multi-threading, \ne.g., by starting threads for outgoing requests. However, in ver-sion 2.1 of the CORBA specification, \nthread support and management is not specified and thus is not portable. Al-though both Orbix and VisiBroker \nsupport multi-threading, they provide very different programming models. Both pro-vide object oriented \nwrappers for threads, locks and condi- tion variables that ensure platform independence (e.g., be-tween \nPosix and Windows NT threads), but these wrapper classes are not compatible. As a result, our OGS resulting \ncode was not fully portable and we came out with two slightly different implement* tions: one for Orbix \nand one for Visibroker. Fortunately, the non-portable part of the code was confined within our messaging \nservice: one of the services underlying OGS (Fig- ure 7). This service relies on multi-threading to provide \nbasic mechanisms for managing reliable asynchronous mes-sages. An Object Messaging Service will be soon \nstandardised by the OMG, providing various qualities of service, including reliable asynchronous message \npassing. Although it might take some time before commercial ORBS support this ser-vice, OGS could be \nplugged on that service by simply re-placing its messaging service, with minimal impact on other OGS \nservices (Figure 8).  4.4 Alternatives CORBA Event Service Besides the basic CORBA communication mechanism, \nOMG specifies a publish/subscribe communication paradigm in the !---my*;L,----! ! machine2 !!mrhine3 \n Figure 9: An event channel is a single point of failure CORBA Event Service. This service decouples \nthe com-munication between suppliers and consumers through event channels. Suppliers produce event data \nand consumers pro-cess event data. An event channel is an intervening CORBA object that allows suppliers \nto communicate with consumers asynchronously (Figure 9). The major problem is that the architectural \ndesign of the Event Service is centralised: although consumers and suppliers use different interfaces \nfor pushing/pulling event data to/from the channel, they have to invoke the same centralised event channel \nobject in order to connect to an event channel. As shown by Figure 9, the event channel is a CORBA object \nlocated at a given machine and is thus a single point of failure. One might circumvent this problem by \nfollowing either of the three following approaches: l By replicating the event channel. This would lead \nto a recursive architecture as the aim of OGS is indeed to support replication. l By representing an \nevent channel as an IP multicast address (and not as a CORBA object). A supplier generates data by sending \nit to the multicast address. This approach was adopted by IONA in an Event Ser-vice implementation, called \nOrbixTalk [27]. However, the use of IP multicast is completely non-interoperable with other event channel \nimplementations: CORBA IIOP does not support IP multicast and an event chan-nel must have a unique (centralised) \naccess entry to be designated by an interoperable object reference. l By chaining event channels. Several \nevent channels could be located on the client and on the server site. This model provides two-way communication \nwith no single point of failure. Distinct clients generate data using distinct request-suppliers and \nreceive replies through distinct response-consumers. Although com-plex, this approach is fully CORBA \ncompliant, does not modify the Event Service specification and does not introduce a single point of failure \n[12]. Our modular structuring of OGS would a priori make it easy to change the implementation of our \nmessaging service and replace it with chained event channels or IP multicast (instead of multi-threading) \nwithout impact on the rest of OGS implementation. Proprietary communication mechanisms An alternative \napproach to the use of CORBA standard communication mechanisms and services would have been the use \nof external asynchronous communication primitives. This approach has been followed in Orbix+Isis [29], \nElec-tra [33] and Eternal [36]. Besides the fact that these systems rely on process group communication \ntoolkits (Isis, Horus and Totem, respectively), with the inherent limitations that we pointed out in \nSection 2, they are proprietary and do not comply with the OMG architecture. In Orbix+Isis [29] and Electra \n[33], new extensions to IDL and ORB architecture are required. In fact, a pro-posal to the OMG has been \nmade for those extensions by Isis Distributed Systems, Inc [30], but the proposal was not adopted. Accepting \nthat proposal would have meant that all current ORBS should have to be rewritten to include sup-port \nfor group communication. In Eternal [36], the ORB is not aware of groups. Internet Inter-ORB Protocol \n(IIOP) requests are intercepted transparently on client and server sides using low-level interception \nmechanisms and passed to a group communication toolkit (Totem) that forwards them using group multicasts. \nThe interception approach does not require any modification to the ORB, but it relies on low-level mechanisms \nspecific to Unix platforms and it is not clear how invocations to replicated and non-replicated ob-jects \nare distinguished. 5 Separating the concerns One of the major objectives of our experiences was to achieve \nclean separation of concerns, i.e., separation of group com-munication features from application functional \ncode. The aim was to hide groups for a programmer that is not exper-imented in reliable distributed programming, \nbut to pro-vide enough flexibility for experimented programmers to customise the group protocols according \nto their applica-tion needs, without however touching the functional code of the application. We describe \nbelow how we achieved this objective using a simple two-level reflective model, and how we implemented \nit both in Smalltalk and C++/CORBA. 5.1 Background Ensuring separation of concerns in our context means \nthat application objects do not deal with grouping issues. They virtually communicate in a point-to-point, \nsynchronous, re-quest/reply manner. Aspects such as multicast invocations axe plugged transparently underneath \nthose invocations. To provide that capability, we have introduced two kinds of meta-objects [31]: encapsulators \nand mailers. The en-capsulator plays the role of a group member administrator whereas the mailer plays \nthe role of a group accessor (OT PTOXY). l Encapsulators are used to wrap (encapsulate) replicas by controlling \nthe way they treat incoming and out-going requests. An encapsulator contains the replica- tion code that \nneeds to be executed at the node of the replica, before and/or after the replica executes any of its \noperations. Encapsulators are located at the nodes of the replicas (in fact a replica and its ssso-ciated \nencapsulator execute within the same process). Every replicated object class is mapped to a class of \n 5.2 A pragmatic reflective model machine 3 Figure 10: Mailer and encapsulators encapsulators. The default \nencapsulator class imple- ments the actiwe replication strategy: it ensures that all replicas treat an \ninvocation and return a reply. As long as one replica is alive, a reply is returned. No specific treatment \nis needed if a replica crashes (the default strategy assumes perfect failure detection, e.g., no network \npartitions). One can however map a repli- cated objects to an encapsulator class that implements a different \nstrategy. For instance, one can uses the pas- sive replication strategy (primary-backup), which con-sumes \nless resources as only one replica, the primary, performs the requests, but requires specific treatment \nin the case of the crash of the primary, i.e., a new primary must be elected. Mailers act as smart proxies \nof replicated objects. They are smart in the sense that they do not only forward communication, but they \nalso transform point-to-point invocations into multicast invocations to sets of repli- cas. A mailer \nof a replicated object is created at every node where a reference of that object exists (in fact they \nexecute on the same process). Every replicated object is mapped to a class of mailers. The default mailer \ntransforms point-to-point invocations into to-tally ordered multicasts, and waits for the first reply. \nOne can however map a replicated object to a mailer that provides a weaker semantic (e.g., reliable but \nnot totally ordered multicast) or does not wait for any re- PlY. Figure 10 depicts a simple scenario \nwhere a client C in- teracts with a replicated object S. Object S is bound to an encapsulator e(S) of \nthe default class ActiveReplica (ac-tive replication), and to a mailer m(s) of the default class TOcast \n(total order multicast). The replicas of S are Sl and S2, respectively attached to the encapsulators \ne(S)1 and e(S) 2. The mailer m(S) is located on the node of C and acts as a proxy of 5: m(S) transforms \na simple invocation to S into a remote multicast to Sl and S2. The mailer selects one reply among all \n(the first one to arrive), and forwards it to the client. Our mailer/encapsulator model can be viewed \nas a prag-matic reflective model as it has only one level of reflection, i.e., there is no meta-meta-level. \nThe mailer/encapsulator model is flexible enough and promotes an incremental pro-gramming methodology. \nFirst, the programmer describes the functional aspects of the application without consider-ing distribution \nand replication issues. At a later stage, the programmer turns to replication features by binding appli-cation \nobjects to adequate encapsulator and mailer classes. The binding step can actually be performed at run-time, \nand one can change a replication policy in a dynamic way. The mailer/encapsulator model is more flexible \nthan the Gaggle model introduced in [6]: a gaggle can be viewed as a specific abstraction hiding replication \nfrom clients. In com-parison, our model goes a step further in separating the concerns by decoupling \nthe client aspect of the replication code (i.e., multicast) from the server aspect of the replica-tion \ncode (i.e., synchronisation). The first is confined within mailers whereas the second is confined within \nencapsulators. 5.3 On mailers and encapsulators In Smalltalk In our Smalltalk [20] developments, the \nmailer/encapsulator model was implemented in a straightforward way using the reflective capabilities \nof the language. The association be-tween application objects, mailers, and encapsulators, is handled \nduring object creation and communication. We simply had to replace the names of replicated object classes \nin the Smalltalk dictionary, in order to catch replicated object creation through the doesNotUnderstand \nexception mechanism. Instead of returning the actual object, we added some specific code in order to \ncreate the replicas, perform the binding to encapsulator and mailer classes, and return a proxy instead \nof the actual object. In a similar way, every invocation is intercepted through the doesNotUnderstand \nexception mechanism, and redirected through mailers and encapsulators (the Smalltalk implementation of \nmailers and encapsulators is fully detailed in [IS]). In CORBA Although CORBA does not provide the same \nlevel of dy- namicity as Smalltalk, it offers some mechanisms for mes-sage interception and redirection. \nIn particular, CORBA 2.1 specifies a Dynamic Skeleton Interface (DSZ) and a Dy- namic Znvocats on Interface \n(DZZ). The DSI locally accepts requests that are actually aimed at the remote server inter-face, and \nwas used to redirect message through mailers. The DII constructs the invocations for the server interface, \nand is used to redirect messages through encapsulators (Figure 11). An easy way to implement mailers \nand encapsulators in our CORBA experience would have been to use ORB spe-cific mechanisms for message \ninterception and redirection, such as smart proxies and jilters in Orbix. Although most of commercial \nORBS we know about provide similar mecha-nisms, these are not CORBA compliant features and would have \nheavily impacted the portability of our code. The new CORBA specification introduces the notion of Interceptor \nobject. An interceptor is an object interposed in the request and response paths between a client and \nserver. After this notion is introduced into commercial ORBS, madhe Figure 11: Dynamic Invocation/Skeleton \nInterfaces it will be a reasonable alternative to dynamic invocation and skeleton interfaces for implementing \nmailers and encapsula- tors. 6 The cost of group transparency We dissect in this section the global overhead \nof full group transparency, both in Bast and OGS. After describing the configuration of our network, \nwe present the global overhead of group transparency, i.e., we compare the cost of trans- parently invoking \na group of replicas as if it was a single (fault-tolerant) object, with the cost of a single remote ob-ject \ninvocation. Then we detail the various costs underlying group transparency. We do not present any measure \non GARF/Isis because, at the time when this testing took place, Isis was no longer supported (by Stratus) \nand we did not own an Isis licence anymore. Some older measures of GARF/Isis are given in [IS]. Even \nfor Bast and OGS, we do not present exhaus-tive performance figures: these can be found in [13, 16, 191. \n6.1 System configuration The performance figures we describe below are obtained from Bast in Smalltalk \nusing VisualWorks 2.x, and OGS in C++ using multi-threaded VisiBroker for C++ 3.0. Testing took place \non a lOMbit Ethernet interconnecting 13 Sun SPARCstations 20 and UltraSPARCl running So-laris 2.5.1 and \n2.6. Each workstation was running Xwindows as well as several interactive applications (e.g., netscape \nand emacs): network and CPU loads were medium to high. We considered an object replicated on three Sun \nUltraSPARCl: each workstation was hosting one replica, and one client ap-plication was located on the \nsame node as one of the replicas. When receiving the client invocation, every replica immedi-ately sends \nback a reply, i.e., it does not perform any specific treatment. All tests consist in invoking an operation \nthat takes a single parameter, which is a value of a complex type (a sequence of references). In the \ncase of OGS, the parame- ter is an inout variable. Since our objective is to compare the cost of a transpar- \nent group invocation with that of a standard remote invoca-tions (i.e., with the invocation of a non-replicated \nobject), we measured only failure-free executions. Figure 12: Dissecting the cost of group transparency \n 6.2 The overhead of group transparency When measuring the cost of group transparency, we con- sidered \nthe case where a client issues a standard invocation that is intercepted and then transformed into a \nmulticast in-vocation to all replicas. The client is not aware of the server being replicated. The invocation \nis performed within a to- tal order multicast protocol which guarantees strong replica consistency. The \ninvocation is terminated when the client receives back the first reply. We compare this cost with that \nof an invocation of the same, yet non-replicated, ob-ject. For Bast, we considered a reliable remote \ninvocation, whereas for OGS, we considered a remote invocation over IIOP (TCP/IP), which is usually considered \nreliable. system BAST OGS Smgla remote Invocation Transparent group invocation 8 0.7 160.923 17.9 Table \n1: The overhead of group transparency -3 replicas - (invocations/set) Performance figures are presented \nin Table 1. Results are expressed in number of invocations per second (through- put). Interestingly, \nin both eases, group transparency has an overhead factor of around 10. 6.3 Dissecting the overhead As \nshown by Figure 12, there are various costs underlying group transparency: (1) message indirection (i.e., \ninvoca-tion transparency), (2) marshaling/unmarshaling (i.e., ar-gument transparency), and (3) total \norder multicast (i.e., behaviour transparency). For OGS, there is an extra cost, related to the use of \nan OGS daemon process to achieve lan-guage transparency (this cost is however small when com-pared to \nmarshaling). In the following, we consider each of those costs individually. Invocation transparency \nIn our context, invocation transparency means the ability to reuse an application code written without \nreplication in mind and plug group protocols underneath object invoca-tions. This is basically the cost \nof message indirection. In Bast, invocation transparency is achieved through the Smalltalk exception \ndoesNotUnderstand. When bypassing the mailer/encapsulator indirections, the response time of a local \ninvocation was around 10~s. When intercepted and redirected through mailers and encapsulators, the same \nin-vocation took about 500~s. The reason for the overhead is that during normal operation execution, \nthe Smalltalk virtual node is partially bypassed, whereas when the ex-ception is raised, the virtual \nnode reinterprets the method that caused the exception. This is what happens when the method doesNotUnderstand \nis called. Other slowdown fac-tors are the manipulation of stack frames as Smalltalk ob-jects and the \ncloning of mailers. In OGS, transparency is achieved through the Dynamic Skeleton Interface (DSI) and \nthe Dynamic Invocation Inter-face (DII). Table 2 presents the invocation throughput for both transparent \nand non-transparent invocations in OGS. In the latter case (non-transparent), invocations are per-formed \nwith stubs and skeletons that are generated at com-pile time. Protocol Transparent Non-transparent Broadcast \n36.4 81.4 Reliable 32.5 55.3 Total order multicast 17.9 22.6 Table 2: The overhead of invocation transparency \nin OGS (invocations/set) Not surprisingly, transparent invocations are less effi- cient that non-transparent \nones. The difference gets however smaller with complex protocols such as total order. This is due to \nthe fact that the DSI and the DII are used only once per invocation, and add a fixed cost to the invocation \ntime. If the protocol is complex, more messages are gener-ated, without increasing the fixed cost of \ndynamic request processing. Argument transparency The protocol frameworks underlying Bast and OGS enable \nus to perform group invocation, whatever the types of the invocation arguments are. In Bast, parameters \ncan be of any subclass of Object, whereas in OGS parameters can be of any subtype of the generic CORBA \ntype Any. Table 3 presents an approximation of the time percentage spent in marshaling and unmarshaling. \nWe consider only the case where invocations are performed with a total order multi-cast: this is the \ncase where the maximum number of remote messages are exchanged and where marshaling and unmar-shaling \nconsume the highest percentage (see [13,19] for more details on alternative multicast protocols). Implementation \nMarshaling ] BAST 65% OGS 45% Table 3: The overhead of marshaling (percentage) These results clearly \nconvey the fact that marshaling and unmarshaling are important causes of overhead. BAST im-plementation \nis baaed on VisualWorks Binary Object Stor-age Service (BOSS), which is not optimised for remote com-munication. \nIn the case of OGS, the cost associated to mar- shaling and unmarshaling is due to the management of \nAny values. Unlike other IDL types, Any values are augmented with type information. Constructing this \ninformation and checking its validity increase message size and slow down the remote invocation process. \nFor instance, extracting a complex structure from an Any value requires a time similar to that of performing \na remote invocation (in a LAN). Behaviour transparency We compare below the costs of various multicast \nprotocols. The first protocol is a simple multicast that does not guar-antee any consistency as the replicas \nmay receive the invo-cations in different orders and, even worse, some replicas might receive an invocation \nwhile other might not. This protocol can however be considered sufficient for a read-only invocation. \nThe second protocol is a reliable multicast which ensures that either all replicas receive the invocations \nor none of them does. This protocol does not ensure to-tal order, but is enough to guarantee consistency \nif the op- erations are commutative. Finally, the third protocol is a total order protocol which always \nguarantees strong replica consistency (even with non-commutative operations). It en-sures behaviouml \ntransparency: all replicas behave the same, and the replicated object looks like a non-replicated one. \nThe results conveyed by Table 4 clearly confirm the fact that strong consistency (i.e., behavioural transparency) \nin-troduces a considerable overhead. Implementation BAST OGS Multicast 7.5 100.1 Reliable multicast 2.2 \n62.4 Total order multicast 0.7 25.7  Table 4: The overhead of strong consistency -3 replicas -(invocations/set) \nThe algorithms we have used for reliable and total order multicast are similar to those described in \n[8]. In particular, the total order multicast protocol ensures that, whatever the number of crashed nodes, \nand even if nodes are falsely suspected to have crashed, total order is never violated. One could consider \na weaker, yet more efficient, algorithm that assumes for instance perfect failure detection and guarantees \ntotal order agreement in a probabilistic manner. Thanks to Bast and OGS open structures, changing the \nalgorithm will not require any modification to the application. Language transparency The OGS implementation \nconsidered so far uses a specific daemon process on every node to run the OGS code at the client side. \nThis approach has the advantage of achieving language transparency, e.g., a Java client can use the C++ \nversion of OGS. Table 5 compares the cost of the daemon approach with that of a library approach where \nOGS is sim- ply linked with the client. In the second case, the client needs to be written in the same \nlanguage as OGS (namely C++). Protocol Daemon Library Broadcast 36.47 81.4 Reliable multicast 32.5 55.3 \nTotal order multicast 17.9 22.6 Table 5: The overhead of language transparency (invoca- tions/sec) Not \nsurprisingly, the daemon solution introduces an over- head of an additional inter-process communication, \ni.e., the cost of the indirection through the daemon process. As for invocation transparency, the overhead \ngets smaller with complex protocols such as total order multicast. Summary For a couple of decades now, \nmany projects have been de-voted to the design and implementation of object based con-current and distributed \nsystems, mainly focusing on building support for object based concurrency control, remote object invocation \nand object migration [4]. Very few however have been devoted to building support for replication and \nobject groups. This is actually not surprising as most object based distributed systems have been experimented \non academic applications for which fault-tolerance is rarely a mandatory feature. This situation has \nrecently changed when distributed ob-jects became the cornerstone of industrial standards such as CORBA \nand DCOM. Applications in various areas are being developed or ported on object based distributed sys-tems, \nincluding those with strong requirements for contin-uous availability such as air traffic control, telecommunica-tion, \nmedical and financial systems. In fact, the OMG has issued a Request For Proposal (RFP) to enhance CORBA \nwith fault-tolerance through object group support, and our Object Group Service complies with many of \nthe require-ments of that RFP. From a more general point of view, we believe that the observations we \nsummarised in this paper can be of valuable help to the designers and implementors of future reliable \nobject baaed distributed systems. We claim for instance that the protocols underlying ob-ject groups \nshould be developed themselves within an object oriented protocol framework. This provides nice flexibility \nand modularity features and avoids the mismatch between object group and process group semantics. In \nthe context of CORBA, our claim means that the best way to intro-duce group support is to follow a service \napproach where group communication protocols are themselves CORBA ob-jects exporting IDL interfaces. \nWe pointed out the fact that group protocols cannot be easily implemented using stan-dard CORBA synchronous \nobject remote invocations. One should better rely on a separate asynchronous invocation mechanism, which \ncould be replaced by a standard one as soon as the CORBA Object Messaging Service announced by the OMG, \nis supported by commercial ORBS. We also argued that a simple reflective mailer/encapsulator model is \nsufficient to separate group primitives from other application aspects and there is no need for complex \nmulti-level reflective models. The mailer/encapsulator model can easily be implemented in a dynamic environment \nlike Smalltalk and with a reasonable effort in middleware like CORBA or DCOM, using their dynamic invocation \nfacilities. We also argue that group transparency should be pro- vided d la carte. It is indeed important \nto hide groups from non-experimented programmers and promote code reuse by separating application functional \ncode from specific calls to group primitives. Nevertheless, transparency comes in dif- ferent flavours \nand an experimented programmer should be able to switch-off any of those flavours and trade it with bet-ter \nperformances. For example, we have experimented with a Bast scenario where distributed protocol messages \nwith ack and naclc values were not marshaled (i.e., we switched- off argument transparency): the throughput \nof group invo-cation using a total order multicast protocol was doubled. The transparency d la carte \nprinciple has indeed been recog- nised as important for other distribution aspects, but we believe that \nthis principle is crucial for object group sup-port because of the cost and complexity of the underlying \nprotocols. As already pointed out, the aim of this paper was to draw general observations and not describe \nspecific aspects of our systems. More information on GARF, Bast and OGS, are available, respectively, \nat: http://lsewww.epj-l.ch/Research/Garf. http://lsewww. epfl. ch/Bast. The Smalltalk implemen- tation \nof Bast is public free and available there. A Java version of Bast will also be available at that address \nsoon. http://lsewww.epJ.ch/OGS. C++ implementations of OGS, for Orbix and Visibroker, are public free \nand available there. Acknowledgements We are very grateful to Ron Resnick for his comments on an earlier \ndraft of this paper.    References G. Agha and R. Guerraoui (guest editors). Theory and PI Practice \nof Object Systems, John Wiley and Sons, Inc. Special issue on High Availability in CORBA, 1998, 4 (2). \nP. Bernstein, V. Hadzilacos, and N. Goodman. Concur- PI rency Control and Recovery in Database Systems. \nAddi-son Wesley, 1987. A. Birell and B. Nelson. Implementing Remote Procedure [31 Calls. ACM Transactions \non Computer Systems, 2 (l), 1984, 39-59. J.P. Briot, R. Guerraoui and K.P Lohr. Concurrency and Distribution \nin Object-Oriented Programming. ACM Computing Surveys, September 1998. K. Birman and R. van Renesse. \nReliable Distributed  151 Computing with the Isis Toolkit. IEEE Computer Society Press, 1993. A. Black, \nand M. Immell. Encapsulating Plurality. Eu-ropean Conference on Object-Oriented Programming, Springer \nVerlag (LNCS 707), 1993, 57-79. N. Brown and C. I71 Kindel. Distributed Component Object Model Protocol. \nDCOM, http://www.microsoft.com/oledev/olecom. T. Chandra and S. Toueg. Unreliable failure detectors for \n PI reliable distributed systems. Journal of the ACM, 43 (2), 1996, 225-267. D. Cheriton and D. Skeen, \nUnderstanding the Limi- PI tations of Causally and Totally Ordered Communica-tion. ACM Symposium on \nOperating Systems Principles, 1993. [lo] E. Elnozahy, V. Ratan, and M. Segai. Experiences Using DCE \nand CORBA to Build Tools for Creating Highly-Available Distributed Systems. IEEE Symposium on Fault-Tolerant \nComputing Systems, 1996. [II] P. Felber, B. Garbinato, and R. Guerraoui. The Design of a CORBA Group \nCommunication Service. IEEE Sym-posium on Reliable Distributed Systems, 1996, 156-159. [12] P. Felber, \nR. Guerraoui, and A. Schiper. Replicating Objects with CORBA Event Channels. IEEE Workshop on Future \nTrends of Distributed Computing Systems, 1997, 14-21. [13] P. Felber, R. Guerraoui, and A. Schiper. The \nImple-mentation of a CORBA Object Group Service. Theory and Practice of Object Systems, John Wiley and \nSons, Inc. Special issue on High Availability in CORBA, 1998, 4 (2), 93-106. [14] E. Gamma, R. Helm, \nR. Johnson, and J. Vlissides. Design Patterns, Elements of Reusable Object-Oriented Software. Addison-Wesley, \n1995. [15] B. Garbinato, R. Guerraoui, and K. Mazouni. Dis-tributed Programming in GARF. In Object-Based \nDis-tributed Programming, Springer Verlag (LNCS 791), 1993, 225-240. [16] B. Garbinato, R. Guerraoui, \nand K. Mazouni. Imple-mentation of the GARF Replicated Objects Plateform. Distributed Systems Engineering \nJournal, 1 (2), 1995, 14-27. 1171 B. Garbinato, P. Felber, and R. Guerraoui. Proto-col Classes for Designing \nReliable Distributed Environ-ments. European Conference on Object-Oriented Pro-gramming, Springer Verlag \n(LNCS 1098), 1996, 316-343. [18] B. Garbinato and R. Guerraoui. Using the strategy design pattern to \ncompose reliable distributed protocols. Usenix Conference on Object-Oriented Technologies and Systems, \n1997, 221-232. [19] B. Garbinato and R. Guerraoui. Flexible Protocol Com-position in BAST. IEEE International \nConference on Distributed Computing Systems, 1998, 22-27. [20] A.J Goldberg and A.D Robson. SMALLTALK-80: \nThe Language and its Implementation. Addison Wesley, 1983. [21] R. Guerraoui and A. Schiper. !PransactionaZ \nmodel us Virtual Synchrony model: bridging the gap. In Theory and Practice in Distributed Systems, Springer \nVerlag (LNCS 938), 1995, 121-132. [22] R. Guerraoui, R. Oliveira, and A. Schiper. Atomic up-dates of \nreplicated data. European Dependable Comput-ing Conference, Springer Verlag (LNCS 1150), 1996, 365- 382. \n [23] R. Guerraoui and A. Schiper. Software-Based Replica-tion for Fault-Tolerance. IEEE Computer, 30 \n(4), 1997, 68-74. [24] R. Guerraoui, B. Garbinato and K. Mazouni. GARF: A Tool for Programming Reliable \nDistributed Applications. IEEE Concurrency, 5 (4), 1997, 32-39. [25] E. Harold. Java Network Programming. \nO Reilly, 1997. [26] H. Huni, R. Johnson, and R. Engel. A Framework for network protocol software. ACM \nConference on Object-Oriented Programming Systems, Languages and Appli-cations, 1995. [27] IONA. OrbixTalk \nProgramming Guide. IONA Tech-nologies Ltd, 1996. [28] IONA. Orbix 2.2 Programming Guide. IONA Technolo-gies \nLtd, 1997. [29] IONA and Isis. An Introduction to Orbix+Isis. IONA Technologies Ltd. and Isis Distributed \nSystems, Inc, 1994. [30] Isis. Object Groups: A response to the ORB 2.0 RFI. Isis Distributed Systems, \nInc, 1993. [31] G. Kiczales, J. des Rivieres, and D. Bobrow. The Art of the Metaobject protocol. The \nMIT Press, 1991. [32] M. Little and S. Shrivastava. Object Replication in Ar- juna. Broadcast Project \ndeliverable report, Vol. 2, 1994 (available from Dept of Computing Science, University of Newcastle upon \nTyne, UK). [33] S. Maffeis. Run-Time Support for Object-Oriented Dis-tributed Programming. PhD thesis, \nUniversity of Zurich, 1995. [34] K. Mazouni, B. Garbinato, and R. Guerraoui. Filtering Duplicated Invocations \nUsing Symmetric Proxies. IEEE International Workshop on Object Orientation in Oper- ating Systems, 1995, \n118-126. (351 S. Mishra, L. Peterson, and R. Schlichting. Implement-ing Fault-Tolerant Replicated Objects \nUsing Psync. IEEE Symposium on Reliable Distributed Systems, 1989. [36] P. Narasimhan, L. Moser, and \nM. Melliar-Smith. Exploiting the intemet inter-ORB protocol to provide CORBA with fault-tolerance. Usenix \nConference on Object-Oriented Technologies and Systems, 1997, 81-90. [37] OMG. The Common Object Request \nBroker Architec-ture: Architecture and Specification. OMG. [38] OMG. CORBAservices: Common Object Services \nSpec-ifications. OMG. [39] L. Peterson, N. Hutchinson, S. O MaIley, and M. Abott. Rpc in the x-Kernel: \nevaluating new design tech-niques. ACM Symposium on Operating Systems Princi-ples, 1989, 91-101. [40] \nD.Powell (guest editor). Communications of the ACM, 39(4), Special issue on Group Communication, April \n1996. [41] L. Rodrigues, K. Guo, A. Sargento, R. van Renesse, B. Glade, P. Verissimo, and K. Birman. \nA Transparent Light- Weight Group Service. IEEE Symposium on Reli- able Distributed Systems, 1996, 130-139. \n[42] S. Shrivastava, G. Dixon and G. Parrington. An Overview of Arjuna: A Progmmming System for Reli-able \nDistributed Computing. IEEE Software, 8 (l), 1991, 63-73. [43] Visigenic. Visibroker C++ 3.0 Progmmmer \ns Guide. Visigenic Software, Inc., 1997. [44] M. Wood. Replicated RPC Using Amoeba Closed Group Communication. \nIEEE International Conference on Dis- tributed Computing Systems, 1993. \n\t\t\t", "proc_id": "286936", "abstract": "This paper draws several observations from our experiences in building support for object groups. These observations actually go beyond our experiences and may apply to many other developments of object based distributed systems.Our first experience aimed at building support for Smalltalk object replication using the Isis process group toolkit. It was quite easy to achieve group transparency but we were confronted with a strong mismatch between the rigidity of the process group model and the flexible nature of object interactions. Consequently, we decided to build our own object oriented protocol framework, specifically dedicated to support object groups (instead of using a process group toolkit). We built our framework in such a way that basic distributed protocols, such as failure detection and multicasts, are considered as first class entities, directly accessible to the programmers. To achieve flexible and dynamic protocol composition, we had to go beyond inheritance and objectify distributed algorithms.Our second experience consisted in building a CORBA service aimed at managing group of objects written on different languages and running on different platforms. This experience revealed a mismatch between the asynchrony of group protocols and the synchrony of standard CORBA interaction mechanisms, which limited the portability of our CORBA object group service. We restricted the impact of this mismatch by encapsulating asynchrony issues inside a specific messaging sub-service.We dissect the cost of object group transparency in our various implementations, and we point out the recurrent sources of overheads, namely message indirection, marshaling/unmarshaling and strong consistency.", "authors": [{"name": "Rachid Guerraoui", "author_profile_id": "81100348136", "affiliation": "Computer Science Department, Swiss Federal Institute of Technology, CH-1015, Lausanne, Switzerland", "person_id": "PP40026317", "email_address": "", "orcid_id": ""}, {"name": "Pascal Felber", "author_profile_id": "81100552596", "affiliation": "Computer Science Department, Swiss Federal Institute of Technology, CH-1015, Lausanne, Switzerland", "person_id": "PP14191902", "email_address": "", "orcid_id": ""}, {"name": "Beno&#238;t Garbinato", "author_profile_id": "81100066273", "affiliation": "Computer Science Department, Swiss Federal Institute of Technology, CH-1015, Lausanne, Switzerland", "person_id": "P29032", "email_address": "", "orcid_id": ""}, {"name": "Karim Mazouni", "author_profile_id": "81100199681", "affiliation": "Computer Science Department, Swiss Federal Institute of Technology, CH-1015, Lausanne, Switzerland", "person_id": "P157057", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/286936.286961", "year": "1998", "article_id": "286961", "conference": "OOPSLA", "title": "System support for object groups", "url": "http://dl.acm.org/citation.cfm?id=286961"}