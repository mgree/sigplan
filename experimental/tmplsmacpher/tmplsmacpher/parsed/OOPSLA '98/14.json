{"article_publication_date": "10-01-1998", "fulltext": "\n Making the future safe for the past: Adding Genericity to the JavaTM Programming Language Gilad Bracha, \nSun Microsystems, gilad.bracha@sun.com Martin Odersky, University of South Australia, odersky@cis.unisa.edu.au \nDavid Stoutamire, Sun Microsystems, david.stoutamire@sun.com Philip Wadler, Bell Labs, Lucent Technologies, \nwadler@research.bell-labscorn Abstract We present GJ, a design that extends the Java program- ming language \nwith generic types and methods. These are both explained and implemented by translation into the unextended \nlanguage. The translation closely mim- ics the way generics are emulated by programmers: it erases all \ntype parameters, maps type variables to their bounds, and inserts casts where needed. Some sub- tleties \nof the translation are caused by the handling of overriding. GJ increases expressiveness and safety: \ncode utiliz- ing generic libraries is no longer buried under a plethora of casts, and the corresponding \ncasts inserted by the translation are guaranteed to not fail. GJ is designed to be fully backwards compatible \nwith the current Java language, which simplifies the tran-sition from non-generic to generic programming. \nIn particular, one can retrofit existing library classes with generic interfaces without changing their \ncode. An implementation of GJ has been written in GJ, and is freely available on the web. 1 Introduction \nGeneric types are so important that even a language that lacks them may be designed to simulate them. \nSome object-oriented languages are designed to support subtypes directly, and to support generics by \nthe idiom of replacing variable types by the top of the type hier-archy. For instance, a collection with \nelements of any type is represented by a collection with elements of type Object. Pernxss~on to make \ndigital or hard cqp~es of all or part of this work for personal or classmom use IS granted wthout fee \nprovided that ccwes are not made or distributed for proflt or commercwl adven-tage and that copies bear \nthis notice and the full citation on the first page. lo copy otherwise, to republish. to post on servers \nor to redHnbute to lasts, requires prlar specific perm~ssuon and/or a fee. OOPSLA 98 lo/99 Vancouver. \nKC. Q 1998 ACM 1.58113~005.8/98/0010...$5.00 This approach is exemplified by the Java program- ming language[GLS96]. \nGenerics are represented by this idiom throughout the standard Java libraries, in-cluding vectors, hash \ntables, and enumerations. As the Java Development Kit (JDK) has evolved, generics have played an increasing \nrole. JDK 1.1 introduced an ob-server pattern that depends on generics, as do the col- lection classes \nintroduced in JDK 1.2. Oberon also relies on the generic idiom, and dynamically typed languages such \nas Smalltalk [GR83] use this idiom implicitly. Nonetheless, generics may merit direct support. De-signing \na language with direct support for subtyping and generics is straightforward. Examples include Mod-ula \n3, Ada 95, Eiffel, and Sather. Adding generics to an existing language is almost routine. We proposed \nadding generics to the Java programming language in Pizza [OW97], and we know of four other proposals \n[AFM97, MBL97, TT98, CS98J. Clemens Szyperski proposed adding generics to Oberon [RS97]. Strongtalk [BG93] \nlayers a type system with generic types on top of Smalltalk. The generic legacy problem However, few \npropos- als tackle the generic legacy problem: when direct sup-port for generics is added to a language \nthat supports them via the generic idiom, what happens to legacy code that exploits this idiom? Pizza \nis backward compatible with the Java pro-gramming language, in that every legal program of the latter \nis also legal in the former. However, this compat-ibility is of little help when it comes to generics. \nFor example, JDK 1.2 contains an extensive library of col- lection classes based on the generic idiom. \nIt is straight- forward to rewrite this library to use generics directly, replacing the legacy type Collection \nby the parametric type Collection<A>. However, in Pizza these two types are incompatible, so one must \nrewrite all legacy code, or write adaptor code to convert between legacy and parametric types. Code bloat \nmay result from refer-ences to both the legacy and parametric versions of the library. Note the problem \nis not merely with the size of legacy libraries (which may be small), but with managing the upgrade from \nthe legacy types to para- metric types (which can be a major headache if refer- ences to legacy types \nare dispersed over a large body of code). If legacy libraries or code are available only in binary rather \nthan source, then these problems are compounded. GJ Here we propose GJ, a superset of the Java pro- \ngramming language that provides direct support for generics. GJ compiles into Java virtual machine (JVM) \nbyte codes, and can be executed on any Java compli- ant browser. In these respects GJ is like Pizza, \nbut GJ differs in that it also tackles the generic legacy problem. GJ contains a novel language feature, \nTQW types, to capture the correspondence between generic and legacy types, and a retrofitting mechanism \nto allow generic types to be imposed on legacy code. A parametric type Collection<A> may be passed wherever \nthe correspond- ing raw type Collection is expected. The raw type and parametric type have the same representation, \nso no adaptor code is required. Further, retrofitting allows one to attribute the existing collection \nclass library with parametric types, so one only requires one version of the library; an added plus is \nthat new code will run in any JDK 1.2 compliant browser against the built-in collec-tion class library. \nRaw types and retrofitting apply even if libraries or code are available only as binary class files, \nand no source is available. Combined, these techniques greatly ease the task of upgrading from legacy \ncode to generics. The semantics of GJ is given by a translation back into the Java programming language. \nThe translation erases type parameters, replaces type variables by their bounding type (typically Object), \nadds casts, and in-serts bridge methods so that overriding works properly. The resulting program is pretty \nmuch what you would write in the unextended language using the generic id- iom. In pathological cases, \nthe translation requires bridge methods that can only be encoded directly in JVM byte codes. Thus GJ \nextends the expressive power of the Java programming language, while remaining compatible with the JVM. \nGJ comes with a cast-iron guarantee: no cast in-serted by the compiler will ever fail. (Caveat: this \nguar- antee is void if the compiler generates an unchecked warning, which may occur if legacy and parametric \ncode is mixed without benefit of retrofitting.) Furthermore, since GJ compiles into the JVM, all safety \nand security properties of the Java platform are preserved. (Reassur-ance: this second guarantee holds \neven in the presence of unchecked warnings.) Security One may contrast two styles of implement- ing generics, \nhomogeneous and heterogeneous. The ho- mogeneous style, exemplified by the generic idiom, re-places occurrences \nof the type parameter by the type Object. The heterogeneous style, exemplified by C++ and Ada, makes \none copy of the class for each instantia- tion of the the type parameter. The GJ and Pizza com-pilers \nimplement the homogeneous translation, while Agesen, Freund, and Mitchell [AFM97] propose having the \nclass loader implement the heterogeneous tra.nsla-tion. Other proposals utilize a mixture of homogeneous \nand heterogeneous techniques [CS98]. As observed by Agesen, Freund, and Mitchell, the heterogeneous translation \nprovides tighter security guarantees than the homogeneous. For example, un-der the homogeneous translation \na method expecting a collection of secure channels may be passed a collec- tion of any kind of object, \nperhaps leading to a security breach. To minimize this problem, GJ always inserts bridge methods when \nsubclassing a generic class, so the user may ensure security simply by declaring suitable specialized \nsubclasses. The homogeneous translation also enjoys some ad- vantages over the heterogeneous. Surprisingly, \nwith the security model of the Java virtual machine, the hetero- geneous translation makes it impossible \nto form some sensible type instantiations. (This problem is entirely obvious, but only in retrospect.) \nGJ and other lan-guages based on the homogeneous t,ranslation do not suffer from this difficulty. Type \ninference While type systems for subtyping and for generics are well understood, how to combine the two \nremains a topic for active research. In particu- lar, it can be difficult to infer instantiations for \nthe type arguments to generic methods. GJ uses a novel algorithm for this purpose, which combines two \ndesirable (and at first blush contradic-tory) properties: it is local, in that the type of an ex-pression \ndepends only on the types of its subexpres-sions, and not on the context in which it occurs; and it works \nfor empty, in that inference produces best types even for values like the empty list that have many pos-sible \ntypes. Further, the inference algorithm supports subsumption, in that if an expression has a type, then \nit may be regarded as having any supertype of that type. In contrast, the algorithm used in Pizza is \nnon-local and does not support subsumption (although it does work for empty), while the algorithm used \nin Strongtalk [BG93] does not work for empty (although it is local and supports subsumption), and algorithms \nfor constraint- based type inference [AW93, EST951 are non-local (al-though they work for empty and support \nsubsumption). Pizza uses a variant of the Hindley-Milner algorithm [Mi178], which we regard as non-local \nsince the type of a term may depend on its context through unification. Raw types and retrofitting Raw \ntypes serve two purposes in GJ: they support interfacing with legacy code, and they support writing code \nin those few sit- uations (like the definition of an equality method) where it is necessary to downcast \nfrom an unparam-eterized type (like Object) to a parameterized type (like LinkedList<A>), and one cannot \ndetermine the value of the type parameter. The type rules for raw types are carefully crafted so that \nthe compiler can guaran-tee the absence of type errors in methods like equal-ity. However, when interfacing \nto legacy code, compile- time checking is not always possible, and in this case, an unchecked warning \nmay be issued. The prolifera-tion of unchecked warnings can be avoided by using retrofitting to add information \nabout type parameters to legacy code. Related work GJ is based closely on the handling of parametric \ntypes in Pizza [OW97]. The Pizza com-piler (itself written in Pizza) has been freely available on the \nweb since 1996. GJ differs from Pizza in pro-viding greater support for backward compatibility, no-tably \nin allowing new code to work with old libraries. GJ also uses a simpler type system. In Pizza the type \nof an expression may depend on the type expected by its context, whereas in GJ the type of an expression \nis determined solely by the type of its constituents. GJ maintains no run-time information about type \nparameters. The same design decision is made in Pizza and in a proposal to add parametric types to Oberon \n[RS97]. There are a number of other proposals for adding parameterized types to the Java programming \nlanguage, all based on carrying type information at run- time [AFM97, MBL97, CS98]. Run-time types may \nbe less efficient to implement than erasure [OR98], and may be harder to interface with legacy code; \non the other hand, it is arguably more expressive to main-tain run-time type information, and more consistent \nwith the rest of the design of the Java programming language, which maintains run-time type information \nabout classes and arrays. For this reason, GJ has been designed to be compatible with an extension that \nmain-tains type information at run-time. In particular, Cartwright and Steele have developed the NextGen \ndesign in tandem with GJ [CS98]. Just as the Java programming language is a subset of GJ, so GJ is a \nsubset of NextGen. A more detailed comparison with NextGen appears in the conclusion. Virtual types have \nbeen suggested as an alternative to parametric types [Tho97, Tor98]. A comparison of the relative strengths \nof parametric and virtual types appears elsewhere [BOW98]. It may be possible to merge virtual and parametric \ntypes [BOW98, TT98], but it is not clear whether the benefits of the merger outweigh the increase in \ncomplexity. Status An implementation of GJ is freely ava.ila.ble on the web [GJ98a]. The GJ compiler \nis derived from the Pizza compiler and, like it, can also be used as a stand- alone compiler for the \nJava programming language. The compiler is about 20,000 lines of GJ. This paper concentrates on the design \nissues under- lying GJ. Companion papers provide a tutorial intro-duction [GJ98b] and a precise specification \n[GJ98c]. Outline The remainder of this paper is structured as follows. Section 2 introduces the basic \nfeatures of GJ, using a running example based on collections and linked lists. Section 3 details the \ntranslation from GJ into the Java programming language and JVM byte code. Sec-tion 4 explains why an \ninvariant subtyping rule is used for parameterized types. Section 5 describes the type inference algorithm. \nSection 6 discusses how generics relate to the Java platform s security model. Section 7 details restrictions \nimposed on the source language by the lack of run-time type information. Section 8 intro- duces raw types. \nSection 9 describes retrofitting. Sec-tion 10 shows how generics are exploited in the imple- mentation \nthe GJ compiler itself. Section 11 concludes. 2 Generics in GJ Figure 1 shows a simplified part of the \nJava collection class library expressed in GJ. There are interfaces for collections and iterators, and \na linked list class. The col- lection interface provides a method to add an element to a collection (add), \nand a method to return an iterator for the collection (iterator). In turn, the iterator inter-face provides \na method to determine if the iteration is done (hasNext), and (if it is not) a method to return the next \nelement and advance the iterator (next). The linked list class implements the collections interface. \nIt contains a nested class for list nodes (Node), and an anonymous class for the list iterator. The interfaces \nand class take a type parameter A, written in angle brackets, representing the element type. The nested \nclass Node has A as an implicit parameter inherited from the scope, the full name of the class be- ing \nLinkedListtA>.Node. The scope of a type parameter is the entire class, excluding static members and static \ninitializers. This is required since different instances of a class may have different type parameters, \nbut access the same static members. Parameters are irrelevant when using a class name to access a static \nmember, and must interface Collection<A> { public void add (A x); public IteratortA> iterator 0; 1 interface \nIterator<A> { public A next 0; public boolean hasNext (); I class NoSuchElementException extends RuntimeException \n{} class LinkedList<A> implements Collection<A> { protected class Node { A elt; Node next = null; Node \n(A elt) { thiselt = elt; } 1 protected Node head = null, tail = null; public LinkedList () {} public \nvoid add (A elt) { if (head == null) { head = new Node(elt); tail = head; } else { tail.next = new \nNode(elt); tail = tail.next; 1 1 public Iterator<A> iterator () { return new Iterator<A> () { protected \nNode ptr = head; public boolean hasNext () { return ptr != null; ) public A next () { if (ptr != null) \n{ A elt = ptr.elt; ptr = ptr.next; return elt; } else { throw new NoSuchElementException 0; 1 class \nTest { public static void main (String[ ] args) { LinkedList<String> ys = new LinkedList<String>(); \nys.add( zero ); ys.add( one ); 1 String y = ys.iterator().next(); Figure 1: Collection classes in GJ \nis a generic method, and also has a bounded type pa- interface Comparable<A> { public int compareTo (A \nthat); 1 class Byte implements Comparable<Byte> { private byte value; public Byte (byte value) { this.value \n= value; } public byte byteValue () { return value; } public int compareTo (Byte that) { return thisvalue \n-that.value; > 1 class Collections 1 public static <k implements Comparable<A>> A max (Collection<A> \nxs) { Iterator<A> xi = xs.iterator(); A w = xi.next(); whik (xLha.;Nex;[))) { if ~w.c~~~~eT~(x) < 0) \nw = x; 1 return w; Figure 2: Generic methods and bounds rameter. The method is generic because it applies \nto a variety of types. To declare a generic method, the quantified type variables are written in angle \nbrackets preceding the method signature and body. The type is automatically instantiated at point of \nuse. For instance, if ys has type Collection<Byte> we may write Byte x = Collections.max(ys); and the \nparameter A of max is inferred to be Byte. The type parameter A is bounded because it varies not over \nall types, but only over types that are com-parable to themselves. For instance, the parameter may be \ninstantiated to Byte because Byte implements Comparable<Byte>. Any type parameter (to an interface, class, \nor generic method) may be bounded. A bound is indicated by following the parameter with the keyword implements \nand an interface or extends and a class. The bound-ing interface or class may itself be parameterized, \nand may include type variables appearing elsewhere in the parameter section. Recursion or mutual recursion \nbe-tween parameters is allowed -that is, GJ supports F-bounded polymorphism [CCHOM89]. Omitting a bound \nis equivalent to using the bound Object. be omitted. In general, nested classes may have type parameters, \nand (if not static) also inherit type param- eters from any surrounding class. Angle brackets were chosen \nfor type parameters since they are familiar to C++ users, and each of the other form of brackets may \nlead to confusion. If round brack-ets are used, it is difficult to distinguish type and value parameters. \nIf square brackets are used, it is difficult to distinguish type parameters and array dimensions. If \ncurly brackets are used, it is difficult to distinguish type parameters from class bodies. Phrases like \nLinkedList<LinkedList<String>> pose a problem to the parser, since >> is treated as a single lexeme. \n(Similarly for >>>.) In C++, users are re-quired to add extra spaces to avoid this problem. In GJ, the \ngrammar has been modified so that no spaces are required. The example in Figure 2 shows another part \nof the collection class library of JDK 1.2 expressed in GJ. There is an interface Comparable<A> for objects \nthat can be compared to other objects of type A. Class Byte implements this interface with itself as \nthe type param- eter, hence, bytes can be compared with themselves. The last class in Figure 2 defines \na static method max that returns the maximum element of a non-empty collection. This method demonstrates \ntwo features: it 3 Translating GJ To translate from GJ to the Java. programming lan-guage, one replaces \neach type by its erasure. The era-sure of a parametric type is obtained by deleting the parameter (so \nLinkedList<A> erases to LinkedList), the erasure of a non-parametric type is the type itself (so String \nerases to String) and the erasure of a type param- eter is the erasure of its bound (so A in Collections.max \nerases to Comparable). Translating the GJ code for collection classes in Fig- ures 1 and 2 yields the \ncode in Figures 3 and 4. The translated code is identical to the original collection class code written \nusing the generic idiom. This prop-erty is essential -it means that a GJ program compiled against the \nparameterized collection library will run on a browser that contains the original collection library. \nThe translation of a method erases all argument types and the return type, and inserts type casts where \nrequired. A cast is inserted in a method call when the result type of the method is a type parameter, \nor in a field access when the type of the field is a type param-eter. For example, compare Test.main \nin Figure 1 with its translation in Figure 3, where a cast is inserted into the call of next. The translation \ninserts bridge methods to ensure overriding works correctly. A bridge is required when-ever a subclass \n(non-trivially) instantiates a type vari- interface Collection { public void add (Object x); public \nlterator iterator 0; 1 interface lterator { public Object next 0; public boolean hasNext (); 1 class \nNoSuchElementException extends RuntimeException {} class LinkedList implements Collection { protected \nclass Node { Object elt; Node next = null; Node (Object elt) { this.elt = elt; } 1 protected Node head \n= null, tail = null; public LinkedList () {} public void add (Object elt) { if (head == null) { head \n= new Node(elt); tail = head; } else { tail.next = new Node(elt); tail = tail.next; I 1 public lterator \niterator () {  return new lterator () { protected Node ptr = head; public boolean hasNext () { return \nptr != null; } public Object next () { if (ptr != null) { Object elt = ptr.elt; ptr = ptr.next; return \nelt; } else { throw new NoSuchElementException 0; 1 1 class Test { public static void main (String[ \n] args) { LinkedList ys = new LinkedList(); ys.add( zero ); ys.add( one ); String y = (String)ys.iterator().next(); \n 1 1 Figure 3: Translation of collection classes Here the next method of the class returns an Integer, \nto interface Comparable { public int compareTo (Object that); 1 class Byte implements Comparable { private \nbyte value; public Byte (byte value) { this.value = value; } public byte byteValue () { return value; \n} public int compareTo (Byte that) { return this.value -that.value; I public int compareTo (Object that) \n{ return this.compareTo((Byte)that); I 1 class Collections { public static Comparable max (Collection \nxs) { lterator xi = xs.iterator(); Comparable w = (Comparable)xi.next(); while (xi.hasNext()) { Comparable \nx = (Comparable)xi.next(); if (w.compareTo(x) < 0) w = x; 1 return w; 1 1 Figure 4: Translation of generic \nmethods and bounds able in a superclass. For example, erasure of compareTo in Comparable yields a method \nthat takes an Object, while erasure of compareTo in Byte yields a method that takes a Byte. Since overriding \noccurs only when method signatures match exactly, a bridge method for compareTo is introduced into the \ntranslation of Byte that takes an Object and casts it to a Byte. Overloading allows the bridge and the \noriginal method to share the same name. Again, the translat)ion from GJ yields code identi- cal to the \noriginal collection class library in JDK 1.2, including the bridge methods. 3.1 A bridge too far A problematic \ncase of bridging may arise if a type pa-rameter appears in the result but not the arguments of an overridden \nmethod. Here is a class that implements the lterator interface in Figure 1. class Interval implements \nIterator<lnteger> { private int i, n; public Interval (int I, int u) { i = I; n = u; } public boolean \nhasNext () { return (i <= n); } public Integer next () ( return new Integer(i++); } I match the instantiation \nof the type parameter. The translation yields the following. As one would expect, a bridge must be added \nto the Interval class. interface lterator { public boolean hasNext (); public Object next 0; 1 class \nInterval implements lterator { private int i, n; public Interval (int I, int u) { i = I; n = u; } public \nboolean hasNext () { return (i <= n); } public Integer next/*l*/ () { return new Integer(i++); 1 // bridge \n public Object next/*2*/ () { return next/*l*/(); 1 > Unfortunately, this is not legal Java source code, \nas the two versions of next cannot be distinguished because they have identical arguments. The code above \ndistin- guishes our intention by suffixing the declarations and calls with /*lr/ and /*2*/ as appropriate. \nFortunately, the two versions of next can be distin- guished in the JVM, which identifies methods using \na signature that includes the result type. This situation represents the one place where GJ must be defined \nby translation directly into JVM byte code. GJ also permits covariant overriding: an overriding method \nmay have a result type that is a subtype of the method it overrides (whereas it must match exactly in \nthe unextended Java programming language). Here is an example. class C implements Cloneable { public \nC copy () { return (C)this.clone(); } > class D extends C implements Cloneable { public D copy () { return \n(D)this.clone(); } > Translation introduces a bridge method into the second class. class D extends C \nimplements Cloneable { public D copy/*l*/ () { return (D)this.clone(); } // bridge public C copy/*2r/ \n() { return this.copy/*l*/(); } 1 This is implemented using the same technique as above. 4 Subtyping \nFor purposes of type comparison, subtyping is invari- ant for parameterized types. For instance, even \nthough the class String is a subtype of Object, the param-eterized type LinkedList<String> is not a subtype \nof LinkedList<Object>. In comparison, arrays use covari- ant subtyping, so the array type String[ ] is \na subtype of Object[ 1. Invariant subtyping ensures that the type constraints enforced by GJ are not \nviolated. Consider the following code. class Loophole { public static String loophole (Byte y) { LinkedList<String> \nxs = new LinkedList<String>(); LinkedList<Object> ys = xs; // compile-time error y-add(y); return xs.iterator().next(); \n This code is illegal, because otherwise it would violate the type constraints by returning a byte when \na string is expected. Both the method call (which adds a byte, which is itself an object, to a list of \nobjects) and the return (which extracts a string from a list of strings) are unobjectionable, so it must \nbe the assignment (which aliases a list of string to a list of objects) that is at fault. It is instructive \nto compare the above to analogous code for arrays. class Loophole { public static String loophole (Byte \ny) { String[ ] xs = new String[l]; Object[ ] ys = xs; ys[O] = y; // run-time error return xs[O]; 1 1 \n Now the code is legal, but raises an array store excep- tion. Observe that the type safety of covariant \nsubtyp-ing depends upon the fact that an array carries its type at run-time, making the store check possible. \nThis ap-proach is not viable for parameterized types, since type parameters are not available at run-time. \nIt should be noted that explicitly declared subtyp-ing is not a problem. For instance, it is fine to \npass a LinkedList<String> when a Collection<String> is ex-pected. 5 Type Parameter Inference GJ includes \na novel type parameter inference algorithm that permits one to elide type parameters to polymor- phic \nmethod calls. Such type parameters can safely be omitted since they are erased by the translation anyway, \nand therefore cannot carry any operational meaning. class ListFactory { public <A> LinkedList<A> empty \n() { return new LinkedList<A>(); 1 public <A> LinkedList<A> singleton (A x) { LinkedList<A> xs = new \nLinkedList<A>(); xs.add(x); return xs; I public <A> LinkedList<A> doublet (A x, A y) { LinkedList<A> \nxs = new LinkedList<A>() ; xs.add(x); xs.add(y); return xs; class Test { static ListFactory f = new ListFactory(); \npublic static void main (String[ ] args) { LinkedList<Number> zs = f.doublet(new Integer(l), new Float(l.0)); \nLinkedList<String> ys = f.singleton(null); LinkedList<Byte> xs = f.empty(); LinkedList<Object> err = \nf.doublet( abc , new Integer( 1)); // compile-time error , ) 1 Figure 5: Example of inference Type \nparameters are inferred for a parametric method call by choosing the smallest type parameter that yields \na valid call. As an example, consider the the code in Figure 5, which defines factory methods for lists \nwith zero, one, and two elements. In the example above, the call to doublet with an integer and a float \nas arguments infers that the type parameter A is Number. If there is no unique smallest type, inference \nfails, as in the call to doublet with a string and an integer (which have both Comparable and Serializable \nas common supertypes). This rule needs to be generalized to the cases where there are no argument types \ninvolving an inferred vari-able or where some argument is null. To support in-ference in these cases, \nthe type inferencer may bind a type variable to the special bottom type *, the type of null. The type \n* is a subtype of every reference type. This type is used only by the type inference algorithm, and cannot \nappear in type declarations in GJ programs. Further, any type containing * is regarded as a subtype of \nany type that results from replacing * with any other reference type. (This is the one exception to the \nrule of invariant subtyping.) Thus, LinkedList<*> is a subtype class Cell<A> { public A value; public \nCell (A v) { value = v; } public static <A> Cell<A> make (A x) { return new Cell(x); 1 1 class PairtB,C> \n{ public B fst; public C snd; public Pair (B x, C y) { fst = x; snd = y; } public static <D> PairtD,D> \nduplicate (D X) { return new Pair<D,D>(x,x); I 1 class Loophole { public static String loophole (Byte \ny) { Pair<Cell<String>,Cell<Byte>> p = Pair.duplicate(Cell.make(null)); // compile-time error p.snd.value \n= y; return p.fst.value; 1 public static String permitted (String x) { Pair<Cell<String>,Cell<String>> \np = Pair.duplicate(Cell.make((String)null)); p.fst.value = x; return p.snd.value; 1 > Figure 6: Illegal \nsituation for inference. of LinkedList<String>, and Pair<Byte,*> is a subtype of Pair<Byte,Byte>. For \ninstance, in the second and third calls of method main above, the type parameter is inferred to be *. \nThe assignments are valid since LinkedList<*> is a subtype of both LinkedList<Byte> and LinkedList<String>. \nAn additional linearity restriction is required: a type parameter cannot be instantiated to * if it appears \nmore than once in the result type. To see why this is neces- sary, consider the code in Figure 6. The \ncall to duplicate in loophole is illegal, because the smallest choice for D is *, but D appears twice \nin the result type of duplicate. On the other hand, the call to duplicate in permitted is ok, because \nthe cast ensures the smallest choice for D is String. But without the cast, the smallest choice is * \nand the call would be illegal. Without the restriction, loophole would circumvent the type system, making \nit possible to treat a string as a byte. General covariance may lead to an unsound type sys- tem, so \nwe have to argue carefully that our type system with its restricted form of covariance remains sound. \nThe argument goes as follows: since one cannot declare interface I {} interface J {} interface K extends \nI {} interface L extends I, J {} class X { static <A> A choose(A x, A y) ( return (x.hash() < y.hash())?x:y; \nI static void test (K k, L I) { I i = choose(k, I); // ok I 1 Figure 7: Near-ambiguous situation for \ninference variables of type T<...r...>, all one can do with a value of that type is assign or pass it \nonce to a variable or parameter of some other type. There are now three possibilities, depending on the \nvariable s type: l The variable s type is an unparameterized super-type of T. In this case the assignment \nis clearly sound. l The variable s type is T<...U...> with some refer- ence type U in the position of \n*. Now, the only value that populates type * is null, which is also a value of every reference type U. \nFurthermore, any method in type T<...*...> with an argument V<...*...> that contains the bottom type \nwould have to be parametric in this type, so that it could equally well be applied to V<...U...>. Hence, \nany value of type T<...*...> will also be a value of type T<. ..U . ..>. and the assignment is sound. \nl The variable s type is a type variable, A. Then code that accesses the variable works for any type \nA may be instantiated to, so the code itself cannot give rise to type errors. Furthermore, if the vari-able \nappears in a method, by the linearity restric-tion, the method s formal result type will contain at most \none occurrence of A, so the actual type of the method application is again of the form T <...*...>. Our \ntype parameter inference scheme is similar to Pierce and Turner s local type inference [PT98]. Pierce \nand Turner only consider covariant type constructors, which is a sensible assumption for the predominantly \nfunctional languages they are dealing with. For GJ, with its exclusive use of invariant type constructors, \nour special treatment of * is essential to make type infer-ence work. Experience has so far shown that \nit works very well indeed. For instance, in the whole GJ com-piler (consisting of about 20,000 lines \nof heavily generic code), there was not a single instance where type infer- ence had to be helped by \nan explicit parameterization or type cast. It is instructive to compare GJ s local type infer-ence with \nthe constraint-based inference of the Hindley- Milner system [Mi178] or its extensions to subtyping [AW93, \nEST95]. I n essence, a type T<...*...> in our system would correspond to a type T<...A...> in the Hindley-Milner \nsystem, where A is a fresh type variable that is used nowhere else. If a type had more than one occurrence \nof *, each occurrence would be replaced by a different type variable. Then our use of subtyping for types \ncontaining * corresponds to instantiations of type variables in the Hindley-Milner system. The linearity \ncondition makes sure that * types are not duplicated when types for method calls are inferred, so that \neach * type can be mapped back to a fresh type variable in the method s result type. Finally, the restriction \nthat * types cannot be declared by the user roughly cor-responds to the variable polymorphism restriction \nfor Hindley-Milner [Wri95], which ensures that values con- taining mutable references cannot be polymorphic. \n Note that any inference algorithm is subject to prob- lems with ambiguity. Consider the code in Figure \n7. Here the type inferencer can determine that the formal parameter A corresponds to the actual parameter \nI in the call of choose in the marked line. However, say that the definition of K is later changed, so \nthat K also extends J. interface K extends I, J {} Now the call to choose becomes ambiguous. Thus even \nthough the programmer has taken care to preserve the supertypes and structure of interface K, code using \nit breaks due to the change. This is an undesirable prop-erty from a software engineering perspective. \nHowever, the Java programming language already suffers from a similar problem with regard to overloading, \nso adding type inference does not introduce any new holes. We believe the convenience of inference outweighs \nthis at-tendant infelicity. Security Implications Since the homogeneous translation erases type informa- \ntion, it opens a potential security hole at run-time. The hole can be filled, but to do that one needs \nto be aware of it. Consider the following example, which is due to Agesen, Freund, and Mitchell [AFM97]: \nclass SecureChannel extends Channel { public String read 0; 1 class C { public LinkedList<SecureChannel> \ncs; . . . 1 Since LinkedList<SecureChannel> gets erased to just LinkedList, it is possible for an attacker \nto add a non- secure channel to the list, which might be used as a way to leak information from a secure \nsystem. If the attacker was itself written in GJ, this would be prevented by the generic type system. \nBut the attacker could be written not in GJ but in the Java programming language or the JVM byte code \nlanguage, in which case neither the compiler nor the run-time system would detect a type system violation. \nTo address this problem, a programmer needs to pre- vent the information about the type parameter from \nbe- ing lost by erasure. If the class in questions does not export any parameterized fields this can \nbe achieved by declaring a specialized type SecureChannelList, which extends type LinkedList<SecureChannel>. \nThe special-ization inherits all fields and methods from its super-type, and its constructor simply forwards \nto the analo- gous constructor in the supertype: class SecureChannelList extends LinkedList<SecureChannel> \n{ SecureChannelList () { super(); } 1 class C { SecureChannelList cs; . . . I Unlike LinkedList<SecureChannel>, \nSecureChannelList gets translated to itself, so no type information is lost. Furthermore, GJ s translation \nscheme for bridge meth-ods ensures that argument types are properly checked at run-time. Here is the \ntranslation of class SecureChan-nellist: class SecureChannelList extends LinkedList { SecureChannelList \n() { super(); } public void add (Object x) { super.add((SecureChannel)x); 1 I  Note the inserted bridge \nmethod for LinkedList.add which checks at run-time that the passed channel is secure. The same scheme \ncannot be applied to pub-lic fields of parameterized types, since access to those fields is not encapsulated \nby bridge methods. Type specialization is a general method for main-taining type parameter information \nwhich would other-wise be lost by erasure. Since the heterogeneous trans-lation effectively applies type \nspecialization everywhere, public static Object[ ] newlnstance (Object[ ] a, int n) { return Array.newlnstance(a.getClass().getComponentType(), \nn); 1 Figure 8: Creating a new instance of an array it looks like a better fit from a security perspective. \nThis is also argued by Agesen et al. [AFM97]. Perhaps surprisingly, the heterogeneous translation nevertheless \nfits poorly with the security model of the Java virtual machine. The problem, first reported in [OR98], \nlies in the package based visibility model for types, which can interfere with automatic type special- \nization. The JVM security model supports only two kinds of visibility for top-level classes: package-wide \nand pub- lic visibility. It is not possible to refer to a class out- side a package unless the class \nis declared public. The JVM specification [LY96] requires the virtual machine to throw an IllegalAccessError \nif a class refers to any class that is in another package and is not public. Sometimes these rules make \nit impossible to find a package where a heterogeneous type instantiation can be placed. Consider an instantiation \np.C<q.D> of a pa- rameterized class C defined in package p, applied to a parameter class D defined in \na different package q. There are two possibilities: either class D must be pub- lic (in which case we \ncan place the instantiation in pack- age p), or else the body of class C must refer only to public classes \n(in which case we can place the instantia- tion in package q). If neither of these cases apply (that \nis, D is private in its package and C refers to private classes in its package), then there is no package \nin which one can place the instantiation p.C<q.D>, hence the het- erogeneous translation must fail. An \nillegal access error would be raised no matter in which package p.C<q.D> is placed. Since class accesses \nare checked when identifiers are resolved at run-time, the error would occur irrespec-tive of whether \nclasses are specialized at compile-time or run-time. This problem makes it difficult to use packages \nef- fectively in the presence of the heterogenous transla-tion. Further, even if one could change the \nJVM se-curity model, it is not clear what change could fix this problem. The problem does not arise for \nthe homoge- nous translation. 7 Restrictions GJ s translation by type erasure requires some language \nrestrictions which would not be necessary if a transla- tion maintained types at run-time. The restrictions \naf-fect object and array creation, and casts and instance tests. 7.1 Object and array creation A new \nexpression where the type is a type variable is illegal. Thus, new A() is illegal, when A is a type variable. \nSuch expressions cannot be executed because type parameters are not available at run-time. This is no \ngreat loss, since such generic creation is of limited value. Rather than create an object of variable \ntype, one should pass in an object with a suitable method for creating new objects (commonly called a \nfactory ob-ject). A new expression where the type is an array over a type variable generates an unchecked \nwarning. Thus, new A[n] is unchecked when A is a type variable. Such expressions cannot be executed with \nthe usual seman-tics, since type parameters are not available at run-time. Rather than create arrays \nof variable type, it is rec-ommended that one should use the Vector or ArrayList classes from the collection \nlibrary, or pass in an array of the same type to be used as a model at run-time (a poor man s factory \nobject). To facilitate the latter, the following method is pro- vided by the java.lang.reflect.Array \nclass in GJ. public static <A> A[ ] newlnstance (A[ ] a, int n) A call returns a new array with the same \nrun-time type as a, with length n and each location initialized to null. This method allows an array \nto act as a factory for more arrays of the same type. The erasure of the above method can be implemented \nin terms of existing reflec-tion primitives as follows as shown in Figure 8. But the types in the figure \nare not parametric, so the typed ver-sion is added to the GJ library. It can be implemented using the \nretrofitting feature discussed in Section 9. For some purposes, such as defining Vector itself, it is \nnecessary to create new arrays of variable type. This is why such expressions are unchecked rather than \nillegal. In this case the translation replaces the type variable by its bound, as usual. Thus, new A[n] \ntranslates to new Object[n], when A is a type variable bounded by Object. Creating a new array of variable \ntype must generate an unchecked warning to indicate that the type sound-ness constraints normally enforced \nby GJ may be vio- lated. Consider the following code. class BadArray { public static <A> A[ ] singleton \n(A x) { return new A[ ]{ x }; // unchecked warning 1 public static void main (String[ ] args) { String[ \n] a = singleton( zer0 ); // run-time exception ) >  This code passes the compiler, but an unchecked \nwarn-ing is issued for the expression new A[ ]{ x }. In this case, the creation expression does indeed \nviolate GJ s t,ype constraints, as when called with A bound to String it creates an array with run-time \ntype Object[ ] rather than String[ 1. Here is the translation of the above code. class BadArray { public \nstatic Object[ ] singleton (Object x) { return new Object[ ]{ x }; 1 public static void main (String[ \n] args) { String[ ] a = (String[ ])singleton( zero ); // run-time exception > 1  It is important to \nrecognize that the run-time type sys- tem of the JVM remains secure, as the last line in the translated \ncode fails at run-time. It is always safe to create a new array of variable type if one takes care to \nensure the array does not escape the scope of the type variable. The method above is unsafe because the \nnew array escapes the scope of the type variable A attached to the singleton method. As an example of \nsensible use of arrays, consider the vector class given in Figure 9 (simplified from the collection library). \nThe array a of type A[ ] always has run-time type Object[ 1, but never leaves the scope of the class. \nThe method asArray returns an array that leaves the scope of the class, but this array is either the \nargument array b (if b is large enough) or is an array with the same run- time type as b (created by \nnewlnstance). As usual, the code is translated by replacing A everywhere by Object, including replacing \nA[ ] by Object[ 1. 7.2 Casts and instance tests Since type parameters are not available at run-time, \nnot all casts and instance tests on parameterized types are permitted. It is legal to include parameters \nin a cast or instance test if the parameters are determined by a class Vector<A> { public final int MIN-CAPACITY \n= 4; protected int n; protected A[ ] a; public Vector () { n = 0; a = new A[MIN-CAPACITY]; > public void \nadd (A x) { if (n == a.length) { A[ ] b = new A[2*n]; :;(tt i = 0; i < n; i++) b[i] = a[;]; 1 a[n++] \n= x; 1 public A get (int i) { if (0 <= i &#38;&#38; i < n) return a[i]; else throw new lndexOutOfBoundsException(); \n1 public void set (int i, A x) { if (0 <= i &#38;&#38; i < n) a[i] = x; else throw new lndexOutOfBoundsException(); \n1 public int size () { return n; } public A[ ] asArray (A[ ] b) { if (b.length < n) b = Array.newlnstance(b,n); \nfor (int i = 0; i < n; i++) b[i] = a[;]; for (int i = n; i < b.length; i++) b[i] = null; return b; Figure \n9: Vector class combination of information known at compile-time and determinable at run-time. class \nConvert { public static <A> Collection<A> up (LinkedList<A> xs) { return (Collection<A>)xs; 1 public \nstatic <A> LinkedList<A> down (Collection<A> xs) { if (xs instanceof LinkedList<A>) return (LinkedList<A>)xs; \nelse throw new ConvertException(); 1 1 In method up, the cast could be omitted, but is included for clarity. \nIn method down, run-time information can be used to check whether the collection is a linked list; if \nit is a linked list, then the compile-time constraints ensure that the type parameters match. Parameterized \ntypes cannot be used in casts or in- stance tests when there is no way to verify the param- eter. The \nfollowing is illegal. class BadConvert { public static Object up (LinkedList<String> xs) { return (0bject)xs; \n > public static LinkedList<String> down (Object o) { if (o instanceof LinkedList<String>) // compile-time \nerror return (LinkedList<String>)o; // compile-time error else throw new ConvertException(); I > Here \nthe marked lines indicate compile-time errors. There are two possible workarounds for this problem. One \nis to use type specialization, as in Section 6, creat- ing a new class that extends LinkedList<String>. \nclass LinkedListString extends LinkedListcStringb { . ..} The other is to create a wrapper class, with \na field of type LinkedList<String>. class LinkedListStringWrapper { LinkedList<String> contents; 1 In \neither case, the resulting class has no type parame-ters, and may always be used as the target of a cast. \n8 Raw types It is occasionally necessary to refer to a parameterized type stripped of its parameters, \nwhich we call a raw type. Raw types maintain consistency with legacy code: for instance, new code may \nrefer to the parameterized type Collection<A> while legacy code will refer to the raw type Collection. \nRaw types are also useful in cast and instance tests, where there may not be adequate information at \nrun-time to check the full parameterized type. Figure 10 defines an extension to the linked list class \nof Section 2 to define equality. One might expect the object passed to equals to have the type LinkedList<A>, \nbut a cast to that type cannot be checked, since type parameters are not available at run-time. However, \nit is possible to check a cast, to the raw type LinkedList. Roughly speaking, the raw type LinkedList \ncorresponds to the type LinkedList<B> for some indeterminate value of B. In this way, it resembles the \nexistential types used in Pizza. But while Pizza s existential types are useful for writing methods such \nas equality, they are no help at all for interfacing with legacy code, which raw types do with ease. \nclass LinkedList<A> implements Collection<A> { . . . public boolean equals (Object that) { if (!that \ninstanceof LinkedList) return false; Iterator<A> xi = this.iterator(); lterator yi = ((LinkedList)that).iterator(); \nwhile (xi.hasNext() &#38;&#38; yi.hasNext()) { A x = xi.next(); Object y = yi.next(); if (!(x == null \n? y == null : x.equals(y))) return false; > return !xi.hasNext() &#38;&#38; !yi.hasNext(); I I Figure \n10: Equality using raw types In the above, the method call iterator() with receiver this of type List<A> \nreturns a value of type Iterator<A>, while the same method with receiver (List)that of raw type List \nreturns a value of raw type Iterator. Simi-larly, the method call next0 with receiver xi of type Iterator<A> \nreturns a value of type A, while the same method with receiver yi of type lterator returns a value of \ntype Object. In general, the signature of a member of an object of raw type is the erasure of the signature \nof the same member for an object of parameterized type. Further, a value of parameterized type is assignable \nto a variable of the corresponding raw type. A value of raw type may also be assigned to a variable of \nany corresponding parameterized type, but such an assignment generates an unchecked warning. Some method \ncalls to objects of raw type must also generate unchecked warnings, to indicate that the type soundness \nconstraints normally enforced by GJ may be violated. Consider the following code. class Loophole { public \nstatic String loophole (Byte y) { LinkedList<String> xs = new LinkedList<String>(); LinkedList ys = xs; \nys.add(y); // unchecked warning return xs.iterator().next(); 1 >  This code passes the compiler, but \nan unchecked warn-ing is issued for the call to the add method. In this case, the call does indeed violate \nGJ s type constraints, as it adds a byte y to the list of strings xs. Here is the translation of the \nabove code. class Loophole { public static String loophole (Byte y) { LinkedList xs = new LinkedList(); \nLinkedList ys = xs; ys.add(y); return (String)xs.iterator().next(); // run-time exception 1 I The run-time \ntype system of the JVM remains secure, as the last line in the translated code fails at run-time. The \nrules for generating unchecked warnings for raw types are: l A method call to a raw type generates an \nunchecked warning if the erasure changes the ar-gument types. l A field assignment to a raw type generates \nan unchecked warning if erasure changes the field type. No unchecked warning is required for a method \ncall when only the result type changes, for reading from a field, or for a constructor call on a raw \ntype. For ex-ample, in the equality test for linked lists given above, none of the raw method calls is \nunchecked, since they all have empty argument lists, so erasure leaves the type unchanged. But in the \nloophole method, the call to add is unchecked, since erasure changes the argument type from A to Object. \nThe unchecked method calls and field accesses may be needed to interface with legacy code, which is why \nthey are not illegal. For example, one could com-pile the GJ versions of Collection<A>, Interface<A>, \nLinkedList<A> and Comparator<A> with the unparam-eterized version of Collections. The test code will \ncom-pile, but generate a unchecked warning for the method calls to compare or compareTo, though in this \ncase the calls happen to be sound. The rule used by GJ to generate unchecked warnings is conservative. \nIn practice, when interfacing legacy code to new GJ code, ma.ny calls may be labelled as unchecked that \nare nevertheless sound. Proliferation of unchecked warnings can be avoided by updating the legacy code, \nor by using the retrofitting technique dis-cussed in the next section. 9 Retrofitting To support independent \ncompilation, the GJ compiler must store extra type information at compile-time. For-tunately, the JVM \nclass file format supports adding ex-tra attributes. Information about parameterized types is stored \nin a Signature attribute, which is read and writ,ten by the GJ compiler, but ignored by the JVM at load-time. \nGJ is designed so that new code will run with old libraries. For instance, new code may refer to a param- \neterized linked list type, but run with old code (source or binary) that implements an unpararneterized \nlinked list type using the generic idiom. To make this work smoothly, the GJ compiler has a retrofitting \nmode that can be used to add Signature attributes to existing code. I ype inforrnation is speci- fied \nin a source file that contains only type information for fields and methods. A simple way to do this \nis to create a dummy that generates the correct type infor-mation but, has trivial code. For instance, \nsay one has a. class file for the unparameterized version of LinkedList, but one wishes to use it as \nif it has paramet,erized t,ypes. This can be done using the following retrofitting file. class LinkedList<A> \nimplements Collection<A> { public LinkedList (){}; public void add (A elt){}; public Iterator<A> iterator \n() { return null;}; > The GJ compiler takes the above file as source, and looks up the unparameterized \nclass file along a speci- fied classpath (currently, given as an argument t(o the -retro flag). It then \noutputs the new class file, includ-ing an appropriate Signature at.tribute, in a directory specified \nby the user. At compile-time, the classpath must specify the retrofitt#ed class file. At run-time, the \nclasspath may specify either the ret,rofitted or the legacy class file. In particular, new code can compile \nagainst the retrofitted linked list class file, then run in a browser containing the legacy linked list, \nlibrary. The entire collection class library available in JDK 1.2 has been retrofitfted in this way. \nAbsolutely all of the public methods in the JDK 1.2 collection classes -without a single exception -can \nbe given sensible parameterized type signatures in GJ. Only type signa- tures needed to be rewritten, \nthe legacy code did not even need to be recompiled. Since signatures are more than an order of magnitude \nmore compact than code, this saves considerable effort. In most cases, one would anticipate eventually \nrewriting the source library with parameterized types. The advantage of the compatibility offered by \nGJ is that, one may schedule this rewriting at a convenient time -~ it is not necessary to rewrit,e all \nlegacy code before new code can exploit parametric t,ypes. We anticipate that most rewriting of code \nwill be straightforward, consisting of adding type parameters and replacing some occurrences of Object \nby suitable type variables. However, not all code may be so easy to upgrade. For instance, in the collection \nclass library the imple- ment,ation of finite maps includes code that may return either the key or value \nof a map entry. This is well- typed using the generic idiom with class Map, because both the key and \nvalue have type Object. But it is not well-typed using parameterized types with the class Map<K,V>, where \nthe key has type K and the value has type V. So this portion of the code must be restruc- tured to update \nthe source to GJ, providing separate code to process keys and values. This need to restruc- ture a (usually \nsmall) portion of the code shows why the flexibility of interfacing with legacy code offered by GJ is \nso helpful. Implementatiori GJ has been implemented and is publicly available from a number of web sites \n[GJ98a]. The GJ compiler is origi- nally derived from the Pizza compiler, but has been sub- stantially \nredesigned. It is itself written in GJ. Generic types and methods were essential in its implementation. \nFor instance, the compiler makes heavy use of generic container types, such as linked lists, dictionaries, \nand iterators. Besides these uses, the compiler also relies on generic methods for its central tree traversal \nroutines, which are implemented using the visitor pattern [GHJV94]. The Pizza and GJ compilers are both \nstructured as a series of passes over an abst,ract syntax tree. The Pizza com-piler made extensive use \nof algebraic data types and pattern matching, which are supported in Pizza but not in the Java programming \nlanguage. The syntax tree in the Pizza compiler is represented as an algebraic data type with a ca.se \nfor each of Pizza s syntactic con-structs. Each pass consists of a recursive method with a case statement \nthat pat tern matches against all relevant, cases in the tree type. It is thus possible to decouple the \ntraversal algorithms from the tree definition itself. This makes sense since we would expect the language \nproces- sors (implemented by traversal passes) to change more frequently than the language they process \n(represented by the tree itself). In GJ, algebraic types and pattern matching are not available. Instead, \nthe visitor pattern is applied to achieve an analogous program decomposition. Fig-ure 11 gives an overview. \nThere is an abstract class Tree with subclasses for each of GJ s syntactic constructs. In total, there \nare 38 such subclasses, although only one is shown. The base class a.nd each subclass define a method \nvisit, which takes a visitor object and applies a method in the visitor which corresponds to the sub- \nclass being defined. All such visitor methods use the overloaded uame -case; they are distinguished by \nthe subclass of Tree which they take as first argument. The abstract visitor class contains a -case method \nfor each of the tree subclasses. Concrete subclasses override those -case methods that can possibly be \nencountered during traversal. To make this standard idiom widely applicable, the visitor class is generic, \nwith two type parameters. The R parameter stands for the result lype of the -case meth- ods in a concrete \nvisitor. The A parameter stands for the type of an additional argument which those methods take. For \ninstance, Figure 11 shows a fragment of the tree attribution visitor. Each -case method in that visi-tor \ntakes an environment (of type Env<AttrContext>) as additional parameter and each method returns a type \n(of type Type). 0th er visitor passes in the compiler would use different argument and result types. \nMissing result types or argument types get instantiated to class Void. Multiple results or arguments \nare expressed using tuple types such as Pair. Since visit in class Tree needs to be able to apply dif-ferent \nparameterized instantiations of the visitor class, it needs to be polymorphic itself. Consequently, its \ntype in Tree is: <R,A> R visit (Visitor<R,A> v, A arg) With this technique, the application of the visitor \npat-tern in the compiler is quite natural. If one tried instead to apply the pattern in this form in \na language without generics using the generic idiom, the abundance of re- quired t,ype casts would make \nthe concept considerably harder to use. It is also worth noting that the use of polymorphic methods was \nessentia,l to achieve a generic typing of visitors; parameterized types alone are not enough. 11 Conclusions \nWe have presented GJ, an extension of the Java pro- gramming language with generic types and methods. \nGJ is implemented by translating back to the unex-tended language, repeating t,he idiom used by program- \nmers to simulate generics. For this reason, it, is easy to interface GJ with legacy code, and it is straightforward \nto use reflection on GJ programs. The design of Pizza is strongly constrained by the criterion of backward \ncompatibility with the Java pro- gramming language. The design of GJ is further con-strained by the criterion \nof smooth interfacing with legacy code, and of forward compatibility with a lan- guage design (such as \nNextGen [CS98]) that maintains information about type parameters at run-time. (In-deed, one referee characterized \nthis paper as polymor- phism with one hand tied behind your back .) Remark-ably, even though the constraints \non GJ are tighter than those on Pizza, it s design is arguably simpler. GJ s in- ference algorithm is \nsimpler than Pizza s, and GJ s use abstract class Tree { public <R,A> R visit (Visitor<R,A> v, A arg) \n{ return v.-case(this, arg); 1 static class Return extends Tree { public Tree expr; public Return(Tree \nexpr) { this.expr = expr; } public <R,A> R visit (Visitor<R,A> v, A arg) { return v.-case(this: arg); \n1 > static abstract class Visitor<R,A> { public R -case(Tree that, A arg) 1 throw new InternalError( \nunexpected: + that); 1 public R -case(Return that, A arg) { return -case((Tree)that, arg); 1 public \nR -case(Throw that, A arg) { return -case((Tree)that, arg); 1 // other cases . . . 1 1 public class \nAttr extends Tree.Visitor<Type,Env<AttrContext>> { . . . public Type -case( Return tree, Env<AttrContext> \nenv) { Type owntype; // code for attribution of return statements . . . return owntype; 1 // other attribution \ncases . . . > Figure 11: Visitors in the GJ compiler of raw types is simpler and more powerful than \nPizza s use of existential types. There are two main alternatives t,o the design pur- sued in GJ. The \nfirst is to use the heterogenous translation. As we saw in Section 6, this alternative either makes \nit difficult to use packages effectively, or requires change to the security model of the JVM. The second \nis to pass type information at run-time, as explored in the NextGen design of Cartwright and Steele \n[CS98]. GJ s forward compatibility makes it pos- sible to arrange for NextGen to be a superset of GJ: \nevery legal GJ program is also a legal NextGen pro- gram with an identical meaning. (The one exception \nis that NextGen, unlike GJ, changes some properties of a program under reflection.) Both GJ and NextGen \nhave advantages. NextGen is more expressive than GJ, in that none of the restrictions discussed in Section \n7 need be imposed on NextGen. In particular, NextGen can implement new A[n] by al- locating a new array \nwith the correct run-time type information, avoiding the severe restrictions placed on this construct \nin GJ. And NextGen can implement an instance test or cast to a parameterized type such as LinkedList<String> \nwithout the workarounds required by GJ. Arguably, the use of run-time types in NextGen is a better fit \nwith the Java programming language, which maintains run-time type information about the class of an object \nand the type of elements in an array. On the other hand, GJ has a considerably simpler design that NextGen. \nAnd since GJ maintains no type information at run-time, it may be more efficient than NextGen, although \nmeasurement is required to deter-mine if this difference is significant. More importantly, GJ achieves \ngreater compatibility than NextGen with legacy code. Not only is GJ back- ward compatible with the Java \nprogramming language and forward compatible with NextGen, but GJ also has backward and forward compatibility \nwith legacy code. It has backward compatibility, in that legacy code us-ing the generic idiom may call \nnew parameterized li-braries, and in that newly created objects of parame- terized type may be passed \nto legacy code that uses the generic idiom. And it has forward compatibility, in that new parameterized \ncode may call legacy libraries that use the generic idiom, and in that objects created by legacy code \nusing the generic idiom may be passed to new code that expects objects of parameterized type. Roughly \nspeaking, GJ achieves backward compatibility through raw types, and forward compatibility through retrofitting. \nIn contrast, NextGen has only backward compati-bility. New code cannot use legacy libraries, and ob-jects \ncreated by legacy code can be passed to new code only via adaptor methods that convert legacy objects \n(with no run-time type information) into NextGen ob-jects (with run-time type information specified for \neach type parameter). The combination of forward and back- ward compatibility in GJ makes it considerably \neasier to manage the process of upgrading from legacy to pa- rameterized code, and we believe that this \nis the chief advantage of GJ over NextGen. Acknowledgements Thanks to Enno Runne and Matthias Zenger, \nfor their input on implementation and security aspects, and to Joshua Bloch, Corky Cartwright, and Guy \nSteele, for their support and many productive discussions. Thanks also to the members of the Java-genericity \nand Pizza- users mailing lists, for valuable criticism and continued feedback. Finally, thanks to the \nanonymous referees for their cogent comments. References [AFM97] Ole Agesen, Stephen Freund, and John \nC. Mitchell. Adding parameterized types to Java. Confer-ence on Object-Oriented Programming, Systems, \nLan-guages and Applications, pages 215-230, 1997. [AW93] Alexander Aiken and Edward L. Wimmers. Type \ninclusion constraints and type inference. Functional Programming Languages and Computer Architecture, \npages 31-41, ACM, 1993. [BG93] Gilad Bracha and David Griswold. Strongtalk: Typechecking Smalltalk in \na production environment. In Conference on Object-Oriented Programming, Sys-tems, Languages and Applications, \npages 215-230, 1993. [BOW981 Kim B. Bruce, Martin Odersky, and Philip Wadler. A statically safe alternative \nto virtual types. European Conference on Object-Oriented Program-ming, July 1998. (An earlier version \nwas presented at 5th Workshop on Foundations of Object-Oriented Languages, January 1998.) [CCHOM89] Peter \nCanning, William Cook, Walter Hill, Walter Olthoff, and John C. Mitchell. F-bounded polymorphism for \nobject-oriented program-ming. Functional Programming Languages and Com-puter Architecture, pages 273-280, \nACM, 1989. [CS98] Corky Cartwright and Guy Steele. Compatible genericity with run-time types for the \nJava pro-gramming language. Conference on Object-Oriented Programming, Systems, Languages and Applications, \n1998. [EST951 Jonathan Eifrig, Scott Smith, and Valery Trifonov. Sound polymorphic type inference for \nobjects. Conjer-ence on Object-Oriented Programming, Systems, Lan-guages and Applications, pages 169-184, \n1995. [GHJV94] Erich Gamma, Richard Helm, Ralph Johnson and John Vlissides. Design Patterns : Elements \nof Reusable Object-Oriented Software. Addison-Wesley, 1994. [GR83] A. Goldberg and D. Robson. Smalltalk-80: \nthe Lan- guage and Its Implementation. Addison-Wesley, 1983. [GJ98a] Martin Odersky. The www.cis.unisa.edu.au/-pizza/gj \nwwwipd.ira.uka.de/ pizza/gj www.math.luc.edu/pizza/gj GJ compiler. Available from www.cs.bell-labs.com/ \nwadler/pizza/gj [GJ98b] Gilad Bracha, Martin Odersky, David Stoutamire, and Philip Wadler. GJ: the Java \nprogramming lan-guage with type parameters. Manuscript, 1998. Avail- able at the GJ web site. [GJ98c] \nGilad Bracha, Martin Odersky, David Stoutamire, and Philip Wadler. GJ Specification. Manuscript, 1998. \nAvailable at the GJ web site. [GLS96] James Gosling, Bill Joy, and Guy Steele. The Java language specification. \nJava Series, Sun Microsystems, ISBN O-201-63451-1, 1996. [LY96] Tim Lindholm and Frank Yellin. The Java \nVirtual Machine specification. Java Series, Sun Microsystems, ISBN 0-201-63452-X, 1996. [Mi178] Robin \nMilner. A theory of type polymorphism in programming. Journal of Computer and System Sci-ences, 17:348-375, \n1978. [MBL97] Andrew C. Myers, Joseph A. Bank, and Barbara Liskov. Parameterized types for Java. Symposium \non Principles of Programming Languages, pages 132-145, ACM, 1997. [OR981 Martin Odersky and Enno Runne. \nMeasuring the cost of parameterized types in Java. Research Report CIS-98-004, Advanced Computing Research \nCentre, University of South Australia, January 1998. [OW97] Martin Odersky and Philip Wadler. Pizza into \nJava: Translating theory into practice. Symposs um on Principles of Programming Languages, pages 146-159, \nACM, 1997. [PT98] Benjamin C. Pierce and David N. Turner. Local Type Inference. Symposium on Principles \nof Program-ming Languages, pages 2522265, ACM, 1998. [RS97] Paul Roe and Clemens Szyperski. Lightweight \nPara-metric Polymorphism for Oberon. Proceedings Joint Modular Languages Conference, Johannes Kepler \nUni-versity Linz SchloB Hagenberg Austria, March, 1997 http://www.fit.qut.edu.au/ szypersk/Gardens/ [Tho97] \nKresten Krab Thorup. Genericity in Java with vir-tual types. European Conference on Object-Oriented Programming, \npages 444-471, LNCS 1241, Springer- Verlag, 1997. [Tor98] Mads Togersen. Virtual types are statically \nsafe. 5th Workshop on Foundations of Object-Oriented Lan-guages, January 1998. [TT98] Kresten Krab Thorup \nand Mads Togersen. Struc- tural virtual types. Informal session on types for Java, 5th Workshop on Foundations \nof Object-Oriented Lan- guages, January 1998. [Wri95] A. Wright, Simple imperative polymorphism, Lisp \n and Symbolic Computation, 8:343-355, 1995.  \n\t\t\t", "proc_id": "286936", "abstract": "We present GJ, a design that extends the Java programming language with generic types and methods. These are both explained and implemented by translation into the unextended language. The translation closely mimics the way generics are emulated by programmers: it erases all type parameters, maps type variables to their bounds, and inserts casts where needed. Some subtleties of the translation are caused by the handling of overriding.GJ increases expressiveness and safety: code utilizing generic libraries is no longer buried under a plethora of casts, and the corresponding casts inserted by the translation are guaranteed to not fail.GJ is designed to be fully backwards compatible with the current Java language, which simplifies the transition from non-generic to generic programming. In particular, one can retrofit existing library classes with generic interfaces without changing their code.An implementation of GJ has been written in GJ, and is freely available on the web.", "authors": [{"name": "Gilad Bracha", "author_profile_id": "81100534214", "affiliation": "Sun Microsystems", "person_id": "P97520", "email_address": "", "orcid_id": ""}, {"name": "Martin Odersky", "author_profile_id": "81100056476", "affiliation": "University of South Australia", "person_id": "PP14030830", "email_address": "", "orcid_id": ""}, {"name": "David Stoutamire", "author_profile_id": "81100002180", "affiliation": "Sun Microsystems", "person_id": "P63984", "email_address": "", "orcid_id": ""}, {"name": "Philip Wadler", "author_profile_id": "81100173596", "affiliation": "Bell Labs, Lucent Technologies", "person_id": "PP39030941", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/286936.286957", "year": "1998", "article_id": "286957", "conference": "OOPSLA", "title": "Making the future safe for the past: adding genericity to the Java programming language", "url": "http://dl.acm.org/citation.cfm?id=286957"}