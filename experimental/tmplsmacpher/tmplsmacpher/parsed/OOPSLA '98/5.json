{"article_publication_date": "10-01-1998", "fulltext": "\n Borrow, Copy or Steal? Loans and Larceny in the Orthodox Canonical Form Anthony J. H. Simons Department \nof Computer Science University of Sheffield Regent Court, 211 Portobello Street Sheffield, S 1 4DP UK \n+44114222 1838 A.Simons@dcs.shef.ac.uk Abstract Dynamic memory management in C++ is complex, especially \nacross the boundaries of library abstract data types. C++ libraries designed in the orthodox canonical \nform (OCF) alleviate some of the problems by ensuring that classes which manage any kind of heap structures \nfaithfully copy and delete these. However, in certain common circumstances, OCF heap structures are wastefully \ncopied multiple times. General reference counting is not an option in OCF, since a shared body violates \nthe intended value semantics; although a copy-on- write policy can be made to work with borrowed heap \nstructures. A simpler ownership policy, based on larceny, allows low-level memory manager objects to \nsteal heap structures from temporary variables, in properly isolated circumstances. Various strategies \nfor regulating theft are presented, ranging from pilfer-constructors to locks on heap data. Larceny has \nsimilarities with other transfer of ownership patterns, but is more a core implementation technique designed \nto improve the efficiency and effectiveness of OCF-conformant libraries. Keywords C++, implementation \nstrategies, memory management, copy-on-write, transfer of ownership, borrowing, stealing, larceny. 1 \nIntroduction This paper compares three policies for regulating the transfer of heap resources in C++, \nnamed according to whether the recipient has to borrow, copy or steal from the Permission to make digital \nor hard cqpoes 01 all or part of this work fqr Personal or ClaSSrOOm use is granted wthout tee provided \nthat cop@% are not made or distributed for proi or commercial advan- IWe and that copies bear this notvx \nand the full crtation on the frrst page. 10 copy otherwise. to republish. to post on servers or to redistribute \nto lists, requires pnor specific permissoon and/or a fee. OOPSLA 98 10198 Vancouver. B:C. 0 1998 ACM \nl-58113s0058/98/0010...$5.00 provider. The area of dynamic resource ownership has received new attention \nrecently, being a concern in concurrent and distributed programming [SBGL91]. Particular issues here \ninclude the containment of resources with a view to cheap synchronisation [Lea961 and the transfer of \nresources at low cost [SaCa96]. The need to assure exclusive ownership is related to other general work \non aliasing-protection, such as the Geneva Convention [HLHW92], alias-free pointers [Mins96], islands \n[Hogg91] and balloon types [Alme97]. Much of this work focuses on who has control over resources and \nwhether further aliases may be granted. In this paper, a different slant is taken. Many C++ programmers \nprefer the so-called orthodox canonical form (OCF) [Cope92, Lea93], with its emphasis on the uniform \nvalue semantics of copying and simple memory management, over more complex forms of resource control, \nsuch as reference-counting using handle/ representation pairs [Stro91, Hors95]. Section 2 reviews the \npragmatic and semantic reasons for adopting OCF, explaining its renewed importance in the context of \nthe Standard Template Library (STL). Section 3 outlines the common problems with excess copying of heap \nstructures in OCF, setting out ideal targets for maximum efficiency. Section 4 describes two copy-on-write \n(borrowing) strategies in the context of OCF. Section 5 describes two transfer-of-ownership (stealing) \npatterns: the aggressive larceny model is contrasted with an alternative opportunistic larceny model. \nThese are shown to be less complex and with fewer overheads than borrowing strategies, while achieving \nthe same optimum efficiency targets outlined in section 3. Larceny is most closely related to Cargill \ns sequence of owners pattern [Carg96], being one form of loculised ownership; and is also similarly related \nto Lea s transfer of ownership pattern [Lea96]. However, whereas these are applied at a high level to \nabstract and distributed designs, larceny drives these principles down into a core implementation technique \nfor OCF-conformant C++ libraries. 6.5 //c----N\\ \\ / default (shallow) copy 1 stkl stk2 -size -size \n-capacity -capacity -block block I I \\ \\ \\ stk3 \\ \\ \\ - -size -capacity -block  OCF-conformant (deep) \ncopy fY Figure 1: Stack objecti sharing and copying heap storage 2 Orthodox Canonical Form According \nto a well-known design tenet in C++, classes which manage any kind of heap memory structures should always \nprovide: a default constructor, a copy constructor, an assignment operator and a destructor, chiefly \nto ensure that heap memory structures are copied and deleted correctly. Classes which provide these explicitly \nare said to conform to the orthodox canonical form (OCF) [Cope92]. If these operations are not provided \nexplicitly, the compiler will automatically generate default versions, which, unfortunately, usually \nbehave in the wrong way, because they assume that an object is a shallow structure. 2.1 Safety Issues \nin OCF For those unfamiliar with C++, Figure 1 illustrates how this default behaviour leads to the accidental \nsharing of substructure, usually a bad idea. A simple Stack variable stkl is copied to another variable \nstk2 (possibly by assignment, or by passing stkl by value into a formal argument stk2). By default, the \nStack data members are shallow-copied, with the consequence that although stkl and stk2 maintain separate \ninformation about the -capacity and active -size of the stack, they both share the same heap storage \n-block, whose address only was copied. If stkl and s tk2 are intended to be separate objects, a sequence \nof pop ( ) and push ( ) operations performed on stk2 will adversely affect s tkl, by modifying the elements \nstored. Apart from this undesired aliasing of Stack states, another practical reason to be concerned \nover accidental sharing is that the memory reclamation mechanism provided in C++ assumes heap structures \nare locally owned. If stk2 goes out of scope, the destructor -Stack() will delete the shared -block, \nleaving a dangling pointer from s tkl. Subsequent operations upon stkl are likely to lead to a memory \nsegmentation fault and program failure. Instead, we would rather that copying stkl produced s tk3, which \nhas a deep copy of the storage -block. To achieve this, an OCF-conformant Stack must provide both a copy \nconstructor Stacklconst Stack&#38;) and an assignment operator Stack&#38; operator= (const Stack&#38;) \nwhich take deep copies of the heap -block, in order to prevent accidental memory sharing. A default constructor \nStack ( ) ensures that dynamic memory is properly initialized and a destructor -Stack ( ) may now safely \nassume that each Stack variable controls its own heap structure, when it deletes this. 2.2 Semantic Issues \nin OCF More compelling reasons for adhering to OCF come from the underlying semantic considerations [Cope92, \nLea93]. C++ was designed on top of a language, C, which has value semantics for assignment and argument \npassing. For consistency s sake, the same operations applied to user-defined objects (of whatever complexity) \nshould therefore have the same value-semantics. This argument is further reinforced by the provision \nof an alternative pass-by-reference mechanism in C++, which programmers may use explicitly where aliasing \nis intended: C++ already contains simple ways for people to obtain copy versus reference semantics. Programmers \nthemselves are in a much better position to know when to make copies and when to use references. Hiding \nthese matters often leads to less efficient and [less] predictable behaviour [Lea93]. Since object identity \nis a salient concern, objects are typically passed by reference. The relatively few times that a true \ncopy is required is usually worth the cost of obtaining it. So, whereas early versions of libg++, the \nGNU C++ library, had originally adopted reference counting and shared body objects to reduce copying \noverheads, the above argument led to a change in policy: Except in a few cases where copy-prevention \nstrategies are transparent and algorithmically superior, libg++ classes maintain the convention that \na copy constructor actually makes a copy. Similar remarks hold for assignment and other operations [Lea93]. \n In this light, it is possible to define an OCF-conformant class as one which, when it is copied, makes \na true copy of any data that it manages; and deletes the data when it is 2.3 The Standard Template Library \nand OCF itself destroyed. Collections are typically characterised as managed or Commercial C++ libraries \n[GOP90, Rati93, Lea93, unmanaged [StroSlJ. The former are primary object Rogu95, BrLo97] make extensive \nuse of heap structures, repositories, responsible for copying (in OCF) and deleting particularly in their \ncollection or container classes. Most their elements when they are themselves copied and are at least \npartially OCF-conformant, in the above sense. destroyed; whereas the latter merely manipulate object \nRational s Booth Components library [Rati93, Booc94] is references and forget these when they are destroyed. \nThe an interesting case, since it draws an explicit contrast introduction of templates in C++, especially \nthe Standard between monolithic collections, whose elements are Template Library (STL) [StLe94], simplifies \nthese retained as a single block, and polylithic collections, management issues. Since a template argument \nmay be whose elements are distributed throughout highly-instantiated with either a value, or a pointer, \nthen it is connected list, tree or graph structures. Monolithic reasonable to define a policy according \nto which all collections are OCF-conformant; however polylithic managed collections are value-based (copies \nhaving value collections are not, because they permit structural sharing: semantics), and all unmanaged \ncollections are pointer- based (copies having reference semantics). This policy is I... In polylithic \nstructures, copying, assignment and. perhaps most consistent with the underlying semantics of equality \nare all shallow (meaning that aliases may C values and pointers. As a result, template code may be share \na reference to a part of a larger structure). . . . kept simple, without special-purpose deallocation \nloops to For example, we may have objects that denote a sublist delete heap objects, and works equally \nwell for theof a longer list, a branch of a larger tree, or individual managed or unmanaged collections. \nOCF is firmlyvertices and arcs of a graph [Rati93]. established in template libraries which adopt this \nIn section 4, we describe a borrowing policy, intended to management policy, since value-based instantiations \npreserve the OCF-conformant value semantics of copying necessarily copy the entire structure of each \nelement when for those polylithic data types where underlying structural the collection is itself copied. \nThis is reinforced in the sharing is an issue. This may be used appropriately with STL, which expects \nclasses instantiating the element type all the singly-linked List, Tree and Graph types. to provide a \ncopy constructor and an assignment operator. typedef . . . Element; // for some Element type class Array \n { public: int size0 const; // array size (equiv. capacity) Element&#38; operator(] (int); // element \nupdate const Element&#38; operator[](int) const; // element access Array ( ) ; // allocate no heap, size \nis zero -Array(); // delete heap memory Array(int); // construct with suggested capacity Array(const \nArray&#38;); // copy construct from other array Array&#38; operator=(const Array&#38;); // copy assign \nfrom other array private: enum { INITIAL = 10 ); // default capacity void expando; // resizing procedure \nint -size; // array size (equiv. capacity) Element* -block; // heap memory pointer 1; // . . . other \noperations omitted for brevity // Expand to double existing size (equiv. capacity), or INITIAL capacity \nvoid Array::expand() t int newsize = (-size ? 2*-size : INITIAL); Element* newblock = new Element [newsize]; \nfor (int i = 0; i < -size; i++) newblock[i] = -block[i]; delete -block; -block = newblock; -size = newsize; \n Figure 2: Optimal expansion of Array objects 67 class Set ( public: int size0 const; // cardinality \nof set void insert(const Element&#38;); /I insert element void remove(const Element&#38;); // remove \nelement boo1 contains(const Element&#38;) const; // element membership SetO; // construct hash table \nusing Array(int) Set(int); // construct hash table using Array(int) . . . // other operations and OCF \nconstructors friend class SetIterator; // dedicated iterator private: void expando; // resizing procedure \nint capacity0 const; // current hash table size Array -table; // hash table storage area int -size; // \ndynamic element count 1; // . . . most operations omitted for brevity  // Expand to double existing \ncapacity, which is guaranteed nonzero; // uses a SetIterator to traverse the elements of this Set. void \nSet::expand() { Set temp (2 * capacity()); SetIterator it (*this); for (it.start(); ! it.atEnd(); it.forth()) \ntemp.insert(it.element()); -table = temp.-table; // transfer by assignment Figure 3: Sub-optimal expansion \nof Set objects The anticipated global adoption of the STL means that OCF-related issues now have a renewed \nimportance. 3 Copying and Loss of Effkiency For reasons of safety, economy and semantic consistency, \nOCF is to be recommended as a basic principle of C++ class design and implementation. The importance \nand desirability of taking copies cannot be underestimated, even in programs which mostly pass objects \nby reference. Difficulties arise in a value-based language like C++ when programmers resort to a defensive \nstyle, in which aliases are passed everywhere to unique copies of objects, since this typically leads \nto scoping errors. The self-conscious avoidance of copying also prevents use of the most natural programming \nidioms, such as the usual constructive mathematical Set operations, which are replaced by one- sided \nmutating operations. Finally, assignment, expansion and copy construction all require copying. However, \nthere are certain common circumstances in which the mechanisms of C++ inevitably force extra copies of \nvariables to be taken; and this impacts badly on OCF-conformant classes. 3.1 Expansion and Copying A \ncommon requirement in many libraries is to have constant-time accessible structures that occasionally \nresize themselves. The cost of resizing is amortised over all the O(1) access enjoyed during the lifetime \nof the structure; and may be avoided altogether if a suitable initial size is selected. However, the \nresizing action itself may be more costly than it strictly needs to be. The ideal minimum cost is for \none copy only to be taken; this is incurred if an object creates a larger heap structure, copies all \nelements from the old to the new heap structure, then replaces the old with the new, deleting the old. \nUnfortunately, this only works for the simplest cases, such as the simple dynamic Array class listed \nin Figure 2. Here, the expand ( ) procedure makes detailed assumptions about the stored representation \nand order of elements in the Array; and is able to manipulate the representation directly. A more realistic \nexample might be the Set class listed in Figure 3. This class uses a server class Array as a hash table, \nreflecting a similar division of concerns as that found in the Booth Components [Rati93, Booc94] and \nthe reference STL [StLe94] (for clarity s sake, we have replaced the template syntax with a typedef in \nFigure 2 and assume the Element type is similarly-defined in all following figures). The Array handles \nthe underlying storage, maintaining a dynamic block on the heap, whereas the Set is the abstract data \ntype, offering appropriate public functions. During expansion, it is impossible simply to replace one \nArray block with a larger Array block and copy elements across in the linear style of Figure 2, since \nthe locations of elements in the larger Array will be quite . different, determined by a hashing function \nin Set's operator= to take a deep copy, for example, when a insert ( ) operation. The most economical \nway to Set is itself copied. Furthermore, if the direct transfer did transfer elements into another Set \nis to use Set's take place, then when expand ( ) terminated, destructors insert ( ) directly, since it \nwould be wasteful to would be called for the local Set and its Array, duplicate, inside expand ( ) , \nall of the hashing and deallocating the resized block. The current Set's Array collision-handling code \npresent in insert ( ) Therefore, block would become a dangling pointer. expand ( ) uses a temporary local \nSet variable, standing 3.2 Constructive Operations and Copying for the replacement, into which elements \nare transferred to their correct locations in the larger Array. At the end of C++ class library designers \nare seriously inhibited from providing constructive operations in OCF-conformant, the method, the current \nSet object must take over the heap structure-owning classes because of excess copying contents of the \nlocal Set. This is usually performed either problems (and also because of type-clashes under by assigning \nthe local Set's Array (as illustrated), or inheritance, as discussed in [Lea93]). Constructive even assigning \nthe whole local Set to *this. operations are those provided in value-oriented classes Here is where the \nexcess copying takes place: the Array's whose operations typically return new instances [Lea93]. operator= \nis invoked to perform the transfer. Because Many simple lightweight classes, such as numeric, date this \nis an OCF-conformant operation, it assumes that it and string classes, fall into this category. Overloaded \nmust duplicate its argument. Accordingly, a true copy of arithmetic operations +, -, *, / are alwaysthe \nlocal Set's Array block is taken, this is assigned to constructive, to conform to the usual semantics. \nManythe current Set's Array block member, causing libraries (e.g. 1 ibg++) also provide value-oriented \ndeallocation of the old Array block. Finally, the local Strings with an overloaded operator+ which Set \nand its Array block are deallocated when constructs the result of concatenating the two argument expand \n( ) terminates. This is strictly one more round of Strings. deep copying and deallocation than is logically \nnecessary. Figure 4 gives the most efficient implementation for this Ideally, we wish to transfer the \nlocal Array block constructive operation, in a simple String class. This contents directly. But we cannot \nalter the semantics of example, rather like that in Figure 2, benefits from anArray's operator=, even \non the grounds that it is a atypical ability to manipulate the underlying char*special implementation \nsupport class, since there are other representation directly. The concatenated String iscircumstances \nin which it is entirely appropriate for constructed only once, in the return expression, using a #include \n<string.h> class String { public: int size0 const; // string length String operator+(const String&#38;) \nconst; /I constructive concatenation . . . // other operations and OCF constructors private: String(char*, \nint); // secret constructor int -size; /I string length char* -block; /I memory storage area 1; // . \n. . most operations omitted for brevity /I Secret constructor initializes String with the data supplied \ninline String::String(char* str, int siz) : -size(siz), -block(str) {I /I Constructive concatenation \nString String::operator+(const String&#38; str) const c int newsize = -size + str.-size; char* newblock \n= new char [newsize + 11; I/ +l for terminating nullchar strcpy(newblock, -block); strcat(newblock, str.-block); \nreturn String(newblock, newsize); /I construct new String 1 Figure 4: Optimal constructive concatenation \nof String objects 69 class Set { public: . . . Set operator+(const Set&#38;) const; Set operator-(const \nSet&#38;) const; . . . private: // . . . other operations omitted for brevity // Constructive union -copy \nother Set into // over this Set adding elements to result Set Set::operator + (const Set&#38; other) \nconst { Set result (other); SetIterator it (*this); for (it.start(); ! it.atEnd(); it.forth()) result.insert(it.element()); \nreturn result; // other Set operations as per Figure3 // constructive union // constructive difference \n// other operations and OCF constructors // implementation as per Figure3 result, then iterate // local \nresult copies the argument // iterate over current set // add current elements to result // copy local \nresult Set on termination Figure 5: Sub-optimal constructive union of Set objects special-purpose private \nconstructor, which builds a String from its completely supplied representation. The notion of constructively \ncombining two collections is quite general: Set has set union; Map has union with override; SortedCollection \nhas merge. However, these cannot reasonably be provided in the same manner as Figure 4. Figure 5 gives \na more realistic example of set union (here, by overloading operator+), in which a temporary local Set \nis used to construct the result. Initially, the local Set copies the argument; then, we iterate over \nthe current Set and insert ( ) each element individually into the local Set. The significance of having \na local Set, rather than simply the underlying representation, is to allow reuse of the hashing and equality-testing \ncode in insert ( ) , which must ensure that elements common to the current and argument Sets are only \ninserted once in the result. Upon termination, the function returns the (enlarged) local Set. Here is \nwhere the excess copying of heap structures takes place: since the local Set goes out of scope when the \nfunction returns, the function result must be copied to the call-site. The Set copy constructor is invoked, \nwhich duplicates the heap structure maintained by the local Set, viz. the server Array's block. The local \nblock is deallocated (by destructors) when the function terminates. Logically, we wish to transfer the \ncontents of the local Set directly and then forget about it. However, the default semantics for return \nexpressions is a value-copy; and an OCF-conformant copy constructor must always duplicate its heap structure. \nThere are no easy ways around this. You cannot, for example, declare a local Set&#38; reference to the \nexternal return buffer; or declare an external reference to a local variable, both of which are syntactically \nillegal. The alternative approach, of dynamically allocating a Set* within the function and returning \na pointer to this result, is less desirable because it introduces storage management problems: clients \nbecome responsible for reclaiming storage they did not allocate. 3.3 Cumulative Copying Effects Individual \nduplications may be tolerated; however, they have a tendency to mount up. Consider that at least three \ncopies of heap structures may be taken in expressions like: Set s, t, u; s = t + u; // assignment to \ns  Here, the contents of u will be copied once, when the local Set is constructed inside operator+. \nDepending on the relative sizes of the Sets t and u, the local Set may resize itself multiple times, \nas elements of t are added, resulting in as many extra copies (especially if u is much smaller than t, \ngiven Figure 5 s implementation of operator+). Otherwise, a second copy will be taken when operator+ \nreturns; and a third, when operator= duplicates its argument. Note especially how the compiler creates \na temporary Set to hold the result of operator+, which is cloned again by operator= and deleted later. \nThe temporary is necessary, because storage for the unioned result must be held somewhere: the argument \nof operator= is passed by reference to this storage. If copy initialization of s is preferred over assignment, \nmost compilers can eliminate one duplication: Set t, u; Set s = t + u; // copy construct s where the \nresult of operator+ is copied directly into s instead of a temporary return buffer. Again, there are \nvery good reasons why all this copying behaviour should be provided - it preserves value semantics and \nprevents access to static data which is out of scope, or to dynamic data which has become deleted. Nonetheless, \nwe should like to do better, where we know that excess copying can be safely avoided. 4 Borrowing: Copy \non Write The alternatives to copying heap structures have traditionally focused on copy prevention. Either, \nclasses are designed to make it hard, or impossible, to obtain copies; or some reference-counting mechanism \nis adopted. The first strategy, a memory management policy which we shall call prohibition, is straightforward: \na class forbids automatic copying by disabling its copy constructor, perhaps by making this a private \nfunction. For the sake of the current discussion, we assume that we are dealing with cases in which copies \nare typically desired. With the second strategy, the reference semantics of a shared body sits rather \nawkwardly with the intended value-semantics of OCF; nonetheless the illusion of value semantics may be \npreserved through a copy-on-write policy, explained below, which we shall call borrowing. This approach \nis more flexible than smart pointers and easier to maintain than handle/representation hierarchies; and \nit incurs relatively small costs. Since borrowing deals with shared memory resources, this suggests thg \npolylithic data types, which already share substructure, may be able to exploit it to particular advantage. \nUltimately, we find that a slightly different borrowing idiom is more useful here. 4.1 Smart Pointers, \nHandles and Representations Reference counting has been advocated many times as a way to avoid excess \ncopying, sometimes cast in elaborate frameworks [Wild96], although the concept is essentially simple \n[Stro91, Hors95]. Logical objects are factored into handles and representations: the handles are small \nand may always be passed by value, at little cost; the representations are accessed via an indirection \nin the handles and so are passed by reference. Every time a handle is acquired or lost, a reference count \nis updated and the representation is deleted automatically when the final handle goes out of scope. Stroustrup \n[Stro91, ~463-4721 describes both intrusive and non-intrusive designs. In the former, a reference count \ndata member intrudes into the representation, whereas in the latter, the handle manages a separate shared \ncounter. A drawback of this approach is that the handle and representation classes must be developed \nin pairs -the handle class delegates all requests to the representation and so must have the same interface. \nWhen cast in a template framework, handles behave like smart pointers [Hors95, ~302-51. Unfortunately, \nthis mitigates against polymorphic binding -a Pointer<B> is not type compatible with a Pointer<A>, even \nif the instantiating classes A and B are type compatible (viz. B is derived from A). General-purpose \nsmart pointers, such as the proposals for an autogtr class in the standard C++ library, are intended \nmore to ensure deletion of heap data after exceptional failures [Colv98], concentrating on the issue \nof transfer of ownership, which we discuss in section 5; though the latest revisions do intend to allow \nsome form of type-casting, using two type templates. Reference counting is in any case not an easy option \nin OCF. In general, maintaining shared representations violates the intended uniform value semantics \nof argument passing and assignment: a smart pointer converts value semantics into reference semantics, \nbut for class types only. However a copy-on-write policy may be made to work within the bounds of OCF \nconformity. 4.2 Loaning out Expensive Heap Resources We call this the borrowing policy -an object will \nloan out its heap structure to its copies, until it or one of its copies wishes to perform some mutating \noperation, at which point a true copy of the heap structure is taken. This is sometimes described as \ndeepening a shallow copy [GOP90]. Horstmann describes a typical copy-on-write design for handle/representation \npairs [Hors95, ~2821; although a borrowing policy (in our view) merely has to share expensive heap resources, \nnot the whole representation. The listing in Figure 6 illustrates how a non-intrusive handle class can \nbe adapted to serve as a Borrower base class for all of its borrowing descendants. A single class hierarchy \nmay be developed, which is less complicated to manage than parallel handle and representation hierarchies. \nBorrowing works exactly as desired, solving the excess copying problems described above. To see how, \nlet us now assume that the Array class is derived from the Borrower base class and so maintains a shared \nreference count. Array must provide a definition for the virtual copy ( ) to make a duplicate of its \nshared -block. Any mutating operation on Array must first invoke the deepen ( ) method, which duplicates \nthe memory block if the reference count is greater than one. Revisiting the case described in Figure \n3, the local Set is still created inside expand ( ) with a brand-new Array block. When it transfers its \nArray by assignment to the current Set, the block is shared and Array's reference count is incremented \nto 2. When expand ( ) terminates, destructors are called for the local Set, which eventually decrement \nthe reference count back to 1. No excess copying is incurred, only the desired minimum cost (as illustrated \nin Figure 2) of reallocating a larger replacement. class Borrower { public: Borrowero; // default constructor \n-Borrower() ; // destructor Borrower(const Borrower&#38;); // copy constructor Borrower&#38; operator \n= (const Borrower&#38;);// assignment operator private: int* -refcount; // shared reference count protected: \nvoid deepen(); // deepen shallow copy void assign(const Borrower&#38;); // assignment book keeping virtual \nvoid copy0 = 0; // copy heap structure virtual void free0 = 0; // free heap structure 1; // Default \nconstructor -initialize shared refcount Borrower::Borrower() *(-refcount = new int) = 1; ; // Destructor \n-if refcount reaches 0, then call free0 in the // derived class to delete whatever heap memory was allocated \nBorrower: :-Borrower0 t if (--(*-refcount) == 0) (: free(); // (dynamic) delete heap structure delete \n-refcount; // (static) delete shared refcount // Copy constructor -share and increment refcount Borrwer::Borrower(const \nBorrower&#38; bor) : -refcount(bor.-refcount) ++(*-refcount); ;  // Assignment -must be redefined and \nretyped in each descendant; // so factor common book-keeping activity into assign0 Borrower&#38; Borrower: \n:operator = (const Borrower&#38; bor) 1 if (this != &#38;bor) assign(bor); // factor out book-keeping \nreturn *this; 1 // Deepen -called inside every mutator operation; if refcount > 1, // invoke copy0 in \nthe derived class to duplicate heap structure void Borrower::deepen() { if (*-refcount > 1) c copyo; \n// (dynamic) copy heap structure --(*-refcount); *(-refcount = new int) = 1; // Assign -called inside \nevery retyped operator=; encapsulates // common book-keeping activity void Borrower* .:assign(const Borrower&#38; \nbor) { if (--(* -refcount) == 0) 1 free(); delete -refcount; 1 -refcount = bar.-refcount; ++(* -refcount); \n } Figure 6: Borrower base class for a copy-on-write hierarchy 72 Revisiting the case described in Figure \n5, the local Set is created inside operator+ as a smart copy of the argument Set, increasing the Array's \nreference count to 2. As soon as the first element from the current Set is inserted, this mutating operation \ninvokes deepen ( ) , which duplicates the Array block on a reference count of 2. This is the only heap \ncopy which is taken, the single copy which was desired, and the minimum cost solution (as illustrated \nin Figure 4). Copying decrements the previously shared reference count and allocates a new counter, initialized \nto 1, in the copy. Further insert ( ) operations do not duplicate the Array block, which now has a reference \ncount of exactly 1. When operator+ terminates and copies the local Set into the return buffer, the reference \ncount is incremented to 2 and the block is shared. When the local Set goes out of scope, destructors \ndecrement the reference count again. In the worst-case scenario where this result is assigned to another \nSet variable, the block is shared inside operator= and later forgotten by the temporary return buffer, \nwith a similar increment and decrement to the reference count. The advantage of a borrowing policy over \nsmart pointers lies in the ability to use Borrower&#38; references and Borrower* pointers (and their \nderived types) in the same polymorphic ways as standard references and pointers. In comparison with the \ndual handle and representation approach, only one hierarchy need be maintained. The cost of adopting \na borrowing policy comes from the increase in design complexity and the small overhead incurred for some \nsimple operations. The programmer must (remember to) invoke deepen ( ) as the first action inside every \nmutator function. This adds a dereference and inequality-check to every such operation, even when no \nduplication is eventually performed. All heap managing classes must be derived from the Borrower base \nand must provide suitable copy( ) and free ( ) implementations, which may be extended to manage more \nthan one heap structure. All operations must be carefully partitioned into accessors and mutators. The \nmutator versions trigger the copying of heap structures on a reference count of 2 or more. This is relatively \nstraightforward -Array may provide two overloads for operator [ 1, one of which protects the current \nobject with const, and only the non-const version need invoke deepen ( ) . Provided that these design \ntrade-offs are considered acceptable, borrowing may be used universally, or in parts of a well-designed \nlibrary of abstract data types. 4.3 Sharing polylithic substructures Since the polylithic data types \nalready share substructure, this suggests that they might be able to exploit a variant of borrowing to \ntheir particular advantage. Whereas the deepening of monolithic objects (for reference counts > 1) duplicates \nthe heap block in its entirety, the deepening of polylithic objects should really only seek to duplicate \nthose parts of the connected structure that are impacted by change, unlike the total memory-copy performed \nin Horstmann s example [Hors95, ~2821. The result of inserting an element into a List should ideally \nclone some list cells and share others, a practice favoured in functional languages like Lisp [Stee86]. \nThis can only be achieved if structures are singly-linked; since otherwise all parts of the connected \nstructure are reachable from any node, therefore no shared substructure can be considered semantically \ndistinct from the entire original structure. In C++, a List is typically a wrapper around a chain of \nCells (similarly, for Trees and directed Graphs). Mutator operations may be delegated to the first Cell, \nthen work recursively through the chain, testing for insertion, removal and mutation points, constructing \nnew Cells as the stack unwinds, returning a pointer which is stored as the new -head of the List. Figure \n7 sketches a recursive, partially-copying, singly-linked Cell class which could be used as the representation \nfor such a polylithic List. We assume that any wrapper List class will have reference-counting constructors \nand a destructor, rather like those of Cell, to determine when the first Cell in the chain is reclaimed. \nThe List wrapper will delegate all accessor and mutator methods to the -head; and will always reassign \nits -head to the result of a mutator method. Notice how the Cell takes responsibility for deciding whether, \nand how much, copying should take place. The List wrapper cannot determine directly (unlike Borrower \nabove) whether parts of its substructure are shared, since it only sees the -refcount of the -head. Cell \nmutator methods pass a flag recursively to report whether any of the Cells already visited were shared; \nif so, then all Cells from the first shared Cell up to the mutation-point must be copied. Otherwise, \nan in-place destructive mutation is allowed. This is safe, even if Cells downstream from the mutation \npoint are shared. If one Cell in the chain is replaced, then possibly many preceding Cells must be. This \nis handled as the recursive stack unwinds, by testing whether the current Cell is shared. If not, the \nrecursive tail is spliced (taking care to adjust reference counts) and no copying is required, otherwise \na new Cell is created, copying the current element and pointing to the recursive tail. A similar borrowing \npolicy may be provided for Tree and Graph Nodes. This approach is elegant and requires 2 or at most 3 \nchecks per Cell, over and above the usual tests for the insertion point and the end of the list, during \na traversal. These are: a reference count comparison, a boolean shared check and a tail identity check \nduring splicing. To make the example in Figure 7 more efficient, class Cell { public: Cell(const Element&#38;, \nCell*); // construct -only using this constructor -celi(); // destroy const Element&#38; item0 const; \n// accessor -inspect element const Element&#38; itemAt(int) const; // accessor -inspect at index . . \n. // other accessors omitted for brevity Cell* replaceAt(int, const Element&#38;, bool=false); // mutator \n-replace at index Cell* insertAt(int, const Element&#38;, bool=false); // mutator -insert at index Cell* \nremoveAt(int, bool=false); // mutator -remove at index pri vate: friend class List; // List granted access \nto adjust head's refcount void attach(Cell*); // secret refcount-adjusting next attachment Cell(const \nCell&#38;); // disable standard copying Cell&#38; operator = (const Cell&#38;); // disable standard assignment \nint -refcount; // reference count Element -item; // stored element Cell* -next; // tail of the list \n}; // Construct with element and next Cell, updating next Cell's refcount. // Current Cell's refcount, \ninitially zero, is updated when it is linked. Cell::Cell(const Element&#38; elt, Cell* Ink) : refcount(O), \n-item(elt), pext(lnk) { Tf (-next) ++(-next->-refcount); 1 // Recursively delete if next Cell is only \npointed to by this one Cell::-Cell0 if (-next &#38;&#38; --(-next->-refcount) == 0) delete -next; : // \nAuxiliary function -attach Ink as next Cell, updating both refcounts. // NOTE: Use only with non-null \nnext and Ink (and best with distinct pointers). void Cell: :attach(Cell* Ink) { ++(lnk->-refcount); // \nstill safe if -next == Ink if (--(-next->-refcount) == 0) delete -next; -next = Ink; 1 // Replace element \nat index position. If list is shared, clone leading Cells and // share trailing Cells; otherwise mutate \nthis Cell's element and return the list. Cell* replaceAt(int index, const Element&#38; elt, boo1 shared) \n{ shared I= (-refcount > 1); // update shared flag if (index == 0) { if (shared) return new Cell(elt, \n-next); // replace current Cell, share tail else 1: -item = elt; // mutate current Cell return this; \n// return existing list 1 1 else { assert(pext != 0); // null pointer check Link* tail = -next->replaceAt(index-1, \nelt, shared); if (shared) return new Cell(-item, tail); // clone leading Cells else I if (tail != -next \n) attach(tai1); // splice leading Cells return this; a single bounds check of the mutation-point index \nin the structures directly from each other, in properly prescribed List wrapper would obviate the need \nfor a null-check circumstances. Eventually, larceny may be integrated with before the recursive call \nin each Cell. This approach constructive operations, opening up a more natural would also benefit from \nspecial-purpose Allocator programming style in OCF. classes to reserve Cells in blocks and recycle them \nto a // Other mutating operations insertAt -~:o I removeAt defined in a similar fashion Figure 7: Recursive \npartially-copying Cell for shared list tails 74 5.1 Pilfer Functions and Constructors free list when \nthey are deleted. By re-examining the specific copying cases that we wish to avoid, it is possible to \ncome up with a different solution for 5 Stealing: Transfer of Ownership heap managing classes. The basic \nidea is motivated by the The designers of GNU s libg++ eventually abandoned example in Figure 3. Although \nwe cannot alter thesmart reference-counting as a general management policy semantics of assignment for \nArray, we can provide it [Lea93]. They found the attempt to minimize copying, (and all other heap structure \nmanagers) with a pi1 f er ( ) while still conforming to value semantics, not especially function to steal \nheap storage from its argument, asworthwhile: tricks like copy-on-write add more overhead illustrated \nin the listing in Figure 8. This function has the than they save [Lea93], probably because the dual task \nof obtaining the storage for the thief (theconventional handle/representation model was too invoking \nobject) and then forcing the victim (thecomplicated. We think that the Borrower and smart argument) to \nforget about it, so that dangling referenceCell patterns introduced in section 4 may nonetheless problems \ndo not arise later. When the victim goes out of prove useful to some programmers, since they encapsulate \nscope and its destructor is invoked, delete is called on a most of the complexity, at a tolerable cost. \nnull pointer, an empty but safe operation. Note how The GNU team considered that programmers should pi1 \nf er ( ) s argument must be passed as a non-const simply live with excess copying, in those few reference, \nbecause it is modified. It is best to consider that circumstances that demanded it, and elsewhere reduced \nthe pi1 f er ( ) destroys its victim, making that variable number of constructive operations available. \nThis need not unusable: it is intended for use on temporary, local be so. After copying and borrowing, \na third, cheaper variables only. Nonetheless, for safety s sake we impose a policy, which we call larceny, \naccepts the standard OCF condition on pi1 f er ( ) that it must reset its victim to a copy-construction \nas the ideal, but provides low-level stable state, so that no subsequent attempt can be made to memory \nmanager classes with the opportunity to steal heap access the stolen heap structure through the victim. \nThis class Array { public: . . . // other Array operations as per Figure2 pilfer(Array&#38;); // pilfer \nfunction -steal from argument private: // other Array implementation as per Figure2 ); ... // Pilfer \nfunction -steal the heap from other Array void Array::pilfer(Array&#38; arr) { if (this != &#38;arr) \n { delete -block; -size = arr.-size; arr.-size = 0; // also resets the argument's -block = arr.-block; \narr.-block = NULL; // book-keeping variables // . . . class Set otherwise defined as per Figure3 // Expand \nSet to double existing capacity -optimal version uses Array::pilfer() // to steal resized hash table \nfrom temporary local Set void Set::expand() { Set temp (2 * capacity0 ); SetIterator it (*this); for \n(it.start(); ! it.atEnd(); it.forth()) temp.insert(it.element()); -table.pilfer(temp.-table); // transfer \nby larceny 1 Figure 8: Array pilfer function enables optimal Set expansion 75 class Set { public: . \n. . // other Set operations as per Figure5 private: enum Pilfer 1: STEAL I; // Pilfer type and flag value \nSet(Set&#38;, Pilfer); // pilfer constructor // other implementation as per Figure3 ); ... // . . . \nother operations omitted for brevity // Pilfer constructor -this Set's implementation steals the heap \n// from the other Set's implementation Set::Set(Set&#38; other, Pilfer p) : // flag p is ignored -size(other.-size), \n-table0 // no heap allocated in initializers { -table.pilfer(other._table); // larceny -steal other Set's \nArray heap other .-size = 0; // book-keeping -make other safe // Constructive union -optimal version \nuses pilfer constructor // to steal heap from local Set in the constructed result Set Set::operator + \n(const Set&#38; other) const t Set result (other); // make just one copy, of other Set SetIterator it \n(*this); // i.terate over current Set for (it.start(); ! it.atEnd(); it.forth()) result.insert(it.element()); \nreturn Setcresult, STEAL); // pilfer-construct result, steal local heap > Figure 9: Set pilfer constructor \nenables optimal constructive functions is done by resetting the victim s book-keeping variables (here, \nthe Array's -size is reset to zero). The object resizing scenario, revised from Figure 3, is also illustrated \nin Figure 8. Here, it is clear that the minimum-cost solution is achieved where pi1 f er ( ) transfers \nthe local Array block directly to the current Set's Array. The further development of this idea is motivated \nby the example in Figure 5. Although we cannot alter the semantics of copy-construction when a function \nreturns its result, C++ does give us the opportunity to call a different constructor explicitly in the \nreturn expression (this is one of the few contexts in which a programmer may explicitly call constructors). \nWe provide Set (and all other value- oriented types having constructive functions) with a variant of \na copy constructor, which we call a pilfer- constructor, whose task is to construct a new Set by stealing \nfrom its argument, which is assumed to be a temporary, local variable. Figure 9 illustrates how the pilfer-constructor \nand pilfer-function work together to ensure that the constructed object properly steals the heap structure \nof its victim: it is a clean theft, with no messy after-effects. Originally, we considered distinguishing \nbetween copy-and pilfer-constructors purely on the basis of the const- ness (or otherwise) of the argument; \nhowever, this cannot be made to work with the usual C++ overloading rules. Given two very similar functions, \nC++ considers the const version to be the marked variant, so will call the unmarked (non-const) version \nunless it can determine that the object passed to its const argument is already const. There were sufficiently \nmany cases where we would have had to cast a non-const object to const, in order to force invocation \nof the copy constructor, to rule out this approach. Instead, we distinguish the pilfer-constructor using \nan additional flag argument, STEAL, of the special type Pilfer. The flag could be a boolean, although \nwe prefer to define a special enumerated type to rule out any possible type conflicts with programmer-defined \nconstructors. The pilfer-constructor of Figure 9 allows us to define cost- effective constructive Set \noperations, like the revised operator+ shown. Pilfer-construction eliminates the deep copying of heap \nstructures into the return buffer. Again, the only deep copy taken is when the local Set is constructed \ninside operator+. This fulfils the minimum overhead requirements expressed in Figure 4. All the usual \nSet operations, such as union, intersection and difference, may be provided in this way. 5.2 Aggressive \nversus Opportunistic Larceny The model for larceny proposed above is what we might call the aggressive \npattern, where it is the thief who initiates heap stealing. The thief (the invoking object) is the raider \nand the victim (the argument) cannot help but submit. An alternative is the opportunistic pattern, where \nwhen the memory-managing object has carelessly left its the victim is careless about locking up heap \nresources and heap storage unlocked, these operators may steal, rather the thief helps himself when he \ncan. than copy. Figure 10 illustrates the changes to Array's copy constructor and assignment operator \nand Figure I1 To implement this requires a slightly more intrusive illustrates the resizing and constructive \nfunction scenarios design. All heap-managers such as Array have an extra for Set once more. boolean Jock \nmember, which is normally initialized to true. Array provides inline lock () and unlock() to During expand \n( ) , a temporary local Set variable of reset this member. The value-oriented classes such as Set twice \nthe original capacity is constructed carelessly using now provide one or more careless-constructors. \nThese are Settint, Neglect ) . This constructs a server Array discriminated on a flag-type, Neglect (similar \nto the -table in its initializers in the usual way, but in its body Pi 1 f er type used above). A careless-constructor \nis only tells this -table to unlock ( ) itself. When expand ( ) ever used to construct and initialize \ntemporary local terminates, the current -table is replaced by the variables. In addition to performing \nall the usual temporary Set's -table using Array's operator=. initialization, Set's careless-constructor \ntells its server This notices that its argument is unlocked, so transfers class Array to unlock () itself. \nFinally, all copy ownership of the heap -block from the argument Array constructors and assignment operators \nmust accept non- to the invoking Array, resetting the temporary const reference arguments. This is so \nthat, on occasions argument s book-keeping variables in the process. In class Array { public: . . . \n// other Array operations as per Figure2 void lock(); // set -lock = true void unlock(); // set Jock \n= false . . . // other constructors set -lock = true Array(Array&#38;); 11 COPY, or steal argument Array&#38; \noperator = (Array&#38;); // copy-assign, or steal private: boo1 -lock; // intrusive lock variable // \nother Array implementation as per Figure2 ); ... // New copy constructor for Array; steals when argument \nis unlocked Array::Array(Array&#38; arr) : -size(arr.-size), -block(arr.-block) { if (! arr.-lock) { \narr.-size = 0; arr.-block = NULL; else { -block = new Element [-size]; for (int i = 0; i < -size; i++) \n-block[i] = arr.-block[i];  // New assignment operator for Array; steals when argument is unlocked Array&#38; \nArray::operator = (Array&#38; arr) (: if (this != &#38;arr) { delete -block; size = arr.-size; -block \n= arr.-block; Tf (! arr.-lock) I arr.-size = 0; arr.-block = NULL; else I -block = new Element [-size]; \nfor (int i = 0; i < -size; i++) -block[i] = arr.-block[i]; 1 1 return *this; Figure 10: Array with opportunistic \ncopying and assignment 77 class Set { public: . . . // other Set operations as per Figure5 private: \nenum Neglect { CARELESS );// Neglect type and flag Set(int, Neglect) ; // careless constructor #l Set(const \nSet&#38;, Neglect); // careless constructor #2 Set(Set&#38;); // copy constructor, coded as before, but \nmay actually steal // other implementation as per Figure3 ); ... // Careless constructor #l allocates \na new Array of size s, but unlocks it. Set: :Set(int s, Neglect n) : -size(O), -table(s) { -table.unlock(); \n // Careless constructor #2 copies its Array but leaves the copy unlocked. Set::Set(const Set&#38; other, \nNeglect n) : -size(other.-size), -table(other.-table) I -table.unlock();  // Expand to double existing \ncapacity -opportunistic version uses dual-purpose // operator= to steal the resized Array hash table \nfrom the careless local Set. void Set::expand() { Set temp (2 * capacityo, CARELESS); // careless constructor \n#l SetIterator it (*this); for (it.start(); ! it.atEnd(); it.forth()) temp.insert(it.element()); -table \n= temp.-table; // opportunistic larceny here // Constructive union -opportunistic version uses dual-purpose \ncopy constructor // to steal the Array's heap from the careless local Set. Set Set: :operator + (const \nSet&#38; other) const 1 Set result (other, CARELESS); // careless constructor #2 SetIterator it (*this); \nfor (it.start(); ! it.atEnd(); it.forth()) result.insert(it.element()); return result; // opportunistic \nlarceny here // NOT: return Set(result, CARELESS); -see section5.2 for reasons Figure 11: Optimal Set \nexpansion and construction using careless constructors total, only one copy of the original heap data \nis made, as per the ideal minimum in Figure 2. Likewise, in the constructive Set union scenario, operator+ \ncarelessly constructs its temporary local variable using Set (const Set&#38;, Neglect), which unlocks \nits Array representation. When the local Set is returned, the standard Set copy constructor is used; \nthis now accepts a non-const argument. Internally, this uses Array's copy-or-steal constructor, which \nagain notices that the argument is unlocked and so steals the heap -block. Notice how the responsibility \nfor larceny now lies with the victim, at the point where the local variable is declared, rather than \nat the moment of the theft itself. The alternative opportunistic model is both better and worse than \nthe original aggressive model. On the benefit- side, programmers may find it more intuitive to define \ncareless local variables, since the focus is already on something temporary. There is now only one kind \nof copy constructor and one kind of assignment operator for each class: the pi1 f er ( ) function is \nnot required, since assignment may be relied upon to steal, on occasion. The assignment operator and \ncopy constructor are provided as usual (apart from the non-const reference argument) for the abstract \ndata types like Set, taking memberwise copies of their elements. For the storage managers like Array, \nthey must either copy or steal, depending on the state of the lock. On the down-side, the locking mechanism \nis a little intrusive, but still habitable. A class may have to provide several careless constructors, \none for each way in which local variables are typically initialized. In Figure 11, Set requires two different \ncureless constructors. There may be objections to allowing non-const arguments to be passed to assignment \nor copy construction. This can be worked around by explicitly casting the argument to a non-cons t reference \ninside operator= and the copy constructor, just prior to the theft taking place (see section 6.3 for \nfurther discussions). A final consideration is that constructive functions must return normally (see \nbottom of Figure ll), rather than carelessly-construct the return value, since we can make no assumptions \nabout whether the return buffer is a normal or temporary variable. In this case, we should prefer copy-initialization \nover assignment (see section 3.3) to the receiving variable at the call-site. 5.3 Encapsulation and Extensibility \nof Larceny Perhaps the only possible objection to larceny is the fact that it is the one memory-management \nstrategy out of the four discussed here (copying, prohibition, borrowing and larceny) in which the client \n(the thief) takes on responsibility for memory management issues in the server (the victim). Objects \nshould typically supervise their own memory resources. Trivially, we can answer such an objection by \nrecasting larceny as a kind of transfer-of- ownership pattern [Carg96, Lea96]. For the aggressive larceny \npattern, instead of pi1 fer ( ) , we could easily have had something like: thief.take(victim.give()); \n in which the victim is clearly responsible for yielding up its heap resources. In practice, provision \nof an explicit give ( ) function makes the victim no more or less vulnerable to takeover than with pi \n1 f er ( ) : it is as easy and as likely that a client of the victim with suitable access rights could \ninvoke give ( ) , to make it yield its resources, as it is that a thief might invoke pilfer ( ) . With \nopportunistic larceny, it is in any case the victim which dictates how its resources are to be transferred \nor copied. Nonetheless, it is clear that larceny should be regulated. In our own C++ libraries, we have \nadopted a more subtle three-level architecture based on the Bridge pattern [GH.JV95] than the two-level \narchitecture used here for expository purposes. At the lowest level are the memory- block classes, which \noffer the ability to reserve ( ) , free ( ) and pi 1 f er ( ) memory. These functions are all public. \nAt the next (middle) level are container-classes, which are parameterised by the element and memory-block \ntypes. These classes may invoke pilfer-functions on their memory blocks. They also provide private or \nprotected pilfer-constructors which they use internally in their constructive operations, such as concatenate \n( ) . Already at this level, it is impossible for clients of the containers to dictate memory management \npolicy, since they do not see the memory-block types directly. At the third (top) level are abstract \ndata types, such as Set and Vector, which are parameterised by the element and the container types. So \nit is clear that pi 1 f er ( ) is properly- encapsulated and only available to containers in the middle \nlayer. We envisage that larceny should be used carefully, by high-performance library designers rather \nthan by applications programmers. While the intended correct usage of pilfer functions and constructors \nis clear, and the suitable identification of temporary local variables (for pilfering, or for cureless \nconstruction) is equally clear, many managers would nonetheless wish to hide this ievel of detail from \ntheir front-line programmers. As with borrowing, we are keen to make larceny behave well under inheritance. \nIn the aggressive model, the pilfer ( ) function is fully extensible in subclasses. Like assignment, \nit is always called statically, and it is redefined whenever it must acquire new data members. It may \nbe redefined to steal more than one heap structure in classes introducing further dynamic memory blocks. \nThe redefined versions should always invoke the base versions first to keep the thief and victim up to \ndate. The pilfer- constructor must be redefined in every new subclass with constructive functions, even \nif no new data members are introduced. This is so that the constructive functions can terminate with \na call to a constructor of the correct type (see section 6.1 and Figure 12 for an example). Where a redefined \npilfer-constructor is only used to retype the result, it may call the base-class pilfer-constructor inline, \nso no extra overhead is incurred. Naturally, a pilfer-constructor is still responsible for shallow-copying \nthe book-keeping variables, and any new data members. In the opportunistic model, the copy-or-steal constructor \nand assignment operator are both always called statically. They are always redefined in derived classes, \nfor typing reasons. Derived constructors may call base constructors. It is beneficial to factor out the \ncore copy-or-steal body from assignment into an auxiliary function which can be called once by all the \nretyped versions (cf the Borrower assign ( ) pattern, Figure 6). This function can be redefined and extended \nif further dynamic memory blocks are introduced. The one lock variable may be used to determine copying, \nor transfer of all dynamic resources. The cureless constructors of a derived class should each call one \ncureless constructor in the base class, to ensure that unlocking requests are sent to the base representation \nobjects. Again, where cureless constructors are simply repeated for typing reasons, they may call the \ncorresponding base versions inline. 6 Evaluation and Comparisons Larceny has clear cost advantages over \nborrowing, in most cases. This is because object-oriented programs typically work with unique objects \nmost of the time and copy them occasionally. Larceny ensures that OCF-conformant copying is at minimal \ncost and immediately gives a new object for whch mutating operations incur no further overhead. On the \nother hand, borrowing assumes that an object will be more frequently passed around (viz. secretly be \nshared), but may need to grant unique ownership occasionally (viz. be copied). The cost of detecting \nthis is perhaps most useful where it is anticipated that large charged against mutating operations. For \nborrowing with structures will be shared, mostly for access. For the the monolithic and doubly-linked \npolylithic structures, any singly-linked polylithic structures, borrowing may mutating operation will \nin any case trigger a complete sometimes prove more cost-effective than larceny, copy. It would be more \ncost-effective to copy the structure especially if only small parts of large structures are first and \nnot have the mutator overhead. Borrowing is impacted by mutating changes. #include <string.h> class \nString { public: String operator+(const String&#38;) const; // constructive concatenation . . . // other \noperations as per Figure4 protected: String&#38; operator+=(const String&#38;); // secret mutator concatenation \nenum Pilfer { STEAL }; // pilfer type and flag String(String&#38;, Pilfer); // pilfer constructor private: \nint -size; // string length char* -block; // memory storage area 1; // . . . most operations omitted \nfor brevity // Optimal string concatenation, secret mutator version String&#38; String::operator += \n(const String&#38; str) 1: -size += str.-size; char* newblock = new char [-size + 11; strcpy(newblock, \n-block); strcat(newblock, str.-block); delete -block; -block = newblock; 1 // Public constructive concatenation, \nuses secret mutator and larceny String String::operator + (const String&#38; str) const t String result \n(*this); // local copy of the current String result += str; // destructively append argument String \nreturn String(result, STEAL); // larceny -transfer String result 1 // Derived class now takes full advantage \nof inherited operations class RString : public String ( public: RString&#38; reverse(); // in-place \nreverse (a token extra operation) RString operator+(const RString&#38;) const; // constructive concatenation \nOK! . . // other public functions omitted protected: RString(RString&#38;, Pilfer); // pilfer constructor \n>; // Redefined pilfer function -inline base version inline RString::RString(RString&#38; str, Pilfer \np) : String(str, p) {} // Redefine constructive version. All String code is reused here, without // \nany excess copying. Use same strategy as before: RString RString:: operator + (const RString&#38; str) \nconst I RString result (*this); // local copy of the current RString result += str; // mutate result, \nusing String method return RString(result, STEAL); // larceny -transfer RString result Figure 12: Constructive \nfunctions used with inheritance 80 These are the theoretical differences, which tend to favour larceny. \nNaturally, other measures may help to give a more complete appreciation. Below we consider both the benefits \nof the more natural programming styles enabled by larceny; and also some performance data from a working \nprogram that makes heavy use of library collection classes. 6.1 Constructive Functions under Inheritance \nTo illustrate the new expressiveness afforded by larceny to C++, we developed a new solution to the problem \nof combining constructive functions with inheritance in value-oriented classes. Constructive operations \nand inheritance tend to be mutually exclusive in C++ [Lea93]. Lea cites an example of a value-oriented \nString, with a constructive operator+ method to concatenate Strings. A subclass, RString, is defined \nwith an extra in-place reverse ( ) operation. The following: RString t, u;RString s = t + U; // type \nclash typically leads to a type error, since t+u returns a String, not a RString. Various work-arounds, \nsuch as overloading a specific version of operator+ for RString, or providing a constructor RString (const \nString&#38;) to convert the result, are not usually satisfactory, since they either duplicate the behaviour \nof String's concatenating function, or they copy Strings unecessarily. Our new solution, illustrated \nin Figure 12, combines secret use of a mutator operator+= and pilfer-construction to deliver cheap, redefinable \nconstructive operations. The base String class implements operator+=, an optimal version of concatenation \n(cf Figure 4), which modifies the invoking String. This function is declared protected, so that it can \nbe used internally by String and any of its descendants, such as RString. Both these classes then provide \na public constructive concatenator, operator+, which is retyped in the derived class. However, the derived \nversion uses the same secret mutating concatenator as the base version, to modify a local copy of the \ninvoking object. In the return expression, pilfer-construction is used to transfer the contents of the \ntemporary local object to a variable of the appropriate base or derived type, at the call- site. Note \nin particular how the pilfer-constructor for RString simply retypes the base String piljer-constructor, \nand may be inlined, as shown. This makes it much easier to define subclasses of value-oriented types \nwhich only add new operations to the base class, as here. Note that this is not a problem in some other \nlanguages, like Eiffel, which provides the like Current adaptive typing mechanism, nor in Smalltalk, \nwhich provides the self class new dynamic creation mechanism. Where derived classes also add new data \nmembers, it is relatively easy to extend the secret mutator-function to handle the extra data. The redefined \nconstructive function will simply call the new mutator and the pilfer-constructors will work as before. \nThe leverage provided by larceny, therefore, is to allow redefinition of constructive methods without \nincurring the penalty of excess copying. 6.2 Performance Evaluation of Larceny Just how much performance \nimprovement can one expect from larceny? This depends very much on how astute the C++ programmer already \nis in recognising situations that lead to excess copying. Many seasoned programmers have become habituated \nto the defensive style of passing by reference and using mutator forms: x+=y, p*=q; rather than the constructive \nforms: x=x+y , p=p*q. Larceny allows the client programmer to be much less self- consciously aware of \nthe copying behaviour of programs, since it eliminates needless extra copying. We tested this theory \non a 1KLOC piece of in-house code that is used for test-set generation, based on finite state machine \nmodels and state transition functions. The program generates a set of test cases T, whose magnitude is \ncalculated according to the formula: T = C*({ 1) u D u a* . . . u @ + )*W, where C is the state cover, \na set containing sequences of transitions, such that we can find a sequence from C to reach any desired \nstate from the starting state; CD is the total set of state transition functions; and W is the characterisation \nset, roughly a set of values used to verify that the state reached is in fact the one we think it is. \nThe exponent n relates to all paths of length n traversed from some starting state. The program generates \ntransition sequences which are subsequently replaced by expected input/output pairs, which are then saved, \nsuppressing sequences of pairs which are prefixes of other sequences. Typical runs generate T-sizes from \njust over 10K to just under 500K test values. The main abstract data types used in this program are Set \nand Sequence. Some 22 public operations involve these collections. In the latest version of the code, \nthe programmer had been very careful to revise an earlier version, inserting many work-arounds to avoid \ncopying collections and replacing constructive operations by mutators. In the earlier version, 7 of the \n22 operations had been constructive set unions, natural expressions of the formula. The time-penalty \nfor this had been about 40-fold: 12 sec. versus 0.3 sec. in the hand-optimised version, on a small test \nrun. This large difference was due in part to the critical code occurring in an inner loop. The use ofpilfer-constructors \nhere would eliminate 2 deep copies in every 3. Constructive set union would also be better able to estimate \nthe capacity of the resulting Set and so, if larceny were also employed, would be no more costly than \nmutative union, which typically resized the invoking Set. Another characteristic of this program is \nthe fact that an unpredetermined number of collections are created, which may vary in size in unpredictable \nways. In the hand-optimised version, all initial Set sizes had had to be fixed at very large values, \nan inflexible use of memory which prevented the generation of test sets for some pathological systems \nwhich required mostly small Sets and some enormous ones, which could not then be allocated. In the pre-optimised, \nmore flexible version, some containers had resized themselves 6 to 10 times (by doubling in capacity). \nThe use of pilfer-functions here would eliminate one deep copy in every two, halving the cost of dynamic \nresizing. 6.3 Conclusions Faced with the choice between: borrow, copy or steal policies for heap memory \nmanagement in C++, this paper recommends larceny as the best policy for all monolithic and (at least) \nfor the doubly-linked polylithic data types; and suggests considering the smart-cell variant of borrowing \nas a policy for the singly-linked polylithic datatypes. Without adopting one of these, section 3 showed \nhow block copying is otherwise unavoidable and then sometimes very costly for the monolithic managers. \nSections 4 and 5 showed how, although borrowing and larceny both achieve the desired minimum copying \ngoals set in section 3, the overhead of borrowing is greater in comparison with larceny. Nonetheless, \nsmart-cell borrowing should be considered for the singly-linked polylithic memory managers, because this \nis the policy which explicitly allows the (intended) sharing of substructure while preserving value semantics. \nSection 2 described the importance of maintaining a consistent semantics across the data structures in \na library; and how the ascendance of the STL has renewed the importance of OCF and value-semantics. In \nthis case, it is important that both mono-and polylithic data structures have copy and assignment operations \nwith value semantics. In section 4, we showed borrowing to be a particular adaptation of copy-on-write \nwhich only shares expensive heap resources, rather than whole data structures; and implemented this using \na single abstract base class, rather than a dual hierarchy of handle/representation pairs. A different \nsmart-cell borrowing idiom is able to duplicate only those parts of a shared polylithic structure that \nare impacted by change. In particular, where parts of the connected structure have a single owner, this \nmay be mutated, unlike the total copying, or leading-cell copying behaviour found in other approaches. \nWe presented two models for larceny in section 5. Aggressive larceny is perhaps the cleanest and most \ndirect form of theft, which adds pilfer-functions and constructors to the canon of OCF-required operations. \nOpportunistic larceny is a more subtle alternative, which is also slightly more intrusive. Lately, we \nfound out that opportunistic assignment is close to the CD-2 proposal for the standard C++ auto_ptr [Colv98]: \nthe difference is that CD-2 does not destroy the argument to assignment, but rather secretly marks the \npointer as unavailable to further clients, in deference to those who did not like mutating a cons t-argument. \nAccording to Greg Colvin (personal communication), the committee has now reverted to the earlier CD-l \nproposal, in which non-const arguments are passed to assignment, and these do yield up their data. Elsewere, \nlarceny is different from the auto_ptr proposals, in that it employs a combined pattern of pilfer- functions \nand constructors, used in different abstraction layers in a library of OCF-coformant data types. As a \ndemonstration of its usefulness, we showed how larceny could be used to provide constructive operations \nunder inheritance, something previously considered difficult, if not impossible, in C++ [Lea93]. We emphasise, \nfinally, that the memory management techniques described here are really intended for use by designers \nof high-performance libraries, rather than by client programmers. In the borrowing framework, the designer \nmust supply copy ( ) and free ( ) in borrowing descendants and must remember to invoke deepen ( 1 in \nevery mutator. In the larceny framework, the designer must be aware of which local variables are temporary \nand therefore suitable victims for theft. We described in some detail how both these policies were amenable \nto extension via inheritance. All of the techniques described may be encapsulated at the representation-level, \nthat is, in the containers which are used to implement abstract data types at the next higher level [Booc94, \nStLe94], following the Bridge pattern [GHJV95]. Acknowledgements Thanks are due to Oscar Nierstrasz, \nDoug Lea, Jim Coplien, Tom Cargill and Greg Colvin for some initial pointers; to Kirill Bogdanov for \nperformance data on the test-set generation program; and to the OOPSLA reviewers for insightful comments \non the first draft. References [Alme97] P S Almeida, Balloon types: controlling sharing of state in data \ntypes , Proc. 11th European Con6 Object-Oriented Prog. (1997), Springer Verlag, 32-59. [Booc94] G Booth, \nFrameworks , chapter 9 in: Object- Oriented Analysis and Design with Applications, 2nd edn. (1994), Benjamin-Cummings. \n[BrLo97] [CABD94] FW961 [Colv98] [Cope921 [GHJV95] [GOP901 [HLHW92] [Hog@11 [Hors951 [Lea 931 M Brain \nand L Lovette, Developing Professional Applications for Windows 95 and NT using MFC (1997), Prentice \nHall. D Coleman, P Arnold, S Bodoff, C Dollin, H Gilchrist, F Heyes and P Jeremaes, Object- Oriented \nDevelopment: The Fusion Method (1994), Prentice Hall. T Cargill, Localised ownership: managing dynamic \nobjects , in [VCK96] (1996), part 1, chapter 1. G Colvin, Why is auto-ptr defined the way it is? , The \ncomp.std.c++ FAQ, question C2, http://reality.sgi.com/austern-mti/std-c++-/faq.html, 13 May (1998). J \nCoplien, Advanced C++ Programming Styles and Idioms (1992), Addison-Wesley. E Gamma, R Helm, R Johnson \nand .I Vlissides, Design Patterns: Elements of Reusable Object-Oriented Software (1995), Addison Wesley. \nK Gorlen, S Orlow and P Plexico, Data Abstraction and Object-Oriented Programming in C++ (1990), John \nWiley. J Hogg, D Lea, R Holt, A Wills and D de Champeaux, The Geneva Convention on the treatment of object \naliasing , OOPS Messenger, April (1992). J Hogg, Islands: aliasing protection in object-oriented languages \n, Proc. 6th ACM Conf Object-Oriented Prog., Sys., Lang. and Appl., SigPlan Notices 26(10) (1991). C S \nHorstmann, Mastering Object-Oriented Design in C+ + (1995) Wiley. D Lea, The GNU C++ Library , C++ Report, \nJune (1993); reprinted in [Lipp96]; revised as: http://gee.cs.oswego.edufdVlibg++paper/ libg++/libg++.html, \n(1995). [Lea961 [LippW [Meye92] [Mins96] [Rati93] [Rogu95] [SaCa96] [SBGL91] [Stee86] [StLe94] [Stro91] \n[VCK96] [Wild961 D Lea, Concurrent Programming in Java -Design Principles and Patterns (1996), Addison \nWesley. S Lippman (ed), C++ Gems (1996), SIGS Books. S Meyers, Effective C++: 50 Specific Ways to Improve \nYour Programs and Designs (1992), Addison-Wesley. N Minsky, Towards alias-free pointers , Proc. 10th \nEuropean Conf Object-Oriented Prog. (1996), Springer Verlag, 189-209 Rational, C++ Booth Components Class \nCatalog, version 2.3 (1993), Rational. Rogue Wave, Tools.h++ Foundation Class Library for C++ Programming, \nversion 6 (1995), Rogue Wave Software, Inc. A Sane and R Campbell, Resource exchanger: a behavioural \npattern for low-overhead concurrent resource management , in [VCK96] (1996), part 7, chapter 8. R Strom, \nD Bacon, A Goldberg, A Lowry, D Yellin and S Yemini, Hermes: a Language for Distributed Computing (1991), \nPrentice Hall. G L Steele, The Common Lisp Reference Manual (1986), Digital Press. A Stepanov and M Lee, \nThe standard template library , Technical Report, Hewlett-Packard Laboratories, May (1994). B Stroustrup, \nThe C++ Programming Language, 2nd edn, Addison-Wesley. J Vlissides, J Coplien and N Kerth (eds.), Pattern \nLanguages of Program Design, 2 (1996), Addison-Wesley. F Wild, Instantiating code patterns , Dr Dobb \ns Journal, June (1996), 72.  \n\t\t\t", "proc_id": "286936", "abstract": "Dynamic memory management in C++ is complex, especially across the boundaries of library abstract data types. C++ libraries designed in the orthodox canonical form (OCF) alleviate some of the problems by ensuring that classes which manage any kind of heap structures faithfully copy and delete these. However, in certain common circumstances, OCF heap structures are wastefully copied multiple times. General reference counting is not an option in OCF, since a shared body violates the intended value semantics; although a copy-on-write policy can be made to work with borrowed heap structures. A simpler ownership policy, based on larceny, allows low-level memory manager objects to steal heap structures from temporary variables, in properly isolated circumstances. Various strategies for regulating theft are presented, ranging from pilfer-constructors to locks on heap data. Larceny has similarities with other transfer of ownership patterns, but is more a core implementation technique designed to improve the efficiency and effectiveness of OCF-conformant libraries.", "authors": [{"name": "Anthony J. H. Simons", "author_profile_id": "81100599907", "affiliation": "Department of Computer Science, University of Sheffield, Regent Court, 211 Portobello Street, Sheffield, S1 4DP UK", "person_id": "P20524", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/286936.286948", "year": "1998", "article_id": "286948", "conference": "OOPSLA", "title": "Borrow, copy or steal?: loans and larceny in the orthodox canonical form", "url": "http://dl.acm.org/citation.cfm?id=286948"}