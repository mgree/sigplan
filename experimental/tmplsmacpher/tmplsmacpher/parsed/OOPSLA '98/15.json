{"article_publication_date": "10-01-1998", "fulltext": "\n Compatible Genericity with Run-time Types for the Java TM Programming Language Robert Cartwright: Rice \nlJniversity* Guy L. Steele Jr., Sun Microsystems Laboratories Abstract The most serious impediment to \nwriting substantial programs in the JavaTM programming language is the lack of a gentr-icity mechanism \nfor abstracting classes and methods with re-spect to type. During the past two years. several research \ngroups have developed Java extensions that support various forms of genericity, but none has succeeded \nin accommodat-ing general type parameterization (akin to Java arrays) while retaining compatibility with \nthe existing .Java Virtual Ma-chine. In this paper, we explain how to support general type parameterization-including \nboth non-variant and covariant subtyping---on top of the existing Java Virtual Machine at the cost of \na larger code footprint and the forwarding of some method calls involving parameterized classes and methods. \nOur language extension is forward and backward compatible with the Java 1.2 language and run-time environment: \npro-grams in the extended language will run on existing Java 1.2 virtual machines (relying only on the \nunparameterized Java core libraries) and all existing Java 1.2 programs have the same binary representation \nand semantics (behavior) in the extended language. 1 Introduction The JavaTM Programming Language (hereafter \ncalled sim-ply Java) has achieved widespread commercial acceptance because it supports a truly portable \nobject-oriented program-ming model with safe program execution. yet it has a familiar syntax similar \nto that of C++. Nevertheless. Java has some significant limitations from the perspective of software \nengi-neering that could be eliminated by judicious language exten-sions. Ironically. Java s portable \nprogramming model makes refining the language more difficult because it imposes severe constraints on \nthe implementation of language extensions. In our experience, the most serious impediment to writing \nsubstantial programs in Java is the lack of a mechanism for abstracting classes and methods with respect \nto type. Type *This research was primarily conducted while this author on sabbat-ical at Sun Microsystems \nLaboratones. Partial support was provided by NSF grants CDA-9414170 and CCR-9633746 and by Texas ATP \ngrant 003604-006. Permlsslon to make digital or hard copes of all or part of this work for personal or \nclassroom use IS granted without fee provided that cop~?s are not made or distributed for proflt or commercial \nadvan-tage and that cope?s bear this notice and the full citation on the first page. To copy otherww. \nto republish, to post on servew or to redtstrlbute to IIsts, requwes prior specifkc permisslon and/or \na lee. OOPSLA 98 lo/98 Vancouver, B.C. 0 1998 ACM 1.59113-00%8/98/0010.,,$5.00 parameterization can be \nsimulated in Java by using the un-versa1 reference type Object in place of type parameters and explicitly \ncasting values of type Object to their intended types. But this coding idiom is clumsy and error prone \nbecause the required casts are tedious to write and largely defeat the error-detection properties of \nJava s static typing discipline. During the past two years. several research groups have investigated \nthe problem of extending Java to support the pa-rameterization of classes and methods by type. Odersky \nand Wadler have designed and implemented an ambitious exten-sion of Java called Pizza [OW97] that supports \nparameterized class and methods. as well as algebraic data types and first-class closures-while retaining \ncompatibility with the exist-ing .Java Virtual Machine. Myers. Bank, and Liskov have designed and implemented \nan extension of Java called PolyJ [MBL97] supporting parameterized classes that relies on an extension \nof the Java Virtual Machine. Agesen. Freund. and Mitchell have designed an extension of .Java [AFM97] \nsup-porting parameterized classes assuming a revision of the class loader and an extension of the class \nfile format to support parameterized class files. Thorup and Torgersen have pro-posed extending Java \nto support virtual types [ Tho97,Tor98]. which accommodates class specialization by narrowing vir-tual \ntype members of classes. Among these proposals. only those of Odersky-Wadler and Thorup-Torgersen require \nno change to the existing .Java Vir- tual Machine. Moreover. only the Odersky-Wadler proposal has addressed \nthe issue of forward and backward compatibil-ity with the JVM standard libraries. For this reason. Gilad \nBracha and David Stoutamire from .JavaSoft are collaborat-ing with Odersky and Wadler on the definition \nand imple-mentation of a derivative of Pizza called GJ [BOSWYX]. III contrast to Pizza. GJ adds only \ntype parameterization to Java. To ensure compatibility with the existing Java lan-guage design and software \nbase, GJ is designed to satisfy the following ambitious design objectives: l a simple, easily-understood \nsemantic definition consis-tent with the existing language definition: l complete forward and backward \ncompatibility of Java Virtual Machine code including: efficient implementation of extended language without \nchanging the .Java Virtual Machine (JVM); compatibility of new parameterizecl code with the unparameterized \nJava 1.2 Core Libraries: and - compatibility of unparameterized Java 1.2 code with new parameterized \nversions of standard Java libraries: and . avoidance of name mangling. G.J adroitly achieves these objectives \nusing a technique called type maswq which is explained in detail in Section 2. In essence, type erasure \nconverts all occurrences of type pa-rameters in program text to the universal type Object. In this way \nall the instantiations of a given parameterized class such as Vector(T) are collapsed onto a single class \nVector(Object) which is identical to an unparameterized Vector class intended to support the generic \nroding idiom. In this way: GJ trans-forms Java with type parameterization into ordinary Java. As part \nof the type erasure transformation, GJ inserts the casts required to recover the erased type information \nwherever it is needed in the transformed program text. The primary disadvantage of type erasure is that \nit cannot support type dependent primitive operations such as instanceof Vector(lnteger) newT(...) new \nT[. .]  where T is a type parameter. Since objects of parametric type (other than built-in arrays) do \nnot carry any type information at run-time, GJ prohibits primitive operations that depend on this information \nwith one notable exception: to accommo-date the parametric generalization of existing library classes: \nGJ provisionally supports the operation new T[. .] by trans-lating it to new Object[. . .]. which is \ninconsistent with para-metric type-checking. GJ generates an explicit unchecked : warning message whenever \nit encounters such an operation. This anomaly in GJ is inescapable in any parameterization scheme that \nrelies on type erasure because Java arrays carry their element type at run-time, enabling Java to support \ndy-namically type-checked array updates, parametric instanceof tests and type casts on arrays. In addition, \nthe Java type system forces array assignments to be type-correct. implying that an array value of type \nObject[ ] cannot be assigned to a variable of type Integer[ 1. As a result. an apparently type-correct \nGJ program can generate a run-time error. Consider a parametric class C(T) with a field T[ ] x; that \nis initialized by an operation new T[. . .] (generating an unchecked : warn-ing message). If the variable \na has type Integer[ 1: and b is an object of type C(lnteger), then the assignment a = b.x will generate \na run-time type error because the erased type of b.x is Object[ ] not Integer[ 1. In this paper. we propose \na more general parametric ex-tension of Java than GJ: dubbed NextGen, that is a strict superset of the \ntype-sound portion of GJ with the exception of reflection (which reveals the presence of class instantia-tions) \nand the treatment of static fields as discussed below. Like GJ. NextGen is a conservative extension of \nJava without reflection and ensures full forward and backward compatibil-ity with the JVM. NextGen differs \nfrom GJ in four respects: Parametric type expressions-including those contain-ing type variables-can \nbe used anywhtw that conut n-tional types arc used. Hence. new operations. casting operations. and instanceof \noperations can be paramet-ric. They can even contain type variables. The use of the operation new T[. \n.] in parameterized classes is discouraged in GJ the workaround of allocating the array at thy point \nof <call (where the bindmg of T is known) IS generally preferred 2The meaning of cxistlng Java source \nprograms that do not use the reflection API 1s unaffected. Type variables can be declared as non-variant \nor covariant . Different type checking rules apply in each case (as discussed below). Both non-variant \nand covar-iant type variables can have a declared upper bound. Bounds may be parametric and may include \ntype vari-ables (declared as class parameters). If no bound is declared: the default upper bound type \nis Object. St atic members (in&#38;ding static inner classes) behave by default as if they are replicated \nin every instantiation of a parametric class: this interpretation is dictated by the simple semantic \nmodel for NextGen described be-low. In GJ: static members are shared across all instan-tiations of a \nclass because GJ implements the various instantiations using a single run-time class. Next&#38;n supports \nboth shared and replicated static variables. We discuss this issue in Section 4. NextGen is always type-sound \nwith respect to paramet-ric type declarations. GJ is type-sound except for the problematic operation \nnew T[. . .] (where T is a type pa-rameter) which generates an unchecked warning mes-sage. Programs that \ncontain this operation can gener-ate run-time type errors even though they are type-correct according \nconventional parametric type check-ing rules. NextGen extends Java to the point where it has essentially \nthe same type parameterization facilities as Eiffel [Mey92] without compromising Java s static typing \ndiscipline. 2 Overview of NextGen The syntax of type parameterization in NextGen is a minor extension \nof that for GJ. which is loosely based on the syn-tax of templates in C++. A parameterized class (interface) \ndefinition has exactly the same form as a conventional class (interface) definition in Java except for \nthe insertion of a list of type variable declarations enclosed in pointy brackets (. .) and separated \nby commas. Each type variable declara-tion may be of the form Identifier or Identifier extends ClassOrInterjaceTypt- \nThe latter form specifies an upper bound on the binding of the type variable. The upper bound is any \nJava type ex-pression. possibly including the type variables introduced in this definition. The scope \nof a type variable introduced in a class definition is the entire text of that class definition. If the \noptional bounds clause in a type variable declaration is omitted. the default upper bound is type Object. \nIn NextGen, a parametric class (or interface) instantia-tion C:(To.. .) may appear anywhere that a simple \nclass (or interface) name C may appear. A type variable may appear anywhere that a simple class (or interface) \nname may appear ezcqt as the direct supertype in an extends or implements clause of a. class or interface \ndeclaration. (However. a type variable may appear as the bound in an extends clause fol another type \nvariable.) 3The s~mantic definition of NextGen can easily be extended to 111. elude contravariant type \nvariables. but the extension is difficult to SLIP port efficiently OH top of the existing JVM. See footnote \n6 Vector /or{ E) Stack{ E) @Stack(E) Figure 1: A Simple Parametric Type Hierarchy and its JVM Class \n--~ .- A simple example of a parameterized the following parametric generalization class in the library \njava.util: public class Vector(T){ private T[ ] elts; public Vector(int hitcapacity) { elts = new T[initCapacity]; \n1 public T elementAt(int index) { return elts[index]; > class definition is of the familiar Vector public \nvoid setElementAt(T newvalue: int index) { elts[index] = newvalue; 1 . .  Note that the type variable \nmethods and the allocation Clients of the parameterized and allocate objects of type T is used in the \ntype signatures of of the array representing a vector. Vector class can declare variables Vector(E) for \nany reference type E. as well as performing instanceof operations and casts for any type expression \nVector(E). We will discuss the syntax of parameterized method def- initions and some additional annotations \navailable in class definitions later in the paper. The semantics of a parameterized class (interface) \ndefi-nition is completely explained schematically: a parameter-ized definition abbreviates all possible \ninstantiations of the type variables by fully qualified ground (no type variables) types. Even instantiations \ninvolving inaccessible package private types are included in this expansion because inacces-sible types \ncan become indirectly accessible if they are bound to type variables. Of course: all of the ground types \nappear-ing in parametric type constructions must satisfy the bounds specified in the definition of the \nparametric type. In program text, parametric type expressions are composed from bound type variables \nand accessible parametric and non-parametric type names. The meaning of any such reference is simply \nthe fully qualified ground type obtained by replacing each type variable by its binding expressed as \na fully qualified ground type. The meaning of type casts and instanceof checks is determined by the type \nspecified by the subtyping initions (including the ters). Like GJ and Pizza, Representation - inclusion \ngraph (a directed graph) relationships declared in class def-variance attributes of type parame- NextGen \nuses a simple set of type- checking rules implied by F-bounded polymorphism [CCH+]. This static typing \ndiscipline dictates some syntactic restric-tions on the form of parameterized classes with covariant \ntype variables.4 These restrictions are discussed in Section 6. The primary costs of supporting this \nextension of Java are a modest restriction on the structure of Java programming environments and the \ncode databases that they manage. In addition, NextGen generates some mangled names to repre-sent run-time \ntype information. similar to those used in the implementation of inner classes. JVM implementations are \nnot affected. 3 Basic Implementation Strategy If we could completely redesign the JVM to support parame-terized \ntypes, we would extend the run-time representation of classes (the class Class) to support parameterized \nclasses just as existing JVM supports arrays. While we would welcome the opportunity to extend the JVM: \nwe can support a simi- lar implementation of parameterized types without changing the JVM. Instead of \nrelying on an enhanced JVM: we can require the compiler for NextGen to generate a lightweight wrapper \nclass and interface for each instantiation of pa-rameterized class used in a compilation unit. The wrapper \nclass inherits type-erased methods from an abstract base class that is constructed from the parameterized \nclass defini-tion using type erasure. In essence. the wrapper class for each parametric class instantiation \ncarries the type information fo1 the instantiation. Parameterized interfaces are supported in a similar \nfash-ion. For each parameterized interface definition, the NextGen compiler generates a base interface \nusing type erasure and a 4Similar restrictions are required to support contravariant type variables. \ncorresponding wrapper interface (extending the base inter-face) for each instantiation appearing in a \ncompilation unit. The wrapper interfaces do not introduce any new abstract methods. The NextGen compiler \nmust generate both a class and an interface for each parametric class instantiation because every Java \nclass has at most one superclass. When one parameter-ized class extends another. e,g. Stack(T) extends \nVector(T). each instantiation Stack(E) of the parameterized subclass has two supertypes: its base class \nStack. from which it inherits nearly all of its members, and the corresponding instantiation Vector(E) \nof the parameterized superclass. We use the inter-face corresponding to a wrapper class to represent \nthe type of the wrapper class. As a result. a wrapper class $$Stack(E) can extend its base class Stack \nand implement its own interface which implements the interface for the corresponding super wrapper class \n$$Vector(E). In the resulting type hierarchy. the class Stack(E) is a subclass of the base class Stack \nand a sub- type of the interfaces for both Stack(E) and Vector(E). Figure 1 illustrates the JVM class \nhierarchy produced by NextGen for this example. Given a parameterized class C( 2 0,. .) in a package \nP. the Next Gen compiler generates a type-erased base class C in P extending (the base class of) the \n(parameterized) super-type of C(T0,. .). All the attributes for each member of C(Z o.. ..) are preserved \nin the base class. Static members must be treated specially as described in Section 2.2. For each instantiation \nC(&#38;:. .) of the parametric class C(T,. .): the compiler generat es . an empty vrrapper interface \n$C(Ao.. .) (with the same visibility attributes as the parametric class C(To.. .)) extending the wrapper \ninterfaces of the immediate SKI-pertypes of C(To,. .):G a wrapper class %%C(Ao.. .) extending the base \nclass C and implementing the corresponding wrapper interface $C(Ao.. .). If typd variables do not occur \nin method bodies. the wrap-per class $$C(Aa.. . .) contains only forwarding (also called trampoline ) \nconstructors (with erased signatures) that in-voke the corresponding constructors from the base class \nusing a superclass constructor call. (Since base class constructors must be accessible in wrapper classes! \nthey must not be pri-vate.) This translation augments the homogeneous transla-tion of Pizza and GJ by \nusing wrapper classes and interfaces to provide run-time type information. Like Pizza and GJ. NextGen \ninserts casts where necessary to inform the Java Virtual Machine about the bindings of type variables. \nNextGen supports the USC of run-time type dependent op-erations in a method body by replacing each such \noperation by a call on a generated auxiliary method that can be appro-priately overridden in each wrapper \nclass. To construct the base class for a parametric class. the compiler performs type erasure and extracts \neach atomic operation involving a type 5To support forward and backward compatibility with Java 1.2 li-braries. \nNextGen uses a slightly dlfferent process to construct the base classes for parametric generalizations \nof standard library classes in java. This process LS described m Section 2.8. NextGen excludes contravariant \nparameterization because sepa-rate class compilation and dynamic class loading make it impossible to \ndetermine all of the supertypes of a contravariant instantratloll At the point where a contravariant \nwrapper Interface is loaded. the collec-tlon of supertypes IS unknown With JVM revision. this problem \ncan easily be solved In particular. the set of supertypes of a contravarlant parametric type can be dynamically \nexpanded as rhry are loaded. variable (a new operation. cast, instanceof test. or polymor-phic method \ninvocation) and encapsulates it in a protect.4 method (with a mangled name) called a snippet. In the \nbase class. all snippets are abstract. Each wrapper class overridrs the abstract snippets in the base \nclass with specialized code to perform the appropriate type dependent operation. NextGen places generated \nwrapper classes and interfaces in the same package P as the definition of the parametric class G(To.. \n.). This placement convention prevents the duplica-tion of wrapper classes and interfaces. while giving \nwrapper classes access to package-private types and methods. The form of wrapper classes is complicated \nby the fact that a type argument 6, in a parametric instantiation C(&#38;. .) may he restricted to some \nother package. In this case. the generated wrapper class W cannot directly perform snippet operations \nsuch as new E,(. .) because the type Ii, is not accessible in P. We overcome this problem by hav-ing \neach client class D containing an instantiation C(Eo.. .) explicitly pass a snippet environmentobject \ncontaining the in-accessible snippet operations as part of class initialization for D. The affected snippet \nmethods in the wrapper class simply forward their calls to the corresponding methods in the snip-pet \nenvironment. Note that a wrapper class may instantiate parametric classes using its inaccessible type \narguments. In this case: the static initialization block for the wrapper class must pass the appropriate \nsnippet environments to the af-fected wrapper classes for which it is a client. Each affected wrapper \nclass must include a special method called $init that accepts the passed snippet environments and assigns \nthem (0 corresponding fields in wrapper objects. To support the independent compilation of client classes. \nthe NrxtGen compiler must attach a Snippet attribute to the base class file for a parametric class C( \nTo : .). (The Java class file format allows compilers to embed arbitrary information within class files \nby attaching attributes to the class file.) This Snippet attribute tells the NextGen compiler (i) how \nto specialize the snippets in forming wrapper classes. (ii) which snippets are inaccessible when type \nvariables are bound to invisible types, and (ii;) what snippets must be passed to other classes by the \nstatic initialization blocks of wrapprl classes. Since this initialization process for the wrapper class \nW is idempotent: it can safely be performed as each client class is loaded.7 3.1 Name Mangling Since \nnames containing pointy brackets are not valid JVM identifiers. NextGen encodes the name C (&#38;: . \n. E,,) as the valid .JVM identifier C$-EO$. .$E~-$ where eo.. t,, are the JVM identifiers encoding the \ntype expressions Eo. : &#38;;,, If an array type E[ ] appears within a type parameter. it is translated \nto array$$-t-B where t is the JVM identifier encod-ing the type expression E. Hence Vector(lnteger[]) \nis encoded as the identifier Vector$xray$$-integer-$-$. 7A simple variation on this Implementation tcchnlque \ncall bt. used to translate Java inner classes to flattened form wthout compromz~-271~tht secumtv o,f \nprivate varzablra from thr encloszng class In the secure translation. each affected private variable \nof type T from the enclosmg class IS allocated on the heap as an array of T of length 1 These arrays \nRR passed as extra arguments to the inner class cow structors just likr the reference to the enclosing \ninstance Since pro-gram text outside the scope of the enclosing class cannot refer to the affected private \nvariables. the translatloll must augnlent the outer class wth factory methods correspondmg to the ,nner \nclass constructors. The factory methods supply the extra parameters to the inner class constructors NrxtC+en \nexplicitly bans the special character $ from ap-pearing in program identifiers. As a result. this translation \nensures that generated mangled names do not collide with program identifiers. In t hc sequel. we use \nmangled namcxs in generated pl.ogr;iln text. but retain the more readable nota-I ion using pointy brackets \neverywhere else.  3.2 A Sample Translation As a simple example of the translation performed by Next-Gen. \nconsider the problem of replacing the rxisting Vector library class by an equivalent class parameterizecl \nby element type. For the sake of brevity. the example does not include all of the methods from the actual \nVector class. For the mo-mcnt, we will ignore lhc 1 ranslation of the unary constructor for Vet-t or. \nThe parameterized class Vector(T) is translated by the Next GelI compiler into a class tile for the following \nbnst class: public abstract class Vector { private Object[ ] elts: public Vector(int initcapacity) { \n // see discussion below i public Object elementAt(int index) ( wturn elts[index]: 1 public void setElementAt(Object \nnewvalue. int index) { elts[index] = newvalue: I // and a snippet --see below 1 augmrutetl by a Signature \nattribute describing the paramrt-ric signature of the class: class Vector(T) { public Vector(int initcapacity): \npublic T elementAt(int index): public void setElementAt(T newvalue. iut, index): I The Next <ien c.ompiler \nuses Ihe Signature attribute to gem crate new wrapper classes and interfaces for instant iations of the \nparamet crized class. For each instantiation Vector(Ao) of the parametc~rized class Vector{ T). the NextGen \nCompiler grncrates class files defining . au empty ?,,r nl~l rinlrrface $Vector(Ao) extending Object \n(since Object is the ouly immediate superclass of $Vector(&#38;) in the parametric type hierarchy) and \nl a wrccp,,rr class $$Vector(&#38;) that extends Vector and in-plrmrnts $Vector( Ao). For examplr. given \nthe class instantiation Vector( Integer). the Next (:cu compiler generat es class files for the following: \npublic interface $Vector$-lnteger$ {] public class $%Vector%Jnteger-$ extends Vector implements $Vector$-lnteger$ \n{ public $$Vector$Jnteger_$(int initcapacity) { super(initCapacity); 1 // and a snippet --see below 1 \n With ihe exception of snippets discussed below. wrapper classes simply inherit all the methods of the \nbase class with-out overriding them and replicate base class constructors ly forwarding constructor calls \nto the base class using super. For example. the wrapper class $%Vector( Integer) inherits the methods \nelementAt and setElementAt and defines forwarding constnlctors corresponding to those in the base class \nVector. (Like Pizza and GJ. Next Gen relics on the compiler and not the I~yte-c-ode verifier to enforce \nmost parametric type con-straints.) We deferred giving the translation of the constructor in the Vector \nbase class above because the constructor invokes an operation that drprnds on the type variable T. To \naccommo-date the specialization of this operation in each wrapper class. the I ranslation must introduce \nan abstract snippet $snip$l foor that allocation operation: public abstract class Vector { public Vector(int \ninitcapacity) { elts = $snip%l(initCapacity): &#38;tract protected final Object[ ] $snip$l(int initcapacity): \n which is subsequently defined in each wrapper class. e.g., public class $$Vector$Jnteger-$ extends Vector \nimplements $Vector$Integer_$ { protected Object[ ] $snip$l(int initcapacity) ( return new Integer[initCapacity]: \nI  3.3 Performance and Optimization The NcxtGen implement ation architecture shollld produce good performance \nacross a wide variety of Java Virtual Ma-chines. The type err1sure process that NextGen uses to con-struct \nbase classes generates essentially the same code for paramcterized classes as the corresponding unparamcterized \ncode written using the generic coding idiom. Pizza has al-rrady drmonstrated that this form of genericity \ndoes not ad-versely affect &#38;Java performanrc. NextGen augments the type erasure model with lightweight \nwrapper interfaces and classes. adding al\\ extra method call in object initialization (invoking the forward&#38; \ning constructor) and increasing the number of class files in a programZ slightly enlarging its code footprint. \nFor most programs. these differences should uot have much effect on program performance except for a \nmodest increase in loacl-time latency. For parametric classes containing tyl>e deperl-dent operations. \nNcxtGen also augments the type erasures modrl with snippets. If the absence of code optimizatioll. each \ntype dependent operation requires an additional dy-namic method call to select the appropriate snippet \ncode. Fortunately. high performance Java Virtual Machines irl-linr most small final methods as part of \neither just-in-time or dynamic compilation of Java byte code. Since snippets are small final methods. \nsnippet call sites that are repeatedly executed will generally be inlined, eliminating nearly all of \nthe overhead produced by snippets. The same inlining opti-mization will also eliminate the extra constructor \ncalls in object initialization.  4 Parametric Type Translation NextGen relies on the process of type \nerasure developed by Odersky and Wadler for Pizza and GJ. GJ is trans-lated to Java 1.2 by type erasure: \nwhich replaces isolated type variables by their upper bounds (typically Object) and translates all parametric \ninstantiations to the corresponding base classes. In any context. where the generated Java code requires \nerased type information for type correctness. GJ in-serts an appropriate cast lo restore the missing \ninformation. For example. in GJ: the hypothetic method (in the parame-terized Vector class shown above) \nint add(Vector(lnteger)v) { int sum = 0: for (int i = 0:i < v.length:i++) sum += v[i].intValue(): 1 \nwould translate to: int add(Vector v) ( int sum = 0: for (int i = 0:i < v.length:i++) sum += ((Integer) \nv[i]).intValue(): ) Parametric type translation in NextGen is similar but more complex because NextGen \nsupports parametric types in cony context: all objects of parametric type carry run-time type information. \nThe first stage of type translation for NextGen mimics type erasure for GJ. NextGen processes the body \nof a class by replacing isolated type variables in method signatures and variable declarations by their \nupper bounds. convert-ing the parametric instantiations appearing in these contexts (method signatures \nand variable declarations) to the corrr-sponding base classes. and inserting casts where erased type \ninformation is required by the enclosing context: Rut this translation is incomplete because (i) type \nvariables can ap pear in executable code. (ii) the state corresponding to static variables must be replicated, \nand (iii) static inner classes have independent extent forcing an independent translation. For the moment: \nlet us ignore static inner classes and static variables. Let us also assume that parametric types embedded \nin executable operations do nol contain type vari-a&#38;s. e.g.. new Stack(NumberX). but not new Stack(T)0 \nwhere T is a type variable. Then there are four contexts that we must consider: 1. Each new operation \ninvolving a parametric type is con-verted to a new operation for the corresponding wrap per class (or \narray of the designated wrapper interfnc~). Hence. new Stack(Number)(25) Type variables not embeddrd \nwithin pararnetnc mstantlations. GJ also erases the parametric type information 111 operations of the \nform new C(&#38;, .): this does not work for Next&#38;n because every object of parametric type must \nbe recognizable as a member of the parametric type. not just a member of the base class type. becomes \nnew $$Stack$NumberS(25) and new Vector( Boolean)[lOO] becomes new $Vector$Boolean-$[lOO]. Each casting \noperation to parametric type is converted to a sequence of two casts: a cast to the corresponding wrapper \ninterface (or array of the appropriate wrap-per interface): followed by a cast to the matching base class. \nI3 Hence. the operation (Vector(lnteger)) x becomes (Vector) ((%Vector$Jnteger$) x) Xld (Stack(Number)[ \n]) x becomes (Stack[ 1) ((%Stack$-Number-$[ 1) x). Each instanceof test involving a parametric type is \ncon- verted to an instanceof test on the corresponding wrap-per interface (or array of wrapper interface). \nHence. instanceof Vector( Boolean) becomes instanceof $Vector$Boolean$. Each parametric class instantiation \nC(&#38;. .) that is used to access a static class member is converted to the corresponding wrapper class \n$$c$-Q$. ,_$.I4 For example. NextGen translates the following code frag-ment Vector( Number)x = new \nVector( Integer) (100); for (int i = O;i < lOO;i++) x.setElementAt(new Integer(i). i): if (x instanceof \nVector(lnteger))  to: Vector x = new $$Vector%Jnteger$( 100): for (int i = 0:i < lOO;i++) x.setElementAt(new \nInteger(i), i): if (x instanceof $Vector$Jnteger_$)  If type variables appear in method bodies. then \nthis sim-ple translation strategy is insufficient. because the generat rode depends on the bindings of \nthese variables. Essentially the same problem arises in the translation of static variables with types \ndependent on type variables. The snippet tech-nique used to solve both of these problems is described \nin the next subsection. 13Two casts ore necessary for class types because the wrapper inter-faces for \nclasses are empty In the absence of static variables and type variables in executable code. there is \nno difference between the meaning of static methods UI wrapper classes and the base class. but the distinction \nmatters when thme restnctlons are dropped. 4.1 Type Variables in Method Bodies as before: the appropriate \ntype-specific operation is guaran- Simple typp erasure cannot accommodate method code con-taining type \nvariables because the behavior of such code de-pends on the bindings of i he typr variables. To accommo-date \nthis variation in behavior. the translation introduces a package-private auxiliary method. called a snippet. \nin the base clabs for each operation involving type variables. Wrapper classes then override snippets \nas appropriate. Simple snippets are insufficient for some parametric in-stautiations involving types \nthat are not public. becausr the type required in a snippet operation may br inaccessible in the package \ncontaining the parametric class drfinition. For example. assume that the source code library java.util \nfog Next(Gen includes the parametcrized Vector class given above and tilat Next Gcn is given t hc following \ncode to translate: package Client: import java.util.*: class Name { 1 // not a public type class Main \n( static Vector( Name)vn = new Vector( Name)( 100): The instantiation Vector ( Name ) in class Main \nforces lhe construction of a wrapper class and interface for Vector(Client.Name). The constructed wrapprr \nclass must irl-clutle a snippet that allocates an array of type Client.Name but Client.Name is not visible \nin the library package java.util where the wrapper class is placecl. In this example. we could solve \nthe problem by placing the constructed wrapper class in the Client package. but this remedy fails if \nthe wrapper class code refers to a non-public class C: of package java.uti1.l Hence. WF must place the \nconstructed wrapper paclagr in the same parkagr as the corresponding base class and devise a general \nsolution to the hidden snippet problem. To make tlrc new Name[. .] operation available in the lj-brary. \nthe Client package passes a snippel f nuironment to the constructed wrapper class that includes the requisite \nalloca-tiorl operation. l his visibility problem can occur for any iso-lat ed snippet that appears in \na public parametcrized class. Thp only isolated snippets for the type variable 7. are the operations \nnew 7 (. .). (T) and and their analogs for the array types 7 [ 1. 7 [ ][ 1. ..I6 All non-isolated snippets \nare visible in the package containing the paramet erized class def-inition because they involve parameteric \ntypes of the form 6 (T. .) wherr C is visible. The simplest general strategy for solving this visibility \nproblem is to embed all of the isolated snippets for a wrap-per class in a snippet enz>ironmcnt object \nthat is constructed in each clicmt class and passed to the corresponding wrapper class as the first step \nin the static initialization of the client class. Each isolated snippet forwards its calls to the corre-sponding \nmethod in thr snippet environment. Each wrapper class W for a parameterized class containing isolated \nsnippets includes the usual forwarding constructors. a private static variablr $is of type SlsolatedSnippets \nto hold the passed snip-ppt rllvironmt~nt. a generated method $init($lsolatedSnippets is) that iuitializrs \n5s. and snippet definitions for both isolated and non-isolated snippets. Non-isolated snippets are defined \nteed to be in scope. In contrast, each isolated snippet is defined to forwards calls to the corresponding \nmethod in the snippet environment $is. The type SlsolatedSnippets is a pub-lic abstract inner class in \nthe package containing the param-eterized class; the class specifies method signatures for the isolated \nsnippets. The $init method for W initializes $is and invokes the $init methods for the wrapper classes \nwith isolated snippets that W directly calls.17 Since the static variable $is does not change after it \nis initialized, the initialization opera-tion for a wrapper class is idempotent and can be performed \nrvery time a calling class using W is loaded. 7 he following code contains the generated base classes \nfor Vector(T) and the automatically constructed wrapper class $$Vector(Name): package java.util; abstract \npublic class Vector { // snippet environment class public abstract static class BlsolatedSnippets { \nObject[ ] $l(int initcapacity); 1 private Object[ ] elts; public Vector(int initcapacity) { elts = $snip%l(initCapacity): \n > // snippet protected abstract Object[ ] $snip$l(int initCapacity): public Object elementAt(int index) \n{ return elts[index]; bublic void setElementAt(Object newvalue, int index) { elts[index] = newvaluei \npublic class $$Vector$Name_$ extends Vector { / / snippet environment static Vector.$lsolatedSnippets \n$is = null: public static void $init($lsolatedSnippets $is) { this.$is = $is: I $$Vector$Name-$(int initcapacity) \n{ super( initcapacity); &#38;otected Object[ ] $snip$l(int initcapacity) { return $is.$l(): 1 I package \nClient: import java.util.*: class Name { ) // not a public type class Main { static { $$Vector$Name-$. \n$init(new Vector.$lsolatedSnippets() ( Object[ ] $l(int initcapacity) { return new Name(initCapacity]: \ni t static $$Vector$Name_$ vn = new $$Vector$Name~$(lOO): k 17Note that the calling class will pass \nsmppet enwronments for all the classes rcachatde from U 4.2 Accommodating Static Members According to \nNextGen s schematic semantic model for pa-rameterized classes, the static members of a parameterized \nclass must effectively be replicated in every wrapper class. NextGen employs an optimized version of \nthis translation that generally avoids replicating static method code. Since the static variables of \na parameterized class are replicated in each instantiation. all operations involving them must be converted \nto snippets so that the code for these oper-ations appears in the proper lexical scope. In particular. \neach access to a static variable z must be expressed in fully qual-ified form-including the appropriate \ntype parameters. For example. if a static variable x is defined in a parameterized class c ( z , ,) any \naccess to x inside of C has fully qualified form c (~0. .) .x. Since the meaning of such an access de-pends \non the bindings of the type variables To.. NextGen converts these operations to snippets (getter methods \nin this case) which must be appropriately defined in each wrapper class. Note that the types of static \nvariables must be erased in wrapper classes because the snippets appear in thr base class signature. \nl he replication of static method code in each wrapper class can be avoided as follows. If a static method \nin a param- cterized class C does not depend on type variable bindings,18 then NextGen translates it \nto its type erasure in the base class. Otherwise: NrxtGen translates the static method to an explicitly \nparameterized static method with exactly the same list of type variables as C (including implicit type \nvari-ables if C is an inner class). The implementation of explicitly parameterized methods is described \nin Section 6. Static inner classes are supported within parametcrized classes by generalizing the simple \nsyntactic. transformation used to support static inner classes in Java 1.1. Each static inner class A \nembedded in a parameterized class C ( 7 ) is transformed to a class C$A (T) defined in the same lexical \nscope as the parent class C(T) .lg The transformation also converts each implicit or explicit reference \nC(T). A anywhere in the program to the corresponding reference C$A(T). 4.3 Wrapper Classes and Interfaces \nWhen a parameterized class C extends another parameter-ized class (interface) D: the extension rstablishes \na mapping from instantiations of C to instantiations of D. which can be represented as a substitution \nH binding the type variables of D to type expressions containing the type variables of C. Each instantiation \nof a parameterized class is represented by a binding of the class variables to ground types. Given a \nbinding #J of the type variables of C to ground types, con-posing 6 with 4 yields the corresponding binding \nof the type variables of D to ground types. If the class (interface) D is a ground instantiation (con-tains \nno type variables), then the base class for C extends the rorrcsponding wrapper class (interface). Otherwise. \nthe base class for C simply extends the base class (interface) for D: the substitution 0 is left pending \nuntil the compiler generates wrapper classes and interfaces for C. When the parameterized class C is \niustantiated as a ground type c (&#38;. .). NextGen generates (i) a wrapper in- As demonstrated above. \ndependence on static variables ~mphes dr,-prndence on type variable bindilrgs As we observed m footnote \n6. there 1s a more secure syntactic trans-formatmn to support mner classes than the one adopted in Java \nI 1 For the sake of mform~ty. NextGrn follows the .Java 1. I mnve~~tion. terface $C(&#38;: .) extending \nthe wrapper interfaces for the corresponding instantiations of the classes and interfaces that C extends. \nand (ii) a wrapper class $%C(&#38;:. .) extending the base class C and implementing $C(&#38;. .). In \nthe wrapper class $$C(70: .): the type dependent operations performed by any snippets inherited from \nD must reflect the substitu-tion 0. These substitutions can cascade because snippets in class D may have \nbeen inherited from a parameterized super-class. In the common case. the substitution 0 is trivial. For \nexample. in the java.util library. the class java.util.Stack ex- tends java.util.Vector. If we parametrically \ngeneralize Vector. we should do the same for Stack: public class Stack(A) extends Vector(A){ } The compiler \nfor NextGen will expand this into the base class definition: public class Stack extends Vector { } and. \nas needed. wrapper classes and interfaces of the form public interface $Stack$-...4 extends $Vector$-..._$: \npublic class $%Stack%-...-$ extends Stack implements %Stack%-.....$ { /* forwarding constructors */ ) \nWhen a parameterized class like Stack(T) extends a pa-ramrterized class like Vector(T). each wrapper \nclass $$Stack(E) has two superclasses: the base class Stack and a wrapper class $$Vector( E). In the \nimplementation. this relationship is re-flected by the fact that the wrapper class $$Stack(E) extends \nthe base class Stack and implements the wrapper interface $Stack (6). which extends the wrapper interface \n$Vector(E). Hence. any value of class $$Stack(E) inherits methods from the base class Stack. yet belongs \nto the type $Vector(E) (because it implements $Stack( E): which is a subtype of $Vector(i?)). Any value \nof class $$Stack(E) also belongs to type Vector (be-cause %$Stack(E) extends Stack which extends Vector). \n 4.4 Parameterized Interfaces Parameterized interfaces are implemented in almost exactly the same fashion \nas parameterized classes. The only differ-pm-e is that the instantiation of a parameterized interface \ngen-erates a single wrapper interface instead of a wrapper class and interface. The generated wrapper \ninterface extenrls thr base interface and its immediate (possibly parameterizecl) sll-pertypes. Since \nbase interfaces only contain abstract rneth-ods. the wrapper interfaces generated for instantiations \nof parameterized interfaces include all of the methods of the parameterizecl interface. As a result. \nthere is no need to cast expressions of wrapper interface type to base interface type before invoking \na method in the base interface signature: the wrapper signature and base interface signature are identical. \nThe only significant complication in implementing param-eterized interfaces is the treatment of static \nfinal fields. If the value of a static final field is type dependent, then it must be replicated in each \nwrapper interface extending the base interface. But wrapper interfaces constructed for the various parametric \ninstantiations cannot include snippets to get the local version of the static final field. The only code \nthat can appear in an interface is initialization code for each static final field. If a parameterized \ninterface I contains a type de-pendent statir final field ET: the NextGen compiler adds an abstract snippet \npublic Object $get_F(); to the base interface I and inserts a copy of the field F toget her with appropri-ate \ninitialization code in each wrapper interface extending I. The snippet Pget3 must be implemented (overridden) \nin each wrapper class that directly implements a wrapper interface extending I. The compiler records \nthe snippet information for an interface in the Snippet attribute in its class file. 4.5 Type Erasure \nComplications NextGcn relies on type erasurr to support variables and method parameters of parametric \ntype. Occurrences of para- metric types in type casts and instanceof checks cannot be translated to the \ncorresponding wrapper class types. because the .JVM restricts classes to a single supertype (single in-heritance), \nyet parametric instantiations like Stack(lnteger) have two supertypes as shown above.21 Given the class \nStack(T) extending Vector(T) defined above. an instance of the class Stack(lnteger) can be assigned to \na variable of type Vector(lnteger). yet the wrapper class $$Stack(lnteger) is not a subclass of the wrapper \nclass $$Vector (Integer). NextGen pairs every lumpper class $$C with a corresponding wrapper interface \nPC to solvr this problem. Type erasure introduces another complication when a class (interface) C extends \na ground instantiation Bo of a param-eterized class (interface). The method signatures in BO are erased. \nbecause they are inherited from the base class B. Hence. they must be erased in the extending class C. \nHut C may override a method m from BO with an erased signature by a method m with an unerased signature. \nWorse,. the class C may implement another interface I with method signatures matching methods in the \nunerased signature of Bo. Consider the following code fragment in NextGen: public: interface CompareTo \n{ public int compareTo(T other); // returns neg,O.pos if this (.=.) other 1 public class String implements \nCompareTo(String){ public int compareTo(String other) { other 1 I According to the translation process \ndescribed above: a Next- Gen compiler will translate this fragment to a .Java code frag-ment of the \nfollowing form public interface CompareTo { public int compareTo(Object other): I public interface $CompareTo$String-% \nextends CompareTo {} public class String implements $CompareTo$String$ { public int compareTo(String \nother) { other 1 1 This code fragment is ill-formed because String does not implement the interface $CompareTo$String$; \nthere is no method matching the signature of compareTo in the interface CompareTo. To solve this problem, \nNextGen borrows a technique from Pizza. Pizza reconciles this signature conflict by adding an overloaded \nversion of the method compareTo. Exrept static vanables. which are replicated. Covariant paramvterlzatmn \nintroduces addItiona supertypes. Stc Seclion 6 public class String implements CompareTo%-String-$ { public \nint compareTo(String other) { other . . . public int compareTo(Object other) { ((String) other) \\ ) \nThr overloaded version of the method casts every reference to other to type String. Static type checking \nensures that these casts can never fail.z2 In general, given a class C that directly or indirectly ex-tends \n(implements) a ground instantiation BO of a parame-terized class (interface): NrxtGen will generate an \noverloaded method m (called a bridge method) with instantiated signa-ture for each method m with an erased \nsignature in BO that is not so overloaded in the superclass of C. If the method m (with instantiated \nsignature) is not defined in class C. the generated method m simply forwards its calls to the inher-ited \nmethod m with erased signature. casting the output of m to an instantiated type. if necessary. If C defines \nm (with instantiated signature). NextGen translates m to a method m with an instantiated signature (no \nerasure). In this case (which is illustrated in th e example above), the translation of C must include \na method implementing or overriding m (with erased signature) that simply calls m : inserting casts where \nnecessary. Note that m and m always have the same semantics except for run-time type checks dictated \nby their signatures.z3 The translation of parametric types to base types con-flicts with static overloading \nbecause syntactically distinct type signatures may collapse to identical signatures after type translation \n(erasure). There are two possible solutions to this problem. First, overloading parametric signatures \ncan be re-stricted to eliminate the conflict. Second. NextGen could mangle the names of operations that \nwould otherwise con-flict. When more than one signature matches a method invo-cation: NextCen could choose \nthe more specific (which might mean less parameterized ) of the two-generalizing an exist-ing rule of \nJava. We favor the first solution. at least initially. for the sake of simplicity of implementation. \n4.6 Parametric Type Spoofing In an earlier parameterized type proposal for Java. Agesen tt nl. observed \nthat untrusted JVM code can breach the parametric components of program typings in homogeneous implementations2 \nsuch as Pizza and GJ. The implementa-tion that we have described above for NextGen suffers from the same \nproblem because it does not check at run-time that method inputs and outputs obey the specified parametric \ntype constraints. We can modify the implementation to per-form the necessary checks, but these checks \ncan add signifi-cant overhead. The spoof-resistant translation is complicated by the fact that untrusted \ncode can extend wrapper classes. possibly overriding methods containing parametric checks. 2 Assum~ng \nthat all of the executed Java code 1s produced by the NrxtGcll compiler. =The mtroductlon of bridge methods \ncan mtroduce an ovwloadmg anomaly the signature of the two vers,ons of a method may dlffa only m their \nresult type. which IS not permItted in Java source codt Fortunately as Odersky and Wadler have observed \n[OW97.BOSW97] the JVM supports this form of overloading. so no workaround necessary. 24An implementation \nof type parametenzation IS homogeneous of It wases parametric type information in object representations \n In the spoof-resistant translation. every base class method with an erased parametric signature is overridden \nby a Yype-secure method that performs the required checks and invokes the base class (bound to super \nin the implementation). An untrusted extension of a wrapper class can override any non-final method. \nimplying that it can breach parametric type constraints enforced by non-final type-secure methods . To \nprevent such overriding, the translation process . marks each type-secure method as final: . forwards \ncalls on type-secure methods (using super) to equivalent calls on new protected auxiliary methods (with \nmangled names) that simply invoke their erased analogs in the base class, . generates the required auxiliary \nmethods, and performs exactly the same name mangling on overriding methods in any extension of a class \ninstantiation. This elaborated translation allows only the core of parametric methods (encapsulated \nin the generated auxiliary methods) to be overridderl-not the checks enforcing para- metric type constraints. \nConsider the elaborated translation of Vector(lnteger) below: public class $$Vector$Jnteger-% extends \nVector implements $Vector$Jnteger$ { public %$Vector$Jnteger$(int initcapacity) { super(initCapacity): \n)protected Integer $elementAt(int index) { return super.elementAt(index); > public final Object elementAt(int \nindex) { return (Integer) $elementAt(index); 1 protected void $setElementAt(Integer newvalue: int index) \n{ super.setElementAt(newValue:index); 1 public final void setElementAt(Object newvalue: int index) { \n$setElementAt( (Integer) newvalue: int index); I 1 Given a class V that extends Vector(lnteger), the \ncompiler must mangle the names of any overridden wrapper methods. The overhead of the additional method \ncalls and large class file footprints in a spoof-resistant implementation would be substantial. This \noverhead can be reduced by performing optimizations that safely eliminate some of these checks in trusted \ncode. For example, wrapper classes can be augmented with private shadow versions of methods without run-time \nchecks on their inputs so that calls within the class can bypass the checks. In the remainder of this \nproposal. we will not include the elaborations required to prevent parametric type spoofing, because \nit would complicate the exposition. Moreover, we believe that the best way to prevent parametric type \nspoofing is to modify the JVM to support parametric types directly. 4.7 Non-parametric Extensions of \nParamet- ric Types When a non-parametric class (interface) C extends or imple-ments a parametric class \nor interface, the new class (interface) C simply extends the appropriate wrapper class (interface). For \nexample. consider the following extension of the class Vector(lnteger): class SummedVectorlnteger extends \nVector( Integer){ public int sum = 0; public SummedVector(int initcapacity) { super(initCapacity); public \nvoid setElementAt( Integer newvalue. int index) ( sum = sum + newValue.intValue() -elts[index].intValue(); \n. . The NextGen compiler must transform this class to the form class SummedVectorlnteger extends $$Vector$Jnteger-$ \n{ public int sum = 0; public SummedVector(int initcapacity) { super(initCapacity); Loblic void setElementAt( \nInteger newvalue: int index) { sum = sum + newValue.intValue() -elts[index].intValue(); I 1  5 Compatibility \nwith GJ and Java 1.2 NextGen is a strict extension of type-sound GJ with the ex-ception of the reflection \nAPI and the treatment of static class members. The differences at the level of reflection are un-avoidable \nbecause the reflection API reveals all the unpro-tected details of the class hierarchy including class \nfields and their attributes. Even a tiny change to a Java class library (such as dropping a final modifier \nfor a public method) is not conservative for programs that use reflection. In contrast, the differences \ninvolving the interpretation of static members are easy to reconcile. Next Gen can easily support both \nshared and replicated static members and in-terpret the unadorned syntax as the shared version. The im-plementation \nof shared members is straightforward: the field or inner class in question is associated with the base \nclass in-stead of the wrapper class. The biggest challenge in designing this extension is devising an \nappealing syntax for declaring replicated static members without introducing a nezu keyword. One possible \nchoice* is to prefix replicated static members by the augmented keyword static{ ) instead of static. \nThe primary disadvantage of adding shared static mern-bers to NextGen is that it complicates the semantic \nmodel. Shared static variables cannot be explained schematically. In addition, static parameterized inner \nclasses and static param-eterized methods can be defined in two different ways that are not equivalent. \n5.1 Legacy Code and Libraries When NextGen translates the parametric generalization C(To. .) of an existing \nJava 1.2 library class java. .C. it cannot place the generated base class in the package java. unless \nit exactly matches the signature and semantics of the original class. In many JVM s, the standard package \nlibrary packages java. are sealed (immutable). Hence, parametric Suggested by Phil Wadler. generalization \nmust he implemented using inheritance (leav- ing the original library package undisturbed). rather than \ncode modification. To compile parametric generalization C(&#38; .) of a class C in a sealed package, \nNext Gen (i) generates the usual base class for c( &#38;. .): and (ii) extracts the parametric . op-erations \nfrom this base class (the generated snippets and methods that directly invoke them) and places them in \na special abstract base class generic.java. . . .C extending the original library class java. . .C. The \nremaining members, which presumably match those in the original library class, are discarded. Obviously. \nno final methods within a class can be parametrically generalized. Similarly, no type dependent method \nin a parametric generalization can access a private variable or invoke a private method. Fortunately. \nall final attributes have been dropped from the core library classes in Java 1.2. This translation does \nnot support shared static variables in parametrically generalized classes. but such sup-port could easily \nbe added at the cost of adding shared static variables to NextGen.  5.2 Interoperability NextGen differs \nfrom GJ in that instances of parametric classes are not instances of the base class. In essence. new \ndata is distinct from old data. In general. new data can be used in place of old data. but not vice versa. \nHence. pro-grams that intermix old and new data must explicitly con-vert old data to the new form. The \nparametric generalization of java.util could include parametcrized methods that perform these ronversions.26 \nIn general. mixed programming involving both old and new data is poor software engineering practice. \nOld code should bc revised to use parametric types. But when source for old code is unavailable. mixed \ndata programming may be unavoidable. The ability to mix old and new code also pro-vides a smooth transition \npath during code ronversion. Next-(ien. following in the footsteps of GJ. supports such mixed programming \nNext Grn. however. generally requires more glue code between new code and old code than G.J does. This \nis an ~ravoiriable cost of type soundness. GJ avoids the use of glue code in some contexts by compromising \ntype soundness: an old value of unparameterized type List can be assigned to a new variable x of parametric \ntype List(lnte-ger). If the old List value contains non-integer elements. then a subsequent operation \non x may generate a riui-time type er-ror. In contrast. NextGen enforces the type constraints given in \nprogram declarations. It will not permit old data of type List to be treated as instances of any parametric \ntype List(T). The old data must be converted to new parametric data to be processed by rode that operates \non parametrir data.  6 Parameterized Inner Classes Static parametrrized inner classes can be implemented \nin es-sentially the same fashion as conventional (unnested) paran-eterized classes because static inner \nclasses have the same semantics as conventional classes except for qualified names. Each static parametric \ninner class A(T) embedded in a class C is translated to an unnested class C $A(T) and every implicit \n> Since thr new methods arc type dependent. NextGen wll place them in the special package generic.java.util \nleaving the binary form of java.util unchanged. or explicit reference C.A(E) to an instantiation of the \ninner class is translated to C$A(E). The implementation of dynamic parameterized inner classes is a more \nchallenging problem because each instance of a dynamic inner class must provide access to the enclosing \n. instance. The NextGen compiler translates a parameterized dynamic inner class to an erased base class \nin exactly the same way that it translates conventional parametric classes to base classes. But the compiler \nmust also extend this inner base class with textually independent wrapper classes. Fortu-nately, the \ninner class facility introduced in Java 1.1 supports exactly this form of inner class extension. An accessible \ndy-namic inner class C can be extended by a class C declared at the top lexical level. Since the containing \ninstances for any instantiation of such a class are not implicit from the text. the constructor for C \nmust explicitly install the innermost containing instance as its first operation. This instance is typically \npassed as an extra parameter to the constructor for C . Given a parameterized dynamic inner class ~(70.. \n.) em- bedded in the class D: the NextGen compiler inserts a pa-rameter of type D at the beginning of \nthe parameter-list for each constructor in wrapper classes. In the translation of each constructor call \nfor an inner class C (To. . . .) Next Gen binds the inserted parameter to the enclosing instance of class \nD. In other words. each operation new C(Es.. . .)(. .) in the orig-inal source becomes new C%-es%. .-$(this:. \n.) in the transla-tion (where es is the translation of the type expression &#38;). Similarly. each operation \np.new C(Es: . .)(. .) in the original source (where p is an an instance of class D) becomes new C$-to$. \n.A(p.. .). If a (static or dynamic) parameterized inner class C is de- fined within a parameterized class \nD. NextGen generates a single base class for the inner class C: but C is indirectly pa-rameterized by \nthe type variables of D. The wrapper classes for C must make this parameterization manifest to accommo-date \nthe various snippets (which can depend on indirect as well as direct type variables) and to replicate \nstatic variables.  7 Parameterized Methods NextGen implements parameterized methods using essen-tially \nthe same techniques that it uses to support parame-t erized classes. But the details of the implementation \nare more complex because parameterized methods can be inher- ited and overridden in subclasses. Static \nparameterized methods are easy to implement bc-cause no inheritance is possible. Every static parameterized \nmethod nr in a class C is explicitly invoked using the class name C!.27 If a static parameterized method \nm does not de-pend on type variable bindings, then NextGen simply trans-lates 71, to its type erasure \nin the class C (or the base class for C if C is parametric). Otherwise. NextGen converts the type dependent \noperations in body of m to snippets. generates a static abstract inner class A in C (with the same visibility \nas m) defining the snippet environment signature, translates nc to snippetej form in C with an additional \nargument of type A (the passed snippet environment). and inserts an appropriate anonymous class instance \nconstruction as an additional argu-ment in each call on rn. The resulting form of the method and method \ninvocations is called snippet-pnssing style. A Next-Gen con~l~ilcr can easily optimize construction of \nanonymous class instances so that no instance is constructed more than once. The implementation of dynamic \nparameterized methods is complicated by the fact that such methods can be over- ridden in subclasses. \nSince method dispatch is dynamic, a method invocation site x.m<T>(. . .) can execute different method \nbodies depending on the receiver x. As a result, dy- namic parameterized methods cannot be translated \nto degen- erate parameterized inner classes containing a single method [OW97]. This translation fails \nin the presence of method over- riding because the inherited parameterized inner class cannot be overridden; \ninner classes are not virtual. The same pathological situation prevents NextGen from translating a parameterized \nmethod directly to snippet- passing style. If a parameterized method is overridden: the set of requisite \nsnippets may change. Hence, in the presence of dynamic dispatch, NextGen cannot determine which snip- \npet environment to pass. A given call site may need to pass different snippet environments in different \nexecutions. To cope with method overriding in the context of dynamic dispatch. NextGen augments class \nfiles containing overrid- able. dynamic parameterized methods with wrapper methods as demanded by client \nclasses. Since some Java packages are sealed (immutable by client code), the parameterized methods in \nsealed packages must be either static. private. or both final and original (not overriding a superclass \nmethod) to rule out the possibility of overriding dynamic parameterized methods. In the special case \nwhere a dynamic parameterized method is either private or both final and original. Next- Gen uses the \nsame snippet-passing transformation as it does for static parameterized methods. For conventional packages \nthat are not sealed. NextGen translates overridable dynamic parameterized methods to snippet-passing \nstyle as follows. For each such method m in class C: NextGen first converts m to snippet-passing style \nand labels it as a protected method of C. This converted method, called the base method of the parameterized \nmethod definition, is never called directly by clients since its signature is not compatible with dynamic \ndispatch. For each distinct instantiation of a parameterized method in a program, Next-Gen generates \na wrapper method in class C (or a wrapper class extending C if C is parametric) with a mangled name and \na signature that exactly matches the erased signature of the parameterized method m. The body of the \ngener-ated wrapper method simply forwards the call to the base method augmented by the appropriate snippet \nenvironment as an extra argument. Note that this strategy accommodates method overriding and dynamic \ndispatch because the wrap-per method has the same signature in the overriding and over-ridden classes. \nbut different code bodies with different snippet environments. To keep track of which wrapper methods \nhave been generated for parameterized methods in the class C. the NextGen compiler attaches a WrapperMethods \nattribute to the class file. The translation for overridable dynamic parameterized methods described \nabove has one important limitation: it does not support binding the type variables appearing in iso-lated \nsnippets2 to types that are invisible in the package containing class C. The wrapper method for such \na type ap-plication cannot define the required isolated snippets because the specified classes are invisible. \nWe refer to such wrapper methods as escaping wrapper methods. The translation of parameterized methods \ncan he extended to accommodate escaping wrapper methods as follows. Next-Gen can augment the class C \nby an abstract static inner class m$A specifying the signature of the isolated snippet environ-ment for \nm. Then for each escaping wrapper method WVI that NextGen adds to class C: it also generates a static \nvari-able wm$lsolatedSnippets of type m$A and a static initializer method wm$lnit that initializes tom$lsolatedSnippets \nto the value specified by its argument. Each client class for the wrapper method wm must invoke the initializer \nwm$lnit as part of its static initialization. Note that if m is overridden in a subclass C of C: every \nclient of 2om in C is a client of the corresponding escaping wrapper method wm in C . To up-date all \naffected class files incrementally as individual classes are compiled. the NextGen compiler must attach \na Clients attribute to each class file specifying the client classes for each escaping wrapper method \nin the class file. In addition. it must attach a WrapperInits attribute to each client class file specifying \nexactly which wrapper-method initializers that it invokes. This wrapper initialization portion of static \nin-tialization for each class can be encapsulated in a method $wrapper$lnit so that it can be incrementally \nupdated without affecting other static initialization code. The implementation of parameterized methods \nin Next-Gen is illustrated by the following examples. Given the fol-lowing program text defining the \nparameterized method zip: package P: public class Vector(A) ( private A[ ] elts; public Vector(int initcapacity) \n{ elts = new A[initCapacity]; 1 public A elementAt(int index) -( return elts[index]; I public void \nsetElementAt(A newvalue. int index) -( elts[index] = newvalue; > public(B)Vector(Pair(A.B))zip(Vector(B)other) \n{ int s = this.size(); if (s != other&#38;e()) throw new NoSuchElementException(); Vector(Pair(A,B))result \n= new Vector(Pair(A,Bxs): for (int i = 0;i < s;i++) result.elts[i] = new Pair(A.B)(this.elts[i], other.elts[i]): \nreturn result: ) 1 public class Pair(A:B)( public A fst; public B snd; public Pair(fst,snd) { this.fst \n= fsr: this.snd = snd; 1 > package Q; public class Main { public static void main(String args[ 1) { \nVector( String)names = new Vector( String) (100); Vector( Integer)numbers = new Vector{ Integer)( 100); \nVector(Pair(String:lnteger))phonebook = names(lnteger)zip(numbers): } 1 the NextGen compiler translates \nthe class Vector(A) to the following base class: package P: abstract public class Vector { // snippet \nenvironment public static abstract class BlsolatedSnippets { Object[ ] $l(int initial capacity): > private \nObject[ ] elts: public Vector(int initcapacity) { elts = $snip$l(initCapacity); j/ snippet abstract \nprotected Object[ ] $snip$l(int initcapacity): public Object elementAt(int index) { return elts[index]: \n public void setElementAt(Object newvalue, int index) { elts[index] = newvalue: I Lublic abstract class \n$zip$Snippets = { Vector $l(int I): Pair $Z(Object fst. Object snd); > protected VectorS-Pai&#38;-Object$Object$_% \nzip(%zip$Snippets Bis. Vector$-Object-B other) { int s = this.size(): if (s != other.length()) throw \nnew NoSuchElementException(); Vector result = $is.$l(s); for (int i = O;i < s;i++) result.elts[i] = $is.$2(this,elts[i]: \nother.elts[i]): returu result: attaches Signature and Snippet attributes to the class Vector sperif;ling \nthe paramedic class signature and the class snippets ($snip$l) including those in the snippet environment \nVector.$lsolatedSnippets: attaches a Snippet attribute to the protected base method zip specifying the \ntype dependent operations corresponding to each snippet in the snippet environ-ment SzipSSnippets: translates \nthe class Main to the form: package Q: public class Main { // inititialize server classes static { VectorPString-$.Pinit( \nnew Vector.$lsolatedSnippets() { Object[ ] $l(int initcapacity) { return new String[initCapacity]; 1 \n1: J static f Vec&#38;Jnteger-$.$init( new Vector.$lsolatedSnippets() { Object[ ] $l(int initcapacity) \n{ return new Integer[initCapacity]; > ) 11 } static { Vector$Pair%-String%Integer4_B.$init( new Vector.$lsolatedSnippets() \n{ Object[ ] $l(int i&#38;Capacity) { return new Pai&#38;String$lnteger$[initCapacity]: J ) jr} public \nstatic void main(String args[ 1) { static VectorOString-$ names = Vector$String-$(lOO): static VectorP-Integer-$ \nnumbers = Vector$Jnteger$(lOO); static Vector%Pair$.String$IntegerJ_% phonebook = names.zip%_lnteger4(numbers): \n) I and generates the wrapper classes $$Vector$String-$ $$Vector%Jnteger-$ $%Vector$Pair$-String$lnteger$-$ \n$$Pair$String$lnteger$ and corresponding interfaces in package P: and 5. augments the class file for \n$$Vector$String_$ with a pub- lic wrapper method for the method instantiation names.(Integer)zip(numbers) \nin class Main: public Vector zip$Jnteger$(Vector other) { return zip( new $zip%Snippets() { Vector $l(int \ns) { return new $$Pair%String$lnteger$[s]: 1 Pair $2(0bject fst: Object snd) { return new Pair$String$lnteger4(fst.snd): \n1: } other); 1 because the variable names has type $$Vector$String-16. Any wrapper class subsequently \ngenerated by the com-piler that is a subtype of $Vector$String-9 must include a def- inition for the \nwrapper method zip$-lnteger$. This obligation is recorded in a WrapperMethocEs attribute attached to \nthe interface $Vector$String-%. Note that if the class Main instantiated zip with a default- access type \n(invisible outside packago Q). the translation woultl have to invoke the machinery required to support \nescaping wrapper methods. 7.1 Type Inference The current G.J design supports type inference for paratneter-ized \nmethods as a convenience to the programmer. F:xactly the same facility could be added to NrxtGen. The \npresencr of covariant subtyping for Next Gen paramet erized classes does not introduce any new complications \nbecause Java array types are already covariant. We are not convinced that the gain in notational convenience \nis worth the added complexity in the language definition.  8 Classes and Interfaces as Parameters In \nNextGen, there are two contexts where a type variable must be bound to a class rather than an interface. \nThe most important is a new expression of the form new $T$(. .) where T is a type variable. To help programmers \nrecognize which parameterized classes contain new operations on iso-lated type variables. NextGen requires \nthe binding occurrcncf (its declaration in the class header) of such a type variable to be prefixed by \nthe keyword class. A class type variable must he bound to a concrctc class: it cannot be an interface \nor an abstract class. The other context separating classes from interfaces is the instantiation of a \ntype variable bounded by a class. Since an interface cannot extend a class. the binding of such a type \nvariable must be a class. However. in contrast to the context above. the binding may be an abstract class. \nHence. the binding occurrence of a type variable bound by a class type may include the prefix abstract \nclass. In general. NextGen permits the prefixes class. abstract class, or interface to appear before \nthe binding occurrence (declaration) of a type variable. If none of these prefixes ap pears. the default \nis interface. unless the binding occurrence contains an extends clause. in which case the default is \nab-stract class. For example we may write class Vector(abstract class A){ } class Stack(class A)extends \nVector(A){ } class List(interface A){ }  When one paramrterized class extends another. the prefixes \n(implicit or explicit) of the new binding classes must be com-patible with their use in the extended \nclass (or interface). 9 Covariance and Contravariance While the distinctions between covariant. contravariant. \nand non-variant parameterization may appear to be the province of type theoreticians. they all arise \nin practice. In fact. each is invaluable in describing important parameterization pat-terns that frequently \noccur in real applications. Since all three forms of type parameterization are important. we would like \nto support all three in NextGen. Unfortunately. we do not know how to implement contravariant parameterization \nefficiently on top of the existing JVM. For this reason: con-travariant parameter&#38;at&#38; is not \nincluded in the current de-sign. In the following discussion. however. we will assume that contravariant \nparameterization is permitted. in antici-pation of future extensions to the JVM and NextGen. Covariant \nand contravariant parameterization are respec-tively indicated by inserting the prefix + or -in front \nof the type parameter. The sole effect of these prefixes is to deter-mine the subtyping behavior of parameters. \nwhich imposes typing restrictions on program text involving parameterized types. As an example. consider \na covariant version of Vector: public class Vector(+A){ ) If the class declaration type-checks. NextGen \ntranslates it in almost exactly the same way as a class with non-variant pa-rameterization. The only \nchange is that whenever a wrapper interface is generated. it implements an additional interface corresponding \nto an immediate covariant supertype: public interface $Vector$Jnteger$ implements $Vector%-Number-$ {} \n Since Number is the superclass of Integer. Vector<Number> is an immediate supertype of Vector(lnteger). \nThis relationship be-tween the interfaces representing parametric types completely captures the covariance \nproperty. As another example. COII-sider the declaration public class Pair(+A:+B){ } For the instantiation \nPair(String,lnteger). NextGen would gen-erat e: public interface $Pair$-String$lnteger$ implements %Pair$-Object%lnteger%: \n$Pair$String$Number$. In general. a wrapper interface for a covariantly parametcr-izrd class or interface \nimplements all the wrapper interfarrh for immediate covariant supertypes. To ensure type safety. NextGen \nprohibits a couarinnt type from being used as the type of a method parameter and a controvrrriant type \nfrom being used as the return type of a method. Note that these restrictions apply to inherited methods \nas well as manifest ones. In addition. the llsage of class instance variables with types involving covariant \nor COJ~-travariant type variables must be restricted because variable access and assignment are implicit \nmethods with parametric signatures. To ensure the type safety of operations on ill-stance variables. \nwe impose two restrictions. First. the class instance variables must be declared private or protected. \nSecond. these instance variables can only be extracted from the pseudo-variable this. These rules ensure \nthat the type constraint associated with an instance variable of parametric type 1 is exactly membership \nin T. not membership in some subtypr or supertype of T. The usage of static (class) variables and methods \nwith covariant (or contravariant) parametric types is unrestricted (except by Java s usual type checking \nrules) because the as-sociated type constraints are manifest at compile time. 10 Future Directions The \nmost serious limitation of the NextGen genericity fa-cility is the lack of support for parameterization \nby primi-tive types. Such primitive parameterization is incompatiblr with the homogeneous implementation \ntechniques (based on type erasure) adopted from Pizza and GJ. NextGen could IX extended to support primitive \nparameterization by incorpo-rating a brute force heterogeneous translation for primitive type instantiations. \nSuch a facility may be important in prac- tice despite the potential for explosive increases in program \ncode size. To prevent the growth of program binaries. Agesen et.al. [AFM97] h ave proposed deferring \nheterogeneous class instantiation until load time. IJnfortunately. this technique requires a revised \nclass loader, breaking backwartl compati-bility with existing Java Virtual Machine. To support a coherent \nparameterization facility that un-formly supports both reference and primitive types. we need to explorr \nan extension of Java that incorporates the prin-itive types in the object type hierarchy. Such an exercise \nis clearly beyond the scope of this paper. References [AFM97] Ole Agesen. Stephen Freund, and John Mitrllell. \nAdding parameterized types to .Java. In A CA4 .Sympo- sium of Obgect-Oriented Pwgrnmntirrg: Systems. \nI.m-guay~s~ and Applications. October 1997. [BOSW98] Cilad Bracha: Martin Odersky, David Stoutamire, \nand Philip Wadler. Making the future safe for the past: Adding Genericity to the JavaTM Programming Language. \nTo appear in Proc. of the ACM Conf. on Object-Oriented Programming, Systems, Languages, and Applications, \nOctober 1998. [CCH+89] Peter Canning, William Cook: Walter Hill. Wal-ter Olthoff. and John C. Mitchell. \nF-bounded poly-morphism for object-oriented programming. In Proc. Etinctional Programming Languages and \nComputer Architecture: September 1989, 273-280. [Mey92] Bertrand Meyer. Eiffel: The Language. Prentice \nHall. 1992. [MBL97] Andrew C. Myers: Joseph A. Bank. and Barbara Liskov. Parameterized types for Java. \nIn ACM Sym-posium on Principles of Programming Languages. Jan-uary 1997, 132-145. [OW97] Martin Odersky \nand Philip Wadler. Pizza into Java: Translating theory into practice. In ACM Sympo-sium on Principles \nof Programming Languages. Jan-uary 1997, 146-159. [Tho97] Kresten Krab Thorup. Genericity in Java with \nvirtual types. In European Conference on Object-Oriented Programming, LNCS 1241, Springer-Verlag. 1997: \n444-471. ITor Mads Torgersen. Virtual types are statically safe. Fifth Workshop on Foundations of Object-Oriented \nLanguages, January 1998.  \n\t\t\t", "proc_id": "286936", "abstract": "The most serious impediment to writing substantial programs in the Java&amp;trade; programming language is the lack of a <i>gentricity</i> mechanism for abstracting classes and methods with respect to type. During the past two years, several research groups have developed Java extensions that support various forms of genericity, but none has succeeded in accommodating general type parameterization (akin to Java arrays) while retaining compatibility with the existing. Java Virtual Machine. In this paper, we explain how to support general type parameterization---including both non-variant and covariant subtyping---on top of the existing Java Virtual Machine at the cost of a larger code footprint and the forwarding of some method calls involving parameterized classes and methods. Our language extension is forward and backward compatible with the Java 1.2 language and run-time environment: programs in the extended language will run on existing Java 1.2 virtual machines (relying only on the unparameterized Java core libraries) and all existing Java 1.2 programs have the same binary representation and semantics (behavior) in the extended language.", "authors": [{"name": "Robert Cartwright", "author_profile_id": "81406592800", "affiliation": "Rice University", "person_id": "PP43116956", "email_address": "", "orcid_id": ""}, {"name": "Guy L. Steele", "author_profile_id": "81100586340", "affiliation": "Sun Microsystems Laboratories", "person_id": "P100946", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/286936.286958", "year": "1998", "article_id": "286958", "conference": "OOPSLA", "title": "Compatible genericity with run-time types for the Java programming language", "url": "http://dl.acm.org/citation.cfm?id=286958"}