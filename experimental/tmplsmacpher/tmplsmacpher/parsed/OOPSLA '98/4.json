{"article_publication_date": "10-01-1998", "fulltext": "\n Ownership Types for Flexible Alias Protection David G. Clarke, John M. Potter, James Noble Microsoft \nResearch Institute, Macquarie University, Sydney, Australia {clad,potter,kjx}@mri.mq.edu.au Abstract \nObject-oriented programming languages allow inter-object aliasing. Although necessary to construct linked \ndata struc-tures and networks of interacting objects, aliasing is prob- lematic in that an aggregate \nobject s state can change via an alias to one of its components, without the aggregate being aware of \nany aliasing. Ownership types form a static type system that indicates object ownership. This provides \na flexible mechanism to limit the visibility of object references and restrict access paths to objects, \nthus controlling a system s dynamic topol-ogy. The type system is shown to be sound, and the specific \naliasing properties that a system s object graph satisfies are formulated and proven invariant for well-typed \nprograms. Keywords Alias protection, sharing, containment, ownership, represen-tation exposure, programming \nlanguage design 1 Introduction Sharing objects through aliasing is both a powerful feature of object-oriented \nprogramming and a weakness [24]. Changes to an object potentially affect all objects that refer to it, \neven though the object being changed may be unaware of the other objects. This complicates reasoning \nabout object-oriented programs; specifically, there is a lack of modularity in reasoning due to the inability \nto iocalise object references. Programs become difficult to understand because knowledge of complete \nprogram behavior is required, ultimately lead-ing to programs which are difficult to maintain. This paper \ntakes the first steps towards imposing discipline in control- ling aliasing, something absent in current \nprogramming lan-guages. Our earlier work with dynamic change detection schemes for aggregate objects \n[37] developed into the notion of per- ible alias protection. That work proposed that aggregate objects \ncould be defined from components where potential aliasing amongst the components is statically determined \nus-ing aliasing modes. In [38], we provided the rationale for our Permlsseon to make digItal or hard \ncopes of all or part of this work for personal or classroom use IS granted wthout tee provided that COPES \nare not made or dtstrlbuted to, pro,,, or commerc,al advan- tage and that copies bear th,s notIce and \nthe full cltatoon on the first page TO copy otherwise. to republish. to post on servers or to redlstnbute \nto Ints, requires pr,or specific perm,ss!on and/or a fee OOPSLA 98 lo/98 Vancouver, 8.C E 1998 ACM l-581 \n13.005.819810010.. $5 00 model of flexible alias protection, supported by illustrative examples, and \nsuggested incorporating aliasing modes into programming languages. For flexible alias protection three \nkey properties are required: no representation exposure; no role confusion between entities with different \nmodes; and limited dependence on the mutable state of other objects (not addressed in this paper). In \nthe current paper, we introduce ownership types: static types annotated with context declarations that \nrep-resent object ownership. For an object-based language, we construct a type system based on ownership \ntypes and es-tablish its soundness via a subject reduction theorem. We refine the notion of representation \nexposure into a restricted visibility property which limits the extent of object visibil-ity, and a representation \ncontainment property which pro-vides a notion of containment based on articulation points [2] (also called \ndominators [3]). Absence of role confusion is phrased in terms of role separation. These properties, \nin particular the representation containment property, repre-sent structural invariants on the object \ngraphs of well-typed programs which indicate the kinds of aliasing that are not possible. The paper is \norganised as follows. Section 2 describes ownership types, object contexts and their intended seman-tics \nin terms of object ownership, and considers some il-lustrative examples in a Java-like language extended \nwith ownership types. Section 3 introduces a core language and formalises a static semantics for it in \nterms of ownership types. Section 4 describes an operational semantics and, by providing a novel interpretation \nof ownership types, proves a subject reduction property demonstrating soundness for our ownership type \nsystem. Section 5 formalises and proves representation containment and other properties. Section 6 discusses: \nthe model of containment suggested by the artic- ulation point formulation; the correspondence between \nthe work presented here and the flexible alias protection model [38]; and any limitations. Section 7 \nconsiders related work, including other proposals for providing alias protection. Sec-tion 8 concludes \nwith the current status of our theoretical work and of the prototype implementation based on Pizza, together \nwith future directions. 2 Ownership Types and Object Contexts Typically in object systems, objects live \nin a global address space called the heap, or object store. There are no strict constraints on which \nparts of the object store an object can access, because there are no restrictions on the way ob-ject \nreferences are passed around. This has repercussions when preventing representation exposure for aggregate \nob-jects. The components which constitute an aggregate object are considered to be contained within that \naggregate, and part of its representation. But, because the object store is global, there is, in general, \nno way to prevent other objects from accessing that representation. Enforcing the notion of containment \nwith the standard reference semantics is im- possible. The key to solving this problem is to introduce \nthe no-tion of object contexts. Each object owns a context, and is owned by the context that it resides \nwithin. Object contexts provide a nested partitioning of the object store, reflecting nesting of objects, \nthat allows us to speak of an object s interior and exterior. We annotate types with context declarations \nto yield ownership types. Two variables having ownership types with different declared contexts cannot \nrefer to the same part of the store, thus cannot be aliases for the same object. Our ownership type system \nestablishes a sensible notion of an object s interior. We now informally develop these ideas. A program \nbegins execution in a root context. In a pro- gram text this is denoted by the context norep (nobody \ns representation). Since the root context is global, its objects are considered to be owned by the system, \nand are poten-tially accessible to all objects in the system. This provides a mechanism for sharing value \nobjects [31, 251 and objects which provide system-wide services. The context norep also represents the \nstandard constraints on references in object- oriented programming languages; that is, none. When a new \nobject is created, it is alloted a new con-text which is considered to be inside that object, and whose \ncontents are deemed to be owned by that object. In the program text, this partition is denoted by rep, \nthe partition which holds the representation. We impose a restriction on the use of rep, which is approximately \nthat the only objects that can access the rep partition are the object that owns it and other objects \ninside that partition (or inside partitions of objects inside that partition, and so on), but only if \nthey have been given explicit access to the rep partition. In other words, a rep partition is not accessible \nfrom outside of its owner. This is an informal statement of what we mean by representation containment. \nNote that rep is object dependent; it denotes a differ-ent context for each object, just as this is different \nfor each object. Within the definition of an object, that is, within its class, the context parameter \nowner denotes the object con-text that owns that object (the one referred to by this). The owner of a \nnew object is not necessarily the owner or the rep context of the object creating it. It follows that \nowning an object and having a reference to it are not necessarily the same. The context parameter owner \nwas not present in [38]. The utility of this extension can be seen in the exam-ples. Further, it is essential \nin assigning an ownership type to this. We have other context parameters which allow object context information \nto be passed around. But we do not treat object contexts as first-class values as this would make it \nimpossible to construct a static type system. Instead, we treat context parameters analogously to the \ntype parameters of a generic class in Eiffel [32] or Pizza [39], or a template in C++ [15] (except that \nwe do not macro-expand to per-form type-checking as in C++). Context parameters allow ownership information \nto be passed from one context into a newly created object. This allows us, for example, to create a container \nwhose links are its hidden representation, but whose contents are owned by an object outside of the con-tainer \n[38]. This is not possible with either Balloons [4] or Islands [23]. These object context parameters \n(including owner) give our system its flexibility. An ownership type consists of a class name, a context \nrepresenting the owner, and bindings for the context param-eters. The bindings to the owner and the context \nparameters must use the visible contexts within the class where a type is declared, that is rep, norep, \nowner, plus the context parame-ters from the class header. Examples of ownership types are given in the \nfollowing sections. The discussion here suggests using explicit first-class stores such as those of [35] \nor the local stores of [46]. But the partitioning of stores is merely a metaphor to enhance understanding. \nEven the notion of ownership is static; the object stores denoted by object contexts within an object \nare fixed for the life of that object. There are no operations on object contexts, and their value does \nnot affect computa-tion. Our contexts are statically enforceable, and although they have a run-time interpretation, \nthey do not require run-time support. Thus object contexts and ownership types are static conceptual \nentities only. 2.1 The object contexts rep and norep The example in Figure 1 illustrates the object contexts \nrep and norep. By executing Main.main() until the end of the line marked (*I, we get the following object \ngraph: 4 driver ] 1 engine 1 In this diagram, the solid arrows are references between ob-jects, and \nthe dotted arrows refer to an object s owner. The arrow marked with an x is a reference not allowed in \nour system. An Engine is part of a Car and there should be no exter- nal alias to it. Otherwise an engine \ncould be started violat-ing the implied precondition of method go0, namely, that a car must have a driver \nbefore it can start its engine. By giving the field engine the ownership type rep Engine, we are saying \nthat the engine is part of the car s representation and thus it belongs to the context owned by the given \ninstance of Car. Furthermore the engine is not accessible outside of this instance. To outlaw the x-marked \nreferences, we characterise the representation containment property as follows: all paths from the root \nof the system to an object must pass through that object s owner. Further points to note about this example \nare as follows. By typing the field driver as norep Driver, we consider the car s driver to be owned \nby the system. The engine cannot be accessed using the field name, or be returned from an external method \ncall. The first could class Engine { void start0 { . . . } void stop0 { . . . } I class Driver { . . \n. } class Car { rep Engine engine; // representation norep Driver driver; // not representation Car0 \n{ // constructor // new engine as part of representation engine = new rep Engined; driver = null; I \nrep Engine getEngine { return engine; ) void setEngine(rep Engine e) { engine = e; } void go0 { if (driver \n!= null) engine.startO; I I class Main { void main0 norep Driver bob = new norep Driver0 ; norep Car \ncar = new norep Car 0 ; car.driver = bob; // (*) car.goO; car.engine.stop(); // fails car.getEngine() \n.stop(); // fails // but not in Java rep Engine e = new rep EngineO; car.setEngine(e); // fails // different \nrep I I Figure 1: Car Example be prevented in Java by making the engine private. But, Java allows the \ncontents of a private field to be returned by a method. This is not allowed for objects with rep-annotated \ntype. For this reason we say that our system provides ob-ject protection, which is stronger than the \nname protection offered by conventional programming languages. The call car.setEngine(e) fails because \nthe rep of the caller and the callee refer to different contexts, namely the root and the car context, \nrespectively, and are therefore distinct. The two types are incompatible. The interpretation of rep also \nimplies that the type rep Engine will be different in different instances of the class Car. This implies \nthat different cars must have different engines. 2.2 Context Parameters The next example illustrates \ncontext parameters, bindings, and some of the restrictions they impose (Figure 2). class Pair<m,n> { \nm X fst; n Y snd; I class Intermediate { rep Pair<rep, norep> pairl; norep Pair<rep. norep> pair2; Pair<rep, \nnorep> a0 { return pairl; } norep Pair<rep, norep> b0 { return pair2; } rep rep X x0 { return pairi.fst; \n} norep Y y0 { return pairl.snd; }  void updateX() { pair1 .f st = new rep X0; I 1 class Main { norep \nIntermediate safe; void main0 { rep Pair<rep, norep> a; norep Pair<rep, norep> b; rep X x; norep Y y \n; a = safe.a(); // wrong b = safe.b(); // wrong x = safe.x(); // wrong y = safe.yO; // valid  safe.updateX() \n; // valid I I Figure 2: Context Parameters Example The class Pair has two context parameters m and \nn. By giving fst type III X and snd type n Y, we are specifying that the values stored in f st and snd \ncome from potentially different contexts. The actual context depends upon the bindings to the context \nparameters m and n when class Pair is used. Class Intermediate uses Pair a number of times. The type \nof the field pair1 is rep Pair<rep,norep> and can be read as follows: the field pair1 is owned by the \ncurrent instance; parameter m of Pair is bound to rep, meaning that contents of the field pairl. f st \nare owned by the current instance; and parameter n is bound to norep, meaning that contents of the field \npair1 . snd are owned by the system. The following diagram illustrates a typical object graph which this \ncode could represent: Within main0 the first three calls to safe are invalid be-cause they create alternative \naccess paths to an object s rep-resentation. In particular, b() does this indirectly by creat- ing a \npath to f st2 through pair2, circumventing the owner safe. Consequently, our type rules must prevent \nthe exter-nal visibility of fields whose types use rep in any parameter position. The call to y0 is valid \nbecause it does not create ille-gal access paths, since the owner of snd2 is the root of the system. \nFrom a typing point of view, the invalidity of calls occurs because a type containing rep in one class \nis different from a syntactically identical type containing rep in a different class. The call to updateX() \nis valid even though it involves a rep, because the rep in the field pairl. f St s type is the rep from \nIntermediate via a binding to Pair s context param-eter m. This is as one would expect. We require textually \ndistinct types appearing in the same class to be distinct, regardless of their bindings. This means, \nfor example, if the field snd had type n X it would be incom- patible with values of type m X. This keeps \ntype-checking modular, and also provides a strong notion of role separa-tion. The type system guarantees \nthat the two sets of val- ues with different ownership types will be kept separate. In a sense, inside \nsuch a class, different virtual partitions are created for each context parameter, even though they may \nultimately be unified.  2.3 Owner context Figure 3 illustrates code for an unbounded stack built from \na singly-linked list of Link nodes. The class XStack provides the handle to the links. A Link node contains \na data element with context pa-rameter n. XStack has a context parameter m which is bound to n of Link. \nThis means that the contents of the appropri-ate data elements will be owned by the context correspond- \ning to the binding of the m parameter of XStack. An example XStack is illustrated in the following dia- \ngram: 4 .., L.,, next /link1 1 --l link2 I ext link3 1 class Link<n> { owner Link<n> next; n X data; \nLink(n X inData) { next = null; data = inData; class XStack<m> { rep Link<m> top; XStackO { top -null; \n) void push(m X data) { rep LinkCm> newTop = nev rep Link<m>(data) ; neuTop.next = top; top = newTop; \n1 m X pop0 { rep Link(m) oldTop = top; rep Link<ti top = oldTop.next; return top.data; 1 boolean isEmpty \n{ return top == null; } 1 Figure 3: Owner Context Example Without more context we do not know the owners \nof the data elements (given by the unknown binding to XStack s context parameter m) or the owner of the \ninstance xstack. This illustrates the reusability of a class which has con- text parameters, analogous \nto generic classes in an object oriented-language with parametric polymorphism. The main interest in \nthis example is the effect owner has on the expressiveness of representation containment. To wit, all \nthe links of the XStack are owned by the xstack object and are not visible outside of it. Within XStack, \nthe links can be freely manipulated. This provides a flexible notion of containment. To see how this \nworks, observe that the top link is rep, so it is owned by the XStack instance, xstack. Inside the instance \nof Link stored in top, owner is bound to the rep context of xstack. This can be seen from the diagram. \nNow the field top.next has type owner Link<+. Thus it is also owned by xstack. Using the same argument, \nwe can see that xstack owns all the links, as shown. Similarly, the data in all the links belongs to \nthe same partition. It is worth noting that the links of this xstack are in-compatible with the links \nof a different instance of XStack. The links of a data structure built in this manner are owned exclusively \nby the handle object (xstack). Unlimited self-referential structures can be built using this mechanism. \nAnother point worth reiterating is that the owner object is not the object that creates another object, \nnor does the owner have to refer to the objects it owns. The owner merely forms a boundary between the \ninside and the outside of an object. 3 Formalisation of an Ownership Type System The technical part \nof the paper spans this and the following two sections. We present an object-based language which resembles \nthe core of Java without inheritance, extended with object contexts. Ownership types are then defined, \nfollowed by the usual machinery required to build a type system. The key element in the type system is \nthe static visibility constraint present in the type rules for field access and update, and for method \ncall. As these expressions represent object access, we must invalidate those which would give access \nto another object s representation. Our type system checks each class against the types purported in \nthe class declaration [16]. This keeps the type system simple and modular. Next we present the operational \nsemantics for our lan-guage. The reduction rules are standard, demonstrating that we do not require ownership \ninformation at run-time. The additional type rules which determine valid stacks and stores are a little \ndifferent. These type rules are based on ownership structures which are novel; they provide a run- time \ninterpretation of ownership types. Ownership struc-tures have the same form as ownership types, but the \ncon-texts are replaced by object identifiers for the owner of ob- jects of the given type and the owners \nof the objects it uses. Using ownership structures, we formulate and prove subject reduction. Ownership \nstructures also allow us to formulate the de- sired structural properties of object graphs that our type \nsystem enforces, namely, role separation, restricted visibil-ity, and representation containment. After \nproving these properties, we conclude with a discussion of their impact on aliasing. 3.1 The Core Language \nThe core language is a simple object-based language with object contexts. This language and the subsequent \ntype rules are based on [16], with our extensions. Unfortunately, our treatment diverges from the concise \noperational seman-tics of [16] due to the object dependence of our ownership types. The core language \nsyntax is: P = defn locar e defn = class c<m*> { field* meth } field = t fd meth = t md ( arg ) { locar \ne } e = new t 1 null 1 e;e 1 x 1 x=e 1 e.fd 1 e.fd = e I e.md(e ) arg = tx local = tY GY = variable \nname or this C = a class name an object context parameter il; 1 m I rep I norep 1 0 fd = a field name \nmd = a method name t = c<MIM > We represent a program, P, as a collection of classes fol- lowed by an \nexpression to evaluate, together with its local variables. Classes take a number of context parameters, \nand con-sist of a collection of fields and methods. Simple control constructs can be added without affecting \nthe type rules. Expressions, e, are, in order, object creation, null, se-quencing, local variable access, \nlocal variable update, field access, field update and method,call. We treat method argu-ments and this \nas local variables, with the obvious restriction that this cannot be updated. Types, t, are written c<M]M*>, \nwhere c is the under-lying class. The parameter preceding the ] is the owner, and the remaining parameters \nare the bindings to the con-text parameters for class c. This notation differs slightly from the examples: \nthe type previously written rep c<m,n> is written c<replm,n>. Furthermore, we use 0 as a short- hand \nto denote owner, and treat it as we treat other context parameters. The expression new c<MJ&#38; can \nbe understood as fol- lows: firstly it creates a new object from class c in context M; it then passes \nM and ii? into the new object, so that the context information is available within the new object. For \nsimplicity there are no explicit constructors. Although Flexible Alias Protection suggested piggyback-ing \ncontext parameters onto type parameters in an object-oriented language with parametric polymorphism [38], \nto understand the essence of ownership types, we do not in-clude parametric polymorphism in the core \nlanguage. 3.2 Ownership Types Before defining ownership types, we introduce ownership schemes as a notational \nconvenience. An ownership scheme is a template from which we can create ownership types and, tater, ownership \nstructures. Ownership schemes are denoted t E c<O]rIr>, where ti are the context parameters taken from \nthe declaration of c and 0 is the implicit owner context. We create an ownership type from an ownership \nscheme by substituting for the parameters 0 and rst. Ownership types appear inside class bodies as the \ndeclared types of fields, of method arguments and return values, and of local variables. The substituted \nvalues are taken from rep, norep, 0, and the set of context parameters from the declaration of the class \nin which the ownership type appears. For example, assume class d is declared as class d<pl,p2>. Then \nit has ownership scheme d<O(pi,p2>. Let c = {O,Pl,P2}. Then t = c<p]@>, where {p} U fi s C U {rep, norep}, \nis a valid ownership type appearing in the body of class d. This is captured by the following definition, \nwhere C will be known from the context. Definition 1 (Ownership Type) Let C be a set of con-text parameters \nand t^ = c-@lfi> is an ownership scheme. An ownership type is given by subs$tuting elements of C U {rep, \nnorep} for the parameters oft. 3.3 Static Visibility Constraint The key to the type system is the static \nvisibility constraint. It restricts the access to fields and methods which are de-clared with rep in \ntheir type. Such fields and methods con-tain or access the representation of a particular object. We \nwant to restrict access to those fields and methods to the object that corresponds to the owner of the \nrepresentation. In a given class, the only expression statically guaranteed to denote the object which \nowns the rep is this. Other ex-3.4.2 Notation pressions denote-potentially different objects, so the \nrep in To simplify the presentation of the type system, we compress the type of their fields and methods \nmay be different. Based each class c in program P into a field and method dictionaryon these observations, \nwe formulate our static visibility con-as follows: straint as follows: Definition 2 (Static Visibility) \nFOT an expression e and an ownership type t, we say that t is visible to e if the fol- lowing condition \nis satisfied: SV(e, t) $f e # this + rep 6 contexts(t). SV(e, t) is called the static visibility constraint, \nwhere the function contexts(-) extracts the arguments from an owner-ship scheme, or a structure built \nfrom an ownership scheme using a substitution. It is defined as follows: contexts(c0+~) dzf {m} U 7% \nBecause we restrict access to this which can denote only one object in any context, we say that we provide \nobject-based protection. Note that the static visibility check is performed on the declared type. This \nallows one to bind rep to the context parameters of internal containers, preventing those contain- ers \nfrom being accessible outside of the current object, but allowing representation to be stored within \nthem. 3.4 The Type System Before the rules of the type system are presented, we define substitution \nand related functions which appear explicitly in our type system. 3.4.1 Substitution A substitution is \na function from context parameters to some set T. Substitutions are applied to both ownership schemes \nand ownership types. The set T will depend on the context in which the substitutions are used. If c<O1r?z> \nis an ownership scheme, then a substitution CI is a map from (0) U 7iz to T. Substitutions are be applied \nas follows: u(d<nJnl, . . , n,>) dGf d<u(n)lu(nl), . . . , o(n,)> u(n) izf p, ifn+ipEu u(n) dzf n, if \nn $Z dam(u) For example, if u = (0 I-+ p, ml I+ pl , . . , m, I-+ pr} is a substitution based on ownership \nscheme c<Olfi>, then u(d<Olml, . . , m,>) = dcplpl, . ,p,> u(d<maIrep, 0, norep>) = d<pslrep,p, norep>. \n Allied with substitutions is the function, $.J, which is a kind of inverse to substitution. II, returns \nthe substitution which was performed on an ownership scheme to generate some other structure, and is \ndefined as: +(c<nlnl,..., nr>)d~f{O+in,ml++nl ,..., m,++nn,} where t^ = c<@~+z> is the ownership scheme \nfor class c. By definition, if u = 4(t) and E is the ownership scheme underlying t, then u(i) = t. A\" \nef {fd ++ t} a map from field names to their types MC ef {md ti ((i 4 t,,,), 2, e, {y ++ t} )} a map \nfrom method names to a 4-tuple consisting of the method s type (with argument types t and result type \nt,,,), its argument variable names, its body, and a mapping from local variables to their types. These \ndictionaries are easily determined from a program. Since the underlying class of an ownership scheme \nis deter- mined by inspection, we allow the above dictionaries to be associated with ownership schemes, \ntypes and structures as well. 3.4.3 The Type System The type system is defined with respect to a program, \nP, and two environments: an object context environment and a type environment. An object context environment, \ndenoted C, is a collection of context parameters, defined as follows: C::=cIC,m where m are context \nparameters and E is the empty envi-ronment. Generally these are the context parameters that appear in \na class declaration along with 0. A type environment, denoted P, is a mapping from vari-ables to ownership \ntypes, defined as follows: In our system, the domain of I? will always include this and appropriate arguments \nand local variables for checking a method definition. The notation I {Z : z!} represents ex-tension of \na type environment with multiple variables and their types. The type system is given in Figure 4, and \nis based on the following judgements. l-, P : t P is well-formed with ownership type t P kd defn defn \nis well-formed P, C, PI-,,, meth meth is well-formed P,C,rl-,e:t e is well-formed with ownership type \nt P, c t-t t t is well-formed  3.4.4 Explanation The rule (Program) states that a program is valid if \neach of its definitions are valid, and the expression to be evaluated is well-typed given the types of \nits local variables. The local variables types do not contain any context parameters as the expression \nis not evaluated within the body of some class. Class validity is checked by the rule (Class). It assigns \nthis the type c<@)r?z>. Methods are typed in an environment with this given that type, and C includes \n0 and the context parameters from the class header. We also require that the field types are well-formed \nusing the same C. (Program) P kd defni for j E [l, n] P, 8 l-t t{ for I E [l, m] P, 8, {$ : I?} l--e \ne : t I-. P : t where P = defnl ,..., defn, t; y; ,..., t &#38; y,,, e (ch.3s) P, C kt tj for j E [l, \nn] P, C, {this : c<Q~TTI>} I-, methk for k E [l,p] P t d class c<ti>{tl fd, . . . t, fd,, methl . . . \nmet&#38;} where C = (0) U 7fi ( h-4 M, A? E C U {rep, norep} P, c t--t c<Mpf> (Method) P,Cht P,Ck-ttjjE[l,n] \nP,Cl-tt;forIE[l,m] P,C,l?{Z:i,jj:i+}i--.e:t P,C,rt-,tmdt121 ,..., tn5, ){G Yl , a > t I m ym e (New) \n(Null) (Sequence) P, c t-t t P,C t-t t P,C,rl--,el:tl P,C,rt-eez:tz P,C,rl--,newt:t P, c, r I--enull \n: t P, C, r I-, el; e2 : t2 (Local Access) (Local Update) x E dom(l?) P, C, r l-c e : I'(X) x E dom(I \n)/{this} P,z,r t-e z: r(x) P,C,rl--,x=e:r(c) (Field Access) P, C, I? l-c e : t u = $(t) d (fd) = t SV(e, \nt ) P, E, r i-e e.fd : u(t ) (Field Update) P, C, I I-, e : t 0 = $(t) dt(fd) = t P, C, I I-* e : a(t \n) SV(e, t ) P, C, r t--e e.fd = e : u(t ) (Method Call) P,C,r!--,e:t u = w Mt(md) = ((f + t ), -, -, \n-) P, C, r I-, ei : U(ti) i E [l, n] SV(e, t ) A r\\iE,l n, SV(e, ti) P, YE, r l--e e.md(el,. . . , e,) \n:a(t ) Figure 4: The Type System (Type) uses ownership schemes extracted from the pro-gram P to build \nvalid types by performing a substitution where the target set consists of object contexts rep and norep, \nplus the context parameters in scope (C). (Method) checks the body of the method in the type environment \nresulting from adding the argument and local variable types to F. The rule also requires that the type \nof each argument and local variable is well-formed with respect to c. (New) creates objects at an ownership \ntype. Similarly, we have a null at each type. This is a restriction because a new object (and null) should \nbe considered free [38], and be subsequently coerced to another type. But the notion of free requires \na linearity restriction, that is, the new object cannot be shared until we know its correct ownership \ntype, and its integration is a subject for future research. Note that free is not the same as unique \n[23], because free only applies to newly created objects (and null). (Sequence) enforces that the type \nof two expressions in sequence is the type of the latter expression. Local vari-ables are given the type \ndeclared in the type environment r (Local Access). Rule (Local Update) enforces that this is not updatable, \nand requires the expression to have the same type as the local variable. In the rules for (Field Access), \n(Field Update), and (Method Call), we initially extract from the type of the left hand side expression \na substitution, u. The type of the field/method is extracted from the appropriate dictionary. This type \nis the type declared in the program text. By ap-plying the substitution to that type, we check the remainder \nof the expression and give the type of the entire expression. The step would be implicit in a standard \nformulation of a type system. But, to properly check static visibility and separate reps from different \ncontexts, we need the declared type to perform the SV() check. Expressions of syntactically different \ntype appearing in the same context are incompatible. This is because there is no subtyping between object \ncontexts, nor at the type level. Because type coercions lose information or require recovery of unknown \ninformation, inheritance and subtyping are not yet supported. These and other extensions are the focus \nof active research. Operational Semantics This section presents a complete operational model for the \ncore language in terms of reduction rules. These rules de-scribe expression evaluation with respect to \na state consist-ing of a stack and a store. The only surprising feature of the operational semantics \nis that the object contexts play no role, demonstrating that our type system imposes no run-time overhead. \nTo demonstrate soundness of our type system, we prove subject reduction. To do so we provide type rules \nspecifing valid execution environments, in a manner similar to [l]. We also introduce a run-time interpretation \nof ownership types. The context-dependent nature of the type system is clearly apparent from this interpretation \nfunction. A few technical lemmas help us to prove subject reduc-tion. The subject reduction result takes \nthe form of a gener- alised subject reduction theorem, which applies to open ex-pressions with a given \nstate, rather than closed expressions. From this we get the ordinary subject reduction theorem by specifying \nan initial execution environment in which to ex-ecute a program, P. This environment combined with the \ngeneralised subject reduction theorem allows us to formulate structural properties which are proven in \nthe next section. 4.1 Stacks and Stores The evaluation environment consists of a stack and a store. These \nare defined as follows: Definition 3 (The Store) The store, S, is a map from object identifiers, o, to \nobjects, 7. An object is a map from field names to v&#38;es (v ::= 0 1 null). l S dgf {o I+ T} where \n.F dgf {fd ct wu)*, dam(r) = dom(d ), and c is the class ofo. We have the following operations on stores: \nS U {o I+ .F} is the store obtained by adding to S a new object o and its field map, where o e dam(S). \nS[o ++ fi is the store obtained from S by updating ob-ject o with field map F, where o E dam(S). 3Lfd \nc-) v] is the result of updating field fd of 7 with value 2). Method arguments and local variables are \nstored on a stack, along with the object whose method is invoked (as variable this). Because stack contents \ndepend on the invoked object, stacks are grouped into stack frames, built from left to right, so that \nthe stack s top is the rightmost stack frame. Definition 4 (The Stack) A stack frame, 6 dgf {z I-) v}* \nis a map from variables to values. It has the following oper-ations: l 6(x) dAf v, where z H w E 6 (F \nrame Lookup) l 6[x I+ u] is the stack frame formed by replacing the value that x maps to by v (Frame \nUpdate) A stack, A d~f&#38;e.-e6,, is a list of stack frames. 6, is the top of the stack. A stack has \nthe following operations: a A 8 6 is the stack constructed by pushing 6 onto A l A(z) dgf a(z) (Lookup) \nl A[x c) w] dgf A 8 6[z c) V] (Update) where A E A 6 d in the last two operations. For well-typed programs, \nall lookups and updates per-formed in the operational semantics will be on valid vari-able names. In \nparticular, the variable this exists for all stack frames.  4.2 Reduction Rules The operational semantics \nare given in Figure 5. They are expressed in terms of a reduction relation which associates a store S, \na stack A and a term e with a value v, another store S , and another stack A . The relation is written: \nS.Al-euv/S .A (Red New) E+S.(A:D) o $Z dam(S) S~A~newt~o/S~{o~{fd~null~fd~dom(dt)}}~A (Red Local Access) \nEbS.(A:D) S,AI-x-v S.A where A(x) = v (Red Local Update) S.Al-e-v S .A S. A I- x = e u v/S A x I+ v] \n(Red Field Access) S.At-e--+o/S .A , , . I-e.fd-v there S (o)(fd) = v (Red Field Update) S.Al-euo/S \n.A S ~A ke --+v /S2~A2 S . A I- e.fd = e -v /S [o I-+ Fvd I+ v ]] . A where S (o) = F (Red Sequence) \ns. A I- el -A m/S1 . A S . A I- es u vzlS2. A2 S~Al-e~;ez-v2/S2.AL (Red Method Call) S.Abe-o/S .A S .A \nl-e 1-=+vl/S2.A2 S . A I- e, u v,,/S + . An+ S n+l . A + 8 {this C) o, I I+ V, $ C) 71) t- e u v /S \n. An+ 8 6 S . A k e.md(el, . . . , e,) -v /S . A + where o has type CC . 1. >, M (md) = (-, f, e , Z), \njj = dam(l) and dam(6) = {this} U Z U G Figure 5: Reduction Rules and means that with store S and stack \nA, the term e reduces to value v yielding an updated store S and updated stack A . Reductions are in \na natural or big-step reduction style semantics [36]. The reduction rules are standard, unsurprising, \nand cap- ture the behaviour of a simple object-based language. The assumptions for rules (Red New) and \n(Red Local Access) are well-typedness of the store and stack. These are defined in Section 4.4. (Red \nMethod Call) requires some explanation: to evaluate the expression e.md(el, . , e,), first evaluate e \nto some value w; if u is an object o (that is, not null), then each argument e, is evaluated to some \nvalue v; in the re-sulting context; a new stack frame is built with this mapped to o, each argument z; \nmapped to the appropriate value vi and each local yj mapped to null; and then the body of the method \nis evaluated to v with the new stack and store. After this evaluation has finished, the top stack frame \nis discarded. The whole expression evaluates to 21 . Note that stack frames lower in the stack are not \ntouched. This last fact can be verified by induction on the rules using the def-inition of stack. Note \nthat the rules ignore dereferencing of expressions which evaluate to null. Technically, this would evaluate \nto some error configuration and additional rules would pro-pogate thisthrough other expressions. Handling \nnull is omit- ted because it does not change the results and its omission simplifies the presentation. \n 4.3 Ownership Structures Ownership structures provide the basis for a semantic in-terpretation of ownership \ntypes. They are used in proving soundness of the type system. The interpretation is novel, but to a certain \nextent, natural. An object context denotes an owner which is another object, so when interpreting an \nownership type, we replace each object context and context parameter by the owner it denotes. This gives \nan ownership structure, defined as follows: Definition 5 (Ownership Structure) Let CJ be a set of object \nidentifiers and c<O/7Fz> an ownership scheme, then r = c<oJO>, where {o} U 0 2 0, is an ownership structure. \nIf p is an object whose ownership type is interpreted as cco]O>, then the owner of p is o. The objects \n6 constitute the owners of objects used by p. The semantic interpretation, I[$,, is defined for each \nob- ject, o, and takes ownership types to ownership structures. It uses the ownership structure of o \nin its definition. This is because any ownership type which [-I0 interprets appears in the body of o \ns class, c, and is defined in terms of rep, norep, 0 and the context parameters from the class c. An \ninterpretation gives values to each object context and con-text parameter in scope in class c. The function \nI[$, uses the ownership information in o to interpret the types of objects used by o. This provides a \nway of propogating ownership information from one context to another, which is what the context parameters \ndo statically. Definition 6 (Semantic Interpretation Function) Let object o have ownership structure \nT, with CCC~~TFOthe ownership scheme for T and u = $(r). Define [&#38;,, the semantic interpretation \nfunction for 0, as follows 6% d2f u(Q) lrn&#38; tZf u(m) [norep], ef root Translating rep to o confirms \nthe fact that o own s its representation. norep is consistently mapped to root, an object representing \nthe root of the system, which is defined precisely when we specify the initial configuration. The sub- \nstitution D allows propogation of the bindings in the context in which o is defined to objects used by \no. It must be stressed that rep is interpreted differently for different interpretation functions. Thus, \ntwo ownership types containing rep are in- compatible precisely when they come from different objects. \nIt should be clear that not all ownership structures can be built using a given interpretation function. \nThis means that types are not visible in all contexts. In particular, types with rep will not be visible \noutside of their owner. The subject reduction theorem amounts to saying that at no point in a program \ns execution will an object be in a context where its type is not visible. This notion of visibility is \nused in defining valid execution environments. 4.4 Valid Execution Environment We can now precisely \ndefine valid stacks and stores, a deli- cate but essential task for proving subject reduction for im- \nperative languages. This is further complicated by our def-inition of ownership structures which introduce \nadditional circularity into the definitions: objects are defined in terms of types; types are defined \nin terms of objects. As we will see, this causes no real difficulty because we can start the def-initions \nusing a collection of object identifiers about which nothing is assumed. Figure 6 provides the complete \ndefinition of stacks and store typings. Types are ownership structures built from a set of object identifiers \nby (Type Type). A store typ-ing, which is a type environment for object identifiers, is a mapping from \nobject identifiers to ownership structures by (Store Type). (Object Type) and (Null Type) correspond \nto value typings: object types are given in the store typing E, and null can have any available type. \n(Stack Frame) con-strains the construction of valid stack frames so that 1) this is always present, and \n2) the type of the other elements in the frame are interpreted correctly with respect to the ob-ject \nwhose method was invoked. (Empty Stack) and (Stack Type) build stacks as lists of stack frames. (Store \nCompo-nent) is similar to (Stack Frame); the ownership structure of an object s fields must have an interpretation \nwithin that ob-ject, where the ownership types are taked from the class defi- nition. (Empty Store) and \n(Store Construction) build stores from objects. Finally, (Stack Store) defines valid stores and stacks: \nfor some store typing, we require that the store is valid, the stack is valid and that every object assigned \na type in E appears in the store. 4.5 Subject Reduction Soundness of the type system is based on a generalised \nsub-ject reduction theorem which states that the semantic inter-pretation of a term s type is invariant \nunder reduction. We prove this theorem for terms which are not closed, having free term variables and \ncontext parameters. an object identifier v ::= 0 1 null a value a set of object identifiers 7 ::= {fd \nI-+ v}* an object s ::= (0 c) F} the store 6 ::= {z I+ v>* a stack frame d ::= {z : 7) stack frame typing \nA::=&#38;e...e&#38;, a stack D ::= dl 8 . . .8 d, stack typing 7- ::= C<OlOl,. . . ,Or> an ownership \nstructure E ::= {o ti r}* store typing well-formed type judgement Oi=T well-formed store judgement El=0 \nEb=V:7 valid typing judgement EbafS:d valid stack frame judgement E +at A : D valid stack judgement EbotiF \nvalid store component judgement valid store typing judgement Ei=S E+S.(A:D) valid stack and store judgement \n(Type Type) (Store Type) (0) u 6 s 0 dam(E) + E(o) for each o E dam(E) 0 c<o 6> E+O (Object Type) (Null \nType) El=0 El=0 d;;C?l= E /= o : E(o) (Stack Frame) E k o : T E k vt : [t;jo for i E [l,n] E b8f {this \nC) o, Z I-+ CJ} : {this : T, Z : [$} where contexts(&#38;) C_ contexts(0 U {rep, norep} and i is the \nownership scheme of T (Empty Stack) (Stack Type) E/==,tA:D Ebsf6:d El=0 E l==st 0 : 0 E+,tAeh:Ded (Store \nComponent) E k 0 : T E k TJ~ : [ti]o E+oct{fdic,vi} where r I CC. ] . > and fdi E dom(d ), d (fdi) = \nti (Empty Store) (Store Construction) E+S EbotiF oedom(S) + E~SU{OHF} (Stack Store) E /= S E bst A : \nD dam(E) = dam(S) E + S. (A : D) Figure 6: Valid Execution Environment The full proof of subject reduction \nis straight-forward but tedious, so has been omitted. Its only enlighting as-pect is captured in the \nfollowing visibility lemma, which is the dynamic version of the static visibility constraint. For a given \nobject, we deem an ownership structure to be not visible when the object s interpretation function cannot \npro-duce the ownership structure. The visibility lemma captures the notion that if one object, o , has \na reference to object, o, then only those ownership types without rep in o can be correctly interpreted \nby I[&#38;+. So the fields and methods of o that o can validly access, that is, the ones which are visible, \nare those without rep in their type, and fields and methods with rep in their type are invisible. Lemma \n1 (Visibility Lemma) 1) If E + o : T then 7 = I&#38;,, where t^ is the ownership scheme of r. 2) Let \nE /== o : r where t^ is the ownership scheme for 7. Let o E dam(E). If 7 = I[&#38;,# for some t, then \nfor any owner- ship type tt such that contexts C contexts(i) U {norep}, we have [o(tt)JJO, = I[t$, where \no = $(t). The first clause states that an object has the correct ownership structure with respect to \nits interpretation function. The second clause states that if the ownership structure of an object can \nbe interpreted with respect to another object s interpretation function, then the second object s interpretation \nfunction can interpret any type that the first object s function can, so long as the ownership type does \nnot contain rep. The lemma does not apply at rep, because rep in two different objects is guara nteed \nto have a different interpretation. Proof. 1) Holds by definition of I[$,. 2) Let II = contexts(i) U \n{norep}. Note that both o and [&#38; are defined for II. Firstly, t = a(8) by the definition of +, Given \nt^ s c<O(fi> from 1) and the definitions of ~7 and [[-I-, we have Thus, because II = (0, norep} U ti, \nwe have that, for each m E II, [u(m)]ol = [m]lO. (Because norep always maps to root, the equation holds \nfor norep.) Then, by definition of I[-]-, if contexts C II, [u(t+)Jjo, = [t+Jo. 0 Because we are evaluating \nnon-closed expressions, we re-quire a condition relating free term variables I , with the stack A, and \nfree context parameters C, with an appropri-ate interpretation. The condition requires that the execu-tion \nenvironment is well typed, that the free variables have an appropriate ownership structure with respect \nto the cur-rent object, A(this), and that the context parameters in the ownership scheme of the current \nobject s type correspond exactly to C. Definition 7 (Valid) The predicate valid@, r, E, A, D) is true \nif and only if E /= A(this) : 7thil, for some Tthis, c = contexts(&#38;,;,) where &#38;his is the ownership \nscheme for Tthis; and dam(r) = dam(d) and Vx E dam(r), d(z) = [r(z)J/a(this), where D = D 8 d. This validity \ncondition constrains only the top frame of a stack. In the appropriate environment, all other stack frames \nwill be well defined via rules for a validly typed stack, but their value is not used in reduction. This \ncan be dexnon- strated by an induction on the reduction rules. The statement of the theorem requires \nstore typing ex-tension. For the full proof, appropriate extension and re-placement lemmas hold (analogous \nto [l]). Definition 8 (Extension) We say that E is an extension of E (written E k E) if and only if dam(E) \n2 dom(E ) and Vo E dam(E), E (o) = E(o). Note that >_ is transitive. Theorem 1 (Generalised Subject Reduction) \nIf P,C,l?!--,e:t, S.Ake~uls .A , E+S.(A:D), and valid@, r, E, A, D), then there exists an ownership structure \nT and a store typing E such that E >-E, E k S . (A : D), E i-= IJ : 7, 7 = [t]&#38;@hisj and valid(C, \nI , E , A , 0). Proof. The proof is by induction on the derivation of S. A k e 23 w/S . A , following \nthe style of [lJ. The only enlighting aspects of it are captured in the visibility lemma. The static \nvisibility condition invalidates those expressions for which the visibility lemma does not apply, where \nthe representation is accessed outside of its owner. I 4.6 Initial Configuration To obtain a subject \nreduction for programs, we need to de-fine an initial configuration in which to begin execution. This \nconfiguration is also used in the next section in proving structural properties of object graphs. Definition \n9 (Initial Configuration) Given a program P = drrefn f 5 e, we define the initial store as: &#38;it fEf \n{root ct 0). The initial stack is the single stack frame: binit dzf {this C) root, 5 ti n%l}. For valid \ntyping, we introduce a class Root which has no context parameters. The initial store typing Ei,it = {root \n: Root} gives Ei,i, /= root : Root. Also define [-],,,, as [rep]lroot +Sf root [norepjroot 5Sf root. \n The object root and the class Root are purely semantic artifacts, because we need an object corresponding \nto the owner of values with norep as their owner, and for complete- ness, we also give it a type. Using \nthe initial configuration above, we get the subject reduction theorem: Corollary 1 -With P E defn i ij \ne, if l-P P, P, 8, {y : t) I-e : t and Sinit 1 Ainit I- e * V/S . A, and Einit + yi : [tijroot for each \nlocal variable yi, then there exists an ownership structure r and a store typing E such that E k Einit, \nE k v : 7, and i-= pnroot - 5 Structural Properties of Object Graphs Definition 10 (Articulation Point) \nFor a graph cJ, node k E 6 is an articulation point for paths from a to b, a, b E E, In this section \nwe formulate three structural invariants which if all such paths pass through k. hold for well-typed \nprograms. These are role separation, re- stricted visibility, and the representation containment. The \nlatter has interesting consequences with respect to alias pro- tection and containment, so we devote \nan additional section to discussing it. 5.1 Role Separation Role separation is actually a property of \nthe type system. Because there are no coercion operations in the type system and because type checking \nis modular, we have: ROLE SEPARATION: Two different ownership types appearing in the same context are \nnot com- patible, regardless of the ensuing bindings. This means that the type rules are necessarily \nconser-vative, but it does guarantee that a class will behave the same way regardless of the bindings \nto its context param-eters. Thus we have a static guarantee that values of two ownership types will not \nbe mixed within a class, regardless of their bindings. 5.2 Restricted Visibility Restricted visibility \nsays dynamic aliasing of representation is not allowed. A dynamic alias is an access which may occur \nvia field access, through the stack, or as the result of a method call [23]. One could imagine such references \nwere valid, even though assignment was not. They aren t. Recall that we say an object is visible in a \ncontext if an interpretation exists for its ownership structure. The required property is then: RESTRICTED \nVISIBILITY: Objects assigned to fields, passed as arguments to method calls, re-turned from field access \nor method call must be visible in both the context of the callee and the caller. In particular, one \ncannot access an object with rep in its type from outside its owner. Restricted visibility follows from \nsubject reduction. 5.3 Representation Containment Representation containment is our formulation of a \nno repre- sentation exposure property. We characterise this property in terms of paths from the root \nof the system as follows: REPRESENTATION CONTAINMENT PROPERTY: All paths from the root of the system \nmust pass through an object s owner. Alternatively, the only path from the root of the sys-tem to an \nobject s representation is through that object. In a sense, this means that an object is in control of \nits representation because the rest of the system must use the object s interface to affect any changes \nupon the represen-tation. And, in a strong sense, the representation can be viewed as being inside its \nowner. The remainder of this section is devoted to formalising this in terms of articulation points [2]. \nThe property we prove is actually stronger. Next we define an object graph. This requires a simple modification \nto a program so that newly created objects appear in the object graph explicitly. This is done simply \nby requiring that, at the point of creation, a new object is stored in a new local variable of the correct \ntype. It can be shown that this transformation preserves program semantics. (This trick is a simplified \nversion of the A normal form [44]). We use the notation o -+ o to indicate that o has a reference to \no , where o,o E dam(S). Intuitively, these are the edges of an object graph: Definition 11 (Object Graph) \nGiven a store typing E, a store S and a stack A E 618.86, such that E k S.(A : D) the object graph, GS.A, \nis the smallest graph satisfying the following: 1. for o = &#38;(this), i E [l, n], o E &#38;.A (method \ninvocation target) 2. for non-nUll 0 E rng(&#38;), 0 E 6s.~ and 0 -+ 0 E &#38;.A, where o = &#38;(this), \nfor i E [l, n] (stack frame reachability)  3. if o E &#38;?~.a, with F = S(o), then for each non-null \n 0 E rng(F), 0 E &#38;.A and 0 -+ 0 E &#38;.A (store reachability) Furthermore, the root of the graph \nis 61 (this). Finally, for an object o, define ap(o) dgf contexts(r), where r is the ownership structure \nof o. Definition 12 (Representation Containment) The representation containment property, RC(-) for an \nob- ject graph, &#38;.A is defined as follows: RC(ES.A) dgf Vo E Gs.A, Vk E J/J(O), k is an articulation \npoint for paths from root to o. This defines representation containment for a particular snapshot of \na program s evolving object graph. It remains to prove that it is invariant over the object graphs for \nthe entire program execution. The argument is inductive in the size of the graph. It is easy to see that \nremoving edges and nodes, or adding nodes does not invalidate the graph, so we just consider adding new \nedges. The following lemma provides a necessary condition for a reference to exist. Lemma 2 If 7 is the \nderivation tree of the evaluation Sinit. A; i, k e X+ v/S . A and S A is any store and stack pair appearing \nin 7 (on either side of the evaluation relation), then for all o + o E &#38;.A, ap(o ) g ap(o) U (0, \nroot}. Proof. Each o -+ o E &#38;.A exists due to a store or stack reference. Let r and 7 be the types \nof o and 0 . To be a valid store reference, 7 = [t'lo for some t' by (Store Component). Similary, for \nstack references by (Stack Frame). By the def- inition of [-IO, contexts(+) c rng([&#38;) = ap(0) U (0, \nroot}. ap(o ) = contexts(#), by definition, thus we have ap(o ) E ap(0) U (0, root}. 0 The following \nlemma is standard for articulation points. Lemma 3 Let k be an articulation point on paths from r to \nboth p and q in graph G. Adding p + q to B preserves the articulation point for both p and q. And now \nthe proof that the representation containment property is invariant over the execution of a program: \nTheorem 2 (Representation Containment Invariance) If 7 is the derivation tree of the reduction S;,;r \n. Ai ;, I- e ti vfS . A and S. A is any store and stack pair appearing in 7 (on either sa deof the reduction \nrelation), then RC(GS.A). Proof. 1) Clearly RC(Gs,,;, A,.,~). 2) (Inductive step). As- sume that for \nsome well formed S. A, with 6 = GS.A, that RC(S). It is sufficient to consider the effect of adding an \nedge p -+ n (via a valid field update or stack frame con- struction) to produce a new graph 6 . For a \ncontradiction, assume that the representation containment property fails for n in 6 . By Lemma 2, ap(n) \n2 ap(p) U {p, root}. Otherwise, the assignment would create an invalid store or stack. Therefore k E \nap(p) or k = p or k = root. k E ap(p). Then k is an articulation point for p in E. By lemma 3, k is also \nan articulation point for p and n in the Q . A contradiction. k = p. Removing k from G breaks paths from \nthe root containing edge p -+ n. By assumption, any other path from the root to n had k as an articulation \npoint. Therefore, k remains an articulation point for n. A contradiction. k = root. By removing the root \nnode from G, the artic- ulation property is vacuously true. Again, a contradic- tion. Cl 6 Discussion \nWe now discuss the consequences of basing representation containment on articulation points; we compare \nthis work with flexible alias protection; and we point out some of the limitations. 6.1 Containment Our \nmodel of alias protection is based on restricting the scope of aliasing using containment, rather than \nlinear-ity constraints which are not entirely compatible with object-oriented programming. By considering \nthe following interpretation of articulation point, we obtain a clear notion of inside and outside. An \narticulation point partitions a graph into two subgraphs: the inside: objects reachable from the root \nonly via paths through the articulation point; and the outside: the remainder of the objects. We consider \nthe articulation point, or the owner, to be on the boundary. The following diagram illustrates this idea. \nBased on this idea, we can say that flexible alias pro-tection prevents object access from outside its \nowner. Ref-erences can go from the inside to the outside, but not vice versa. Our model does not require \nobjects to be referred to by their owner. This allows arbitrary self-referencing data structures to be \ninside another object. Furthermore, articulation points form a tree (the dominator tree in [3]) which \ncorresponds to having nested containment relation-ships. Elsewhere [40] we have pursued this idea to \nrecognise the inherent containment relationships in evolving object graphs. Furthermore, the model based \non articulation points is faithful to the model of containment in object-oriented mod-elling given by \nthe part-of or has-a relationship [43]. 6.2 Relationship with Flexible Alias Protection This work is \na formalisation of the core of flexible alias pro- tection [38]. The precise correspondence is discussed \nin this section. Flexible alias protection annotated types with mode dec- larations. These do more than \nour context declarations by expressing restrictions on effects and dependence on muta-ble state. Ownership \ntypes do not address these issues, as outlined below. We have introduced the context parameter owner, \nab-sent in [38], allowing us to type this. Doing so has also increased our modelling power: we can build \nan arbitrary self-referencing data structure and impose the restriction that all of its nodes are owned \nby its handle object. We pre- sented one such example, a stack implemented as a linked list. The context \nparameter owner adds more flexibility to flexible alias protection. Flexible alias protection has an \naliasing mode var which is described as a loophole to obtain normal reference seman-tics when required. \nIt also has an optional role parameter, which, when present, imposes the restriction that each role must \nbe kept independent, that we call role separation. In our system, norep corresponds to var without a \nrole param-eter, and context parameters correspond to var with a role parameter. The semantics of internal \nobject context rep is consistent with its use in [38]. Finally, our system lacks some elements of the \nflexible alias protection model. The most significant is arg mode which restricts object access to the \ninterface which does not depend on immutable state. Roughly, this corresponds to parts of an object s \nextended state which are fixed from the moment the object is initialised. Mode free, omitted for sim- \nplicity, represents newly created objects as not being owned by anyone. The mode val for value objects \nwas omitted because we are not yet concerned with effects. Value ob-jects can be given any object context, \nin particular norep, if the values are to be shared arbitrarily. Furthermore, we omitted parametric polymorphism, \nagain for simplicity. Nor do we include inheritance, but [38] makes no mention of it either, due to the \ndifficulty caused by loss of information. Maintaining the representation containment invariant in the \npresence of subtyping cannot be achieved by extending the system here in the obvious way. 6.3 Limitations \nApart from the object-oriented features, inheritance in par- ticular, not yet incorporated, there are \nsome limitations in the containment model based on articulation points. Firstly, we cannot, for example, \nconstruct external itera-tors over the representation of some object. An example in [38] solves this \nby lifting the owner of the representation to the highest context where both the iterator and the list \nare used. This is clearly unsatisfactory, as it defeats the purpose of containment. The path we intend \nto take in solving this is by having multiple owners and by reformulating reference containment in terms \nof cut sets. However, we are unsure of how this affects static typing. The second limitation is that \nwe cannot support multiple representations visible in the same context. An example where this is required \nis for friendly functions such as plus for objects representing money, for example. This seems easy to \nresolve by relaxing the allowable forms of dynamic aliasing. Finally, change of ownership does not fit \nwell in the model, nor is it easily captured in a static type system. 7 Related Work The problems engendered \nby reference semantics and alias- ing are well known. These problems are particular severe for object-oriented \nprogramming languages [4, 23, 241 where aliasing is common-place. To control aliasing, researchers have \nconsidered explicit notions of aggregation, object containment, and ownership (23, 4, 12, 26, 14, 191. \nHogg s Islands 1231 and Almeida s Balloons [4], have a similar aim called fuU alias encapsu-lation which \nprohibits any references from crossing the en-capsulation boundaries. Unfortunately, full encapsulation \nof aliasing is too restrictive for many common design idioms used in object-oriented programming, such \nas sharing data between two collections. Both Islands and Balloons distin-guish between static and dynamic \naliases -a dynamic alias is caused by a short-lived, stack allocated variable. To gain flexibility, these \nsystems permit various forms of dynamic aliases with otherwise encapsulated objects. Unfortunately, such \nflexibility often defeats their system s safety. In our system, we protect against both static and dynamic \naliases. The intuition underlying Kent and Maung [26] is at the heart of our work. They proposed an informal \nextension of the Eiffel programming language with ownership anno-tations that are to be explicitly tracked \nand monitored at run-time. Besides statically achieving the constraints their run-time checks impose \n(apart from their extension for mul- tiple ownership), our system also restricts object visibility through \ndynamic aliases, something their system fails to do. None of the above approaches have been completely \nfor-malised, despite considerable effort. We have a sound for-malisation and proven alias protection \nguarantees. Much work has been done in program language semantics in proposing means for coping with \npointers and references including [27, 13, 41, 30, 21, 5, 8, 7, 461. Special reference attachment mechanisms \nhave been proposed for language run-time systems to enforce unique or linear pointers [6, 11, 34, 20, \n281. Unfortunately, these proposals forbid many common uses of aliasing in object-oriented programs. \nA common approach to preventing representation expo-sure is by restricting the access to variable names. \nBut the private and protected modes of Java and C++, for exam-ple, and related mechanisms [18, 15, 17, \n321, or their formal models [42, 11, fail to adequately constrain the sharing of object references. Name \nprotection does not enforce alias protection, because, for example, an externally aliased ob-ject can \nbe assigned into a private field, or the contents of a private field can be exported by another means. \nThis is more likely to happen when subclassing a class for which the internal invariants are unknown. \nCreating external ref-erences can break these invariants. Our type system can prevent such external references, \nthus providing a stronger form of protection than name protection. In the r-calculus resources are protected \nby restricting the scope of a name [33]. Other process calculi model capa-bilities [lo], which control \naccess to resources. Such notions seem applicable to alias protection. But these calculi are operational \nmodels which do not provide static protection. One exception introduces location types [22] and provides \na static type system which prevents access control to resources for which the capability is not held. \nBut because there is no concrete notion of an object, or object reference, it is unclear how their system \ntranslates to object calculi. The work on security calculi and their type systems are certainly related \nto our work. Indeed, part of Leroy s for-malisation [29] of security properties of strongly-typed ap-plets \nconstrains references in one environment from being accessible in another. To prevent references being \nleaked to applets, the browsers API must not contain any references types. We see this as a major limitation \nin his system which the present system overcomes. The work that most closely resembles ours on a purely \nformal level is the work on regions [45]. Regions are aimed at improving memory management for a functional \nlan-guage @ML), with region information being inferred us-ing Hindley-Milner-style type inference. On \nthe other hand, ownership types are declared and provide alias protection for object-oriented languages. \nIt is nonsensical to infer which objects are representation; such information is part of the programmer \ns intention. Nevertheless, the underlying tech-niques are similar, modulo encoding objects into a functional \nlanguage [9]. To be precise, rep corresponds to letregion, and context parameters correspond to region \nvariables. Regions also include read and write effects, which we do not. To our knowledge, no existing \nformal system statically models object ownership and statically prevents object ac-cess from outside \nan object s owner as ours does. 8 Conclusion Although necessary in object-oriented programming, unre-stricted \naliasing is problematic [24], and therefore must be controlled. This paper presents a formalised system \npro-viding alias control, proves its soundness and the invariance of specific aliasing properties, namely \nrole separation, Te-stricted visibility and representation containment for well-typed programs. This \nis the first static type system for an object-based language offering alias protection. Its key mechanisms \nare limiting visibility of objects using the inter- nal object context rep, and safely extending visibility \nusing context parameters. We have implemented flexible alias protection by extend- ing Pizza [39]. Our \nimplementation statically validates own-ership types according to the type system presented here. With \nexperience, this will allow us to gain a clearer picture on the use and limitations of ownership types. \nThere are many directions for future research. Extending the type system to include inheritance is our \nimmediate goal. The control of aliasing with respect to other programming language constructs such as \nfriendly functions and multi-methods will subsequently be considered. Further work will include developing \na more thorough understanding of the re- lationship between the static and dynamic semantics, study-ing \nthe properties induced by ownership structures, and ex-tending the ideas to concurrent object systems. \nAcknowledgements We would like to thank our colleagues Ryan Shelswell, Geoff Outhred, Ian Joyner, and \nthe anonymous referees for their insight and criticism which made this a better paper. This work was \nsupported by Microsoft Australia. References [l] Martin Abadi and Luca Cardelli. A Theory of Objects. \nSpringer-Verlag, 1996. [2] Alfred V. Aho, John E. Hopcroft, and Jeffrey D. Ull-man. The design and analysis \nof computer algorithms. Addison-Wesley, 1974. [3] Alfred V. Aho, Ravi Sethi, and Jeffrey D. Ull-man. \nCompilers: Principles, Techniques, and Tools. Addison-Wesley, 1986. [4] Paulo Sergio Almeida. Balloon \nTypes: Controlling sharing of state in data types. In ECOOP Proceedings, June 1997. [5] Pierre America \nand Frank de Boer. A sound and com-plete proof system for SPOOL. Technical Report Tech-nical Report 505, \nPhilips Research Laboratories, 1990. [6] Henry G. Baker. Use-once variables and linear objects -storage \nmanagement, reflection and multi-threading. ACM SIGPLAN Notices, 30(l), January 1995. [7] Edwin Blake \nand Steve Cook. On including part hi-erarchies in object-oriented languages, with an imple-mentation \nin Smalltalk. In ECOOP Proceedings, 1987. [8] Alan Borning. The programming language aspects of ThingLab, \na constraint-oriented simulation labora-tory. ACM Transactions on Programming Languages and Systems, \n3(4), October 1981. [9] Kim B. Bruce, Luca Cardelli, and Benjamin C. Pierce. Comparing Object Encodings. \nIn Theoretical Aspects of Computer Software (TAGS S );), LNCS 1281, pages 415-438, 1997. [lo] Luca Cardelli \nand Andrew D. Gordon. Mobile Ambi-ents. In Foundations of Software Science and Computa- tion Structures, \nEuropean Joint Conferences on Theory and Practice of Software, March 1998. [ll] Edwin C. Chan, John T. \nBoyland, and William L. Scherlis. Promises: Limitied specifications for analysis and manipulation. In \nIEEE International Conference on Software Engineering (ICSE), 1998. [12] Franc0 Civello. Roles for composite \nobjects in object- oriented analysis and design. In OOPSLA Proceedings, 1993. 113) Alain Deutsch. Interprocedural \nMay-Alias Analysis for Pointers: Beyond k-limiting. In Proceedigns of the ACM SIGPLAN 94 Conference \non Programming Lan-guage Design and Implementation, June 1994. [14] Jin Song Dong and Roger Duke. Exclusive \ncontrol within object oriented systems. In TOOLS Pacific 18, 1995. [15] Margaret Ellis and Bjarne Stroustrup. \nThe Annotated C++ Reference Manual. Addison-Wesley, 1990. [16] Matthew Flatt, Shriram Krishnamurthi, \nand Matthias Felleisen. Classes and Mixins. In 25th ACM confer-ence on Principles of Programming Languages, \nJanuary 1998. [17] A. Goldberg and D. Robson. Smalltalk-80: The Lan-guage and its Implementation. Adison-Wesley, \n1983. [18] James Gosling, Bill Joy, and Guy Steele. The Java Language Specification. Addison-Wesley, \n1996. [19] Peter Grogono and Patrice Chalin. Copying, sharing, and aliasing. In Proceedings of the Colloquium \non Ob-ject Orientation in Databases and Software Engineering (COODBSE 9.$), Montreal, Quebec, May 1994. \n[20] Douglas E. Harms and Bruce W. Weide. Copying and swapping: Influences on the design of reusable \nsoftware components. IEEE nansactions on Software Engineer-ing, 17(5), May 1991. [21] Laurie J. He&#38;en \nand G. R. Gao. Designing pro-gramming languages for analyzability: A fresh look at pointer data structures. \nIn Proceedings of the IEEE 1992 International Conference on Programming Lan-guages, April 1992. (221 \nMatthew Hennessy and James Riely. Resource Control in Systems of Mobile Agents. Technical Report 2/98, \nUniversity of Sussex, February 1998. [23] John Hogg. Islands: Aliasing protection in object-oriented \nlanguages. In OOPSLA Proceedings, Novem-ber 1991. [24] John Hogg, Doug Lea, Alan Wills, Dennis de Cham- \npeaux, and Richard Holt. The Geneva convention on the treatment of object aliasing. OOPS Messenger, 3(2), \nApril 1992. [25] Stuart Kent and John Howse. Value types in Eiffel. In TOOLS 19, Paris, 1996. 1261 Stuart \nKent and Ian Maung. Encapsulation and aggre- gation. In TOOLS Pacific 18, 1995. [27] William Landi. Undecidability \nof static analysis. ACM Letters on Programming Languages and Systems, l(4), December 1992. [28] K. Rustan \nM. Leino and Raymie Stata. Virginity: A contribution to the specification of object-oriented soft-ware. \nTechnical Report SRC-TN-97-001, Digital Sys-tems Research Center, April 1997. [29] Xavier Leroy and \nFrancois Rouaix. Security properies of type applets. In 25th ACM conference on Principles of Programming \nLanguages, January 1998. [30] John M. Lucassen and David K. Gifford. Polymorphic effect systems. In Proceedings \nof the Eighteenth Annual ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages, January \n1988. [31] B. J. MacLennan. Values and objects in programming languages. ACM SIGPLAN Notices, 17(12), \nDecember 1982. [32] Bertrand Meyer. Eiffel: The Language. Prentice Hall, 1992. [33] Robin Milner, Joachim \nParrow, and David Walker. A calculus of mobile processes, Parts I and II. Information and Computation, \nlOO:l-77, September 1992. [34] Naftaly Minsky. Towards alias-free pointers. In ECOOP Proceedings, July \n1996. [35] J. Gregory Morrisett. Refining First-Class Stores. In ACM SIGPLAN Worshop on State in Programming \nLanguages, 1993. [36] Hanne Riis Nielson and Flemming Nielson. Semantics with Applications: a formal \nintroduction. Wiley, 1992. [37] James Noble and John Potter. Change detection for aggregate objects with \naliasing. In Australian Software Engineering Conference, Sydney, Australia, 1997. IEEE Press. [38] James \nNoble, Jan Vitek, and John Potter. Flexible alias protection. In ECOOP Proceedings, 1998. [39] Martin \nOdersky and Philip Wadler. Pizza into Java: Translating theory into practice. In Proc. 24th ACM Symposium \non Principles of Programming Languages, January 1997. [40] John Potter, James Noble, and David Clarke. \nThe ins and outs of objects. In Australian Software Engineering Conference, Adelaide, Australia, November \n1998. IEEE Press. to appear. [41] John C. Reynolds. Syntatic control of interference. In 5th ACM Symposium \non Principles of Programming Languages, January 1978. [42] Jon G. Riecke and Chrisopher A. Stone. Privacy \nvia Subsumption. In Fifth Workshop on Foundations of Object-Oriented Languages, 1998. [43] James Rumbaugh, \nMichael Blaha, William Premerlani, Frederick Eddy, and William Lorensen. Object-Oriented Modeling and \nDesign. Prentice Hall, 1991. [44] Ann Sabry and Matthias Felleisen. Reasoning about programs in continuation-passing \nstyle. In 1992 ACM Conference on LISP and Functional Programming, pages 288-298, San Francisco, CA, June \n1992. ACM. [45] Mads Tofte and Jean-Pierre Talpin. Region-Based Memory Management. Information and Computation, \n132(2):109-176, 1997. [46] Mark Utting. Reasoning about aliasing. In The Fourth Australasian Refinement \nWorkshop, 1995.    \n\t\t\t", "proc_id": "286936", "abstract": "Object-oriented programming languages allow inter-object aliasing. Although necessary to construct linked data structures and networks of interacting objects, aliasing is problematic in that an aggregate object's state can change via an alias to one of its components, without the aggregate being aware of any aliasing.<i>Ownership types</i> form a static type system that indicates object ownership. This provides a flexible mechanism to limit the visibility of object references and restrict access paths to objects, thus controlling a system's dynamic topology. The type system is shown to be sound, and the specific aliasing properties that a system's object graph satisfies are formulated and proven invariant for well-typed programs.", "authors": [{"name": "David G. Clarke", "author_profile_id": "81100391212", "affiliation": "", "person_id": "P61007", "email_address": "", "orcid_id": ""}, {"name": "John M. Potter", "author_profile_id": "81100200773", "affiliation": "Microsoft Research Institute, Macquarie University, Sydney, Australia", "person_id": "P145583", "email_address": "", "orcid_id": ""}, {"name": "James Noble", "author_profile_id": "81100588708", "affiliation": "Microsoft Research Institute, Macquarie University, Sydney, Australia", "person_id": "PP15036977", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/286936.286947", "year": "1998", "article_id": "286947", "conference": "OOPSLA", "title": "Ownership types for flexible alias protection", "url": "http://dl.acm.org/citation.cfm?id=286947"}