{"article_publication_date": "10-01-1998", "fulltext": "\n Extending the ODMG Object Model with Composite Objects Elisa Bertino Dipartimento di Scienze dell Informazione \nUniversit&#38; di Milan0 Via Comelico, 39/41 20135 Milano, Italy +39 02 55006 227 bertino@dsi.unimi.it \nGiovanna Guerrini Dipartimento di Informatica e Scienze dell hformazione UniversitA di Genova Via Dodecaneso, \n35 16146 Genova, Italy $39 010 353 6635 guerrini@disi.unige.it ABSTRACT In this paper we extend the ODMG \nobject data model with composite objects. A composite object is an object built by aggregating other \ncomponent objects. Exclus- iveness and dependency constraints, as well as referen- tial integrity, can \nbe associated with composition rela- tionships among objects. Our composite object model is developed \nin the framework of the ODMG object data- base standard data model, but can be used in both object-oriented \nand object-relational database systems. In the paper, we propose a language for defining com- posite \nobjects and we define the semantics of update operations on composite objects. Keywords Object-oriented \ndatabase systems, composite objects, integrity constraints, data models. INTRODUCTION Object-oriented \nDBMS (OODBMS) and object-re-lational DBMS (ORDBMS) are establishing themselves as the new generation \nDBMS. Object database systems overcome the limitations of relational systems with re-spect to several \nemerging data-intensive applications be-cause of their ability to directly represent complex ob-jects \nand to store in the database not only data but also the operations that can be performed on the data. \nPernxss~on to make dIgItal or hard copes 01 all or part of this work lor personal or classroom use IS \ngranted wthout fee prowded that copnes are not made or distributed for profit or commercial advan- tage \nand that copies bear this notice and the full cltatoon on the first page. lo copy otherwise, to republish, \nto post on servers or to redlstrlbute to 11~16. recwres prnr specific pernvss~on and/or a fee OOPSLA \n98 10198 Vancouver, B.C. 0 1998 ACM l-581 1%005.8/98/0010...$5.00 All the data models supported by object \nDBMS share a number of basic concepts, such as the concepts of ob- ject, class, and inheritance, which \nare often collectively referred to as core data model. That core model, al-though quite rich, does not \ncapture integrity constraints and semantic relationships which are important in many applications. In \nparticular, an important semantic rela-tionship is the composition relationship. In an object- oriented \ndata model, an object, called composite object, can be defined by aggregating other objects, called com-ponent \nobjects [19]. Th e relationship relating a compos- ite object with its components is called aggregation \nor part-ofrelationship. The fact that an object is defined as an aggregate of other objects raises a \nnumber of require- ments. A first relevant constraint is related to referential integrity. Referential \nintegrity ensures that whenever the value of an attribute of an object is another object, the referenced \nobject exists. Violations to referential integrity must be detected upon any attempt to delete a referenced \nobject. Violations to referential integrity can be repaired by forbidding the deletion, by setting to \nnull the value of the attribute containing the reference or by cascade deleting also the object containing \nthe ref- erence. In addition to referential integrity, two other important constraints are related to \ncomposite objects, namely exclusiveness and dependency. An exclusiveness constraint specifies that an \nobject must be component of only one composite object (possibly, with respect to a certain class or through \na certain attribute). A de- pendency constraint specifies whether the existence of the component object \nis independent from the existence of the composite objects containing it, that is, whether the deletion \nof a composite object implies the deletion of its components. In addition of being relevant from the \n semantic point of view, the notion of composite object as a logical entity is useful in enhancing performance \nbecause a composite object can be considered a locking, authorization and clustering unit. In this paper \nwe define a composite object model, sup- porting also referential integrity. A lot of work has been carried \non composite objects and part-whole relation-ships, in the data modeling [3, 14, 151, knowledge rep-resentation \n[23, 24, 251 and software engineering [12, 201 areas. There is obviously a trade-off between the com- \nplexity of the model and the efficiency and simplicity of its realization. We restrict ourselves to composite \nob-ject models typical of OODBMS. The model we propose unifies composite object models typical of OODBMS \nand referential integrity as supported in SQL. In par-ticular, composite object models like the Orion \none [19] do not include referential integrity constraints. There-fore, an object may be removed even \nif it is a compon- ent of a composite object. Referential integrity through the notion of external keys \nis supported in relational DBMS [8]. However, the notion of composite objects is not supported by SQL \nnor by the object extensions of SQL [ll, 17, 221; therefore, exclusiveness and exist- ence constraints \nare not supported by these data models. Our goal is to define a composite object model support- ing: \n(i) referential integrity with the same repair actions supported by SQL; ( ii ) exclusiveness constraints \nand ex- istence constraints in a more general form than those defined in Orion [19]. We cast the definition \nof our composite object model in the framework of the ODMG object database stand- ard data model [9]. \nHowever, we believe that our model, being quite general, can be used in both OODBMS and ORDBMS. The ODMG \ndata model, which we describe in the following section, supports two kinds of properties of objects: \nattributes and relationships. Relationships are declared between two object types and induce a pair of \ntraversal paths between the two types. In this paper, we extend the ODMG data model with a special kind \nof relationship, the part-ofrelationship, modeling compos-ite object references. Note that the part-of \nrelationship is listed among the features that will have to be ad- dressed by the ODMG standard. Therefore, \nwe believe that our proposal addresses an issue still open in the ODMG standard. In particular, in this \npaper we propose a language, as extension of the ODMG object definition language (ODL), for defining \ncomposite objects. The language supports the definition of two kinds of relationships between objects, \ncomposite and weak relationships. Composite relationships have exclusiveness and depend- ence constraints. \nExclusiveness is expressed by specify- ing a set of classes with respect to which exclusiveness is enforced. \nMoreover, for each relationship, the beha- vior to be observed upon violations of referential integ-rity \ncan be specified. We then analyze update opera-tions; in particular, the delete operation must be care- \nfully handled. The dependence semantics of a composite reference as well as the the cascade option for \nreferen-tial integrity propagate the deletion of an object to other objects, while the restrict option \nfor referential integrity prevents the deletion of referred objects. These differ-ent options may, thus, \nraise conflicts. In our work, we have developed strategies for solving ambiguities when conflicts arise. \nThe basic idea behind conflict resolution is to adopt a conservative approach, that is, we prefer not \ndeleting an object, which is no longer useful, rather than deleting a useful object. We remark that those \ncon- flicts depend on the dynamic configuration of the object aggregation graph, and thus they cannot \nbe detected at the schema level. At the schema level, we could impose some sufficient conditions to prevent \nconflicts, but these conditions would be too restrictive. We exemplify and analyze those conflicts, and \nformally define a semantics of update operations. The remainder of this paper is organized as follows. \nWe first introduce some preliminary notions, then we present the language for defining composite objects \nand discuss the semantics of update operations on compos-ite objects. Finally, we conclude the paper \nby discussing some implementation issues and pointing out some pos- sible extensions. PRELIMINARIES In \nthis section we introduce some preliminary notions that will be useful in the subsequent development \nof the paper. In particular, we introduce the notions of com- posite object and referential integrity, \nthe basic concepts of the ODMG data model and all the notations that will be used in the following. Composite \nObjects and Referential Integrity Composite objects have been introduced in the Orion data model [18, \n191. In that model, two types of refer- ences -weak and composite -are defined between ob-jects. A weak \nreference is a usual reference between objects on which no additional semantics is superim- posed. An \nobject o has a reference to an object o if this reference is the value of an attribute of o. A composite \nreference is a reference on which the part-of relationship is superimposed. A composite reference can, \nin turn, be exclusive or shared. In the former case, the referred ob-ject must belong to a single composite \nobject, whereas in the latter case it can belong to several composite objects. The semantics of a composite \nreference is then refined by introducing the distinction between dependent and independent composite \nreferences. In the former case, the existence of the objet referred to is dependent upon the existence \nof the object to which it belongs, whereas in the latter case, it is independent. The deletion of a composite \nobject results in the deletion only of the com- ponent objects which are dependent for their existence. \nThe objects whose existence is independent are not de-leted. Obviously, because the dependence/independence \nis orthogonal with respect to the exclusiveness/shared status, four possible types of composite references \nare obtained. In case of shared dependent composite refer-ences, an object can be dependent upon several \nobjects; this means that the deletion of a composite object res-ults in the deletion of a shared component \nobject only if all the other references to the object have been removed. That model has been extended \nin [5] by introducing two new forms of exclusiveness for composite references: exclusiveness with respect \nto a class, meaning that. two instances of the same class cannot share a component, whereas instances \nof other classes can refer that com-ponent; exclusiveness with respect to a class hierarchy, meaning \nthat two members of the same class cannot share a component. Referential integrity defines a relationship \namong se-mantically identical attributes in different entities. In an object-oriented data model this \nmeans that for any object o containing a reference to an object o , the re-ferred object, i.e. o , must \nexist. In some OODBMS, such as Gemstone [i ] and 02 [13], referential integrity is automatically ensured, \nin that those systems do not sup- port explicit object deletion, rather they use a garbage collection \nmechanism to determine which objects can be removed not being referred any longer by any other ob- ject. \nIn systems with an explicit delete operation, if a referred object is deleted, the problem of dangling \npoint-ers may arise. Referential integrity is not a peculiar constraint of object-oriented data models, \nrather it is present in all data models. The concept of referential integrity, is in- cluded in the SQL2 \nstandard [8] which was accepted by ANSI and IS0 in 1992. In SQL2 various options for ref- erential integrity \ncan be specified. Referential integrity in the relational data model is an integrity constraint between \na set of attributes (called foreign key) of a re- lation C (called child) and a set of attributes that \nis the primary key of a relation P (called parent). Integ-rity constraint violations are caused by update \nopera-tions on the parent and child relations. According to the SQL2 standard, insert and update operations \non the child relation are forbidden (backed out) if these would result in database states violating referential \nintegrity. For deletions and updates of tuples in the parent rela-tion, by contrast, in SQL2 different \nrepairing actions can be specified. This is accomplished through clauses We say that an object is an \ninstance of a class C if C is the most specific class, in the class hierarchy, to which the object belong. \nAn object is a mrmber of a class C if it is an instance of C or of a subclass of C. ON UPDATE and ON \nDELETE in the definition of the parent relation, stating how to handle modifications that may violate \nreferential integrity. For each of the clauses above, different repairing actions can be specified: CASCADE: \nin case of update, the new values in the key are propagated to the referencing children, whereas in case \nof deletion the referencing children are also deleted; SET-NULL: the foreign key attributes in the refer- \nencing tuples of the child relation are set to null; SET-DEFAULT: the foreign key attributes in the ref- \nerencing tuples of the child relation are set to a given default value; NO-ACTION: no action is taken; \nreferential integ-rity remains violated and if no other operation is executed to correct the mismatch \nof the correspond- ing tuples, the complete work of the transaction is backed out. There is another important \nreferential action not intro-duced in the SQL2 standard, but supported by most of the relational DBMS: \nRESTRICT. The semantics of this referential action is to forbid any change (update or de- lete) of a \nparent tuple as long as there are referencing child tuples. Although this action is not in the SQL2 standard, \nwe include it in our discussion. A problem with referential integrity constraints, as specified in SQL2, \nresults from the possibility of in-terference when performing multiple referential actions on a tuple. \nThat is, a straightforward implementa-tion may lead to a non-determinism in the result of a user operation. \nThe SQL2 standard prevents such non- determinism through the specification of a complex test carried \nout during the execution of referential actions. A detailed discussion of this approach can be found \nin the work by Markowitz [21]. ODMG Object Database Standard Data Model This section focuses on the features \nof the object model of the ODMG standard that are relevant to this paper. The basic modeling primitives \nare the object and the lit-eral. Each object has a unique identifier. A literal has no identifier. The \nstate of an object is defined by the values it carries for a set of properties. These proper-ties can \nbe attributes of the object itself or relationships between the object and one or more other objects. \nTyp-ically the values of an object properties can change over time. The behavior of an object is specified \nby the set of operations that can be executed on or by the object. Ob-jects and literals can be categorized \naccording to their types. All elements of a given type have a common range of states (i.e., the same \nset of properties) and common behavior (i.e., the same set of defined operations). A Symbol OBJ P(S) \ncl <ISA c2 ingaths(0) r(o) r-l 0 -r, 0 composite(r) ezcZusive(r) in-rel(r) dependent(r) delete(r) Setd(o) \n Meaning the set of all objects the powerset of set S class Cr is a subclass of class C2 the set of \nobjects members of class C the set of objects instances of class C the set of objects instances of classes \nin the set S the set of objects participating in some relationships with o the set of objects participating \nin some composite relationships with o (the set of o components) the set of traversal paths leading \nto object o the object participating in relationship r with object o the inverse traversal path of traversal \npath r there is a traversal path r from object o to object o whether or not relationship r is composite \nthe set of classes w.r.t. which relationship r is exclusive whether or not relationship r is exclusive \nin r whether or not relationship r is dependent behavior to be taken upon deletion of an object from \nwhich traversal path r originates the set of objects to be deleted as a consequence of the deletion of \no Table 1: Notation and terminology database stores objects, enabling them to be shared by multiple users \nand applications. A database is based on a schema, defined according to an object definition language \n(ODL), and contains instances of the types defined by its schema. A type defines a set of properties \n(attributes and rela- tionships) constituting the state of instances of the type. An attribute models \na property of all instances of a type. A relationship is defined between two types, each of which must \nhave instances that can be referenced by object identifiers. Only binary relationships, i.e., rela- tionships \nbetween two types, are supported. A binary relationship may be one-to-one, one-to-many, or many-to-many, \ndepending on how many instances of each type participate in the relationship. For example marriage is \na one-to-one relationship between two instances of type Person. A woman can have a one-to-many mother \nof re-lationship with many children. Teachers and students typically participate in many-to-many relationships. \nA relationship is implicitly defined by declaring tra-versal paths that enable applications to use the \nlogical connections between the objects participating in the re- lationship. Traversal paths can be declared \nin pairs, one for each direction of traversal of the binary relation-ship. For example, a professor teaches \ncourses and a course is taught by a professor. The teaches traversal path would be defined in the declaration \nfor the Professor type. The is-taught-by traversal path would be defined in the declaration for the Course \ntype. The fact that both these traversal paths apply to the same relationship is indicated by an inverse \nclause in both the traversal path declarations. For example: class Professor { . . . relationship Set<Course> \nteaches inverse Course::is-taught-by; . . 1 class Course { relationship Professor is-taught-by inverse \nProfessor::teaches; 1 However, the specification of an inverse traversal path is not mandatory; in such \na case, the relationship can be traversed in a single direction. The relationship defined by the teaches \nand the is-taught-by traversal paths is a one-to-many relationship between Professor and Course objects. \nThe cardinality is shown in the traversal path declarations. A Professor instance is associated with \na set of Course instances via the teaches traversal path. A Course instance is associated with a single \nProfessor instance via the taught-by traversal path. The OODBMS is responsible for maintaining the ref- \nerential integrity of relationships. This means that if an object that participates in a relationship \nis deleted, then any traversal path to that object must also be de- leted. For example if a particular \nCourse instance is de- leted, then not only is the reference from this object to a Professor instance \nvia the is-taught-by traversal path deleted, but also all references in Professor objects to the Course \ninstance via the teaches traversal path must be deleted. Referential integrity ensures that applic-ations \ncannot dereference traversal paths that lead to non-existing objects. Notations Table 1 illustrates the \nsymbols most frequently used in this paper. For each symbol, the table reports a brief explanation of \nits meaning. A LANGUAGE FOR SPECIFYING COMPOSITE OB-JECTS For the sake of simplicity in the presentation \nwe re-strict ourselves to consider single-valued, that is, one-to-one relationships. The extension to \nmulti-valued (that is, one-to-many and many-to-many) relationships is straightforward. In what follows \nwe extend ODMG relationships to support the composite semantics for relationships. The actions to execute \nupon referential integrity violations can be specified for composite as well as for weak rela- tionships. \nAs we have discussed in the previous section, ODMG already supports a form of referential integrity, \nby deleting a relationship upon deletion of the parti-cipating objects. We extend that model by allowing \na user to declare different behaviors, corresponding to the SQL CASCADE and RESTRICT options. Therefore, \nwe can prevent the deletion of an object participating to a relationship and we can propagate the deletion \nof an ob- ject to the object which participates in the relationship with the deleted object. We can thus \nmodel mandatory relationships, that cannot be modeled by ODMG. We extend the ODL syntax for specifying \nrelationships as specified in Figure 1, according to a BNF-like style. In the grammar of Figure 1: l \nthe keyword composite specifies the relationship to be a composite relationship; l the keyword exclusive \nintroduces the set of classes with respect to which the relationship is exclusive; if the option in rel \nis specified, then the exclusiveness is intended with respect to the relationship itself; l the keyword \ndependent specifies that, upon the dele- tion of the composite object, the component objects are also \ndeleted, unless they participate in some other composite relationship; l the keyword delete specifies \nthe actions to be per- formed on the composite object upon the deletion of one of its components; this \nclause can be present also for weak references. <rel-dcl> :: = [<compldecl>] relationship <class-id> \n<rel-id> [inverse < inv-trav-path >] [delete < del-opt > ] <compldecl> ::= composite [dependent] [exclusive \n<excl-target>] <excl-target> ::= [in rel] < target-classes > < target-classes > ::= all 1 { <t-class> \n} <t-class> ::= <class-id> 1 hierarchy(<class-id>) ( <t-class>, <t-class> <del-opt> ::= cascade ) restrict \n<inv-trav-path> ::= <class-id> :: <rel-id> Figure 1: ODL extension for specifying composite rela-tionships \nWe remark that it is not mandatory to specify an in- verse relationship. If an inverse relationship is \nnot spe-cified the relationship is unidirectional, that is, it can be traversed in a single direction. \nIf an inverse relation-ship is specified, certain coherence conditions must be verified by a relationship \nand its inverse relationship. In what follows we discuss in detail the various clauses in the relationship \ndefinition. Composite clause If the keyword corn posite appears in a relationship defini-tion, the relationship \nis qualified as a composite relation-ship. The semantic meaning of a consists-of relationship is thus \nimposed on the relationship. If the keyword is missing, the relationship is weak, that is, no special \nse-mantics is superimposed on it. Keywords exclusive and dependent can appear only in composite relationships. \nNote that the keyword composite must appear in the de- claration of the traversal path associated with \nthe com- posite object, and not in the traversal path associated with the component object. Exclusive \nclause The exclusive clause introduces: l the option in rel, specifying that exclusiveness is re- stricted \nto the relationship itself; l a set of classes, corresponding to the < tar-get-classes > non-terminal \nof the grammar, with respect, to which the relationship is exclusive; in particular: -the keyword all \nspecifies the relationship to be exclusive with respect t,o all t,he classes in the database; -the notation \nC, where C is a class identifier, specifies the relationship to be exclusive with respect to the instances \nof class C, that is, the relationship is exclusive with respect to class C; - the notation hierarchy(C), \nwhere C is a class identifier, specifies the relationship to be ex- clusive with respect to the members \nof class C, that is, the relationship is exclusive with respect to the class hierarchy rooted at C. \nThe keyword all has been introduced to denote the set of all classes without the need of explicitly enumerating \nthem. This option is useful in case of addition of new classes to the database. If the clause is omitted, \nno exclusiveness semantics is associated with the relationship (that is, it is shared). A composite relationship \ncan then be associated with a set S of classes. The relationship is thus exclusive with re-spect to all \ninstances of classes in 5 . Set S is the empty set 0 for relationships for which no exclusive clause \nis specified; it is the entire set of classes of the database for relationships for which exclusive all \nhas been specified. Finally, S is defined as UyZ1 Ci U Uj =, (JC.lrsAC, C* if the exclusive clause of \nthe relationship defini)tion contains {Cl, . . , C,, hierarchy(Ci), . . , hierarchy(C/,)} with m, n > \n0. The following definition formalizes the notion of ex- clusiveness with respect to a set of classes \nS. Definition 1 (Exclusivity). Let r be a relationship spe-cified in class C to be composite exclusive \nwith respect to a set of classes S. The following conditions must hold: l Vo E [Cl 3 o E [IS] +, o # \no , such that r(o) E comp(0 ); l if C E S, moreover, Vo E [[Cl] $ r composite relationship of class C, \nr # r, such that r(o) = r (0). 0 The first condition ensures that the object associated with o by r \ndoes not participate in any composite re-lationship with any other object instance of classes in S, while \nthe second one ensures that that object is not associated with o in any other composite relationship. \nThe following definition formalizes the notion of ex-clusiveness in a relationship with respect to a \nset of classes S. Definition 2 (Exclusivity in a Relationship). Let r be a relationship specified in \nclass C to be composite exclus-ive in r with respect to a set of classes S. The following condition must \nhold: Qo E [C] jf o E [SJJ+,o # o , such that r(0) = r(0 ). Obviously, for the above notion to be meaningful, \neach class in S must participate to an r relationship. Intuitively, exclusiveness with respect to a set \nof classes S states that two objects instances of classes in S cannot share a component, while exclusiveness \nin a relationship with respect to a set of classes S states that two objects instances of classes in \nS cannot be in the specified relationship with the same component. We re- mark that an exclusive relationship \nr is also exclusive in r, since r(o ) E comp(o ). Thus, exclusivity is a stronger notion than exclusivity \nin a relationship. Dependent Clause The dependent clause specifies that the deletion of the composite \nobject must be propagated to the component objects. This automatic propagation is useful because it saves \nthe application from having to explicitly delete all the component objects. Consider a relationship r, \nspecified in a class C to be composite dependent. Consider moreover an object o E [[Cl , such that r(o) \n= 0 . Because the relationship is dependent, upon the deletion of o, o is also deleted, if it does not \nparticipate in other relationships. The deletion of o , may in turn cause the deletion of other objects, \nif o has some components. If the relationship is not dependent (that is, no dependent clause is specified), \nthen the deletion of o does not impact 0 . Delete Clause The delete clause specifies how the deletion \nof an object affects other objects eventually in relationships with this object. Consider a relationship \nr, specified in a class C. Consider moreover an object o E [C] , such that r(o) = 0 . Then, the deletion \nof o has different results depending on the value of the delete clause of r: l if this clause contains \nthe keyword cascade the de- letion of o implies the deletion of o; 9 if this clause contains the keyword \nrestrict o cannot be deleted; l if this clause is omitted the deletion of o only results in the deletion \nof the traversal paths r and r-l as in the current semantics of ODMG2. Note that traversal paths r and \nr-l are obviously deleted also in the cascade case. Examples In what follows we present two examples \nto illustrate the notions introduced above. Example 1 Consider the following class definitions. class \nTeam { attribute string name; attribute short score; composite exclusive { hierarchy(Team)} relationship \nPlayer goalkeeper delete restrict; composite exclusive (hierarchy(Team)} relationship Player forward; \n composite exclusive {hierarchy(Team)} relationship Coach coach inverse Coach::trains delete restrict; \n corn posite dependent relationship Sponsor sponsor; } class Coach { attribute string name; relationship \nTeam trains inverse Team::coach; } A team consists of a number of players, playing in dif-ferent roles, \nand a coach. In particular, each team has a goalkeeper and may have a forward. Both relationships goalkeeper \nand forward are composite, and exclusive with respect to the class hierarchy rooted at class Team. This \nmodels the fact that a player cannot play in two different teams, nor can play two different roles in \nthe same team. This also means that two subclasses of class Team, say classes First-Class-Team and Second-Class-Team, \ncannot share a player. A player cannot be deleted as long as he is the goalkeeper of some team and a \ncoach cannot be de- leted as long as he trains a team. This models the fact that both goalkeeper and \ncoach relationships are mandat-ory. A team consists moreover of a sponsor. Sponsors are dependent for \nexistence on the existence of the team they sponsor. Finally, note that only relationship coach has an \nexplicit inverse relationship trains. 0 Example 2 Consider the following class definitions. class Project \n{ attribute string name; attribute short budget; corn posite exclusive in rel { hierarchy( Project)} \nrelationship Manager leader inverse Manager::leads delete cascade; corn posite dependent relationship \nEmployee staff-member inverse Employee::worksjn; } class Employee { attribute string name; attribute \nshort salary; relationship Project works-in inverse Project::staff-member; } class Manager extends Employee \n{ relationship Project leads inverse Project::leader; } A project is characterized by a leader and a \nstafl mem-ber. The same manager cannot lead two diflerent pro-jects, however, a manager (which is also \nan employee) can be the leader and the staff member of a project (or of different projects), because \nof the in rel option in the exclusiveness declaration for relationship leader. The deletion of a project \ndoes not impact the existence of its leader; by contrast, upon deletion of a manager the pro- ject he \neventually leads is in turn deleted. By contrast, an employee can be a staff member of several projects. \nThe deletion of a project also results in the deletion of its staff member, if the member is not the \nstaff mem- ber, or the leader, of other projects. If an employee is deleted, finally, the project he \nworks for is not affected. Correctness of Composite Relationships Definitions It is important to note \nthat given a traversal path de-claration in a class, an inverse traversal path can be specified in the \nother class participating in the relation- ship. Therefore, some constraints must be imposed to ensure \nthe coherence between a traversal path declar-ation and the declaration of the inverse traversal path. \nIn particular, we choose to state that a relationship is composite in the declaration of the traversal \npath from the composite object to the component. Thus, if r is de- clared composite, r-l must not be \ndeclared composite. Moreover, because a composite traversal path declara-tion specifies both the actions \nto perform upon the dele- tion of the composite object as well as upon the deletion of the component, \nno delete clause can be specified for the inverse of a composite traversal path. Finally, we remark that \nspecifying a dependent clause in a composite traversal path is different from specify-ing delete cascade \nin the definition of the inverse traversal path. The specification of the dependent clause requires the \ndeletion of the component object upon deletion of the composite object, unless the component object is \nreferred by some other object. By contrast, the delete cascade implies the deletion of the component \nobject in-dependently from other references to it (unless if they are through relationships with delete \nrestrict, as we will discuss in detail in the following section). SEMANTICS In this section we consider \nthe semantics of update oper- ations on composite objects. We first consider creation and modification, \nand then deletion. Creation and Modification The creation of a new object may cause the violation of \ncomposite exclusive relationships already in the data- base. The creation is thus allowed if for any \ncomposite relationship in which the object participates, exclusive-ness is not violated. Moreover, the \ncreation may violate referential integrity if the object specified as value for a relationship does not \nexist in the database. If any of these constraints is violated, the creation is disallowed, that is, \nit is backed out. The following rule states the conditions upon which creation is allowed. Rule 1 (Creation \nRule). The creation of object o is allowed provided that: l REFERENTIAL INTEGRITY: for each object o \nE ref (o), 0 E OBJ must hold, that is, each object referenced by o must exist; l EXCLUSIVENESS: for each \nobject o E camp(o), for each r E in-paths(o ) such that composite(r) = true - if in-rel(r) = false, then \nfor each r E in-paths(o ) such that composite(r ) = true, r -l(o ) C$ fezclusive(r) ] + must hold; - \nif in-rel(r) = true, then {o* 1 r(o*) = O AO* E [exclusive(r) ] f} = {o} must hold.  0 The modification \nof an object can be dealt with as the creation of a new object. We recall that the OID of an object cannot \nbe modified and that the modification of an object cannot result in object deletion. Therefore, the only \nconstraints potentially violated by a modific- ation are those related to exclusiveness and referential \nintegrity. If those constraints are violated, the modific- ation is simply disallowed (backed out). Deletion \nIn this section we deal with object deletion. As we will see, object deletion must be carefully handled \nin pres- ence of composite objects, because semantic ambiguities due to the different options may arise. \nIn formulating the strategies for solving those ambiguities we follow the basic idea of preserving the \ninformation contained in the database from non explicitly requested deletion, and thus, in ambiguous \ncases, we have chosen not to delete an object. r 1 02 I 01 restrict cascade CO Figure 2: Objects and \nrelationships of Example 3 cascade cascade 01 re# ,:i;__l cascade Figure 3: Objects and relationships \nof Example 4 Let us first show, by means of examples, why dele-tion may result in ambiguities, and then \npresent the se- mantics we have defined to capture the desired behavior. Example 3 Consider the objects \nand the relationships in Figure 2. When object o is deleted, delete(r) = cas-cade requires the deletion \nof 01. By contrast, delete(r ) --restrict states that 01 cannot be deleted. Thus, an am-biguity arises. \nWe adopt a conservative approach and thus we choose not to delete object 01. Thus, the restrict option \nof r prevails on the cascade option of r. 0 Example 4 Consider the objects and the relationships in Figure \n3. When object o is deleted, two different pos-sible final states can be obtained depending on the order \nin which traversal paths leading to o are considered. If rg is considered first, 02 is deleted, since \ndelete(rs) = cascade (note that, as a consequence, the traversal path from 02 to o is also removed). \nThen, r a s considered and 0 and 01 are also deleted, because delete(r) = delete(rl) = cascade. Thus, \nall the four objects are deleted. If r is considered first, o is not deleted because it partacipates \nin a relationship (r2) with delete(rz) = restrict. Then, rg is considered and 02 is deleted because delete(r3) \n= cascade. This deletion does not cause the deletion of any other object. Thus, the deletion of o only \ncauses the deletion of 02. Note that the final state which more closely reflects the intuitive semantics \nis the first one, because the object preventing the deletion of o , namely 02, is in turn de-leted as \na consequence of the deletion of o. 0 A similar situation may arise because of dependent declarations, \nas shown by the following example. Example 5 Consider the objects and the relationships in Figure 4. \nWhen object o is deleted, two different possible final states can be obtained depending on the order \nin which traversal paths originating from o are considered. depeny : \\ 0 _______t 0 dependent Figure \n4: Objects and relationships of Example 5 a If r1 is considered first, 0 is deleted, because dependent(rl) \n= true and no other traversal path leading to 0 exists (note that, as a consequence, the traversal path \nfrom 0 to o is also removed). Then, r is considered and o is also deleted, be-cause dependent(r) = true \nand no more traversal paths leading to o exist. Thus, all three objects are deleted. l If r is considered \nfirst, o is not deleted because it participates in relationship r2. Then, r1 is con-sidered and 0 is \ndeleted. Thus, the deletion of o only causes the deletion of 0 . Note that the final state which more \nclosely reflects the intuitive semantics is the first one, because the object to which o belongs as a \ncomponent (i.e. 0 ) is in turn deleted as a consequence of the deletion of o. 0 It is thus important \nto establish a well-founded se-mantics for delete operations on composite objects. Such semantics is \ndefined in what follows. We start from the idea that, given an object o, we want to determine the set, \ndenoted as Setd, of the objects that have to be de- leted as a consequence of the deletion of o. Obviously, \nbefore determining Setd, it must be verified whether ob-ject o itself can be deleted, that is, whether \nno traversal path r leading to o3 exists, such that delete(r) = restrict. The set Setd initially contains \nonly the object to be deleted, that is, Setd = (0). Other objects are then inserted into this set, because \nof dependent declarations or delete declarations, according to what follows. l dependent declarations: \nEach object o participating in some composite re-lationships with an object o in Se@ such that all the \ntraversal paths leading to o originate from objects in Setd or from object o itself, and at least one \nof these paths has a dependent declaration, is added to Setd. Formally, Vo E Setd if 3 r such that r(o) \n= o , dependent(r) = true, in-paths(o ) = {rl, . . . , rn) and Vi,i = l,..., n, ril(o ) E Setd or ri \n(o ) = o , then Setd = Setd U (0 ). 3This means that an object 0 exists such that r(o ) = o. . delete \ndeclarations: Each object o participating in some composite re-lationships with an object o in Setd through \na tra- versal path r with delete(r) = cascade and such that for all other traversal paths r leading to \no either delete(r ) # restrict or r originates from some ob- ject in Setd or from object o itself, is \nadded to Setd. Formally, Vo E Setd if 3 r such that r(o ) = o, delete(r) = cascade, in-paths(o ) = in,..., \nr,} and Vi, i = 1,. , n, either delete(ri) # restrict, or r$Tl(o ) E Setd or ril(o ) = o , then Setd \n= Setd U (0 ). Now we introduce two operators formalizing the above concepts. Definition 3 (t-d). Let \no, o E OBJ be two objects. o is said to be deleted for dependence from o, denoted as o kd o , if r(o) \n= o , dependent(r) = true and for any other relationship r such that o = r (o*) either o* = o or o* E \nSetd. cl Definition 4 (I- ). Let o, o E OBJ be two objects. o is said to be deleted for referential integrity \nfrom o, denoted as o tc o , if r(o ) = o, delete(r) = cascade and for any other relationship r such that \no = r (o*) and delete(r ) = restrict either o* = o or or E Setd. 0 We now introduce an operator which \nis the union of td and tc. Definition 5 (DEL). Operator DEL : P(OBJ) -+ P(OBJ) denotes the operator which \nreturns the objects to be deleted (either for dependence or for referential integrity) from a given set \nof objects, Given a set of objects 0 C_ P(OBJ) DEL(O) = 0 u {o 1 3 o E 0 o kd o } u (0 ) 3 0 E 0 0 t \n0 ).  We are now able to formally specify the semantics of the delete operation, relying on the notion \nof fixpoint. According to [6], given a poset (A, <), where A is a set and < is a partial order on A, \nand given a monotonic transformation T on the complete poset (A, <), T has a least fixpoint. In our context, \n(A, 5) is (P(OBJ) , Q, where P(OBJ) is the set of all possible sets of objects containing object 04, \nc is set inclusion on P(OBJ) and the monotonic transforrnation T is DEL. (P(OBJ) , C) IS a complete poset \nsince for each subset 0 of P(OBJ) both the least upper bound (lub(0)) and 4P(OB.q0 consists of the sets \nof objects 0 belonging to P(OBJ) such that o E 0. the greatest lower bound (glb(0)) exist. Finally, DEL \nis a monotonic operator on (P(OBJ) , C). Indeed, for each I,J E P(OBJ) , I C J, DEL(I) C DEL(J), be-cause \nthe DEL operator applied to set J (where J con-tains all the objects in I and eventually some other ob- \njects) returns all the objects in DEL(I) and eventually some more objects that can be deleted starting \nfrom J. Thus, the monotonic operator DEL has a least fixpoint, denoted as lfp(DEL) = Std. An element \n0 E P(ORJ) is said a fixpoint of DEL if DEL(O) = 0. Definition 6 Let o E OBJ be an object, the effect \nof the deletion of o in a composite object model is the set Setd E P(OBJ) such that Setd = lfp(DEL). \n0 The following example shows how the defined se-mantics correctly handles the ambiguous situation of \nExample 4. Example 6 Referring to objects and relationships of Example 4, the various iterations of the \nfixpoint com- putation lead to the following sets: Setd = (0) Setd = {o,oz} for 0 I- 02 Setd = {0,02,0 \n} for 0 t\" 0 Setd = {o,o~,o ,o~} for 0 t-c 01 The set {o,o~,o ,o~} is the effect of the deletion of \no, be- cause DEL({o,o~,o ,o~}) = {o,o~,o ,o~}. In the fixpoint computation, note that at the second iteration, \no has not been inserted in Setd because of an incoming tra- versal path to it with delete restrict (i.e. \nrz), whereas in the third iteration o is inserted because the origin of that traversal path (i.e. 02) \nbelongs to Setd. 0 The following example illustrates the semantics of de- letion in a more complex example. \nExample 7 Consider the objects and the relationships in Figure 5. Suppose that object o is deleted. The \nvari-ous iterations of the fixpoint computation lead to the following sets: Setd = (0) Setd = {o,ol} \nfor 0 t\" 01 Setd = {o,o~,o~,o~} for 01 t- 03 and 01 td 02 Setd = {0,01,02,03,06} for 03 tc 06 The set \n{o,o~,o~,o~,oe} is the effect of the deletion of o, because DEL({~,~I,oz,o~,~~}) = {0j01102r03r06}. This \ncorrectly models the semantics specified for the relationships. Indeed: object o can be deleted, because \nthere is no traversal path with delete restrict leading to it; e as a consequence of the deletion of \nobject o, object 01 is deleted, because of a traversal path with delete cascade leading to o, and because \nno traversal path with delete restrict leads to 01; 06 cascade /I 0 Figure 5: Objects and relationships \nof Example 7 l as a consequence of the deletion of object ol( objects 03 and 07 (due to a traversal path \nwith delete cas-cade leading to 01) and object 02 (due to a compos-ite dependent traversal path coming \nfTom 01) could be deleted; - 02 is deleted, because there are no more tra-versal paths leading to it; \n- 03 is deleted, because there are no incoming traversal paths with delete restrict; - 07 is not deleted, \nbecause there is an incoming traversal path (from 04) with delete restrict; l the deletion of 02 does \nnot cause the deletion of any other object, whereas the deletion of 03 could cause the deletion of 06 \n(due to a traversal path with delete cascade leading to 03) and of 04 (due to a composite dependent traversal \npath coming from 03); - 06 is deleted, because there are no incoming traversal paths with delete restrict; \n- 04 is not deleted, because there is a traversal path leading to it (from object OS); l the deletion \nof 06 does not cause the deletion of any other object. CONCLUSIONS In this paper we have proposed a \ncomposite object model. The proposed model supports both exclusive-ness (with various degrees of granularity) \nand depend-ency specifications, as well as the declaration of the be-havior to be taken upon violations \nof referential integ-rity. Though, for the sake of simplicity, in the paper we have only dealt with single-valued \n(that is, one-to-one) relationships, the model also covers multi-valued (that is, one-to-many and many-to-many) \nrelationships. Fur-thermore, the model can be easily extended to associa.te composite declarations and \nreferential integrity specific-ations with attributes. We remark that our model expresses an important \nclass of constraints related to the aggregation relstion-ship among objects, in a declarative way. If \nsuch a spe- cific handling of such a category of constraints were not provided, these constraints would \nhave to be enforced by inserting repairing code in met,hods. An ad-hoc support for such important class \nof constraints seems, however, more adequate. In the paper we have presented a language for specify- \ning composite objects and have revised the semantics of update operations to take into account those \nconstraints. However, though composite objects are useful from a semantic point, of view, composite object \nhandling must not decrease t,oo much the performance of the system. Our composite object model has been \nimplemented in the Ode active OODBMS [l, 21. Our approach relies on the use of a classical facility of \nDBMS to maintain dat,a integrity, namely triggers [lo]. In particular, we have de- veloped a t#ool, aut,omatically \ngenerating, from compos-ite object specifications, a set of triggers enforcing the associated constraints. \nThe use of triggers for support- ing referential integrity has been investigated by Baralis et al. [4] \nwhoc have shown how triggers can be derived for maintaining SQL referential integrity. However, they \nhave not addressed how to solve the non-determinism that may a.rise from conflicting restrict and cascade \nop-tions. In our t,ool, by cont,rast, problems relat,ed t,o non- determinism are solved according to \nthe well-defined se-mantics we have described in the paper. This semantics could also be adopted in the \nrelational context. Our tool, moreover, also appropriately handles exclusiveness and dependency constraints. \nSome preliminary evaluations have been performed on the prototype implementation, to verify the pract,icab- \nilit-y of our approach. While the results in terms of the general utility of the tool from a semantic \nmodel-ling point of view and of case of use are encoura.ging, it is more difficult, to evaluate the prototype \nfrom the performance point, of view, mainly because the Ode irn- plementation itself, and in particular \nits trigger support, are not optimized. We thus plan to implement the proposed model on some commercial \nOODBMS without active capabilit,ies. In l)articular, we would like to investigate the possibility of \nexploiting a.ppropriate access structure t,o efficiently support operations on composite objects. This \nmeans that operations on composite objects can be implcmen- ted by appropriately traversing the object \naggregation graph. In such traversals, ad-hoc access techniques can be exploited, possibly adapted from \nthose proposed in the relational context by Harder and Reinert [ 161. Such an approach still needs further \ninvestigation. REFERENCES R. Agrawal and N. Gehani. ODE (Object Database PI and Environment): The Language \nand the Data Model. In Proc. of the ACh4 SIGMOD Int 1 Conf. on Management of Data, pages 36-45, 1989. \nR. Arlein, J. Gava, N. Gehani, and D. Lieuwen. PI Ode 4.1 User Manual. AT&#38;T Bell Laboratories, Murray \nHill, New Jersey, 1995. A. Artale, E. Franconi, N. Guarino, and I,. Pazzi. PI Part-whole Relations in \nObject-Centered Systems: An Overview. Data and Knowledge Engineering, 20(3):347-383, 1996. E. Baralis, \nS. Ceri, and S. Paraboschi. Declarative WI Specification of Constraint Maintenance. In P. Lou- copoulos, \neditor, Proc. Thirteenth Int l Conf. on the Entity-Relationship Approach, number 881 in Lecture Notes \nin Computer Science, pages 205-222, 1994. PI E. Bertino and S. Jajodia. Modeling Multilevel Entities \nusing Single-Level Objects. In S. Tsur, S. Ceri, and K. Tanaka, editors, Proc. Third Int l Conf. on Deductive \nand Object-Oriented Databases, number 760 in Lecture Notes in Computer Science, pages 415-428, 1993. \nPI G. Birkhoff. Lattice Theory. American Mathemat-ical Society Colloquium. Publications, 25, 1973. R. \nBreitl, D. Maier, A. Otis, J. Penney, PI B. Schuchardt, J. Stein, E. H. Williams, and M. Williams. The \nGemstone Data Management System. In W. Kim and F. I-I. Lochovsky, editors, Object-Oriented Concepts, \nDatabasases, and Ap-plications, pages 283-308. Addisort-Wesley, 1989. PI S.J. Cannan and G.A.M. Otten. \nSQL -The Stand-ard Handbook. McGraw-Hill, 1992. PI It. Cattel. The Object Database Standard: ODMG- 93. \nMorgan-Kaufmann, 1996. S. Ceri and J. Widom. Actrvc Database Systems 001 -Triggers and Rules for Advanced \nDatabase Pro-cessing. Morgan-Kaufmann, 1996. Pll D. Chamberlin. [Jsiny the New DR%! -IBM s Object-Relational \nDatabase System. Morgan-Kaufmann, 1996. F. Civello. Roles for Composit,e Objects in Object- WI Oriented \nAnalysis and Design. In Proc. Eighth Znt l Conf. on Object-Oriented Programming: Systems, Languages, \nand Applications, pages 376.-385, 1993. [13] 0. Deux et al. The Story of 02. IEEE Transactions on Knowledge \nand Data Engineering, 2(1):91-108, 1990. [14] M. Halper, J. Geller, Y. Perl, and W. Klas. In-tegrating \na Part Relationship into an Open OODB System using Metaclasses. In N.R. Adam, U.K. Bhargava, and Y. Yesha, \neditors, Proc. of the Third Int l Conf. on Information and Knowledge Man-agement, pages 10-17, 1994. \n[15] E. Hanson. Rule Condition Testing and Action Ex-ecution in Ariel. In Proc. of the ACM SIGMOD Int \nl Conf. on Management of Data, pages 49-58, 1992. [16] T. Harder and J. Reinert. Access Path Support \nfor Referential Integrity in SQL2. VLDB Journal, 5:196-214, 1996. [17] Illustra Information Technologies, \nOakland, Cali-fornia. Illustra User s Guide. Release 2.1. [18] W. Kim, J. Banerjee, H.T. Chou, J.F. Garza, \nand D. Woelk. Composite object support in a Object- Oriented Database System. In N. Meyrowitz, ed-itor, \nProc. Second Int l Conf. on Object-Oriented Programming: Systems, Languages, and Applica-tions, pages \n118-125, 1987. [19] W. Kim, E. Bertino, and J. Garza. Composite Ob-jects Revisited. In J. Clifford, \nB. Lindsay, and D. Maier, editors, Proc. of the ACM SIGMOD Int l Conf. on Management of Data, pages 337- \n347, 1989. [20] M. Kolp and A. Pirotte. An Aggregation Model and its C++ Implementation. In M.E. Orlowska \nand R. Zicari, editors, Proc. of the Fourth Int l Conf. on Object-Oriented Information Systems Engineering, \nnumber 685 in Lecture Notes in Computer Science, pages 352-373, 1993. [al] V.M. Markowitz. Safe Referential \nStructures in Relational Databases. In G. M. Lohman, A. Ser-nadas, and R. Camps, editors, Proc. Seventeenth \nInt l Conf. on Very Large Data Bases, pages 123- 132, 1991. [22] J. Melton and A.R. Simon. Understanding \nthe New SQL: a Complete Guide. Morgan-Kaufmann, 1993. [23] R. Motschnig-Pitrik. The Semantics of Parts \nversus Aggregates in Data/Knowledge Modelling. In C. Rolland, F. Bodart, and C. Cauvet, editors, Proc. \nof the Fifth Int l Conf. on Advanced Inform-ation Systems, pages 211-224, 1997. [24] C. Peltason, A. \nSchmiedel, C. Kindermann, and J. Quantz. The BACK System Revisited. Technical Report KIT -Report 75, \nTechnische Universitat Berlin, 1989. [25] M. E. Winston, R. Chaffin, and D. Herrmann. A Taxonomy of \nPart-whole Relations. Cognitive Sci-ence: a Multidisciplinary Journal of Artificial In-telligence, Linguistzcs, \nNeuroscience, Phalosophy, Psychology, 11(4):417-442, 1987. \n\t\t\t", "proc_id": "286936", "abstract": "In this paper we extend the ODMG object data model with composite objects. A composite object is an object built by aggregating other component objects. Exclusiveness and dependency constraints, as well as referential integrity, can be associated with composition relationships among objects. Our composite object model is developed in the framework of the ODMG object database standard data model, but can be used in both object-oriented and object-relational database systems. In the paper, we propose a language for defining composite objects and we define the semantics of update operations on composite objects.", "authors": [{"name": "Elisa Bertino", "author_profile_id": "81409594658", "affiliation": "Dipartimento di Scienze dell'Informazione, Universit&#224; di Milano, Via Comelico, 39/41 20135 Milano, Italy", "person_id": "PP15029409", "email_address": "", "orcid_id": ""}, {"name": "Giovanna Guerrini", "author_profile_id": "81100209640", "affiliation": "Dipartimento di Informatica e Scienze dell'Informazione, Universit&#224; di Genova, Via Dodecaneso, 35 16146 Genova, Italy", "person_id": "PP14082290", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/286936.286965", "year": "1998", "article_id": "286965", "conference": "OOPSLA", "title": "Extending the ODMG object model with composite objects", "url": "http://dl.acm.org/citation.cfm?id=286965"}