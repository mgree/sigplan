{"article_publication_date": "10-01-1998", "fulltext": "\n How to preserve the benefits of Design Patterns Ellen Agerbo Aino Cornils Computer Science Department, \nUniversity of Aarhus, Denmark. e-mail: {agerbo / cornils}Qdaimi.aau.dk Abstract 2 An Analysis of Design \nPatterns The rapid evolution of Design Patterns has hampered the benefits gained from using Design Patterns. \nThe increase in the number of Design Patterns makes a common vocabulary unmanageable, and the tracing \nproblem obscures the doc-umentation that should be enhanced by using Design Pat-terns. We present an \nanalysis of Design Patterns that will st,rongly reduce the number of Fundamental Design Patterns and \nshow how strong language abstractions can solve the tracing problem and thereby enhance the documentation. \n1 Introduction Design Patterns are presented as a means of encapsulating the experience of programmers \nin a form that is easily com-municated to other programmers in all domains regardless of their expertise \nwithin computer science. The benefits that they claim to provide are the following: 1. They encapsulate \nexperience. 2. They provide a common vocabulary for computer sci-entists across domain barriers. 3. \nThey enhance the documentation of software designs.  The objective of this paper is to promote the point \nof view that the formation of Design Patterns should be re-strictive, and to suggest ways to evaluate \nexisting Design Patterns, leading to a reduction of the number of Design Patterns. In this thesis we \npropose a set of guidelines to follow when evaluating a Design Pattern, and we present the re-sults of \nthese guidelines applied to the Design Patterns of [Gamma et al. 951. For the Design Patterns that are \nconsidered genuine De-sign Patterns after this evaluation, we have investigated how they could be defined \nas Library Design Patterns in a class library and reused by use of inheritance or delegation -any such \nDesign Pattern will in this paper be denoted an LDP. One of the advantages of using such LDPs is that \none doesn t have to copy the structure of the Design Pattern anew each time a Design Pattern is applied \nin a new context. Thereby reducing the implementation overhead; a problem connected to the use of Design \nPatterns identified by Jan Bosch in [Bosch97]. Another advantage is that by using a LDP it will be possible \nto trace that the Design Pattern is used in an application, which consequently will promote the documentation \nbenefit. Permlsslon to make dlgdal or hard copses of all or part of this work for personal or classroom \nuse IS granted without fee prowded that copes are not made or datributed for probt or commercial advan-tage \nand that CCIPNZS bear this notvce and the full cutatnn on the 11~1 page lo copy olherwse, to republish. \nto post on servers or to redistribute to IIS~S, requires pruor specific perrmssw~n and/or a fee. OOPSLA \n98 10198 Vancouver. B.C. 134 6, 1998 ACM l-581 13.005.8/98/0010...$5.00 The generally accepted definition \nof a Design Pattern is that it is a description of a well tested solution to a recurring problem within \nthe field of software designs in Object Ori-ented languages. This definition clearly accentuates what \nthe principal idea behind Design Patterns is; namely to distribute the knowledge of good design, such \nthat designers of software applications can benefit from work previously done within similar areas. However, \nthe definition also leaves it up to the individual designer to decide what constitutes a Design Pattern \nsince terms like well tested and recurring are not objective terms that can be evaluated true or false \nin an unambiguous way. The consequence of this is that new Design Patterns appear in a seemingly endless \nstream; each of the new Design Patterns being presented with the best intents, since they represent some \nexperience to be dis- tributed to the entire society of framework designers. One has but to look at the \nPatterns Home Page to be convinced that there exists numerous patterns, and that the amount is continuously \nincreased by PLOP conferences and discussion groups. The obvious consequence is that the number of Design \nPatterns will grow to a level, where it becomes impossible to maintain an impression of which Design \nPatterns exist, let alone to know what problems these Design Patterns actually solve. This will in turn \ndestroy the possibility of using the Design Patterns as a common vocabulary, which otherwise holds the \npotential of becoming one of the primary benefits of using Design Patterns to document software systems. \nIt will also obscure the entire field of Design Patterns, so that it becomes too hard to find the Design \nPattern to help with a given problem. This may dissuade designers from using Design Patterns as a helping \ntool in the design phase. In short, an overdose of Design Patterns will eliminate two of the three benefits \nthat Design Patterns offer; they will make it too laborious to find and use the encapsulated experience, \nand they will make the common vocabulary too large to be easily comprehended. There are two possible \nsolutions to this problem: One is to restrict the submittance of new Design Patterns by inventing restrictions \nthat prospective Design Patterns must abide to in order to be accepted. The problem with this approach \nis that too much control in the innovative phase of discovering new Design Patterns will invariably exclude \nnew Design Patterns unjustly, since it is next to impossible to find proper restrictions without knowing \nall potential Design Patterns beforehand. Another solution is to evaluate the existing Design Pat-terns, \nand for each Design Pattern decide whether it qualifies or not. The problem is again to find the guidelines \nby which to decide whether or not the prospective Design Pattern is accepted, but the advantage is that \neach Design Pattern will be evaluated in its own right, which should minimise the probability of rejecting \na Design Pattern unjustly. We will in this paper present an analysis in the form of a set of criteria, \nthat we have used for an evaluation of the De- sign Patterns that are presented in [Gamma et al. 951. \nOur analysis does not go so far as to identify the true Design Patterns and to throw away the rest; instead, \nit focuses on assembling a core of Fundamental Design Patterns (FDPs) which should capture good Object \nOriented design on a suf- ficiently high level so that it can be used in various kinds of applications. \nThe Design Patterns that are not judged to be Fundamental are then either classified differently or rejected \ncompletely. It is important to note that we do not believe our analysis to be the analysis of Design \nPatterns. It has evolved from our work with the Design Patterns from [Gamma et al. 951, which means that \nthe criteria are based on a rather narrow set of Design Patterns. If the analysis was tested on a larger \nnumber of Design Patterns, it might be revealed that the criteria are not sufficient or that some of \nthe criteria are too restrictive in that they unjustly rule out some valid Design Patterns. We do believe, \nhowever, that the criteria form a sound starting point in a much needed discussion on the quality of \nthe Design Patterns. In [Agerbo97] we have evaluated the Design Patterns in [Gamma et al. 951 using the \nguidelines of this analysis. We give some examples of how the guidelines of the analysis are applied \non a few of the Design Patterns -for the complete analysis we refer to [Agerbo97]. 2.1 The Analysis \nWe present an analysis whose purpose it is to define Fun-damental Design Patterns. As mentioned above, \nwe believe it is better to have a conservative analysis, that will accept too many Design Patterns rather \nthan unfairly reject some Design Patterns. Our analysis is therefore based on three guidelines on when \nnot to accept a prospective Design Pat-tern as an FDP. It will be possible to make a stricter analysis \nby adding further guidelines without changing the original guidelines. 2.1.1 Design Patterns vs. language \ncon-structs In [Gamma et al. 951 the authors state that one person s Design Pattern can be another person \ns primitive building block, because the point of view affects one s interpretation of what is and what \nis not a Design Pattern. And the point of view is influenced by the choice of programming language. In \n[Gamma et al. 95, p. 41 it is said: The choice of programming language is important, be-cause it influences \none s point of view. Our patterns assume SMALLTALK/~++ level language features, and that choice determines \nwhat can and cannot be implemented easily. If we assumed procedural languages, we might have included \ndesign patterns called ?nheritance , Encapsulation , and Polymorphism . Similarly, some of our patterns \nare sup-ported directly by less common object-oriented languages. Thus, they believe that Design Patterns \ndo not need to be language independent. We agree with [Gamma et al. 951 so far that the Design Patterns \nextracted from various applications will always be dictated by the programming language used in the appli-cation; \nthings that are easy to do will not be worth form-ing into a Design Pattern. But where [Gamma et al. \n951 seem to believe that Design Patterns should emerge from each programming language, we are of the \nconviction that the Fundamental Design Patterns should not be covered by any generally accepted language \nconstruct. This point of view is rooted in our belief that a Fundamental Design Pat-tern must be independent \nof any implementation language. There should not be Design Patterns for C++ program-mers or Design Patterns \nfor Delphi programmers , since a such partition would have the following consequences: l Programmers \nusing one programming language will be able to understand and exchange Design Patterns with other programmers \nusing the same programming lan-guage, but not with programmers using some other programming language. \nThis will either create bar-riers between programmers who have essentially the same background, namely \nthe object oriented line of thought, or it will mean that the Design Patterns will not be used to the \nfull of their potential even within the different societies of programmers. In either case the Design \nPatterns will have lost their ability to provide a common vocabulary between object oriented designers \nregardless of their background. An example of this can be found in [Alpert et al. 98, p. 31 where the \nauthors justify the need for gather-ing the Design Patterns from [Gamma et al. 951 in a SMALLTALK version \nwith the following: The Gang of Four s Design Patterns presents design issues and solutions from a C++ \nperspective. It illu-strates patterns for the most part with C++ code and considers issues germane to \na C++ implementation. Those issues are important for C++ developers, but they also make the patterns \nmore difficult to under-stand and apply for developers using other languages. The same Design Pattern \ncan exist under different names in different programming languages. It will be hard to compare two Design \nPatterns coming from different groups of Design Patterns, since the back-grounds in given programming \nlanguages will almost certainly have an impact on the presentation of the Design Pattern. If a programmer \nwho has accustomed to work in some programming language changes to another program-ming language, he \nwill have to learn a whole new set of Design Patterns. A collection of language specific Design Patterns \nwill sooner or later evolve into cover-ups for shortcomings of the programming language that will explain \nhow things can be done cleverly using some or other lan-guage construct. An example of this is found \nin [Coplien94], that con-tains a collection of C++ idioms. If we on the other hand concentrate on building \na core of Fundamental Design Patterns that are not covered by any generally accepted language construct, \nwe can use this core to form the common vocabulary to be used among computer scientists regardless of \nbackground. However, a Design Pattern which is covered by a lan- guage construct in one language might \nstill be a design idea worth preserving in languages which do not have this lan-guage construct. Therefore, \nwe believe that the Design Pat-terns, which are not Fundamental because they are language dependent must \nbe kept as Language Dependant Design Patterns (LDDPs). They should not be partitioned by the languages \nthey are useful in, but rather by which language construct(s) they are covered by. This way a designer \ncan use the Fundamental Design Patterns (FDPs) plus the part of the LDDPs that is necessary for the programming \nlan-guage he uses for his implementations. In time, we imagine that some of the LDDPs will be removed \nfrom the field of Design Patterns when the covering language constructs are adopted by the majority of \nthe object oriented languages. These reflections lead to Guideline 1: Design Patterns covered by language \nconstructs are not Fundamental Design Patterns.  2.1.2 Design Patterns are original ideas The fields \nin which the Design Patterns can be used are nu- merous. It is an almost certain fact that the various \npossible applications of some Design Pattern will not look the same; for each application the roles of \nthe Design Pattern have been parameterised by roles from the application. There will be restrictions \nfrom the applications that were not con-sidered in the Design Pattern, and the Design Pattern will be \nforced to adjust accordingly. It might be convenient if these adjustments were recorded in some way, \nsuch that pro-grammers who are applying some Design Pattern in a given field could exploit the experiences \nfrom previous applications within the same field. These experiences should in fact be named Design Patterns \nin that they clearly fit into the def- inition of being well-tested solutions to recurring problems, \nand - they do encapsulate experience - they do enhance the documentation of frameworks - they do provide \na common vocabulary within the given field  The obvious problem is that this would cause an explo- \nsion of new Design Patterns; the disadvantages of which have been discussed in the previous section. \nThese new Design Patterns would bring little new of general interest, and they would not be generally \nunderstandable for pro-grammers regardless of their background. Since these De-sign Patterns can be categorized \nas mere variations or appli- cations of a Design Pattern, we have chosen to place them as Related Design \nPatterns in Design Pattern families. For each of these families, the original Design Pattern (which can \nbe either a Fundamental or a Language Dependent De-sign Pattern) will figure as the head of the family. \nWhen a designer wants to make use of a Design Pattern, he can get the main idea from the head of the \nfamily and investigate the related Design Patterns for more specific solutions. That these variations \nwill not add to the number of Fundamental Design Patterns will be ensured by Guideline 2: Applications \nand variations of Design Patterns are not Fundamental Design Patterns.  2.1.3 Design Patterns are design \nideas When building an application within object oriented pro-gramming, there will be many problems to \nsolve. The size of these problems may naturally differ, as may what ap-pears to be hard problems, and \nwhat is easily solved. It is therefore difficult to set any limits to the size of problem a Design Pattern \ncan solve. However, since it must be as-sumed that the programmers, who use the Design Patterns, all \nare schooled in the object oriented line of thought, they posses a common ground of knowledge, that will \nlet them know the answers to certain problems without too much thought. In [Gamma et al. 951 the authors \nhave an intro-ductory section containing good advice as to how to apply the object oriented concepts \nto build flexible, reusable soft-ware. It is among other things here explained when to use class inheritance \nas opposed to when to use composition. These kinds of advice are things that should be common knowledge \nto programmers in object oriented programming and will therefore not be thought of as problems needing \nan explicit solution. So even though these advice do represent solutions to recurring problems within \nthe field of object orientation they are not cast out as new Design Patterns. New Design Patterns must \nrepresent solutions to actual problems in design that could be of interest to the society of object orientation \nin general, regardless of one s previous experience. This leads to Guideline 3: A Design Pattern may \nnot be an inherent object oriented way of thinking.  2.1.4 Design Patterns reconsidered The product \nof an analysis will be the Design Patterns di-vided into three categories: The Fundamental Design Pat-terns, \nwhich are language-independent original ideas; the Language Dependant Design Patterns, which are covered \nby a language construct and the Related Design Patterns, which are applications or variations of a Fundamental \nor Language Dependant Design Pattern. For all three cate-gories of the Design Patterns the actual implementations \nwill vary from one language to another, and it could there-fore be useful to collect implementation hints \nin language specific catalogues (as it is done in eg. [Alpert et al. 981). But it is important to keep \nthe design ideas as far from ac-tual languages as possible, such that all designers can gain from them \nregardless of background..  2.2 Applying the analysis We have applied the analysis on the Design Patterns \nin [Gamma et al. 951. The Design Patterns presented in this collection are probably the best known patterns \nin the area, which should enable the readers of this paper to focus on the analysis and its results instead \nof on the functionalities of the Design Patterns. Furthermore they are presented as domain independent \npatterns, and even though they lay no claims as to being an exhaustive collection of Design Pat-terns \nin the field of object-oriented design, they are fairly widely spread in their proposed uses, so we felt \nthat they would provide a sensible base. For the obvious reasons of space, we will not present the evaluations \nof all 23 Design Patterns in this paper, but instead we present an example of the application of each \nguideline on a Design Pattern. For the detailed analysis of all the Design Patterns we refer to [Agerbo97]. \n2.2.1 Factory Method The purpose of this Design Pattern is to create objects whose exact classes are \nunknown until runtime. This is done in [Gamma et al. 951 by instantiating the objects in virtual methods \nthat can be bound at runtime as shown in Fig-ure 1. creator where it can be said that a P is at least \na SuperP, the further binding VP will at least be the class VP that it extends. ConcreteCreatorA ConcreteCreator \n; * I I ProductA I 1 Product0 tkmryMethod(, -; ~ac,oryMcthod() -:------------I Using this notation we \ncan now show how to use virtual classes instead of FactoryMethod to guarantee that the pro- ductclass \ncan be chosen by the subclasses of the creatorclass. Instead of having a virtual creator-method to handle \nwhat concrete class to instantiate at runtime, it is now possible to attack the problem more directly \nby making the product- class virtual. This makes it possible to bind the class to be instantiated at \nruntime, instead of binding the creator-method at runtime. I _ creator AbstractProduct operarm , p Product \ni ti. q + +] ProductA I ConcreteCreatorA Figure 1: The Factory Method Design Pattern In a language with \nvirtual classes the goal of this Design Pattern can be achieved quite differently. The concept of virtual \nclasses is explained in depth in [Madsen89], is im- plemented in BETA ([DETA93]) and has been proposed \nas an extension to JAVA ([Thorup97]). To show how the use of vir- tual classes will solve the problem \nbehind Factory Method, we need an expansion of the GMT-based notation that has been used in [Gamma et \nal. 951. We have chosen to use the notation in Figure 2 for a further binding of a virtual class. VP \nis in the class P declared to at least have the type V, and this type is then extended in a subclass \nof P to have the type subV. SubV Figure 2: Further virtual bindings in subclasses The similarity to the \nnotation for inheritance is not coin- cidental. As with a specialisation P of a superclass SuperP, Figure \n3: Factory Method modelled using virtual classes An advantage in using virtual class patterns is that \nit is not necessary to rewrite a new FactoryMethod for each concrete product class. Furthermore it is \nnow possible to ex- tend the interface of the AbstractProduct-class, which is not possible using the \noriginal FactoryMethod Design Pattern. It is clearly demonstrated that FactoryMethod is covered by the \nlanguage construct virtual classes, and according to Guideline 1 it should therefore not be accepted \nas a Funda- mental Design Pattern, but should instead be classified as a Language Dependant Design Pattern \nto be used in pro-gramming languages without virtual classes.  2.2.2 Observer The motivation behind \nthis Design Pattern is to define a one-to-many dependency between objects such that when one object changes \nstate, all its dependents are notified and updated automatically. An object (a Subject) can have many \nrepresentations (Observers) and when one of these rep- resentations are changed by the user, the object \nbehind it and all the other representations will be changed. The re-presentations do not know about each \nother. This enables a user to add or to delete new representations as he wishes. We claim that this Design \nPattern is in fact an applica- tion of the Mediator Design Pattern. The Mediator Design Pattern defines \nan object (a Mediator) that encapsulates how a set of objects (Colleagues) interact. The intent of the \nDe- sign Pattern is to promote loose coupling by keeping objects from referring to each other explicitly, \nand it makes it pos-sible to vary their interaction independently. The structure is shown in Figure 5. \nWhen the functionality of an Observer is desired, an application of the Mediator Design Pattern can be \nimple- mented instead by letting the ConcreteSubject play the role I I Figure 4: The Observer Design \nPattern Figure 5: The Mediator Design Pattern of the ConcreteMediator and the ConcreteObservers play \nthe role of the ConcreteColleagues. Thus the ConcreteSubject will be the mediator between the ConcreteObservers \nand the communication it needs to handle will be the notification procedure. That Notify is to be called \nwhenever the state of the ConcreteSubject changes is an application specific fea-ture, that is added \nin the observer-part . There is more information in an Observer than in a Me- diator since the communication \nbetween the Subject and Ob-servers is fixed, but this is why it is an application of Medi- ator and not \njust a variant. According to Guideline 2, the Observer Design Pattern should therefore not be a Fundamental \nDesign Pattern, but a Related Design Pattern belonging to the family of Medi- ator Design Patterns. \n2.2.3 Strategy This Strategy Design Pattern defines a family of algorithms, encapsulates each one and \nmakes them interchangeable. Strat-egy lets the algorithm vary independently from clients that use it. \nIt is useful when many related classes differ only in behaviour, because it makes it possible to configure \na class with one of many behaviours. The Design Pattern can also be applied when a class has many conditional \nstatements in an operation to avoid it becoming clumsy and confusing. Each behaviour can be placed in \nits own class, thus build-ing a simple hierarchy of behaviours. The structure of the Strategy Design \nPattern is shown in figure 6. When comparing the applicability of the Strategy De-sign Pattern with the \nintent of the State Design Pattern in [Gamma et al. 95, pp. 3051, it will appear as if State solves the \nsame problem as Strategy, thus making Strategy redundant. Both aim at encapsulating behaviour in objects, \nbut whereas State wants the behaviour to reflect the state of the context and therefore change at runtime, \nthe Stra-tegy Design Pattern leaves it up to the client to choose a ConcreteStrategyA ConcreteStrategyB \nConcreteStrategyC Algorithmlntrrface() Algori~hmlnterfaceO Algorithmlnkrface() Figure 6: The Strategy \nDesign Pattern concrete strategy to work with. In the State Design Pat-tern it should be possible to \nchange directly from one state to another when some condition is met, which means that the different \nconcrete State classes have to be interdepen- dent so that they can pass whatever data is necessary to \none another. In the Strategy Design Pattern, it is the client that decides what ConcreteStrategy to apply, \nand the data needed by the ConcreteStrategy will be provided by giving the Context object as argument \nto the Strategy. It is thus obvious that there is a fundamental difference between the two Design Patterns, \nbut it is not one that is visible from the structures of the Design Patterns as pre- sented in [Gamma \net al. 951; in fact the close connections in the purposes of the two Design Patterns is mirrored in almost \nidentical structures of the Design Patterns. Evaluating the Strategy Design Pattern we believe that announcing \nthis as a Design Pattern is stretching the con-cept of Design Patterns too far. Having different implemen-tations \nof some method encapsulated in virtual methods, and using dynamic dispatch for binding them at runtime \nshould represent a fundamental way of thinking when pro-gramming in an object-oriented language. We conclude \nthat the Strategy idea should not be a De- sign Pattern according to Guideline 3.  2.2.4 Results For \neach of the Design Patterns in [Gamma et al. 951, we have in [Agerbo97] discussed whether it is covered \nby a known object oriented language construct (and thereby an LDDP), an application of another Design \nPattern (an RDP) or an inherent way of thinking in object-oriented program-ming. The results of this \nanalysis are shown in the table in Figure 7. The seven Design Patterns marked as LDDPs are good design \nideas that are covered by generally known language constructs. These Design Patterns are the ones that \nshould spur on the evolution of programming languages to encom-pass stronger language constructs. There \nare only two Design Patterns marked as RDPs, but there will be many more once the analysis is applied \nto other catalogues of Design Patterns. Some of the Design Patterns that will fall into this category \nare obvious variants of Design Patterns, such as State Patterns ([Dyson et al. 961) and Variations on \nthe Visitor Pattern ([Nordberg96]) where the authors propose several variations on the Design Pat-terns \nfrom [Gamma et al. 951. Other Design Patterns will only after thorough reading prove to be variations \non exist- ing patterns. An example is the Design Pattern Late Cre-ation ([Baumer et al. 961) which in \nfact is a variation on the Abstract Factory Design Pattern. The Design Pattern proposed in this paper \nlies very close to what is described in Name Category Application of Guideline Abstract Factory FDP \nBuilder FDP Factory Method LDDP Prototype LDDP Singleton LDDP Adapter Bridge F6P Composite FDP Decorator \nFDP Facade LDDP Flyweight FDP Proxy FDP Chain of Responsibility FDP Command LDDP Interpreter RDP Iterator \nFDP Mediator FDP Memento FDP Observer RDP State FDP Strategy Template method LDDP Visitor LDDP Figure \n7: Analysis of Design the Implementation section of [Gamma et al. 951 as Defining extensible factories. \nFinally there is some likelihood that some of the designers of Patterns over the years will have come \nup with almost identical ideas and solutions, but have named the resulting Design Patterns according \nto their own taste. This is already acknowledged in [Gamma et al. 951 where each Design Pattern has a \nsection with the name Also Known As. Concludingly, the Design Patterns left as good design ideas seen \nfrom a general object oriented view are the twelve marked as an FDP in the table in Figure 7. This leads \nus to conclude that it is beneficial to have a critical approach to Design Patterns, because it minimises \nthe amount of Fun- damental Design Patterns and thereby makes the area of Design Patterns easier to get \non top of. 3 Solving the Tracing Problem by Certain Language Features One of the advantages gained by \nusing Design Patterns is that large software systems are better documented because a large part of the \nexplanation on how the system works lies in which Design Patterns that have been used to design the system. \nBut when the designers have used a large number of Design Patterns in their applications and some application \nclasses play roles in more than one Design Pattern it be-comes difficult to trace, which Design Patterns \nhave been used. This problem is known as the Pacing Problem and has been discussed in [Bosch981 and [Soukup95]. \n1: Covered by Virtual classes 1: Covered by Pattern variables 1: Covered by Singular objects  3: Reuse \nof existing code. 1: Covered by Nested Classes 1: Covered by Explicit Delegation 1: Covered by Procedure \nclasses  2: Application of Composite 2: Application of Mediator  3: Dynamic dispatch 1: Covered by \nComplete block structure 1: Covered by Multiple dispatch  Patterns from [Gamma et al. 951 A proposal \nto solve this problem is to use Library De-sign Patterns (in short LDPs). When using LDPs in the application \ncode, it will be possible to trace from which De-sign Pattern the implementation ideas came. It is generally \nrecognised that Design Patterns provide a common vocabulary that makes it possible for designers from \nwidely different application areas to communicate with each others. If designers were to make a habit \nof using commonly known Design Patterns in their applications, it would make it easier for outsiders \nto read and understand the programs and thereby making long term maintenance an easier task. We believe \nthat a way of promoting the habit of using Design Patterns is to have the Design Patterns as LDPs in \na library where they are easily accessible. Another advantage of having a Design Pattern as an LDP is \nthat it is not necessary to copy the design ideas anew each time a Design Pattern is applied in a new \ncontext. However, this will only work when the intent of the Design Pattern is mirrored in the library \nversion, and any application that uses the LDP automatically adheres to the intent of the Design Pattern. \nSeen from a modelling point of view, it is of course just as good to copy the idea of the Design Patterns \ndirectly from [Gamma et al. 951, but this solution places a bigger demand on the designer of the application. \nThere are naturally also costs to pay when using LDPs. When placing a Design Pattern in a library as \nan LDP, this imposes a certain rigidness on any application in which the LDP might be applied. The Design \nPattern will be fixed, in the sense that it will not be possible to adapt it in other ways than those \nthat were foreseen when making the LDP. Another disadvantage is the use of names in the LDPs. Having \nan abstract method declared in a class of the LDP with the name anoperation will enforce that the applica-tion \nusing the LDP has to implement the method under the name anoperation where the use of another name might \nhave been more informative. This is however a small price to pay to have ready-to-use solutions available \nin a library, and a common problem for all who use functions from libraries. The most obvious way of \nusing a library of Design Pat-terns is by letting the classes in the application inherit from the classes \nin the LDP. In languages without multiple in-heritance this will cause problems whenever the classes \nin the application already inherit from other classes -either because they are part of existing hierarchies \nin the applica- tion or because they play roles from more than one Design Pattern. In the following subsection \nwe show how the use of composition can solve this problem, provided that certain features are accessible \nin the programming language. 3.1 Simulating Multiple Inheritance by Com-position One of the advantages \nin using multiple inheritance com-pared to composition is that with a class inheriting from several other \nclasses, where some of those have virtually de-clared classes or methods, it is possible to re-bind these. \nIn BETA this advantage could also be achieved with com-position by creating a singularly defined part \nobject Addr: Addr: 0 Address(# extension #) as an instance of a locally defined anonymous subclass of \nAd-dress. An example of this and the structure in our expanded OMT-notation is shown below. Address: \n(# Street:@ Text; Town:@ Integer; printLabel:< (# do inner; (*print Street, Town*) #) #I; Person: (# \nName:@ Text: Addr:@ Address (# printlabel:: (# do ; (*print Name*); #) #) #I Since printLabel is defined \nas a virtual method in the class Address, and Addr is a singular instance of a locally defined subclass \nof Address it is possible to further bind printLabel in Addr. This way, the method printLabel can be \nextended to serve the Person class better. Using this kind of composition, designers can add roles to \nclasses throughout the whole system development by nesting part objects containing roles from the Library \nDesign Pat-terns into the application classes and still be able to gain from the virtual classes and \nmethods in the LDPs. Further-more it will always be evident that a Design Pattern is used, since the \napplication-specific hierarchy will be built by in-heritance whereas the roles played from the LDPs will \nbe played by nested objects. Using multiple inheritance this distinction will not be as easily made. \n 3.2 Implementing the LDPs In [Agerbo97] we have discussed how and to what extent the Fundamental Design \nPatterns could be placed in a library of Design Patterns. In this article we show an example of these \ndiscussions to illustrate what we believe could be possible and profitable to keep in a library. The \nclasses in the applications using such a library are sometimes already subclasses of other classes in \nthe applica- tion or play roles from one or more Design Patterns. There-fore, in the descriptions of \nthe LDPs we assume that such a library is used in a language with multiple inheritance or the possibility \nto simulate multiple inheritance, because the use of LDPs will mean that the classes in the application \ninherit from the classes in the LDP. The following discussions are based on the descriptions of the Design \nPatterns found in [Gamma et al. 951, and require the book at hand for full understanding. 3.2.1 Flyweight \nThe application-dependent issues to consider when making an LDP out of Flyweight are the following: What \nkind of object is a key ? How does a key identify a flyweight-object? How is the state of an object split \ninto extrinsic state and intrinsic state? What operations should the flyweights support? These considerations \nhave led to a Flyweight-LDP as shown in Figure 8. By having the LDPs FlyweightFactory declaring keyType \nas a virtual class and the procedure getFlyweight a virtual procedure it makes it possible for the concrete \napplication to decide what key to use as well as to specify how that sort of key should identify a flyweight \nobject. It is enough for the abstract FlyweightFactory to know that there is a key and a flyweight determined \nby the key to be able to maintain the pool of shared flyweights under the invariant that there is only \none instance of each flyweight. In the application of the LDP the flyweightType should be further bound \nto the class of shared flyweights, MyCon-creteflyweight, -it is thus guaranteed that each flyweight in \nthe poolOfFlyweights has this type, which in turn guar-antees that the IntrinsicState has been further \nextended in accordance with the concrete application. We have chosen to have the abstract class Flyweight \nde-clare the classes ExtrinsicState and IntrinsicState since this separation is a fundamental property \nof a flyweight object. This will however mean that any application using the LDP poolOfFlyweights 7 \nI msert(keyType, flyweightType) elements 1 from Object 7 A A MyFlyweight extended operation(Extr;nsicSrate): \nc 7 A I I 1 I I MyConcreteFlyweight 1 MyUnsharedConcreteFlyweight 1 I extended I operation(ExtrinsicState):: \np operation(ExtrinsicState):: 0   wpssq -1 Inscrl(kcy.llyweiaht(Ley)) I I I I ~-_------~~_--__-_-----------------~~~~~~~~~~~~~ \nFigure 8: Flyweight-LDP 141 will have to use the terms ExtrinsicState and IntrinsicState in-stead of \nmore application-specific names. In the text editor example motivating this Design Pattern the extrinsic \nstate could typically be the character s font, size and placement. The use of the LDP would here imply \nthat these attributes should be nested into an extension of the virtual pattern ExtrinsicState. The advantage \nof having Flyweight as an LDP lies pri- marily in the FlyweightFactory class, where the use of virtual \nclasses makes it possible to have an abstract implementation of the poolOfFlyweights even though the \nkeyType and fly-weightType is only known in the concrete application. This implementation of the poolOfFlyweights \nensures that the in- tent of the Design Pattern is met whenever this LDP is applied in an application. \n3.3 Discussion In section 3.1 it is described how the LDPs are reused by letting the classes in the application \ntake on roles from the Design Pattern by nesting instances of locally defined anony-mous subclasses of \nthe LDP. This means that the use of LDPs would annotate where the Design Patterns were used in the applicat,ion. \nThis automatic annotation is a very im-portant contribution to the documentation of software sys-tems \nA number of the language features in BETA prove them-selves especially useful in connection to the LDPs \nby sup-porting genericity and reuse of models. This is further elab-orated on in [Agerbo97] where we \nshow how the intent of a Design Pattern could be encapsulated as an LDP for 10 out of the 12 Fundamental \nDesign Patterns, and that it in 6 out of these 10 cases is due to uirtual classes and nested classes. \nThat it in this way is possible to reuse enough of a De-sign Pattern for it to be applied directly from \nan LDP while keeping the intent of the Design Pattern intact reduces the impltmentution ouerheud, a problem \nconnected to the use of Design Patterns identified by Jan Bosch in [Bosch97]. The fact that it is possible \nto make a useful LDP out of a Design Pattern proves that it is possible to make a reusable implementation \nof it. And since the Design Patterns in [Gamma et al. 951 formulate good design- or implementation- ideas, \nthe language features that support them must be con- sidered flexible and useful in relation to reuse \nof design. 4 Related Work Most efforts concerning Design Patterns have so far been put into discovering \nnew Design Patterns and investigat-ing their usefulness. To the best of our knowledge, little work has \nbeen done in evaluating the existing Design Pat-terns. The only other critical evaluation of Design Patterns \nwe have found is the article Design Patterns vs. Lan-guage Design ([Gil et al. 971) where Joseph Gil \nand David H. Lorenz have offered a taxonomy of the Design Patterns from [Gamma et al. 951 based on how \nfar they are from be-coming actual language features. They have partitioned the Design Patterns as either \ncliche s, idioms or cadets, which correspond to an application of Guideline 1 and 3 from our analysis \non the Design Patterns. This taxonomy was pre-sented as a workshop paper at ECOOP 97, and it needs a \nmore thorough argumentation for its classifications, which we have discussed in depth in [Agerbo97]. \nTheir resulting taxonomy is difficult to compare to ours directly, since they allow the same Design Pattern \nto appear in several cate-gories, and their reasonings are somewhat fuzzy at places. However, the fact \nthat the two categorisations are not iden-tical shows that it will be hard to obtain a consensus on any \none evaluation of Design Patterns; especially will it be hard to agree on what Design Patterns are formalisations \nover inherent object oriented ways of thinking -[Gil et al. 971 claims that three of the Design Patterns \nfall into this cat-egory, none of which we have categorised in the same way. However, the fact that two \nalmost identical set of Guide- lines have evolved independently indicates that they can be used as valid \nstarting points for a dialogue on the quality of Design Patterns. The tracing problem has become a generally \nrecognised problem within the field of Design Patterns. Gore1 Hedin has proposed a technique for formalising \nDesign Patterns which allows the Design Pattern applications to be identified in the source code ([Hedin97]). \nThe technique is based on attribute grammars, and places a demand on the programmer that he explicitly \nannotates his program with Design Pattern roles. This has the benefit that it will also enable automatic \ncheck-i71y, i.e. it will be possible to decide whether or not a Design Pattern has been applied correctly. \nThe largest difference between this approach and ours is that our approach will partly reduce the implementation \noverhead, whereas Hedin s solution can work as a debugger for Design Patterns where our solution can \nnot guarantee that the Design Patterns are applied correctly. Jiri Soukop has also tried to solve the \ntracing problem. In his article Implementing Patterns ([Soukup95]), he pro- poses to build a library \nof Design Patterns consisting of so- called pattern classes. A pattern class encapsulates all the behaviour \nand logic of the Design Pattern and the classes that form the Design Pattern in the application thus \ncontain no methods related to the Design Pattern. What is left in the classes are only pointers and other \ndata required for the Design Pattern. The problem of this solution is that all the structure of the Design \nPattern is lost, since everything is now contained as methods in the pattern class. 5 Conclusion The \nobjective of this article is to regain the benefits of using Design Patterns: 1. They encapsulate experience. \n 2. They provide a common vocabulary for computer sci-entists across domain barriers. 3. They enhance \nthe documentation of software designs.  We believe that the field of Design Patterns should be narrowed \ndown to a minimum, to preserve the first two bene- fits of Design Patterns. By partitioning the Design \nPatterns into Fundamental Design Patterns, Language Dependant Design Patterns, and Related Design Patterns, \nwe have a core of the Design Patterns -the Fundamental Design Pat-terns -which fully provides the benefits \nof Design Patterns. 12 of the 23 Design Patterns from [Gamma et al. 951 are classified as Fundamental \nDesign Patterns following these criteria. This leads us to conclude that it is beneficial to have a critical \napproach to Design Patterns, because it minimises the amount of Fundamental Design Patterns and thereby \nmakes the area of Design Patterns easier to get on top of. Using Design Patterns in software systems \nshould make it an easier task to document the systems. There is however the problem, that the more Design \nPatterns that are applied, the more difficult it will be to recognise the structure of the participating \nDesign Patterns. This is referred to as the tracing problem. We have in this paper described how the \nuse of LDPs can preserve the Design Patterns in a library, and how the use of these would guarantee automatic \nannotation in a program that some object participates in an application of a Design Pattern. Furthermore, \nwe claim that the presence of nested classes and virtual classes in the programming language will reduce \nthe implementation overhead, since these two lan-guage features makes it possible to capture the intent \nof the Design Pattern in the collaborations between the objects, and to inherit the interdependencies \nin an application. This is described in detail in [Agerbog ?], where we have shown that out of the 12 \nFundamental Design Patterns, 10 can be implemented as LDPs preserving the intent of the Design Pattern. \nThus the use of LDPs will provide us with a means of ensuring the third benefit of Design Patterns, and \nit will to some extent eliminate the implementation overhead if the chosen implementation language possess \nthe necessary lan-guage abstractions. References [Agerbo97] Ellen Agerbo and Aino Cornils (1997): Theory \nof Language Support for Design Patterns. Department of Computer Science, Aarhus University. [Alpert et \nal. 981 Sherman R. Alpert, Kyle Brown and Bobby Woolf (1998): The Design Patterns Smalltalk Companion. \nAddison-Wesley Publishing Company. [Bosch971 Jan Bosch (1997): Design Patterns &#38; Frame-worlds: On \nthe Issue of Language Support. Workshop on Language Support for Design Patterns and Object-Oriented Frameworks \n(LSDF), ECOOP 97. [Bosch981 Jan Bosch (1998): Design Patterns as Language Constructs. Journal of Object \nOriented Programming, May 98 pp. 18-32. [Bsumer et al. 961 Dirk B;iumer and Dirk Riehle (1996): Late \nCreation: A Creational Pattern. PLOP 96. [Coplien94] J.O. Coplien (1994): Advanced C+S: Program-ming \nStyles and Idioms. Addison-Wesley, Reading, MA. [Dyson et al. 961 Paul Dyson and Bruce Anderson (1996): \nState Patterns. PLOP 96. [Gamma et al. 951 Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides (1995): \nElements of Reusable Object-Oriented Software. Addison-Wesley Publishing Company. [Gil et al. 971 Joseph \nGil and David H. Lorenz (1997): De-sign Patterns vs. Language Design. Workshop on Lan-guage Support for \nDesign Patterns and Object-Oriented Frameworks (LSDF), ECOOP 97. [Hedin97] Giirel Hedin (1997): Language \nSupport for Design Patterns usign Attribute Extension. Workshop on Lan-guage Support for Design Patterns \nand Object-Oriented Frameworks (LSDF), ECOOP 97. [Madsen891 0. L. Madsen, B. Moller-Pedersen (1989): \nVir-tual classes: A powerful mechanism in object-oriented pro-gramming. Proceeding of OOPSLA 89. [Madsen921 \n0. L. Madsen, B. Merller-Pedersen (1992): Part-objects and their location. Proceeding of TOOLS 92 pp. \n283-297. [BETA931 0. L. Madsen, B. Moller-Pedersen, K. Nygaard (1993): Object-Oriented Programming in \nthe BETA Pro-gramming Language. Addison-Wesley Publishing Com-pany. [NordberggG] Martin E. Nordberg III \n(1996): Variations on the Visitor Pattern. PLOP 96. [Soukup95] Jiri Soukup (1995): Implementing Patterns. \nPattern Languages of Program Design. Eds. Coplien and Schmidt. Addison-Wesley 1995. [Thorup97] K. K. \nThorup (1997): Genericity in JAVA with Virtual Types. Proceedings of ECOOP 97 pp. 444-469. Springer-Verlag. \n \n\t\t\t", "proc_id": "286936", "abstract": "The rapid evolution of Design Patterns has hampered the benefits gained from using Design Patterns. The increase in the number of Design Patterns makes a common vocabulary unmanageable, and the tracing problem obscures the documentation that should be enhanced by using Design Patterns. We present an analysis of Design Patterns that will strongly reduce the number of Fundamental Design Patterns and show how strong language abstractions can solve the tracing problem and thereby enhance the documentation.", "authors": [{"name": "Ellen Agerbo", "author_profile_id": "81100363943", "affiliation": "Computer Science Department, University of Aarhus, Denmark", "person_id": "P76924", "email_address": "", "orcid_id": ""}, {"name": "Aino Cornils", "author_profile_id": "81100208035", "affiliation": "Computer Science Department, University of Aarhus, Denmark", "person_id": "P11517", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/286936.286952", "year": "1998", "article_id": "286952", "conference": "OOPSLA", "title": "How to preserve the benefits of design patterns", "url": "http://dl.acm.org/citation.cfm?id=286952"}