{"article_publication_date": "10-01-1998", "fulltext": "\n Compound Types for Java Martin Biichi and Wolfgang Week Turku Centre for Computer Science (TUCS) Abe \nAkademi University Lemminktiisenkatu 14A, FIN-20520 Turku Martin.Buechi@abo.fi, Wolfgang.Weck@abo.fi \n Abstract Type compatibility can be defined based on name equivalence, that is, explicit declarations, \nor on structural matching. We argue that component software has demands for both. For types expressing \nindividual contracts, name equivalence should be used so that ref- erences are made to external semantical \nspecifications. For types that are composed of several such contracts, the structure of this composition \nshould decide about compatibility. We introduce compound types as the mechanism to handle such compositions. \nTo investigate the integrability into a strongly typed language, we add compound types to Java and report \non a mechan- ical soundness proof of the resulting type system. Java users benefit from the higher expressiveness \nof the ex- tended type system. We introduce compound types as a strict ex- tension of Java, that is without \ninvalidating existing programs. In addition, our proposal can be implemented on the existing Java Vir- \ntual Machine. 1 Introduction One of several reasons to use Java is its support of component- oriented \nprogramming, the creation of compiled building blocks to be used in different contexts, and the assembly \nof systems from such components. JavaBeans [34], Java s component model, com- petes with other component \nsoftware standards, such as CORBA [13] and Microsoft s COM [32], but the language itself may also be \nused to program to these language independent standards. Type systems, such as Java s, help to document \nand safeguard component interfaces. By annotating inter-component call param- eters with types, one provides \nsome primitive documentation on how to use a service and at the same time expresses a statically checkable \nprecondition: the object passed must implement certain methods, as stated by the type. Explicitly declared \nand named types can stand for contracts about services. The behavioral specification ,is documented sep- \narately and linked to the type via the name. A compiler can, of course, not check compliance with such \na specification, but it can verify that references to the same types, and intentionally the same contracts, \nhave been made. Explicitly stated contracts are particu- larly important in the component software realm \n[3.5]. Permission to make dIgItal or hard copses of all or part of the work for personal or classroom \nuse IS granted wthout fee prowded that copes are not made or dlstrlbuted for profd or commercial advan- \ntage and that copses bear thas notoce and the full citation on the farst page lo COPY othervase. to republish. \nto post on servers or to redistribute to Irsts, reqwes pnor specific permw~on and/or a fee. OOPSLA 98 \nlo/98 Vancouver. B C. G 1998 ACM 1.5f3113-005.8/98/0010...$5.00 Frequently, classes need to conform to \nmore than one contract. For instance, Microsoft s OLE [6] defines ActiveX control contain- ers via a \nbundle of contracts to be implemented. Java supports mul- tiple subtyping to this end. Similarly, one \nmay want to declare vari- ables or method parameters of a type comprising several contracts. This is \nnot supported to the same degree by Java. On a first glance it may seem to be no problem because one \nonly would have to declare the right subtype. We will demonstrate, however, that this may not be possible \nwith independently developed software components. This problem is explained in Sect. 2. In Sect. 3 we \ntake the problem to its root, the question whether type compatibility is be- ing decided by name equivalence \nor structural match. We will show that we need a mixture of both, and therefore, we propose com- pound \ntypes in Sect. 4. In Sect. 5 we show how to add compound types to Java. They are a strict extension, \nthat is, existing Java programs need not be changed. This also holds for the run-time support, the byte \ncode and the virtual machine in particular. We il- lustrate the latter in Sect. 6. In Sect. 7 we report \non a mechanically verified soundness proof for the extended type system. Section 8 relates to other work \nand Sect. 9 summarizes our conclusions. 2 The Problem The problem with Java s type system is explained \nin this section. In 2.1 we briefly review the relevant aspects of Java s type system. In the second subsection, \nwe introduce the essentials of component software, the domain in which the problem mainly surfaces. With \nthese preliminaries we show that it may be impossible to sharply type a parameter to demand a specific \ncombination of interfaces, so that existing or independently developed classes need not be modi- fied \nto be compatible. 2.1 Java s type system An essential ingredient of object-oriented programming and \ncom- ponent software is polymorphism. In Java, subtyping relationships can be declared in three ways: \na class can subclass another class, a class can implement an interface, and an interface can extend an- \nother interface. Subclassing provides for code inheritance in addi- tion to subtyping, whereas interfaces \nare pure types, that is, no code is attached to them. Typically, multiple subtyping needs less extra \nconflict resolution rules than multiple subclassing. Thus, Java s designers decided that a class can \nhave only a single direct super- class but implement several interfaces. Because a class without an explicitly \ndeclared superclass implicitly inherits from a predefined class Object, every class -except Object-subtypes \nexactly one The compound types defined in this paper are not to be confused with structured types (records. \narrays, functions), which are sometimes also called compound types. class B interface I interface J \nn _- 7 i-;  1 ,A/ ,, C I class C class C extends B implements I, J { . . . ); Figure I: A class extending \na base class and implementing two interfaces class directly and an arbitrary number, possibly zero, of \ninterfaces, as illustrated in Fig. 1. If a class C is declared to implement an interface I, all methods \ndefined by I exist in C, too. Thus, it is type-safe to assign instances of class C to variables of type \nI. We have to take a closer look at the situation in which a class C implements several interfaces, say \nI and J, that both declare a method with the same name, m. If I and J both declare m with exactly the \nsame signature and return type, C defines m only once and binds this to both interfaces. If the parameter \nlists differ, Java s overloading mechanism takes care of the situation. Both versions exist within C \nand upon a call the one with the best fitting signature is selected.2 The case in which the parameter \nlists are equal but the return types differ is not permitted by the overloading rules. Consequently, \nthe compiler rejects the declaration of C if I and J conflict in this way. Subtyping relations can also \nbe established between interfaces. An interface I can be declared to extend other interfaces JO, . ., \nJn. A class implementing I, implicitly implements all interfaces JO, ., Jn, but not vice versa. Interfaces \ncannot subtype (extend) classes. Whereas subclassing is basically a mechanism for code reuse, multiple \nsubtyping offered via interfaces can be used to express different aspects of objects. For instance, a \nclass D of objects being an applet, runnable in a separate thread, and wanting to be informed of changes \nin observable objects, would subclass the class Applet and implement the interfaces Runnable and Observer. \nThese combinations are stated without the need to declare a new type first. The class D automatically \nconstitutes such a new type of its own. Another class, E, also extending Applet and im- plementing the \nsame interfaces as D, establishes a new type too, but a different one. Java uses name equivalence of \ntypes, that is, two types are compatible only if declared so. With classes D and E be- ing declared as \nseparate types, instances of one cannot be assigned to variables of the other s type. Figure 2 summarizes \nthe discussed aspects of Java s type system. l code inheritance via single subclassing l multiple subtyping \nvia interfaces (without code inheritance) l conflict resolution (partially) via overloading l only types \ndeclared to be compatible are compatible (name equivalence) Figure 2: Relevant aspects of Java s type \nsystem This may not be decidable. in which case an error is flagged, as defined by Java s rules about \noverloading. 2.2 Component software One purpose of using object-oriented technology is to create build- \ning blocks to be used in several systems. To support such building blocks, Java features, for instance, \nseparate compilation of classes and bundling of related classes as packages. Component software tries \nto move the idea of building blocks to an industrial scale. Like in other engineering disciplines, soft-ware \nsystems shall be assembled from premanufactured compo-nents rather than crafted individually by hand. \nThis is an old idea, dating back to the NATO conference on software engineering in 1968 [22]. In 1990 \nBrad Cox even advocated an industrial revolu-tion in the software realm [lo], observing that software \ncomponents are not just a technological issue but a cultural one as well. In par- ticular, as also stressed \nin a recent book by Clemens Szyperski 1351, the true potential of component software comes from establishing \ncomponent markets. If system assemblers can acquire individual components from several vendors, they \ncan actually combine the many special skills, ideas, and inventions each vendor has to offer. The number \nof possibly interesting combinations grows rapidly as vendors can join an open market to offer components \nin the field of their special competence. An example, frequently used to illustrate this, are spell-checking \ncomponents that can be composed with a text editor to provide for in-place checking and correction. For \ninstance, a ven- dor with special competence in linguistics and a specific language, Finnish, offers \nan add-on spell checker [ 181 to be used with Mi-crosoft Word. Offering a component rather than a complete \nword processor allows the company to concentrate on what their staff is good at. Also, the market for \nFinnish language checkers is proba- bly not extremely large and may not give enough revenue to finance \nthe construction of a competitive editor. Furthermore, Microsoft s editor serves as an integration plat-form \nwith other add-ons offered by further vendors. For instance, a user requiring not only well performed \nchecking of Finnish but also needing to include some special type of diagrams into documents, may not \nfind an of-the-shelf program with this particular feature combination. Custom programming of such a system \nwould be too expensive in most cases, but a custom assembly from standard com- ponents may be achievable \nat a reasonable price. Because of this, component software is also described as a path between standard \nand custom software [29]. Using industrial components as described above has two re-quirements. Firstly, \nusing a premanufactured component must be easy enough, compared to programming it from scratch, to balance \nthe cost of acquiring it. Otherwise, component reuse is simply not going to happen because system development \ncosts would increase instead of decrease. The most inexpensive way to compose components is by plug- \nand-play. This means that neither the components need to be adapted nor any programming is required to \nglue the components together. The problem may not even be the programming itself, but the required reengineering \nand detailed understanding of the components or at least their interfaces. Plug-and-play in turn may \nsometimes be left to the end user. Netscape s Communicator Plug-Ins [7] are an example of this. As a \nsecond requirement, vendors must be able to produce com- patible components despite being mutually unaware. \nConsidering a large component market, it is impossible to demand any vendor to know about all other products \nand to adapt to them. It seems, as if the latter requirement of independent component development would \ncontradict the former requirement of plug-and- play, but fortunately this is not the case. Component \nvendors cannot be expected to synchronize their work with each other, but they can build on common standards. \nIf the latter are properly designed, First Phase : standardized contracts define common reference for \ncomponent vendors manufacture components Third Phase : assemblers select and plug components System Assembler \nFigure 3: The three phases of component-oriented programming the independently produced components will \nstill interoperate in a plug-and-play manner. It is not sufficient, however, to use a common wiring (or \nplumb- ing) standard, such as COM, CORBA, or a specific programming language, such as Java. These standards \nonly define the calling conventions for procedures or methods respectively. In addition, component plug-and-play \nrequires application domain dependent standard contracts, specified both syntactically and semantically. \nThe three phases of creating component systems are shown in Fig. 3, omitting feedback loops, which drive \nthe evolution of stan- dards and components. During the first phase, different standard in- terfaces \nare designed and described in public. In the second phase, vendors program towards these standards and \nplace the resulting components on the market. In the third phase, finally, system as- semblers select \nand acquire components from the market and plug them together. Note, that assemblers do not need to analyze \nwhat a standard interface actually specifies. It suffices to know that two components refer to a common \nstandard. In Java, types are used to support standard contracts. By types we understand both classes \nand interfaces. Like a plug-and-play system assembler, the loader can check that two components refer \nto the same type(s) and are thus compatible. A type s name des- ignates the standard. The full behavioral \nspecification associated with it must be stated outside the language in the documentation for component \nmanufacturers.  2.3 A scenario exemplifying a problem with Java The following example describes a situation \nthat cannot be prop- erly handled by Java s type system. We assume two different and independent standards, \nwhich have come into existence entirely un-related. One of them defines an interface Text, describing \noper-ations, such as insertion and deletion of characters. We also as- sume a transformation function \nwhich converts text positions to pixel positions. The second standard defines a compound docu- ment framework, \nlike OLE [6], including an interface Container to be implemented by all objects that may act as compound \ndocu- ment containers. The latter must support insertion and removal of document parts. Figure 4 shows \nportions of these two interfaces in Java. / as oari of a text framework: / public interface Text { void \ninsert (char ch, int textPos); / insert character ch at position textPos / java.awt.Point displayPoint \n(int textPos); / returns the display position at which the character at textPos is drawn */ /+ as part \nof a compound document framework: / public interface Container { void insertpart (DocPart part, java.awt.Point \nxyPos); Figure 4: The standard interfaces Text and Container Both standards form individually useful \nframeworks. Vendors can build components for either of them. The problem comes with the wish to create \ncomponents that build on both standards simulta- neously. In our example, this would be components that \ndeal with both texts and containers. In object-oriented programming, combining independently emerged \nframeworks has been described as an open problem [21]. This is not a problem with component software, \nwhere components just implement standard interfaces but do not reuse code from the framework. A component \ncan implement several interfaces belong- ing to different standard collections. (A common plumbing stan-dard, \nfor instance Java, is still helpful but not strictly necessary.) p Vendor public A s component: 1 class \nTextContainerA implements Text, Container {. .}; / Vendor public B s component: 1 class ContainerTextB \nimplements Text, Container {. .}; Figure 5: Classes offered by vendors A and B Figure 5 shows portions \nof two sample classes, TextContain- erA of Vendor A and ContainerTextB of vendor B, both imple- menting \nthe interfaces Text and Container of our sample standards. These classes exhibit a little nuisance. To \ninsert a document part one has to pass the graphical coordinates because the container in- terface must \nbe used. One may prefer to give a text position and have the part inserted after the corresponding character. \nFor this purpose, a generic service can be implemented that maps the text position to a display position \nand then inserts the document part there. We assume that a Vendor C wants to offer this service within \na class LibraryServices. Figure 6 shows part of this class and Fig. 7 illustrates that whole scenario. \npublic class LibraryServices { public static vold insertDocPart (DocPart part, ? into, int textPos) { \n/ the question mark stands for a type saying that interfaces Text and Container must be implemented \n/ into.insertPart(part, into.displayPoint(textPos)); 1 1; Figure 6: Vendor C s library services Standard \nInterface Text Standard Interface Container bination of three interfaces, the three pair interfaces have \nto be cre- (part of a text framework) (part of a compound atcd and the combined interface has to be defined \nas the extension document framework) of all three pair interfaces as to make its implementations compat- \nVendor X creates a container. which is Vendors A and 6 create texts Vendor C creates a service working \nwhich are also containers with objects implementing interfaces Containers and Texts Assembler wants Figure \n7: Independent development of classes and insertion service ible with the pair interfaces as well. The \noverhead of this solu- tion and, herewith, the pollution of the name space grows exponen- tially with \nthe number of combined interfaces. Furthermore, legacy classes that do not abide by this convention are \nleft out. Finally, this approach fails completely, if we try to combine three or more types one of which \nis a class. Assume that we have a class C and interfaces I and J. According to the above convention, \nthis would give us the abstract classes Cl and CJ as well as the combined interface IJ. For classes implementing \nall three types C, I, and J to be compatible with the three pair types Cl, CJ, and IJ, the triple type \nwould have to extend all three pair types. This, however, is impossible because Java does not support \nmultiple class inheri- tance. We can define a class D which extends CJ and implements IJ, but instances \nof D -or D s subclasses- cannot be assigned to variables of type Cl (Fig. 8). Java does not permit us \nto declare a class to be compatible with all subsets of its supcrtypcs. This is an additional problem, \nnot bound to component software. As a different approach, we can resort to run-time tests and textual \nannotations. We declare parameter into of InsertDocPart (Fig. 6) to be of type Text, add a comment that \nit must also im- plement Container, and cast the parameter s value to Container when accessing the latter \ns members. In this approach, we loose static type checking. Yet another possibility would be to use two \nparameters, one of type Text and one of type Container and require them to refer- cnce the same object. \nAgain, we need a less desirable run-time test instead of compile-time type checking. 3 Structure vs. \nName Equivalence of Types Vendor C s library service works only for instances of classes that implement \nboth interfaces Text and Container. Unfortunately, this cannot be expressed by the type of parameter \ninto, as the ques- tion mark in Fig. 6 indicates. The obvious solution is to create a combined interface \nTextContainer, which extends both Text and Container and does not add or hide anything, and to declare \nparameter into of this type. However, instances of neither TextContainerA nor Contain- erTextB are compatible \nwith the library service, as they arc both declared to implement only the base interfaces but not the \ncom- bined interface TextContainer. The problem is who is to define the interface TextContainer to be \nused by all parties? It is not part of either of the two frameworks because they are assumed to be in- \ndependent. If one of the vendors A, B, or C defines TextContainer, the others would be obliged to use \nthis definition. This contradicts mutual unawareness postulated for component software vendors. On the \nother hand, if all three vendors declare their own combined interfaces, they are not compatible either. \nThe problem can be partly tackled by conventions. A class never implements more than one interface directly; \nan interface never extends any of its superinterfaces by more than one base in- terface. Instead, combined \ninterfaces named as concatenation of the fully qualified names of the two direct superinterfaces in al- \nphabetical order are introduced into a package Combinedlnter- faces. In our example, all three vendors \nwould create and use inter- face com..X-Text-corn-Y-Container, assuming that Text is part of standard \nX and Container of Y. The system assembler then deletes all but one of the equivalent definitions. Unfortunately, \nthis renders plug-and-play less feasible. Furthermore, the conventions-based approach suffers from the \ncombinatorial explosion of the number of interfaces. For the com- The problem described above can be \nattributed to Java s use of name equivalence of types. Types are compatible only if explicitly declared \nso. A radical cure would be to use structure equivalence instead, as for instance proposed in [16]. All \ntypes that look alike would be considered compatible in this case. From the modeling perspective of object-oriented \nprogramming, however, name equiv- alence is more expressive. In this section we review the advantages \nof both structural and name equivalence, before we introduce com- pound types as a beneficial combination \nof these two in the next section. class C interface I interface J ! \\/, /\\ class Cl i class CJ h interface \n114 IJ impossible: inheritance not sin@) anymore! \\ \\ . I class D Figure 8: Impossibility of compatibility \nwith all subsets of super- tY Pes compiler checked class X implements Text bool parse (Text t) intended \ny Standard Specification Figure 9: Compiler checked reference to same standard specifica- tion 3.1 Structure \nequivalence of types With structure equivalence, any two types containing methods and fields with the \nsame names and signatures are equivalent. Like-wise, subtyping is based on structure. A type T is assumed \nto be a subtype of another type S if T contains at least all the methods and fields contained in S. This \nis the principle; there are more elabo- rated rules, for instance, allowing for co- or contravariant \nparame-ters. The goal is an as big as possible type matching relation and, therefore, a maximum of flexibility. \nQpes and the relations be- tween them may even be inferred automatically by the compiler and thus need \nnot be declared explicitly by the programmer. If Java would use structure equivalence between types, \nthe problems described in the previous section would not exist. Ven-dor C could define a combined interface \nTextContainer, extending Text and Container and use this to type the parameter into. As both implementations \nTextContainerA and ContainerTextB con-tain (at least) all methods named in TextContainer, they would \nbe structural subtypes of TextContainer and, thus, compatible with the library service. The fundamental \npurpose of a type system is to prevent the occurrence of run-time errors [4]. On a quasi syntactical \nlevel structural type equivalence suffices. Types prevent, for instance, method not understood and memory \naccess violation errors that could occur if, for example, an integer could be assigned to a pointer. \n 3.2 Name equivalence of types When using objects as a modeling aid, we would like to eliminate errors \nbeyond those covered by structural type equivalence. When- ever an object of a specific type is required, \nsay as a parameter, we actually intend to require a specifically behaving object. Behav-ioral subtyping \n[19] and class refinement [24] formalize this idea of behavior associated to types and of subtypes having \nto refine the behavior of their supertype( From this point of view, types stand for semantical specifica- \ntions. While the conformance of an implementation to a behavioral specification cannot be easily checked \nby current compilers, type conformance is checkable. By simply comparing names, compilers can check that \nseveral parties refer to the same standard specifica- tion (Fig. 9). Similarly, Microsoft s COM [32] \nuses interface identifiers (IIDs) to give each interface its own name. IIDs become, like numbers of IS0 \nstandards, abstractions of specifications. Consider also the analogy to the well-established component \nmarket for mass storage with its interface standards such as SCSI, IDE, etc. The buyer of a new hard \ndrive simply ensures that she buys a SCSI drive, if that is what it says on her disk controller. For \nher, the term SCSI represents a common reference made by the manufacturers of the controller and the \ndrive. The buyer would not be served well, if she would simply shop for a hard disk with matching mechanical \nconnectors, as a drive that adheres to another, incompatible logical signaling standard might also fit \nthis criterion. In the same way, even if the projections of two unrelated se-mantical specifications \nby coincidence result in the same structure, the two should not be considered equal. As an extreme example \nof such accidental matches, borrowed from [20], consider two classes: Rectangle with operations Move \nand Draw and a class Cowboy with operations Move, Draw, and Shoot. Looking only at the structure, Cowboy \nis a subtype of Rectangle. This can be ruled out only by forcing programmers to be ex- plicit about their \nintentions. In other words, type equivalence and subtype relations must be declared rather than be inferred. \nTo this purpose, several languages use name equivalence. They consider two types compatible only if the \ndeclaration of either type explicitly refers to the name of the other. Java is one example. Modula-3 \n[5] uses structural type equivalence by default, but al- lows the programmer to explicitly demand name \nequivalence by assigning a unique brand to a type. 4 Compound Types Both structural and name equivalence \noffer benefits as discussed above. Structure equivalence gives more flexibility when compos- ing software, \nname equivalence allows programmers to better ex- press their intentions. To combine these advantages, \nwe introduce a light-weight construction to explore the middle ground between exclusive use of structure \nor name equivalence: compound types. To begin with, let us analyze the respective advantages of name \nand structure equivalence in the context of our initial example of TextContainers introduced in Sect. \n2.3. Name equivalence allows us to explicitly state that objects compatible with interface Text are supposed \nto adhere to the respective specification, in our example partially provided in the form of comments. \nA similar statement holds with respect to interface Container. Structure equivalence, on the other hand, \nwould allow us to type the service defined in Fig. 6 more reasonably. The behavioral specification of \nthat service refers to the two specifications associated with the types Text and Container, not just \nto the union of the methods and fields defined by these types. In the service s implementation, this \nshows whenever the parameter into is used as if being of the (behavioral) type Text or Container. We \ncall a type that combines the behavioral specifications of several other types the compound type of these. \nIn the follow- ing, we denote a compound type as a list of its constituent types in square brackets. \nIn our example, the service s parameter into would be typed as [Text, Container]. Neither in a language \nbased only on structure equivalence nor in one using only name equivalence such a type can be expressed. \nWith structure equivalence more types than wanted would be com- patible because of possible accidental, \npurely syntactical matches. With name equivalence, different types declared with the same con- stituent \ntypes remain incompatible. Fig. 10 visualizes the different sets defined when using name equivalence, \nstructure equivalence, and compound types. structural equivalence: all types containing the same methods \nas implement Text and TextContainer Figure 10: Type compatibility with name equivalence, structure equivalence, \nand compound types Compound types, composed from the same behavioral types can be treated as equal even \nwith respect to behavioral specifi-cation. Any type subtyping both Text and Container, such as TextContainerA, \nmust respect both semantical specifications at the same time. Consequently, it can be safely cast to \neither of its con- stituent types and therefore it is compatible with the corresponding compound type \n[Text, Container]. We conclude that type equivalence of compound types can and should be defined based \non the structure of the composition. We thus speak of structure equivalence of compositions of name equiv- \nalent types. Compound types combine the best of two worlds. Using compound types, we can solve our typing \nproblem of the parameter into from Fig. 6. We give it the type [Text, Container]. Since both classes \nTextContainerA and ContainerTextB imple-ment the two constituent interfaces Text and Container, instances \nof them can be passed as actual parameters to the library service. Variable into having all members of \nits constituent interfaces, the required method calls can be made without any additional casts or run-time \nvalidity tests. Thanks to the combination of structural and name equivalence, instances of other classes \nthat just happen to declare methods with the same names and signatures as Text and Container, rather \nthan implement the two interfaces, are rightfully rejected at compile time as values for parameter into. \nFigure 11 illustrates the subtype relationships, omitting transitive arrows. Compound types also solve \nthe other typing problem pointed out in Sect. 2.3 and illustrated in Fig. 8. Java s type system does \nnot allow a programmer to declare a class that is assignment compat- ible with all subsets of extended, \nrespectively implemented types, if the class implements more than one interface and does not have Text \nContainer\\-11 s;- TextContainer \\ ~. _-7 \\~ / J/ Dotted relationships \\ do not hold! TextContainerA ContainerTextB \nFigure 11: Subtype relationship (transitive arrows omitted) Object as its direct superclass. Consider \nnow the case with com-pound types. Let class G extend class C and implement interfaces l and J. Instances \nof G can be assigned to variables of types C, I, J, [C, 11, [C, Jl, [I, Jl, and [C, I, Jl. Compound types \nhave underpinning in the theory of intersec- tion types ([9,33], see [30] for a recent overview). The \nintersection of two types S and T is the type of all elements belonging to both S and T. The new idea \nis to use defined types, which represent be- havioral specifications, rather than the members of these \ntypes as atoms. To mark this specific choice of atoms and to emphasize the in- tuition of combining specifications, \nrather than that of intersecting sets of possible values, we have decided to use the new name com- pound \ntype. 5 Compound Types in Java In this section we discuss a number of details showing how com- pound \ntypes are integrated into Java. We investigate the conditions for well-formedness and a number of interesting \nproperties. We define compound types in Java as anonymous reference types. A compound type is a direct \nextension of a set of inter- faces and a non-final class, collectively referred to as constituent types. \nThe members (methods, fields) of a compound type are the members of its constituent types with their \nrespective accessibility. The compound type does not add any additional members, redefine any members, \nor hide any constants. If no constituent class type is explicitly given, Object is implicitly assumed \nacknowledging that any reference type can be converted to Object by assignment con- version. Compound \ntypes can be used as parameter types, variable types, return types of methods, cast operators, and operands \nof the instanceof operator. They are not permitted in the extends or implements clauses of interface \nand class declarations. A variable, the declared type of which is a compound type, may have as its value \na reference to an instance of a class declared to ex- tend the constituent class and implement the constituent \ninterfaces, or the value of the variable may be null. In other words, the le- gal values of a variable, \nthe declared type of which is a compound types, are those that could also be assigned to variables of \nall con- stituent types of the variable s type. Compound types are written as comma separated lists delim- \nited by square brackets. The order of constituent types is not rel- evant, e.g., [Text, Container] and \n[Container, Text] denote the same type. As a guiding principle, a compound type [C, II, 12, ., In] is \nwell-formed, if the abstract class definition abstract class D extends C implements II, 12, ., In {}, \nwhere D is a fresh name, would be acceptable in the same package. Thus, no two constituent types may \ndefine a method with the same name and signature but different return types. If the statistically rare \nand, therefore, comparatively minor problem of method clashes were solved in the Java base language, \ne.g., by qualified names, it would also automatically disappear for compound types. Including more than \none class type is pointless, as no compat- ible objects could ever be created in Java s single class \ninheritance system, unless the classes are in a subclass relationship. For sim- plicity and consistency, \nwe do not allow more than one class to be included. On the other hand, coherence with Java s design principles \ndic-tates that both an interface and one of its superinterfaces may be included. Assume that TrivText \nis a superinterface of Text. Then, instances of TextContainerA and ContainerTextB can also be as- signed \nto variables of type [Text, Container, TrivText] as their classes indirectly also implement TrivText. \nHowever, [Text, Con- tainer] and [Text, Container, TrivText] do-due to an in our opin- ion unfortunate \nfeature of Java - not denote the same type. In Java interfaces may shadow constants defined in their \nsuperinterfaces. Let TrivText define a constant int k = 21 and Text shadow it by defining boolean k = \ntrue. Then a.k denotes the boolean expres- sion true for a of type [Text, Container], but is ambiguous \nfor a of type [Text, Container, TrivText]. In the latter case, a qualification such as Text.a.k would \nbe required. Including an interface that is already implemented by the constituent class is analogous. \nAs in a class declaration, the same interface may not be included more than once in a compound type. \n We have introduced compound types as anonymous types only. They could, however, also be given names \nfor documentation pur- poses. Of course, partially structure equivalence as described above would also \napply to the named variant. A named compound type would only be visible where all its constituting interfaces \nare visi- ble. The changes we propose to Java s language specification [ 121 can be found in [3, Appendix]. \nEmulating Compound Types on the Virtual Machine Our proposed extension requires modifications of the \nJava com- piler, but programs with compound types can be executed on an unchanged virtual machine [ 171. \nThe latter is significant because many of the security and portability properties of Java are tied to \nthe virtual machine, as remarked by Agesen et al. [I]. There are -at least-two ways of emulating compound \ntypes. Both of them are hinted at in Sect. 2.3. One idea is to use one of the constituent types in place \nof the compound type and to employ ex-plicit casts to access members of the other constituent types. \nMost of these casts require run-type validity checks. However, if the byte-code has been generated by \na correct compiler all these casts will always succeed at run time, as they have already at compile time \nbeen proven correct. These superfluous run-time tests are also needed when using current Java as only \none of the constituent types can be asserted statically. Removing unnecessary tests automatically requires \na flow analysis of the complete system. Already expensive for closed systems, this is entirely impossible \nfor extensible systems that by definition are never complete. Thus, the use of compound types on an existing \nvirtual machine without any adaptation does not incur any performance penalty over a solution in current \nJava. Rather, if the virtual machine would be adapted to support compound types, a performance increase \nover the state-of-the-art would result. The other way is to use multiple variables, one for each con- \nstituent type. These variables all contain the same value but have different types. The compiler takes \ncare that the variables are changed in lockstep; a run-time check that all refer to the same object is \nnot necessary. This solution also comes with some over- head in space and time compared to an adapted \nvirtual machine, but it is as efficient as a solution in current Java. The result of the instanceof expression \nE instanceof [C, Ll , L2, ., Ln] is true if the value of E is not null and the reference could be cast \nto [C, Ll, L2, ., Ln] without raising a ClassCas- tException. Let o be a fresh variable of type Object. \nThen E instanceof [C, Ll, L2, .., Ln] E (o=E) instanceof C &#38;&#38; o instanceof Ll &#38;&#38; &#38;&#38; \n0 instanceof Ln In spite of the emulation option on the existing virtual machine, compound types cannot \nbe mapped to plain Java without loosing static safety on the language level. 7 Type Soundness In this \nsection, we report on a mechanically verified formal proof of type soundness of Java with compound types. \nType soundness intuitively means that all values produced during any program ex- ecution respect their \nstatic types. An immediate corollary of type soundness is that method calls always execute a suitable \nmethod, that is, there are no method not understood errors at run time. Type soundness is not a trivial \nproperty, especially for polymor- phic languages [2,4]. It came to prominence with the discovery of the \nfailure of its application to older versions of Eiffel [8, 231. Our proof of type soundness for compound \ntypes is based on the work of von Oheimb and Nipkow [36], a much extended version of [26], in which they \nhave formalized and proved type soundness of a large subset of Java. They verified the proof mechanically \nwith the theorem prover Isabelle/HOL [27]. To this formalization, we added compound types as reference \ntypes, appended the widening and casting relations with compound types, and defined the members of the \nlatter. Finally, we adapted the proofs and ran them through Isabelle/HOL. The definition of compound \ntypes adds 13 1 lines to the existing 137 1 lines, approxi- mately 10 %. Here, we present the extensions \nto the widening and casting relations, which are interesting in their own rights. A full report of all \nthe mechanical details is beyond the scope of this paper. The Java language specification introduces \nidentity and irreffex- ive widening conversions separately. Since in all conversion con-texts permitting \nwidening identity conversions are possible as well, the two are merged in the formalization. The expression \nr t- S 5 T says that in program environment I- objects of type S can be trans- formed to type T by identity \nor widening conversion. In particular, expressions of type Scan be assigned to variables of type T and \nex- pressions of type S can be passed for formal parameters of type T. Widening can be understood as \na syntactic, declared form of sub- typing.4 Unlike subtyping in most type theoretic frameworks, the Java \nlanguage specification does not say that widening is transitive. Hence, transitivity is a proved property \nrather than an axiom. We use the following naming conventions: C, D classes M, L sets of interfaces I,J \ninterfaces S, T arbitrary types R reference type I-program, environment Likewise, r I-C+cD expresses \nthat C is a subclass of D, r k C Q I that class C implements interface I, and r F I+iJ that I is a subinterface \nof J. Furthermore, is-type I- T expresses that T is a legal type in r, RefT R denotes reference type \nR, and NT stands for the null type. With this, we can express the following two typing judgments, which \nare also applicable to compound types: is-type r T is-type I- (RefT R) I-kT5T rFNTdRefTR Further Class \nC stands for the class type C, lface I for the in- terface type I, and T[ .] for an array type with elements \nof type T. Compound (C,L) denotes the compound type with class C and interfaces L; E L. The discriminators \nis-class I- C, is-iface r 1, 3At http://www.abo.fi~mbuechi/publications/CompoundTypes.html the Isabelle \ntheories are available. 4For simplicity, the term subtyping is used in the other sections of this paper \nin place of the formally correct notion of widening . Tl--S<T S widens to ( is subtype of ) T in I- I-t \nC-+D C is a subclass of D in I- l-l-C-1 C implements I in r r t- I<iJ I is a subinterface of J in r r \nb- S-+T cast from S to T permissible at compile time in r no-conflict I-(I,D,M) in I- interface I, class \nD, and constituent interfaces of M do not define a method with the same name and the same signature but \ndifferent return types Figure 12: Summary of notation  and is-compound r (C,L) are also used. The latter \nis true, if the compound type is well formed, that is, all constituent types are ac- cessible, C is not \nfinal, and there is no method name p such that two constituent types define a method named p with identical \nsignature but different return types. We assume that is..ciass r Object and is-iface I- Cloneable holds \nfor all I-. In Java, Cloneable is the only interface implemented by arrays. With this we can define the \nremaining widening rules involving compound types: r t Class C 3 Class D; is-compound r (D,M); VJ E M.T \nk C-+ J r k Class C 5 Compound (0, M) is-iface r I; is-compound r (Object, M); VJ E M.T t- I+iJVI = \nJ r t- lface I 5 Compound (Object, M) is-type r T r I- T[ .] 5 Compound (Object, {}) is-type r T r I- \nT[ .] 5 Compound (Object, {Cloneable)) r k Class C 5 Class D; is-compound r (C,L) r t- Compound (C,L) \n5 Class D isxompoundr(C,L); r~C-v,JV(31EL.Tt-I~iJVI=J) l-t-Compound (C,L) 5 lface J r t Class C j Class \nD; is-compound r (C,L); is-compound r (D,M); VJ JMM.Tl-C-+JV((31~L.T~I-qJVI=J) I- I- Compound (C,L) 5 \nCompound (D,M) The casting relation I- t S+vT states, that a cast from type S to type T is permissible \nat compile time, that is, the type cast (T)e , where e is of type S, might succeed at run-time. If it \ncan be proven to always fail, the compiler can already flag an error. If r k S % T holds, the cast can \nbe proven to always suc-ceed. Other&#38;e, a run-time validity test must be performed to check whether \nr k R 3 T holds for the run-time type R of the cast operand. The following general casting conversions \nare applicable to compound types as well: rt-SST r t RefT Ss, RefT T rtS$T r t- (RefT S)[ .]$RefT T)[ \n.] In the rules below, no-conflict r (I,D, M) means that there is no method name p such that both I and \nD or one of the interfaces in M declare a method named p with the same signature but different return \ntypes.5 We use this abbreviation freely for different combi- nations of classes, interfaces, and sets \nof interfaces to indicate the absence of a method clash in place of the actual predicates, which are \nlengthy and technical. r t- D+c; is-compound r (D,M) rt Class C3?Compound (D,M) r I- Class C 5 Class \nD; is-compound r (D, M); +is-final I- C); no-conflict I- (C, M) r t- Class CdZompound (D, M) isiface \nr I; is-compound r (D,M); no-conflict r (I,D,M) r k lface I+ompound (D, M) r k D-+C; is-compound r (C,L); \n+is-final r D) v (V I E L.r t-D CC$I); no-conflict r (D,L) rk Compound (C,L)57Class D is-compound r \n(C,L); is-iface r J; no-conflict JY (C,L,J) r/-Compound (C,L)<?lfaceJ is-type r T r k Compound (Object, \n{})d?T[ .] is-type r T r k Compound (Object, {Cloneable})d?T[ .] r t-D-+$2; is-compound r (C,L); is-compound \nr (D, M); no-conflict r (C,L,D, M) r I- Compound (C,L)d?Compound (0, M) r I- Class C 5 Class D; is-compound \nr (C,L); iscompound I- (D,M); no-conflict r (C,L,D,M) r t Compound (C,L)<+ompound (D,M) Whereas the \nwidening rules can be considered as a particular instantiation of subtyping for intersection types, the \nrules for casts are believed to be new. The currently by von Oheimb and Nipkow formalized subset of Java, \non which we build, still does not capture all features. Of them final classes, modifiers, class variables, \nstatic methods, inter- face fields, and methods of the class Object would be relevant for compound types. \nThe main advantages of a mechanized over a paper-and-pencil proof are additional confidence and support \nfor extensions. We %I what is believed to be an omission from the specification [28], Java checks at \ncompile time only for clashes between methods contained in interfaces, but not for clashes between methods \ncontained in classes and interfaces. Opting for maximum static detection of errors, casts involving compound \ntypes are defined to check for all kinds of clashes. would like to stress the second aspect. Not only \ndid the formaliza- tion result in a soundness proof, but the proof tool also reminded us of what all \nneeded to be defined about compound types before the desired properties could be established. Most proof \nscripts worked without modifications. The fact that all theorems were reproved mechanically for the extended \nlanguage definition conveys more confidence than the typical adaptation of a paper-and-pencil proof with \nthis-should-still-hold handwaving. Related Work Our analysis leading to the observation that component \nsoftware demands a combination of named, behavioral types and structure equivalence for compositions \nof those, was inspired by Microsoft s binary standard COM. To our knowledge, however, it has never been \npresented on the programming language level so far. With-out this underpinning, some existing programming \nlanguages of- fer similar or related constructions. In this section we review in brief Microsoft s COM, \nthe languages Objective-C, Sather, and Modula-3, the theory of intersection types, and -as a quite dif- \nferent technology- binary component adaptation. Microsoft s COM: The principle idea of using structural \ntype equivalence with named types as atomic building blocks, each pre- senting a behavioral contract, \nis very much inspired by Microsoft s Component Object Model (COM) [32,6]. In COM, objects cannot be accessed \ndirectly but through interfaces only. These interfaces have globally unique identifiers (GUID) as names. \nIt is the inten- tion that with each interface also goes a behavioral specification, to be documented \nseparately. An object s type is defined as the set of the interfaces imple- mented by it. The COMEL language \n[ 141, built to formalize COM, consequently uses interface sets, similar to our compound types, to type \nobjects. This compositional definition of an object s behavior is heavily used, for instance, by the \nActiveX framework [6], which defines, for example, an ActiveX control container as any object implementing \na specific set of interfaces. Here the parallel ends, however. Clients of a COM object need to use a \nseparate reference variable to each interface through which they want to interact with the object, because \neach interface may be implemented by a separate node and thus have a different address in memory. This \nis acceptable as memory layout under the hood and may be hidden by a proper programming language. We \nexpect such a language to build heavily on compound-typed variables. To determine whether an object is \nof a given type, queries must be issued for each interface being part of that type. This may se- riously \nimpact a system s performance, in particular, if an object is situated remotely. Therefore, distributed \nCOM (DCOM) intro-duced a service to retrieve sets of interfaces. Alternatively, categories could be used. \nMembership of classes in a certain category can describe, beyond other, that a specific set of interfaces \nis supported. In this sense, categories can be compared to explicitly declared subtypes. Only if a class \nmakes an explicit reference, that is, registers as a category member, the information can be exploited. \nObjective-C: Objective-C [2.5], an object-oriented extension of C, first introduced the dual class and \ninterface hierarchies. Entities can be typed with a combination of a class type and one or more protocol \ntypes (Objective-C s name for interfaces), much like our compound types. Objective-C s type system is \nnot sound; for ex- ample, the validity of casts is not checked at run time. Introducing and verifying \ncompound types as part of a type-sound language, such as Java, still remained to be done. Modula-3: Modula-3 \n[5] is another language which combines name equivalence and structure equivalence of types. This combi- \nnation, however, is different than what we proposed. In Modula-3 structure equivalence is the default \nfor all types, unless declared as branded, which makes them clearly distinguishable. Also, Modula- 3 \nsupports only single subtyping and thus compound types cannot contribute anything. Sather: Sather [ 111, \nan object-oriented programming language featuring multiple subtyping and subclassing in separate hierar- \nchies, allows the programmer to introduce types as supertypes of already existing classes. That way it \noffers two symmetric possi- bilities to introduce a subtype relationship: it can be declared with either \nthe sub- or the supertype. Most other languages require a declaration with the subtype. The compatibility \nproblem described in Sect. 2.3 may be solved partially by that. Even if vendor C creates the library \nservice after vendor A creates his TextContainer component, C can still declare the type of the parameter \ninto (Fig. 6) in such a way that A s imple- mentation becomes a supertype. This requires, of course, \nthat C is aware of A s component. Sather allows subtype relationships to be introduced in the source \ncode by programmers of either type, but not by third par- ties, such a system assemblers, who only have \naccess to the binary components. In our above example, the library service is still not compatible with \nvendor B s component, as C was not aware of B s implementation and did thus not explicitly declare it \nto be a sub- type. Likewise, any components created after the library service, the manufacturers of which \nwere not aware of the combined type introduced by C, are incompatible with the library service (Fig. \n13). With the mutual unawareness postulate for a large component mar- ket, Sather s supertyping does, \ntherefore, not solve the problem at hand. Pure structure equivalence in Java: The use of pure structural \ntype equivalence between classes and interfaces in Java to increase compatibility has been suggested \nby Laufer et al. [ 161. In their sug- gestion, any instance of a class that provides an implementation \nfor each method in an interface can be used where a value of the inter- face type is expected. Thus, \nclasses declared to implement several interfaces directly, such as TextContainerA, are compatible with \ninterfaces, such as TextContainer, combined of the base interfaces implemented by the class. However, \nalso classes that by coinci- dence happen to contain methods with matching signatures but that are not \nmeant to adhere to the associated semantics are assignment compatible. As explained in Sect. 3.2, pure \nstructure equivalence ignores the modeling aspect of types resulting in too large a com- patibility relation. \nUsing only structure equivalence to decide compatibility be-tween classes and interfaces, as proposed \nby Lgufer et al., it is not possible to express that a parameter must also subclass a certain class in \naddition to implementing some interfaces. As a case in point, structural conformance between classes \nand interfaces does not solve the problem of compatibility with all subsets of super- types for the case \nof three or more types including a class other than Object (Fig. 8). Furthermore, the proposal requires \nchanges to the Java Virtual Machine, possibly introducing some security problems. In addi- tion, the \nexisting Java language is changed, rather than extended as by our compound types. Intersection types: \nAs pointed out in Sect. 3, intersection types with classes and interfaces as atoms are the theoretical \nfoundation for our approach. Intersection types were introduced into the h- calculus in the late 70 s \nby Coppo and Dezani-Ciancaglini [9] and independently by Salle [33]. The original motivation for introduc- \ning intersection types was the desire for a type-assignment system in which the typing of terms is invariant \nunder P-expansion and in which every term with a normal form has a meaningful typing. Text Container \nTextContainerA ContainerTextB TextContainerD ContainerTextE Figure 13: Scenario in Sather where supertyping \nsolves part of problem In the past twenty years, intersection types, infinite intersec-tions, and the \ndual notion of union types have been studied ex-tensively in type theory. Pierce and others have also \nstudied the combination of intersection types with bounded polymorphism and other object-oriented concepts \n(see [30] for a summary of his the- sis and an overview of recent work in the field). In contrast to \nour work, these studies all take the type rather than the modeling view. Thus, they use pure structure \nequivalence, not taking seman-tical soundness into account. Forsythe [31], a descendant of Algol 60, \nis the only program- ming language that explicitly uses intersection types and that we are aware of. \nForsythe is based on pure structure equivalence, rather than on a combination of name and structure equivalence \nas our approach. Objects exist in the form of function records only, not allowing for co-variant specialization \nof the self parameter. Binary component adaptation (BCA): BCA allows components to be adapted in binary \nform and during program loading 1151. BCA rewrites class files before or while they are loaded without \nrequiring source code access. Thus, modifications described by delta files can be applied by third-parties. \nAdding an interface to the implements clause, one of the supported modifications, could be used to solve \nthe compatibility problem described in Sect. 2.3: Vendor C, the creator of the library service, declares \na combined interface, which is used to type the parameter into (Fig. 6). Even if vendors A and B have \nnot declared their components to imple- ment this interface, a component integrator can add it to the \nlists of implemented interfaces using BCA. BCA adds further flexibility because it can be used to glue \nclasses that are not based on common standard interfaces. Unfor-tunately, it also burdens the person \nassembling the system with the task of figuring out how to do this correctly. That is, the system assemblers \nneed to understand the interfaces semantics and pro- gram the adaptation. Plug-and-play with made-to-fit \ncomponents, as enabled by compound types, is the more economical alternative wherever applicable. Furthermore, \nBCA makes systems harder to understand as delta files must also be taken into account. BCA does not solve \nthe problem of compatibility with all sub- sets of supertypes for the case of three or more types including \na class other than Object (Fig. 8), because BCA does not add any new kind of types or modify any conversion \nrules. 9 Conclusions We have exhibited a shortcoming of Java s current type system. In a programming \nlanguage for extensible component software, substi- tutability of typed objects should neither be decided \nby the types name nor just by the structural compatibility of signatures exclu- sively. Name equivalence, \nas offered by Java, is too restrictive when composing independently evolved standards or frameworks. \nStructure equivalence, on the other hand, does not support behav- ioral typing, that is, to associate \nsemantical specifications with type names. We concluded that one needs both. On the level of declared \ntypes, name equivalence is to be used. A behavioral contract can be associated with each type. When composing \nthese types, however, we want separately declared compositions to be compatible if they have the same \nstructure, that is if they consist of the same types. To this end, we propose compound types as structurally \nmatched compositions of named types, considered to match only if declared so. We showed how to add compound \ntypes as anonymous com-positions of named types to Java, an example of a practical, type- sound programming \nlanguage. To a variable of a compound type one can assign any object with the same structure in terms \nof im- plemented interfaces and extended classes. Java is well suited to host compound types. Building \non multi- ple inheritance of interfaces, we integrated our proposal smoothly. The resulting language \nis a strict extension and thus backward com-patible. Java programs with compound types can be executed \non an unchanged virtual machine. A mechanical soundness proof gives additional confidence in the well-definedness \nof the extended type system. The relative ease of adapting a formalization of the existing Java language \nfurther illustrates the orthogonality of our proposal. The changes we pro- pose to Java s language specification \n[12] can be found in [3, Ap- pendix]. We believe that compound types can contribute to any typed language \nwith multiple subtyping and name equivalence of types. Acknowledgments David von Oheimb and Tobias Nipkow \npro-vided us with their formalization of Java and helped us with our extensions. We would like to thank \nRalph Back, Dominik Gruntz, Cuno Pfister, and Clemens Szyperski for a number of fruitful dis-cussions. \nThe referees helpful comments are also gratefully ac-knowledged. References [II Ole Agesen, Stephen N. \nFreund, and John C. Mitchell. Adding type parameterization to the Java language. In Pro-ceedingsofOOPSLA \n97, pages 49-65. ACM Press, 1997. 121 Kim B. Bruce, Robert van Gent, and Angela Schuett. Poly-TOIL: A \ntype-safe polymorphic object-oriented language. In Proceedings of ECOOP 95, pages 27-51. LNCS 952, Springer \nVerlag, 1995. PI Martin Btichi and Wolfgang Week. Java needs compound types. Technical Report 182, Turku \nCentre for Computer Science, 1998. http://www.tucs.fi/publications/techreports/TR 182.html. M Luca Cardelli. \nType systems. In Handbook of Computer Science and Engineering, chapter 103. CRC Press, 1997. http:Nwww.luca.demon.co.uWPapers.html. \nLuca Cardelli, James Donahue, Lucille Classman, Mick Jor-danand Bill Kalsow, and Greg Nelson. Modula-3 \nreport (revised). Research Report 52, Systems Research Center, Digital Equipment Corporation, Palo Alto, \nNovember 1989. http:Nwww.research.digital.com/src/m3defn/html/. [61 David Chappell. Understanding ActiveX \nand OLE. Microsoft Press, 1996. [71 Netscape Communications. Netscape Plug-Ins, 1998. http://developer.netscape.com/docs/manuals/communicator/ \nplugin/index.htm. PI William Cook. A proposal for making Eiffel type-safe. In Proceedingsof ECOOP 89, \npages 57-70. Cambridge Uni-versity Press, 1989. [91 M. Coppo and M. Dezani-Ciancaglini. A new type assign- \nment for h-terms. Archiv. Math. Logik, 19:139-156, 1978. r101 Brad Cox. Planning the software industrial \nrevolution. Soft-ware Technologies of the 90 s special issue of IEEE Software magazine,November 1990. \nr111 B. Comes, D. Stoutamire, B. Weisssman, and H. Klawitter. Sather 1.1 : Language essentials, 1998. \nhttp://www.icsi.berkeley.edursather/Documentation/lan-guageDescription/contents.html. [121 James Gosling, \nBill Joy, and Guy Steele. The Java Language Specification. Addison Wesley, 1996. [I31 Object Management \nGroup. The common object request bro- ker: Architecture and specification, 1997. Revision 2.0, for- mal \ndocument 97-02-25, http://www.omg.org. [I41 Rosziati Ibrahim and Clemens Szyperski. The COMEL language. \nTechnical Report FIT-TR-97-06, Fac-ulty of Information Technology, Queensland Uni-versity of Technology, \nBrisbane, Australia, 1997. http://www.fit.qut.edu.au/TR/techreportslFIT-TR-97-06.ps.Z. u51 Ralph Keller \nand Urs Hiilzle. Binary component adaptation. In Proceedingsof ECOOP 98. LNCS, Springer Verlag, 1998. \nhttp://www.cs.ucsb.edu/oocsb/papers/ecoop98.html. [I61 Konstantin Laufer, Gerald Baumgartner, and Vincent \nF. Russo. Safe structural conformance for Java. Technical Re- port CSD-TR-96-077, Department of Computer \nScience, Pur- due University, 1996. 1171 Tim Lindholm and Frank Yellin. The Java Virtual Machine Specification. \nAddison Wesley, 1996. 1181 Lingsoft. Orthografix: Finnish proofing tools for Microsoft Word, 1998. http:Nwww.lingsoft.fi/. \nu91 Barbara H. Liskov and Jeanette M. Wing. A behavioral notion of subtyping. ACM Transactions on Programming \nLanguages and Systems, 16(6):1811-1841, November 1994. m Boris Magnusson. Code reuse considered harmful. \nJournal of Object-Oriented Programming, 4(3):8, November 1991. Pll Michael Mattsson and Jan Bosch. Framework \ncomposition: Problems, causes and solutions. In Proceedings of TOOLS USA 97,1997. [221 McIllroy. Mass-produced \nsoftware components. In Peter Naur, Brian Randell, and J. N. Buxton, editors, Software engi- neering: \nconcepts and techniques: proceedings of the NATO conferences. The Conference on Software Engineering \nheld in Garmisch, Germany, 7th to 11th October 1968. Petro-celli/Charter, 1976. [231 Bertrand Meyer. \nObject-Oriented Software Construction. Prentice Hall, second edition, 1997. 1241 Anna Mikhajlova and \nEmil Sekerinski. Class refinement and interface refinement in object-oriented programs. In Proceed-ings \nof FME 97: Industrial Applications and Strengthened Foundationsof Formal Methods, pages 82-l 01. LNCS \n13 13, Springer Verlag, 1997. WI NeXT Software, Inc. Object-Oriented Programming and the Objective-C \nLanguage. Addison-Wesley, 1993. http://developer.apple.comltechpubslrhapsodylObjectiveC/. 1261 Tobias \nNipkow and David von Oheimb. Javalight is type-safe -definitely. In Proc. 25th ACM Symp. Principles of \nPro- gramming Languages, pages 161-170. ACM Press, 1998. r271 Lawrence C. Paulson. Isabelle: A Generic \nTheorem Prover. LNCS 828, Springer Verlag, 1994. See also http://www.cl.cam.ac.uk/ResearcNHVG/isabelle.html. \nWI Roly Perera and Peter Bertelsen. The unofficial Java spec report, 1997. http:Nwww.nodule.demon.co.uk/java/java- \n1 .Ospec-bugs.htm. ~291 Cuno Pfister. Component software: A case study using Black- Box components (online \ntutorial of the BlackBox Component Builder), 1997. http://www.oberon.ch. 1301 Benjamin C. Pierce. Intersection \ntypes and bounded poly- morphism. Mathematical Structures in Computer Science, 7(2):129-193, April 1997. \n[311 John C. Reynolds. Design of the programming language Forsythe. In Algal-like Languages, volume 1, \npages 173- 234. Birkhauser, 1997. Also available as CMU-CS-96- 146, ftp://reports.adm.cs.cmu.edu/usr/anon/l996/CMU-CS-96-146.ps.gz. \n [32] Dale Rogerson. Inside COM. Microsoft Press, 1996. See also http://www.microsoft.com/coml. [33] \nP. Salle. Une extension de la theory des types en h-calcul. In Proceedings of Automata, Languages and \nProgramming, pages 398410. LNCS 61, Springer Verlag, 1978. [34] Sun Microsystems, Inc. Java Beans, 1997. \nhttp://splash.javasoft.com/beans/. [3.5] Clemens Szyperski. Component Software : Beyond Object- oriented \nProgramming. Addison-Wesley, 1998. [36] David von Oheimb and Tobias Nipkow. Machine-checking the Java \nspecification: Proving type-safety. In Jim Alves- Foss, editor, Formal Syntax and Semantics of Java. \nLNCS, Springer Verlag, 1998, to appear.  \n\t\t\t", "proc_id": "286936", "abstract": "Type compatibility can be defined based on name equivalence, that is, explicit declarations, or on structural matching. We argue that component software has demands for both. For types expressing individual contracts, name equivalence should be used so that references are made to external semantical specifications. For types that are composed of several such contracts, the structure of this composition should decide about compatibility.We introduce compound types as the mechanism to handle such compositions. To investigate the integrability into a strongly typed language, we add compound types to Java and report on a mechanical soundness proof of the resulting type system.Java users benefit from the higher expressiveness of the extended type system. We introduce compound types as a strict extension of Java, that is without invalidating existing programs. In addition, our proposal can be implemented on the existing Java Virtual Machine.", "authors": [{"name": "Martin B&#252;chi", "author_profile_id": "81341488555", "affiliation": "Turku Centre for Computer Science (TUCS), &#194;bo Akademi University, Lemminkt&#228;isenkatu 14A, FIN-20520 Turku", "person_id": "PP31071286", "email_address": "", "orcid_id": ""}, {"name": "Wolfgang Weck", "author_profile_id": "81100315352", "affiliation": "Turku Centre for Computer Science (TUCS), &#194;bo Akademi University, Lemminkt&#228;isenkatu 14A, FIN-20520 Turku", "person_id": "PP31098919", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/286936.286975", "year": "1998", "article_id": "286975", "conference": "OOPSLA", "title": "Compound types for Java", "url": "http://dl.acm.org/citation.cfm?id=286975"}