{"article_publication_date": "05-09-2003", "fulltext": "\n \u00b4  module TimerM { provides { interface StdControl; interface Timer; } uses interface Clock as \nClk; } ... Figure 2: Speci.cation and graphical depiction of the TimerM component. and dynamic dispatch. \nWe have, so far, implemented one opti\u00admization and one analysis: a simple whole-program inliner and a \ndata-race detector. Details are given in Section 4. nesC supports and re.ects TinyOS s design: nesC is \nbased on the concept of components, and directly supports TinyOS s event\u00adbased concurrency model. Additionally, \nnesC explicitly addresses the issue of concurrent access to shared data (Section 3.3). In prac\u00adtice, \nnesC resolved many ambiguities in the TinyOS concepts of components and concurrency, and TinyOS evolved \nto the nesC ver\u00adsions as it was reimplemented. 3.1 Component Speci.cation nesC applications are built \nby writing and assembling compo\u00adnents. A component provides and uses interfaces. These interfaces are \nthe only point of access to the component. An interface gen\u00aderally models some service (e.g., sending \na message) and is speci\u00ad.ed by an interface type. Figure 2 shows the TimerM component, part of the TinyOS \ntimer service, that provides the StdControl and Timerinterfaces and uses a Clockinterface (all shown \nin Fig\u00adure 3). TimerMprovides the logic that maps from a hardware clock (Clock) into TinyOS s timer abstraction \n(Timer). Interfaces in nesC are bidirectional: they contain commands and events, both of which are essentially \nfunctions. The providers or an interface implement the commands, while the users implements the events. \nFor instance, the Timer interface (Figure 3) de.nes start and stop commands and a fired event. In Figure \n2 pro\u00advided interfaces are shown above the TimerM component and used interfaces are below; downward-pointing \narrows depict commands and upward-pointing arrows depict events. Although this same in\u00adteraction between \nthe timer and its client could have been provided via two separate interfaces (one for start and stop, \nand one for fired), grouping these commands and events in the same interface makes the speci.cation much \nclearer and helps prevent bugs when wiring components together. Split-phase operations are cleanly modeled \nby placing the command request and event response in the same interface. Figure 3 shows two examples \nof this. The Send interface has the send command and sendDone event of the split\u00adphased packet send (Section \n2.1). The ADC interface is similarly used to model split-phase sensor value reads. The separation of \ninterface type de.nitions from their use in components promotes the de.nition of standard interfaces, \nmaking components more reusable and .exible. A component can provide and use the same interface type \n(e.g., when interposing a compo\u00adnent between a client and service), or provide the same interface multiple \ntimes. In these cases, the component must give each inter\u00adface instance a separate name using the as \nnotation shown for Clk in Figure 2. Components are also a clean way to abstract the boundary be\u00adtween \nhardware and software. For instance, on one sensor board, the temperature sensor (accessed via a component \nnamed Temp) is mostly in hardware; Temp is a thin layer of software accessing on-chip hardware registers. \nOn another it is accessed over an I2C interface StdControl { command result_t init(); } interface Timer \n{ command result_t start(char type, uint32_t interval); command result_t stop(); event result_t fired(); \n } interface Clock { command result_t setRate(char interval, char scale); event result_t fire(); } \n interface Send { command result_t send(TOS_Msg *msg, uint16_t length); event result_t sendDone(TOS_Msg \n*msg, result_t success); } interface ADC { command result_t getData(); event result_t dataReady(uint16_t \ndata); } Figure 3: Some interface types. module SurgeM { provides interface StdControl; uses interface \nADC; uses interface Timer; uses interface Send; } implementation { uint16_t sensorReading; command \nresult_t StdControl.init() { return call Timer.start(TIMER_REPEAT, 1000); } event result_t Timer.fired() \n{ call ADC.getData(); return SUCCESS; } event result_t ADC.dataReady(uint16_t data) { sensorReading \n= data; ... send message with data in it ... return SUCCESS; } ... }  Figure 4: Simpli.ed excerpt from \nSurgeM. bus; Temp is implemented as a number of interacting components including a generic I2C access \ncomponent. A subtle but important point is that bidirectional interfaces make it very easy to support \nhardware interrupts. In contrast, one-way interfaces based on pro\u00adcedure calls force hardware polling \nor having two separate inter\u00adfaces for hardware operations and the corresponding interrupts.  3.2 Component \nImplementation There are two types of components in nesC: modules and con.g\u00adurations. Modules provide \napplication code, implementing one or more interfaces. Con.gurations are used to wire other components \ntogether, connecting interfaces used by components to interfaces provided by others. Every nesC application \nis described by a top\u00adlevel con.guration that wires together the components used. The body of a module \nis written in C-like code, with straightfor\u00adward extensions. A command or event f in an interface i is \nnamed i.f. A command call is like a regular function call pre.xed with the keyword call, similarly an \nevent signal is like a function call pre.xed by signal. The de.nition of a commands or event  Figure \n6: The SurgeCcon.guration: A top-level con.guration. named i.f is pre.xed with command or event. We require \nthese annotations to improve code clarity. Figure 4 is a simpli.ed excerpt from SurgeM, which is part \nof the Surge application. It de.nes the StdControl.init command, called at boot-time, and two of the \nevents handled by Surge: the .ring of the timer (Timer.fired) and sensor data acquisition (ADC.dataReady). \nThe code calls the Timer.start command to setup periodic timer events and the ADC.getDatacommand to request \na new sensor sample. Modules have private state, in this example the sensorReading variable. TimerC, \nthe TinyOS timer service, is implemented as a con.gu\u00adration, shown in Figure 5. TimerC is built by wiring \nthe two sub\u00adcomponents given by the components declaration: TimerM (from Figure 2) and HWClock (access \nto the on-chip clock). It maps its StdControl and Timer interfaces to those of TimerM (StdCon\u00adtrol= TimerM.StdControl, \nTimer = TimerM.Timer) and con\u00adnects the hardware clock interface used by TimerM to that pro\u00advided by \nHWClock (TimerM.Clk -> HWClock.Clock). Figure 6 shows a more elaborate example: the toplevel con.guration \nfor the Surge application. An interface of a component may be wired zero, one or more times. As a result, \nan arbitrary number of command call expres\u00adsions may be wired to a single command implementation ( fan\u00adin \n), and a single command call expression may be connected to an arbitrary number of command implementations \n( fan-out ). For in\u00adstance, Figure 6 shows that calls to StdControl.initin Mainare connected to four \ndifferent implementations (in SurgeM, Photo, TimerC and Multihop). nesC allows a fan-out degree of zero \n(no wires) if the module implementer provides a default implemen\u00adtation for the unwired command. Fan-out \ndegrees greater than one are allowed as long as the return type of the command is associated with a function \nfor combining the results of all the calls. In the case of StdControl.init, the result type result t \n(Figure 3) repre\u00adsents success or failure. Its combining function implements the logical AND of the results, \nthus the result of the call to StdCon\u00adtrol.init in Main is success exactly if all four implementations \nsucceed. The analogous situations for event signal expressions is handled identically. The explicit wiring \nof components via interfaces, combined with the removal of function pointer types1, makes the control-.ow \nbe\u00adtween components explicit. Module variables are private and, as a design style in TinyOS, we discourage \nsharing of data among com\u00adponents. Taken together, this makes it much easier to write correct components \nand understand their behavior when wired in an appli\u00adcation. Most components in TinyOS represent services \n(such as the timer) or pieces of hardware (such as the LEDs) and therefore exist only in a single instance. \nHowever, it is sometimes useful to create several instances of a component. In nesC, this is achieved \nby declaring an abstract component with optional parameters; abstract compo\u00adnents are created at compile-time \nin con.gurations. For instance, the QueuedSend component used by the multi-hop communica\u00adtion layer Multihop(Figure \n1) is an abstract component that takes a maximum retransmit count parameter: abstract module QueuedSend(int \nmaxAttempts) { ... } configuration Multihop { provides interface Send; } implementation { components \nMultihopM, QueuedSend(10) as newQueue, ... ; Send = MultihopM.Send; MultihopM.QueuedSendMsg -> newQueue.Send; \n ... }  3.3 Concurrency and Atomicity Data races occur due to concurrent updates to shared state. \nIn or\u00adder to prevent them, a compiler must 1) understand the concurrency model, and 2) determine the \ntarget of every update. In this section we present the concurrency model and the key invariant that the \ncompiler must enforce to avoid data races. We achieve tractable target analysis by reducing the expressive \npower of the language and performing alias analysis. In particular, nesC has no dynamic memory allocation \nand no function pointers. In TinyOS, code runs either asynchronously in response to an interrupt, or \nin a synchronously scheduled task. To facilitate the detection of race conditions, we distinguish synchronous \nand asyn\u00adchronous code: Asynchronous Code (AC): code that is reachable from at least one interrupt handler. \nSynchronous Code (SC): code that is only reachable from tasks. The run-to-completion rule and sequential \nexecution of tasks lead immediately to a key invariant: Invariant: Synchronous Code is atomic with respect \nto other Synchronous Code. By atomic, we mean that any shared state between the two will be updated atomically. \nThis essentially provides atomicity by default for tasks. Code that includes split-phase operations, \nwhich by de.nition must include (at least) two tasks, is not atomic as a 1At this point our implementation \nissues a warning when function pointers are used. \u00b4\u00b4    \n\t\t\t", "proc_id": "781131", "abstract": "We present <i>nesC</i>, a programming language for networked embedded systems that represent a new design space for application developers. An example of a networked embedded system is a sensor network, which consists of (potentially) thousands of tiny, low-power \"motes,\" each of which execute concurrent, reactive programs that must operate with severe memory and power constraints.nesC's contribution is to support the special needs of this domain by exposing a programming model that incorporates event-driven execution, a flexible concurrency model, and component-oriented application design. Restrictions on the programming model allow the nesC compiler to perform whole-program analyses, including data-race detection (which improves reliability) and aggressive function inlining (which reduces resource consumption).nesC has been used to implement TinyOS, a small operating system for sensor networks, as well as several significant sensor applications. nesC and TinyOS have been adopted by a large number of sensor network research groups, and our experience and evaluation of the language shows that it is effective at supporting the complex, concurrent programming style demanded by this new class of deeply networked systems.", "authors": [{"name": "David Gay", "author_profile_id": "81100039538", "affiliation": "Intel Research, Berkeley, Berkeley, CA", "person_id": "PP39024398", "email_address": "", "orcid_id": ""}, {"name": "Philip Levis", "author_profile_id": "81340490533", "affiliation": "University of California, Berkeley, Berkeley, CA", "person_id": "PP94030330", "email_address": "", "orcid_id": ""}, {"name": "Robert von Behren", "author_profile_id": "81100279972", "affiliation": "University of California, Berkeley, Berkeley, CA", "person_id": "P517422", "email_address": "", "orcid_id": ""}, {"name": "Matt Welsh", "author_profile_id": "81336493667", "affiliation": "Intel Research, Berkeley, Berkeley, CA", "person_id": "PP43135855", "email_address": "", "orcid_id": ""}, {"name": "Eric Brewer", "author_profile_id": "81100357712", "affiliation": "University of California, Berkeley, Berkeley, CA", "person_id": "PP14128065", "email_address": "", "orcid_id": ""}, {"name": "David Culler", "author_profile_id": "81405593136", "affiliation": "University of California, Berkeley, Berkeley, CA and Intel Research, Berkeley, Berkeley, CA", "person_id": "PP94029413", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/781131.781133", "year": "2003", "article_id": "781133", "conference": "PLDI", "title": "The <i>nesC</i> language: A holistic approach to networked embedded systems", "url": "http://dl.acm.org/citation.cfm?id=781133"}