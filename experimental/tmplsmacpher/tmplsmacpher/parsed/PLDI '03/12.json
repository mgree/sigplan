{"article_publication_date": "05-09-2003", "fulltext": "\n CSSV: Towards a Realistic Tool for Statically Detecting All Buffer Over.ows in C Nurit Dor* Michael \nRodeh Mooly Sagiv Tel-Aviv University IBM Research Lab in Haifa Tel-Aviv University nurr@post.tau.ac.il \nrodeh@il.ibm.com msagiv@post.tau.ac.il ABSTRACT Erroneous string manipulations are a major source of \nsoft\u00adware defects in C programs yielding vulnerabilities which are exploited by software viruses. We \npresent CString Static Verifyer (CSSV), a tool that statically uncovers all string manipulation errors. \nBeing a conservative tool, it reports all such errors at the expense of sometimes generating false alarms. \nFortunately, only a small number of false alarms are reported, thereby proving that statically reducing \nsoftware vulnerability is achievable. CSSV handles large programs by analyzing each procedure separately. \nTo this end procedure contracts are allowed which are veri.ed by the tool. We implemented a CSSV prototype \nand used it to ver\u00adify the absence of errors in real code from EADS Airbus. When applied to another commonly \nused string intensive application, CSSV uncovered real bugs with very few false alarms. Categories and \nSubject Descriptors D.2.4 [Software Engineering]: Software/Program Veri\u00ad.cation Assertion checkers, Reliability, \nValidation; F.3.1 [Logics and Meanings of Programs]: Specifying and Verifying and Reasoning about Programs \nAssertions, Pre\u00adand post-conditions; F.3.2 [Logics and Meanings of Pro\u00adgrams]: Semantics of Programming \nLanguages Operational semantics, Program analysis General Terms Algorithms, Reliability, Experimentation, \nSecurity, Languages, Veri.cation  Keywords Error detection, abstract interpretation, static analysis, \nbu.er over.ow, contracts * Partially supported by a grant from the Ministry of Science, Israel and by \nthe RTD project IST-1999-20527 DAEDALUS of the european FP5 programme. Permission to make digital or \nhard copies of all or part of this work for personal or classroom use is granted without fee provided \nthat copies are not made or distributed for pro.t or commercial advantage and that copies bear this notice \nand the full citation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. PLDI 03, June 9 11, 2003, San Diego, California, \nUSA. Copyright 2003 ACM 1-58113-662-5/03/0006 ...$5.00. 1. INTRODUCTION String manipulation errors are \na common source of soft\u00adware defects and lead to many security vulnerabilities. CERT advisories report \non many security holes that result from bu.er over.ow, i.e., updates beyond the bounds of a bu.er [37]. \nFurthermore, 60% of the UNIX failures reported in the 1995 FUZZ study [28] are due to runtime string \nmanipulation er\u00adrors, such as bu.er over.ow, access beyond the bounds of a string and misuse of the null-termination \nbyte. Our goal is to perform static analysis that detects all string runtime errors with just a few false \nalarms.A false alarm is a reported error that can never occur at runtime. This goal is ambitious. Existing \nmethods either: (i)miss errors (e.g., LCLint [23], Eau Claire [4], and [37]); (ii) yield many false alarms \n(e.g., [23, 37]); or (iii) cannot handle com\u00adplex aspects of C, such as multi-level pointers and structures \n(e.g., [13, 35]). Moreover, the cost of static analysis is con\u00adsidered prohibitive when it comes to large \nprograms. This paper presents CString Static Verifyer (CSSV for short) a tool that demonstrates that \nuncovering all string problems in C is achievable. CSSV is capable of analyzing realistic procedures \nand produces rather precise results. Be\u00ading a conservative static-analysis tool it can never miss a runtime \nstring error. It therefore guarantees the absence of all errors at the expense of sometimes generating \nfalse alarms. For every procedure, CSSV allows the programmer to pro\u00advide a contract including (i)a precondition, \n(ii)a post\u00adcondition, and (iii)the potential side-e.ects of the proce\u00addure. Contracts may refer to normal \nC expressions (includ\u00ading pointers)and can also refer to properties, (such as the number of allocated \nbytes)that are de.ned by instrumented concrete semantics. 1.1 Analysis of String Errors: CSSV Fig. 1 \nshows how CSSV operates. Each procedure is an\u00adalyzed separately. In the .rst phase, a source-to-source \nsemantic-preserving transformation is applied to the ana\u00adlyzed procedure P. This transformation exposes \nthe behav\u00adior of the procedures invoked by P by essentially inlining their contracts. The generated program \nyields a runtime error when a contract is violated. In addition, the inliner normalizes the C code to \nonly include statements in a C subset called CoreC [38] which simpli.es the task of imple\u00admenting CSSV. \nIn the second phase, CSSV analyzes pointer interactions. Conducting pointer analysis in a language like \nC is a non\u00adtrivial task. Moreover, it is di.cult for programmers to de\u00ad  Figure 1: High-level structure \nof CSSV. .ne contracts in terms of pointer behavior. Fortunately, sev\u00aderal .ow-insensitive algorithms \nhave been shown to run on whole applications of considerable size, e.g., [8, 18]. There\u00adfore, CSSV does \nnot require contract information regard\u00ading pointers. Instead, CSSV applies a whole-program .ow\u00adinsensitive \npointer analysis to detect statically which point\u00aders may point-to the same base address. CSSV then applies \nan algorithm that extracts procedural points-to information for the analyzed procedure P. Our algorithm \nbene.ts from the fact that memory locations inaccessible from visible vari\u00adables of P cannot a.ect the \npostcondition of P.Inmany cases this allows subsequent analyses to perform strong up\u00addates [3] when analyzing \nthe procedure s body. We also compute certain must-aliases to improve the precision of the global .ow-insensitive \npointer analysis. In the third phase, the procedure code and points-to infor\u00admation are fed into the \nC2IP transformer. C2IP generates a procedure that manipulates integers. C2IP guarantees that if there \nis a runtime string manipulation error in a procedure invocation then either (i)the procedure s precondition \ndid not hold on this invocation, or (ii)an assert statement in the resultant integer program is violated \non a correspond\u00ading input. In addition, C2IP checks pointer assertions if speci.ed in the contracts. \nIn the fourth phase, the resultant integer program is ana\u00adlyzed using a conservative integer-analysis \nalgorithm to de\u00adtermine all potential violations of assert statements. Be\u00adcause the integer and pointer \nanalyses are sound and because contracts are veri.ed both at call sites and at the procedu\u00adral level, \nall string errors are reported. In particular, the integer analysis reports an error when the speci.ed \npost\u00adcondition is not guaranteed to hold. For minimizing the number of false alarms, CSSV uses a rather \nprecise integer analysis that represents linear relationships on integer vari\u00adables. The .nal result \nis a list of potential errors. For every error, a counter-example is generated that can assist the programmer \nin determining if a message is a real error or a false alarm. False alarms may occur due to (i)erroneous \nor overly weak contracts, (ii)abstractions conducted by C2IP, or (iii)imprecision of the pointer or integer \nanalyses. As opposed to alternative interprocedural program analy\u00adsis techniques, CSSV s approach has \nimportant advantages: (i)Each potentially recursive procedure can be analyzed sep\u00adarately, exactly once. \n(ii)The tool is applicable even if the source code is not available in its entirely. (ii)Contracts of\u00adfer \nuser control in a way similar to design by contract [30]. In particular, it enables CSSV to more e.ectively \nlocate the actual source location in which the error occurs. (iii)Con\u00adtracts can improve the precision \nof the analysis by providing information which can be hard to statically infer via an inter\u00adprocedural \nanalysis. (iv)By using the contracts to analyze procedure calls, CSSV applies a rather precise intraproce\u00addural \nalgorithm to reduce false alarms.  1.2 The Burden of Contracts Contracts exert additional burden on \nthe programmer. In the case of CSSV, this de.ciency is minimized because the pre-and post-conditions \nneed not describe the proce\u00addure s complete behavior. Moreover, unlike tools such as Eau Claire and LCLint, \nCSSV does not require annotations within the code itself such as loop invariants. Also, un\u00adlike these \nunsound approaches, since CSSV is sound, with any given contract, runtime errors cannot go undetected. \nDepending on the contracts, errors will be identi.ed when analyzing the body of the procedure or at the \nprocedure in\u00advocations. Clearly, when a procedure code is omitted as in the case of library functions, \nCSSV assumes its contract is correct and cannot verify it. Pointer information is automatically collected \nby CSSV, and therefore contracts usually omit information about how pointers are used. In addition, interprocedural \nmodi.ca\u00adtion side-e.ect analysis algorithms already exist (e.g., [34]). They can generate automatically \nthe modi.cation clause. Therefore, it is always possible to run CSSV with vacuous contracts including \nonly the side-e.ect information and a true pre-and post-condition. This paper presents preliminary algorithms \nfor automati\u00adcally strengthening the pre-and post-conditions. The e.ec\u00adtiveness of these algorithms is \nmeasured by comparing the number of false alarms obtained: (i)with the vacuous con\u00adtracts, (ii)when using \nautomatically derived contracts, and (iii)when using manually provided contracts. The derivation procedure \nuses a forward sound integer\u00adanalysis algorithm called ASPost to compute an Approxi\u00admation to the Strongest \nPostcondition of the integer pro\u00adgram. Similarly, a backward sound integer-analysis algo\u00adrithm called \nAWPre is used to compute an Approximation to the Weakest liberal Precondition [11]. The generated postcondition \n(precondition)is not necessarily the strongest (weakest)because information is lost during the static \nin\u00adteger analysis. Both ASPost and AWPre yield integer con\u00additions. Therefore, the process can be repeated \niteratively by running the derivation process given the generated in\u00adteger con and further restricting \nthe existing postcondition (precondition). We also present a conservative method that uses the pro\u00adcedural \npoints-to information to convert an integer expres\u00adsion for postcondition (precondition)into a C expression \nthat can be used to strengthen the initial contract. 1.3 Main Results The contributions of this paper \ncan be summarized in the following way: A conservative static-analysis algorithm for detecting string \nruntime errors is presented. The algorithm re\u00adduces the problem of checking string manipulation to that \nof checking integer manipulations a problem for which well-known solutions exist. In comparison to our \nprevious algorithm, presented in [13], it handles the full spectrum of C language constructs, including \ndynamically allocated structures, multi-level arrays, multi-level pointers, function pointers, and casting. \nIn addition, this algorithm is an order of magnitude bet\u00adter in its asymptotic time and space requirements. \n An algorithm that computes procedural pointer infor\u00admation from a given whole-program .ow-insensitive \npointer information is presented. The goal is to re\u00adduce the number of false alarms when analyzing well\u00adbehaved \nprograms. Speci.cally, the algorithm can in\u00adfer that a formal parameter points to a single loca\u00adtion \nthroughout the procedure and that a local vari\u00adable must be aliased to a formal parameter. Obtain\u00ading \nprocedural pointer information is a fundamental problem that clients of whole-program .ow-insensitive \npointer information face. The problem stems from the fact that a formal parameter may point to di.er\u00adent \nabstract locations. Thus, a naive implementation will perform weak updates which may lead to many false \nalarms. Hence, we believe that our algorithm can be used to improve the precision of other clients of \nwhole-program .ow-insensitive algorithms, such as slicing tools and program optimizers (e.g., [15, 25]). \n Preliminary program-analysis algorithms for strength\u00adening pre-and post-conditions are presented. The \nal\u00adgorithms reduce the burden on the programmer. They analyze the input procedure using existing (potentially \nvacuous)contracts and yield a new, more restrictive, contract for this procedure.  We have implemented \nCSSV using the AST-Tooklit [32], CoreC, the Golf pointer analysis [8, 9], and the poly\u00adhedra integer \nanalysis of [6] from [19]. We have ap\u00adplied the implementation to real-life programs. CSSV veri.ed an \nintricate string library from EADS Air\u00adbus yielding only 6 false alarms. In the application .xwrites,part \nof web2c, CSSV uncovered 8 errors with 2 false alarms. Finally, we implemented the derivation algorithms \nand applied them to automatically gener\u00adate pre-and post-conditions. The results show that in some cases \nthis brought about contracts equivalent to the manually speci.ed ones.  1.4 Outline of the Rest of \nthis Paper The rest of the paper is organized as follows: Section 2 introduces CoreC, a contract language, \na running exam\u00adple, and our instrumented concrete sem Section 3 describes CSSV. Section 4 describes the \ncontract derivation algorithms. Section 5 describes the prototype implementation and the experimental \nresults. Section 6 discusses related work.  2. BACKGROUND 2.1 CoreC CoreC is a subset of C with the \nfollowing restrictions: (i)Control-.ow statements are either if, goto , break,or continue; (ii)expressions \nare side-e.ect free and cannot be nested; (iii)all assignments are statements; (iv)declarations do not \nhave initializations; (v)address-of formal variables is not allowed. An algorithm for transforming C \nprograms to Attribute Intended Meaning exp.base Thebaseaddressof exp exp.o.set The o.set of exp, i.e., \nexp -exp.base exp.is nullt Is exp pointing to a null-terminated string? exp.strlen The length of the \nstring pointed-to by exp exp.alloc The number of bytes allocated from exp Table 1: Attributes in the \ncontract language. exp.base Figure 2: Graphical representation of the contract\u00adlanguage attributes. \nCoreC is presented in [38]. Given a C program, it generates an equivalent CoreC program by adding new \ntemporaries. CSSV is de.ned and implemented for CoreC. In the rest of this paper, CoreC is used instead \nof C. 2.2 Contracts Contracts are used to describe expected inputs, side-e.ects, and expected output \nof functions. In this paper, we write contracts in the style of Larch [24]. Our implementation ac\u00adtually \nsupports a more general executable language similar to [29], which can include loops. Contracts are speci.ed \nin the .h .le. Every prototype declaration of a function f has the form: (type) f (\u00b7\u00b7\u00b7) requires (e) \nmodi.es (e), (e),..., (e) ensures (e); de.ning the precondition required to hold whenever f is invoked, \nthe side-e.ects of the function f, i.e., the objects that may be modi.ed during invocations of f, and \nthe post\u00adcondition that is guaranteed to hold on the modi.ed ob\u00adjects. Here, (e) is a C expression, without \nfunction calls, over global variables and the formal parameters of f.We allow attributes of the form \nde.ned in Table 1 and displayed in Fig. 2. A designated variable return value denotes the return value \nof f.The special syntax i(e)lpre denotes the value of (e) when f is invoked. Although not required, the \ncontract mechanism enables specifying pointer values. In addition a shorthand expression is within bounds(arg) \nis allowed to indicate that arg points within the bounds of a bu.er. 2.3 Running Example The CoreC version \nof the function RTC Si SkipLine from EADS Airbus (SkipLine for short)is showninFig.3. SkipLine inserts \nNbLine newline characters starting at the location pointed-to by *PtrEndText, appends a null-termination \nchar\u00adacter and sets *PtrEndText to point to the end of the string. A contract for SkipLine is showninFig.4. \nThe pre\u00adcondition demands that upon entry: *PtrEndText points to within the bounds of a bu.er; the allocation \nsize from the void SkipLine(int NbLine, char** PtrEndText) {int indice; char* PtrEndLoc; [1] indice=0; \n[2] begin loop: [3] if (indice>=NbLine)goto end loop; [4] PtrEndLoc = *PtrEndText; [5] *PtrEndLoc = \\n \n; [6] *PtrEndText = PtrEndLoc + 1; [7] indice = indice + 1; [8] goto begin loop; [9] end loop: [10] PtrEndLoc \n= *PtrEndText [11] *PtrEndLoc = \\0 ; } void main() { char buf[SIZE]; char *r, *s; [1] r=buf; [2] SkipLine(1,&#38;r); \n[3] fgets(r,SIZE-1,stdin); [4] s =r +strlen(r); [5] SkipLine(1,&#38;s); } Figure 3: SkipLine, a string \nmanipulation function from EADS Airbus with a toy main function. location *PtrEndText is greater than \nNbLine; and, NbLine is at greater or equal to zero. The function may mod\u00adify the *PtrEndText pointer \nand the bu.er pointed-to by *PtrEndText. The postcondition indicates that *PtrEndText points to a null-terminated \nstring of length zero, and its value is advanced by NbLine bytes. Due to multi-level pointer indirections, \ndestructive up\u00addates, and pointer arithmetic, it is rather challenging to ver\u00adify the absence of errors \nin this function. CSSV is able to statically verify the absence of string errors in this function, without \nreporting any false alarm. The toy main procedure, shown in Fig. 3, calls SkipLine to insert a newline \ncharacter, reads input from the stan\u00addard input, and concatenates an additional newline by call\u00ading SkipLine \nagain. This procedure has an o.-by-one error. In the case of a user input of length SIZE-1, buf is full \nand there is no space for the additional newline. CSSV detects this error in main without reporting any \nfalse alarm. There is a strong correlation between the provided set of contracts and the messages reported. \nHowever, errors do not go undetected. For example, omitting NbLine >= 0 from the precondition of SkipLine \nyields an error message during the analysis of the procedure. The message indicates that the postcondition \n*PtrEndText == i*PtrEndTextlpre + NbLine may not hold. Interestingly, the counter-example produced by \nCSSV for this message shows that this postcondition does not hold when the value of NbLine is negative. \nProviding a precondition which is stronger than the weak\u00adest precondition can yield error messages on \na procedure invocation. For example, requiring in the precondition of void SkipLine(int NbLine, char** \nPtrEndText) requires is within bounds(*PtrEndText)&#38;&#38; *PtrEndText.alloc > NbLine &#38;&#38; NbLine \n>=0 modi.es *PtrEndText *PtrEndText.is nullt *PtrEndText.strlen ensures *PtrEndText.is nullt &#38;&#38; \n*PtrEndText.strlen == 0 &#38;&#38; *PtrEndText == i*PtrEndTextlpre +NbLine ; Figure 4: Acontract for \nSkipLine. SkipLine that *PtrEndText points-to a null-terminated string will cause an error message regarding \nthe call to SkipLine at line [2] of main.  2.4 Instrumented Concrete Semantics The C programming language \ndoes not de.ne semantics for C programs. In the ANSI-C standard there is an in\u00adformal notion of de.ned \nand unde.ned behaviors. However, the exact behavior can change, and often does, from one im\u00adplementation \nof a compiler to another. Due to the following features of the language, it is not trivial to de.ne semantics \nfor C: Address-of operation enables changing the value of a variable without assigning to the variable. \nIt also permits pointers to invisible variables.  Allocation library functions (e.g., malloc)provide \nan unformatted contiguous memory locations, while from the logic point of view there is a hierarchy of \nob\u00adjects where one object may contain objects of di.erent types. Moreover, objects are type-less, thus \nproviding .exibility, and allowing accesses to a location accord\u00ading to di.erent types. Therefore, it \nis di.cult to de.ne and check the legitimacy of an access.  Pointer arithmetic is frequently used and \nhas a de.ned result. However, checking its validity is im\u00adpossible without additional instrumented information. \n Cast operation exposes the internal memory layout e.g., by allowing casting from integer to pointer \ntype.  In this section, we sketch an instrumented operational se\u00admantics for C that veri.es the absence \nof out-of-bound vi\u00adolations while allowing pointer arithmetic, destructive up\u00addates and casting. The \ngeneral idea is to de.ne a non\u00adstandard low-level semantics that explicitly represents the base address \nof every memory location and the allocated size starting from the base address. This semantics is rigor\u00adous. \nIt forbids programs with unde.ned ANSI-C behavior but it also checks additional requirements re.ecting \ngood programming styles such as dereferences beyond the null\u00adtermination byte. This semantics provides \nthe foundation of CSSV s abstract interpretation, i.e., the abstract interpre\u00adtation conservatively represents \nthe states of this semantics. In addition, CSSV statically veri.es the absence of string errors by conservatively \nchecking the preconditions of this semantics. The reader is referred to [12] for a discussion on this \nsemantics and re.nements for checking the validity of maps locations into their values. For example, \nthe pointer to s is described as a pointer to a location which is loc(s). Our concrete example contains, \namong others, the following interesting mappings: st(loc(PtrEndText)) = loc(s) numBytes(loc(PtrEndText)) \n=4 st(loc(buf)+1) = h numBytes(loc(buf)+1) =1 indicating that PtrEndText points-to the stack location \nof s Figure 5: Aconcrete state arising at entry to SkipLine invoked by the second call from main.For \nclarity, the allocation size of buf is only shown sym\u00adbolically. accesses to general arrays and multi-level \nstructures. There, the soundness of CSSV is proved with respects to the oper\u00adational semantics. Definition \n2.1. A concrete state at a procedure P is a tuple: state. =(L, BA, aSize. , loc. , st, numBytes. , base) \nwhich is a four-byte value, and that the second byte of buf contains the character h . The association \nof the number of bytes with locations en\u00adables us to handle cases where a location is accessed through \ndi.erent types. Speci.cally, writing a location as one type unde.ned value. variable v, we de.ne the \nL-value and the R-value, denoted andlater readingit di.erentsizetyperesults in the as a L-value and R-value \nofCexpressionscanbede.nedby straightforward structuralinduction. In particular for a and ,respectively,asfollows: \nlvrvasv v lvv def where: loc(v) = def L is a .nite set of all static, stack, and dynamically allocated \nlocations. BA. .L. is the set of base addresses in L. .  aSize. : BA. ..de.nes the allocation size \nin bytes of the memory region starting at a base address.  loc. : visvarP .BA. maps visible variables \ninto their assigned global or stack locations (which is always a base address).  st. : L. .val de.nes \nthe memory content, where  val = {uninit, unde.ned}.primitive .L. is the set of possible values. The \nvalue uninit repre\u00adsents uninitialized values; unde.ned represents results from illegal memory access; \nprimitive refers to the set of Cprimitive type (char, int, etc.) values. numBytes. : L. ..de.nes for \neach location the num\u00adber of bytes of the value stored starting at the location.  base. : L. .BA. maps \nevery location to its base ad\u00address.  A concrete state that arises at entry to SkipLine when in\u00advoked \nby the second call in main is showninFig.5. We draw contiguous memory locations as boxes and display \ntheir al\u00adlocation sizes underneath the boxes. Here, we assume that integers and pointers are four bytes \nlong and a character is one byte long. We draw a variable v above a box whose base address is loc(v). \nThe value inside each box shows the corresponding store content. Pointer values are drawn as edges. Intuitively, \nthe state keeps track of the set of allocated locations (L). The origin location of each memory region \nthat is guaranteed to be contiguous is in BA.In order to handle destructive update to a variable via \nthe address-of operation, loc. represents the address of variables, and st. v (lv. We de.ne a function, \nindex, to reason about the displace\u00adment of a location from its base. Formally, index. : L. .. def index(l)= \nl. -base(l) With the additional information of aSize. and base. the R\u00advalue of an attribute is easily \nde.ned. In particular the R\u00advalue of the attribute p.offset is index(rvp. ). In addition, the use of \nthe instrumented mappings allows the seman\u00adtics to validate that pointer arithmetic and dereferences \nare within bounds. For example, a pointer expression p+i is within the bounds of the bu.er pointed-to \nby p when the following condition holds: 0 =index(rvp)+ rvi =aSize(base(rvp)) We follow [20, pp.205] \nand check that the result of pointer arithmetic is either before or at the .rst location beyond the upper \nbound.  3. CSSV CSSV analyzes each procedure separately. We refer to the analyzed procedure as P. CSSV \nchecks for three kinds of er\u00adrors: (i)ANSI-C violations related to strings, such an access out of bounds. \n(ii)Violations of pre-and post-conditions of procedures as required by the provided contracts. When a \nprocedure is invoked, the callee s precondition is checked. At the end of P, the postcondition of P is \nchecked. (iii)Our analysis checks certain cleanness conditions that correspond to good programming style. \nIn particular, it validates that all accesses are before the null-termination byte, if it exists. 3.1 \nTechnical Overview Pointers and integers interact in a non-trivial way, espe\u00adcially in the C programming \nlanguage. For example, it is non-trivial to check the safety of the expression *PtrEndText = \\n )= st(loc(v)) \nstrv = v in line [5] of SkipLine, i.e., that the pointer *PtrEndText is within bounds. CSSV infers the \nrelationships between the o.set of *PtrEndText, the allocation size of its base address, and the integer \nvariables indice and NbLine needed to ver\u00adify the safety of this destructive update. As we shall see, \nour algorithm statically veri.es such inequalities by com\u00adbining a pointer-analysis algorithm that detects \npointers to the same base address, with an integer-analysis algorithm that detects o.set relationships \namong pointers. The o.set of a pointer is the index of the location it points to. Of course, in contrast \nto the concrete semantics, the abstract semantics summarizes many concrete locations by a single abstract \nlocation. It also maintains the potential points-to relationships between these addresses. CSSV applies \na whole program .ow-insensitive pointer analysis to detect statically which pointers may point to the \nsame base address. In particular, for every function, it provides a summary of all of its calling contexts. \nIn principle, a conservative analysis can utilize this informa\u00adtion and analyze a function with all possible \ncalling con\u00adtexts. However, this can yield many false alarms. For ex\u00adample, the whole-program analysis \nof SkipLine yields that PtrEndText may point to either s or r. Conservatively an\u00adalyzing the function \ns body with the two calling contexts, requires treating updates to integer properties such as the o.set \nof *PtrEndText as weak updates. Therefore, the anal\u00adysis will fail to show that the postcondition holds. \nAs a result, a false alarm will be issued. CSSV avoids this false alarm by performing strong updates \nin certain cases. The main idea is to precompute procedural points-to informa\u00adtion that guarantees that \nstrong updates to the o.set of *PtrEndText can be performed. In general, it guarantees that in well-behaved \nprograms direct updates through the formal parameters can be interpreted as strong updates. The procedural \npoints-to information is used by C2IP to generate an integer program. Integer constraint variables summarize \nthe semantic properties (e.g., allocated size)of the represented locations. Finally, a conservative integer \nanalysis determines potential values of the semantic proper\u00adties and veri.es the constraints upon them. \nThe rest of this section is organized as follows: Section 3.2 describes the procedure that inlines contracts \nin P .Sec\u00adtion 3.3 formalizes the procedural points-to information for P . Section 3.4 describes the \nC2IP transformation applied to P . Section 3.5 sketches the integer-analysis algorithm.  3.2 Exposing \nthe Behavior of Procedures The .rst step of CSSV takes as input the C program and the provided set of \ncontracts, and generates a new C pro\u00adcedure inline(P )by exposing the contracts of P and of the invoked \nprocedures. Since inline(P )contains assert state\u00adments that verify contracts, the behavior of inline(P \n)di.ers from the behavior of P on inputs which violate the contracts. We extend C as follows: The construct \nassume((e)) that indicates that (e) holds after this statement, i.e., if (e) does not hold the exe\u00adcution \nis aborted without any message. It is used to re.ect commitments of other procedures.  Additional temporary \nvariables named (e) used to store the value of a subexpression i(e)lpre at the pro\u00adcedure entry.  The \ncontract-language attributes which have a well\u00adde.ned meaning in our instrumented concrete seman\u00adtics. \nMost of the C statements remain intact. Table 2 shows the scheme for translating the a.ected statements. \nProcedure entry is encountered before the .rst executable statement. In this case, the additional variables \nare initialized and the precondition of P is assumed to hold. The designated vari\u00adable return value is \nset at every return statement. At every exit point (including return), the postcondition of P is ver\u00adi.ed. \nOn a call to g we verify that g s precondition holds and assume that the postcondition holds. The original \ncall to g is in the emitted code. This is essential for inline(P )to have the same interpretation as \nP .  3.3 Pointer Analysis The second step of CSSV computes an abstraction of all potential pointer relationships \nbetween locations in concrete states that may occur during the execution of P . However, only locations \nthat can be accessed during the execution of P are of interest. Therefore, we de.ne the notion of reachable \nlocations. l Definition 3.1. In a concrete state, a location is reachable if there exists a visible variable \nwhose content can (indirectly) include l. (i.e., there is an expression whose L-value is l). Computing \nprocedural pointer information allows us to infer the pointer relationships among reachable locations \nof P . Moreover, the procedural pointer information aims at representing the location a formal points \nto at the procedure entry as a single location. This section describes the abstract state representing \npointer relationships and an algorithm to compute this state. 3.3.1 Procedural Points-to Information \nWe formalize an abstract state that regards pointer rela\u00adtionships among reachable locations of P as \nfollows: Definition 3.2. A procedural abstract points-to state of P (PPT) is a quadruple stateP =(BAP \n, locP , ptP , smP ) where: BAP is a set of abstract locations that represent all reachable concrete \nbase addresses. . 2BAP  locP : visvarP maps variables into set of ab\u00adstract locations representing \nthe variable s global or stack locations. . 2BAP  ptP : BAP abstract the possible pointers. A concrete \npointer is represented by a ptP relationship between the abstract locations representing the base ad\u00addresses \nof the source and target locations of the pointer.  smP : BAP .{1, 8} is an abstract count of the num\u00adber \nof concrete base addresses represented by an ab\u00adstract location, i.e., sm(ba)= 8 when ba may repre\u00adsent \nmore than one base address in a given concrete store, and 1 when it is guaranteed to represent at most \none base address. An abstract location having sm = 8 is a summary abstract location. Summary abstract \nlocations can be used to represent unbounded sets of base addresses.  Event Emitted Code entry of P(f1,f2,...,fn) \n (ei) = (ei); for every i(ei)lpre in post[P] assume(pre[P](f1,f2,...,fn)); return (e) return valueP = \n(e); exit P assert(post[P](f1,f2,...,fn)); { (ei) = (ei); for every i(ei)lpre in post[g] assert(pre[g](a1,a2,...,am)); \n(e) = g(a1,a2,...,am) return valueg = g(a1,a2,...,am); assume(post[g](a1,a2,...,am)); (e) = return valueg; \n} Table 2: The emitted C code for a.ected statements. The notation pre[x](e1,e2,...,em) stands for the \nprecon\u00addition of procedure x where formal fi is replaced with the expression ei. The expression post[x] \nis obtained in a similar way, however each of the i(ei)lpre expression is replaced with the variable \n(ei) . return valuex is a designated variable representing the return value in the postcondition of procedure \nx. WesaythataPPT (BAP ,locP ,ptP ,smP )is a sound ap\u00adproximation of a concrete state (L,BA,aSize,loc,st, \nnumBytes,base)in a procedure P if there exists a function a: BA. .BAP satisfying the following requirements: \nBase For all reachable b. .BA: a(b) .BAP . Stack For all v . visvarp: a(loc(v)) . locP (v). Pointer For \nall l1,l2.L. s.t., l1and l2are reach\u00ad(l1 able, and satisfying st)= l2: a(base(l2)) . ptP (a(base(l1))). \n. . Summary For all b.BAp, s.t., smP (b)=1, and b1,b2 BA. having a(b1)= a(b2)= b: b1= b2. Definition \n3.3. A stateP is a sound approximation of P if it is a sound approximation of all the concrete states \nthat may arise during the execution of P. L-values and R-values are generalized to return sets of abstract \nlocations. In particular for a visible pointer variable q: def lvq = locP (q) .. def rvq = ptP (l)= ptP \n(l) l.lvq l.locP (q)  3.3.2 Constructing Procedural Information CSSV computes a sound approximation \nstatep in two stages. First, a whole-program analysis is applied to compute a global abstract points-to \nstate of the whole program Gstate = (BA,loc,pt,sm)where: BA includes all abstract locations.  loc: \nvar . 2BA .  pt: BA . 2BA .  sm : BA . {1,8}. This global state is guaranteed to be a sound approxima\u00adtion \nof all procedures. Second, this global state is used to construct a sound approximation for P. It is \npossible to construct di.erent sound PPTs for P with di.erent abstract locations and points-to relationships. \nWe decided to bias to\u00adwards precise representation of formal parameters, with the lvPtrEndText   \nlvr lvs  lvbuf N lvPtrEndLoc (a) lvPtrEndText  rvPtrEndText   N lvPtrEndLoc (b) Figure 6: \nThe whole-program points-to informa\u00adtion for the running example (a), and the PPT for SkipLine (b). intention \nof conducting strong updates on their properties in many cases. Fig. 6 demonstrates the process. Fig. \n6(a)shows the whole-program points-to information of our running exam\u00adple. Boxes represent abstract locations. \nWhen possible we denote abstract locations as either L-value (e.g., lvs)or as R-value of a unique pointer \nvariable. Otherwise, we pro\u00advide an arbitrary name (e.g., N). Edges represent the pt relationship. There \nare no summary abstract locations in this example. The .nal result of computing the PPT for SkipLine \nis shown in Fig. 6(b). A new abstract location rvPtrEndText represents the (unique)concrete location \nwhich holds the value of *PtrEndText. Given a global abstract pointer state of the whole pro\u00adgram Gstate \n=(BA,loc,pt,sm), let us construct a PPT for P stateP =(BAP ,locP ,ptP ,smP ). The mapping locP is computed \nby projecting loc to the visible variables of P. Similarly, BAP and smP are computed by including abstract \nlocations reachable from visible variables of P. An initial value for ptP is obtained by projection. \nIn our running example, this yields the same state as the global points-to information shown in Fig. \n6(a)without the lvbuf abstract location. We aim at a potentially more precise rep\u00adresentation. A conservative \nalgorithm which checks whether it is sound to merge the nodes l1,l2,...,lm pointed-to by a formal f without \ncreating a new summary node, is presented in Fig. 7. This algorithm checks that for every concrete store \nat most one concrete location is represented by rvf (the set of abstract locations pointed-to by a formal \nparameter f). The correctness of the algorithm is established in [12]. Whenever possible, merging is \ndone by (i)replacing the Boolean parameterizable( PPT stateP ,formal f ) CExp. Generated IP Condition \nlvp.o.set = 0. *p ((rvp.is nullt . lvp.o.set = rvp.len). (\u00acrvp.is nullt . lvp.o.set < rvp.aSize)) p+i \n0 = lvp.o.set + lvi.val = rvp.aSize { let stateP =(BAP ,locP ,ptP ,smP ) let lf = locP (f)// the L-value \nof f if smP (lf )= 8 return false let {l1,l2,...,lm} = pt(lf )// the R-values of f for i =1to m if smP \n(li)= 8 return false remove from pt edges from lf to lj where j =.i, and let pt. be the resultant points-to \nmap. if exists a reachable node lj,j .. then = i in pt return false // at most one of the concrete locations \npointed-to by f // is reachable in a concrete state represented by stateP return true; } Table 3: Asserted \nIP conditions for C expressions. l.o.set to represent potential o.sets of the pointers represented by \nl, i.e., l.o.set conservatively represents index (st (l )) for every location l represented by l.  l.aSize, \nl.is nullt and l.len to describe the allocation size, whether the base address contains a null termi\u00adnated \nstring, and the length of the string (excluding the null byte)of all locations represented by l.  Figure \n7: Algorithm to conservatively check that at most one concrete location is represented by the set pointed-to \nby a formal parameter f. abstract locations l1,l2,...,lm by a single non-summary ab\u00ad . stract location \nrvf. (ii)setting pt(rvf)to mi=1 pt(li).This may improve the precision of destructive updates through \nf, but may decrease the precision of other updates.  3.4 C2IP The C2IP transformation takes the inline(P)procedure \nwith its PPT as input, and produces an integer program (IP for short)as output. The generated IP tracks \nthe string and integer manipulations of P and of the invoked proce\u00addures. The IP is nondeterministic, \nre.ecting the fact that not all values are known. The symbol unknown stands for an undetermined value. \nIn particular, we use the following expressions: x := unknown; Assigns any value to x. if (unknown) Either \nthe true or the false branch can be taken. The semantics of the assume construct in the integer pro\u00adgram \nis to restrict the behavior of nondeterministic pro\u00adgrams. Finally, for clarity, we use mathematical \nconstructs in the IP. The IP includes constraint variables used to denote se\u00admantic properties of interest \nsuch as o.sets. C2IP generates statements which assign new values to constraint variables, re.ecting \nthe changes in the semantic properties. Assert statements over the constraint variables are generated. \nThey check for the safety of basic C expressions and for verifying contracts. In addition, C2IP can validate \npointer assertions if speci.ed in the contracts. Due to the .ow insensitivity of our pointer analysis, \nthis capability is rather weak in terms of precision. When a precondition may not hold, an error message \nis reported. 3.4.1 Constraint Variables For every abstract location, l, C2IP generates the follow\u00ading \nconstraint variables: l.val to represent potential primitive values stored in the locations represented \nby l. 3.4.2 Translating Expressions Transforming C expressions involves querying the PPT to obtain the \nabstract locations a pointer may point-to. For the sake of simplicity, in this subsection we assume that \nevery pointer may only point to a single non-summary abstract location. Thus, lvp (representing the global \nor stack location of p),and rvp (representing the location pointed-to by p) are both singletons for every \npointer p. In Section 3.4.2.3, general PPTs are considered. 3.4.2.1 Safety Checks. For every C expression, \nthere is a condition that veri.es the validity of the expression. Table 3 lists the generated assert \nexpressions. On every dereference to an address, a check that the address is within bounds is generated. \nThe upper bound is checked depending on whether the bu.er is null-terminated. If it is, the dereferenced \nlocation is checked to be at or before the null-termination byte. For pointer arithmetic, the generated \nassert statement checks the re\u00adquirement that the resultant reference is within or at the upper bound \nof the bu.er. The generated assert resem\u00adbles the requirement de.ned in the concrete semantics for pointer \narithmetic. This emphasizes that CSSV abstracts the properties needed to statically verify pointer arithmetic. \n 3.4.2.2 Statements. C2IP generates statements to re.ect semantic changes re\u00adgarding the properties tracked. \nThe core rules for translat\u00ading C constructs into IP is shown in Table 4. On allocation, the resultant \npointer always points to a base address. Therefore, its o.set is always zero. We set the allocation size \nof the abstract location that represents the newly allocated location. Destructive updates are sepa\u00adrated \ninto two cases: (i)The assignment of the null charac\u00adter, which sets the bu.er to a null-terminated string. \nThe length of the string is the location of the .rst zero byte. C2IP generates a check that all dereferences \nare before the null-termination byte (if it exists). We can therefore safely assume that when assigning \na null-termination byte it is the .rst one. (ii)In the assignment of a non-zero character, it is checked \nwhether an existing null-termination byte is overwritten. The generated IP does not contain function \ncalls. Because C2IP transforms the inline(P)procedure, the pre-and post\u00ad CConstruct IP Statements lvp.o.set \n:= 0; p = Alloc(i); rvp.aSize := lvi.val; rvp.is nullt := false; p= q + i; lvp.o.set := lvq.o.set + lvi.val; \n*p = c; if c =0 {rvp.len := lvp.o.set; rvp.is nullt := true; }else if rvp.is nullt . lvp.o.set = rvp.len \nlvp.is nullt := unknown; if rvp.is nullt . lvp.o.set = rvp.len c= *p; lvc.val := 0; else lvc.val := unknown; \ng(a1,a2,...,am); mod[g](a1,a2,...,am); *p == 0 rvp.is nullt . rvp.len = lvp.o.set p > q lvp.o.set >lvq.o.set \np.alloc rvp.aSize - lvp.o.set p.o.set lvp.o.set p.is nullt rvp.is nullt p.strlen rvp.len - lvp.o.set \n Table 4: The generated transformation for C state\u00adments, conditional expressions and for contract\u00adlanguage \nattributes. p and q are variables of type pointer to char. i and c are variables of int type. Alloc is \na memory allocation routine, e.g., malloc and alloca. conditions of an invoked procedure g are transformed \ntoo. However, the call to a procedure needs to be analyzed con\u00adservatively. C2IP converts the call to \ng with the modi.ca\u00adtion clause of g and substitutes actual for formal parame\u00adters. The modi.cation clause \nis interpreted as assignments of unknown to the constraint variables of the abstract loca\u00adtions that \nrepresent potentially modi.ed objects. To increase precision, certain program conditions are in\u00adterpreted. \nThe second part of Table 4 shows the interpreted conditions. When checking for null-termination, C2IP \nre\u00adplaces the condition with a condition over constraint vari\u00adables that track the existence of a null-character \nand the length. Pointer comparisons are replaced by expressions over the appropriate offset constraint \nvariables. For convenient use, the contract language allows speci\u00adfying attributes on pointers instead \nof on base addresses. For example, p.alloc represents the allocation size start\u00ading at the location pointed \nto by p. The last part of Table 4 lists the transformation of contract s attributes to constraint variables \nby referring to the abstract locations pointed to by the speci.ed pointer. 3.4.2.3 Other C Constructs. \nIn the case that an L-value (R-value)in the abstract points\u00adto state includes more than one abstract \nlocation or a sum\u00admary abstract location, the translation rules of Table 4 need to be changed to guarantee \nsound results. To re.ect the fact that a base address represented by lmay or may not be mod\u00adi.ed, C2IP \ngenerates every statement (shown in Table 4) as a nondeterministic assignment, under an if (unknown) \nstatement. In addition, the analysis must take into account all possible values of a pointer, and verify \nexpressions on all possible pointer values. This applies to all generated assert statements and program \nconditions. To handle casting and unions, C2IP generates for an as\u00adsignment to one type of constraint \nvariable assignments of unknown to the other constraint variables of the same ab\u00adstract location. For \nexample, an assignment of an integer to a concrete location represented by abstract location l yields \nan assignment to l.val. In addition, C2IP generates the as\u00adsignment l.o.set := unknown. In particular, \na cast to and from pointer type is conservatively handled by an assign\u00adment to unknown. The pointer analysis \ndetermines which functions may be invoked at a call statement via a function pointer. Then, CSSV generates \na non-deterministic statement that selects an arbitrary function call. It is di.cult to write general \ncontracts for the format functions, such as sprintf() and printf(). Therefore, for the format functions, \nC2IP generates automatically pre-and post-condition according to the exact calling context. CSSV warns \nin cases where the format parameter is not a constant. 3.4.2.4 The Complexity of C2IP. The number of \nconstraint variables in the IP is O(V) where V is the number of variables and allocation sites in the \nC program. Because a pointer may point to V abstract locations, the translation of a C expression that \ncontains one pointer generates O(V)IP statements. Therefore, the size of the IP is O(S * V), where S \nis the number of C ex\u00adpressions. This is an order-of-magnitude improvement over the transformation in \n[13], which generates O(V2)variables and O(S * V2)statements.  3.5 Integer Analysis In the .nal step, \nCSSV analyzes the IP and reports poten\u00adtial assert violations. In theory, any sound integer analysis \ncan be used. Because many of the tracked semantic prop\u00aderties are external to the procedure, and sometimes \neven to the whole application, it is essential to track relationships between constraint variables and \nnot just possible values. Furthermore, many of the conditions to infer involve three and more properties, \ne.g., the postcondition of SkipLine re\u00adgarding the new o.set of *PtrEndText. Given that our goal is to \ngenerate as few as possible false messages, we apply the a linear-relation analysis [6, 17] which discovers \nlinear inequalities among numerical vari\u00adables. This method identi.es linear inequalities of the form: \nSn i=1cixi + b = 0, where xi is an integer variable and ci and b are constants. In our case, xi are the \nconstraint variables. Upon termination of the integer analysis, the information at every control-.ow \nnode conservatively represents the in\u00adequalities that are guaranteed to hold whenever the control reaches \nthe respective point. The reader is referred to [6, 17, 13] for information about integer analysis. 3.5.1 \nAssert Checking During integer analysis, each assert statement is veri\u00ad.ed. This is done by checking \nif the asserted integer ex\u00adpression is implied by the linear inequalities that hold at the corresponding \ncontrol-.ow node. If the assertion can\u00adnot be veri.ed then a counter-example is generated. The counter-example \ndescribes the values of the constraint vari\u00adables where a string error in the C program may arise. rvbuf.aSize \n= SIZE rvbuf.len = 1 rvbuf.aSize = rvbuf.len + 1 lvs.o.set = rvbuf.len (a) [5] SkipLine(1,&#38;s); require(rvbuf.aSize \n- lvs.o.set > 1 ) error: the requirement may be violated when: rvbuf.aSize = rvbuf.len + 1 (b) Figure \n8: Areport on the error in line [5] of main. The derived inequalities before execution of line [5] of \nmain (a), and a counter example (b). Fig. 8 demonstrates how the static integer-analysis algo\u00adrithm identi.es \nthe error in the call to SkipLine in line [5] of main. The algorithm discovers that the inequalities \nshown in Fig. 8 (a)hold before the execution of line [5], and that when the equality shown in Fig. 8 \n(b)holds a violation of SkipLine s precondition occurs.   4. DERIVING CONTRACTS This section presents \ninteger-analysis algorithms to strengthen pre-and post-conditions. The following process is applied toaprocedure \nP: 1. Compute side-e.ect information for P. 2. Run the inliner and C2IP with vacuous true pre-and post-condition \nwhich produces an integer program IP0. 3. Run ASPost, a forward integer analysis of [6] on IP0 which \ncomputes a safe approximation of the strongest postcondition. Obtain a new IP program IP1 by strength\u00adening \nthe postcondition with the set of linear inequali\u00adties generated by the integer analysis at the procedure \nexit. 4. Run AWPre, a backward integer analysis on IP1 which computes an approximation to the weakest \nliberal pre\u00adcondition. Obtain a new IP program IP2 by strength\u00adening the precondition with a set of linear \ninequalities generated by the analysis at the procedure entry. 5. Writeback by using the PPT, convert \nthe pre-and the post-conditions of IP2 to C expressions over the formal parameters and global variables \nof P.  The derivation process can also start with manually given contracts. For applications with acyclic \ncall graphs, the above process can be automatically applied in a bottom-up fashion, starting with the \nleaf procedures. 4.1 Integer Analysis The ASPost algorithm is essentially the algorithm of Sec\u00adtion 3.5 \nwithout issuing messages. It computes linear in\u00adequalities that hold at the exit point. Local variables \nare eliminated. The resulting inequalities are added to the in\u00adput postcondition. To improve the e.ectiveness \nof the derivation, the inliner phase is allowed to add designated variables to record values of properties \nthat may be modi.ed by P. For every poten\u00adtially modi.ed integer property expressed as a C expression \n(e),the inline(P)procedure includes a new variable (e) with an additional C statement assume( (e) == \n(e)); During the writeback process, this variable is replaced by an appropriate i(e)lpre expression in \nthe postcondition. In this example, since *PtrEndText may be modi.ed, variables are used to record all \nits properties. In particular, a variable *PtrEndText.offset records the value of the expression *PtrEndText.offset \nat the entry. The linear relationships obtained by ASPost when applied to SkipLine in the running example \nwith a true precondi\u00adtion are: N.is nullt = true N.len = rvPtrEndText.o.set rvPtrEndText.o.set = *PtrEndText.offset \n+ lvNbLine.val (1) The existence of a null-termination byte and the new length of the base address points \nto-by *PtrEndText is com\u00adputed by ASPost precisely. ASPost .nds a relationship be\u00adtween the old and new \no.sets of *PtrEndText. However, this relationship is weaker than the manually provided one on which the \ninequality is an equality. Both ASPost and AWPre may lose information due to joins of control-.ow paths \nand due to the widening operation. AWPre is similar to the forward algorithm in the sense that it uses \nthe same abstract domain and abstract opera\u00adtions. The main di.erence is the treatment of assignments, \nwhich are handled by substitutions. 4.2 Write Back The pre-and post-conditions generated by AWPre and \nASPost are converted into C expressions over the formal parameters and global variables of P. These expressions \nare added to the input contracts using logical-and operator. 4.2.1 Obtaining Postconditions Recall that \nthe integer analysis computes properties of ab\u00adstract locations. Each such abstract location corresponds \nto a set of L-value expressions over global and formal variables of P. Consider an abstract location \nl and assume, for simplic\u00adity, that there is a unique expression, say e,whose L-value is l. In this case, \nevery constraint variable in the inequalities that occur in the exit are replaced by substituting e for \nl. Each occurrence of a designated formal parameter (e) is replaced by i(e)lpre. Finally, the semantic \nproperties are converted to the contract-language attributes. For the equations in (1), the writeback \nalgorithm yields: **PtrEndText.is nullt &#38;&#38; **PtrEndText.strlen = 0 &#38;&#38; *PtrEndText.o.set \n>= i*PtrEndText.offset lpre +NbLine When an abstract location corresponds to a set of L\u00advalue expressions, \nwe generate a weaker postcondition using logical-or operator. An alternative would be to ignore some \nof these expressions, which may lead to false alarms when the procedure is analyzed by CSSV. 4.2.2 Obtaining \nPreconditions Generating C expressions for preconditions from the en\u00adtry inequalities is similar to the \nprocess of generating post\u00adconditions. The main di.erence is that we use logical-and instead of logical-or \nwhen multiple expressions correspond to the same abstract location.   5. EMPIRICAL RESULTS Implementing \nthe CSSV tool is non-trivial because of the complicated aspects of C and program analysis. We have im\u00adplemented \na prototype of CSSV with signi.cant help from the Semantics Based Tools group at Microsoft Research and \nfrom Greta Yorsh from Tel-Aviv university. The compiler from C to CoreC is built upon the AST-Toolkit. \nCSSV uses Golf, a .ow-insensitive context-sensitive points-to analysis technique, as the underlying whole \nprogram pointer analy\u00adsis. Golf uses .ow edges to represent assignments. Partial must information on \npointer aliases is extracted from these edges. Both the integer analysis and the automatic deriva\u00adtion \nof pre-and post-condition were implemented using the Polyhedra library. We applied CSSV to procedures \nfrom the following: (i)A string-manipulation library from EADS Airbus with a total of 400 lines and 11 \nprocedures. (ii) .xwrites partof web2c a converter from TeX, Metafont, and other related WEB programs \nto C. fixwrites consist of 460 lines and eight procedures. We have manually written contracts for the \nanalyzed procedures. Table 5 describes the benchmark characteristics and the analysis results. The column \nLOC displays the number of source lines in the original source. Column SLOC dis\u00adplays the number of source \nlines after the source-to-source transformation. The Contract column investigates the dif\u00ad.culty of manually \nproviding a contract. We use the char\u00adacters S , B and I as follows: (S)for simple speci.cation, such \nas string and is within bounds, (B)for specifying the boundaries of bu.ers, and (I)for other integer \nrelations. There was no need to provide pointer speci.cation for the analyzed code. Columns IP Vars and \nIP size report the number of variables and statements in the integer program produced by C2IP. Columns \nCPU and Space display the running time and total allocated space of CSSV. All experiments were conducted \non a 900 MHz Intel Pentium-III CPU with 512MB of memory, running Windows 2000. The Msg columns classify \nthe messages reported by CSSV. Messages are classi.ed as errors for cases where there is an input to \nthe application on which the error occurs. The errors detected are due to unsafe calls to library functions, \nsuch as strcpy(), unsafe assumptions that an input contains a speci.c character, or unsafe pointer arithmetic. \nThere are six false messages on Airbus s code. The pro\u00adgram destructively assigns a non-zero character \nto a certain place in a bu.er. CSSV fails to infer that this character is non zero. The function skip \nbalanced safely assumes that the input parameter contains a balanced number of paren\u00adtheses. This is \nveri.ed by the whole function which is called prior to skip balanced. This example demonstrates that \nin some cases it is hard to separate safety from correctness. To show that this function is safe, we \nneed to verify cor\u00adrectness, i.e., that the implementation correctly checks that the input string contains \na balanced number of parentheses.   Fortunately, in most of the analyzed examples, this is not the \ncase, i.e., the safety does not depend on correctness. The Deriving columns provide information about \nthe ef\u00adfectiveness of the AWPre and ASPost algorithms. It is not trivial to measure the result in terms \nof precision. A new contract for a function P can change the result of the anal\u00adysis of P itself and \nof procedures invoking P .We provide a simple measurement that is independent of the calling con\u00adtext. \nWe run ASPost to generate a postcondition, AWPre to generate a precondition, and then run CSSV. Columns \nCPU and Space display the running time and total allo\u00adcated space of both ASPost and AWPre. Column Vacu\u00adous \ndisplays the number of false-alarm messages reported by CSSV when a vacuous contract for the analyzed \npro\u00adcedure is provided. Column Auto displays the number of false alarms reported by CSSV when using the \nautomati\u00adcally derived contracts. On average, the manually provided contracts reduce the number of false \nalarms by 93% as com\u00adpared to the vacuous contracts false alarms, while the au\u00adtomatic derivation algorithm \nreduces the number of mes\u00adsages by 25%. The derived preconditions are in many cases weaker than the manually \nprovided ones. Our initial study indicates that this happens when the integer analysis joins two di.erent \nprocedure behaviors. One potential remedy to this imprecision is by using sets of linear inequalities \nthat allow to precisely represent logical-or.  6. RELATED WORK Many academic and commercial projects \nproduce practi\u00adcal tools that detect string manipulation errors at runtime, e.g., [31, 1, 26, 7]. The \nmain disadvantage of runtime check\u00ading is that its e.ectiveness strongly depends on the input tested, \nand it does not ensures against future bugs on other inputs. Our goal is a conservative static tool that \ndetects all string errors and provides an assurance against all such errors. 6.1 Static Detection of \nString Errors Although the problem of string manipulation safety check\u00ading is to verify that accesses \nare within bounds [21, 2, 33], the domain of string programs requires that the analysis be capable of \ntracking the following features of the C program\u00adming language: (i)handling standard C functions, such \nas strcpy() and strlen(), which perform an unbounded num\u00adber of loop iterations; (ii)statically estimating \nthe length of strings (in addition to the sizes of allocated base addresses); this length is dynamically \nchanged based on the index of the .rst null character; and (iii)simultaneously analyzing pointer and \ninteger values is required in order to precisely handle pointer arithmetic and destructive updates. Many \nacademic projects produce unsound tools to stati\u00adcally detect string manipulation errors. In [23] an \nextension to LCLint is presented. Unsound lightweight techniques, heuristics, and in-code annotations \nare employed to check for bu.er over.ow vulnerabilities. Eau claire [4], a tool based on ESC-Java, checks \nfor security holes in C programs by translating a subset of C to guarded commands. Its annota\u00adtion language \nis similar in sense to CSSV. In [37] Wagner et al. present an algorithm that statically identi.es string \ner\u00adrors by performing a .ow insensitive unsound analysis. The main disadvantage of all of these unsound \ntools is that they miss errors while CSSV does not miss any error. Further\u00admore, none of them can track \ne.ects of pointer arithmetic,      Function Source Code CSSV Msg Deriving           \n remove newline 12 260 S 35 203 0.1 2 0 0 0.61 1 1 0  Table 5: The experimental results. a widely used \nmethod for string manipulation. Sound al\u00adgorithms for statically detecting string errors are presented \nin [13, 35]. However, they cannot handle all C, in particu\u00adlar multi-level pointers and structures. As \nfar as we know, CSSV is the .rst sound tool to handle all C and in a rather precise manner.  6.2 Procedural \nPoints-to Information Many algorithms compute procedural pointer information to improve the cost and \nprecision of interprocedural analy\u00adsis, e.g., [27, 22, 10, 5]. In contrast, we focus on the prob\u00adlem \nof representing procedure points-to information in a way which allows us to perform strong updates in \nwell-behaved programs. In [25] a modular parameterized pointer anal\u00adysis (MoPPA)is described. MoPPA computes \nprocedural pointer information during the process of computing global pointer information. In contrast, \nour algorithm utilizes ex\u00adisting whole-program scalable pointer analysis and trans\u00adforms the global information \nto the procedural information. Our technique thus is more general since it applies to many pointer analysis \nalgorithms and not just to Steensgaard s analysis [36] which serves as the basis for MoPPA. 6.3 The \nAutomatic Derivation Process The Houdini annotation-derivation tool [14] tries ESC/Java with di.erent \nannotations. Such an approach is inadequate in our case because the number of potential annotations is \nunbounded. In contrast, we derive a contract by forward and backward analyses of the integer program \n[16].  7. CONCLUSIONS Bu.er over.ow is one of the most harmful sources of de\u00adfects in C programs. Moreover, \nit makes software vulnerable to hacker attacks. We believe that CSSV provides evidence that sound analysis \ncan be applied to statically verify the absence of all string errors in realistic applications. Acknowledgments \nWe would like to thank Manuvir Das for providing and as\u00adsisting us with AST-ToolKit and GOLF. Thanks \nto Bertrand Jeannet and Nicolas Halbwachs for providing us the poly\u00adhedra library and for their support. \nThanks to Greta Yorsh for her assistance in the prototype implementation and for many technical insights. \nThanks to Seth Hallem, Roman Manevich, Tom Reps, Ran Shaham, and Reinhard Willhelm for their helpful \ncomments.  8. REFERENCES [1] T.M. Austin, S.E. Breach, and G.S. Sohi. E.cient detection of all pointer \nand array access errors. In SIGPLAN Conf. on Prog. Lang. Design and Impl. ACM Press, 1994. [2] R. Bodik, \nR. Gupta, and V. Sarkar. ABCD: eliminating array bounds checks on demand. In SIGPLAN Conf. on Prog. Lang. \nDesign and Impl., 2000. [3] D.R. Chase, M. Wegman, and F. Zadeck. Analysis of pointers and structures. \nIn SIGPLAN Conf. on Prog. Lang. Design and Impl., pages 296 310, New York, NY, 1990. ACM Press. [4] B. \nChess. Improving computer security using extended static checking. In IEEE Symposium on Security and \nPrivacy, 2002. [5] J. Choi, M. Gupta, M.J. Serrano, V.C. Sreedhar, and S.P. Midki.. Escape analysis for \njava. In Conf. on Object-Oriented Prog. Syst. Lang. and App., pages 1 19, 1999. [6] P. Cousot and N. \nHalbwachs. Automatic discovery of linear constraints among variables of a program. In Symp.on Princ.ofProg. \nLang., 1978. [7] C.Cowan, P.Wagle, C. Pu,S.Beattie, and J. Walpole. Bu.er over.ows: attacks and defenses \nfor the vulnerability of the decade. In In Proc.ofthe DARPA Information Survivability Conference and \nExpo, 1999. [8] M. Das. Uni.cation-based pointer analysis with directional assignments. In SIGPLAN Conf. \non Prog. Lang. Design and Impl., 2000. [9] M. Das, B. Liblit, M. F\u00a8ahndrich, and J. Rehof. Estimating \nthe impact of scalable pointer analysis on optimization. In Static Analysis Symp., 2001. [10] A. Deutsch. \nInterprocedural may-alias analysis for pointers: Beyond k-limiting. In SIGPLAN Conf. on Prog. Lang. Design \nand Impl., pages 230 241, New York, NY, 1994. ACM Press. [11] E.W. Dijkstra. A Discipline of Programming. \nPrentice-Hall, 1976. [12] N. Dor. Statically Detecting All Bu.er Over.ows in C. PhD thesis, Univ. of \nTel-Aviv, Israel, 2003. In preparation. [13] N. Dor, M. Rodeh, and M. Sagiv. Cleanness checking of string \nmanipulations in C programs via integer analysis. In Static Analysis Symp., 2001. [14] C. Flanagan, K. \nRustan, and M. Leino. Houdini, an annotation assistant for Esc/java. In Formal Methods for Increasing \nSoftware Productivity, volume 2021 of Lecture Notes in Computer Science, 2001. [15] R. Ghiya, D. Lavery, \nand D. Sehr. On the importance of points-to analysis and other memory disambiguation methods for c programs. \nIn SIGPLAN Conf. on Prog. Lang. Design and Impl., 2001. [16] N. Halbwachs. Static Analysis of Linear \nProperties Invariantly Satis.ed by the Numeric Variables of a program. PhD thesis, Grenoble University, \n1979. [17] N. Halbwachs, Y.E. Proy, and P. Roumano.. Veri.cation of real-time systems using linear relation \nanalysis. Formal Methods in System Design, 11(2):157 185, 1997. [18] N. Heintze and O. Tardieu. Ultra-fast \naliasing analysis using cla: A million lines of c code in a second. In SIGPLAN Conf. on Prog. Lang. Design \nand Impl., 2001. [19] B. Jeannet. New polka library. Available at [23] D. Larochelle and D. Evans. Statically \ndetecting likely bu.er over.ow vulnerabilities. In 10th USENIX Security Symposium, 2001. [24] G. Leavens \nand A. Baker. Enhancing the pre-and postcondition technique for more expressive speci.cations. In Formal \nMethods, 1999. [25] D. Liang and M. J. Harrold. E.cient computation of parameterized pointer information \nfor interprocedural analyses. In Static Analysis Symp., 2001. [26] A. Loginov, S. Yong, S. Horwitz, and \nT. Reps. Debugging via run-time type checking. In Proc. of Fundamental Approaches to Softw. Eng. (FASE), \nApril 2001. [27] T.J. Marlowe and B. G. Ryder. An e.cient hybrid algorithm for incremental data .ow analysis. \nIn Symp. on Princ. of Prog. Lang., 1990. [28] B. Miller, D. Koski, C. Lee, V. Maganty, R. Murthy, A. \nNatarajan, and J. Steidl. Fuzz revisited: A re-examination of the reliability of Unix utilities and services, \n1995. Available at http://www.cs.wisc.edu/~bart/fuzz/fuzz.html. [29] C. Morgan. Programming from Speci.cations. \nPrentice-Hall, Engelwood N.J, 1990. [30] E.W. Myers. A precise inter-procedural data .ow algorithm. In \nSymp. on Princ. of Prog. Lang., 1981. [31] Inc. Rational. Purify software. Available at http://www.rational.com \n, 1995. [32] Microsoft Research. AST-toolkit. 2002. [33] R. Rugina and M.C. Rinard. Symbolic bounds analysis \nof pointers, array indices, and accessed memory regions. In SIGPLAN Conf. on Prog. Lang. Design and Impl., \n2000. [34] B. G. Ryder, W. A. Landi, P. A. Stocks, S. Zhang, and R. Altucher. A schema for interprocedural \nmodi.cation side-e.ect analysis with pointer aliasing. ACM Transactions on Programming Languages and \nSystems, 23(2):105 186, 2001. [35] A. Simon and A. King. Analyzing string bu.ers in c. In International \nConference on Algebraic Methodology http://www.irisa.fr/prive/Bertrand.Jeannet/newpolka.html . and Software \nTechnology, 2000. [20] B. W. Kernighan and D. M. Ritchie. The C programming language. Prentice-Hall, \nEnglewood Cli.s, NJ 07632, USA, 1988. [21] P. Kolte and M. Wolfe. Elimination of redundant array subscript \nrange checks. ACM SIGPLAN Notices, 30(6):270 278, 1995. [22] W. Landi. Interprocedural Aliasing in the \nPresence of Pointers. PhD thesis, Dept. of Comp. Sci., Rutgers Univ., 1991. [36] B. Steensgaard. Points-to \nanalysis in almost-linear time. In Symp. on Princ. of Prog. Lang., pages 32 41, 1996. [37] D. Wagner, \nJ. Foster, E. Brewer, and A. Aiken. A .rst step towards automated detection of bu.er overrun vulnerabilities. \nIn Symp. on Network and Distributed Systems Security, 2000. [38] G. Yorsh. CoreC: A Simpli.er for C, \n2002. http://www.cs.tau.ac.il/~ gretay/GFC.htm.  \n\t\t\t", "proc_id": "781131", "abstract": "Erroneous string manipulations are a major source of software defects in C programs yielding vulnerabilities which are exploited by software viruses. We present <b>C</b> <b>S</b>tring <b>S</b>tatic <b>V</b>erifyer (CSSV), a tool that statically uncovers <i>all</i> string manipulation errors. Being a conservative tool, it reports all such errors at the expense of sometimes generating <i>false alarms</i>. Fortunately, only a small number of false alarms are reported, thereby proving that statically reducing software vulnerability is achievable. CSSV handles large programs by analyzing each procedure separately. To this end procedure <i>contracts</i> are allowed which are verified by the tool.We implemented a CSSV prototype and used it to verify the absence of errors in real code from EADS Airbus. When applied to another commonly used string intensive application, CSSV uncovered real bugs with very few false alarms.", "authors": [{"name": "Nurit Dor", "author_profile_id": "81100296204", "affiliation": "Tel-Aviv University", "person_id": "PP31035976", "email_address": "", "orcid_id": ""}, {"name": "Michael Rodeh", "author_profile_id": "81100123457", "affiliation": "IBM Research Lab in Haifa", "person_id": "P198604", "email_address": "", "orcid_id": ""}, {"name": "Mooly Sagiv", "author_profile_id": "81100150928", "affiliation": "Tel-Aviv University", "person_id": "PP39029858", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/781131.781149", "year": "2003", "article_id": "781149", "conference": "PLDI", "title": "CSSV: towards a realistic tool for statically detecting all buffer overflows in C", "url": "http://dl.acm.org/citation.cfm?id=781149"}