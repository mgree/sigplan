{"article_publication_date": "05-09-2003", "fulltext": "\n Ownership Types for Safe Region-Based Memory Management in Real-Time Java Chandrasekhar Boyapati, Alexandru \nS.alcianu, William Beebee, Jr., Martin Rinard MIT Laboratory for Computer Science 200 Technology Square, \nCambridge, MA 02139 {chandra,salcianu,wbeebee,rinard}@lcs.mit.edu Abstract The Real-Time Speci.cation \nfor Java (RTSJ) allows a pro\u00adgram to create real-time threads with hard real-time con\u00adstraints. Real-time \nthreads use region-based memoryman\u00adagement to avoid unbounded pauses caused byinterference from the garbage \ncollector. The RTSJ uses runtime checks to ensure that deleting a region does not create dangling ref\u00aderences \nand that real-time threads do not access references to objects allocated in the garbage-collected heap. \nThis pa\u00adper presents a static type system that guarantees that these runtime checks will never fail for \nwell-typed programs. Our type system therefore 1) provides an important safety guar\u00adantee for real-time \nprograms and 2) makes it possible to eliminate the runtime checks and their associated overhead. Our \nsystem also makes several contributions over previ\u00adous work on region types. For object-oriented programs, \nit combines the bene.ts of region types and ownership types in a uni.ed type system framework. For multithreaded \npro\u00adgrams, it allows long-lived threads to share objects without using the heap and without memoryleaks. \nFor real-time programs, it ensures that real-time threads do not interfere with the garbage collector. \nOur experience indicates that our type system is su.ciently expressive and requires lit\u00adtle programming \noverhead, and that eliminating the RTSJ runtime checks using a static type system can signi.cantly decrease \nthe execution time of real-time programs. Categories and Subject Descriptors D.3.3 [Programming Languages]: \nLanguage Constructs; D.2.4 [Software Engineering]: Program Veri.cation; C.3 [Special-Purpose Systems]: \nReal-time Systems  General Terms Languages, Veri.cation, Theory This research was supported by DARPA/AFRL \nContract F33615\u00ad00-C-1692, NSF Grant CCR-0086154, NSF Grant CCR-0073513, NSF Grant CCR-0209075, and the \nSingapore-MIT Alliance. Permission to make digital or hard copies of all or part of this work for personal \nor classroom use is granted without fee provided that copies are not made or distributed for pro.t or \ncommercial advantage and that copies bear this notice and the full citation on the .rst page. To copy \notherwise, to republish, to post on servers or to redistribute to lists, requires prior speci.c permission \nand/or a fee. PLDI 03, June 9 11, 2003, San Diego, California, USA. Copyright 2003 ACM 1-58113-662-5/03/0006 \n...$5.00.  Keywords Ownership Types, Regions, Encapsulation, Real-Time 1. Introduction The Real-Time \nSpeci.cation for Java (RTSJ) [8] provides a framework for building real-time systems. The RTSJ al\u00adlows \na program to create real-time threads with hard real\u00adtime constraints. These real-time threads cannot \nuse the garbage-collected heap because theycannot a.ord to be in\u00adterrupted for unbounded amounts of time \nbythe garbage collector. Instead, the RTSJ allows these threads to use ob\u00adjects allocated in immortal \nmemory(which is never garbage collected) or in regions [42]. Region-based memorymanage\u00adment systems structure \nmemory by grouping objects in re\u00adgions under program control. Memoryis reclaimed bydelet\u00ading regions, \nfreeing all objects stored therein. The RTSJ uses runtime checks to ensure that deleting a region does \nnot create dangling references and that real-time threads do not access heap references. This paper presents \na static type system for writing real\u00adtime programs in Java. Our system guarantees that the RTSJ runtime \nchecks will never fail for well-typed programs. Our system thus serves as a front-end for the RTSJ platform. \nIt o.ers two advantages to real-time programmers. First, it provides an important safetyguarantee that \na program will never fail because of a failed RTSJ runtime check. Second, it allows RTSJ implementations \nto remove the RTSJ runtime checks and eliminate the associated overhead. Our approach is applicable even \noutside the RTSJ context; it could be adapted to provide safe region-based memory management for other \nreal-time languages as well. Our system makes several important technical contribu\u00adtions over previous \ntype systems for region-based memory management. For object-oriented programs, it combines re\u00adgion types \n[16, 23, 34, 42] and ownership types [10, 11, 14, 18, 19] in a uni.ed type system framework. Region types \nstaticallyensure that programs never follow dangling refer\u00adences. Ownership types statically enforce \nobject encapsula\u00adtion and enable modular reasoning about program correct\u00adness in object-oriented programs. \nConsider, for example, a Stack object s that is imple\u00admented using a Vector subobject v. To reason locallyabout \nthe correctness of the Stack implementation, a programmer must know that v is not directlyaccessed byobjects \noutside s. With ownership types, a programmer can declare that s owns v. The type system then statically \nensures that v is encapsulated within s. In an object-oriented language that onlyhas region types (e.g., \n[16]), the types of s and v would declare that theyare allocated in some region r. In an object-oriented \nlanguage that only has ownership types, the type of v would declare that it is owned by s. Our type system \nprovides a simple uni.ed mechanism to declare both properties. The type of s can declare that it is allocated \nin r and the type of v can declare that it is owned by s. Our system then statically ensures that both \nobjects are allocated in r, that there are no pointers to v and s after r is deleted, and that v is en\u00adcapsulated \nwithin s. Our system thus combines the bene.ts of region types and ownership types. Our system extends \nregion types to multithreaded pro\u00adgrams byallowing explicit memorymanagement for objects shared between \nthreads. It allows threads to communicate through objects in shared regions in addition to the heap. \nA shared region is deleted when all threads exit the region. However, programs in a system with only \nshared regions (e.g., [33]) will have memoryleaks if two long-lived threads communicate bycreating objects \nin a shared region. This is because the objects will not be deleted until both threads exit the shared \nregion. To solve this problem, we introduce the notion of subregions within a shared region. A subregion \ncan be deleted more frequently, for example, after each loop iteration in the long-lived threads. Our \nsystem also introduces typed portal .elds in subre\u00adgions to serve as a starting point for inter-thread \ncommuni\u00adcation. Portals also allow typed communication, so threads do not have to downcast from Object \nto more speci.c types. Our approach therefore avoids any dynamic type errors as\u00adsociated with these downcasts. \nOur system introduces user\u00adde.ned region kinds to support subregions and portal .elds. Our system extends \nregion types to real-time programs bystaticallyensuring that real-time threads do not inter\u00adfere with \nthe garbage collector. Our system augments re\u00adgion kind declarations with region policy declarations. \nIt supports two policies for creating regions as in the RTSJ. A region can be an LT (Linear Time) region, \nor a VT (Vari\u00adable Time) region. Memoryfor an LT region is preallocated at region creation time, so allocating \nan object in an LT region onlytakes time proportional to the size of the object (because all the bytes \nhave to be zeroed). Memory for a VT region is allocated on demand, so allocating an object in a VT region \ntakes variable time. Our system checks that real\u00adtime threads do not use heap references, create new \nregions, or allocate objects in VT regions. Our system also prevents an RTSJ priority inversion prob\u00adlem. \nIn the RTSJ, anythread entering a region waits if there are threads exiting the region. If a regular \nthread exiting a region is suspended bythe garbage collector, then a real\u00adtime thread entering the region \nmight have to wait for an unbounded amount of time. Our type system statically en\u00adsures that this priorityinversion \nproblem cannot happen. Finally, we note that ownership-based type systems have also been used for preventing \ndata races [14] and dead\u00adlocks [10], for supporting modular software upgrades in per\u00adsistent object stores \n[13], for modular speci.cation of e.ects clauses in the presence of subtyping [11, 14] (so they can be \nused as an alternative to data groups [36]), and for program understanding [3]. We are currently unifying \nthe type sys\u00adtem presented in this paper with the above type systems [9]. The uni.ed ownership type system \nrequires little program\u00adming overhead, its typechecking is fast and scalable, and it provides several \nbene.ts. The uni.ed ownership type system thus o.ers a promising approach for making object-oriented \nprograms more reliable. Contributions To summarize, this paper makes the following contributions: Region \ntypes for object-oriented programs: Our system combines region types and ownership types in a uni.ed \ntype system framework that statically enforces object encapsulation as well as enables safe region\u00adbased \nmemorymanagement.  Region types for multithreaded programs: Our system introduces 1) subregions within \na shared region, so that long-lived threads can share objects without using the heap and without memoryleaks \nand 2) typed portal .elds to serve as a starting point for typed inter\u00adthread communication. It also \nintroduces user-de.ned region kinds to support subregions and portals.  Region types for real-time programs: \nOur system allows programs to create LT (Linear Time) and VT (Variable Time) regions as in the RTSJ. \nIt checks that real-time threads do not use heap references, create new regions, or allocate objects \nin VT regions, so that theydo not wait for unbounded amounts of time. It also prevents an RTSJ priority \ninversion problem.  Type inference: Our system uses a combination of intra-procedural type inference \nand well-chosen de\u00adfaults to signi.cantlyreduce programming overhead. Our approach permits separate compilation. \n Experience: We have implemented several programs in our system. Our experience indicates that our type \nsystem is su.ciently expressive and requires little pro\u00adgramming overhead. We also ran the programs on \nour RTSJ platform [6, 7]. Our experiments show that elim\u00adinating the RTSJ runtime checks using a static \ntype system can signi.cantly speed-up programs.  The paper is organized as follows. Section 2 describes \nour type system. Section 3 describes our experimental results. Section 4 presents related work. Section \n5 concludes.  2. Type System This section presents our type system for safe region-based memorymanagement. \nSections 2.1, 2.2, and 2.3 describe our type system. Section 2.4 presents some of the important rules \nfor typechecking. The complete set of rules are in the Appendix. Section 2.5 describes type inference \ntechniques. Section 2.6 describes how programs written in our system are translated to run on our RTSJ \nplatform. 2.1 Regions for Object-Oriented Programs This section presents our type system for safe region-based \nmemorymanagement in single-threaded object-oriented pro\u00adgrams. It combines the bene.ts of region types \n[16, 23, 34, 42] and ownership types [10, 11, 14, 18, 19]. Region types staticallyensure that programs \nusing region-based mem\u00adorymanagement are memory-safe, that is, theynever fol\u00adlow dangling references. \nOwnership types statically enforce O1. The ownership relation forms a forest of trees. O2. If region \nr Co object x,then x is allocated in r. O3. If object z Co y but z Co x,then x cannot access y. Figure \n1: Ownership Properties R1. For anyregion r, heap C r and immortal C r. R2. x Co y =. x C y. R3. If region \nr1 Co object o1,region r2 Co object o2,and r2 cannot contain a pointer to o2. C r1,then o1 Figure 2: \nOutlives Properties object encapsulation. The idea is that an object can own subobjects that it depends \non, thus preventing them from being accessible outside. (An object x depends on [35, 11] subobject y \nif x calls methods of y and furthermore these calls expose mutable behavior of y in a waythat a.ects \nthe invariants of x.) Object encapsulation enables local reason\u00ading about program correctness in object-oriented \nprograms. Ownership Relation Objects in our system are allocated in regions. Everyobject has an owner. \nAn object can be owned byanother object, or bya region. We write o1 Co o2 if o1 directlyor transitivelyowns \no2 or if o1 is thesameas o2.The relation Co is thus the re.exive transitive closure of the owns relation. \nOur type system statically guarantees the properties in Figure 1. O1 states that our ownership relation \nhasno cycles. O2statesthat ifanobject isowned by a region, then that object and all its subobjects are \nallocated in that region. O3 states the encapsulation propertyof our system, that if y is inside the \nencapsulation boundaryof z and x is outside, then x cannot access y. 1 (An object x accesses an object \ny if x has a pointer to y, or methods of x obtain a pointer to y.) Figure 6 shows an example ownership \nrelation. We draw a solid line from x to y if x owns y.Region r2 owns s1, s1 owns s1.head and s1.head.next,etc. \nOutlives Relation Our system allows programs to create regions. It also provides two special regions: \nthe garbage collected region heap, and the immortal region immortal. The lifetime of a region is the \ntime interval from when the region is created until it is deleted. If the lifetime of a region r1 includes \nthe lifetime of region r2,wesaythat r1 outlives r2,and write r1 C r2.The relation C is thus re.exive \nand transitive. We extend the outlives relation to include ob\u00adjects. We de.ne that x Co y implies x C \ny. The extension is natural: if object o1 owns object o2 then o1 outlives o2 because o2 is accessible \nonlythrough o1. Also, if region r owns object o then r outlives o because o is allocated in r. Our outlives \nrelation has the properties shown in Figure 2. R1 states that heap and immortal outlive all regions. \nR2 states that the outlives relation includes the ownership re\u00adlation. R3 states our memorysafetyproperty, \nthat if object o1 in region r1 contains a pointer to object o2 in region r2, then r2 outlives r1. R3 \nimplies that there are no dangling references in our system. Figure 6 shows an example outlives relation. \nWe draw a dashed line from region x to region y if x outlives y. In the example, region r1 outlives region \nr2, 1 Our system handles inner class objects specially to support constructs like iterators. Details \ncan be found in [11]. P ::= def * e def ::= class cn(formal +)extends c where constr * {.eld * meth * \n} formal ::= kfn c ::= cn (owner +)|Object(owner ) owner ::= fn |r |this |initialRegion |heap |immortal \n.eld ::= t fd * meth ::= t mn(formal *)((t p) * ) where constr {e } constr ::= owner owns owner |owner \noutlives owner t ::= c |int |RHandle(r) k ::= Owner |ObjOwner |rkind rkind ::= Region |GCRegion |NoGCRegion \n|LocalRegion e ::= v |let v = e in {e }|v.fd |v.fd = v |new c |*) * v.mn(owner (v ) |(RHandle(r)h) {e \n}h ::= v cn . class names fd . .eld names mn . method names fn . formal identi.ers v, p . variable names \nr . region identi.ers Figure 3: Grammar for Object Oriented Programs Owner  ObjOwner Region NoGCRegion \nGCRegion  LocalRegion SharedRegion user defined region kinds Figure 4: Owner Kind Hierarchy: Section \n2.1uses only Area 1. Sections 2.2 &#38; 2.3 use Areas 1 &#38; 2. and heap and immortal outlive all regions. \nThe following lemmas follow triviallyfrom the above de.nitions: Lemma 1. If object o1 C object o2,then \no1 Co o2. Lemma 2. If region r C object o, then there exists a unique region r such that r C r' and r' \nCo o. Grammar To simplifythe presentation of keyideas behind our approach, we describe our type system \nformally in the context of a core subset of Java known as Classic Java [28]. Our approach, however, extends \nto the whole of Java and other similar languages. Figure 3 presents the grammar for our core language. \nA program consists of a series of class declarations followed byan initial expression. A prede.ned class \nObject is the root of the class hierarchy. Owner Polymorphism Everyclass de.nition is parame\u00adterized \nwith one or more owners. (This is similar to para\u00admetric polymorphism [1, 15, 38] except that our parameters \nare values, not types.) An owner can be an object or a re\u00adgion. Parameterization allows programmers to \nimplement a generic class whose objects can have di.erent owners. The .rst formal owner is special: it \nowns the corresponding ob\u00adject; the other owners propagate the ownership information. Methods can also \ndeclare an additional list of formal owner parameters. Each time new formals are introduced, pro\u00adgrammers \ncan specifyconstraints between them using where clauses [24]. The constraints have the form o1 owns o2 \n (i.e., o1 Co o2)and o1 outlives o2 (i.e., o1 C o2). Each formal has an owner kind. There is a subkinding \nrelation between owner kinds, resulting in the kind hier\u00adarchyfrom the upper half of Figure 4. The hierarchyis \nrooted in Owner, that has two subkinds: ObjOwner (owners that are objects; we avoid using Object because \nit is al\u00adreadyused for the root of the class hierarchy) and Region. Region has two subkinds: GCRegion \n(the kind of the garbage collected heap) and NoGCRegion (the kind of other regions). Finally, NoGCRegion \nhas a single subkind, LocalRegion.(At this point, there is no distinction between NoGCRegion and LocalRegion. \nWe will add new kinds in the next section.) Region Creation The expression (RHandle(r) h) {e} creates \na new region and introduces two identi.ers r and h that are visible inside the scope of e. r is an owner \nof kind LocalRegion that is bound to the newlycreated region. h is a runtime value of type RHandle(r)that \nis bound to the handle of the region r. The region name r is onlya compile\u00adtime entity; it is erased \n(together with all the ownership and region type annotations) immediately after typecheck\u00ading. However, \nthe region handle h is required at runtime when we allocate objects in region r (object allocation is \nexplained in the next paragraph). The newlycreated region is outlived byall regions that existed when \nit was created; it is destroyed at the end of the scope of e. Thisimpliesa last in .rst out order on \nregion lifetimes. As we mentioned before, in addition to the user created regions, we have spe\u00adcial regions: \nthe garbage collected region heap (with handle h heap) and the immortal region immortal (with handle \nh immortal). Objects allocated in the immortal region are never deallocated. heap and immortal are never \ndestroyed; hence, theyoutlive all regions. We also allow methods to allocate objects in the special region \ninitialRegion,which denotes the most recent region that was created before the method was called. We \nuse runtime support to acquire the handle of initialRegion. Object Creation New objects are created using \nthe ex\u00adpression new cn (o1..n) . o1 is the owner of the new object. (Recall that the .rst owner parameter \nalways owns the cor\u00adresponding object.) If o1 is a region, the new object is allo\u00adcated there; otherwise, \nit is allocated in the region where the object o1 is allocated. For the purpose of typechecking, re\u00adgion \nhandles are unnecessary. However, at runtime, we need the handle of the region we allocate in. The typechecker \nchecks that we can obtain such a handle (more details are in Section 2.4). If o1 is a region r, the handle \nof r must be in the environment. Therefore, if a method has to allocate memoryin a speci.c region that \nis passed to it as an owner parameter, then it also needs to receive the corresponding region handle \nas an argument. A formal owner parameter can be instantiated with an in\u00adscope formal, a region name, \nor the this object. For every type cn (o1..n)with multiple owners, our type system stati\u00adcallyenforces \nthe constraint that oi Co1, for all i .{1..n}. In addition,ifan object oftype cn (o1..n)has a method \nmn , and if a formal owner parameter of mn is instantiated with an object obj , then our system ensures \nthat obj Co1.These restrictions enable the type system to statically enforce ob\u00adject encapsulation and \nprevent dangling references. Example We illustrate our type system with the exam\u00adple in Figure 5. A TStack \nis a stack of T objects. It is implemented using a linked list. The TStack class is param\u00adeterized by \nstackOwner and TOwner. stackOwner owns the TStack object and TOwner owns the T objects contained in the \nTStack. The code speci.es that the TStack object owns 1 class TStack<Owner stackOwner, Owner TOwner> \n{ 2 TNode<this, TOwner> head = null; 3 4 void push(T<TOwner> value) { 5 TNode<this, TOwner> newNode = \nnew TNode<this, TOwner>; 6 newNode.init(value, head); head = newNode; 7 } 8 9 T<TOwner> pop() { 10 if(head \n== null) return null; 11 T<TOwner> value = head.value; head = head.next; 12 return value; 13 } 14 } 15 \n16 class TNode<Owner nodeOwner, Owner TOwner> { 17 T<TOwner> value; 18 TNode<nodeOwner, TOwner> next; \n19 20 void init(T<TOwner> v, TNode<nodeOwner, TOwner> n) { 21 this.value = v; this.next = n; 22 } 23 \n} 24 25 (RHandle<r1> h1) { 26 (RHandle<r2> h2) { 27 TStack<r2, r2> s1; 28 TStack<r2, r1> s2; 29 TStack<r1, \nimmortal> s3; 30 TStack<heap, immortal> s4; 31 TStack<immortal, heap> s5; 32 /* TStack<r1, r2> s6; illegal! \n*/ 33 /* TStack<heap, r1> s7; illegal! */ 34 }} Figure 5: Stack of T Objects  s1.head.value s2.head.value \ns3.head.value (T) (T) (T) s1.head.next.value s2.head.next.value s3.head.next.value (T) (T) (T) Figure \n6: TStack Ownership and Outlives Relations the nodes in the list; therefore the list nodes cannot be \nac\u00adcessed from outside the TStack object. The program creates two regions r1 and r2 such that r1 outlives \nr2. The pro\u00adgram declares several TStack variables: the type of TStack s1 speci.es that it is allocated \nin region r2 and so are the T objects in s1; TStack s2 is allocated in region r2 but the T objects in \ns2 are allocated in region r1;etc. Note that the type of s6 is illegal. This is because s6 is declared \nas TStack(r1,r2),and r2 Cr1. (Recall that in anylegal type cn (o1..n)with multiple owners, oi Co1 for \nall i .{1..n}.) Figure 6 presents the ownership and the outlives relations from this example (assuming \nthe stacks contain two elements each). We use circles for objects, rectangles for regions, solid arrows \nfor ownership, and dashed arrows for the outlives re\u00adlation between regions. Safety Guarantees The following \ntwo theorems state our safetyguarantees. Part 1 of Theorems 3 and 4 state the object encapsulation property. \nNote that objects owned by regions are not encapsulated within other objects. Part 2 of Theorem 3 states \nthe memorysafetyproperty. Theorem 3. If objects o1 and o2 are allocated in regions r1 and r2 respectively, \nand .eld fd of o1 points to o2,then 1. Either owner of o2 Co o1,orowner of o2 is a region. 2. Region \nr2 outlives region r1.  Proof. Suppose class cn(f1..n){... T (x1, ...) fd ...} is the class of o1. Field \nfd of type T (x1, ...) contains a reference to o2. x1 must therefore own o2. x1 can be either 1) heap, \nor 2) immortal,or 3) this,or 4) fi, a class formal. In the .rst two cases, (owner of o2)= x1 is a region, \nand r2 = x1 C r1.In Case 3, (owner of o2)= o1 Co o1,and r2 = r1 C r1. In Case4,weknow that fi C f1,since \nallownersin a legal type outlive the .rst owner. Therefore, (owner of o2) = x1 = fi C f1 C this = o1.If \n(owner of o2)is an object, we know from Lemma 1 that (owner of o2) Co o1.This also implies that r2 = \nr1 C r1.If the (owner of o2) is a region, we know from Lemma 2 that there exists region r such that (owner \nof o2) C r and r Co o1. Therefore r2 = r C r1. Theorem 4. If a variable v in a method mn of an object \no1 points to an object o2,then 1. Either owner of o2 Co o1,orowner of o2 is a region. Proof. Similar \nto the proof of Theorem 3, except that now we have a .fth possibilityfor the (owner of o2): a formal \nmethod parameter that is a region or initialRegion (that are not required to outlive o1). In this case, \n(owner of o2)is a region. The other four cases are identical. Most previous region type systems allow \nprograms to cre\u00adate, but not follow, dangling references. Such references can cause a safetyproblem when \nused with copying collec\u00adtors. Our system therefore prevents a program from creating dangling references \nin the .rst place. Part 2 of Theorem 3 prevents object .elds from containing dangling references. Even \nthough Theorem 4 does not have a similar Part 2, we can prove, using lexical scoping of region names, \nthat local variables cannot contain dangling references either. 2.2 Regions for Multithreaded Programs \nThis section describes how we support multithreaded pro\u00adgrams. Figure 7 presents the language extensions. \nA fork instruction spawns a new thread that evaluates the invoked method. The evaluation is performed \nonlyfor its e.ect; the parent thread does not wait for the completion of the new thread and does not \nuse the result of the method call. Our unstructured concurrencymodel (similar to Java s model) is incompatible \nwith the regions from Section 2.1 whose life\u00adtimes are lexicallybound. Those regions can still be used \nfor allocating thread-local objects (hence the name of the associ\u00adated region kind, LocalRegion), but \nobjects shared bymul\u00adtiple threads require shared regions, of kind SharedRegion. Shared Regions (RHandle(rkind \nr) h) {e} creates a shared region (rkind speci.es the region kind of r;region kinds are explained later \nin this section). Inside expression e, the identi.ers r and h are bound to the region and the region \nhandle, respectively. Inside e, r and h can be passed to child threads. The objects allocated inside \na shared re\u00adgion are not deleted as long as some thread can still ac\u00adcess them. To ensure this, each \nthread maintains a stack of shared regions it can access, and each shared region main\u00adtains a counter \nof how manysuch stacks it is an element of. When a new shared region is created, it is pushed onto the \nP ::= def * srkdef * e srkdef ::= regionKind srkn (formal * ) extends srkind ** * where constr { .eld \nsubsreg }rkind ::= ... as in Figure 3 ... |srkind srkind ::= srkn (owner * )|SharedRegion subsreg ::= \nsrkind rsub e ::= ... as in Figure 3 ... | * fork v.mn(owner * )(v ) |(RHandle(rkind r) h) {e }|(RHandle(r) \nh = [new]opt h.rsub ) { e }|h.fd |h.fd = v srkn . shared region kind names rsub . shared subregion names \nFigure 7: Extensions for Multithreaded Programs region stack of the current thread and its counter is \ninitial\u00adized to one. A child thread inherits all the shared regions of its parent thread; the counters \nof these regions are incre\u00admented when the child thread is forked. When the scope of a region name ends \n(the names of the shared regions are still lexicallyscoped, even if the lifetimes of the regions are \nnot), the corresponding region is popped o. the stack and its counter is decremented. When a thread terminates, \nthe counters of all the regions from its stack are decremented. When the counter of a region becomes \nzero, the region is deleted. The typing rule for a fork expression checks that objects allocated in local \nregions are not passed to the child thread as arguments; it also checks that local regions and handles \nto local regions are not passed to the child thread. Subregions and Portals Shared regions provide the \nbasis for inter-thread communication. However, in manycases, theyare not enough. E.g., consider two long-lived \nthreads, a producer and a consumer, that communicate through a shared region in a repetitive way. In \neach iteration, the producer allocates some objects in the shared region and the consumer subsequentlyuses \nthe objects. These objects become unreachable after each iteration. However, these objects are not deleted \nuntil both threads terminate and exit the shared region. To prevent this memoryleak, we allow shared \nregions to have subregions. In each iteration, the producer and the consumer can enter a subregion of \nthe shared region and use it for communication. At the end of the iteration, both the threads exit the \nsubregion and the reference count of the subregion goes to zero the objects in the subregion are thus \ndeleted after each iteration. We must also allow the producer to pass references to ob\u00adjects it allocates \nin the subregion in each iteration to the consumer. Note that storing the references in the .elds of \na hook object is not possible: objects allocated outside the subregion cannot point to objects in the \nsubregion (oth\u00aderwise, those references would result in dangling references when objects in the subregion \nare deleted), and objects al\u00adlocated in the subregion do not survive between iterations and hence cannot \nbe used as hooks . To solve this prob\u00adlem, we allow (sub)regions to contain portal .elds. A thread can \nstore the reference to an object in a portal .eld; other threads can then read the portal .eld to obtain \nthe reference. Region Kinds In practice, programs can declare several shared region kinds. Each such \nkind extends another shared region kind and can declare several portal .elds and subre\u00adgions (see grammar \nrule for srkdef in Figure 7). The result\u00ading shared region kind hierarchyhas SharedRegion as its root. \nThe owner kind hierarchynow includes both Areas 1 and 2 from Figure 4. Similar to classes, shared region \nkinds 1 regionKind BufferRegion extends SharedRegion { 2 BufferSubRegion b; 3} 4 5 regionKind BufferSubRegion \nextends SharedRegion { 6 Frame<this> f; 7} 8 9 class Producer<BufferRegion r> { 10 void run(RHandle<r> \nh) { 11 while(true) { 12 (RHandle<BufferSubRegion r2> h2 = h.b) { 13 Frame<r2> frame = new Frame<r2>; \n14 get_image(frame); 15 h2.f = frame; 16 } 17 ... // wake up the consumer 18 ... // wait for the consumer \n19 }}} 20 21 class Consumer<BufferRegion r> { 22 void run(RHandle<r> h) { 23 while(true) { 24 ... // \nwait for the producer 25 (RHandle<BufferSubRegion r2> h2 = h.b) { 26 Frame<r2> frame = h2.f; 27 h2.f \n= null; 28 process_image(frame); 29 } 30 ... // wake up the producer 31 }}} 32 33 (RHandle<BufferRegion \nr> h) { 34 fork (new Producer<r>).run(h); 35 fork (new Consumer<r>).run(h); 36 } Figure 8: Producer \nConsumer Example can be parameterized with owners; however, unlike objects, regions do not have owners \nso there is no special meaning attached to the .rst owner. Expression (RHandle(r2) h2 = [new]opt h1.rsub \n) {e} evaluates e in an environment where r2 is bound to the sub\u00adregion rsub of the region r1 that h1 \nis thehandleof, and h2 is bound to the handle of r2. In addition, if the keyword new is present, r2 is \na newlycreated subregion, distinct from the previous rsub subregion. If h is thehandleof region r, the \nexpression h.fd reads r s portal .eld fd ,and h.fd = v storesa value into that .eld. The rule for portal \n.elds is the same as that for object .elds: a portal .eld of a region r is either null or points to an \nobject allocated in r or in a region that outlives r. Flushing Subregions When all the objects in a subregion \nbecome inaccessible, the subregion is .ushed, i.e., all objects allocated inside it are deleted. We do \nnot .ush a subregion if its counter is positive. Furthermore, we do not .ush a subregion r if anyof its \nportal .elds is non-null (to allow some thread to enter it later and use those objects) or if anyof r \ns subregions has not been .ushed yet (because the objects in those subregions might point to objects \nin r). Recall that subregions are a wayof packaging some data and sending it to another thread; the receiver \nthread looks inside the subregion (starting from the portal .elds) and uses the data. Therefore, as long \nas a subregion with non\u00adnull portal .elds is reachable (i.e., a thread mayobtain its handle), the objects \nallocated inside it can be reachable even if no thread is currentlyin the subregion. Example Figure 8 \ncontains an example that illustrates the use of subregions and portal .elds. The main thread cre\u00adates \na shared region of kind BufferRegion andthenstarts * meth ::= t mn(formal * )((t p) * ) e.ects where \nconstr {e} * e.ects ::= accesses owner owner ::= ... as in Figure 3 ... |RT subsreg ::= srkind : rpol \ntt rsub rpol ::= LT(size) |VT tt ::= RT |NoRT k ::= ... as in Figure 3 ... |rkind : LT e ::= ... as \nin Figure 7 ... | (RHandle(rkind : rpol r) h) {e }| * RT fork v.mn(owner * )(v ) Figure 9: Extensions \nfor Real-Time Programs two threads, a producer and a consumer, that communicate through the shared region. \nIn each iteration, the producer enters subregion b (of kind BufferSubRegion), allocates a Frame object \nin it, and stores a reference to the frame in subregion s portal .eld f. Next, the producer exits the \nsub\u00adregion and waits for the consumer. The subregion is not .ushed because the portal .eld f is non-null. \nThe consumer then enters the subregion, uses the frame object pointed to byits portal .eld f,sets f to \nnull, and exits the subregion. Now, the subregion is .ushed (because its counter is zero and all its \n.elds are null) and a new iteration starts. In this paper, we do not discuss synchronization issues; \nwe assume synchronization primitives similar to those in Java. 2.3 Regions for Real-Time Programs A \nreal-time program consists of a set of real-time threads, a set of regular threads, and a special garbage \ncollector thread. (This is a conceptual model; actual implementa\u00adtions might di.er.) A real-time thread \nhas strict deadlines for completing its tasks.2 Figure 9 presents the language extensions to support \nreal-time programs. The expression RT fork v.mn (owner * )(v * ) spawns a new real-time thread to evaluate \nmn . Such a thread cannot a.ord to be interrupted for an unbounded amount of time bythe garbage collector \nthe rest of this section explains how our type system statically ensures this property. E.ects The garbage \ncollector thread must synchronize with anythread that creates or destroys heap roots, i.e., references \nto heap objects, otherwise it might end up collect\u00ading reachable objects. Therefore, we must ensure that \nthe real-time threads do not read or overwrite references to heap objects. (The last restriction is needed \nto support copying collectors.) To staticallycheck this, we allow methods to declare e.ects clauses [37]. \nIn our system, the e.ects clause of a method lists the owners (some of them regions) that the method \naccesses. Accessing a region means allocating an object in that region. Accessing an object means read\u00ading \nor overwriting a reference to that object or allocating another object owned bythat object. Note that \nwe do not consider reading or writing a .eld of an object as accessing that object. If a method s e.ects \nclause consists of owners o1..n, then anyobject or region accessed bythat method, the methods it invokes, \nand the threads it spawns (transitively) is guaranteed to be outlived by oi,for some i .{1..n}. The typing \nrule for an RT fork expression checks all the constraints of a regular fork expression. In addition, \nit checks that references to heap objects are not passed as arguments to the new thread, and that the \ne.ects clause 2Our terminologyis related, but not identical to the RTSJ terminology. E.g., our real-time \nthreads are similar to (and more restrictive than) the RTSJ NoHeapRealtimeThread s. of the method evaluated \nin the new thread does not contain the heap region or anyobject allocated in the heap region. If an RT \nfork expression typechecks, the new real-time cannot receive anyheap reference. Furthermore, it cannot \ncreate a heap object, or read or overwrite a heap reference in an object .eld the type system ensures \nthat in each of the above cases, the heap region or an object allocated in the heap region appears in \nthe method e.ects. Region Allocation Policies A real-time thread cannot create an object if this operation \nrequires allocating new memory, because allocating memory requires synchroniza\u00adtion with the garbage \ncollector. A real-time thread can, however, create an object in a preallocated memoryregion. Our system \nsupports two allocation policies for regions. One policyis to allocate memoryon demand (potentiallyin \nlarge chunks), as new objects are created in the region. Al\u00adlocating a new object can take unbounded \ntime or might not even succeed (if a new chunk is needed and the system runs out of memory). Flushing \nthe region frees all the memory allocated for that region. Following the RTSJ terminology, we call such \nregions VT (Variable Time) regions. The other policyis to allocate all the memoryfor a region at region \ncreation time. The programmer must provide an upper bound for the total size of the objects that will \nbe al\u00adlocated in the region. Allocating an object requires sliding a pointer if the region is alreadyfull, \nthe system throws an exception to signal that the region size was too small. Allocating a new object \ntakes time linear in its size: sliding the pointer takes constant time, but we also have to set to zero \neach allocated byte. Flushing the region simply resets a pointer, and, importantly, does not free the \nmemoryallo\u00adcated for the region. We call regions that use this allocation policy LT (Linear Time) regions. \nOnce we have an LT sub\u00adregion, threads can repeatedlyenter it, allocate objects in it, exit it (thus \n.ushing it), and re-enter it without having to allocate new memory. This is possible because .ushing \nan LT region does not free its memory. LT subregions are thus ideal for real-time threads: once such \na subregion is created (with a large enough upper bound), all object cre\u00adations will succeed, in linear \ntime; moreover, the subregion can be .ushed and reused without memoryallocation. We allow users to specifythe \nregion allocation policy(LT or VT) when a new region is created. The policyfor sub\u00adregions is declared \nin the shared region kind declarations. When a user speci.es an LT policy, the user also has to specifythe \nsize of the region (in bytes). An expression (RHandle(rkind : rpol r) h) {e} creates a region with al\u00adlocation \npolicy rpol and allocates memoryfor all its (transi\u00adtive) LT (sub)regions (including itself). Our system \nchecks that a region has a .nite number of transitive subregions. If a method enters a VT region or a \ntop level region (i.e., a region that is not a subregion), the typechecker en\u00adsures that the method contains \nthe heap region in its e.ects clause. This is to prevent real-time threads from invoking such methods. \nHowever, a method that does not contain the heap region in its e.ects clause can still enter an existing \nLT subregion, because no memoryis allocated in that case. Preventing the RTSJ Priority Inversion So far, \nwe presented techniques for checking that real-time threads do not create or destroyheap references, \ncreate new regions, or allocate objects in VT regions. However, there are two other subtle ways a thread \ncan interact with the garbage collector. First, the garbage collector needs to know all locations that \nrefer to heap objects, including locations that are in\u00adside regions. Suppose a real-time thread uses \nan LT region that contains such heap references (created bya non-real\u00adtime thread). The real-time thread \ncan .ush the region (by exiting it) thus destroying any heap reference that existed in the region. If \nwe use a copying garbage collector, the real-time thread has to interact with the garbage collector to \ninform it about the destruction of those heap references. Therefore, we should prevent regions that can \nbe .ushed by a real-time thread from containing anyheap reference (even if the reference is not explicitlyread \nor overwritten bythe real-time thread). Note that this restriction is relevant only for subregions: a \nreal-time thread cannot create a top-level region and hence cannot .ush a top-level region either. Second, \nwhen a thread enters or exits a subregion, it needs to do some bookkeeping. To preserve the integrityof \nthe runtime region implementation, some synchronization is necessaryduring this bookkeeping. E.g., when \na thread exits a subregion, the test that the subregion can be .ushed and the actual .ushing have to \nbe executed atomically, without allowing anythread to enter the subregion in between . If a regular thread \nexiting a subregion is suspended bythe garbage collector, then a real-time thread entering the sub\u00adregion \nmight have to wait for an unbounded amount of time. This priority inversion problem occurs even in the \nRTSJ. To prevent these subtle interactions, we impose the re\u00adstriction that real-time threads and regular \nthreads cannot share subregions. Subregions used byreal-time threads thus cannot contain heap references, \nand real-time threads never have to wait for unbounded amounts of time. For each subregion, programmers \nspecifyin the region kind de.nitions whether the subregion will be used onlyby real-time threads (RT \nsubregions) or onlybyregular threads (NoRT subregions). Note that real-time and regular threads can still \ncommunicate using top-level regions. Anymethod that enters an RT subregion must contain the special e.ect \nRT in its e.ects clause. Anymethod that enters a NoRT subregion must contain the heap region in its e.ects \nclause. The type system checks that no regular thread can invoke a method that has an RT e.ect, and no \nreal-time thread can invoke a method that has a heap e.ect. 2.4 Rules for Typechecking Previous sections \npresented the grammar for our core lan\u00adguage in Figures 3, 7, and 9. This section presents some sample \ntyping rules. The Appendix contains all the rules. The core of our type system is a set of typing judgments \nof the form P; E; X; rcr fe : t. P, the program being checked, is included to provide information about \nclass de.nitions. The typing environment E provides information about the type of the free variables \nof e (t v, i.e., variable v has type t), the kind of the owners currentlyin scope (k o, i.e., owner o \nhas kind k), and the two relations between owners: the ownership relation (o2 Co o1, i.e., o2 owns o1)and \nthe outlives relation (o2 Co1, i.e., o2 outlives o1). More formally, E ::= \u00d8|E, t v |E, k o |E, o2 Co \no1 |E, o2 Co1. rcr is the current region. X must subsume the e.ects of e. t is the type of the expression \ne. A useful auxiliaryrule is E fX1 CX2, i.e., the e.ects X1 subsume the e.ects X2: .o .X2, .g .X1,s.t. \ng Co.To prove constraints of the form g Co, g Co o etc. in a speci.c environment E, the checker uses \nthe constraints from E, and the properties of C and Co: transitivity, re.exivity, Co implies C, and the \nfact that the .rst owner from the type of an object owns the object. The expression (RHandle(r) h) {e} \ncreates a local re\u00adgion and evaluates e in an environment where r and h are bound to the new region and \nits handle respectively. The associated typing rule is presented below: [EXPR LOCAL REGION] E2 = E, LocalRegion \nr, RHandle(r)h, (re >r).re.Regions(E) P fenv E2 P; E2; X, r; r fe : tE fX >heap P; E; X; rcr f(RHandle(r) \nh) {e}: int The rule starts byconstructing an environment E2 that ex\u00adtends the original environment E \nbyrecording that r has kind LocalRegion and h has type RHandle(r).As r is deleted at the end of e, all \nexisting regions outlive it; E2 records this too (Regions(E) denotes the set of all regions from E). \ne should typecheck in the context of the environ\u00adment E2 and the permitted e.ects are X, r (the local \nregion r is a permitted e.ect inside e). Because creating a region requires memoryallocation, X must \nsubsume heap.The ex\u00adpression is evaluated onlyfor its side-e.ects and its result is never used. Hence, \nthe type of the entire expression is int. Therulefor a.eld read expression v.fd .rst .nds the type cn \n(o1..n) for v. Next, it veri.es that fd is a .eld of class cn ;let t be its declared type. The rule obtains \nthe type of the entire expression bysubstituting in t each formal owner parameter fni of cn with the \ncorresponding owner oi: [EXPR REF READ] P; E; X; rcr fv ' : cn(o1..n) P f(t fd ) .cn(fn1..n)t= t[o1/fn1]..[on/fn] \nn ((t' = int) . (t' = cn'(o'). ' E fX >o1')) 1..m P; E; X; rcr fv.fd : t The last line of the rule checks \nthat if the expression reads an object reference (i.e., not an integer), then the list of e.ects X subsumes \nthe owner of the referenced object. For an object allocation expression new cn (o1..n) , the rule .rst \nchecks that class cn is de.ned in P: [EXPR NEW] class cn((ki fni)i.{1..n}) ... where constr1..c ... .P \n.i =1..m, (E fk oi : k'. P fk'=k ki . E f oi >o1) ii .i =1..c, E fconstri[o1/fn1]..[om/fn ] m E fX >o1 \nE fav RH(o1) P; E; X; rcr fnew cn(o1..n): cn(o1..n) Next, it checks that each formal owner parameter \nfni of cn is instantiated with an owner oi of appropriate kind, i.e., the kind ki ' of oi is a subkind \nof the declared kind ki of fni.It also checks that in E,each owner oi outlives the .rst owner o1, and \neach constraint of cn is satis.ed. Allocating an object meansaccessing itsowner; therefore, X must subsume \no1. The new object is allocated in the region o1 (if o1 is a region) or in the region that o1 is allocated \nin (if o1 is an object). The last part of the precondition, E fav RH(o1), checks that the handle for \nthis region is available. To prove facts of this kind, the type system uses the following rules: [AV \nHANDLE] [AV THIS] E = E1, RHandle(r)h, E2 E fav RH(r) E fav RH(this) [AV TRANS1] [AV TRANS2] E fo1 >o \no2 E fav RH(o2) E f o1 >o o2 E fav RH(o1) E fav RH(o1) E fav RH(o2) The rule [AV HANDLE] looks for a \nregion handle in the envi\u00adronment. The environment always contains handles for heap and immortal; in \naddition, it contains all handle identi.ers that are in scope. The rule [AV THIS] re.ects the fact that \nour runtime is able to .nd the handle of the region where an object (this in particular) is allocated. \nThe last two rules use the fact that all objects are allocated in the same region as their owner. Therefore, \nif o1 Co o2 and the region handle for one of them is available, then the region handle for the other \none is also available. Note that these rules do signif\u00adicant reasoning, thus reducing annotation burden; \ne.g., if a method allocates onlyobjects (transitively) owned bythis, it does not need an explicit region \nhandle argument. We end this section with the typing rule for fork.The rule .rst checks that the method \ncall is well-typed. (see rule [EXPR INVOKE] in Appendix B). Note that mn cannot have the RT e.ect: a \nnon-real-time thread cannot enter a subregion that is reserved onlyfor real-time threads. [EXPR FORK] \nP; E; X \\{RT}; rcr fv0.mn(o(n+1)..m)(v1..u) : t def NonLocal(k)=(P fk =k SharedRegion) . (P fk =k GCRegion) \nE fRKind(rcr)= kcr NonLocal(kcr) P; E; X; rcr fv0 : cn(o1..n) .i =1..m, (E f RKind(oi)= ki . NonLocal(ki)) \n P; E; X; rcr ffork v0.mn()(v1..u) : int o(n+1)..m The rule checks that the new thread does not receive \nanylo\u00adcal region or objects allocated in a local region. It uses the following observation: the onlyowners \nthat appear in the types of the method arguments are: initialRegion, this, the formals for the method \nand the formals for the class the method belongs to. Therefore, the arguments passed to the method mn \nfrom the fork instruction maybe owned only bythe current region at the point of the fork,bythe owners \no1..n that appear in the type of the object v0 points to, or bythe owners o(n+1)..m that appear explicitlyin \nthe fork instruction. For each such owner o, our system uses the rule E f RKind(o)= k to extract the \nkind k of the region it stands for (if it is a region), or of the region it is allocated in (if it is \nan object). The rule next checks that k is a subkind of SharedRegion or GCRegion. The rules for inferring \nstate\u00adments of the form E f RKind(oi)= ki (see Appendix B) are similar to the previouslyexplained rules \nfor checking that a region handle is available. The keyidea theyexploit is that a subobject is allocated \nin the same region as its owner.  2.5 Type Inference Although our type system is explicitly typed in \nprinciple, it would be onerous to fullyannotate everymethod with the extra type information that our \nsystem requires. Instead, we use a combination of type inference and well-chosen defaults to signi.cantlyreduce \nthe number of annotations needed in practice. Our system also supports user-de.ned defaults to cover \nspeci.c patterns that might occur in user code. We emphasize that our approach to inference is purelyintra\u00adprocedural \nand we do not infer method signatures or types of instance variables. Rather, we use a default completion \nof partial type speci.cations in those cases. This approach permits separate compilation. The following \nare some defaults currentlyprovided byour system. If owners of method local variables are not spec\u00adi.ed, \nwe use a simple uni.cation-based approach to infer the owners. The approach is similar to the ones in \n[14, Portal  10]. For parameters unconstrained after uni.cation, we use initialRegion. For unspeci.ed \nowners in method signa\u00adtures, we use initialRegion as the default. For unspeci.ed owners in instance \nvariables, we use the owner of this as the default. For static .elds, we use immortal as the default. \nOur default accesses clauses contain all class and method owner parameters and initialRegion.  2.6 Translation \nto Real-Time Java Although our system provides signi.cant improvements over the RTSJ, programs in our \nlanguage can be translated to RTSJ reasonablyeasily, bylocal translation rules. This is mainlybecause \nwe designed our system so that it can be implemented using type erasure (region handles exist speci.callyfor \nthis purpose). Also, RTSJ has mechanisms that are powerful enough to support our features. RTSJ o.ers \nLTMemory and VTMemory regions where it takes lin\u00adear time and variable time (respectively) to allocate \nobjects. RTSJ regions are Java objects that point to some memory space. In addition, RTSJ has two special \nregions: heap and immortal. A thread can allocate in the current region using new. A thread can also \nallocate in anyregion that it en\u00adtered using newInstance, which requires the corresponding region object. \nRTSJ regions are maintained similarlyto our shared regions, bycounting the number of threads executing \nin them. RTSJ regions have one portal, which is similar to a portal .eld except that its declared type \nis Object.Most of the translation e.ort is focused on providing the missing features: subregions and \nmultiple, typed portal .elds. We discuss the translation of several important features from our type \nsystem; the full translation is discussed in [40]. We represent a region r from our system as an RTSJ \nre\u00adgion m plus two auxiliaryobjects w1 and w2 (see Figure 10). m points to a memoryarea that is pre-allocated \nfor an LT region, or grown on-demand for a VT region. m also points to an object w1 whose .elds point \nto the representation of r s subregions. (We subclass LT/VTMemory to addanextra .eld.) In addition, m \ns portal points to an object w2 that serves as a wrapper for r s portal .elds. w2 is allocated in the \nmemoryspace attached to m, while m and w1 are allocated in the region that was current at the time m \nwas created. The translation of new cn (o1..n) requires a reference to (i.e., the handle of) the region \nwe allocate in. If this is the same as the current region, we use the more e.cient new. The type rules \nalready proved that we can obtain the necessaryhandle, i.e., E fav RH(o1); we presented the relevant \ntype rules in Section 2.4. Those rules pushed the judgment E fav RH(o) up and down the ownership re\u00adlation \nuntil we obtained an owner whose region handle was available: immortal, heap, this, or a region whose \nregion handle was available in a local variable. RTSJ provides   Program Lines of Code Lines Changed \n  Array 56 4 Tree 83 8  Water 1850 31 Barnes 1850 16 ImageRec 567 8 http 603 20 game 97 10 phone \n244 24 Figure 11: Programming Overhead Execution Time (sec) Program Static Dynamic Overhead Checks Checks \n   Array 2.24 16.2 7.23 Tree 4.78 23.1 4.83   Water 2.06 2.55 1.24 Barnes 19.1 21.6 1.13   ImageRec \n6.70 8.10 1.21 load 0.667 0.831 1.25 cross 0.014 0.014 1.0 threshold 0.001 0.001 1 hysteresis 0.005 0.006 \n1 thinning 0.023 0.026 1.1 save 0.617 0.731 1.18 Figure 12: Dynamic Checking Overhead mechanisms for \nretrieving the handle in the .rst three cases: ImmortalArea.instance() , HeapArea.instance() ,and Me\u00adthodArea.getMethodArea(Object), \nrespectively. In the last case, we simplyuse the handle from the local variable.  3. Experience To gain \npreliminaryexperience, we implemented several programs in our system. These include two micro bench\u00admarks \n(Array and Tree), two scienti.c computations (Water and Barnes), several components of an image recognition \npipeline (load, cross, threshold, hysteresis,and thinning), and several simple servers (http, game,and \nphone, a database\u00adbacked information sever). In our implementations, the pri\u00admarydata structures are \nallocated in regions (i.e., not in the garbage collected heap). In each case, once we understood how \nthe program worked and decided on the memoryman\u00adagement policyto use, adding the extra type annotations \nwas fairlystraightforward. Figure 11 presents a measure of the programming overhead involved. It shows \nthe number of lines of code that needed type annotations. In most cases, we onlyhad to change code where \nregions were created. We also used our RTSJ implementation to measure the execution times of these programs \nboth with and without the dynamic checks speci.ed in the Real-Time Speci.ca\u00adtion for Java. Figure 12 \npresents the running times of the benchmarks both with and without dynamic checks. Note that there is \nno garbage collection overhead in anyof these running times because the garbage collector never executes. \nOur micro benchmarks (Array and Tree) were written specif\u00adicallyto maximize the checking overhead our \ndevelopment goal was to maximize the ratio of assignments to other com\u00adputation. These programs exhibit \nthe largest performance increases theyrun approximately7.2 and 4.8 times faster, respectively, without \nchecks. The performance improve\u00adments for the scienti.c programs and image processing com\u00adponents provide \na more realistic picture of the dynamic checking overhead. These programs have more modest per\u00adformance \nimprovements, running up to 1.25 times faster without the checks. For the servers, the running time is \ndominated bythe network processing overhead and check removal has virtuallyno e.ect. We present the overhead \nof dynamic referencing and assignment checks in this paper. For a detailed analysis of the performance \nof a full range of RTSJ features, see [21, 22].   4. Related Work The seminal work in [43, 42] introduces \na static type sys\u00adtem for region-based memorymanagement for ML. Our sys\u00adtem extends this to object-oriented \nprograms bycombining the bene.ts of region types and ownership types in a uni.ed type system framework. \nOur system extends region types to multithreaded programs byallowing long-lived threads to share objects \nwithout using the heap and without having memory leaks. Our system extends region types to real-time \nprograms byensuring that real-time threads do not interfere with the garbage collector. One disadvantage \nwith most region-based management systems is that they enforce a lexical nesting on region life\u00adtimes; \nso objects allocated in a given region maybecome inaccessible long before the region is deleted. [2] \npresents an analysis that enables some regions to be deleted early, as soon as all of the objects in \nthe region are unreachable. Other approaches include the use of linear types to control when regions \nare deleted [23, 25]. None of these approaches currentlysupport object-oriented programs and the conse\u00adquent \nsubtyping, multithreaded programs with shared re\u00adgions, or real-time programs with real-time threads \n(although it should be possible toextendthem todoso). Conversely, it should also be possible to applythese \ntechniques to our sys\u00adtem. In fact, existing systems already combine ownership\u00adbased type systems and \nunique pointers [20, 14, 3]. RegJava [16] has a region type system for object-oriented programs that \nsupports subtyping and method overriding. Cyclone [34] is a dialect of C with a region type system. Our \nwork improves on these two systems by combining the bene.ts of ownership types and region types in a \nuni.ed framework. An extension to Cyclone handles multithreaded programs and provides shared regions \n[33]. Our work im\u00adproves on this byproviding subregions in shared regions and portal .elds in subregions, \nso that long-lived threads can share objects without using the heap and without hav\u00ading memoryleaks. \nOther systems for regions [29, 30] use runtime checks to ensure memorysafety. These systems are more \n.exible, but theydo not staticallyensure safety. To our knowledge, ours is the .rst static type system \nfor memorymanagement in real-time programs. [26, 27] auto\u00admaticallytranslates Java code into RTSJ code \nusing o.-line dynamic analysis to determine the lifetime of an object. Un\u00adlike our system, this system \ndoes not require type annota\u00adtions. It does, however, impose a runtime overhead and it is not safe because \nthe dynamic analysis might miss some execution paths. Programmers can use this dynamic anal\u00adysis to obtain \nsuggestions for region type annotations. We previouslyused escape analysis [39] to remove RTSJ run\u00adtime \nchecks [41]. However, the analysis is e.ective only for programs in which no object escapes the computation \nthat allocated it. Our type system is more .exible: we allow a computation to allocate objects in regions \nthat mayoutlive the computation. Real-time garbage collection [5, 4] provides an alterna\u00adtive to region-based \nmemorymanagement for real-time pro\u00adgrams. It has the advantage that programmers do not have to explicitlydeal \nwith memorymanagement. The basic idea is to perform a .xed amount of garbage collection activity for \na given amount of allocation. With .xed-size allocation blocks and in the absence of cycles, reference \ncounting can deliver a real-time garbage collector that imposes no space overhead as compared with manual \nmemorymanagement. Copying and mark and sweep collectors, on the other hand, payspace to get bounded-time \nallocation. The amount of extra space depends on the maximum live heap size, the maximum allocation rate, \nand other memorymanagement parameters. The additional space allows the collector to successfullyperform \nallocations while it processes the heap to reclaim memory. To obtain the real-time allocation guar\u00adantee, \nthe programmer must calculate the required mem\u00adorymanagement parameters, then use those values to pro\u00advide \nthe collector with the required amount of extra space. In contrast, region-based memorymanagement provides \nan explicit mechanism that programmers can use to structure code based on their understanding of the \nmemoryusage be\u00adhavior of a program; this mechanism mayenable program\u00admers to obtain a smaller space overhead. \nThe additional de\u00advelopment burden consists of grouping objects into regions and determining the maximum \nsize of LT regions [31, 32]. 5. Conclusions The Real-Time Speci.cation for Java (RTSJ) allows pro\u00adgrams \nto create real-time threads and use region-based mem\u00adorymanagement. The RTSJ uses runtime checks to ensure \nmemory safety. This paper presents a static type system that guarantees that these runtime checks will \nnever fail for well-typed programs. Our type system therefore 1) provides an important safetyguarantee \nand 2) makes it possible to eliminate the runtime checks and their associated overhead. Our system also \nmakes several contributions over previous work on region types. For object-oriented programs, it com\u00adbines \nthe bene.ts of region types and ownership types in a uni.ed type system framework. For multithreaded \npro\u00adgrams, it allows long-lived threads to share objects without using the heap and without having memoryleaks. \nFor real\u00adtime programs, it ensures that real-time threads do not in\u00adterfere with the garbage collector. \nOur experience indicates that our type system is su.ciently expressive and requires little programming \noverhead, and that eliminating the RTSJ runtime checks using a static type system can signi.cantly decrease \nthe execution time of real-time programs. Acknowledgments We are grateful to Viktor Kuncak, Darko Marinov, \nKaren Zee, and the anonymous referees for their comments. 6. References [1] O. Agesen, S. N. Freund, \nand J. C. Mitchell. Adding type parameterization to the Java language. In Object-Oriented Programming, \nSystems, Languages, and Applications (OOPSLA), October 1997. [2] A. Aiken, M. F\u00a8ahndrich, and R. Levien. \nBetter static memory management: Improving region-based analysis of higher-order languages. In Programming \nLanguage Design and Implementation (PLDI), June 1995. [3] J. Aldrich, V. Kostadinov, and C. Chambers. \nAlias annotations for program understanding. In Object-Oriented Programming, Systems, Languages, and \nApplications (OOPSLA), November 2002. [4] D. F. Bacon, P. Cheng, and V. T. Rajan. A real-time garbage \ncollector with low overhead and consistent utilization. In Principles of Programming Languages (POPL), \nJanuary 2003. [5] H. G. Baker. List processing in real-time on a serial computer. Communications of \nthe ACM, 21(4):280 94, 1978. [6] W. Beebee, Jr. Region-based memory management for Real-Time Java. MEng \nthesis, Massachusetts Institute of Technology, September 2001. [7] W. Beebee, Jr. and M. Rinard. An \nimplementation of scoped memory for Real-Time Java. In First International Workshop on Embedded Software \n(EMSOFT), October 2001. [8] G. Bollella, B. Brosgol, P. Dibble, S. Furr, J. Gosling, D. Hardin, and M. \nTurnbull. The Real-Time Speci.cation for Java. Addison-Wesley, 2000. Latest version available from http://www.rtj.org. \n[9] C. Boyapati. Ownership types for safe object-oriented programming. PhD thesis, Massachusetts Institute \nof Technology. In preparation. [10] C. Boyapati, R. Lee, and M. Rinard. Ownership types for safe programming: \nPreventing data races and deadlocks. In Object-Oriented Programming, Systems, Languages, and Applications \n(OOPSLA), November 2002. [11] C. Boyapati, B. Liskov, and L. Shrira. Ownership types for object encapsulation. \nIn Principles of Programming Languages (POPL), January 2003. [12] C. Boyapati, B. Liskov, and L. Shrira. \nOwnership types and safe lazy upgrades in object-oriented databases. Technical Report TR-858, MIT Laboratory \nfor Computer Science, July 2002. [13] C. Boyapati, B. Liskov, L. Shrira, C. Moh, and S. Richman. Lazy \nmodular upgrades in persistent object stores. Submitted for publication, March 2003. [14] C. Boyapati \nand M. Rinard. A parameterized type system for race-free Java programs. In Object-Oriented Programming, \nSystems, Languages, and Applications (OOPSLA), October 2001. [15] G. Bracha, M. Odersky, D. Stoutamire, \nand P. Wadler. Making the future safe for the past: Adding genericity to the Java programming language. \nIn Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA), October 1998. [16] M. \nV. Christiansen, F. Henglein, H. Niss, and P. Velschow. Safe region-based memory management for objects. \nTechnical Report D-397, DIKU, University of Copenhagen, October 1998. [17] D. G. Clarke. Ownership and \ncontainment. PhD thesis, University of New South Wales, Australia, July 2001. [18] D. G. Clarke and S. \nDrossopoulou. Ownership, encapsulation and disjointness of type and e.ect. In Object-Oriented Programming, \nSystems, Languages, and Applications (OOPSLA), November 2002. [19] D. G. Clarke, J. M. Potter, and J. \nNoble. Ownership types for .exible alias protection. In Object-Oriented Programming, Systems, Languages, \nand Applications (OOPSLA), October 1998. [20] D. G. Clarke and T. Wrigstad. External uniqueness is unique \nenough. In European Conference for Object-Oriented Programming (ECOOP), July 2003. [21] A. Corsaro and \nD. Schmidt. The design and performance of the jRate Real-Time Java implementation. In International Symposium \non Distributed Objects and Applications (DOA), October 2002. [22] A. Corsaro and D. Schmidt. Evaluating \nReal-Time Java features and performance for real-time embedded systems. In IEEE Real-Time and Embedded \nTechnology and Applications Symposium (RTAS), September 2002. [23] K. Crary, D. Walker, and G. Morrisett. \nTyped memory management in a calculus of capabilities. In Principles of Programming Languages (POPL), \nJanuary 1999. [24] M. Day, R. Gruber, B. Liskov, and A. C. Myers. Subtypes vs. where clauses: Constraining \nparametric polymorphism. In Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA), \nOctober 1995. [25] R. DeLine and M. F\u00a8ahndrich. Enforcing high-level protocols in low-level software. \nIn Programming Language Design and Implementation (PLDI), June 2001. [26] M. Deters and R. Cytron. Automated \ndiscovery of scoped memory regions for Real-Time Java. In International Symposium on Memory Management \n(ISMM), June 2002. [27] M. Deters, N. Leidenfrost, and R. Cytron. Translation of Java to Real-Time Java \nusing aspects. In International Workshop on Aspect-Oriented Programming and Separation of Concerns, August \n2001. [28] M. Flatt, S. Krishnamurthi, and M. Felleisen. Classes and mixins. In Principles of Programming \nLanguages (POPL), January 1998. [29] D. Gay and A. Aiken. Memory management with explicit regions. In \nProgramming Language Design and Implementation (PLDI), June 1998. [30] D. Gay and A. Aiken. Language \nsupport for regions. In Programming Language Design and Implementation (PLDI), June 2001. [31] O. Gheorghioiu. \nStatically determining memory consumption of real-time Java threads. MEng thesis, Massachusetts Institute \nof Technology, June 2002. [32] O. Gheorghioiu, A. S.alcianu, and M. C. Rinard. Interprocedural compatibility \nanalysis for static object preallocation. In Principles of Programming Languages (POPL), January 2003. \n[33] D. Grossman. Type-safe multithreading in Cyclone. In Workshop on Types in Language Design and Implementation \n(TLDI), January 2003. [34] D. Grossman, G. Morrisett, T. Jim, M. Hicks, Y. Wang, and J. Cheney. Region-based \nmemory management in Cyclone. In Programming Language Design and Implementation (PLDI), June 2001. [35] \nK. R. M. Leino and G. Nelson. Data abstraction and information hiding. Research Report 160, Compaq Systems \nResearch Center, November 2000. [36] K. R. M. Leino, A. Poetzsch-He.ter, and Y. Zhou. Using data groups \nto specify and check side e.ects. In Programming Language Design and Implementation (PLDI), June 2002. \n[37] J. M. Lucassen and D. K. Gi.ord. Polymorphic e.ect systems. In Principles of Programming Languages \n(POPL), January 1988. [38] A. C. Myers, J. A. Bank, and B. Liskov. Parameterized types for Java. In Principles \nof Programming Languages (POPL), January 1997. [39] A. S.alcianu. Pointer analysis and its applications \nfor Java programs. MEng thesis, Massachusetts Institute of Technology, September 2001. [40] A. S.alcianu, \nC. Boyapati, W. Beebee, Jr., and M. Rinard. A type system for safe region-based memory management in \nReal-Time Java. Technical Report TR-869, MIT Laboratory for Computer Science, November 2002. [41] A. \nS.alcianu and M. Rinard. Pointer and escape analysis for multithreaded programs. In Principles and Practice \nof Parallel Programming (PPoPP), June 2001. [42] M. Tofte and J. Talpin. Region-based memory management. \nIn Information and Computation 132(2), February 1997. [43] M. Tofte and J. Talpin. Implementing the call-by-value \n.-calculus using a stack of regions. In Principles of Programming Languages (POPL), January 1994. P ::= \ndef * srkdef * e def ::= class cn (formal +) extends c * ** where constr { .eld meth } formal ::= kfn \nc ::= cn(owner +)|Object(owner ) owner ::= fn |r |this |initialRegion |heap |immortal |RT .eld ::= t \nfd * meth ::= t mn(formal * )((t p) * ) e.ects where constr {e } * e.ects ::= accesses owner constr \n::= owner owns owner |owner outlives owner t ::= c |int |RHandle(r) srkdef ::= regionKind srkn (formal \n* )extends srkind ** * where constr { .eld subsreg } subsreg ::= srkind : rpol tt rsub srkind ::= SharedRegion \n|srkn (owner * ) rkind ::= Region |NoGCRegion |GCRegion |LocalRegion | srkind k ::= Owner |ObjOwner |rkind \n| rkind : LT rpol ::= LT(size) |VT tt ::= NoRT |RT e ::= v |let v = e in {e }| * v.fd |v.fd = v |v.mn(owner \n* )(v ) |new c | ** fork v.mn(owner )(v ) | * RT fork v.mn(owner * )(v ) | (RHandle(r) h) { e }| (RHandle(rkind \n: rpol r)h) { e }| (RHandle(r) h = [new]opt h.rsub) { e }| h.fd |h.fd = v h ::= v cn . class names fd \n. .eld names mn . method names fn . formal identi.ers v, p . variable names r . region identi.ers srkn \n. shared region kind names rsub . shared subregion names Figure 13: Grammar Appendix A. TheTypeSystem \nThis section formally describes our type system. To sim\u00adplifythe presentation of our keyideas, we describe \nour type system in the context of a core subset of Java known as Clas\u00adsic Java [28]. Our approach, however, \nextends to the whole of Java and other similar languages. Figure 13 presents the grammar for our core \nlanguage. Throughout this section, we tryto use the same notations as in the grammar. To save space, \nwe use o instead of owner and f instead of formal .We also use g and a to range over the set of owners. \nWe assume the program source has been preprocessed byreplacing each constraint o1 owns o2 with the non-ASCII, \nbut shorter form o1 Co o2 and each constraint o1 outlives o2 with o1 Co2. The core of our type system \nis a set of typing judgments of the form P; E; X; rcr fe : t. P, the program being checked, is included \nto provide information about class de.nitions. The typing environment E provides information about the \ntype of the free variables of e (t v, i.e., variable v has type t), the kind of the owners currentlyin \nscope (k o, i.e., owner o has kind k), and the two relations between owners: the ownership relation (o2 \nCo o1, i.e., o2 owns o1)and the outlives relation (o2 Co1, i.e., o2 outlives o1). More formally, E ::= \n\u00d8|E, t v |E, k o |E, o2 Co o1 |E, o2 Co1. rcr is the current region. X must subsume the e.ects of e. \nt is the type of e. Typing rule Meaning fP : t Program P has type t. P fdef def def is a well formed \nclass de.nition from pro\u00ad gram P . P fsrkdef srkdef j srkdef j is a well formed shared region kind de.nition \nfrom program P . P; E; X; rcr fe : t In program P, environment E, and current re\u00adgion rcr,expression \ne has type t.Its evalu\u00ad ation accesses only objects (transitively) out\u00ad lived by owners listed in the \ne.ects X. P fenv E E is a well formed environment with respect to program P . P; E fmeth meth Method \nde.nition meth is well de.ned with respect to program P and environment E. P fmbr .c Class c de.nes or \ninherits member de.ni\u00ad tion mbr . Member refers to a .eld or a method: mbr = .eld |meth. P frmbr .rkind \nSharedregionkind rkind de.nes or inher\u00ad its region member de.nition rmbr . Re\u00ad gion member refers to \na .eld or a subregion: rmbr = .eld |subsreg. P; E ftype t t is a well formed type with respect to program \nP and environment E. P ft1 =t2 In program P, t1 is a subtype of t2. P; E fokind k k is a well formed \nowner kind, with respect to program P and environment E. P fk1 =k k2 In program P, k1 is a subkind of \nk2. E fX2 >X1 E.ect X1 is subsumed by e.ect X2,with re\u00ad spect to environment E. E fconstr In environment \nE, constr is well formed (i.e., the owners involved in it are well formed) and satis.ed. E fk o : k In \nenvironment E, o is a well formed owner with kind k. E fRKind(o)= k Owner o is either a region of kind \nk or an object allocated in such a region. E fav RH(o) The handle of the region o is allocated in (if \no is an object) or o stands for (if it is a region) is available in the environment E. E fo2 >o o1 In \nenvironment E,owner o2 (an object or a region) owns owner o1 (which must be an object). Figure 14: Typing \nJudgments  E fo2 >o1 In environment E,owner o2 outlives owner o1. Predicate Meaning WFClasses(P) No \nclass is de.ned twice and there is no cycle in the class hierarchy. WFRegionKinds(P) No region kind is \nde.ned twice and there is no cycle in the region kind hierarchy. In ad\u00addition, no region kind has an \nin.nite number of (transitive) subregions. MembersOnce(P) No class or region kind contains two .elds \nwith the same name, either declared or in\u00adherited. Similarly, no class declares two methods with the \nsame name. InheritanceOK (P) The constraints of a sub-class/kind are included among the super-class/kind \ncon\u00adstraints. For overriding methods, in addition to the usual subtyping relations between the return/parameter \ntypes, the constraints of the overrider are included among the con\u00adstraints of the overridden method; \na similar relation holds for the e.ects. Figure 15: Predicates Used in Type Checking Rules  Figure 14 \npresents our typing judgments. Appendix B presents the rules for these judgments. Figure 15 presents \nseveral auxiliarypredicates that we use in our rules. Most of these predicates are straightforward and \nwe omit their de.\u00adnitions for brevity; the only exception is InheritanceOK (P), which we de.ne formallyin \nthe set of rules.  B. Rules for Type Checking fP f P : t def def [PROG] [CLASS DEF] def = class cn((ki \nfni)i=1..n) extends c WFClasses(P) WFRegionKinds(P) where constr1..p { .eld1..m meth1..q } MembersOnce(P) \nInheritanceOK (P) P =...def ... P =def 1..n srkdef 1..r eE = \u00d8, GCRegion heap, SharedRegion :LT immortal, \n.i =1..n, P fdef def i .i =1..r, P fsrkdef srkdef j RHandle(heap)h heap, RHandle(immortal)h immortal, \nE = \u00d8, GCRegion heap, SharedRegion :LT immortal, (ki fni)i=1..n, constr1..p, cn(fn1..n)this, (fni >fn1)i=2..n \nRHandle(heap)h heap, RHandle(immortal)h immortal P fenv EP;E ftype c P;E;world;heap fe :t .j =1..m, \n(.eldj =tj fdj . P;E ftype tj ) .k =1..q, P;E fmeth methk fP :tP fdef def P fsrkdef srkdef P f env E \n [REGION KIND DEF] [ENV \u00d8] srkdef =regionKind srkn ((ki fni)i=1..n) extends r where constr1..c { .eld1..m \nsubsreg1..s } P =... srkdef ... E =\u00d8, (ki fni)i=1..n, constr1..c, srkn (fn1..n)this, (fni >this)i=1..n \nP fenv EP;E fokind r .j =1..m, (.eldj =tj fdj . P;E ftype tj ) .k =1..s, (subsregk =srkindk :rpolk tt \nrsubk . P;E fsrkind srkindk) P fsrkdef srkdef P fenv \u00d8 [ENV v] P fenv E v .Dom(E) P;E ftype t P fenv \nE, t v [ENV OWNER] P fenv E o .Dom(E) P;E fokind k P fenv E, k o [ENV to] P fenv E E fk o1 :ObjOwner \nE fk o2 :k P fenv E, o1 >o o2 [ENV =] P fenv E E fk o1 :k1 E fk o2 :k2 P fenv E, o1 >o2 P; E ftype t \n[TYPE INT] P;E ftype int [TYPE OBJECT] E fk o :k P;E ftype Object(o) [TYPE REGION HANDLE] E fk r :k P \nfk =k Region P;E ftype RHandle(r) [TYPE C] P =... def ... def =class cn((ki fni)i=1..n) ... where constr1..c \n... .i =1..n, (E fk oi :k ' i . P fk ' i =k ki . E foi >o1) .i =1..c, E fconstri[o1/fn1]..[on/fn n] P;E \nftype cn(o1..n) P ft1 =t2 [SUBTYPE REFL] P ft =t [SUBTYPE TRANS] P ft1 =t2 P ft2 =t3 P ft1 =t3 [SUBTYPE \nCLASS] P fdef class cn ((ki fni)i=1..n)extends cn2(fn1 o * ) ... P fcn(o1..n)=cn2(fn1 o * )[o1/fn1]..[on/fn] \n n P; E f okind k [USER DECLARED SHARED REGION] [STANDARD OWNERS] [LT REGIONS] P fsrkdef regionKind \nsrkn ((ki fni)i=1..n) ... where constr1..c ... '' k .{Owner, ObjOwner, Region, GCRegion, .i =1..n, (E \nfk oi :k P fk =k ki) ii NoGCRegion, LocalRegion, SharedRegion} P;E fokind rkind .i =1..c, E fconstri[o1/fn1]..[on/fn] \nn P;E fokind k P;E fokind rkind :LT P;E fokind srkn (o1..n) P fk1 =k k2 [SUBKIND REFL] P fk =k k [SUBKIND \nVALUE] P fValue =k k P; E f meth meth [SUBKIND TRANS] [SUBKIND OWNER] P fk1 =k k2 P fk2 =k k3 k .{ObjOwner, \nRegion} P fk1 =k k3 P fk =k Owner [SUBKIND SHARED REGION KIND] P fsrkdef regionKind srkn ((ki fni)i=1..n) \nextends r [SUBKIND REGION] k .{GCRegion, NoGCRegion}P fk =k Region [DELETE LT] ... P fsrkn (o1..on)=k \nr[o1/fn1]..[/fn ] P frkind :LT =k rkind onn [SUBKIND NOGCREGION] k .{LocalRegion, SharedRegion}P fk =k \nNoGCRegion [ADD LT] P frkind1 =k rkind2 P frkind1 :LT =k rkind2 :LT [METHOD] E ' =E, f1..n, constr1..c, \n(tj pj )j=1..p, Region initialRegion, RHandle(initialRegion)hfresh P fenv E ' .i =1..q, (E ' fk ai :ki \n. ai =RT) P;E ' ;a1..q;initialRegion fe :t P;E fmeth t mn(f1..n)((tj pj )j=1..p) accesses a1..q where \nconstr1..c {e} P fmbr .c,where mbr = .eld |meth [DECLARED CLASS MEMBER] [INHERITED CLASS MEMBER] ' P \nfdef class cn((ki fni)i=1..n) ... {... mbr ...} P fdef class cn2((ki fni)i=1..m) extends cn(o1..n)... \nP fmbr .cn(fn1..n) ' P fmbr .cn(fn1..n) P fmbr [o1/fn1]..[on/fn n].cn2(fn1..m) P frmbr .rkind ,where \nrmbr = .eld |subsreg [DECLARED REGION MEMBER] [INHERITED REGION MEMBER] P frmbr .srkn (fn1..n) ' P fsrkdef \nregionKind srkn ((ki fni)i=1..n) ... { ... rmbr ... } P fsrkdef regionKind srkn ((ki fni)i=1..m) extends \nsrkn (o1..n) ... ' P frmbr .srkn (fn1..n) P frmbr [o1/fn1]..[on/fn n].srkn2(fn1..m) E fconstr [ENV CONSTR] \n[to world] [to OWNER] [to REFL] [to TRANS] [to .t] E =E1, constr ,E2 o =RT E =E1, cn (o1..n)this,E2 E \nfo1 >o o2 E fo2 >o o3 E fo1 >o o2 E fconstr E fworld >o E fo1 >o this E fo >o o E fo1 >o o3 E fo1 >o2 \n E fX1 tX2 E fk o : k [theap/immortal] [tREFL] [tTRANS] [X1 tX2] [OWNER THIS] [OWNER FORMAL] o1 .{heap, \nimmortal} E fo1 >o2 E fo2 >o3 .o .X1, .g .X2,E fo >g E =E1, cn(...)this,E2 E =E1, k o, E2 E fo1 >o2 E \nfo >o E fo1 >o3 E fX1 >X2 E fk this :Owner E fk o :k E fav RH(o) [AV HANDLE] [AV THIS] [AV TRANS1] \n[AV TRANS2] E = E1, RHandle(r)h, E2 E = E1, cn(o1..n)this,E2 E fo1 >o o2 E fav RH(o2) E fo2 >o o1 E fav \nRH(o2) E fav RH(r) E fav RH(this) E fav RH(o1) E fav RH(o1) [RKIND THIS] E = E1, cn(o1..n)this,E2 E fRKind(o1)= \nk E fRKind(this)= k InheritanceOK(P) [RKIND FN1] E fk fn : k k .{Owner, ObjOwner} E fRKind(fn )= k [RKIND \nFN2] E fk fn : kk .{Owner, ObjOwner} E fo >o fn E fRKind(o)= k2 E fRKind(fn )= k [INHERITANCEOK REGION \nKIND] [INHERITANCEOK PROG] ' P = def 1..n srkdef 1..r e srkdef = regionKind srkn (f1..n) extends srkn \n(o1..m) where constr1..q ... ' ''' ' .i =1..n, P fInheritanceOK(def i) srkdef = regionKind srkn ((ki \nfni)i=1..m) extends srkind where constr 1..s ... ' ''' .i =1..r, P fInheritanceOK (srkdef i) P fsrkdef \nsrkdef constr1..s[o1/fn1]..[om/fn ] .constr m1..q InheritanceOK (P) P fInheritanceOK (srkdef ) [INHERITANCEOK \nCLASS] [OVERRIDESOK METHOD] def = class cn((ki fni)i=1..n) extends cn(o1..m) where constr1..q ... meth \n= tr mn(f1..n)((ti pi)i=1..m) accesses a1..q ' ''' ' def = class cn ((ki fni)i=1..m) extends c where \nconstr 1..u ... where constr1..r ... ''' '' ''' P fdef def constr1..u[o1/fn1]..[om/fn ] .constr meth \n' = t mn(f1..n)((t p )i=1..m) accesses a m1..q rii1..s ' .mn, ( P fmeth .def .meth = tr mn(...)(...) \n... . where constr 1..u ... ' ' '' P fmeth ' .def .meth = t r mn(...)(...) ... ) P ft r =tr .i =1..m, \nP fti =ti '' . P fOverridesOK(meth, meth ' ) a1..q .a1..s constr 1..r .constr1..u P fInheritanceOK (def \n) P fOverridesOK(meth, meth ' ) P; E; X; rcr f e : t [EXPR VAR] [EXPR LET] [EXPR NEW] E ' E = E1,t v,E2 \nP fenv E ' P; E ' ; X; rcr fe2 : t2 E fav RH(o1) E fX >o1 P; E; X; rcr fv : tP; E; X; rcr flet v = e1 \nin e2 : t2 P; E; X; rcr fnew c : c P; E; X; rcr fe1 : t1 = E, t1 v P; E ftype cc = cn(o1..n) [EXPR INVOKE] \n P; E; X; rcr fv : cn (o1..n).i =(n +1)..m, E foi >o1 [EXPR REF READ] [EXPR REF WRITE] P fmeth .cn(fn1..n) \nP; E; X; rcr fv1 : cn(o1..n) meth = t mn((ki fni)i=(n+1)..m) ((tj pj )j=1..u) accesses Xm where constr1..c \n{e} P; E; X; rcr fv : cn (o1..n) P f(t fd ) .cn (fn1..n) def ' P f(t fd ) .cn (fn1..n) t = t[o1/fn1]..[on/fnn] \nRename(a)= a[o1/fn1]..[om/fnm][rcr/initialRegion] ' ''' t = t[o1/fn1]..[on/fn n] P; E; X; rcr fv2 : t2 \nP ft2 =t .i =1..u, (P; E; X; rcr fvi : t . P ft =Rename(ti)) i i '' '' (t = int) . (t = int) ..i =(n \n+1)..m, (E f. P fk =k Rename(ki)) k oi : kii ''' '''' ' (t = cn (o1..m). E fX >o1)(t = cn (o1..m). E \nfX >o1) E fX >Rename(Xm) .i =1..c, E fRename(constri) ' ' P; E; X; rcr fv.fd : tP; E; X; rcr fv1.fd \n= v2 : tP; E; X; rcr fv.mn()(v1..u) : Rename(t) o(n+1)..m [EXPR SUBREGION] [EXPR REGION] P; E; X; rcr \nfh2 : RHandle(r2) E fk r2 : srkn2(o1..n) P; E frkind = srkn () {okind rkind P frkind3 : rpol tt rsub \n.srkn2(fn1..n) rkind : LT if rpol = LT(size) rkind = rkind3[o1/fn1]..[on/fn ][r2/this] n kr = { rkind \notherwise rkind : LT if rpol = LT(size) kr = E2 = E, kr r, RHandle(r)h rkind otherwise  {E2, (re >r).re.Regions(E) \nE2 = E, kr r, RHandle(r)h, r2 >r P fenv E2 E3 =ifP frkind =k LocalRegion P; E2; X, r; r fe : t  E2 \notherwise (new . (rpol = VT ) . (tt = NoRT)) . E fX >heap P fenv E3 P; E3; X, r; r fe : tE fX >heap (tt \n= RT) . E fX >RT P; E; X; rcr f(RHandle(rkind : rpol r) h) {e}: int P; E; X; rcr f(RHandle(r) h1 = [new]opt \nh2.rsub) {e}: int Regions(E) is the set of all regions mentioned in E, de.ned as follows: Regions(\u00d8)= \n\u00d8 Regions(E, rkind r)= Regions(E) .{r}Regions(E, )= Regions(E), otherwise [EXPR LOCALREGION] P; E; X; \nrcr f(RHandle(LocalRegion : VT r) h) {e}: int P; E; X; rcr f(RHandle(r) h) {e}: int [EXPR FORK] [EXPR \nRTFORK] P; E; X \\{RT}; rcr fv0.mn(o(n+1)..m)(v1..u) : t ' X = {o .X |E fRKind(o)= k . P fk =k SharedRegion \n: LT} def ' NonLocal(k)=(P fk =k SharedRegion) . (P fk =k GCRegion) P; E; X, RT; rcr fv0.mn(o(n+1)..m)(v1..u) \n: t E fRKind(rcr)= kcr NonLocal(kcr) P; E; X; rcr fv0 : cn (o1..n)P; E; X; rcr fv0 : cn(o1..n).i =1..m, \n(E fRKind(oi)= ki . P fki =k SharedRegion) .i =1..m, (E fRKind(oi)= ki . NonLocal(ki)) E fRKind(rcr)= \nkcr P fkcr =k SharedRegion P; E; X; rcr ffork v0.mn(o(n+1)..m)(v1..u) : int P; E; X; rcr fRT fork v0.mn(o(n+1)..m)(v1..u) \n: int [EXPR SET REGION FIELD] [EXPR GET REGION FIELD] P; E; X; rcr fh : RHandle(r) E fk r : srkn (o1..n) \n' P; E; X; rcr fh : RHandle(r) E fk r : srkn (o1..n) P ft fd .srkn (fn1..n) t = t[o1/fn1]..[on/fnn][r/this] \n' ' P ft fd .srkn (fn1..n) t = t[o1/fn1]..[on/fn n][r/this] P; E; X; rcr fv : t1 P ft1 =t ''' '' '' ' \n((t = int) . (t = cn (o ). E fX >o1)) ((t = int) . (t = cn(o ). E fX >o1)) 1..m 1..m ' ' P; E; X; rcr \nfh.fd : t P; E; X; rcr fh.fd = v : t  \n\t\t\t", "proc_id": "781131", "abstract": "The Real Time Specification for Java (RTSJ) allows a program to create real-time threads with hard real-time constraints. Real-time threads use region-based memory management to avoid unbounded pauses caused by interference from the garbage collector. The RTSJ uses runtime checks to ensure that deleting a region does not create dangling references and that real-time threads do not access references to objects allocated in the garbage-collected heap. This paper presents a static type system that guarantees that these runtime checks will never fail for well-typed programs. Our type system therefore 1) provides an important safety guarantee for real-time programs and 2) makes it possible to eliminate the runtime checks and their associated overhead.Our system also makes several contributions over previous work on region types. For object-oriented programs, it combines the benefits of region types and ownership types in a unified type system framework. For multithreaded programs, it allows long-lived threads to share objects without using the heap and without memory leaks. For real-time programs, it ensures that real-time threads do not interfere with the garbage collector. Our experience indicates that our type system is sufficiently expressive and requires little programming overhead, and that eliminating the RTSJ runtime checks using a static type system can significantly decrease the execution time of real-time programs.", "authors": [{"name": "Chandrasekhar Boyapati", "author_profile_id": "81319488571", "affiliation": "MIT Laboratory for Computer Science, Cambridge, MA", "person_id": "PP42052098", "email_address": "", "orcid_id": ""}, {"name": "Alexandru Salcianu", "author_profile_id": "81100441082", "affiliation": "MIT Laboratory for Computer Science, Cambridge, MA", "person_id": "P335277", "email_address": "", "orcid_id": ""}, {"name": "William Beebee", "author_profile_id": "81100000875", "affiliation": "MIT Laboratory for Computer Science, Cambridge, MA", "person_id": "P517423", "email_address": "", "orcid_id": ""}, {"name": "Martin Rinard", "author_profile_id": "81100087275", "affiliation": "MIT Laboratory for Computer Science, Cambridge, MA", "person_id": "P192534", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/781131.781168", "year": "2003", "article_id": "781168", "conference": "PLDI", "title": "Ownership types for safe region-based memory management in real-time Java", "url": "http://dl.acm.org/citation.cfm?id=781168"}