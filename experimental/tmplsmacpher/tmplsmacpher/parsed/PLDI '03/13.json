{"article_publication_date": "05-09-2003", "fulltext": "\n A Practical Flow-Sensitive and Context-Sensitive C and C++ Memory Leak Detector David L. Heine and \nMonica S. Lam Computer Systems Laboratory Stanford University {dlheine, lam}@stanford.edu ABSTRACT This \npaper presents a static analysis tool that can automatically .nd memory leaks and deletions of dangling \npointers in large C and C++ applications. We have developed a type system to formalize a practical own\u00adership \nmodel of memory management. In this model, every ob\u00adject is pointed to by one and only one owning pointer, \nwhich holds the exclusive right and obligation to either delete the object or to transfer the right to \nanother owning pointer. In addition, a pointer\u00adtyped class member .eld is required to either always or \nnever own its pointee at public method boundaries. Programs satisfying this model do not leak memory \nor delete the same object more than once. We have also developed a .ow-sensitive and context-sensitive \nalgorithm to automatically infer the likely ownership interfaces of methods in a program. It identi.es \nstatements inconsistent with the model as sources of potential leaks or double deletes. The al\u00adgorithm \nis sound with respect to a large subset of the C and C++ language in that it will report all possible \nerrors. It is also practical and useful as it identi.es those warnings likely to correspond to er\u00adrors \nand helps the user understand the reported errors by showing them the assumed method interfaces. Our \ntechniques are validated with an implementation of a tool we call Clouseau. We applied Clouseau to a \nsuite of applications: two web servers, a chat client, secure shell tools, executable object manipulation \ntools, and a compiler. The tool found a total of 134 serious memory errors in these applications. The \ntool analyzes over 50K lines of C++ code in about 9 minutes on a 2 GHz Pentium 4 machine and over 70K \nlines of C code in just over a minute.  Categories and Subject Descriptors D.2.3 [Software Engineering]: \nCoding Tools and Techniques; D.2.4 [Software Engineering]: Program Veri.cation; D.3.4 [Programming Languages]: \nProcessors Memory Management This material is based upon work supported in part by the National Science \nFoundation under Grant No. 0086160. Permission to make digital or hard copies of all or part of this \nwork for personal or classroom use is granted without fee provided that copies are not made or distributed \nfor pro.t or commercial advantage and that copies bear this notice and the full citation on the .rst \npage. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior \nspeci.c permission and/or a fee. PLDI 03, June 9 11, 2003, San Diego, California, USA. Copyright 2003 \nACM 1-58113-662-5/03/0006 ...$5.00.  General Terms Algorithms, Experimentation, Languages, Veri.cation. \n Keywords Program analysis, type systems, memory management, error detec\u00adtion, memory leaks. 1. INTRODUCTION \nMany existing programs are written in C and C++ where memory needs to be manually managed. Leaking memory \nand deleting an object multiple times are some of the most common and hard-to\u00ad.nd errors in these programs. \nMemory leaks can cause memory\u00adintensive and long-running programs, such as server codes, to fail. Deleting \nan object that has already been deleted can cause memory corruption. 1.1 Existing Tools Dynamic tools \nlike Purify are commonly used for detecting memory management errors in programs[20]. Purify instruments \na program and reports all allocated memory at program exit that is not pointed to by any pointers. Unfortunately, \nit can only .nd leaks that occur during instrumented executions and incurs a nontrivial run-time overhead. \nMoreover, Purify can only identify the alloca\u00adtion sites of leaked memory; users are still left with \nthe dif.cult task of .nding the statements that cause the leak. A number of automatic static analysis \ntools, such as PRE.x[6] and Metal[12, 19], have also been developed that help .nd memory leaks in programs. \nThese tools aim to identify those cases when a program loses all references to an object without having \ndeleted the object. However, without global pointer alias analysis, these tools cannot track pointers \nstored in recursive data structures and container objects. Thus, they can only .nd memory leaks that \noc\u00adcur close to allocation sites, missing many errors that account for important leaks in real programs. \nTechniques that require user participation have also been pro\u00adposed. Linear types allow only one reference \nto each dynamically allocated object[26]. This restriction is enforced by nullifying the contents of \na linear-typed variable whenever it is read. That is, whenever a pointer assignment, q=p, is executed, \nthe value of p is nulli.ed and qbecomes the sole reference of the object pointed to by p. Memory management \nis simple with linear types; deleting an object whenever its unique reference is destroyed guarantees \nno memory leaks, no double deletes and no dangling references. Un\u00adfortunately, it is dif.cult to program \nwith the semantics of linear types.   The auto ptrtemplate class in the C++ standard library is an \nattempt at a practical solution. An auto ptr owns the object it points to; whenever an auto ptris destroyed, \nthe object it points to is automatically deleted. An auto ptr is nulli.ed whenever it is copied; however, \nunlike linear types, multiple references are allowed. Similar concepts are adopted by LCLint[13], which \nre\u00adquire programmers to decorate their pointer variables with only and shared keywords. The burden imposed \non the programmer and the lack of support for polymorphic ownerships in functions render these techniques \nunappealing. 1.2 Contributions We have developed a fully automatic technique that can .nd memory leaks \nand multiple deletes in large C and C++ programs. It is powerful enough to .nd leaks of objects whose \nreferences have been stored in recursive data structures in C++ programs. The main contributions of this \npaper include the formalization of a practi\u00adcal memory management scheme based on object ownership, a \nfully automatic ownership inference algorithm, and validation of the ideas via an implementation and \nan experiment. 1.2.1 A Practical Object Ownership Model One way to ensure that no memory is leaked is \nto check that an object is deleted whenever its last reference is obliterated. Enforc\u00ading such a property \nis dif.cult as it requires, among other things, tracking all pointers to recursive data structures carefully. \nIn fact, this is too hard even for programmers who, when dealing with ob\u00adjects that have multiple aliases, \noften resort to dynamic reference\u00adcounting schemes. However, dynamic reference counting can be expensive \nand cannot handle circular data structures. In practice, programmers often adopt simple programming con\u00adventions \nto help them manage memory. One such convention is object ownership, which associates with each object \nan owning pointer,or owner, at all times. An owning pointer holds the exclu\u00adsive right and obligation \nto either delete the object it points to or to transfer the right to another owning pointer. Upon deleting \nthe object it points to, an owning pointer becomes non-owning. One or more non-owning pointers may point \nto the same object at any time. Note that this notion of ownership is different from the con\u00adcept of \nownership for encapsulation[7, 9, 21], which assumes that all accesses to an object must go through an \nowning pointer. This model eliminates the possibility of deleting an object more than once and guarantees \nthe deletion of all objects without ref\u00aderences. However, like reference counting, this model may leak \nobjects whose owning pointers form a cycle. This is rare in prac\u00adtice because most programs are designed \nwith acyclic ownership structures. Well-designed object-oriented programs often have simple easy\u00adto-use \nexternal method interfaces. One common idiom is to require that pointer member .elds in an object either \nalways or never own their pointees at public method boundaries. Correspondingly, the destructor method \nof an object contains code to delete all and only objects pointed to by owning member .elds. By adopting \nthis as\u00adsumption, our tool can reason about object ownership with the same relative ease afforded to \nprogrammers. We have developed a formal type system for a small language to capture the object ownership \nmodel as described above. We have also expanded this formal model to handle most of the safe fea\u00adtures \nof the full C and C++ languages. Our ownership model is applicable to real programs because: 1. Unlike \nlinear types, multiple non-owning references are al\u00adlowed to point to the same object. 2. Ownership can \nbe transferred. Each object has an owner im\u00admediately upon creation, and the ownership may be trans\u00adferred \nfrom owner to owner until the object is deleted. 3. Normal assignment and parameter passing semantics \nare supported by allowing ownership to be optionally trans\u00adferred. In statement u=v,if v owns its object \nbefore the statement, it can either retain ownership, or transfer owner\u00adship to u and become a non-owning \npointer itself after the assignment. 4. Object member .elds are required to have the same owner\u00adship \nonly at public method boundaries. More speci.cally, this invariant is required to hold only at method \ninvocations where the receiving object may not be the same as the send\u00ading object. 5. Polymorphic method \ninterfaces are supported. The own\u00adership type signatures of methods are represented by con\u00adstraints on \nthe ownerships between input and output param\u00adeters. The same method may be invoked using parameters \nwith different ownerships as long as the constraints are satis\u00ad.ed.  Note that we are not advocating \nthe exclusive use of an owner\u00adship model for all objects. It is sometimes appropriate to manage some \nobjects in a program using other techniques, such as refer\u00adence counting and region-based management. \nOur system does not require that memory be managed solely with the ownership model. 1.2.2 Automatic \nOwnership Inference Our algorithm automatically infers the ownership signatures for all pointer member \n.elds and method interfaces directly from the code and can be applied to existing C and C++ programs \nwithout any modi.cation. The algorithm is sound, i.e. it reports all possi\u00adble errors, for the large \nsafe subset of C++ described in Section 3.5. The algorithm is also practical and useful for the following \nreasons. Being .ow-sensitive and context-sensitive, the algorithm is power\u00adful yet fast enough to run \non real programs. It is designed to isolate the sources of errors and not let them propagate. It identi.es \nthose warnings most likely to correspond to errors. Lastly, it helps users understand the error reports \nby showing them the assumed method interfaces. The object ownership model is designed to allow fast infer\u00adence. \nTracking properties of objects, such as the count in refer\u00adence counting, requires tracking aliases of \nobjects, which is ex\u00adpensive. Ownership is not a property associated with the objects being managed, \nbut rather an abstract property associated with the pointer variables themselves. We place ownership \ninference con\u00adstraints on pointer variables to ensure that ownership is conserved between assignments \nand parameter passing in procedures. Meth\u00adods in C++ classes are allowed to transfer ownership into and \nout of their pointer member .elds. By assuming that member .elds are either always owning or never owning \nat public method bound\u00adaries, we can easily track member .elds in the thisobject within methods in a \nclass. Alias analysis is rendered unnecessary by not allowing ownership to be transferred to: pointer \nmember .elds out\u00adside of their class, static pointer variables, pointers to pointers or pointer arrays. \nThis model, while simple, is suf.cient to .nd many errors in real code. A powerful .ow-sensitive and \ncontext-sensitive ownership in\u00adference. The algorithm tracks ownerships .ow-sensitively as they are transferred \nbetween local variables and context-sensitively as they are transferred between procedural parameters. \nOwnership is tracked with 0-1 valued variables where 1 means owning and 0 means non-owning. Ownership \ninference is modeled as solving limited forms of 0-1 linear inequalities. We represent method own\u00adership \ntypes polymorphically and succinctly as 0-1 linear inequali\u00adties on the ownerships of input and output \nparameters. We also use a sparse representation akin to semi-pruned SSA form[5] to reduce the size of \nthe constraints per method. While ownership constraints can be resolved with a general-purpose solver, \nwe have developed a specialized ownership constraint solver for ef.ciency and to gain control over how \ninconsistencies are reported. A sound and practical tool by prioritizing constraints. It can be dif.cult \nto deduce the actual cause of errors reported by poly\u00admorphic type systems. Especially because our model \ndoes not en\u00adcompass all legal ways of managing memory, a sound algorithm can potentially generate many \nfalse positive warnings, which could render the tool ineffective. Our solution is to satisfy the more \npre\u00adcise constraints .rst so as to minimize the propagation of errors as\u00adsociated with the less precise \nconstraints. In addition, the warnings are ranked according to the precision of the constraints being \nvio\u00adlated. By concentrating on the high-ranked warnings, and with the help of the automatically computed \nmethod signatures, the user can .nd errors in the program with reasonable effort. The advantage of having \na sound system is that researchers can browse through the low-ranked warnings to understand the system \ns weakness and un\u00adcover opportunities for further improvement. 1.2.3 Validation We have implemented \nthe algorithm presented in this paper as a program analysis pass in the SUIF2 compiler infrastructure. \nWe applied the system, called Clouseau, to six large open-source soft\u00adware systems, which have a total \nof about 400,000 lines of code. Every one of the C++ programs in our experiment contains classes that \nconform to our object ownership model. Clouseau found 134 de.nite errors in the programs. It analyzed \nover 50K lines of C++ code in about 9 minutes on a 2 GHz Pentium 4 machine.  1.3 Paper Organization \nThe rest of the paper is organized as follows. Section 2 gives an overview of the design of our ownership \nmodel. Section 3 presents our formal ownership type system for a simple object-oriented pro\u00adgramming \nlanguage and describes how we extend the system to C and C++. We describe our type inference algorithm \nin Section 4 and present experimental results in Section 5. We describe related work in Section 6 and \nconclude in Section 7. Appendix A contains the static typing rules for our ownership type system.  2. \nOVERVIEW This section presents a high-level overview and the rationale for our system, with the help \nof several examples. We describe how we create constraints to model ownership in a program and how we \norder the satisfaction of constraints to improve the quality of error reports. 2.1 Optional Ownership \nTransfer in Assign\u00adments Pointers returned by allocation routines and pointers passed to deallocation \nroutines are, by de.nition, owning pointers. Owner\u00adship of all other pointer variables needs to be inferred, \nas illustrated by the following simple example: EXAMPLE 1. Assignment statements. u = new int; (1) z \n= u; (2) delete z; (3) The object allocated in statement (1) is clearly not leaked because it is deleted \nin statement (3) through the alias z. Our system, how\u00adever, does not track pointer aliases per se. Instead, \nit knows that u is an owner after the allocation function in statement (1) and that z is an owner before \nthe delete operation in statement (3). Statement (2) represents a possible transfer of ownership from \nu to z. All the constraints can be satis.ed by requiring that the ownership be transferred from uto z, \nand thus the program is leak-free. . Notice that the analysis is necessarily .ow-sensitive. The source \nand destination variables of an assignment statement may change ownership after the execution of the \nassignment. In addition, both forward and backward .ow of information is necessary to resolve the ownership \nof variables, as illustrated by the example above. We model all statements as constraints such that if \nall the constraints extracted from a program can be satis.ed then the program has no memory leaks. Our \nanalysis is not path-sensitive; a variable must have the same ownership at the con.uence of control .ow \npaths. 2.2 Polymorphic Ownership Signatures Our analysis uses an accurate .xpoint algorithm to compute \npolymorphic ownership interfaces for each method in the program. The analysis initially approximates \nthe effect of each method by ignoring the methods it invokes. It then instantiates the approxi\u00admation \nof the callee s constraints in the caller s context to create a better approximation. This step is repeated \nuntil the solution con\u00adverges. EXAMPLE 2. Recursive procedures. int *id(int *a) { int *t= 0; if (pred()) \n{ int *c = new int; t = id(c); delete t; }; return(a); } The recursively de.ned id function returns \nthe original input value, with the side effect of possibly creating and deleting a num\u00adber of integers. \nEven though id is called with an owning input parameter and return value in the recursive cycle, our \nanalysis cor\u00adrectly summarizes the function as requiring only that the input pa\u00adrameter and the return \nvalue have identical ownerships. . 2.3 Object Ownership For C++ programs, member .elds in objects are \nassumed to be either always owning or never owning at public method bound\u00adaries. Our analysis starts \nby examining a class s constructors and its destructor to determine the ownership signatures of its .elds, \ni.e. whether the .elds are owning or non-owning at public method boundaries. Because an object s member \n.elds can only be mod\u00adi.ed by methods invoked on the object, our analysis only needs to track member \n.elds of the this object intraprocedurally and across methods on the this object. At other method invocation \nboundaries, member .elds take on the ownership speci.ed by their signatures. EXAMPLE 3. Object invariants. \nclass Container { Elem *e; public: Container(Elem *elem) { e = elem; } void set_e(Elem *elem) { delete \ne; e = elem; } Elem *get_e() { return(e); } Elem *repl_e(Elem *elem) { Elem *tmp = e; e = elem; \nreturn(tmp); } Container() { delete e; } } Member .eld e can be easily recognized as an owning mem\u00adber \nof the Containerclass because the destructor Container deletes it. Once e has been identi.ed as an owning \nmember .eld, the analysis can infer the ownership of pointers passed to and returned from each method \nof the class. The constructor Con\u00adtainerand set emust be passed an owning pointer; the return value of \nget e must not be owning; the argument and return of repl emust both be owning. This example also illustrates \na lim\u00aditation of the model. In practice, many classes implement a poly\u00admorphic get emethod and a set \nethat does not delete the orig\u00adinal member .eld. The object invariant is temporarily violated by code \nthat uses get e .rst to retrieve an owning pointer then uses set eto deposit an owning pointer in its \nplace. Our analysis .ags this idiom as a violation of the ownership model. . 2.4 Reporting Errors It \nis important that a leak detection tool pinpoints the statements that leak memory. In our system, a memory \nleak shows up as an inconsistency among constraints collected from a number of state\u00adments. The tool \nshould strive to identify which among these state\u00adments is likely to be erroneous. Our solution is to \ntry to satisfy the more precise constraints .rst, classify those constraints found to be inconsistent \nas errors and leave them out of consideration in subsequent analysis. Furthermore, we rank all the identi.ed \nerrors according to the precision of the constraints being violated. EXAMPLE 4. For the class de.ned \nin Example 3, suppose there is one illegal use of the Containerclass that deletes the element returned \nby get e. Had the analysis considered the constraints generated by this usage .rst, it would conclude \nthat member .eld e is not owning in the Container class. This would lead the analysis to generate errors \nfor all correct uses of the class, including one for the Containerdestructor function. Our analysis avoids \nthis problem because constraints from destructors and constructors are considered to be more precise \nand are thus satis.ed .rst. . Our system does not allow any writes of owning pointers to .elds in C structures \nor arrays of pointers. Many violations of this restric\u00adtion are expected in real programs. To avoid propagating \nsuch inac\u00adcuracy to many other statements in the program, our algorithm .rst analyzes the code assuming \nthat indirect accesses can optionally hold owning pointers, then re-analyzes it with the stricter constraint \nto generate all the warnings necessary to make the system sound. More details on constraint ordering \ncan be found in Section 4.3.      3. OBJECT OWNERSHIP CONSTRAINTS This section presents a formal \ntype system that models object ownership. We de.ne a small object-oriented programming lan\u00adguage with \ntyped ownerships. This language associates 0-1 own\u00adership variables with pointers to indicate whether \nthey own their pointees. Every member .eld in a class has a .eld signature which indicates if it is owning \nor non-owning at public method invoca\u00adtions. Each method also has an ownership signature which speci\u00ad.es \nconstraints on the ownership variables associated with param\u00adeters and results. Note that although this \nlanguage is de.ned with declared .eld and method signature ownerships, our inference al\u00adgorithm automatically \ninfers these signatures from C and C++ pro\u00adgrams. Well-typed programs in our ownership type system can \nbe shown, using an approach developed by Wright and Felleisen[28], to satisfy the following two properties: \nPROPERTY 1. There exists one and only one owning pointer to every object allocated but not deleted. PROPERTY \n2. A delete operation can only be applied to an owning pointer. Property 1 guarantees no memory leaks; \nobjects not pointed to by any variables are always deleted. Together, both properties guaran\u00adtee that \nobjects can only be deleted once. We .rst present the language in Section 3.1. Sections 3.2 and 3.3 describe \nthe handling of intraprocedural constraints and interproce\u00addural constraints, respectively. Section 3.4 \ndescribes how we han\u00addle null pointers. Finally, Section 3.5 describes extensions to cover most of the \nsafe features in C and C++. 3.1 A Language with Typed Ownership A program Pconsists of a set of classes \nCL(P); each class ECL(P)has an ordered set of member .elds F(), a construc\u00adtor new, a destructor deleteand \na set of other methods M(). Constructors and destructors can execute arbitrary code and call other methods. \nConstructors have a list of formal arguments and a return value; destructors have a single implicit this \nargument, and all other methods have an implicit thisargument, formal ar\u00adguments, and a return value. \nA method body contains a scope statement, which can access the this variable, local variables and parameters. \nField accesses are allowed only on the thisobject. The language has a number of assignment statements. \nSimple variables can be assigned from NULLvalues, variables, class .elds, and method invocation results. \nFields in a class can only be assigned from variables. The language also has a number of compound statements: \ncomposition, if and while. This language has ownership variables associated with parame\u00adters for each \nmethod and member .elds for each class. The owner\u00adship variables may be given two values \"E{O,I}, where \n\"I means owning, \"Omeans non-owning. Constraints on owner\u00adship are represented as 0-1 linear inequalities \nover ownership vari\u00adables. These constraints form a semi-lattice. The top element T in this lattice is \ntrue, and the bottom element .is false. The meet operator in the lattice corresponds to the conjunction \nof 0-1 linear constraints. C.:C.if and only if solutions satisfying C.also satisfy C. . Each member .eld \nfin class has an associated .eld ownership type FOT(f), [p;p\"], which speci.es that .eld fis associated \nwith ownership variable pwhose value is \". Whenever a method is invoked on a receiver object other than \nthis, .elds in both the sender and receiver objects must obey the ownerships speci.ed in their respective \n.eld ownership types. Each method min class has an associated method ownership type MOT(m), [a5;C]. a5speci.es \nthe ownership variables for this, the formal arguments, the class member .elds at method entry and exit, \nand the return value. Cspeci.es the set of linear constraints that must be satis.ed by these ownership \nvariables. The signatures for constructors include ownership variables for formal arguments, .elds on \nmethod exit, and the return value. The sig\u00adnatures for destructors include ownership variables for this \nand .elds on method entry. Typing rules in our system ensure that once an object is created, its ownership \nis held by some pointer variable. This ownership may be transferred via assignments and parameter passing \nin method invocations or stored in an owning member .eld. When the object is .nally deleted, the owning \nvariable relinquishes ownership and all objects pointed to by owning member .elds are also deleted. Typing \njudgments for statements in our system have the form B;D;Cfs=D.;C. which states that given a mapping \nfrom variables to their declared class type B, a mapping from variables to their ownership variables \nD, and a set of ownership constraints C, it is legal to execute the statement s, which results in a new \nownership mapping D. and new constraints C. . The static ownership typing rules are shown in Appendix \nA. Due to space constraints, we will discuss only one representative infer\u00adence rule in detail to give \nreaders a .avor for how the system is de.ned formally and focus on explaining the intuition behind the \nformulation. 3.2 Intraprocedural Ownership Constraints Assignment Statements. Let us .rst consider an \nassignment statement zy, where yand zare both simple variables. The in\u00ad ference rule for the simple assignment \nstatement, rule STMT-ASGN, is given in Appendix A and reproduced here: Dfy:py,z:pz pz. ,py. freshC. Cl{pzO}l{pypy. \n+pz.} B;D;Cfzy=D[z Hpz. ,y Hpy.];C. The term D[z that Hpz.]is the functional update of the map Dbinds \nzto pz. after removing any old binding. The ownerships of both yand zcan change after the state\u00adment. \npyand pzrepresents the ownerships of yand zbefore the statement; py. and pz. represent their ownerships \nafter the state\u00adment. Since zis overwritten, it must not own its pointee before the statement (pzO), \notherwise memory is leaked. The constraint pypy. +pz. guarantees the conservation of ownership required \nby Property 1. If yowns its pointee before the statement, it either retains ownership or transfers it \nto zafter the statement. If ydoes not own its pointee, neither ynor zis an owner after the statement. \nWithin a method, .elds of the thisobject are treated like local variables. We de.ne two rules STMT-FLDASGN \nand STMT-FLDUSE to handle assignments to and from member .elds of the thisob\u00adject. These are similar \nto their STMT-ASGN counterpart. A NULLpointer can be treated as either owning or non-owning. In C++, \nit is legal to delete a NULL pointer. We have found this relaxed constraint useful for analyzing C as \nwell. Thus, if the right hand side of an assignment statement is NULL, we only require that the overwritten \nvariable before the assignment be non-owning as given in the rule STMT-NULL. A new, unbound, ownership \nvariable is generated to represent the ownership of the destination variable after the assignment. Control \n.ow statements. The rule for composition, STMT-COMP, is straightforward. Our treatment of control .ow \nis path\u00adinsensitive. At join points, variables and .elds must have the same ownership at the con.uence \nof control .ow paths, as re.ected in rules STMT-IF and STMT-WHILE. 3.3 Interprocedural Constraints Constructors \n(new) and destructors (delete) are special be\u00adcause the former are guaranteed to return owning pointers \nand the latter always expect owning this pointers. Thus, we have three separate inference rules, CONSTR-GOOD, \nDESTR-GOOD, and METHOD-GOOD, to specify when constructors, destructors, and all other methods are well-typed. \nLocal variables de.ned in the scopestatement in each method must not carry ownership on entry and exit; \nreturn variables start out non-owning, but may carry ownership upon exit. The owner\u00adship constraints \nimposed by the method s scope statement on all ex\u00adternally visible variables are summarized by a method \ns ownership type (MOT). Variables that are externally visible include the im\u00adplicit thisparameter, input \nparameters, member .elds at method entry and exit, and the return value. To keep our type system simple, \nwe have adopted the conven\u00adtion that all variables to be passed as input parameters are .rst as\u00adsigned \nto fresh variables, which are then passed as parameters in their place. This implies that all owning \nactual parameters can be assumed to pass their ownerships to their formal counterparts. That is, formal \ninput parameters may be owning or non-owning upon en\u00adtry, but must not be owning on exit. This convention \nalso avoids the complexity that arises when the same variable is passed to multiple arguments of a method. \nWe refer to method invocations where the sender and the receiver are known to be the same object as internal. \nAll other method in\u00advocations are considered external. As indicated by the inference rule for internal \nmethod invocations STMT-INTCALL, each execu\u00adtion of rthis.m(...)involves instantiating the constraints \nin the declared method ownership type of mand replacing the for\u00admal ownership variables with fresh variables. \nEquations are set up between the ownerships of actual parameters and .elds and their corresponding instantiated \nformal variables. The ownership of the implicit this argument may be optionally passed to the invoked \nmethod. Furthermore, the ownership of the return value is trans\u00adferred to variable rin the caller, which \nmust not hold ownership before the statement. Theinferenceruleforexternalmethodcalls STMT-EXTCALLdif\u00adfers \nfrom the rule for internal calls in its treatment of member .elds. Member .elds in both the sender and \nreceiver objects must match their respective declared .eld ownership types (FOT). The rules for constructors \nSTMT-CONSTR and destructors STMT-DESTR are slight modi.cations of that for external calls due to their \ndiffering parameter and return signatures. EXAMPLE 5. Shown in Figure 1(a) is a short C++ program with \nmethod ownership types included as comments. The method own\u00adership type of n, MOT(n), is: [a asata/a/.a/.;aOlatIla/Olasa/.+a/.], \nwhere arepresents the ownership of this at entry, asand at are the ownership variables of the .rst and \nsecond arguments, a/ and a/. are the ownership variables for the .eld fat method entry and exit, respectively, \na/. is the ownership variable of the returned result. This signature says that the ownership of this \nis not passed into the method, the input parameter tmust be an owning pointer, the member .eld fmust \nbe non-owning at method entry. In addi\u00adtion, this signature polymorphically captures the fact that the \n.rst argument scan be called with either an owning or a non-owning pointer and allows the ownership, \nif present, be transferred to ei\u00adther the member .eld for the returned result. It is easy to tell from \nreading the code in method mthat all the three objects created are deleted and not leaked. The second \nin\u00advocation of method nis particularly interesting because the same object is passed as the .rst and \nsecond arguments to the method, a fact that our analysis captures as a constraint in the caller. The \nownership signature in method mhas three ownership vari\u00adables: arepresents this at the entry of method \nm, a/and a/ . represent .eld fat entry and exit. Statements where ownerships may change are labeled with \nthe names of the freshly generated ownership variables. We use pa. to denote the ownership of vari\u00adable \nain method mgenerated after executing statement i. We use . ato denote the instantiated ownerships for \nvariable bin the jth invocation of n. The extracted ownership constraints of method m are given in Figure \n1(b). To keep the example short, the constraints for CALL #1 and CALL #2 directly encode the choice of \nownership transfer for each of its arguments. In addition, we have omitted the ownership vari\u00adables associated \nwith thisand the initial ownership values of the local variables in m, all of which are constrained to \nbe non-owning. As shall be shown in Example 6, the seemingly complex con\u00adstraints in Figure 1(b) have \na simple structure and are satis.able. Thus, there is no memory leak within the method. Projecting away \nall the externally invisible variables gives the constraints in the de\u00adclared ownership type in Figure \n1(a). This example also illustrates how our system handles aliases. The signature of ndoes not depend \non whether the input param\u00adeters are aliased. The alias between xand yis implicitly captured by an ownership \nconstraint in the calling method on the pointer variables themselves, pX5 pX6+py6. . 3.4 Handling Null \nPointers Programs often .rst check if a pointer is null before deleting the object: if (p != NULL) delete \np This idiom is problematic for our path-insensitive system as de\u00adscribed above because objects are \ndeleted on one path but not the other. Our solution is to handle the predicates that test if a pointer \nis NULL by inserting an explicit NULL assignment to the pointer on the appropriate path. For example, \nthe previous statement is translated to: if (p != NULL) delete p else p = NULL; Since NULLis treated \nas both an owning and non-owning pointer, the analysis will correctly deduce that the pointer is no longer \nown\u00ading when the then and else branches merge. We also use an intraprocedural analysis to propagate NULLvalues \nin each method so that they can be more precisely represented as either owning or non-owning. (a) class \nc { int* f; // MOT(n)=[aasata/a/ .a/ .; // a=O/at=l/a/=O/as=a/ . +a/ .l int* n (int* s, int* t) { delete \nt; f=s; int*r = s; return r; } // MOT(m)=[aa/a/ .;a=O/a/=O/a/ .=Ol void m () { int* u = new int; (1) \n// PUI int* v = new int; (2) // PV2 int* w = n(u, v); (3) // PU3PV3P/3PW3 .. // (.(.(.(.(. st/// delete \nw; (4) // PW4 c*x=newint; (5)// PX5 c*y=x; (6)// Py6PX6 c*z=n(x,y); (7)// PX7P/ Py77Pz7 .. // (.(.(.(.(. \nst/// }... } (b) pUI IlpV2 I[stmt I,2] +a.+a. pUI pU3slpV2 pV3t .. a.la.la. la///p/3/pW3 [CALL #1] .. \na.a. Ila. Ola.+a.[MOT(n)] pW3 IlpW4 O[stmt 4] t/s// pX5 IlpX5 pX6+py6 [stmt 5,6] +a.+a. pX6 pX7slpy6 \npy7t .. lp/3 a.la.p/7la/.pz7 [CALL #2] // .. a. Ila. Ola.a.+a.[MOT(n)] t/s// pU3 OlpV3 OlpW4 OlpX7 O \nlpy7 Olpz7 Olp/7 a/ . [EXIT(m)] Figure 1: (a) A short C++ program with method ownership types and (b) \nownership constraints for method m. 3.5 Handling C and C++ Features While our small language is object-oriented, \nit can also be used to model C by simply treating all functions as methods de.ned for one global this \nobject. We have further extended the system to handle various C++ features including multiple inheritance \nwith virtual dispatch, static functions, multiple constructors per class and templates. Use of these \nfeatures in a program will not cause any unnecessary warnings in our system. Our model currently requires \natomic memory allocation and object construction, as well as atomic object destruction and de\u00adallocation. \nBreaking these invariants by using the C++ placement new syntax or making explicit calls to the destructor \nwill generate warnings. Our system does not yet model ownerships for the following C and C++ language \nfeatures: aliases to the address of a pointer mem\u00adber .eld in a class, concurrent execution, exception \nhandling, the use of unsafe typecasts, pointer arithmetic, and function pointers. The use of any of these \nfeatures may prevent our system from iden\u00adtifying all potential leaks. Conversely, if none of these features \nare used, our algorithm is sound and will report all the potential mem\u00adory leaks.  4. OWNERSHIP INFERENCE \nOur ownership inference algorithm automatically infers the likely ownership signatures of .elds and methods. \nIt identi.es statements that are inconsistent with these signatures and warns of potential memory leaks \nand double deletes. Constraints are intro\u00adduced in a carefully designed order so as to isolate the source \nof errors. If a constraint is found to be inconsistent with the already established constraints, it is \ndiscarded and its associated statement is labeled as an error. In the following, we .rst describe our \nspe\u00adcialized constraint solver used to determine if a set of constraints is consistent. Then we describe \nthe interprocedural type inference algorithm. Finally we present the order in which constraints are considered. \n4.1 Constraint Resolution The constraints on ownership variables as shown in the inference rules in Appendix \nA are all 0-1 integer equalities. As introduced in Section 2.4 and further described in Section 4.3.3, \n0-1 integer inequalities are also introduced by our algorithm to minimize error propagation. Ownership \nconstraints are of the form: pOIpIIpEipiIp.Eipi We have developed a solver optimized to take advantage \nof the special properties held by ownership constraints. Our attempt to ap\u00adply a general solver to this \nproblem suggests that it is signi.cantly slower than our special-purpose solver. 4.1.1 Ownership Graphs \nOwnership constraints can be represented by a bipartite owner\u00adship graph G(N,V,E), where Nis a set of \npartitions of own\u00adership variables, Vis a set of .ow nodes representing non-constant constraints, and \nEis a set of directed edges connecting nodes in N to nodes in Vand vice versa. Each partition nENmay \nhave a label, L(n), which can either be 1 representing owning or 0 rep\u00adresenting non-owning. Initially \nevery ownership variable is placed in its own partition. Our solver gradually rewrites the ownership \ngraph to create smaller, equivalent graphs, along with ownership partitioning functions n:O HN, which \nmap elements in the set of ownership variables 0to their respective partitions. Constant constraints \nare represented by labeling the partitions accordingly. Each non-constant constraint .. ppior p.pi ii \nis represented by a .ow node vEV, an edge (n(p),v)and edges (v,n(pi)), for all i. Thus, a .ow node has \none incoming edge and possibly multiple outgoing edges. Flow nodes are so named because they have the \nfollowing properties: 1. If the source of the incoming edge of a .ow node is labeled 0, the outgoing \nedges must also have destinations labeled 0. 2. If the source of the incoming edge of a .ow node is \nlabeled 1, then at most one outgoing edge has a destination labeled 1. In the special case where the \n.ow node represents an equality constraint, then exactly one outgoing edge has a destination labeled \n1.  4.1.2 Consistency Checks We now describe how our solver checks if a new constraint is consistent \nwith a given set of consistent constraints, represented as an ownership graph G(N,V,E)and a partitioning \nfunction n, and returns the combined set of constraints if no inconsistency is detected. If the new constraint \nis a constant constraint, p\", \"E{O,I}, we assign \"to L(n(p)).If n(p)has already been given a different \nlabel, the constraint is inconsistent. If the new constraint is a non\u00adconstant constraint, we represent \nthe constraint by adding a new .ow node and corresponding edges to Gas described above. Next, we apply \nthe rewrite rules below repeatedly to Guntil none is ap\u00adplicable. If any application of the rewrite rules \nrequires assigning a labeled partition with a different value, the new constraint is found to be inconsistent. \nBefore describing the rewrite rules, let us de.ne a few terms. We say that a node nreaches n . if there \nexists a path of edges in Ethat lead nto n ..To unify node n . with node n, we merge the partition of \nn . into nby assigning L(n .)to L(n)and replacing .ow edges (v,n .)and (n . ,v)with edges (v,n)and (n,v), \nrespectively. The rewrite rules we use are as follows: [EDGEREMOVAL]. Remove a .ow node and its edges \nif its pre\u00addecessor and successor nodes are labeled. [SINGLENODE]. If an equality .ow node vhas a single \npredeces\u00adsor nand a single successor n ., unify nand n . . [ZEROIN]. If L(n) from n. O , assign 0 to \nL(n .), for all n . reachable [ZEROOUT]. If L(n) O , eliminate all (v , n )edges in E. [ONEOUT]. If L(n) \nI , assign 1 to L(n .)for all n . reaching n. [MULTIPATH]. If a .ow node reaches the same partition \nnvia two distinct paths, assign 0 to L(n). [CYCLEELIMINATION]. Unify all partitions along a cyclic path \nand assign 0 to any partition reachable from the uni.ed par\u00adtition. All but the last rule are self-explanatory. \nTo understand the CY-CLEELIMINATION rule, we consider two cases. If a partition in a cycle is labeled \n1, it must pass ownership back to itself through the cycle, thus all other partitions along the cycle \nmust also be la\u00adbeled 1. Conversely, if a partition in a cycle is labeled 0, all other partitions must \nalso necessarily be labeled 0. In either case, no ownership is passed downstream. We refer to the ownership \ngraph obtained by the rewrite pro\u00adcedure as the canonical ownership graph. It is easy to show that a \ncanonical ownership graph consists of a set of unconnected directed acyclic graphs (DAGs), whose root \npartitions may be labeled 1 and the rest unlabeled. This graph is trivially satis.able if one of the \nfollowing is true: 1. None of the root nodes is labeled. Labeling all nodes 0 is a solution. 2. The \nlabeled root nodes have no common descendant. A so\u00adlution can be found by assigning 1 to an arbitrary \ndescendant of a labeled root node and 0 to all others.  In the general case, if the above two simple \ntests fail, we can check the connected components of the DAG independently for satis.a\u00adbility; these \nDAGs are found to be small in practice. EXAMPLE 6. Figure 2 is the ownership graph derived from method \nmin Figure 1 with both calls to method ninstantiated. Flow nodes are represented simply by the equal \nsign (=). Square  1 1 1 == = Figure 2: Ownership graph of method min Figure 1 after in\u00adstantiations \nof n. nodes represent variables visible outside of m; circles represent variables internal to m. Each \nsquare and circle represents a parti\u00adtion, unless it is embedded in an oval, which represents the uni.\u00adcation \nof the variables therein. Each partition node is labeled with its ownership assignment, if one is known. \nEdges in the ownership graph are represented by arrows. All nodes and edges instantiated from method \nnare represented by dotted lines. It is easy to see the solution from this graphical representation. \nThe ownerships held by pUI,pV2and pX5all must .ow down the right edge of each .ow node because the rightmost \ndescendant in each case is labeled 1. .  4.2 Interprocedural Analysis Our algorithm is polymorphic, \nor fully context-sensitive, in that it .nds the least constrained signature for each method and .eld \nownership type in well-typed programs. The algorithm introduces no inaccuracy even in the presence of \nrecursive cycles. This section describes how we .nd the method ownership types assuming that .eld ownership \ntypes have already been found. We will discuss how .eld ownerships are handled in Section 4.3. The algorithm \n.rst creates a set of constraints representing the effect of each method, assuming that the called methods \nhave T for constraints. It then iterates to .nd a better approximation until the solution stabilizes. \nOur algorithm precomputes strongly con\u00adnected components from a program s call graph. Method evalua\u00adtion \nis performed in reverse topological order on the components with iteration needed only within components. \nWhenever the own\u00adership type of a method is changed, all the methods that invoke the changed method are \nre-evaluated. To create the initial summary of each method, we collect the con\u00adstraints for each statement \nin the method according to the inference rules presented in Appendix A, ignoring method invocations. \nTo handle arbitrary control .ow in C and C++ programs, we use an SSA-like algorithm to generate ownership \nvariables in the method and uni.cations of ownership variables at the join points of control .ow. Since \nownerships may change for both the source and desti\u00adnation variables in an assignment statement, we have \nadapted the original SSA algorithm to create new ownership variables not only for the destination variables \nbut also for the source variables. We prune the SSA-like form by removing all the unnecessary joins for \nvariables whose live ranges are limited to one basic block[5]. We also apply intraprocedural dead-code \nelimination to further reduce unnecessary assignments in the code. The solver de.ned in Section 4.1 is \napplied to the constraints collected to create a canonical ownership graph for each method. Note that \nthe system may be found to be inconsistent in the process and only consistent constraints are used to \nsummarize a method. In the iterative step, a method is visited only if the signature of at least one \nof its callees has changed. For each callee with new constraint information, we .rst reduce its current \nownership con\u00adstraints to pure relations on formal parameters. We project away the internal partition \nnodes by connecting each input parameter to a fresh .ow node, which is then connected to all output parameters \nreached by that input. This may create many more edges but limits the name space of the ownership partitions. \nThese relations be\u00adtween formal parameters are then instantiated in the calling context by substituting \nactual parameters for the formal parameters. The solver is then applied to check the constraints for \nconsistency and to simplify it. Figure 3: Ownership graph of method min Example 5 after (a) intraprocedural \nanalysis and (b) interprocedural analysis. EXAMPLE 7. Returning to the example in Figure 1, our algo\u00adrithm \n.rst creates an intraprocedural summary for methods nand m. It calls the solver to simplify the constraints \ninternal to each method, ignoring the constraints of any callees, and projects away all internal variables \nother than parameters. The result for mafter the .rst step is shown in Figure 3(a). All that remains \nin the own\u00adership graph for mare the external parameters a/and a/ . and the parameters passed into and \nout of its callee n. Note that the instan\u00adtiated constraints, shown in dotted lines, are not visible \nto this .rst step; they are shown here only for reference. The second step of the algorithm instantiates \nthe constraints from ninto the intraprocedural summary of mand applies the solver to the resulting graph, \nyielding the result shown in Figure 3(b). The .nal signature for mobtained by projecting away all internal \nvariables (and including the ownership variable afor this, which is not included in the .gure) is simply: \n.. [aa/a/;aOla/Ola/O]. . One complication that arises in practice is that programs often invoke functions \nor methods for which no source code is available. These include system calls and calls to libraries that \nare compiled separately. We prede.ne method ownership types for a number of system calls like strdup, \nstrcpyand memcpy. We also allow the user to give a speci.cation for other routines. If no speci.cation \nis provided, we assume that parameters to unde.ned functions are non-owning. 4.3 Constraint Ordering \nWithout a speci.cation, it is impossible to tell which constraints among a set of inconsistent constraints \nare the erroneous ones. Thus we can only use heuristics to .nd the statements most likely to be incorrect. \nMisclassifying an erroneous statement as correct can result in misclassifying many correct statements \nas erroneous. This propagation of errors can result in many warnings, which require more user effort \nto diagnose. Some statements are more precisely modeled than others. For example, allocations are precisely \nmodeled because they will al\u00adways return an owning pointer. On the other hand, the constraint that owning \npointers cannot be stored indirectly is imprecise and is likely to be violated. Similarly, some methods \nare less likely to con\u00adtain ownership errors than others. Destructors are more likely to be correct in \nhandling member .elds than methods that invoke them. Our approach to minimizing error propagation is \nto classify con\u00adstraints according to their degree of precision and to try to satisfy the more precise \nconstraints .rst. In addition, we rank warnings according to the precision of the constraints being violated. \n4.3.1 Typing Fields Before Methods We assume that the implementation of a class is a more reliable source \nfor identifying an interface than code that uses the class. Therefore, our top-level algorithm has two \nsteps: it .rst .nds the ownership type of member .elds in each class by considering only methods within \nthe class; it then uses the .eld ownerships in a whole-program analysis to .nd the method ownership signatures. \nTo .nd class member .eld ownerships, we use an algorithm sim\u00adilar to the one described in Section 4.2. \nThis step analyzes a class at a time. Because even constructors and destructors may invoke other methods, \nan interprocedural analysis is used. We model exter\u00adnal invocations by simply assuming that constructors \nreturn owning pointers and destructors accept owning pointers as arguments and ignoring all other constraints. \nMember .eld ownerships are ini\u00adtialized to T, meaning they can be either owning or non-owning. Destructors \nand constructors are analyzed before other methods. A member .eld is presumed to be owning if it is owning \nat the entry of the destructor or owning at the exit of any of the constructors. It is presumed to be \nnon-owning otherwise. 4.3.2 Ranking Statements The intraprocedural analysis orders the constraints so \nthat the more precise constraints are satis.ed .rst. Below is the ranking used, starting with the most \nprecise: 1. Constant constraints including allocations, deletions, over\u00adwritten variables, and variables \nentering and exiting a scope. 2. Equality .ow constraints with a single output, except those generated \nby uncommon control .ow paths. These arise from join nodes and assignments without choice. Among .ow \nnodes generated from joins, those with a lower fan-in are considered more precise. 3. Constraints generated \nby assignments with choice. 4. Flow constraints arising from joins on uncommon control .ow paths like \nloop continues and breaks. 5. Constraints generated by loads and stores involving indirect pointer accesses. \n  4.3.3 Handling Inaccuracies in Methods The order in which methods are analyzed is dictated by the \ncall graph, since it is not possible to .nd the ownership signature of a method without the signature \nof its callees. This creates a problem because errors in summarizing a callee can propagate interproce\u00addurally \nto all its callers. There are three kinds of constraints that are of particular concern: the constraint \nthat indirectly accessed pointers may not hold own\u00adership, the constraint that unde.ned functions cannot \nhave owning parameters and return values, and the constraint that .elds in the sender object must honor \ntheir ownership type before and after ex\u00adternal invocations. The last constraint is overly restrictive \nbecause most external calls do not access member .elds in the sender ob\u00adject. Our solution is to analyze \nthe program with more relaxed ver\u00adsions of the above constraints. We relax the constraints to allow indirectly \naccessed pointers and parameters to unde.ned functions to optionally hold ownerships. These constraints \nare represented by 0-1 inequalities. A sender s member .elds need not obey the .eld signatures across \nexternal method invocations. At the end of the analysis, we walk through each method, tighten the constraints, \nand report the rest of the violations.   5. EXPERIMENTAL RESULTS Clouseau, the memory leak detector \nwe implemented, incorpo\u00adrates all the techniques described in this paper. Clouseau is im\u00adplemented as \na program analysis pass in the SUIF2 compiler in\u00adfrastructure. Besides .nding potential errors in a given \nprogram, Clouseau also generates inferred ownership signatures of each pro\u00adcedure, class method and class \nmember .eld. These signatures help users understand the warnings generated. Clouseau is sound within \nthe safe subset of C and C++ presented in Section 3.5, meaning that it will report all possible errors \nin the program. Some of these warnings pertain to incorrect usage of the ownership model, which is the \nmain objective of the tool. Some of these warnings are due to limitations of our analysis or the use \nof schemes other than object ownership in managing memory. To evaluate the utility of the Clouseau system, \nwe applied Clouseau to six large C and C++ applications. Our tool reported warnings on all the applications. \nWe examined the warnings to determine if they correspond to errors in the program. We found errors in \nevery package and 134 potentially serious memory leaks and double deletes were found in total. 5.1 The \nApplication Programs The application suite in this experiment consists of three C pack\u00adages and three \nC++ packages. The C programs in the suite are widely used: GNU binutils, which are a set of object .le \ngenera\u00adtion and transformation tools, openssh, a set of secure shell clients and servers, and the apache \nweb server. The C++ applications are under active development: licq, an internet chat client, Pi3Web, \na web server written in C++, and the SUIF2 compiler s base package. The .rst two are available from http://sourceforge.net \nand SUIF2 is available at http://suif.stanford.edu. Many of these packages contain a number of executable \npro\u00adgrams and libraries, as shown in Figure 4. The .gure also includes other statistics on each package \nincluding the number of source .les, the number of functions, and the lines of code (LOC), as mea\u00adsured \nby counting unique non-blank lines of preprocessed source code. In total, our tool analyzed about 390,000 \nlines of code in the experiment. We also report the size of the largest program in each package and the \ntime ownership inference takes for that program. The measurements were taken on a 2 GHz Pentium 4 machine \nwith 2 GBytes of memory. These numbers do not include the time required by the front end, linker, and \npreprocessing transforma\u00adtions. It took 1.2 minutes to analyze 71K lines of C code and Largest Exe Package \nExe Lib Files Func LOC LOC Time binutils 14 4 196 2928 147K 71K 69 openssh 11 2 132 1040 38K 23K 13 apache \n9 27 166 2047 66K 43K 29 licq 1 0 31 2673 28K 28K 240 Pi3Web 48 14 173 2050 40K 25K 85 SUIF2 12 30 203 \n8272 71K 55K 528 TOTAL 95 77 901 19010 390K Figure 4: Application characteristics: number of executables, \nlibraries, .les, functions, lines of code, lines of code in the largest executable and its ownership \nanalysis time in seconds. 8.8 minutes to analyze 55K lines of C++ code. C++ program anal\u00adysis is slower \nbecause of the extra intra-class analysis used to de\u00adtermine member .eld ownerships, the inclusion of \nmember .elds in the analysis, and the larger call graphs generated by class hier\u00adarchy analysis, We have \nnot optimized our implementation, as the analysis was fast enough for experimentation. 5.2 The C Packages \nClouseau generated a total of 1529 warnings for the three C pro\u00adgrams in the suite. The warnings are \nseparated into three classes: violations of intraprocedural constraints, violations of interproce\u00addural \nconstraints, and escaping violations. Escaping violations re\u00adfer to possible transfers of ownership to \npointers stored in struc\u00adtures, arrays or indirectly accessed variables. While these warn\u00adings tell the \nusers which data structures in the program may hold owning pointers, they leave the user with much of \nthe burden of determining whether any of these pointers leak. Users are not ex\u00adpected to examine the \nescaping warnings, so we only examined the non-escaping warnings to .nd program errors. Only 362 of the \nwarnings are non-escaping; 82 are intraproce\u00addural and 280 are interprocedural. We found altogether 85 \nerrors, as shown in Figure 5. The error-to-warning ratio is 32% for in\u00adtraprocedural violations and 21% \nfor interprocedural violations. We found the method signatures generated by Clouseau helpful with our \nexamination of the interprocedural warnings. Intraprocedural Interprocedural Package Reported Bugs Reported \nBugs Escapes binutils 79 26 200 40 727 openssh 1 0 73 18 408 2 0 7 1 32 apache Total 82 26 280 59 1167 \n Figure 5: Reported warnings and identi.ed errors on C appli\u00adcations Many of the errors in binutils \nand openssh are due to missing object deletions along abnormal control .ow paths, such as early procedure \nreturns or loop breaks. Some procedures return both pointers to newly allocated and statically allocated \nmemory. Oc\u00adcasionally, deletes are missing in the normal execution of a loop. In openssh, almost all \nmemory allocation and deletion routines are wrapped by other procedures, thus interprocedural analysis \nis a pre\u00adrequisite to .nding any leaks in the program. The apache web server illustrates an interesting \nscenario. Clouseau reported only 9 warnings, only one of which was found to be an error. Examination \nof these warnings quickly revealed that apache manages its memory using a region-based scheme. While \nClouseau does not understand region-based management, the few warnings generated succeed in helping users \nunderstand how the program manages memory. 5.3 The C++ Packages Clouseau offers more functionality in \n.nding leaks in C++ pro\u00adgrams. By assuming that member .elds are either owning or non\u00adowning at public \nmethod boundaries, Clouseau can .nd errors asso\u00adciated with leaks stored in class member .elds. For C++, \nClouseau generates two more categories of warnings than those for C: vi\u00adolations of receivers member \n.eld ownerships and violations of senders member .eld ownerships in external invocations. The lat\u00adter, \nas discussed in Section 4.3.3, are most likely caused by limita\u00adtions in our model and not real errors \nin the program. The break\u00addown of each category of warnings and errors is shown in Figure 6. We analyzed \nthe receiver-.eld, intraprocedural and interproce\u00addural violations to look for memory leaks and double \ndeletes. We found two common suspicious practices, which we classify as mi\u00adnor errors. First, many classes \nwith owning member .elds do not have their own copy constructors and copy operators; the default implementations \nare incorrect because copying owning .elds will create multiple owners to the same object. Even if copy \nconstruc\u00adtors and copy operators are not used in the current code, they should be properly de.ned in \ncase they are used in the future. Second, 578 of the 864 interprocedural warnings reported for SUIF2 \nare caused by leaks that occur just before the program .nds an assertion vio\u00adlation and aborts. We have \nimplemented a simple interprocedural analysis that can catch these cases and suppress the generation \nof such errors if desired. Counting the minor errors, 770 (69%) of the 1111 examined warnings lead to \nerrors. Ignoring the minor errors and their warnings, 49 (13%) of the 390 examined warnings lead to errors. \nThis experiment shows that the object ownership model is used in all the three C++ applications. Ignoring \nthe minor default copy constructors and copy operators problem, classes with owning member .elds have \nno leaks in Pi3web and licq. In the SUIF2 com\u00adpiler, however, some classes leak owning members because \neither the class destructor does not delete them or the default destructor is used. We also identi.ed \ntwo serious errors where an object can be deleted twice. Double deletes are even more signi.cant than \nmem\u00adory leaks because they can cause memory corruption and unde.ned behavior.  5.4 Discussion Our experience \nin working with real-life applications leads to a number of interesting observations. First, the .eld \nand method signatures generated by Clouseau help explain to the programmer the cause of the warnings. \nIt has been found that good explanations are required for effective error detection tools[6]. Our generated \nmethod interfaces allow users to reason about the methods one at a time. Even when the generated method \ninterfaces are erroneous, programmers can often easily detect such errors. Second, automatic tools are \nnot affected by some of the problems that can mislead programmers. One error we found in binutils was \ncaused by a misnomer. The function bfd alloc does not return ownership of newly allocated objects despite \nits name; giving no credence to function names, Clouseau easily derived this fact from the implementation. \nAs another example, some of the leaks in licq are generated by macros that expand to include early loop \nexits that cause memory leaks. It is dif.cult for a programmer, without look\u00ading at the preprocessed \ncode, to .nd these leaks. These examples Package Receiver-Field Intraprocedural Interprocedural Escapes \nSender-Field Reported Major Minor Reported Major Reported Major Minor Pi3Web 38 0 33 10 0 46 4 0 134 \n36 licq 42 0 40 33 14 114 16 0 231 622 SUIF2 91 8 70 33 5 704 2 578 523 886 Total 171 8 143 76 19 864 \n22 578 888 1544 Figure 6: Reported warnings on C++ applications, with identi.ed major and minor errors \nsuggest that tools can .nd new program errors even in well-audited code. Third, without using or needing \na speci.cation, Clouseau can only .nd inconsistencies in programs and cannot say, for sure, which statements \nin the program are wrong. Inconsistencies are often interesting to programmers, even if they do not correspond \nto erroneous memory usage. In some code in binutils, a pro\u00adgrammer called the wrong function by mistake. \nThe function hap\u00adpened to have an ownership signature different from the intended function. By examining \nthe ownership inconsistency reported by Clouseau, we were able to discover an otherwise hard-to-.nd error. \nSome of the inconsistencies are due to unusual programming styles. Clouseau found a suspicious case where \na pointer to the middle of an object is stored as an owning pointer. The pointer happens to be suitably \ndecremented to point to the beginning of the object be\u00adfore it is freed. Identi.cation of such unconventional \npointer usage might be of interest to a programmer. Fourth, detecting program errors is but the .rst \nstep towards .x\u00ading the errors. Fixing memory leaks, especially when errors are caused by poorly designed \ninterfaces, can be hard. A few of the leaks we found appear to have been discovered before, based on \ncomments in the source .les near the reported problems. They have not been .xed presumably because of \nthe complexity involved. In fact, after we reported one such interface problem in binutils, a developer \nintroduced another bug in an attempt to .x the error. In\u00adcidentally this bug would have been caught by \nClouseau had it been run after applying the .x. While Clouseau successfully helped identify a number \nof er\u00adrors in large complex programs, our experiment also revealed some weaknesses in our current system \nand suggests several interesting avenues for future work. It would be useful and possible to reduce the \nnumber of false warnings among the receiver-.eld, intrapro\u00adcedural and interprocedural violations. We \nfound that predicates are often used to indicate whether pointers own their objects, thus adding path \nsensitivity will reduce the number of false warnings. There are many receiver-.eld violations due to \nthe idiom of using a combination of get and set to replace an owning member .eld. Relaxing the ownership \nmodel and improving the analysis to han\u00addle such cases would be useful. More importantly, we need to \nhelp programmers .nd leaks among the escaping violations. We found that C and C++ programs often pass \npointers to pointers as parameters to simulate a pass-by\u00adreference semantics. Better handling of such \npointers would be useful. We also need to improve the handling of objects in contain\u00aders. Our investigation \nsuggests that containers can be handled by having the user specify the relationships between containers \nand their elements in the code and augmenting the static analysis de\u00adscribed in this paper. Details of \nthis work are the subject of another paper.   6. RELATED WORK This research builds upon previous work \non linear types, object ownership models and capability-based type systems. The design of our system \nis driven mainly by our goal to build a tool that can be applied to the large existing C and C++ code \nbases. Ownership model. Our work is based on a notion of ownership that has been adopted by practitioners \nand shares many similar\u00adities with the concepts embodied in auto ptr and LCLint[13]. Owning pointers \nhelp .nd memory leaks, but do not eliminate ref\u00aderences to dangling pointers. Our model adds optional \nownership transfer in assignment, allows arbitrary aliases, and includes an ob\u00adject ownership invariant \nat public method boundaries. We have for\u00admalized the ownership model and developed an algorithm that \ncan automatically infer polymorphic ownership signatures of the meth\u00adods and .elds in C and C++ programs. \nClarke et al. proposed a stricter model of ownership known as ownership type[9, 21]. The basic notion \nis that an object may own another subobject. An object is always owned by the same object; furthermore, \nownership types enforce object encapsulation, that is, objects can only be referenced through owner pointers. \nThis notion of encapsulation restricts access to the subobjects, thus allowing one to reason about a \nsubobject by only considering methods in the object. This has been used in preventing data races and \ndead\u00adlocks[2]. Various extensions have been proposed to allow restricted forms of access to objects without \ngoing through the owner[2, 7, 8]. AliasJava uses a more .exible ownership type system[1]. While it is \nstill not possible to change the ownership of an object, an owner can grant permission to access an object \nto another object, and aliases can be temporarily created to owned objects. More recent work has enabled \nthe expression of parameterized containers and their iterators while enforcing encapsulation properties[3]. \nSince ownership can be passed around in our system, our work also bears some similarities with linear \ntypes. Because we allow non-owning pointers, assignments may or may not transfer owner\u00adship; the option \nis captured by a constraint, and the system is type\u00adsafe as long as the constraints derived are satis.able. \nStrict linear types require the right-hand-side pointer be nulli.ed. Language ex\u00adtensions have been proposed \nto allow read-only aliases[26]. Boy\u00adland s alias burying allows aliases but the aliases are all nulli.ed \nwhen one of them is read[4]. He proposed an inference algo\u00adrithm that requires annotations be placed \non procedural interfaces. Alias types have been proposed to allow limited forms of aliasing by specifying \nthe expected data memory shape properties[24, 27]. Linear types have been applied to track resource usage[14] \nand ver\u00adify the correctness of region-based memory management[10, 15, 16, 17, 18, 25]. Finally, Dor et \nal. propose checking for mem\u00adory leaks using a sophisticated pointer shape analysis[11]; unfor\u00adtunately \nthe scalability of this powerful technique has not been demonstrated. Automatic Inference. Our ownership \ninference is fully auto\u00admatic and quite powerful. Automatic interprocedural annotation inferencing is \nalso used in other software understanding tools in\u00adcluding Lackwit[23], Ajax[22] and AliasJava[1]. While \nall these tools support polymorphism, or context sensitivity, our algorithm is also .ow-sensitive unlike \nthe .rst two of these. Moreover, we do not know of any other inference algorithms that allow choice in \nownership transfer in assignment statements and method invoca\u00adtions. This idea is also useful for solving \nother resource manage\u00adment problems. Experimental Results. This paper includes experimental results demonstrating \nthe success of our system in .nding errors in large C and C++ programs. Very few experimental results \nhave been reported in previous work involving ownership-based models. We are able to apply our system \nto large programs because the system assumes a .exible model, requires no user intervention, and has \nan ef.cient .ow-sensitive and context-sensitive algorithm. The GNU C++ compiler has a -WeffC++.ag which \nwarns of violations of Meyers s effective C++ rules, which include some rules to minimize memory leaks. \nThe tool uses mainly syntactic analysis and tends to generate many false warnings. Fully auto\u00admatic tools \nlike PRE.x[6] and Metal[12, 19] have been found to be effective in .nding program errors. Although unsound \nand lacking a notion of object invariants, these tools have been shown to .nd many errors in large systems. \nHandling false warnings is a major issue in both of these systems. Experience with the PRE.x system shows \nthat it is important to prioritize the warnings so programmers can focus on the most likely errors. Metal \nstatistically identi.es common coding practice in a program and classi.es deviations as errors. We also \nprioritize warnings based on their likelihood of repre\u00adsenting real errors. Moreover, because errors \nin our system appear as consistency violations, it is particularly important to attribute the errors \nto their source correctly. We do so by satisfying the more pre\u00adcise constraints .rst. Our experience \nwith Clouseau con.rms that a good constraint ordering is important to generating useful error reports. \n 7. CONCLUSIONS This paper formalizes a practical object ownership model for managing memory. In this \nmodel, every object is pointed to by one and only one owning pointer. The owning pointer holds the exclusive \nright and obligation to either delete the object or to trans\u00adfer the right to another owning pointer. \nIn addition, a pointer-typed class member .eld either always or never owns its pointee at public method \nboundaries. This model can be used to analyze existing code as is because it supports the normal semantics \nof assignments and method in\u00advocations. Namely, assignments may transfer ownership from the source to \nthe destination variable, but are not required to do so. We capture the choice of ownership transfer \nwith 0-1 integer linear in\u00adequalities. In addition, method interfaces also use 0-1 integer linear inequalities \nto capture the ownership relationships among parame\u00adters in a method. This representation supports a \npowerful form of polymorphism. We have developed a .ow-sensitive and context-sensitive algo\u00adrithm that \nautomatically infers .eld and method ownership signa\u00adtures in C and C++ programs and identi.es statements \nviolating the model as errors. We have optimized the algorithm by using a sparse graph representation \nand a custom constraint solver to take advantage of the highly-structured 0-1 ownership constraints. \nOur memory detection tool, Clouseau, is designed to help users isolate errors in a program. It tries \nto satisfy the more precise con\u00adstraints .rst to prevent errors associated with the less precise con\u00adstraints \nfrom propagating. Warnings are ranked so as to focus users on warnings most likely to lead to errors. \nFinally, the member .eld ownerships and method signatures that the tool generates give the context of \nreported constraint violations and minimize the code in\u00adspection required to identify bugs from the warnings. \nOur experimental results suggest that our algorithm is effective and ef.cient. It .nds errors in each \nof the large software systems we experimented with, which include web servers, secure shell clients and \nservers, a chat client, object code tools and the SUIF compiler. The algorithm is practical; it analyzed \nover 50K lines of C++ code in about 9 minutes on a 2 GHz PC. 8. REFERENCES [1] J. Aldrich, V. Kostadinov, \nand C. Chambers. Alias annotations for program understanding. In Proceedings of OOPSLA 2002: Object-Oriented \nProgramming Systems, Languages and Applications, pages 311 330, November 2002. [2] C. Boyapati, R. Lee, \nand M. Rinard. Ownership types for safe programming: Preventing data races and deadlocks. In Proceedings \nof OOPSLA 2002: Object-Oriented Programming Systems, Languages and Applications, pages 211 230, November \n2002. [3] C. Boyapati, B. Liskov, and L. Shrira. Ownership types for object encapsulation. In Proceedings \nof the Thirtieth Annual ACM Symposium on Principles of Programming Languages, pages 213 223, January \n2003. [4] J. Boyland. Alias burying: Unique variables without destructive reads. Software Practice and \nExperience, 31(6):533 553, May 2001. [5] P. Briggs, K. D. Cooper, T. J. Harvey, and L. T. Simpson. Practical \nimprovements to the construction and destruction of static single assignment form. Software Practice \nand Experience, 28(8):859 881, July 1998. [6] W. R. Bush, J. D. Pincus, and D. J. Sielaff. A static \nanalyzer for .nding dynamic programming errors. Software Practice and Experience, 30(7):775 802, June \n2000. [7] D. Clarke. An object calculus with ownership and containment. In The Eighth International Workshop \non Foundations of Object-Oriented Languages, January 2001. [8] D. Clarke and S. Drossopoulou. Ownership, \nencapsulation and the disjointness of type and effect. In Proceedings of OOPSLA 2002: Object-Oriented \nProgramming Systems, Languages and Applications, pages 292 310, November 2002. [9] D. G. Clarke, J. \nM. Potter, and J. Noble. Ownership types for .exible alias protection. In Proceedings of OOPSLA 98: Object-Oriented \nProgramming Systems, Languages and Applications, pages 48 64, October 1998. [10] K. Crary, D. Walker, \nand G. Morrisett. Typed memory management in a calculus of capabilities. In Proceedings of the Twenty-sixth \nAnnual ACM Symposium on Principles of Programming Languages, pages 262 272, January 1999. [11] N. Dor, \nM. Rodeh, and S. Sagiv. Checking cleanness in linked lists. In Proceedings of the Static Analysis Symposium, \npages 115 134, July 2000. [12] D. Engler, D. Y. Chen, S. Hallem, A. Chou, and B. Chelf. Bugs as deviant \nbehavior: A general approach to inferring errors in systems code. In Proceedings of Eighteenth ACM Symposium \non Operating System Principles, pages 57 72, October 2001. [13] D. Evans. Static detection of dynamic \nmemory errors. In Proceedings of the SIGPLAN 96 Conference on Programming Language Design and Implementation, \npages 44 53, May 1996. [14] M. F\u00a8ahndrich and R. DeLine. Adoption and focus: Practical linear types for \nimperative programming. In Proceedings of the ACM SIGPLAN 2002 Conference on Programming Language Design \nand Implementation, pages 13 24, June 2002. [15] D. Gay and A. Aiken. Memory management with explicit \nregions. In Proceedings of the ACM SIGPLAN 98 Conference on Programming Language Design and Implementation, \npages 313 323, May 1998. [16] D. Gay and A. Aiken. Language support for regions. In Proceedings of the \nACM SIGPLAN 2001 Conference on Programming Language Design and Implementation, pages 70 80, May 2001. \n[17] D. K. Gifford and J. M. Lucassen. Integrating functional and imperative programming. In ACM Conference \non Lisp and Functional Programming, pages 28 38, August 1986. [18] D. Grossman, G. Morrisett, T. Jim, \nM. Hicks, Y. Wang, and J. Cheney. Region-based memory management in cyclone. In Proceedings of the ACM \nSIGPLAN 2002 Conference on Programming Language Design and Implementation, pages 282 293, June 2002. \n[19] S. Hallem, B. Chelf, Y. Xie, and D. Engler. A system and language for building system-speci.c, static \nanalyses. In Proceedings of the ACM SIGPLAN 2002 Conference on Programming Language Design and Implementation, \npages 69 82, June 2002. [20] R. Hastings and B. Joyce. Purify: Fast detection of memory leaks and access \nerrors. In Proceedings of the Winter USENIX Conference, pages 125 136, December 1992. [21] J. Noble, \nJ. Vitek, and J. Potter. Flexible alias protection. In The 12th European Conference on Object-Oriented \nProgramming, pages 158 185, July 1998. [22] R. O Callahan. Generalized Aliasing as a Basis for Program \nAnalysis Tools. PhD thesis, Carnegie Mellon University, November 2000. [23] R. O Callahan and D. Jackson. \nLackwit: A program understanding tool based on type inference. In Proceedings of the 19th International \nConference on Software Engineering, pages 338 348, May 1997. [24] F. Smith, D. Walker, and G. Morrisett. \nAlias types. In Proceedings of the Ninth European Symposium on Programming, pages 366 381, April 2000. \n[25] M. Tofte and J.-P. Talpin. Region-based memory management. Information and Computation, 132(2):109 \n176, February 1997. [26] P. Wadler. Linear types can change the world. In M. Broy and C. B. Jones, editors, \nIFIP TC 2 Working Conference on Programming Concepts and Methods, pages 561 581, April 1990. [27] D. \nWalker and G. Morrisett. Alias types for recursive data structures. Lecture Notes in Computer Science, \n2071:177 206, 2001. [28] A. K. Wright and M. Felleisen. A syntactic approach to type soundness. Information \nand Computation, 115(1):38 94, November 1994. APPENDIX  A. STATIC TYPING RULES This appendix includes \nall the static typing rules in our owner\u00adship type system. Figure 7 gives the typing rules for all statements \nin a method, other than those involving method invocations. Fig\u00adure 8 gives the typing rules for method \nde.nitions and invocations. Figure 9 gives the syntax and the rules of the static judgments. A program \nPis well-typed, Pf, if it has a well-typed constructor, destructor, methods and .elds for each class \nin the program. A set of constraints Cis good, fC, if it is consistent. We de.ne the restriction Cta5to \nbe the resulting constraint after projecting away all variables but those in a5. (STMT-NULL) .. Dfz:pzpzfreshCCl{pzO} \nB;D;CfzNULL=D[zHpz .];C. (STMT-ASGN) Dfy:py,z:pz ... .. pz,pyfreshCCl{pzO}l{pypy+pz} . .. B;D;Cfzy=D[zHpz,yHpy];C \n(STMT-FLDASGN) .. Bfthis:Dfy:py,this.f:p/p/,pyfresh . .. CCl{p/O}l{pypy+p/}fEF() . .. B;D;Cfthis.fy=D[this.fHp/,yHpy];C \n(STMT-FLDUSE) .. Bfthis:Dfthis.f:p/,z:pzpz,p/fresh . .. CCl{pzO}l{p/p/+pz}fEF() . .. B;D;Cfzthis.f=D[ZHpz,this.fHp/];C \n(STMT-COMP) B;D;Cfs .=D;CB;D;Cfs .=D;C ...... B;D;Cfs . s .=D.;C. (STMT-IF) B;D;Cfs .=D.;C. B;D;Cfs .=D.;C. \nC. ClCl{D(x)D(x)IxEDom(D)} .... . B;D;Cfif.thens .elses .=D.;C (STMT-WHILE) B;D;Cfs=D.;C. C. ClCl{D(x)D(x)IxEDom(D)} \n.. . B;D;Cfwhile.dos=D;C Figure 7: Typing rules for statements [METHOD-GOOD] .. MOT(m)[a,a5Xa5/a5/a/;Cm] \nf5F()p/,p5zfreshthis:,5x:t5 .,r:t.,5z:t5.;this:a,,5x:a5X,this.f5:a5/,r:p/,5z:p5z;true fs=D;C .. ... Dfthis:p,,5x:p5X,this.f5:p5/,r:p/,5z:p5z \n. ........ .. C{p/O}l{p5zO}lCl{p,O}l{p5XO}l{p5/a5/}l{p/a/}l{p5zO}fCmCm:Cta,a5Xa5/a5/a/ fm(this:,5x:t5 \n.):t.{soper:t.,5z:t5{sreturnr}} . [CONSTR-GOOD] .. 5 MOT(new)[a5Xa5/a/;Cm]fF()p,,p5/,p5zfresh .. .. \n this:,5x:t5 .,5z:t5.;this:p,,5x:a5X,this.f5:p5/,5z:p5z;true fs=D;CDfthis:p,,5x:p5X,this.f5:p5/,5z:p5z \n. ...... ... C{p,I}l{p5/O}l{p5zO}lCl{p,a/I}l{p5XO}l{p5/a5/}l{p5zO}fCmCm:Cta5Xa5/a/ 5 fnew(5x:t5 .):{sopethis:,5z:t{sreturnthis}} \n. [DESTR-GOOD] 555 MOT(delete)[a,a5/;Cm]fF()p5zfreshthis:,5z:t.;this:a,,this.f:a5/,5z:p5z;true fs=D;C \n. ... ... . 5 Dfthis:p,,this.f:p5/,5z:p5zC{a,I}l{p5zO}lCl{p,I}l{p5/O}l{p5zO}fCmCm:Cta,a5/ fdelete(this:){sope5z:t5.{s}} \n[STMT-INTCALL] Bfthis:f5F()Dfthis:p,,5x:p5X,this.f5:p5/,r:p/ .... .. .. .. p,,p5X,p5/,p/freshMOT(m)[a,a5Xa5/a5/a/;Cm]CsCm[a,a5Xa5/a5/a/fresh/a,a5Xa5/a5/a/] \n. . ..... CCl{p/O}lCsl{p,p,+a,}l{p5Xa5X}l{p5XO}l{p5/a5/}l{a5/p5/}l{a/p/} .. ... B;D;Cfrthis.m(5x)=D[thisHp,,5xHp5X,this.f5Hp5/,rHp/];C \n[STMT-EXTCALL] 555 Bfy:,this:. fF()f. F(.)Dfy:p,,5x:p5X,this.f.:p5/I,r:p/ ... .. .... p,,p5Xp/freshMOT(m)[a,a5Xa5/a5/a/;Cm]CsCm[a,a5Xa5/a5/a/fresh/a,a5Xa5/a5/a/] \n. . .... CCl{p/O}l{p5/I FOTI(f5.)}lCsl{p,p,+a,}l{p5Xa5X}l{p5XO}l{a5/a5/FOT(f5)}l{a/p/} B;D;Cfry.m(5x)=D[yHp,. \n,5xHp5X . ,rHp/ .];C. [STMT-CONSTR] Bfthis:. f5F()f5. F(.) 5 .. .. .... Df5x:p5X,this.f.:p5/I,r:p/p5X,p/freshMOT(new)[a5Xa5/a/;Cm]CsCm[a5Xa5/a/fresh/a5Xa5/a/] \n. .. .. CCl{p/O}l{p5/I FOTI(f5.)}lCsl{p5Xa5X}l{p5XO}l{a5/FOT(f5)}l{a/p/} B;D;Cfrnew(5x)=D[5xHp5X . ,rHp/ \n.];C. [STMT-DESTR] Bfy:,this:. f5F()f5. F(.)Dfy:p,,this.f5.:p5/I,p, . freshMOT(delete)[a,a5/;Cm] CsCm[a,a5/fresh/a,a5/]C. \nCl{p5/I FOTI(f5.)}lCsl{p,p, . +a,}l{a5/FOT(f5)} B;D;Cfy.delete()=D[yHp,.];C. Figure 8: Good method de.nition \nand invocation typing rules [PROGRAM-GOOD] VECL(P),VfEF(),mEM() FOT(f)[p;p\"]\"E{O,I}fm(this:,5x:t5.):t.{...}fnew(5x:t5.):{...}fdelete(this:){...} \nPf [CONSTRAINT-GOOD] C.false fC Figure 9: Well-typed programs  \n\t\t\t", "proc_id": "781131", "abstract": "This paper presents a static analysis tool that can automatically find memory leaks and deletions of dangling pointers in large C and C++ applications.We have developed a type system to formalize a practical ownership model of memory management. In this model, every object is pointed to by one and only one <i>owning</i> pointer, which holds the exclusive right and obligation to either delete the object or to transfer the right to another owning pointer. In addition, a pointer-typed class member field is required to either always or never own its pointee at public method boundaries. Programs satisfying this model do not leak memory or delete the same object more than once.We have also developed a flow-sensitive and context-sensitive algorithm to automatically infer the likely ownership interfaces of methods in a program. It identifies statements inconsistent with the model as sources of potential leaks or double deletes. The algorithm is sound with respect to a large subset of the C and C++ language in that it will report all possible errors. It is also practical and useful as it identifies those warnings likely to correspond to errors and helps the user understand the reported errors by showing them the assumed method interfaces.Our techniques are validated with an implementation of a tool we call Clouseau. We applied Clouseau to a suite of applications: two web servers, a chat client, secure shell tools, executable object manipulation tools, and a compiler. The tool found a total of 134 serious memory errors in these applications. The tool analyzes over 50K lines of C++ code in about 9 minutes on a 2 GHz Pentium 4 machine and over 70K lines of C code in just over a minute.", "authors": [{"name": "David L. Heine", "author_profile_id": "81100046776", "affiliation": "Stanford University", "person_id": "P517401", "email_address": "", "orcid_id": ""}, {"name": "Monica S. Lam", "author_profile_id": "81100237956", "affiliation": "Stanford University", "person_id": "PP14092336", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/781131.781150", "year": "2003", "article_id": "781150", "conference": "PLDI", "title": "A practical flow-sensitive and context-sensitive C and C++ memory leak detector", "url": "http://dl.acm.org/citation.cfm?id=781150"}