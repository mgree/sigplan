{"article_publication_date": "05-09-2003", "fulltext": "\n Checking and Inferring Local Non-Aliasing Alex Aiken University of California, Berkeley aiken@cs.berkeley.edu \n John Kodumal University of California, Berkeley jkodumal@cs.berkeley.edu  Jeffrey S. Foster University \nof Maryland, College Park jfoster@cs.umd.edu Tachio Terauchi University of California, Berkeley tachio@cs.berkeley.edu \n ABSTRACT In prior work [15] we studied a language construct restrictthat allows programmers to specify \nthat certain pointers are not aliased to other pointers used within a lexical scope. Among other appli\u00adcations, \nprogramming with these constructs helps program analysis tools locally recover strong updates, which \ncan improve the track\u00ading of state in .ow-sensitive analyses. In this paper we continue the study of \nrestrict and introduce the construct confine. We present a type and effect system for checking the correctness \nof these annotations, and we develop ef.cient constraint-based al\u00adgorithms implementing these type checking \nsystems. To make it easier to use restrictand confinein practice, we show how to automatically infer \nsuch annotations without programmer as\u00adsistance. In experiments on locking in 589 Linux device drivers, \nconfine inference can automatically recover strong updates to eliminate 95% of the type errors resulting \nfrom weak updates. Categories and Subject Descriptors D.2.1 [Software Engineering]: Requirements/Speci.cations; \nD.3.3 [Programming Languages]: Language Constructs and Features; D.2.4 [Software Engineering]: Software/Program \nVeri.cation; F.3.1 [Logics and Meanings of Programs]: Specifying and Verifying and Reasoning about Programs; \nF.3.3 [Logics and Meanings of Programs]: Studies of Program Constructs General Terms Algorithms, Design, \nReliability, Experimentation, Languages, The\u00adory, Veri.cation  Keywords Restrict, con.ne, types, type \nquali.ers, alias analysis, effect infer\u00adence, .ow-sensitivity, constraints, locking, Linux kernel Permission \nto make digital or hard copies of all or part of this work for personal or classroom use is granted without \nfee provided that copies are not made or distributed for pro.t or commercial advantage and that copies \nbear this notice and the full citation on the .rst page. To copy otherwise, to republish, to post on \nservers or to redistribute to lists, requires prior speci.c permission and/or a fee. PLDI 03, June 9 \n11, 2003, San Diego, California, USA. Copyright 2003 ACM 1-58113-662-5/03/0006 ...$5.00. 1. INTRODUCTION \nAlmost all program analyses for languages with pointers must perform some form of alias analysis: when \na program indirectly loads or stores through a pointer p, the analysis must determine to which location(s) \np points. Alias analysis is a key ingredient in many program checking systems and compiler optimizations. \nThe research literature abounds with proposed alias analysis techniques [1, 7, 10, 18, 20, 21, 24, 26, \n30] (to name only a few), some of which scale to very large programs. Almost all of these techniques \nare fully automatic. That is, such an analysis takes a bare program and infers all possible aliasing. \nThis paper is about aliasing in programs, but the purpose is dif\u00adferent from previous work on automatic \nalias analysis. Our mo\u00adtivation comes from experience developing and using CQUAL,a system for extending \nC with user-de.ned type quali.ers [15]. Con\u00adsider the partial program shown in Figure 1. We use this \nexample to tell a story, the moral of which is that we needed a new form of alias analysis to make CQUAL \nand similar analyses work in prac\u00adtice; that new form of alias analysis, previously sketched brie.y [15] \nand developed further here, is the topic of this paper. One application of CQUAL is to verify properties \nof locking. CQUAL usestwo non-standard, .ow-sensitive(see below) type qual\u00adi.ers lockedand unlockedto \nre.ne the type lock. If all goes well in the example in Figure 1, CQUAL infers that *l (the lock that \nl points to) has type unlocked lock at point 1 (i.e., the lock is not held), the type locked lockat point \n2 (i.e., the lock is held), and the type unlocked lock at point 3.1 In this way, CQUAL checks code for \ndeadlocks caused by reacquiring a lock that is already held or releasing a lock that has not been acquired. \nCQUAL models state by mapping every program variable v (or other concrete memory location) to an abstract \nlocation ..If two program quantities may alias each other (according to a particular alias analysis), \nthey are mapped to the same abstract location. In the example, because our alias analysis cannot distinguish \ndifferent elements of an array, all elements of the array reside at the same abstract location .. Similarly, \nlpoints to location ., meaning that *lis stored at location ., and thus both *land all array elements \nmay alias. To analyze locking CQUAL performs a .ow-sensitive analysis, which means that CQUAL must be \nable to assign *ldifferent types at different points in the program. Assume that all locks in the array \nbegin in the state unlocked lock. The call to spin lock(l) changes the state of *l to a locked lock. \nHowever, it is not *l s state that is changed, but the state of *l s abstract location 1To accomplish \nthis, CQUAL also needs to know how the functions spin lock and spin unlock change the state of locks. \nThis information is given as type signatures [15].  void foo(int i) { do_with_lock(&#38;locks[i]); \n } void do_with_lock(lock *l) { /* 1 */ spin_lock(l); /* 2 */ work(); spin_unlock(l); /* 3 */ } Figure \n1: Example program .. But . stands for other locks, too namely the other locks in the array, which are \nstill in the unlockedstate. Thus after the call to spin lock(l)the static information about . degrades \nto know\u00ading only that any locks it represents may be either in the lockedor the unlockedstate, and the \nveri.cation of any locking properties on any of these locks becomes impossible. The dif.culty is that \nthe single abstract location . stands for mul\u00adtiple concrete locks, and the call to spin lock(l)only \nchanges the state of a single lock. Thus the information about . after the call to spin lock(l)is the \nunion of the old state (for the locks that did not change) and the new state (for the one lock that did \nchange). In .ow-sensitive analysis, this is known as a weak update. What we need for accurate analysis, \nthough, is a strong update:we want to change the state of *l from unlocked to locked and not affect the \nstatus of any other lock. The need to perform strong updates is not speci.c to locks. This problem arises \nin any static analysis where there are both collections such as arrays or lists and we want to track \nstate changes of values. If we knew that do with lock could only access *l through its formal parameter \nl, and not through some alias it holds through, e.g., a global variable, then locally within do with \nlockwe could ignore the aliases of *l external to do with lock and perform strong updates on *l s location \n[15]. The recent C99 standard for the C programming language [2] provides a way to say almost exactly \nthis. Change the de.nition of do with lockto void do_with_lock(lock *restrict l) At a high level, the \nrestrict keyword means that no alias of *l de.ned outside of do with lock is used during the func\u00adtion \ns execution. Although there may be many aliases of l in the program, locally we know l is the only way \nfor do with lock to access *l. This notion of locally unaliased pointers is miss\u00ading from conventional \n.ow-insensitive may-alias analysis, where pointers are either aliased or not and the only scope of interest \nis the entire program. Notice that while context-sensitive [24] or parame\u00adterized [21] alias analysis \nmay help our do with lockexample, we can also use restrict to indicate local non-aliasing within nested \nscopes smaller than function scopes. Indeed, we make use of this feature in our experiments (Section \n7). Another key feature of restrict is that it provides a form of program documentation: it allows the \nprogrammer to specify a particular kind of non-aliasing. Combined with a checking sys\u00adtem such as we \npropose, we believe that restrict is not only bene.cial for tools like CQUAL, but also for the programmer \nwhen writing their program. In C, restrict is trusted and unchecked by the compiler it amounts to a license \nfor compilers to perform aggressive optimiza\u00adtions that would be unsound in the presence of aliases. \nWe believe restrictis even more useful in program checking tools, and not just for C programs, but for \nprograms written in any language with references. While there are important exceptions, such as functions \nthat copy data or pointers, we believe many pointers in practice can be marked restricted.      \n    The thesis of this paper is that restricted references are com\u00admon in real programs, and that \nexploiting this (usually implicit) structure is important to software engineering tools such as CQUAL \nthat need to reason about references. More speci.cally, the contri\u00adbutions of this paper are: We develop \na formal semantics of restrict(Section 3.2) and also present an informal description and examples (Sec\u00adtion \n2).  We give a type and effect system [22] for checking that a restrict-annotated program is correct \nwith respect to our semantics (Section 3).  We give a O(kn) constraint-based algorithm for verifying \nrestrict annotations, where n is the size of the typed program and k is the number of restrict annotations \nin the pro\u00adgram. The type system for restrict is described brie.y in prior work [15], but this is the \n.rst description of the type checking algorithm (Section 4).  In using CQUAL we have found it necessary \nto add many more restrict annotations to programs than we would like to do by hand. This motivates the \nidea of restrict in\u00adference: not just checking user-supplied restrictannota\u00adtions, but automatically \ninferring restricts in a program with no restrict annotations. We give an O(n 2) algo\u00adrithm for restrictinference \n(Section 5).  Furthermore, in many applications we wish to restrict not just a variable, but an expression. \nThis extension of restrict introduces two new problems. First, to treat an arbitrary expression as a \nname, it must be referentially transparent, which introduces additional constraints beyond what is required \nfor restrict. We call this stronger con\u00addition con.ning an expression and likewise name the associ\u00adated \nconstruct confine. Second, for confine inference we have the additional problem of inferring in what \nscope an expression can be con.ned (Section 6).  We present the results of experiments with confineinfer\u00adence, \nin which we use CQUAL to analyze the locking behav\u00adior of 589 Linux device drivers. In this experiment, \nconfine is very effective at identifying the program points where strong updates can aid the analysis \n(Section 7).  2. RESTRICT This section gives an informal semantics of restrictand sev\u00aderal examples. \nSection 3.2 sketches a precise, formal semantics of restrict. Let pbe a pointer declared as int *restrict \np; meaning that p is a restricted pointer to an integer, and suppose p points to object X. The simplest \nuse of restrictis to bind a new name pfor all accesses of Xin a local scope. Here an access within a \nscope is either a direct access or an access that occurs during the execution of a function called within \nthat scope. The following example demonstrates valid and invalid pointer dereferences within the scope \nof a restrict: { int *restrict p = q; *p; // valid *q; // invalid *a; // invalid if a and q may alias \n } Here p is initialized to q, and we attempt to dereference p, q, and awithin the scope of p. Since \npis annotated with restrict,we may dereference pbut we may not dereference qor a(if aaliases q). In other \nwords, within the scope of the restrict, the name p (and copies derived from p; see below) must be the \nsole access to the location ppoints to. As another example, the following code shows that restrict\u00adquali.ed \npointers may be re-bound in an inner scope: { int *restrict p = ...; { int *restrict r = p; *r; // \nvalid *p; // invalid } *p; // valid } In our version of restrict (which differs from C99 [2] on \na few points; see below), it is legal to create and use some aliases of restricted pointers. Consider \nthe following example: int *x; { int *restrict p = ...; int *r= p; *r; // valid: use of local copy \n x = p; // invalid: copy escapes } Here we are allowed to make copies of the restricted pointer p, \nwhich we can also dereference inside of the restrict. Intuitively, annotating the de.nition of pwith \nrestrictsplits the aliases of pinto two groups: Aliases of pcreated outside scope of the restrictmay \nbe accessed outside the restrictbut not inside.  pand aliases of pcreated inside the scope of the restrict \nmay be accessed within the scope of the restrictbut not outside.  In most uses of restrict, only the \nrestricted pointer itself is used to reference storage it points to inside the restrict con\u00adstruct. In \nthis common case, restrict serves to create a local pointer that is known to be the sole access to its \nstorage in a par\u00adticular scope. However, there is no dif.culty in supporting copies of restricted pointers \nas in the example above. The require\u00adment that aliases created inside the restrictnot be used outside \nof the restrict means that we must check that no aliases of the restricted pointer escape the scope of \nthe restrict. Thus the assignment to x is illegal in the example above and would be .agged as an error \nby our system. References can also escape by being stored into the heap or global variables; our system \ndisal\u00adlows such operations on restricted pointers. While we have found that preventing restricted pointers \nfrom escaping suf.cient so far, one can imagine applications where allowing restricted pointers to leave \ntheir original scope of de.nition might be useful. We plan to consider such an extension as future work. \nAs mentioned in the introduction, our version of restrictis inspired by the ANSI C keyword of the same \nname [2]. The ma\u00adjor difference between our version of restrict and ANSI C s is that in ANSI C restrictis \nnot checked the programmer is assumed to have added the restrictquali.er correctly. Another difference \nis that in ANSI C, a restrictannotation on a pointer p is ignored if the object pointed to by p is not \nwritten within the scope of the restrict. For a full discussion, see [13, 14].  3. LANGUAGE AND TYPE \nCHECKING We present our type system for restrictusing a small imper\u00adative language: e ::= x Variable \n||||| n Integer new e Allocate memory initialized to e *e Dereference pointer e e1 :=e2 Assign e2 to \ne1 letx =e1 ine2 Bind e1 to name x in e2 | restrictx =e1 ine2 Restrict e1 to name x in e2 For simplicity, \nwe have omitted function de.nitions and calls from the language. The treatment of functions is standard \nand introduces no new issues; we omit it for brevity. Statement sequencing e1; e2 is also not present \nin the language, but is easily added with no com\u00adplications. A discussion of the language extended with \nfunctions, as well as a detailed proof of soundness, can be found elsewhere [13, 14]. Besides variables, \nintegers, pointer allocation new e, derefer\u00adence *e, and assignment, our language has two mechanisms \nfor introducing local variables. The .rst is letx =e1 ine2, which simply initializes a new pointer variable \nx to e1 for use in e2. There is also a new scoping construct restrictx =e1 ine2 with the following meaning: \nlike let, the pointer x is initialized to e1 and bound within the body e2. However, unlike let, within \ne2 the only access to the location x points to is through x or values derived from x. To enforce the \nsemantics of restrict, our type system needs two extensions of standard types. First, we need a way to \nkeep track of program names that may be aliased to one another. We use the standard solution, which is \nto associate abstract memory locations . with pointer types. Names that have the same abstract location \nin their types may be aliased to the same concrete memory location. The grammar for types is: t ::= int \n|ref .(t ) Pointer types are ref .(t ), meaning a pointer to a value of type t where . is the abstract \nlocation pointed to. Second, we need to enforce the rule that a location .0 may not be accessed within \nthe body e of a restrict. To accomplish this, we calculate the set of abstract locations Le that e may \nread or write and check .0. Le. The set Le is called the effect of e [16]. The grammar for effects is: \nL ::= \u00d8|{.}|L1 .L2 |L1 nL2 We need one auxiliary function for our type checking system. We write locs(t \n) for the set of locations occurring in the type t , de.ned as locs(int)= \u00d8 locs(ref .(t )) = {.}.locs(t \n) Our type system proves judgments of the form G fe : t ; L (Var) G fx:G(x); \u00d8 (Int) G fn : int; \u00d8 G \nfe: t; L (Ref) G fnew e: ref .(t); L.{.} G fe: ref .(t); L (Deref) G f*e: t; L.{.} G fe1 : ref .(t); \nL1 G fe2 : t; L2 (Assign) G fe1 :=e2 : t; L1 .L2 .{.} G fe1 : ref .(t1); L1 G[x (t1)] fe2 : t2; L2 .ref \n. (Let) G fletx=e1 ine2 : t2; L1 .L2 G fe1 : ref .(t1); L1 G[x (t1)] fe2 : t2; L2 .ref .' ..L2 .' .locs(G,t1,t2) \n (Restrict) G frestrictx=e1 ine2 : t2; L1 .L2 .{.} Figure 2: Type Checking Rules meaning that expression \nehas type t in type environment G (a map\u00adping of variables to types), and the evaluation of emay read \nor write . the locations in L. We de.ne locs(G) as locs(t). x:t.G Figure 2 gives the type checking rules \nfor our language. We brie.y discuss the rules, which except for restrictare all typi\u00adcal of effect systems. \n (Var) looks up the type of a variable in the type environment G. Looking up a pointer variable does \nnot dereference that variable and thus has no effect.  (Int) says an integer constant has type int. \nThere is no effect.  (Ref) constructs a pointer type; there is an effect on the allo\u00adcated location. \n (Deref) deconstructs a pointer type. Since operationally a dereference reads a location, we add ., \nthe abstract location pointed to by e, to the effect set.  (Assign) updates a location. As with (Deref), \nwe add .to the effect set, since the assignment updates e1. Notice we require that the type of e2 and \nthe type pointed to by e1 match. Since those types may themselves contain abstract locations, this rule \nencodes a uni.cation-based may-alias analysis Steens\u00adgaard [26].  (Let) does two things. First, letintroduces \na local variable  x. The type of x is required to be a pointer. This restriction just makes let parallel \nwith restrict in our small lan\u00adguage (restrictonly makes sense for pointers). Second, letevaluates both \ne1 and e2; note that the effect of the let is the union of the effects of these two expressions. The \nkey rule in this system is (Restrict). The rule is written to highlight the similarities and differences \nwith the rule for let, which introduces normal unrestricted pointers. There are four dif\u00adferences: Recall \nthe semantics of restrictx=e1 ine2 states that x is a pointer to a copy of the location pointed to by \ne1 (Sec\u00adtion 2). This naturally suggests giving x a type with a fresh abstract location .' during the \nevaluation of e2. With this binding we can distinguish accesses through x or copies of x, which have \nan effect on location .', from accesses through other aliases of e1, which have an effect on location \n..  The constraint . .L2 prevents other aliases of e1 from being accessed within e2.  The constraint \n.' .locs(G,t,t2), prevents the new location for xfrom escaping the scope of e2. Consider:  letx = new0 \nin letp = ... in (restrict q = x in p:= q; /* 1*/ restrict r = x in **p) Suppose x has type ref .x \n(int). By (Restrict), the types of q and x can contain different abstract locations. Let q s type be \nref .q (int), where .x = .q. Now if the clause .' . locs(G,t,t2) were not included in (Restrict), the \nassignment p:=q would type check. At program point 1, we would have two different names for the same \nlocation .q and .x even though neither is restricted. Thus the dereference **pwould type check even \nthough the program is incorrect. We forbid .' from escaping in (Restrict) to prevent this prob\u00adlem. Finally, \nnotice that the conclusion of (Restrict) contains the effect {.}, i.e., restricting a location is itself \nan effect. This forbids sneaky programs such as: restrict y = x in restrict z = x in ... *y... *z... \n If restricting a location had no effect on that location, it would be possible to restrict the same \nname twice and have both restricted names available for use in the same scope. While the type and effect \nsystem presented here is built upon a uni.cation-based alias analysis, restrict (and restrict checking) \ncan also be combined with more precise alias analyses. We have not yet explored this possibility. 3.1 \nRemoving Effects This section details a kind of polymorphism that we have found to be important for effectively \nchecking restrict annotations in programs. Consider a generic sentence in our logic G f e : t; L. In \npractice, surprisingly often it happens that the effect L contains locations that are not mentioned either \nin the type t or the environment G. The cause of this seemingly odd behavior is easy to see: emay have \nsubexpressions that allocate temporary storage and have effects on that storage. No rule in Figure 2 \nremoves locations from the effect of an expression, so effects simply grow as we move from the leaves \nto the root of the abstract syntax tree. This behavior is not benign. In recursive functions, these extra \nlocations appear to be in both the effect of recursive calls and the effect of the body of the function, \nresulting in more locations being equated than should be and frequently causing restrictchecking to fail. \nWe need a rule that removes effects: G fe: t; L (Down) G fe: t; Lnlocs(G,t) (Down) states that effects \non locations that are no longer in use neither part of the result computed by an expression, nor accessible \nthrough the environment can be removed from the effect set [4, 16, 22]. Note that the rule (Down) is \nthe one non-syntactic rule in our system. We can construct a purely syntax-directed version of our system \nby observing that two applications of (Down) in a row always can be combined into one. Thus, we can assume \nthere is one application of (Down) for each expression in the program. In fact, it is unpro.table to \napply (Down) anywhere except before the rule for functions (which, again, we have not shown). Combining \nthese observations yields a syntax-directed system.  3.2 Semantics and Soundness In this section we \ngive a very brief sketch of the semantics and soundness of restrict. Our big-step operational semantics \nis formulated to prove judgments of the form S fe .v; S ' , mean\u00ading that evaluating estarting in initial \nstore S(a map from locations l to values, which may themselves be locations) yields a value v and a (possibly \nupdated) .nal store S ' . Here a value v is either a location lor an integer n(or a function binding, \nif that were in our source language). We model restrict in our semantics using the following rule: S \nfe1 .l; S ' ' '' ''' S [l .err,l .S (l)] fe2[x.l ] .v,S ' '' l .dom(S ) l .dom(S ) '' '''' S frestrictx=e1 \nine2 .v; S [l .S (l ),l .err] This rule uses copying to enforce restrict s semantics. To evaluate restrictx=e1 \nine2, we .rst evaluate e1 normally, which must yield a pointer l. Within the body of e2, the only way \nto access what l points to should be via the particular value that resulted from evaluating e1. We enforce \nthis by allocating a fresh location l ' initialized with the contents of l, and then binding l to err \nto forbid access through l. The remainder of our semantics (not shown) is strict in err, and any computation \nthat goes wrong re\u00adduces to err (rather than becoming stuck). Thus, any program that tries to read or \nwrite l within e2 will reduce to err. The sound\u00adness of our checking system (see below) implies that \nno program evaluates to err, which in turn implies that an implementation can safely optimize restrictby \neliding the copy of l. Instead, in an implementation restrictsimply binds xto l. Notice that it is not \nan error to use the value lwithin e2, but only to dereference it. After e2 has been evaluated, we re-initialize \nl to point to the value x points to, and then forbid accesses through l ' . Forbidding access through \nl ' corresponds to the requirement in the type rule (Restrict) that . ' not escape. (An alternative formulation, \nwhich we leave to future work, is to rename occurrences of l ' to l after e2 .nishes.) We can show soundness \nin the usual way via a subject reduction theorem that shows that the type of an expression is preserved \nby evaluation. Then since err has no type, a program that starts off well-typed can never reduce to err: \nTHEOREM 1(SOUNDNESS). If \u00d8f e : t; L and \u00d8f e . r; S ' , then ris not err. Here r is either a value or \nerr (all terminating programs reduce to one or the other). In other words, in a program that type checks, \nno use of restrictis found to be invalid at run time. (Var) G,eG fx:G(x); \u00d8 (Int) G,eG fn : int; \u00d8 G,eG \nfe: t; L.fresh et .{.}.eref .(t) (Ref) G,eG fnew e: ref .(t); L.{.} G,eG fe: ref .(t); L (Deref) G,eG \nf*e: t; L.{.} G,eG fe1 : ref .(t1); L1 G,eG fe2 : t2; L2 t1 = t2 (Assign) G,eG fe1 :=e2 : t1; L1 .L2 \n.{.} G,eG fe: t; L (Down) G,eG fe: t; Ln(eG .et ) G,eG fe1 : ref .(t1); L1 G ' ,eG ' fe2 : t2; L2 G ' \n=G[x.ref .(t1)] eG .eref .(t1) .eG ' (Let) G,eG fletx=e1 ine2 : t2; L1 .L2 G,eG fe1 : ref .(t1); L1 \nG ' ,eG ' fe2 : t2; L2 G ' =G[x .ref . ' (t1)] et1 .{. ' }.eref . ' (t1) eG .eref . ' (t1) .eG ' ..L2 \n. ' .eG .et1 .et2  (Restrict) G,eG frestrictx=e1 ine2 : t2; L1 .L2 .{.} Figure 3: Type Inference Rules \nfor Checking Restrict  4. ALIAS AND EFFECT INFERENCE We now give an algorithm for checking restrict \nannotations ac\u00adcording to the type rules in Figure 2 together with the rule (Down). The algorithm we \ngive is sound and complete; if there is a proof that a restrict-annotated program is correct according \nto Figure 2, the algorithm .nds it. We assume that the programmer has written their program us\u00ading restrictand \nthat the program type checks according to the standard type rules of the language. Figure 3 gives inference \nrules that show how to compute the remaining missing elements, namely the locations and effects needed \nat each point. As is standard, for inference we transform the conditions in the type checking rules into \na system of constraints that can be solved if and only if there is some proof according to the rules \nin Figure 2. We .rst discuss the constraints and some details of the inference algorithm, and then we \ndescribe the individual type rules. Our rules generate three kinds of constraints C: equality con\u00adstraints \nbetween types, inclusion constraints between effects, and disinclusion constraints between locations \nand effects: C ::= t1 = t2 |L .e|..L t ::= int |ref .(t) L ::= \u00d8|{.}|e|L1 .L2 |L1 nL2 Here e is an effect \nvariable, which stands for an unknown set of locations. Notice that inclusion constraints between effects \nare of the special form L .e, which makes these constraints particularly easy to solve. An important \nalgorithmic consideration is how we compute the sets of locations locs(t) and locs(G) required by the \ntype checking rules (Restrict) and (Down). We want to avoid repeatedly travers\u00ading type structures t \nand type environments G at each point in the program a program with O(n) expressions may have (monomor\u00adphic) \ntypes of size O(n) and environments G with O(n) variables, and thus this part of the algorithm alone \nwould likely be at least quadratic. Our solution is to memoize the computation of locs(\u00b7). Recall that \neffects are sets of locations. We associate an effect variable et with each type t , and we maintain \nthis association with an implicit global mapping. As we construct new types, e.g., in (Ref), we generate \nconstraints to represent the locations in the new types: et .{.}.eref .(t) Then in the type inference \nrules, instead of locs(t ),weuse et , e.g., in (Down). Similarly, we observe that the type environment \nis empty at the root of the proof tree and then is only incrementally modi.ed for each subexpression. \nIf we know the set of locations in an environ\u00adment at an expression e, we can incrementally compute the \nset of locations in the environments at each of e s subexpressions. We use effect variables eG to contain \nthe set of locations occurring in en\u00advironment G. Where we extend environment G with a new binding x \n.t in (Let) and (Restrict), we generate a constraint eG .et .eG[x. .t] Thus we succinctly capture locs(G[x \n. t ]) without recomputing locs(G). Because the variables eG must be communicated between adjacent steps \nof the proof, they are included as part of the environ\u00adment (to the left of the turnstile f) in the rules \nof Figure 3. We brie.y discuss the type inference rules in Figure 3. We as\u00adsume that type checking has \nalready been carried out for the under\u00adlying standard types of the language, and that these types are \ngiven to us. That is, we do not infer the standard types. (Var), (Int), and (Deref) are identical to \nthe type checking rules except for the addition of eG to the left of the turnstile.  (Ref) and (Assign) \nare written with explicit fresh variables and equality constraints between types where needed.  (Down) \nis similar to its type checking rule, except we use the variable eG in place of locs(G) and et in place \nof locs(t ). Notice the use of our implicit global mapping of t to et .  (Let) differs in one signi.cant \nway from its type checking rule. The set of locations eG ' of G ' is taken to be the union of the locations \nof G (which is eG) and the locations in ref .(t1).  (Restrict) differs from (Let) in the following ways. \n The variable x is given a type with the new location . ' , and . ' instead of . is included in the \nset of locations eG ' of environment G ' .  A check ensures that . does not appear in the effect L2 \nof e2.  A check ensures that . ' does not escape.  There is an extra effect on . in the effect of the \nwhole expression.   Let n be the size of the initial program with its standard types. Applying the \ninference rules in Figure 3 takes O(n) time and gen\u00aderates a system of constraints C of size O(n). We \nsplit the reso\u00adlution of the side constraints C into two phases, shown as left-to\u00adright rewrite rules \nin Figure 4. First, we solve the type equality C .{int = int}. C C .{ref .1 (t1)= ref .2 (t2)}. C .{.1 \n= .2}.{t1 = t2}C .{.1 = .2}. C[.1 ..2] C .{e1 = e2}. C[e1 .e2] (a) Type Equality C .{. .L}.C .{. .e}.{L \n.e} e fresh C .{\u00d8.e}. C C .{L1 .L2 .e}. C .{L1 .e}.{L2 .e}C .{\u00d8nL .e}. C C .{L n\u00d8.e}. C C .{(L1 .L2) \nnL .e}.C .{e ' nL .e}.{L1 .L2 .e ' } fresh e ' C .{L n(L1 .L2) .e}.C .{L ne ' .e}.{L1 .L2 .e ' } fresh \ne ' (b) Constraint Normalization Figure 4: Constraint Resolution constraints t1 = t2 using the rules \nin Figure 4a. Because we as\u00adsume checking of the standard types has already been done, the type equality \nrules can never discover an inconsistency. However, the type equalities must still be solved to discover \nall implied con\u00adstraints between . and e variables. This step requires O(n) time. The resulting constraints \nare of the form L . e and . . L. We call such a system of constraints an effect constraint system.A solution \nto an effect constraint system C is a mapping s from effect variables to sets of locations such that \ns(L) .s(e) and . .s(L) for each constraint L . e and . . L in C, where we extend s from effect variables \nto arbitrary effects in the natural way. An effect constraint system is satis.able if it has a solution. \nNotice that abstract locations are not in the domain of s intuitively, after discovering all equalities \nbetween locations after applying the rules in Figure 4a, we can treat abstract locations as constants. \nWe de.ne a partial order on solutions, s =s ' iff for every effect variable e we have s(e) . s ' (e). \nThe least solution to an effect constraint system is the solution s such that s =s ' for any other solution \ns ' . If an effect constraint system C has any solution, then C has a least solution [13, 14]. To test \nsatis.ability of an effect constraint system, we .rst apply the rules in Figure 4b to translate the constraints \ninto the following normal form: C ::= L .e |. .e L ::= M |M nM M ::= {.}|e Notice that the rules in Figure \n4b preserve least solutions but not ar\u00adbitrary solutions. Also notice that in Figure 4b we do not consider \nthe case (L1 nL2) nL . e or L n(L1 nL2) . e. Such con\u00adstraints are never generated once (Down) is merged \ninto the rule for functions (not shown). Applying the rules in Figure 4b takes time O(n). We view the \ninclusion constraints in a normal form effect con\u00ad CHECK-SAT(..e): Associate Count(v)with each node v \nin the graph Initialize Count(v)=0for all v Let W ={.}, the set of nodes left to visit While W is not \nempty Remove some node v from W If v ==ereturn unsatis.able For each edge v .e ' If Count(e ' )==0then \nCount(e ' )=1 Add e ' to W For each edge v .I If Count(I)==0then Count(I)=1 Else if Count(I)==1then \nCount(I)=2 Add I to W Return satis.able Figure 5: Checking satis.ability of ..e straint system as a directed \ngraph: Constraint Edge(s) {.}.e ..e e1 .e2 e1 .e2 M1 nM2 .e M1 .I M2 .I I .e I fresh The nodes of the \ndirected graph are abstract locations .(with in\u00addegree 0), effect variables e (with arbitrary in-degree), \nand inter\u00adsections I (with in-degree 2). We generate a fresh I node for each constraint M1 nM2 .e. Given \na normal form effect constraint system, we test satis.abil\u00adity by checking, for each constraint . .e, \nwhether ..s(e)in the least solution s. Figure 5 shows the modi.ed depth-.rst search we use to check this \ncondition. The algorithm in Figure 5 takes time O(n)for each . .e constraint. Given an initial program \nwith k occurrences of restrict, the system considered in Figure 5 has O(k)constraints of the form . .e. \nHence the time for this step is O(kn), which is also the total time for the algorithm. 5. RESTRICT INFERENCE \nThe type checking algorithm of the previous section checks user\u00adsupplied restrictannotations. In practice, \nhowever, many such annotations may be necessary to give the quality of aliasing infor\u00admation needed for \nother analyses, and adding these annotations by hand can be very time-consuming. In this section we give \nan al\u00adgorithm for automatically adding restrictto a program. More precisely, we show how to automatically \ndecide whether a binding construct should be let or restrict. A bit surprisingly, our type rules always \nadmit a unique maximum set of letexpressions that can be restricted. Our inference algorithm computes \nthis optimal annotation of the program. As we have observed, letand restrictdiffer only in a few ways. \nOur approach is to combine the inference rules (Let) and (Restrict) into a single rule (Let-or-Restrict), \ncorresponding to a new construct let-or-restrictx=e1 ine2, with two prop\u00aderties. First, in any solution \nof the constraints, (Let-or-Restrict) satis.es the requirements of exactly one of the (Let) or (Restrict) \nrules. Second, (Let-or-Restrict) prefers the (Restrict) solution: if the constraints have any solution \nsatisfying the requirements of (Restrict), then that will be the least solution. Recall that restricthas \nfour differences from let. We con\u00adsider each of these in turn. First, a restrictuses two locations . \nand . ' where lethas only .. Thus, our inference rule should begin by assuming . and . ' are distinct \n(the restrictcase), and if it turns out that the expression cannot be a restrict, the locations should \nbe uni.ed (.=. ' , the letcase). Second, there are two negative constraints . . L2 . ' . eG .et1 .et2 \nin restrict. If either of these is unsatis.able, then the expres\u00adsion must be a let. We can combine this \nwith the reasoning above to yield the following constraints: ..L2 . .=. ' . ' .(eG .et1 .et2 ) . .=. \n' These constraints say that if either the old location .is used in the body of the construct, or the \nnew location . ' escapes, then the lo\u00adcations must be equal and the construct is a let. We have not seen \nsuch conditional constraints before in this paper. These constraints are easy to solve, though we omit \nthe details here. Finally, there is the extra effect on .in the result of restrict. If the expression \nis a restrict we must have the effect, and if it is a let we must not. Given the semantics of restrict \nwe have used so far, we do not know how to model this choice ef.\u00adciently. However, if we interpret restricta \nlittle more liberally, an ef.cient solution is straightforward. Consider the construct let-or-restrictx=e1 \nine2, which will behave either as restrictor let.If e2 has an effect on . ' , we are done: if it is a \nrestrict there is an effect on . and if it is a let there is also an effect on . because . = . ' . What \nif e2 has no effect on . ' ? In that case, we do not need to require that restrict have an effect on \n.! Recall from the example in Section 3 that the extra effect is needed to prevent . from being restricted \ntwice and both restricted pointers used simultaneously. If a restricted pointer is not used at all, there \nis no need to prevent it from being restricted a second time in the same scope.2 These two cases (e2 \ndoes or does not have an effect on . ' ) can be combined in one additional conditional constraint (. \n' .L2).{.}.e where L2 is the effect of e2 and e is included in the effect of the entire expression. Putting \neverything together, we have the following inference rule: G,eG fe1 :ref .(t1);L1 ' G ' ,eG ' fe2 :t2;L2 \nG =G[x .ref . ' (t1)] et1 .{. ' }.eref . ' eG .eref . ' .eG ' (t1)(t1) . ' .(eG .et1 .et2 )..=. ' ..L2 \n..=. ' . ' .L2 .{.}.e .,. ' ,efresh G,eG flet-or-restrictx=e1 ine2 :t2;L1 .L2 .e 2This is consistent \nwith the semantics of restrictin C. We have not introduced this semantics before now because it is more \ncom\u00adplicated. This new rule, which replaces (Let) and (Restrict), allows us to infer restrict annotations. \nIt is easy to check that these con\u00adstraints have a least solution, which guarantees the existence of \nan optimal annotation of a program with restrict. A straightforward implementation of this inference \nrule gives a quadratic time algorithm. Given a typed program of size n, there are O(n) possible locations \nand O(n) constraints. Computing ini\u00adtial reachability in the constraint graph (without the conditional \nconstraints) for all O(n) locations using the algorithm in Figure 5 takes O(n 2) time. We maintain a \nwork-list of conditional con\u00adstraints whose left-hand side has become true. For each conditional constraint \non our work-list, we perform O(n) extra work to recom\u00adpute reachability for the uni.ed locations (or \nto recompute reacha\u00adbility for the location . in the constraint {.}.e). Since there are O(n) possible \ntotal uni.cations, and each may trigger O(n) work, the overall complexity is O(n 2).  6. CONFINE Recall \nthat, as in the code in Figure 1, many realistic examples where restrict-like functionality is useful \ninvolve values held in containers. Unlike Figure 1, however, in practice programs often do not include \nan explicit variable to restrict. For example, consider spin_lock(&#38;locks[i]); work(); spin_unlock(&#38;locks[i]); \n Assuming that work()does not modify ior access any other ele\u00adments of the array locks, we can rewrite \nthis code using restrict to allow a checker like CQUAL to analyze this code: restrict x = &#38;locks[i] \nin { spin_lock(x); (*) work() spin_unlock(x); } While this is effective, implementing this transformation \nby hand is tedious, not only because we must introduce a new name and manually perform a substitution, \nbut also because we must discover the scope of the restrictand check that the restricted ex\u00adpression \nrefers to the same object throughout the body. For in\u00adstance, in this case, we must notice that there \nare two occurrences of &#38;locks[i]in the code that refer to the same object, and then we must put the \nscope of the new variable that names the lock around both uses. Note that in the system described in \nSection 5 we only infer restrictfor variables, which come with an obvious scope. Editing a program to \nadd a few restrict annotations is not dif.cult; the problem is that in practice there are many restrict \nannotations to add, and many involve expressions. In our experi\u00adence, the manual labor required to introduce \nlocal variables for all of those expressions is just too much. Our solution is to introduce a new construct, \nconfine, that deals speci.cally with restricting the aliases of expressions. The syntax is confinee1 \nine2 meaning that aliases of the location e1 refers to are restricted in the scope e2. (Note that our \nuse of the word con.ne is not related to the term as used in object-oriented alias control sys\u00adtems [28].) \nThe expression e1 itself serves as the name for the restricted location. Assuming all program variables \nhave been renamed to be distinct, we de.ne confinesyntactically by trans\u00adlation to restrict: confinee1 \nin(e2[e1/x]) = restrictx =e1 ine2 where x is a fresh variable that is substituted for occurrences of \ne1 in e2. For nested confines, the translation must be done innermost-.rst. For instance, the example \nabove would be written: confine (&#38;locks[i]) in { spin_lock(&#38;locks[i]); work(); spin_unlock(&#38;locks[i]); \n } and this is de.ned to be equivalent to (*) above. Notice that with confinewe do not need to rewrite \nthe body of the restricted scope we need only wrap an appropriate confinearound it. Our goal is to perform \nconfine inference to automatically place confines in the program. Intuitively, confineinference corresponds \nto performing a kind of common sub-expression elim\u00adination that handles aliasing and then applying restrict \ninference. There are two issues: Referential transparency. For the de.nition given above of confinein \nterms of restrictto make sense, an expres\u00adsion that is confined must truly behave like a name within \nthe scope of the confine. An expression behaves like a name in a scope only if it is referentially transparent \nwithin that scope3 if it in fact always evaluates to the same value.  Inferring scopes. As mentioned \nabove, we must determine the scope for a confine.  6.1 Referential Transparency Consider an expression \nconfinee1 ine2. To enforce referen\u00adtial transparency of e1 within the scope of e2, we must .rst ensure \nthat e1 terminates. Our solution is to simply forbid e1 from contain\u00ading a function application, and \nindeed for the experiment described in Section 7 we are interested only in e1 s that are composed of \nidenti.ers, .eld accesses, and pointer dereferences. To enforce referential transparency, we must also \nbe certain that neither e1 nor e2 modify any of the locations e1 needs during its evaluation locations \nused by e1 must only be read within e1 and e2. To accomplish this we must extend our notion of effect. \nFor a given location ., we now distinguish effects read(.) (reads of location .), write(.) (writes to \nlocation .), and alloc(.) (allocation of location .). Our rules now have two different kinds of sets: \nsets S of locations (as before) and sets L of read, write, and alloc effects on locations. For clarity, \nwe separate these two kinds of sets and use variables p for sets of read, write, and alloc effects, and \nvariables e for sets of locations. The grammars for sets are now: L ::= \u00d8|{read(.)}|{write(.)}|{alloc(.)}|p \n|L1 .L2 |L1 nL2 S ::= \u00d8|{.}|e |S1 .S2 |S1 nS2 All inference rules must be modi.ed to correctly report \nread, write, and allocation effects on locations; we omit the details due to space constraints. We also \nneed to introduce a new kind of effectful variable xL, which is typechecked just like a regular variable \nx, except that evaluating xL has effect L: (VarL) G,eG fxL :G(x); L Intuitively, we could also model \nxL as a thunk if the language used in this paper contained functions. We discuss the use of effectful \nvariables xL below. 3Our usage is slightly non-standard; in the standard use of the term referential \ntransparency, the scope referred to is the whole pro\u00adgram. To perform type inference for confinee1 ine2, \nwe modify let-or-restrictfor use with confine: G,eG fe1 : ref .(t1); L1 G ' ,eG ' fe2[xp ' /x]: t2; L2 \nG ' =G[x.ref . ' (t1)] et1 .{. ' }.eref . ' (t1) eG .eref . ' (t1) .eG ' . ' .(eG .et1 .et2 ) .(.= . \n' .L1 .p ' ) X(.) .L2 .(.= . ' .L1 .p ' ) X(. ' ) .L2 .{X(.)}.p '' '' ) .L1 .(. ...write(. = . ' .L1 \n.p ' ) '' '' ) .L1 .(. ...alloc(. = . ' .L1 .p ' ) '''' '' ' ...read(. ) .L1 .(write(. ) .L2 .(.= . \n' .L1 .p )) '''' '' ' ...read(. ) .L1 .(alloc(. ) .L2 .(.= . ' .L1 .p )) .,. ' ,p,p ' fresh G,eG fconfine? \ne1 ine2[e1/x]: t2; L1 .L2 .p The name confine? is meant to be suggestive of an op\u00adtional confine. This \nrule chooses whether to insert confine based on the solution of the constraints (if . = . ' and L1 . \np ' there is a confine, otherwise there is not). The easiest way to understand this rule is to compare \nit with the inference rule for let-or-restrict(Section 5). The .rst line of the two rules is identical. \nIn the second line, we bind xas before, and we replace x in e2 with an effectful variable xp ' . Recall \nthat in e2, occurrences of e1 have been replaced by x. If inserting confine succeeds, p ' = \u00d8in the least \nsolution of the constraints, so xp ' is equiv\u00adalent to x. In other words, if inserting confine succeeds, \nthen we replace occurrences of the common sub-expression e1 by x. But if inserting confinefails (for \nany reason) then the constraint L1 .p ' will be generated, and therefore in this case when type\u00adchecking \ne2 we will give each occurrence of x both e1 s type and e1 s effect. Thus, if inserting confinefails, \nwe do not eliminate common sub-expression e1. The third and fourth line of our rule for confine? are \nas in our rule for let-or-restrict, with the addition of the constraint L1 .p ' . In the next two lines \nwe have used a short-hand in the new rule: X is a wildcard constructor standing for any of read, write, \nor alloc. These constraints simply instantiate the requirements of the original rule for each of the \nthree speci.c kinds of effects. The four lines beginning with universal quanti.ers are the referential \ntransparency constraints speci.c to confine. The .rst two lines of the premise require that the confined \nexpression e1 have no side effects; the last two lines say that if a location . '' is read by e1 (i.e., \nthe effect read(. '' ) is in L1) then . '' cannot be written or allocated by e2. In other words, the \nlast two lines prevent e1 from being con.ned if the meaning of e1 may be changed by an assignment in \ne2. It is important to understand that it is not necessary to actually introduce new program variables \nand carry out inverse substitutions to implement confine inference. Our reduction of confine inference \nto restrict inference allows us to rely on soundness results for restrict, but an ef.cient implementation \nis possible without explicit program transformations. For space reasons we have not given a type checking \nrule for confine.A confine rule is easily derived from the rule for confine? by requiring that .= . ' \nand simplifying.  6.2 Inferring Scopes Our confine? rule gives us a method for inferring confine. This \nfacility gives us a very simple way to automatically infer the best (largest) scope in which to con.ne \na given expression e1.In Section 7, we use this technique to con.ne expressions correspond\u00ading to locks \nin the Linux kernel. Brie.y, the main idea is that to infer the scope of a confine of an expression e1, \nwe add confine? e1 ine2 to every possi\u00adble scope e2 and pick the largest scope where inference succeeds \n(where succeeds means that the solutions of the constraints indi\u00adcate that a confinecan be added). The \npossible scopes where e1 can be con.ned are just those where the free variables of e1 are in scope. For \nexample, if we have letx=e3 in(lety=e2 in...e1 ...) then con.ne inference for e1 adds confine? to the \nouter scopes: confine?e1 in(let x= e3 in confine? e1 in(lety=e2 in...e1 ...)) assuming that e1 did not \nmention either x or y. Con.ne infer\u00adence is then carried out. After the constraints are solved, we select \nthe outermost confine? that succeeds, if indeed any succeed. Note that this method checks all confine? \nexpressions simulta\u00adneously. Given a typed program of size n and a .xed expression e1, there are O(n) \npossible places to insert confine?. Finding syntactic occurrences of e1 takes O(n 2) time. Solving the \ncon\u00adstraints for O(n) confine?s takes O(n 2) time. To see this, note that our type inference rules generate \nO(n) locations, and com\u00adputing reachability for a location in the constraint graph (using an algorithm \nsimilar to that in Figure 5) takes O(n) time. Thus, com\u00adputing an initial least solution of every location, \nbefore taking any conditional constraints into account, takes time O(n 2). Then for any conditional constraint \nwhose left-hand side is true, we perform O(n) extra work to recompute reachability for the uni.ed loca\u00adtions \nand to propagate the least solution of L1 to p ' . Since there are O(n) possible total uni.cations, and \neach may trigger O(n) work, the overall complexity is O(n 2). In our implementation, we use an algorithm \nwith a higher worst\u00adcase running time but better performance in practice. Rather than computing reachability \nfor every location in the constraint graph (which takes O(n 2) time), we do a backwards search from effects \nin constraints generated for confine? to .nd which locations reach them. Since this tends to be a small \nportion of the constraint graph, this is usually more ef.cient.  7. EXPERIMENTS As discussed in Section \n1, among other applications, we are in\u00adterested in restrictand confine because they enable strong updates \nin .ow-sensitive analyses. To assess the usefulness of our confine construct in practice, we have implemented \nconfine inference in CQUAL and tested it in conjunction with CQUAL s .ow-sensitive analysis. This section \npresents the results of that ex\u00adperience. The .ow-sensitive analysis we use is the analysis of locking \nbe\u00adhavior reported previously [15]. The Linux kernel has two primi\u00adtives spin lock(e) and spin unlock(e) \nfor acquiring and releasing locks, respectively. By tracking the state (held or not held) of locks, we \ncan detect when a lock is acquired or released twice in succession within a single thread. These particular \npro\u00adgramming errors are surprisingly common in Linux device drivers [11]. In previous experiments [15], \nwe examined hundreds of device drivers and discovered numerous locking errors by inspecting the results \nof analyzing single .les and a few entire device drivers. Po\u00adtentially, more errors could be found by \nanalyzing entire device driver modules (which typically consist of many .les), but we dis\u00adcovered in \nanalyzing many whole modules that the aliasing of locks became so pervasive that it was very dif.cult \nto separate true bugs from type errors reported due to spurious aliases, and it was sim\u00adply impractical \nto remove the spurious aliases by adding all of the needed restrictannotations by hand. We have repeated \nour locking experiments, using confinein\u00adference as described in Section 6 to try to confineany arguments \npassed to change type(), a special state-changing statement built in to CQUAL [15] in particular, we \ntry to confine any arguments to spin lock or spin unlock. There is one wrin\u00adkle in performing confineinference \nin a language with blocks of statements {e1;...ei;...ej;...en} such as C. Sometimes it is necessary to \nconfine only a portion of the block with respect to an expression e; e.g., we may need to introduce a \nnew scope to write {e1;...;confineein{ei;...ej;};...en} The problem is to discover to what portion of \na block we can add confine. Observe that (confineeine1;confineeine2)= (confineein{e1;e2}) That is, adjacent \nconfines of the same expression can be com\u00adbined. This suggests the following general algorithm: in a \nblock e1;...en, for each i, add confine? einei and then greedily combine all adjacent confine?s that \nsucceed. This algorithm discovers the largest possible confinesub-blocks within a block of statements. \nTo improve performance, our current implementation introduces new sub-blocks for confine? using a slightly \ndifferent algorithm based on a syntactic heuristic. For each statement in the program (including statement \nblocks), we keep track of whether the state\u00adment contains change type. When two statements in the same \nblock contain change type, and the arguments to change type match syntactically, we introduce the smallest \npossible sub-block around the two statements and report that the new sub-block does not contain a change \ntype. Intuitively, this heuristic tries to put confine? around sets of statements that call spin lock \nand spin unlockwith the same syntactic expression. The heuristic is weaker than the general strategy \noutlined above, but still works well in our experiment, as our results suggest. Also notice that al\u00adthough \nthe introduction of confine? is a syntactic heuristic, our confine inference algorithm uses our type \nand effect system to decide whether introducing confineis safe. We analyzed 589 whole device driver modules \nfrom the 2.4.9 Linux kernel. We used CQUAL in three different modes: without con.ne inference, with con.ne \ninference, and .nally in a mode where all updates are assumed to be strong. In each case we mea\u00adsured \nthe number of type errors reported by CQUAL in the .ow\u00adsensitive pass here the number of type errors \nis the number of syn\u00adtactic calls to spin lock()and spin unlock()where CQUAL could not verify that locks \nare held in the correct state. Since one application of confine is to enable strong updates in a .ow\u00adsensitive \nanalysis, the last mode provides an upper bound on the number of spurious type errors that can be eliminated \nby adding confineannotations. Of the 589 modules, 352 are free of type errors without the ad\u00addition of \nany confineannotations. 85 of the remaining modules contain type errors, but not because of strong updates \nusing no confine at all yields the same type errors as assuming all up\u00addates are strong. Of the remaining \n152 modules where CQUAL reports type errors, using confine inference produces the same type errors as \nassuming all updates are strong in 138 modules. That is, in 138 of 152 modules where confineinference \ncould make a      Number of modules 90 80 70 60 50 40 30 20 10 0 Number of spurious type errors \neliminated Figure 6: Spurious type errors eliminated by confine infer\u00adence. Module Number of lock/unlock \ntype errors no con.ne con.ne all updates inference inference strong wavelan cs 22 16 15 trix 29 24 \n22 netrom 41 25 0 rose 47 28 0 usb-ohci 32 26 17 uhci 74 45 34 sb 31 24 22 ide-tape 58 47 41 mad16 29 \n24 22 emu10k1 198 60 35 trident 107 49 36 digi aceleport 62 32 4 sbni 23 16 9 iph5526 39 34 32  Figure \n7: Modules for which confineinference does not infer all possible strong updates. difference, it removes \nall spurious type errors due to lack of strong updates. Figure 6 shows the distribution of type errors \neliminated by confine inference for these modules. Summing the individ\u00adual results for all modules, confine \ninference could potentially eliminate 3,277 type errors, and it succeeds in eliminating 3,116 type errors, \nor 95%. Note that the type error counts should be taken with a grain of salt, as multiple type errors \noften have a single root cause. Also, many modules share .les, so even type errors reported in different \nmodules are not independent. Of the 152 modules, 14 contain sites where confineinference cannot infer \nthat a potentially useful strong update is possible. We give the type error counts for each of the three \nmodes of usage for these modules in Figure 7. We have examined the type error reports from several of \nthese 14 modules to discover where confinein\u00adference fails. In some cases, our underlying may-alias analysis \nis unable to verify the addition of confinewithout programmer in\u00adtervention (e.g., a type cast). In other \ncases, there is not a well\u00adde.ned lexical scope for confine; these cases often involve quite tricky coding \nstyles. Although it is not the subject of this paper, as mentioned above even assuming that all updates \nare strong, CQUAL reports at least some type errors in 137 of the modules. The sources of these type \nerrors are mostly the same as reported previously [15]. In particu\u00adlar, there are a few places where \na path sensitive analysis would be useful, and others where we need the ability to model the sequential \nacquiring or releasing of a set of aliased locks at once. There are also just plain program errors, including \n4 apparently new bugs we have found since the results reported previously [15]. These bugs were present \nin the code analyzed previously [15] but escaped no\u00adtice simply because the large number of spurious \ntype errors caused by the lack of confine inference. Finally, so far we have found one place where the \naddition of location polymorphism would re\u00admove a CQUAL type error. The performance impact of confine \ninference on CQUAL is modest, because in our experiments the pointer-valued expressions that are confined \ntend to be small and because we only try to confine arguments to spin lock or spin unlock. For ex\u00adample, \nin the largest module where confineinference eliminated some type errors (ide-tape)CQUAL ran in 28.5 \nseconds with confine inference and in 26.0 seconds without it. The running time of confineinference for \nother modules is a similarly small fraction of the overall time. 8. RELATED WORK Effect systems were \n.rst described by Gifford and Lucassen for FX-87 [16, 22]. FX-87 includes subtyping, polymorphism, and \nnotation for declaring the effects of expressions [16]. One of the best-known type and effect systems \nis the region type system pro\u00adposed by Tofte and Talpin [27]. Our type systems, and particularly the \nsystem for automatically inferring where to place restrict and confine annotations, is related to region \ninference. The . annotations can be thought of as regions, and we can apply the rule (Down) (which is \nborrowed from a region type system [4]) whenever we discover that a location is purely local to a lexical \nscope of the computation [4]. One important difference between restrict/con.ne inference and region inference \nis that introducing restrict and con.ne requires that certain locations not be accessed within their \nscope, whereas introducing a new region never de\u00adcreases the set of accessible locations. Wang and Appel \n[29] use a technique very similar to restrict to check that covariant subtyping under reference types \nis safe. This can be seen as another application of restrict. Automatic alias analysis has been heavily \nstudied in recent years; a few of the many proposed analyses are [1, 7, 10, 18, 20, 21, 24, 26, 30]. \nOur type system incorporates may-alias analysis to check the correctness of restrictand confine. The \nmay-alias anal\u00adysis we use is very conservative, and it is possible that a more expressive (and expensive) \nmay-alias analysis would be useful in practice to improve the precision of restrict and confine checking \nand inference. One of the limitations of our approach is that restrict and confinemust be lexically scoped. \nThis assumption .ts well with many, but not all, uses of restrict and confine in practice. Other type-based \nsystems that model strong and weak updates and do not have lexical scoping restrictions [9, 12, 25] are \nmore expres\u00adsive, but also less suited to tractable automatic inference than our approach. For example, \nBoyland [3] shows how to check several programming paradigms using non-lexically scoped linearities and \n.ow-sensitive aliasing information. There are several systems for modeling uniqueness in object ori\u00adented \nprogramming languages [19, 23, 3]. In these systems a unique object always has exactly one pointer pointing \nto it. In contrast, in our system a location pointed to by a restricted pointer may be pointed to by \narbitrarily many pointers. However, some of the techniques from the literature on uniqueness may be applicable \nto restrictand confine. For example, a type system by Clarke and Wrigstad [6] allows a unique object \nto have a non-unique view in a scope while leaving the unique pointer to the object alive by forbidding \nthe escape of aliases created in the scope.  As discussed in the introduction, one of the most interesting \nproperties of restrictand confineis that they allow us to lo\u00adcally recover the ability to treat a pointer \nas a reference to a unique value, which allows analyses that use restrict and confine information to \nperform strong updates [5]. This idea is the subject of previous work [15] that combines restrict with \nideas from .ow-sensitive type systems [25]. The resulting system can be used to check .ow-sensitive program \nproperties. Several other systems, such at Meta-level compilation [17] and ESP [8], check .ow-sensitive \nprogram properties using approaches more directly based on data.ow analysis. In these systems, ar\u00adbitrary \ndata.ow facts are associated with each program point. In contrast, our approach can be seen as associating \na more restricted language of facts, i.e., the quali.ed type of each abstract location ., with each program \npoint. This yields a quite different design trade\u00adoff: Meta-level compilation and ESP support a richer \nlanguage of facts that is correspondingly more complex to reason about. In CQUAL,thefactsareeasiertoreasonaboutbutlessexpressive. \nThe restrictand confineconstructs regain some expressiveness by enriching the set of abstract locations, \nwhich correspondingly enriches the set of possible facts at each program point. 9. CONCLUSION In this \npaper we have presented restrict, a language con\u00adstruct that allows a programmer to specify that certain \npointers are not aliased within a lexical scope. We have shown both how to au\u00adtomatically check the correctness \nof restrictannotations using an alias and effect system, and how to automatically infer which letbindings \nmay be safely changed to restrictbindings. We have also developed confine, which allows an expres\u00adsion \nto be restricted, and shown how to automatically add confine annotations to a program. We have shown \nthat auto\u00admatic confineinference can be used to recover nearly all impor\u00adtant strong updates needed for \na .ow-sensitive analysis to check locking behavior in Linux kernel device drivers. Although our ex\u00adperiments \nto date have focused on using restrictand confine to aid CQUAL, we believe that restrict and confine \ncan be pro.tably applied as programmer annotations in other systems. In our view, the key bene.t of our \napproach is that restrict and confine give the programmer a handle on an alias analysis and, by extension, \nany subsequent analyses (e.g., program veri.ca\u00adtion tools) based on aliasing information. We feel that \nthis exposure of aliasing information is important, especially to express critical aliasing invariants \nneeded to verify .ow-sensitive program proper\u00adties. However, we also believe that many uses of restrict \nand confineare routine. Thus, we believe a workable approach is to support both automatic inference of \nrestrictand confineas well as programmer restrict and possibly confine annota\u00adtions. 10. REFERENCES [1] \nL. O. Andersen. Program Analysis and Specialization for the C Programming Language. PhD thesis, DIKU, \nDepartment of Computer Science, University of Copenhagen, May 1994. [2] ANSI. Programming languages \n C, 1999. ISO/IEC 9899:1999. [3] J. Boyland. Alias burying: Unique variables without destructive reads. \nSoftware Practice and Experience, 31(6):533 553, May 2001. [4] C. Calcagno. Strati.ed Operational Semantics \nfor Safety and Correctness of The Region Calculus. In Proceedings of the 28th Annual ACM SIGPLAN-SIGACT \nSymposium on Principles of Programming Languages, pages 155 165, London, United Kingdom, Jan. 2001. [5] \nD. R. Chase, M. Wegman, and F. K. Zadeck. Analysis of Pointers and Structures. In Proceedings of the \n1990 ACM SIGPLAN Conference on Programming Language Design and Implementation, pages 296 310, White Plains, \nNew York, June 1990. [6] D. Clarke and T. Wrigstad. External Uniquness. In Proceedings of the 10th International \nWorkshop on Foundations of Object-Oriented Languages, Jan. 2003. [7] M. Das. Uni.cation-based Pointer \nAnalysis with Directional Assignments. In Proceedings of the 2000 ACM SIGPLAN Conference on Programming \nLanguage Design and Implementation, pages 35 46, Vancouver B.C., Canada, June 2000. [8] M. Das, S. Lerner, \nand M. Seigle. ESP: Path-Sensitive Program Veri.cation in Polynomial Time. In Proceedings of the 2002 \nACM SIGPLAN Conference on Programming Language Design and Implementation, pages 57 68, Berlin, Germany, \nJune 2002. [9] R. DeLine and M. F\u00a8ahndrich. Enforcing High-Level Protocols in Low-Level Software. In \nProceedings of the 2001 ACM SIGPLAN Conference on Programming Language Design and Implementation, pages \n59 69, Snowbird, Utah, June 2001. [10] M. Emami, R. Ghiya, and L. J. Hendren. Context-Sensitive Interprocedural \nPoints-to Analysis in the Presence of Function Pointers. In Proceedings of the 1994 ACM SIGPLAN Conference \non Programming Language Design and Implementation, pages 242 256, Orlando, Florida, June 1994. [11] D. \nEngler, D. Y. Chen, S. Hallem, A. Chou, and B. Chelf. Bugs as Deviant Behavior: A General Approach to \nInferring Errors in Systems Code. In Proceedings of the 18th ACM Symposium on Operating Systems Principles, \nBanff, Canada, Oct. 2001. [12] M. F\u00a8ahndrich and R. DeLine. Adoption and Focus: Practical Linear Types \nfor Imperative Programming. In Proceedings of the 2002 ACM SIGPLAN Conference on Programming Language \nDesign and Implementation, pages 13 24, Berlin, Germany, June 2002. [13] J. S. Foster. Type Quali.ers: \nLightweight Speci.cations to Improve Software Quality. PhD thesis, University of California, Berkeley, \nDec. 2002. [14] J. S. Foster and A. Aiken. Checking Programmer-Speci.ed Non-Aliasing. Technical Report \nUCB//CSD-01-1160, University of California, Berkeley, Oct. 2001. [15] J. S. Foster, T. Terauchi, and \nA. Aiken. Flow-Sensitive Type Quali.ers. In Proceedings of the 2002 ACM SIGPLAN Conference on Programming \nLanguage Design and Implementation, pages 1 12, Berlin, Germany, June 2002. [16] D. K. Gifford, P. Jouvelot, \nJ. M. Lucassen, and M. A. Sheldon. FX-87 Reference Manual. Technical Report MIT/LCS/TR-407, MIT Laboratory \nfor Computer Science, Sept. 1987. [17] S. Hallem, B. Chelf, Y. Xie, and D. Engler. A System and Language \nfor Building System-Speci.c, Static Analyses. In Proceedings of the 2002 ACM SIGPLAN Conference on Programming \nLanguage Design and Implementation, pages 69 82, Berlin, Germany, June 2002. [18] N. Heintze and O. Tardieu. \nUltra-fast Aliasing Analysis using CLA: A Million Lines of C Code in a Second. In Proceedings of the \n2001 ACM SIGPLAN Conference on Programming Language Design and Implementation, pages 254 263, Snowbird, \nUtah, June 2001. [19] J. Hog. Islands: aliasing protection in object-oriented languages. In Proceedings \nof the sixth annual conference on Object-oriented programming systems, languages, and applications, pages \n271 285, Oct. 1991. [20] W. Landi and B. G. Ryder. A Safe Approximate Algorithm for Interprocedural Pointer \nAliasing. In Proceedings of the 1992 ACM SIGPLAN Conference on Programming Language Design and Implementation, \npages 235 248, San Francisco, California, June 1992. [21] D. Liang and M. J. Harrold. Ef.cient Computation \nof Parametrized Pointer Information for Interprocedural Analyses. In P. Cousot, editor, Static Analysis, \nEighth International Symposium, volume 2126 of Lecture Notes in Computer Science, pages 279 298, Paris, \nFrance, July 2001. Springer-Verlag. [22] J. M. Lucassen and D. K. Gifford. Polymorphic Effect Systems. \nIn Proceedings of the 15th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, \npages 47 57, San Diego, California, Jan. 1988. [23] N. Minsky. Towards Alias-Free Pointers. In Proceedings \nof the tenth European Conference on Object Oriented Programming, 1996. [24] J. Rehof and M. F\u00a8ahndrich. \nType-Based Flow Analysis: From Polymorphic Subtyping to CFL-Reachability. In Proceedings of the 28th \nAnnual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, pages 54 66, London, United \nKingdom, Jan. 2001. [25] F. Smith, D. Walker, and G. Morrisett. Alias Types. In G. Smolka, editor, 9th \nEuropean Symposium on Programming, volume 1782 of Lecture Notes in Computer Science, pages 366 381, Berlin, \nGermany, 2000. Springer-Verlag. [26] B. Steensgaard. Points-to Analysis in Almost Linear Time. In Proceedings \nof the 23rd Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, pages 32 41, \nSt. Petersburg Beach, Florida, Jan. 1996. [27] M. Tofte and J.-P. Talpin. Implementation of the Typed \nCall-by-Value .-Calculus using a Stack of Regions. In Proceedings of the 21st Annual ACM SIGPLAN-SIGACT \nSymposium on Principles of Programming Languages, pages 188 201, Portland, Oregon, Jan. 1994. [28] J. \nVitek and B. Bokowski. Con.ned Types. In Proceedings of the fourteenth annual conference on Object-oriented \nprogramming systems, languages, and applications, pages 82 96, Oct. 1999. [29] D. C. Wang and A. W. Appel. \nType-Preserving Garbage Collectors. In Proceedings of the 28th Annual ACM SIGPLAN-SIGACT Symposium on \nPrinciples of Programming Languages, London, United Kingdom, Jan. 2001. [30] R. P. Wilson and M. S. Lam. \nEf.cient Context-Sensitive Pointer Analysis for C Programs. In Proceedings of the 1995 ACM SIGPLAN Conference \non Programming Language Design and Implementation, pages 1 12, La Jolla, California, June 1995.   \n\t\t\t", "proc_id": "781131", "abstract": "In prior work [15] we studied a language construct &lt;tt&gt;restrict&lt;/tt&gt; that allows programmers to specify that certain pointers are not aliased to other pointers used within a lexical scope. Among other applications, programming with these constructs helps program analysis tools locally recover strong updates, which can improve the tracking of state in flow-sensitive analyses. In this paper we continue the study of &lt;tt&gt;restrict&lt;/tt&gt; and introduce the construct &lt;tt&gt;confine&lt;/tt&gt;. We present a type and effect system for checking the correctness of these annotations, and we develop efficient constraint-based algorithms implementing these type checking systems. To make it easier to use &lt;tt&gt;restrict&lt;/tt&gt; and &lt;tt&gt;confine&lt;/tt&gt; in practice, we show how to automatically infer such annotations without programmer assistance. In experiments on locking in 589 Linux device drivers, &lt;tt&gt;confine&lt;/tt&gt; inference can automatically recover strong updates to eliminate 95% of the type errors resulting from weak updates.", "authors": [{"name": "Alex Aiken", "author_profile_id": "81100399954", "affiliation": "University of California, Berkeley", "person_id": "PP39041079", "email_address": "", "orcid_id": ""}, {"name": "Jeffrey S. Foster", "author_profile_id": "81338488852", "affiliation": "University of Maryland, College Park", "person_id": "PP42049823", "email_address": "", "orcid_id": ""}, {"name": "John Kodumal", "author_profile_id": "81100523487", "affiliation": "University of California, Berkeley", "person_id": "P517413", "email_address": "", "orcid_id": ""}, {"name": "Tachio Terauchi", "author_profile_id": "81100563652", "affiliation": "University of California, Berkeley", "person_id": "P348279", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/781131.781146", "year": "2003", "article_id": "781146", "conference": "PLDI", "title": "Checking and inferring local non-aliasing", "url": "http://dl.acm.org/citation.cfm?id=781146"}