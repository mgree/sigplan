{"article_publication_date": "05-09-2003", "fulltext": "\n CCured in the Real World Jeremy Condit Matthew Harren Scott McPeak George C. Necula Westley Weimer \nUniversity of California, Berkeley * {jcondit,matth,smcpeak,necula,weimer}@cs.berkeley.edu ABSTRACT \nCCured is a program transformation system that adds mem\u00adory safety guarantees to C programs by verifying \nstatically that memory errors cannot occur and by inserting run-time checks where static veri.cation \nis insu.cient. This paper addresses major usability issues in a previ\u00adous version of CCured, in which \nmany type casts required the use of pointers whose representation was expensive and incompatible with \nprecompiled libraries. We have extended the CCured type inference algorithm to recognize and verify statically \na large number of type casts; this goal is achieved by using physical subtyping and pointers with run-time \ntype information to allow parametric and subtype polymorphism. In addition, we present a new instrumentation \nscheme that splits CCured s metadata into a separate data structure whose shape mirrors that of the original \nuser data. This scheme allows instrumented programs to invoke external functions directly on the program \ns data without the use of a wrapper function. With these extensions we were able to use CCured on real\u00adworld \nsecurity-critical network daemons and to produce in\u00adstrumented versions without memory-safety vulnerabilities. \n Categories and Subject Descriptors D.2 [Software]: Software Engineering; D.2.4 [Software Engineering]: \nSoftware/Program Veri.cation General Terms Reliability, Experimentation, Security, Languages  Keywords \nType safety, memory safety, C, run-time type information, compatibility with library code. * This research \nwas supported in part by the National Science Foundation Career Grant No. CCR-9875171, ITR Grants No. \nCCR-0085949 and No. CCR-0081588, an NSF Graduate Fellowship, and gifts from Microsoft Research. The information \npresented here does not necessarily re.ect the position or the policy of the Government and no o.cial \nendorsement should be inferred. Permission to make digital or hard copies of all or part of this work \nfor personal or classroom use is granted without fee provided that copies are not made or distributed \nfor pro.t or commercial advantage and that copies bear this notice and the full citation on the .rst \npage. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior \nspeci.c permission and/or a fee. PLDI 03, June 9 11, 2003, San Diego, California, USA. Copyright 2003 \nACM 1-58113-662-5/03/0006 ...$5.00. 1. INTRODUCTION CCured is a program transformation system that adds \nmemory-safety guarantees to C programs. It .rst attempts to .nd a simple proof of memory safety for the \nprogram, essentially by enforcing a strong type system. Then, the portions of the program that do not \nadhere to the CCured type system are checked for memory safety at run time. Since CCured enforces memory \nsafety, which is an implicit requirement of every C program, it is a good debugging aid. We were able \nto .nd several bugs in the Spec95 benchmark suite and in network daemons simply by running the instru\u00admented \nprograms on inputs included with them. Memory safety is also bene.cial in extensible systems such as \nthe Apache web server or an operating system kernel, which support pluggable modules and device drivers. \nBy instru\u00admenting modules with CCured, the failure of an individual component cannot contaminate the \nsystem as a whole. Perhaps the greatest potential impact of CCured is in the domain of security-critical \nsoftware. Memory safety is an absolute prerequisite for security, and it is the failure of memory safety \nthat is most often to blame for insecurity in deployed software [26]. Further, CCured s relatively mod\u00adest \nperformance cost makes it plausible for security-critical production systems to use binaries compiled \nwith CCured s run-time checks enabled. In a previous paper [15] we described an early version of the \nCCured system. The fundamental concept in CCured is the pointer quali.er, which is used to classify each \npointer into one of three categories according to how it can be used. First, pointers with the quali.er \nSAFE can be dereferenced but cannot be subject to pointer arithmetic or to type casts. They require only \na null-pointer check and are as cheap to use as a reference in a type-safe language such as Java. The \nsecond quali.er, SEQ ( sequence ), indicates that a pointer can be used in pointer arithmetic but not \nin type casts. Such a pointer requires bounds checks and is instrumented to carry with it information \nabout the bounds of the memory area to which it is supposed to point. Finally, the CCured type system \nhas a third class of pointers with the quali.er WILD. In the original CCured type system, WILD pointers \nwere the only ones that could be cast to other pointer types; however, they are more expensive to use \nbecause they carry type tags and require tag manipulation at run time, much like references in a dynamically \ntyped language like Lisp. We review the CCured type system in more detail in Section 2. The early version \nof CCured was already usable on exist\u00ading C programs because of its ability to infer the best pointer \nkinds in unannotated programs. However, that system also had some serious usability problems that made \nit very di.\u00adcult to apply it to system software and large security-critical network daemons. In this \npaper we describe extensions that make it possible to apply CCured to these programs, and we describe \nour experience in doing so. The major usability problem in the original version of CCured was due to \nincompatibilities between the CCured representation of types and the standard C representation used by \nprecompiled libraries. One notable example is the multi-word representation of the CCured SEQ and WILD \npoint\u00aders. Also, objects referenced by WILD pointers must contain tags used to perform CCured s run-time \nchecks. Even a small number of casts that CCured considers bad can re\u00adsult in a large number of WILD \npointers, because any pointer that is obtained from a WILD pointer through assignment or dereference \nmust be WILD as well. In this paper we describe a three-point solution to allevi\u00adating the incompatibility \nproblem. First, we observe that in the presence of structures and unions, most of the type casts can \nbe classi.ed as either up\u00adcasts (e.g., from a pointer to an object to a pointer to the .rst subobject) \nor downcasts (in the opposite direction). To avoid treating these casts as bad, and thus to reduce the \nnumber of WILD pointers, we extend the CCured type system with a physical subtyping mechanism for handling \nthe up\u00adcasts and with a special kind of pointer that carries run-time type information for handling the \ndowncasts. These two mechanisms, described in detail in Section 3, allow CCured to handle object-oriented \ntechniques such as subtyping poly\u00admorphism, dynamic dispatch, and checked downcasts, which are surprisingly \ncommon in large C programs. Second, we have developed a notation that allows a pro\u00adgrammer to specify \nthe conversions and run-time checking operations that must occur at the boundary between the code processed \nwith CCured and precompiled libraries. In Section 4.1, we describe our technique for automatically in\u00adstantiating \nuser-speci.ed wrappers in many contexts. Third and .nally, to address the remaining compatibility problems, \nwe devised a new representation for wide pointers in which CCured s metadata is not interleaved with \nthe pro\u00adgram data. Rather, the metadata is represented in a sepa\u00adrate data structure whose shape mirrors \nthat of the program data itself. Since this separation would incur a performance penalty if used for \nall data, the CCured inference algorithm has been extended to limit the use of this new represen\u00adtation \nto only those types where it is required in order to preserve both soundness and compatibility. This \nmechanism is described in more detail in Section 4.2. The new capabilities of CCured have enabled us \nto ap\u00adply it to a realistic sampling of security-critical applications. We have produced CCured-transformed \nversions of several popular network servers (ftpd, bind, openssl, sshd and sendmail). We have veri.ed \nthat CCured prevents known security exploits, and most importantly, we have produced memory-safe versions \nof these applications that should elim\u00adinate any further vulnerabilities due to memory safety viola\u00adtions. \nWe describe our experience in using CCured for these applications in Section 5. Perhaps if these instrumented \nbi\u00adnaries seewideadoption wemight seean end to (oratleast a slower pace of) the cycle of vulnerability \nreports and patches that has become all too common with security-critical infras\u00adtructure software. Rep(int)= \nint Rep(struct{...tifi; ...})= struct{...Rep(ti)fi; ...} Rep(t * SAFE)= struct{Rep(t ) * p; } Rep(t * \nSEQ)= struct{Rep(t ) * p, * b, * e; } Rep(t * WILD)= struct{Rep(t ) * p, * b; } Figure 1: CCured representations. \nGiven a CCured type t (with pointer quali.ers), Rep(t ) gives its lay\u00adout and representation. 2. CCURED \nTYPES AND CHECKS In this section we review in more detail the typing rules and the run-time checks used \nin the original CCured imple\u00admentation [15]. The CCured type system can be viewed as two universes that \ncoexist soundly. On one hand we have statically-typed pointers for which we maintain the invariant that \nthe static type of the pointer is an accurate description of the contents of the referenced memory area. \nOn the other hand we have untyped pointers, for which we cannot count on the static type; instead, we \nrely on run-time tags to dif\u00adferentiate pointers from non-pointers. CCured provides three pointer kinds \nwith varying capa\u00adbilities and costs. Most pointers in C programs are used without casts or pointer arithmetic. \nWe call such pointers SAFE, and they are either null or valid references. Pointers that are involved \nin pointer arithmetic but are not involved in casts are called SEQ ( sequence ) pointers. SEQ pointers \ncarry with them the bounds of the array into which they are supposed to point. The SAFE and SEQ pointers \nare statically typed. The original CCuredrequiredequal types onbothsides of an assignment statement involving \nSAFE or SEQ pointers. Type casts between unequal pointer types are called bad casts, and we consider \nthe pointers involved to be untyped, or WILD. Such pointers have all the capabilities of C pointers; \nhowever, the static type of a WILD pointer is not necessarily an accurate description of the contents \nof the memory to which it refers. Since CCured pointers must carry bounds and type in\u00adformation, they \nare represented di.erently from normal C pointers. The representation for a CCured type t is given by \nthe function Rep(t ), de.ned in Figure 1. We refer to the pointer, base, and end parts of a sequence \npointer x as x.p, x.b,and x.e, respectively. We store the base and end .elds, which contain metadata \ninformation, with the pointer itself, thus turning C s one-word pointer representation into a multi-word \nstructure. An area referenced by WILD pointers contains additional metadata that indicates the size of \nthe area and whether each word in the area is a pointer. Reads and writes through CCured pointers require \nrun\u00adtime checks. Reads through SAFE pointers require merely a null check, whereas reads through SEQ pointers \nrequire a check that the pointer is in bounds (i.e., x.b = x.p = x.e - sizeof(t ), where t is the type \nbeing read). Reading through a WILD pointer requires bounds checks similar to the checks performed on \nSEQ pointers, although the upper bound for a WILD pointer is stored in the memory area itself. In addition, \nWILD pointer reads require run-time tag checks to ensure that the program never reads a pointer from \na location that contains an integer. Memory writes perform the same checks as memory reads, but writes \nmust also verify that a stack pointer is not being stored in the heap and, for WILD pointers, they must \nupdate the tags. 2.1 Pointer Kind Inference The CCured type system assumes that pointers are al\u00adready \nannotated with pointer quali.ers. In order to use CCured on existing C programs without such annotations, \nwe use a whole-program pointer-kind inference. We as\u00adsociate a quali.er variable with each syntactic \noccurrence of the * pointer-type constructor, with the address of ev\u00adery variable, and with the address \nof every structure .eld. The inference algorithm then assigns a pointer kind to ev\u00adery quali.er variable \nsuch that the resulting program type checks in the CCured system. The CCured inference .nds the best \nkind for a pointer and assigns SAFE and SEQ quali.ers whenever possible. In CCured s algorithm, every \noccurrence of pointer arithmetic produces a constraint that the pointer involved must be SEQ or WILD. \nAlso, every occurrence of a bad cast produces a constraint that the pointers involved must be WILD.Pointers \nwithout any such constraints are inferred SAFE. To ensure soundness in CCured, we cannot allow both an \nuntyped and a statically-typed pointer to refer to the same location, for otherwise the untyped pointer \ncould write ar\u00adbitrary data in the referenced location and invalidate the assumptions of its statically-typed \nalias. The other sound\u00adness condition is that we cannot allow an untyped pointer to point to a statically-typed \npointer, or else we could alter the value of the statically-typed pointer in a way that violates its \ninvariant. These conditions mean that if a pointer quali\u00ad.er becomes WILD then all quali.ers in its base \ntype become WILD as well. Similarly, the quali.ers of pointers that are assigned to or from a WILD pointer \nbecome WILD as well. This linear-time inference algorithm, restricted to the case of a language without \nstructured types, is described in detail and proved to be both correct and optimal in a previous paper \n[15]. However, the trivial extension of the algorithm to structured types has some serious limitations. \nIn particular, there are many casts between pointers to structured types that our algorithm considers \nbad. In the next section, we describe two new extensions to the CCured type system that we have found \nto be very e.ective in reducing the number of bad casts.  3. COPING WITH CASTS Many C programs make \nheavy use of casts between pointer types. In the original CCured, all pointer quali.ers involved in non-trivial \ncasts must become WILD, which creates perfor\u00admance and compatibility problems. Notice that WILD point\u00aders \ncreate more challenging compatibility problems than the other pointer kinds because the memory area to \nwhich they point requires a special layout. This problem is exacerbated by the extensive spreading of \nthe WILD quali.ers. For exam\u00adple, if a FILE * value is involved in a bad cast, it becomes WILD and also \nrequires the return value of the fopen function to become WILD. To support this kind of fopen we would \nneed to change the layout of the statically allocated FILE structures in the standard C library to include \nthe neces\u00adsary tags. As an easy escape hatch, CCured allows the programmer to assert that an otherwise \nbad cast can be trusted. This mechanism is a controlled loss of soundness and assumes an external review \nof those casts. Still, this approach has practical value in focusing a code review when the number of \nsuch casts is relatively small. One standard application of such a trusted cast is a custom allocator \nin which a portion of an array of characters is cast to an object. Fortunately, there are many situations \nin which we can reason e.ectively about casts between unequal types. For example, consider the following \ncode fragment, which con\u00adtains object-oriented style subtype polymorphism. struct Figure { double (*area)(struct \nFigure * obj); }; struct Circle { double (*area)(struct Figure * obj); int radius; }*c; double Circle \narea(Figure *obj) { Circle *cir = (Circle*)obj; // downcast return PI * cir->radius * cir->radius; } \n c->area((struct Figure *)c); // upcast Circle is meant to be a subtype of Figure.Both struc\u00adtures include \na function pointer, which is set to Circle area in the case of circles. The program can compute the \narea of any .gure by invoking the function pointer as shown at the end of the above code fragment (a \nform of dynamic dispatch). According to the strict classi.cation of types from before, there are two \nbad casts: one in the body of Circle area where the input argument is cast to Circle * (a downcast in \nthe subtype hierarchy), and one in the invo\u00adcation of the area method at the end of the code fragment \n(an upcast). Si. et al. [22] observe that a large fraction of the casts between unequal types in real \nprograms are either upcasts or downcasts, and our experiments support this observation. In particular, \nwe have observed that around 63% of casts are between identical types. The remaining 37% were bad casts \nin the original CCured. Of these bad casts, about 93% are safe upcasts and 6% are downcasts. Less than \n1% of all casts fall outside of these categories, and must still be considered bad even in the presence \nof mechanisms that handle downcast and upcasts. In the rest of this section we describe two mechanisms, \none for dealing with upcasts and one for downcasts, with the overall goal of reducing drastically the \nnumber of casts that CCured considers bad. 3.1 Upcasts and Physical Subtyping An upcast is a cast from \ntype t*to type t. *when the aggregate t. is laid out in memory exactly as a pre.x of the layout of the \naggregate t. This relationship between types t and t. is called physical subtyping and has been shown \nprevi\u00adously to be important for understanding the typing structure of C programs [6, 22]. We de.ne the \nphysical subtyping relation t.t. by requir\u00ading that the aggregate tbe physically equal to the concate\u00adnation \nof the aggregate t. and some other (possibly empty) aggregate t: . def t.t...t.t struct{t; t; } Physical \ntype equality is de.ned as the smallest equiva\u00adlence relation generated by the following equations: . \n*t[1] t t[n1 + n2] struct{t[n1]; t[n2]; }struct{t1; void; } t1 struct{t1; struct{t2; t3; }; } struct{struct{t1; \nt2; }; t3; }Note that care must be taken to account for structure padding when using the structure associativity \nrule; we omit t*WILD tWILD Expression Typing Premises Run-time checks and translation (t . * RTTI)xx \n: t * SAFE,t .t . {p = x, t = rttiOf(t )}(t . * RTTI)xx : t * RTTI,t .t . x (t . * RTTI)xx : t * RTTI,t \n. .t assert(isSubtype(x.t, rttiOf(t )); x (t . * SAFE)xx : t * RTTI assert(isSubtype(x.t, rttiOf(t )); \nx.p Figure 2: CCured typing rules for casts involving RTTI pointers. For an expression in the left column, \nthe middle column shows the typing premises, and the right column shows the instrumentation that is added. \nthe details. With these de.nitions the more relaxed CCured typing rules for casts are the following: \nt . e : t . * SAFE .te : t . * SEQ .n,n .t [n ] t [n] (t * SAFE)e : t * SAFE (t * SEQ)e : t * SEQ Our \nnotion of physical subtyping for SAFE pointers is dif\u00adferent from that of previous work; speci.cally, \nCCured dif\u00adfers in its handling of void* and of pointer arithmetic. In previous work [6, 22], void* is \nallowed in the smaller aggre\u00adgate in any position where a regular pointer is present in the larger one. \nThis approach is unsound; instead, void should be considered to be the empty structure and any type should \nbe considered a physical subtype of void.As a result, we can safely cast a pointer to any type into void*. \nHowever, when we try to use the resulting void* we have to cast it to some other pointer type .rst; this \ndowncast operation is handled later in this section. Physical subtyping must also be modi.ed in the presence \nof pointer arithmetic; we cannot use simple width subtyping as with SAFE pointers. For example, it is \nnot safe to cast apointer cs of type struct Circle * SEQ to type struct Figure * SEQ, because then the \nmemory word residing at address cs.radius can be accessed as a double and also as a function pointer \nusing ((struct Figure * SEQ)cs + 1).area. To .xthis soundness problem we require for each type cast on \nSEQ pointers that t [n ] t [n]where n, n . > 0are the smallest integers such that n \u00b7 sizeof(t )= n \n. \u00b7 sizeof(t ). Notice that when changing the type of a SEQ pointer into another SEQ pointer, the representation \ndoes not change. Casting between SEQ pointers also allows for a robust treat\u00adment of multi-dimensional \narrays (in which case one of the n or n . is typically 1) and is necessary for handling many non-trivial \nC programs. Changes to the Inference Algorithm. In order to handle structures and physical subtyping, \nthe original CCured inference algorithm [15] must be extended to pay special at\u00adtention to casts. If \nthere is a cast from t1 * to t2 *,we examine t1 and t2 in tandem using the physical type equal\u00adity rules, \nand we emit pointer kind constraints to make sure that t1 is a subtype of t2. Basically, if t2 s representation \nis a pre.xof t1 s representation, the quali.ers can remain SAFE.Otherwise,they must be WILD. For reasons \nof space we omit many details here; a complete discussion of inference is available as a technical report \n[27].  3.2 Downcasts and Run-Time Type Info. A downcast is a cast from a type t * to t . * when t . \nis a physical subtype of t . One example of a downcast is the cast in the body of the Circle area function \nshown in the previous section. Such examples seem to arise often in large programs when C programmers \ntry to use subtype polymorphism and dynamic dispatch to achieve an object\u00adoriented structure for their \nprograms.  Another frequent occurrence of a downcast is a cast from void* to any other pointer type. \nAn interesting result of our experiments is that only a small percentage of uses of void* can be attributed \nto implementations of parametric polymorphism (e.g., arrays whose elements all have the same dynamic \ntype). More often it seems void* is used for imple\u00admenting the more expressive subtype polymorphism (e.g., \narrays whose elements have distinct types that are all sub\u00adtypes of void*). If we classify all downcasts \nas bad casts, we essentially ignore static type information, which is undesirable. In\u00adstead, we extend \nthe CCured type system with a new pointer kind, RTTI, that allows checked downcasts using run-time type \ninformation in a manner similar to the checked down\u00adcasts in typed object-oriented languages. In the \ncontext of CCured, however, we have to answer several questions. First, how should the run-time type \ninformation be encoded, and should it be carried with the pointer or stored with the referenced object? \nSecond, what changes are necessary to the CCured inference mechanism to use RTTI pointers in existing \nC programs? We represent the run-time type information as nodes in a global tree data structure that \nencodes the physical subtyp\u00ading hierarchy of a program. There is a compile-time func\u00adtion, rttiOf, that \nmaps a type to its node in the hierarchy data structure, and a run-time function, isSubtype,that checks \nwhether one node is a physical subtype of another. In addition, we have decided to store the run-time \ntype infor\u00admation with the pointer and not with the referenced object, as it is done in object-oriented \nlanguages. The main reason in favor of this choice is that C allows pointers to point into the interior \nof an allocation unit (e.g., to a .eld of a struc\u00adture or to an element of an array). In such cases it \nwould have been hard or impossible to insert the run-time type information at a statically known o.set \nin the referenced object. Furthermore, we have observed experimentally with other pointer kinds in CCured \nthat if we change the layout of pointers to objects rather than that of the objects them\u00adselves, we increase \nthe likelihood that the transformed code will be compatible with external libraries. The representation \nof a pointer of type t * RTTI consists of two words, one encoding the pointer value and the other encoding \nthe node in the subtype hierarchy that corresponds to its actual run-time type: Rep(t * RTTI)= struct{Rep(t \n) * p, RttiNode * t}CCured maintains the invariant that such a pointer is either null or otherwise points \nto a valid object of some type that is a physical subtype of t . This invariant means that such a pointer \ncan be safely dereferenced just like a t * pointer if needed; alternatively, it can be cast to some physical \nsubtype of t with a run-time check. In Figure 2 we show the necessary changes to the CCured type system \nand instrumentation. Notice that a cast from SAFE to RTTI must be an upcast and that the original type \nis recorded in the newly created pointer. Among RTTI pointers we allow both upcasts or downcasts, but \nin the latter case we check at run-time that the representation invariant is preserved. A similar check \nis performed when we cast from RTTI to SAFE. The rules for dereferencing RTTI pointers are thesameasfor \nSAFE pointers. Changes to the Inference Algorithm. The inference algorithm considers each cast from type \nt* qto type t. * q . and collects constraints on the pointer kind variables qand q . as follows: If \nthis cast is a downcast (t. .t)then q= RTTI.  If thebasetypes are physically equal(t t) then the RTTI \nkind propagates against the data .ow: q . = RTTI =. q= RTTI.  If this cast is an upcast (t.t)and the \nsource type has subtypes, then the RTTI pointer kind propagates against the data .ow:  q = RTTI . (. \nt.t.t)=. q= RTTI. Otherwise, this cast is a bad cast and q= q . = WILD The .rst two rules identify the \ndowncasts and propagate the requirement for run-time type information to the origin of the pointer. The \nthird inference rule attempts to restrict the backwards propagation of the RTTI kind to those types that \nhave subtypes (the existential quanti.er ranges over the types actually occurring in the program). If \na pointer type does not have subtypes in the program, then the represen\u00adtation invariant of RTTI pointers \nensures that its static type is the same as its run-time type, and thus the RTTI pointer kind is not \nnecessary; instead, we use the pointer kind SAFE, which saves both space and time. For example, consider \nthe following sequence of casts, which uses the types introduced before: Circle* q1 -. Figure* q2 -. \nvoid* q3 -. Circle* q4 The new inference rules generate constraints that require q3 to be RTTI (due to \nthe downcast from void* to Circle*) and then will propagate the RTTI kind to q2. However, the RTTI kind \ndoes not propagate to q1 since Circle * does not have subtypes in the program. The variable q4 is uncon\u00adstrained \nand thus remains SAFE. The RTTI pointer kind naturally supports the paramet\u00adric polymorphism discipline \nas well as other programming practices common in C programs, such as various .avors of dynamic dispatch \nand generic data structures. The infer\u00adence rules associated with this pointer kind are simple, and the \nresults of inference are predictable.  4. COMPATIBILITY WITH LIBRARIES It is often necessary to link \ncured programs with libraries that were not compiled by CCured. Doing so allows users to avoid recompiling \nthese libraries with each program. More importantly, this feature allows CCured s output to be linked \nwith binaries written in assembly code or other languages, and it allows programmers to use libraries \nfor which the source code is unavailable. #pragma ccuredWrapperOf(\"strchr_wrapper\", \"strchr\") char* \nstrchr_wrapper(char* str, int chr) { __verify_nul(str); // check for NUL termination // call underlying \nfunction, stripping metadata char *result = strchr(__ptrof(str), chr); // build a wide CCured ptr for \nthe return value return __mkptr(result, str); } Figure 3: A wrapper for strchr. 4.1 Library Wrappers \nOne approach to the problem of library compatibility is to write wrapper functions for external library \nfunctions. CCured has been structured so that a program that tries to communicate with a non-CCured library \nusing multi\u00adword pointers will fail to link rather than crash at run time. To link correctly with a function \nthat is not instrumented, CCured must: 1. Determine what constraints the external function places on \nits inputs to ensure safe operation. Although there is no way to guarantee that the external function \nis memory-safe, CCured can validate assumptions on which the function relies, such as the size of an \ninput bu.er. 2. Perform appropriate run-time actions to check that these constraints are met and pack \nor unpack multi\u00adword pointers.  We accomplish these tasks by requiring the programmer to provide a \nsmall wrapper speci.cation for each external function called by a program.1 For example, Figure 3 shows \na wrapper speci.cation for strchr, a function that returns a pointer to the .rst occurrence of a given \ncharacter in a string. CCured replaces all calls to strchr with the body of this wrapper, in which the \nhelper functions verify nul, ptrof,and mkptr are replaced with specialized code de\u00adpending on the pointer \nkinds of their arguments and results. A single wrapper function works with any set of inferred quali.ers. \nNotice that the wrapper speci.cation can also include checks of preconditions of the library functions. \nWe have implemented wrappers for about 100 commonly\u00adused functions from the C Standard Library. The wrappers \nare packaged with CCured so that calls to these functions are correctly handled with no further intervention \nrequired. 4.2 Compatible Metadata Representations The wrapper speci.cations described above have proved \nuseful for relatively simple external functions such as the core of C s standard library. However, C \nprograms often make use of library interfaces that are much more complex. Consider, for example, the \nlibrary function gethostbyname(), which is used to perform DNS queries in some of the net\u00adwork servers \non which we want to use CCured. This function returns a pointer to the following structure (omitting \nsome In practice, this speci.cation is only necessary for functions .elds for clarity): struct char \nhostent {*h name; // String char **h aliases; // Array of strings int h addrtype; 1 } ; whose actual \narguments contain multi-word pointers. h_name h_aliases h_addrtype Figure 4: Interleaved representation \nfor struct hostent. Array-bounds metadata (gray) is inter\u00adspersed with data (white). h_aliases Figure \n5: Non-interleaved representation for struct hostent. Metadata (gray) has been separated into a parallel \ndata structure so that the data (white, boxed) has the format expected by the C library. The m .eld is \na pointer to the array s metadata. Since the library that creates this structure is not instru\u00admented \nby CCured, it returns data in exactly this format. However, CCured needs to store metadata (b and e .elds) \nwith each string and with the array of strings itself; in other words, CCured expects a representation \nin which all pointers are wide pointers, as shown in Figure 4. In order to convert the library s data \nrepresentation to CCured s data represen\u00adtation, we would have to do a deep copy of the entire data structure. \nSince deep copies require expensive allocations and destroy sharing, such a conversion is undesirable. \nCon\u00adversions can be avoided if the metadata is not interleaved with the normal data; however, merely \nmoving the metadata to the beginning or the end of the structure is insu.cient in a number of cases (e.g., \nan array of structures used by a library). Our solution is to split the data and metadata into two separate \nstructures with a similar shape; for example, a linked list is transformed into two parallel linked lists, \none containing data and the other containing metadata. Cre\u00adating and maintaining these data structures \nis quite easy. For every data value in the original program, our trans\u00adformed program has a data value \nand a metadata value. Every operation on a value with metadata is split into two such operations, one \non the data and one on the correspond\u00ading metadata. Figure 5 shows the representation of struct hostent \nusing this new approach. We will now make our informal notion of separated data and metadata more precise \nby specifying the types of these values. The data value s type must be identical to the origi\u00adnal C type, \nsince we intend to pass it directly to an external C(int)= int C(struct{...ti fi; ...}) = struct{...C(ti) \nfi; ...} C(t * SAFE)= C(t) * C(t * SEQ)= C(t) * Meta(int)= void Meta(struct{...ti fi; ...})= struct{...Meta(ti) \nfi; ...} Meta(t * SAFE) = struct{Meta(t) * m; } Meta(t * SEQ) = struct{C(t) * b,* e; Meta(t) * m; } \n The m .eld is omitted if Meta(t)= void. Figure 6: The C and Meta functions de.ne the data and metadata \ntypes (respectively) in the compatible representation. Together, these functions de.ne a compatible alternative \nto the Rep function. library (or obtain it directly from a library). For a given CCured type t, we express \nthis original C type (without pointer kinds) as C(t). Similarly, we write the type of the separated metadata \nvalue as Meta(t). Together, the types C(t)and Meta(t) provide a complete representation for the CCured \ntype t; thus, they can be used in place of the rep\u00adresentation given by Rep(t)inFigure 1. Formal de.nitions \nfor the functions C and Meta are given in Figure 6. The de.nition for C recursively strips o. all pointer \nquali.ers; for example, C(int * SEQ * SEQ)= int **. The de.nition of the function Meta is slightly more \ncomplex, but it adheres to the following rule of thumb: the metadata for a type t must include the metadata \nrequired by t itself (e.g., a SEQ pointer s b and e .elds) as well as the metadata for any base types. \nThus, the metadata for a SEQ pointer includes a base pointer, an end pointer, and a pointer to the metadata \nof its base type, if such metadata exists. A SAFE pointer has no metadata of its own, so it only needs \nto maintain a pointer to the metadata of its base type, if the base type requires metadata. Likewise, \na structure requires no metadata in and of itself, so its metadata is simply a structure containing the \nmetadata of each of its .elds, as necessary. Note that we currently do not support this com\u00adpatible representation \nfor WILD pointers. An important property of the Meta function is that meta\u00addata is only introduced by \npointers that have metadata in their original CCured representation as given by the Rep function (e.g., \nSEQ pointers); if a type does not contain any of these pointers, its metadata type will be void.On the \nother hand, any type that is composed from a pointer that needs metadata must itself have metadata, since \nat the bare minimum it must maintain a pointer to the component pointer s metadata. This case illustrates \nthe disadvantage of using the separated metadata representation: pointers re\u00adquire more metadata than \nbefore, and in some cases, even SAFE pointers require metadata. Because this new representation is less \ne.cient than the original one, we restrict its use to those parts of a program that require it for compatibility. \nTo indicate which represen\u00adtation should be used for a given type, we add two new type quali.ers: SPLIT \nand NOSPLIT. Note that unlike the SAFE and SEQ quali.ers, which apply only to pointer types, these new \nquali.ers apply to all types. A value of type t SPLIT is represented using data of type C(t) and metadata \nof type Rep(struct{...ti SPLIT fi; ...})= struct{...C(ti) fi; Meta(ti) mi; ...}Rep(t SPLIT * SAFE)= struct{C(t \n) * p; Meta(t ) * m; }Rep(t SPLIT * SEQ)= struct{C(t ) * p, * b, * e; Meta(t ) * m; } Figure 7: The Rep \nfunction can be extended to han\u00addle NOSPLIT types that contain SPLIT types. This de.\u00adnition extends the \nde.nition given in Figure 1, which considers only NOSPLIT types. Meta(t ). Correspondingly, a value of \ntype t NOSPLIT is rep\u00adresented using the type Rep(t ), which contains interleaved data and metadata. \nSPLIT pointers cannot point to NOSPLIT types; otherwise, they would be incompatible with external libraries. \nHow\u00adever, NOSPLIT pointers are allowed to point to SPLIT types. The representation of such boundary pointers \nis given in Figure 7, which extends the previous de.nition of Rep to handle this case. For example, a \nSAFE NOSPLIT pointer to a SPLIT type t consists of pointers to t s data and metadata, which are represented \nusing C(t )and Meta(t ). SEQ pointers and structures are handled in a similar manner. Example. The following \nexample demonstrates the trans\u00adformation applied when using CCured s compatible repre\u00adsentation. struct \nhostent SPLIT * SAFE SPLIT h1; struct hostent SPLIT * SAFE NOSPLIT h2; char * SEQ SPLIT * SEQ SPLIT a; \na = h1->h aliases; h2 = h1; In this program, struct hostent uses the compatible rep\u00adresentation as shown \nin Figure 5. We declare two pointers to this structure, one SPLIT and one NOSPLIT.We copy h1 s h aliases \n.eld into the local variable a of the same type, andthenwe assign the SPLIT pointer h1 to the NOSPLIT \npointer h2. The instrumented program is as follows: struct meta seq char { char *b, * e; }; struct meta \nseq seq char { char * *b, ** e; struct meta seq char *m; }; struct hostent * h1; struct meta hostent \n{ struct meta seq char h name; struct meta seq seq char h aliases; } * h1m; struct { struct hostent \n* p; struct meta hostent * m; } h2; char **a; struct meta seq seq char am; a = h1->h aliases; am = h1m->h \naliases; h2.p = h1; h2.m = h1m; In the transformed program, the SPLIT pointers h1 and a are now represented \nusing two pointers each: h1, h1m, a, and am. In these variable names, the m designates a meta\u00addata value. \nThetypeof h1m is as shown in the right-hand side of Figure 5. The NOSPLIT pointer to a SPLIT struct hostent \nis represented as a structure containing pointers to the data and metadata of the underlying SPLIT structure. \nThe assignment to a becomes two assignments, one for the data part stored in a and one for the metadata \npart stored in am. Note that we dereference h1m in the same way that we dereference h1; the metadata \nstructure is traversed in parallel with the data structure. The conversion from the SPLIT pointer h1 \nto the NOSPLIT pointer h2 simply copies the data and metadata pointers into h2. Changes to the Inference \nAlgorithm. CCured re\u00adquires that the programmer identify places in the program where this compatible \nrepresentation should be used. To assist the programmer, CCured provides an inference algo\u00adrithm that \nspreads the SPLIT quali.er as far as necessary based on the programmer s annotations. Initially, all \ntypes are assumed to be NOSPLIT unless the programmer indicates otherwise. Starting from user-supplied \nSPLIT annotations, SPLIT quali.ers .ow down from a pointer to its base type and from a structure to its \n.elds in order to ensure that SPLIT types never contain NOSPLIT types. In addition, if there is a cast \nfrom a SPLIT type to a NOSPLIT type (or vice versa), we ensure that all types con\u00adtained within the NOSPLIT \ntype are SPLIT;that is, a cast be\u00adtween pointers requires that both base types be SPLIT,and a cast between \nstructures requires that all .elds be SPLIT. This restriction corresponds directly to a restriction in \nthe pointer quali.er inference algorithm; in both cases, convert\u00ading between pointer types whose base \ntypes have di.erent representations is unsound. To obtain the type quali.ers in the above example, the \nprogrammer would only have to an\u00adnotate the top-level type of h1 and a to be SPLIT (possibly because \nthey are being passed to or from library functions). The remaining SPLIT and NOSPLIT quali.ers are then \nin\u00adferred based on the rules we described above. Limitations. This compatible metadata representation \nsigni.cantly eases the burden of communicating with exter\u00adnal libraries, but unfortunately, it does not \nsolve the entire problem. In particular, if a library makes changes to a data structure that require \ncorresponding changes to the associ\u00adated metadata, then the metadata will be invalid upon re\u00adturn from \nthe external library. Also, CCured must generate new metadata when the library returns a newly allocated \nobject. Thus, CCured must validate any new or potentially modi.ed data structures after calling into \nan external library function. We are currently evaluating a number of strategies for coping with this \nproblem. However, experience suggests that this compatible representation is useful even in the ab\u00adsence \nof such mechanisms. Many data structures are read\u00adonly for either the application or the library, which \nsimpli.es or eliminates this problem; for instance, applications rarely modify the struct hostent returned \nby gethostbyname(), which simpli.es the problem of generating metadata for its return value. In other \ncases, such as the function recvmsg(), the library only modi.es a character bu.er that has no as\u00adsociated \nmetadata.  5. EXPERIMENTS We tested our system on many real-world C programs ranging in size from several \nhundred lines of code to sev\u00aderal hundred thousand. These experiments allowed us to measure both the \nperformance cost of the run-time checks inserted by CCured and the amount of manual intervention required \nto make existing C programs work with our system. In general, computationally expensive tasks like the \nSpec95 benchmarks and the OpenSSL cryptography library showed the greatest slowdown (ranging from 0 87% \noverhead). Sys\u00adtem software like Linuxkernel modules and FTP daemons showed no noticeable performance \npenalty; the cost of run\u00adtime checks is dwarfed by the costs of input/output oper\u00adations. Our experiments \nallowed us to detect a number of bugs in existing programs and enable us to run safety-critical code \nwithout fear of memory-based security errors such as bu.er overruns. We .rst tested CCured with the Spec95 \n[24], Olden [3], and Ptrdist-1.1 [2] benchmark suites. Using CCured re\u00adquired minor changes to some of \nthese programs, such as correcting function prototypes, trusting a custom allocator, or moving to the \nheap some local variables whose address is itself stored into the heap. These changes resulted in modi\u00ad.cations \nto about 1 in 100 lines of source code. In the pro\u00adcess we discovered a number of bugs in these benchmarks, \nincluding several array bounds violations and a printf that is passed a FILE* when expecting a char* \n[15]. CCured s safety checks added between 7 and 56% to the running times of these tests. For comparison, \nwe also tried these tests with Purify version 2001A [8], which increased running times by factors of \n25 100. Purify modi.es C bina\u00adries directly to detect memory leaks and access violations by keeping two \nstatus bits per byte of allocated storage. Purify has an advantage over CCured in that it does not require \nthe source code to a program (or any source code changes), so it is applicable in more situations. However, \nwithout the source code and the type information it contains, Purify can\u00adnot statically remove checks \nas CCured does. Also, Purify does not catch pointer arithmetic between two separate valid regions [11], \na property that Fischer and Patil [17] show to be important. We commented on some of these experiments \nin a previous paper [15]. We also ran comparisons against Valgrind [20], an open\u00adsource tool for .nding \nmemory-related bugs. Valgrind checks all reads, writes, and calls to allocation functions via JIT in\u00adstrumentation, \nas well as maintaining 9 status bits per bit of program memory. Like Purify, it does not require the \npro\u00adgram source but entails a steep run-time overhead; Valgrind slows down instrumented programs by factors \nof 9 130, as shown in Figure 9. Both Purify and Valgrind miss many memory errors that CCured catches; \nin particular, these other tools do not catch out-of-bounds array indexing on stack-allocated arrays. \nFor the remainder of this section, we focus on experiments that we were able to perform only after extending \nCCured as explained in this paper. Interacting with C Code. As we began to tackle larger programs that \nrelied heavily on the C Standard Library and on other preexisting C binaries, we found that CCured had \nno convenient way to link with such code. Our .rst solution to this problem was the system of wrappers \ndescribed in Section 4.1. These wrappers helped us use CCured to make memory\u00adsafe versions of a number \nof Apache 1.2.9 modules. Bu.er overruns and other security errors with Apache modules have led to a least \none remote security exploit [19]. In addition to writing CCured wrappers for Apache s array\u00adhandling \nfunctions, we annotated data structures that are created by Apache and passed to the module so that they \nwould be inferred as having SAFE pointers. The physical sub- Module Lines % CCured Name of code sf/sq/w/rt \nRatio asis 149 72/28/0/0 0.96 expires 525 77/23/0/0 1.00 gzip 11648 85/15/0/0 0.94 headers 281 90/10/0/0 \n1.00 info 786 86/14/0/0 1.00 layout 309 82/18/0/0 1.01 random 131 85/15/0/0 0.94 urlcount 702 87/13/0/0 \n1.02 usertrack 409 81/19/0/0 1.00 WebStone n/a n/a 1.04  Figure 8: Apache Module Performance. The sf/sq/w/rt \ncolumn show the percentage of (static) pointer declarations which were inferred SAFE, SEQ, WILD and RTTI, \nrespectively. A ratio of 1.04 means that the CCured module was 4% slower than the original. typing described \nin Section 3.1 was necessary for CCured to determine that some casts were safe. Figure 8 shows the performance \nof these modules on tests consisting of 1,000 requests for .les of sizes of 1, 10, and 100K. The WebStone \ntest consists of 100 iterations of the WebStone 2.5 manyfiles benchmark with every request af\u00adfected \nby the expires, gzip, headers, urlcount and usertrack modules. We also used CCured on two Linuxkernel \ndevice drivers: pcnet32, a PCI Ethernet network driver, and sbull,a ramdisk block device driver. Both \nwere compiled and run using Linux2.4.5. We used wrapper functions for Linuxassem\u00adbly code macros, which \nhas the advantage of allowing us to insert appropriate run-time checks into otherwise opaque as\u00adsembly \n(e.g., we perform bounds checks for the Linuxinter\u00adnal memcpy routines). Some Linuxmacros (like INIT \nREQUEST) and low-level casts were assumed to be part of the trusted interface. Porting sbull to CCured \ninvolved changing about 20 lines of code, and pcnet32 required only 5 changes. The performance measurements \nare shown in Figure 9. pcnet32 measures maximal throughput, and ping indi\u00adcates latency. sbull measures \nblocked reads (writes and character I/O were similar), and seeks indicates the time to complete a set \nnumber of random seeks. Finally, we ran ftpd-BSD 0.3.2-5 through CCured. This version of ftpd has a known \nvulnerability (bu.er over.ow) in the replydirname function, and we veri.ed that CCured prevents this \nerror. The biggest hurdle was writing a 70-line wrapper for the glob function. As Figure 9 shows, we \ncould not measure any signi.cant performance di.erence between the CCured version and the original. With \nboth ftpd and Apache modules, the client and server were run on the same machine to avoid I/O latency. \nRun-time Type Information. In one of the .rst uses of the new RTTI pointer kind, we revisited a previous \nexper\u00adiment. With the original version of CCured the ijpeg test in Spec95 had a slowdown of 115% due \nto about 60% of the pointers being WILD. (We also had towrite afair number of wrappers to address the \ncompatibility problems.) This benchmark iswritteninanobject-oriented style witha sub\u00adtyping hierarchy \nof about 40 types and 100 downcasts. With RTTI pointers we eliminated all bad casts and WILD pointers \n Name Lines of code % sf/sq/w/rt CCured Ratio Valgrind Ratio pcnet32 1661 92/8/0/0 0.99 ping 1.00 sbull \n1013 85/15/0/0 1.00 seeks 1.03 ftpd 6553 79/12/9/0 1.01 9.42 OpenSSL 177426 67/27/0/6 1.40 42.9 cast \n1.87 48.7 bn 1.01 72.0 OpenSSH 65250 70/28/0/3 client 1.22 22.1 server 1.15 sendmail 105432 65/34/0/1 \n1.46 122 bind 336660 79/21/0/0 1.81 129 tasks 1.11 81.4 sockaddr 1.50 110 Figure 9: System software \nperformance. A ratio of 1.03 means the CCured version is 3% slower than the original. Not all tests were \napplicable to Val\u00adgrind. with only 1% of the pointers becoming RTTI instead. This result shows how far \nthe WILD quali.er can spread from bad casts. Overall, the slowdown is reduced to 45%. We modi.ed OpenSSL \n0.9.6e, a cryptographic library and implementation of the Secure Sockets Layer protocol, to compile under \nCCured. Because of the structure of OpenSSL, this task required changing many function signatures so \nthat they match the types of the function pointers to which they were assigned. We used RTTI pointers \nextensively to handle OpenSSL s many uses of polymorphic pointers and container types. Because OpenSSL \nuses char* as the type for its poly\u00admorphic pointers, we were also forced to change the type of each \nof these pointers to void* to avoid unsound casts.2 These changes allowed us to compile OpenSSL with \nonly two trusted casts, which were needed for pseudorandom num\u00adber seeds; thus, CCured should guarantee \nmemory safety for this program with a minute trusted computing base. While running OpenSSL s test suite \nafter compiling with CCured, we found one array bounds violation in the processing of rulestrings. We \nalso found a bounds error in the test suite itself and two programming errors in the library that do \nnot a.ect program behavior. Figure 9 shows the performance of OpenSSL s test suite after compiling with \nCCured, compared to the original C code. We show speci.c results for a test of the cast cipher and the \nbig number package ( bn ). Note that the baseline C version is itself 20% slower than a default installation \nof OpenSSL, which uses assembly code implementations of key routines. CCured, of course, cannot analyze \nassembly code. We also ran CCured on OpenSSH 3.5p1, an ssh client and server that links with the OpenSSL \nlibrary. Not counting that library, we made 109 small changes and annotations to the 65,000 lines of \ncode in OpenSSH. We use several trusted casts to deal with casts between di.erent types of sockaddr structs, \nsince CCured also adds bounds information to guar\u00adantee that these are used safely. We are using an instru- \nWith the adoption of ANSI C, void* replaces char* as the standard notation for an undetermined pointer \ntype. mented version of the OpenSSH daemon in our group s login server with no noticeable di.erence \nin performance. In doing so we have found one bug in the daemon s use of open(). We used CCured to make \na type-safe version of sendmail 8.12.1. CCured is capable of preventing security-related er\u00adrors in \nsendmail, including two separate bu.er overrun vul\u00adnerabilities that have been found recently [5]. Using \nCCured with sendmail required annotating variable argument func\u00adtions and replacing inline assembly with \nequivalent C code. To avoid WILD pointers, we modi.ed several places in the code that were not type safe: \nunionsbecame structs, and unsound casts needed for a custom allocator were marked as trusted. We also \nused RTTI for polymorphic pointers that were used with dynamic dispatch. Finally, several stack al\u00adlocated \nbu.ers were moved to the heap. In all, about 200 changes were required for the approximately 105,000 \nlines of code in sendmail. We found 2 bugs, both at compile time: a debug printf was missing an argument, \nand a (currently unused) section of code had a memory error due to a miss\u00ading dereference operator. Figure \n9 shows the results of a performance test in which messages were sent to a queue on the same host, using \ninstrumented versions of sendmail for both client and daemon. Finally, we ran CCured on bind 9.2.2rc1, \na 330,000-line network daemon that answers DNS requests. CCured s qual\u00adi.er inference classi.es 30% of \nthe pointers in bind s unmod\u00adi.ed source as WILD as a result of 530 bad casts that could not be statically \nveri.ed. (bind has a total of 82000 casts of which 26500 are upcasts handled by physical subtyping.) \nOnce we turn on the use of RTTI, 150 of the bad casts (28%) proved to be downcasts that can be checked \nat run time. We instructed CCured to trust the remaining 380 bad casts rather than use WILD pointers, \ntherefore trading some safety for the ability to use the more e.cient SAFE and SEQ point\u00aders. A security \ncode review of bind should start with these 380 casts. Figure 9 provides performance results for experiments \nin\u00advolving name resolution; the tasks trial measured multi\u00adple workers and the sockaddr trial measured \nIPv4 socket tasks. bind was the one of the most CPU-intensive pieces of systems software we instrumented, \nand its overhead ranged from 10% to 80%. Compatible Pointer Representations. When curing bind, it was \nnecessary to deal with networking functions that pass nested pointers to the C library, such as sendmsg \nand recvmsg. To demonstrate the bene.t of our compatible pointer representation, we instructed CCured \nto use split types when calling such functions. By doing so, we elimi\u00adnated the need to perform deep \ncopies on the associated data structures, and we relieved the programmer of the burden of writing complexwrapper \nfunctions. The inference algo\u00adrithm described in Section 4.2 determined that 6% of the pointers in the \nprogram should have split types and that 31% of these pointers need a metadata pointer. The large number \nof metadata pointers is a result of the trusted casts used when curing bind; in order to preserve soundness \nwhen using these casts, we had to add metadata pointers to places where they would not normally be necessary. \nWe also used our compatible pointer representation when curing OpenSSH.As with bind, split types were \nused when calling the sendmsg function. In addition, we used split types when reading the environ variable, \nwhich holds the program s current environment. Less than 1% of all pointers in the program required a \nsplit type or a metadata pointer. The nature of the call sites allowed us to take advantage of split \ntypes without spreading them to the rest of the pro\u00adgram. To demonstrate the usefulness of our compatible \npointer representation when linking with libraries that have compli\u00adcated interfaces, we applied CCured \nto the ssh client pro\u00adgram without curing the underlying OpenSSL library. The ssh program uses 56 functions \nfrom the OpenSSL library, and many of these functions have parameters or results that con\u00adtain pointers \nto pointers (and even pointers to functions). It would have been di.cult to write wrappers for such a \ncom\u00adplexinterface, but our compatible representation required the user to add only a handful of annotations \n(e.g., the user must identify places where results are returned via a func\u00adtion parameter). Even when \nusing split types for all of these interfaces, our compatible representation was only needed in a limited \nnumber of places in the cured program: only 3% of pointers had split types, and only 5% of pointers required \nmetadata pointers. To determine the overhead of our compatible represen\u00adtation, we ran the olden, ptrdist,and \nijpeg tests with all types split. In most cases, the overhead was negligi\u00adble (less than 3% slowdown); \nhowever, execution times in\u00adcreased in a few cases. The em3d program (part of olden) was slowed down \nby 58%, and the anagram program (part of ptrdist) was slowed down by 7%. While split types are relatively \nlightweight, these outliers suggest that it is impor\u00adtant to minimize the number of split types used, \nwhich can be achieved by applying our inference algorithm. Unfortu\u00adnately, the performance impact of \nour compatible represen\u00adtation is di.cult to predict at compile time; the slowdown appears to depend \nheavily on how the program uses pointers at run time. Summary of Experiments We have used CCured on several \nlarge, widely-used pro\u00adgrams for which reliability and security are critically impor\u00adtant, including \nftpd, bind, sendmail, OpenSSL, OpenSSH, and several Apache modules. Modi.cations and annotations were \nrequired to deal with unsound behavior in these pro\u00adgrams. The performance of the instrumented code is \nfar better than the performance when using existing tools such as Valgrind or Purify for adding memory \nsafety to C. As a result, it is possible to use instrumented programs in day-to\u00adday operations so that \nmemory errors can be detected early and many security holes can be prevented. Finally, we have detected \nseveral bugs in the programs we tested.  6. RELATED WORK There have been many attempts to design C-like \nlan\u00adguages or language subsets that are provably type safe. The Cyclone language [10] is expressive, \ngives programmers a high degree of control, and has been used on similar types of programs (e.g., device \ndrivers). Smith et al. [23] present a type-safe polymorphic dialect of C that includes most of C s features \n(and higher-order functions, which our current system handles weakly) but lacks casts and structures. \nHow\u00adever, these approaches work only for programs written in the given dialect. Ramalingam et al. [18] \nhave presented an algorithm for .nding the coarsest acceptable type for structures in C pro\u00adgrams. Chandra \nand Reps [6] present a method for physical type checking of C programs based on structure layout in the \npresence of casts. Si. et al. [22] report that many casts in C programs are safe upcasts and present \na tool to check such casts. Each of these approaches requires programs to adhere to their particular \nsubset; otherwise, the program is rejected. CCured s static type system has comparable ex\u00adpressiveness, \nbut CCured can fall back on its .exible RTTI or WILD pointers to handle the corner cases. Our notion \nof physical subtyping extends this line of work to include pointer arithmetic (see Section 3.1). Another \ncommon approach is to add run-time checks to C programs. Kaufer et al. [12] present an interpretive scheme \ncalled Saber-C that can detect a rich class of errors (includ\u00ading uninitialized reads and dynamic type \nmismatches but not all temporal access errors) but runs about 200 times slower than normal. Austin et \nal. [2] store extra information with each pointer and achieve safety at the cost of a large overhead \n(up to 5 times slower) and a lack of library compat\u00adibility. Jones and Kelly [11] store extra information \nfor run\u00adtime checks in a splay tree, allowing safe code to work with unsafe libraries. This approach \nresults in a slowdown factor of 5 to 6. Fischer and Patil have presented a system that uses a second \nprocessor to perform the bounds checks [16]. Loginov et al. [14] store type information with each memory \nlocation, incurring a slowdown factor of 5 to 158. This extra information allows them to perform more \ndetailed checks than CCured can, and they can detect when stored types do not match declared types or \nwhen union members are accessed out of order. The approaches of Austin et al. and Jones and Kelly are \ncomparable to the implementation of CCured s WILD pointers. However, beyond array bounds check elimination, \nnone of these techniques use type-based static analysis to aggressively reduce the overhead of the instrumented \ncode. The global splay tree used by Jones and Kelly [11] pro\u00advides an alternative approach to the problem \nof library com\u00adpatibility; however, we found that looking up metadata in a global data structure was \nprohibitively expensive. Also, Patil and Fischer [16] maintain shadow data using a tech\u00adnique that resembles \nour compatible metadata representa\u00adtion. However, CCured s representation handles di.erent kinds of metadata \nfor di.erent pointer kinds, requires less overhead, and allows run-time checking to be done in the same \nprocessor and address space as the main program. Fur\u00adthermore, in CCured it is possible for both the \ncompatible representation and the more e.cient incompatible represen\u00adtation to coexist in a given program. \nThe pointer kind quali.ers used in CCured are a spe\u00adcial case of type quali.ers [7]. The CCured inference \nal\u00adgorithm bears some resemblance to Henglein s inference al\u00adgorithm [9], but we also consider physical \nsubtyping, pointer arithmetic, updates and multiple pointer kinds. Henglein s algorithm has the nice \nfeature that it does not require any type information to be present in the program. However, we believe \nthat his algorithm does not extend to the more complexlanguage we consider here and also that existing \nC types contain valuable information that should be used to make inference both simpler and more predictable. \nAn entire body of research [4, 9, 13, 21, 25, 28] examines thenotion of a Dynamictypewhose values are \n(type, ptr) packages. Such a value can only be used by .rst extracting and checking the type. In particular, \none can only write val\u00adues that are consistent with the packaged type. Because the underlying value s \nstatic type is carried within the Dynamic package and checked at every use, there is no problem with \nDynamic aliases for statically-typed data. Abadi et al. [1] study the theoretical aspects of adding a \nDynamic type to the simply-typed .-calculus and discuss extensions to poly\u00admorphism and abstract data \ntypes. CCured s RTTI quali.er is similar, but we combine it with an inference algorithm based on physical \nsubtyping. 7. CONCLUSIONS CCured is a C program analysis and transformation sys\u00adtem that ensures memory \nsafety. It .rst analyzes the pro\u00adgram and attempts to .nd safe portions of it that adhere to a strong \ntype system. The remainder of the program is in\u00adstrumented with run-time checks. Parts of the program \nthat cannot be proved safe statically are often slow and incom\u00adpatible with external libraries. The techniques \nin this paper improve the usability of CCured by increasing the amount of the program that can be veri.ed \nstatically and the ease with which instrumented code can interface with the outside world. Physical subtyping \nprevents many type casts from re\u00adquiring the use of WILD pointers. We incorporate physical subtyping \nwith pointer arithmetic, allowing upcasts (which make up about 33% of all casts) to be statically veri.ed \nas safe. This approach improves the analysis portion of CCured. We describe a system for run-time type \ninformation that handles downcasts, and we provide an inference algorithm that uses physical subtyping \nto decide which pointers require this information. As a result, CCured can reason about the common idioms \nof parametric and subtype polymor\u00adphism. Using this mechanism improves the analysis portion of CCured \nand adds additional run-time checks. When run\u00adtime type information is combined with physical subtyping, \nmore than 99% of all program casts can be veri.ed without resorting to WILD pointers. CCured s pointers \nare often incompatible with external libraries. One way to bridge this gap is by writing wrap\u00adpers, and \nwe have extended CCured to include support for writing wrappers that ensure memory safety. In addition, \nwe presented a scheme for splitting CCured s metadata into separate data structures, allowing instrumented \nprograms to invoke external functions directly. This mechanism could also be useful for any run-time \ninstrumentation scheme that must maintain metadata with pointers while remaining com\u00adpatible with precompiled \nlibraries. We veri.ed the utility of these extensions while working on a number of real-world security-critical \nnetwork daemons, device drivers and web-server modules. Without these ex\u00adtensions, these programs would \nhave been quite di.cult to make safe using CCured. Equipped with the mechanisms described in this paper, \nwe can build tools, such as CCured, that are better able to analyze and instrument real-world software \nsystems, thereby improving their reliability and se\u00adcurity. Acknowledgments We thank Aman Bhargava, SP \nRahul, and Raymond To for their contributions to the CIL infrastructure. We also thank AlexAiken, Ras \nBodik, Je. Foster, and the anonymous re\u00adviewers for their helpful comments on this paper, and the members \nof the Open Source Quality group for their advice and assistance throughout the project.  8. REFERENCES \n[1] M. Abadi, L. Cardelli, B. Pierce, and G. Plotkin. Dynamic typing in a statically typed language. \nACM Transactions on Programming Languages and Systems, 13(2):237 268, April 1991. [2] T. M. Austin, S. \nE. Breach, and G. S. Sohi. E.cient detection of all pointer and array access errors. SIGPLAN Notices, \n29(6):290 301, June 1994. Proceedings of the ACM SIGPLAN 94 Conference on Programming Language Design \nand Implementation. [3] M. C. Carlisle. Olden: Parallelizing Programs with Dynamic Data Structures on \nDistributed-Memory Machines. PhD thesis, Princeton University Department of Computer Science, June 1996. \n[4] R. Cartwright and M. Fagan. Soft typing. In Proceedings of the 91 Conference on Programming Language \nDesign and Implementation, pages 278 292, 1991. [5] CERT Coordination Center. Cert advisory ca-2003-12: \nBu.er over.ow in sendmail. http://www.cert.org/advisories/CA-2003-12.html, 2003. [6] S. Chandra and T. \nReps. Physical type checking for C. In Proceedings of the ACM SIGPLAN-SIGSOFT Workshop on Program Analysis \nfor Software Tools and Engineering, volume 24.5 of Software Engeneering Notes (SEN), pages 66 75. ACM \nPress, Sept. 6 1999. [7] J.S.Foster, M. F\u00a8ahndrich, and A. Aiken. A theory of type quali.ers. In Proceedings \nof the ACM SIGPLAN 99 Conference on Programming Language Design and Implementation, pages 192 203, Atlanta, \nGeorgia, May 1 4, 1999. [8] R. Hastings and B. Joyce. Purify: Fast detection of memory leaks and access \nerrors. In Proceedings of the Usenix Winter 1992 Technical Conference, pages 125 138, Berkeley, CA, USA, \nJan. 1991. UsenixAssociation. [9] F. Henglein. Global tagging optimization by type inference. In Proceedings \nof the 1992 ACM Conference on LISP and Functional Programming, pages 205 215, 1992. [10] T. Jim, G. Morrisett, \nD. Grossman, M. Hicks, J. Cheney, and Y. Wang. Cyclone: A safe dialect of C. In USENIX Annual Technical \nConference. Monetery, CA, June 2002.  [11] R. W. M. Jones and P. H. J. Kelly. Backwards-compatible bounds \nchecking for arrays and pointers in C programs. AADEBUG, 1997. [12] S. Kaufer, R. Lopez, and S. Pratap. \nSaber-C: an interpreter-based programming environment for the C language. In Proceedings of the Summer \nUsenix Conference, pages 161 171, 1988. [13] A. Kind and H. Friedrich. A practical approach to type inference \nfor EuLisp. Lisp and Symbolic Computation, 6(1/2):159 176, 1993. [14] A. Loginov, S. Yong, S. Horwitz, \nand T. Reps. Debugging via run-time type checking. In Proceedings of FASE 2001: Fundamental Approaches \nto Software Engineering, Apr. 2001. [15] G. C. Necula, S. McPeak, and W. Weimer. CCured: Type-safe retro.tting \nof legacy code. In The 29th Annual ACM Symposium on Principles of Programming Languages, pages 128 139. \nACM, Jan. 2002. [16] H. Patil and C. N. Fischer. E.cient run-time monitoring using shadow processing. \nIn Automated and Algorithmic Debugging, pages 119 132, 1995. [17] H. Patil and C. N. Fischer. Low-cost, \nconcurrent checking of pointer and array accesses in C programs. Software Practice and Experience, 27(1):87 \n110, Jan. 1997. [18] G. Ramalingam, J. Field, and F. Tip. Aggregate structure identi.cation and its application \nto program analysis. In Symposium on Principles of Programming Languages, pages 119 132, Jan. 1999. [19] \nSecuriTeam.com. PHP3 / PHP4 format string vulnerability. http://www.securiteam.com/ securitynews/6O00T0K03O.html, \nDec. 2000. [20] J. Seward. Valgrind, an open-source memory debugger for x86-GNU/Linux. Technical report, \nhttp://developer.kde.org/ sewardj/, 2003. [21] M. Shields, T. Sheard, and S. L. P. Jones. Dynamic typing \nas staged type inference. In Symposium on Principles of Programming Languages, pages 289 302, 1998. [22] \nM. Si., S. Chandra, T. Ball, K. Kunchithapadam, and  T. Reps. Coping with type casts in C. In 1999 ACM \nFoundations on Software Engineering Conference (LNCS 1687), volume 1687 of Lecture Notes in Computer \nScience, pages 180 198. Springer-Verlag / ACM Press, September 1999.  [23] G. Smith and D. Volpano. \nA sound polymorphic type system for a dialect of C. Science of Computer Programming, 32(1 3):49 72, 1998. \n[24] SPEC 95. Standard Performance Evaluation Corportation Benchmarks. http://www.spec.org/osg/cpu95/CINT95, \nJuly 1995. [25] S. Thatte. Quasi-static typing. In Conference record of the 17th ACM Symposium on Principles \nof Programming Languages (POPL), pages 367 381, 1990. [26] D. Wagner, J. Foster, E. Brewer, and A. Aiken. \nA .rst step toward automated detection of bu.er overrun vulnerabilities. In Network Distributed Systems \nSecurity Symposium, pages 1 15, Feb. 2000. [27] W. Weimer. The CCured type system and type inference. \nTechnical Report UCB-CS, University of California, Berkeley. http://www.cs.berkeley.edu/ weimer/ TheCCuredTypeSystem.ps, \n2002. [28] A. Wright and R. Cartwright. A practical soft type system for Scheme. ACM Transactions on \nProgramming Languages and Systems, 1997. APPENDIX  A. CCURED RUN-TIME CHECKS This appendixprovides concrete \ndetails about CCured run-time invariants and checks. In order to describe the CCured typing rules and \nthe run-time checks we shall use a simpli.ed presentation of C. Since the array indexing op\u00ad eration \ne1[e2] is just syntactic sugar for *(e1 + e2), we will only consider pointer arithmetic. Comparison operations \non pointer values are performed after converting the pointers to integers. We shall not describe the \noperations on integers since they are not interesting for memory safety. CCured run-time invariants are \nshown in Figure 10. If the static type of a value is t * SAFE, that value is either null or a valid pointer \nto a t in memory. If the static type of a value is t * SEQ, that value is either null or its b and e \nmetadata .elds delimit a valid array of t sin memory. In the SAFE and SEQ cases the type of the referent \nis known statically. If the static type of a value is t * WILD,wemust check the type at run time. We \nmaintain the invariant that either the value is null or it has a valid b .eld that points to the beginning \nof a WILD object. The associated tags give the type of the last value stored in that object. As a special \ncase of SEQ and WILD pointers, if the base .eld is null then the pointer actually represents an integer \nthat was cast to a pointer. The CCured typing rules and the run-time checks are shown in Figure 11. \nFor each form of expression shown in the left column of the .gure there are a number of alter\u00adnative \ntyping premises (shown in the middle column) under which the expression is well typed. The right column \nshows what run-time checks CCured adds in each case and how it translates the left-column expression. \nIn the case of memory reads we .rst check whether the pointer is null.In the case of SEQ and WILD pointers \nthis check also veri.es that the pointer was not obtained by cast\u00ading from an integer. For SEQ and WILD \npointers we perform a bounds check, using the notation len(x.b) to refer to the length of a dynamically-typed \narea pointed to by the base .eld of x. Finally, when reading a pointer through a WILD pointer we must \ncheck the tag bits to verify that the stored pointer has not been altered. The notation tag(b, p) denotes \nthe tag corresponding to the word pointed to by p inside the dynamically-typed area pointed to by b. \nFor memory writes (not shown), we perform the same checks as for reads, and additionally, we check that \nwe do not store a stack pointer. This restriction is a conservative approximation that prevents the program \nfrom dereferenc\u00ading the address of a local variable after its parent function has returned. When writing \ninto dynamically typed areas, the tag bits must be updated to re.ect the type of what is written; when \na pointer is written into such an area we set the bits corresponding to the stored base and pointer .elds \nto one and zero respectively. When an integer is written, we clear the tag bit for the written word, \nthus invalidating any previously stored base .eld. This scheme maintains the invariant that the tag bit \nfor a word is set to one if and only if the word contains a valid base pointer. The .rst three lines \nin the Type Casts section of Fig\u00adure 11 show that any kind of pointer can be cast to an in\u00adteger, but \nthe reverse direction prevents integers (except 0) from being cast to SAFE pointers. Note that even though \nwe can disguise an integer as a SEQ or a WILD pointer, the base .eld will be null, meaning that we cannot \nuse the pointer in a memory operation. The necessary restrictions for han\u00addling arithmetic and physical \nsubtyping are shown in the last three lines under Type Casts. Finally, true pointer arithmetic is allowed \nonly for SEQ and WILD pointers. Accessing a structure .eld can be viewed as a combination of casts and \npointer arithmetic, however. CCured supports the creation of pointers to substructures starting from \na pointer to the host structure. The represen\u00adtative case of x . f2 is shown. If x is a SAFE pointer \nto a structure, then it must be non-null;otherwise, we would obtain a SAFE pointer that is neither valid \nnor null.In the case of a SEQ pointer we must .rst convert the pointer to a SAFE one (hence the bounds \ncheck) and then we can obtain a SAFE pointer to the second .eld. Pointer Quali.er Representation Invariants \n x : t *SAFE struct{t *p; } x.p .= null =. IsAValid(x.p, t ) x : t *SEQ struct{t *p, *b, *e; } x.b =.null \n. x.b =x.p =x.e -sizeof(t )=. IsAValid(x.p, t ) x : t *WILD struct{t *p, *b; } x.b =.null . x.b =x.p \n=x.b + len(x.b) -4=. IsAValid(x.p, int)  x.b .. = null x.b =x.p =x.b + len(x.b) -8 . tag(x.b, x.p)=1 \n. tag(x.b, x.p +4)=0 =..t . .IsAValid(x.p, t . *WILD) Figure 10: CCured pointer quali.er invariants. \nWhenever a value x of the given type exists in a well-typed CCured program, the associated invariant \nwill hold for that value. IsAValid(x, t ) means that x is a valid address in memory and that the last \nvalue stored there is a physical subtype of t (see Section 3.1). Expression Typing Premises Memory Reads \n*xx : t *SAFE *xx : t *SEQ *xx : int *WILD *xx : t *WILD *WILD Type Casts (int)xx : t *SAFE (int)xx \n: t *SEQ (int)xx : t *WILD (t . *SAFE)xx =0 (t . *SEQ)xx : int (t . *WILD)xx : int (t . *WILD)xx : t \n*WILD (t . *SAFE)xx : t *SAFE,t .t . (t . *SEQ)xx : t *SEQ,t [n] t [n ] (t . *SAFE)xx : t *SEQ,t [n] \n.t . (t . *SEQ)xx : t *SAFE,t [n ] .t Miscellaneous x1 + x2 x1 : t *SEQ,x2 : int x1 + x2 x1 : t *WILD,x2 \n: int &#38;(x .f2): t2 *SAFE x : struct{t1f1; t2f2; }*SAFE &#38;(x .f2): t2 *SAFE x : struct{t1f1; t2f2; \n}*SEQ &#38;(x .f2): t2 *WILD x : struct{t1f1; t2f2; }*WILD Run-time checks and translation assert(x.p \n.*(x.p) = null); assert(x.b .assert(x.b =x.p =x.e -sizeof(t )); (x.p) = null); *assert(x.b .assert(x.b \n=x.p =x.b + len(x.b) -4); (x.p) = null); *assert(x.b .assert(x.b =x.p =x.b + len(x.b) -8); = null); assert(tag(x.b, \nx.p)==1); assert(tag(x.b, x.p +4) == 0); *(x.p) x.p x.p x.p  {p = null} {b = null,p = x, e = null} \n{b = null,p = x} x x x assert(x.p = null || x.b =.null); assert(x.b =x.p =x.e -sizeof(t )); x.p {b = \nx.p, p = x.p, e = x.p + sizeof(t )} {b = x1.b, p = x1.p + x2 *sizeof(t ),e = x1.e} {b = x1.b, p = x1.p \n+ x2 *sizeof(t )} assert(x.p . = null); &#38;(x.p .f2) assert(x.b . = null); assert(x.b =x.p =x.e -sizeof(t1) \n-sizeof(t2)); &#38;(x.p .f2) {b = x.b, p =&#38;(x.p .f2)} Figure 11: CCured typing rules for reads, casts, \narithmetic and aggregate accesses. For each kind of expression shown in the left column, the middle column \nshows the typing premises that make the expression well-typed in CCured, and the right column shows the \ninstrumentation that is added. For simplicity word size is assumed to be 4. All arithmetic in the right \ncolumn is integer arithmetic.  \n\t\t\t", "proc_id": "781131", "abstract": "CCured is a program transformation system that adds memory safety guarantees to C programs by verifying statically that memory errors cannot occur and by inserting run-time checks where static verification is insufficient.This paper addresses major usability issues in a previous version of CCured, in which many type casts required the use of pointers whose representation was expensive and incompatible with precompiled libraries. We have extended the CCured type inference algorithm to recognize and verify statically a large number of type casts; this goal is achieved by using physical subtyping and pointers with run-time type information to allow parametric and subtype polymorphism. In addition, we present a new instrumentation scheme that splits CCured's metadata into a separate data structure whose shape mirrors that of the original user data. This scheme allows instrumented programs to invoke external functions directly on the program's data without the use of a wrapper function.With these extensions we were able to use CCured on real-world security-critical network daemons and to produce instrumented versions without memory-safety vulnerabilities.", "authors": [{"name": "Jeremy Condit", "author_profile_id": "81100200251", "affiliation": "University of California, Berkeley", "person_id": "P517412", "email_address": "", "orcid_id": ""}, {"name": "Matthew Harren", "author_profile_id": "81100370412", "affiliation": "University of California, Berkeley", "person_id": "P479922", "email_address": "", "orcid_id": ""}, {"name": "Scott McPeak", "author_profile_id": "81100329375", "affiliation": "University of California, Berkeley", "person_id": "P343133", "email_address": "", "orcid_id": ""}, {"name": "George C. Necula", "author_profile_id": "81100295630", "affiliation": "University of California, Berkeley", "person_id": "PP14109324", "email_address": "", "orcid_id": ""}, {"name": "Westley Weimer", "author_profile_id": "81100631608", "affiliation": "University of California, Berkeley", "person_id": "PP18002460", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/781131.781157", "year": "2003", "article_id": "781157", "conference": "PLDI", "title": "CCured in the real world", "url": "http://dl.acm.org/citation.cfm?id=781157"}