{"article_publication_date": "05-09-2003", "fulltext": "\n A Type and Effect System for Atomicity Cormac Flanagan Shaz Qadeer HP Systems Research Center Microsoft \nResearch 1501 Page Mill Road One Microsoft Way Palo Alto, CA 94304 Redmond, WA 98052 ABSTRACT Ensuring \nthe correctness of multithreaded programs is dif\u00ad.cult, due to the potential for unexpected and nondeter\u00administic \ninteractions between threads. Previous work ad\u00addressed this problem by devising tools for detecting race \nconditions, a situation where two threads simultaneously access the same data variable, and at least \none of the ac\u00adcesses is a write. However, verifying the absence of such simultaneous-access race conditions \nis neither necessary nor su.cient to ensure the absence of errors due to unexpected thread interactions. \nWe propose that a stronger non-interference property is required, namely atomicity. Atomic methods can \nbe as\u00adsumed to execute serially, without interleaved steps of other threads. Thus, atomic methods are \namenable to sequen\u00adtial reasoning techniques, which signi.cantly simpli.es both formal and informal reasoning \nabout program correctness. This paper presents a type system for specifying and ver\u00adifying the atomicity \nof methods in multithreaded Java pro\u00adgrams. The atomic type system is a synthesis of Lipton s theory \nof reduction and type systems for race detection. We have implemented this atomic type system for Java \nand used it to check a variety of standard Java library classes. The type checker uncovered subtle atomicity \nviolations in classes such as java.lang.String and java.lang.String-Buffer that cause crashes under certain \nthread interleav\u00adings.  Categories and Subject Descriptors D.1.3 Concurrent Programming, parallel programming; \nD.2.4 Software/Program Veri.cation  General terms Reliability, Security, Languages, Veri.cation  Keywords \nMultithreading, race conditions, static checking, atomicity Permission to make digital or hard copies \nof all or part of this work for personal or classroom use is granted without fee provided that copies \nare not made or distributed for pro.t or commercial advantage and that copies 1. INTRODUCTION Ensuring \nthe correctness of multithreaded programs is dif\u00ad.cult, due to the potential for unexpected and nondeter\u00administic \ninteractions between threads. Previous work has addressed this problem by devising type systems [18, \n17] and other static [19] and dynamic [35] checking tools for de\u00adtecting race conditions. A race condition \noccurs when two threads simultaneously access the same data variable, and at least one of the accesses \nis a write. Unfortunately, verifying the absence of such simultaneous\u00adaccess race conditions is insu.cient \nto ensure the absence of errors due to unexpected thread interactions. To illustrate this idea, consider \nthe following method, in which the shared variable x is protected by the lock l: int x; // shared var \nguarded by lock l void m() { int t; synchronized (l) { t = x; } t++; synchronized (l) { x = t; } } This \nmethod does not su.er from race conditions, a prop\u00aderty that can be easily veri.ed with existing tools \nsuch as rccjava [18]. However, the method may still not have the expected e.ect of simply incrementing \nx that it would in a sequential setting. In particular, if n calls to the method are made concurrently, \nthe overall e.ect may be to increment x by any number between 1 and n. We propose that a stronger non-interference \nproperty is required, namely atomicity. If a method is atomic, then any interaction between that method \nand steps of other threads is guaranteed to be benign, in the sense that these interac\u00adtions do not change \nthe program s overall behavior. Thus, having veri.ed the atomicity of a method, we can subse\u00adquently \nspecify and verify that method using standard se\u00adquential reasoning techniques, even though the scheduler \nis free to interleave threads at instruction-level granularity. We believe that a fundamental correctness \nproperty com\u00admon to many interfaces in multithreaded programs is that the methods of these interfaces \nare intended to be atomic. Programmers have precise expectations regarding the meth\u00adods that should be \natomic, as illustrated by the documen\u00adtation for the class java.lang.StringBuffer in JDK1.4: bear this \nnotice and the full citation on the .rst page. To copy otherwise, to String bu.ers are safe for use by \nmultiple threads. republish, to post on servers or to redistribute to lists, requires prior speci.c The \nmethods are synchronized where necessary permission and/or a fee. so that all the operations on any particular \nin- PLDI 03, June 9 11, 2003, San Diego, California, USA. Copyright 2003 ACM 1-58113-662-5/03/0006 ...$5.00. \nstance behave as if they occur in some serial order that is consistent with the order of the method calls \nmade by each of the individual threads in\u00advolved. A methodology that supports concise speci.cation and \nef\u00ad.cient checking of such expectations of atomicity would be invaluable to both the implementor and \nthe client of such an interface. Unfortunately, existing checking methodologies are unable to either \nformally specify or verify such expecta\u00adtions. Although the notions of atomicity and race-freedom are \nclosely related, race-freedom is not su.cient to prove atomicity, as shown in the example above; it is \nalso not nec\u00adessary, as we show in Section 1.1. In this paper, we present a type system for specifying \nand checking atomicity properties of methods in multithreaded programs. Methods can be annotated with \nthe keyword atomic. The type system checks that for any (arbitrarily\u00adinterleaved) execution, there is \na corresponding serial exe\u00adcution with equivalent behavior in which the instructions of the atomic method \nare not interleaved with instructions from other threads. To evaluate the utility of this atomic type \nsystem, we implemented an atomic type checker for the full Java pro\u00adgramming language [23] and tested \nit on a variety of widely\u00adused Java library classes. We discovered a number of pre\u00adviously unknown defects, \nincluding subtle atomicity viola\u00adtions in java.lang.String and java.lang.StringBuffer that cause crashes \nunder certain interleavings. These errors are not due to race conditions, and would be missed by a race \ncondition checker. 1.1 The need for atomicity As an illustration of the problems that arise in multi\u00adthreaded \nprogramming, consider the program shown below. This program allocates a new bank account, and makes two \ndeposits into the account in parallel. This program is writ\u00adten in the language ConcurrentJava, which \nis essentially a multithreaded subset of Java extended with let and fork constructs. class Account { \nint balance = 0; int deposit1(int x) { this.balance = this.balance + x; } } let Account a = new Account \nin { fork {a.deposit1(10)}; fork {a.deposit1(10)} } The program may exhibit unexpected behavior. In par\u00adticular, \nif the two calls to deposit1 are interleaved, the .nal value of balance may re.ect only one of the two \ndeposits made to the account, which is clearly not the intended be\u00adhavior of the program. That is, the \nprogram contains a race condition: two threads attempt to manipulate the .eld deposit1 simultaneously, \nwith incorrect results. We can .x this error by protecting the .eld balance by the implicit lock of the \naccount object and only accessing or updating balance when that lock is held: int deposit2(int x) { synchronized \n(this) { this.balance = this.balance + x; } } The race condition checker rccjava [18] can detect the \nrace condition in the original bank account implementation and can verify that the modi.ed implementation \nis race-free. In general, however, the absence of race conditions does not imply the absence of errors \ndue to thread interactions. To illustrate this point, we extend the account implementa\u00adtion with two \nadditional methods readBalance1 to return the current account balance and withdraw1 to take money out \nof the account. int readBalance1() { void withdraw1(int amt) { int t; int b = readBalance1(); synchronize \n(this) { synchronize (this) { t = balance; balance = b -amt; }; } return t; } } Even though there are \nno races in either method, the method withdraw1 is not atomic and may not behave correctly. For example, \nconsider two concurrent transactions on the ac\u00adcount a withdrawal and a deposit issued at a time when \nthe account balance is 10. fork { withdraw1(10); }; // Thread 1 fork { deposit2(10); }; // Thread 2 We \nwould expect an account balance of 10 after the pro\u00adgram terminates, but certain executions violate this \nexpec\u00adtation. Suppose the scheduler .rst performs the call to readBalance1 in Thread 1 which returns \n10. The sched\u00aduler then switches to Thread 2 and completes the execution of deposit2 ending with balance \n= 20. Finally, the sched\u00aduler switches back to Thread 1 and completes the execution setting balance to \n0. Thus, even though there are no races in this program, unexpected interaction between the threads canleadto \nincorrect behavior. The account interface provided by the methods deposit2, readBalance1,and withdraw1 \nis intended to be atomic, a fundamental property common to many interfaces in multi\u00adthreaded programs. \nA programmer using an atomic inter\u00adface should not have to worry about unexpected interactions between \nconcurrent invocations of the methods of the inter\u00adface. Our type system provides the means to specify \nand verify such atomicity properties, thus catching errors such as the one in withdraw1 above. Having \ncaught the error with our type system, we .x the problem in withdraw1 as shown below. At the same time, \nsince readBalance1 performs a single read of a single-word .eld, its synchronized statement is redundant, \nand we re\u00admove it. int readBalance2() { void withdraw2(int amt) { return balance; synchronize (this) \n{ } balance = balance - amt; } } A race condition checker will report a race in readBalance2. However, \nthis warning is a false alarm as the race condition is benign. Despite the presence of benign race conditions, \nour type system can still verify that the methods deposit2, readBalance2,and withdraw2 are atomic.  \n1.2 An overview of types for atomicity As we have seen, although the notions of atomicity and race-freedom \nare closely related, and both are commonly achieved using locks, race-freedom is neither necessary nor \nsu.cient for ensuring atomicity. We now present an overview of our type system for check\u00ading atomicity. \nWe allow any method to be annotated with keyword atomic, and use the theory of right and left movers, \n.rst proposed by Lipton [28], to prove the correctness of atomic annotations. An action a is a right \nmover if for any execution where the action a performed by one thread is immediately followed by an action \nb of a di.erent thread, the actions a and b can be swapped without changing the resulting state, as shown \nbelow. Similarly, an action b is a left mover if whenever b immediately follows an action a of a di.erent \nthread, the actions a and b can be swapped, again without changing the resulting state. absss 1 23 ba \nss s 1 23 The type system classi.es actions as left or right movers as follows. Consider an execution \nin which an acquire operation a on some lock is immediately followed by an action b of a second thread. \nSince the lock is already held by the .rst thread, the action b neither acquires nor releases the lock, \nand hence the acquire operation can be moved to the right of b without changing the resulting state. \nThus the type system classi.es each lock acquire operation as a right mover. Similarly, consider an action \na of one thread that is im\u00admediately followed by a lock release operation b by a second thread. During \na, the second thread holds the lock, and a can neither acquire nor release the lock. Hence the lock re\u00adlease \noperation can be moved to the left of a without chang\u00ading the resulting state, and thus the type system \nclassi.es lock release operations as left movers. Finally, consider an access (read or write) to a shared \nvariable declared with the guard annotation guarded by l. This annotation states that the lock denoted \nby expression l must be held when the variable is accessed. Since our type system enfores this access \nrestriction, no two threads may access the .eld at the same time, and therefore every access to this \n.eld is both a right mover and a left mover. To illustrate how the theory of movers enables us to verify \natomicity, consider a method that (1) acquires a lock (the operation acq in the .rst execution trace \nin the diagram below), (2) reads a variable x protected by that lock into a local variable t (t=x), (3) \nupdates that variable (x=t+1), and then (4) releases the lock (rel). Suppose that the actions of this \nmethod are interleaved with arbitrary actions E1, E2, E3 of other threads. Because the acquire operation \nis a right mover and the write and release operations are left movers, there exists an equivalent serial \nexecution where the operations of the method are not interleaved with operations of other threads, as \nillustrated by the following diagram. Thus the method is atomic. acq E1 t=x E2 x = t+1 E3 rel s3 s4s2 \ns5 s6 s7s1  s8  More generally, suppose a method contains a sequence of right movers followed by a \nsingle atomic action followed by a sequence of left movers. Then an execution where this method has been \nfully executed can be reduced to another execution with the same resulting state where the method is \nexecuted serially without any interleaved actions by other threads. Therefore, an atomic annotation on \nsuch a method is valid. The remainder of the paper describes our type system in more detail. The following \nsection presents a multithreaded subset of Java, and Section 3 formalizes the atomic type system for \nthis Java subset. Section 4 describes the imple\u00admentation of the atomic type system for the Java program\u00adming \nlanguage [23]; the application of this type checker to a number of widely-used classes; and reports on \natomicity violations caught using this checker. Section 5 describes re\u00adlated work, and we conclude with \nSection 6. Appendix A contains the full set of type rules for our system.  2. CONCURRENT JAVA This \nsection presents ConcurrentJava [18], a multi\u00adthreaded subset of Java [23] that we use to formalize our \ntype system. ConcurrentJava supports multithreaded programs by including the operation fork e which spawns \na new thread for the evaluation of e. This evaluation is per\u00adformed only for its e.ect; the result of \ne is never used. Locks are provided for thread synchronization. As in Java, each object has an associated \nlock that has two states, locked and unlocked, and is initially unlocked. The expression synchronized \ne1 e2 is evaluated in a manner similar to Java s synchronized statement: the subexpression e1 is eval\u00aduated \n.rst, and should yield an object, whose lock is then acquired; the subexpression e2 is then evaluated; \nand .nally the lock is released. The result of e2 is returned as the result of the synchronized expression. \nWhile evaluating e2, the current thread is said to hold the lock. Any other thread that attempts to acquire \nthe lock blocks until the lock is re\u00adleased. A forked thread does not inherit locks held by its parent \nthread. The syntax of the synchronized and fork expressions and the rest of ConcurrentJava is shown in \nFigure 1. A pro\u00adgram is a sequence of class de.nitions together with an ini\u00adtial expression. Each class \nde.nition associates a class name with a class body consisting of a super class, a sequence of .eld declarations, \nand a sequence of method declarations. A .eld declaration includes an initialization expression and an \noptional final modi.er; if this modi.er is present, then the .eld cannot be updated after initialization. \nWe use [X]opt in grammars to denote either X or the empty string. A method declaration consists of the \nmethod name, its return type, number and types of its arguments, and an expression for the method body. \nTypes include class types, integers, and long integers. Class types include class names intro\u00adduced by \nthe program, as well as the prede.ned class Object, which serves as the root of the class hierarchy. \nExpressions include the typical operations for object allocation, .eld ac\u00adcess and update, method invocation, \nvariable binding and reference, conditionals, and loops, as well as the concurrency primitives. Variables \nare bound by let-expressions, formal parameter lists, and the special variable this is implicitly bound \nby a class declaration and is in scope within the body rel E1 E2E3  s3 s4  s s1 7 P ::= defn * e (program) \ndefn ::= class cn body (class decl) body ::= extends c { .eld * meth * } (class body) .eld ::= [final]opt \nt fd = e (.eld decl) meth ::= t mn(arg * ) { e } (method decl) arg ::= t x (variable decl) s, t ::= \nc | int | long (type) c ::= cn | Object (class type) e ::= new c (allocate) | x (variable) | e.fd (.eld \naccess) | e.fd = e (.eld update) | e.mn(e * ) (method call) | let arg = e in e (variable binding) | while \nee (iteration) | if eee (conditional) | synchronized ee (synchronization) | fork e (fork) cn . class \nnames fd . .eld names mn . method names x, y . variable names Figure 1: ConcurrentJava. We present example \nprograms in an extended language with integer and boolean constants and operations, and the constant \nnull. The sequential composition e1; e2 abbrevi\u00adates let x = e1 in e2,where x does not occur free in \ne2;the ' expression e[x := e] denotes the capture-free substitution of e' for x in e. We sometimes enclose \nexpressions in parenthe\u00adsesor bracesfor clarityand use return e to emphasize that the result of e is \nthe return value of the current method.  3. TYPES FOR ATOMICITY 3.1 Basic Atomicities Like conventional \ntype systems, our type system assigns to each expression a type characterizing the value of that expression. \nIn addition, our type system also assigns to each expression an atomicity characterizing the behavior \n[39] or e.ect of that expression. The set of atomicities includes the following basic atomicities: const: \nAn expression is assigned the atomicity const if its evaluation does not depend on or change any mu\u00adtable \nstate. Hence the repeated evaluation of a const expression with a given environment always yields the \nsame result.  mover: An expression is assigned the atomicity mover if it both left and right commutes \nwith operations of other threads. For example, an access to a .eld f de\u00adclared as guarded by l is a mover \nif the access is per\u00adformed with the lock l held. Clearly, this access can\u00adnot happen concurrently with \nanother access to f by a di.erent thread if that thread also accesses f with the lock l held. Therefore, \nthis access both left and right commutes with any concurrent operation by another  1 thread. 1 Since \nJava does not provide separate lock acquire and re\u00ad atomic: An expression is assigned the atomicity \natomic if it is a single atomic action or if it can be considered to execute without interleaved actions \nof other threads.  cmpd: An expression is assigned the atomicity cmpd if none of the preceeding atomicities \napply.  error: An expression is assigned the atomicity error if it violates the locking discipline speci.ed \nby the type annotations.  If the basic atomicity a re.ects the behavior of an expres\u00adsion e, then the \niterative closure a * re.ects the behavior of executing e an arbitrary number of times, and is de.ned \nas follows: * const = const * mover = mover * atomic = cmpd * cmpd = cmpd * error = error Similarly, \nif basic atomicities a1 and a2 re.ect the behav\u00adior of e1 and e2 respectively, then the sequential composition \na1; a2 re.ects the behavior of e1; e2, and is de.ned by the following table. ; const mover atomic cmpd \nerror const const mover atomic cmpd error mover mover mover atomic cmpd error atomic atomic atomic cmpd \ncmpd error cmpd cmpd cmpd cmpd cmpd error error error error error error error Basic atomicities are \nordered by the subatomicity relation: const . mover . atomic . cmpd . error Let U denote the join operator \nbased on this subatomicity ordering. If basic atomicities a1 and a2 re.ect the behavior of e1 and e2 \nrespectively, then the nondeterministic choice between executing either e1 or e2 has atomicity a1 U a2. \n 3.2 Conditional Atomicities In some cases, the atomicity of an expression depends on the locks held \nby the thread evaluating that expression. For example, an access to a .eld declared as guarded by l has \natomicity mover if the lock l is held by the current thread, and has atomicity error otherwise. We assign \nsuch an access the conditional atomicity: l ? mover : error A conditional atomicity l ? a : b is equivalent \nto atomicity a if the lock l is currently held, and is equivalent to atomic\u00adity b if the lock is not \nheld. Conditional atomicities provide a more precise characterization of the behavior of synchro\u00adnized \nstatements and methods. We use l ? a to abbreviate l ? a : error. The set of atomicities thus includes \nboth the basic atomicities described above and conditional atomici\u00adties: a, b ::= a | l ? a : b a, \u00df \n::= const | mover | atomic | cmpd | error l ::= e lease operations, we do not need separate left movers \nand right movers, since each expression is either a mover in both directions or not at all. Each atomicity \na is equivalent to a function [ a]] from the set of locks currently held to a basic atomicity: [[a]](ls)= \na . [[a1]](ls)if l .ls [[l? a1 : a2]](ls)= [[a2]](ls)if l .ls For example, the conditional atomicity \na: l1 ? mover :(l2 ? atomic : error) is equivalent to the function: 8 < mover if l1 .ls [[a]](ls)= atomic \nif l1 .ls, l2 .ls : error if l1 .ls, l2 .ls We extend the calculation of iterative closure, sequential \ncomposition, and join operations to conditional atomicities as follows: (l? a: b) * = l? a * : b * (l? \na1 : a2); b = l?(a1; b):(a2; b) a;(l? b1 : b2)= l?(a; b1):(a; b2) (l? a1 : a2) Ub = l?(a1 Ub):(a2 Ub) \naU(l? a1 : a2)= l?(aUa1):(aUa2) We also extend the calculation of subatomicity ordering to conditional \natomicities. To decide a cb, we use an auxiliary h relation cn,where h is a set of locks that is known \nto be held by the current thread, and n is a set of locks that is known to be not held by the current \nthread. Intuitively, the condition ach b holds if and only if [ a]](ls) c[[b]](ls)holds n for every lockset \nls that contains h and is disjoint from n. \u00d8 h We de.ne a cb to be a cb and check acn b recursively \u00d8 \nas follows: a \u00df a h \u00df n . n . a1 h.{l} (l n b)(l . h . a2 h b) n.{l} l ?a1 :a2 h b n . n . a h.{l} (l \nn b1)(l . h . a h b2) n.{l} a h l ?b1 :b2 n The following theorem claims that the iterative closure, \nsequential composition, and join operations on conditional atomicities are the pointwise extensions of \nthe corresponding operations on basic atomicities. Similarly, the subatomicity ordering on conditional \natomicities is the pointwise exten\u00adsion of the subatomicity ordering on basic atomicities. Theorem 1. \nFor all atomicities a and b, the following statements are true. 1. For all locksets ls, [[a * ]](ls)= \n([ a]](ls)) * [[a; b]](ls)= [ a]](ls); [ b]](ls) [[aUb]](ls)= [ a]](ls) U[[b]](ls) 2. acb..ls. [[a]](ls) \nc[[b]](ls) The relation c is an equivalence relation with minimum element const and maximum element error. \nAtomicities a and b are equivalent, written a =b,if a cb and b ca.If a=b,then .ls.[[a]](ls)= [ b]](ls). \nThe equivalence relation = identi.es atomicities that are syntactically di.erent but se\u00admantically equal. \nFor example, (l? mover : mover) =mover. The following theorem states interesting properties of atom\u00adicities. \nTheorem 2. For all atomicities a, b,and c, the following statements are true. 1. Iterative closure is \nmonotonic and idempotent. a c a * * ) * (a = a * 2. Sequential composition is monotonic and associative \nand const is a left and right identity of this operation. a c a; b (a; b); c = a;(b; c) const; a = a \na; const = a 3. Sequential composition and iterative closure distribute over the join operation. a;(bUc) \n= a; bUa; c (aUb); c = a; cUb; c (aUb) * = a * Ub * 3.3 The Type System The atomicity of a .eld access \ndepends on the synchro\u00adnization discipline used for that .eld. Our type system relies on the programmer \nto explicate this synchronization disci\u00adpline as a type annotations. The annotation guarded by l expresses \nthe common synchronization discipline that the lock expression l must be held whenever the .eld is read \nor written. The annotation write guarded by l states that the lock expression l must be held for writes, \nbut not necessarily for reads. If neither annotation is present, the .eld can be read or written at any \ntime. The soundness of the type system requires that each lock expression ldenotes a .xed lock throughout \nthe execution of the program. We satisfy this requirement by ensuring that each lock expression has atomicity \nconst; such expressions include references to immutable variables2, accesses to .nal .elds of const expressions, \nand calls to const methods with const arguments. Each method declaration includes a speci.cation of the \nmethod s atomicity. The type system checks that the body of the method has this atomicity, and uses this \natomicity at call sites of the method. We extend the syntax of .eld and method declarations to include \nthese type annotations, and refer to the extended language as AtomicJava. .eld ::= [final]opt t fd [g]opt \n= e (.elds) meth ::= at mn(arg * ) {e } (methods) g ::= guarded by l |write guarded by l (guards) l ::= \ne (lock expression) A method declaration may also contain the type annotation requires l1 ,...,ln stating \nthat the locks l1 ,...,ln should be held at any call site of the method. A method declaration with a \nrequires clauses, such as: at mn(arg * ) requires l1 ,...,ln {e } 2All variables are immutable in AtomicJava, \nbut only .nal variables are in Java. is an abbreviation for the declaration: (l1 ? l2 ? ... ? ln ? a) \nt mn(arg * ) { e } where the conditional atomicity (l1 ? l2 ? ... ? ln ? a)is equiv\u00adalent to a if the \nlocks l1 ,..., ln are all held, and equivalent to error otherwise. The core of our type system is a set \nof rules for reasoning about the type judgment P ; E . e : t &#38; a. Here, P (the program being checked) \nis included in the judg\u00adment to provide information about class de.nitions in the program; E is an environment \nproviding types for the free variables of e; t is the type of e,and a is the atomicity of e. The rule \n[exp while] for while e1 e2 determines the atom\u00adicities a1 and a2 of e1 and e2, and states that the atomicity \nof the while loop is a1;(a2; a1) * , re.ecting the iterative nature of the while loop. [exp while] P;E \n. e1 : int &#38; a1 P;E . e2 :t &#38; a2 P;E . while e1 e2 : int &#38;(a1;(a2;a1)*) The atomicity of \na .eld access e.fd depends on the syn\u00adchronization discipline, if any, used for that variable. If fd \nis a .nal .eld, then the rule [exp ref final] checks that e is a well-typed expression of some class \ntype c and that c de\u00adclares or inherits a .nal .eld fd of type t. It states that e.fd has type t and \natomicity a; const,where a is the atomicity of e. [exp ref final] P;E . e:c &#38; a P;E . (final t fd \n= e ' ) . c P;E . e.fd : t &#38;(a;const) The rule [exp ref race] deals with the case where fd is not \n.nal and not protected. [exp ref race] P;E . e:c &#38; a P;E . (t fd = e ' ) . c P;E . e.fd :t &#38;(a;A(t)) \nThe atomicity A(t) of the .eld reference depends on the type t.If t is a class type or int, then the \n.eld reference is atomic.If t is long, then the .eld may be read with two 32-bit loads, and hence is \ncmpd. . atomic if t = long A(t)= cmpd if t = long The rule [exp ref guard] applies when fd is guarded \nby alock l. In this case, the .eld reference has atomicity mover provided the lock is held, and has atomicity \nerror other\u00adwise. The substitution l[this := e] accounts for the aliasing between this and e. That is, \noccurrences of this in the lock expression l refer to the object being dereferenced, which is the same \nobject as that denoted by e. [exp ref guard] P;E . e:c &#38; a P;E . (t fd guarded by l = e ' ) . c b \n= (l[this :=e]?mover) P;E . b P;E . e.fd :t &#38;(a;b) The rule [exp ref write guard] applies when fd \nis write guarded by a lock, i.e., the lock must be held for writes but not for reads. If the lock is \nheld, then the reference is a mover, since it commutes with reads by other threads, and no other thread \ncan write to the .eld. If the lock is not held, the .eld reference has atomicity A(t), i.e.,the read \nis atomic if and only if fd is not of type long. [exp ref write guard] P;E . e :c &#38; a P;E . (t fd \nwrite guarded by l = e ' ) . c b = (l[this :=e]?mover :A(t)) P;E . b P;E . e.fd : t &#38;(a;b) The rules \nfor .eld updates e.fd = e ' are similar to those for .eld accesses. A .nal .eld cannot be updated. A \nguarded by .eld can only be updated if the appropriate lock is held, and the update is a mover. A write \nguarded by .eld can only be updated if the appropriate lock is held, and the update has atomicity A(t), \nwhere t is the type of the .eld. An un\u00adprotected .eld can always be updated, and the update has atomicity \nA(t). The atomicity of a method call re.ects the atomicity of the callee. The substitution b[this := \ne0]in the method call rule accounts for the aliasing between this and e0.That is, occurrences of this \nin the method s atomicity b refer to the object being invoked, which is the same object as that denoted \nby e0. [exp call] P;E . ei :ti &#38; ai t0 =cP;E . b[this :=e0] P;E . (bs mn(t1 y1 ,...,tn yn ) { e }) \n. c P;E . e0.mn(e1 ,...,en ) :s &#38;(a0;a1;...;an;b[this := e0]) The rule [exp sync] for synchronized \nle checks that l is a const expression of some class type c and infers the atom\u00adicity a of the synchronized \nbody e. [exp sync] P;E . l :c &#38; const P;E . e:t &#38; a P;E . synchronized le :t &#38; S(l,a) The \nfunction S de.ned below determines the atomicity of the synchronized statement. For example, if the body \nis a mover and the lock is already held, then the synchronized statement is also a mover, since the acquire \nand release op\u00aderations are no-ops. If the body is a mover and the lock is not already held, then the \nsynchronized statement is atomic, since the execution consists of a right mover (the acquire), followed \nby a left and right mover (the body), followed by a left mover (the release). If the body has conditional \natomic\u00adity l ? b1 : b2, then we ignore b2 and recursively apply S to b1, since we know that l is held \nwithin the synchronized body. If the body has some other conditional atomicity, then we recursively apply \nS to both branches. S(l, const)= l ? const : atomic S(l, mover)= l ? mover : atomic S(l, atomic)= atomic \nS(l, cmpd)= cmpd S(l, error)= error S(l, (l ? b1 : b2)) = S(l, b1) S(l, (l ' ? b1 : b2)) = l ' ? S(l, \nb1): S(l, b2)if l = l ' The rule [exp fork] for fork e requires that the forked expression have atomicity \ncmpd. In particular, a coarser atomicity such as l ? cmpd : error is not allowed, because this atomicity \nis equivalent to error when the lock l is not held, and the newly forked thread does not initially hold \nany locks. [exp fork] P; E. e: t&#38; cmpd P; E. fork e : int &#38; atomic The type system also supports \nsubtyping and subatomic\u00adities. [exp sub] P; E. e: s&#38; a P . s<: tP; E. ab P; E. e: t&#38; b The remaining \ntype rules are mostly straightforward. The complete set of type judgments and rules is contained in Ap\u00adpendix \nA. If a program P is well-typed according to these rules, and an arbitrarily-interleaved execution of \nP reaches a state s in which no thread is executing an atomic method, then the state s is also reachable \nvia a serial execution of P . An execution of P is serial if the execution of an atomic method is never \ninterleaved with actions of other threads. This soundness property has been formally proved for an earlier \nversion of our type system [20] for a sequentially con\u00adsistent shared-memory model. 3.4 Atomic bank \naccounts To illustrate the use of our type system, we now apply it to the bank account example of Section \n1.1. We .rst add type annotations to the initial version of the bank account stating that the .eld balance \nis guarded by this,and that all bank account methods are atomic. class Account { int balance guarded_by \nthis = 0; atomic int deposit2(int x) { ... } atomic int readBalance1() { ... } atomic int withdraw1(int \namt) { ... } } Our type system detects that the withdraw1 method is not atomic, since it consists of \ntwo sequentially composed atomic expressions and therefore behaves erroneously under certain thread interleavings. \nWereplace withdraw1 with the .xed method withdraw2, and also optimize readBalance1 to readBalance2, resulting \nin an optimized synchronization discipline that we explicate using the write guarded by annotation: class \nAccount { int balance write_guarded_by this = 0; atomic int deposit2(int x) { ... } atomic int readBalance2() \n{ ... } atomic int withdraw2(int amt) { ... } } The corrected and optimized implementation type checks, \nindicating that all these methods are atomic. An alternative implementation of the bank account may rely \non its clients to perform the necessary synchronization operations. The following method signatures explicate \nthe requirement that the object s lock must be acquired be\u00adfore calling certain methods, but not others. \nThe meth\u00adods deposit3 and withdraw3 are versions of deposit2 and withdraw2 where the synchronized statement \nis hoisted out of the method bodies and left to the caller. Our type system can again verify that all \nthese methods are atomic. class Account { int balance write_guarded_by this = 0; atomic int deposit3(int \nx) requires this { ... } atomic int readBalance2() { ... } atomic int withdraw3(int amt) requires this \n{ ... } }  4. EVALUATION To evaluate the usefulness of our type system, we have implemented it for \nthe full Java programming language [23] and applied it to a variety of standard Java library classes. \n4.1 Implementation Our implementation extends the type system outlined so far to handle the additional \nfeatures of Java, including ar\u00adrays, interfaces, constructors, static .elds and methods, in\u00adner classes, \nand so on. The extra type and atomicity anno\u00adtations required by the type checker are embedded in spe\u00adcial \nJava comments that start with the character # , thus preserving compatibility with existing Java compilers \nand other tools. The default atomicity for unannotated routines is cmpd, thus the atomic type checker \npasses all unannotated, well-typed Java programs. The checker allows class declara\u00adtions to be annotated \nwith an atomicity that is the default atomicity for each method in that declaration, which makes it is \neasy to specify that every method in a class is atomic. The atomicity checker is built on top of the \nrace condi\u00adtion checker rccjava [18], and re-uses rccjava s machinery for reasoning about the set of \nlocks held at each program point and the locks used to protect .elds. The checker also infers the atomicity \nof each expression and statement in the program, and checks the atomicity of each method body. If a method \nbody s atomicity does not match the declared atomicity of the method, an appropriate error message is \nproduced. This error message describes the inferred atom\u00adicity of each operation in the method body, \nwhich is crucial for determining the cause of atomicity violations. In practice, programs use a variety \nof synchronization mechanisms, not all of which can be captured by our type rules. Like rccjava, the \natomicity checker is able to relax the formal type system in several ways when it proves too restrictive. \nThe no warn annotation turns o. certain kinds of warnings on a particular line of code, and is commonly \nused if a particular race condition is considered benign. The holds annotation causes the checker to \nassume that a par\u00adticular lock is held from the current program point to the end of that statement block. \nThe checker may be con.gured to make global assump\u00adtions about when locks are held. For instance, the \ncommand line .ag -constructor holds lock causes the checker to assume that the lock this is held in \nconstructors. This assumption is sound as long as references to this do not escape to other threads before \nthe constructor returns. Vi\u00adolations of this assumption are unlikely, and using it elimi\u00adnates a large \nnumber of spurious warnings. We believe this command line .ag could be replaced with a sound escape analysis \n[10, 34] without signi.cant reduction in the expres\u00adsiveness of the system. Extending the atomic type \nsystem to handle arrays intro\u00adduces a number of technical challenges. Following rccjava, we use the type \nannotation /*# elems guarded by l */ to specify the lock guarding the elements in an array. We also introduce \ntype annotations for arrays that are local to a par\u00adticular thread, and for read-only arrays. In many \ncases, a newly-allocated array is local to its allocating thread during its initialization phase, and \nis later shared between threads, either protected by a lock, or in a read-only mode. Since the protection \nmechanism is part of the array s type, we use typecasts to accomodate such changes in the protection \nmechanism. These typecasts are currently unsound, as in C, rather than dynamically checked, as in Java. \nMany of these typecasts could be statically checked by extending our system with linear, unique, or ownership \ntypes [31, 6, 5].  4.2 Applications To evaluate and gain experience with the atomicity checker, we applied \nit to check several standard Java classes from JDK1.4 that are intended to be atomic. These classes in\u00adclude \nStringBuffer, String, PrintWriter, Vector, URL, Inflator,and Deflator, and vary in size from 296 to 2399 \nlines of code. Adding appropriate type annotations to these classes was mostly straightforward, once \nthe synchronization discipline of each class was understood. Determining the synchroniza\u00adtion discipline \nof each class was often an iterative process, where we used the checker to investigate the behavior of \nlarge code .les, and to .nd violations of a hypothesised synchronization discipline. While verifying \nthe atomicity of these classes, we had to add appropriate atomicity anno\u00adtations to called methods in \nother classes. We also used the command line .ag -constructor holds lock. The atomicity checker succeeded \nin detecting a number of subtle atomicity violations, including errors that would not be caught by a \nrace condition checker. A particularly clear example of the bene.ts of our type system is provided by \nthe the class java.util.StringBuffer (version 1.70 from JDK 1.4). The documentation of this class states \nthat all StringBuffer methods are atomic. The StringBuffer im\u00adplementation uses lock-based synchronization \nto achieve this atomicity guarantee, and we formalized this synchroniza\u00adtion discipline using guarded \nby annotations. The following StringBuffer method append failed to type check, and an examination of \nthe method reveals that it violates its atom\u00adicity speci.cation: public final class StringBuffer ... \n{ ... private int count /*# guarded_by this */; /*# atomic */ // does not type check public synchronized \nStringBuffer append(StringBuffer sb){ if (sb==null){sb= NULL; } int len = sb.length(); // len may be \nstale int newcount = count + len; if (newcount > value.length) expandCapacity(newcount); sb.getChars(0, \nlen, value, count); // use of stale len count = newcount; return this; } /*# atomic */ public synchronized \nint length() { return count; } /*# atomic */ public synchronized void getChars(...) { ... } } After \nappend calls the synchronized method sb.length(), a second thread could remove characters from sb.In \nthis situation, len is now stale [9] and no longer re.ects the cur\u00adrent length of sb,and so getChars \nis called with invalid ar\u00adguments and throws a StringIndexOutOfBoundsException. The following test harness \ntriggers this crash. public class BreakStringBuffer extends Thread { static StringBuffer sb = new StringBuffer(\"abc\"); \npublic void run() { while(true) { sb.delete(0,3); sb.append(\"abc\"); } } public static void main(String[] \nargv) { (new BreakStringBuffer()).start(); while(true) (new StringBuffer()).append(sb); } } Wealso type \nchecked java.lang.String, and discovered that it contains a method contentEquals,which su.ers from a \nsimilar defect: a property is checked in one synchronized block and assumed to still hold in a subsequent \nsynchronized block, resulting in a potential ArrayIndexOutOfBoundsEx\u00adception. public boolean contentEquals(StringBuffer \nsb) { if (count != sb.length()) return false; // under a sequential execution count == sb.length() // \nbut concurrent threads may change that property ... char v2[] = sb.getValue(); // subsequent code wrongly \nassumes v2.length==count // and may throw an ArrayIndexOutOfBoundsException ... } Type checking java.io.PrintWriter \nraised interesting is\u00adsues concerning rep-exposure [15]. For example, the follow\u00ading PrintWriter method \ntries to ensure atomicity using syn\u00adchronization: public void println(int x) { synchronized (lock) { \nprint(x); println(); } } However, both print and println write to an underlying Writer, which was originally \npassed to the PrintWriter con\u00adstructor. Hence, some other thread could concurrently write characters \nto the Writer, without acquiring the protecting lock used by PrintWriter. To deal with this problem, \nwe declared println and 9 similar methods in PrintWriter as cmpd, and the remaining 17 public methods \nas atomic,and then succeeded in type checking PrintWriter.Our experi\u00adence suggests that an ownership \ntype system [5, 6] or escape analysis [10, 34] for reasoning about rep-exposure [15] would be helpful \nin verifying atomicity. The class java.util.Vector illustrates the need for the extra precision in our \ntype system a.orded by conditional atomicities. The public method removeElementAt is atomic when called \nwithout the vector s lock being held, but also must be a mover when called from removeElement with the \nvector s lock held, in order to verify the atomicity of removeElement. Assigning removeElementAt the \natomicity this ? mover : atomic allows this class to type check. public class Vector ... { /*# conditional_atomicity \nthis ? mover : atomic */ public void synchronized removeElementAt(int index) {... } Annotations per KLOC \n Class LOC total guard requires atomicity arrays escapes java.util.zip.Inflater 296 20.3 16.9 0.0 3.4 \n0.0 0.0 java.util.zip.Deflater 364 24.7 19.2 0.0 5.5 0.0 0.0 java.io.PrintWriter 557 35.9 5.4 0.0 25.1 \n0.0 5.4 java.util.Vector 1029 13.6 2.9 1.0 3.9 2.9 2.9 java.net.URL 1269 33.1 10.2 0.8 9.5 0.0 12.6 java.lang.StringBuffer \n1272 18.9 2.4 3.9 4.7 7.1 0.8 java.lang.String 2399 21.7 0.0 0.0 1.3 19.2 1.3 All benchmarks 7186 23.3 \n4.7 1.0 5.9 8.1 3.6 Table 1: Programs analyzed using the Atomicity Checker. /*# atomic */ public synchronized \nboolean removeElement(Object obj){ modCount++; int i = indexOf(obj); if (i >= 0){ removeElementAt(i); \nreturn true; } return false; } /*# atomic */ public int indexOf(Object elem) { ... } ... } Apart from \nthe need for conditional atomicities, type check\u00ading java.util.Vector was mostly straightforward. In \npar\u00adticular, the race condition in lastIndexOf from JDK1.1 de\u00adtected by rccjava has been .xed. The synchronization \ndiscipline used by java.net.URL is fairly involved, and the atomicity checker reported a number of race \nconditions. For example, the following method can be simultaneously called from multiple threads, resulting \nin multiple initializations of the .eld specifyHandlerPerm: private static NetPermission specifyHandlerPerm; \nprivate void checkSpecifyHandler(SecurityManager sm) { if (specifyHandlerPerm == null) specifyHandlerPerm \n= new NetPermission(\"specifyStreamHandler\"); sm.checkPermission(specifyHandlerPerm); } We have not yet \ndetermined if these warnings re.ect real errors in the program or benign race conditions. We summarize \nour experience in checking these classes in Table 1. It shows the names and the sizes of the vari\u00adous \nclasses that we checked; the number of annotations per thousand lines of code required for each class; \nand breaks down this number into guard annotations (guarded by and write guarded by), requires annotations, \natomicity anno\u00adtations, array annotations (elems guarded by, etc), and es\u00adcapes from the type system \n(holds, no warn).  5. RELATED WORK Lipton [28] .rst proposed reduction as a way to reason about concurrent \nprograms without considering all possi\u00adble interleavings. He focused primarily on checking dead\u00adlock \nfreedom. Doeppner [38], Back [4], and Lamport and Schneider [27] extended this work to allow proofs of \ngeneral safety properties. Cohen and Lamport [12] extended reduc\u00adtion to allow proofs of liveness properties. \nMisra [32] has proposed a reduction theorem for programs built with mon\u00aditors [26] communicating via \nprocedure calls. Bruening [8] and Stoller [37] have used reduction to improve the e.ciency of model checking. \nA number of tools have been developed for detecting race conditions, both statically and dynamically. \nThe Race Con\u00addition Checker [18] uses a type system to catch race condi\u00adtions in Java programs. This \napproach has been extended [7, 5] and adapted to other languages [24]. Other static race detection tools \ninclude Warlock [36], for ANSI C programs, and ESC/Java [19], which catches a variety of software de\u00adfects \nin addition to race conditions. ESC/Java has been ex\u00adtended to catch higher-level race conditions, where \na stale value from one synchronized block is used in a subsequent synchronized block [9]. Vault [13] \nis a system designed to check resource management protocols, and lock-based syn\u00adchronization can be considered \nto be such a protocol. Aiken and Gay [1] also investigate static race detection, in the context of SPMD \nprograms. Eraser [35] detects race condi\u00adtions and deadlocks dynamically, rather than statically. The \nEraser algorithm has been extended to object-oriented lan\u00adguages [40] and has been improved for precision \nand perfor\u00admance [11]. A variety of other approaches have been devel\u00adoped for race and deadlock prevention; \nthey are discussed in more detail in earlier papers [17, 18]. An alternative approach is to generate \nsynchronization code automatically from high-level speci.cations [14]. Thus, reduction has been studied \nin depth, as have type systems for preventing race conditions. This paper combines these existing techniques \nin a type system that provides an e.ective means for checking atomicity. Recently, Freund and Qadeer \nhave combined both reduc\u00adtion and simulation in the Calvin checker to verify con\u00adcise procedure speci.cations \nin multithreaded programs [22]. Our atomic type system is inspired by the Calvin checker, but represents \na di.erent point in the tradeo. between scal\u00adability and expressiveness. While Calvin s semantic analy\u00adsis \nbased on veri.cation conditions and automatic theorem proving is more powerful, the syntactic type-based \nanaly\u00adsis of this paper provides several key bene.ts; it is simpler, more predictable, more scalable, \nand requires fewer annota\u00adtions than the Calvin checker. Atomicity is a semantic correctness condition \nfor multi\u00adthreaded software. In this respect, it is similar to strict serializability [33] for database \ntransactions and linearizabil\u00adity [25] for concurrent objects. However, we are not aware of any automated \ntechniques to verify these conditions. We hope that the lightweight analysis for atomicity presented \nin this paper can be leveraged to develop checking tools for other semantic correctness conditions as \nwell. While our type system can check the atomicity of code blocks, researchers have proposed using atomic \nblocks as a language primitive. Lomet [30] .rst proposed the use of atomic blocks for synchronization. \nThe Argus [29] and Avalon [16] projects developed language support for imple\u00admenting atomic objects. \nPersistent languages [2, 3] are at\u00adtempting to augment atomicity with data persistence in or\u00adder to introduce \ntransactions into programming languages. 6. CONCLUSION Reasoning about the behavior of multithreaded \nprograms is di.cult, due to the potential for subtle interactions be\u00adtween threads. However, programmers \noften expect that in certain atomic methods, such interactions do not occur, and document these beliefs \nby characterizing these methods as synchronized or thread-safe . Knowing that certain methods are atomic \nsigni.cantly simpli.es subsequent (for\u00admal or informal) reasoning about the correctness of those methods, \nsince they can be checked using traditional se\u00adquential reasoning techniques. However, despite the crucial \nrole of atomicity in reasoning about the behavior of multi\u00adthreaded programs, programmers have had little \nsupport for formally documenting or verifying atomicity properties. To remedy this situation, we propose \nan extension to the type language to allow methods to be annotated as atomic. In addition, we present \na type system for checking these atomicity assertions. Although necessarily incomplete, this atomic type \nsystem can handle a number of widely-used syn\u00adchronization disciplines. We have implemented the atomic \ntype system, and our experience to date indicates that this technique is a promising approach for building \nmore reli\u00adable multithreaded software. Our type checker uncovered atomicity violations in classes such \nas java.lang.String and java.lang.StringBuffer that cause crashes under cer\u00adtain thread interleavings. \nFor sequential languages, standard type systems provide a means for expressing and checking fundamental \ncorrectness properties. We hope that type systems such as ours will play a similar role for reasoning \nabout atomicity, a crucial property of many methods in multithreaded programs. Acknowledgments: We thank \nMart\u00b4in Abadi, Chandrashekhar Boyapati, Dan Grossman, Stephen Freund, Shriram Krish\u00adnamurthi and Sanjit \nSeshia for comments on this paper.  7. REFERENCES [1] A. Aiken and D. Gay. Barrier inference. In POPL \n98: Principles of Programming Languages, pages 243 354. ACM Press, 1998. [2] M. P. Atkinson, K. J. Chisholm, \nand W. P. Cockshott. PS-Algol: an Algol with a persistent heap. ACM SIGPLAN Notices, 17(7):24 31, 1981. \n[3] M. P. Atkinson and D. Morrison. Procedures as persistent data objects. ACM Transactions on Programming \nLanguages and Systems, 7(4):539 559, 1985. [4] R.-J. Back. A method for re.ning atomicity in parallel \nalgorithms. In PARLE 89: Parallel Architectures and Languages Europe, volume 366 of Lecture Notes in \nComputer Science, pages 199 216. Springer-Verlag, 1989. [5] C. Boyapati, R. Lee, and M. Rinard. Ownership \ntypes for safe programming: preventing data races and deadlocks. In OOPSLA 02: Object-Oriented Programming, \nSystems, Languages, and Applications, pages 211 230. ACM Press, 2002. [6] C. Boyapati, R. Lee, and M. \nRinard. Safe runtime downcasts with ownership types. Technical Report 853, MIT Laboratory for Computer \nScience, June 2002. [7] C. Boyapati and M. Rinard. A parameterized type system for race-free Java programs. \nIn OOPSLA 01: Object-Oriented Programming, Systems, Languages, and Applications, pages 56 69. ACM Press, \n2001. [8] D. Bruening. Systematic testing of multithreaded Java programs. Master s thesis, Massachusetts \nInstitute of Technology, 1999. [9] M.Burrows and K.R.M.Leino.Finding stale-valueerrors in concurrent \nprograms. Technical Note 2002-4, Compaq Systems Research Center, May 2002. [10] J.-D. Choi, M. Gupta, \nM. J. Serrano, V. C. Sreedhar, and S. P. Midki.. Escape analysis for Java. In OOPSLA 99: Object-Oriented \nProgramming Systems, Languages, and Applications, pages 1 19. ACM Press, 1999. [11] J.-D. Choi, K. Lee, \nA. Loginov, R. O Callahan, V. Sarkar, and M. Sridharan. E.cient and Precise Datarace Detection for Multithreaded \nObject-Oriented Programs. In PLDI 02: Programming Language Design and Implementation,pages 258 269. ACM \nPress, 2002. [12] E. Cohen and L. Lamport. Reduction in TLA. In CONCUR 98: Concurrency Theory, volume \n1466 of Lecture Notes in Computer Science, pages 317 331. Springer-Verlag, 1998. [13] R. DeLine and M. \nF\u00a8ahndrich. Enforcing high-level protocols in low-level software. In PLDI 01: Programming Language Design \nand Implementation, pages 59 69. ACM Press, 2001. [14] X. Deng, M. Dwyer, J. Hatcli., and M. Mizuno. \nInvariant-based speci.cation, synthesis, and veri.cation of synchronization in concurrent programs. In \nICSE 02: International Conference on Software Engineering, pages 442 452. ACM Press, 2002. [15] D. L. \nDetlefs, K. R. M. Leino, and C. G. Nelson. Wrestling with rep exposure. Research Report 156, DEC Systems \nResearch Center, July 1998. [16] J. L. Eppinger, L. B. Mummert, and A. Z. Spector. Camelot and Avalon: \nA Distributed Transaction Facility. Morgan Kaufmann, 1991. [17] C. Flanagan and M. Abadi. Types for safe \nlocking. In ESOP 99: European Symposium on Programming,volume 1576 of Lecture Notes in Computer Science, \npages 91 108, 1999. [18] C. Flanagan and S. N. Freund. Type-based race detection for Java. In PLDI 00: \nProgramming Language Design and Implementation, pages 219 232. ACM Press, 2000. [19] C. Flanagan, K. \nR. M. Leino, M. D. Lillibridge, C. G. Nelson, J. B. Saxe, and R. Stata. Extended static checking for \nJava. In PLDI 02: Programming Language Design and Implementation, pages 234 245. ACM Press, 2002. [20] \nC. Flanagan and S. Qadeer. Types for atomicity. In TLDI 03: Types in Language Design and Implementation, \npages 1 12. ACM Press, 2003. [21] M. Flatt, S. Krishnamurthi, and M. Felleisen. Classes and mixins. In \nPOPL 98: Principles of Programming Languages, pages 171 183. ACM Press, 1998. [22] S. N. Freund and S. \nQadeer. Checking concise speci.cations for multithreaded software. Technical Note 01-2002, Williams College, \nDecember 2002. [23] J. Gosling, B. Joy, and G. Steele. The Java Language Speci.cation. Addison-Wesley, \n1996. [24] D. Grossman. Type-safe multithreading in Cyclone. In TLDI 03: Types in Language Design and \nImplementation, pages 13 25. ACM Press, 2003. [25] M. P. Herlihy and J. M. Wing. Linearizability: A correctness \ncondition for concurrent objects. ACM Transactions on Programming Languages and Systems, 12(3):463 492, \n1990. [26] C. Hoare. Monitors: an operating systems structuring concept. Communications of the ACM, 17(10):549 \n557, 1974. [27] L. Lamport and F. Schneider. Pretending atomicity. Research Report 44, DEC Systems Research \nCenter, May 1989. P .t P .s<:t [type c] class c ... .P [type Object] [type int] [type long] [subtype \nrefl] P .t [subtype class] P .c1 <:c2 class c2 extends c3 ....P P .c P .Object P .int P .long P .t<:t \nP .c1 <:c3 P .E P;E .a [env empty] [env var] P .EP .tx .Dom(E) [atom basic] P .E [atom cond] P;E .l \n: c &#38; const P;E .ai P .\u00d8 P .E,tx P;E .a P;E .l?a1 :a2 P;E .e:t &#38; a [exp sub][exp new][exp var][exp \nref final] P;E .e:s &#38; aP .EP .cP .EE =E1,tx,E2 P;E .e :c &#38; a P .s<:tab P;E .new c: c &#38; mover \nP;E .x:t &#38; const P;E .(final t fd = e ' ) .c P;E .e: t &#38; bP;E .e.fd :t &#38;(a;const) [exp ref \nrace][exp ref guard][exp ref write guard] P;E .e :c &#38; aP;E .e:c &#38; aP;E .e :c &#38; a ' P;E .(t \nfd = e ' ) .cP;E .(t fd guarded by l = e ) .cP;E .(t fd write guarded by l = e ' ) .c P;E .e.fd :t &#38;(a;A(t)) \nb =(l[this :=e]?mover) P;E .bb =(l[this :=e]?mover :A(t)) P;E .b P;E .e.fd :t &#38;(a;b) P;E .e.fd : \nt &#38;(a;b) [exp assign race][exp assign guard][exp assign write guard] P;E .e :c &#38; aP;E .e :c \n&#38; aP;E .e: c &#38; a '''' '' P;E .e :t &#38; aP;E .e :t &#38; aP;E .e :t &#38; a '' '' ) .c '' P;E \n.(t fd = e ) .cP;E .(t fd guarded by l = e P;E .(t fd write guarded by l = e ) .c P;E .e.fd = e :t &#38;(a;a \n' ;A(t)) b =(l[this :=e]?mover) P;E .bb =(l[this :=e]?A(t)) P;E .b ' '' ' P;E .e.fd = e :t &#38;(a;a \n;b) P;E .e.fd = e :t &#38;(a;a ' ;b) [exp call][exp let] P;E .ei :ti &#38; ai t0 = cP;E .b[this :=e0] \nP;E .e1 :t1 &#38; a1 P;E .(bs mn(t1 y1 ,...,tn yn ) {e }) .cP;E,tx .e2 :t2 &#38; a2 P;E .a2[x:= e1] P;E \n.e0.mn(e1 ,...,en ) : s &#38;(a0;a1;...;an;b[this :=e0]) P;E .let tx = e1 in e2 :t2 &#38;(a1;a2[x:=e1]) \n[exp if][exp while] P;E .e1 :int &#38; a1 P;E .e2 :t &#38; a2 P;E .e3 :t &#38; a3 P;E .e1 :int &#38; \na1 P;E .e2 :t &#38; a2 P;E .if e1 e2 e3 :t &#38;(a1;(a2 a3)) P;E .while e1 e2 :int &#38;(a1;(a2;a1) *) \n [exp sync][exp fork] P;E .l : c &#38; const P;E .e:t &#38; aP;E .e:t &#38; cmpd P;E .synchronized le \n:t &#38; S(l,a) P;E .fork e : int &#38; atomic P;E ..eld P;E .meth [field no guard][field guard] [method] \nP .EP;E .l :c &#38; const P;E .aP .t P;\u00d8.e: t &#38; mover P;\u00d8.e :t &#38; mover P;E,arg1...n .e: t &#38; \na P;E .[final]opt t fd = eP;E .t fd [write ]guarded by l = eP;E .at mn(arg1...n ) {e } P ..eld .c P \n.meth .c [field member] [method member] ' ' P .c<:c P .c<:c ' ' class c ... {... .eld ...}.P class \nc ... {... meth ...}.P P ..eld .cP .meth .c P .defn .P [prog] E = cn this P .c ClassOnce(P) WFClasses(P) \nFieldsOnce(P) P;E ..eldi P;E .methi MethodsOnce(P) OverridesOK(P) [class] P .class cn extends c {.eld1...j \nmeth1...k} P = defn1...n eP .defni P;\u00d8.e:t &#38; cmpd .P APPENDIX  A. THE TYPE SYSTEM This appendix \npresents the type system described in Sec\u00adtion 3. We de.ne the following predicates informally, based \non similar predicates in [21]. [28] R. Lipton. Reduction: A method of proving properties of parallel \nprograms. In Communications of the ACM,volume 18:12, pages 717 721, 1975. [29] B. Liskov, D. Curtis, \nP. Johnson, and R. Schei.er. Implementation of Argus. In SOSP 87: Symposium on Operating Systems Principles, \npages 111 122, 1987. [30] D. B. Lomet. Process structuring, synchronization, and recovery using atomic \nactions. Language Design for Reliable Software, pages 128 137, 1977. [31] N. H. Minsky. Towards alias-free \npointers. In ECOOP 96: European Conference for Object-Oriented Programming, volume 1098 of Lecture Notes \nin Computer Science,pages 189 209. Springer-Verlag, 1996. [32] J. Misra. A Discipline of Multiprogramming: \nProgramming Theory for Distributed Applications. Springer-Verlag, 2001. [33] C. Papadimitriou. The theory \nof database concurrency control. Computer Science Press, 1986. [34] A. Salcianu and M. Rinard. Pointer \nand escape analysis for multithreaded programs. ACM SIGPLAN Notices, 36(7):12 23, 2001. [35] S. Savage, \nM. Burrows, C. G. Nelson, P. Sobalvarro, and T. A. Anderson. Eraser: A dynamic data race detector for \nmultithreaded programs. ACM Transactions on Computer Systems, 15(4):391 411, 1997. [36] N. Sterling. \nWARLOCK a static data race analysis tool. In USENIX Technical Conference Proceedings, pages 97 106, \nWinter 1993. [37] S. D. Stoller. Model-checking multi-threaded distributed Java programs. In SPIN 00: \nWorkshop on Model Checking and Software Veri.cation,volume1885of Lecture Notes in Computer Science, pages \n224 244. Springer-Verlag, 2000. [38] T. W. Doeppner, Jr. Parallel program correctness through re.nement. \nIn POPL 77: Principles of Programming Languages, pages 155 169. ACM Press, 1977. [39] J.-P. Talpin and \nP. Jouvelot. The type and e.ect discipline. In LICS 92: Logic in Computer Science, pages 162 173. IEEE \nComputer Society Press, 1992. [40] C. vonPraun andT. Gross. Object-racedetection. In OOPSLA 01: Object-Oriented \nProgramming, Systems, Languages, and Applications, pages 70 82. ACM Press, 2001. Predicate ClassOnce(P) \nWFClasses(P) FieldsOnce(P) MethodsOnce(P) OverridesOK(P)  Meaning no class is declared twice in P there \nare no cycles in the class hierarchy no class contains two .elds with the same name, either declared \nor inherited no class contains two declared methods with the same name overriding methods have the same \natomicity, return type, parameter types, and requires set as the overridden method A typing environment \nis de.ned as E ::= \u00d8|E, arg We de.ne the type system using the following judgments and the typing rules \nin Figure 2. We use the notation [write ]guarded by to denote either write guarded by or  guarded by. \nJudgment Meaning P . t tis a well-formed type P . s<: t sis a subtype of t P . E E is a well-formed typing \nenvironment P; E. a a is a well-formed atomicity P; E. e: t&#38; a expression ehas type tand atomicity \na P; E. .eld .eld is a well-formed .eld P; E. meth meth is a well-formed method P . .eld . c class cdeclares/inherits \n.eld P . meth . c class cdeclares/inherits meth P . defn defn is a well-formed class de.nition . P program \nP is well-formed  \n\t\t\t", "proc_id": "781131", "abstract": "Ensuring the correctness of multithreaded programs is difficult, due to the potential for unexpected and nondeterministic interactions between threads. Previous work addressed this problem by devising tools for detecting <i>race conditions</i>, a situation where two threads simultaneously access the same data variable, and at least one of the accesses is a write. However, verifying the absence of such simultaneous-access race conditions is neither necessary nor sufficient to ensure the absence of errors due to unexpected thread interactions.We propose that a stronger non-interference property is required, namely <i>atomicity</i>. Atomic methods can be assumed to execute serially, without interleaved steps of other threads. Thus, atomic methods are amenable to sequential reasoning techniques, which significantly simplifies both formal and informal reasoning about program correctness.This paper presents a type system for specifying and verifying the atomicity of methods in multithreaded Java programs. The atomic type system is a synthesis of Lipton's theory of reduction and type systems for race detection.We have implemented this atomic type system for Java and used it to check a variety of standard Java library classes. The type checker uncovered subtle atomicity violations in classes such as &lt;tt&gt;java.lang.String&lt;/tt&gt; and &lt;tt&gt;java.lang.String-Buffer&lt;/tt&gt; that cause crashes under certain thread interleavings.This paper proposes that a stronger non-interference property is required, namely <i>atomicity</i>, and presents a type system for verifying the atomicity of methods in multithreaded Java programs. Methods in a class can be annotated with the keyword &lt;tt&gt;atomic&lt;/tt&gt;. Clients of a well-typed class can then assume that each atomic method is executed in one step, thus significantly simplifying both formal and informal reasoning about the client's correctness.", "authors": [{"name": "Cormac Flanagan", "author_profile_id": "81100538763", "affiliation": "HP Systems Research Center & Microsoft Research, Palo Alto, CA & Redmond, WA", "person_id": "PP14187273", "email_address": "", "orcid_id": ""}, {"name": "Shaz Qadeer", "author_profile_id": "81100286660", "affiliation": "HP Systems Research Center & Microsoft Research, Palo Alto, CA & Redmond, WA", "person_id": "PP14106781", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/781131.781169", "year": "2003", "article_id": "781169", "conference": "PLDI", "title": "A type and effect system for atomicity", "url": "http://dl.acm.org/citation.cfm?id=781169"}