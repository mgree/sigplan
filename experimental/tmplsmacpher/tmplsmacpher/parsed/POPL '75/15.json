{"article_publication_date": "01-01-1975", "fulltext": "\n Permission to make digital or hard copies of part or all of this work or personal or classroom use is \ngranted without fee provided that copies are not made or distributed for profit or commercial advantage \nand that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, \nto post on servers, or to redistribute to lists, requires prior specific permission and/or a fee.&#38;#169; \n1975 ACM 0-12345-678-9 $5.00 Modes, Values and Expressions Marvin Solomon Cornell University O, Introduction: \nSeveral modern programming languages (e.g. Algol 68 [1], Pascal [2], Basel [3], EL1 [4] ) require each \nvariable to have a declared mode or type, which limits the class of values wh~ch it may assume. In each \nof these languages, a value may con\u00adtain a reference or pointer to z value of the same type, allow?ng \nl~nked lists. In this case, it is natural to define the mode of the value recursively --that is, in terms \nof itself. For example, if list describes values which are structures con\u00adtaining two fields, one being \nan integer and the other a pointer to another value of type list, then we can summarize these facts by~ting \n(0.1) e list= struct2(~,ref list). . What is a mode? One point of view is that it is a set of values \n[5,6]. The PLgol 68 Report [1] takes the slightly different view that a mode is a possibly infinite object \nthat is associated with a set of values. For example, list is the infinite tree: list ~ struct -ref - \nstrucrefef . . . ._ _ II Building on these ideas, Lewis and Rosen [7], using methods of Scott [8,9], \nbuilt a formal model SEQ, in which every meaningful definition like (0.1) denotes a unique element of \nSEQ. The question of which mode definitions should be consid\u00adered equivalent (cf. [10,11]) is answered \nby saying that two definitions are equi\u00advalent if and only if they denote the same member of SEQ. Lewis \nand Rosen were principally interested in answering the question of equivalence of modes in type systems \nwhich allow unions. We extend their work in a different direction by constructing a Scott-like model \nfor values. The con~ struction is similar to the model for modes, but involves certain new complica\u00adtions. \nMoreoverr we investigate the relationship between modes and their asso\u00adciated sets of values. As an application \nof our technique, we consider certain mode definitions which are excluded from Algol 68, for example: \nmode ml =ml mode m2 = struct(m2)  mode m3 = ref m3 . . Mode ml is also disallowed by Lewis and Rosen,~ince \nit fails to denote a unique object in their system. (In fact, any object whatsoever satisfies the de\u00adfining \nproperty. ) They give a syntactic characterization of those definitions which do have unique solutions. \nMode m2 does have a unique solution, but we wi~ show that the corresponding set of values is empty. We \ngive a syntactic method of detecting such definitions, and it seems reasonable to disallow them. Mode \nm3 is excluded for still more subtle reas~s; by considering the allowed expressions in Algol 68 and their \neffect on values, we show that it is possible to construct a value of mode m3 which has subvalues (in \na sense to~e made more precise below) which cannot be accessed. These useless values can be eliminated \nby preventing definitions like that of m3. Again, we show how to detect such de~ni\u00adtions. Removal of \nthese modes entails no essential loss of expressivity from the language. Alternatively, a new operator \nmay be added to the lanquaqe so that such values are no longer useless. The syntactic tests mentioned \nabove are similar to the declaration condition [1, paragraph 4.4.4]. However, our con\u00additions are less \nad hoc, following from general considera~o~which may be ap\u00adplied to other programming languages as they \nare developed. Moreover, our seman\u00adtic approach points out an anomaly in the Algol 68 definition: mode \nm4 = struct(ref m4) . is legal, but mode m5 = [1:1] ref m5 . is not, despite the obvious similarity. \nOur considerations would allow m5 as a . mode. 1. Modes 1.1 Syntax We use the following definitional \nfacility as a concrete example: cdefinition~ : :=<declaraction> I ~ def inition> ;~declaraction> <declaract~on> \n: :=mode<indicanti= (1.1.1) <declarer> <declarer> z :=int I<indicant> )ref<declar~> I structk (.:aclare~> \n. .... ,<declare~> k declarers(k~ 1) We will denote terminal productions of <indicant> by underlined \nwords. For nota\u00adtional simplicity, we use integers as field selectors rather than arbitrary character \nstrings as in Algol 68. This has no essential effect on the theory. We will assume that every definition \ncontains exactly one declaration for each indicant appearing in it. 1.2 Semantics The model M we build \nfor modes is in\u00adspired by [9] and closely resembles the one presented in [14] (cf. [7,8]). As mentioned \nabove, modes are conceived of as (possibly) infinite trees. The nodes of these trees are labeled by the \nsymbols {int,ref,struct1,struct2,...} . We allow only those trees which are ranked, in the following \nsense: Define the rank of a SylTbOl by rank(~ = O (1.2.lfank(ti) = 1 rank (.structk) = k (k = 1,2,3, \n...) . If S labels a node of a ranked tree, then that node has precisely rank(s) sons. For example, int \nwppears only at leaves. We could com~tely specify our intended set of modes by saying that it consists \nof all ranked trees built from the ranked set of symbols given by (1.2.1), but for the sake of other \ndefinitions, it is preferable to have infinite modes built up inductively from finite pieces. Rather \nthan build our model specifi\u00adcally for the ranked set of symbols (1.2.1), we show how to construct such \na model for any ranked set !2 = no U Q1lJ .... Appendix A contains the details. In this case, Q = {int], \n~1 = {ref,structl], and o  = struc,tk for k > 2. We write M for k T(O) with this particular choice of \nQ. Elements of M are called modes. Briefly, the facts about M are as follows: Miss._ type of ordered \nset, called a Cpor in which certain limits are defined. A func\u00adtion which preserves these limits is said \nto be continuous. The theorem of Tarski (A.6) guarantees that such a function f has fixed points, and \nshows how to compute a Particular fixed point called the least fixed point of f, Yf. . Now consider a \ndefinition such as (0.1). The declarer struct2(int,ref list) may be thought of as ~ng . a funct~ where \nthe indicant list is a free variable. More specifically, = t? M, let f[m) = struct2 /\\ int ref -i-\u00ad \nm Then (0,4) may be thought of as saying that list is any element of M such that m = f(m) --i.e. a fixed \npoint of f. More formally, let D be the definition mode m =dl; -1 mode m =d2; 2 . . . mode m =dn. -n \nFor each declarer di, define a function fd:@ + M as follows: If d = int then fd(~) = int Ifd=mi then \nfd(~) = xi If d = ~ ~ then fd(~) = ref(f~(~)) If d = structk(dl, . . ..dk) then fd (=) = _k(fd, (z)r.. \n.rfdl~ (=)) . n where x=<x ,.. .,xn> ~M . 1 Let fn:d + I@ by fD(a-= <fd(;),. ..,fd (2)> . 1n fD is built \nup from operators in Q so that by lemmas A.15 and A.7 in Appendix A, fn is continuous. Hence, Tarski \ns theorem\u00adyields as a corollary (1.2.2) Theorem: Each declaration D is satisfied by at least one m ~ \nMn. The set of m e Mn satisfying D is a cpo. The least element of this cpo is lub{f~(<~, . . ..L>)l k \n> O} .  1.3 Unique Modes We have seen that each definition identifies at least one element of Mn. However, \nsome definitions are satisfied by more than one. For example, the definition (1.3.1) mode m = ~ . is \nsatisfied by any mode whatsoever. Oth\u00aderwise stated, f is the identity function on M, so the lat?ice \nof fixed points of fD is all of M. Howeverr we can show that any definition with multiple fixed points \nis essentially a variation on (1.3.1). To characterize those good definitions which define unique fixed \npoints, consider the following directed graph GD constructed from a definition D. The nodes of GD are \n the indicants of D. There is an arc from 3 to g if and only if the declaration mode m = n appears in \nD. \u00ad (1.3.2) Theorem(modified from Lewis and Rosen [7]): If GD contains no directed cycles (i.e. if G~ \nis a directed acyclic graph) then the least fixed point YfD of f is maximal in @ (i.e. there is no nD~ \nMn such that n > m) . Conversely, if GD contains a directed cycle, then fD has a fixed point of which \nat least one com\u00adponent is 1 . Proof (outline): Let fi = <L J-> ~ IF, r...r and let :k+l = <mk+l k+l> \n= fD(;k). ~...)mn 1 BY theorem A.6, the least fixed point Yf is given by R= <ml,... rmn>=lub{=k I k~O] \n. Suppose G is acyclic. For each m 4S M let u(m) be the length of the shortest branch which terminates \nin J-if any such exists, and ~ otherwise. Thus m is com\u00adpletely defined up to level u(m). The idea is \nto show that as k increases, u(m~) increases without bound. This is because each iteration of fD adds \nsomething to the root of mi, for those indicants mi which depend non-trivially (or not at all) on the \nother indicants (-D. = in D) . Each other compone~ ~~~~;2\u00ad pends on such an m: in such a way that the \nvalue of u(m~) grows as fast as u(mf). For the converse, suppose in G we have a path m. +m. + ... +m. \n+m. . 11 2 k 11 Then for all k ~ Oand all j &#38; i,m~ =1. j= (1.3. 3) Corollary: If GD is acyclic, \nthen fD has a unique fixed point. Hence D associates a unique mode mi e M with each indicant ~i in D. \n Proof: Let i = Yf and let ~ be any other fix~d p~int. ~ is the least fixed point so m~ n. But ~ is max~mal \nin Mso E =~. For the remainder of this paper, we will assume that all definitions mentioned have acyclic \ngraphs and hence unique solu\u00adtions. We will consistently use the no\u00adtation mi for the element of M associated \nwith the indicant :i by a definition.  1.4 Regular Modes We have seen that every definition is associated \nwith some element of M. We may wonder whether the converse holds. The answer is negative. (1.4.1) Theorem: \nA mode m ~ M is associat\u00aded with some lndicant by some definition (satisfying the property of 51.3) if \nand only if m is a regular tree (see Appendix B) . Proof: Let D be a definition, and s ~ O. M-y D to \nform a grammar G as follows: The non-terminal symbols of G are the in\u00ad dicants of D. The terminal symbols \nare lr...rn where n = max{kls g k for some s occurring in D]. For each declaration mode m= e . in D, \ninclude the followinq productions in G: If s occurs at node ~ of e and ADDRESS(n) = L, then include !g \n+ E in G. If n occurs at node n of e and ADDREgS(~) = ~, include ~ + ~g.  Now for each indicant ~, it \nshould be clear that if m is taken to be the start symbol of G, t~en G produces exactly Ls (m) . Since \nG is right linear ([15]), Ls(m) is a regular set. Conversely, let m be a regular mode. Let Sir. ..,sk \nbe the symbols appearinq in m and let Ai = <Oi,q~,8i,Fi> be the mini\u00ad mal finite automaton recognizing \nLs (m) . Let A be the parallel composition o $ the A. --i.e. A = <0,q0,6,F> where d(<q, ,.. = <6 (ql,a), \n. ..~ ; ~ (qk,a)> .,qk>,a) 1 (the-definition of F is irrelevancy. - Delete those states of A which are \nun\u00adreachable. Now for each remaining state <ql,.. .,qk> there is exactly one k such .. that qk ~ Fk. \nThis is because the reach\u00ad ability Of q~~... tqk > implies that for some x~ {l,..., k}*, <ql;. ..rqk> \n= qo> x) = <dl(ql,x),.../ 5 (%:?..., k ? dk(cl:,x)? BUE qi = 6i(q~,x) e Fi implies that the node whose \naddress is x is labeled by s<. Clearly this is true for exactly one 1 i. Now introduce an indicant q \nfor each state q of A and give the defi~ition  mode q = :i(&#38;(q,l), . . ..d(q.k)) where q = <(glr.. \n.,qk> and Si is the unique symbol such that qi ~ Fi, It may be veri\u00ad fied that the mode corresponding \nto the indicant q. is the given mode m. 8 2. Modes and Values The central contribution of this work \nis the construction of a model for the set of possible values of an Algol 68\u00adlike language which provides \na meaning for the, until now, purely formal notion of mode. In particular, each mode is asso\u00adciated with \na set of values in such a way that distinct modes are associated with distinct sets of values. A value \nsuch as the one shown in figure 2.1 may be consid\u00adered to be an infinite tree by unrolling it as shown \nin fiqure 2.2, or it may be defined by a recursive equation such as v = struct2(5,ref (v)). Both of \nthese descriptions suggest a model ~ ~: va~: similar to the model . But m the case of values. an additional \ncomplication arises: whereas figure 2.2 indicates that some infinite trees should be allowed as values, \nwe don t want infinite values such as v = struct2(5,v) since this would imply that v is a struc\u00adture, \none of whose fields contains v. Thus a more involved construction is re\u00adquired. 2.1 The Model V In Appendix \nA, we have all the ma\u00adchinery to produce a cpo T(Q) from an ar\u00adbitrary ranked set Q of operators. Our \napproach will be to produce an appropriate set Z of operators and let v = T(Z) . In\u00adtuitively, an operator \no e E~ will be a storage cell having exactly n pointer fields and possibly some integer fields already \ninitialized. Formally, we make the inductive definition 2 1 110 = z (the set of integers) ref ~Z 1 If \nUi ~ Zn, for i = I,.. .rk, then . 1 structk(ol, . . ..uk) ~ Z l+n2+ -+nk Let V = T(Z). Intuitively, \nV con\u00adtains all finite and infinite ranked trees with labels in Q (cf. 1.2), perhaps with leaves labeledl, \nand satisfying the ad\u00additional property that on each infinite branch, ref appears infinitely often. \n 2.2 The Map VALUE Let 2V denote the collection of all sets of values. Order :!v by letting S<T if \nand only if T c S (nc)te the change ~f direction) . It i~ readily verified that 2V becomes a cpo, with \n~L = V. Define a function VALUE on finite modes inductively by: VALUE(1) = v 2 2 :L)VALUE(int) = 7, VALUE(= \nm) = {ref v . . Iv e! VALUE(m)} VALUE (structk (ml,,... ,mk)) = {structk (vi,,. ..,vk) Ivi e VALUE (mi) \nand vi +1, i=l,. ..l,k} . This completely specifies VALUE for all finite modes. In fact, if we let VALUEn \ndenote the restriction c]f VALUE to Mnr then the set {VALUEn:Mn + 2VI n :1 cI} satisfies all the hypotheses \nof Theorem A.13 as may easily be chec:ked. Thus we have a unique extension of VALUE to infi\u00adnite modes. \nBy the proof of Theorem A.13, VALUE:M + V is given explicitly by VALUE(m) = fiVALUE,l(Tn(m)). n= o  \nFor example, consider the mode m defined by (0.1). The first few approximations to. m and the value sets \nassociated with them are shown in figure ;!.2.1. Intui\u00adtively, each mk g ives more information about \nm than ~_l and so eliminates some values as possible values of m. Now, for some modes m ~ M, VALUE(m)=~. \nFor example, consider the definition mode m = structl(m) , . . This specifies a mode m ~ M whose projec\u00adtions \nare mi = ~i(m) = struct~ l,. . VALU E(mo) = VALUE(L) =: V VALUE(ml) = VALUE(structlL) = {structl(v)l \nv #&#38;}. . . . VAI~E(mi) = {struct~(v)l v +1} . . Each v ~ VALUE(mi) has the property that v= Cl[vl \nr..., vk) for some operator u ~ Zk .\u00adof de,pth at least i, whsre the depth of an operator is defined \nby depth(o) =Oif u=ref or u6Z depth (structk (ol,. ..,uk> ) = 1 + max{depth(ai)l ~L = 1,. ..,k} . \nSuppose v ~ VALUE(m) = fi Value. i=o Since v~V, v=l or v= a(vlr. ... vk) for some Ue z, Vl, . . ..vk \n~ V (Theorem A.14). ~f! VALUE(ml) ~VALUE(m) so v #~. If V=u(vl,. ..,v ), then for each i,vi~ VALUE (mi), \nso~epth (u) ~i. It follows that depth(o) is greater than any integer a patent absurdity. The generalization \nof this proof is the following theorem. Given a definition D, we define a graph GD similar to the graph \nconstructed in $1.3, but now z +,~ if and only if D contains the declaration mode m = e where e is an \nexpression con\u00ad=i~g an occurance of n not contained in the operand of any occur~ence of ref.kj Theorem: \nIf GD is acyclic then every mode defined by D (i.e. made to correspond to some indicant ~ in D) has a \nnon-empty value set. Conversely, if GD has a cycle, then D defines some m ~ M such that VALUE(m) = 0 \n. Proof: Suppose GD i~ acyclic. Letmbe an indicant appearing in G~ and let its declaration be mode m \n= e for some expres\u00ad . sion e. Perform the following transforma\u00ad tion on e: Step 1: Replace all occurrences \nof ~nt in e by O, and all occurrences Xref e (for some expression e ) by al. Step 2: If e has an occurrence \nof n for some indicant n, replace that occurrence by e , ~here the declar\u00adation of nis mode n=e!,and \ngo \u00adback to s~ep 1; otherwise stop (e contains no indicants) . This procedure halts after a finite number \nof steps because GD is acyclic. It is readily verified that a value v ~ V is produced such that v ~ \nVALUE(m). The proof of the converse is similar to the above example, and is left as a tedious exercise. \n m  2.3 Regulzr Values Because of the impossibility of structures, such as circular lists, whose unrolled \nversions are infinite, we have allowed infinite elements in V. But some elements of V are actually infinite, \nin that they require an infinite amount of storage. In fact, we have the following: */ See the remarks \nabout notation at the ~eginning of Appendix A. Theorem: For any value v ~ V, v corres\u00adponds to some \nfinite list structure if and only if v is a regular value (cf. Appen\u00addix B; notice that the occurrence \nlan\u00adguages Ls are defined in terms of the operators s ~ X , not the symbols of 0). Proof: (It may help \nthe reader to look at the example, fiqure 2.3.1, while reading this proof) Given a finite list structure \nS, we construct a finite automaton ([15]), whose states correspond to the cells of S. There is a transition \nfrom state ql to q2 under the symbol k > 1 if and only if the kth pointer out of ~he cell corresponding \nto ql points to the cell corresponding to qz. For each cell c, if the corresponding state is made to \nbe the unique final stat+ the automaton will recognize Lc(s) , the occurrence language of c in S. Thus \nS is (or, more precisely, corresponds to under unrolling) a regular value. The converse construction \nis similar. 3. Modes, Valuesr and Expressions Suppose x is a variable with mode m and current value \nv. Let e[x] be an ex= pression containing an occurrence of x. What values may occur as values of such \nexpressions? Viewing v as a tree, we say w is a subvalue of v if w is the tree com\u00adposed of some node \nof v and all its des\u00adcendants. Now for any value of x, it would be desirable that there is some expression \ne for each subvalue of v. Otherwise, this subvalue is inaccessible and may as well be eliminated from \nv. This motivates the (3.1) Definition: Let ~be a mode, v a value ~n VALUE(m) , x a variable of mode \nm. A subvalue w of v is accessible with re\u00ad  spect to m if and only lf there 1s some expres~ofi e[x] \nsuch that if x = v, then e[x] = w. v is connected with respect to m if and only if every subvalue of \nv ls ~ccessible with respect to m. m is connect\u00aded if and only if every val~e ~ ~ value(m) . ~ connected \nwith respect to m.  Of course, this definition depends on what expressions are allowed. UJe choose the \nfollowing subset of Algol 68 as an example: (3.2)<expression> ::=<variable> I<selection> [ <coercion> \n ,.. <selection>: :=<positiveinteger> of <expression> <corecion> : :=<declarer> :<expression> k of \ne is defined if and only if the mode of~ begins with structk for some k ~ k. Then the value of e must \nbe of the form and the value of k of e is of mode ref mfor some k >0. ~k(vl ~ve) . In this case the \nvalue of e is either equal to m4, so the corecion has its desired e~ect. refkv for some v, or reffil. \nfor k < k. In . the former case d:e =7 in the latterK 4. Conclusiond:e =L. (In case the mode of e = \nref m . for more than one value of k, choose the We have given a model for modes andleast such k.) Mode \nm3 is not connected, values, and used it to classify three as figure 3.1 illustr~es: clearly, any types \nof undesirable declarations: thoseexpression involving only a variable x of which do not define unique \nmodes, thosemode m3 cannot contain any selections. which define valueless modes, and thoseSucce~ive coercions \ncan be combined, so which define unconnected modes. We qive any expression is equivalent to one ofk criteria \nfor detecting each kind of defi\u00adthe form d:x. If the mode of x is ref m nition in terms of an easily \nchecked pro\u00ad for some ~, then m = m>, so the mode of x perty of a graph which can be constructedis m3 \nand the mod= of d is m3. Thus the directly from the definition. bJe alsoval~ of the expression is mat \nof x. If consider regular trees and show that they the value of x is v, then w is inaccessible. correspond \nexactly to the definable modes and the representable values. Let D be a definition. Again we con\u00adstruct \na graph GD as in 5$1.3, 2.2. Here But we feel that the most important we have an arc from m to n if and \nonly if aspect of this paper is that it shows the declaration of m is m~de m = e where that the purely \nsyntactic approach to there is an occurre~ce o~i= e which is programing lanq~not always the not contained \nin any opera~d of any best --that a description in terms of in\u00adstruct tended meaning can be at the same \ntime k equally rigorous and more clear than the (3.3) Theorem: Every mode m defined by a syntactic approach, \nif the semantics is definition D is connected if and only if properly formalized. GD is acyclic. References \nProof (by pictures): Suppose GD is acyclic. Let m be a mode defined by D, x a varia-[1] van Wijngaardenr \nA. Report on the ble of mode m, v a value of x, and w a Algorithmic Language Algol 68 , Numer\u00ad subvalue \nof v. Since GD is acyclic, each ishe .Mathematicr 14(1969), 79-218. [2] Wirthr N. The Programming Languagebranch \nof m (and hence of v) consists of Pascal , Acts Informatica ~,1 (1971),alternating finite, non-empty \nsequences of 35-63. structs and refs. The situation is given [3] . Basel Language Programmer Man\u00ad pictorially \n~figure 3.2. Then the value ual. Massachusetts ComDuter Assoc~ates . w may be described by the expression: \n~., Wakefield Mass.r 1970. [4] Wegbreit, B. Studies in Extensible (3.4) ~p~:iknk~...~ikl~l:l: . . . : \nprograrmning Languages. Ph.D. Thesis, Harvard University. 1970. [5] Reynolds, J.C. A set-theoretic ap\u00ad \n2 :i2n2Q. ..Qi22Qi21Q$ml: proach to the concept of type , Ar\u00adgonne National Laboratories, 1969. ~lnl= \n...@i12~ill~x . [6] Morris, J.H.,Jr. Types are not sets , ACM Symposium on Principle s of ??r o- Notice \nthat each m. is a mode which gramming Languages, Boston, Mass. 1973 can be described by som~ declarer \nbuilt [71 Lewis, C. and F3.K. Rosen. Recursivelyup from the indicants appearing in D. defined data types, \nPart 1 , ACM Sym-Thus (3.4) becomes a valid expression if posium on Principles of Progr~each mi is replaced \nby the corresponding Languagesr Boston, Mass. 1973. declarer. [8] Scott, D. Continuous lattices , Pro\u00adceedings \nof the Dalhousie Conference, Conversely, if GD contains a cycle, Lecture Notes in Mathematics ~, then \none of the modes m defined by D Springer Verlag, Berlin, 1972. satisfies the equation m = refkm for [9] \nScott, D. The lattice of flow dia-SOIl&#38; k > 1. The unique solutlon to this grams , in Semantics of \nAlgorithmic equatio~ in M is the mode ref ref ref . . . Languagesr E. l?ngeler, @d. , Lecture which, \nas we saw above, is not connected. Notes In Mathematicsr =, Springer Verlag, Berlinr 1971. From one point \nof view, such a mode. [10] Koster, C.H.A. on infinite modes , is anomalous simply because there are not \nA1. ol-Bulletin 30 in SIGPLAN Noti ces enough expressions. If, for example, we &#38;llarch 1969~ allow \nan operator deref, then m3 becomes [11] i?ralj J. The equivalence of modes connected (in fact, all regula~modes \nbe-and the equivalence of finite automata come connected) . On the other hand, m3 Algol Bulletin 35 (March \n1973). may be replaced by m4 using m4: 1 of ~ [12] -i, A. A l~tice-theoretical fix\u00adto access the seco~ \nnode ~ x. ~ere point theorem and its applications , 1 of x is of mode ref m4 which is not pacific Journal \nof Mathematics 5_(1955) . . 285-309. [13] Rabin, M.O. Automata on infinite ob-A.2 Definition: Introduce \na partial order jects-and Churchts problem , Regional on D as follows: n+l Conference Series in Mathematics \n13, American Ma~i~l Socletyr Pr~i-X<y  dence. R.I., 1972. if and only if [14] Wand., M. Ma~hematical \nfoundation of formal language theory. Ph.D. Thesis, x =1, or x = s(dl,. ..,dk)r MIT Project MAC report \nTR-108, Cam- Y = s(dl ,. ..,d) ) brid~e, Mass. 1973. [15] Hopc~oft, J. and J.D. Unman. Formal for some \nk, some seQ and some all,. ..,dwk Languages and their Relation to Au\u00adall ,. ..,dk ~ Dn such that di < \ndi in Dn tomata. Addison Wesley, Reading, Mass. 1969. fori=l, . ..rk.  [16] Eilenbergr S. Automata, \nLanguages and Machines. Academic Press, New York, A.3 Definition: Let C be a set and < a 1974. relatxon \non C (a subset of C x C). <~,< > [17] Engelfreit, J. lVA note on infinite is a cpo (complete ~artially \n~rdered s~t) trees , Information PrOc. Letters 1, if an~nl~ if 6 (December 1972), 229-232--(i) ~ partially \norders C (i.e. < is Rosenr ~.K. l!Tree-maXIi,pUlating sys\u00ad [18] transitive, reflexive and anti~ tems \nand Church-Rosser theorems , symmetric) JACM 20.1 (January 1973), 160-187. (ii) There is an element _L~ \nC such that [19] -a~j S; Categ&#38;cies for the Work-VXec,l-<x. ing Mathemat~c~an. Sprmger-Verlag, (iii) \nEach chaifi X. ~ xl ~ X2 ~ . . . of New York, 1971. elements of C has a least upper bound X = lub{xi} \n--i.e. an element satis- Appendix A fying the pro erties In this appendix, we show how to con-a) xi \n~ x ~i struct the cpo T(Q) of all (ranked, finite b) if x i~y~itheny~x.m or infinite, partially or completely \nde\u00adfined) trees over an arbikrary ranked al-Notice that if C is finite, then (iii)phabet Q and derive \nsome of its properties holds trivially. . Suppose Q =QOU fllU f12LJ . . . is A.4 Lemma: Each Dn defined \nby A.1 and A.2 any set of symbols. Without loss of gen-is a cpo. m erality, assume the Qi s are disjoint \nA.5 Definition: Let A, B be cpo s f:A + B (otherwise replace s ~ fin by <n,s>). In- Then f is monotone \nif and only if troduce a new symbol i j? fi and define: for each Xry ~ A, with x ~y,  A.1 Definition: \n= {L} (-I f(x) :f(y). D = {s(dlj. ..,dk)l s eflkand n+ 1 f is continuous if and only if f s mono\u00ad all, \n..., dk e Dn} U{1} . tone and [Here we pause to make a remark about no\u00ad or achchain o ~ 1 ~  In tation. \nThe elements of Dn are to be f(lub{xi}) = lub{f(xi)} . 8 thought of as trees. s(dl,. ... d k ) is the \ntree given pictorially by: Notice that the monotone property of f in\u00ad sures that f(xo) < f(xl) < . . \n. so the  definition of continuity makes sense. No\u00adtice also that in a finite CPO (or more generally, \nin one in whimh all chains are In the case s ~ !2., S( ) ~ Dn+l where finite) every monotone function \nis contin\u00aduous . S( ) is a one-node tree: ~ s. A.6 Theorem: (Modified from Tarski [12]) We will often \nrefer to such a one-node Let C be a cpo and f:C + C continuous. tree by the label on its node. For exam-Let \nB ~ CrB={x\\ f(x) = x}, the set of ple, in definition A.1 both occurrences fixed points of f. Then of \n~ denote one-node trees. (i)B#@ [ii) Bis acpo  Throughout the paper, we use.thf (iii) The least element \n&#38;of B is de\u00ad tree and the term or eXPress~on terminology interchangeably. For example noted Yf and \nmay be computed by each symbol occuxring in di in the abov~ Yf = lub[fn(l)l n ~ 0} . example is in \nthe ith subtree of s and m a the ith operand of s.] We list several easy properties of cpo s and continuous \nfunctions. A.7 Lemma: Let A, B, C be cpos, f:A + B, g:B + C continuous. (i) gOf:A + C:x -g(f (x)) is \ncontinuous (ii) idA:A + A:x * x is continuous.  (iii) if A ~B then G:A + B:XH x is continuous . (iv) \nA x B is a cpo under component-wise ordering: <Xl,X2> ~ ~y~rY~> if and only if Xl 2Y1 and X2zY2. (V) \nnl:A X B + A:<x,y> ,+ x and n2:A x El + B:<x,y~~~ y are continuous (vi) Similar to (iv) and (v) but for \narbitrary products. (vii) if s ~ Ok, then s:D~ + Dn+l is continuous. A.8 Definition: The projection \npn:Dn+l+ Dn is defined by P. (x) =L Vx Pn+l(l) =1 )= pn+l(s(dl,.. .,dk s(pn(dl),... Pn (dk ). A.9 Lemma: \ndn, Dn L Dn+l r is continuous for all n. Pn Moreover, pn(x) ~x in D and if y ~ D, n+l y :x, theny ~pn(x). \n9 The intuitive idea of all this is as follows: Let D be the set of all finite or in\u00adfinite ranked trees \nover O u {1} where _i has rank O. If t ~,t2 ~ D, define tl ~ t2 if and only if t can be obtained from \nt 21 by replacing occurrences of J-by other trees. It may be verified that for fi\u00adnite trees, this is \nexactly the ordering defined in A.2. NOW if t ~ D is an infi\u00adnite tree, define the sequence <tO,tl, . \n..j as follows: ti comes from t by chopping off all branches after the first i levels and replacing removed \nsubtrees by~. It may be readily verified that ti ~ Di and ti = Pi(ti+~) for all i. But it may be shown \nthat the sequence thus constructed corresponds to a unique tree t ~ D. Thus we define t to be the sequence \n<t ~,tl,.. .>. . A.1O Definition: Let D = T(Q) be the set of all sequences <d O dl  e ox 1XD2X.. . \nsuch that dn = pn(dn+l) . Order D by <di> < <di ~ if and only if dn ~ dn for each n. Let Tn:D + Di:<di~d \ndn. 8 All Theorem: D is a cpo. Tn:D + Dn is continuous and satisfies ~ = pnown+l. If Eis acpo and {fi:E \n+~i} is aset of continuous functions such that fn = pn.f n+ 1 then there is a unique f:E + D such that \nfn = TnOf for all n. Pictorially : Theorem All may be summarized by say\u00ading that D is the inverse limit \nof {D.} [19]. D is also the d~rect llmit of ~{ Di} as we show below: A.12 Definition: Let in:Dn + D \n:x!-+ x n+l L*:Dn + D:x-<di> where xifib n di = Pi(Pi+~7. .. (Pn_~(x) )...) ) if { i<n. Q A.13 Theorem: \nEach ~ n:Dn + D is continuous andIn=I n+l ~n If t is a cpo and {gn:Dn + E}continu\u00adous functions such \nthat qn = then there is a unique g:D-+ E such that 9n = 90in. Pictorially, Proof: We may show that each \nd = <di>sat\u00adlsfles the property that d = lub({~n(dn)l n ~ O}). From this it follows easily that g may \nbe defined by g(d) = l~({gi(di)}). 9 We conclude with a recursive charac\u00adterization of D and two lemmas \nfor con\u00ad structing continuous functions on D. A.14 Theorem: D = {L} U {s(dl,. ..,dkl Ise Qk,di ~D}. . \nkA.15 Lemma:  or ach se k :D +D s continuous. Proof: s:D~ + Dn+l is continuous by A.7. Using All and \nA.13, s can be extended to a continuous function s:Dk + D. Our last lemma uses the particular inductive \nstructure of the Q constructed in 52.1 to build a continuous map similar to the one in A.14. A.16 Lemma: \nLet k > 0 and suppose that for each n ,...,n 1 k \u00ad f:n Xf X...X!2 + Rn+o +... in . 1 2 k 1 2 k Then there \nis a unique function $:Dk +D S-ach that ~(dl, ... ,dk) =1 if d. = 1 for any i 1 and %l(dll,..., dln ) \n  sk(dkl  dknk)) 1 = f(xl,. ..,sl) (d11,d12,.. .,dkn ) . k 9 Appendix B In this appendix we introduce \nthe no\u00adtion of regular tree. This idea has ap\u00adpeared in many place? in the literature under many guises. \nSee, for example, [11,13,14,16,17] . The notion of regulari\u00adty is reasonably robust in that different \ndefinitions yield essentially equivalent results. We present only the version that seems particularly \nconvenient for our purposes. Letd~D=T($l). We wish to give a notation for the nodes of d (cf. [18]). \nInformally, if u is a node of d, then there is a unique path ~ from the root of dtorl. ~ may be described \nby giving the sequence of choices made in passing from the root to rl. If the k sons of a node are labeled \n1 to k, this assigns to each node ~ a finite string ADDRESS(TI) of pOsi\u00adtive in cegers. (see figure B.1) \nThen for s (2 Q, let the occurrence language of s in dbe the set Ls(d) = {ADDRESS(q) In is labeled byS} \n. More formally, B.1 Definition: ([14]) For each s ~ $2Zy and TI > 0, define a mapping LS:Dn + 2 as \nfol;ows::/ Ls(l) = p ~ i.Ls(di) Ls(~(dl, . . ..dk)) = ~;~#s [ {c}~ &#38;i.Ls(di) [ i=l (.. 2.s * */ z+ \nis the set of finite strings of positive integers. where i.Ls(di) denotes the result of pre\u00ad fixing \neach string in Ls(di) by the number i. D z: is a cpo under the subset ordering (the2converse of the ordering \nin 62.2) and Ls is continuous and satisfies the hypo\u00ad theses of A.13. Thus :: can extend Ls to a function \nfrom D to 2 + . The reader may verify that this formal definition corres\u00adponds to the informal definition \nabove. We are particularly interested in the case where Lq(d) is a regular set. sup\u00ad pose only finitely \nmany s ~ Q appear in d. Then there is an n such that any s appear ing in d may be found in some Qk for \nk<n. Hence, Ls(d)&#38; {1,.. .,n} for each s in 0. B.2 Definition: d ~ D is regular if and only lf Ls(d) \n= ,U for all but finitely many s and Ls(d) is a regular subset of {1, . . ..n}* for all s (where n = \nmax{kl s ~ Ok andLs(d) #@} ). ~ v 51 0 1 5 5 1. ..- Figure 2.1 A Value The value Figure of figure 2.2 \n2.1 unrolled L Ri4?6 .. . . m= o 1 2 3 4 m = = = = . . . -L struct2 (J_ ,J_) struct2(int,ref~ struct2(int,ref \n struct2(int,ref . ref_L)) struct2 intrref ref struct2( ) struct2(J,-L)) struct2(~, struct2 int, . \n. . ))) Zr %kl--lll~lll VALUE(@~ Some typical Figure members of 2 .2.1 the cpo V of Values. \\ Q d z \no d z Figure 2.3.1 A list structure and its finite automaton A connected W mode m, w-I 1= L[7 Figure \n3.1 A value v which is not connected and an subvalue w s+ruc+J () (t)&#38; S+J..k inJ ($) addresses are \n~A* M)  Lf:z) shown in paren\u00ad theses ADDRESS(int) = s+ruc+a (Itf) (2111) ~ -h+(llfz) {1, 2m, 3} Figure \nB.1 The ADDRESS function on modes A mode and on symbols  //T1=____ raf .ll -T._ --\u00ad /#&#38;=\u00ad//%% k-%:.=, \n//7p.a   /+ks+ n x ref -1\u00adref ----> w : p levels 3 ref -T\u00ad % Figure 3.2 mode n, a value v:of\u00adand a \nsubvalue w of v of mode n inaccessible Figure B.2 which is not regular \n\t\t\t", "proc_id": "512976", "abstract": "", "authors": [{"name": "Marvin Solomon", "author_profile_id": "81547017856", "affiliation": "Cornell University", "person_id": "PP95029102", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/512976.512992", "year": "1975", "article_id": "512992", "conference": "POPL", "title": "Modes, values and expressions", "url": "http://dl.acm.org/citation.cfm?id=512992"}