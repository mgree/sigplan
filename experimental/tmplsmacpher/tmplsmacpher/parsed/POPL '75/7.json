{"article_publication_date": "01-01-1975", "fulltext": "\n Permission to make digital or hard copies of part or all of this work or personal or classroom use is \ngranted without fee provided that copies are not made or distributed for profit or commercial advantage \nand that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, \nto post on servers, or to redistribute to lists, requires prior specific permission and/or a fee.&#38;#169; \n1975 ACM 0-12345-678-9 $5.00 Actor Semantics of PLANNER-73 Irene Grelf and Carl Hewitt Massachusetts \nInsttute of Technology Cambridge, Abstract Wotk on PLANNER-73 and actors has led to the development \nof a basin for semantics of programming languages. Its value in describing programs wtth side-effects, \nparallehsm, and synchronization M discussed. Formal, definitions are written and explained for sequences, \ncells, and a simple synchronization primitive. Jn adcfit[on there IS discussion of the implications of \nactor semantics for the contt-oversy over elimination of side-effects. Introduct ton A fo! rnahsm fo!-semantics \nIS usually m some context which provldrs moovatlon. the purpose of be}ng the forma! definition a guide \nto programmers and Implementors. used as the means for describing properties or as a basis for a set \nof proof rules for developed and presented It might be designed for of a specific language as The formalism \nmight be of a particular program, verifying properties of programs. The motivation for this semantic \nbase not fol-some particular rather for a kmd of computation.:t The which revolve parallehsm, srde-effects, \nconcepts which must be available to paper is development of a programming language, but systems of interest \nare those and synchronization. The express properties of these systems WIII be presented and examples \ngiven. However, no particular programming language will be used. Our approach to the semantics WIII be \ncentered on the concept of an actor. An actor is simply an object which can send or recetve messages. \nAll elements of a syszem can be viewed as actors. The only activity possible is transmlssio,l of one \nactor to another actor. The energy for compotatlon comes from an activator which can follow the script \nof an actor. All programs and systems will be referred to as actors. The existence of more than one activator \nindicates parallelism, Continuations Once an actor, m, is transmitted to another actor, t, the activator \nproceeds by following the scr{pt this to be of any me as a model for m to have some structure. In message. \nIt will often also contain of i using information from m. For of computation, it must be possible many \ncases m will simply contain a a continuation part. Then m may : Actor semantics was not developed to \nexplain or define PLANNER-73. PLANNER-73 M a language dedicated to the direct realization of this semantic \nbase. Massachusetts be t-epresented as (apply: message (then-to: continuation)) If a mess?~e is sent \nwlthoot a continuation then all further instructions foi computation most be determmed by the target. \nSendlog a contmuat[on makes it possible to indicate another actor to which control can et,entually be \npassed (I.e., an actor whose script the achvator may follow). The reason that it M useful to be able \nto ralk, about conunuations in a semantic folrnallsm is that otherwise much of the contt-ol structlire \nhas io ren~~ln implicit In some!hlng like an evaluator or a compilel. COntIol strucrlite )s a pattern \nof passing messages m a compotatlon Mcqlly It should i]e possible to dtstmguish between, say, recursive \nand Itelatlve computations as being two different patterns of message passltlg beha VIOI-which can be \nprecisely chat acterlzed. An ordinary functional call to a function f can be implemented by passing a \ntransnussion with an explicit continuation to f. The continuation represents rhe actor to which the value \nof f should be sent. In actciition, other kinds of control structures can be expressed, such as jumps \n(m which no continuation u present) and co-routines [see Appendix] Distribution of Information Information \ncan be Ireptesented m various ways in an actor system. Often It 1Sdesirable [O represent knowledge redundantly \nwith different uses of the same Lrmwledge appearing m different gwlses in several places. How one might \nchoose to dlstribu[e it depends on one s purposes and the various uses to which the knowledge can be \nput. Concentrating on use as the key to representation of data structures contrasts with the approach \nof concentrating on the notion of type [van Wijtlgaarrfen, 19691. For example, In deflnin: Ilsts and \nthe usual operations on lists, there IS flexlblllty in how the information about the structure of lists \nmay be dlstilboted amon~ thrse operations and the data c%jects themselves. One posslblhty M thar the \nfunction call denoted by (Ienglh L) can directly produce the length of the list, L. That Is, the operation, \nlength. could be defined in such a way that it knows enough about how IISU are constructed (and about \nhow they can be decomposed) to be able to operate on the list directly and to compute its length. For \nexample, rhe operator length could repeatedly ask the list L for its next element and keep a count of \nthe number of times it succeeds. Altei-natively, the operaror length might know nothing about Ilsts and \nwhen sent one would have to depend on the list Itself to understand its own stl-ucture (and to understand \nit m terms of the concept length among others) What happens in this case is that (length L) tutns around \nand asks L for its lengthy This makes sense for fixed len~rh lists since for such lists the information \nnever changes and need only be compu!ed once. This message-passmg style of definition is particularly \nuseful for polymorphic operators in an interact ive system where new k!nds of objects which share some \nof the properties of Ilsts can be Cieflned at any time. It is desirable for (length L) to continue worklrrg \nand to extend correctly to new data types that are continually be)ng defined, When information can be \nput wherever it seems natural, polymorphic operators can be defined without deta}ls of type checking, \ninstead the operator can be applied to any type of data and (t ts up to the data to determine whether \nit is a reasonable opet-ator and If so how to perform its operation. Depending on circumstances, either \nstyle can lead to a more efficient implementation< but both should be representable. Behavior of an Actor \nActors are defined by their behaviors. A behavior is a partially ordered set of events which represent \ntransmissions. The behavior Involvlng only a single activator (process~ is a totalty otdered sequence \nof events. A description of the behavior of an actor has at least two uses. First, lt defines the actor. \nSecondly, it speclfles the properties of the actor which can be relied on in a proof about properties \nof another system in which it is contained, The event ot lentec! app:o~ch to scmantlcs M well suited \n{o the expression of meanings of programs with side-effects and parallelism. Rather than attempt!n$ to \nrecord the current state of the world in something like a state vector [McCarthy, 1964], changes in state \nare reflected In changes over time m the behaviors of the actor cells. The event ortented approach is \nparticularly useful when there is parallehsrn as well as change In state. If one tries to record all \npossible global states (including control reformation) for all the pa!allel processes one can become \nrevolved in a combinatorial exploslon of states. In order to describe the effect of a change in a s!ngle \ncell using global states, one would have to make the corresponding changes m the state mformatlon for \neach of the processes which could be active. Level of Detail in Describing Computations Another degree \nof flexlblllty avadable in actor semantics Involves the amount of deta !1 [o be included in specifications \nThat is, an actor can be specified (or its set of possible behaviors can be specified) In as much or \nas Imle detail as is desired. In describnrg an existing actor system this level of detail IS fixed by \nthe choice of a set of distinguished actors contained m the actor system. Only events mvolvmg these disringulshed \nactors WIII be recorded as behavior of the sjstem. To specify desired behavior of a system one writes \naxioms which any behavtor of the system must satisfy. At a very high level of detail these axioms WIII \nessentially be input-output constraints, i.e. what is to be done, not how. If more detailed specifications \nare made, the poss!bie behaviors which will realize those input-output constraints become more restricted. \nGenerally, in : Note that while the activator as a source of energy for computation may be analogous \nto some notion of process, the activator is definitely not meant to connote any of the following concepts \nprogram counters, pushdown stacks, or address spaces, order to prove that a set of specifications is \nsatisfied by a particular sYsrem, one examines the behaviors of the system at a level of greater detail \nthan that of the speclftcatlons and proves that these behaviors realize the behavior that IS required. \nThese points should give some Indication of how the simple actor concept can be used as a brslldmg block \nto define the higher level concepts which are useful descriptive tools. After the formal definitions \nof behaviors of actors in the following section, we will give sernant!c definitions of several familiar \nsystems, illustrating the application of these concepts, Behaviors Since actors are defin~d by their \nbehaviors, the concept of behavior WIII have to be defined. Behaviors consist of events. Definition: \nAn event is a four-tuple, (t m a ec> where t is the target, m is the transrmssion, a is the activator, \nand ec is the event count of the activator a. AS stated earner, an event is a description of the transmission \nof m to t by a. Since the events of a single activator are totally ordered in time, an event count is \nalso necessary to completely characterize a pat-tlcular transrmsslon. This means that if identical transmissions \noccur mvolvmg some particular, t, m, and u then the two can in fact be distinguished by the proper time \nfor ss at which they occurred, The event co~ltlt ec denotes the time immediately after ec. Therefore \n<t m a ec> Immediately precedes <t m a cc > and we can write <t m a ec> --> <t m a cc >, For events with \ndifferent activators, <t] ml al eci> --> <t2 m2 a2 ecy lf and only if at least one of tz, mz, az is created \nin the event <il ml al ecp. (Some actors have the ability to create new actors --cons-cell creates an \nactor with the behavior of a cell, cons-list creates a list, etc.) The transitive closure of the relation \n--> IS referred to as causally precedes i.e. for events El and E2 El --> E2 IS read as E} causally precedes \nE2! This is the ordering which can reasonably be considered to be a property of the actor system in question. \nThe relationship between causally precedes and the actual t!nle at which events occur M that if El --> \nE2 then El will necessarily occur before E2 In any computation. Other orderings may be imposed by axioms \nfor primltlve actors. (For example a synchronization primitive introduces constraints in the causally \nprecedes relatlon.) Definltlon: A m M a set of events partially ordered by the transmve closure of the \nrelatlon -->. An external environment for an actor system is a set of actors constituting the outside \nof the system. This includes an assignment of an initial set of activators and initial events for each \nactivator which will determine the beglntrlng of history for this system and environment. These initial \nevents will always be about transmissions which cross the boundary and enter the actor system, i.e. events \nwhich have a target mslde the system and a message outside the system. Histories are written for systems \nin environments, The behavior of an arbitrary system of actors can be extracted from the history by choosing \nonly those events which involve certain distinguished actors. Note: we will consider any new actor created \nby an event involving an actor m the system ~ to be in ~ also. Deflnmon: For any history of the actor \nsystem ~ the behavior of system ~ with respect to the set of dlstmgulshed actors A c ~ M the subset of \nthe events of the history containing events <1 m a ec> where either 1.t ism ~and misnot, 2.misIn Zand \ntNnot, 3.Either Ior mISIn A. Thus an event WIII be In the behavior if it describes either a transmission \nacross the boundary of ~ (i.e. with target inside and transrmssion outside or vice versa) or a transmission \nwith a dlstmgulshed actor as either target or message. This is how the level of detail of a behavior \nIS fixed by the choice of A, Note that if the set A IS empty then the mmlmalty detailed behavior results, \ni.e. the behavior of ~ as seen from the outside. Two actot-systems are equivalent with respect to some \nset of distinguished actors if and only If they have identical behawors with respect to that same set \nof actors. The choice of distinguished actors can make a difference m equivalence of ac!or systems. For \nexample, two programs for factorial can be seen to be equivalent at the level of input-output transformation \n(i.e. with no actors distinguished) even if a larger set of dlstmgulshed actors would rtveal one to be \na counhn~-up factorval and the other to be courrtmg-down. If mtiltlpllcatlon, represented by *, is considered \nto be a distinguished actor then in any behav[or of one factorial there might be a series of events <*[I \nI] a?>--> <*[2 I] a?>--> <x [3 2] a ?> and so on, while in the other there might be a series <* [n 1] \na ?) --> <x [n-l n] a j) --> {* [n-2 n*n-i] a ?). Behavioral Specifications of Systems Since behaviors \nof most actors are infinite obJects it WIII not often be possible to wrlre out completely the set of \nbehaviors of any given (or desired) actor. And lrr fact, many behaviors of a system will contain ]ncldental \nreformation about events in the environment. Instead, characteristics common to a7 1 behaviors of any \nactor system corrtairrirrg tfre actor in cwestion can be specified m the form of ax mms about events \nand the causally precedes relation. These are not Hoa,re [19691 style axioms about transformations of \npredicates over the occurrence of an operation or of a line of code, but rather are about the kinds of \nevents that can possibly occur in a computation and how they must be ordered. When an actor M being specified \nas a primi[ive, that is, when it M not defined In terms of other actors, the axioms describe condmons \nwhich must be satisfied by any h}story. Any actor can be described from the outside but lf an acror is \nto be implemented m terms of other actors It should be understood that between any two events there may \nbe an arbitral-y number of other events if we examine a history (or even a mot-e derailed behavior). \nHowever, all events related by causally precedes w]ll remam so related. When we do not wish to Imply \nthat E2 Immediately follows E3 we will write, ~ m the event count. In general ? can be used m any place \nin an event to indicate that we do not care about what actor or activator appears there. Recall that \nIf two events El and E2 are known to be in a behavior, we can write El --> E2 to indicate that El causally \nprecedes E2. When El and E2 have not previously been mentiOned. a statement of the form El --~ E2 should \nbe read as whenever EI is in, the htstory (behavior) then so IS E2 and El causally precedes E~ or alternatively \nas if El is m the history (behavior) it will cause Ez This is a way m which we guarantee response in \nfinite time from an actor. We will continue to use the Iabelllng convention on the transmissions actors, \nThe tt-ansmiss{ons are of the following general form: (apply: message (then-to: continuation) (else-to: \ncomplaint-dept)) We WIII often omit the else-to part when it is not of interest Sequences The following \naxioms about the behaviors of sequences summarize some of the familiar properties of sequences while \nillustrating the use of axtoms to constrain the kinds of behavior an actor can have. Note that since \nsequences are indeed functional objects they could have been described m more conventional mathematical \nnotation [Scott and Strachey, 1971], An actor which ts a sequence of n elements has the property (among \nothers) that it can be asked for m r th element, If a sequence IS re~resetlted by [Xl ,., Xn] thts property \ncan be specified by the following axiom: <[x, ,., Xn] (apply: [i] (then-to: c) (else-to: cd)) a ec> --> \n<c (apply: xi) Cscc ) forlsisn This means th~t at the level of detail at which sequences are black boxes \nthe e:cn[ in which th< iequence [xl . Xn] IS sent the message [i] and the contmuatlon, c, always causes \nas the next event the transmission of the ith element of the sequence to that continuation. This transmission \nhad three components. a message, a continuation, and a complaint department. This last actor is the one \nto which not-applicable messages are sent If the target actor does not hke Its message. For instance, \nfor i > n, it is the case that the sequence satisfies <[x, ,,. Xn] (apply: [i] (then-to: c) (else-to: \ncd)) a ec> --> <cd (apply: not-applicable) IX cc ). When using axioms as speclflcatlons of all possible \nbehav!ors one assumes that for any messages not explicitly dealt with the actor being described causes \nnot-applicable to be sent to the complamt department. Thus at this stage m the defmmon it can be assumed \nthat send]ng any transmission (apply: x (then-to: c) (else-to: cd)) 10 a sequence where x IS nor a sequence \ncontaining an integer, causes not-applicable to be sen[ to cd. Ce77s Cells do not flt as neatly mto a \nfunctional notatton. A cell is created with some mmal contents. It IS possible to ask for the contents \nof a cell, Uprface messages to that cell can chaaige its contents. Thus It is possible that several events \nin a single behavior can have ldentlcal targets (namely the cell) and identical transmissions and yet \ncause different events to occur. This occurs when the events have transmissions (apply: contents (then-to: \ncontinuation)) but the contents have been changed between the two events. In each case the continuation \nIS sent different actors. This means that cells are stale-effect primitives. Loosely speaking, an actor \nsystem has undergone a side-effect if its behavior has changed over time. In terms of functions, a side-effect \nhas occurred when the same procedure p has been called on two different occasions with the same argument \nand returned different values, This can be generalized to behaviors by looking at future evecrts rather \nthan just at values returned. Cells correspond to side-effect primitives in various languages. Therefol-e, \nit IS likely that most readers have relied on them m programming. We will now try to formulate exactly \nwhich properties we have been relylng on. First would be that creation of a cell (or allocation of space \nfor a cell) with its initial value should be an opetatlon guaranteed to take only finite amount of time. \nThis is also a dewrable property of updates and contents queries. (Anyone who has convinced himself that \na given program which contains asslgmment statements always terminates has relied on these properties). \nAxiom 0. - Cons-cell crea[es cells <cons-cell (apply: [x] (then-to: cl) (else-to: cdl )) a eel> ..> <~1 \n(apply: cell*) ~ eci > where cell is a newly created actor Axiom I: Cells can respond to contents queries \nand updates. <cell (apply: contents (then-to: continuation) (then-to: cd)) a ec> --><continuation ? a \ne~ > <cell (apply: [+-x] (then-to: continuation) (else-to: cd)) a ec) --> <continuation (apply: cell) \nc1 cc >. [Notice that a cell returns itself, not Hs value after update] Newly created actors are marked \nin events by an asterisk*]. It is often useful to be able to tell explicitly when an actor, a, appears \nfor the first time m event E since for any other event El in which a occurs It must be the case that \nE -+ El. : The next two properties that we rely on are related. Initially we expect contents quer}es \nto find the original contents in the cell. This should be true until an update transmission is sent. \nSimilarly, once an update transnussion is sent, say [-y] , we would expect to find Y In the cell unt}l \nit IS upd~. ted. Thus two more axioms are required, one about retrieving the initial contents and the \nother about retrieving the last contents stored. Axtom 2 says that If cell first appears in event El \nand if no update occurs between El and contents query E> then E3 will be an event which sends the initial \ncontents to the continuation, : This has Implications for the relauon knows about which can be formalized \nand wh!ch has implications for control structure recognition and implementation details. [See Appendix] \n70 Axiom 2 lnlrial Contents --A cell created with x as its contents will respond to the message contents \nwith x if no new value has been explicitly placed there yet. Suppose that PO --~ El IS in the behavior \nwhere E. is <cons-cell (apply: [x] (then-to: c) (else-to: cd)) al ecp El IS <c (apply: cell*) ccl ec~> \nIf thet-e are events E2, E3 where El --> E2 --> E3 E2 is <cell (apply: contents (then-to: c 1) (else-to: \ncdl)) cl ?> E3 is (cl (apply: y) a ?> and -3E(E[-->E-->E2) where E is of the fornl <cell (apply: [+ ?] \n(then-to: ?) (else-to: ?)) ? 7> then y=x. Axiom 3 makes a similar statement about the last contents stored \nby an update, rather than about the initial contents. The only significant change from th,e statement \nof Axiom 2 is that E. is <cell (apply: [+ x] (then-to: c) (else-to: cd)) a eel> Unfortunately these axioms \nare reasonable only in the absence of parallelmm since we are ignoring the fact that --> only refers \nto tmle cons[ramts Imposed by the program. In programs without parallelism, It IS the case that time \nconstraints imposed by the program form a toml order on events making these axioms sufficient. (Also, \ndue to the predictable nature of the cell m the absence of parallehsm Its use does not really increase \npower [See Appendix].) But in genel-al there may also be update events occurring independently of this \nordering. In a behav!or such as: <cons-cell (apply: [2] (then-to: c)) a ec) 4 <c (apply: cell*) a cc \n> 2 <cell (apply: [+ 3] (then-to: c1 )) at eel> N <cell (apply: [~ 4] (then-to: C2)) a2 ecz) 1 1 <c, \n(app y: cell) al ?) <C2 (apply: cell) a2 ?> 1 <cell (apply: contents (then-to: C3)) al ?> I <C3 (apply: \n?) al ?> The message place marked by the question mark can represent either the message ? or +. Which \nactor it will be is not a property of the svstern. Axiom 2 u ould force It to be 2 The obvious patch \nn to weaken the axiom from saying exactly what has to be returned to the conunuation, to just restricting \nthe set of actors It could be. Thu requmes adjusting the last line of axiom 2 to say that y is ]n the \nset {zlz=xv3E4suchlhat (E4 is <ceil (apply: [+ z] Ohen-to: c) (else-to: cd)) ? ?> A . (E+ --> E2 or E2 \n--> E4))). That is, Y can be the initial contents or any value stored in parallel with this activator, \nAx!om 2 should be adjusted similarly, such that the contents could be etther the contents stored in the \nlast upd~te event to causally precede the contents query, or m any update which is parallel to the activator. \nNow observe the following behavior: <cons-cell (apply: [2] (then-to: c)) # ec> 1 * <c (apply: cell*) \na cc ) d <cell (apply: [-3] (then-to: c1 )) al eel> \\ <cell (apply: [-5] (then-to: ?)) a2 ecz> 1 <cell \n(apply: contents (then-to: C2)) a ?> 1 <cell (apply [* 6] (then-to: ?)) sY2?> i <C2 (apply: ?1 ) rsl \n?> , # <cell (apply: contents (then-to: C3)) al 7, + <C3 (apply: ?2) al ?> In fact, out mtuit!on about \nthe contents of cells is that it is even more. restricted than stated, because If ?1 has value 5, then \n?2 can no longer have any value in {3, 5, 6}, but rather can only have values m {5, 6). There at-e many \nexamples m which we can make deductions that severely restrict the poss!ble contents of a cell. These \nare actually deductions about constraints In ~ddihon to those Imposed by --> as to the order in time \nin wh!ch events could have occurred. A first leaction to these examples might be that although the current \ndefinition jars wth mtomon, it may be reasonable to accept blzart-e behavior once non-determinism is \na possibility. Perhaps we simply should not rely on any meanmgful contents in tkus situation. However, \nth~re are times when we do rely on the behavior of cells even m the presence of parallelism. For instance, \nseveral solutions to the mutual exclusion of critical sections which do not make use of semaphores [Di \nJkstra, 1965; Knuth, 1966], implicitly make use of the cell s retaining its last contents stored even \nin the presence of parallelism. We found that the fact from which all our deductions about reasonable \nbehaviors were made was that rhe contents retrieved had to be consistent with some possible total ordering \nof all references to that cell In that ordering each time the contents is checked it must agree with \nthe last contents stored. Thus cells allow one to make deductions about the actual order m which events \noccur even though the events may not be necessarily ordered by -->. This is the property of cells which \nmakes It possible to use busy waiting to synchronize independent processes. Axiom 4: In any behav]or \ncontam!ng an actor, cell, created by cons-cell, it is possible to rieflne a total ordering, =>, on all \nevents which have cell as target. This ordering has the properties that if El and E2 have cell as target \nthen 1. E --> E2 tmphes El => E2 2.If El -->E where El = <cell (apply: contents (then-to: c)) a ec> and \nE = <c (apply: x) a cc > then x is the &#38; contents storpd with respect to =>. The last contents stored \nwith respect to an ordering can be defined for an arbitrary total ordering, ->, and used in axiom 4 with \nrespect to =>, Definmon: For the event E, the last contents stored in cell with respect to the ordering \n-> is defined to be either the inlttal contents, [f cell IS created m evetlt E. and there is no update \nevent E3 such that E. -> E3 -> E or the actor stored m update E@ if E. -> E and there IS no other update \nE3 such that E. -> E3 -> E. There can still be notl-determin ism since although in any computation the \nevents referring to a particular cell can be totally ordered, In fact, only parts of that ordering will \nbe forced by the actor system. Synchronization Synch rontzdtlon fills m the gaps in the total order. \nIt imposes total ordering on all events involving it. This means that if some synchronization actor always \nencased a cell it would never be necessary to worry about unordered updates and contents queries. The \nsynchronizarlon would Impose an ordering and the cell would always contain the last (in the causally \nprecedes relation) contents stored. This is part of a general form for specifying behaviors of any system \nusing synchronization There must be an axiom to the effect that an ordetmg M Imposed, and rhe axioms \nabout other properties of the system can be dependent on this ordering. One way to protect a cell would \nbe to define a primitive cons-protected-cell which can create cells and protect them. Externally cons-protecled-cell \nshould have behavior satisfying: <cons-protected-cell (apply: x (then-to: c)) a ec> --~ <c (apply: protected-cell*) \na cc >. In order to desct ibe the behavior of protected-cell, it is necessary to describe cons-protected-cell \nm some more detad. Although Its means, of synch t-on! zatlon can be left unspeclfled, the fact that it \ncontains a locally known cell and [hat this cell N encased m a protective actor which is known to the \nworld should be axiomatized. The behaviors of cons-protected-cell also satisfy <cons-protected-cell \n(apply: x (then-to: c)) a ec) --> <cons-cell (apply: x (then-to: c1 )) a ?> where c1 has behaviots which \nsatisfy: <c, (apply: cell*) a ?> --~ <c protected-cell* a ?), Now we can describe the behavior of protected-cell \nAxiom 1: From the outside a protected cel~ should look like a cell. <protected-cell (apply: contents \n(then-to: c)) U ec> --> <c (apply: ? (then-to: c)) a cc > and <protected-cell (apply: [+ ?] (then-b c)) \na ec> --z <c (apply: protected-cell) a cc >. The rest of the propel-ties of protecied-cell can be inferred \nft-om further details about what it does with its messages Axiom 2: Protected-cell sends messages to \ncell <protected-cell (apply: x (then-to: c)) a ?) --> <cell (apply: x (then-lo: Cx)) U ?> where <cxt \na ec> --> <c t a cc >. Thus protected-cell has side-effects because its behavior reflects the behavior \nof cell. Axiom 3: Protected-cell adds ordering to a behavior, If El --> E2 and E3 -+ E4 where E} \n= <protected-cell (apply: x (them-to: c1 )) al ?> E2 = <cell (apply: x (then-to: c1x)) a ?> E? = <protected-cell \n(apply: X2 Ohen-!o: C2)) U2 ? > E4 = <cell (apply: X2 (then-to: C2X)) a2 ? } then either E2 --> E4 \nThis says that somewhere in the interface between protected-cell and cell there N locking and unlocking \ngoing on which causes all events with cell as target to be ordered by causally precedes.. The exact mechanism \ncannot be seen at this level of detail but it exists. Axiom 4: Given El, E2. E3, and E4 as above and \nE2 --, E+, then in fact E2 --s <clx (apply: ?) al ?> --> E+ That is, the event m which a response is \nmade from the cell triggers protected-cell and allows another transmission to the cell. Thus c1 x must \nknow how to free the cell, Again, since the synchronization mechanism M primitive we cannot see the chain \nof events caus irrg the unlocking, It IS simply a property of this mechantsm that it causes the protected \ncell to let someone else get to the cell. Now, from the point of view of the cell, all events are totally \nordered by causally precedes. [f cells were always used inside protectors only the simpler single acuvator \naxioms for cells would be interesting. The more complex global ordering constraints can be deduced from \na combmed understanding of synchronization which imposes ordering and of cells which remember their .contents, \nConclusions We can express characteristics of a side-effect primitive in the p~esence of parallelism. \nSide-effects are described by delineation of possible changes in behavior rather than in a state vector. \nSynchronization can be used to impose additional ordering constraints. Further research is in progress \non applying this semantic fo{-mahsrn to str(lctored synchronization actors, similar to monitors [Hoare, \n197+]. Once a sufflclendy expressive set of descriptions is developed we will implement some systems, \nsuch as an airline ~e5ervatlon sYstem or a sokmon to the readers,writers problem, and pt-ove correctness \nrelauve to ihese descriptions. The formalism can also be used m comparative studies of the behaviors \ncharactetvstlc of a variety of control structures. An example of this kmd of work accompanies a result \non elimination of cells presented in the Append Ix. !Qf2z!x Concerning Side-Effects There M some controvel-sy \nat present over the desirability and necessity of use of side-effect primitives. A result to the effect \nthat cells (or other side-effect ptmmtives) can be eliminated from programs and that this can be done \nwlthln certain bounds on loss in efficiency M given before starting our dncussion of this controversy. \nAlthough this result may be of little help in deciding which way to program, it does show that it is \npossible to avoid side-effect primitives If that is your prefet-ence Th!s M the least which must be known \nbefore discussion is meaningful. Also, when considered in light of the actor semantics of !hls papet \nthis fact can be seen to be true even m the presence of Iteration, generators, and co-routines. We wdl \npresent the result with Informal argument rather than proof and then proceed with discussion of side-effects \nur varvous control and data structures, Theot-em: There IS a uniform procedure for eliminating cells \nfrom pt-ograms with side-effects It causes at most an (n * (In n)) vs n loss of efficiency in time, and \nat most a (c * m) vs M increase in storage where c is a constant. The general idea is that instead of \nhaving cells with contents which can be changed, the system has to keep track of these contents In some \nformat which can be referenced by the cell s name. We call this object a map. Then whenever the contents \nof a cell is needed, it can be found by asking the map. Whenever the value of a cell named n, is to be \nupdated to v, this change must be simulated without an actual side-effect. That is, the existing map, \nrnapl, can not be changed by the operation of simulatmg updating the conrents of a cell. Thn can be accomplished \nby creating a new map, which we shall call map2, whose behavmr is Identical to that of mapl except that \nwhen asked for the contents of nl it must respond with v. The new map, map2, must be the one examined \nm the future on all update and content operations on cells. All statements mvolvmg cells must have access \nto the current map. The way to give them this access is to always pass around the current map. This can \nbe done m apphcative programming languages by passing around an additional argument, namely the map, \nto ail .functlons. The map would then be available as a local variable in each procedure body. In m~petatlve \nIan,grrages this would be done by rewriting sequential code to pass the map from one statement to the \nnext so that the simulated sicfe-effec[s WIII propagate through the sequence. In both cases all creation \nof new cells, and all updating or accessing of the conrenrs of cells will be simulated by operations \non the current map. In an actor based Iangrw:e m which the basic operation is the rransrmttlng of a message \nactor to a target actor, the current map must be lnclucfecf in all messages. We WIII continue to use \nthe message passing metaphor to expla In the bound on loss of efficiency. In accordance with this decision, \ntime N measured by the number of transmissions which must occur, Transmissions can be thought of as taking \none unit of time, although an arbnrary amount of real time may pass between transrnlsslons, depencfmg \non how the program is being rurl, The acfdltion of the map to each ilansmission only linearly increases \nthe time taken, The imporranr mefflciency comes in the number of t] ansrnmsions needed to look up reformation \nin the map. The bound !s based on a tree structured Implementation of the map. It is well known that \na tree with n nodes can be searchea or copied in rime proportional to (In n). Thus at any [Jme if there \nare M nodes in the map a slmularlon of a cell statement (creahon, updating, accessing) causes extra tanstmlssions \nIn a number proportional to (In m). At the nth transmmion of rhe otvginal computation there can be at \nmost n transmissions in which a cell was created and the size of ,the map increased. The! efore a computation \nof n transmissions can be stmulated in at worst (n In rr) transmmons, The bound on space is based on \none possible physical storage art-a ngement fot-the tree. [f it M stored in the form 1$ then If the \noriginal computation created m cells (realized physically in m location) the s]mcrlation requires qm. \nImpl teat ions of the Theorem Ce77s [also called references, variab7es, and 7ocat ions in the literature] \nare objects whlrh are very commonly used in current generation programmmg. The very common use of cells \nneeds to be re-evalu~ted m the light of the discovery of styles of programming whrch do not t-equlre \nuse of cells The following are some points from borh sides of the argument, The use of cells can introduce \na time variant behavior in sYstems wtllch makes them harder to understand and debug. The tmle variant \nbehavior can make it much harder to prove and verify properties of progi-ams because some of the assumptions \nwhich have been established in the middle of a module as a result of conditional tests can be Invalidated \nby Invoking a procedure with side-effects. At the level of hardware the use of celts causes difflccrlties \nfor mcrltkprocessor computer systems which use buffer [cache] memories. Unless expensive precautions \nare taken, two processors might load the contents of a cell mto their respective caches and update the \ncontents Inconsisentty. In the actor model the intuitive riotton of one object pointing to another objecl \nhas been formalized into one actor knowrring about another so t!lat the former can send transmissions \nto the Iattel-. The use of cells can introduce cycles into the graph of the krrowirrg about relation \nfor actors maknrg the use of a reference count scheme for garbage collection impossible. On the other \nhand the reference count scheme for garbage collection Itself puts a substantial efficiency drain on \nsystems and may not be the most economical way to do garbage collection. An alternative scheme is to \nrun a conventional copying garbage collection in parallel with regular computation. Also a style of programming \nwithout cells creates more gal bage than a style using cells. Many progl-ammers have become accustomed \nto using cells in their progt-ams and are reluctant co change without a very persuasive reason just as \nmany of the programmers who have become used to using the golo are reluctant to give it up. On a more \nphllosophjcal level, some theoreticians note that a side-effect is a kmd of behavior that is very important \nin the world in which we hve and feel that this kmd of behavior should be directly reallzed In the computational \nprimitives available for use by programmers. Also there are cases, such as communication between two \nprocesses running m parallel, where cells are absolutely required. Programming Sty7es which do not use \nCells  Note that the Ehmmation of Cells Theorem applies to actor systems with expliclt access to transmissions \nas opposed to the A-calculus where there is explicit access only to the message part of a transmission \nThus it applies to systems with Iteration, generators,, and co-routines [e.g. systems as powerful as \nSIMULA-67 [Bmstwhistle et a 1, 1974 which use quasi-parallelism but not real parallelism]. Each of the \nabove control structures has its own programming style which does not revolve the use of cells. We iilusrrate \nthese styles and the trade-offs Involved using smy~le examples below This is similar to the use of continuations \nas In [Mazurkiewicz, 1971;Fischer, 1972]. Iteration and Side-effects Itet-ative control structures can \nbe realized i,l the ~-calculcrs and thus without cells. We will give a simple example to illustrate how \nthis is done (label itera!ive-factorial (A[n a] (if(n=l) then a else (iterative-factorial (n -1) (n * \na))))) Of course the above deflnluon M also a recursive definition of iterative-factorial In the sense \nthat it IS defined in terms of itse7f. However, In rerms of the actor semantics it is not a recursive \ndefinition In the sense of ALGOL-lihe languages =it does not use UP arbitrarily large amounts Of intermediate \nworking storage in order to do the computation. Using the actor semantics the fotfowing verston of factorial \nis recurs iire m both senses of recursive: (label recursive-factorial (A [n] (if(n=l) then 1 eke (n * \n(factOrial (n -1 )))))) The reason that storage increases is that the number of actors currently pointed \nto ( known about ) continues to increase. Actors which are polntect to are not eliglble for garbage collection. \nAfter formalizing the knows about relatlon we can demonstrate that iterative-f aciorial only requires \na bounded amount of working storage Conceptually every actor a consists of two components which are inextr \ni cab lY bound together: a data part and an action part [called a script]. The data of an actor consists \nof a finite set of actors known to the actor and the script of the actor consists of a recipe of what \nto do if the actor M sent a transmission. We shall indicate that an actor a knows a set of actors A by \nthe notation aA. A fundamental restriction of the actor model of computation is [hat an actor t can only \nbe sent a transmmlon If It is known to the transmitter More formally the restriction can be expressed \nas follows if an event (tIT mlM1 a ec> --> <t2m2 a cc ) occur in a behavior then, it Imust be the case \nthat t2 and m2 are either the same as ml or are known either to !1 or to ml. I.e. t2 and m2 are restricted \nto being in the set {ml} UTIUMl An actor aA created bY an event (tT mM a ec) is restricted to knowing \nabout a subset of the union of the actors known to IT and the actors known to m . I.e. A is restricted \nto bem~ a subset of T U M. Any ocher A event E which refers to a must be causally preceded by the event \nwhich created t, We postulate thar each newly created actor is not lden~ical to any pre-exlst!ng actor. \nMore formally, the requirement is that for any pte-exmtlng ac~or x It must be the case that x+a where \n= is the usual equahty relauon The above restrictions express a kind of locality or compactness< restriction \nfor actor systems. We can demonstrate that iterative-factorial does not use arbitrarily large amounts \nof working storage by analyzing the computations of iterative-factorial and observing the structure of \nthe knows about relation. In the course of the computation some tempera ry actors will be created but \nonly one such temporary will be needed at any given instant. This establishes an upper bound on the amount \nof temporary sto) age needed, Generators With and Without Cells We shall demonstrate how to define generators \nwith and without us!ng cells by def}ning generators that produce the squares 1, 4, 9, 16, etc. m sequence \non demand using a device called streams by Peter Landln [1965]. We WIII develop Iwo implementations that \nuse the same Interface with the polymorphic operator next which requests the next element. The interface \nu defined in such a way that it WIII work wjth streams with side-effects [Balzer, 1971; Krutar, 1971; \nand Mitchell, N711 as well as with functional streams [Lanolin, 1965]. The polymorphic operator next \nwhich makes this happen works by Irnmedlately turning around and passing the buck to the-supply using \nthe message (next: (ek-cowsldn-to: W-owhint-%t)) to pohtely ask the-supply for its next and to complain \nto the-complaint-dept If It doesn t have a next, A stream consists of two components a first which is \nthe next element in the stream, and a rest which is another stream that holds the rest of the elements \nafter the first. Below we define a stream that produces integers whtch are squares up to some limit. \nIt produces the next larger square each time It is asked for it, and returns the square along with a \nstream for generating more squares. To construct a stream of squares, receive a sequence of a limit \nof how many squares to produce and a count from which to begin producing squares. Then return an actor \nwhich, when asked either to produce the next element or to complain to a complaint-dept if it doesn t \nhave one, checks Ihe count !O see if it is greater than the limit and if so complains to the complainl-dept. \nOtherwise it returns a stream which has the square of the currenf count as its next element and rest \nwhich is a stream of squares with the same limit but whose count is one greater than the input count. \n Below we define a polymorphic operator print-elements which prints the elements of any stream which \nit is given. For example (print-elements (cons-stream-for-squarea (limit: 3) (count: 1))) will print \n1, 4, 9, and then print done. To print-elements of a stream receive a stream. Ask the stream for its \nnext. If it has a next, receive the stream and bind its first and rest. Print the first of the stream. \nThen print-elements of the rest of the stream. If the stream has no next, print done.  Below we define \na port [a stream with side effects] that produces square integers up to some limit. It produces the next \nlarger square each time it is asked for its next returning itself [with i~ behavior mod!f]ed by a side \neffect] as the rest. To construct a port for squares, receive a sequence of a limit of how many squares \nto produce and a count from which to begin producing squares. Let current-count be a cell that initially \ncontains the inifial count. Label the actor whose behavior is defined below as the-port. Return the-port \nwhich is an actor which, when asked either to produce the next or to complain to a complaint-dept if \nit doesn t have one, checks the contents of current-count to see if it is greater than the limit, and \nif so complains to the complaint-dept. Otherwise it increments the contents ot the currenf count. Then \nreturns a stream which has as its next element the square of the contents of current-count and rest which \nis the-port. Note that we have defined the port in such a way that the polymorphic opet-ator next can \nalso be used to obtain squares from it. Thus in many cases the decision of which of the two implementations \nof the square generator to use can often be deferred or even later reconsidered. For example (print-elements \n(cons-port-for-squares (limit: 3) (count: 1))) will also prwtf 1, 4, 9, and then print done. However, \nthe behavior of cons-stream-for-squares is not exactly the same as that of cons-port-for-squares. Once \na port for squares has been printed then it IS totally used up and has no more useful behavior. There \nis no backup capablhty built Into ports. The burden of providing such a capability if it is desired IS \nborne by the user of the port. Debugging a system where ports are used as the basic communication primitive \ncan be painful because useful debugging activities such as printing the contents of a port sornetmles \nhave unfortunate side-effects. In contrast a stream for squares does not change its behavior as a result \nof being printed and can be used for other purposes at the same time such as searching for successive \nsquares whose sum is an odd prime. Generators can always be implemented almost as efficiently without \nthe use of cells as by using cells except that avoiding the use of cells imposes more of a gat-bage collection \nproblem. Data Structures and Side-Effects The dla70~ue sty7e of programming used for generators is applicable \nto deflnms aclors which behave like a variety of data structures sUch as stacks, queues, sets, deques, \nand bags, making it possible to impfement them either with or without side-effects. For example (pop \nthe-stack) can rewrn a value of the form (next: the-top-of-the-stack (rest: a-stack-without-the-top-element)) \n The technique n also apphcable to Implementing control structures [such as ltet ation and co-routines] \nwhich can be implemented either with or without cells. Co-routines and Side-effects Co-routines are a \ncontrol structure which are often used by programmers in artificial intelligence and systems programming. \nThey have recently found mcreasmg popularity [Hewitt, 1971; Bobrow-Wegbreit, 1972; McDermott and Sussman, \n1972; Davies, 1972; Hewnt, Bishop, and Stelger, 191?] m knowledge-based applications as the founciatjon \nfor a dia?ogue-based programming style. Early Altlflcial Intelligence programs were mamly organized as \nmultj-pass heu~ isric progmnls consmng of a pass of urformation gathering, a pass of constraint analysls, \n?ncl a pass of hypothesis formation. It is now generally recognized that muk-pass organizations of this \nkind are inflexible because It IS often necessary for information to flow across rhese boundaries at \nall stages of the processing. Co-rootlrtes were introduced by Conway [1963] to convert the separate Iexjcal \nand syn[actlc passes of two-pass a compder mto a single pass complier. Using cells and gotos a co-routine \ncontrol structure [m a language like PAL, GEDANKEN, or CONNIVER] can be built to do this m the following \nway. We assume that there are four-cells known globally to both the lexical analyzer and the syntactic \nanalyzer of the compiler: messageto+exical: cell for messages to lexical analyzer messageto-~yntactic: \ncell for messages to syntactic analyzer resumelexical: ceil for resume-f] otnts of Iexlcal analyzer rasume~yntactic: \ncell for resume-fzolnts of syntactic analyzer The sysrem IS initialized by setting resurnelexieal and \nre$urne~yntactic to their respective starting Iocattons. To start the system execute the following: Update \nthe contents of the cell me$$ageto+exical to be start therr goto the contents of ihe cell resumelexical. \n Whenever the Iexlcal analyzer has parsed the next lexical item L then it can resume the analyzer by \nexecuting the following: Update the contents of resumelexical to be a-lexical-resume-Point which is defined \nbelow. Then update the contents of mes$ageto.~yntactic to be L and then goto the contents of resumesyntactic. \na-lexical-resume-point: Read the contents of me$sageto.lexical Return @exical as the value of this lexical \nroutine. Whenever the syntactic analyzer needs more input It can resume the lexical analyzer by executing \nthe following: Update the contents of resume$yntactic to be a-$yntacfic-ras~me-Poiot . which is defined \nbelow. Update the contents of messageto.lexical to be next and then goto the contents of resumelexical. \na-syntactic-resume-point: Read the contents Of me$sageto-$yntacfic L?.@2syntactic as the value of this \nsyntai rountine. etUrn In order to explain the Imphcatlons of passing transmissions instead of messages \nwe shall attempt to translate the above scheme into the h-calculus and show where It runs mto problems. \nThe idea IS very slmllar to [he one used m [he Ehmmatlon of Cells Theorem in that we will Increase the \nsize of all the messages passed around insole the lexical analyzer to include resume~yntactic and increase \nthe size of the messages passed m the syntax analyzer to include resumelexical. The system N started \nby sending [ start the-syntax-analyzer] to the-lexical-analyzer. Whenever the Iexlcal analyzer has parsed \nthe next Iexlcal lrem L then It can resume the syntax analyzer by executltrg the followlng: (resume~yntactic \nL (h [message resumesyntactic] [Valuelexical esumesyntacticl)) Unfortunately, the above scheme has \na bug in that by the rules of the h-calculus the value [Valuelexical esumesyntacticl will be sent to \nrhe syntax analyzer instead of to the lexical analyzer! The bug can be fixed to produce an efficient \nsolution by using Eandin s J operator as follows: (let {[back-to-lexical = J(X [x] x)]) ~resumegyfltactic \nL (X [message resume.-yn~acl;c] (back-to-lexical [valuelexical resutrre~yn,actic])))) Using tmnsmmons \nwe sh~ll indicate how to eliminate the side effects Involved In co-routinlng between the syntactic and \nlexical analyzers without severe loss of efficiency. To start the system send the message [ dart ihe-syntax-analyzer] \n to the-lexical-analyzer. Whenever the lexical analyzer has parsed the next Iex Ical item L, then It \ncan resume the syntax analyzer by sending the transmmlon (apply: L (then-to: continuation)] to the-syntax-analyzer \nwhere continuation is an actor which receives transmissions from the syntax analyzer and resumes the \nwork of the lexical analyzer Whenever the syntax analyzer needs more input fl-om the lexical analyzer \nIt sends a transmission of the following form to the-lexical-analyzer (apply: next (then-to: continuation)) \n When shou7d Cel 7s be Used? We would Ilke to re-emphasize that we do not advocate rewriting programs \nusing the algorithm described in the~oof. Such activity 1s just as pointless as Systematicaity rewriting \nprograms that use the goto construct by subsmuting while loops and boolean variables, Instead a style \nof programming that has certain definite advantages must be developed The theorem does not imply that \nthe cllalogue style of programrmng which we discussed above can always be used to ehmmate cells. Further \nresearch is needed on this q{iestlon.Therehasbeena sh[ft In formalisms for artificial intelligence away \nfrom heavy reliance on side-effects as illustrated by the development of the context mechanism m QA-4 \n[Rulifson, }972], defining PLANNER worlds In terms of actors [Hewitt, Bishop, and Steiger, 1973], and \nthe communtcatlon between PLANNER-73 plans in terms of message passing [Smith and Hewitt, 1974], A programming \nsryle that avoids the use of cells seems very. att!-active since the programs are just as efficient \nand seem more readable to many people. In the case of generators and co-routines, not using cells circumvents \nthe pltfails of using side-effects but Imposes some additional garba~e collection overhead. The proposal \nto cornple[ely avoid the use of cells m actors that behave like data bases seems more controversial because \na great many data-base apphcatlons req{lire parallel access to the data-base on the partof several acuvators. \nIn all such cases the cells used should be encased within some kind of modular synchronization primitive \nsuch as nron i tors [Hoare, 1974] or ser ia 7izers [Hewitt et al, 1974]. Acknowledgements This research \nwas sponsored by the MIT Artificial Intelligence Laboratory and Project MAC under a contract from the \nOffice of Naval Research. ,We would Iihe to thank Marilyn McLennan, David Marr, Allen Brown, Ben Kulpers \nand Drew McDermott for helpful comments which led to substantial improvements m the form and content \nof th}s paper, Bil>7iography Balzer, R. M. PORTS-A Method for Dynamic Interprogram Communication and \nJob Control 1971SJCC. Birstwhistle et al. SIM ULA Begin 1974. Bobrow, D. and Wegbreit, Ben. A Model \nfor Control Structures for Artificial Intelligence Programming Languages IJCAI-73. August, 1973. Conway, \nM. E, Design of a Separable Transition-Diagram Conlpller CACM. July, 1963. Davies, D. J. M. POPLER 1.5 \nReference Manuaf TPU Report No. 1. Theoretical Psychology Unit, School of At-tlf]clal Intelligence, University \nof Edinburgh. M? Y,< 1973. Dljkstra, E. W. Sohmon of a Problem in Concurrent Programming Contof CACM \n8,9. Sept, 1965. Fischer, M, J. Lambda Calculus Schemata ACM Conference on Proving Asser tlons about \nPrograms Jan. 1972. Hewitt, C. Description and Theoretical Analysis [Using Schemata] of PLANNER: A Language \nfor Proving Theorems and Manipulating Models for a Robot Phd. MIT. February, 1971. Hewitt, C., Bishop \nP., and Sretger, R. A Universal Modular Actor Formalism for Artificial Intelligence IJCAI-73. Stanford, \nCahf. Aug, 1973. pp. 235-245. Hoare, C. A. R. An Axiomatic Basis for Computer Programmmg CACM 12,10. \nOct. 1969. Hoare, C. A. R. Monltots: An Operating System Structuring Concept CACM 17,10. Oct. 1974 \nKnuth, D E. Addmonal Comments on a Problem in Concurrent Programmmg Control CACM 9, 5. May 1966. Krutar, \nR. A.. Conversational Systems Programming SIGPLAN Notices. Dec. 1971. Landin, P. J. A Correspondence \nBetween ALGOL 60 and Church s Lambda-Notation CACM. February, 1965. proving Algorithms by Tail Functions \nInformation and Control. 1971. Mazurkiewicz, A. McCarthy, J. A Formal Description of a Subset of Algol \nin Formal Language Description Languages for Computer Programming, North Holland Publishing Company. \n1964. McDernlott, D. V., and Sussman G. J. The Conniver Reference Manuaf Al Memo No. 259. 1972. Mitchell, \nJ. G. The Modular Programming System: Processes and Ports NIC 7359. June, 1971. 76 Ruhfson. Johns F, \nDerkwn J. A., and Waldinger R. J. QA4 A Procedural Calculus for Intuitive Reasoning Phd. Stanford. November \n1972. Scott, D. and Strachey, C. Towards a Mathematical Semantics for Computer Languages Oxford University \nComputing Laboratory. August, 1971. Smnh, Brian and Hewitt, Carl. Towards a Programming Apprentice AIS \nB Conference. July 1974. vanWijngaarrlen, A. , Report on the Algorithmic Language ALGOL-6$ Mathematische \nCentrum. 1969, \n\t\t\t", "proc_id": "512976", "abstract": "Work on PLANNER-73 and actors has led to the development of a basis for semantics of programming languages. Its value in describing programs with side-effects, parallelism, and synchronization is discussed. Formal definitions are written and explained for sequences, cells, and a simple synchronization primitive. In addition there is discussion of the implications of actor semantics for the controversy over elimination of side-effects.", "authors": [{"name": "Irene Greif", "author_profile_id": "81100427186", "affiliation": "Massachusetts Institute of Technology, Cambridge, Massachusetts", "person_id": "PP40027153", "email_address": "", "orcid_id": ""}, {"name": "Carl Hewitt", "author_profile_id": "81332503927", "affiliation": "Massachusetts Institute of Technology, Cambridge, Massachusetts", "person_id": "PP43124513", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/512976.512984", "year": "1975", "article_id": "512984", "conference": "POPL", "title": "Actor semantics of PLANNER-73", "url": "http://dl.acm.org/citation.cfm?id=512984"}