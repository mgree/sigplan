{"article_publication_date": "01-01-1975", "fulltext": "\n Permission to make digital or hard copies of part or all of this work or personal or classroom use is \ngranted without fee provided that copies are not made or distributed for profit or commercial advantage \nand that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, \nto post on servers, or to redistribute to lists, requires prior specific permission and/or a fee.&#38;#169; \n1975 ACM 0-12345-678-9 $5.00 COMPUTER ASSISTED APPLICATION DEFINITION Martin Mikelsons Computer Sciences \nDepartment T. J. Watson Research Center Yorktown Heights, New York ABSTRACT This paper describes a \nsystem being developed to bridge the gap between an application program and a user inexperienced in the \nways of computers. The user explores the characteristics of the available programs by a natural language \ndialogue with the system. The dialogue is supported by a knowledge base covering both the program semantics \nand the application domain. This paper addresses the problems of representation and inference involved \nin this approach and describes our solution for them. Introduction Most of the work in the area of automatic \nprogramming is aimed at the creation of new programs from a user s problem description. This view requires \nthe user to have a thorough and formal understanding of the problem domain. There is another class of \nusers without this coherent view of their problems who could still benefit from computer solutions. To \nthose users even the recognition of a suitable program in a catalog is a task comparable to programming \nsince the description of each program must be understood in the precise sense imposed by the semantics \nof programming languages. The selection of an appropriate application program can be viewed from three \ndistinct points of view: 1. A prospective customer has in mind some conception of the situation to be \nautomated. We call this the customer model. 2. The actual behavior of the program or programs under \nconsideration defines a second model, the ~rogram model. 3. Finally, the intended relationships between \nthe program semantics and the application domain form a third model, the application model.  It is important \nto stress the distinction between the program and application models. In traditional program practice \nthis distinction is confused by a forced and intimate relationship between the two. In most programming \nlanguages, the expression EXTPRICE = QTYORD * lJNITPR is intended to denote two distinct concepts. One \nis the pure programming notion, that the expression denotes that some program variable is the product \nof two other program variables. This aspect of the program statement remains unchanged if all the variables \nin the program are renamed systematically. The other notion our example is intended to express is the \nrelationship between the program and the application domain, that the variable in which the result is \nstored is -intended to represent the application quantity extended price and that it is the product of \ntwo program variables which represent respectively quantity Qrdered and unit price . In effect, traditional \nprogramming practice stores the application description in the variable names and comment fields of a \nprogram. The formal links between application objects and program objects are collapsed so that related \nobjects become identical objects. This approach may be both effective and desirable if programs are produced \nby programmers for use by programmers. It is definitely not appropriate for describing programs to the \nnon-programmer. One Solution This paper describes a system that automates the interaction between a naive \ncomputer user and a set of highly parametrized application programs. We have chosen business accounting \nprocedures as the application domain because bewildering number of variations of th; same basic processes \nhave been implemented in the field without exhausting all the possibilities. It is also an area in which \nthe program selection problem is felt very acutely since many businesspersons are unfamiliar with computers \nand the formal systems that drive them. In this context the program model is a representation of the \navailable programs and options. The application model describes the assumptions the programmers made \nabout the application domain and the links they intended between program and application concepts. The \nparameters themselves are program switches that also have an intended meaning. The selection of appropriate \nparameters, and thus the generation of a specific set of application programs, is performed through a \nnatural language dialogue between the customer and the machine. This discourse can be classified into \nthree major categories: 1. System driven questioning to obtain parameter values. 2. User driven questioning \nto explore the relationships between program and application concepts. 3. User driven questioning about \nprogram behavior answered by partial and conditional simulation of the incompletely specified application \nprograms.  To support this dialogue, we are building a Planner-like system <4> that contains knowledge \nabout both the program and application models in the form of data and inferential procedures. The system \nhas a sense of purpose derived from unspecified parameter values. The data base is a semantic net describing \nthe conscious knowledge of the system. The nodes of the. net are objects representing application and \nprogram concepts; the arcs of the net are attributes that represent relationships between concepts. The \nknowledge embedded in procedures is unconscious in the sense that it can be used to generate inferences \nand compute. values but cannot be explicitly discussed at the user interface. This paper discusses only \nthe internal organization of the system since it is both independent from and prerequisite to a natural \nlanguage interface. Many automatic programming systems <1, 5, 7, 8> are concerned with synthesizing programs \nfrom problem descriptions; their action can be viewed as finding the best match in the space of all possible \nalgorithms. In this sense the major matching burden is on the machine. In our system on the other hand \nthe machine has a detailed knowledge of the algorithms under consideration. The matching task performed \nby the user in the sense that ~~ decides whkther the functions provided by the machine have a useful \ninterpretation in his specific application domain. As a result, our approach shifts the major matching \nburden to the more effective processor; at the same time, since the knowledge in the machine is concerned \nwith a known program set, we know in adv-ante most of the concepts that need to be available to the machine. \nMeanwhile, program synthesis has not been excluded since any understanding of procedures that can be \ndescribed formaliy can be added to the knowledge base in the machine. Thus one of our goals is to produce \na versatile program understander and paraphraser that can be extended in an evolutionary way towards \na program synthesis machine. Background The immediate motivating ancestor of the system is the Application \nCustomizer Servicer ACS <6>, provided by IBM to System/3 customers. The service provides a customer with \nan installation-specific set of application programs on the basis of a detailed questionnaire. One difficulty \nof this approach is that many questions can be properly understood only after extensive reading of application \ndescription manuals. In fact, the questionnaire simply is a very specific programming language with very \ncomplex operators. In addition the effect of a choice of parameters is felt only after the custom application \nis installed in the customer s machine. The Business Definition System (BDS) <3>, developed at IBM Researchr \nextends the ACS methodology to a formal model building system. A model in the 13DS sense is simply the \nparametrized application program. As such BDS suffers from the same deficiencies as ACS at the customer \ninterface. The Business Definition Language does however provide an efficient abstract representation \nfor the kinds of programs and parameters useful in the business application domain. The work of Heidorn \n<5> on NLP demonstrates the effectiveness of model-driven questioning for program parameters. The NLP \ndata base is a network of concepts organized into a hierarchy by a superset attribute. Inferences are \nperformed by rules that test and modify the network. The MAPL and OWL systems of Martin <7, 8> at MIT \nqre examples of a similar approach to bridging the gap between an inexperienced user and a programming \nsystem. The work of Balzer <2> at 1S1 also views the program generation problem as one of building a \nmodel of the application domain. In fact the conceptual breakdown of the domain into relations and objects \ndescribed by Balzer is very similar to that of Martin. In the area of natural language interface, Heidorn \n<5>, Schank <11, 12> and Winograd <13> have all illustrated the importance of a model for proper understanding \nof natural discourse. In addition their work has isolated a number of important concepts and relations \nthat must be represented in any model. Basic Approach In order to have a system that can explain programs, \nwe need a machinable notion of program explanation. We can derive this notion by observing the informal \nprocess of program documentation. One component of program documentation is the programming language. \nThe language semantics are usually described by relating formal properties of the language to the general \napplication situations in which they are most useful. The two primary objects of BDS semantics, the document \nand the transformational step, are explained in terms of business forms and clerical operations that \nrelate their contents. A particular program is further documented by relating specific choices of language \ncomponents to their intended usage through the choice of variable names and the insertion of comments. \nbJe recognize this two-level program description practice when we distinguish between good and bad comments. \nIf the statement A=B+C is explained by set A to the sum of B and C we call the comment trivial or redundant \nsince the explanation is implicit in a consistent usage of the notions of assignment and addition. Our \napproach in this paper is to choose a representation for the elementary objects of the programming language \nand the application concepts they are normally expected to represent. A specific program is an appropriate \nselection and combination of program components. As such it is explained at an elemetary level by the \ncorresponding selection and combination of application concepts. A complete description of the oromam \ncontains, in addition, link; to application concepts that establish the arbitrary intentional relationships \nbetween the program and the application domain. Basic System Facilities The underlying data structure \nin our system is a network of labelled nodes interconnected by labelled directed arcs. Nodes represent \nobjects or concepts that the system knows about, arcs represent relations among objects. The active knowledge \nof the system is stored in procedures identified by patterns of nodes and arcs. When a search or update \noperation is performed on the network, procedures with patterns that match the affected parts of the \nnetwork are executed. In qeneral structure the system resembles most Planner-like knowledge systems in \nthe field. Several set-theoretic notions are built into the system and constrain the usage of the network. \nA proper object is a node that represents some uniquely identifiable object in the domain of discourse. \nSome potential proper objects might be John Brown, the one contemporary with Abe Lincoln or the billing \nprogram BILL437 . A general object represents a more abstract entity. Some potential general objects \nare an apple , someone named John Brown or a billing program . A general object is a node that represents \na typical element of some set, or alternatively a variable ranging over a set. Every object in the network \nis either general or proper. General objects can be related by the fact that one is a more constrained \nspecification of another. For example a red apple is more specific than an apple while neither expression \npins down a unique real apple. We say the more specific object is a general instance of the other. If \na proper object satisfies the constraints of some general object X we say thak it is a proper instance \nof x. The semantics of these relations are built into the system. All other relations are defined in \nthe model and appear in the network as labelled arcs. To make patterns and diagrams of the network consistently \nreadable, we adopt the convention that if objects X and Y are linked by an arc from X to Y labelled with \nxxx then we say that YisxxxofXor XhasxxxY xxx is an attribute of X X has an xxx attribute with value \nY Y = xxx(x) and X = (xxx) (Y) Attributes are further classified into relations and properties. Relations \npoint to nodes in the network; properties point to Lisp data. Since attributes may be viewed. as objects \nwith attributes of their own, the above classification is part of the model GI structure. Under these \nconventions, general instance and proper instance are represented by labelled arcs pointing to the more \nspecific object; the labels are GI and PI respectively. A general object is then an object that is a \nGI of some other object or that has one or more GI attributes. A proper object is one that is a PI of \nsome other object. T.o simplify illustrations of the network, we adopt tne convention used in Figure \n1 . Unlabeled single line arcs denote GI relations, and unlabeled double line arcs, PI relations. APPLE \n/ \\\\ RED YELLOW MIXED $! ii/\\ DEL ROME DEL JON MAC SPY Figure 1: A simple GI tree We should note that \nthe GI relation is the transpose of the a kind of or AKO relation used by Martin <7, 8> and by Balzer \n<2>. PI is the transpose of the relation IS-A. The advantage of using the labels GI and PI is that khey \nfit a consistent linguistic pattern for reading the network. Since the GI relation implies a subset relationship \nbetween two concepts, the GI arcs in the network define a partial ordering of the nodes with a natural \ndefinition of GI ancestor and descendant. The immediate attributes of a node are the labels of the arcs \ndirectly connected to the node and Dointin~ awav from it. The inherited attributes Gfa-node are the nnmedlate \nattributes of GI ancestors of the node. In addition to a label, arcs in the network may be associated \nwith a Lisp expression. The relation then holds only when the expression evalutes to a non-NIL value. \nThese conditional arcs are used to express relationships that depend on the state of the model or on \nthe values of model parameters. Each node is implemented as a unique Lisp identifier. In addition each \nnode has an associated label, a Lisp identifier, not necessarily~ue, that can be used to refer to the \nnode. A node can be referenced by its Lisp name or more commonly by its label. To make a reference by \nlabel unique the notation label/ancl anc2 . . . / is used to denote a node labelled label with successive, \nbut not necessarily contiguous, GI ancestors ancl r anc2 , . . . . To specify a proper object we use \nthe notation label//ancl anc2 . . . / In both cases the label may be omitted to specify any object with \nthe specified ancestry. Whenever a label notation is used, it is assumed that the locally specified GI \nstructure is sufficient to distinguish between referencing and defining c6currences. This notations allows \nlabels to reflect only the local classification choices instead of the entire taxonomy. With respect \nto the simple GI structure in Figure 1, we can reference the end nodes with DEL/RED APPLE/, ROME/RED \nAPPLE/, ROME/APPLE/ and so on instead of creating labels such as DEL-RED-APPLE. We read ROME/APPLE/ as \nROME, a kind of APPLE . We read /APPIJ3/ as some GI descendent of APPLE , i.e. some object of kind APPLE \n. Since we chose in our example to classify apples first by color and then by variety, the two occurrences \nof DEL in the figure reDresent distinct concepts. As a result ali uses of that label must always be properly \nqualified. Model .Manipulation The knowledqe stored in the network is manipulated by search and update \noperators. The knowledge is enhanced and expanded by procedures that are invoked when a primitive look-up \noperation is insufficient. An argument common to all the manipulation operators is the object specification \nthat locates an object in the network. An object specification is a pattern, comparable to a MERLIN beta-structure \n<10>, of the form :< obname anamel obspecl aname2 obspec2 . . . > where obname is an object reference, \nanamei is the label of an attribute (or of its transpose) and obspeci is an object specification. An \nobject specification describes a node in the network by a sequence of attribute/value descriptions. Since \nthe order of the latter is not significant, an object specification is somewhat more general than a Planner \npattern. Any part of the specification can be a variable that is evaluated or assigned following Planner \nconventions. An object specification can be viewed as a description of a part of the network. As a search \nPattern, a specification can be viewed as a template of nodes and arcs to be matched in the data base. \n Update operators add or delete objects and arcs in the network. Associated with each update operation \nare two kinds of procedures. Verifying demons are activated by an update pattern before the update operation \ntakes place. If a verifying demon returns failure, the update operation fails. Update demons are activated \nafter an update has taken place, they are used to generate the consequences of the operation in the same \nway as Planner antecedent and erasing theorems. There are three search operators. MATCH attempts to locate \na specified object and attribute pattern. A successful match assigns values to variables in the pattern. \nEXTEND generates the longest possible path alo,ng a given attribute. This operation is most often used \nwith an implied attribute, i.e. one not explicitly stored as an arc, but defined by procedures. Figure \n10 gives an example of an application of EXTEND. EXPAND is a breadth-first search operator that returns \nthe set of nodes reached by a given attribute. While execution of all operations in the system takes \nplace in the normal Lisp control environment, access to the network is structured into contexts. Except \nfor the lack of control reformation, our notion of context is identical to that in Conniver <9>. A search \nstatement may sometimes be satisfied by several parts of the network. In that case, the statement acts \nas a generator. Each context can harbor exactly one generator; if a new generator must be created the \nolder one is destroyed. The action of generators is best illustrated by a program example. The programs \nin Figure 2 scan the structure in Figure !; loop (a) will scan the descendants of APPLE and print the \nlabels RED, YELLOW and MIXED. Since loop (b) contains two generators, each will cause the other to be \ndestroyed. As a result, 100P (b) will print an infinite sequence of DELs. The third loop uses the context \nmechanism to concatenate the two generators and print DEL/RED/, DEL/YELLOW/ and SPY. LOOP LOOP LOOP : \nMATCH : MATCH : MATCH ?X/APPLE/ ?X/APPLE/ ?X/APPLE/ FAIL END; FAIL END; FAIL END; :SPROUT; : MATCH : \nMATCH ?Y/?x/ ; ?Y/?x/; : POP; (PRINT?X) (PRINT ?Y) (PRINT ?Y) (GO LOOP) (GO LOOP) (GO LOOP) END END END \n(a) (b) (c) Figure 2: An Example of Generator Action Viewed as generators, MATCH operations generate \nalternative assignments for the variables in a pattern, EXTEND operations generate alternate paths, and \nEXPAND operations generate expanding sets of nodes. In all cases failure and success are only messages \nthat can be tested by the programmer. There is no automatic state saving or backup at the main program \nlevel. Program Model Representation The organization and usage conventions for the program and application \nmodels also embody a substantial amount of knowledge. This knowledge is as inflexible as the system \nsemantics and embodies our best guess at a suitable framework for solving the program description problem. \nThe program mode 1 consists of all the GI-descendants of a general program object POB and the application \nmodel is all the descendants of AOB . The only relation connecting program and application nodes is the \nrelated application object (RAO, or label * ) arc that points from a program object to a related application \nobject. The GI arcs emanating from POB form a tree that reflects the type structure of the BDS language. \nFigure 5 shows part of this structure. The static description of the actual programs in the model consists \nof a collection of instances of the program object types. The interactions among program components are \ndescribed by relations. For data structures the main relation is PART that points from a composite data \nobject to its components. Repeating groups have a DEFINITION attribute that points to the structure of \na typical document. The relationships among data items are exrmessed by CAUSALITY and DERIVATION attributes \nthat express the associated BDS concepts. Program steps and data are related by the DATAFLOW relation \nwhich points from data to program in the case of inputs and from program to data in the case of outPuts. \nSince BDS program steps are normally activated by data flow the outputs and their causality and derivation \nin terms of the inputs completely describe the effect of a program. Some programs may also have a TRIGGER \nattribute that points to some event that is the trigger for the execution of the program. Program model \nparameters are typically expressed as QUEST objects that represent a question to be asked the user. For \nexample, a SEL or selector question has a SELECTED-OBJECT attribute that usually points to a data structure. \nThis construct causes the system to ask the user whether he wants the associated report to be produced. \nPointers to the data object are represented as conditional arcs that test the state of the question object. \nSeveral Program model attributes are not expressed directly as arcs but are stored in search demons. \nThe attribute FREQUENCY captures the notion of frequency of generation or execution. The frequency of \nan output document is the frequency of the program that produces it. The freqU;~cY of a program may be \ndetermined the frequency of its inputs or by the frequency of its triggering event. The ~~~;;~ures in \nFigure 10 embody these Two attributes, REALIZATION and ACTIVATION, play an important role in the symbolic \nexecution of the program model. REALIZATION is a data attribute and points to a specific data item containing \n. actual. values: ACTIVATION is a Pro9ram attribute and points to an activation of a program step. The \nsimulation is performed by update demons associated with these attributes. It is initiated by the creation \nof a realization or activation. It then proceeds through the data flow graph of the application creating \nadditional realizations and activations as needed. A simplified implementation of this process is illustrated \nin Figure 9. A simulation is normally performed in a new context so that the resulting network components \ncan be conveniently erased. When a conditional arc is encountered, a new descendent sibling context is \ngenerated for each possible value of the conditions. Application Model Representation The application \nmodel, like the program model, consists of all GI descendants of a l!Ao~,,. primitive object, in this \ncase However, while the program model is tightly organized by the semantics of the programming language, \nthe application model consists of a loosely organized collection of concept groupings. * PAIR//HET/ \n//iiV TUPLE/ PART PART NTPAR \\ / i Pi//INTEGER/ ~//CUSTNO/ I , P2//sTRING/ ~ 1 * Figure 3: Relationship \nbetween program and application model structures  The components of a program description are related \nto the appropriate application concepts; tfiese are then organized into an explanation by the structure \nof the program itself. Figure 3 illustrates this mode of description for a simple heterogeneous data \nobject PAIR. Figures 6, 7 and 8 show a more complex example. The explanation that PAIR represents-the \naddress of a customer is derived by examining the explanations ( * attribute values) of the components \nand data types of PAIR. The only application model relationship specific to PAIR is the arc that specifies \nwhich component of PAIR is the entity description. The main concept used in explaining data groupings \nis the attribute-value (AV) or the attribute-value-time (AVT ) n-tuple. One or more fields of the data \nstructure are identified by the ENTPART attribute. The values in these fields identify an entity such \nas a customer, transaction, or inventory item. As a result, the target of the ENTPART attribute is an \nobject of the kind MAP. It is a mapping from the values described by the data type of the corresponding \nfield, to the kinds of objects specified by the RANGE attribute. The remaining components of the structure \nare explained by pointing to ATTR objects. These describe attributes of the entity specified by the n-tuple. \nAVT objects are further described by the TINEPART attribute which points to the explanation of a date \nfield in the data structure. This date is the time at which the n-tuple is current. The various forms \nof business documents are classified under the node DOCUMENT. FILE documents are retained and updated \nin the firm. REPORT document are classified by distribution properties such internal (INT) or external \n(EXT) . INVOI% and STATEMENT are two common external document categories. Both have a DEST attribute \npointing to CUST, to indicate their destination. A Program Description Example Figures 4 to 10 show some \nof the objects, relations and procedures necessary to describe a simple BDS program. The program performs \na simplified version of the processing done in the Accounts Receivable department of a business. Payments \nand invoices are accumulated in each customer s master file record. At the end of each month, the payments \nand orders are reconciled and a statement is produced for each active customer. The past due balance \non the $tatement is eitiier zero or the positive difference between the balance carried forward and the \npayments made since the last statement. The current balance is the remaining amount due. This simple \nmodel can be used to answer a wide variety of questions about the structure and purpose of the data and \noperations involved in the above situation. In particular, we can see the Wladawsky for many livelv discussions \nvalue of the EXTEND operation over a during which many of the ideas in this search operator that only \nreturns the paper were refined and elaborated. result. The value of the statement :EXTEND FREQUENCY D17; \nis the list (MONTH EXTENT MLY * PIT TRIGGER PI References (DATAFLOW) D17) which records not only the \nresult of the 1. Balzer, Robert M. , A Global View of search but also how it proceeded. As a Automatic \nProgramming, 3 IJCAI , result we can derive the fact that the Stanford, August 1973, 494-499. frequency \nof producing statements can be varied by changing the period (or extent) 2. Balzer, Robert M ., et al., \nof the external event that control P1. Domain-Independent Automatic Programming, USC/Information Sciences \nInstitute, ISI-RR-73-14, January 1974. Conclusion 3. Hammer, M.. M. , Howe, W. G., and The system described \nin this paper is Wladawsky, I., An Interactive Business currently under implementation at IBM Definition \nSystem, SIGPLAN Symposium Research. Our aim is to evolve a sequence on Very High Level Languagesr March \nof experimental systems to explore the 1974. basic questions posed by our intent to bridge the gap between \na customer s 4. Hewitt, Carl, PLANNER, A Language for informal understanding of an application Proving \nTheorems in Robots , 1 IJCAI , area and a program with useful effects in Washington, D. C., 1969, 295-301. \nthat domain. We are concentrating on the local description of existing programs, .5. Heidornr G. E., \nNatural Language and not the synthesis of programs from Inputs to a Simulation Programming descriptions. \nThe former can help a naive System, Technical Report user recognize a suitable program while NPS-55HD72101A, \nNaval Postgraduate the latter requires a coherent and formal School , October 1972. understanding of \nthe problem on the user s part. 6. IBM Application Customizer Service Application Description, Form number \nBeyond our initial goal of discussing a GH20-0628. parametrized application a number of extensions are \npossible. The most 7. Martin, William A., OWL, A System for immediate possibility is to use the Building \nExpert Problem Solving knowledge in the application model and Systems Involving Verbal Reasoningr extend \nthe system to more programs. In Course 6.871 Notes, MIT, 1974. this direction one can also think of extending \nand abstracting the program 8. Martin, William A., Project MAC model to allow construction of the Progress \nReport X, July 1972 -July ultimate program model through the same 1973, Automatic Programming , natural \nlanguage interface. 170-192. Finally one may take a step closer to 9. McDermott, Drew V., and Sussman, \nautomatic program generation by allowing Gerald Jay, The Conniver Reference users to describe algorithms \nthat can be Manual, MIT Artificial Intelligence safely inserted into the program model. In Memo No. 259, \nMay 1972. the limiting case, the program model then becomes a description of the semantics of 10. Moore, \nJ.r and Newell, A.t How can some programming language together with a Merlin Understand? , Department \nof library of program schemas. Computer Science, Carnegie-Mellon University, Pittsburghr Pennsylvania, \nThis paper is primarily concerned with the November 1973. conceptual structures and inference mechanisms \nnecessary under the covers of 11. Schank, Roger C.r The Fourteen an effective program describing system. \nAt Primitive Actions and th~ir the same time a number of difficult Inferences, Stanford AI Lab. Memo \nproblems must be solved at the user AIM-183, March 1973. interface to make the system usable by a user \ntruly naive of the idiosyncrasies of 12. Schank, Roger, et al., MARGIE: Memory, computer systems. Analysis, \nResponse Generation, and Inference English, 3 IJCAI , Stanford, 197~v 255-261. Acknowledgement 13. Winocmad, \nTerrv, Understanding Natural The author wishes to thank his co-workers Lang~agei Acad&#38;ic Pressr 197~. \nGeorge Heidorn, Peter Sheridan and Irving 1 Master s 1 Statement s 2 cust# 2 cust# 2 Date 2 Date 2 Address \n2 Address Monthly Master s 2 Balance 2 Balance fwd 2 Cur invoice s 2 Cur invoice s Operator / 3 3 Invoice# \nDate 3 3 Invoice# Date Monthly 3 mount 3 Amount Run date > statement 2 Payment s 2 Payment s printing \n3 Date 3 Date step 3 Amount 3 Amount I 2 Past due ~Statement s 2 Current due 2 Total due w Figure 4: \nData flow and structure for a simple A/R application ~ ONEPER ~PA.M~pOB\\\\~>MpOUND SIMPLE QUEST ATTRIBUTE \nMULTCH c):,//EpGRo[~\\ET ~>:y RELATION TRANS li/Rr\\DEF~T~LJART c STRING DATE INTEGER / \\ M JUL GREG \nSCALED ~ DOLLAR~2 Figure 5: Program model type structure -JZ==== 0 \\~ TUPLE DOCUMENT PERSON / %7 7 ( \nJ~ 4L ,, AvT#\\ MONEY TIME FILE REPORT CUST EMPL \\ /\\ /\\ J CUSfNO INVNO INT PT IN t I ATTR Jh lNT IL xT> \nPER REL INiOICE ST-iTEMENT DATE ADDR AMNT --%&#38; ,ALDUE ~ PAST PAY~ TRANS ~ PURCH CURNT Figure 6: \nPart of the application model type structure 240 :ADD :< P1//TRANS STEP/ (DATAFLOW) FI DATAFLOW D17 (DATAFLOW) \n;<SDT//DATE/ (DATAFLOW) :<PIT/EXT STEP/ * OPER >> TRIGGER :<//EXT EVENT/ * MLY >>; :ADD :<F1//FILE/ \nDEFN :<D1//HET/ * CM//AVT TUPLE/ PART :<DIF1//INTEGER/ * CM//CUSNO/ > PART :<D7F2//GROUP/ * ADDR/ATTR/ \n> PART :<DlF3//DATE/ CM//DAT E ATTR/ > PART :<DlF4//DOLLAR/ * CM//BALDUE/ > PART :<DlF5//GRouP/ DktiN \n:<DlF6//HET/ * CMI//AVT TUPLE/ PART :<DlF7//INTEGER/ * CMI//INVNO/ > PART :<DlF8//DATE/  * CMI//DATE \nATTR/ > PART :<DlF9//DoLLAR/  * CMI//PURCH ATTR/ > >> PART :<DIFIO//GROUP/ DEFN :<DIF1l//HET/ * CMP//AVT \nTUPLE/ PART :<DlF12//DATE/  * CMP//DATE ATTR/ > PART :<DlF13//DoLLAR/  * CMP//PAY ATTR/ > >> >>; Figure \n7: Detailed structure of to application :ADD :<CM//AVT TUPLE/ ENTPART CM//CUSNO/ TIMEPART CM//DATE ATTR/ \n> ; : ADD :<CMI//AVT TUPLE/ ENTPART CMI//INVNO/ ENTPART CM//CUSTNO/ TIMEPART CMI//DATE ATTR/ >; : ADD \n:<CMP//AVT TUPLE/ ENTPART CM//CUSTNO/ TIMEPART CMP//DATE ATTR/ >; :ADD :<D17//GROUP/ CAUSALITY :<//SIMPLE \nONEPER/ ITEM FI > DEFN :<D17//HET/ * ST/lAVT TUPLE/ ,, tiiRT :<D17F1//INTEGER/ * ST//CUSTNO/ DERIVATION \nDIFI > PART :<D17F2//GRouP/ DERIVATION DIF2 > PART :<D17v3 DERIVATION SDT * ST//DATE ATTR/ > :<D17F3 \nDERIVATION D IF3 > PART :<D17F4 DERIVATION D1F4 > PART :<D17F 5 DERIVATION DIF5 > PART :<D17FI0 DERIVATION \nDIFIO > PART :<D17F14//lloLLAR/ * ST//PASTDUE ATTR/ DERIVATION (N-PROG ( (x DIF4) (Y D1F13) ) (MAx o \n(DIFF x (suM y))) )> PART :<D17:15//DoLLAR/ ST//CURDUE ATTR/ DERIVATION (N-PROG ( (PST DIF4) (NEwDIF9) \n(PY DIF13) ) (MAX O (DIFF (SUM NEW) (mx o (DIFF (SUM PY) PST)) )) ) > PART :<D17F16//DoLLAR/ * ST//BALDUE \nATTR/ DERIVATION (N-PROG ((X D17FIO) (Y D17F 15)) (PLUS XY) ) > >>; the program model with links model \n: ADD :<MLY//REL l?TIN TIME/ EXTENT MONTH//STD INT VALUE/ OFFSET MONTH//STD INT VALUE/ >; : ADD :<ST//AVT \nTUPLE/ FORM STATEMENT ENTPART ST//CUSTNO/ DATEPART ST//DAT E ATTR/ >; Figure 8: Details of application \nmodel :DEMON ADD ;<?x (REALIZATION) ?y When a realization of a data object is DATAFLOW ?Z> created attempt \nto activate the program to : ADD :<?u (ACT1VATION) ?Z>;: which the data is input. :DEMON VERIFY ADD \n:<?x (Activation) ?y> This demon is called by the system LOOP whenever an attempt is made to add an :MATCH \n:<?Z DATAFLOW ?Y> activation to the network. If the demon FAIL ALLTHERE; fails then the add fails. Otherwise \nthe : MATCH :<?Z REALIZATION ?U> new node is added to the network and other FAIL NOTYET RANGE 1; demons \nare invoked to expand the (GO LOOP) consequences of the addition. NOTYET :EXIT FAIL; This procedure scans \nthe inputs of the ALLTHERE program ?Z and succeeds when all of them :EXIT SUCCEED;; have been realized. \n:DEMON ADD :<?x (AcTj-vATIoN) ?y> To continue the simulation, when a program LOOP activation is created, \nthis demon creates : MATCH :<?y DATAFLOW ?Z> a realization of each output of the FAIL ALLDONE; program. \n: ADD :<?u (REAL1ZATION) ?Z>: (GO LOOP) ALLDONE :EXIT SUCCEED;; Figure 9: Demons used in a simple data \nflow simulation of the program model :DEMON EXTEND FREQUENCY ?D\\DATA/ : MATCH FAIL END; :<?p DATAFLOW \n?D> :EXTEND FREQUENCy (?p (DATAFLOW)); :EXIT SUCCEED; END :EXIT FAIL;;  :DEMON EXTEND FREQUENCY ?P//STEP/ \n(COND ( : MATCH :<?P TRIGGER ?T>; :EXTEND FREQUENCY (?T TRIGGER); :EXIT SUCCEED;)) LOOP : MATCH  :<?p \n(DATAFLOW) ?D> FAIL END; :EXTEND FREQUENCy (?D (DATAFLOW)) RANGE 1; :EXIT SUCCEED MORE; (GO LOOP) END \n:EXIT FAIL;; This demon assists in the generation of a path that begins at a data object and elaborates \nits frequency attribute. It states in effect that to determine the frequency of a data item we must back \nup along the DATAFLOW attribute to the program that produces the data and determine the frequency of \nthe program. If a program has an explicit trigger, the frequency of the Drogram is the frequency of the \ntrigger. Otherwise we must examine the inputs to the program and determine the frequency of each. :DEMON \nEXTEND FREQUENCY ?E//EXT EVENT/ The frequency of an external event is not ;MATCH :<?E * ?X>; defined \nin the program semantics , :EXTEND (?X *); therefore we must examine the application :EXIT SUCCEED;; \nmodel for further details. :DEMON EXTEND FREQUENCY ?T//REL PTIN TIME/ A relative point in time is defined \nas the :EXTEND EXTENT NIL; end of a time interval within an outer :EXIT SUCCEED;; time interval. Thus \nthe frequency of the event can be interpreted as the extent of the outer interval. Figure 10: Some depth-first \nsearch demons 242  \n\t\t\t", "proc_id": "512976", "abstract": "This paper describes a system being developed to bridge the gap between an application program and a user inexperienced in the ways of computers. The user explores the characteristics of the available programs by a natural language dialogue with the system. The dialogue is supported by a knowledge base covering both the program semantics and the application domain. This paper addresses the problems of representation and inference involved in this approach and describes our solution for them.", "authors": [{"name": "Martin Mikelsons", "author_profile_id": "81100290768", "affiliation": "T. J. Watson Research Center, Yorktown Heights, New York", "person_id": "P192428", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/512976.512999", "year": "1975", "article_id": "512999", "conference": "POPL", "title": "Computer assisted application definition", "url": "http://dl.acm.org/citation.cfm?id=512999"}