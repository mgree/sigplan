{"article_publication_date": "01-01-1975", "fulltext": "\n Permission to make digital or hard copies of part or all of this work or personal or classroom use is \ngranted without fee provided that copies are not made or distributed for profit or commercial advantage \nand that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, \nto post on servers, or to redistribute to lists, requires prior specific permission and/or a fee.&#38;#169; \n1975 ACM 0-12345-678-9 $5.00 AN ALGEBRAIC MODEL FOR STRING PATTERNS GLENN F. STEWART I.P. SHARP ASSOCIATES \nLIMITED 145 King Street West Torontor Ontario Canada 1. Introduction A great deal has been learned about \nprogramming and programming language design during the past ten years. The concepts of structure, protection \nand abstraction are having profound effects on the way languages are designed. Unfortunately, however, \nthe progression from FORTRAN to PASCAL and SIMULA and beyond has no parallel in the development of string \nmanipulation languages. It was the lack of powerful string manipulation tools that lead to the invention \nof SNOBOL [Farber et al. 19641 and its descendant, SNOBOL4 ~Griswold et al. 19711, has .- found widespread \nappl~cation in a great variety of string manipulation problems. Although SNOBOL4 is dominant in the \nfield, other string manipulation languages have been developed, among them AXLE [Cohen and Wegstein 1965], \nPANON [di Forino 1968], and COMIT [Yngve 19721. Each of these languages provides facilities for the grouping, \nrearranging, inserting, deleting, sorting, testing, tagging, and counting of strings. Accordingly, they \nshare a common set of design difficulties, characteristic of this class of languages. The central problem \nin designing string manipulation languages is to find a set of basic concepts for building strinq composition \nand transformation procedures, which appear quite different and more gene~al than ordinary algebraic \ncomputations. Unfortunately, no standard notation or accepted system of operations exists for string \nmanipulation. Farber et al. [19641. The difficulty arises largely from the weak algebraic structure \nassociated with the monoid, A*, of strings generated from an alphabet, fit under the fundamental operation \nof concaten~tion. In particular, many useful mappings from tuples of strings in A* to elements of A* \nare not expressable in terms of concatenation alone. The second fundamental operation of strinq manipulation \nis substrinq extract on. This can be done deterministicall~, by specifying <he fi;st character positi~n \nand lenqth of the substring to be extracted,-or ~on~detekmi~isticallyr by a proce=s of pattern \u00admatching. \nA number of formal systems exist for the specification of pattern matching processes, including Post \nsystems (described in [Minsky 19671) , and Markov normal algorithms. It was Markov s thesis that any \nalgorithmic activity involving the manipulation of characters . . . could be specified as a normal algorithm. \nGaller and Perlis [1970] A Markov normal algorithm consists of a sequence of rules for the replacement \nof characters from a string, stored in a register, by other characters. A number of variants and extensions \nto normal algorithms exist [di Forino 19681, but in general, a rule consists of a left-hand side, specifying \nthe substring of the register contents, that is to be replaced, and a right-hand side, specifying the \nreplacement string. The intent of a rule is that the left-hand side, or pattern, be matched in some fashion \nagainst the register contents. If a substring as specified by the pattern is found, the rule is said \nto be applicable, or, equivalently, the pattern match is said to have succeeded. Otherwise, the pattern \nmatch has failed, and the rule is inapplicable. If the rule is applicable, the string specified by the \nright-hand side replaces the substring matched by the pattern. Unfortunately, Markov algorithms are not \nin themselves a very pratical tool for string manipulation applications. The widespread difficulty in \nlearning and using Markov algorithm based languages is summarized in a comment by C. Strachey at the \nlI?IJ? Working Conference on Symbol Manipulation Languages, 1968: I think one of the troubles about Markov \nalgorithm type languages, at least for my purposes, is that there is a rather small number of problems \nin which my mind works like a Markov algorithm. We feel that this problem can, to a great degree, be \nalleviated by embedding the pattern matching and replacement features of Markov algorithms into lanuages \nthat encourage, and as far as possible enforce, the concepts of structured programming. One of the most \npressing problems in the design of better string manipulation languages arises in the specification of \npatterns. SNOBOL4 patterns, although extremely flexible and powerful, are notoriously difficult to explain \nand use. We feel that this is due primarily to the complexity of the interpretive model used for pattern \nmatching in SNCBGL4. In particular, the programmer must be intimately familiar with the operation of \nthe pattern matching procedure, called the scanner , including its backtracking and pattern matching \nheuristics. Goyer [1973] has developed a theoretical model to distinguish problems inherent in SNOBOL4 \npattern matching from those inherent in its implementation. However, Goyer s model is intended to aid \nin the design of improved SNOBOL4 implementations, not to clarify and simplify the semantics of patterns \nand pattern matching. It is to the latter problem that the algebraic model developed in this paper is \naddressed. In section 2 a number of definitions and notational conventions are introduced, and an example \nillustrating the lattice-theoretic approach to the theory of mathematical semantics is presented. This \nmaterial is preparatory to the algebraic model for patterns and pattern matching developed in section \n3. BY appealing to familiar algebraic notions, most notably that of a ring, and to a theory of mathematical \nsemantics, it is felt that the model developed here is more logically consistent, and hence simpler to \nunderstand and use correctly than the SNOBOL4 interpretive model. For example, the notions of negative \npattern and semi-inverse pattern allow certain classes of strings to be recognized by patterns that are \nboth easier to read and simpler to write than their SNOBOL4 counterparts. As another example, the assumption-based \nrecursive pattern definition mechanism in SNOLBOL4 is notoriously error prone, whereas the semantics \ndeveloped here for recursive patterns is consistent and assumption-free. 2. Definitions and Notation \nIn this section we establish a number of definitions and notational conventions, preparatory to the development \nof the algebraic model for string patterns. 2.1 Strings We start by assuming the existence of some alphabet, \nfit of atomic symbols or characters. The nature of these symbols is left undefined; the emphasis in the \nexamples of this section will be on a character set of letters, digits, and punctuation symbols, but \nthere is nothing in the development preventing the symbols of the alphabet from representing other entities, \neven entities having structure, as long as that structure is not used in string manipulation operations. \nWe give the following inductive definition of strings over A: Definition: The null string is a string \nover every alphabet. If S is a string over ~, and a c ~, then Sa is a string over A. The length of a \nstring, S, is denoted by ISI , and is the total number of characters in S. The length of the null string \nis zero, i.e. , it consists of no characters. 2.2 Counted Sets The definition that we shall give for \npatterns depends upon an extended form of sets. The definition, below, of counted sets provides us with \na mechanism for retaining -with each set element any information that can be encoded as a single integer: \nDefinition: A counted set (also called a multi-set [Earley 19741, or bag [Reboh and Sacerdoti 19731) \nis a set with the added property that with each member of the set there is associated an integer denoting \nthe multiplicity of that element. If S is a counted set containing the elements s1, s2, . . . . sm with \nmultiplicities nl, n2, . . . , nm respectively, then S is written as {nl*sl, n2*s2r . . . . nm*sm). If \nthe multiplicity of an element is not given explicity, that element is assumed to have multiplicity one. \nNote that the definition of counted sets does not exclude the possibility of zero or even negative multiplicities. \nWe postpone for the moment a discussion of negative multiplicities; however, we remark that if s is not \nan element of a counted set, S, then s can be said to have multiplicity zero in S. Ordinary sets, then, \nare simply counted sets in which all elements have multiplicity one or zero. We first establish a partial \nordering for counted sets: Definition: Let S and T be counted sets. Then S contains T, written S ~ T, \nif every element of T with non-zero multiplicity has the same or greater multiplicity in S. S and T are \nequal, written S = T, if and only if S 2 T and 1 > S. In developing an algebraic model for string patterns, \nwe will require definitions for the following operations on counted sets: nm*cm} be a counted set, and \nlet k be an integer. Definition: Let C = {nl*cl, n2*c2, . . . . Then k*C is a counted set, and is defined \nby k*c = {k(nl)*~l, k(n2)*c2, . . . . k(nm) *cm} We remark that O*C = $, (the empty set). Definition: \nLet C = {nl*cl, n2*c2, . . . . nm*cm} be a counted set of integers, and let k be an integer. Then k f \nC = {nl*(kfcl), n2*(kic2), . . . . nm*(ktcm)} (Contrast this definition with that of k*C. * is an operation \non element multiplicities, and hence it is defined for all counted sets; + and -are operations on the \nelements of counted sets of integers.) The concept of set union can be extended to counted sets in any \nof a number of ways. we define here the notion of additive union, which we will use in defining the operations \nof pattern alternation and concatenation: Definition: Let C and D be counted sets. The additive union \nof C and D, denoted by C + D, is a counted set containing the set-theoretic union of the elements of \nC and D, with the property that the multiplicity of each element in C + D is the sum of its multiplicities \nin Cand D. -6*b, c} Example: Let C = {5*a, D = {-2*a, 6*b} E = {a, -7*b, C} then C+ D= {3*a, c} c + E \n= {-l*a, -13*b, 2*c} D + E = {-l*a, -l*b, c} 2.3 Lattice-Theoretic Extensions In developing a mathematical \nsemantics for recursive pattern definitions we will\u00ad be using the lattice-theoretic approach to the theory \nof computation, based on the notion of finite approximation [Donahue 1974; Scott 1970]. To use this theory, \nthe data types with which we will be dealing, namely strings and counted sets of integers, must be defined \nas complete lattices. A review of some definitions [Birkhoff 19671 may prove helpful at this point: Definition: \nA poset is a set in which a binary relation x s Y is defined, which satisfies for all x, y, z the following \nconditions: 1. For all x, x s x. (reflexive) 2. If x s y and Y s x, then x = Y. (anti-sYmmetric) 3. \nIf xsyand ysz, then xsz. (transitive)  Definition: Let A be a poset partially ordered by S, and. let \nB be non-empty subset of A. Then an element a c A is an upper bound (lower bound) of B if and only if \nfor all b E B, b s a (as b). The least~a-e=t~he set of all upper (lower) bounds of B is the least _ bound \n(greatest lower bound) of B, symbolized by lub B (glb B) . . Definition: A lattice is a poset any two \nof whose elements have a greatest lower bound and a least upper bound. A lattice, L, is complete when \neach of its subsets has a lub and a glb in L. In dealing with data types, we make the following definition: \nDefinition: A domain is a lattice-structured data type that is partially ordered by approximation. We \nhave already defined a partial ordering by containment for counted sets. To form a complete lattice from \nthe counted sets of valid cursor positions for a given string, S, (i.e., those integers c such that O \ns c s ISI) we add to the data type an overdetermined (universal) counted set, denoted top, which is the \nleast upper bound of the domain and contains every counted set, and a~derdetermined counted set, denoted \nbet, which is the greatest lower bound of the domain and is contained in every counted set. We denote \nthe domain thus defined by Q(S). To strings, we simply add two new values, ~ and bet, and define a partial \nordering, ap, to form a primitive domain, ~, as follows: s== top , I ... bot where SO, S1, S2, . . \n. . Sn, . . . is an enumeration of all strings over a given alphabet. Adopting the Scott terminology, \nbot is the greatest lower bound of the data type, and an approximation of every string. ~ is the least \nupper bound of the data type, and is an extension of every string. The product domain S x D(S) is defined \nfor valid contexts (S,c) where S E S and c E D(S). The partial order~ng En-this lattice is defined by \n(Slrc ) ap (S2,C2) i~ and only if S1 ap S2 in S and c1 < cz in D(S). 2.4 Continuous Functions and Least \nFixed Points continuous The in second requirement the sense of the of following the Scott definiti theory \nons: is that mapping between data types be Definition: for each finite A subset subset X of of a X. l \nattice is directed if and only if X c ontains an upper bound Definition: A function f:D + D is continuous \nif and only if for every directed subset of D, f(lub X) = lub {f(x) I X c X}, i.e., the function preserves \nlimits. Among the operations we have defined thus far on counted sets, only multiplicatj.on by a negative \ninteger constant is not continuous, and will, accordingly, be shown to be ineligible for use in defining \nrecursive patterns. The importance of complete lattices and. continuous functions lies in the technique \nof modelling recursive functions by infinite sequences of finite approximations, and then showing that \nany particular value of these functions is determined by a finite number of approximations. The technique \nis well illustrated by an example, from [Donahue 19741, modelling thr recursive factorial function. We \nadopt the notation f = (D:x)D : body to define a function f:D + D . Example: Consider the primitive domain \nin integers, Num, and the multiplication operator * extended from the set of integers to the domain Nu~s \nfollows: nl n2 nl*n2 il i2 ilxi2 bot i bot top top -bit bot bit bot bot top bot top -top top bit top \n* top c top This extension makes * continuous, since it is continuous in each argument. Now we can define \nthe factorial function Fact: Num + Num on this domain by . Fact = (Num: k) Num: if k=O then 1 else k*Fact \n(k-1) . Notice that Fact can be regarded as a parameter of the right-hand ,~ide of the equation. Thus \n, the equation defining Fact can be rewritten as Fact = F(Fact] , where F: [Num + Num] + [Num + Num] \nis defined by  F = (Num + Num: G) Num + Num: (Nuiiiiik) Nun: if k=O then 1 else k*G(k-1) Fact is then \na fixed point of F by the following definition: D + D! for some domain D. Then x E D is a fixed point \nof f if and only if x = f(x) . A fixed point x of f is a least fixed point of f if Definition: Consider \na function f: . and only if for all fixed points xl, x2, ... of f, x ~ x1, x ~ x2r ... . It can be shown \nthat any continuous function on a complete lattice has a least fixed point [Scott 19721. Moreover, if \nf is continuous, the least fixed point x = f(x) is given by the iteration formula x =lub{fo(bot), fl(bot) \n, f2(bot), . ..}. where fn(bot) = f(f(...(bot) _ . ..)). for n applic~ons of~ Thus, we can solve the \nequation Fact =F(Fact) for its least fixed point using Fact = lub{FO(bot), Fl(bot), F2(bot), . . . } \nwhere bot E Num + Num maps each element of Num to bet. We produce the sequence 05 domain .. elements \nFO(bot) , Fl(bot) , F2(bot) , . . . where FO(bot) ap Fl(bot) ap F2(bot) ap . . . and form the limit \nlub{FO(bot), Fl(bot), F2(bot), . . . ] which is the least fixed point of F. A table of some of the Fn \nfor various values of n and k will show that the least fixed point is indeed the factorial function: \n171 3. An Algebraic Model for String Patterns k . . . O (bet) . F1 (bet) _ lF2(~) ,F3@) F4 (bet) F5 I \n (bet) ~act bot o bot m bot 1 bot 1 bot 1 bot 1 l bot 1 bot 1 1 bot bot 1 1 1 1 1 2 bot bot bot 2 2 2 \n2 3 bot bot bot_ bot . 6 6 6 4 bot bot bot bot bot . 24 24 . I . top bot top t Op top 3.1 Introduction \nTwo facts lead to the search for an algebraic model for string patterns for the specification of string \ntransformation procedures. Firstr there is only a very weak algebraic structure inherent in strings, \nand, second, it is the function of patterns to impose a st.xucture upon the strings they match. Early \nattemptsto directly enrich the algebraic structure of strings failed to produce useful results, encouraging \nattempts to approach the problem indirectly, through string patterns. A strong hint of the viability \nof this approach is contained in [Gimpel 19731, and this section is a reformulation and extension of \nGimpel s theory of discrete patterns in order to enrich the algebraic properties of the model. The principal \njustification for the model developed here lies in the natural interpretations that can be given to the \nconcepts that will be introduced to enrich the algebra. The most notable of these are negative and semi-inverse \n$~~ternsr both of which resemble similar but more awkward constructs m the SNOBOL4 mo e 3.2 Patterns \nEquipped with a definition of counted sets, we can now give a definition, adapted from [Gimpel 1973], \nof patterns: Definition: A pattern, P, is a function P(S,C) , where S is a string, called the subject \nstring, and c is an integer indexing S, called the pre-cursor position. The value of P(S,C) is a counted \nset of integers, called the post-cursor positions. Two patterns are said to be equal if and only if they \nrepresent the same function. Cursor positions can take values in the range O, 1, . . . . Is]. Thus, the \ncursor may be regarded as a pointer into the subject string, motivating the following definition: Definition: \nThe ordered pair (S,c), where S is a subject string and O < c < ISI, is referred to as a context for \npattern matching, and represents a sectioned string [Griswold 1973], sectioned into two parts by a cut \nbetween the c-th and (c+l) st characters of s. Examples: 1. Let Abe any string. We can define a pattern, \nwhich we denote simply by A, as follows: For all contexts (S,c), if Substring (S,C,IAI) = A, then A(S,C) \n= {c+IAI}, else A(S,C) = $.  2. Let P = AB and S = !ABAB!. Then P(S,C) for c = 0, 1, 2, 3, and 4 is \n{2}, $, {4}, O, and @ respectively. 3. The SNOBOL4 primitive pattern-valued function LEN is defined \nas follows: Let n be a  non-negative integer. For all contexts (S,c) , if c+n < ISI, then LEN(n) (S,c) \n= {c+n}, else LEN(n) (S,C) = ~. We can now introduce the concept of negative patterns, which is central \nto the extended algebraic structure of the model. Definition: Let P be a pattern. Then -P is a pattern, \nand is defined by . (-P) (S,C) = (-l)*P(S,C) where (S,c) is an arbitrary context. 172 Example: Let P \n= LEN(1) and S = AA . Then (-P) (S, c) for c = O, 1, and 2 is {-1*1}, ~1*2}, and @ respectively. Thus \n, a negative pattern is defined in a purely algebraic sense as a function producing a negative instance \nof a counted set. The final definition in this section extends the definition of an arbitrary pattern, \nP, to allow a counted set of valid cursor positions as its second argument: Definition: .... P(S,{nl*cl, \nn2*c2, nm*cm}) = (nl*p(S,cl)) + (n2*p(S,c2)) + . . . + (nm*p(S,cm)) If the second argument is the empty \nset, we define P(S,$) = $. Example: Let P = AB and S = ABABm. Then P(S,{2*0, 1, 2}) = (2*{2}) + @ + {4} \n= {2*2, 4] 3.3 The Algebra of Patterns We are now able to define the pattern synthesis operations of \nconcatenation and alternation. In the definitions that follow, P and Q denote patterns, and (S,c) is \n,an arbitrary context. Definition: The concatenation of P and Q, denoted by P &#38; Q, is a function \ndefined by (P &#38; Q)(S,C) = Q(S,P(S,C)) Definition: The alternation of P and Q, denoted by P ] Q, is \na function defined by (p I Q)(S,C) = P(S,C) + Q(S,C) We now propose to show that, given suitable definitions \nof identity patterns for the operations of alternation and concatenation, patterns form a ring with unit \nelement. Definition: FAIL is a pattern defined by FAIL(S,C) = $ for all contexts (S,c) . Intuitivelyr \nFAIL is a pattern that fails to match any string. Definition: NULL is a pattern defined by NULL(S,C) \n= {C} for all contexts (S,c). Intuitively, NULL is pattern that matches just the null string. Theorem: \nPatterns, under the operations of alternation and concatenation, form a ring with unit element. Proof: \nLet P, Q, and R be arbitrary patterns, and (S,c) be an arbitrary context. It is a ~ghtforward process \nto verify that 1. p I Qis a pattern. 2. PIQ=Q IP 3. (PIQ) IR=P I(QIR) 4. P ]FAIL =P 5. -P &#38;FAIL \n PI Byl. - !5., patterns under I form a group. 6. P&#38;Qis apattern. 7. (P &#38; Q) R= P&#38; (Q&#38;R) \n 8. P&#38; (QIR)=(P&#38;Q) [(P&#38; R)  (Q IR)&#38;P= (Q&#38;P \\(R&#38;P) Byl. -8., patterns under ] \nand &#38; form a ring. p.p 9. P&#38;NULL =NULL 173 Q.E. D. We have deliberately avoided attaching an \ninformal semantic interpretation to negative patterns since their role in the pattern matching model \ncan be defined solely in terms of inverse elements in the pattern algebra. Howeverr the theory can best \nbe Put. into perspective by suggesting an application of negative patterns. Specifically, pattern negation \nis useful in specifying patterns that are set difference expressions. That is, if we view patterns as \nfunctional specifications of sets of strings, then the pattern P I Q sPecifies the sets of strings matched \nby p but not by Q, i.e., the set difference of P and Q. Pattern negation, then, is a generalization of \nthe function of the primitive pattern ABORT in SNOBOL4 [Griswold et al. 19711. . Example: The following \nSNOBOL4 pattern matches any character except an asterisk: * ABORT ] LEN(1) Using instead the concept \nof negative patterns, we have: - * \\ LEN(1) Note that we could equally well write: whereas the SNOBOL4 \npattern LEN,(1) \\ * ABORT would not have the desired effect. 3.4 Introduction to Inverse Patterns We \nremark that, given an arbitrary pattern, P, -P is the additive (alternation) inverse of P. If a multiplicative \n(concatenation) inverse of P (Z FAIL) , say P-l, could be defined such that P &#38; P-l = P-l &#38; P \n= NULL, then patterns under I and &#38; would form a division ring. (We cannot hope to further extend \nthe ring definition to obtain a field since &#38; is not commutative.) Recall, however, that (P &#38; \nP l) (S,c) = P l(S,P(S,c)), independently of the context and the definition of P-l . If P fails to match \nin S, i.e. P(S,C) = ~, then P 1 (S,P(S,c)) = P-l(S,$) = @ z NULL(S,C). Thus there does not exist a definition \nof P-l that will yield a division ring. A modified concept-of inverse patterns under &#38; is nonetheless \nan interesting and useful one, and this section is devoted to the introduction of such a concept. To \ndevelop a theory of inverse patterns, we start by noting that negative patterns are an important special \ncase of a more general concept. Recall the definition of -P: (-P) (S,c) = (-l) *P(S,C) where (S,c) is \nan arbitrary context. Parenthesizing the expression on the right side of this equation in a slightly \ndifferent way, we get (-P) (S,C) = (-l*P)(S,C) This immediately suggests the more general Definition: \nLet P be a pattern and i be any integer. Then i*P is a pattern, and is defined by (i*P)(S,c) = i*(P(S,c)) \nwhere (S,c) is an arbitrary context. We observe that if P and Q are patterns and i and j are integers, \nthen i*(p IQ) = j-*p I i*Q .(ii) (i + j)*P = i*P I j*P (i) (iii) i*(j*P) = (ij)*P l*p ; p(iv) 174 From \nobservations (i) -(iv), we conclude that patterns form a module over the integers. Since there are infinitely \nmany primitive patterns, including all strings, this module is not finitely generated. We can, however, \nderive a useful definition of semi\u00adinvertibility based on linear dependence in the module. The entity \nwe will define is not a true inverse, but it retains most of the flavour and usefulness of the stronger, \nbut unattainable, concept. First we note that in the module of patterns, the following lemma holds: Lemma: \nIf P # FAIiI, then i*P = FAIL implies that i = O. Proof: If P z FAIL there exists at least one context \n(S,c) for which P(S,C) z $. Therefore, if i * O, then (i*P) (S,c) = i*(P(S,c)) z $. Q.E.D. Definition: \n Let P and Q be patterns. Then P and Q are conformable, written P ~ Q, if and only if for each context \n(S,c) there exist integers i and I, not both zero, such that i*(p(s,c)) = j*(Q(S,c)) or, equivalently, \n(i*P ] -j*Q)(S,c) = FAIL(S,C) = @ Thtit is, two patterns are conformable if and only if for each context \nin which they both succeed, the multiplicities of the strings matched by one pattern in that context \nare a constant multiple of the corresponding multiplicities of the strings matched by the other. Examples: \n1. Let P = A Q = 1~1 I A Then Q = 2*P, and hence P and Q are conformable 2. Let P be any, string Q = \nLEN(]PI) Then, for any context (S,c), either P(S,C) = Q(S,C) or P(S,C) = O*Q(S,C) and hence P and Q \nare conformable. 3.5 Semi-invertible Patterns -1 Definition: A pattern, P, is said to be semi-invertible \nif there exists a pattern, P , called a semi-inverse of P, with the properties that for all contexts \n(Src) , 1. (p &#38; P-l) (s,c) = @ only if P(Src) = $. (p-l &#38; P)(s,c) = @ only if P-l(S,c) = $. \n2. P &#38;P-l %NULL. Pzl &#38;P wNULL.  Note that the restriction P * FAIL, which was required to define \na division ring, is not needed here if we define FAIL I by FAIL- (S,C) = FAIL(S,C) = @ for arbitrary \ncontexts (S,c) . To avoid heavily parenthesized expressions, we arbitrarily assign precedences to the \noperators defined thus far, as fol~~ws: highest + lowestt 175 We remark that semi-inverse patterns can \nbe used (when they exist) to define context sensitive patterns, that is, patterns that match successfully \nonly in the context of certain specified strings. Doyle [19731 gives an example that is naturally described \nby a context sensitive pattern: A sentence is recognized as being an arbitrary string of characters including \na terminating period, which is followed by at least two blanks. A SNOBOL4 pattern to match sentences \nis obscure and complex: ARB . @XFAIL \\ TAB(*(X -2)) The concept of semi-inverse patterns yields equivalent \nbut much simpler and more transparent patterns: ARB &#38; . &#38; -1 or ARB&#38; . &#38; LEN(2)-] \nThe pattern component . &#38; -1 matches a period in the right context of two blanks, and fails otherwise. \nDoyle s solution is conceptually more complex, involving the addition of a state variable to the scanner \nto govern the direction of scanning in the subject string, and an extension to the definition of the \nLEN primitive: ARB . LEN(-2) Having shown that semi-inverse patterns are a potentially useful concept, \nthe questions of immediate interest concern whether semi-inverse patterns do exist, and, if indeed they \ndo exist, how they are characterized. Unfortunately, it is not possible to define semi-inverses in such \na way that all patterns will be semi-invertible, as the following example illustrates: lAIExample: Let \nP = TA I Then P(S,O) = {2], matching TA , and P(S,l) = {2}, by matching A . Suppose P is semi-invertible. \nThen, as a result of the first defining _~roperty of semi-inverse patterns, our choice of contexts ensures \nthat both (P &#38; P )(S,0) and (P &#38; P- ) (S,1) will be non-null. That is, there exist non-zero integers, \ni and j, such that (P &#38; P- ) (S,l) = i*(NULL(S,l)) = {i*l}, and (P &#38; P- ) (S,O) = j*(NULL(S,O)) \n= {j*()} * (P&#38; P- )(s/l) Evaluating now the left sides of these equations, we have (p&#38; P- ) (s,o) \n= P- (s,p(s,o)) = P- (S,2) = P-I(S,P(S,l)) = (P&#38; P- ) (s,l) contradicting the serni-invertibility \nof P. Note that this result is independent of whatever definition we may choose for P. 1 In general, \nif a pattern, P, matches successfully in a given context, the result of applying P &#38; P-l in that \ncontext will contain the pre-cursor position (possibly with multiplicity > 1) , and, if P is not semi-invertible, \ncan contain other post-cursor positions (possibly with multiplicities > 1) . Further, as the preceding \nexample illustrates, it is not possible in general to deduce which of the post-cursor positions was in \nfact the pre-cursor position. We have shown that if P and Q are semi-invertible patterns, it is not in \ngeneral true that P I Q is a semi-invertible pattern. We remark that P I Q will, however, be 176 semi-invertible \nif and only if P does not match any prefix or suffix substring of the strings matched by Q, and vice \nversa. In these cases, p \\ Q is equal in each context to exactly one of P or Q, and~czi-invertibility \nof P and Q guarantees semi\u00adinvertibility of P I Q. Although alternation tends to destory semi-invertibility, \nwe can prove that semi\u00adinvertibility is preserved under concatenation. First, we prove a lemma: Lemma: \nLet P and Q be patterns such that P m Q, and let R be an arbitrary pattern. Then (i) P&#38;RwQ hR and \n(ii) R&#38;P~R&#38;Q Proof: We will prove only (i) since the proof of (ii) is quite similar. If P % Q, \nthen for each context (S,c) there exist integers i and j, not both zero, such that ix(p(s,c)) = j*(Q(.S,c)). \nThus , R(S,i*(P(S,c))) = R(S,j*(Q(S,c))) i* (R(S,P(S,c))) = j*(R(S,Q(S,c))) i*((p L R)(S,C)) = j*((Q \n&#38; R)(SJc)) P &#38;RmQ &#38;R Q.E.D. Usin~ this result, we can easily prove the following theorem: \nTheorem: If P and Q are semi-invertible patterns, then P &#38; Q is a semi-invertible pattern, and Q- \n&#38; P-L is a semi-inverse of P &#38; Q. , Proof: This result is easily ascertained by considering (p \n&#38; Q) &#38; (Q-l ~ p-l )= p&#38;(Q&#38;Q- ) &#38;P- mP &#38;NULL &#38;P-l P &#38; P-l ~ NULL similarly, \n(Q-l &#38; p- &#38; (P &#38; Q) 1 NULL. Q.E.D. The neaative results of this section notwithstanding, \nthere is a large class of .:. patterns ror whxch semi-inverse patterns do exist, and are useful. In the \nnext section we give a definition of semi-inverse patterns motivated by the examples given above, and \nproceed to identify the class of semi-invertible patterns. 3.6 Semi inverse Patterns The essential characteristic \nof inverse patterns is their ability to effectively reverse the direction of pattern matching. This can \nbe done most simply for string patterns by reversing the pattern and applying it in the usual way to \nthe reverse of the subject string. The extension to more complex patterns presents few difficulties, \nand hence we give the following definition: Definition: For every pattern, P, we state the existence \nof a pattern, reverse(P) , and define its standar~ semi-inverse pattern, P- , by P-l(s,c) = Is] -reverse \n(P) (reverse(S) ,ISI -c) where (S,c) is an arbitrary context. Although, as we have seen, P-l is an abuse \nof notation, we will hereafter use the symbol -1 consistently in the sense defined here. It has the advantages \nof beinq mnemonic and accurate in a restricted sense. That is, we will later prove that if P is a semi-invertible \npattern, then any semi-inverse of P is equivalent to the standard semi\u00ad inverse in the sense of the following \ndefinition: Definition: Two patterns, P and Q, are said to be match-equivalent if and only if for all \ncontexts (S,c) and cursor positions, d, d E P(S,C) if and only if d E Q(S,C). Informally, two patterns \nare match-equivalent if and only if they match the same set of strings in every context. IAl ] !A~l Example: \nLet 1?. = A I Q = At , JATI I AT Then P and Q always match the same strings, e.g., P( AT ,0) = {2*1, \n2} Q( AT ,0) = {1, 2*2} and hence P and Q are match-equivalent. In a pragmatic sense, two patterns that \nare match-equivalent differ only trivially, since the multiplicities of successful matches are often \nof little or no interest. Put another way, the relevant question seems to be: what were the successfully \nmatched substrings? The number of times each match occurred is generally a question of secondary importance. \nSNOBOL4 goes even further, by halting the pattern matching operation after the first successful match. \nDoyle [1973] provides a similar capability for SNOBOL4 by introducing a state variable into the scanner \ngoverning the direction of scan (pattern matching) . A new built in function, SCAN, returns a directive \n(primitive pattern) that permits the direction of scanning to be changed dynamically during pattern matching, \nand restored automatically during backtracking. In addition, certain primitives permit the cursor to \nbe moved backwards without changing the direction of scan. This approach has the disadvantage that it \nadds considerable complexity to the pattern matching process by introducing the direction of scan as \nan additional parameter to each pattern component (or, equivalently, as an added piece of context information, \nsupplementing the sectioned subject string) . Further, the built in function SCAN lacks generality in \nthat its definition (or the defintion of an equivalent facility) would be awkward in any pattern matching \nfacility not defined in terms of a scannerf procedure. Note that the model we have defined so far is \nentirely independent of the existence of such a procedure. (Nor does the model preclude the definition \nof a scanner in the design of a language based on the model, should such a procedure be desired.) Our \ndefinition of P l is incomplete, for we have not yet defined reverse(P), for arbitrary patterns, P. reverse(S) \nis~ however, well-known for strings, and hence for primitive string patterns: Definition z Let S = sl...sn \nbe a string, where si denotes the i-th character in S. Then reverse(S) = sn...sl The implications of \nthis definition, and the definitions of the alternation and concatenation operators, are that reverse(P) \nshould, for all patterns, P, have the following axiomatic properties: (i) reverse(P I Q) = reverse(P) \n] reverse(Q) (ii) reverse(P &#38; Q) = reverse(Q) &#38; reverse(P)  (iii) reverse(reverse (P)) = P \nIf we define a mapping P + reverse(P) from the ring of patterns onto itself, properties (i) and (ii) \nstate that reversal is an anti-automorphism [Jacobson 1951; Redei 19671, and property (iii) states that \nreversal is a self-inverse mapping. Given these properties, we can easily prove the following lemma: \nLemma: Let P be an arbitrary pattern and let i be an integer. Then . (iv) reverse(FAIL) = FAIL (v) reverse(-P) \n= -reverse(P) (vi) reverse(i*P) = i*reverse(P)  Proof: (iv) and (v) are elementary results from the \ntheory of group homomorphisms. To prove (iv) , consider reverse(P) = reverse(P I FAIL)  reverse(P) \n] reverse(FAIL) Thus , reverse(FAIL) = FAIL. Using this result, we have 178 and hence where i > -reverse(P) \n0. Then = FAIL reverse(-P) = = = reverse(FAIL) reverse(P reverse(P) , proving \\ -P) I reverse(-PO / (v) \n. To prove (vi) , consider first the case reverse(i*P) = = = reverse(P reverse(P) i*reverse(P) I P I \n. . . I P) [i I . . . I reverse(P) repetitions] If (v) i = to O, the property above (iv) result. applies, \nQ.E.D. and if i < 0, write i*P = -(lil *P), and apply property An immediate consequence of property \n(vi) (which includes properties (iv) and (v) as special cases) is the following lermna, which we state \nwithout proof: Lemma: Let P and Q be patterns such that P ~ Q. Then reverse(P) ~ reverse(Q). If P is \nsemi-invertible, and P-l is a semi-inverse of P (we have yet to prove this) , then NULL = reverse(NULL) \nm reverse(P l &#38; P) = reverse(P) &#38; reverse(P-l) Similarly, NULL m reverse(P-l)&#38; reverse(P). \nSince reverse(P) &#38; reverse(P-l ) clearly fails in any context if and only if reverse(P) fails, and \nreverse(P- ) &#38; reverse(P) fails if and only if reverse(P- ) fails, we conclude that reverse(P-l) \nis a semi-inverse of reverse(P), and hence is match-equivalent to (reverse(P) )-] . We are otherwise \nunconstrained in defining reverse(P-l) , and therefore give the obvious definition: Definition: Let P \nbe any pattern. Then reverse(P-l) = (reverse(P))- . If there are primitive patterns other than strings \nunder consideration, their reverses must be individually defined. Some primitive patterns, such as the \nSNOBOL~ primitive, LEN, are self-reverse patterns. Some, however, are not. reverse(BAL) , for example, \nis a pattern that matches any non-null string of characters that is balanced with respect to right and \nleft parentheses. The reverses of other primitive patterns can often be determined by modelling the primitive \npattern using other primitives for which reverses are known, and the operations of alternation and concatenation. \nSome examples using the primitive patterns in SNOBOL4 will illustrate the technique: Examples: 1. ARB \ncan be modelled as NULL I LEN(1) I LEN(2) I . . . Hence, reverse(ARB) = reverse(NULL I LEN(1) I LEN(2) \nI . ..) . reverse(NULL) I reverse(LEN(l)) \\ . . . = NULL \\ LEN(1) I LE~~(2) I . . . = ARB Similarly, \nreverse(ARBNO (P)) = ARBNO(reverse(P)) 2. If S=sl... sn is any string, where si denotes the i-th character \nin S, then ANY(S) can be modelled as S1 [S2 ... Isn I 179 Hence, reverse ANY(S)) = reverse(sl I S2 I \n. . . \\ sn) = reverse I . . . I reverse  = ANY(S) Similarly, reverse(NOTANY(S ) = NOTANY(S) S1 IS2 \nI... Isn 3. If we write BREAK(S) = ARBNO(NOTANY(S) &#38; ANY (S) &#38; ANY(S)-l then reverse (BREAK(S))= \nreverse (ARBNO(NOTANY (S)) &#38; ANY(S) &#38; ANY(S)-l) = reverse(ANY(S) 1) &#38; REVERSE(ANY(S))&#38; \nreverse (ARBNO(NOTANy (S))) = ANY(S)-l &#38; ANY(S) &#38; ARBNO(NOTANY(S)) Then, reverse(BREAK(S)) matches \nall strings not containing break characters, and which have a break character as immediate left context. \n4. If we model SPAN(S) as ANY(S) &#38; ARBNO(ANY(S)) &#38; NOTANY(S) &#38; NOTANY(S)-l then, followinq \nthe example of BREAK, we see that reverse(SPAN(S) ) matches, in the immediate left-context o; any character \nnot appearing in its argument, all strings consisting solely of characters appearing in its argument: \nreverse(SPAN(S)) = NOTANY(S)-1 &#38; NOTANY(S) &#38; ARBNO(ANY(S)) &#38; ANY(S) Returning to the definition \nof P 1, it follows from the definition of reverse(P) that the mapping P + P-l is also an anti-automorphism \nof patterns. Accordingly, 1. (P 2. (P (Q) l &#38; (P)-l  !:]:: : p)- ] (Q)-l It can also be shown \nthat 3. FAIL-l = FAIL 4. (-p)-l = _(p-1) 5. (P- )- = P  We close the section with the proof that if \nR is a semi-invertible pattern, then all semi-inverses of R are match-equivalent. Lemma: Let R be a semi-invertible \npattern, and let P be a semi-inverse of R. Then for all contexts (S,c) , d s P(S,C) implies R(S,d) z \n~. Proof: Suppose there exists a context (S,c) such that d E P(S,C) and R S,d = $. Since (P &#38; R) \n(S,c) = $ only if P(S,C) = $, there must exist some other cursor pos. tion e E P(S,C) and non-zero integer \ni such that R(S,e) = {i*c}. Now. (R &#38; P)(S,e) = P(S,R(S,e)) = P(S,{i*c}) = i*(P(S,c)) 2 {d} contradicting \nthe assertion that P is a semi inverse of R. Theorem: Let R be a semi-invertible pattern, and let P and \nQ be semi-inverses of R. Then for all contexts (S,c) , d &#38; P(S,C) if and only if d e Q(S,C). Proof: \nSuppose there exists a context (SIC) such that d c P(S,C) and d E Q(S,C) . Since -a semi-inverse of R, \nthere exists (by the previous, lemma) a non-zerb integer, i, such that R(S,d) = {i*c}. Now, (R &#38; \nQ)(S,d) = Q(S,R(S,d)) = Q(S,{i*c}) = i*(Q(S,c)) Since d -c Q(S,C), this contradicts the assertion that \nQ is a semi-inverse of R. Interchanging P and Q in the above argument completes the proof. 180 3.7 Unambiguous \nPatterns We can now turn to the problem of characterizing semi-invertible patterns and proving that if \nP is a semi-invertible pattern, then the standard semi-inverse, P-l, actually is a semi-inverse of P. \nThe following definition gives a simple sufficient condition for semi-invertibility. Definition: A pattern, \nP, is unambiguous if and only if for all contexts (S,c) , the cardinality of P(S,C) is at most one. Theorem: \nIf P and reverse(P) are unambiguous then P is semi-invertible, and P-l is a semi-inverse of P (and hence \nevery semi-inverse of P is match-equivalent to P l) . Proof: Let (S,c) be an arbitrary context. Two cases \narise in showing that _ P &#38;P 1mNULL: case 1: P(s,c) = $. In this case the result holds trivially, \nsince (P &#38; P-l) (s,c) = O*NULL(S,C) = @ case 2: P(s,c) * $. Then P(S,C) = k*{c+n}, for some non-zero \ninteger, k, and integer, n. Also, since only the reverses of those pattern alternates that matched successfully \nin the forward direction can match successfully in the reverse direction< we have reverse(P) (reverse \n(S), lS1-c-n) = k*{ IS1-c}. Hence, (P &#38; P- ) (s,c) = P- (Sfp(s,c)) = k*(p\u00ad (S,c+n)) . k*(lSl -reverse(P) \n(reverse s) , S1-c-n)) =k*(lSI -k*{lS\\ -C}) -k2*{c} = k2*NULL(S,c) and so P &#38; P l m NULL. i he proof \nthat P l &#38; P ~ NULL is analogous. Q. E. D. 3.8 Recursively Defined Patterns Many naturally occuring \npatterns have recursive definitions. In particular, patterns resembling context free grammars can be \nused to recognize context free languages. Example: Consider the following context free grammar for a \nsubclass of constant arithmetic expressions: <E> ::= <T> I <E> + <T> <T> ::= <F> 1 <T> * <F> <F> ::= \n0111 . ..191 (<E>) In SNOBOL4, a Pattern to recognize (match) such expressions can be wriiten as F =ANY( \n0123456789 ) I ( *E ) T= F;*T * F E=TI *E ?+! T Pattern + Pattern. In general, recursive patterns are \nthose defined by equations of the form: P = g(P) where domain g is of p an arbitrary atterns by pattern-producin~ \nthe domain equation function of patterns. Thus , if we define the Pattern = ~ x D(S) + ~(~), where domain \np atterns map strings and counted sets into counted sets, then g is an element of the In this section \nwe give a mathematical semantics for such patterns using least fixed point techniques. In section 2 we \nexcluded the use of negation in recursive pattern definitions on the grounds that negation (or multiplication \nby any negative integer) is not a continuous 181 operation. As a result, we can restrict our attention \nin this section to counted sets containing only elements with non-negative multiplicities. We will denote \nthe sub-domain of D(S) defined by this restriction by D(S)+. Note that in D(S)+, bot = $, since for all \n. xcQ(~)+, $ < ~. Patterns are extended to the domain S x D(S)+ as follows: . Definition: Let P (Z FAIL) \nbe any pattern and. (S,c) be an arbitrary context. Then the following table defines the values of P on \n~ x D(S)+: I II1 P(top,bot) = bot P(top,c) = top P(top,top) = top . P(S,bot) = bot P(s,c) P(s,top) = \ntop . P(bot,bot) = bot P(bot,c) = bot P(bot,top) = top . We define FAIL in the extended domain by Note \nthat under this extension any pattern defined in terms of primitive patterns and continuous pattern-valued \nfunctions (i.e., all functions defined in the model, with the exception of multiplication by a negative \ninteger) is a continuous function. Returning now to the problem of giving meaning to patterns defined \nby equations of the form P = g(P), where P and g are continuous, we can write g using the extended definition \nof patterns and the notation f = (D:x)D : body to define a function f:D + D~. Example: Let P = A I P \n&#38; A then P = g(P) , where g = (Pattern: Q) Pattern: A IQ&#38; A P is thus a fixed point of g, and \nwe can solve the equation P = g(P) for its least fixed point using - P= lub{gO(FAIL), gl(FAIL), g2(FAIL), \n. . . 1 We produce the sequence of domain elements gO(FAIL) , gl(FAIL) , g2(FAIL) , . . . where, for \narbitrary (S,c) E ~ x Q(s)+, gO(FAIL) (S,C) S gl(FAIL) (S,C) S g2(FA IL) (S,c) ~ . . . and form the \nlimit lub{gO(FAIL) , gl(FAIL), g2(FAIL), . . . } which is th e least fixed point of g. A table of some \nof-the gn for various values of n and contexts (S,c) will show that the least fixed point definition \nof the pattern in the previous example does indeed match any sequence of one or more A s: 182 (src) 31 \n(FAIL) T2 (FAIL) J3(FAIL) 34(FAIL) P (bet, $) (J $ . {1,2,3} ( AAA ,1) {2} {2,3} ( AAA ,2) {3} {3} ( \nAAA ,3) $ @ ( -uwi ,o) {1} . (g; toP) top top 3.9 Summary The following points summarixe the main features \nof the algebraic model developed in this section: 1. Patterns are defined as counted set producing functions \nof contexts or counted sets of contexts. 2. Negation, alternation and concatenation are pattern-valued \nfunctions of patterns, and are defined in terms of operations on counted sets. 3. Patterns, under the \noperations of alternation and concatenation, form a ring with unit element. The additive identify is \nFAIL, and the multiplicative identity is NULL. 4. The algebra cannot be further extended to define a \nfield or even a division ring. We can show, however, that patterns form a module over the integers. . \n 5. Semi-inverse patterns are defined in terms of conformity, a notion based on linear dependence in \nthe module. 6. Not all patterns are semi-invertible. Further, if P and Q are semi-invertible patterns, \nthen P &#38; Q is semi-invertible but P I Q need not be. 7. For an arbitrary pattern, P, a definition \nof its standard semi-inverse, P-l, can be formulated in terms of reverse(P) , and it is shown that any \nsemi-inverse of P is match\u00adequivalent to P-l. A method for defining P l for an arbitrary pattern, P, \nis outlined. 8. Unambignity is defined, and is shown to be a simple sufficient condition for semi\u00adinvertibility. \n 9. The semantics of recursive pattern definitions can be defined using least fixed point techniques. \n The development in this paper has been exploratory and abstract, with only occasional references to \nprogramming applications in order to suggest interpretations or applications of algebraic features. Some \nof the ramifications of the model in terms of string manipulation language design are explored in [Stewart \n19741. BY choosing an algebraic rather than an interpretive model, we have been able to separate those \nissues inherent to the data structures and operations of pattern macthing from those concerned with its \nefficient implementation. Considerations of the latter type include pattern matching heuristics and backtracking. \nFurther, the algebraic model allows the language designer the liberty to incorporate the data and control \nstructures best suited to meeting specific language design goals. In contrast, Markov-algorithm-based \nlan9uages such as SNOBOL4 and COMIT have control structures that are strongly influenced by the concept \nof expression and statement continuations [Tennent 19731, which are in a sense the result of pattern \nmatching in these languages. In comparing the efficiency of pattern matching in the model presented here \nw: th that of the SNOBOL4 model, certain definitional differences must be taken into account For example, \nan optimization problem arises in patterns containing negative alternates In those parts of the pattern \nstructure containing negative alternates the possibility of cancellations precludes optimizations designed \nto avoid matching alternates remaining after a successful match. Commutativity of the alternation operator \nin the present model precludes the optimization, available to SNOBOL4 programmers, of ordering alternates \nby likelihood of successfully matching. However, it can be argued [Stewart 1974] that this optimization \nshould not be an implicit part of the pattern specification process, but rather should be deferred and \nprogrammed explicitly, when it is appropriate, as part of the pattern matching process. On parallel and \nvector computers, commutativity of alternation becomes an advantage, and the need for the optimization \ndiscussed above vanishes, since alternates can be matched in parallel against the subject string. Since \nthe order in which alternates are matched is important in SNOBOL4, there is very little opportunity to \ntake advantage of hardware parallelism, and on such machines the model we have proposed may very well \nprove to be the more efficient. 4. Acknowledgements The thesis work on which this paper is based was \ndone while the author was an M.SC. candidate under the supervision of Profeesor J. J. Horning in the \nDepartment of Computer Science at the University of Toronto. This research was partially funded by the \nNational Research Council of Canada. 5. References [Birkhoff 19671 G. Birkhoff, Lattice Theory, American \nMathematical Society Colloquium Publications, vol. XXV, ~an Mathematical Society. [Cohen and Wegstein \n19651 K. Cohen and J. H. We9stein, AXLE: An Axiomatic Language for String Transformations , CACM 8,11. \n[di Forino 1968] A. C. di Forino, Str~ng Processing Languages and Generalized Markov Algorithms , Symbol \nManipulation Languages and Techniques, Proceedings of the IFIP Work-nference on Symbol Manipulation Languages, \nD. G. Bobrow (cd.), North Holland Publishing COmPanY. [Donahue 1974] J. Donahue, Scottery , University \nof Toronto, Department of Computer Science, unpublished. [Doyle 1973] J. N. Doyle, A New Approach to \nthe Analysis and Synthesis of Strings , S4D38a, University of Arizona, Department of Computer Science. \n[Earley 1974] J. Earley, High Level Operations in Automatic Programming , SIGPLAN Notices 2,4. [Farber \net al. 19641 D. J. Farber, R. E. Griswold, I. p. Polonsky, SNOBOL, A Strin9 Manipulation Language , \nJACM Il. . [Galler and Perlis 19701 B. A. Galler and J. A. Perlis, A View of Programming Lanuages, \n. Addison-Wesley. [GimDel 19731 J. F. Gimpel, A Theory of Discrete Patterns and Their Implementation \nin SNOBOL4 ,-CACM 16,2 \u00ad[Goyer 19731 P. Goyer, ~Lfige SNOBOL4 et la Conformit6 Chaine-modele , Ph.D. \nThesis, Universit6 de Montr6al. [Griswold et al. 19711 R. E. Griswold, J. F. poa9e, I. P. Polonsky, The \nSNOBOL4  Programming Languager second edition, Prentice-Hall. [Griswold 19731 R.E.~swold, New Control \nMechanisms and Syntax for SNOBOL4 , S4D35a, University of Arizona, Department of Computer SCiW2Ce. [Jacobson \n1951] N. Jacobson, Lectures in Alqebra, D. Van Nostrand. [Minsky 19671 M. L. Minsky, Computation; Finite \nand Infinite Machinesr Prentice-Hall. [Reboh and Sacerdoti 1973] R. Reboh and E~r~i, A Preliminary QLISP \nManual , Stanford Research Institute, Artificial Intelligence Centre, Technical Note 81. [Redei 19671 \nL Redei, Algebra, Pergammon Press. [Scott 19701 D. Scott, Outline of a Mathematical Theory of Computation \n, Proceedings Of the Fourth Annual Princeton Conference on Information Science and Systems: ~n~ [Scott \n19721 D. Scott,!rLattice Theory, Data Types and Formal Semantics , ~ SYmPosium ~ Formal Semantics, Prentice-Hall. \n[Stewart 19741 G. F. Stewart, An Algebraic Model for String Patterns , University of Toronto, Computer \nSystems Research Group Technical Report No. CSRG-39. [Tennent 19731 R. D. Tenn~nt, M~thematical Semantics \nand Design of Programming Languages , University of Toronto, Department of Computer Science Technical \nReport No. 59. [Yngve 1972] V. H. Yngve, Computer Programming With COMIT II, M.I.T. Press. _ \n\t\t\t", "proc_id": "512976", "abstract": "", "authors": [{"name": "Glenn F. Stewart", "author_profile_id": "81100264532", "affiliation": "I.P. Sharp Associates Limited, Toronto, Ontario, Canada", "person_id": "P348467", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/512976.512994", "year": "1975", "article_id": "512994", "conference": "POPL", "title": "An algebraic model for string patterns", "url": "http://dl.acm.org/citation.cfm?id=512994"}