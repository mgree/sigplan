{"article_publication_date": "01-01-1975", "fulltext": "\n A Description of Path Expressions by Petri Nets Permission to make digital or hard copies of part or \nall of this work or personal or classroom use is granted without fee provided that copies are not made \nor distributed for profit or commercial advantage and that copies bear this notice and the full citation \non the first page. To copy otherwise, to republish, to post on servers, or to redistribute to lists, \nrequires prior specific permission and/or a fee.&#38;#169; 1975 ACM 0-12345-678-9 $5.00 P.E. Lauer and \nR.H. Campbell* Computing Laboratory University of Newcastle upon Tyne Claremont Tower, Claremont Road, \nNewcastle upon Tyne, England. Abstract: Petri nets are used to define a path and process notation which \nis more general in its ability to express synchronization than previous path notations. The Petri net \nclasses corresponding to the path notation prove to be interesting in their own right and have demonstrable \nproperties such as liveness and safeness. o. Introduction This paper is the first of a set of two joint \npapers written on the description of Path Expressions by Petri Nets. The concept of a path expression \nused in these papers is based on that introduced by Campbell and Habermann [1] as a new method of describing \nthe synchronization of processes. The example path notation used to illustrate this concept was shown \nto be equivalent to P and V operations of Dijkstra [3] with respect to its ability to express any given \nsynchronization. A set of transformation rules allowed any path expression in the notation to be translated \ninto an equivalent description of the synchronization based on P and V operations. In the present paper \nan equivalent definition of a subset of that notation in terms of Petri Nets [Petri 8] is given. The \ndefinition is subsequently used to extend the path notation by removing a restriction maintained in [1]. \nSimilarly, extensions are made from an elementary notion of process defined in terms of Petri Nets. In \nthe second of the set of papers, Campbell and Lauer [2], the resulting notation is applied to a synchronization \nproblem. Various synchronizations written in Path, Petri Net or P and V notation are compared and contrasted \nand several solutions are presented. A third paper, Lauer [4], was an initial attempt to describe the \nentire notation of rl] by means of Petri Nets. The path notation allows synchronization to be specified \nin terms of named actions. The actions are procedures capable of being executed by processes. Each procedure \nwhose execution is to be synchronized must be named in a path expression indicating its synchronization \nproperties with respect to the execut\u00adions of other procedures named therein. A process invoking a procedure \nnamed in a path expression may proceed to execute it provided the synchronization specified by the path \nexpression is not contravened, otherwise the process is delayed until it can execute the procedure without \ninfringing the synchronization restriction. In analogy to finite state acceptor mechanisms, path expressions \nwill be identified with the set of strings of actions they accept. Such sets can be regarded as the semantics \nof path expressions since each set uniquely describes the synchronization prescribed by all path expressions \naccepting the same set of strings of actions. Petri Nets may be thought of as dichromatic directed graphs \nin which no two adjacent vertices have the same colour. Colour of a vertex is indicated by its shape, \neither round or square. = vertices and square vertices are called ~laces and transitions, respectively, \nand denote conditions and events. A net, being a set of vertices interconnected with directed arcs, can \nbe used to describe arbitrary systems of occurrences of events. This interpretation is obtained by specifying \nthat an event may occur if all its ~ conditions hold in the system. This is indicated in the net by dra,wing \na directed arc from the places denoting the enabling conditions of the event, to the transition denoting \nthe event. Thus ~net specifies the set of all possible sequences of concurre= events of the system. The \nnet can alsO be used to simulate system behaviour by indicating the holding of a condition in the system \nby placing a token into the corresponding place in the net. Assume that a transition is enabled to fire \nwhen all its enabling places are marked,and that firing means subtracting a single token from each enabling \nplace and adding a single token on each place with a directed arc from the node to that place (the output \nplace). * This work was carried out as part of the Ph.D. Thesis of R.H. Campbell who was financed by \na grant from the Science Research Council. If two transitions share an enabling place with one token \non it, they are said to be in conflict over that place, both are enabled but only one will fire disabling \nthe other. This implies thai a marked net represents the set of all sequences of occurrences of events \n(firings of transitions) determined by the holding of the conditions corresponding to the marked places. \nA marked net is live if each of its component transitions is live. A transition is live at a given marking \nif there exists a sequence of firings which firesit for every marking reachable from the given marking. \nA marking is reachable from another marking if there exists a sequence of firings which transforms the \nlatter into the former. A marked net is safe if all its component places are safe. A place is safe at \na given marking if every marking reachable from the given marking has at most one token on that place. \nPetri nets corresponding to path expressions will have their transitions labelled with names of the corresponding \ncomponent actions of the path expressions. The occurrence graphs of Holt and Commoner [7] can be used \nto characterize the set of all possible sequences of firings of the transitions (executions of actions) \nof a net. This permits the identification of a net with the set of all possible firing sequences in analogy \nto the identification of path expressions with the set of strings of actions they will accept. A Petri \nnet simulates a path expression, if and only if, the set of strings of actions it generates is exactly \nthe set of strings of actions accepted by the path expression. In the sequel, an algorithm is specified \nsuch that given a path notation, the application of the algorithm to an arbitrary expression belonging \nto that notation will yield a corresponding simulating net. Proofs of theorems concerning path expressions \nand their corresponding simulating nets will be kept brief and informal in the present exposition. 1. \nElementary Paths Elementary path, E path for short, involve three synchronization schemes: sequencin~, \nselection and repetition. The syntax of E-paths is specified by four BNF like productions and a restriction \nas follows: Production rules: PI . path = -sequence end P2 . sequence = sequence; orelement I orelement \nP3 . orelement = orelement, element I element P4 . element = procedurename I (sequence) Restriction: \nRI . No procedure name may occur more than once in a path. Elementary paths are all and only those strings \nproduceable by P1-P4 and satisfying R1. 2. Simulating Nets of Elementary Paths Translation of an elementary \npath into its corresponding simulating net E-net for short, will be accomplished by application of the \nfirst of the following four transformation rules to the given path, followed by repeated application \nof the remaining rules to the intermediate results already obtained, until no rule applies. The transitions \nof the resulting net will be labelled only by procedure names. Each rule permits the replacement of a \npart of the net corresponding to the left hand side of the rule by the right hand side of the rule, preserving \nall markings (if any) on places involved in the replace ment. TRI. AL ,.% ..... ~ &#38; a O.elem*.t \n.,.L.J,J, A ( Sey. e ) TR3 TFi4 I o IK3 =) 0 eI. . .. t Figure 1 illustrates a possible transformation \nprocess prescribed by these rules. Before sketching a proof of the first theorem some terminology will \nhe introduced. In the diagrams below t~ and t~ are shared initial and terminal transitions, respectively \n ofR andP4; pl and pa are shared = and output places, respectively, of t] and tz. TI . E-nets are live \nand safe State Machines. Proof: First we show that all E-nets are State Machines. State machines are \nnets having shared input and/or output places, but no shared initial or terminal transitions [cf. Holt \nand Commoner 7]. None of rules TRI TR4 are capable of producing shared transitions. It remains to be \nshown that the resulting State Machines are live and safe. A necessa~ and sufficient condition that a \nstrongly connected state machine is live and safe is that every elementa~ circuit of the net have exactly \none marker on it. It is easily verified that TRI-TR4, when applied to E-paths, produce only strongly \nconnected State Machines each of whose elementary circuits pass through the place produced and marked \nby TRI from the g?ven E-path. The marker on this place is, furthermore, the only marker on the net. Q.E.D. \n3. Repeat Paths Repeat paths, R-paths for short, involve the same synchronization schemes as E paths. \nTheir syntax is likewise specified by means of PI P4 but without Restriction R1. Hence, in R-paths the \nsame procedure name may occur more than once. Two actions with the same name must be distinguished from \na single action whose name appears at two different occurrences in a path expression: The extension to \nR paths permits only the latter, indicating that the single action is subsumed under several sets of \nsynchronizing condit\u00adions. This means that the corresponding simulating net will only have a single corresponding \ntransition for the action, and this transition will be labelled by a single procedure name. 4. Simulating \nNets of Repeat Paths To obtain a simulating net of a Repeat Path, R-net for short, apply TRI-TR4 as before \nuntil none of these rules are applicable, keeping a record of all repeated procedure names. Then, starting \nat the marked place introduced by TR1 , let us call it the initial -of the net, apply TR5 successively \nuntil all repeated procedure names have been treated and TR5 no longer applies. For the algorithm to \nfunction correctly a new path must be taken every time the initial place is reached again. The first \noccurrence of a repeated procedure name X is treated by TR5(a), subsequent occurrences being treated \nby TR5(b) . rR5.(b) &#38; s *-~-  &#38; f!ji7ji .-, J.-I .-IL J-LJi\u00ad k, l + t> The transformation permits \nthe transition with label X to be enabled from n separate places in the net. n unlabeled transitions \nare introduced to supervise the enabling of X and a further n transitions are introduced to ensure return \nof the marker to the correct place in the net. Figure 2 is an example of a live and safe R net obtained \nby application of these rules. T2. R nets are live and safe Simple Nets. Proof: Again we begin by showing \nthat all R-nets are Simple Nets. A Petri net is a Simple Net (SN), if and only if every transition has \nat most one shared input place [Hack 6]. TR1-TR4 produce State Machines by T1. Thus it must be shown \nthat applications of TR5 to State Machines can only produce nets with at most one shared input place. \nThis is done by induction on the number of applications of TR5: (1) The net corresponding to the left \nhand side of the rule TR5(a) is part of a State Machine (SM) byT1. Application of the rule produces a \nright hand side embedded in this SM. Examination of the right hand side reveals that it contains no shared \ninput places and, hence, it satisfies the condition. (2) Assume that the left hand side of rule TR5(b) \nbelonLs to a net satisfying the condition, as induction hypothesis. An application of the rule will replace \nthr, left hand side by the right hand side thereby introducing transitions @ and t~ into the net, both \nof which satisfy the condition that they share at most one input place with another transition. Finally, \nit must be shown that R nets are live and safe. As yet no necessary and sufficient condition for liveness \nand safeness of general Simple Nets is known, hence, it must be shown that our particular subset of SN \ncontains only members having this property by recourse to the definitions of liveness and safeness [Hack \n6]. By T1 we know that nets produced from E-paths by TR1-TR4 are live and safe. Hence, it must be shown \nthat application of TR5 preserves this property. This is again done by induction on the number of applications \nof the rule: (3) By the above reasoning, transition xmust be firable On the left hand si&#38;e Of TR5(a). \nto must like\u00ad wise be firable and marks PI and pz on firing, increasing the total number of markers on \nthe net to two. X is the only transition enabled in this situation and on firing it will mark P3, leaving \nthe number Of markers on the net unchanged and enabling cl . When tl fires the total number of markers \nwill again be reduced to one. Hence, the structure introduced by TR5(a) into a live and safe net is itself \nlive and safe and preserves the liveness and safeness of the whole. (4) Assume as induction hypothesis \nthat the left hand side of rule TR5(b) is part of a live and safe net. It remains to be shown that the \nnet produced by one application of the rule will also be live and safe. Consider the labelled right hand \nside of the rule. Note that an application of the rule leaves all initial and. terminal transitions of \npz and pa , respectively, unchanged and the additional tz and t~ preserve the connections of the transition \n(of the latest repeated procedure name treated) to the rest of the net. A.SSUMe tl fires enabling tz, \nwhich is the initial transition to X just introduced by the application of the rule. tz is the only enabled \ntransition in the net by induction hypothesis. On firing, tz will mark pa and PA. Being the only enabled \ntransition, X will fire marking P3 and enabling only ta since all other placed in the subnet will be \nunmarked. On firing, ta will again reduce the total number of markers to one, which proves the theorem. \nQ.E.D. 5. Compound Paths Compound paths, C-paths for short, are collections of paths belonging to either \none of the simple classes of paths discussed so far. They can be thought of as being obtained by addition \nof a further production P5 to P1 P4 and satisfying the restriction R2 stated below: Pi. C-path = path \n[;path]* R2 . No procedure name may occur in more than one path. C-paths are CE paths ur CRpaths depending \non whether all constituent paths are E paths or at least one constituent path is an R-path, respectively. \n C nets corresponding to C paths are collections of the (disjoint) nets produced from the component paths \nof the C-paths. CE nets and CR nets are understood in analogy to their corresponding CE-or CR\u00adpaths, \n T3 . CE-nets are collections of live and safe E-nets. CR-nets are collections of live and safe R-nets \nand/or E nets. Proof: Immediate from Tl, T2 and R2. 6. General Paths General paths, G-paths for short, \nare C paths for which restriction R2 has been dropped. G paths obtained from CE paths and CR-paths will \nbe called GE-paths and GR-paths, respectively. A procedure named in several paths belonging to the same \nG-path can only be executed by a process if permitted by all synchronizations specified by these paths. \nC paths will, however, be considered to be special cases of G-paths. 7. Simulating Nets of General Paths \nSimulating nets of G-paths will be called G-nets. We will introduce GE-nets and GRnets successively, \nthus increasing the complexity of the nets to be considered by moderate steps. 7.1 General Elementary \nNets (GE-nets) The E-nets corresponding to the constituent E paths of the GE-path are obtained as in \nSection 2. To any two identically labelled transitions of the resulting nets the following rule TR6a \nis applied until all such transitions have been identified. TR6(a) . For n22: R6( )...+*.. ) . I-1 1 \n. . . .. n-l e-s .,. .. F)= : ;: - *... .. t= ...1* . .. m) Since components of GE paths are E paths, \nthere are initially,no shared initial and terminal transitions. The rule TR6a, Of cOurse~ permits arbitrarily \nmany shared initial and terminal transitions where the number of incoming arrows is always equal to the \nnumber of outgoing arrows. Note, however, 98 that the class of nets we obtain from live and safe State \nMachines by this rule is always uniquely decomposable into live and safe State Machines. Thus we obtain \na larger class of Petri nets than Simple Nets but not the entire class of general Petri nets. This seems \nto be a new class of nets which has not as yet been studied in petri net theory Fcf. Hack 61, but may \nbe close to the class of nets studied b,y Lautenbach in his recent Ph.D. Thesis [5]. The following two \nexamples illustrate the rule: 1.(a) -(A,B); Cend (b) WA; B end B 7 The net generates the following string \nof actisfia which is acceptable to the GE-path {(a),(b)?: ACBCACBC .,. Consider this string of actions \nwe can immediately write down an R-path which accepts it: 3.@12 A;C;B;C S@ which translates into the \nsimulating net hereby shown to be equivalent to the above net. 2. (c) m P;(M, S) end (d) -T; (R,M) end \nWhere useful and unambiguous, weP combine arcs leading {(c), (d)l M ? to the same place. R zs Note that \nthis net is live and safe. M only fires when both its enabling places are marked which is correct since \nM must occur exclusive of both S and R, whereas the latter need not occur exclusive of each other. T4. \nGE-nets are safe general Petri nets. Proof: The theorem follows from the assumption that the input and \noutput places of the net on the left hand side of TR6a are safe, and the fact that safe places can only \nbe made unsafe by identifying two safe places while keeping their initial transitions distinct. To appreciate \nthat the composition of two live and safe E-nets by means of TR6a may result in a GE-net which is not \nlive construct simulating nets for the following GE-paths: d J2QA;(B$C) =; S@ J.?Q4B:(A~~) Both examples \nproduce nets which are not live due to the existence of elementary cycles between A and B all of whose \nplaces are unmarked. Let us call such cycles empty cycles. There is, however, a class of generalized \nelementary paths for which we can already guarantee live\u00adness and safeness. Let Eo-paths be E-paths generated \nby P1 and P2 alone, and GEo-paths be c-paths such that each component path is an Eo-path but procedure \nnames may be repeated in more khan one path. GEo-nets are nets produced from GEo paths by TR1, TR2 and \nTR6s,. Provided we identify multiple arcs, the following theorem holds: . T5 . GE&#38;-nets are safe \nMarked Graphs. Proof: By T4 Next, we define GE~ paths as GEo paths such that no constituent paths contain \nsequences (s1 ,.. . ,s,) S1= ... xl . . . . ...%... . .x=n-~ ...;... x2n n =... satisfying X, = xzn and \nxi+, = .> , for i=2 by 2 until 2n 2. G%-nets form the expected subset of GEo-nets. T6. GE~-nets are live \nand safe Marked Graphs. Proof: We do not give a proof at this point, but such a proof depends on the \nfact that the presence of such sequences in a GEo-path is sufficient and necessary reason for the corresponding \nG~-net to contain an elementary cycIe with no markers, i.e. . an empty cycle. The latter is known to \nbe a sufficient and necessary reason for the marked Rraph not to be live. Hence, together with T5, the \nexclusion of such sequences in GEo paths guarantees the liveness and safeness of the corresponding marked \ngraph. 7.2 General Repeat Nets (GR-nets) The E-nets and R-nets corresponding to the constituent E paths \nand R-paths of the GR-path are obtained as previously. Treat combinable E nets as in the previous section. \nIf a transition t is of the form t, $-.! x tm t. it will be called a multiple transition t and t] through \ntm and t.., , through t. will be called its ,T . initiating and terminating transitions. Ordinary transitions \nwill be call~d simple. Next, combine all identically labelled simple transitions by TR6a until none remain \nto be combined. Finally, combine all remaining identically labelled transitions by the following rule: \nTR6(b) : If one is a multiple transition and the other is a simple transition: P2K*I Plm+r Pin P21 Note \nthat the input places and output places of the resulting net constitute a coding and a decoding net, \nrespectively. A construction of simulating nets of the following G paths, reveals that both nets are \nnot live for the resulting markings. All transitions of the net for the first example are disabled from \nthe outset, but the transitions of the net for the second example only become disabled after a finite \nsequence of firings, but both nets are trivially safe. Actually, the examples are G~ paths, where ~ paths \nare defined in analogy to GEo-paths. A consider ation of the examples indicates that even a restriction \nto G@ paths would not yield a sufficient and necessary criterion for liveness and safeness. Much work \nremains to be done to extend the earlier theorems to GE-paths, GE nets, GR-paths and GR-nets. In the \nremaining part of the pap r we express our belief that such extensions are obtainable by means of conjectures \nrather than theorems. ? cl : GR-nets are safe. C2: There is a restriction rl on G~-paths such that G@I \n-nets are live and safe. A construction of nets for the following examples will indicate some of the \ndifficulty involved in extending the restriction theorems to GE paths and GR paths: -A;B ~; * D;(B,C);A \nend and w C;A;E. ~; -(A,D);E;B end and &#38; (B;c).A@; @B; (C,A) end. Footnote: Recently, H. Schmid \nr9] communicated to us his belief that our conjectures can be shown t to be valid from recent results \nin Petri net theory by Commoner, Hack [6], Lautenbach [5] and H.J. Genrich. C3: There is a restriction \nr2 on GE-paths such that GEr2-nets are live and safe. C4: There is a restriction r3 on GR paths such \nthat GRr3 nets are live and safe. 8. Path Classes and their Instantiation It may be necessary to have \nmany instances of paths of the same general form but involving different instances of the actions named \nin them. The class notation is introduced to enable the programmer to indicate the general form of a \nclass of paths. Every time he requires a particular instance of a path belonging to the class he can \nuse a corresponding instantiation statement (analogous to a procedure call) and the corresponding path \nwill be created on execution of the statement. The syntax of class declarations and instantiation statements,is \nspecified by means Of the fOllOwing productions and their accompanying restriction: P6 . classes = Fclass \ncname; c-path endclass;]* . P7 . instantiation = [cname prefixname[,prefixname]*;l* R3 . Each cname is \nunique and its use in an instantiation must be accompanied by a corresponding class declaration. Each \nprefixname must be unique and different from the cnames. Classes together with their corresponding instantiation \nwill be identified with the paths thev give rise to when the instantiation are executed according to \nthe following rule: Suppose we have n classes and m instantiation involving the class names cni , l<isn, \nthe rule is TR7 . . class Cni ;c-pathi endclass c n~ c n~ (c-path, )pn,, .Cn, ;.. .;(pathlhl )Pn,, ,Cn,; \n. cnipn, l,. ... pnj~; . where (c-path)cn with the appropriate subscripts indicates the result of substituting \npn.cn for en mm c ~... . .. throughout c-path . Note that the class corresponding to cni is deleted and \nit.has thus been assumed that all instantiation involving cni have been treated according to this rule. \n9. Elementary Processes Elementary processes, E processes for short, are cyclic and involve only sequencing. \nTheir syntax is specified by two productions and a restriction as follows: P8 . process =y recess p sequence \nend P9 . p sequence = procedurename f;procedurename]* R4 . No procedurename may occur more than once \nin a process. 10. Simulating Nets of Elementary Processes Translation of an E process into its corresponding \nsimulating net, Eo net for short, will be accomplished by application of the first of the following transformation \nrules to the given process, followed by repeated application of the second rule to the intermediate results \nalready obtained, until ,6., .rc a.!e f-w-\u00adf J, . I I TR7. The set of Eo nets is a subset of the set \nof E nets. Proof: Immediate from a comparison of TRI 2 and TR8 9. Corollary. Eo nets are live and safe \nState Machines (Marked Graphs). Proof: That they are live and safe SM S is immediate from TI and T7. \nThat they are live and safe MG s follows from the fact that they have neither shared input nor output \nplaces. Note also that Eo nets are simulating nets of Eo-paths. 11. Repeat Processes and their Simulating \nNets Repeat processes, R-processes for short, are specified by P8 P9 but without restriction R4, permitting \nthe same procedure name to occur more than once in a process. Their corresponding simulating nets, % \nnets for short, are produced as in Section 1 .4 except that TRI-TR4 are replaced by TR8-TR9. T8 . The \nset of ~ nets is a subset of the set of R-nets. Proof: Obvious from above remarks. Corollary. ~-ne?cs \nare live and safe Simple Nets. Proof: Immediate from T2 and T8. 12. Compound Processes Compound processes, \nC processes for short, are collections of processes belonging to either one of the simple classes of \nprocesses discussed so far. They can be thought of as being obtained by addition of a further production \nPIO to P8-P9 and satisfying the restriction R5. PIO. C-process = process [;prOcess]* R5 . No procedure \nname may appear in more than one process. C-processes are E-processes or R processes as before and a \ntheorem corresponding to T3 may be obtained (cf. Section 1.5). 13. General Processes General processes, \nG-processes for short, are C processes for which restriction R5 has been dropped. GE-processes and GR-processes \nare defined analogously to G paths in Section 1.6. A procedure named in several processes belonging to \nthe same G-process can be executed by any of the processes independent of the others. C processes are \nconsidered to be special cases of G processes. This leads to an interpret ation of multiple occurrences \nof procedure names analogous to the interpretation of the same fact in R-paths. 14. Simulating Nets of \nGeneral Processes Simulating nets of G-processes will be called R~-nets. They are obtained from the Eo-nets \nand ~-nets corresponding to the constituent E-processes and F&#38;processes, respectively of the G-processes \nby means of rule TR5. Note, however, that the resulting nets seem to resemble ~ nets if we disregard \nmarkings. When markers are considered we see that there are as many markers on the net as there were \nconstituent processes of the G process, This is indicated by the superscript n in R~ net. Thus the earlier \nRo nets are really ~ nets, and the earlier G-nets are really G -nets. But all the resulting nets were \nsafe in the sense of the definition in the proof of T2. In the present context it will be useful to employ \na more general notion of safeness. A Petri net is m-safe at marking M if and only if every place of the \nnet is m safe at marking M. A place is m-safe at marking M if and only if every marking M! reachable \nfrom M has at most m markers on the place. Thus the old notion of safeness is now seen to be the same \nas one safeness. C5., R~-nets are live and m safe Simple Nets, I<msn and m is the maximum number of processes \nof the corresponding G-process sharing a procedure name. Consider the following example GE-processes \n(Eg. 1 3) which will ultimately be used to generate a program which deadlocks.1 ) E L. E,,2 E4.3., r \n1) Footnote: The program is a representation of the so called Smokeri s Problem which is studied bv means \nof the present formilism in [2], The resulting R1-nets are disjoint, having no names in common. They \nwill be linked by means of the path expressions of Eg. 4 which constitute a CEo path and are accompanied \nby their corresponding CEo-net. 15. Programs The syntax of programs is specified by adding two productions \nto productions P1-P9 and keeping restriction R3 while dropping all other restrictions. P1O. program = \nQ.@ classes instantiatiOns cO-Path C-prOCeSS@ Ph. Co-path = [path;]* Programs are all and only those \nstrings producible by productions P1 PII and satisfying restriction R3 . Due to TR7 we can identify programs \nwith ordered pairs of the form J2%i2 o-path -Pr C ss@. 16. Simulating Nets of Programs Simulating nets \nof programs, P nets for short, are obtained by reducing their component G-paths and G-processes to G \nnets and R~ nets, respectively, and then applying TR6 successively to the intermediate results until \nit is no longer applicable. The number n will be the sum of the number of component paths and the number \nof component processes in the original program. Next, we give an example of the result of applying the \nrule to the program resulting from a combinat ion of examples Eg. 1-4. The net obtained from this program \nis a P!e net which is one-safe but not- Multiple transitions will be simply represented by where it is \nunderstood that markers will move from input places to corresponding output places and t is enabled when \neither or both input places are marked. The example Fig. 3 is presented in abbreviated form for ease \nof considering aspects of relevance to liveness. Lines denote paths, broken lines processes. Although \nno sufficient and necessary criterion of liveness and safeness of P nets is known, it is easy to see \nthat the above net is not live by observing that the subnet involving d,b,f,k,i and g is capable of absorbing \nas many as three markers from PI -Pa withOut enabling either k,i Or g. An examination of the rest of \nthe net shows that at most two of Pi ,Pz or Pa can be marked without one of k, i or g firing. Hence, \nthe possibility of deadlock is demonstrated. Finally, we give an example program whose simulating net \nFigure 4 does not deadlock. The program is obtained from the program of Figure 3 by adding the R path \nof Figure 2 and replacing the last three processes by the following processes: -process b;o ~; yrocess \nd;p ~; ~rocess f;q @; yrocess t;g ~; yrocess r;k end; yrocess s;i end. 17. Ittresenting Petri Nets and \ntheir Simulation by Path Expressions For completeness we mention that safe General Petri nets may be \ndescribed by the path and process notation. The following transformations may be applied to such a net \nto yield a set of path expressions and processes to simulate that net. The firing rules for transitions \nwill be built into this representat\u00adion due to the implementation and semantics of the path notation. \nTR1 . TR2 . - (El, E2, ,. ... Ej); (Al, A2, . . ..A~) end; ,~, or if the place is marked:-P@ (AI ,%, \n. . .. Ak). (El, E2, . . ..Ej) end: Ai and Ej are the actions of removing a marker from or placing a \nmarker on a place respectively and t the action of the transition firing. To complete the description \nof the Petri net a set of processes are introduced to invoke each action. 18. Conclusion A path notation \nwhich is more general in its ability to express synchronization than that given in [1] has been presented. \nThe semantics of this notation has been formally specified by a set of transformations which translate \nprograms using path expressions and processes into Petri nets which sj.mulate them. The use of Petri \nnets permitted a systematic extension from an elementary path notation to the most general class treated \nin this paper. In addition, the Petri nets justify our extensions of the path notation by provid\u00ading \na machine independent implementation. The results obtained in this paper should motivate further attempts \nto extend our knowledge of the properties of the more complex types of Petri nets we have defined. The \nnew classification of Petri nets should, furthermore, allow the determination of liveness and safeness \ncriteria for a large class of nets which had hitherto been lumped with general Petri nets, about which \nlittle has so far been proved. Finally, we have completed a set of transformations between various synchronization \nmechanisms. Path expressions can describe P and V operations and P and V operations can describe path \nexpressions [1]. Now we have shown that path expressions can describe l safe general Petri nets and that \nPetri nets can describe Path expressions. A claws of Path expressions has now been shown to be equivalent \nto message transfer systems MTEfs by Bill Riddle [10]. This came as a surprise since in [12] itwasmaintained \nthat MTE1s are only properly contained in Petri nets. In [11] Bill Riddle demonstrates equivalence of \nMTE s and Petri nets. Acknowledgements We gratefully acknowledge the helpful conversations we have had \nwith our colleagues, in particular with Mike Melliar-Smith. Bibliography [1] Campbell, R.H. and Habermann, \nA.N.: The Specification of Process Synchronization by Path Expressions, University of Newcastle upon \nTyne, Computing Laboratory, Technical Report Series, No. 55). [2] Campbell, R.H. and Lauer, P.E.: A Spectrum \nof Solutions to the Cigarette Smokers Problem, An application of the description of path expressions \nby Petri nets, Computing Laboratory, Newcastle upon Tyne, Technical Report Series, No. 63. [3] Dijkstra, \nE.W.: Co-operating Sequential processes. (In Programming Languages, F. Genuys, Ed. Academic Press, New \nYork, 1968). [4] Lauer, P.E.: Path Expressions as Petri Nets, or Petri Nets with Fewer Tears, MRM 70, \nComputing Laboratory, University of Newcastle upon Tyne, 10 January, 1974. [5] La~tenbach, K.: Exakte \nBedingungen der Lebendigkeit ftir eine Klasse von Petri Netzen, BMFT-GMD-82, Gesellschaft Fitir Mathematik \n~nd Daten Verarbeitung, Bonn, 1973. [6] Hack, M.H.T.: Analysis of Production Schemata by Petri Nets, \nMasters Thesis, MIT, Feb., 1972. [7] Holt, A.W, and Commoner, F.: Events and Conditions, Applied Data \nResearch, New York 1970. [81 Petri, C. A.: Kommunikation mit Afitomaten (Communication with Automata) \nPh.D,, Thesis 1962, Technische Hochsch~le, Darmstadt. [9] Schmid, H.A.: An Approach to the Communication \nand Synchronization of Processes, In: International Computing Symposium 1973 (Eds. Gunther, A. et al) \nNorth-Holland Publ. Co. 1974. [10] Riddle, W. E.: A Comparison of Path Expressions and Message Transfer \nExpressions, Systems Research Memo SRM/93, The University of Newcastle upon Tyne Computing Laboratory, \n3 ,July, 1974. [11] Riddle, W.E.: The Equivalence of Petri Nets and Message Transfer Models, Sys-hems \nResearch Memo SFW1/97, The University of Newcastle upon Tyne Computing Laboratory, 21 August, 1974. Peterson, \nJ.L. and Bredt, T.H.: A comparison of models of parallel computation, Proc. IFIP Congress 1974, Stockholm, \nAugust 1974, North Holland, Amsterdam 1974, pp. 466-470. rlzl Flg2 R-path and R-netFlg 1 E-path to E-net \n1 path o,((p, r), (q, s)) end  2-lTR1 3 0 ((p, r), (q, s)) v 1) o , 2,TR2 4 o ((pjr) 3, TR4. TR3 (q, \ns) % 4, TR4, TR2 @!! (o, ((p; r). (q:. ))), (p; ((o; r), (q:t))) .(q; ((o:s). [p:t))) @ Flg 4 Abbreviated \nP net which is I!ve and safe ~-- .-..... . . . . . . ---.+ - ----.__ . ..__ ... 1 .-..-l$t!Es F@ 7- ------____ \n____ ___  d: --~----i-----------\u00ad  ,,,,,, ------}/-- --{----t--l-l--- m m I , v\\w M l,, ,, .-Q .-Q \n,-=(2 1 1 trs gg y$ ,. ---\u00ad .i---o fi (?----------.2 ... L --- - -- 4, , ---% L LL beEi. D.th a;b end; \nD.th c;J end; D.th e;f g; a g;h end: D.th i;j end; path k;l end; mth .;. @; I@ (.; (((p; r), (q; .))) \n<(p; ((.; r), (q; t))) .(q; ((.; .), (p; t))) -; m .;. ;e end; . . . ..ss .; .;. end; woces . m; e:. \ns@: ~ h;. end; process j;. g: ~ 1:. ~; ~ f:o~; ~ d:p end: Process b:q Q; ~t;k~; ~ ,; l@; ~ s:g~; *. \n105 \n\t\t\t", "proc_id": "512976", "abstract": "Petri nets are used to define a path and process notation which is more general in its ability to express synchronization than previous path notations. The Petri net classes corresponding to the path notation prove to be interesting in their own right and have demonstrable properties such as liveness and safeness.", "authors": [{"name": "P. E. Lauer", "author_profile_id": "81100329205", "affiliation": "University of Newcastle upon Tyne, Claremont Tower, Claremont Road, Newcastle upon Tyne, England", "person_id": "PP43140873", "email_address": "", "orcid_id": ""}, {"name": "R. H. Campbell", "author_profile_id": "81100212328", "affiliation": "University of Newcastle upon Tyne, Claremont Tower, Claremont Road, Newcastle upon Tyne, England", "person_id": "PP43137626", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/512976.512987", "year": "1975", "article_id": "512987", "conference": "POPL", "title": "A description of path expressions by Petri nets", "url": "http://dl.acm.org/citation.cfm?id=512987"}