{"article_publication_date": "01-01-1975", "fulltext": "\n Permission to make digital or hard copies of part or all of this work or personal or classroom use is \ngranted without fee provided that copies are not made or distributed for profit or commercial advantage \nand that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, \nto post on servers, or to redistribute to lists, requires prior specific permission and/or a fee.&#38;#169; \n1975 ACM 0-12345-678-9 $5.00 A i]ATt{EMATI CAL APPROACH To LANGUAGE ~ESIGrl : George T. Ligler Programming \nResearch Group Oxford [University Abstract: A framework for validating surface properties of programming \nlanguage constructs , composed of proof rules (akin to those of lIoare) and supporting hypoth\u00adeses, is \nconstructed using the mathemati\u00adcal semantics of Scott and Strachey. The following approach to language \ndesign is then considered: the constructs of a language should have surface properties which l)need few \nhypotheses other than assumed surface properties; and 2)have proofs consisting, as far as possible, of \ntrivial fixpoint and structural induc\u00adtions. o. INTRODUCTION The mathematical semantics Of Scott and \nStrachey [7,10,14,16,17,20,21] is capable of defining realistic programming languages fully in a concise, \nflexible, and mathematically rigorous fashion. It is therefore no surprise that properties of programming \nlanguage constructs ex\u00adpressed in notations similar to that of Hoare [1] can be validated as theorems \nwith respect to a language description written in mathematical semantics. Such verification further ensures \na consist\u00adency of those properties which might be difficult to obtain were a more intuitive approach \ntaken towards their formulation. This research was supported by the Rhodes Scholarship Trust, Oxford, \nEngland. Section 1 of this paper presents a frame\u00adwork for the validation of surface proper\u00adties, which \nessentially consist of proof rules and hypotheses, in mathematical semantics . In Section 2, the techniques \nof Sec\u00adtion 1 are used to form the mathematical underpinnings of an experiment in language design. In \nthe belief that correct and well-formulated surface properties provide a subject of interest to both \nsemantic theorists and the rest of the computing community, we consider the consequences of having a \nh ai!idation Criterion as an impor\u00adtant goal of our design efforts. Loosely speaking, we require the \nconstructs of a language to possess surface properties with few qualifying hypotheses (that are not then.selves \nsurface properties) and easy, if not short, formal proofs. Satis\u00adfaction of the Ilalidation Criterion \nwill be seen to imply greater semantic clarity in a language: that is, not only will both the semantic \ndescription and surface properties of each construct be less com\u00adplicated, but a construct will also \nhave fewer surface properties whose respective sets of qualifying hypotheses are mutually exclusive. \nWe shall discuss general prin\u00ad ciples of design emanating from our ap\u00ad proach as well as the effect of \nour cri\u00ad terion on the design of a number of parti\u00ad cular constructs. 1. A FRAMEWORK FOR SURFACE PROPERTY \nFORMULATION AND VALIDATION After defining the notion of surface property, we discuss proof-oriented \nse\u00admantic descriptions , which aid our vali\u00addation efforts. We then introduce 3, a function which evaluates \npredicates on program variables in terms of semantic functions from the proof-oriented descrip\u00adtion of \nthe programming language under consideration. Finally, we give an exam\u00adple of surface property formulation \nusing mathematical semantics. 1.1. SURFACE PROPERTIES lie begin with an arbitrary program\u00adming language \nP. A surface property of a construct r of P consists of a triple ( (P,Q), ~, (7z,, . . . . hn)) , where \n(1) (P,Q) is an ordered pair of elements of some syntactic predicate domain[15] Pred, members of which \ncorrespond to productions of a BNF-like grammar such as Pred ::= Expr 1= Exprzl Predl APred~l PredlvPred*l \n-Pred. Here Expr is the syntactic category of expressions in P. The formulation of Pred depends on the \nnature of P, as will that of many other syntactic and semantic domains; we shall refer to such domains \nas P-domains. (2) (h,, . . . . hn) is an n-tuple of lzypotk\u00adeses. llypotheses fall into three cat\u00adegories \n: (a) Assertions about the syntax and execution of r. (b) Statements about the interdepend\u00adence of program-variable \nvalues. (c) Other surface properties.  Satisfaction of the Validation Criter\u00adion of Section 2 will \nimply that sur\u00adface properties contain few hypotheses of types (a) and (b), which will be called qualifiers. \n. The intention of the above definition can be made clear by using the notation of Hoare [1]: if hi through \nhn hold$ then P{r}Q. Syntactic substitution of Exprl for Exprz in Pred, Pred[Ezprl/Expr~], can be rigorously \ndefined. In practice, Expr, is either an identifier, a (possibly com\u00adposite) selection on an identifier \nof structured type, or an array or vector application; we call such expressions assignab2es. We define \ntwo assignable to be related if l)they are identical; 2)one is a selection on an assignable re\u00adlated \nto.the other; or 3)one is an array or vector application of an array or vec\u00adtor related to the other. \nWe shall use this last notion in 1.4., 2.1,3., and 2.2.7. We require an explicit predicate syntax in \norder to be afile to carry out structural inductions on Pred when neces\u00ads ary. Our restriction of possible \npredi\u00adcates on program-variable values to such a syntax does not entail a loss of gener\u00adality, however, \nsince any useful predicate of this type can be constructed from a fairly small set of generators. Predi\u00adcates \ninvolving scope and instances of structured types will be discussed in 2.2.6. and 2.2.7., respectively. \n1.2. PROOF-ORIENTED SEMANTIC DESCRIPTIOTJS The flexibility of the definition techniques of Scott and \nStrachey implies that our surface property validations might be based on any one of a number of equivalent \n(in a sense to be discussed below) semantic descriptions of P; we restrict ourselves to proof-oriented \nsemantic descriptions. A proof-oriented semantic description of P, E(P), has the following characteristics: \n(1) Abstraction denotations are text\u00adenvironment pairs simj.lar to the cZosures of Lanolin [4]. (2) \nThe denotations of label identifiers and special jump identifie~s (see 2.2.6.) are eontinuat<on-enuironmezt \npairs [7], where the second component contains, if necessary, information about how the a~~ea [16] of \nthe ab\u00adstract store is influenced by the jump involved. (3) The program-ansuer P-domain A includes P-domains \nlike those of abstract stores (S), environments (Env), and expressed vaZu.. (E) as summands (see [20]). \nThe functionalities of eo?z\u00adtinuatiorz domains [10,20] associated with various semantic functions are \ndefined accordingly. (4) Each semantic domain B contains an error element,  B Condition (1) acts as \nan aid to proofs of the surface properties of abstraction calls by easing formulation of context conditions \n(e.g. , testing whether an identifier is a free variable of an ab\u00adstraction) ; it also makes possible \ndirect proofs (by fizpoint [6,8] and structural inductio~s) both of necessary continua\u00adtion-removal theorems \nand of propositions involving wide classes of constructs of P. By a continuation-removaZ theorem (see \n[7,12]), we mean a result justifying the decomposition of an expression written in continuation semantics \n[21] into a form allowing specification of intermedi\u00adate ansuers, that form usually containing functional \ncomposition of some sort. For example, if QEC=[S+S] is a con\u00adtinuation and Y has functionality C+c, then \nwe might wish to consider the condi\u00adtions under which Y{(3}CJ = @.Y{au, .ol}u, where o and CT, are elements \nof S. Condition (2) helps discussions of the surface properties of jumps, while (3) implies that elements \nof domains which are important to our validation efforts may be used as intermediate an\u00adswers . Finally, \n(4) permits greater latitude in the specification of error con\u00additions. The results of Reynolds [12] \nand Milne [7] provide means for discussing the equivalence of different mathematical se\u00admantic descriptions \nof a language in the following sense: if correspondences be\u00adtween the elements of respective semantic \ndomains are defined (the existence of a general class of such correspondences is proven in the above \nreferences), then two descriptions are regarded as equivalent if, whenever they are used for correspond\u00ading \nevaluations, they give corresponding answers , Consequently, we can show that our insistence on having \nproof-oriented semantic descriptions does not imply a loss of generality. We stress that E(P) is meant \nto be used for the disc-ussion of implementation\u00adindependent properties of P. Our stores and environments \nare abstract, and the primitive operations on these semantic entities indicate the features common to \nimplementations. Therefore, when an ele\u00adment of L, the domain of abstract loca\u00ad tions, is mentioned in \nE(P), one is con\u00adsidering a mathematical value which might be reaZized as a bit, word, or group of words \nwere P to be implemented. llilne [7] discusses the correctness of implementa\u00adtion techniques by showing \nwhether or not they satisfy the conditions put on them by semantic descriptions. 1.3. %, TIIE EVALUATIVE \nFIJNCTION With Pred and 5(P) defined, semantics may be given to elements of the former using 1: Pred \n+ [Env + S + T], where + signifies that the function space being specified need not consist purely-of \ncontinuous functions. As mentioned in 1.2., Env and S are the P-domains of environments and stores, respectively; \ntheir defining equations are given in E(P) (sampie defining equations and an indication of their variety \nmay be found in Strachey [20]). T is a semantic domain of truth values. ~ is defined in terrrrs of the \nsemantic functions of E(P) and equal\u00adity relations between elements of seman\u00adtic domains. The surface \nproperties defined in  1.1. can now be formulated as follows: if hl through kn hold, then (1) 3[P]P0 \n= true implies ~[Q]PiIsi = true. In (l), p, and CJ, depend on r, p, and a and are calculated using the \nequations of E(P). For example, in Algol 60, p, = p for all r except declarations and jumps; for a declaration \nof an identifier Ide, p, would equal p[6/lde], where 6 is an element of D, the Algol-domain of denoked \nva2ues (see [20]); and for a jump goto L, Pi would be the environment component of the denotation of \nL in p. The flexibility of mathematical se\u00admantics implies that 3 could well be defined with other functionalities. \n~lJe have simply picked a definition which in\u00adcorporates the minimum which must be ex\u00adpected of this \nevaluative function: existence and dependence on Pred, Env, and S. 1.4. AN EXAMPLE-SIMPLE ASSIGNMENT \nIN ALGOL 60 }ie now consider the formulation of a surface property for an Algol 60 assign\u00adment statement, \nx := e, where z is not a function identified-. The most fruitful way to proceed is to picli tile predicates \nP and Q of 1.1. and then find those ki which make the va lid.ation of ( (P,Q), x := e, (k,, . . ..hn)) \npo~sible. In general, such searches for suitable hypotheses often suggest more sensible P-Q pairs for \nthe construct under consideration. Accordingly, we let P be S [e/x] (see 1.1.) and Q be S, where S is \nany member of an appropriate Pred syntax for Algol 60; this choice gives us a surface property analogous \nto the assignment proof rule of lIoare [1]. Ne wish. to show for all p and o, 3[S[e/x]]pO = true implies \n (2) 3[S]P01 = t~ue, where 01 = C[x := elp{A02. cJ2}0. In (2), c is the semantic function of E(Algol \n60) giving meaning to Algol commands , with functionality Cmd + Env +C -+S+ A, where C = S + A is the \nA.lgol-domain of command continuations. E(Algol 60) may be derived straightforwardly from the semantic \ndescription of the language given in [10]. Iiypotheses sufficient to ensure the validity of (2) are enumerated \nbelow> with each ki being followed by its formulation in mathematical semantics. kl : the evaluation \nof x := e terminates without error C[x := e]p{i02.02}o is not LA (see [15]) or ?A. kj : the evaluation \nof e has no side effects WeloT{AR. lo2.02}o = o, where ti is the semantic function of E(Algol 60) giving \nmeaning to Algol 60 expressions which can appear on the right-hand side of an assignment statement; ~ \nis an appropriate type argument. h, : x does not skare with any other assignable (1.1.) A in S; that \nis, the abstract location which x denotes is not the L-va2ue [18,19] of A or any assignable related to \nA Notskare[x][S]pO = t~ue. liotskare , like Safe and Donnam. (below), may be defined in much the same \nfashion as 2 . We emphasize that lieare defining sharing as a property of Algol 60, not of an implementation \nof Algol 60. h : x neither shares with or is a free variable of an abstraction applied in S Safe[x][S]po \n= true. 72, : the change in the value of x does not change that of a call-by-name param\u00adeter which does \nnot share with x but is evaluated in S 7ionname[cc][S]pu = true. Ifh,, lz4, or h~ fails to hold, we say \nthat x occurs implicitly in S. Such problems of implicit occurrence demon\u00adstrate the inadequacy of syntactic \nsub\u00adstitution in program-variable predicates (1.1.). TO illustrate h , we give a situation in which our \nother hypotheses are assumed to hold and (2) is not valid: (a) S is y = funny(2) (b) e is 3 (c) funny \nis an abstraction which takes an integer parameter n and has the fol\u00adlowing body: begin funny := x+n \nend (d) the R-va2ue [18,19] of z is not 3 with respect to p and a. As for h,, let (a), (b), and (d) hold \nas above and let y be an identifier which is a formal name parameter of an abstraction g in whose body \nt!le assignment statement under consideration is assumed to occur. Finally, assume that the con\u00adtext \nin which x := 3 is being evaluated is a call of g with an actual parameter if x=3 then doubZe(2) else \n1 corresponding to y. Given hl through hs and the basic continuation-removal theorems (1.2.) for E(Algol \n60), the proof of (2) follows principally from structural inductions on Pred and the syntactic category \nof Algol expressions. Although a completely formal proof is extensive, it is both easy and of a length \nproportional to the size of the syntactic categories involved. 2. LANGUAGE DESIGN We now consider the \ndesign of pro\u00adgramming languages with satisfaction of the following Validation Criterion as our goal \n: the constructs of a language should have surface properties which have both few qua2ifiers(l. 1.) and \nproofs in mathematical semantics which mainly consist of straightforward fixpoint and structural inductions. \nThe author has designed a series of block\u00adstructured, procedure-oriented program\u00ading languages on this \nbasis> and in the rest of the paper, the most important features of these languages will be dis\u00adcussed. \nAlthough few of these features are new, our reason for including them may cause them to be seen in a \nfresh light. Examples will be drawn from ProofLS, one of the languages in the aforementioned series; \nour treatment will be informal, because the principles of language design involved, not any par\u00adticular \nlanguage, are the center of our attention. An important consequence of our de\u00adsign approach has been \nthe formulation and fortification of the belief that pro\u00adgramming languages should be designed in a global \nmanner, rather than construct hy construct, because the surface proper\u00adties of constructs are intricately \ninter\u00addependent. For example, the assignment statement discussed in 1.4. has surface properties which \ndepend on the design of the following language features: (a) expressions presence of side effects (b) \nsharing (c) abstractions treatment of free vari\u00adables and choice of parameter trans\u00admission mechanisms. \n  We have found few constructs which satisfy the Validation Criterion in isolation; conversely, many \nconstructs not mentioned in this paper might be integrated into some programming language without viola\u00ad \nting our standard. At best, only one qualifier, that assuming termination and error-freedom, will need \nto be used in the formulation of surface properties. The use of this hy\u00adpothesis.has one large notational \nbenefit: since error-freedom is assumed, we can ignore type-checking when proving surface properties. \nThus some of the most intri\u00ad cate parts of our semantic descriptions (like that in [10]) may be discarded. \nAnother aspect of our approach to language design is that the constructs of a language which satisfies \nour criterion will have surface properties with proofs whose lengths are proportional to the num\u00ad ber \nof clauses in the syntax of that lan\u00ad guage. It is doubtful that a better rela\u00ad tionship can be achieved. \nRemarks about syntax and semantics, puns and name clashes, and sharing will be found in 2.1. A second \nsubsection dis\u00adcusses the design of specific language constructs. Although the constructs in\u00adcluded (1) \nare by no means claimed to form a complete (or optimal) set; and  (2) can in several cases be designed \nin a number of adequate ways, one of which is chosen for ProofLS,  it is hoped that their description \nwill illustrate the major consequences of our mathematical approach to language design. 2.10 GEl?ERAL \nREMARI(S 2.1.1. Syntax and Semantics A fundamental principle which has emerged from our approach is that \nlanguage features with different surface properties should have distinct syntaxes. The alter\u00adnatives \nto adopting this policy are (1) to formulate several sets of surface properties for the same syntactic \ncon\u00adstruct, each having qualifiers which describe the semantic case under con\u00adsideration; or (2) to \nuse surface properties made more general (when possible) by the inser\u00adtion of both additional surface\u00adproperty \nhypotheses and P-Q predicate pairs with complex internal struc\u00adture however, this generalization makes \nvalidations more difficult and surface properties less clear.  The syntactic differentiation advocated \nabove also facilitates confining the con\u00adtexts in which various language features can occur; for example, \nexpressions with side effects can be syntactically re\u00adstricted to a small subset of the con\u00adstructs of \na language. The effect of such limitations of context is to make our validation task easier without forcing \nus to reject language features which, if used carefully, are compatible with the Validation Criterion. \nIn our view, syntax should play an active role in helping to provide semantic clarity for a programming \nlanguage. The process of language design thus becomes more continuous and cannot be fragmented into l!syntax!l \nand semantics stages. Indeed, we agree with the opinion of Strachey [20] that the consideration of \nsemantic domains should be among the first steps in the design of a language.  2.1.2. Puns and l{ame \nClashes A second point derived from this mathematical attempt at language design is that puns should \nbe eliminated. For example, the function result mechanisms in Algol 60, Pascal, and, Fortran involve \nassigning to an identifier which in other contexts is of an unassig,nable type; be\u00adcause this does not \nhappen with any other types of assignment (apart from name clashes), the use of such~ devices runs counter \nto the spirit of 2.1.1. The rejection of this result pun accordingly simplifies the semantic description \nof both assignment and result-producing ab\u00adstractions, thereby easing our validation task for those constructs \n(~ie discuss a replacement result mec!lanism in 2.2.6.). If this pun is not eliminated, the only alternative \nto accepting more complicated validation proofs is to include extra qualifiers: the example of 1.4., \nstrictly speaking, should have had our assumption about x not being a function identifier as a sixth \nhypothesis. Along much the same lines, the only name clashes allowed are dynamic. These arise from two \nsources: (1) local variables and formal parameters of recursive abstractions; and (2) free va~iables \nof fixed abstractions  (see 2.2.5.3.). We can assume the existence of a pre\u00adprocessing operation that \nremoves textual name clashes from a programming language without this specification we then at\u00adtempt \nsurface property validations with respect to the preprocessed language.  2.1.3. Sharing Indiscriminate \nsharing greatly com\u00adplicates any attempt to prove the surface properties of a construct, since changes \nto the value of an assignabZa (1.1,) might well alter the values of unrelated assignable that occur$ \nexplicitly or implicitly, in the predicates under con\u00adsideration. For this reason (others may be found \nin Iioare [3]), the type pointer is prohibited in our languages; this exclusion, however, is not in itself \nenough to remove sharing qualifiers simi\u00adlar to h, of 1.4. from surface properties. In the absence of \npointer variables, languages with capabilities similar to those of ProofLS, which does not have facilities \nfor parallel processing, can contain three main sources of sharing between unrelated assignable: (1) \nfeatures similar to the EQUIVALENCE statement in Fortran; (2) assignment involving instances of structured \ntypes; and (3) parameter transmission.  The first two of these sources must be eliminated if the Validation \nCriterion is to be met; ProofLS has no equivalence statements and uses copy rules . The third cause, \nhowever, need only be re\u00adstricted. Sharing can result from parameter transmission because (a) corresponding \nactual and formal para\u00admeters might share with respect to the environment used in the evaluation of the \nbody of the abstraction being applied; or (b) distinct formal parameters might share because their corresponding \nactual parameters share.  If the dictates of 2.2.S.2 are followed and if ~i~ we rules like the s\\lbstitu\u00adtion \nproof rule of 2 .2.5.1. , sharing of type (a) necessitates neither extra quali\u00adfiers nor complex syntactic \noperations on predicates. We limit sharing of type (b) to that between formal parameters passed by mechanisms \nwhich do not allow those parameters to have their values altered; in ProofLS, ealZ-by-expressed-vaZue \n(see 2. 2.5.1.) is such a parameter mechanism. Perhaps the occurrence of other type (b) sharing indicates \nthat an abstraction has has been either misused or improperly de\u00adsigned, since surface properties of \nits body cannot be extended to those of its call without the inclusion of sharing qualifiers. ProofLShare \n, a variant of ProofLS, has the ProofLS restrictions on sharing with one exception: unrelated assignabies \nof structured type are allowed to share as a result of assignment operatioris invol\u00ad ving instances of \nstructured types. If we limit the contexts in which such as\u00adsignments can occur (2.2.1.,2.2.7.), sharing \nqualifiers need not be included in the surface properties of most constructs; this is another benefit \nof following the dictates of 2.1.1. Although it meets the Validation Criterion less fully than ProofLS, \nProofLShare is useful as a tool for the analysis of the surface proper\u00adties of structu~,e-abstractio??s \n(2.2. 7.) in sharing situations. 2.2. THE DESIG:J OF SEVERAL LAIJGIJAGE CONSTRUCTS 2,2.1. Expressions \nProofLS has two syntactic categories, Fullexp and Exp, for expressions with and without side effects, \nrespectively. It can be shown that Exp satisfies this spec\u00adification: that is, if the evaluation of an \nelement of Ezp terminates without error, an equation similar to that for hypothesis h, of 1.4. is valid. \nThe proof of this proposition follows from the con\u00adtinuation-removal theorems of ProofLS (1.2.) and a \nstructural induction on Ezp, in which the abstraction application case is proven using both fixpoint \nand struc\u00adtural inductions. The formal proof, al\u00adthough lengthy for a syntactic category as large as \nEXp, is straightforward. Given this result, much of our validation task may be done implicitly by requiring \nExp in our syntax. Additionally, we use only Exp in Fred syntax (1.1.); the in\u00adfluence of this decision \non the free\u00advariable qualifier k~ of 1.4. will be discussed in 2.2.5.3. The FulLexp-Exp distinction implies \nthat expressions with possible side effects can be used without hindering our validation efforts provided \n(1) the contexts in which such expressions can occur are limited, so that the surface properties of most \nconstructs will need neither qualifiers similar to h, Cf 1.4. nor formulations which, like t tlat of \nFullexp assignment (2.2.2.), account for side effects. (2) the surface properties of members of Fullezp \nare carefully validated. Side effects can arise in the evaluation of an element fe of Ful~exp only if \nfe contains the call of an abstraction of type function(2.2.5.); this specification eases the fulfillment \nof the second con\u00ad dition above,  2.2.2. Assignment In ProofLS, assignment statements con\u00adtaining the \nsymbol := are limited to the form Ide := Exp , where Ide is an identifier of basic type (integer, real, \nor boolean). A surface property of this construct is (i) ((P[Exp/Ide],P), ~, ht(~)), where ~ is Ide := \nExp and ht(A) expresses that the evaluation of A is assumed to terminate without error. The proof of \n(i) follows from (1) the continuation-removal theorems (1.2.) of ProofLS; (2) the result concerning \nExp in 2.2.1;  (3) a short lemma about the effect of simple assignment on the abstract store; and (4) \na trivial structural induction on pred.  For the justification of the elimination of qualifiers h~ \nto k, of 1.4., see 2.1.37 2.2.5.3. ,an d 2.2.5.1. The symbol + is used to signal the presence of a production \nof Fullexp syntax on the right-hand side of an assignment statement , with the left-hand side as above, \ne.g., Ide * Fullexp. If a surface property of Fullexp is S = ( (P,Q[Exp~/Ide]),FuZLexp~ (l re,h.l, . \n. ..hfl)l. then one can validate where T1 is Ide * Fullezp and Here R and W are the semantic functions \nof S(ProofLS) which give semantics to ex\u00adpressions of assignable type in Exp and Fullexp, respectively. \nFinally, the polymorphic abstraction Change is used to perform assignments in\u00advolving assignable of structured \ntype. The contexts in which Change can be ap\u00adplied are specified in 2.2.7.  2.2.3. Composition A surface \nproperty for composition in ProofLS is (see [2]) (iii) ( (P,R), rl;r,,~sl,sz,hj~rl~~j , where s, = ( \n(P,Q), r,, ht(r,)) and S2 = ( (Q,R), rz, ;Lt(rz)) , and 71i(A) asserts that A does not con\u00adtain a jump \nto a point external to it\u00adself. This qualifier may be matherirati\u00adcally expressed using a purely syntactic \npredicate, or environment and abstract store arguments may be added to ensure that a forbidden jump occurring \nin a dy\u00adnamically unused arm of a conditional does not affect the result of the jump\u00adfree test. The validation \nof (iii) fol\u00adlows immediately from an appropriate con\u00adtinuation-removal theorem (1.2.) and the property \nthat r, cannot contain a jump into rl in our language. ProofLS aims to keep sensible jumps while having \nhj(A) hold for as many con\u00adstructs A as possible. In an attempt to satisfy this goal> only rep2ies (2.2.6. \n) are allowed in the language, 2.2.4. Conditionals and Iterations If only Ezp syntax is allowed in boolean \ncontexts, the surface properties of conditionals and boolean-controlled iterations (like whi le) are \neasily formu\u00adlated and validated relative to the sur\u00adface properties of their component com\u00ad mands . \nThese validations usually require fixpoint induction and no structural in\u00ad ductions with hi and (sometimes) \nh. as J qualifiers. The Validation Criterion for for-loops is best satisfied if the syntax of for-lists \nis kept uncomplicated and if the maximum number of iterations is deter\u00ad mined before the first evaluation \nof the for-statement.  2.2.5. Abstractions and Parameters The design of abstractions has a per\u00advasive \neffect on our validation efforts. In line with 2.1.1., ProofLS has three abstraction types: (1) fixed \nfunctions: result-producing abstractions with fixed free variables (2.2.S. 3.). These are the only ab\u00adstractions \nwhose applications can occur in Exp or Pred syntax; thus their calls have no side effects. (2) functions: \nresult-producing abstrac\u00adtions whose applications occur in Fullezp syntax. (3) routines: abstractions \nwhose calls produce side effects without returning vaiues of result type; the appli\u00adcations of routines \nare in Command syntax.  We first discuss parameter mechanisms and continue with considerations of global \neffects of abstraction calls and treatment of free variables. 2.2.5.1, Parameter Mechanisms The example \nof 1.4. demonstrates how the use of call-by-name as a parameter mechanism can necessitate additional \nqual\u00adifiers in the surface properties of lan\u00adguage constructs. ProofLS employs two types of parameter \ntransmission, call-by\u00adreference and ca22-by-expressecZ-va Lue. Formal expressed-value parameters may \nnot legally occur in a context which might .,, cause their values to be altered; this method of passing \nparameters is similar to a device proposed by Tennent [22] (but here we do not allow actual reference \nand exprassed-tia2ua parameters to share) . AS should be expected, abstractions of type fixed function \nmay only take parameters by expressed value. The use of these para\u00admeter mechanisms, combined with our \nre\u00adstrictions on sharing between actual para\u00admeters, implies that parameter passing need not affect the \nabstract store and thus can have a purely environmental ef\u00adfect. This in turn allows, for example, the \nvalidation of a surface property anal\u00adogous to the proof rule P{~}R (iv) > P ~u1,{Proe(ELq21, . . . \n..Expn)}R$ub where all free assignable of P and R must occur in I or be abstraction identifiers, P \nPIEzpl/Idel ].., [Expn/Iderl], sub R R[Ezp,/Ide,]... [EXpP1/Ide)l], sub and PY~oe is an identifier \nof type routine or function with formal parameters ldel through. Iden and body I , by a proof similar \nin size and nature to the proof of the i-calculus substitution lemma given in Wadsworth [23]. (iv) is \nsimilar to the substitution rule of Hoare [2]; its validity depends also on the prohibitions of 2.2.5.2. \nand 2.2.5.3. 2.2.5.2. Global Ef feets of Abstraction Calls The free variables of an abstraction f (and \nany abstraction applied within f) are like expressed-value parameters, in that their values may not be \naltered le\u00adgally by any call of f. This convention (1) eases the specification of those pro\u00adgram variables \nwhose values can be altered by an abstraction call; and (2) makes sharing.between a free vari\u00adable of \nan abstraction and an actual reference parameter of an enclosing  abstraction call either illegal or \ninconsequential. 2.2.5,3. Treatment of Free Variables The prohibition of 2.2.5,2. on the use of free \nvariables does not solve the problem which manifests itself in the form of qualifiers like h. of 1.4. \nlie remove the need for such qualifiers, while retaining free variables, by using only fixed abstractions, \nas defined by Strachey [19], in Pred syntax: a fixed abstraction (1) takes its free variables of assignable \ntype by R-value when it is declared; and (2) has abstractions as free variables only if they are fixed. \n We do not require abstractions of types function and routine to be fixed, because the use of fixed \nfree variables causes dynamic name clashes which complicate the validations of surface properties like \nthat corresponding to (iv) of 2.2.5.1. Calls of abstractions of type fixed function, however, have no \nside effects; therefore the surface properties of such abstractions are trivial and our fixing causes \nno practical validation diffi\u00adculties.   2.2.6. Jump S Although full jumps and labels may be described \nand characterized in mathemati\u00adcal semantics [21], we use no labels and restrict jumps to Pep Lies: jumps \nwhich in effect complete the evaluations of specific constructs. Examples of replies and their associated \nconstructs are (see [13]): return call of an abstraction of type routine resultis Exp call of an abstraction \nof type fixed function or function endcase switch break while-or for-loop. return, resultis, and the \nlil:e become special jump identifiers and have denota\u00adtions in the environment p. The use of only replies, \ncombined with rules which regulate the scopes (below) of special jump identifiers, implies that (1) the \njump-free test of 2,2.3. is satis\u00adfied by most associated constructs;and (2) in rl;rz , neither I 1 nor \nrz can con\u00adtain a jump into the other. The specification of the surface properties of replies (and general \njumps, for that matter) is aided by the use of the concept of scope. By the scope of an identifier, we \nmean that area of a program text in which the identifier can legally occur; this definition of scope, \nwhich is a purely textual property> is valid be\u00adcause of our prohibition of lexicographic name clashes \n(2.1,2.). Mathematically, Ide is in scope if its denotation in the environment under consideration is \nnot an error element. A surface property of, say, break is (v) ((P,Irzseope(P)), break,kt(break)), where \nInseope(P) consists of those parts of P which can be evaluated without error with respect to the environmental \ncompo\u00adnent of the denotation of break (1.2.). The qualifier in (v) is needed solely to hypothesize error-freedom. \nThe proof of (v) is immediate (vir\u00adtually a one-liner ) if the area of the abstract store is not affected \nby jumps. If this is not the case, ~ie need to show (by structural induction) that if an identifier is \nin scope, its P.-value can always be taken without accessing any abstract locations which are not in \nthe area of the store under consideration. The proofs of the surface properties of abstraction bodies \nare aided if we validate a wide range of surface proper\u00adties of return and WSUlt iS EXp. Though most \nof these properties are variants of (v), care must be taken over dynamic name clashes, which do not affect \nthe validations of surface properties of break. 2.2.7. Structured Types Structured types nay be introduced \ninto a language without violating the Validation Criterion if the contexts in which instances of such \ntypes might have their values altered can be limited syn\u00adtactically. There are a number of treat\u00adments \nof structured types which satisfy this condition (for an example, see l!orris [9]); ProofT,S simply uses \none such method that allows the declaration of recursive union types like Tree and List. The polymorphic \nabstraction Change (2.2.1.) serves as an assignment operator for structured types and can only be applied \nwithin the bodies of structure-abstrac\u00adtions, abstractions which can have ref\u00aderence parameters of structured \ntype. P~~~d syntax can be expanded to in\u00adclude elements like Depth(Side) = Ezp, which acts on an object \nof structured type and thereby aids the formulation and validation of surface properties of structure-abstractions \nas well as the characterization of the shape of a struc\u00adtured type. F1ere Side is an assignable related \nto an identifier of structured type ; Depth determines the maximum length of the composite selectors \nwhich may be legally applied to Side if a graphical representation of the value of Side con\u00adtains a loop, \nDepth(Side) is a suitable constant Cycle. The shape of a stiwc\u00adtured type is defined to be whatever propositions \ninvolving Depth and similar measure-predicates are to be taken as invariant over all instances of that \nstructured type. For example, one part of the shape of the structured type Einaryintegertree would be \n R3[Depth(Side) + Cyetc]PU = true for all Side of type Binaryintegertree with respect to p. 3. CONCLUDING \nRENARKS The interplay between the subsec\u00adtions of Section 2 calls attention both to the interdependence \nof language fea\u00adtures and to the complications which can emerge from the attempt to discuss the surface \nproperties of a large programming language. While we consider the first of these inherent to programming \nlanguages, our efforts to design languages which meet the Validation Criterion are made in the hope of \nreducing the latter. Pragmati\u00adcally, qualifiers indicate the presence of semantic catches that a programmer \nmust take into consideration when he assesses the impact of a construct in his program in the absence \nof qualifiers satisfaction of the Validation Criterion often implies simpler, and therefore more useful, \nsur\u00adface properties. The mathematical approach to language design presented in this paper ~iill be more \nfully discussed in the authorfs doctoral dissertation [5], which will also include an introduction of \nthe approach to system programming languages. Future experiments in language design should be aided by \nthe compiler-compiler of Mosses [11], which is to allow both semantic descriptions to be debugged and \nimple\u00admentations to be given to theoretical lan\u00adguages. Perhaps a mathematical approach to language design, \nwhen combined with the ideas of practical programmers , will yield more coherent design principles in \nfuture than are available at present. Acknowledgements The author gratefully acknowledges Chris\u00adtopher \nStrachey, Robert Milne, and Chris\u00adtopher Iiadsworth, who have provided many stimulating discussions. \nAdditionally, P.D. Mosses, M.D. IIarrison, J.E. Stoy, and P.J.L. Wallis have read the manus\u00adcript and \nhave made several suggestions for improvement. REFERENCES [1] C.A,R. Hoare, An Axiomatic Basis for Computer \nProgramming, Comm.ACM,12:10, (1969), 576-580. .[2] C.A.R. Hoare, Procedures and Para\u00ad meters : An Axiomatic \nAp roach, Sym\u00adposiufi on Semantics of A? gorithmic Languages, S. -Verla.g, (l97l),lO2-ll7. [3] C.A.R. \nI1oare, Hints on Programming Language Design, Stanford A.I. Labora\u00adtory, AIM-224$ (1973). [4] P.Landin, \nThe Meehanieal Evaluation of Expressions, Computer Journal 6, (1 264), 308-320. [5] G.T. Ligler, D.PhiI.Thesis, \nOxford University, (1975), in preparation. [6] Z.Manna and J.Vuillemin, I ixpoint Approach to the Theory \nof Computation, Comm.ACPl ,15:7,(1972), 528-536. [7] R.E. Milne, The formal semantics of computer languages \nand their imple\u00admentations , Ph.D,Thesis, Cambridge IJniversity, and Technical Monograph PRG-13, Oxford \nUniversity Computing Laboratory, Programming Research Group, (1974). [8] R.Milner, Implementation and \nApplica\u00adtions of Scottts Logic for Computable Functions, SIGPLA~{ Notices 7:1 (= SIGACT News 14), (1972), \n1-6. [9] J,H.Morris, Types are not Sets,Proc. ACM Symposium on Principles of Pro\u00adgramming Languages, \nBoston, (1973), 120-124. [10] P.D. Mosses, The mathematical seman\u00adtics of AlgoZ. 60, Technical Monograph \nPRG-12, O.U.C.L. , Programming Research Group, (1974). [11] P.D. Mosses, Matkematiea2 Semantics and Compi2er-Generation, \nD.Phil. Thesis, Oxford University, (1974). [12] J.C. Reynolds, On the Relation Between Direct and Continuation \nSemantics, Proc. Second Colloquium on Automata, Languages, and Programming, Saar\u00adbriicken, (1974). [13] \nM. Richards, The BCPL Reference Man\u00adual, Technical Memorandum 69/1, Cambridge U. Mathematical Laboratory, \n(1969). [14] D.Scott, Outline of a Mathematical Theory of Computation, Proc. Fourth Annual Princeton \nConference on Infor\u00admation Sciences and Systems, pp.169\u00ad176, and Technical Monograph PRG-2, O.U.C.L. \n, Programming Research Group, (1970). [15] D.scott, Continuous Lattices, PrOC. 1971 Dalhousie Conference, \nSpringer Lecture l~ote Series, and Technical 140nograph PRG-7, O.U.C.L. , Program\u00adming Research Group, \n(1970). [16] D,Scott, Mathematical Concepts in Programming Language Semantics, AFIPS Conference Proceedings, \nVO1.40, (1972), 225-234. [17] D.Scott and C.Strachey, Touard a Mathematical Semanties for Computer Languages, \nProc.Symp. on Computers and Automata, Polytechnic Institute of B rooklyn, and Technical Monograph PRG-6,0.U.C. \nL.,Prog.Res .Group, (1971).  [18] C. Strachey, Towards a Formal Seman\u00ad [21] C. Strachey and C. Wadsworth, \nContin\u00ad tics , Formal Language Description uations A Mathematical. Semantics for Languages for Computer \nProgramming, Full Jumps and Labels, Technical (cd. T. Steel), North-Ilolland, (1966), Monograph PRG-11, \nOxford University 198-220. Computir.g Laboratory, Programming [19] C. Strachey, Fundamental Concepts \nin Research Group, (1974). Programming Languages, Unpublished, [22] R.D. Tennent, A Contribution to the \n(1970). Dev@20pment of Pascal-Like Languages, [20] C. Strachey, Varieties ming Language, Proc. Computing \nSymposium, Foundation, Venice, of Program-International pp.222-233,Cini and Technical Technical ment \nScience, (1974) of . Report Computing Queen s lJo. 74-25, and Information University, Depart-Ontario, \nMonograph PRG-10, Oxford University [23] C,.Wadsworth, The Semantics and Prag- Computing Laboratory, \nProgramming Maties of the A-Calculus, D.Phil. Research Group, (1972). Thesis, Oxford University, (1971). \n \n\t\t\t", "proc_id": "512976", "abstract": "A framework for validating <i>surface properties</i> of programming language constructs, composed of proof rules (akin to those of Hoare) and supporting hypotheses, is constructed using the mathematical semantics of Scott and Strachey. The following approach to language design is then considered: the constructs of a language should have surface properties which 1) need few hypotheses other than assumed surface properties; and 2) have proofs consisting, as far as possible, of trivial fixpoint and structural inductions.", "authors": [{"name": "George T. Ligler", "author_profile_id": "81100622283", "affiliation": "Oxford University", "person_id": "P330482", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/512976.512982", "year": "1975", "article_id": "512982", "conference": "POPL", "title": "A mathematical approach to language design", "url": "http://dl.acm.org/citation.cfm?id=512982"}