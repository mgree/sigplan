{"article_publication_date": "01-01-1975", "fulltext": "\n REDUCTION: A NEW METHOD OF PROVING PROPERTIES OF SYSTEMS OF PROCESSES Permission to make digital or \nhard copies of part or all of this work or personal or classroom use is granted without fee provided \nthat copies are not made or distributed for profit or commercial advantage and that copies bear this \nnotice and the full citation on the first page. To copy otherwise, to republish, to post on servers, \nor to redistribute to lists, requires prior specific permission and/or a fee.&#38;#169; 1975 ACM 0-12345-678-9 \n$5.00 Richard J. Lipton Computer Science Department Yale University New Haven, Connecticut 06520 Abstract \nWhen proving that a system of processes has a given property it is often convenient to assume that a \nroutine is uninterruptible, i.e. that the routine cannot be interleaved with the rest of the sys cem. \nHere sufficient conditions are obtained to show that the assumption that a routine is un\u00adinterruptible \ncan be relaxed and still preserve basic properties such as halting and determinacy. Thus correctness \nproofs of a system of processes can often be greatly simplified. This technique \u00adcalled reduction -is \nviewed as the replacement of an interruptible routine by an uninterruptible one. 1, Introduction Suppose \nthat P is a system of independent parallel processes and H is some routine cOn\u00adtained in P. It is often \neasy to prove that (1) P has some property Z as long as the routine R is uninterruptible . A routine \nis uninterruptible provided it is never interleaved with the rest of P, i.e. provided it can be treated \nas one indivisible action. For inst2fnce, R might be the three instructions or actions: r-+x; increment \nr ; xt-r Assuming that R is uninterruptible or indivisi ble reduces R to the single instruction: x+x+ \n1; In contrast to (l), it is not usually easy to prove that (2) P has property Z when R is interruptible. \nThe basic question considered in this paper is: when does assertion (1) imply assertion (2) ? Define \nP/R to be the system of processes obtained from P by reducing R to one indivisi\u00adble action (;.e. R is \nconsidered to be uninter ruptible) . P/R is called the reduction of P by R. The type of results we obtain \nare: (3) if P/R has property Z, then P has property 1. In proving these results restrictions must be \nplaced on R. These restrictions, however, are satisfied by a wide range of routinea. These re\u00adsults are \nthen used as followa: Suppose that one desires to prove that P has property Z. P is reduced to P and \nP is reduced to P and so on finally yielding Q. Now Q is shown to have property Z; thus, several applications \nof (3) show that P also has property E. The reason this method is fruitful is that Q is usually much \nsimpler than P. Q is simpler than P, first, because Q has less actions than P. It follows that a proof \nthat Q has property z must consider less cases than a proof that P haa property X. Second, Q is simpler \nthan P, be\u00adcause assertions about Q are often simpler than assertions about P. For example, we will later \ninvestigate an example where in Q the sum of two variables -a+b is always a constant, while in P a+b \n= a complex function of the state of P. This difference in the assertions that can be made about a+b \nis important: the fact that a+b is constant allows an easy proof that Q does not halt. The previous proof \nprocedures for systems of processes consisted essentially of Floyd s asser\u00adtion method [1] adapted to \nparallel systems (Levitt [2], Lauer [3], and Ashcroft [4]). The basic drawback to this method is that \nbecause of the many possible computations in a parallel system, the assertion method tends to in\u00ad volve \nthe consideration of many cases. The arbi trary interleaving of systems of processes is a major obstacle \nfor the assertion method. This should be,compared with the ma in advantage of the reduction method: the \ncomputations of P/R are a proper subset of the computations of P. Of course the reduction method can \nindeed be used in conjunction with the assertion method. Reduction is developed in the context of a variant \nof the model of systems of processes of The author was supported in part by Army Research Office grant \nnumber DAHc04-75-G-0037. Lipton [5]. One of the key advantages of this mo\u00ad del is that it is not biased \ntoward any particular type of systems of processes. This is important since the reduction P/R cannot \nalways be de\u00ad scribed in terms of one of the classic models: for example, if P is a PV system of processes \n(Dijk stra [6]) , then P/R need not be a PV system of processes. However, in our model, P/R is always \na valid system of processes. This paper is composed of 5 sections. In section 2 the basic model of system \nof processes is presented. In section 3 the concept of reduc tion is presented, and then shown to preserve \nboth halting and determinacy. In section 4 several ex\u00adamples are presented which demonstrate the power \nof the reduction method. 2. Basic Model A system of processes is a finite collection of disjoint flowcharts. \nEach of these flowcharts consists of a finite connected directed graph whose nodes are statements of \nthe form: 1. START STATEMENT: START 2. TEST STATEMENT: J  9 B TRUE FALSE J% +3. GENERALIZED ASSIGNMENT \nB :x STATEMENT: T where B is a predicate and X is a list of as\u00adsignments. These predicates and assignments \nare assumed to be fully interpreted and to operate on program variables. We will not need to specifi\u00ad \ncally state what predicates and assignments are allowed: the results presented here are indepen\u00addent \nfrom the class of predicates and assignments allowed. Each statement is also called an action and each \nflowchart is called a process . A- of the form (1) and (2) are given the usual seman\u00ad tics. Actions of \nthe form (3) are given the fol\u00ad lowing semantics: (*) if B is t~ e, then the assignments in Z are executed; \notherwise, nothing is executed. Another way of viewing the semantics of a gene\u00adralized assignment is \nto consider it equivalent to ~..--- ~.= -..., TRUE 1 B FALSE di where the actions inside the dotted \nlines are con\u00ad sidered indivisible. (Note, no claim is made that generalized assignments should be implemented \nin this way; just that they should behave in this way. ) A computation of a system of process is a finite \nsequence of actions such that each action in turn is able to execute. Thus, if aft is a computation and \nf is the action lB~ - then the predicate B must be true after the com\u00adputation CL is executed. For example, \nthe compu\u00ad tations of the system of processes (S = 1 initially) 1 @@ 3 ? f+l&#38;lf4* are the sequences \nlf2f3 lf3f2 lf3f4 3f4fl fff and all prefixes of these se\u00ad312 3flf4 quences. Note, is not a computation: \nlf3f2f4 after lf3f2 Xecutes s s qual 0 0; ence W (*) cannot execute. 4 Next the class of PV systems of \nprocesses is defined. The importance of this clasa is twofold. First, the fact that the reduction method \napplies to PV systems of processes demonstrates that it has practical value. This follows since PV or \na variant of it is used in most current operating systems [7]. Thus, the reduction method can be used \nto prove the correctness of parts of opera\u00adting systems. Second, the literature contains many complex \nexamples of PV systems of processes. The fact that the reduction method can be used to simplify their \nproofs demonstrates the power of the reduction method. Definition P is a PV system of processes [6] provided \nthere is a distinguished subset of the program variables called semaphores 1  n with integer values \nsuch that they can be only used in generalized assignments of the form or I* ~ ;--i\u00ad ------: The former \ncalled a is ~~. called a P(s- k ); the latter is (t) B6 denotes the concatenation of B and 6. Semaphores \nare intuitively used by PV systems of processes as a method of communication. The name semaphores itself \nstems from the use of se\u00admaphores or flags to send signals between trains . They are manipulated in exactly \ntwo ways: either one could increment a semaphore by 1 (e.g. V(Sk)) or one could test whether a semaphore \nwas possible and if this was true then decrement the semaphore by 1 (e.g. P(Sk)). Semaphores are often \nthought of as resources. A P(Sk) is then an attempt to seize 1 unit of the resource Sk, while a V(Sk) \nis a release of 1 unit of this resource. 3. Reductions The concept of reduction is now defined. It is \nthen shown that reductions preserve both hal\u00adting and determinacy. 3.1 Routines and Reductions Suppose \nthat are actions in a sys I fn tern of processes. When do fl...fn form a rou\u00ad tine? (Routine here means \nopen routine. ) First, it is reasonable to insist that they all lie in the same procees; routines that \nspan seve\u00adral processes are very unusual and are not allowed here. Of course this is not enough: one \nwould not consider f and to be a routine in the 1 2fragment fl \u00ad~+o I 4 3 TRUE: y + y+l I  2I * [ ; \n The missing requirement is that the routine must be entered via and then exited via f 1 n This is still \nnot the case: one would not consi\u00adder fl and f2 to be a routine in the fragment &#38; . In a routine \nthere must be no way to jump into the middle of the routine. Once this is forbid\u00adden fl...f will certainly \nform a routine. In n summary, in order for f . . .f to form a routine in they must satisfy two constraints: \n(1) they must all lie in the same process; (2) they must be entered via fl and exited via f n with no \njumping into the middle. In order to avoid notational -not concep\u00adtual complexities all the routines \nstudied here are asaumed to be straight line. That ia they are assumed not to branch. The generalizations \nof the following results to include branching ia straightforward. Definition The generalized assignment \nactions form a routine provided f. is the l...fn _ predecessor+ Of i+~ Or ~ s i < n. The fact that ia \na predecessor of 1 2 and f is a predecessor of and so on implies 2 3 that muet lie in the same flowchart \n l...fn (flowchart are disjoint, connected, directed graphs). Since is the unique predecessor of i f \nthere can be no jumping into the middle of i+l the routine. Definition Suppose that is a routine in I...fn \na system of processes where (l<i<n) f is i BX.: 1i d-l + where Z. is a list of assignments and B is \na 1i predicate. Then the composite action of l.. fn is the action g defined by * where B is the predicate: \n(1) B1 is true, and (2) B2 is true on the state that results  after is executed, and 1 (n) B is true \non the state that results n after E. 1 .. ; n l s Xecuted. Suppose that g is the composite action of \nthe routine is the action that l. ..fn. hen g computes the effect of when it is consi l. ..fn dered to \nbe uninterruptible or indivisible. For example, the composite action of the routine (t) In a directed \ngraph f is the predecessor of g provided there is an arc frOm f tO g. 80 1? The most optimistic conjecture \nto make is that 1 all reductions preserve halting; more exactly, S> (): s+ s l; T+ T+l --J 2 + 3 4 is \nthe action &#38; 8 S> OAT20: T + T+2 + Note in the composite action T is tested to be nonnegative since \nalways increments T by 1 1 before tests T to be positive. Also note 2 that g leaves T fixed: increments \nT and 1 decrements T.  2 Definition Suppose that is a routine in I fn P. Then P/fl...f -the reduction \nof P by n is the system of processes formed when l fn \u00adthe path is removed and replaced by g l fn \nwhere g is the composite action of fl. ..fn. Thus , J 1 J i becomes g I fn J ! The reduction P/fl...f \nie the system of n processes that is formed when the routine l fn is considered to be uninterruptible \nor indivisi\u00adble. The fundamental question is: what is the re\u00adlationship between P and P/fl...fn? In parti\u00adcular: \nif P/fl...fn does not halt, then does P halt? A eystem of processes halte if there is some com\u00adputation \na such that uf is not a computation for all actions f, A system of processes that does not halt is often \ncalled deadlock free [6]. In analyzing parallel systems, such as operating systems, it is often important \nto prove that they never halt, i.e. that they are deadlock free. This follows since operating system \nprocesses are often never ending tasks (e.g. disk handler) and hence must be proved to never halt. 3.2 \nReductions that Preserve Halting and Determinac~ (1) if P P/fl... does not f n does halt, not halt, \nthen Unfortunately of processes this EX1 is false. Consider whose processes are: the system 1 a>l): \na + a-l 2 b> (): b + b l g 3 TRUE: a + a+l; b -e b+l L where a=b=l initially. It is easy to see that \nEX1 halts: is a computation a,ld lf4 f1f4f2 and f1f4f5 are not computations. The actions f1f2f3 form \na routine; the processes of EX1/f1f2f3 are @i9 /. 4 \\b>O:Jb+b-ll It is easy to eee that EX1/flf2f3 does \nnot halt. Therefore, EX1/f1f2f3 dOes nOt halt and RX1 does halt; this contradicts assertion (l). The \nfailure of assertion (1) can be explained as fol\u00adlows . In the routine f1f2f3 in EX1 it is pos\u00ad sible \nto enter the routine and not be able to ever exit it. This observation leads to one restric-and fz together. \nWhen routine f1f2 cannot be tion on routines: interrupted y is always set to 1; when routine can be interrupted \ny can be set to O or 1. (Rl) if the.routine is ever entered, lfz then it must be possible to This observation \nleads to a further restriction: eventually exit the routine. (R2) the effect of the actions of a This \nrestriction appears to be strong; however, as routine when interrupted and when demonstrated later it \nis satisfied by a wide class uninterrupted must be the same. of routines. Restriction is not sufficient \nto ensure The restriction may appear to be difficult to cap\u00ad 1 ture precisely and perhaps just as difficult \nto the truth of assertion (l). For example, consider satisfy. This is not the case. The following is \nthe system of processes EX2 whose actions are: the key definition. Definition Suppose that f and g are \nactions in a system of processes. Then f is a right mover provided if ctfh~ is a computation and f and \n * h lie in different processes, then ahf~ is also a computation; moreover, the values of all the program \nvariables TRUE : y+x in afh~ and cthf~ are the same. Also g ia a left mover provided y>o: y+ y-1 &#38; \ns if uhg~ is a computation and g and h lie in different processes, then a ghfl is a computation; moreover, \ntheSTART values of all the program variables in clhg~ and aghf3 are the same. 4 X+oTRUE : Essentially \na right mover ia an action that performs a seize, while a left mover is an action that performs a release \nof a resource. In order to see this consider, first. the case of a left mo\u00ad~. where y-o initially. It \nis easy to aee VI r. If cthf~ is a computation and f performs a that EX2 halts: is a computation and \n,s. lf4f2 elease, then afh~ is also a computation prO is not a computation (y = O aftex v ded f and \nh lie in different processes: lf4f2f3 executes) . lf4f2 he actions lf2 rm a Ou-1. af is a computation \nsince a release tine that satisfies restriction Now the ac can always execute (here we use the 1 fact \nthat f and h lie in different tions of EX2/f If z are: processes). 2. afh is a computation since h executed \nafter a and f did notSTART seize any resource (i.e. any demand of h can still be fulfilled). y+l 3. afh~ \nis a computation since afh &#38; and uhf are .computationa with the same effect and we know that ahf \nB is a computation. 9 Second consider the case of a right mover. If aghf3 is a computation and g performs \na !iseize,ll START then uhgB is also a computation provided g and . h lie in different processes: 1. \nah is a computation: argue as before. v 2. tihg is a computation: If h is a release this follows immediately;EX2/flf2 \ndoes not halt; hence, restriction 1 s thus assume that h is a seize. not sufficient to imply assertion \n(l). This exam Then the result follows by a symmetry ple fails to satisfy assertion (1) because the argument. \neffect of actions f and f ~ when separated by 1 3. ahg~ is a computation: argue as before. action is \nnot the same as the effect of 4 1 . i+l j+l ; The above proofs can be stated exactly for B f PV syatems \nof processes (see section 3.3). (2) if f3i =fj and j >1, then Definition The routine is a D-routine I \n fn B f provided it is of the form i-1 = j-~ If no fi is in o., then a is already in the 1  B : El \ndesired form (i.e. let @ = a). Therefore, suppoee that some f is in ct. By repeated applications * i \nof lemmas 1 and 2, 2 TRUE : 2 Q where no action from the process of f is in any i fn aj (j =2.. .n). \nBy the definition of D-routines TRUE : En and left and right movers for some k, + d = a(x2...cik fl . \n..fn ak+l...un ~ where for some k, are right movers l fk-l and f k+l. ..fn are left movers (f is not \nso res-is a computation and it agrees with a on all the k program variables. This argument can be repeatedtricted) \n. to form the desired computation 6. Now Restriction (Rl) corresponds to the fact that each fi is of \nthe form (i > 1) e 6 = 61 fl...fn B2. ..131-1 fl...fn Bm r where no f< is in any 6 and a and B agree \nJTRUE: Ei on all program variables. Let g be the composite action of the routine l fn hen Restriction \n(R2) corresponds to the fact that the first k 1 actiona are right movers and the last n-k are left movers. \nis a computation in P/fl...fn; moreover, a and Theorem 1. Suppose that is a D-routine l fn B and 6 agree \non all the program variables. If in a system of processes P. Then if P/fl...f n 6 halts in P/fl...fn, \nthen the contrapositive of does not halt, then P does not halt. the theorem has been proved; hence, the \ntheorem would be true, Conversely, assume that 6 does Proof. First we will state two simple lemmas that \nnot halt in P/fl...fn; further aasume that 6h are needed in our proof. Their proofs are omit\u00ad ted, for \nthey follow easily from the def init ions is a computation in P/fl. . .f Ifh+g, then n of D-routines. \nah is a computation in P; if h = g, then clf . ..fn is a computation in P. These assertions Lemma 1. \nSuppose that afi~ is a computation 1 follow since a and 6 agree on all program vari\u00ad 2 with i> 1. Then \na = alfi_la where no action ables. In aither case, however, we have reached a 2 contradiction. D from \nthe process of fi is in a . A corollary of theorem 1 is that reductions of Lemma 2. Suppose that afit3 \nis a computation D routines also preserve determinacy. Ssy a system 2 of processes is determinate provided \nif a and I? that halts in P with i < n. Then 6 = L31fi+1B halt, then they agree on all program variables. \nwhere no action from the process of fi is in The proof of theorem 1 actually established that for each \na that halts in P, there is a B that \u00ad 132. halts in P/fl...f such that a and B agree on n In order \nto continue the proof, supp ose that all the program variables. Thus if f l n Sa a is a computation \nin P such that a halts. D-routine, then We will show how to construct a computation B P/fl...f is determinate \nimplies that such that the program variables agreed after a n and @ are executed and always occurs as \nP is determinate. I fn consecutive blocks of actions in B, i.e. In order to prove this last assertion \nargue as fol\u00adlows : Assume that P is not determinate. Then (1) if ill = fj and j < n, then there are \nu and al that halt in P with dif\u00adferent values on some program variable, say v. As (t) Bi is the ith \nelement of the sequence B. noted above, there are B and 61 that halt in P/fl. ..f with n (1) a and 6 \nagree on v and (2) al and f31 agree on v. Thus B and 61 disagree on v; hence, P/fl...f n is not determinate. \n3.3 D-Routines The next theorems are a major aid in proving that an action is a left or right mover. \nDetermi\u00adning whether or not a given action is a left or right mover often is the main difficulty in proving \nthat a routine is a D-routine. Definition A system of processes is commutative provided if afg and agf \nare both computations, then they agree on all the program variables. Commutative is a fundamental restriction \nthat is often placed on parallel systems. In parallel schemata theory (Karp and Miller [8]) the concept \nof commutative plays an important role in their study of determinacy, Theorem 2. Suppose that 7? is a \nPV system of pro\u00adcesses. Then (1) every P(S) action is a right mover; (2) every V(S) action is a left \nmover; (3) all other actions are both right and left movers provided P is commuta tive.  Proof. A sketch \nof this proof was made earlier (also see Lipton [9], theorem 1 section 7). u Theorem 2 shows that commutative \nPV systems of processes contain a great abundance of left and right movers. For example, in a commutative \nPV system of processes the routine I fn s a \u00adroutine whenever f . . .f ~ are anything but a P(S). 2Thus \n, X+1TRUE : - Y is a D-routine in a commutative PV system of pro cesses, 4. Applications The reduction \nmethod is now demonstrated by a number of examples. The first two examples demon\u00adstrate the importance \nof precision in studying the reduction concept. In these two examples two sys\u00adtems of processes -EX1 \nand EX3 -are analyzed. EX1 halta, while EX3 does not. Since they are almost identical, this shows that \nloose arguments cannot be allowed here; in a sense theorem 1 is on the edge of being incorrect, The third \nexample presents an example where the reduction method gl\u00ad10WS an assertion to be vastly simplified. \nThe first example is based on the system of processes EX3 whose actions are: 2- f J 3 TRUE : a + a+l; \nb + b+l i 1 4 r-=%-m izz5zd 6&#38; where a = b = 1 initially. It is easy to see and f f are D-routines: \ntheorem hat 2f3 56 shows that and are right movers. Thus by 2 5 theorem 1 we can prove that EX3 never \nhalts if we can show that the following system of processes never halts 1*  -ud=- START 4 a>l): a + \na-l g2 b>o: a+ a+l =!=  where a = b = 1 initially. Clearly b is iden\u00adtically 1. Therefore, f gis a D-routine, \nby 11 theorem 2. Again by theorem 1, EX3 never halts if the following system of processes never halts \nSTART Q 4,+-1 4 T :  LA-1 2=+z!_l where a=O and b = N > 0 initially. Tliis ex ample is essentially \nthe bounded buffer example of [10]. The value of a+b intuitively representswhere ~=1 initially. It i.s \ntrivial to prove the number of elements in the buffer. One wouldthat this system of processes never halta: \nhence, like to argue that a+b is alwaya equal to N,EX3 does not halt. but it clearly is not. Indeed a+b \ncan equal NThe second example is based on the system of or N-1 or N 2. Now let us apply the reduction \nprocesses EX1 defined in section 3.2. If we re\u00admethod. Theorem 2 shows that f f duce EX1 as we did EX3 \nwe obtain 12 and 3f4 are both D-routines. Then theorem 1 shows that EX4 does not halt provided that the \nfollowing system of proceseea does not halt  1--==!==3 START Q *\u00ad g2 I I I)>(): a + a+l; b + b-lt + \n!32 where a=l) and b = N. It ia now trivial, by aIa>(): b + b+~ conservation argument, that a+b = N always. \nThe above system of proceaaee can only halt when I asl) and b s O; but this implies that a+b = N s O, \nwhich is impossible. where a = b = 1 initially. The key difference is that b is not identically equal \nto 1 as it was in 5. Conclusions the previous example. This is of course not sur\u00ad prising since EX1 does \nhalt. The reason theorem The basic properties deadlock free (not hal\u00ad1 could not be applied is that ting) \nand determinacy are preserved by reductions. 1% and 4g2 Since reduction reduce the interleaving of a \npara\u00adare both not D-routines. This example shows how llel system, reduction often reduces the effort \nre sensitive the reduction method ia. quired to prove that a system is correct. ManY re_The final example \nie based on the syetem of duction~ follow easily from theorem 2; this leads processes EX4 whose actions \nare: to the interesting possibility that they can be au somatically generated. Indeed a program that \ncould keep track of actions, form composite actions, and determine whether or not an action was a left \nor 85 right mover would be a great aid in proving the correctness of parallel systems. References [1] \nR.W. Floyd. Assigning meanings to programs. Mathematical Aspects of Computer Science. American Mathematics \nSociety: 19-32 (1967). [2] K.N. Levitt. The application of program\u00adproving techniques to the verification \nof synchronization processes. AFIPS (1972) : 33-47. [31 H.C. Lauer. Correctness in Operating Systems, \nPh.D. thesis, Carnegie-Mellon University. [41 E.A. Ashcroft. Proving Assertions about Parallel Programs, \nResearch Report CS-73-01, Department of Applied Analysis and Computer Science, University of Waterloo, \n1973. [51 R.J. Lipton, Limitation of Synchronization Primitives . Yale Computer Science Report no. g, \n1974. [61 E,W. Dijkstra. Cooperating Sequential PrO\u00adcesses, Programming Languages. Edited by F. Genuys. \n43-112. [71 B.H. Liskov. The Design of the Venus Operating System. =15(3): 144-156. [8] R.M. Karp, R.E. \nMiller. Parallel Program Schemata. JCSS 3(2): 147-195. [9] R.J. Lipton. On Synchronization Primitive \nSystems. Yale Computer Science Report no. 22, 1974. [10] A.N, Habermann. Synchronization of Connnunicating \nProcesses. CACM 15,3(1972): 171-176. \n\t\t\t", "proc_id": "512976", "abstract": "When proving that a system of processes has a given property it is often convenient to assume that a routine is uninterruptible, i.e. that the routine cannot be interleaved with the rest of the system. Here sufficient conditions are obtained to show that the assumption that a routine is uninterruptible can be relaxed and still preserve basic properties such as halting and determinacy. Thus correctness proofs of a system of processes can often be greatly simplified. This technique - called reduction - is viewed as the replacement of an interruptible routine by an uninterruptible one.", "authors": [{"name": "Richard J. Lipton", "author_profile_id": "81100546583", "affiliation": "Yale University, New Haven, Connecticut", "person_id": "PP15035881", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/512976.512985", "year": "1975", "article_id": "512985", "conference": "POPL", "title": "Reduction: a new method of proving properties of systems of processes", "url": "http://dl.acm.org/citation.cfm?id=512985"}