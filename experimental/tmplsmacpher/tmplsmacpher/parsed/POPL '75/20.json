{"article_publication_date": "01-01-1975", "fulltext": "\n Permission to make digital or hard copies of part or all of this work or personal or classroom use is \ngranted without fee provided that copies are not made or distributed for profit or commercial advantage \nand that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, \nto post on servers, or to redistribute to lists, requires prior specific permission and/or a fee.&#38;#169; \n1975 ACM 0-12345-678-9 $5.00 STRUCTURED EXCEPTION HANDLING;: John B. Goodenough SofTech, Inc. Waltham, \nMass. Summary In essence, exceptions permit the user of an operation to extend the operations domain \n(i. e. , In this paper, we define what exception the set of inputs for which effects are defined) or \nconditions are, discuss the requirements exception its range (the effects obtained when certain inputs \nhandling language features must satisfy, survey are processed). Exceptions permit a user to and analyze \nexisting approaches to exception tailor an operations results or effects to his par\u00adhandling, and propose \nsome new language features ticular purpose in using the operation. In~hort, for dealing with exceptions \nin an orderly and re-exceptions s erve to generalize operations, making liable way. Our objective is \nnot solely to put for-them usable in a wider variety of contexts than ward a lanugage proposal. It is \nalso to analyze would otherwise be the case. Specifically, excep\u00adexception handling is sues and principles \nin detail. tions are used: The proposed language features serve to highlight exception handling issues \nby showing how defic - to permit dealing with an operations iencies in current approaches could be remedied \nimpending or actual failure. W e in a coherent and orderly way. will discuss two types of failure: 1. \nExceptions: What are They and Why are range failure, and They Needed ? domain failure Of the conditions \nthat are detected while to indicate the significance of aattempting to perform some operation, exception \nvalid result or the circumstances conditions ar+ ones the operation brings to the under which it was \nobtained. attention of its invoker. The invoker is then per \u00admitted (or required) to respond to the condition. \nto permit an invoker to monitor Bringing an exception condition to an invoker s an operation, e. g. , \nto measureattention is called raising an exception. The in \u00adcomputational progress or to voker!s response \nis called handling the exception. provide additional info rmation Some properties of exception conditions \nrelevant and guidance should certain con\u00adto language features for raising and handling them ditions arise. \nare: The value of making this classification of exception their full significance is known only uses \nis the insight it will give into the need foroutside the detecting operation; the various exception-handling \nlanguage capabilities. operation is not permitted to determine Although it may sometimes be difficult \nto decide unilaterally what is to be done after precisely how to classify a given exception, this they \nare raised; ambiguity is not crucial for our purposes. an invoker may choose to terminate the operation \nat the point of the Range failure occurs when an operation exception s detection; the operation finds \nit is either unable to satisfy its output may specify that its termination is assertion (i. e. , its \ncriterion for determining when required; it has produced a valid result), or it decides it may not ever \nbe able to satisfy its output asser\u00ad  an invoker controls whether or not tion. For example, a range \nfailure of the first a default response is to be activated; kind for a ,read operation would be finding \nan end\u00addefaults are defined within the of-file mark instead of a record to be read. The operation raising \nthe exception and second type of failure is exemplified by encounter \u00adare executed unless something has \ning a parity error when attempting to read a been done to prevent their execution. record, since in this \ncase, it is uncertain whether  repeated attempts to read will or will not eventu\u00adally be successful. \nFor a numerical algorithm, :<This work was performed under Contract evidence of divergence is a range \nfailure of theDAAA25-74-C0469 for Frankford Arsenal, first kind; failure to converge after a certainPhiladelphia, \nPa. amount of effort has been expended would be a failure of the second kind. In general, to deal with \nrange failures, the following capabilities are needed: the invoker needs the ability to request termination \nof the operation; the operation also needs the ability to say it can!t do any more --termina\u00adtion is \nrequired. Sometimes it is necessary to undo all effects of attempting the operation as a side\u00adeffect \nof terminating the operation.  the ability to tell the operation to try again is also required, since \nthis may be a reasonable response in some circumstances (e. g. , in the case of reading the bad tape \nrecord).  the ability to terminate the operation, returning partial results to the invoker, perhaps \ntogether with additional info rmation needed to make sense of the results, is also required. For example, \nin the case of the bad tape record, the invoker may be able to perform some inde\u00adpendent check of the \nrecord s validity, or he may be able to compensate for any errors found. In short, he may want to modify \npartial results to make them valid for his purposes. This capability is of obvious utility in increasing \nthe generality of an operation, since the appropriate fix-up actions (or even the possibility of fixing \nup the partial results) will vary from one use of the operation to the next.  In short, range failures \nrequire the ability to force termination of the operation (with or with\u00adout production of partial results \nand with or with\u00ad out the undoing of intermediate results). They also require the ability to resume the \noperation, in cases where further attempts at completion are deemed reasonable. Domain failure is a somewhat \ndifferent type of failure. It occurs when an operation s inputs fail to pass certain tests of acceptability, \ne. g. , the appearance of a letter in input that is supposed to consist of a string of digits or the \ninability to find enough space to satisfy a storage allocation require\u00adment. Domain failure is distinguished \nfrom range failure in that domain failure occurs when the operation finds that some input assertion is \nnot satisfied; range failure occurs when the opera\u00adtion finds that its output assertion cannot be satis \n\u00adfied. To deal with domain failures, an invoker must be given enough information about the failure so \nthat he can, if he wishes, modify the input to satisfy the input criteria. If the invoker is unable to \nfix the problem, he must be permitted to terminate the operation, with or without the operation undoing \nany setup actions taken before the domain failure was detected. The capability an invoker may require \nto deal with this type of failure is the ability to access the operands of the operation as well as additional \ninformation provided from within the operation. The invoker needs this information to help pinpoint in \nwhat way the oper\u00adands are in error. Exceptions may also be raised to classify the result of an operation. \nIn this case, the operations result satisfies its output assertion, but the invoker needs additional \ninfo rmation de\u00adscribing the result before he can give it an appro\u00adpriate interpretation. For example, \naddition overflow on many computers produces a valid result as long as the bits of the result are inter\u00adpreted \nappropriately. Or an operation processing a list of items (or reading a file) may return the last item \nin the list (or file) with an indication that it is the last item so the invoker will not attempt to \n~!d more items. Note that exceptions of this type are different from range failures because the operations \noutput assertion is satisfied; it!s just that the output assertion may be satisfied in several ways, \nand the invoker needs to know which way it was satisfied so he can use the result appropriately. Result \nclassification is a type of exception that leads naturally to the use of status variables (i. e. , output \nparameters whose value designates the type of result produced), because the opera\u00adtion is complete; there \nis no need to resume the operation because a valid result has been produced already. Note, however, that \nstatus variables are not always appropriate for classifying res ults; for example, additional overflow \nis not best indicated with a status variable. Monitoring is the last class of exception conditions. In \nthis case, the invoker wants to be notified when some condition occurs, not because the condition indicates \na failure or the type of result being produced, but because he simply wants to keep track of the computations \nprogress, or the operation may need additional information at certain points and it is too expensive \nto calcu\u00adlate this information every time the operation is invoked, since the conditions under which \nit is needed occur only rarely. When a monitoring type of exception is raised, an invoker may wish to \nterminate an operation; more frequently, the invoker may be required to resume the operation because \nit is not possible or economical to ter\u00adminate the operation cleanly at every monitoring point. One example \nof a desirable use of monitor\u00ading is in conjunction with an operation for search\u00ad~g through a data structure. \nEach time an item is found, an exception is raised with an argument identifying the item. The invoker \ncan then decide whether or not he wishes to get the next item. If so, he resumes the operation. If not, \nhe ter\u00adminates it. Resuming the operation is particularly economical if the operations state has been \npre \u00ads erve.i by the exception handling mechanism. Then, the search algorithm, e. g. , for searching \na binary tree, can be written recursively and intermediate results can be returned without un\u00adwinding \nthe recursion. In short, exceptions and exception handling mechanisms are not needed just to deal with \nerrors. They are needed in general as a means of conveniently interleaving actions belonging to different \nlevels of abstraction [1, 2, 3,4, 5, 6]. They are not necessarily rarely activated. For ex\u00adample, in \ntheir use to deal with result classifica\u00adtion, they might be activated on every invocation of an operation. \nh their use to monitor opera\u00adtions and receive intermediate results, an exc ep \u00adtion might occur many \ntimes for a single invoca\u00adtion of the operation. Exception handling methods that are committed to a fixed \nimplementation tech\u00adnique are therefore not suited for dealing with the complete range of exception requirements. \nIn this paper, we will propose a technique that is neutral with respect to its implementation, and so \nexcep \u00adtions associated with different operations can potentially be implemented differently, dependtig \non their expected frequency and type of use. 2. General Language Design Issues One of the objectives \nof this paper is to define criteria for evaluating exception handling language features. The intent is \nto document considerations that should be in a language de\u00adsigner s mind when deciding how to deal with \nexceptions. Some criteria deal with functional requirements such as those discussed in the pre\u00advious \nsection (e. g, how well does a particular method support each of the various uses of exceptions ? ) Other \ncriteria deal with how well certain general programming language require\u00adments are satisfied. In particular, \nexception handling language features should be evaluated in terms of their effect on: error prevention \n/detection --How does a language feature help to prevent programmer errors or help in detecting such \nerrors at compile\u00adtime ? What errors are programmers likely to make in raising or respond\u00ading to exceptions \n? Does a language feature encourage a programmer to think more thoroughly about the assumptions he is \nmaking in dealing with exception conditions so inade \u00adquacies in these assumptions are easier to see \nand can be corrected earlier in program development ?  modifiability --Modifiability is enhanced bv \nlanzua~e features that  ,-\u00ad make connections between modules (and sections of modules) explicit, so \nall ramifications of changes can be traced out more easily. Modifiability is also enhanced by features \nthat limit the scope of a change s possible effects. Specifically, when new exception con\u00additions are \nadded to an operation, or when one is deleted, is it easy to pro\u00advide new handlers or to modify the old \nones ? Are the necessary changes localized or widespread ? Simple or complex to make? Note th?t sometimes \neven when changes are widespread, they are simple to make if the language reduces the amount of effort \ninvolved; for example, consider the difference between adding a parameter to a subroutine call in a language \nthat permits sub \u00adroutines to have an indefinite number of parameters or optional parameters versus in \na language where all calls must have the same number of param \u00adeters. In the first case, only those calls \nusing the new parameter need be modified, while in the second, every call must be changed. reusability \n--we have already mentioned that exception conditions in and of themselves make it easier to reuse previously \nwritten modules in different contexts. Other re\u00adusability issues concern possible naming conflicts between \nexceptions raised by previously written modules when they are used to\u00adgether for the first time in a \nnew system or being integrated into an existing s ys tern as an extension of the s ystem s capabilities. \n efficiency --Does a method imply use of an implementation technique that is sometimes costly depending \n on the frequency of an exceptions occurrence ? Is it possible for a programmer to associate different \nimplementation techniques with certain exceptions, depending on his use of them and his time and spat \ne efficiency requirements ? The exception handling technique we are proposing does have this property \nof implementation neutrality; in principle, a pro\u00adgrammer can choose among several implementation methods \nfor each exception condition he identifies. readability --Does the syntax permit structuring a program \ns text so the effects of exception handling are more readily understandable ? How easy is it to as sure \noneself that exception handling actions have the correct effect and that no unusual cases have been overlooked \n? Note that readability affects both error prevention /correction and modi\u00adfiability. m w ratability \n--Is the syntax natural and adequate for expressing a pro\u00adgrammer s intent straightforwardly ? Is the \nsyntax uniform, i. e. , are there many or few exceptions to the general rules for dealing with exceptions \n? Depending on the type of the exception condition, do different notations have to be used (e. g. , \ncan user-defined and system\u00addefined exceptions be treated the same way ? ) Can unchanging information \nabout an exception be exceptions occur when attempting suppress ed in favor of highlighting to perform \nsome operation, one what is variable, so the notation for basic is sue is how to insure the dealing with \nexceptions is concise ? proper handler is associated with (Note: this enhances readability as a given \ninvocation. The clas sifi \u00adwell as writability. ) cation of exception handling methods presented in this \nsub\u00ad programming style --do the syntactic section is basic to the discussion and semantic constraints \nof a par-in the remainer of the paper. ticular method enforce or encourage proper exception handling \ndiscipline ? control flow issues --In this Do they encourage appropriate use of section, we will discuss \nhow exceptions in program design and exceptions can be used to support implementation ? multi-level \nloop exits needed in go to -free programming as well as  linguistic complexity --is a language methods \nfor defining what state \u00adfeature just powerful enough to meet ments are to be executed after an clearly \nunderstood requirements, or exception has been handled. We is it as powerful and general as can will \nalso discuss how to insure be conceived ? Is the idea behind that the user and the implementer the language \nfeature s design to deny of an operation agree on whether nothing to the programmer, even termination \nor resumption of the capabilitiess that may be needed only operation is permitted when a rarely, or is \nsome awkwardness on particular exception is raised, rare occasions permitted in favor of and how a programmer \nexpresses  simplifying the number of rules and which of these possibilities is being cases that must \nbe considered in chos en. The proposed exception using a particular feature ? Are the handling language \nforms eliminate features associated with exception the need for explicit GOTO state\u00adhandling unique to \ndealing with ex-ments in dealing with exceptions, ceptions, or are they similar or and so in this sense, \nthe proposed identical to features already needed features constitute a structured for other reasons \n? Are different approach to exception handling. exception handling functional require \u00adments satisfied \nwith variants of a hierarchies of operations and their single, standard exception handling exceptions \n--Up to this point, our approach, or are a variety of dif-d~scuss ion will have focused on ferent notations \nare used, are the is sues relevant to the interaction differences worth the cost in addi-between an operation \nand its tional language complexity (e. g. , immediate invoker. In this section, see [7]) ? Is the philosophy \nto pro-we will discuss issues that arise vide the least power for which a when an exception is passed \nfrom definite need is seen, or the most one invoker to the next until one is power that is conceivable \n[8] ? foundthat is prepared to deal with it. implementation difficulty --how costly is it to implement \na proposed default exception handling --In this technique ? Is it merely a syntactic section, we will \nconsider what to sugaring of a capability a compiler do with exceptions raised by an must already provide, \nor is additional operation but not handled by any complexity in the code generator and invoker of the \noperation, and the optimizer necessary to make the differences between treatment of technique acceptably \nefficient ? system-defined default handlers and default handlers provided by While we will not analyze \nexception han-user -defined reusable packages of dling techniques in depth with respect to each of operations. \nWe will also discuss these criteria, these criteria should be kept in how to restore and replace mind \nwhen formulating a new language proposal or defaults. in evaluating an existing feature. They have been \nkept in mind in formulating the exception handling One issue not discussed in this paper, but features \nproposed in this paper. crucially important nonetheless, are methods associating parameters with exceptions. \nAna \u00ad 3. Exception Handling Requirements lysis of these issues has not been completed. and Issues 3.1 \nAssociating Exception Handlers With In this section we discuss in detail various Operations issues and \nmethods for dealing with exceptions. In particular, we will discuss: ti discussing the various methods \nfor ass ociating handlers with exceptions raised by how to associate handlers with invocations of operations \n--Since  operations, the differences between an operation, its invocation, and its points of activation \nneed to be kept in mind. An operation is either a sub\u00adroutine or a language -defined operator like addi\u00adtion. \nAn invocation is an attempt to execute the operation. An activation point is the place from which an \noperation is invoked. For example, the loop DO 1=1 TON; cALL F (I:KI>XI); END ;  specifies N invocations \nof the operation F and 2N invocations of ~. However, there is only one activation point for F and there \nare two for >*. Handlers associated with exceptions raised by operations are of two kinds: default and \ndefault \u00adoverriding. A default handler is executed only if a programmer has decided not to override it \nwith a different handler. The key distinction between default and override handlers is that handlers \nex\u00adecuted by default are necessarily the same every time they are invoked, but override handlers need \nnot be the same. Examples of default handlers are those defined for certain exceptions in PL/1, e. g. \n, OVERFLOW for all arithmetic operations. When this exception occurs, there is a system-defined action \nthat will be invoked by default unless some overriding action has been specified. The difference between \noverriding a de\u00ad fault handler and replacing it is sometimes subtle. For example, in some systems, default \nhandlers may be coded as separately compiled subroutines and linked to an operation at load time. In \nsuch systems, a programmer can replace a default handler with one he has written by linking his handler \nto the operation in place of the normal one. Although this means the normal default handler has been \nreplaced, it has not been overridden, because the new handler is constant over different invoca\u00adtions \nof the operation. This constancy is what shows it to be a new default handler rather than an overriding \nhandler. We will discuss this distinc\u00adtion further later. The key requirement for associating han\u00addlers \nwith exceptions is the ability to define dif\u00adferent handlers for an exception raised on differ \u00adent invocations \nof the same operation. Dynamic associational methods permit different handlers to be associated with \nthe same activation point. Even so, static methods are still able to associate different handlers with \ndifferent invocations be\u00adcause different handlers can be statically as\u00adsociated with different activation \npoints. Our interest in this Section is in properties of fiethods for associating overriding handlers \nwith exceptions. We have already mentioned the distinction between static and dynamic associa\u00adtion al \nmethods. Another way of viewing these same methods is in terms of how easy it is to see if an override \nhandler exists at a particular activation point. Local associational methods show explicitly whether \nan override handler exists. These methods incorporate a reference to a handler (or the handler itself) \ninto the syntactic form of the activation point, e. g. , by specifying the name of a handler as a parameter \nof a sub\u00adroutine call. This makes the presence or absence of a handler easy to detect, and so makes it \neasy to see whether exceptions will be handled by default. Global associational methods, in con\u00ad trast, \nas s=e overriding handlers implicitly with activation points by specifying the handler independently \nof the activation point. PL/I ON conditions are an example of a global association method. The local, \nglobal, static, and dynamic properties of associational methods lead to a four-fold classification of \nthese methods: local\u00adstatic, local-dynamic, global-static, and global\u00addynamic. The various methods failing \nin these classes are listed in Table 1. Having classified the methods for associat\u00ading handlers with \nexceptions, we will discuss the specific methods listed in Table 1 in detail, and the utility of this \nclassification s theme will be \u00adcome more apparent. 3. 1. 1 Local Association Local association methods \nin essence treat handlers like parameters of operations. For example, in languages that permit subroutine \n names to be passed as parameters, the handler can be cOded as a subroutine, its name given as an actual \nparameter, and the handle r invoked from within the operation when the exception arises. This is the \nexception handling method recommend\u00aded by Parnas [9, 10]. When the actual parameter is not a subroutine \nname, but is instead a sub\u00ad routine-valued expression (e. g. , either a sub\u00ad routine -valued variable \nor a subroutine -valued function call), then the value passed to the opera\u00ad tion is still the name of \na subroutine, but the actual handler can be varied from one call to the next. This technique permits \ndifferent handlers to be associated with the same activation point, and so is a dynamic associational \ntechnique. When a subroutine name is used as a parameter (instead of a subroutine -valued expression), \nthe handler is permanently associated with the activation point, and so this is an example of a static \nassociational method. Subroutine names and expressions both qualify as local associational methods because \nthe existence of a handler is clear by examining the activation point its elf; no examination of the \nactivation pointls context is needed to see if the programmer has provided a handler for the exceptions \nthe operation can raise. In some languages, a label can serve as the exception parameter ; control is \ntransferred to the location specified by the label parameter when the exception is detected. Label-valued \nexpres \u00adsions may be either label variables (if a language permits them) or a formal label parameter. \nWhen a label-valued expression is used as a parameter, the label to which control is transferred can \nvary from one call to the next, and so this is another instance of a local-dynamic associational tech\u00adnique. \nThe use of subroutines or labels as param\u00adeters is well-known as a way of dealing with exceptions. To \nthese two methods we propose a third (which we call the local exception name method), in which the name \nof the exception Table 1 CLASSIFICATION OF EXCEPTION ASSOCIATION METHODS STATIC DYNAMIC * Label constants \nas Label variables as parameters parameters EXPLICIT EVIDENCE OF LOCAL >: Subroutine names Subroutine-valued \nexpressions HANDLER EXISTENCE AT as parameters as parameters ACTIVATION POINT ~Local exception names~ \n*Global exception >~PL /1 ON conditions names Object-oriented Object-oriented exceptions exceptions with \nwith variable operand constant operand Recursive cache Backtracking NO EXPLICIT EVIDENCE GLOBAL Hoare \ns otherwise OF AT HANDLER ACTIVATION EXISTENCE POINT Setup call with subroutine argument Non-local \nlabel Setup call with label argument Setup call with status variable External status variable Status \n-valued functions Wtatus -valued output parameters NECESSARILY PERMANENT POSSIBLY ASSOCIATION VARYING \nASSOCIATION ~will be given greater attention in this paper. Local methods make a reference to a handler \na syntactic part of an activation point; hence these methods provide explicit evidence that a handler \nhas been provided for an exception. Global methods associate a handler implicitly with an activation \npoint. Analysis of the activation point% static or dynamic context is necessary to see if a handler exists. \nStatic methods associate an overriding handler permanently with an exception raised at some activation \npoint. Dynamic methods are capable of associating different handlers with the same exception raised at \na given activation point. appears at the activation point together with the to be able to substitute \na single handler definition definition of its handler. For example, for repeated, identical local definitions. \nIf local handler association were the only method pro -F(A) [X: handler-action] ; vialed by a language, \nthe program text would often be cluttered with unchanging information. One represents the invocation \nof an operation capable important notational principle leading to more . of raising exception X and having \na single param-readable programs is to suppress such unchang \u00adeter. A similar notation has been proposed \nby ing information when convenient. Global exception Mitchell [ 11, 12]. handler association methods \nfill this need. 3. 1.2 Global Association The most obvious example of a global method is the PL/I ON \nstatement. An ON state- Defining exception handlers 10C ally is ment consists of an exception name and \na block of satisfactory when each activation point must have statements defining the handler for that \nexception. a different handler. But when several activation The association between name and handler \nis points are to have the same handler, it is useful effected when the ON statement is executed. Once \nDO I=1T02; IFI=l  THEN ON ENDFILE (F) BEGIN: . . . I* first pass endfile handler ~1 GOTO REPEAT; END; \nELSE ON ENDFILE (F) BEGIN; / $ second pass endfile handler ~1 &#38;TO REPEAT; END: PROCESS: . . . 1>~ \ninitialize file processing for pass i and 2 ~f u. DO WHILE (TRUE); . . . J>? process file F */ END ; \n REPEAT: END ; REVERT ENDFILE (F); Figure 1: PL/I example exploiting ON statement capability to associate \ndifferent handlers with the same activation points, namely the READ statements in the loop for processing \nthe records of file F. PROCESS is used merely for expository clarity; it shows where file processing \nbegins. 1=1; ON ENDFILE (F) BEGIN;  IFI=I THEN DO. , I = 2; GOTO PROCESS; END; /* first pass handler \n>:/ ELSE DO: j::; GOTO DONE; END; /* second pass hafidler ::/ END ; PROCESS: . . . / : initialize file \nprocessing for pass 1 and 2 $/ DO WHILE (I = 1OR I =2); . . . ~;$ process file F ,)/ END; DONE: REVERT \nENDFILE (F); Figure 2: PL/I example showing static use of ON statement to associate different exception \nhandling actions with the same activation points , namely the READ statements in the loop for processing \nthe records of file F. LOOP I= 1TO 2; PROCESS : . . . /+ initialize file processing for both pass I and \n2 >~f LOOP UNLESS ENDFILE; . . . /;~ process file F +/ REPEAT [ENDFILE: IF I . 1 THEN . . . / ~ first \npass endfile handler ,%/ ELSE . . . / $ second pass endfile handler ~1 EXIT] ; REPEAT; /;~ fall through \nafter two iterations ~/ Figure 3: Structured exception handling example showing static association of \nan ENDFILE handler with the body of a loop. LOOP I= 1TO 2; CALL PROCESS (I) [ENDFILE: IF I = 1 THEN \n. . . l>? first pass endfile handler >$/ ELSE . . . / ~ secOnd pass endfile handler ~1 EXIT] ; REPEAT: \n Figure 4: Structured exception handling example showing uniform treatment of loop bodies and subroutine \ncalls; we assume here that the body of PROCESS is equivalent to text in figure 3 that actually processes \nthe file. established, the association remains in effect until ano the r ON statement for the same exception \nis executed, until the block containing the se ON state - ments is exited, or until a REVERT statement \nreferencing the exception is executed [ 13]. ON conditions associate handlers dynam\u00adically with activation \npoints. Is this ability to associate different handlers with the same activa\u00adtion point really useful \n? In practice, ON state\u00adments usually associate only one handler with certain activation points in some \nblock; the ability to associate different handlers with the same activation point is almost never exploited. \n>: Static association with an activation point is sufficient. For example, consider the program in Figure \n1. This program is intended to read a file twice, performing somewhat different processing each time. \nFor each pass of the file, the program associates a different END FILE(F) handler with activation points \nin the inner, processing loop. In practice, however, the program in Figure 1 would probably be written \nas shown in Figure 2, in which the same handler is associated with the inner loopts activation points \nfor both passes of the file; the value of I is used inside the handler to show whether the first or second \npass end-of-file actions are to be carried out. In both Figures 1 and 2, REVERT opera\u00adtions are executed \nafter the second pass is com\u00adpleted to revoke the association established be\u00adtween END FILE (F ) exceptions \nand the handler specified in the ON statements. The REVERT is included to make these examples semantically \nequivalent to the next two examples, in which any ENDFILE(F) exceptions raised outside the given section \nof program will not be processed by the handlers established in the examples. Figure 3 shows how the \nprocessing speci\u00adfied in Figures 1 or 2 could be expressed more straightforwardly with a global extension \nof the exception handling method proposed in the pre\u00adceding section. The global variant of this method \nassociates a handler permanently with activation points in some fixed section of text. In Figure 3, a \nhandler is defined for ENDFILE exceptions raised from activation points inside the inner, file processing \nloop. (There is no need to specify that the handler is for END FILE exceptions associated with F, since \nF is the only file being read. ) The inner loop in this Figure is executed until an END FILE exception \nis raised. Then con \u00adtrol is immediately transferred to the handler attached to the REPEAT signifying \nthe end of the inner loop. After performing appropriate first pass end-of-file actions, the EXIT statement \ncauses control to pass out of the handler, and the REPEAT associated with the outer loop is en\u00adcountered. \n1 is then increased by one, the inner loop is recentered, and the next time the ENDFILE exception is \nraised, the same handler will be invoked, but this time the value of I will be 2 and the second pass \nend-of-file actions will be carried ~Note: we are referring here to the use of ON conditions to define \nhandlers for activation points existing in the same block as the ON statement that establishes the association \n(single-level exception handling). out. Then control will leave the inner loop, I will be increased to \n3, and control will leave the outer loop. The UNLESS clause in the inner loop of Figure 3 does not take \na Boolean expression; instead, it takes a list of exceptions that can be raised by those operations within \nthe loop that will terminate iterations of the loop. This syntax for loop exiting by raising an exception \ncondition was s ugges ted by Knuth [ 14] as a modification of an idea presented by Zahn [ 15]; I have \nmodified Knuth s idea by using the word UNLESS instead of UNTIL, both to avoid confusion with the use \nof UNTIL in the REPEAT-UNTIL looping concept and because the loop is not necessarily exited by raising \nan exception, as is suggested by the word UNTIL ; a normal exit by failure of some pre\u00addicate in a WHILE \nclause is in general equally possible. The similarity between exceptions raised by operations and exceptions \nraised from within loops is illustrated in Figure 4, where the file processing loop and its initialization \nare replaced with a subroutine, PROCESS. The ENDFILE handler for this form of the program is the same \nas in Figure 3. The similar treatment of excep \u00adtions raised from within a loop and from within a subroutine \nis a pleasant property of the proposed method, since a loop can usually be considered a lower level refinement \n[ 1, 2, 3] of a more abstract operation that could have been coded as a sub\u00adroutine. There are other \nglobal associational tech\u00adniques that we have not yet discussed. One of the more unusual and interesting \nvariants is the use of object-oriented exception handlers. Handlers are usually thought of as being associated \nwith operations, but it is occasionally useful to associate handlers with operands of operations instead \nof with the operations themselves. For example, the AED Free Storage Package [ 16] permits a programmer \nto establish different areas of storage, called zones, each with poten\u00adtially a different handler controlling \nwhat is to be done when no space is available in the zone, or when an attempt is made to return storage \nnot belonging to the zone, etc. An appropriate han\u00ad dler is associated with a zone at the time the zone \nis created; the handler is invoked as a result of applylng some operation using a zone as a param\u00adeter. \nFor example, the storage allocation opera\u00adtion, when applied to some zone, will activate the zone s handler \nif insufficient space is available. This means that depending on the allocation operator s operand, different \nexception handlers might be invoked. Since the exception handler cannot be replaced once a zone has been \ncreated, if an allocation operation has a constant zone operand, its flout-of -space !! handler is implicitly \nand permanently associated with that activation point. This is an example of static global excep \u00adtion \nhandling. Lf the allocation operator has a zone variable for its operand, then the handler could change \nas allocation is performed in different zones, so this associates a handler dynamically with an activation \npoint. Some programming languages have excep\u00adtion handling capabilities for dealing with range failures \nonly. These capabilitiess are based on the idea that recovery from a range failure is impossible; the \nonly sensible action is to try some alternative operation that may succeed in obtain\u00ading the desired \neffect. This leads to a check\u00adpoint-retry approach, in which when failure is reported, the system erases \nthe effects of all operations performed from a certain point up to the time failure was detected. Then \na fresh start is made using an alternative approach. The only information retained from the failure is \nsimply the fact that a failure did occur. This very limit\u00ad ed approach to exception handling is useful \nin some applications, but cannot handle the wide range of possibilities we are interested in. Specific \ntechniques that have been devel\u00ad oped to deal with range failures in this way are the ,, technique [ \n17] and the recursive Ibacktracking cache (a proposed hardware concept for making more efficient the \nactivity of restoring an environment after failure has been reported) [ 18]. Hoare [ 19] has suggested \na similar concept, written as Q1 otherwise Q2 meaning that if Q1 fails, then Q2 should be per\u00adformed \n(so Q2 acts as an exception handler for the failure of Ql). In Hoare s proposal, the failure of Q1 does \nnot imply the effects of Q1 are undone before Q2 is invoked. We will not discuss these techniques further \nsince they are suited only for a subset of the various types of excep\u00ad tion conditions. Some s ys terns \ngive an approximation to ON conditions by defining special operators for each exception condition associated \nwith some package of routines. These operators take a subroutine name as an operand, where the subroutine \nis a handler to be invoked whenever the exception arises. For example, consider a package for formating \na program s output [20]. A program\u00admer using this package is permitted to define a routine, say, NEW. \nEND, and specify that it is to be called in place of the default routine when a line is too long to be \nprinted. He establishes this ass ociation between line overflow and his handler by executing SE TEND \n(NEW. END). NEW. END will now be called when a line overflows. SE TEND also returns the name of the replaced \nline over \u00adflow routine to the caller, so if he wants to res tore the previous handler, he can save the \nreturned value and later call SE TEND with the previous value. (Our earlier definition of default and \ndefault override handlers should be read again with this exception handling method in mind. Note that \nNEW. END is not a default handler because, 1) if SETEND were never executed NEW. END is not the handler \nthat would be executed and because 2) handlers established with the SE TEND operator can be different \nfor cliff erent run-time invocations of the print routines, i. e., SETEND is the method of establishing \na handler that overrides the default handler sup\u00adplied if SETEND is never executed. ) The idea of providing \nthe name of a handler subroutine with a setup call can naturally be ex\u00adtended to provide the name of \na label to which control is to be transferred when an exception arises, if a language permits this use \nof labels. A technique more often used with labels than this is simply the transfer out of a subroutine \nto a non -local label when an exception arises. Of course, this technique gives quite limited flexi\u00adbility \nin dealing with exceptions, and we will not discuss it further. The last group of techniques for as sociat \n\u00ading handlers with exceptions deals with the use of status values and status variables. This class of \ntechniques does not directly associate the occur\u00adrence of an exception with the invocation of some handler. \nIUS tead, information that an exception has occurred is made available to an invoker of the operation \nby setting a status variable to a certain value, and it is up to the invoker to decide when he will test \nthe value of this variable and how this test will be associated with the execution of some exception \nhandling actions. Since dif\u00adferent executions of the same activation point can lead to different exception \nhandling actions for the same exception (see example below), we classify the use of status variables \nas a dynamic associa\u00adtional technique. Status variables are most often used as output parameters of operations. \nAfter the operation is invoked the value of these parameters is tested, e. g. , DCL S STATUS (OK, X, \nY); ... CALL F(A, S); IF S= XANDI=l THEN . .. ELSE IF S= XANDI=2 THEN ... ELSE IF S=Y THEN ... Sometimes, \nthe status value is returned as the principle value of the function, e. g. , DCL F ENTRY (FIXED) RETURNS \n(STATUS (OK, X, Y)); ... DO CASE (F(A)); (x): ... (Y): ... (OK): ... END CASE; Conceivably, setup calls \ncould be used to es tab\u00ad lish what status variable is to be set when an operation is invoked, although \nthis technique is seldom, if ever, used. More frequent is the idea of providing a single external status \nvariable that is set whenever an exception occurs. PL/I s ONCODE pseudo-variable [ 21] serves this purpose, \nsince every s ys tern-defined exception gives ON CODE a particular value. One advantage of status variables \nnot shared by any of the other techniques mentioned so far is that with careful organization of the set \nof values the variable can take on, a programmer can test for the existence of a whole class of exceptions \nwith a single test, rather than having to know the individual member \u00adship of the class. For example, \nif a status variables values could be OK, READ XCP I, READ XCP_2, READ XCP_3, and W% ITE XCP_l, . a programmer \ncould test for any read exception by writing: IF OK <S<WRITE XCP 1 THEN...  meaning that if S has any \nvalue between OK and WRITE_XCP_l, a read exception has occurred. This is a useful property of status \nvariables that should be preserved with other exception handling methods. 3. 1.3 Evaluation of the Associational \nMethods In this section we critique the principle ass ociational methods in terms of the extent to which \nthey satisfy certain language design criteria. Specifically, we will discuss: the extent to which they \nhelp prevent or detect exception handling errors;  the extent to which they promote program readability \nand writ\u00adability; and  their effect on program efficiency.  Programming Error Prevention and Detection \nThe kinds of errors a programmer can make in associating handlers with exceptions are: 1) forgetting \nthat an operation can raise a particular exception, and so not giving due consideration to how it should \nbe dealt with; 2) when more than one exception is possible, associating a handler with the wrong exception. \n Forgetting to deal with ail exceptions an operation can raise is less likely if a compiler can automatically \ndetect such oversights. I his means that a programmer must in some way de\u00adclare what exceptions can be \nraised, and he must use an associational method that permits detection at compile-the of the various \nerror possibilities. Satisfying both requirements means: using a static associational method (since \nthe dynamic methods require a flow analysis to check for omissions, and even then are not necessarily \nable to definitely determine if all exceptions have been dealt with), and  requiring the declaration \nof what ex\u00adceptions an operation can raise.  For example, suppose a subroutine F is capable of raising \nexceptions X and Y. Depending on the associational method to be used in dealing with these exceptions, \nF might be declared as: c DECL F EN TRY(FIXED, ENTRY, ENTRY) for the subroutine as parameter method . \nDECLF EN TRY(FIXED, LABEL, LABEL) for the label as parameter method DECLFENTRY(FIXED )[X:Y:. . . ] for \nthe local or global exception name method  PL/1, of course, does not even permit a program\u00admer to declare \nwhat exceptions an operation can raise, and this deficiency combined with the dyna\u00admic nature of ON conditions \nis an important failing in PL /11s approach to exception handling. Associating a handler with the wrong \nexcep\u00adtion (the second type of error possibility) is some \u00adwhat more possible with the subroutine and \nlabel methods, since the exception name does not appear in the declaration nor at the point of use. Excep\u00adtions \nare only defined by their position in the argument list. The proposed exception name method is superior \nin this respect because a pro\u00adgrammer or reader is reminded of what exceptions are possible at each activation \npoint. They do not have to recall it themselves or refer to a declarat\u00adion to refresh their memory. W \nriteability /Readability An important language design principle is that of uniformity --an expression \nhaving some meaning in one context should not have a radically different meaning in another context; \nsyntax rules should not have exceptions; a programmer should not have to use different language forms \nfor essen\u00adtially the same purpose [cf 22, page 218-219]. PL/I violates the uniformity principle by making \nseemingly redundant parentheses significant in some contexts, e.g. , F(G) means pass the function G as \na parameter; F((G)) means pass the value of G as the value of the parameter. The uniformity principle \napplied to exception handling argues that whatever exception handling method is provided by a language, \nit should be useable in all contexts where exception handling is required. This appli\u00adcation of the uniformity \nrule argues against the use of the subroutine, label, and status variable exception handling methods \nbecause these methods cannot be used to deal with exceptions raised by language-defined operations like \naddition and divi\u00adsion. In contrast, the exception name method can be used with language-defined operations \njust as with programmer-defined operations. For exam\u00adple, suppose a programmer desires to check whether \nthe sum of A and B exceeds C; note that if the sum overflows, it certainly does exceed C. Using the exception \nname method, he could write: IF (A +B > C)[OVERFLOW: EXI I (TRUE)] THEN ... i. e., exceptions may be \nassociated with expres \u00adsions, and the valued form of the EXIT statement defines the expression ls value \nwhen the exception occurs. (We will discuss this use of the EXIT statement further in Section 3. 2. ) \nIf all excep\u00adtions were handled with status value s,. then the more cumbersome: FLAG= A+ B>C; IF FLAG \nOR OVERFLOW THEN ... would be required. The procedure parameter or label parameter methods are, of course, \nentirely infeasible. One of the merits of the dynamic associa\u00adtional methods, including P L/1 ON conditions, \nis that they do permit language -defined and program\u00admer -defined operations to be treated the same way \nas far as exceptions are concerned. Another writeability requirement is the ability to suppress unchanging \ninformation. We have already justified the need for global associa\u00adtional methods on this ground. Efficiency \nIt has been argued [23, 12] that the cost of setting up an exception handler association should be low \nrelative to the cost of activating a handler, since exceptions occur only rarely. This argument equates \nexceptions with failure of an operation, and we have explicitly taken a broader view. Some \u00adtimes it \nis reasonable to raise an exception every time an operation is activated, and perhaps, several times \nper activation. Excluding for the moment the exception name method, the setup cost associated with various \nassociational methods results in the following ordering (from least setup cost to great\u00adest): ON conditions \n set-up calls  status variables and local parameter  methods Organick [23] discusses in some detail \nwhy the set\u00ad up cost for an ON condition can be quite low. The cost for a setup call is primarily the \ncost of link\u00ad age overhead (note: the use of setup calls rather than direct assignment is justified on \ninformation hiding grounds [24, 25], since the data structure in which the handler name is stored is \nthereby hidden from the program making the setup call; future languages may make it possible to directly \nassign override handlers without at the same time making too much internal information available for \npossible misuse. ) rhe setup cost for the cases where a handler is a parameter is primar\u00ad ily the extra \ncost in space occupied by parameters associated solely with exceptions. Considering that they are passed \nat every activation point, the cost could ultimately be great. The cost of invoking a handler results \nin the following ordering (from least cost to great\u00adest): Procedure and label parameter; setup call \n . ON conditions  status variables  The activation cost for the first class of methods is the lowest \nbecause no tests need be made to find the location of the handler; the location is directly available \nto the operation raising the exception. In dealing with PL /1 ON conditions, a search must generally \nbe made through the stack frames (see[23, 13] for detailed discussion), and this is more time-consuming. \nThe cost in space is probably greatest for the status variable method, since code to test a s tatus variable \ns value mus t be written after each activation point. The key advantage of the exception name method \nis that any of these implementation tech\u00adniques can be used, and in a properly supported system, a programmer \nwill be able to specify with a compiler directive what implementation method will be used for what exceptions. \nh this case, a progranmner can control implementation efficiency without having to rewrite his program. \nThis im \u00adplementation neutrality of the explicit exception name technique is one of its most attractive \nattri\u00adbutes, although admittedly, there are few systems in existence, if any, that permit this property \nto be exploited today. Nonetheless, the notation pre\u00ad sents an opportunity that is foreclosed by the \nother methods.  3.2 Control Flow Iss ues There are basically two sorts of control flow issues to be \nconsidered: . issues relevant to raising an exception; issues relevant to the method for leav\u00ad ing an \nexception handler and re -entering fie llnormalll flow of control. 3.2. 1 Raising an Exception The various \nsituations in which exceptions occur can be characterized as either: requiring termination of the exception\u00adraising \noperation; continuation of the operation must be prevented.  forbidding termination of the operation, \nrequiring its continuation after the ex\u00adception has been dealt with;  permittin~ termination or continuation \nof the operation at the invoker!s dis \u00adcretion.  The reason these three options are needed is best \nunderstood by examining the circumstances under which exceptions arise: in some cases, an invoker may \nbe required to terminate the ope ration raising the exception because no further sensible action is possible. \n, For example, when a read operation finds an end-of-file mark instead of a record, termination of the \nreading attempt is required; attempting to read further is pointless. in other cases, the invoker may \nreasonably be given the option of . deciding whether to continue the Q operation or terminate it. For \nexam\u00adple, when a parity error is encoun\u00adtered while attempting to read a tape, the invoker must decide \nwhether attempts to re-read the record will be continued or not. for domain failur es,  termination \nis required when no fixup is deemed possible, e. g. , when divi\u00adsion by zero is attempted.  when fixup \nis deemed possible, the invoker can be given the option of re s uming the operation o r of terminating \nit. For example, when an operation finds a letter in what is supposed to be a string of digits, an invoker \nmay decide, under some circumstances, to replace the letter with a digit and continue the operation with \nthe fixed\u00adup string; in other circumstances, he may reasonably decide to terminate the operation. Either \ndecision should be permitted when the exception is raised.   for result classification,  . termination \nof the operation is always required because the operation has nothing more to do; the exception was raised \nonly to classify the result pro\u00adduced. . when an exception is raised to help in monito ring an operation, \ntermination is never required by the operation raising the exception; . in some cases the invoker may \nbe permitted to choose between termin\u00adating and continuing the operation. For example, if an operation \nis de \u00adsigned to scan through a data strut \u00adture, raising an exception each time an item is found, the \ninvoker should decide whether to continue looking for more items or not. in some cases, termination may \nnot be permitted, because the operation is not prepared to terminate grace\u00adfully. This makes an exception \nlike a subroutine call to a higher level context. The value of distinguishing this control flow possibility \nis that if the operation is guaranteed to be resumed after the exception has been handled, the implementer \nof the oper ation need not spend any effort or space to take care of the possibility of being terminated. \nSince exceptions present an invoker with cliff erent possibilities for resuming or terminating an operation, \neach exception should specify what its resumption or termination constraints are. For this reason we \ndivide exceptions into three classes: - - EXCAPE exceptions, which require termination of the operation \nraising the exception; NOTIFY exceptions, which forbid ter \u00admination of the operation ra~the exception \nand require its resumption after the handler has completed its actions; and SIGNAL exceptions, which \npermit the operation raising the exception to be either terminated or resumed at the handler s discretion. \n It is an error if an exception of one of these types is treated by an invoker as if it were some other \ntype. Greater clarity in dealing with exceptions and in understanding programs is the result of distinguishing \nthese control flow possibilities in the actual text of a program. All existing exception handling techniques \nare deficient either in not making control flow constraints sufficiently explicit, or in not being able \nto handle the entire spectrum of control flow possibilities inherent in the different reasons for raising \nan exception. For example, PL/I permits an invoker to resume or terminate ~ operation raising an exception, \nbut it does not permit ex\u00adpressing constraints about whether termination or resumption is permitted or \nrequired. Other methods are explicit about their control flow op\u00adtions, but they are not flexible enough \nto handle all the possibilities. For example, status exc ep \u00adtion handling methods are appropriate for \ndealing with most result clas sification exceptions, but since the status value methods require terminating \nan operation before the status value can be proc \u00adessed, this technique is not suitable for notifying \nor signaling. Passing exception handling sub\u00adroutines as parameters is really suitable only for the NOTIFY \ncontrol flow discipline. The exception handling method being pro \u00adposed in this paper permits an invoker \nto termi\u00adnate or resume operations and it makes control flow cons traints explicit. For example, with \nthe proposed method, a subroutine F taking a single argument and raising exceptions X and Y must be declared \nas follows if X is an ESCAPE exception (i. e. , if the operation of F cannot be continued after X is \nraised) and if Y is a SIGNAL exception (i. e. , if F s operation can be terminated or re\u00adsumed by the \nhandler for Y):  DCL F ENTRY (FIXED) [X: ESCAPE, Y: SIGNAL]; The definition of F is similarly required \nto specify what exceptions can be raised and their type: - F: PROCEDURE (AA: FIXED) [X: ESCAPE, Y: SIGNAL] \n; To raise the exceptions X or Y from within F, a programmer must write either ESCAPE X or SIGNAL Y, \ne.g. , WHILE exception Y should be raised ; SIGNAL Y; END ; IF exception X should be raised ; THEN ESCAPE \nX; Writing ESCAPE Y or SIGNAL X is an error. A compiler can verify that the handler for X does not attempt \nto resume F, and that the implementer of F does not make incorrect assumptions about wnecner I can or \ncannot De resumeu 1 after raising exceptions X or Y. NOTIFY exceptions are de\u00adfined and raised similarly, \nand the NOTIFY con\u00adtrol flow constraints can similarly be enforced by a compiler. The dis tine tion between \nSIGNAL and ESCAPE exceptions is also made in MPS [ 12], where the word for ESCAPE is ERROR; we have used \nthe more neutral term ESCAPE since an ESCAPE exception may be used merely to indicate that an operation \nis completed, as with result clas sification exceptions. It should be noted that our proposed method \ndoes not permit an exception to be raised with ESCAPE control flow constraints in some circum\u00adstances \nand SIGNAL or NOTIFY constraints in others. Once an exception is defined to be of a particular type, \nall its uses must conform to that type declaration. Hence, for example, if under some circumstances the \ncondition causing Y to be raised will not permit F to be resumed, then it will be necessary to add an \nESCAPE exception to the definition of F and raise it instead of Y in such circumstances. Before an operation \ncan be terminated by an invoker (in exercising the termination option of a SIGNAL exception), it may \nbe necessary to release certain areas of storage, close files, restore external data structures to a \nconsistent state., etc. MU LTICS PL/I [23] provides a dis\u00adciplined way of dealing with this problem by \nrais \u00ading a special clean_up exception. If an ON state\u00adment inside the operation being terminated has \nestablished a handler for the clean-up exception, it will be executed to perform the required clean\u00ad \n~P actions just before control is returned to the revoker. Since the need to clean up is a possible result \nof using the SIGNAL operation, it is natural to handle it syntactically just like any exception associated \nwith an operation: sIGNAL Y [CLEANUP: . ..] ; Local association suffices when the cleanup action differs \nfrom one invocation of SIGNAL to another. If it should happen that the same cleanup actions are to be \nassociated with every SIGNAL s tatement in some operation, the global form of exception association could \nbe used, e. g. , . F: PROCEDURE [X: ESCAPE, Y:Z: SIGNAL]; ... SIGNAL Y; ;~&#38;NAL z; ... END [CLEANUP: \n. . .]: In short, the cleanup problem is treated just like any exception. The only differences between \nCLEANUP and other exceptions are: CLEANUP is raised implicitly when some handler for Y decides the operation \nis to be terminated;  The actions within CLEANUP cannot raise any exceptions (other than CLEANUP) that \nare not handled within the scope of the CLEANUP handler. For example, CLEANUP could not attempt to raise \nexception X associated with F. The com\u00adpiler can determine whether or not any exceptions raised at activation \npoints within the CLEANUP handler will not be dealt with fully inside the handler, so this constraint \nis not difficult to enforce. The CLEANUP exception can be passed from a local CLEANUP handler to a more \nglobal one, but it cannot be passed outside the operation being terminated. This rule can also be enforced \nby the computer.  When control exits from the CLEANUP handler, instead of executing the next s tatement, \nas is normally the case (see Section 3.2. 1), the operation is terminated and control returns to the \npoint specified by the handler terminating the operation.  We will discuss other issues related to CLEANUP \nin Section 3.3. We noted earlier that exception handlers could be associated with loops, and hence, with \nloop exiting. For example, the ESCAPE state\u00adment serves naturally as a multi-level loop exiting method, \ne. g. , LOOP UNLESS X; LOOP WHILE A # B UNLESS X; ;; THEN ESCAPE X; ELSE ... REPEAT; REPEAT [X: . ..]. \nWhen X is raised, both the inner and outer loops will be terminated. Similarly, exceptions raised by \noperation invocations within a loop (instead of with an ESCAPE s tatement) can cause exiting from the \nloop, e. g. , if F is able to raise the ESCAPE exception X, then we could write: LOOP UNLESS X; .,. \nB = F(A) [X: PASS]; i ~ F(A) [X: PASS]; REP;AT [X: ... ]; The PASS statement written with each invocation \nof X indicates explicitly that X is not handled locally, but rather, that the exception is passed to \na containing context. It would certainly be possible to permit F to be invoked without explic \u00aditly mentioning \nthe exception X in this case, but for clarity , it seems more reasonable to have a programmer explicitly \ndeclare his disinterest in dealing with X locally. This should make the program more understandable to \nreaders, who will be reminded thereby that the exception X is raised by F and not some other operation \ninvoked within the loop. MPS [12] and MU LTICS support the PASS operation; MPS calls it REJECT, and MU \nLTICS requires that a user call the subroutine continue_ to_signal . . Exceptions can be raised by operations \nexecuted within handlers, since otherwise the actions permitted within handlers would be too restricted. \nFor example, it is convenient to be able to write: CALL F[X: CALL G[Y: ESCAPE z]; . ..]; meaning that \nif X is raised, G will be called. If G fails by raising Y, then the handler for X is exited by raising \nexception Z; a handler for Z is assumed to exist somewhere in the context of CALL F. This example suggests \na question: could Z be an exception associated with F, i. e. , can a handler associated with some operation \ninvoke another handler associated with the same opera. tion ? We propose to forbid such a possibility, \nbecause it is useful to be able to write: CALL F[X: CALL G[Y: ESCAPE X]; . ..]. meaning that if G fails, \nthen the handle r for X fails and it is appropriate to pass the exception X on up to a higher context. \nNote that we could not write PASS in place of ESCAPE X because we do not want to pass exception Y up \nhigher, we want to raise exception X. Now if it were possible for a handler to invoke a handler associated \nwith the same operation, then ESCAPE X in the above con\u00adtext would seem to recursively invoke the handler \nfor X, and this is certainly not what is desired. Hence we impose the following rule: Only one handler \nin a set of handlers associated with a given operation or statement can be active at any one time. No \nhandler can invoke another handler associated with the same operation or statement. One advantage of \nthis rule is that is makes it possible to add exceptions to operations without having to worry about \nconflicts with exceptions raised by previously existing handlers. The rule implies that: CALL F [X: CALL \nG [Y: PAsS]; ESCAPE Y; Y: ... 1; means some handler for Y in the context of the invocation of F will \nbe invoked when X is raised, since the handler for X cannot raise F!s excep\u00adtion Y. The proposed rule \ncan also be justified by appropriately viewing the context in which handlers operate, i. e. , the Y handler \nfor F in the above example cannot be raised by the X handler for F because Y exists to handle exceptions \nraised from within F, and the ESCAPE Y and PASS s tat.emen k above are not being executed from within \nF but in the context of the call to F. Hence the ESCAPE Y is not intended to raise an exception to be \nfielded by any handler associated with F. The ability to pass exceptions up is con\u00advenient because it \nis quite natural to deal with an exception first on a local basis and then on a more global basis. For \nexample, it is often convenient to be able to write something like this: LOOP UNLESS X ; ... B = F(A) \n[X: . . . PASS]; ... REPEAT [X: . . . PASS]; meaning that the exception X is first dealt with locally, \nand when either no fixup is deemed possible for when no further action using local context is useful, \nthe exception is passed on up to the next handler, in this case one associated with the loop. When this \nmore global action is com\u00adpleted, the exception is passed up to a still more global context. This is \noften quite natural and is more convenient than having to invent different exception names just to prevent \napparent naming conflicts. Note that the program fragment given above could itself be part of a handler \nfor an exception called X. Even so, the flow of control as explained above would be unchanged. Note also \nthat PASS could have been written as ESCAPE X. PASS seems more natural here. PASS also gives useful extra \npower to the exception raising capabilities when a handler is identical for two or more exceptions. For \nexample, CALL F [X:Y: PASS]; means that exception name X or Y, depending on which was raised by F, is \npassed on to an enclosing context. This makes the excep\u00adtion handling notation more concise and readable \nin such circumstances. We will note another use for PASS in Section 3.4, when we discuss its use for \ndealing conveniently with optional exceptions. The issues discussed in this section may be summarized \nas follows: prevention /detection of errors  the need to classify exceptions according to their control \nflow constraints (ESCAPE, NOTIFY, SIGNAL)  readability .  the need for multi-level exits to support \ngoto-free programming (ESCAPE to handlers associated with loops or compound state \u00adments);  exception \nhandling requirements   the need to clean up before terminating an operation (the CLEANUP optional \nexception associated with SIGNAL)  the need to deal with an exception first locally and then more globally \n(PASS)  the need to resolve certain ambiguities  about which handler is invoked when an exception is \nraised from inside a handler (the rule permitting only one handler in a handler group to be active at \na time) 3. 2.2 Leaving a Handler The difficulty presented by SIGNAL excep\u00adtions with traditional exception \nhandling methods (PL/I ON conditions and subroutines passed as parameters ) is that an explicit GOTO \nstatement is needed to transfer control out of the exception handler to the appropriate point in the \nmain con\u00adtrol flow. This need for an explicit GO TO state \u00adment is repugnant in light of current desires \nto replace GO TOis with more structured statements for specifying control flow. In this section, we discuss \nthe various requirements associated with transferring control out of a handler. In the exception handling \napproach being proposed in this paper, the last executed state\u00adment in a handler must explicitly state \nwhether the operation raising the exception is to be ter\u00adminated or resumed or if the exception is to \nbe passed to another handler. If a programmer writes RESUME, control will return to the operation raising \nthe exception. Termination of the operation is expressed by having the flow of control leave the handler, \neither by raising an escape type exception, or by executing an EXIT statement. The EXIT statement provides \nseveral options for specifying what context is being exited, and hence, what s tatement o r operation \nis to be executed next, but its simples t form is just the word EXIT, meaning that the statement contain\u00ading \nthe handler being exited is to be considered complete, and the next statement in the normal control flow \nis to be executed. For example, in the following program fragment, if exception A is raised, in both \ncases the next statement executed will be the statement assigning C to D: CALL P [A: EXIT]; D=C; i; Q \n[A: EXIT] THEN ... ELSE ... D=C; When this convention for a parameterless EXIT statement does not express \nthe desired control flow, the EXIT may con text to be take left. an argument For example, that defines \nconsider: E = F [X: ;~~L G [Y: EXIT F]; D=C; EXIT;] ; The EXIT F statemraised, I = J will immediately \nflow returns normally ent not be to D and means that executed = C; if Y is J is assigned and if exception \ncontrol not raised, to I; then Y will G the is assignment to E is not made, because the execution of \nF is terminated by the final EXIT statement, and control flows to D = C;. We have illustrated in previous \nsections the use of EXIT to terminate execution of a function, returning a value for the function as \nthough it had terminated normally. For example, if the EXIT F statement above were replaced with EXIT \nF (6), then P would be terminated and execution would continue as though F had returned the value 6, \nwhich would &#38;en be assigned to E. Figure 5 illustrates other possibilities. We previously mentioned \nCLEANUP as an exception raised implicitly under certain circum\u00adstances. There is a need for another implicitly \nraised exception as well --an exception 1 called ENDED that signifies the normal completion of an operation \n[26]. Figure 6 shows why. Sometimes special action must be taken just in the cases where the operation \nterminates normally. For example, in a loop searching for a value in an array, an exception FOUND might \nbe raised just in the cases where the value is found. But when the loop terminates normally, this means \nthe searched-for value has not been found, and appropriate action must be taken before the flow paths \nfor the found and not found conditions can be merged. For example a program to count the number of different \nand duplicate values in an array V containing N elements might be written (Cf [13]): DIFF = O; LOOP I=1TO \nN; LOOP J = 1 TO DIFF UNLESS FOUND; IF VII] = A[J] THEN ESCAPE FOUND; REPEAT [FOUND: B[J] = BIJ]+l; EXIT; \nENDED: DIFF = DIFF t 1 ; A [DIFF] = v [I]; B [DIFF] . I; EXIT]; REPEAT; When a function returns normally, \nthe ENDED handler needs to deal with the returned value. Perhaps it is reasonable to use the word ENDED \nitself to represent the value, e. g. , B= F(A) [X:... ENDED: . . . EXIT (ENDED)]; ENDED could also be \nused in expressions, e. g. EXIT ( -ENDE D) would return the complement of the value F returned. To summarize, \nthe issues concerned with leaving an exception handler are: ability to avoid explicit GOTOS to terminate \nthe operation raising the exception; the need to express what handler is being left; multi-level exits \nfrom nested handlers;  the need to provide a value for a function when leaving a handler, e.g. , EXIT \n(6).  ability to define an exception handler for normal termination of an operation (ENDED) H: PROCEDUREIW: \nESCAPE]; DCL F ENTRY [X: SIGNAL] RETURNS (FIXED); DCL G ENTRY [Y: ESCAPE]; . . . LOOP UNLESS Z; . . . \nB= F[X: . . . CALL G [Y: . . . term]; RESUME]; C=D; . . . REPEAT [Z: . . . EXIT]; . . . RETURN; END ; \nNext Statement term Effect Executed EXIT G abort G RESUME EXIT equivalent to EXIT G RESUME EXIT F I abort \nF and G; do not change B C=D; EXIT F (6) I abort F and G; F given value 6 which is C=D; I as signed to \nB ESCAPE Z abort F and G; Z s handler ESCAPE W abort F, G, and H; w s handler RETURN abort F and G; H \nreturns EXIT H equivalent to RETURN Figure 5. Example Showing Effect of Substituting Different Statements \nfor term EscAp7~F&#38;ETuRN Y Figure 6. The Need for ENDED Before proces sing can resume independently \nof whether F raised any exceptions or terminated normally, it may be necessary to perform some actions \nnecessary &#38; when the operation terminates normally. ability to refer to the value pro -deals with \nall exceptions the operation can raise. duced by a function inside an Some additional iss ues arise when \nthe operation ENDED exception handler. handling an exception is not the immediate caner of the subroutine \nraising the exception. For 3.3 Exception Handling Hierarchies example, suppose operation B is called \nby operation A. A expects B to raise exception X Up til now, we have concentrated on dis -under certain \nconditions, but it turns out that cussing exception handling requirements that these conditions occur \nonly when B invokes arise when the immediate invoker of an operation operation C, so C is the ope ration \nthat actually raises the exception. B merely acts as a conduit, transmitting the exception raised by \nC to A. b this section, we will focus on special problems peculiar to operations in B s position. The \nproposed exception handling technique uses PASS to explicitly dis claim interest in (further) processing \nof an exception, directing that the exception be passed on to some higher handler. If it should happen, \nas in B s case, that an exception is always to be passed to an invoking operation without any processing \nat all, then it violates the principle of conciseness to require that a programmer repeatedly write PASS \nfor exceptions in which he has not the slightest in\u00adterest. For example, following the conventions and \nrules given previously, the implementor of B would have to write: B: PROCEDURE [X: SIGNAL] DCL C ENTRY \n[X: SIGNAL]; ... LOOP WHILE . . . UNLESS X; CALL C [X: PASS]; ... REPEAT; ... END ; We argued before \nthat these explicit references to X were important for preventing errors and enhancing readability, but \nin this case the loop is exited only if B is terminated ! It seems more reasonable and sufficiently safe \nto permit a pro \u00adgrammer to declare his disinterest in dealing with exception X anywhere in B. For example, \nhe could write: B. PROCEDURE [X: SIGNAL]; DCL C ENTRY [X, SIGNAL]; DCL X EXCEPTION PASS; ~bOP WHILE ... \n; CALL C; ... REPEAT; END: A separate declaration is used to declare B s dis\u00adinterest in X (rather than \nwriting DCL C ENTRY [X: SIGNAL PASS] ) because the declaration of C might be supplied from a COMPOOL \nor INCLUDE file [ 2 1], and such a centralized declaration of C s properties could not ~nclude the PASS \nproperty, since it will not apply to every routine using C. So a separate declaration is necessary. It \nshould be noted that if B s invoker decides to t6rminate B (and implicitly, C ) when X is raised, there \nmight be a need to clean up before B is terminated. The CLEANUP exception could be attached either to \nthe invocation of C o r to the END, or in both places, e. g. , B: PROCEDURE [X, SIGNAL] ; tiALL c [CLEANUP: \n. . . PASS]; ... END [CLEANUP: . . . EXIT]; A routine like B might also have another function in mediating \nbetween exceptions raised by C and handled by A, namely, C might raise a more detailed set of exceptions \nthan A is interest\u00aded in. For example, C might raise exceptions Q, R, and S, but as far as A is concerned, \nit only wants to bow about exception X. B knows that when Q, R, or S is raised, X should be signaled. \nOrdinarily, to do this, a handler like the following would be written: [Q:R:S: SIGNAL x; R13suiME]; but \nonce again, if B is acting solely as a conduit for C s exceptions, it is awkward and unnecessary to perform \nthis translation as explicitly and as frequently as our previously developed require\u00adments would imply. \nA declaration defining this translation once and for all is again the useful answer that trades off explicitness \nfor conciseness. DCL (Q, R, S) EXCEPTION PASS CLASS (X); The ability to pass exceptions through several \nmodule levels to a module prepared to deal with them has advantages and disadvantages. Its advantage \nis essentially the same as one of the advantages of the multi-level exit --it makes systems transparent \nto the introduction or deletion of modules at intervening levels of abstraction. The dis advantage is \nthe potential inability to be s ure that an implementor of an intervening module knew of and explicitly \ncon \u00adsidered the possible occurrence of each such an exception before deciding its occurrence is of no \ninterest. The declaration of PASS and CLASS exceptions overcomes this disadvantage. The lack of such \ndeclarations in PL/I is a disadvantage of the PL /1 approach to exception handling. 3.4 Default Exception \nHandling Up to now, our discussion has concen\u00adtrated on exceptions that have handlers provided explicitly \nby invokers of operations. It is very convenient, however, to define default handlers for some exceptions. \nThese handlers are invoked unless specifically overridden by a programmer\u00addefined handler. Exceptions \nhaving default handlers will be called default exceptions. Failure to provide a handler for a default \nexception is not an error; to the contrary, it is the way of specifying that the default handler is to \nbe executed. Most exception handling methods do not treat requirements for default exceptions very well. \nThese requirements are: 1) the ability to specify, for any activation point, whether a default handle \nr is to be invoked or overridden. 2) the ability to supply default handlers for programmer -defined subroutine \npackages as well as for system-defined operations (addition, 1/0, etc. ); the method should be as similar \nas possible to the method for dealing with system\u00addefined defaults. 3) the ability to pre -empt one default \nhandler with a higher level default handler. 4) to help prevent and detect mistakes in using exceptions, \nexceptions having default handlers should be declared to have them. Only if the existence of default \nhandlers is made lmown to a compiler can the compiler detect proper treatment of exceptions (i. e. , \nfailure to provide an explicit handler is an error only for non-default excep \u00adtions ). Default exceptions \nare rotationally ess ential. They make operation invocations more concise and read - able. The firs \nt requirement (ability to control whether default handlers are invoked or overridden) is satisfied adequately \nin PL/I only for system\u00addefined exceptions like OVERFLOW. For such exceptions, a programmer can insure \nthat the default handler will be invoked at certain activa \u00adtion points by writing ON condition-name \nSYSTEM; For example, the following sequence of statements establishes a default overriding OVERFLOW \nhan\u00addler for the first addition, and removes it for the second addition: ON OVERFLOW BEGIN; . . . END; \nA = B t C; /*uses programmer-defined handler ~/ ON OVERFLOW SYSTEM; / ~ restores default handle r ~/ \nA =D +B; /*will use default handler :/ This technique for insuring the execution of a default handler \ncannot, however, be applied to programmer -defined exceptions, e. g. , X, because the nature of the SYSTEM \nhandler for X is not known to the compiler and PL/I provides no mechanism for making it known. Writing \nON CONDITION X SYSTEM is an error and does not associate execution of X s default handler with the desired \nactivation point. So defaults associated with programmer -defined exceptions cannot be treated in the \nsame way as PL /1-defined defaults. This lack of uniformity is a deficiency in PL/I s exception handling \napproach. MULTICS [23] has two mechanisms that permit defaults to be defined and restored for sub\u00adroutine \npackages; one is currently obsolete (though still implemented). We will describe both and ex\u00adplain their \nadvantages and disadvantages. The obsolete method for dealing with pro\u00ad grammer -defined default exceptions \nis that when an exception is raised and no handler is found for Ilmclaimed signal! is raised it, another \nexception with an argument giving the name of the unhandled exception. The search for an unclaimed signal \nexc e~tion handler beains with the operation origi \u00adnally raising the exc=ption for whit-h no handler \nwas found. For example, suppose program A calls subroutine B, and B calls C. C raises ex\u00ad ception X, \nbut no handler for X is defined at C s activation point in B, or at B ts activation point in A. The exception \n unclaimed signal (X ) is then raised, and a handler for unclaimed signal is looked for in C. If one \nis found, it is invoked, and it tests its argument to see if it is lX1. If so, it performs some appropriate \naction. In this way, a default action for X is always performed if no explicit handler has been defined \nfor X. The simi \u00ad larities and differences between this approach to default exception handling and the \nmethod for s ys tern -defined exceptions is illustrated in Figure 7. Figure 7 shows that ON OVERFLOW \nSYSTEM is not equivalent to REVERT OVERFLOW, and yet, with the unclaimed signal approach to default invo \n\u00adcation, the programmer is provided only with the REVERT capability for res~oring default handlers. Specifically, \nFigure 7 shows that a programmer can guarantee invocation of the default handler for system-defined exceptions, \nbut not for program\u00addefined exceptions. It might be argued that if A (the caller of B) has a handler \ndefined for OVER-FLOW, the implementer of B should not be per\u00admitted to pre-empt it with the default \nhandler. But equally well, it could be argued that if B depende for its correctness on the default handler \ns effect, A s handler for OVERFLOW is pre-empted by writing ON OVERFLOW SYSTEM, but is not pre \u00adempted \nby writing REVERT OVERFLOW. To make the capabilities of programmer-defined and system\u00addefined exceptions \nequivalent, a capability equiva \u00adlent to ON CONDITION X DE.FAULT is still needed. This deficiency is \nremedied in the current version of MU LTICS [,27] by providing the opera\u00adtions default_handler_$s et \nand default_handler_ _$revert, Rather than explain how these routines are used in MU LTICS, we will first \nexplain our approach to default exception handling, show how it solves this problem, and then show how \nit can be extended to provide even more capabilities than MU LTICS currently provides. In extending \nour proposed exception handling notation to deal with requirernents for default hand\u00adling, the first \nissue is to distinguish those excep\u00adtions for which default handlers exist (requirement (4) above). Then \na compiler can enforce the rule that absence of a handler is an error unless the exception is a defult \nexception. We propose that default exceptions be distinguished by declaring them to have the attribute \nOPTIONAL , since it is optional for the programmer to provide an ex\u00adception handler for these exceptions. \nFor example, DCL F[X: ESCAPE, Z: SIGNAL OPTIONAL]; means a handler must be provided for X but not for \nZ. Note that ESCAPE exceptions cannot, by their very nature, have default handlers. Our next proposal \nis more radical --thp s earth for a default handler is not automatically continued from one invoker to \nt~next, up the chain of calls. The search continues to higher levels only if the default exception is \nexplicitly passed on up. This is consistent with our principle of being explicit about important connections \nbetween mod \u00ad ules. We don t want exceptions to be passed by convention to an invoker. Moreover, there \nis no need to examine invokers in a call chain for a handler unless these invokers have been explicitly \nB: PROCEDURE; -ON CONDITION BEGIN; . . . END; CALL C; / :if X is raised, itsdefault handler will be \noverridden>:/ REVERT CONDITION X; />:~ .now:no handler for X exists in B >~/ CALL C; />~ if X is raised, \nand if B s callers do not have handlers defined for X, the default will be invoked >*/ ON OVERFLOW BEGIN; \n. . . END; F= G+H; / ~ if OVERFLOW is raised, its default hmdler is overridden ~/ ON OVERFLOW SYSTEM; \nF= G+H; /* if OVERFLOW is raised, its default handler will now be invoked even if a caller of B has \ndefined a handler for OVERFLOW >~/ REVERT OVERFLOW; F= G+H; / ~ now if OVERFLOW is raised, it will be \npassed to the caller of B ~/ END; Figure 7: The difference between replacing programmer-defined and \nsystem-defined defaults in PL/I. B: PROCEDURE [X: SIGNAL OPTIONAL, OVERFLOW: SIGNAL OPTIONAL]; DCL C \nENTRY [X, SIGNAL OPTIONAL]; &#38;hL c [x: . ..]. />~ default handler overridden*/ CALL C [x: PASS]; />: \nexception passed to B s invoker */ F = G + H [OVERFLOW; . . .]; />~ default handler overridden >~/ F \n= G + H; / :: default invocation ,k/ F = G + H [OVERFLOW: PASS]; />: exception passed to B!s invoker \n>:/ END ; Figure 8: Program equivalent to that in Figure 7, but expressed in the proposed notation. \nRO GRA D END PAGE PACKAG B K;~ ENDPAGE ENDPAGE PRINT  L-_---i Figure 9: An example of Multiple Default \nHandlers. CALL PRINT [ENDPAGE: SIGNAL ENDPAGE [DEFAULT: . . . ; EXIT; />: overrides PRINT default; serves \nas defualt for Package A or B : / ENDED: . . . EXIT]; / :t pRO GRAM D provided an overriding handler \n~<! RESUME]; />~ control returns to PRINT ~/ Fi~ure 10: Substituting a Default Handler. given the power \nto deal with the exception being raised. Figure 8 demonstrates these new features with a program equivalent \nto that shown in Figure 7. The program shows clearly that in the second call to C, B has disclaimed any \nresponsibility for pro\u00adviding an overriding handler by passing the search for a handler explicitly up \none level. Note: We consider a default handler to be overridden ~ if a handler exits without returning \nto the operation raising the exception, or if control returns to the exception -raising operation via \na RESUME. PASS\u00ading an exception higher does not override the default handler. Note that in Figure 8, \nwriting just GALLC; without any handler for X means X 1s default handler will be invoked if X is raised, \neven if there is an overridtig handler for X associated with the call to B. This happens because the \nsearch for an over\u00adriding handler stops unless the exception is explicitly passed up to B s invoker. \nUsing the special MU LTICS routines referred to earlier, these effects could be obtained by writing: \nON CONDITION X BEGIN; . . . END; CALL C; /* equivalent to CALL C[X:. ..] ; ~/ REVERT CONDITION X; CALL \ndefault_handler_$s et(B_defaults ); CALL C; / ~equivalent to CALL C; */ CALL default handler_$revert; \nCALL C; /*e~uivalent to CALL C[X: PASS]; >~/  where B_defaults is the name of a subroutine that tests \nto see if a raised condition is IX , and if so, calls X default, the name of the default handler for \nX. The comments in the program explain the effect of the calls to C in my proposed notation. The greater \ncomplexity of the MU LTICS technique is clear. The proposed notation for associating de \u00adfault handlers \nwith some exception is illustrated below. With respect to Figure 8, this is what the implementer of subroutine \nC would write to define a default handler for X: SIGNAL X[DEFAULT: . . . / ~ the default handler for \nX ::/ CLEANUP: . . . ENDED: . ..] />~ invoked if default is overridden */ In short, DEFAULT is an exception \ncondition asso\u00adciated with the SIGNAL operation. This condition occurs only if no overriding handler \nis found for X, in which case, the actions associated with SIGNAL X s DEFAULT exception will be execu\u00adted. \nThe CLEANUP actions will, of course, be executed if X]s override handler does not return control to C. \nThe actions associated with ENDED will be executed just in case the default handler for X is not executed \nand C is resumed. Note that this is the normal definition of ENDED as applied to the SIGNAL statement. \nDEFAULT exceptions can be associated with NOTIFY as well as with SIGNAL operations. The ability for \nhigher level programs to subs titute default handlers for lower level default handlers can be quite useful. \nFigure 9 illustrates the meaning and value of substituting rather than overriding a default handler. \nThe Figure shows an application program, PROGRAM D, that makes use of two program packages, A and B, \neach of which prints mate rial using a PRINT utility sub \u00adroutine. The PRINT utility is assumed to raise \nthe exception ENDPAGE at appropriate points. Instead of having Package A and Package B over\u00adride the \nPRINT default handler, they need to signal D to see if D wants to deal with the ENDPAGE exception. If \nnot, A and B will deal with the ex\u00adception in an appropriate way. As far as D is con\u00adcerned, the default \nresponse for ENDPAGE when using Package A can be different from the default response for Package B. In \neffect, Package A and B need to provide their own default response for the ENDPAGE exception raised by \nPRINT. The solution to this problem is quite simple using the mechanisms already provided. If the call \nto PRINT is written in Package A or B as shown in Figure 10, the desired effect will be obtained. Figure \n10 shows that if Program A or B SIGNAL rather than PASS the ENDPAGE exception to D, they can provide \na special default response if D chooses not to handle the exception. The de\u00adfault handler provided by \nA and B will presumably be cliff erent from the default provided by PRINT, and this default will be executed \nonly if PROGRAM D does not override it. Note that the EXIT from the DEFAULT handler in Figure 10 terminates \nthe SIGNAL ENDPAGE operation; it does not terminate the PRINT operation. Sometimes an invoker may want \nto take some action in response to an exception, and then want to execute the lower level default handler \nanyway, i. e. , an invoker should be permitted to invoke a default handler explicitly as well as im\u00adplicitly. \nTo permit this, we add an option to the RESUME statement that can be used when return\u00ading control to \nthe SIGNAL or NOTIFY statement raising a default exception. To specify invocation of the default handler \ninstead of overriding the de\u00adfault handler, a programmer writes RESUME (DEFAULT); instead of RESUME. \nThis makes it look like there really was no handler for the exception and so the default handler will \nbe executed. For example, with respect to Figure 8, writing CALL C with no handler for X is equivalent \nto writing CALL C[X: RESUME(DEFAULT)]; RESUME (DEFAULT) is analogous to PASS, except that it directs \ncontrol flow downward to the next default handler ins tead of upward to an overriding handle r. h the \nexample illustrated in Figure 10, Package A or B could resume the PRINT program by invoking PRINT s default \nhandler for END PAGE, if this were appropriate, by writing RESUME PRINT (DEFAULT) instead of EXITing \nfrom the DEFAULT handler. This. discus sion shows that the important distinction between default and \nnon -default handlers is in whether lower or higher level programs have the power to pre-empt the handlers \nat a given level. If a higher level handler can prevent execution of a lower level handler, then the \nlower level handler is a default handler. If a lower level handler can prevent execution of a high level \nhandler, then the lower level handler is not a default handler; it is what we have been calling an overriding \nhandler. Our method gives programmers the ability to per\u00admit either a lower level or a higher level to \nhave the final say in how an exception should be disposed of. The proposed method of dealing with defaults \nsatisfies all default handling requirement by extend\u00ad ing our previously developed exception handling \nnotation in a uniform way. We assume that system\u00addefined exceptions like OVERFLOW will be defined as \ndefault exceptions, so a programmer does not have to provide an explicit handler for every opera\u00adtion \nable to raise such exceptions. Of course, this means an OVERFLOW default handler must be overridden by \nthe immediate invoker of an arithmetic operation (if it is not passed up explicitly unlike in PL/1, but \nthis is probably the way it should be dealt with anyway. Only the immediate invoker knows enough about \nthe context of the overflow\u00adraising operation to take appropriate action; a high\u00adlevel invoke r would \nnot be able to respond approp\u00adriately. 4. Conclusions In this paper we have discussed the issues posed \nby exception conditions and how these issues have been dealt with by existing exception handling methods. \nWe have proposed a new exception hand\u00adling notation that solves exception handling problems in a more \nuniform and reliable way than any exist\u00ading method. Our proposed method is not complete, for we have \nnot yet resolved how to satisfy the need for parameters associated with exceptions. None\u00adtheless, our \nanalysis shows that the wide variety of exception handling approaches that exist today can be replaced \nwith a single uniform approach that satisfies tie needs of failure, result classification, and monitoring \nexceptions equally well with reason\u00ad ,, ame efficiency. REFERENCES 1) Dahl, O-J. ,Dijkstra, E. W. , and \nHoare, C.A. R. , Structured Programming, Academic Press, New York, N. Y. , 19 72. I,on Semantic Levels \nin Program\u00ad 2) ~tiO~,g,~~r~~~lFIP Congress 71, 1972, 402-407. Liskov B. H. , 11A Design Methodology for \nReli\u00ad 3) able So~tware Systems, Proc. 1972 FJCC, 191-199. Liskov, BO HO , llThe Design of the VENUS C@er \n\u00ad4) ating System, I GAGM 15, 3 (March 1972), 144-149 5) Dijkstra, E. W., The Structure of the THE - Multiprogramming \nSystem, CACM 11, 5 (May 1968),341-346. 6) Liskov, B, and Zilles, S. , progra~ing with Abstract Data \nTypes, SIGPLAN Notices 9, 4 (April 1974), 50-59.  .7) Hoare, G, A. R. , A Note on the FOR Statement, \n BIT 12. (1972), 334-341. ,,project sUE as a Learn\u00ad 8) Sevcik, D. L. , et. al. , ~gEwerience, ( proc. \n1972 FJCC, 331-338. ! 7A Technique for Software Mod - Y) Parnas, D. L. , 1, CACM 15, ule Specification \nwith Examples, (Mav 1972), 330-336. IIResp~nse to Detected Errors 10) Parnas, D. L. , in Well-Structured \nPrograms, Dept. ofcomp. Sci. , Carnegie-Mellon University, Pittsburgh, Pa. , July 1972. 11) Mitchell, \nJ. G. , Signals, Unpublished note, September 1973. 12) Lampson, B. W. , Mitchell, J. G. , and Satterthwaite> \nE.H. , On the Transfer of Control Between Con\u00adtexts, Xerox PARC, Palo Alto, Cal. , undated. 13) Noble, \nJ.M. , The Control of Exceptional Con\u00additions in PL/I Object Programs, Proc. IFIP Congress 68, C78-C83. \n14) Knuth, D. E. , Structured Programming With GO TO Statements, STAN -CS-74 -416, Stanford University, \nPalo Alto, California PB2335C17 /3, May 1974. 11A Contro I Statement for Natural 15) Zahn, C.T. , Top-Down \nStructure Programming. Symp osium on Programming Languages, Paris 1974. 16) Ross, D. T., The AED Free \nStorage Package, CACM 10, 8 (August 1967), 481-492. 17) Golomb, S. W. and Baumert, L.D. , Backtrack \nProgrammtig, JACM 12, 4 (October 1965), 516-524. 18) Horning, J. J. , Lauer, H. C. ,Melliar-smith> \nP. M. ~ Randell, B. , Program Structure for Error De\u00ad tection and Recoveryj Computing Laboratory, Univ. \nof Newcastle upon Tyne, England, Decem\u00adber 11, 1973. 19) Hoare, C. A.R. , Parallel Programming: An Axiomatic \nApp roach, STAN-CS-73-394, AD769674, October 1973. 20) ---, AED Programmer s Guide, SofTech, hc. , Waltham, \nMass. 1972. 21) ---, OS PL/I Checkout and Optimizing Com\u00adpiler: Language Reference Manual, IBM Corp. \n, GC 33-0009-3, 1974. 22) Weinberg, G. M. , The psycholo~v of Computer Programming, Van Nostrand Reinhold \nCo. , New York, N. Y. , 1971. 23) Organick, E. L. , The MU LTICS System: An Examination of Its Structure, \nMIT press, Cambridge, Mass. , 1972, 187-216. 24) Parnas, D. L. , Information Distribution Aspects of \nDesign Methodology, ,, pi-o C. IFIP Congress 71Z Booklet TA-3, 26-30. 25) Parnas, D. L+ , l!on the Criteria \nto be Used in Decomposing Systems Into Modules, CACM 15, 12 (December 1972), 1053-1058. 26) Bochmann, \nG. V. , Multiple Exits From A Loop Without the GOTO, CACM 16, 7 (July 1973), 443-444. 27) , The Multics \nProgrammer s Manual, Vol. 11 -Reference Guide, Honeywell, Inc. , AG-9 1A, July 1973. \n\t\t\t", "proc_id": "512976", "abstract": "In this paper, we define what exception conditions are, discuss the requirements exception handling language features must satisfy, survey and analyze existing approaches to exception handling, and propose some new language features for dealing with exceptions in an orderly and reliable way. Our objective is not solely to put forward a language proposal. It is also to analyze exception handling issues and principles in detail. The proposed language features serve to highlight exception handling issues by showing how deficiencies in current approaches could be remedied in a coherent and orderly way.", "authors": [{"name": "John B. Goodenough", "author_profile_id": "81100238611", "affiliation": "SofTech, Inc., Waltham, Mass.", "person_id": "PP39033971", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/512976.512997", "year": "1975", "article_id": "512997", "conference": "POPL", "title": "Structured exception handling", "url": "http://dl.acm.org/citation.cfm?id=512997"}