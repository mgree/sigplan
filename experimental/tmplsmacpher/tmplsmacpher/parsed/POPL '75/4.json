{"article_publication_date": "01-01-1975", "fulltext": "\n Permission to make digital or hard copies of part or all of this work or personal or classroom use is \ngranted without fee provided that copies are not made or distributed for profit or commercial advantage \nand that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, \nto post on servers, or to redistribute to lists, requires prior specific permission and/or a fee.&#38;#169; \n1975 ACM 0-12345-678-9 $5.00 AUTOMATIC DATA STRUCTUFU2 CHOICE IN A LANGUAGE OF VERY HIGH LEVEL J. T. \nSchwartz Computer Science Department, Courant Institute, New York University Abstract SETL is a set-theoretically \noriented language of very high level whose reper\u00adtoire of semantic objects includes finite sets , ordered \nn-tuplesr and sets of order\u00aded n-tuples useable as mappings. This paper sets forth techniques for the \nlogi:. cal analysis and optimization of SETL programs. The techniques described allow relations of inclusion \nand membership to be established, the domains and ranges of (tabulated) mappings to be estimated from \nabove and below, and the singlevaluedness of (tabulated) mappings to be proved. Once facts of this kind \nhave been estab\u00adlished, automatic choice of data struc kures becomes possible. The methods employed are \nbased upon, and extend, known techniques of data-flow analysis. Keywords and Phrases Program optimization, \nautomatic pro\u00adgramming, high level languages, set\u00adtheoretic languages, data structure choice . This work \nwas supported by the Nation al Science Foundation under Grant NSF-GJ\u00ad1202x3. SETL (cf. Schwartz [11, \nMorris [11) is a set-theoretically oriented lan\u00adguage of very high level whose reper toire of semantic \nobjects includes not only the integers, reals, strings, and procedures of medium-level programming languages, \nbut also sets, ordered n\u00adtuples, and sets of ordered n-tuples useable as mappings. A SETL program may \nbe considered to represent an algorithm as it exists before the detailed data choices which govern algorithm \nrealiza\u00adtion in a language of lower level (such as PL/1 or ALGOL 68) have been made. Because of the abstractness \nof SETL its unoptimized compilation produces code of rather low efficiency, consisting largely of calls \nto library routines each of which implements the most general case of some basic set-theoretic construction. \nAgain because of the abstractness of the language, most of the relatively routine decisions which a programmer \nmakes in realizing an algorithm efficiently are potentially availableto an optimizing SETL translator \nhaving a language of roughly PL/1 level as target. This paper will out\u00adline a number of program analysis \ntechni\u00adques, in part built on currently known global optimization methods, which should allow many of \nthese choices to be made automatically. For an account of classi\u00adcal global optimization techniques, \nsee Schaefer [1], Allen [1]. A more detailed account of the algor\u00adithms to be sketched in the present \npaper will be found in SETL Newsletters 131 and 132: cf. Schwartz [2,3,6]. We note also, as a necessary \npreliminary to this paper, that although SETL involves no type decla\u00ad rations, the types of the objects \nappear\u00ading in SETL programs P can be deduced by an appropriate global analysis. For this, see Tenenbaum \n[1,2]. The typefinding analysis described by Tenenbaum yields rather precise information and, e.g. , \nis capable of discovering that the value of a variable x is a program P is a set of triples, each having \nan integer first component, a character string second component, and a third component which is a set \nof integers. We assume that this kind of detailed type information is available at the start of the \nmore penetrating program analysis which we shall now describe. We begin by introducing symbols for certain \nimportant monadic operations on SETL objects i. Specifically: The symbol 3 denotes the operation of choosing \na random member of a set i; the symbol n (an integer) signifies the operation of choos\u00ading the n-th component \nof a tuple i ; the symbol w signifies the operation of choos ing an arbitrary component of a tuple; the \nsymbol ii (n an integer) signifies the operation of choosing an arbitrary compo\u00adnent, but not one of \nthe first n-1 compo\u00adnents, of a tuple. We also introduce symbols for various binary operations with boolean \nvalues: ~ denotes the membership relation, 3 and C relations of inclu~i~n, >,>,< , ~ ari~hmetic comparisons. \nNext, usi~g these elementary relation symbols, 36 we introduce a family of composite symbols analysis, \nas described in Tenenbaum [1,2] ; which we shall call relation strings. Let this makes available rather \ndetailed infor-Illr. ..,nk andpl, . . ..~. be symbols repre-mation concerning the structural type of \nsenting monadic mappin~s on composite the values assumed by each ivariable and SETL objects, and let \np denote a binary ovariable of P. Using this type informa\u00adboolean-valued operation. We requite tion, \nwe set up a collection of relation that the mappings pi be single-valued. ships of the form (1) ; heuristically \nspeak-Then if x and xl designate SETL objects ing, this collection consists of all rela\u00adwe write tionships \nxRy which are plausible in view of the known types of the (o-or i-) (1) X ~~n~..-n~ P variables x, y, \nand in view of the opera\u00ad tor defining x (if x is an ovariable). For if the relation (fIk TIk_l. ..?ll \nx) P example, the relationship x c x is only U~. .Pj ~ lJ1. .Pjxl plausible if .x and xl are s~tsland \nif xlholds . The following are significant is known to have elements of a type atexamples of this general \nconstruction: least as wide as the type of the elements means that the n-th component of x of x; x 31s \nx is plausible only if xl is;::;:;40;OXX1 ; x31~ x means that every a set of tuplek each of which has \na firstis a tuplelwhose first compo\u00adcomponent which is of a type at least as nent belongs to x , i.e. \nthat x is a map\u00adwide as the type of x, etc. Startingping with domain $ncludedinxl. The with the set of \nplausible relationships relationship x 3E x ~ means that every for P, our analysis algorithm then works \ndownward, systematically eliminating rela\u00ad element of x is an element of xl , i.e., tionships which might \nbe false, until a that x is included in xl. This is equiva- kernel of mutually confirming, and hence \nprovably true, relationships remains. More lent to Xcx. The family of relation 1 specifically: If i is \nan ivariable a rela\u00adships (1) forms the basic vocabulary of tionship iRx can only hold if ORX holds our \nanalysis, which aims to find statical-for all o 6 ud(i). The remaining rules ly true relationships, i.e. \nrelationships for elimination of relationships reflect (1) which must necessarily hold because of the \nproperties of all SETL primitive opera\u00adof the (compile time) structure of a tors which can appear in \nthe schematized program P. form of P. The full set of rules is lengthy but we illustrate it by listing \nIn our analysis a program is represen-the rules which apply to the relationships ted schematically by \na family of basic Oco. This relationship is always false blocks B consisting of schematic assign-if \nth~ operation defining o is anything ments; the flow-structure of P is repre-other than + (designating \nset union) , -, * sented by a mapping which sends each B (set difference and intersection respec\u00adinto \nthe set of all B to which control tively) , {i} (singleton formation) , can flow when it leaves B. We \nclassify i1(i2) , il(i2, . . ..ik ) (application of a the occurrences in P of variables into map of one \nor more parameters or extrac\u00ad ova?iable occurrences and ivariable tion of a tuple component) , i1{i2} \nor occurrences: an ovariable (resp. ivari able) is an occurrence of a variable as i1{i2,. ..,ik} (application \nof a multi\u00adthe target of an assignment (resp. as an valued map of one or more parameters) . If operator \nargument) in the schematized ois defined by o=il +i2 ,then o~ol form of P. is false unless i C 01 both \n15\u00b01and12-As the first step of our analysis, hold; if o=il -i2 ,then il ~ol mLISt we subject P to the \ndata flou analysis introduced by John Cocke and described hold; if o = il * i2 , then o ~ 01 is in Allen \n[1]; this produces, for each false unless either il ~ ol or i2 ~ 01 ivariable i of P, the set ud(i) of \nall ovariables o which can supply a value holds . If o = {i}, then o c 01 is false to i. Note that we \nwork with programs unless i c 01 holds. If o = il(i2) with which consist of several subroutines, some \nof which can be recursive, and a set, then il 325 01 must hold for % that our data-flow analysis must \noperate Oco_ ~to be true; if o=i (i ,.. .,i across subroutine boundaries; techni-12 k) ques allowing \nthis are outlined in Allen then il 3k~ 01 must hold. lf 0 = l(i%~[2] and Schwartz [5]. Once data-flow \nwith i ~ a tuple, and the value of i2 is analysis has been performed, the remain\u00adder of our analysis \ncan be carried out known to be n at compile time, then o ~ 01 in a manner which makes no reference to \ncm only be true if il n~ 01 is true; if the flow of control in the program P being analyzed; in particular, \nthe exis-the value of i2 is not known at compile tence of subprocedures and subprocedure time, then il \nCO~ 01 must be true. If calls Is not productive of additional complications. o = i1{i2}, then 32E o ~ \n, and if il o = i {i2, . . ..ik}. then il>ke 01 mustOur next step is to perform type hold.l 37 Note also \ntnat a few basic set con stants , such as the null set nfi and the null tuple nult , will enter in=o \nopera\u00adtions as iv-+les. Each of these con stants has properties which are to be exploited in applying \nthe above rules. Relationships satisfied by ovariables whose value is established by a read operation \nmust be declared explic~ in appropriate form. The technique of analysis sketched above, modified in a \nfairly evident way, can also be used to establish useful dis jointness relationships o ~ ~1 and member \nship relationships o @ al (where 8 1 denotes the complementof 01) . Moreoverr it can be used to establish \narithmetic inequalities x > 0, x > y, and their set\u00ad theoretic analo~s x 3~ y etc. The rules applied \nin proving such arithmetic rela tlonships are typified by the following statements: if 01 is defined \nby 01= i+lr > 0 will be rejected unless i > 0; hen 1 if 01 is defined by o = 3i (selection of an element \nfrom i) then i must satisfy i >~ 0 for o > 0 to hold. To avoid the generation of too many initially plausible \nrelationships (if too many are generated, our analysis will become inefficient) we conjecture relationships \no only if ~ 1 the ovariables o and 01 are instances of variables v and v for which a test 1 v~v is made \nsomewhere in the program 1 being analyzed, and conjecture o > 0 only if either v c&#38; O occurs in a \ntest or if at some point v is initialized to zero. The methods of analysis outlined above can be improved \nso that the analyzer is aware that immediately after instruction t=s + s , s C t is necessarily true. \n1 This is accomplished by automatically inserting psezldo-instructions = sl*t; 1 s=s*t; after t = S1 \n+ s. A similar technique can be used in connection with conditional branches, so that, e.g. , the analyzer \nwill know that x E s along one branch of the conditional if x E s then . . . and that x e s along the \nother branch. For use in connection with such pseudo instructions it is convenient to introduce a pseudo-operator, \nwhich may be des~gnated by the symbol oralternatively, where x oralternatively y has either the value \nx or the value y, but where it is understood that the operator is only to be used when it is known that \nx and y have the same value. Note that this construct makes a logical or available during global analysis, \nsince fien z = x oralternatively y , z will have all the properties posses\u00adsed by either x or y. In contrast, \nconverging flow paths are associated dur ing analysis not with the or operation but with the logical \noperation of inter\u00adsection (which is applied to the proper\u00adties known to hold for a variable after a \n9.roup Of converging flow paths has come together) . In optimizing SETL programs, it can sometimes be \nuseful to estimate the domain of a (tabulated) mapping f from below, i.e. to show that the domain includes \nall of some set s. This information, if available, can be used either to ensure that a parti\u00adcular value \nf(x) is not Q (i.e. undefined) , or to justify the association with each element x in s of a field for \nthe value f(x) . The constructions which are normal\u00adly used to build up a function f defined everywhere \non a set s are as follows: (i) The set s may be defined first, and then f may be defined for each element \nof s, either by an iterative loop, e.g. (1) f=@; (Vx ~ s) f(x) = o;; or by a set expression e.g. (2) \nf = {<xJo>, x= s}; (ii) The set s may be built up progres\u00adsively, and f defined for the elements of \ns as these elements are added to s, e.g. in the pattern  (3) .... s S+{x}; .... f(x) =y; ... Of these \ntwo cases, (i) is best handled by treating both explicit set theoretic iterations (4) (Vx G S) bZoek; \nand the set theoretic iterations implicit in expressions such as (2) in terms of auxiliary sets s and \ns representing all the elements x &#38;lready2processed in the iteration (4) , where sl (resp. S2) is \nupdated immediately before (resp. immedi\u00adately after) each cycle of (4) . In such an approach, (4) is \ntreated essentially as if it were (5) sl = nk. s2 = ~; / initialize J sets to null */ while 1 = ) x = \n3 (S-Sl) ; /* choose arbitrary element of s-s ~ / Sl= Sl+{x}; block; s2= (s2+{x}) oralternatively 51; \nend while; S=s oralternatively s; l If this transformation is applied, then the analytic methods outlined \nearlier will suffice in cases like (1) and (2) to prove that the domain of f includes s. Case (ii) , \nexemplified by (3) , is more difficult to handle. To treat it, we can 38 allow our fact-gathering routine \nto mani\u00adpulate statements of the form (6) sC{x} +domain (f) . If the analysis algorithm is to be of reasonable \nefficiency, it is important not to permit facts of so compound a structure to be surmised unless they \nare likely to be both true and useful. To help ensure this, we allow statements of the form (6) to be \nmanipulated by our analysis routines only if x occurs in an assignment of the form f(x) = .... and only \nif x E s, s C domain(f) , and x 6 domain (f) are all pl~usible. In dealing with maps, it is generally \nimportant to know when they are single\u00advalued. When true, this fact will often be provable by a straightforward \nvariant of the techniques that we have described. Specifically, we can introduce a family of monadic \nassertions concerning sets f of ordered n-tuples, writing these assertions as anf , where n > 1. The \nassertion unf signifies that f is a single-valued map\u00adping of n parameters. This relationship is only \nplausible if f is a set of n+l tuplesr or is the null set. The assign\u00adment f = nt confirms a f; a f holds \nafter an =signment of the f~rm f(xl,. ..,xn) = . . . if it holds before this assignment. Applying these \nrules and a few others, we can eliminate relationships anf from an initially surmised set until the relationships \nwhich remain become mutually confirming. Once information concerning set theore\u00adtic relationships of \ninclusion, membership, domain inclusion, and single-valuedness of maps has been collected, we are in \na position to make automatic data-structure choices . (For a study of some of the issues which arise \nin connection with such choices, see Low [1] .) To implement an abstract algorithm P efficiently, a manual \nprogrammer designs data structures such as arrays, structures containing sub\u00adfields, lists, hashtables, \netc. which have the same information content as the abstract sets and mappings used in P, but which represent \nthis information in a com pact, and rapidly accessible, modifi\u00adable form. 14any of these design decisions \nare relatively routine, and can be seen by sampling the abstract algorithms collected in Schwartz [1] \nto depend only on informa\u00adtion derivable by the analytic methods just explained; on live/dead information; \nand on information concerning the opera\u00adtors applied to the objects generated in a SETL program to be \noptimized. (Schwartz [3] describes algorithms which develop information of this last sort.) A typical \ndevice applied in designing the data struc\u00adture of a program is to find cases in which a set s included \nwithin a set s can do without ex~licit representation of its own, perhaps because each element of s is \nissued a serial number represented by an s-based b~~~e~~o~~ti~ n-th bit of the vector signifying whether \nthe n-th element of s does or does not belong to S1. Another typical device is to find and exploit cases \nin which a map f known to have domain included in a set s can be represented either by a vector of items \nor by a collection of fields attached to the elements x of s, where esch field stores one value f(x) \n. Data structure choice motivated by such considerations is amenable to automatic treatment. Here are \na few of the principles which apply: if is to be represented by an 1 ~sandsl s based bit vector, we must \nbe sure that s is not set up when the set s has one partii cular value and used later after elements \nhave been removed from s. If sl is a top-level object which is not made member or part of any still more \ncomposite object, only this check need be made to ensure that S1 can be represented by such a bit vector. \nIf S1 is itself made a direct or indirect part of some composite object y, either as a set member or \nas a tuple component, addi\u00adtional complications arise. For representa\u00adtion of slas an s-based bit vector \nto remain desirable in this case, it is neces\u00adsary that each such y be dead at every point in the program \nP at which s is dimin\u00adished. If this is the case, we write More general relationships 1~: (7) xi-l . \n..nk p P1. ..ldj: xl can be defined in much the same way. When they hold, strong inclusion/membership \nrelationships of the form (7) logically validate a wide variety of data structure choices. Schwartz [3] \noutlines an algo\u00adrithm which finds all the y of which a given object S1 is made a direct or indi\u00adrect \npart and thus allows the validity of strong relationships (7) to be determined. e ote hat f 1 ~: s and \n1 s pres\u00adented by an s-based bit vector, then this bit vector can be inserted, in lieu of S1 , into any \ncomposite object y of which sl is to become part. If all the members or components of y are s-based, \nthen the mem\u00adber type-marking and testing which such insertion would otherwise make necessary is superfluous. \nThe optimization techniques which have been outlined will generally improve the efficiency of SETL programs \nsubstantially, and should in many cases bring them to an efficiency comparing decently with that obtainable \nby manual transcription. A com\u00adprehensive optimization system incorpora\u00adting these techniques is presently \nbeing designed at New York University, and will be implemented there. In concluding we note that the \nabove methods of analysis may be regarded as greatly coarsened variants of some of the techniques which \nhave been used to prove more general assertions concerning programs (such as their correctness). However, \nour analyzers are themselves responsible for choosing, out of a quite constricted a priori range of possibili\u00adties, \nthe propositions which they will attempt to prove. Moreoverr the rela\u00adtionship of implication with which \nthey work is easily recursive rather than merely being recursively enumerable, which is the case when \nproof of more general propositions is attempted. We observe that the techniques outlined above, as well \nas the type finding techniques described in Tenenbaum [4] , [2] all have a number of properties in common. \nBasically they use a straight\u00adforward method of transitive closure. To make any particular program property \namenable to analysis, one constructs some algebra A of symbols upon which programs P act in a manner \nhomomorphic to the detailed action of P on its data environ\u00adment during actual execution. All these algebras \nare finite enough for the action of P on A to stabilize after finitely many steps, which implies that \nthe inter\u00adaction of P with A is a matter which can be fully worked out at compile time. In implementation \nterms, such algebras A are represented by medium-to-large tables or table-representing subroutines whose \nseparate entries describe the action, on the symbolic entities of A, of each of the primitives of the \nlanguage L to be analyz\u00aded. WY such table defines some aspect of the basic knowledge concerning L which \nan analysis algorithm will have; a suitable transitive closure algorithm then distri\u00adbutes this knowledge \nglobally over the program to be analyzed. For a related remark on optimization technique, see Sintzoff \n[1]. Bibliography F. E. Allen [1] A Basis for Program optimization, Proceedings of the IFIP Congress, \n1971, North-Holland Publish\u00ading Co. , Amsterdam. [2] Interproeedura2 Data Flow .4nai!ysis, Proceedings \nof the IFIP Congress, 1974, North Holland Publish\u00ading Co. , Amsterdam. J. R. LOW [1] Automatic Coding: \nChoice of Data St~uetu~es. Ph.D. Thesis , Stanford University (1974). J. B. Morris [1] A Comparison of \nMADCAP and SEYL, Los Alamos Sci. Lab., Univer\u00adsity of California, Los Alamos, New Mexico, 1973. J. T. \nSchwartz [1] On Programming: An Interim RepoPt on the SETL Project. Installment 1. Gene~alities . Installment \n2. The SETL Language and Examples of its Use. 520 pp. , New York University, 1973. [2] Deducing Relationships \nof Inclusion and Membership in SETL Pro\u00adgrams . SETL Newsletter No. 130, New York University, 1974. [3] \nMore on Copy Optimiza\u00adtion of SETL Programs. SETL Newsletter No. 131, New York University, June 1974. \n [41 Deducing the Logica2 Structure of Objects Appearing in SETL Programs. SETL Newsletter No. 71, New \nYork University, April 1972. [51 Inter-Procedural Optimization. SETL Newsletter No. 134, New York Universityr \nJuly 1974. [6] Optimization of Very High Level Languages, to appear, Journal of Programming Languages, \nOxford/New York. M. Schaefer [11 A Mathematical Theory of Global Program Optimization. Prentice-Hall \nPublishing Co. , Englewood Cliffs, N. J., 1973. M. Sintzoff [11 Calculating Properties of Programs by \nValuations on Specific Mode Ls. Sigplan Notices, Vol. 7, No. 1, 1972. A. Tenenbaum [1] Revised and Extended \nAlgorithms for Deducing the Types of Objects Appearing in SETL P~ograms. SETL Newsletter No. 118, New \nYork Univer\u00adsity, October 1973.  [2] .4utomatie Type Analysis in a Very High Level Language. Thesis \n, New York University, October 1974. 40\n\t\t\t", "proc_id": "512976", "abstract": "SETL is a set-theoretically oriented language of very high level whose repertoire of semantic objects includes finite sets, ordered n-tuples, and sets of ordered n-tuples useable as mappings. This paper sets forth techniques for the logical analysis and optimization of SETL programs. The techniques described allow <i>relations of inclusion and membership</i> to be established, the domains and ranges of (tabulated) mappings to be estimated from above and below, and the singlevaluedness of (tabulated) mappings to be proved. Once facts of this kind have been established, automatic choice of data structures becomes possible. The methods employed are based upon, and extend, known techniques of data-flow analysis.", "authors": [{"name": "J. T. Schwartz", "author_profile_id": "81100404411", "affiliation": "Courant Institute, New York University", "person_id": "PP31040798", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/512976.512981", "year": "1975", "article_id": "512981", "conference": "POPL", "title": "Automatic data structure choice in a language of very high level", "url": "http://dl.acm.org/citation.cfm?id=512981"}