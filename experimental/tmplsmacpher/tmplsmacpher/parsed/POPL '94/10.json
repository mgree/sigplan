{"article_publication_date": "02-01-1994", "fulltext": "\n A Type-Theoretic Approach to Higher-Order Modules with Sharing* Robert Harpert Mark Lillibridge$ School \nof Computer Science Carnegie Mellon University Pittsbwgh, PA 15213-3891 Abstract The design of a module \nsystem for constructing and main\u00adtaining Ilarge programs is a difficult task that raises a number of \ntheoretical and practical issues. A fundamental issue is the management of the flow of information between \nprogram units at compile time via the notion of an interface. Expe\u00adrience has shown that fully opaque \ninterfaces are awkward to use in practice since too much information is hidden, and that fully transparent \ninterfaces lead to excessive interde\u00adpendencies, creating problems for maintenance and separate compilation. \nThe sharing specifications of Standard ML address this issue by allowing the programmer to specify equational \nrelationships between types in separate modules, but are not expressive enough to allow the programmer \ncom\u00adplete control over the propagation of type information be\u00adt ween modules. These problems are addressed \nfrom a type-theoretic view\u00ad point by considering a calculus based on Girard s system FU. The calculus \ndiffers from those considered in previous studies by relying exclusively on a new form of weak sum type \nto propagate information at compile-time, in contrast to approaches based on strong sums which rely on \nsubsti\u00adtution. The new form of sum type allows for the specifica\u00adtion of equational, as well as type \nand kind, information in interfaces. This provides complete control over the propa\u00adgation of compile-time \ninformation between program units and is sufficient to encode in a straightforward way most uses of type \nsharing specifications in Standard ML. Modules are treated as first-class citizens, and therefore the \nsys\u00adtem supports higher-order modules and some object-oriented *Thk work was sponsored by the Advanced \nResearch Projects Agency, CSTO, under the title The Fox Project: Advanced De\u00advelopment of Systems Software \n, ARPA Order No. 8313, issued by ESD/AVS under Contract No. F19628-91-C-0168. t Electro&#38; ~~1 ad&#38;e~~: \nrWh@c~ , ~mu. ~d~. ~Electronic mail address: mdl@cs . cmu. edu.  Permission to copy without fee all \nor part of this material is granted provided that the copies are not made or distributed for direct commercial \nadvantaga, the ACM copyright notica and tha titfe of the publication and its data appear, and notica \nia givan that copying ia by parrtiasion of the Association for Computing Machinery. To copy otharwiaat \nor to repubfish, raquirea a fee and/or specific permission. POPL 94-1/94, Portland Oregon, USA @ 1994 \nACM C-897914336-IY941001 ..$3.S() programming idioms; the language may be easily restricted to second-class \nmodules found in ML-like languages. 1 Introduction Modularity is an essential technique for developing \nand maintaining large software systems [46, 24, 36]. Most modern programming languages provide some form \nof module system that supports the construction of large systems from a collection of separately-defined \nprogram units [7, 8, 26, 32]. A fundamental problem is the man\u00adagement of the tension between the need \nto treat the components of a large system in relative isolation (for both conceptual and pragmatic reasons) \nand the need to combine these components into a coherent whole. In typical cases this problem is addressed \nby equipping each module with a well-defined interface that mediates all access to the module and requiring \nthat interfaces be enforced at system link time. The Standard ML (SML) module system [17, 32] is a particularly \ninteresting design that has proved to be useful in the development of large software sys\u00adtems [2, 1, \n3, 11, 13]. The main constituents of the SML module system are signatures, structures, and functors, \nwith the latter two sometimes called modules. A structure is a program unit defining a collection of \ntypes, exceptions, values, and structures (known as sub\u00adstructures of the structure). A functor may be \nthought of as a parameterized structure , a first-order function mapping structures to structures. A \nsignature is an in\u00adterface describing the constituents of a structure the types, values, except ions, \nand structures that it defines, along with their kinds, types, and interfaces. See Fig\u00adure 1 for an illustrative \nexample of the use of the SML module system; a number of sources are available for further examples and \ninformation [15, 39]. A crucial feature of the SML module system is the no\u00adtion of type sharingl which \nallows for the specification 1The closely-related notion of structur-c sharing ia not consid\u00adered in \nthis paper. signature SYMBOL = slg type syrobol val intern : string -> symbol val pname : symbol -> string \nval eq : symbol * symbol -> bool end structure Symbol : SYMBOL = struct structure HashTable : HASH.TABLE \n= . type symbol = HashTable.hash_key fun intern id = HashTable.enter (HashTable.hash id) id fun pname \nsym = HashTable.retrieve sym fun eq (s1, s2) = HashTable.same-key S1 S2 end Figurel: Example of the SML \nModule System of coherence conditions among a collection ofstructures that ensure that types defined \nin separate modules co\u00adincide. The classic example (adapted from MacQueen) is the construction of a parser \nfroma lexer and asym\u00adbol table, each of which make use of a common notion of symbol (see Figure 2). The \nparser is constructed by afunctor that takes as arguments two modules, alexer and asymbol table manager. \nThe parser composes func\u00adtionsfromthelexer andsymboltable manager; thecom\u00adposition is well-typed only \nif the two modules share a common notion of symbol. Within the body of the functor Parser the types L. \nS. symbol and T. S. symbol coincide, as specified by the type sharing specification in the parameter \nsignature. See MacQueen s seminal paper for further examples and discussion [26, 17]. 1.1 !t ransparencyand \nOpacity Module bindings in SML are transparent in the sense that the type components ofa module are fully \nvisible in the scope of the binding. For example, the structure declaration structure S = struct type \nt =int type u=t->t val f =fn x:t =>x end introduces a structure variable S with type components S.t \nand S.u and value component S.f. Within the scope of S, the type s.t is equivalent to the type int and \nthe type S.u is equivalent to the type int >int. These equivalences are not affected by the ascription \nof a signature to the binding. For example, the signature SIG defined bv the declaration signature LEXER \n= sig structure S : SYMBOL type token end signature SYMTAB = sig structure S : SYMBOL end signature \nPARSER = sig structure L : LEXER val parse : string -> Lexer. token stream end functor Parser (structure \nL: LEXER and T: SYMTAB sharing type L.S.symbol=T.S.symbol) :PARSER= struct end Figure 2: Sharing Specifications \nsignature SIG = sig type t type u val f:u end may be correctly ascribed to the structure S without \nobscuring the bindings ofs.t and S.u. Functor bindings are similarly transparent in that the type components \nof the result of any application of the functor are fully visible within the scope of the functor binding. \nFor example, consider the following functor declaration: functor F(structure X:SIG):SIG = struct type \nt =X.t * X.t type u =X.u val f =X.f end  The bindings ofthet and ucomponents ofanyappli\u00adcation of F \nare fully visible as a function of the t and u components of the parameter X. For example, within thescope \nof the declaration structure T:SIG = F(S) thetype T.tis equivalent to the type int*int and the type \nT.u is equivalent to the type int->int. It is possible only to a very limited extent in SML tospecify \nina signature the bindings of the types ina module. For example, we may augment the signature SIG with \na sharing specification to specify that t is int as follows: signature SIG = si.g type t sharing type \nt=int type u valf:u end This method cannot be extended to specify the bind\u00ading of u sharing specifications \nmay only involve type names, not general type expressions. To fully determine the type bindings in S \nrequires a transparent signature: signature FULL_SIG~ = sig type t =int type u=int -> int val f :int \n-> int end Note that this is not a legal SML signature because of the type equations. There is no way \nto express equa\u00adtions such as u = int -> int in SML signatures. The signature FULL-SIG-S is the full \nsignature of S since it completely determines the bindings of its type com\u00adponents. The importance of \ntransparent signatures only be\u00adcomes apparent when we consider functors and the closely-related abstraction \nbindings suggested by MacQueen [26, 17]. Functor parameters are opaque in the sense that the ascribed \nsignature is the sole source of type information for those parameters (this property is the basis for \nthe reduction of abstraction bindings to functor applications). Fine control over the (degree of opacity \nof a functor parameter can be achieved by admitting transparent, or, more generally, translu cent, signatures \nthat allow for the partial (possibly full) de\u00adtermination of the type components of a module. For example, \nthe translucent signature signature PARTIAL-S IG-S-1 = s ig type t type, u=t -> t valf:u end is a partially \ntransparent signature that leaves the type t unconstrained, but determines u up to the choice oft. The \nstructure S matches the signature PARTIALJ31GS-I since S. u is equal to S. t->S, t which is itself equal \nto int ->int. Conversely, the translucent signature signature PARTIAL-SIG-S-2 = sig type t =int type \nu valf:u end in signatures it is possible to specify the dependency of the functor result on the functor \nargument. For exam\u00adple, a natural signature for the functor F defined above is the following functor \nsignature which fully determines the type components of F: determines t, leaving u unconstrained. This \nsignature is essentially equivalent to the signature SIG) above.2 S mat ches this signature. Translucent \nsignatures are particularly useful in con\u00ad nection with higher-order functors [43]. Using equations \nfuns ig FULLSIGI = (structure X: SIG): slg type t= X.t*X. t type u=X. U val f :U end Another, less precise, \nsignature for F is the functor sig\u00adnature funsig PARTIAL51G1 = (structure X: SIG): sig type t type u=X \n.U val f :U end which only specifies the behavior of F on the component u, leaving its behavior on t \nunspecified. Higher-order functors [43] are particularly important in connection with separate compilation. \nA separately\u00adcompiled module may be represented by a variable whose signature is the full transparent \nsignature of the module itself [42]. By abstracting the client mod\u00adule with respect to these variables \nwe obtain a (possi\u00adbly higher-order) functor whose application models the process of linking the clients \nof the module with its ac\u00adtual implementation. The signature matching process ensures that the presumed \nsignature of the separately\u00adcompiled module is consistent with the module itself so as to guarantee type \nsafety. The full signature of the separately compiled module, is necessary to ensure that separate and \ncombined compilation yield the same re\u00adsult 1.2 Static Semantics The static semantics of SML [32] is \ndefined by a col\u00adlection of complex elaboration rules that specify the static well-formedness conditions \nfor SML programs. The main techniques employed in the semantics are the use of unique names (or generativity \n) to handle abstraction and sharing specifications, and the use of non-deterministic rules to handle \npolymorphism, shar\u00ading specifications, and signature matching. The static semantics has proved useful \nas a guide to implementa\u00adtion [28, 2, 41, 40], but is remarkably difficult to modify 2It seems plausible \nthat most uses of type sharing specifications may be accounted for in this way, provided that we neglect \nlocal specifications and re-binding of variables in specifications, both of which are of questionable \nutility. or extend (see, for example, [43]). The naive attempt to enrich signatures as sketched above \nis incompatible with the crucial principal signature property [31]. But it is not clear whether this \nfailure is a symptom of an intrin\u00adsic incoherence in the language, or is merely an artifact of the semantic \nmethod.3 In an effort to gain some insight into the complexi\u00adties of the static semantics several authors \nhave under\u00adtaken a type-theoretic analysis of SML, especially its module system [27, 33, 35, 7, 20, 19]. \nPrevious studies of the module system focused on the transparency of SML-style structures through the \nuse of (strong sum or dependent product types. These are types of the form ZZ:A..B(Z) whose elements \nare pairs (IMl, A/fz) that are accessed via projections ml(M) and mz(kf). The crucial properties of strong \nsums [29] are that if M : XLE:A.I?(Z), then Tz(lf) : 13(ml(Lf)), and that ZI ( (&#38;fl, Mz)) n &#38;fl. \nTogether, these properties ensure that type information is propagated in rough accord with the SML static \nsemantics. (See [27, 33, 20, 19] for further discussion.) Substitution-based methods are problematic \nin the presence of computational effects, unless care is taken to account for the phase distinc\u00adtion \n[20]. Moreover, strong sums fail to account for sharing specifications and the abstract nature ( gener\u00adativity \n) of structure and datat ype bindings. In this paper we extend the type-theoretic analysis of SML-like \nmodule systems by presenting a calculus with the following features: * translucent sum types, which generahze \nweak sums by providing labeled fields and equations governing type constructors. These mechanisms obviate \nthe need for substitution, and account for abstraction and common uses of SML-style sharing specifica\u00adtions. \n-A notion of subsumption that encompasses a co\u00adercive pre-order associated with record fields and a forgetful \npre-order associated with equations that represent sharing information. -Treatment of modules as first-class \nvalues. The typing rules ensure that visibility of compile-time components is suitably restricted when \nrun-time se\u00adlection is used (see also [34]). If run-time selection is not used, modules behave exactly \nas they would in a more familiar (second-class module system such as is found in SML. Our calculus improves \non previous work by providing a much greater degree of control over the propagation of 3Based on the \napproach taken here, and a related idea due to Leroy, Tofte has recently devised a way to accommodate \na form of type abbreviation in Standard MLs ignatures [44]. Kinds K ::= Q [ K*K Constructors A ::= a \n[ ILu:A.A [ . . I {DI, ..Dn} k::K.A I AA I V.b Declarations D ::= bpa::~ I bDcr::K=A I yPz:A Terms M \n::= z IXZ:A.M IMM ]M:A I {B,,..., B.} I M.y Bindings B ::= bDa=A1ybx=ikf .._ Values v .. z I kz:A. M \nI {Bvl, .... Bvn} I V.y BV ::= bDa=AlyDz=v Contexts r ::= c I r,a::K I r,a::K=A I I , mA Figure 3: Syntax \nrules (n ~ O) type information at compile time so that we can achieve the effect of SML-like sharing \nspecifications and provide direct support for abstraction.  2 Overview of the Calculus Our system is \nbased on Girard s FW [14] in much the same way that many systems are based on the second\u00adorder lambda \ncalculus (Fz). That is to say, our system can be (roughly) thought of as being obtained from FW by adding \nmore powerful constructs (translucent sums and dependent functions) and a notion of subtyping and then \nremoving the old constructs (quantification (V), weak sums (3), and non-dependent functions (+)) su\u00adperseded \nby the new ones. Subtyping interacts with the rest of the calculus via implicit subsumption. Bounded \nquantification is not supported. Like FW, our system is divided into three levels: terms, (type) constructors, \nand kinds. Kinds classify constructors, and a subset of constructors, called types, having kind Q classify \nterms. The kind level is neces\u00adsary because the constructor level contains functions on constructors. \nExample: the constructor k: :L?.cY+a has kind td+fl and when applied to type Int yields Int+Int. The \nsyntax rules for our system are given in Figure 3. The meta variable a ranges over constructor variables \nand the meta variable x ranges over term variables. The meta variable b ranges over constructor field \nnames and the meta variable y ranges over term field names. We 4 Quantification is derivable from dependent \nfunctions and translucent sums. The basic idea is to transform Acz: :K. M into kn{b b CX::K}. [c. b/a]kf \nwhere z is not free in M and M [A] into Wf {b D a= A}. Note that this implements constructor abstraction \nas a delaying operation unlike the normal SML semantics. See [16] for a discussion of the differences \nbetween these two interpreta\u00adtions of constructor abstractions and why this choice seems to be preferable. \nhave placed field names in bold in order to help empha\u00adsize that they are names, not variables. The complete \ntyping rules appear in appendix A. Our handling of dependent functions (Ax:A.M) is standard [29] except \nthat our elimination rule only al\u00adlows for the application of functions having arrow-types5 (non-dependent \nfunction types). The normal elimina\u00adtion rule for dependent functions does not have this re\u00adstriction, \nrequiring functions only to have a II-type. We make this restriction because we intend to extend this \nsystem in future work with effect-producing primitives. In the presence of effects, the unrestricted \nrule is un\u00adsound because of interactions with the first-class nature of translucent sums.6 Translucent \nsums ({Bl, . . . . Bn }), the central contri\u00adbution of the calculus, will be discussed at length in the \nnext section. Very briefly, they are n-ary labeled dependent sums whose types can optionally contain \nin\u00adformation about the contents of their constructor fields. Traditional records and weak sums (existential) \nare de\u00adgenerate forms of translucent sums. A mechanism (written &#38;f :A) for forcing a term i14 to \nbe coerced to a supertype A is provided. The subtyp\u00ading relation allows for both generalized record subtyp\u00ading \n[7, 6, 9] (fields which are not depended on by the other fields in a translucent sum may be dropped) \nand for the forgetting of information about the contents of constructor fields. There are two basic forms \nof constructor definitions. A constructor definition is opaque if within the scope of the definition \nthere is no information available about the identity of the constructor variable being defined. By contrast, \na transparent constructor definition makes available the identity of the constructor variable that is \nbeing defined. Contexts in our system can contain both opaque (a::K) and transparent (a::K=A) definitions. \nThe ef\u00ad fect of transparency is implemented by a typing rule (ABBREV ) for the constructor equality relation \njudge\u00ad ment that establishes that a = A when a: :K=A is in the context. (This is similar to mechanisms \nused in AU- TOMATH and LEGO [12, 45, 25].) Our calculus is intended to be interpreted using a call\u00ad \nby-value semantics. The typing system is not sound for call-by-name in the presence of effects.7 We re\u00ad \nstrict terms in constructors to values in order to avoid the problem of trying to give a meaning to a \nconstruc\u00ad tor cent aining a side-effecting terms In our system, 5The arrow-type A+A can be regarded as \nan abbreviation for fIEA.A where a is not free in A . Abbreviated example: (((kc. z.Y)lf).2) (((~z. z.Y)~).1) \nwhere A9 is the example in section 4.6. 7To see this consider the outermost g?-redex of ( Az. (r. y.2) \n(z. Y.1)) &#38;f where A4 is the example in section 4.6. 8 It is not clear that allowing general terms \nin constructors values (V) are considered to be term variables, term A-expressions, translucent sums \ncontaining only values and constructors, and selections of term fields from val\u00adues. We allow V.y to \nbe a value in order to allow paths like x. y. y to be values while still keeping the set of val\u00adues closed \nunder the substitution of a value for a term variable. 3 Translucent Sums A translucent sum has the \nform of a possibly empty sequence of bindangs written between curly braces ({ B,,..., B.}). The corresponding \ntranslucent sum type is similar except that declarations are used instead of bindings ({ D1, . . . ,D~}). \nTranslucent sums differ from traditional records in a number of ways. In addition to normal term fields, \nthey can contain constructor fields. The type or content of later fields in a translucent sum can depend \non the content of earlier fields. As an example, consider the following translucent sum, call it F , \nthat packages up a type with a value of that type:g {bb a=Int, y b z=3} : {bb cr::~, yb z:a} Binding \nr to P would give r.b :: Q and r.y : r.b.10 The scope of variables bound in bindings and decla\u00adrations \nis all the following bindings/declarations in that translucent sum (type). For example, the scope of \nx in the following translucent sum includes &#38;f and A but not J4 orA: {bp a=A, y b z=kf, y B z =M \n, b b a =A } Scoping for the other constructs is as normal. We re\u00ad gard terms, constructors, etc., that \ndiffer only by a\u00ad conversion of variables as equivalent. Note that field names cannot be a-converted, \nChang\u00ad ing a field name in a translucent sum term/type results in a different term/type because the set \nof legal field names which can be selected changes. Failure to distin\u00ad guish between field names which \ncannot be a-converted and the internal names for fields which must be able to a-convert in order to permit \nsubstitution to work, leads to problems. 11 For example, the equivalent of the would be that useful anyway \nsince the substitution of general terms for term variables would be prohibited in a call-by-value 8etting \nin any case. 9 we suggest pronouncing D ~ as ! as has type , and : : as has kind . 10 Note the distinction \nbetween r and P here: r is a te~ vari\u00adable (and hence a value) while P is a term met a-variable denot\u00ading \na non-value. This distinction is important because the typing rules treat values specially. 11TO avoid \nverbosity, a real prOW amming language based on ours yst em would probably provide that by defanlt only \none name need be given per field, to be used as both the field name and the internal name. following \ncannot be written straightforwardly in SML: 12 {bb a=Int, y D z={bp a =Bool, y D x =k:a . 3}} : {b Da::fi, \ny~z:{bpa ::fl, /Dz :cr +a}} Because SML does not distinguish the two kinds of names, it is problematic \nto express that the type of the y field depends on both the outer and inner b fields. The field names \nof any given translucent sum (type) are required to be distinct. Translucent sum types that differ only \nin that their declarations have been reordered without violating any dependence are considered equiv\u00adalent. \nFor example, the following first two types are equivalent but both are different from the third type: \nIt may help to think of translucent sum types as be\u00ading directed acyclic graphs (DAGs) where the nodes \nare declarations and the edges are dependencies by one dec\u00adlaration on a variable declared in another \ndeclaration. It is possible to include information in a translucent sum type on the contents of the constructor \nfields of its instances. This ability can be used to give a more expressive type to P: {b~a=Int, yb z=3} \n: {bpa::fl=Int, yDz:a} If it can be shown that r has this type, then it can be inferred that r.b = Int. \nThis can not be inferred if it can only be shown that r has the less expressive type. The use of nested \ntranslucent sums and constructor field component information can give rise to more complex dependencies \nas the following example illustrates: {y P z={b~ a=Int}, y D x =3, bp a=z.b} : {y~z:{bpa::~}, y D z :x.b, \nb> a:: f2=z.b} 3.1 Introduction and elimination rules The introduction rule for translucent sums is \nas follows: 1-17 valid Vi G[1..n]. r, Dl, .... D._l t-B, :D, (TSUM) rt-{~l,. ... Bn}:{DI, . . ..Dn} (The \noverline function (~) merely strips off the field name.) Note that each of the bindings is being type \nchecked under a context which takes account of the ef\u00adfect of all of the previous bindings. Constructor \nbind\u00adings result in transparent definitions, both when type 12 It is ~o~~ible to write thk in SML by \nusing a combination of 1 ocal specifications and type sharing in the signature. Thanks to Mads Tofte \nfor pointing this out. Unfortunately, however, some SML implementations ( e.g., SML/NJ) do not implement \nlocal specifications in signatwes properly so this is not very helpful in practice. checking later bindings \nand in the resulting type. Thus, the introduction rule gives P the more expressive type. The less-expressive \ntype is obtained by the use of the subsumption rule afterwards. There are two elimination forms with \ncorresponding rules for translucent sums, one for constructor fields and one for term fields: I \\V:{b \nDa::K} (C-EXT-0) rFv.b::K ri-&#38;f:{y Dz:A} (EXT-V) rFM.y:A In order to apply these rules to translucent \nsums with multiple fields, it is first necessary to use the subsump\u00adtion rule to drop the fields that \nare not being selected. The constructor field case may also require that type information about the field \nto be selected be dropped. Unlike traditional records, with translucent sums it is not always possible \nto drop all the other fields because the field we wish to select may depend in an essential way on them. \nThus, the fact that M has a translucent sum type with a y field is not in itself sufficient to en\u00adsure \nthat M.y is well-typed. 13 It is always possible to drop fields from the type of V because of the VALUE \nrules which we will discuss in section 3.3. 3.2 Translucency When z:A appears in the context where A \nis a translu\u00adcent sum type which cent ains information about the contents of the constructor fields of \nits instances, it gives rise to equations via the following rule: r t-V : {b~a::K=A} (ABBREV) rt-V.b=A::K \n Thus it is possible to infer that r.b = Int when it can be shown that r has the type ({b D a::&#38;=Int, \ny D z:cY}) but not when it can only be shown to have the type ({b ba::~, YD$X~}). This rule also gives \nrise to equations such as {b b a=Int, b D a =Bool}.b == Bool. These equations allow any valid constructor \nV.b to be reduced to a constructor which cent ains only values of the form x.y~ . ~. .Y~ (n > 0). Because \nof this, it is not neces\u00adsary in our system to consider the equality of arbitrary values (and hence terms) \nat type-checking time. When the equality rules compare the parts of a con\u00adstructor that are in the scope \nof a variable binding, they do so with the declaration associated with that vari\u00adable in the context. \nFor example, the equality rule for 3 For example, ({b D a=Int, y b x=3} : {bp cK:f2, y D z:cr}).y is \nnot well-typed. If-types below compares A\\ and Aj with Z:A1 in the context: I I-AI=A2::0 This allows \nuse of the ABBREV rule to obtain equa\u00adtions such as the following: lh:{b D a:: O= Int}. z.b = IIz:{b \nD a:: f2=Int}. Int {b B a:: f2=Int, y D z:a} = {b D a:: fldnt, y D z:Int} A similar effect occurs while \ntyping terms, For exam\u00adple, in the following, we know that ~ .b = Int while type checking ill: {y D z:{b> \na:: f2=Int}, y D z :?vf} Because of the ability to substitute away transparently bound names using the \nequality rules, no dependency on a transparently bound name is ever truly essential. This allows many \nmore field selections and function ap\u00adplications to type check than would otherwise be the case. When \ntranslucent sums are given fully opaque types, they act like weak sums which can be used to create abstract \ndata types (ADTs) [35]. Because we have de\u00adpendent functions and a form of dependent pairs (a pair of \nterms where the type of the second term depends on the first component of the pair), our elimination \nform for weak sums is more powerful than usual [35, 7, 10]. Consider the following example in SML-like \nnotation, where weak is used to construct a weak sum: let structure S = struct structure Stack = weak \ntype T = (int ref) list val makeStack: ( )->T = . . . val push: (int, T)->() = . . . ... end val my Stack \n= Stack .makeStacko end in S. Stack .push(l, S.myStack) end This example is well-typed in our system \nbecause we can determine that S. my Stack has type S. St ack. T which is the argument type of the function \nS. Stack. push. Note that there is no way to type this example using the open elimination form for weak \nsums because there is no scope containing both the initialization of my Stack and its use that is also \ninside the scope of Stack. 3.3 The VALUE rules Suppose the typing context contains the following dec\u00adlaration: \nr:{bp a::~, YDz:cY} What types can we give to the expression r under this context? Because we have a \nname, r, for the translucent sum expression we are trying to type, we have a name for the contents of \nits b field, namely r,b. This sug\u00adgests that we can giver the type {b D a:: fkT.b, y D x:T.b} which is \na subtype of the context type for r. This technique of giving a more expressive type to translucent sums \nwhen we have a name for their con\u00adstructor components can be generalized to work on ar\u00adbitrary translucent \nsum values. The name in this case is simply V.b where V is the value in question. Attempt\u00ading to extend \nthe technique to general terms requires dropping the restriction that only values may appear in constructors \nand results in unsoundness in the presence of effects. 14 The following two typing rules implement this \ntechnique: I k V:{ bDa::K, Dl,. ... D~} (VALUE-O) r + V : {b bm:h7=V.b, Dl,..., D~} rFv.y:A rEV:{y Dz:A, \n~1, ...,&#38;} (VALUE-V) I k V:{ybz:A , Dl,..., D~} (The VALUE-V rule is used in cases of nested translu\u00adcent \nsums to apply the technique recursively.) By alternately applying the VALUE rules to convert an opaque \nbinding into a transparent one and the sub\u00adsumption rule to propagate that definition (and hence removing \nany dependencies on that binding), we can give any translucent sum value a fully transparent type (there \nare no constructor components for which infor\u00admation is lacking) with no dependencies between the fields \n(or subfields). Because of this, field selection on values as well as applications of functions to values \ndo not run into problems due to the inability to remove de\u00adpendencies. Without this kind of usage of \nthe VALUE rules, expressions such as r. y would not type check. The more expressive type given by the \nVALUE rules to translucent sum values is also critical to the propaga\u00adtion of typing information. For \nexample, ifs is bound to the result of the expression r, it will be given the more expressive type, allowing \nthe fact that s.b = r.b to be inferred.  4 Selected Examples 4.1 Simple structures Typical SML structures \ncan be translated straightfor\u00adwardly into our system, with the only complication being the treatment \nof polymorphism (as discussed 14 This ~o~d allow field selection to always succeed because it would permit \nall dependencies to be removed. Unsoundness example: (kf.y.2) (kf.y.1) where A4 is the example in section \n4.6. in [16].) Consider the following structure S considered in the introduction: structure S = struct \ntype t =int typeu=t->t val f =fn x:t =>x end This translates as: S = {t D t=Int, uDu=t-+t, f Df=~x:t. \nx) The translations of the signatures considered earlier (only SIG here is actually a valid SML signature) \nare: FULL.SIG.S = {t D t::$2=Int, u D u:: f2=Int+Int, f D f: Int+Int} PARTIAL-SIG-S-1 = {t D t::~, Ub \nu::~=t+t, f P f:u} PARTIAL-SIG-S-2 = {t D t:: f2=Int, u D u::~, f D f :u} SIG = {t bt::~, UDU::Q, f Df:U} \n The subtyping rules for our system establish that FULL-SIG-S < PARTIAL_sIGJS.i < SIG and FULL-SIG-S \n< PARTIALJ31G_S_2 < SIG. The signatures PARTIAL51G-S-I and PARTIAL-SIG-S-.2 are incompara\u00adble. The signature \ngiven to S determines which equations on S. t and S. u can be deduced. By default our system, like SML, \nwill give S its full signature, FULL-SIG-S. This means that we will be able to deduce that S.t = Int \nand S.u = Int--+Int. If we insert a coercion to one of the other signatures before the binding to S, \nfewer equations will be deducable in our system. In SML, by contrast, user-specified coercions never \nresult in the loss of typing information. They can, however, result in the loss of fields. Thus, in order \nto translate a coercion from SML into our system, we need to enrich the target signature with all the \navailable typing information.  4.2 Abstraction SML/NJ [2] supports an extension to SML, called ab\u00adstraction, \nwhich is an alternative to the normal struc\u00adture binding mechanism. If the keyword abstraction is used \ninstead of the keyword structure when bind\u00ading a structure, all information about the constructor components \nof that structure is forgotten. Had S in the previous example been bound with an abstraction binding \ninstead of the structure one we used, it would have been as if we had given S in our system the signa\u00adture \nSIG. That is to say, S. t and S. u would have been bound opaquely. Note that it is not possible in SML/NJ \nto give S a partial signature using this mechanism. Only the fully transparent (via structure) and fully \nopaque (via abstraction) alternatives are available. Abstraction bindings can be translated into our \nsys\u00adtem by inserting a forced coercion just before the bind\u00ading to the appropriate opaque type. For example, \ncon\u00adsider the following implementation of an abstract data type (ADT): abstraction Stack = struct type \nT = (int ref) list val push: (T, int)->() = . . . val pop: T->int = . . . val isEmpty: T->bool = . . \n. end This translates to: Stack = ({ T b T=list(ref Int), push D push= (.. .):(T, Int)+(), pop D pop=(. \n. .): T+Int, isEmpty D isEmpty=(. . .): T+BooI } ):{ TDT::f2, push D push: (T, Int)+.(), pop D pop: T+Int, \nisEmpty D isEmpty:T--+Bool } Note that because the type information about the iden\u00adtity of the T field \nis lost in the coercion, the rest of the program will be unable to break the abstraction. sML provides \nan abstraction mechanism, abstype, at the core language level. Because translucent sums are first-class \nin our system, we can achieve the effect of SML S ab\u00adstype using the abstraction binding mechanism. 4.3 \nSub-structures Sub-structures are also easily translated. For example, suppose we wanted to use the Stack \nstructure in a bigger structure as follows: structure Big = struct structure ourStack = Stack type T \n= ourStack. T ... end This translates into: Big = {ourStack p ourStack=Stack, T P T=ourStack.T, . . \n.} Big will be given the following full signature: {ourstackb ourStack:{ T D T:: Q= Stack.T, push b push: \n(T, Int)_(), pop b pop:T+Int, isEmpt y D isEmpt y:T+Bool }, T b T:: fl=ourStack.T, . . .} Note that \nwe have that Big.ourStack.T = Big.T = Stack.T. 4.4 Functors signature E = sig Functors translate into \ndependent functions in the ex\u00adpected way. Consider the following example from the intro duction: functor \nF(structure X: SIG) :SIG = struct type t =X.t * X.t type u=X.u Val f = X.f end This translates into: \nF = Ax:sIG. ( {t D t=x.t * x.t, UbU=X.U, f D f=x.f} : {t D t::~=x.t * x.t, uDu::~=x.u, f D f:U}) (The \ncoercion on the result type of the functor is an abbreviation for a coercion on the functor body.) Note \nthe enriched signature we have to give instead of SIG in order to make the coercion have the same effect \nas it does in SML. llanslating the functor signatures we considered for F gives: FULL-SIG-F = nx:sIG. \n{t ~ t:: fkx.t * x.t, UP U::!kx.U, f Df:U} PARTIAIdIG.F = nX:SIG. {t D t::~, U P u: f)=x.u, f D f :u} \nSIG.F = lIx:sIG. sIG Here, FIYLL.SIGI < PARTIAL_SIG1 < SIG1. Suppose T was bound to the result of applying \nF to S. Before the APP rule can be applied to determine T s type, the subsumption rule must be used to \nco\u00aderce F s type (FULL_SIG1) to an arrow type. one way this could be done is shown in Figure 4. First, \nF s ar\u00adgument type is coerced to a subtype (remember that FULL_SIG_S < SIG) using the fact that subtyping \nof function types is contra-variant. Next, the equality rules are used to remove the dependencies on \nX by the result type, resulting in an arrow type. The result is that T gets assigned the following type: \n{t D t:: fkInt * Int, u D u:: C2=Int-+Int, f D f :u} If F had instead had the type PARTIAL51GI, T would \nhave been assigned the type: {t D t::~, u D u:: f2=Int+Int, f D f :u}  4..5 Sharing specifications \nThe basic idea in translating sharing specifications is that for each set of names that are asserted \nto be equal, pick one with maximal scope as representative of the equivalence class and set the others \nequal to it using transparent definitions. For example, the following SML signature: type t type u type \nv sharing type t = u and type v = u end translates into: H = {t D t::fl, UDU::~=t, VD V::~=t) A more \ninteresting case is provided by the argument signature of the Parser functor in MacQueen s example from \nthe introduction: s ig structure L: LEXER structure T: SY14TAB sharing type L. S. symbol=T. S. symbol \nend This translates into: {L D L: LEXER, T D T:{S D S:{syxubol D symbol::O=L.S.symbol, . ..}!...}} The \nomitted parts are the usual translation of the rest of SYMTAB and SYMBOL. This translation method also \nworks on sharing between constructors in the argument and result of a functor. 4.6 First-class modules \nSo long as we restrict ourselves to simple module op\u00aderations like binding, functor application of a \nnamed functor to a named or fully transparent module, and se\u00adlection from a named module, we never lose \nany typing information. In fact, the only module operation avail\u00adable in SML that causes a loss of information \nwhen used in our system is coercing a module to a user-specified type. This is not surprising, however, \nsince the purpose of coercions is controlled information loss. Due to the fact that modules are first-class \nin our system, it is possible to write module expressions which force the loss of typing information \nin order to preserve soundness. For example, consider the following: 15 if flipo then {b D a=Int, Y D \nz=(3, Succ)} else {b D a= Bool, y b z=(true, not)} While both parts of the if can be given fully transpar\u00adent \ntypes, these types are not equal. In order to make the if type check, we must give them equal types. \nThe only way to do this is to use the subsumption rule to coerce both of their types to {b D CY::Q, y \nD z:(a, o-a)}. 15 For the -,0-&#38;e.s .xa,mpkS, f 1 ip iS a f~ction fi&#38; a\u00adternates ret-rig t rue \nand f alse. It is easily implemented using a global variable. FULL.SIG-F = nx:sIG. {t P t:: fkx.t * x.t, \nubu::fkx.u, f D f:u} < ~x:FULL-SI&#38;S. {t D t::kx.t * x.t, UDU::kx.U, f P f:U} = lIX:{t D t:: f2=Int, \nUD u:: f2=Int-+Int, f D f: Int+Int}. {t b t:: Gl=X.t * X.t, ubu::~=X.u, f D f:u} = HX:{t b t::~=Int, \nu D u:: fl=Int&#38;+Int, f D f :lnt+Int}. {t D t::~=Int * Int, u D u:: L?= Int-+Int, f P f :u} = FULL_SIG_S-+{t \nD t:: fl=Int * Int, u D u:: Q= Int+Int, f D f :u} Figure 4: Steps in coercing F s type to an arrow type \nThe system described in [34] displays similar behav\u00adior, namely a forced loss of typing information when \nusing modules in conditionals and other primitives. In that system, types are divided into two universes, \nU1, the universe of normal types like Int and Bool--+Int, and U2, the universe of module types. The loss \nin this system is caused by the need to apply an implicit co\u00adercion from a strong sum (which belongs \nto U2) to a weak sum (which belongs to WI) because primitives op\u00aderate only on terms with types in U1. \nThis coercion causes a total loss of typing information. Our system is more flexible than this because \nit only loses just enough information to ensure soundness. The possible uses for first-class modules \nhave not been well explored. One known use discussed in [35] is to select at runtime between two or more \nADTs which im\u00adplement the same abstraction using different algorithms based on expected usage conditions. \nFor example, we could use one particular hash table implementation for small tables and another for large \nones.   Related Work An early influential attempt to give a comprehensive type-theoretic analysis \nof modularity and abstraction was undertaken by BurstalI and Lampson with the ex\u00adperimental language \nPebble [5]. Their work stresses the role of dependent types and the mechanisms required to support abstraction, \nbut does not address the problem of controlling the degree of abstraction. In particu\u00adlar, Pebble supports \ntype and value bindings as primi\u00adtive notions, but with an opaque typing discipline, in contrast to our \ncalculus. Cardelli s language Quest [7] has exerted a strong influence on the present work. Our approach \nshares with Quest the emphasis on type-theoretic methods, and is similarly based on Girard s FW enriched \nwith a no\u00adtion of subsumption (though we depart from Cardelli s approach by omitting bounded quantification). \nQuest does not provide an adequate treatment of modularity; our work can be seen as providing the type-theoretic \nba\u00adsis for an extension of Quest with an expressive module system. Mitchell, et al. [34] consider an \nextension of the SML module system with first-class modules as a means of supporting certain object-oriented \nprogramming id\u00adioms. Their paper is primarily concerned with illustrat\u00ading an interesting language design \nrather than with the type-theoretic underpinnings of such a language, though a brief sketch is provided. \nA comparison with their work is given in Section 4.6. The type-theoretic analysis of the SML moduIes \nsys\u00adtem was initiated by MacQueen [27], and further devel\u00adoped by Harper and Mitchell [33, 20, 19]. This \nwork is summarized and compared with the present work in the introduction. Our language bears some relationship \nto Russell [4] and Poly [30], but a detailed comparison seems diffi\u00adcult in the absence of a type-theoretic \nanalysis of these languages (see [21] for an early attempt). In an effort to address the problem of separate \ncompi\u00adlation, Leroy has independently developed a variant of the SML modules system based on the notion \nof a man\u00adifest type which is similar in spirit to our translucent sum types. See Leroy s paper in this \nvolume [23] for a description of his system and some comments on its relationship to ours. 6 Conclusions \nThe main contribution of this work is the design of a calculus of modularity with the following features: \n-Fine control over the degree of abstraction through the notion of a translucent sum type. -A treatment \nof modules as first-class entities with\u00adout sacrificing the control over type abstraction af\u00adforded by \na second-class module system. -Support for separate compilation in a form that ensures the complete equivalence \nbetween separate and integrated compilation of a large system. The following are some important directions \nfor fu\u00adture research: -Establish the soundness of the type system by prov-[8] ing preservation of typing \nunder a call-by-value op\u00aderational semantics. -Investigate the eficiency of type checking and de\u00ad [9] \nvelop practical algorithms that may be used in an implementation. We show in Appendix B that the subtyping \nproblem for our system, and hence the [10] type checking problem, is undecidable. There is reason to \nbelieve, however, that this will not be a problem in practice. [11] -Design an elaborator to translate \nan SML-like syn\u00adtax into the calculus, including a systematic treat\u00ad ment of the reduction of symmetric \nsharing spec\u00adifications to asymmetric definitions in signatures. [12] -Develop an treatment of structure \nsharing that ac\u00ad counts for structure generativity and interacts well with computational effects. [13] \n Acknowledgements We are grateful to Andrew Appel, Luca Cardelli, Olivier Danvy, John Greiner, Nick \nHaines, Mark Leone, Xavier [14] Leroy, Brian Milnes, John Mitchell, and Mads Tofte for their comments \nand suggest ions. [15] References [1] Andrew W. Appel. Compiling with Continuations. Cambridge University \nPress, 1992. [16] [2] Andrew W. Appel and David B. MacQueen. Standard ML of New Jersey. In J. Maluszynski \nand M. Wirsing, editors, Third Int 1 Symp. on Prog. Lang. Implementa\u00ad tion and Logic Programming, pages \n1 13, New York, [17] August 1991. Springer-Verlag. [3] Edoardo Biagioni, Nicholas Haines, Robert Harper, \nPe\u00ad ter Lee, Brian G. Milnes, and Eliot B. Moss. ML signa\u00ad tures for a protocol stack. Fox Memorandum \nCMU-CS\u00ad [18] 93 170, School of Computer Science, Carnegie Mellon University, Pittsburgh, PA, July 1993. \n[4] Hans-Jiirgen Bohm, Alan Demers, and James Donahue. An informal description of Russell. Technical \nReport [19] 80 430, Computer Science Department, Cornell Uni\u00ad versity, Ithaca, New York, 1980. [5] Rod \nBurstall and Butler Lampson. A kernel language for abstract data types and modules. In Kahn et al. [20] \n[22], pages 1-50. [6] Luca Cardelli. A semantics of multiple inherit ante. In Kahn et al. [22], pages \n51-67. [7] Luca Cardelli. Typeful programming. Technical Re\u00ad [21] port 45, DEC SRC, 1989. Luca Cardelli, \nJames Donahue, Lucille Glassman, Mick Jordan, Bill Kalsow, and Greg Nelson. Modula-3 report (revised). \nTechnical Report 52, DEC Systems Research Center, Palo Alto, CA, November 1989. Luca Cardelli and Peter \nWegner. On understanding types, data abstraction, and polymorphism. Computing Surveys, 18(4), December \n1986. Luca Cardelli and Leroy Xavier. Abstract types and the dot notation. Technical Report 56, DEC SRC, \nPalo Alto, CA, March 1990. Eric Cooper, Robert Harper, and Peter Lee. The Fox project: Advanced development \nof systems software. Technical Report CMU-CS 91-178, School of Com\u00adputer Science, Carnegie Mellon University, \nPittsburgh, PA, August 1991. Nicolas G. de Bruijn. A survey of the project AU-TOMATH. In J. P. Seldin \nand J. R. Hindley, edi\u00adtors, To H. B. Curry: E.ways in Combinatory Logic, Lambda Calculus and Formalism, \npages 589-606. Aca\u00addemic Press, 1980. Emden Gansner and John Reppy. eXene. In Robert Harper, editor, \nThird International Workshop on Stan\u00addard ML, Pittsburgh, PA, September 1991. School of Computer Science, \nCarnegie Mellon University. Jean-Yves Girard. Interpretation Fonctionnelle et Elimination des CoupuRs \nclans 1 Arithvn6tique d Ordre Sup&#38;ieum. PhD thesis, Universit6 Paris VII, 1972. Robert Harper. Introduction \nto Standard ML. Techni\u00adcal Report ECS LFCS 86-14, Laboratory for the Foun\u00addations of Computer Science, \nEdinburgh University, September 1986. Robert Harper and Mark Lillibridge. Explicit polymor\u00adphism and \nCPS conversion. In Twentieth ACM Sympo\u00adsium on Principles of Programming Languages, pages 206-219, Charleston, \nSC, January 1993. ACM, ACM. Robert Harper, David MacQueen, and Robin Milner. Standard ML. TechnicaJ Report \nECS-LFCS-86-2, Lab\u00adoratory for the Foundations of Computer Science, Ed\u00adinburgh University, March 1986. \nRobert Harper, David MacQueen, and Robin Milner. Standard ML. Technical Report ECS-LFCS-86-2, Lab\u00adoratory \nfor the Foundations of Computer Science, Ed\u00adinburgh University, March 1986. Robert Harper and John C. \nMitchell. On the type structure of Standard ML. ACM Transactions on Programming Languages and Systems, \n15(2):21 1-252, April 1993. (See also [33].). Robert Harper, John C. Mitchell, and Eugenio Moggi. Higher-order \nmodules and the phase distinction. In Sev\u00adenteenth ACM Symposium on Principles of Program\u00adming Lcmguages, \nSan Francisco, CA, January 1990. James G. Hook. Understanding russell: A first attempt. In Kahn et al. \n[22], pages 69-85. [22] Gilles Kahn, David MacQueen, and Gordon Plotkin, editors. Semantics of Data \nTypes, volume 173 of Lec\u00adture Notes in Computer Science. Springer-Verlag, June 1984. [23] Xavier Leroy. \nManifest types, modules, and separate compilation. In Proceedings of the Twe nt y-first Annual ACM Symposium \non Principles of Programming Lan\u00adguages, Portland. ACM, January 1994. [24] Barbara Liskov and John Guttag. \nAbstraction and Spec\u00adification in Program Development. MIT Press, 1986. [25] Zhaolui Luo, Robert Pollack, \nand Paul Taylor. How to use Lego: A preliminary user s manual. Technical Report LFCS-TN-27, Laboratory \nfor the Foundations of Computer Science, Edinburgh University, October 1989. [26] David MacQueen. Modules \nfor Standard ML. In 1984 ACM Conference on LISP and Functional Program\u00admmg, pages 198 207, 1984. Revised \nversion appears in [18]. [27] David MacQueen. Using dependent types to express modular structure. In \nThirteenth ACM Symposium on Principles of Programming Languages, 1986. [28] David B. MacQueen. An implementation \nof Standard ML modules. In Proceedings of the 1988A CM Confer\u00adence on LISP and Functional Programming, \nSnowbird, Utah, pages 212-223. ACM Press, July 1988. [29] Per Martin-Lof. Constructive mathematics and \ncom\u00adputer programming. In Sizth International Congress for Logic, Methodology, and Philosophy of Science, \npages 153 175. North-Holland, 1982. [30] David C. J. Matthews. POLY report. Technical Re\u00adport 28, Computer \nLaboratory, University of Cam\u00adbridge, 1982. [31] Robin Milner and Mads Tofte. Commentary on Stan\u00addard \nML. MIT Press, 1991. [32] Robin Milner, Mads Tofte, and Robert Harper. The Definition of Standard ML. \nMIT Press, 1990. [33] John Mitchell and Robert Harper. The essence of ML. In Fifleenth ACM Symposium \non Principles of Pro\u00adgramrnmg Languages, San Diego, California, January 1988. [34] John Mitchell, Sigurd \nMeldal, and Neel Madhav. An extension of Standard ML modules with subtyping and inherit ante. In Eighteenth \nACM Sympos turn on Princi\u00adples of Programming Languages, January 1991. [35] John C. Mitchell and Gordon \nPlotkin. Abstract types have existential type. ACM Transactions on Program\u00adming Languages and Systems, \n10(3):470 502, 1988. [36] Greg Nelson, editor. Systems Programming with Modula-3. Prentice-Hall, Englewood \nCliffs, NJ, 1991. [37] Benjamin Pierce. Bounded quantification is undecid\u00adable. In Proceedings of the \nNineteenth Annual ACM Symposium on Principles of Programming Languages, Albuquerque. ACM, January 1992. \n[38] Benjamin C. Pierce. Programming with Intersec\u00adtion Types and Bound&#38; Polymorphism. PhD thesis, \nSchool of Computer Science, Carnegie Mellon Univer\u00adsity, Pittsburgh, PA, December 1991. [39] Chris Reade. \nElements of Functional Programming. In\u00adternational Computer Science Series. Addison Wesley, 1989. [40] \nNick Rothwell. Functional compilation from the Stan\u00addard ML core language to lambda calculus. Technical \nReport ECS LFCS-92-235, Laboratory for the Foun\u00addations of Computer Science, Edinburgh University, Edinburgh, \nScotland, September 1992. [41] Nick Rothwell. Miscellaneous design issues in the ML kit. Technical Report \nECS LFCS 92 237, Laboratory for the Foundations of Computer Science, Edinburgh University, Edinburgh, \nScotland, September 1992. [42] Zhong Shao and Andrew Appel. Smartest recompi\u00adlation. In Twentieth ACM \nSymposium on Principles of Programming Languages, pages 439 450, Charleston, SC, January 1993. [43] Mads \nTofte, Principal signatures for higher-order pro\u00adgram modules. In Nineteenth ACM Symposium on Principles \nof Programming Languages, pages 189-199, January 1992. [44] Mads Tofte. Type abbreviations in signatures. \nUnpub\u00adlished manuscript, August 1993. [45] Diedrik T. van DaaJen. The Language Theory of AU-TOMA TH. \nPhD thesis, Technical University of Eind\u00adhoven, Eindhoven, Netherlands, 1980. [46] Niklaus Wirth. Programming \nin Modula-2. Texts and Monographs in Computer Science. Springer-Verlag, 1983. A The Typing Rules Definition \nA.1 (Judgments) 1-I valid valid context rl-A::K valid constructor rl-A=A ::K equal constructors I k D=D \nequal declarations r}A<A subtype relation rkD<D subfield relation 17t-M:A well-t ypsd term I +B:D wel!-typed \nbinding Definition A.2 (The field name stripping function) bbcr::K = CY::K bb ~::K=A = CY::K=A ybx:A \n= x:A Definition A.3 (Context Formation Rules) k -valid (INITIAL-T) 1-I valid a # dom(r) (DEF-0) 1-r, \nCY::K valid F r, Q: X-valid I I-A::K  (DEF-T) 1-r, a::K=A valid rt-A::fl ~ fz dom(r) (DEF-V) E r, z:A \nvalid Definition A.4 (Constructor Formation Rules) t-r valid a::K Gr (C-VAR-0) rka::h F I valid a::K=A \nE r (C-VAR-T) rl-a::K r 1-v: {b>a::K} (C-EXT-0) r t-V.b ::K r,x:A t-A ::$2 (C-DFUN) 1? 1-IIz:A. A :: \nQ 1-r valid (C-UNIT) rb{}::~ r,~k{~l,..., ~n}::n (C-TSUM) rF{D, Dl,.. ., Dn}::C2 I , a::K + A:: K (C-LAM) \nJ7 + kY::K. A :: K+-K r t-Al :: K,*K rl-A2::K2 (C-APP) I I-A1A2::K Definition A.5 (Constructor Equality \nRules) rJ-A::K (E-REFL) I 1-A=A::h I EA =A::K (E-SYM) rkA=A ::K rl-A=A ::K rl-A =A ::K (E-TRAN) I 1-A=A \n::K r+Al=Az::Q r,z:Al 1-A; = A; :: Q (E-DFUN) r t-IIz:A1. A; = IIz:Az. A; :: Q I 1-D=D r,~+{Dl,.. ., \nDn}={Dj, D~}, D~} ::Q I F{D, D1, . . .. Dn}={D . Dj,. ... D~}::Q (E-TSUM) 17,a::K +A = A ::K (E-LAM) \nr k k::K. A = kY::K. A ;: K+-K 171-Al = A! :: K+K (E-APP) I 1-AIAz=Aj Aj::K r,a::K 1-A :: K I FA ::K \n (E-BETA) r + (A@::K. A) A = [A /a]A:: K I , a:: Kt-Aa :: K r F A;: K+-K (E-ETA) r 1-Aa::K. Acr = A \n:: K+-K r 1-V : {b>a::K=A} (ABBREV) I FV.b=A::h 1-1? valid a::K=A c r (ABBREV ) I Fa=A::K Definition \nA.6 (Declaration Equality Rules) i-r,a::K valid (EQ-0) rkbba::K=b Da::K r+ A= A ::K + I , Q::K=A valid \n(EQ-T) I F b D a::h7=A = bb cr::h =A rt-A=A ::Q I I , z:A valid (EQ-V) r+y Px:A=ybz:A Definition A.7 \n(Subtyping Rules) I 1-A=A ::fl (S-EQ) rt-A <A I t-A <A rl-A <A (S-TRAN) I I-A <A I I-D <D rl-{D , D;,..., \nD~}::Q r,~l-{D1,..., Dn}<{Dj, D~}, D~} I E{D, DI,..., Dn} < {D , D[,..., D~} (S-TSUM) I F{D1,..., Dn, \nD}::Q (S-THIN) rl-{Dl,..., Dn, D} < {Dl,..., D~} Definition A.8 (Subfielding Rules) (S-SAME) I KA <A \ni-r,x:A valid (S-VALUE) I kyhx:A<y Dx:A h r, a::K=A valid (S-FORGET) r t-bD CY::K=A < bb a::K Definition \nA.9 (Term Formation Rules) information about the type components of translucent rPx:A F,x:At-M:A r E \nJz:A. M : IIZ:A. A rE Ml ; A1+A2 rt-M2:Al 17FM1MZ:AZ I-r Valid Vt c [1.. n]. I , T,. ... D1-1 t-B, : \nD, rt-{B1,..., B~}:{D], D~}, D~} r>~:{y Dx:A} rl-M.y:A rl-v:{b ba::K, Dl, . . ..Dn} r+ V:{ b~a::K=V.b, \nD,,..., D~} rl-v.y:A rt-V:{y ~z:A, Dl,..., Dn} I &#38;V:{y c-x: A , D,,..., Dn} rt-M:A rl-M:A:A 17t-M:A \nI ~A <A rt-M:A Definition A.1O (Binding Formation 1-I , CY::K=A valwl rt-b~a=A:b~a::K=A rl-M:A 1-r, x:A \nvalid I Fy~x=M:ypx:A (VAR-V) (LAM) (APP) (TSUM) (EXT-V) (VALUE-O) (VALUE-V) (COERCE) (SUBS) Rules) (BIND-T) \n(BIND-V) sums. Even a vastly simpler system with transparent and opaque sums and a forgetting rule is \nundecidable. In order to demonstrate this as well as simplify the discus\u00ad sion, we consider now a very \nsimple fragment of our full system. B. 1 The fragment A+q3= The fragment A+qq= is obtained from our \nsystem by restricting the set of constructors to include only types and restricting the methods of building \ntypes to only allow for arrow types, binary opaque sums (often called weak sums), and binary transparent \nsums. We use a slightly different notation to emphasize that these are simpler constructs. The syntax \nfor A+ s q= is as follows: As before, the meta-variable a ranges over type vari\u00adables and we identify \ntypes that differ only by a\u00adconversion. The t ranslat ion back to our earlier not at ion is as follows: \nz =a . Al +/42 = rIx:A1.A2 3a.A = {b~ a::~, yDx:~} 3a= A1.A2 = {b~ ff::~=z, y D X:z} The effect of the \nsubtyping rules of our system on this fragment is captured by the following simple set of rules: Definition \nB.1 (Subtyping rules for A+ 3]3= ) Lemma All (Properties of the typing system) 1. if r EA ::K then t-I \nvalid (ARROW) 2. ifr+Al= Az::A then rbAl::Kandr RAz::K  3. if r + D1 = D2 then t-17,E valid and k r,= \nvalid A<A  ~.ifrEAl<AzthenrEAl::O and171-Az::fl (SUM-O) 3a.A < 3cY.A 5. if r t-D1 < Dz then E r,~ valid \nand E 17,n valid [A/a]AI < [A/~]Az 6.ijl?t-M: Athen I t-A::Q (SUM-T) 3cr=A.Al < 3LY=A.Az 7. if171-B: \nDthenkr, ~ualid 8. if+ I , ~ valid then 1-17 valid  (FORGET ) B Undecidability of Subt yping Note \nthat this set of rules is completely syntax di\u00ad rected and does not require the use of a context because \nThe subtyping relation for our system can be shown to of the explicit use of substitution. The proof \nthat this be undecidable by a slight modification to Benjamin set of rules corresponds to the subt yping \nrules of the Pierce s proof of the undecidability of F< subtyping original system on this fragment is \nomitted. For the [38, 37]. The basic source of undecidability is the sub-purposes of the undecidability \nproof, we will only need typing rule (FORGET) that allows the forgetting of the following lemma: al ifp=cr, \nF(p) = %r, al,. ... an. -@$=a,cl;=r(pl), . . . . a~=f(pn). -lqpl)) ifp=[al, . . ..an]<ppn>. pn> { %,al,... \n,ix~a~a if p = HALT F(R) = ikl =c7, al+(pl), . ,an=$-(pn). lF(pl) < u where R = <pl . . . pn> and u = \n%, al, . . ..*n.1(3a =a. a;=a,,..., a~=a7a)a) Here, a, a , and aj through a ~ are fresh variables. Figure \n5: Modifications to Pierce s encoding of row machines Lemma B.2 The subtyping relation for A-313= is \nre-Theorem B.4 A+ a 3= subtyping is undecidable. flexive. Pierce s proof can be found in chapter 6 of \nhis thesis The proof proceeds by structural induction on the size [38] or in [37]. Space considerations \nprevent outlining of the type using the following measure:16 it here. The modifications necessary to \nchange his en\u00adcoding of row machines so that it produces /4+ 3 3= lal =0 IA1+A21 = l+ IAII+IA, I  subt \nyping questions instead are found in Figure 5. The 1%.AI = l+IAI key diffe~ences are as follows: p~=A,.A21 \n= 1 + l[A,/cY]A, I . Use of 3a=A.A1 < 3cr.A2 instead of Va.A2 d@A.A1 . B.2 Undecidability of A+qq= subtyping \n. Use of reflexivity to halt computation instead Theorem B.3 If the FORGET rule is removed, then the \nFTOP rule. (Compare the two definitions ~~,as= subtyping is decidable. ~(HALT)) Proofi Each use of the \nother rules strictly decreases the following non-negative measure, so the simple syntax\u00addirected procedure \nalways terminates in this case: IA, <A,l = IAII+ IA21. 0 Note that use of the FORGET rule does not decrease \nthis measure and in fact can increase it because the type on the right side can grow without limit in \nthe recursive call. This fact can be used to construct examples that cause the simple syntax-directed \nprocedure for checking A 3 3= subt yping to loop. For example, consider the following definitions: 1A \n= A--d P(A) = 3cx=A.TA where a fresh G~(A) = 3~.TA  The definition of -1A is chosen so that -Al < -AZ \niff A2 ~ Al. Any type constructor with a contravariant subtyping rule could be used here. An example \nwhich causes cyclic behavior is then as follows: P(G~(P(cI))) < GcY(P(cY)) = 3~=G*(P(~)).=G~(P(~)) < \n3~.~P(~) * [G(P(a))/a](+%(P( a))) S [Gx(P(a))/a](=P( a))  =G~(P(~)) < =P(G&#38;(P(CY))) ~ P(G*(P(~))) \n< Ga(P(~)) 16Note that IIAI /CI]A21 = ][IAI l/4421 if we defie Iil = .  \n\t\t\t", "proc_id": "174675", "abstract": "<p>The design of a module system for constructing and maintaining large programs is a difficult task that raises a number of theoretical and practical issues. A fundamental issue is the management of the flow of information between program units at compile time via the notion of an interface. Experience has shown that fully opaque interfaces are awkward to use in practice since too much information is hidden, and that fully transparent interfaces lead to excessive interdependencies, creating problems for maintenance and separate compilation. The &#8220;sharing&#8221; specifications of Standard ML address this issue by allowing the programmer to specify equational relationships between types in separated modules, but are not expressive enough to allow the programmer complete control over    the propagation of type information between modules.</p><p>These problems are addressed from a type-theoretic viewpoint by considering a calculus based on Girard's system F<subscrpt>&#969;</subscrpt>. The calculus differs form those considered in previous studies by relying exclusively on a new form of weak sum type to propagate information at compile-time, in contrast to approaches based on strong sums which rely on substitution. The new form of sum type allows for the specification of equational, as well as type and kind, information in interfaces. This provides complete control over the propagation of compile-time information between program units and is sufficient to encode in a straightforward way most users of type sharing specifications in Standard ML. Modules are treated  as   &#8220;first-class&#8221; citizens, and therefore the system supports higher-order modules and some object-oriented programming idioms; the language may be easily restricted to &#8220;second-class&#8221; modules found in ML-like languages.</p>", "authors": [{"name": "Robert Harper", "author_profile_id": "81100140064", "affiliation": "School of Computer Science, Carnegie Mellon University, Pittsburgh, PA", "person_id": "PP39029370", "email_address": "", "orcid_id": ""}, {"name": "Mark Lillibridge", "author_profile_id": "81100001867", "affiliation": "School of Computer Science, Carnegie Mellon University, Pittsburgh, PA", "person_id": "P190619", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/174675.176927", "year": "1994", "article_id": "176927", "conference": "POPL", "title": "A type-theoretic approach to higher-order modules with sharing", "url": "http://dl.acm.org/citation.cfm?id=176927"}