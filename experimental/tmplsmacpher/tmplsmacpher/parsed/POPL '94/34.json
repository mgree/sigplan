{"article_publication_date": "02-01-1994", "fulltext": "\n The Revival Transformation Lawrence Feigen David Klappholz Novell, Inc. and Stevens Institute of Stevens \nInstitute of Technology Technology david@gattss.stevens-tech.edu lef@univel.com  Abstract The notion \nthat a definition of a variable is dead is used by optimizing compilers to delete code whose execution \nis useless. We extend the notion of deadness to that of partial deadness, and define a transformation, \nthe revival transformation, which eliminates useless executions of a (partially dead) definition by tightening \nits execution conditions without changing the set of uses which it reaches or the conditions under which \nit reaches each of them. 1. Introduction Transformations which eliminate unnecessary code executions \nsuch as common subexpression elimination [1]-[2], dead code elimination [1]-[2], and elimination of partial \nredundancy [8]-[14], are a significant source of performance enhancement. The revival transformation, \na generalization of dead code elimination extends the notion of dead (for variables and definitions of \nvariables) to dead on a path, and removes a definition d from paths on which it is dead. 1.1. Deadness \nof a Variable at a Point / Deadness of a Definition In the standard theory of optimizing compilers [l]\u00ad \n [2] a variable v is termed dead at a point p in a program P if there is no use-before-definition of \nv on any path from p to P s exit. A definition is Pem $sion to copy without fee all or part of this material \nis granted provided that the copies are not made or distributed for direct commercial edventege, the \nACM copyright notice end the titfe of the publication and its date eppeer. and notice is given thet copying \nis by permission of the Association for Computing Machinery. To copy otherwisa, or to republish, requires \na faa and/or specific permission. POPL 94-li94, Portland Oregon, USA @ 1994 ACM 0-897914536-9i94/001 \n..$3.5O Robert Casazza Xing Xue Nynex Science and Technology, Inc. and Stevens Institute of Technology \nStevens Institute Technology of termed dead (dead code) if the variable v which it defines is dead at \nthe point in P which immediately follows the definition. The utility of the notion of deadness is, of \ncourse, that dead code may be removed from a program without changing the program s result. For reasons \nwhich should become clear shortly, it will be convenient for us to consider point in a program to mean \narc of a flow graph, We will use the notation (S, a) to denote an arc from node S with label CL tx e \n{True, False, -}. When we say that variable v is dead (live, etc.) at point p = (S, a) in program P, \nwe will mean that v is dead (live, etc.) at entry to the target of p, which node we will refer to as \nS s a successor in P. 1.2. Deadness of a Variable on a Path / Partial Deadness of a Variable at a Point \n/ Partial Deadness of a Definition / Attachment of a Definition We begin the discussion of the revival \ntransformation by extending the notion of deadness / liveness of a variable at a point to that of deadness \n/ liveness on a path in the obvious way. I.e., if P is a program and n is a path from some node S of \nP to P s exit, then v will be termed live on n if there is a use-before definition ofvon n,andv will \nbetermed deadonnif vis not live on 7c. We will term a variable v partially dead (alternatively, partially \nlive) at point p = (S, U) in a program P if there exists a path z from S s cx successor to Ps exit on \nwhich v is live and there also exists a path n from S s et successor to P s exit on which v is dead. \nHaving defined the notion of partial deadness /partial liveness for variables, we turnto its counterpart \nfor definitions. We will term a definition d of variable v in program P partially dead (alternatively, \npartially live) if v is dead on at least one path from a successor of d to Ps exit and v is live on at \nleast one path from a successor of d to P s exit. Finally, if node T is an ct successor of node S in \nprogram P, then we will say that T is attached at (S, CC)in P. Note that this means that a single node \nT can be attached in P at multiple points (S1, CXl), (S2, Ct2), etc., i.e., if S is the target of multiple \narcs (S1, al), (S2, ~2), etc. we will be particularly concerned with the attachment points of definitions. \nTo simplify matters, we will restrict our attention to flow graphs (programs) with one instruction per \nnode and make no distinction between a definition and a node containing that definition. 1.3. The Revival \nTransformation The revival transformation detaches a partially dead definition d from the point(s) at \nwhich it is attached in program P and reattaches it at a point(s) at which it is maximally live (minimally \ndead) among all points at which its reattachment preserves P s result. Consider, as an example, the flow \ngraph of Figure 1 in which definition S 1 is attached at (ENTRY, -), i.e., at ENTRY sl sole, unlabeled, \narc. S 1 is live on path S2 ~ S4 + EXIT, dead on path S2 ~ S3 + S4+ EXIT, and, therefore, partially dead \n/partially live. In this case the partial deadness is the result of an other-def\u00ad before-use situation. \nConsider, as a second example, the code of Figure 2. Definition T1 is dead on path T2 3 T4 + EXIT, live \nonpath T2 ~ T3 + T4 + EXIT, and, therefore, partially dead /partially lIn succeeding examples we will \nomit the ENTRY and EXIT nodes, with the understanding that they are present in every flow graph. live. \nIn this case the Dartial deadness is the result of a no use situation. S1 x-l C5 2<2 F T S3 x.2 S2 S4 \nY-X+3 b EXIT c+) Figure 1 T1 X-1 T 2>5 F T2 T T3 Y-X+4 T4 Q-2 F EXIT (5 Figure 2 2<2S2 SI - > S4 y=x+3 \n3 - AEXIT Figure 3 Z>5 F T2 T T1 x-l T3 ~=x+4 T4 0.2 5 Figure 4 Figures 3 and 4 show the results of \napplying ~he revival transformation to Figures 1 and 2 respectively. In the case of Figure 3, S1 has \nbeen detached from (ENTRY, -) and reattached at (S2, T) where it is totally live and, therefore, more \nlive (less dead) than it was when it was attached at its old attachment point --without changing the \nresult of the program. In Figure 4, T1 has been detached from (ENTRY, -) and reattached at (T2, F) where \nit is totally live. In the general case, if d is a partially dead definition in program P, then we want \nto reattach d at precisely those points at which d goes from being partially dead to totally live. More \nprecisely, let (S, et) and (T, ~) be points in P such that T is S s ct successor. If d is only partially \nlive at (S, U) and d is totally live at (T, ~), then (T, ~) will be said to be a reattachment point for \nd. (S2, True) is easily seen to be the reattachment point for S 1 in Figure 1, and (T2, False) can easily \nbe seen to be the reattachment point for T1 in Figure 2. For the time being we will restrict our attention \nto the case in which a partially live definition has exactly one reattachment point. In a later section \nwe will address the case of multiple attachment points. Now the revival transformation will not always \nsucceed in rendering a partially dead definition totally live; in some cases it will only render the \ndefinition more live, where more live (less dead) is defined as follows. Let P be a program, d a definition \nin P of a variable v, (Sl, Q (s2> q)> ... . (Sm, am) the points at which d is attached in P, and (T, \n~) a point in P. Let excondP(X) represent the conditions under which node X executes in program P. Let \nreachcondp(d, Y) represent the conditions under which d s definition of v is the definition of v which \nis used by a use of v in node Y1. If P is the result of detaching d from (Sl, CXl), (S2, ~2), ... , (Sm, \nCXm)in P and reattaching it at (T, ~), then d is more live in P than in P if [excondP(T) A (T=~)] = excondP,(d) \n~ excondp(d) = [excondP(S ~) A (Sl=cj)] v [excondP(S2) A (S2=ct2)] v ... v [excondP(Sm) A (Sm= cxm)], \nbut excondP,(d) # excondP(d), and for all nodes Y, reachcondP,(d, Y)= reachcondP(d, Y)z. S 1 is more \nlive (less dead) in Figure 3 than in Figure 1 because while it still provides a value for the use of \nX in S4 under exactly those conditions under which it did so formerly, namely S2=True, it accomplishes \nthis end while being executed on fewer paths through the program, i.e., with execution conditions tightened \nfrom True 3 to TrueA(SZ=True). T1 is more live (less dead) in Figure 4 than in Figure 2 because while \nit still provides a value for the use of X in T3 under exactly those conditions under which it did so \nformerly, namely T2=False, it accomplishes this end while being executed on fewer paths through the program, \ni.e., with execution conditions tightened from True to TrueA(T2=False). As a final note we remark that \nall the examples considered thus far have been of loop\u00adfree code. As it turns out, there is little to \nbe achieved by attempting to apply the revival transformation across loop boundaries. We will, therefore, \nrestrict out attention to loop-reduced lexcondP(X)andreachcondP(d,Y) areeasilyformalizedin termsof control \ndependence [3]. 2Note thatthesetof nodesin theresult of applying the revival transformation is the same \nas the set of nodes in the the flow graph to which it is applied. 31.e., unconditional execution. flow \ngraphs, i.e., flow graphs in which loops have been reduced to single nodes. Beginning with the most deeply \nnested loops, we apply the revival transformation to the various partially live definitions in each of \ntheir bodies. Each loop is reduced to a single node, and the process is repeated. The transformation, \nas formulated here, is, however, not applicable to the body of a multiple-entrance loop. In the remainder \nof this introductory section we consider a number of complications of the revival transformation. In \nSections 2 and 3 we show how these complications may be dealt with. 1.4. Backoffi Reversal of Data Dependence \nIn some instances a partially dead definition is not reattachable at any point at which it is totally \nlive. In such instances, the revival transformation reattaches the definition at a point at which the \ndefinition is as live as possible within the given flow graph. As an example, consider the code of Figure \n5. S 1 s reattachment point is (S4, False), a point at which it would be totally live; if S 1 is attached \nthere, however, as it is in Figure 6, then the use of Y in S 1 picks up the wrong definition of Y, that \nin S3; in the terminology of automatic parallelization, the use-clef data dependence from S1 to S3 has \nbeen reversed. S 1 can, however, be attached at (S2, False), a point at which its definition of X is \nstill partially dead, but less dead (more live) than in its original position (see Figure 7). For the \nsake of clarity, we will henceforth use the term preliminary reattachment point instead of simply reattachment \npoint to denote a point at which a definition goes from partially live to totally live. A non-preliminary \nreattachment point at which a definition may be reattached with a resulting increase of liveness, but \nnot to total liveness, will be termed a backofl reattachment point. In later sections we will encounter \nadditional reasons, distinct from reversal of data dependence, to back off from a preliminary reattachment \npoint. 4 S1 X-Y+2 + S2 M-O T S4 T * S6 X-2 t Figure 5 + S2 M-O T S4 T v S6 X-2 t Figure 6 + T S4 T \nt S6 X.2 + Figure 424 1.5. Moving Additional Superstructure In some cases moving a definition to increase \nits degree of Iiveness requires that additional superstructure be moved with the definition. Figures \n8,9 and 10 illustrate this situation. If node S3 of Figure 8 is moved to (S4, True), where it is totally \nlive, to form the flow graph of Figure 9, then the definition s execution condition has not been tightened; \nrather, it has gone from Sl=False to S4=True, an incomparable execution condition. What s worse, S6 uses \nS3 s definition of X even if S l=True, thereby changing the results of the program. What is required, \nif S3 is to be moved at all, is for nodes S 1 and S2, and the associated arcs, to be moved along with \nS3 to produce the flow graph of Figure 10. Fortunately, nothing about S 1 or S2 prevents this move from \nbeing made; in fact the move also reduces the number of unnecessary executions of definition S2 (reduces \nS2 s degree of deadness); it also reduces the number of execution traces on which S 1 executes unnecessarily \nbecause S1 serves no purpose other than to decide which of S2 and S3 is to execute, and neither of them \nneed execute unless S4=True. Note that it is not only the partially live definition being revived which \ncan cause a data dependence to be reversed. In some instances in which additional superstructure must \nbe moved, even if the definition itself causes no reversal, the uses or definitions in the additional \nsuperstructure reverse data dependence, requiring a backoff reattachment pofit to be found. - Figure \n8 425 Figure 9 I S2 I S6 ~Y-X+3j Figure 10 1.6. Decision-Node Copying In the worst case, whether \nor not there is additional superstructure to be moved, the only backoff reattachment point is precisely \nthe point at which the definition was attached originally. In this case, we can sometimes still apply \na version of the revival transformation, but at an increased cost. Consider, as an example, the code \nof Figure 11. S3 can t be moved without S 1 and S2. If we were to move S 1, S2, and S3 to (S4, True), \nwhere we would like to move S 1 to render it totally live, then the use of W in S4 would be a use of \nthe wrong value of W. As an alternative, though, we may move S3, copy S1, and leave S2 in place as we \nhave done in Figure 12. S1 T ) S4 T S5 ) * Figure 11 S1 a T W>3 S4 T X-2 )3 T Slb Z<2 S5 F S3 x-1 s6 \ny-x+3%1 Figure 12 In this particular case it is uncertain whether the el~nation of unnecessary executions \nof S3 is worthwhile considering the fact that S 1 now sometimes executes twice. Suppose, however, that \nS3 contained a lengthier computation than X = 1, e.g., a function call. Even if the test in S 1 were \nalso more complex, as in Figure 13, the transformation into the code of Figure 14 would likely be worthwhile. \nIn the remainder of this paper we will not consider this decision-node-copying version of the revival \ntransformation, relegating it, rather, to a separate paper. Si T 24 T x.2 S5 ) w S6 Y-x+3 Figure 13 S1 \ntemp -f(Z) Sla te T F S2 W-M+5 W>3S4 F %T Slb temp S5 x.2 T F S3 x -g(...) %? .56 ~=> Figure 14 1.7. \nMultiple Preliminary Reattachment Points Up to this point we have ignored the case of multiple preliminary \nreattachment points. According to the definition of preliminary reattachment point, we see that in Figure \n15, T1 has (T3, False) and (T4, True) as preliminary reattachment points. The result of reattaching T1 \nat both these points is shown in Figure 16. In the multiple-preliminary-reattachment-point case the relevant \ndefinition of more live is as follows. Let P be a program, d a definition in P of a variable v, (Sl, \nctl), (S2, CX2),... , (Sm, cj.J the 426 T5 Figure 15 points at which d is attached in P, and (Tl, PI), \n(T2, 132),... . (Tn, ~n) a set of points in P. Let excondP(X) represent the conditions under which node \nX executes in program P. Let reachcondp(d, Y) represent the conditions under which ds definition of v \nis the definition of v which is used by ause of v in node Y. If P is the result of detaching d from (Sl, \nctl), (S2, ~2), ... , (Sm, txm) in P and reattaching it at (Tl, ~1), (T2, ~2), ... , (Tn, Dn), then d \nis more live in P than in P if [excondP(Tl) A (TI=PI)] v [excondP(T2) A (T2=~2)] V ... v [excondp(Tn) \nA (Tn=Pn)] = excondp,(d) * excondp(d) = [excondp(S ~) A (Sl=ul)] v [excondp(S2) A (S2=~)] v ... v [excondp(Sm) \nA (Sm= CXm)], but excondp,(d) # excondp(d), and for all nodes Y, reachcondp,(d, y)= reachcondp(d, y). \n In certain multiple-preliminary\u00adreattachment-point situations there is simply no way to reattach the \ndefinition being moved at all its preliminary reattachment points. Consider as an example the case of \nFigure 17 in which S 1 has both (S5, True) and (S3, False) as preliminary reattachment points. There \nexists no control flow graph in which S 1 has been detached from (E~RY, -) and reattached at both (S5, \nTrue) and (S3, False), and no simple way to ascertain this fact without computing the original program \ns control dependence graphl. Perhaps a better way of stating this is that, in the multiple-preliminary-reattachment-point \ncase the control-flow graph development of reattachment is ill-defined, as is, therefore, the control-flow-graph \ndevelopment of the revival transformation. We have, as a matter of fact, presented the control-flow-graph \npicture of the transformation only because of its greater intuitive appeal as compared to the better-defined \ncontrol\u00addependence-graph version. In Section 2, therefore, we present the complete operational (control-dependence-graph) \ndevelopment of the revival transformation, including the answer to the question of finding necessary \nadditional superstructure. Having admitted the weakness of the control-flow-graph development of the \nrevival transformation, we indulge ourselves one final time to point out that one way to deal with the \nnon\u00adexistent-flow-graph multiple-attachment-point version of the reviwd transformation is to reattach \none copy of the definition to each of the preliminary reattachment points as has been done in Figure \n18. Like the decision-node-copying version of the revival transformation, this definition-copying version \nwill not be considered in the present paper. As in the case of data dependence reversal, we will address \nthe present problem through the expedient of backing off, In the case of Figure 17, (S2, True) is the \nbest backoff point; Figure 19 shows the result of reattaching S1 there. Figure 16 lIt is relatively \neasy, though, to see that in the single\u00adpreliminary-reattachment-point case this problem does not occur. \ninvoker of Y. Rather, when we speak of a n S1 X*1 invoker of a node, say B, we will - +=-- S9 CM-Q+l) \nFigure 17 Figure 18 2. The CDG Version of the Revival Transformation As the purpose of the present section \nis to develop the revival transformation in terms of control dependence [3], we begin with a number of \npreliminaries regarding that subject. Let X and Y be two nodes in a program (flow graph) P, X a branching \nnode, and let a = {True, False}. Y is said to be a-control dependent on X if Y postdominates X s et successor, \nbut Y does not postdominate X s ~ successor. If Y is ct\u00adcontrol dependent on X, then X will be said to \nct\u00adinvoke Y or to be an et-invoker of Y. Note that X by itself will not be referred to as simply an s \n B>D T F S1 x-l T % S7 Figure 19 mean an ordered pair consisting of a node and a member of {True~False}, \nfor e~krnple (A, False). The CDG version of the transformation relies on the notion of a common control \ndependence predecessor, which we now proceed to define. Let G be the CDG of a loop-free flow graph P, \nand let X be a node of G. The notation reachubleG(X) is used to denote the subgraph of G consisting of \nall nodes reachable from node X in G, including X itself, and all arcs connecting them in G. Let G be \nthe CDG of a loop-free flow graph P, and let S~ and S2 be two distinct nodes of G. A node z in G will \nbe termed a common control dependence predecessor of S~ and S2 if there exist two distinct nodes ZI and \nZ2 in G, both distinct from z, and an a c {True, False} such that SI = reachable~ (z ~), and S2 e reachable~(~), \nand z is an a-invoker of both ZI and Z2. The nodes ZI and Z2 respectively will be termed S1 s leader \nwith respect to common control dependence predecessor z (S1 s leader wrt common cdp z for short), and \nS2 s leader with respect to common control dependence predecessor z (S2 s leader wrt common cdp z for \nshort) respectively. This situation is illustrated in 428 9 Figure 20 in which a path consisting of \nzero or more control dependence arcs is denoted by a zigzag curve. Figure 20 Let P be a loop-free program \n(control flow graph). It is easy to see that two nodes of P, say S1 and S7 have the property that there \nexists a path fr~m ENTRY of P to EXIT of P which passes through both S~ and S2 iff S~ and S2 have a common \ncontrol dependence predecessor. The existence of a path from ENTRY of P to EXIT of P which passes through \nboth S1 and S2 simply means that there are executions of the program on which both S~and S2execute, soapartially \ndead definition and the node(s) at which it is to be reattached always have a common control dependence \npredecessor. Let G be the CDG of a loop-free program P, and let Zl, and Z2 be two distinct nodes of G. \nZI, and Z2 will be said to be twinsz if there exists a node z, distinct from ZI and Z2 and NI ~ e {Tree, \nFalse) such that z et-invokes both ZI and Z2. The leaders of two nodes with respect to a common control \ndependence predecessor are thus twins. It has been well known [4]-[7] that if G is the CDG of a hop-free \nprogram and Z1 and 22 are twins, then reachable~(zl ) n reachable = 03, a lThe notion of common control \ndependence predecessor is generalized to sets of nodes in the obvious way. 2Ball and Horwitz [7] would \nterm ZI and Z2 an (~ b)-pair. 3readableG(X) was deftied as a subgraph of G. We are using it here, sloppily, \nto denote the set of nodes in that property which will be useful in what follows. If Z1 and ~ are twins \nand, in addition, the set of invokers of ZI is identical to the set of invokers of %4, then Z1 and Z2 \nwill be termed identical twins. It can be shown, though not in the space available to us here, that in \na loop-free program if z is a common control dependence predecessor of nodes S ~ and S2 with leaders \nZI and Z2 respectively, then, unless ZI and ~ are identical twins, backing off is required, and the only \nbackoff reattachment point is the point at which the definition being revived was originally attached. \nIt can further be shown that in a loop-free program if z is a common control dependence predecessor of \nnodes S~and S2 with identical twin leaders ZI and Z2 respectively, and w is a common control dependence \npredecessor of nodes S ~ and S2 with leaders WI and W2 respectively, then it must be the case that Zl=wl, \nand Z2=WT We will refer to this property as the unique leader pairproperty. Finally, we use the various \nnotions relating to common control dependence predecessors both to answer the additional superstructure \nquestion and to formulate the operational (CDG) version of the revival transformation. Let P be a loop-free \nprogram. Let S~be a partially-live definition in P with (X, et) as its sole invokers, and let (S2, ~) \nbe the unique reattachment point for S~. Note that, since S~ is not a decision node, no nodes in P are \ncontrol dependent on S~, as is shown in the schematic version of P s CDG G in Figure 21. If S~ is simply \ndetached from (X, u) and reattached at (S2, P) to form the CDG of Figure 22, then S1 s execution condition \ngoes from excondP(X) A (X=ct) to the incomparable execution condition subgraph. We will persist in this \nmild sloppinesswhere doing so is likely to cause no confusion. 4Recall that an invoker is not a node, \nbut, rather a pair consisting of a node and a Boolean value. 51n the case of S ~ s having been attached \nat multiple points in P and/or S~ s having multiple reattachment points the argument is just a bit more \ncomplex than the one presented here for single attachment /reattachment points. 429 4 excondP(SJ A (S2=P) \nwhich violates the tighter\u00adexecution-condition aspect of reattachment 1. The only way, in fact, to ensure \nthat, after reattachment, S~ s new execution conditions are tighter than (i.e., imply) S~ s old execution \nconditions is to fmd a common control dependence predecessor z of S1 and S2 with leaders Z1 and Z2 respectively, \ndetach all of reachable from G, and reattach it all at (S9, a). L Figure 21 ENTR a b T 1 % Figure 22 \n If S~ is a definition to be revived, (S2, a) is the unique reattachment point, and z is a common control \ndependence predecessor of S ~ and S2, then the CDG version of the transformation is as shown in Figure \n23 (before) and Figure 24 (after), where the irregular bolded shapes attached to ZI and Z2 in Figures \n23 and 24 lExcept, of course, if S ~ and S2 happen to be twins. represent reachable and reachable respectively. \na Figure 23 (z Figure 24 Consider, as examples, the control flow graphs of Figures 25 and ~6 in each \nof which we see, by inspection of the control flow graph, that S3 can be moved to (S4, True), but with \ndifferent amounts of superstructure. In the case of Figure 25, S 1 and S2 must be moved with S3, to form \nthe flow graph of Figure 27, whereas in the very\u00adslightly-different case of Figure 26, only S2 must 430 \nbe moved with S3, to form the flow graph of Figure 28. The reason for the difference can easily be read \nfrom the control dependence graphs (CDG S) shown in Figures 29 and 30 respectively, of the programs of \nFigures 25 and -. Lb. ( Z<2SI T T 1 Cl#654 c T S5 Y Figure 25 E)  %( S2 ~>33 T ) S4 Q*6 ( T ) Figure \n26 In the first example, the common control dependence predecessor of the node to be moved, node S3, \nand the preliminary reattachment point, (S4, True), is ENTRY, S3 s leader wrt ENTRY is S1 and reachable= \n{S1, S2, S3}. In the second example, the common control dependence predecessor of the node to be moved, \nnode S3, and the preliminary reattachment point, (S4, True), is S 1, S3 s leader wrt S 1 is S2 and reachable \n= { S2, S3 }. Figure 27 Figure 28 reattached is reattached to an entirely new b\u00ad labeled outgoing arc. \ncZ<2S1 F S2 W>3 S5 x.2 ) F 4 S3 x-1 Figure 29 S1 cZ<2 F S2 W>3 F S4 Q#6 F S3 7Z x-l S5 x.2 Figure 30 \n In the general case, the transformation begins with (1) finding the leader pair of a common control \ndependence predecessor of the original attachment point(s) and the reattachment point(s), which leader \npair is unique by the unique leader pair property if the leaders are identical twins; if they are not, \nthen we stop here because, as indicated above, backoff will be required, and the only backoff reattachment \npoint will be the original attachment point. (2) detaching the definition s leader s reachab2e subgraph, \nand (3) reattaching it at the reattachment point(s), which have been computed using the control-flow-graph \ndefinition of Section 1. Control-dependence\u00adgraph reattachment, unlike control-flow-graph reattachment, \nis always well-defined because, a control-dependence graph can have multiple identically-labeled arcs \nfrom the same node. Thus, in Figure 23, regardless of whether or not node S2 already has zero, one, or \nmultiple outgoing arcs labeled b, the subgraph to be The next step in the revival transformation is (4) \nto attempt to serialize the transformed CDG, i.e., to translate it into a control flow graph. Although \nthe result of the reattachment is always, as indicated above, a valid CDG, it is not always the CDG of \nany sequential program (control flow graph); occasionally, the only program whose CDG it is is a parallel \nprogram. It is during the serialization attempt that one discovers whether there exists a control flow \ngraph which represents the result of reattaching the definition being revived at all the reattachment \npoints, and if not finds a (set ofj backoff reattachment point(s), reattaches the definition at the backoff \npoint(s), and, finally, serializes the resulting CDG. We note that when, as is generally the case, a \nprogram contains many partially live definitions to be revived, one need not go the CFG (control flow \ngraph)-to-CDG-to-CFG-to-CDG-... route in order to effectuate the multiple applications of the algorithm. \nRather, there is only one translation into a CDG, multiple applications of the transformation on the \nCDG, and a single serialization. at the end. Lack of space, however, prohibits us from presenting further \ndetails of the multiple-application algorithm. These details are contained in a second paper which is \navailable from the authors. There is one additional, and extremely important, multiple-application-related \npoint, which, in fact, leads to a significant simplification of the revival transformation. It begins \nwith the simple observation that having chosen a particular partially live definition d to revive, its \nleader s reachable subgraph (wrt a common control dependence predecessor with its reattachment point(s)) \nmay very well contain additional partially live definitions whose reattachment points lead to the very \nsame pair of leaders. A very simple example of this situation may be found in Figure 8, in which S2 and \nS3 have the same common control dependence predecessor, and the same leaders, with respect to their comnon \nreattachment point (S4, False). This suggests that we recast the revival transformation, from an attachment \npoint(s) -to\u00adreattachment point(s) algorithm (a for every partially live definition algorithm) to a twin-to-twin \nalgorithm (a for every node which has a twin 432 algorithm). We no longer search for a partially live \ndefinition, search for the definition s reattachment points, search for the corresponding leaders, and, \nfinally, performing the detachment / reattachment; rather, we find a node z, which has a twin ~, find \nall the~inal reattachment points in reachable (Z2) of partially live definitions in reachable(z~) --all \nin one bottom-up sweep through reachable --and perform the detachment /reattachment. By$nal (reattachment \npoint) we mean, of course, either preliminary or backofi, whichever turns out to be the case. It is easy \nto see that by starting with pairs of leaders (twins) we eliminate numerous searches for leaders. The \ntwin-to-twin algorithm, whose details we are precluding from presenting because of space limitations \nis detailed in the continuation paper alluded to above. Once we have decided to apply the transformation \non a twin-to-twin basis, a number of additional questions arise and are simply answered, to a fmt approximation, \nas follows; If the CDG contains nesting of twin pairs as in Figure 31, then the revival transformation \nis applied bottom-up. If the CDG contains multiple births of cardinality greater than two, i.e., triplets, \nquadruplets, etc., as in Figure 32, then the revival transformation is applied right-to-lef~ i.e., ~-1 \nis moved into ~ if possible, then Z-2 is moved, etc., etc. This corresponds, in control flow terms, to \nmoving target reachable sets as far down as possible, and then moving source reachable sets into them. \nThis ordering is afirst approximation because of the so called order fixed and order arbitrary serialization \nconstraints on pairs of twins discussed in [7]. A z aa z Y b b CD % Figure 31 Figure 32 3. Summary This \npaper concerns itself with the pure-win (non\u00addecision node copying, non-definition copying) version of \nthe revival transformation in which a definition, together with additional superstructure if necessary, \nis detached from its original attachment point(s) and is reattached, without its or any other node s \nbeing copied, at one or more, preliminary or backoff, reattachment points. The result of applying this \npure-win version of the revival transformation, which we will, henceforth, refer to simply as the revival \ntransformation, to a flow graph P is a new flow graph P whose nodes are precisely those of P but whose \nstructure may be substantially different from P s. The revival transformation parallels and complements \nthe recently-much-studied elimination of partz al redurukzncy transformation in the following ways. Elimination \nof partial redundancy [8]-[ 14], which can be thought of as a generalization of common subexpression \nelimination, takes an instruction, I, whose execution is unnecessarily performed multiple times and moves \nit to a location in the program where the number of its unnecessary executions is lower, in the best \ncase zero; elimination of partial redundancy assumes that a minimum of one execution of I is always necessary, \nso after its application every path in the program which contained one or more executions of I still \ncontains at least one execution of I. The revival transformation, a generalization of dead code elimination \nextends the notion of dead (for variables and definitions of variables) to dead on a path and removes \nan instruction (definition) I from paths on which it is dead; since the basic premise of the transformation \nis that a minimum of one execution of I is not always necessary, after its application some paths which \npreviously contained executions of I no longer contain any executions of I. The revival transformation \nis thus complementary to elimination ofpartial redundancy in much the same way as dead code elimination \nis complementary to common subexpression elimination. References [1]Aho, A., Sethi, R., and Unman, J., \nCompilers: Principles, Techniques and Tools, Addison-Wesley, 1986 [2] Allen, F. E. and Cocke, J. A catalogue \nof optimizing techniques. Design and Optimization of Compilers, R. Rustin, Ed., Prentice-Hall, Englewood \nCliffs, N.J., (1971) 1-30. [31 Ferrante, J., Ottenstein, K. J., and Warren, J. -. D. The pro~am dependence \n~aph and its use in optimization. Technical Report CS-TR 86\u00ad8, Computer Science Department, Michigan \nTechnological University -Houghton, M.I., (1986). [4] Ferrante, J. and Mace, M. On linearizing parallel \ncode. Conf. Rec. of the Twelfth ACM Symp. on Principles of Programming Languages, New Orleans, (1985) \n175-189. [5] Ferrante, J., Mace, M., and Simmons, B. Generating sequential code from parallel code. Proceedings \nof the ACM 1988 Int. Conf. on Supercomputing, (1988) 582-592. [6] Simmons, B., Alpern, D., and Ferrante, \nJ. A foundation for sequentializing parallel code. Proceedings of the Symp. on Parallel Algorithms and \nArchitectures, (1990) 350\u00ad 359. [7] Ball, T., and Horwitz S. Constructing control flow from control \ndependence. Technical Report TR1091, Computer Sciences Department, University of Wisconsin -Madison, \nW. I., (1992). [8] Morel, E., and Renvoise, C. A global algorithm for the elimination of partial redundancies. \n2nd Int. Symp. on Programming, Paris, (1976) 147-159. [9] Morel, E., and Renvoise, C. Global optimization \nby suppression of partial redundancies. Commun. of the ACM, 22 (2) (1979) 96-103. [10] Drechsler, K. \nH., and Stadel, M. P. A solution to a problem with Morel and Renvoise s Global optimization by suppression \nof partial redundancies. ACM &#38;r:4~gram. Lang. Syst., 10 (4) (1988) . [11] Rosen, B. K., Wegman, M. \nN., and Zadeck, F. K, Global value numbers and redundant computations. Conf. Rec. of Fifteenth ACM Symp. \non Principles of Programming Languages, San Diego, (1988) 12-27. [12] Sorkin, A. Some comments on A solution \nto a problem with Morel and Renvoise s Global omimization bv sutmression of tmrtial r~dundancies. y A@M \nTrans. fiogram. Lang. Syst., 11 (4) (1989) 666-668. [13] Dhamdhere, D. M. Practical adaptation of the \nglobal optimization algorithm of Morel and Renvoise. ACM Trans. Program. Lang. Syst., 13 (2) (1991) 291-294. \n[14] Knoop, J., Rothing, O., and Steffen, B. Lazy Code Motion. ACM SIGPLAN 92 Conf. on Program. Lang. \nDesign and Implementation, San Francisco, (1992) 224\u00ad 234. \n\t\t\t", "proc_id": "174675", "abstract": "<p>The notion that a definition of a variable is <italic>dead</italic> is used by optimizing compilers to delete code whose execution is useless. We extend the notion of <italic>deadness</italic> to that of <italic>partial deadness</italic>, and define a transformation, the <italic>revival transformation</italic>, which eliminates useless executions of a (partially dead) definition by tightening its execution conditions without changing the set of uses which it reaches or the conditions under which it reaches each of them.</p>", "authors": [{"name": "Lawrence Feigen", "author_profile_id": "81100431318", "affiliation": "Novell, Inc. and Stevens Institute of Technology", "person_id": "P169629", "email_address": "", "orcid_id": ""}, {"name": "David Klappholz", "author_profile_id": "81100484385", "affiliation": "Stevens Institute of Technology", "person_id": "PP14169577", "email_address": "", "orcid_id": ""}, {"name": "Robert Casazza", "author_profile_id": "81100584079", "affiliation": "Nynex Science and Technology, Inc. and Stevens Institute of Technology", "person_id": "P244403", "email_address": "", "orcid_id": ""}, {"name": "Xing Xue", "author_profile_id": "81546146356", "affiliation": "Stevens Institute of Technology", "person_id": "PP14060315", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/174675.178043", "year": "1994", "article_id": "178043", "conference": "POPL", "title": "The revival transformation", "url": "http://dl.acm.org/citation.cfm?id=178043"}