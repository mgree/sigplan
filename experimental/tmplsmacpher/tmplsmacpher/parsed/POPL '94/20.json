{"article_publication_date": "02-01-1994", "fulltext": "\n Higher-Order Equational Logic Programming Zhenyu Qian* Universitat Brement Abstract Higher-order equational \nlogic programming is a par\u00adadigm which combines first-order equational and higher-order logic programming, \nwhere higher-order logic programming is based on a subclass of simpIy typed A-terms, called higher-order \npatterns. Cen\u00adtral to the notion of higher-order equational logic programming is the so-called higher-order \nequational unification. This paper extends several important classes of first-order equational unification \nalgorithms to the higher-order setting: only problems of the ex\u00adtensions are discussed and first-order \nequational uni\u00adfications are viewed as black boxes whenever possible. We first extend narrowing and show \nthat the com\u00adpleteness of many higher-order narrowing strategies reduces to that of their underlying \nfirst-order counter\u00adparts. Then we propose an algorithm for higher-order equational unification of free \nhigher-order patterns in an arbitrary equational theory. Finally a general ap\u00adproach to extend first-order \nunification combination algorithms is sketched informally. The termination property of the above higher-order \nextensions is con\u00ad sidered in a uniform way. Introduction Higher-order logic programming paradigm, like \ne.g. LA [20], Elf [27] or the recent implementation [23] of Isabelle [25], provides a powerful and efficient \ncom\u00ad * Res.arch partially supported by ESPRIT Basic Research WG COMPASS 6112. f ,&#38;d&#38;ess: FB 3 \nInfornmtik, Universitiit Bremen, D-28334 Bremen, Germany. E-mail: qlsn@inf ormat ik .uni-bremen. de Perrrission \nto copy without fee 811 or part of this materi8! is granted provided that the copies are not mede or \ndistributed for direct commercial advantage, the ACM copyright notice and the title of the publication \nend its date appear, and notica is given that copying is by permission of the Association for Computing \nMachinery. To copy otherwise, or to republish, requires a fee and/or specific permission. POPL 94-1/?24, \nPortland Oregon, USA @ 1994 ACM O-89791 -836-91 941W1 ..$3.50 mutational mechanism for succintly representing \nand manipulating syntactical structures involving notions of abstractions, scope, bound and free variables, \nand is therefore very suitable for syntactically handling formulas, types, proofs and programs. Equational \nlogic programming paradigm (as in [7, 10, 12, 13, 21, 31, 32, 35, 39] and in the collection [6]) includes \nfirst-order extensions of Prolog, where symbols can be specified by equations. Although the higher-and \nfirst-order paradigms are successful on their own, no techniques of one paradigm, to our knowledge, have \nbeen systematically used in the other. In this paper we investigate the integration of them. The integration \nis important from the perspective of higher-order logic programming, since equations exist naturally \nin many mathematical systems and facilities to handle them naturally ease the manipu\u00adlation of these \nmathematical systems in the higher\u00adorder setting. Examples are the mathematical sys\u00adtems that include \nthe number theory, where arith\u00admetic operations on numbers may be naturally de\u00adfined by equations. Changing \nthe perspective, ex\u00adtending equational logic programming to a higher\u00adorder setting is also important, \nsince equational the\u00adories are often subject to some syntactical structures, which can be naturally formulated \nin a higher-order setting. Examples are parameterized many-sorted al\u00adgebraic specifications. The higher-order \nlogic programming paradigm mentioned above is based on a subclass of A-terms, discovered by Miller, where \nthe unification is decid\u00adable, unifiable terms always have a most general uni\u00adfier [20] and a most general \nunifier can be computed in linear time and space [28]. This subclass consists of all /3-normal forms \nwhere free variables F may only occur in the form F(zl, . . . . Zk), k ~ 0, with ~1,...,~k being distinct \nbound variables. We follow Nipkow [22] to call these terms highe~-onie~ patterns (short: patterns). Their \nunification is called higher\u00adorder unification in this paper. Roughly speaking, the higher-order logic \nprogramming paradigm can be viewed as an extension of Prolog where first-order terms are replaced by \npatterns, and first-order uni\u00adfication by higher-order one. Just as in the first\u00adorder case, where unification \nmodulo equations, usu\u00adally called equational unification, is central to the no\u00adtion of equational logic \nprogramming, so is higher\u00adorder unification modulo equations, called higheT\u00adoTdeT equational unification \nhereafter, to the notion of higher-order equational logic programming. Unifi\u00adcation modulo no equations \nis said to be syntactic. In the first-order setting, a unification algorithm in an equational theory \ncan either be designed directly or composed of existing unification algorithms for dis\u00adjoint sub-theories \n(cf. e.g. [1, 17]). In the higher-order case, the situation seems to be similar. However, we should make \nuse of first-order algorithms whenever possible. Nipkow, Qian and Wang proposed some equational unification \nalgorithms, which accept all simply typed A-terms and are parameterized by ar\u00adbitrary first-order equational \nunification algorithms ([24, 29]). But the restrictions of these algorithms to higher-order patterns \ninherit some unpleasant opera\u00adtional properties from syntactic unification of simply typed A-terms. The \naim of this paper is to extend three important kinds of first-order equational unifi\u00adcation algorithms \nto the higher-order setting, where the resulting algorithms have operational properties close to those \nin the first-order case. Firstly, we consider functional logic programming systems (in Section 4), which \nare logic programming systems, where function symbols may be specified by directed equations, called \nrewrite rwles. The equa\u00adtional unification in this case is also called namow\u00ading. For example, let the \nusual addition + be defined by O+ X 4X and SUC(X) + Y ~ SUC(X + Y) where O is zero and suc the successor \nfunction as usual. Then narrowing X+Y =? SUC(Y) may yield a solution {x w Sue(o)}. We introduce a notion \nof higher-order narrowing such that e.g. the unification problem Ay.1 (y) + y=? ~Y.suc(Y) with 1 being \na free (function) variable may be solved modulo the above rewrite rules. Al\u00adthough different first-order \nnarrowing strategies have been considered in the literature, which have led to very different first-order \nfunctional logic program\u00adming systems (cf. e.g. [7, 10, 12, 13, 21, 31, 32, 35, 39] and the collection \n[6]), it will be shown here that if a strategy of higher-order narrowing is a total higher\u00adorder extension \nof its first-order restriction in a cer\u00adtain sense, then the completeness of the strategy re\u00adduces to \nthat of the first-order restriction. As the second contribution of this paper, the notion of unifiers \nis extended and an algorithm is presented (in Section 6) for computing the most general uni\u00adfiers of \nfree patterns in the presence of an arbitrary equational theory. Note that in the first-order case, syntactic \nunification is conservative in equational uni\u00adfication in the sense that if the terms to be unified are \nfree, (i.e. contain no function symbols occurring in the equations, ) then their equational unification \nis just syntactic unification. This property is lost in the higher-order case. Consider the unification \nprob\u00adlem ~zy.1 (z, y) =? ~zy.1 (y, z) in the presence of a usual commutative function symbol +, where \nF is a free variable. Let On denote the substitution {F H kZy.Gn(~I(Z, y) + ~I(y, z), .0., Hn(z, y) + \nZl(Y,~ ))}! where n is a natural number, G~, Hi, i = 1, o , n, are distinct free variables. It may be \neasily checked that On is a unifier of the above unifica\u00adtion problem. But the syntactical unification \nof Aizy.F(z, y) =? Azy.F(y, x) yields a most general uni\u00adfier {F +-+ Axy.H} with a new free variable \nH, which is obviously not a most general one in the presence of +. Thus, the algorithms in [20], [22] \nand [27] are not complete for equational unification of free pat\u00adterns. In general, 19fi is not a most \ngeneral unifier either, since Om+l is a unifier and strictly more gen\u00aderal than On. Note that Azy.F(z, \ny) and kzy.F(y, z) are both free patterns and en contains ~-terms that are not patterns. It may be proved \nthat in the simply typed A-calculus every unifier of the above unification problem is an instance of \n6n for some n. Therefore, the higher-order unification is not finitary, even if all simply typed A-terms \nare allowed in the solutions. In the first-order case, a unification algorithm for an equational theory \nmay be built by combining uni\u00adfication algorithms for the disjoint sub-theories using some combination \nalgorithm (cf. e.g. [2, 9, 33, 38]). Higher-order equational unification can also be pur\u00adsued in an analogous \nway. We informally sketch (in Section 7) a uniform way of extending first\u00adorder combination algorithms \nto the higher-order set\u00adting. Higher-order combination algorithms combine the higher-order equational \nalgorithms proposed in this paper, and also those developed elsewhere (cf. [30] for a higher-order AC \nunification algorithm). Termination of a unification algorithm is an im\u00adportant property, since the decidability \nproperty may depend on it. A general method is proposed (in Sec\u00adtion 5) which reduces the termination \nof a higher\u00adorder equational unification to its first-order counter\u00adpart. The method is applied several \ntimes in this paper. 2 Other related work This section discusses other related work not men\u00adtioned in \nSection 1. Breazu-Tannen and Meyer were the first who showed that the integration of a first-order equational \ntheory in a simply typed A-calculus is conservative w.r.t. the first-order equational theory [5]. The \npoint was then made more clearly by Breazu-Tannen and Gallier [3, 4] where the computational reductions \nin the integrations are studied. In the spirit of universal unification [11], Sny\u00adder studied equational \nunification of simply typed A terms [34]. Wolfram considered the same problem in terms of a general form \nof term rewriting [37], Dougherty and Johann for restricted equational theo\u00adries in a combinatory logic \nframework [8]. As already mentioned, Nipkow, Qian and Wang proposed a uni\u00adfication algorithm parameterized \nby first-order equa\u00adtional unification algorithms ([24, 29] ). Weber and Moller implemented the Nipkow, \nQian and Wang s algorithm in their software development system (cf. [36]). All the above algorithms inherit \nsome seri\u00adous problems from the syntactic unification of sim\u00adply typed A-terms: the unification is undecidable \nand unifiable terms may have infinite independent uni\u00adfiers. With a higher-order logic programming para\u00addigm \nbased on patterns we have a new starting point in this paper. 3 Preliminaries This section briefly introduces \nour notations. More technical details are given in Appendix A. We follow the standard notations for the \nsimply typed A-calculus and use the following conventions: s, t, u and v stand for the simply typed }-terms \n(short: terms), z, y and z for bound variables, X, Y, Z, F, G and H for free variables, c, d, f, g and \nh for function symbols, a and b for atoms (i.e. function symbols, bound or free vaiables). Bound and \nfree variables are always kept disjoint. The set of all bound (or free) variables in a syntactic object \nO is denoted by Z?V(0) (or 9V(0)). The letters a, ,8, ~ range over types, and dl + ... --+an + /3or ~ \n-i /3stands for al -+(... --+ (% + P)). We may write ~Z.s, or simply Az.s for AZ1. . . . Axn .s, where \ns is not an abstraction, and a(ul, ..., tin), a(~) or a(li) for (((a ul) uJ) . . .un). In the same context, \noccurrences of 3? (or ti) always denote the occurrences of the same% (or w, resp.). If D stands for w \nand ii for ~ then {u E-+ v} stands for { Uk ~ vk}. Let X 6 {p, q, pq}. We use -+x to denote one step \n%-reduction, -+$ the reflexive and transitive closure and =X the equivalence of +x. Define ti(~~.a(~)) \n= a. Let slp denote the @-normal form of .s. An q-long form is a /3-normal form XZ.a(K) with a(z) being \nof a base type and each tz being q\u00adlong. Use .sTn to denote the unique q-long form such that s~v ~~ s~p. \nThe q-long form of a single bound variable z may still be written as z. Patterns are the q-long forms, \nin which argu\u00adments of a free variable may only be distinct bound variables. If &#38; (y, z), G(z), ~(G(z)) \nand Y(~z. @z)t .f(G(z))) are of base types, then terms Azyz.F(y, z) and Azy.y(}z.G(z), ~(G(z))) are pat\u00adterns. \nThe terms ~z.1 (c, z), Azy.F(z, X) and kz.1 (G(z)) are not patterns. In the sequel, @ reductions are \nalways assumed to be performed au\u00adtomatically, and all terms are patterns unless stated otherwise. We \nuse 0(s) to denote the set of the positions of all subterms in a pattern s, ~(s) that of all rigid subterms. \nFor p c 0(s), SIP denotes the subterm ofs at p, S[U]P the result of replacing SIP in s by u. A substitution \nmay be written as {Xl ~ tl, ..., Xn R tn} or {Xn +-+ -tn}. The letters a, 0, p range over substitutions. \nLet 6 = {Xn ~ tn }. Then D(e) = {xl,..., Xn} and Z(6) = YT(tl, c . .,tn). The restriction of 6 to a variable \nset W is denoted by 91W, the composition of n and $ by cTtJ satisfying 08(X) = u(19(X)) for every X. \nWe call 6 a variable renaming if tl, . . . ! % are distinct free variables. A rewrite rule ! + r is an \nordered pair, an equation 1 = r an unordered pair of first-order terms. A term rewrite system (short: \nTRS) R is a finite set of rewrite rules, an equational theory E a finite set of equations. In this paper, \nmany notions and notations defined for rewrite rules may also be used for equations in an obvious way. \nFor example, function symbols flee w.r. t. R are those not occurring in R, and function symbols free \nw.r. t. E means similar. In the sequel, all TRS S are assumed to be con\u00adsistent and confluent. In Section \n4, every rewrite rule 1--+ r is required to additionally satisfy that 7V(~) G ~Y(l) and 1 is not a free \nvariable. We use _+R to denote one step R-rewriting, --+; the reflexive transitive closure and =R the \nequivalence of .+R. Let =pq~ denote (=R U =@q)*. Since for all patterns u and v, u =@@ v if and only \nif u~q =R vTq [3], we need only to consider =~ instead of =pq~. Let W be a free variable set. We use \na =~ 19 [w] to denote o(X) =~ 6(X) for each X c W, where [W] may be omitted if clear from the context. \nWe may write o ~~ 6 [W] if pa =~ @[W] for some p. A unification pairs=? t is an unordered pair of pat\u00adterns \ns and t of the same type. It may be assumed that both sides of a unification pair are always auto\u00admatically \na-converted to have the same sequence of outer A-binders. Unification problems are multisets of unification \npairs. Let P, Q range over them. Then we use UR (P) to denote the set of all higher-order R-unifiers \nof P. If UR(P) = UR(Q), P and Q are said to be equivalent w.r.t. R. 4 Higher-order narrowing In the first-order \ncase, an R-narrowing step on a first\u00adorder term s is the combination of guessing a first\u00adorder substitution \nal for s and applying a rewrite rule 1~ r to al(s) at a position p E ~(s). Let a2 be such that 02(1) \n= UI(SIP). Then the result of the R-narrowing step is al(s) [C7Z(r)]P. It maybe assumed that 3V(1 -+ \nr) fl 2V(S) = {}. Thus al U C72may be chosen as a most general syntactic unifier of SIP and , 6. For \na rewrite rule 11 + TI and a variable renam\u00ading p such that D(p) ~ ~V(il ~ rl) and Z(p) con\u00adtains only \nnew variables, we call p(ll ) + p(~l ) a va~i\u00adant of tl -+ TI. Let s be a first-order term and R={ Z1*TI, \n. . . ,h~T~} a TRS. If /+T is a vari\u00adant of some 1, ~ ri, 1< i < m, and u a most general syntactic unifier \nof SIP and 1, an R-narrowing step may be written as s +P,z,a a(S[T]p). we may write s -m tfor s +P,i,u \nt. A narrowing derivation may be denoted as s w; t,where c = nn l ..OU1. If n=l then o={}. Regard =? \nas a new binary function symbol. Then a unification pair s=? t is a term with (S=? t )1I.p = Slp and \n(S =? t )12.P = t 1P. A narrowing derivation s =? t +; u =? v is called successful if there is u with \no (u) = a (v). In this case, c a is an R-unifier of S=?t. Let R = {O+ X -+X, SUC(X) + Y ~suc(X + Y)}. \nThen the unification pair .X + Y=? SUC(Y) has only one successful narrowing derivation x + Y=? SUC(Y) \n--1,2,01 Suc(xl + Y)=? SUC(Y) -l.l,l, q stic(Y) =? SW(Y), where SUC(X1 ) +Yl -+ SUC(X1 +Yl ) is the variant \nused in +l,z,~l and O + X2 -+ X2 in +l.l,l,CZ with al = {X + SUC(XI), YI i-+ Y} and a2 = {Xl w O,X2 ~ \nY}. Restricting U2U1 to {X, Y} yields an R-unifier {x M Sue(o)}. In the higher-order setting, unification \npairs may contain patterns, thus higher-order unification is needed. Roughly speaking, a higher-order \nnarrowing step is a first-order narrowing step where first-order syntactic unification is replaced by \nhigher-order one, As a preparation, we first explain how to make a rewrite rule applicable in the higher-order \nsetting. The idea is inspired by the notion of lifting over pa\u00adrameters in [26]. Definition 4.1 Let i \n~ T be a rewrite rule with W(J ~ T) = {z}. Let Ill, c .0, lln be distinct new free variables, and yl, \n00., yk distinct bound variables. Let u and v be the results of replacing all occurrences of X, in 1 \nand ~, resp., by Ha(~). Then ~~.u ~ ~~.v is a variant of 1b T over ~. 1 Lemma 4.2 For 1 ~ r E R, if A~.u \n-+ A~.v is a vari\u00ad ant of 1-+ r over V, then ~~.u ~R ~~.v holds. Let R = {O+X -+X, WC(X)+ Y~suc(X + Y)}. \nThen the unification pair AY.F(Y) + Y=? ~Y.sue(Y) has a higher-order narrowing derivation Ay.F(y) + y \n=? ~Y.sue(Y) -1.1,2, el Ay.suc(xl (y)+ y) =? Sue(y) --1.1.1,1,62 Ay.sue(y) =? Ay.sue(y) where ~y.suc(Xl(y))+yl \n(Y)+ ~Y.SUC(XI (Y)+Y1 (Y)) is the variant used in +1.1,2,01 and Ay. O + x2(Y) -+ x2(Y) in +1.1.l,l,e, \nwith 61 = {F W k. SUC(xI(Z)), Y1 ~ ~Z.Z} 82 = {xl ++ Az.o, X2 H Az.z]. The resulting R-unifier is (6261 \n)I{F1 = {F H Az.suc(0)}. If no lifting over y were made in e.g. the variant in AI. 1,2, e,, then the \nsyntactical unifica\u00adtion of the subterm F(y) + y and the left-hand side SUC(X1 ) + Y1 oft he variant \nwould fail, since y cannot occur free in the substitution of YI. Definition 4.3 Suppose R = {ll~rl, . \n. .,lm+T~}. Let s be a pat\u00adtern, p 6 ~(s) and kzl, ..., ~~k all ~-binders in s covering p. Let A=. u \n~ .A~. v be a variant of la ~ ri over ~. A higher-order R-narrowing step (short: R\u00adnarrowing step) is \ndefined ass NP,t,e 6(s[v]P), where 6 is a most general syntactic unifier of A~.SIP =? AR.U such that \nD((I) c FV(S, A=.u) and D(6) nZ(0) = {}. We may write s ~~ t or s ~p,a t for s +P,i,u t. The notation \ns G: tis defined in the same way as in the first-order case. If 2)(6) n ?V(s) = {}, we may write s --+p,i \ns[e(~)]p. 0 Lemma 4.4 Let R be a TRS. Then s ~P,a t if and only ifs ~R t. Lemma 4.5 Ifs -P,,,. t -then \na(s) ~P,i t. Theorem 4.6 (Soundness) Let R be a TRS. If a unification pair s =? t has an R-narrowing \nderivation s =? t +; u=? w with o satisfying a (u) = a (v), then U F is an R-unifier ofs =? t. Definition \n4.7 Let 6 be a substitution. An R\u00adnarrowing derivation s =? t +: u=? v is called suc\u00adce,wfzd (for 0,) \nif there is a satisfying a (u) = a (v) and da ~R 6[~~(s, t)]. 0 4.1 Completeness Usually the completeness \nof narrowing means that if s =? i has an R-unifier 8, then there exists an R\u00adnarrowing derivation issuing \nfrom s =? tand success\u00adful for 0. However, in order to find a successful one, too many R-narrowing derivations \nmay need to be looked at in general. Therefore, restricted TRS S and restricted unification pairs have \nbeen considered where special and efficient strategies can be devel\u00adoped for finding successful narrowing \nderivations (cf. the references of [19]). Since we are only interested in the problems of higher-order \nextensions, the details of the existing first-order approaches will be avoided whenever possible. A notion \nof narrowing strategy is then defined in an abstract way. Definition 4.8 A higher-order narrowing strategy \n(short: narrowing stTategy) is a function S which for each TRS R and pattern tyields a set S(R, t) of \nR\u00adnarrowing derivations issuing from t. 0 Many existing first-order narrowing strategies can be naturally \nextended to the higher-order case. Take basic narrowing as an example. Then higher-order basic narrowing \nshould have the same idea as the firsr-order one ([15]): for a confluent and terminating TRS, a narrowing \nstep need not happen at a subterm introduced by a substitution in a previous narrowing step. The difference \nis just that higher-order substi\u00adtutions are used in higher-order basic narrowing. It should not be surprising \nthat the definition of higher\u00adorder basic narrowing is almost identical to that in [15]. Definition 4.9 \nLet R = {11 +T1, . ~., Zm +Tm} be a TRS. Then higheT-ordeT basic R-naTTowing consists of all R-narrowing \nderivations of the form where p~eBjfor1<j<n 1,andthesets Bl,. ... Bn _ 1 are inductively defined as Let \nus now introduce an abstract notion of com\u00adpleteness. Note that we will only consider normalized R-unifiers, \nas in most existing work, although TRS S R are not required to be even weakly normalizing in general. \nDefinition 4.10 Let R be a TRS and P a class of unification pairs. A narrowing stragety S is said to \nbe complete for R and P if for every s=? t c P and every normalized R-unifier O of s =? t,there is an \nR\u00adnarrowing derivation in S(R, s =? t) which is success\u00adful for O. 0 We will present a result which reduces \nthe com\u00adpleteness of a higher-order narrowing strategy to that of its first-order underlying counterpart. \nThe key is to relate a pattern with a first-order term by view\u00ading }-binders as new unary free function \nsymbols and flexible subterms as new first-order free variables. For example, Az.f(F(z)) should be viewed \nas kc(f(X)) where AZ denotes a free function symbol. When fixing A-binders as free function symbols, \nno explicit a-conversion is possible. Therefore pat\u00adterns should be a-converted beforehand so that no \nexplicit a-conversion is needed any more. For doing this, assume an infinite list of new bound variables \nfor every type. A pattern is said to be a-converted if each A-binder in the pattern always uses in the \ncor\u00adresponding list the first bound variable that has not been used by other covering A-binders. For \nexample, ~yl. f (Ay2y3 .y2, Ayz .y2) is an a-converted form, pro\u00advided that fisofthe type (~a ~--t/3)~ \n(P-+ the list of bound vari\u00ad @ ~ 7 and (yl, y2, y3, . ..) ables for /3. Note that a A-binder may occur \nmore than once in an a-converted form, but only at inde\u00adpendent positions. Occurrences of the same Xbinder \nwill be viewed as occurrences of the same function symbol. No explicit a-conversions are needed in prov\u00ading \nR-equivalence of a-converted forms (cf. [29] for a proof ). It is assumed in the rest of this section \nthat all patterns are a-converted. For viewing flexible subterms as first-order free variables, we introduce \na special mapping. Definition 4.11 A weak abstraction is a large enough injective mapping 4 which maps \na flexible subt erm F(z) into a first-order variable X. If u is a pattern then #(u) denotes the result \nof replacing Now we may introduce a way to characterize nar\u00ad each flexible subterm F (T) in u by #( J \n(?F)). For a substitution 6, define #(O) to be a substitution such that if 6(F) = ~~.-t then @(6)( @(l \n(~))) = q$({z~ ~ y~ }(t)) for all bound variable sequences ~ with each yz being of the same type as that \nof xi. 0 Note that ifF # Gorv# zthen ~(F(v)) # #J(G(z)). For a pattern u, ~(u) can be regarded as a first-order \nterm when the types of the symbols in u are forgotten and all A-binders in u are regarded as free function \nsymbols. For a substitution 6, #(O) can be regarded as a first-order substitution in a similar way, where \nthe domain D(#(6)) is restricted to a fi\u00adnite set including only #(F(~)) of those ~(~) which are in consideration. \nBy definition we may directly prove that the weak abstraction mapping can always be moved into a substitution \nin the following way: Lemma 4.12 FOT a pattern u and substitution 6, 4(6(u)) = #(@)(@(u)) always holds. \nFurthermore, the weak abstraction mapping pre\u00adserves rewriting relations. Lemma 4.13 Let R be a TRS and \ns, t two patterns. Then s ~p,i t if and only i.f 4(s) +P,i d(t). Proof See Appendix B. 0 A rewrite step \nalways transforms a weak abstrac\u00adtion into a weak abstraction. Lemma 4.I4 Let s be a pattern. If ~(s) \n4P,, u then there exists a pattern t such that u = ~(t). Finally, we formulate how ~ relates narrowing \nderivations with their first-order counterparts. Note that derivations (1) and (2) below employ the same \nrewrite rules at the same positions. Lemma 4.15 Let R be a TRS, s=? t a unification pair and 8 a normalized \nR-unifier of s=? t. Then #(O) is a normalized R-unijiev of I#(s) =? ~(i!). Fw~\u00ad thermore, if 4(s) 4 d(t) \n p~,i~ . ..+ Pn,%ll s At (1) is successful for ~((1), then we have s: t +Pl,tl, ol . . . -+Pn,%m,on \nUzv (2) foT some UI, . . . . Un such that there is a with c+(u) = a (v) and C an . . . al ~~ 19 [7V(S, \nt)]. Proof If 6 is a normalized R-unifier of s=? t,then 0(s) =~ O(t), thus @(O) is a normalized R-unifier \nof g+(s) =? @(t)by Lemmas 4.4,4.12 and 4.13. The proof of the second claim is based on Lem\u00admas 4.5, 4.14, \n4.13 and an additional lemma, which is rather technical. For details see Appendix B. 0 rowing strategies. \nDefinition 4.16 A higher-order narrowing stragety S is said to be a total higher-order extension for \na TRS R and a class F of unification pairs if for every s=? tc Pand every normalized R-unifier 0 of s=? \nt, whenever S(R, #(s) =? #(t)) contains a first\u00adorder R-narrowing derivation as derivation (1) suc\u00adcessful \nfor ~(d), S(R, s =? t) contains a higher-order R-narrowing derivation as derivation (2). By Lemma 4.15, \nthe existence of derivation (1) al\u00adways implies that of derivation (2). Therefore, to see whether a narrowing \nstrategy S is a total higher\u00adorder extension, we need only to check that whenever derivation (1) is in \nS(R, ~(s)=? #(t)), derivation (2) is in S(R, s=? t). Higher-order basic narrowing is a total higher-order \nextension. For, every posit ion of narrowing in deriva\u00adtions (1) and (2) corresponds to a rigid subterm \nin either the initial s=? t or the right-hand side of a rewrite rule, and s=? t and ~(s) =? #(t)have \nthe same set of positions of rigid subterms. A narrowing strategy consisting of all those higher\u00adorder \nbasic narrowing derivations where the positions of narrowing are always outermost is a total higher\u00adorder \nextension. To see this, we can check that if a position p% of narrowing in derivation (2) is not outermost, \nassuming that it is the first one which is not outermost, then the position pi in derivation (1) cannot \nbe outermost. Theorem 4.17 Let R be a TRS and P a set of uni\u00adfication pairs. A higher-order narrowing \nstrategy S is complete for R and P if S is a total higher-order extension and complete for R and 4(P). \nProof Follows from Lemma 4.15 and Definition 4.16. 0 As an instance of the above theorem, by the fact \nthat basic narrowing in the first-order setting is com\u00adplete for all confluent and strongly normalizing \nTRS S and all first-order unification pairs [15], we know that higher-order basic narrowing is complete \nfor all confluent and strongly normalizing TRS S and all (higher-order) unification pairs. 5 Termination \nof equational unifica\u00adtion A very important property of an equational unifica\u00ad tion algorithm is the \ntermination. This section in\u00adtroduces an approach to reduce the termination of a higher-order equational \nunification algorithm to that of its first-order counterpart. Let us first formulate very abstractly \nthe notions of unification process and unification algorithm. Definition 5.1 An abstract unification \nprocess is a (finite or infinite) sequence of pairs of unification problems P, and substitution sets \nS, in the form (P,, s,) =+ (P,, s,) ==$ .... An abstract unification a~go? ithm U.A is a function which \nfor every unification problem P yields a set of abstract unification processes issuing from (P, {}) such \nthat if P contains only first-order terms then 24.4(P) contains only first-order terms and substitu\u00adtions. \nAn algorithm UA is called terminating if for every P, UJI(P) contains no infinite abstract unifica\u00adtion \nprocesses. 0 To relate a higher-order equational unification algo\u00adrithm to its first-order counterpart, \nwe view all bound variables of the same type as identical. This implies that all A-binders with their \nbound variables being of the same type are viewed as identical and so are all flexible subterms with \nthe same head free variable. Definition 5.2 Let us associate each type ~ with two new function symbols \nlT and o. such that all these new function symbols are pairwise distinct. A strong abstraction ~ is a \nmapping which transforms every pattern in a topdown way as follows: @( Az.s) = /7(+(s)) +(a(~)) = ~(a)(~(sn)) \n@(l@)) = F +(z) = 0. lKf) =f where x is a bound variable of type r, a a function symbol or a bound variable, \nF a free variable and ~ a function symbol. For a substitution u, define ~(a) = {F -+(t) I F ~ ~~.-t E \no}. Strong abstrac\u00adtions of sets of patterns or of substitutions are defined componentwise. 0 For a pattern \nt, @(t) may be viewed as a first-order term. For example, if z and y are bound variables of type a, and \nz of type /3, then ~(kzy.z.z(z, F(z, y), F(y, z), y)) = la(~a(~p(op(oa, F, F, Oa)))). Definition 5.3 \nAn abstract unification algorithm UA is said to be fimt-order embedded in another ab\u00adstract unification \nalgorithm UA1 if for every unifica\u00adtion problem PI, (P,,{}) ==$ (P,, s,) ==$ . . . = UA(P1) always implies \n(@(Pi), {}) ==$ (4( P2),4(S2)) -~. ~E UA~(4(Pl)). We may now easily prove the following theorem. Theorem \n5.4 Let UA be fi? st-orde? embedded in UAI. For a unification problem P, if all abstTact uni\u00adfication \nprocesses in UAI (@(P)) are terminating then so aTe all those in UA(P). 5.1 Termination of higher-order \nnarrowing The method developed in the above will be used sev\u00aderal times in this paper. First of all, \nlet us con\u00adsider narrowing strategies as equational unification algorithms and see how to reduce the \ntermination of higher-order narrowing strategies to that of their first-order counterparts. We show first \nthat the most general unifiers are preserved by strong abstractions. Proposition 5.5 If O is a most geneTal \nsyntactic unijieT of two patterns s and t then ~(e) is a most geneTal syntactic unijieT of ~(s) and \n~(t). The preservation of the most general unifiers can be extended to narrowing derivations. Proposition \n5.6 Let R be a TRS. If $1 pl,il, ol  Pj-1,%3-19V3-1 ~ ~Pj,~j9\u00b03 is an R-namowing derivation, then so \nis #($1) --+P,,u,v(a,) Pj-l,zj-l,+(uj-l) @(sl) ... P,!~3)*(Cj) Let S1 =? tl be a unification pair. Then \nwe may view an infinite R-narrowing derivation ... $1 =? tl -Pl,%i,g, Sn=? tn-Pn-l, zn-19gw-1 ... P.,an,v. \nas an abstract unification process (sl~tl, {})s... q(sn~tn, al-ol)~ol) ~... and a finite R-narrowing \nderivation sl :tl +Pl,tl, ml . . . tipn_l,tn_l,an_l sm A tn with a being a most general syntactic unifier \nof Sn =?tm as (s, = t,, {}) * ... + (sn=?tn, an_l. ..ol) * (U (sn) =?d(tn),c7 &#38;l ...U1). Propositions \n5.5 and 5.6 say that a strong abstraction of an R-narrowing derivation is still an R-narrowing derivation \nof the same length and may also be con\u00adsidered as an abstract unification process as defined above. Let \nS be a narrowing strategy for some TRS R and some set P of unification pairs and SI a narrow\u00ading strategy \nfor R and @(P) with S being first-order embedded in S1. By Theorem 5.4 we know that for a unification \npair s =?t c 7, if S(R, ~(s)=? @(t)) is terminating, then so is S(R, s =? t). 6 Equational unification \nof free pat\u00adterns In this section we propose an algorithm for equational unification of free patterns. \nThe algorithm is com\u00adplete for every consistent equational theory. Let E be an arbitrary but fixed consistent \nequational the\u00adory. Our algorithm is in fact a revision of the one in [22] (see also Appendix A.3). The \nkey of the revision is to leave unification pairs of the form ~~.1 (ij) =? Az.1 (z) as constraints in \nthe unification process. For nota\u00adtional simplicity, the outer A-binders Xi maybe omit\u00adted, since any \nA-binders AZ such that {Z} ~ {~} U {T] can have the same effect. Let C and D range over sets of constraints. \nA substitution IS is said to E-satisfy C if a(~(~)) =,g a(# (Z)) for every l (~) =? F(Z) 6 C. Suppose \nthat a = {F * ~V.a(H~(@)} is a sub\u00adstitution with a being a function symbol or a bound variable and 111, \n. . . . ~m distinct free variables. Let C be a set of constraints. Then we use constr(a(C)) to denote \n{I&#38;(y) = Hm(z) I F(Y)= F(z) E C} u {G(z)=? G(z) e C I G + F}. For example, if C = {f (z, z, y) =? \nF(Y1 z, z), G(y, z) =? G(z, z)} and a = {F w }zyz.f(lll(z, y,z),Hz(z, y,z))}, then constr(a(C)) = {lfl(z, \nz, y) =? HI(Y, z, z), lf2(z, z,y)=?H2(y, z,z), G(y, z) =? G(z, z)}. A decorated substitution is a pair \n(u, C), which can be viewed as representing a set of instance sub\u00adstitutions ~~SE (a, C) = {pa I P ~-satisfies \nC}. Let (0, D) be another decorated substitution. We may write (a, C) ~E (6, D) if ZAfSE(~, C) ~ ZAfSE \n(6, D). Obviously, a single substitution a can be written as (cr, {}): (a, {}) 2E (8, {}) if and only \nif a ~E 6. A decorated substitution (u, C) is also called an E-unifier of a unification problem if so \nis every u e ~~SE (~, C). Our algorithm is given by four transformation rules on triples of unification \nproblems, substitutions and sets of constraints. The algorithm starts with the triple (Po, {}, {}) for \nany unification problem I . and terminates with ({}, a, C) if I . is E-unifiable, in which case the (a, \nC) is the most general E-unifier of I o. The four rules are extensions of rules (Bin), (Dee), (FF-1) \nand (FF-2) in Appendix A.3, resp. We only present two rules here in Figure 1. Other two rules can be \nobtained in a corresponding way. Intuitively, rule (Bin ) yields a partial solution for the head variable, \nand rule (FF-2 ) yields a partial solution with a constraint on the coomon head vari\u00adable. Compared with \nthe algorithm in Appendix A.3, we have one more failure case here, i.e. where a = yi with Zz # z: for \nsome F(z) =? F(%) ~ C in rule (Bin ). Theorem 6.1 There are no infinite sequences of transformations \nby the fou7 rules of OUT algo? ithm here. FOT any equational theo7y E, a f7ee unij$ca\u00adtion pToblem P \nis E-unijiable if and only if (P, {}, {}) can a!ways be transformed into ({}, u, C), whe? e (~lrvti=), \nC) is the most gene7al E-unifie? of P, Proof Use the method in Section 5 to prove the termination. First, \nour algorithm here is first-order embedded the algorithm in Appendix A.3, since some strong abstraction \nmapping @ may map each trans\u00adformation sequence here into a transformation se\u00adquence via the rules in \nAppendix A.3. Since the al\u00adgorit hm in Appendix A.3 is terminating, so is our algorithm. The proof of \nsoundness and completeness is similar to that in [22]. 7 Combining higher-order equational unification \nalgorithms In this section we consider informally the higher\u00adorder extensions of first-order combination \nalgo\u00adrithms. Only the termination property of the higher\u00adorder extensions is discussed, since experiences \nin the first-order case show that it may be a hard problem (cf. e.g. [9, 38,33, 2]). Again, our approach \nhere is to reduce the termination of the higher-order extensions to that of their underlying first-order \ncounterparts. When a combination algorithm is available, an equational unification algorithm can always \nbe ob\u00adtained by combining an equational unification for free patterns (as in Section 6) and an equational \nunifica\u00adtion algorithm for so-called pu7e patferns. Definition 7.1 A pattern is called pu7e (in an equa\u00adtional \ntheory E) if it contains no subterms of the form ({xi!.F(yJ : Az.a(G)}@P, a, c) * ({ M.Hm(~) : A7i.tm}@d(P), \n(7 (7,Cmstr(d(c))) (Bin ) if F @3V(~), a ~ CU{~}, a = y~with 1< z< n implies Z$= z; for every F(z) =? \nF(%) c C, where o = {F + A~.a(Hm(~))} with new distinct variables HI, . . . . lifm. ({F(x) ~ F(~)} @P, \nCT,C ) ==+ (o (P), a a, o (C) U {H(q) ~ H(=)}) (FF-2 ) where p,, l < i < q, are all those from {l, ..., \nn} such that yP~, ZP< 6 {~} n {z}, u = {F i-i MX.~(Yp,, . . . . YP, )} and H is a new variable. Figure \n1: Equational unification of free patterns a(~) with n > 0 and a being a free function symbol For collapse-free \nregular equational theories such as or a bound variable. A substitutions or unification AC theories, \na cycle can be detected in applying rule pair is called pure if it contains only pure patterns. 0 (Abs) \nwhen t= Jz.F(v) with F E FV(U). A cycle corresponds to a failure of unification. For example,Assume that \nsome equational theories are given, the unification pair }zy.G(z) + f(F(y)) =? ~zy.F(z) which are disjoint \nin the sense that no function sym\u00adwith + being an AC and $ free function symbol is bols occur in more \nthan one theory. If a term is not AC-unifiable, since F occurs both in the right\u00adpure in none of the \nequational theories, it can be hand side at the outermost level and in the subterm decomposed into pure \nones. For doing this, every f(F(z)) of the left-hand side. atomic symbol in the term should be given \nan equa\u00adtional theory in the following way: First of all, every A higher-order combination algorithm \nfor collapse\u00adfunction symbol is either free or already belongs to free regular equational theories can \nin fact be ob\u00adan equational theory. Then bound variables and }\u00ad tained by repeating rule (Abs) with the \ndetection of binders are always treated as free function symbols. cycles and the application of given \nequational unifica-For notational simplicity, all free function symbols tion algorithms just as in the \nfirst-order case ([9, 38]). are assumed to belong to a trivial equational theory Note that the notion \nof decorated substitution may .EO = {}. So free patterns are pure in Eo. Note that have to be used (cf. \n[30]). But it can be dealt with lJo is disjoint to all other equational theories. in a natural way as \nin Section 6. The higher-order combination algorithm as above is always terminat-Those patterns, which \ncontain function symbols be\u00ading since the strong abstract mapping as defined in longing to different \nequational theories, maybe trans-Section 6 maps all its unification processes into unifi\u00adformed by rule \n(Abs) formulated as follows: cation processes of some underlying first-order com\u00adbination algorithm in \n[9, 38] and the first-order com\u00ad{s[u] = t} u P =%; bination algorithm is terminating. {s[H(lZ)]p =? t, \nAllX.H(G) =? Aw.u} u P We may also build a higher-order combination al\u00adif u is a maximal rigid subterm \nof a base type in s gorithm for arbitrary equational theories by naturally such that H(u) and H(s) or \n%(u) and ?f(i) belong to extending the first-order combination algorithms in different equational theories, \nwhere Ayl,.. ., Aym are [33, 2]. At the moment we see no serious problems in all A-binders in S[U] covering \nu. the higher-order extensions. The strong abstraction mapping reduces the termination of the extensions \ntoIn order to completely understand the compact that of the first-order combination algorithms [33, 2]. \nform of the above rule, we should mention that, due to the well-typedness of a pattern, a subterm of \nthe form Ax .s cannot be directly covered by a function 8 Conclusion symbol belonging to some given (first-order) \nequa\u00adtional theory, since kc.s is of a function type. We have shown in this paper that the notion of \nRepeatedly applying the above rule will eventually higher-order patterns is the key to connect first\u00adyield \nsome unification pairs that are pure in a certain order equational and higher-order logic programming. \nequational theory E. The given equational unifica-Three essential aspects in building higher-order equa\u00adtion \nalgorithm for the theory E may be then used to tional unification have been considered: higher-order \nunify these pure unification pairs. narrowing, unification of free patterns in the pres\u00adence of equations \nand combination of higher-order tion and confluence. In PTOC. 16th Int. Coil. equational unification \nalgorithms for special equa-Automata, Languages and Programming, pages tional theories. The results cover \na large part of the 137-150. Springer-Verlag LNCS 372, 1988. whole spectrum of higher-order equational \nunification [5] V. Breazu-Tannen and A. Meyer. Computabledue to their formulations at an abstract level. \nOnly values can be classical. In PTOC. Ilth ACMproblems of higher-order extensions are considered Symp. \nPrinciples of PTogTamming Languages,and details for the existing first-order approaches are pages 238-245. \nACM, 1987. avoided whenever possible. What is missing in this paper is the development [6] D. DeGroot \nand G. Lindstrom (eds.). Logic Pro\u00adof higher-order equational unification algorithms for gramming: Relationsl \nFunctions and Equations. pure patterns in special equational theories. Combi-Prentice Hall, 1986. nation \nalgorithms may use these special algorithms [7] N. Dershowitz and D. Plaisted. Logic program\u00adin building \nalgorithms for arbitrary patterns and for ming cum applicative programming. In PTOC. combined theories. \nAlthough general equational uni\u00ad1985 Symp. on Logic PTogTamming, pages 54 fication algorithms for arbitrary \nsimply typed A-terms 67. IEEE Comput. Sot. Press, 1985. and arbitrary equational theories have been \nproposed in [24, 29], where first-order equational unification al\u00ad [8] D. Dougherty and P. Johann. A \ncombinatory gorithms are called as parameters, it seems difficult logic approach to higher-order E-unification. \nIn for us to build a similar algorithm just for patterns, PTOC. Ilth Int. Conf. on Automated Deduction, \nwhich behaves closely to the called first-order unifi\u00adpages 79-93. Springer-Verlag LNCS 607, 1992. cation \nalgorithms. Therefore, equational unification algorithms for pure patterns in special equational the-[9] \nF. Fages. Associative-commutative unification. ories might have to be developed individually. See In \nR. Shostak, editor, Proc. 7th Int. Conf. Au\u00ad [30] for such an algorithm in AC theories. tomated Deduction. \nSpringer-Verlag LNCS 170, 1984. Another possible future direction would be to con\u00adsider higher-order \nconditional narrowing by extending [10] L. Fribourg. SLOG: A logic programming lan\u00ad the results in the \nfirst-order case (cf. e.g. [14, 16, 18]). guage interpreter based on clausal superposition From the \nsemantic point of view, model theoretic se\u00adand rewriting. In PTOC. 1985 Symp. on Logic mantics still \nneed to be studied. The work by Breazu-Programming, pages 172 184. IEEE Comput. Tannen and Meyer [5, \n3] might be a good starting Sot. Press, 1985. point. [11] J. Gallier and W. Snyder. Complete sets of \ntrans- ACKNOWLEDGEMENT formations for general E-unification. Theoretical ComputeT Science, 67:203-260, \n1988. We sincerely thank Claude Kirchner for helpful dis\u00adcussions and Dale Miller for useful comments \non the 12] E. Giovannetti, G. Levi, C. Moiso, and paper. C. Palamidessi. Kernel-LEAF: A logic plus func\u00ad \n tional language. J. Computer and System Sci-References ences, pages 139 185, 1991. [1] F. Baader and \nJ. Siekmann. Unification the-13] M. Hanus. Compiling logic programs with equal\u00adory. In D. Gabbay, C. \nHogger, and J. Robinson, it y. In PTOC. Int. WoTkshop on Language Imple\u00adeditors, Handbook of Logic in \nArtificial Intelli-mentation and Logic Programming, pages 387 gence and Logic Programming. Oxford Univer-401. \nSpringer-Verlag LNCS 456, 1990. sity Press, Oxford, UK, 1993. To appear. [14] S. H611dobler. Foundations \nof .Equationa/ Logic [2] A. Boudet. Combining unification algorithms. J. Programming. Springer-Verlag \nLNCS 353, 1989. Symbolic Computation, 11,1992. [15] J.-M. Hullot. Canonical forms and unification. [3] \nV. Breazu-Tannen. Combining algebra and In W. Bibel and R. Kowalski, editors, Proc. 5th higher-order \ntypes. In PTOC. 3rd IEEE Symp. Int. Conf. Automated Deduction, pages 318-334. Logic in Computer Science, \npages 82 90, 1988. Springer-Verlag LNCS 87, 1980. [4] V. Breazu-Tannen and J. Gallier. Polymorphic [16] \nH. Huf3mann. Unification in conditional\u00adrewriting conserves algebraic strong normaliza-equational theories. \nIn Proc. European Conf. on Computer Algebras, pages 543 553. Springer-Verlag LNCS 204, 1985. [17] J.-P. \nJouannaud and C. Kirchner. Solving equa\u00adtions in abstract algebras: A rule-based survey of unification. \nIn J.-L. Lassez and G. Plotkin, editors, Computational Logic: Essays in Honor of Alan Robinson. MIT Press, \n1991. [18] S. Kaplan. Simplifying conditional term rewrit\u00ading systems: Unification, termination and con\u00adfluence. \nJ. Symbolic Computation, 4(3):295-334, 1987. [19] A. Middeldorp and E. Hamoen. Complete\u00adness results \nfor basic narrowing. In Proc. 3Td Int. Conf. on Algeb? aic and Logic Programming, pages 244-258. Springer-Verlag \nLNCX 632, 1992. A long version to appear in the journal of Ap\u00adplicable Algebra in Engineering, Communication \nand Computing. [20] D. Miller. A logic programming language with lambda-abstraction, function variables, \nand sim\u00adple unification. Jou? nal of Logic and Computa\u00adtion, 1(4):497 -536, 1991. [21] J. Moreno-Navarro \nand M. Rodriguez-Artalejo. BABEL: A functional and logic programming language based on constructor discipline \nand narrowing. In PTOC. 2th Int. Conf. on Alge\u00adbraic and Logic Programming, pages 223-232. Springer-Verlag \nLNCS 343, 1989. [22] T. Nipkow. Higher-order critical pairs. In PTOC. 6th IEEE Symp. Logic in Computer \nScience, pages 342-349, 1991. [23] T. Nipkow. Functional unification of higher\u00adorder pat t ems. In PTOC. \n8th IEEE Symp. Logic in Computer Science, pages 64 74, 1993. [24] T. Nipkow and Z. Qian. Modular higher-order \nE-unification. In R. Book, editor, PTOC. lth Int. Conf. Rewriting Techniques and Applica\u00adtions, pages \n200-214. Springer-Verlag LNCS 488, 1991. [25] L. Paulson. Isabelle: The next 700 theorem provers. In \nP. Odifreddi, editor, Jogic and Com\u00adputer Science, pages 36 1 385. Academic Press, 1990. [26] L. Paulson. \nIntroduction to Isabelle. Techni\u00adcal report, University of Cambridge, Computer Laboratory, 1993. [27] \nF. Pfenning. Logic programming in the LF log\u00adical framework. In G. Huet and G. D. Plotkin, editors, Logical \nI+ameworks, pages 66-78. Cam\u00adbridge University Press, 1991. [28] Z. Qian. Linear unification of higher-order \npat\u00adterns. In J.-P. J. M.-C. Gaudel, editor, PTOC. TAPSOFT 93, pages 391-405. Springer-Verlag LNCS 668, \n1993. [29] Z. Qian and K. Wang. Higher-order E\u00adunification for arbitrary theories. In PTOC. 1992 Joint \nInt. Conf. and Symp. on Logic Program\u00adming. MIT Press, 1992. [30] Z. Qian and K. Wang. Modular equational \nunification of higher-order patterns: The AC case. Technical report, Draft, Universitat Bre\u00admen, June \n1993. [31] U. Reddy. Narrowing as the operational seman\u00adtics of functional languages. In PTOC. 1985 Symp. \non Logic Programming, pages 138 151. IEEE Comput. Sot. Press, 1985. [32] P. R6ty, C. Kirchner, H. Kirchner, \nand P. Les\u00adcanne. NARROWER: A new algorithm and its application to logic programming. In PTOC. 1st Int. \nConf. Rewriting Techniques and Applica\u00adtions, pages 141-157. Springer-Verlag LNCS 256, 1985. [33] M. \nSchmidt-Schaut3. Unification in a combina\u00adtion of arbitrary disjoint equational theories. J. Symbolic \nComputation, 8:51-99, 1989. [34] W. Snyder. Higher-order E-unification. In PTOC. 10th Int. Conf. Automated \nDeduction, pages 573-587. Springer-Verlag LNCS 449, 1990. [35] M. van Emden and K. Yukawa. Logic program\u00adming \nwith equality. J. Logic Programming, pages 265-288, 1987. [36] F. Weber. Softwareentwicldung mit Logik \nhoe\u00adhe? e? Stufe. PhD thesis, FZI, Universitat Karl\u00adsruhe, 1993. [37] D. Wolfram. Rewriting, and equational \nunifica\u00adtion: the higher-order cases. In R. Book, edi\u00adtor, PTOC. lth Int. Conf. R.ewTiting Techniques \nand Applications, pages 25 36. Springer-Verlag LNCS 488, 1991. [38] K. Yelick. Unification in combinations \nof collapse-free regular theories. J. Symbolic Com\u00adputation, 3:153-181, 1987. [39] J.-H. You. Unification \nmodulo an equality theory for equational logic programming, J. Computer and System Sciences, pages 54 \n75, 1991. A Appendix  A.1 The simply typed J-calculus A term of the form (s -t) is called an application \nand Ax.s an abstraction. The topmost part Ax in Ax.tis called a A-binder of z, It is assumed that no \nterms may contain Ax more than once, unless stated other\u00adwise. Every symbol in tof ~x.t is said to be \ncovered by or in the scope of kc. In a(ul, . . . . Un) the subterms U1 , . . . . u~ are called arguments \nof a, and symbols in U1, . . ., u~ are said to be covered by or in the scope of a. Terms are only compared \nmodulo a-conversion. The /3-normal form s is called flexible if fi(s) is a free variable, rigid if not. \nIf t is a pattern and u a substitution containing only patterns, then a(t)lp is a pattern. In the sequel, \nall terms are patterns unless stated otherwise. Positions are strings of numbers, denoted by p, q, and \nconcatenated by . . The empty string is denoted by c. Subterms of a pattern may be numbered by positions \nsuch that (i) tlc = kz.tll.p t,(ii)= tlpand (iii) (a(w)li.P = (t;)lP for 1< i <k. We write p < q if there \nis p! such that p. p = q. If neither p < q nor q < P, we say that p and q are independent. A.2 Equational \ntheories An algebraic term (or $? st-order term) is a pattern of a base type, which is either a free \nvariable or of the form ~(~) with n ~ O, ~ being a function symbol and each Si an algebraic term. The \nR-rewriting ~~ is the smallest relation such that (i) a(l) ~~ o(r) for all substitutions a and all 1~rcR,and \n(ii) s~~ t implies (u s) ~~(u t), (s u) ~~(t u) and kc.s -+~ k.t. For example, Ay.f(y) -+~ Ay.g(y) if \n~(X) -i g(X) ~ R. A TRS R is called consistent if X =R Y does not hold for distinct free variables X \nand Y. A TRS R is called confluent if for every u ~~s and u ~~ t there is a term v with s~~ v and t+; \nV. For a confluent R, we may write ~~ ~ -for =R. A pattern s is R-normal if there is no pattern t with \ns dR t. A pattern s is R-formalizable if there is a &#38;!-normal pattern t with s -~ t. A substitution \no is R-normal or R-formalizable if so is a(X) for all X G D(a). A TRS R is weakly normalizing if every \npattern is R-normalizable. A TRS R is strongly nor\u00admalizing if there are no infinite rewriting derivations \ntl_+Rt2+R ---- An equational theory E can always be considered as a confluent TRS {1--+ v,r~l I 1 z \nr c Ej, Fur\u00adthermore, E is called reguiav if each ! = r E E sat\u00adisfies ~~(z) = ~~(T), E is called coilapse-free \nif no equation i z r E E satisfies 1c V and T # V. A substitution u is called idempotent if co =R CT. \nA substitution is idempotent whenever Z2(IY) fl~(a) = O. Let W be a set of free variables such that there \nare still infinite many free variables not in W. If W ~ D(u) then there always exists u such that D(d) \nfl ~(a ) = 0, D(a) = D(a ), a ~R a [w] and u ~R a [W]. Note that a is idempotent. It suffices to consider \nthe substitutions like u . An R-unifier of a unification problem P is a sub\u00ad stitution 6 such that O(s)lp \n=R 6(t)Jp for each s =? tG P. Let W be a set of free variables such that there are still infinite many \nfree variables not in W. A set U of R-unifiers of P is said to be complete w.r.t. W if for every R-unifier \nO there is u ~ U such that a ~R d [W]. We may write such U as Ctl?4~(P)[W]. It is always assumed that \nfor each o E CSUR(.P)[W], D(a) ~ FV(P) and Z(a) rl (D(a) U W) = 0 where W contains all free variables \nthat have been used be\u00adfore, i.e. the free variables in T(o) are always fresh variables. A.3 Syntactic \nunification of patterns Miller was the first to present an algorithm for syn\u00adtactic unification of patterns \n[20]. Here we slightly revise the Nipkow s algorithm [22] and give an algo\u00adrithm consisting of four transformation \nrules on pairs of substitutions and unification problems. The rules are shown in Figure 2, where unification \nproblems are viewed as lists instead of multisets of unification pairs and @ denotes the concatenation \noperation of lists. The transformation starts with the pair (p, {}) for any unification problem P and \nterminates with ({}, a) if P is unifiable, in which case CTis the most general unifier of P. Intuitively, \nrule (Bin) finds a partial binding for a head variable, rule (Dee) breaks a unification pair into simpler \nones, rule (F F-1) finds a unifier of two flexible patterns with distinct heads, and rule (FF-2) finds \na unifier of two flexible patterns with the same head. Inversing the preconditions to the rules in Figure \nyields the following failure cases. The first case, called ciash, is the case a # b in rule (Dee). The \nsecond case, called cycle, is the case F E FV(z) in rule ({/mF(jj) AW.a(q}tw, o-) =$ ({ AzHm(y) 2 A?F.tm}Kw(P), \nda) (Bin) if F @ 7V(Z) and a E CU {~} where HI). ... Hm are new variables and a = {F ~ AV.a(Hm(~))}. \nifa,6EC U{ Z}, a= ({~~.a(~) b(and thus ~ A5.b(~)}@LP, n= m). 0) =+ ({ AZ.Sn ~ AE.tn}@P, a) (Dee) if F \nnew and free G are distinct variable. free ({ AE.F(Y) variables, 4 XE.G(Z)}QP, where u = {F o) ==+ (u \n(P), + Av.H(ti), G a u) w ~Z..H(T)}, {T} = {~} n {z} and (FF-1) H is a where u = {F R Az.H(~)}, ({ Az.F(G) \n{ti} = 3 Jz.F(z)}@P, o) = (o (P), {y, I y~ = z,, 1 < i < n} and H is Figure 2: Unification of patterns \na a) a new free variable. (FF-2) (Bin). The third case, called bound variable capture, is the case a \nE {Z} {~} in rule (Bin). Theorem A.1 There are no injinite sequences of transformations by the rules \nin Figure 2. A unifi\u00adcation problem P is syntactically unifiable if and only if every sequence of transformations \nstarting with (P, {}) terminates with ({}, a), in which case 017V(P) is a most general syntactic unifier \nof P. B Appendix Proof of Lemma 4.13. ~: Assume s -+P,i,e t. Then there is a variant ~~.u -+ ~~.v such \nthat 6(A~.u) = }ZZ.slP and t = SIO(V)]P. BY Lemma 4.12, #(@)( #(u)) = #($IP) and @(t) = @(s)[#(@)(#(v))]P. \nSince Aw.u = ~~.v is a variant of a rewrite rule in R over ~, ~(u) ~ ~(v) is a variant of the same rule. \nHence 4(s) +P,,,~(eJ ~(t). ~: Assume that #(s) --+P,.,a q+(t).Then there is a variant 1 -+ r in the first-order \ncase such that o(i) = #(s)lP and #(-t) = q$(s)[a(~)]p. Assume D(a) G FV(l) and Z(a) ~ FV(I#J(S)). Let \n~Yl, .-. , ~yk be all ~-binders in ~(s) covering the position p. Let XV(J + r) = {~}. Without loss of \ngenerality, we may assume that ZA ~ is so chosen that for each vari\u00adable Xi, #J (Xi ) is of the form \nH;(~). Construct a variant ~~.u ~ ~~.v from i -T as required in Defin\u00adition 4.1, where each Xi is replaced \nby Ht(yk ). Con\u00adstruct a substitution 6 = {Hi H Am.q$-l(u(X, )) I 1< i < n}. Then 8(u) = ~-l(a(l)) = \n#-l(#(s)\\p) = Slp and O(v) = # l(a(r)) = &#38;l(#(t)p)= tp.Hence s +P,z,e S[e(v)]p = S[tp]p = t. 0 To \nprove the second claim of Lemma 4.15, we need the following lemma, which lifts the relationship be\u00adtween \na rewrite and narrowing step in the first-order case to the higher-order setting. Indeed, the following \nlemma is a natural higher-order extension of the one in [19] except a subtle change in the requirement \n(v). The change is because the lemma in [19] is based on the fact that two unifiable first-order terms \ns and t that contain no common free variables always have a most general syntactic unifier a with D(0) \nIU(C) = {} and D(u) U Z(o) = 3V(S, t), while an analogous fact does not hold in the higher-order setting. \nA most gen\u00aderal syntactic unifier in the higher-order setting may have to introduce new free variables, \neven in the case when the patterns to be unified contain no common free variables [20, 22]. Lemma B.1 \nLet R be a TRS. Suppose we have a pattern s, a no? maiized substitution @ and a set W of free variabies \nsuch that 5V(S) U 2)(6) ~ W. If 9(s) +P,, t holds, then there exist a pattern s and substitutions v, \n0 such that (i) s -+P,i,c s , ( ii) 0 (s ) = t , (iii) @ a = 6[W], (iv) 6 is normalized and ( v) Fv(s \n) uD(e ) g w -D(a) uz(a,~). Proof Similar to that in [19]. 0 Now we continue to prove Lemma 4.15. Proof \nof 4.15 (continued): By using an induction on n in each line, we may prove as follows: Derivation (1) \n~(~)(d(s)) =? 4(@)(f#(~)) +P,,i,  +pn,zn ~ =? ~ by Lemma 4.5 q$(o)(q$(s)) = ~(o)(~(t)) #(s ) = #(s ) \n+Pl,%l  +Pm,an by Lemma 4.14 e(s) =? e(t) 4P,,;, . . . +Pn,,m v =? v by Lemma 4.13 Derivation (2) for \nsome a with c+(u) = u (v) A dc7n 0.. ml ~R 6 [~~(s,t)] by Lemma B. 1 1 \n\t\t\t", "proc_id": "174675", "abstract": "<p>Higher-order equational logic programming is a paradigm which combines first-order equational and higher-order logic programming, where higher-order logic programming is based on a subclass of simply typed &#955;-terms, called higher-order patterns. Central to the notion of higher-order equational logic programming is the so-called higher-order equational unification. This paper extends several important classes of first-order equational unification algorithms to the higher-order setting: only problems of the extensions are discussed and first-order equational unifications are viewed as black boxes whenever possible.</p><p>We first extend narrowing and show that the completeness of many higher-order narrowing strategies reduces to that of their underlying first-order counterparts. Then we propose an algorithm or higher-order equational unification of free higher-order patterns in an arbitrary equational theory. Finally a general approach to extend first-order unification combination algorithms is sketched informally. The termination property of the above higher-order extensions is considered in a uniform way.</p>", "authors": [{"name": "Zhenyu Qian", "author_profile_id": "81100414350", "affiliation": "FB 3 Informatik, Universit&#228;t Bremen, D-28334, Bremen, Germany", "person_id": "PP14146771", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/174675.177889", "year": "1994", "article_id": "177889", "conference": "POPL", "title": "Higher-order equational logic programming", "url": "http://dl.acm.org/citation.cfm?id=177889"}