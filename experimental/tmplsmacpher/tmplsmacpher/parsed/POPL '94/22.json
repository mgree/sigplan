{"article_publication_date": "02-01-1994", "fulltext": "\n Detecting Pipeline Structural Hazards Quickly Todd A. Proebsting University of Arizona  Introduction \n Most modern CPUS pipeline instructions. When two instructions need the same machine resource like a \nbus, register or functional unit at the same time, they suffer a structural haz\u00ad ard, which stalls the \npipeline or corrupts a re\u00ad sult. Compilers order or schedule instructions to cut structural hazards. \nA fundamental step in scheduling is detecting if a series of instructions suffers a structural hazard. \nThis paper describes a method for detecting structural hazards 5 80 times faster than its pre\u00ad decessors, \nwhich generally have simulated the pipeline at compile time. It accepts a compact specification of the \npipeline and creates a finite\u00ad state automaton that can detect structural haz\u00ad ards in one table lookup \nper instruction. The automaton maintains an integer state that encodes all potential structural hazards \nfor all instructions in the pipe. It accepts an instruc\u00ad tion type and a state and either reports a haz\u00ad \nard or produces the state that folds in the new instruction and advances the pipeline by one cy\u00ad *Address: \nTodd A. Proebsting, Department of Com\u00ad puter Science, University of Arizona, Tucson, AZ 85721. Internet: \nt oddQcs. arizona. edu t Address: Christopher W. Fraser, AT&#38;T Bell Labo\u00ad ratories, 600 Mountain \nAvenue 2C-464, Murray Hill, NJ 07974-0636. Internet: cwf @research. att. com Permkrsion to copy without \nfee all or part of this material is granted provided that the copies are not made or distributed for \ndirect commercial advantaae, the ACM copyright notice end the title of the publication end its date eppear, \nand notice is given thet copying la by permission of the Association for Computing Machinery. To copy \notherwise, or to republish, requires a fee and/or epecific permission. POPL 94-1194, Portfand Oragon,USA \n@ 1994 ACM 0-69791-636-0/94/001 ..$3.50 Christopher W. Frasert AT&#38;T Bell Laboratories cle. The automaton \ncan be implemented with a two-dimensional array. An implementation of the method below gen\u00aderates practical \nautomata quickly. For example, a 33mhz MIPS R3000 generates a 6175-state au\u00adtomaton for the MIPS R3000/R3010[8] \nin five seconds. This architecture has only 14 distinct instruction classes with respect to creating \nstruc\u00adtural hazards, so the automaton s table takes only 14 x 6175 two-byte entries. Contrast this with \nthe t heretical upper bound of 222 37 states for the MIPS R3000/R3010. Such automata will speed up current \ninstruc\u00adtion scheduling heuristics and allow compilers to try more schedules. Profilers that count cycles \nlike pixie[13] and qp[2] could use it too. We use an algorithm described in 1975[5], but the prior literature \ndescribes neither implemen\u00adtations nor measurements, perhaps because the defining paper attacked a variant \nproblem that needed much larger 3D tables. We show that smaller 2D tables suffice for typical schedulers, \nwe prove that the automata are minimal, and we describe an implementation and experiments. 2 Background \nSome schedulers detect structural hazards by recording the instructions in the pipe and when each was \nissued[9]. When the next instruction is proposed, the scheduler compares each instruc\u00adtion in the pipe \nwith the proposed instruction and objects if there is a hazard. The compari\u00adson code is machine-specific. \nIf the architecture is complex, so is the code. Instruction Resources needed cycle O cycle 1 cycle 2 \ncycle 3 cycle 4 cycle 5 cycle 6 mov. s EX add. s u S+A A+R R+S mul. s u E+M M M N N+A R Figurel: R4000 \nSubset Resource Resources needed Vector 0123 456 Empty state 0000 000 add. s u S+A A+R R+S o @ @ Combined \nvectors U S+A A+R R+S @ @ g Shifted state S+A A+R R+S @ 000 Figure 2: Issuing add. s into an empty pipe. \nResource Resources needed Vector o 1 2 3 456 Previous state S+A A+R R+S 0 000 add. s u S+A A+R It+S O@@ \nCombined vectors S+A+U I hazard on A hazard on R I R+S o@@ Figure 3: Issuing subsequent add. s into pipe. \n Other structural-hazard detectors use reserva\u00adtion tables [5] or resource vectors [3, 4] instead. The \nvector is indexed by a cycle number, and each element records the resources needed dur\u00ading that cycle. \nThere is one resource vector for each distinct class of instructions and another that composes the vectors \nof all instructions al\u00adready in the pipe. To schedule an instruction, the scheduler compares its resource \nvector with the composite vector for the instructions already in the pipe. If both vectors show a need \nfor the same resource at the same time, a structural haz\u00adard is reported. Otherwise, the resources from \nthe instruction s vector are incorporated into the composite. Then the composite vector is shifted one \ncycle forward to simulate issuing the new in\u00adstruction. Figure 1 describes three instructions from the \nMIPS R4000 floating point unit (FPU). For ex\u00adample, add. s requires exclusive access to the U (for unpack \n) stage in cycle O, the S (for shift ) and A (for adder ) stages in cycle 1, A and R (for round ) in \ncycle 2, and R and S in cycle 3. Ta\u00adbles 8-7 and 8-8 in Reference [8] elaborate. To illustrate resource \nvectors, we issue two add. s instructions into an empty pipe. The first causes no structural hazard. \nCombining the ini\u00adtial empty vector with add. s s and shifting it one cycle forward yields the next state \ns resource vector. Figure 2 demonstrates this combination. Later instructions must respect these reserva\u00adtions. \nThe second add. s (Figure 3) causes a struc\u00adtural hazard when issued in this state. The first add. s \nneeds A in its third cycle, and after the first add. s issues, this reservation appears in the com\u00adposite \nvector s second cycle. The second add. s needs A (and S) in its second cycle, which causes a hazard. \nThere s another hazard on R one cycle later.  3 The LDSTP Automaton In 1975, Davidson, Shar, Thomas, \nand Patel (here abbreviated DSTP ) [5] proposed to use resource vectors to compute an automaton. The \nautomaton would accept integers representing an instruction class i, a cycle count c, and a pipeline \nstates. If the pipeline is in states, and if c cycles later, i could be issued without structural haz\u00adard, \nthe automaton would produce the integer that encodes the new pipeline state; otherwise, it would report \na hazard. The automaton could be represented as a single 3D table. The DSTP automaton has been underused. \nThe literature includes few citations[12, 1, 7, 6, 10] mostly surveys and describes no imple\u00admentations \nor measurements. One explanation is table size. For example, we implemented the method and found that \nit gen\u00aderates 6175 states for the MIPS R3000. This ma\u00adchine has 14 instruction classes and instructions \nthat take up to 37 cycles, so the 3D table would have 6175 x 14 x 37 or over 3.1 million two-byte entries. \nThe table s not sparse, so sparse matrix encodings wouldn t help. DSTP S application needed the whole \ntable, but many schedulers do not. (DSTP S applica\u00adtion required the 3D table in order to find the minimum \naverage latency of a given sequence of instructions and the cycles that contribute to that latency a \nspecial-purpose scheduling ob\u00adjective.) A typical scheduler might run down a prioritized list of ready \ninstructions and schedule the first one for which the automaton reports no hazard for the current pipeline \nstate. If all ready instructions suffer a hazard, then the scheduler might issue a nop. The scheduler \ncan thus get by with only the 2D slice of the 3D table for which c is 1. This observation drops the R3000 \ntable to 6175 x 14 or 86,450 two-byte entries. The sim\u00ad plified DSTP automaton is practical for current \npipelined microprocessors. DSTP S table constructor, adapted to 2D ta\u00adbles, works as follows. It represents \neach state S internally as a 2D table of Boolean values. S[1, t] is 1 if and only if instruction 1 suffers \na structural hazard if issued t cycles after the machine enters state S. States are computed using collision \nmatrices, which record when instructions collide. The col\u00adlision matrices are computed into a 3D table, \nM, of Boolean values. kf[~A, 1~, t] is 1 if and only if issuing ~~ t cycles after issuing 1A causes a \nstructural hazard. The slice ikf[lA] is 1A s col\u00adlision matrix. Collision matrices are computed using \nresource vectors: if % such that l~[k+t]nlB[k]#@ otherwise where I[t]denotes the set of resources that \nin\u00adstruction 1 uses at time t. The sample machine above yields these collision mat rices: 1A IB t 123456 \nadd. s add. s 110000 mov. s 000000 mul. s 000000 mov. s add. s 000000 mov. s 000000 mul. s 000000 mul. \ns add. s 001100 mov. s 000000 mul. s 110000 For example, the leftmost 1 in the top row in\u00addicates that \none add. s instruction must not fol\u00adlow another by exactly one cycle. The adjacent 1 indicates that the \ntwo add.s s also colIide if sep\u00adarated by exactly two cycles. Note that mov. s collides with nothing. \nIf a machine is in state S, and S[1, 1] is O, then instruction 1 may be issued immediately with a transition \nto state S . To compute the matrix for S , S is shifted one cycle forward (to reflect the passage of \nthe issuing cycle) and combined with 1 s collision matrix, A4[l] (to reflect the subse\u00ad quent potential \nhazards introduced by 1): S [J,t] = S[J,t + 1] v MII, J, t] (The original DSTP algorithm allowed an in\u00adstruction \nto be issued after an arbitrary number of cycles, k. Under this model, for every k such that S[1, k] \n= O, substitute t+ k for t+ 1 in mov. s mul. s mov. s ( ) mov. s, adds \\ mov. h mOv. s/ .... ~ Figure4: \nFinite Automaton the equation and create S:. Transitions for this tural hazards. To prove this, it is \nsufficient to automaton were labelled with both 1 and k.) show that some sequence of input instructions \ndistinguishes every pair of different states. A nop The automaton is built as follows. Beginning instruction \nhas a collision matrix of all O s (that with the empty start state (a matrix of all O s), is, Jf[nop, \n1, t] = 0, VI, t) and all other instruc\u00adall instructions are issued, producing new states. tions collision \nmatrices are all O with respect toFor each state, S, an instruction 1 is issued if issuing a nop (that \nis, M[l, nop,~] = o,VI, ~). S[1, 1] = O. The combining rule above forms a The DSTP algorithm guarantees \nthat each statetarget state, S . If S has not been created be\u00adrepresents a unique matrix of 1 s and 0 \ns. As\u00adfore, it is added to the automaton, as is a transi\u00adsume, without loss of generality, that S. and \nS ution from S to S on 1. Otherwise, the previously differ because S3[1, t] = 1 and SY[l, t] = O for \ncreated identical matrix (state) is the target of some 1 and t. If t 1 nop s are issued to eachthe transition. \nThis process terminates when all state, the new states, S: and S;, will have thepossible instructions \nhave been issued from all properties that S~[l, 1] = 1 and S$ [1,1] = O be\u00adstates. A state lacks a transition \non a particular cause the combining rule above simply shifts eachinstruction (because S[1, 1] = 1) when \na struc\u00adstate by one cycle and combines it with the nop stural hazard exists. empty collision matrix. \nS: [1, 1] = 1, so S: has no This algorithm yields the automaton in Fig\u00adtransition on 1. SJ does have \na transition on 1, so ure 4 for the sample machine. The empty start t 1 nops followed by instruction \n1 distinguishes state is on the left. The transition from that SO and S u. Thus any two distinct states \ncreated state on add.s, for example, shifts the start by the DSTP algorithm are distinguishable, and \nstate s bits one position left and then ors in the automaton must be minimal. add. s S colkkm matrix. \nSimilarly, the transi\u00adtion from the target state on mul. s shifts that An alternative automata generator \nhas been state s bits one position left and then ors in described recently [n]. It generates minimal \nau\u00ad mul. s s collision matrix. tomata with heuristics and a postpass mini- The algorithm above creates \na minimal finite mizer. Our adapted DSTP algorithm generates state automaton for machines with a nop, \nwhich minimal automata directly and appears to do so is an instruction that participates in no struc-significantly \nfaster than this alternative. Fewer Instruction Classes For example, The size of the automaton s transition \ntable is reduced primarily by reducing the number of states, but reducing the number of instruction classes \nhelps too. Many instructions share re\u00adsource vectors. For example, addition instruc\u00adtions generally have \nthe same resource vectors as subtraction instructions. Combining like in\u00adstructions into classes reduces \nthe over one hun\u00addred R3000/R3010 instructions modelled to 20 classes. We also combine instruction classes \nthat are identical with respect to the generated collision matrices. Two instructions, A and 1?, are \ncom\u00adbined if and only if M[A, 1, t] = M[B, 1, t] and &#38;l[l, A, t] = Ii/q], B,t] Vl,t. Instructions \nwith distinct resource vectors can generate the same collision matrices, because the resource vector \nidentifies the resources that cause the conflict, but the collision matrix records only that there is \na conflict. This optimization re\u00adduces the 20 R3000/R3010 instruction classes above to 14. 5 An Implementation \nAn automaton compiler has been implemented as part of a larger system, RPS S (Retcwgetalde Pipeline Scheduling \nSubstrate), which is under development. RPSS accepts a compact, formal specification of a pipelined machine \nand emits the machine-specific part of an instruction sched\u00aduler. It produces routines for detecting \ncontrol and data hazards as well as an automaton to de\u00adtect structural hazards. RPSS attacks more than \njust structural haz\u00ad ards, so its specifications include material be\u00adyond the scope of this paper. Eliminating \nthis extra material leaves just a list of resource vec\u00adtors, one per instruction class. Blanks separate \nvector elements, and + s separate resources used during a single cycle. The suffix n flags stages that \nare repeated for n consecutive cycles. Multi\u00adple instructions may share the same description. u S+A A+R \nR+s . add. s U A R D-27 D+A D+R D+A D+R A R. div. d describe the R4000 instruction classes that add. \ns and div. d exemplify. Text accompanying Fig\u00adure 1 in Section 2 described some of the resources named \nabove, and Tables 8-7 and 8-8 in Refer\u00adence [8] describe them all. Appendices A and B contain specifications \nfor the R4000 FPU and the R3000/R3010; they present only the material relevant to struc\u00adtural hazards. \nRPSS cannot model variable\u00adlength instructions (e.g., the R4000 s sqrt. d), so the specification must \nchoose a single pipeline description typically minimum, max\u00adimum or average instruction length and au\u00adtomaton \nclients must accept approximate an\u00adswers for those few instructions whose length cannot be predicted. \nThe R4000 spec in Ap\u00adpendix B uses the maximum length sqrt. d to maximize generated states. To create \na structural hazard detection au\u00adtomaton, a 500-line Icon program preprocesses the specification into \ninitialized C data struc\u00adtures describing the pipeline. Bit vectors en\u00adcode the resources used in each \ncycle. One\u00addimensional arrays of these blt vectors encode resource vectors. The automaton compiler results \nfrom link\u00ading this data module with 300 lines of C that construct an automaton. A 33mhz R3000 con\u00adstructed \nautomata for the R3000/R3010 and for the R4000 FPU in under five seconds each. The table below describes \nthe automata sizes. The theoretical maxima are huge. For a machine with r resources, there are 2 possible \nvalues for each element of each resource vector; if its longest pipeline has n stages, then there could \nbe as many as 2rxn possible resource vectors or states. R4000 FPU R3000/R3010 variant classes states \nclasses states 15 29x112 20 222x37 theoretical maximum 15 2665 14 6175 actual  int tick(unsigned *new, \nunsigned *old, unsigned *instruction) { int i; new[hlAXSTAGES-2] = instruction[MAXSTAGES-1] ; /x optimized \nfirst iteration x/ for (i = MAXSTAGES -2; i > O; i--) { unsigned int a = old[i], b = instruction[i]; \nif (a &#38; b) /* if overlap . . . */ return O; /* . . . then report hazard */ new[i-1] = a I b; /* otherwise \ncombine vectors and shift */ 3 if (old[O] &#38; instruction[O]) /* optimized last iteration */ return \nO; return 1; } Figure5: Optimized Code to Interpret Resource Vectors The automata are much faster than \ntheir pre\u00addecessors. A typical implementation of fixed\u00adlength resource vectors accepts three resource \nvectors: one for the instruction, another for the current composite, and an empty one for the new composite. \nAn optimized implemen\u00adtation is given in Figure 5. For the MIPS R3000/R3010 pipeline, which requires \n37-stage vectors, this code takes 329 cycles to detect a structural hazard onaMIPSR3000, a.ssumingno \ncache misses. A more sophisticated implemen\u00adtationmight implement variable-length resource vectors, but \neven it can t average better than a fixed-length implementation of 5-stage vectors, which takes 50 cycles. \nAnalogous code using our automaton replaces the resource vectors with integers andthefunc\u00adtion with an \nexpression: newstate = dfa[oldstate] [instruction] ; It takes 9 cycles, and schedulers that test several \ninstructions before picking the best can amortize the cost of one subscript calculation with /* done \nonce */ t emp = dfa[oldstate]; ... I* done repeatedly *I newstate temp [instruction] ; and average \nas few as 4 cycles per test. References [1] [2] [3] [4] [5] Jean-Loup Baer. Computer Systems Archi\u00adtectwe. \nComputer Science Press, 1980. Thomas Ball and James R. Larus. Opti\u00admally profiling and tracing programs. \nCon\u00adference Record of the Nineteenth Annual ACM Symposium on Principles of Pro\u00adgramming Languages, pages \n59 70, January 1992. David G. Bradlee, Robert R. Henry, and Susan J. Eggers. The Marion system for \nretargetable instruction scheduling. Pro\u00adceedings of the SIGPLAN 91 Conference on Programming Language \nDesign and Imple\u00admentation, SIGPLAN Notices, 26(6) :229 240, June 1991. David Gordon Bradlee. Retargetable \nIn\u00adstruction Scheduling for Pipeline Proces\u00adsors. PhD thesis, University of Washington, 1991. Technical \nreport 91-08-07, Depart\u00adment of Computer Science and Engineering. Edward S. Davidson, Leonard E, Shar, \nA. Thampy Thomas, and Janak H. Pa\u00adtel. Effective control for pipelined comput\u00aders. In Spring COMPCON75 \nDigest of Pa\u00ad pem, pages 181 184. IEEE Computer Soci-pc+epc+ir rd+pc+epc alu mem r.d+wb. j al pc+epc+ir \nrd+pc+epc alu mem nb. ety, February 1975. j pc+epc+ir rd+pc+epc alu r-3 I+mem wb bgt zal [6] Kai Hwang \nand Faye A. Briggs. Com-pc+epc+ir rd alu C+S+MEM WB FWB. Ctcl pc+epc+ir rd alu MEM WB FWB+f _d. lWCI \n puter Architecture and Parallel Processing. pc+epc+ir rd alu lo+mem wb. mtloMcGraw-Hill, 1985. pc+epc+ir \nrd alu mem+hi wb. mthi pc+epc+ir rd alu mem r_d+wb. add [7] Kai Hwang, Shun-Piao Su, and Lionel M. pc+epc+ir \nrd alu mem ub. sb Ni. Vector computer architecture and pro\u00adpc+epc+ir rd alu r_t+mem wb. lW1 cessing techniques. \nIn Advances in Comput\u00adpc+epc+ir rd lo+alu+hi lo+hi li. mult ers, volume 20, pages 115 197. 1981. pc+epc+ir \nrd lo+alu+hi lo+hi-34. div [8] Gerry Kane and Joe Heinrich. MIPS RISC Architecture. Prentice Hall, 1992. \nB R4000 FPU Description [9] James Larus. Assemblers, linkers, and EX . mov. s spire. In David Patterson \nand John Hen-U S+A A+R R+S. add. s UAR. c.cond.s nessy, Computer Organization &#38; Design: u s. neg.s \nThe Hardware/Software Interface, Morgan UARSAR. Cvt.s.w Kaufman, 1993. USARS. cvt.d.w UARSSAR. Cvt.s.l \n[10]H. F. Li and R. Jayakumar. Systolic struc- UARS. cvt.d.l tures: A notion and characterization. Jour- \nUSAR. cvt.s.d nal of Parallel and Distributed Computing, UE+MMMNN+AR. mul.s pages 373-397, September \n1986. UE+MMMMNN+AR. mul. d U S+A S+R S D-13 D+A D+R D+A D+R A R. div.s [11] Thomas Miiller. Employing \nfinite automata U A R D-27 D+A D+R D+A D+R A R. div.d for resource scheduling. In The 26th An-U E A+R \n50 A R. sqrt.s nual ACM/IEEE International Symposium U E A+R I08 A R. sqrt. d on Microarchitecture, December \n1993. To appear. [12] C. V. Ramamoorthy and H. F. Li. Pipeline architect u re. ACM Computing Surveys, \n9(1):61-102, March 1977. [13] MIPS Computer Systems. RISCompiler Language Programmers Guide. MIPS Com\u00adputer \nSystems, 1988.  A R3000/R3010 Description pc+epc+lr RD ALU DIVA 15 ALU-3 MEM WB FWB+f .d. div.d pc+epc+lr \nRL) ALU DIV-8 ALU-3 MEkl WB FWB+f _d. div.s pc+epc+lr RD ALU MEM WB FWB+f .d. abs. d pc+epc+ir RD ALU \nMUL-2 ALU MEM WB FWB+f .d. mul.s pc+epc+ir RD ALU MUL 3 ALU MEM WB FWB+f _d. mul. d pc+epc+ir RD ALU-2 \nMEM WB FWB+f_d. add. d pc+epc+ir RD ALU-3 MEM WB FWB+f _d. cvt.d.w pc+epc+ir RD C+ALU MEM WB FWB. c.eq.d \n \n\t\t\t", "proc_id": "174675", "abstract": "", "authors": [{"name": "Todd A. Proebsting", "author_profile_id": "81100592757", "affiliation": "Department of Computer Science, University of Arizona, Tucson, AZ", "person_id": "P283229", "email_address": "", "orcid_id": ""}, {"name": "Christopher W. Fraser", "author_profile_id": "81100364566", "affiliation": "AT&T Bell Laboratories, 600 Mountain Avenue 2C-464, Murray Hill, NJ", "person_id": "P47620", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/174675.177904", "year": "1994", "article_id": "177904", "conference": "POPL", "title": "Detecting pipeline structural hazards quickly", "url": "http://dl.acm.org/citation.cfm?id=177904"}